From f1377703e1557e59b55112b789eeddf84decbf76 Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Thu, 13 Dec 2012 19:43:41 +0200
Subject: [PATCH 0387/1825] Armada300,tools: Align tools.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 71886b04f7f0610980fb31d059a488ddb6f8c833

Change-Id: Icac66edd2b2c11af27a9286acf42d91572253e9f
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 tools/Makefile                      |   18 +-
 tools/mv_eth_tool.c                 |  603 +++++++++++++++
 tools/mv_omci_tool.c                |  128 ++++
 tools/mv_set_coal.c                 |  226 ++++++
 tools/testusb.c                     |  429 +++++++++++
 tools/tsutool/Makefile              |   34 +
 tools/tsutool/mv_tsu_tool.c         |  769 +++++++++++++++++++
 tools/voice/silabs/Makefile         |   58 ++
 tools/voice/silabs/mv_voice_tool.c  | 1335 +++++++++++++++++++++++++++++++++
 tools/voice/silabs/mv_voice_tool.h  |   84 +++
 tools/voice/silabs/silabs_lib.c     |  442 +++++++++++
 tools/voice/silabs/silabs_lib.h     |   92 +++
 tools/voice/zarlink/Makefile        |   58 ++
 tools/voice/zarlink/mv_voice_tool.c | 1388 +++++++++++++++++++++++++++++++++++
 tools/voice/zarlink/mv_voice_tool.h |   84 +++
 tools/voice/zarlink/profile_79238.c | 1248 +++++++++++++++++++++++++++++++
 tools/voice/zarlink/profile_79238.h |   83 +++
 tools/voice/zarlink/profile_88266.c |  644 ++++++++++++++++
 tools/voice/zarlink/profile_88266.h |   98 +++
 tools/voice/zarlink/vpapi_lib.c     |  432 +++++++++++
 tools/voice/zarlink/vpapi_lib.h     |  102 +++
 21 files changed, 8352 insertions(+), 3 deletions(-)
 create mode 100644 tools/mv_eth_tool.c
 create mode 100644 tools/mv_omci_tool.c
 create mode 100644 tools/mv_set_coal.c
 create mode 100644 tools/testusb.c
 create mode 100644 tools/tsutool/Makefile
 create mode 100644 tools/tsutool/mv_tsu_tool.c
 create mode 100644 tools/voice/silabs/Makefile
 create mode 100644 tools/voice/silabs/mv_voice_tool.c
 create mode 100644 tools/voice/silabs/mv_voice_tool.h
 create mode 100644 tools/voice/silabs/silabs_lib.c
 create mode 100644 tools/voice/silabs/silabs_lib.h
 create mode 100644 tools/voice/zarlink/Makefile
 create mode 100644 tools/voice/zarlink/mv_voice_tool.c
 create mode 100644 tools/voice/zarlink/mv_voice_tool.h
 create mode 100644 tools/voice/zarlink/profile_79238.c
 create mode 100644 tools/voice/zarlink/profile_79238.h
 create mode 100644 tools/voice/zarlink/profile_88266.c
 create mode 100644 tools/voice/zarlink/profile_88266.h
 create mode 100644 tools/voice/zarlink/vpapi_lib.c
 create mode 100644 tools/voice/zarlink/vpapi_lib.h

diff --git a/tools/Makefile b/tools/Makefile
index 5cca5b7..ab2a051 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -20,6 +20,10 @@ SUBDIRS +=
 
 TARGETS=mv_shell
 
+ifeq ($(CONFIG_MV_GATEWAY),y)
+CFLAGS += -DCONFIG_MV_GATEWAY
+endif
+
 ifeq ($(CONFIG_MV_ETHERNET),y)
 CFLAGS += -DCONFIG_MV_ETHERNET
 endif
@@ -32,8 +36,12 @@ endif
 ifeq ($(CONFIG_MV_ETH_LEGACY),y)
 TARGETS+=mv_eth_tool
 CFLAGS += -DCONFIG_MV_ETH_LEGACY
+ifeq ($(CONFIG_PLAT_ORION),y)
+CFLAGS += -I$(KSRC)/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/
+else
 CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_network/mv_ethernet/
 endif
+endif
 
 ifeq ($(CONFIG_MV_CPU_PERF_CNTRS),y)
 CFLAGS += -DCONFIG_MV_CPU_PERF_CNTRS
@@ -41,12 +49,16 @@ endif
 
 ifeq ($(CONFIG_MV_CESA),y)
 TARGETS += mv_cesa_tool
+ifeq ($(CONFIG_PLAT_ORION),y)
+CFLAGS  += -I$(KSRC)/arch/arm/plat-orion/mv_drivers_lsp/mv_cesa/
+else
 CFLAGS  += -I$(KSRC)/arch/arm/plat-armada/mv_drivers_lsp/mv_cesa/
 endif
+endif
 
-#ifeq ($(CONFIG_MV_INCLUDE_USB),y)
-#TARGETS += testusb
-#endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+TARGETS += testusb
+endif
 
 ifeq ($(CONFIG_MV_PHONE),y)
 SUBDIRS+=voice
diff --git a/tools/mv_eth_tool.c b/tools/mv_eth_tool.c
new file mode 100644
index 0000000..3fdfc64
--- /dev/null
+++ b/tools/mv_eth_tool.c
@@ -0,0 +1,603 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "mv_eth_proc.h"
+
+extern char **environ; /* all environments */
+
+static unsigned int port = 0, tag = 0, q = 0, weight = 0, status = 0, mac[6] = {0,};
+static unsigned int policy =0, command = 0, packet = 0;
+static unsigned int value = 0;
+static unsigned int inport, outport, dip, sip, da[6] = {0, }, sa[6] = {0, };
+static unsigned int db_type = 0;
+static char* name = NULL;
+
+void show_usage(int badarg)
+{
+        fprintf(stderr,
+	"Usage: 										\n"
+	" mv_eth_tool -h		       Display this help				\n"
+	"                                                                                       \n"
+	" --- Global commands ---								\n"
+        " mv_eth_tool -txdone <quota>          Set threshold to start tx_done operations       	\n"
+	" mv_eth_tool -reuse   <0|1>           SKB reuse support:   0 - Disable, 1 - Enable    	\n"
+        " mv_eth_tool -recycle <0|1>           SKB recycle support: 0 - Disable, 1 - Enable     \n"
+        "                                                                                       \n"
+    " --- NetDev commands ---                                                               \n"
+    " mv_eth_tool -netdev_sts <name>       Print network device status                      \n"
+    " mv_eth_tool -port_add <name> <port>  Map switch port to one of network devices        \n"
+    " mv_eth_tool -port_del <name> <port>  Unmap switch port from network device            \n"
+    " --- vtu commands ---                                                                  \n"
+    " mv_eth_tool -vtu_add <port> <tag>    Add vlan tag to port                             \n"
+    " mv_eth_tool -vtu_del <port> <tag>    Remove vlan tag from port                        \n"
+	" --- Port commands ---                                                                 \n"
+        " mv_eth_tool -rxcoal <port> <usec>    Set RX interrupt coalescing value               	\n"
+        " mv_eth_tool -txcoal <port> <usec>    Set TX interrupt coalescing value               	\n"
+	" mv_eth_tool -txen   <port> <deep>    Set deep of lookup for TX enable race.          	\n"
+        "                                      0 - means disable.                              	\n"
+	" mv_eth_tool -ejp    <port> <0|1>     Set EJP mode: 0 - Disable, 1 - Enable           	\n"
+	" mv_eth_tool -tx_noq <idx> <0|1>      Set queuing mode: 0 - Disable, 1 - Enable        \n"
+	" mv_eth_tool -lro    <port> <0|1>     Set LRO mode: 0 - Disable, 1 - Enable           	\n"
+	" mv_eth_tool -lro_desc <port> <value> Set LRO max concurrent sessions			\n"
+	"                                                                                       \n"
+	" --- Port/Queue commands ---                                                           \n"
+	" mv_eth_tool -tos <port> <rxq> <tos>  Map TOS field to RX queue number                 \n" 
+	"                                                                                       \n"
+	" mv_eth_tool -srq <port> <rxq> <bpdu|arp|tcp|udp>                                     	\n"
+        "                                      Set RX queue number for different packet types. 	\n"
+	"                                      rxq==8 means no special treatment.		\n"
+	"		                       rxq==8 for Arp packets means drop.      		\n"
+	"                                                                                       \n"
+	" mv_eth_tool -sq <port> <rxq> <%%2x:%%2x:%%2x:%%2x:%%2x:%%2x> 				\n"
+	"                                      Set RX queue number for a Multicast MAC         	\n"
+	"                                      rxq==8 indicates delete entry.		        \n"
+        " mv_eth_tool -srp <port> <WRR|FIXED>  Set the Rx Policy to WRR or Fixed 		\n"
+	"											\n"
+	" mv_eth_tool -St <option> <port>			       		                \n"
+	"   Display different status information of the port through the kernel printk.		\n"
+	"   OPTIONS:										\n"
+	"   p                                   Display General port information.		\n"
+        "   mac                                 Display MAC addresses information               \n"
+	"   q   <0..7>                          Display specific q information.			\n"
+	"   rxp                                 Display Rx Policy information.			\n"
+	"   txp                                 Display Tx Policy information.			\n"
+	"   cntrs                               Display the HW MIB counters			\n"
+	"   regs                                Display a dump of the giga registers		\n"
+	"   stats                               Display port statistics information. 		\n"
+	"   tos                                 Display port TOS to RXQ mapping                 \n"
+	"   switch                              Display switch statistics                 	\n"
+        "\n"	
+        );
+        exit(badarg);
+}
+
+static void parse_pt(char *src)
+{
+        if (!strcmp(src, "bpdu"))
+        	packet = PT_BPDU;
+	else if(!strcmp(src, "arp"))
+        	packet = PT_ARP;
+	else if(!strcmp(src, "tcp"))
+        	packet = PT_TCP;
+	else if(!strcmp(src, "udp"))
+        	packet = PT_UDP;
+	else {
+		fprintf(stderr, "Illegall packet type, packet type should be bpdu/arp/tcp/udp. \n");	
+                exit(-1);
+        }
+        return;
+}
+
+static void parse_db_name(char *src)
+{
+	if (!strcmp(src, "routing") || !strcmp(src, "route"))
+		db_type = DB_ROUTING;
+	else if (!strcmp(src, "nat"))
+		db_type = DB_NAT;
+	else if (!strcmp(src, "fdb") || !strcmp(src, "bridge"))
+		db_type = DB_FDB;
+	else if (!strcmp(src, "ppp"))
+		db_type = DB_PPP;
+	else if (!strcmp(src, "sec"))
+		db_type = DB_SEC;
+	else {
+		fprintf(stderr, "Illegall DB name, expected routing|nat|bridge|ppp|sec. \n");
+		exit(-1);
+	}
+	return;
+}
+
+static void parse_port(char *src)
+{
+	int count;
+
+        count = sscanf(src, "%x",&port);
+
+        if (count != 1)  {
+		fprintf(stderr, "Port parsing error: count=%d\n", count);	
+                exit(-1);
+        }
+        return;
+}
+
+static void parse_tag(char* src)
+{
+    int count;
+
+    count = sscanf(src, "%d",&tag);
+
+    if (count != 1)  {
+        fprintf(stderr, "Port parsing error: count=%d\n", count);	
+        exit(-1);
+    }
+    return;
+}
+
+static void parse_q(char *src)
+{
+	int count;
+
+        count = sscanf(src, "%x",&q);
+
+        if (count != 1) {
+		fprintf(stderr, "Queue parsing error: count=%d\n", count);	
+                exit(-1);
+        }
+        return;
+}
+
+static void parse_policy(char *src)
+{
+
+        if (!strcmp(src, "WRR"))
+        	policy = WRR;
+	else if (!strcmp(src, "FIXED"))
+        	policy = FIXED;
+	else {
+		fprintf(stderr, "Illegall policy, policy can be WRR or Fixed.\n");	
+                exit(-1);
+        }
+        return;
+}
+
+static void parse_status(char *src)
+{
+    	if (!strcmp(src, "p")) {
+      		status = STS_PORT;
+      	}
+        else if (!strcmp(src, "mac")) {
+                status = STS_PORT_MAC;
+        }
+     	else if(!strcmp(src, "q")) {
+       		status = STS_PORT_Q;
+     	}
+   	else if(!strcmp(src, "rxp")) {
+          	status = STS_PORT_RXP;
+      	}
+     	else if(!strcmp(src, "txp")) {
+           	status = STS_PORT_TXP;
+      	}
+        else if(!strcmp(src, "cntrs")) {
+                status = STS_PORT_MIB;
+        }
+        else if(!strcmp(src, "regs")) {
+                status = STS_PORT_REGS;
+        }
+      	else if(!strcmp(src, "stats")) {
+             	status = STS_PORT_STATS;
+        }
+        else if(!strcmp(src, "tos")) {
+                status = STS_PORT_TOS_MAP;
+        }
+        else if(!strcmp(src, "switch")) {
+                status = STS_SWITCH_STATS;
+        }
+        else {
+                fprintf(stderr, "Illegall status %d.\n");
+                exit(-1);
+        }
+        return;
+}
+static void parse_dec_val(char *src, unsigned int* val_ptr)
+{
+    int i, count;
+
+    count = sscanf(src, "%d", val_ptr);
+    if(count != 1) {
+        fprintf(stderr, "Illegall value - should be decimal.\n");
+        exit(-1);
+    }
+    return;
+}
+
+static void parse_hex_val(char *src, unsigned int* hex_val_ptr)
+{
+    int i, count;
+
+    count = sscanf(src, "%x", hex_val_ptr);
+    if(count != 1) {
+        fprintf(stderr, "Illegall value - should be hex.\n");
+        exit(-1);
+    }
+    return;
+}
+
+static int parse_mac(char *src, unsigned int macaddr[])
+{
+        int count;
+        int i;
+        int buf[6];
+
+        count = sscanf(src, "%2x:%2x:%2x:%2x:%2x:%2x",
+                &buf[0], &buf[1], &buf[2], &buf[3], &buf[4], &buf[5]);
+
+        if (count != 6) {
+		fprintf(stderr, "MAC parsing error: Expected %%2x:%%2x:%%2x:%%2x:%%2x:%%2x.\n");
+                exit(-1);
+        }
+
+        for (i = 0; i < count; i++) {
+                macaddr[i] = buf[i];
+        }
+        return 0;
+}
+
+static int parse_ip(char *src, unsigned int* ip)
+{
+    int count, i;
+    int buf[4];
+
+    count = sscanf(src, "%d.%d.%d.%d",
+                &buf[0], &buf[1], &buf[2], &buf[3]);
+
+    if (count != 4) {
+        fprintf(stderr, "Illegall IP address (should be %%d.%%d.%%d.%%d)\n");
+        exit(-1);
+    }
+    *ip = (((buf[0] & 0xFF) << 24) | ((buf[1] & 0xFF) << 16) |
+           ((buf[2] & 0xFF) << 8) | ((buf[3] & 0xFF) << 0));
+    return 0;
+}
+
+static void parse_cmdline(int argc, char **argp)
+{
+	unsigned int i = 1;
+
+	if(argc < 2) {
+		show_usage(1);
+	}
+
+	if (!strcmp(argp[i], "-h")) {
+		show_usage(0);
+	}
+	else if (!strcmp(argp[i], "-srq")) {
+		command = COM_SRQ;
+		i++;	
+		if(argc != 5)
+			show_usage(1); 
+		parse_port(argp[i++]);
+		parse_q(argp[i++]);
+		parse_pt(argp[i++]);
+	}
+	else if (!strcmp(argp[i], "-sq")) {
+		command = COM_SQ;
+		i++;
+		if(argc != 6)
+			show_usage(1); 
+		parse_port(argp[i++]);
+		parse_q(argp[i++]);
+		parse_mac(argp[i++], mac);
+	}
+	else if (!strcmp(argp[i], "-srp")) {
+		command = COM_SRP;
+		i++;
+		if(argc != 4)
+			show_usage(1); 
+		parse_port(argp[i++]);
+		parse_policy(argp[i++]);
+	}
+	else if (!strcmp(argp[i], "-srqw")) {
+		command = COM_SRQW;
+		i++;
+		if(argc != 5)
+			show_usage(1); 
+		parse_port(argp[i++]);
+		parse_q(argp[i++]);
+		parse_hex_val(argp[i++], &weight);
+	}
+    	else if (!strcmp(argp[i], "-stp")) {
+        	command = COM_STP;
+        	i++;
+        	if(argc != 6)
+            		show_usage(1);
+		parse_port(argp[i++]);
+        	parse_q(argp[i++]);
+		parse_hex_val(argp[i++], &weight);
+		parse_policy(argp[i++]);
+    	}
+    	else if (!strcmp(argp[i], "-fprs")) {
+        	command = COM_IP_RULE_SET;
+        	i++;
+        	if(argc != 8)
+            		show_usage(1);
+		parse_dec_val(argp[i++], &inport);
+        	parse_dec_val(argp[i++], &outport);
+		parse_ip(argp[i++], &dip);
+		parse_ip(argp[i++], &sip);
+        	parse_mac(argp[i++], da);
+		parse_mac(argp[i++], sa);
+    	}
+	else if (!strcmp(argp[i], "-fprd")) {
+		command = COM_IP_RULE_DEL;
+		i++;
+		if(argc != 4)
+			show_usage(1);
+		parse_ip(argp[i++], &dip);
+		parse_ip(argp[i++], &sip);
+	}
+	else if (!strcmp(argp[i], "-txdone")) {
+        	command = COM_TXDONE_Q;
+        	i++;
+		if(argc != 3)
+			show_usage(1);
+        	parse_dec_val(argp[i++], &value);
+    	}
+    	else if (!strcmp(argp[i], "-txen")) {
+                command = COM_TX_EN;
+                i++;
+		if(argc != 4)
+			show_usage(1);
+		parse_port(argp[i++]);
+                parse_dec_val(argp[i++], &value);
+        }
+	else if (!strcmp(argp[i], "-lro")) {
+		command = COM_LRO;
+		i++;
+		if(argc != 4)
+			show_usage(1);
+		parse_port(argp[i++]);
+		parse_dec_val(argp[i++], &value);
+	}
+	else if (!strcmp(argp[i], "-lro_desc")) {
+		command = COM_LRO_DESC;
+		i++;
+		if(argc != 4)
+			show_usage(1);
+		parse_port(argp[i++]);
+		parse_dec_val(argp[i++], &value);
+	}
+        else if (!strcmp(argp[i], "-reuse")) {
+                command = COM_SKB_REUSE;
+                i++;
+		if(argc != 3)
+			show_usage(1);
+                parse_dec_val(argp[i++], &value);
+        }
+        else if (!strcmp(argp[i], "-recycle")) {
+                command = COM_SKB_RECYCLE;
+                i++;
+                if(argc != 3)
+                        show_usage(1);
+                parse_dec_val(argp[i++], &value);
+        }
+	else if (!strcmp(argp[i], "-rxcoal")) {
+        	command = COM_RX_COAL;
+        	i++;
+		if(argc != 4)
+			show_usage(1);
+        	parse_port(argp[i++]);
+        	parse_dec_val(argp[i++], &value);
+    	}
+    	else if (!strcmp(argp[i], "-txcoal")) {
+        	command = COM_TX_COAL;
+        	i++;
+		if(argc != 4)
+			show_usage(1);
+        	parse_port(argp[i++]);
+        	parse_dec_val(argp[i++], &value);
+    	}
+        else if (!strcmp(argp[i], "-ejp")) {
+                command = COM_EJP_MODE;
+                i++;
+                if(argc != 4)
+                        show_usage(1);
+                parse_port(argp[i++]);
+                parse_dec_val(argp[i++], &value);
+	}
+        else if (!strcmp(argp[i], "-tos")) {
+                command = COM_TOS_MAP;
+                i++;
+                if(argc != 5)
+                        show_usage(1);
+                parse_port(argp[i++]);
+		parse_q(argp[i++]);
+                parse_hex_val(argp[i++], &value);
+        }
+		else if (!strcmp(argp[i], "-tx_noq")) {
+				command = COM_TX_NOQUEUE;
+				i++;
+				if(argc != 4)
+						show_usage(1);
+				parse_port(argp[i++]);
+				parse_dec_val(argp[i++], &value);
+	}
+    else if (!strcmp(argp[i], "-netdev_sts")) {
+        command = COM_NETDEV_STS;
+        i++;
+        if(argc != 3)
+            show_usage(1);
+        name = argp[i++];
+    }
+    else if (!strcmp(argp[i], "-port_add")) {
+        command = COM_NETDEV_PORT_ADD;
+        i++;
+        if(argc != 4)
+            show_usage(1);
+        name = argp[i++];
+        parse_dec_val(argp[i++], &port);
+    }
+    else if (!strcmp(argp[i], "-port_del")) {
+        command = COM_NETDEV_PORT_DEL;
+        i++;
+        if(argc != 4)
+            show_usage(1);
+        name = argp[i++];
+        parse_dec_val(argp[i++], &port);
+    }
+    else if (!strcmp(argp[i], "-vtu_add")) {
+        command = COM_NETDEV_VTU_ADD;
+        i++;
+        if(argc != 4)
+            show_usage(1);
+        parse_port(argp[i++]);
+		parse_tag(argp[i++]);
+    }
+    else if (!strcmp(argp[i], "-vtu_del")) {
+        command = COM_NETDEV_VTU_DEL;
+        i++;
+        if(argc != 4)
+            show_usage(1);
+        parse_port(argp[i++]);
+		parse_tag(argp[i++]);				
+    }
+    	else if (!strcmp(argp[i], "-St")) {
+        	command = COM_STS;
+        	i++;
+		if(argc < 4)
+			show_usage(1);
+		parse_status(argp[i++]);
+		if( status == STS_PORT_Q ) {
+            		if(argc != 5)
+                		show_usage(1);
+               		parse_q(argp[i++]);
+	    	}
+            	else if(argc != 4)
+                	show_usage(1);
+	
+		parse_port(argp[i++]);
+        }	
+	else {
+		show_usage(i++);
+	}
+}
+
+static int procit(void)
+{
+  	FILE *mvethproc;
+  	mvethproc = fopen(FILE_PATH FILE_NAME, "w");
+  	if (!mvethproc) {
+    		printf ("Eror opening file %s/%s\n",FILE_PATH,FILE_NAME);
+    		exit(-1);
+  	}
+
+	switch (command) {
+		case COM_TXDONE_Q:
+		case COM_SKB_REUSE:
+	    case COM_SKB_RECYCLE:
+			fprintf (mvethproc, ETH_CMD_STRING, ETH_PRINTF_LIST);
+			break;			
+		case COM_RX_COAL:
+		case COM_TX_COAL:
+		case COM_TX_EN:
+		case COM_EJP_MODE:
+		case COM_TX_NOQUEUE:
+		case COM_LRO:
+		case COM_LRO_DESC:
+			fprintf (mvethproc, PORT_CMD_STRING, PORT_PRINTF_LIST);
+			break;
+		case COM_TOS_MAP:
+			fprintf (mvethproc, QUEUE_CMD_STRING, QUEUE_PRINTF_LIST);
+			break;
+		case COM_IP_RULE_SET:
+			fprintf(mvethproc, IP_RULE_STRING, IP_RULE_PRINT_LIST);
+			break;
+		case COM_IP_RULE_DEL:
+			fprintf(mvethproc, IP_RULE_DEL_STRING, IP_RULE_DEL_PRINT_LIST);
+			break;
+		case COM_NETDEV_PORT_ADD:
+		case COM_NETDEV_PORT_DEL:
+		case COM_NETDEV_STS:
+			fprintf(mvethproc, NETDEV_CMD_STRING, NETDEV_PRINTF_LIST);
+			break;
+		case COM_NETDEV_VTU_ADD:
+		case COM_NETDEV_VTU_DEL:
+			fprintf(mvethproc, NETDEV_VTU_CMD_STRING, NETDEV_VTU_PRINTF_LIST);			
+			break;
+		default:
+			fprintf (mvethproc, PROC_STRING, PROC_PRINT_LIST);
+			break;
+	}
+
+	fclose (mvethproc);
+	return 0;
+}
+
+int main(int argc, char **argp, char **envp)
+{
+        parse_cmdline(argc, argp);
+        return procit();
+}
+
diff --git a/tools/mv_omci_tool.c b/tools/mv_omci_tool.c
new file mode 100644
index 0000000..543bbda
--- /dev/null
+++ b/tools/mv_omci_tool.c
@@ -0,0 +1,128 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <sys/socket.h>
+#include <linux/if_packet.h>
+#include <linux/if_ether.h> 
+
+int main(int argc, char* argv[])
+{
+	char buf[1024];
+	int sz, i;
+	int sk, proto = 0x9000;
+	struct sockaddr_ll socket_address; 
+
+    	if(argc >= 2) 
+       		proto = strtol(argv[1], (char **)NULL, 16);
+
+   	printf("Open Raw socket for protocol 0x%x\n", proto);
+
+    	sk = socket(AF_PACKET, SOCK_RAW, htons(proto)); 
+    	if (sk < 0) {
+		perror("open:");
+		goto out;
+    	}
+
+    do {
+
+        sz = recv(sk, buf, 1024, 0);
+        if (sz == -1) {
+            perror("recv ERROR");
+            goto out;
+        }
+        printf("read %d bytes\n", sz);
+        i = 0;
+/*
+        while(i < sz) {
+            printf("%02x ", buf[i]);
+            i++;
+            if( (i % 32) == 0)
+		printf("\n");
+        }
+	printf("\n");
+*/
+        /* Send data back */
+	socket_address.sll_family = PF_PACKET;
+	socket_address.sll_protocol = htons(proto);
+	socket_address.sll_ifindex = 2; 
+	socket_address.sll_pkttype = PACKET_OTHERHOST; 
+ 
+        sz = sendto(sk, buf, sz, 0, 
+		    (struct sockaddr*)&socket_address, sizeof(socket_address)); 
+
+        if (sz == -1) {
+            perror("send ERROR");
+            goto out;
+        }
+        printf("send %d bytes\n", sz);
+    } while (1);
+
+out:
+    if (sk > 0)
+	close(sk);
+
+    return 0;
+}
+
diff --git a/tools/mv_set_coal.c b/tools/mv_set_coal.c
new file mode 100644
index 0000000..68b6fb1
--- /dev/null
+++ b/tools/mv_set_coal.c
@@ -0,0 +1,226 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sys/mman.h>
+#include <paths.h>
+#include <stdlib.h>
+
+#include <sys/sysctl.h>
+#include <sys/time.h>
+
+#define ETH_SDMA_CONFIG_REG(port)           (MV_ETH_REG_BASE(port) + 0x41c)
+#define MV_ETH_REG_BASE(port)      	(((port) == 0) ? 0x72000 : 0x82000)
+#define ETH_RX_INTR_COAL_OFFSET             7
+#define ETH_RX_INTR_COAL_ALL_MASK           (0x3fff<<ETH_RX_INTR_COAL_OFFSET)
+#define ETH_RX_INTR_COAL_MASK(value)        (((value)<<ETH_RX_INTR_COAL_OFFSET)  \
+                                             & ETH_RX_INTR_COAL_ALL_MASK)
+
+#define ETH_TX_FIFO_URGENT_THRESH_REG(port) (MV_ETH_REG_BASE(port) + 0x474)
+#define ETH_TX_INTR_COAL_OFFSET             4
+
+
+mv_reg_read(unsigned int reg)
+{
+    unsigned int value;
+    FILE *resource_dump;
+
+    resource_dump = fopen ("/proc/resource_dump" , "w");
+    if (!resource_dump) {
+      printf ("Eror opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fprintf (resource_dump,"register  r %08x",reg);
+    fclose (resource_dump);
+    resource_dump = fopen ("/proc/resource_dump" , "r");
+    if (!resource_dump) {
+      printf ("Eror opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fscanf (resource_dump , "%x" , &value);
+    fclose (resource_dump);
+
+    return value;
+}
+
+void
+mv_reg_write(unsigned int reg, unsigned int value)
+{
+    FILE *resource_dump;
+
+    resource_dump = fopen ("/proc/resource_dump" , "w");
+    if (!resource_dump) {
+      printf ("Eror opening file /proc/resource_dump\n");
+      exit(-1);
+    }
+    fprintf (resource_dump,"register  w %08x %08x",reg,value);
+    fclose (resource_dump);
+    return;
+}
+
+/*******************************************************************************
+* mvEthRxCoalSet  - Sets coalescing interrupt mechanism on RX path
+*
+* DESCRIPTION:
+*       This routine sets the RX coalescing interrupt mechanism parameter.
+*       This parameter is a timeout counter, that counts in 64 tClk
+*       chunks, that when timeout event occurs a maskable interrupt occurs.
+*       The parameter is calculated using the tCLK frequency of the
+*       MV-64xxx chip, and the required number is in micro seconds.
+*
+* INPUT:
+*       MV_U32          uSec        - Number of micro seconds between 
+*                                   RX interrupts
+*
+* RETURN:
+*       None.
+*
+* COMMENT:     
+*   1 sec           - TCLK_RATE clocks
+*   1 uSec          - TCLK_RATE / 1,000,000 clocks
+*
+*   Register Value for N micro seconds -  ((N * ( (TCLK_RATE / 1,000,000)) / 64)
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+unsigned int    mvEthRxCoalSet (unsigned int uSec) 
+{ 
+    unsigned int	  port = 0;
+    unsigned int 	  Tclk = 166000000;
+    unsigned int          coal = ((uSec * ( Tclk / 1000000)) / 64);
+    unsigned int          portSdmaCfgReg;
+
+    portSdmaCfgReg =  mv_reg_read(ETH_SDMA_CONFIG_REG(port));
+    portSdmaCfgReg &= ~ETH_RX_INTR_COAL_ALL_MASK;
+    portSdmaCfgReg |= (ETH_RX_INTR_COAL_MASK(coal));
+    mv_reg_write(ETH_SDMA_CONFIG_REG(port), portSdmaCfgReg);
+    return coal;
+}
+
+/*******************************************************************************
+* mvEthTxCoalSet - Sets coalescing interrupt mechanism on TX path
+*
+* DESCRIPTION:
+*       This routine sets the TX coalescing interrupt mechanism parameter.
+*       This parameter is a timeout counter, that counts in 64 tClk
+*       chunks, that when timeout event occurs a maskable interrupt
+*       occurs.
+*       The parameter is calculated using the tCLK frequency of the
+*       MV-64xxx chip, and the required number is in micro seconds.
+*
+* INPUT:
+*       MV_U32          uSec        - Number of micro seconds between 
+*                                   RX interrupts
+*
+* RETURN:
+*       None.
+*
+* COMMENT:     
+*   1 sec           - TCLK_RATE clocks
+*   1 uSec          - TCLK_RATE / 1,000,000 clocks
+*
+*   Register Value for N micro seconds -  ((N * ( (TCLK_RATE / 1,000,000)) / 64)
+*
+*******************************************************************************/
+unsigned int    mvEthTxCoalSet(unsigned int uSec) 
+{
+    unsigned int          port = 0;
+    unsigned int          Tclk = 166000000;
+    unsigned int          coal = ((uSec * (Tclk / 1000000)) / 64);
+
+    /* Set TX Coalescing mechanism */
+    mv_reg_write (ETH_TX_FIFO_URGENT_THRESH_REG(port), 
+                  (coal << ETH_TX_INTR_COAL_OFFSET));
+    return coal;
+}
+
+int
+main(int argc, char **argv)
+{
+        unsigned int direct,usec;
+
+        if (argc == 3) {
+                sscanf(argv[1], "%x", &direct);
+                sscanf(argv[2], "%x", &usec);
+        }else{ printf ("Usage: mv_set_coal <direction 0-Rx 1-Tx> <coal in micro sec>\n");
+                return 0;
+        }
+
+        if(direct == 0)
+		mvEthRxCoalSet(usec);		
+	else
+		mvEthTxCoalSet(usec);
+
+        return 1;
+}
+
diff --git a/tools/testusb.c b/tools/testusb.c
new file mode 100644
index 0000000..9dbbd91
--- /dev/null
+++ b/tools/testusb.c
@@ -0,0 +1,429 @@
+/* $(CROSS_COMPILE)cc -Wall -g -lpthread -o testusb testusb.c */
+
+/*
+ * Copyright (c) 2002 by David Brownell
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define __user
+
+#include <stdio.h>
+#include <string.h>
+#include <ftw.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <linux/usbdevice_fs.h>
+
+/*-------------------------------------------------------------------------*/
+
+#define	TEST_CASES	30
+
+// FIXME make these public somewhere; usbdevfs.h?
+
+struct usbtest_param {
+	// inputs
+	unsigned		test_num;	/* 0..(TEST_CASES-1) */
+	unsigned		iterations;
+	unsigned		length;
+	unsigned		vary;
+	unsigned		sglen;
+
+	// outputs
+	struct timeval		duration;
+};
+#define USBTEST_REQUEST	_IOWR('U', 100, struct usbtest_param)
+
+/*-------------------------------------------------------------------------*/
+
+/* #include <linux/usb_ch9.h> */
+
+struct usb_device_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__u16 idVendor;
+	__u16 idProduct;
+	__u16 bcdDevice;
+	__u8  iManufacturer;
+	__u8  iProduct;
+	__u8  iSerialNumber;
+	__u8  bNumConfigurations;
+} __attribute__ ((packed));
+
+enum usb_device_speed {
+	USB_SPEED_UNKNOWN = 0,			/* enumerating */
+	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
+	USB_SPEED_HIGH				/* usb 2.0 */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static char *speed (enum usb_device_speed s)
+{
+	switch (s) {
+	case USB_SPEED_UNKNOWN:	return "unknown";
+	case USB_SPEED_LOW:	return "low";
+	case USB_SPEED_FULL:	return "full";
+	case USB_SPEED_HIGH:	return "high";
+	default:		return "??";
+	}
+}
+
+struct testdev {
+	struct testdev		*next;
+	char			*name;
+	pthread_t		thread;
+	enum usb_device_speed	speed;
+	unsigned		ifnum : 8;
+	unsigned		forever : 1;
+	int			test;
+
+	struct usbtest_param	param;
+};
+static struct testdev		*testdevs;
+
+static int is_testdev (struct usb_device_descriptor *dev)
+{
+	/* FX2 with (tweaked) bulksrc firmware */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x1002)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* devices that start up using the EZ-USB default device and
+	 * which we can use after loading simple firmware.  hotplug
+	 * can fxload it, and then run this test driver.
+	 *
+	 * we return false positives in two cases:
+	 * - the device has a "real" driver (maybe usb-serial) that
+	 *   renumerates.  the device should vanish quickly.
+	 * - the device doesn't have the test firmware installed.
+	 */
+
+	/* generic EZ-USB FX controller */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x2235)
+		return 1;
+
+	/* generic EZ-USB FX2 controller */
+	if (dev->idVendor == 0x04b4 && dev->idProduct == 0x8613)
+		return 1;
+
+	/* CY3671 development board with EZ-USB FX */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x0080)
+		return 1;
+
+	/* Keyspan 19Qi uses an21xx (original EZ-USB) */
+	if (dev->idVendor == 0x06cd && dev->idProduct == 0x010b)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* "gadget zero", Linux-USB test software */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a0)
+		return 1;
+
+	/* user mode subset of that */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a4)
+		return 1;
+
+	/* iso version of usermode code */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a3)
+		return 1;
+
+	/* some GPL'd test firmware uses these IDs */
+
+	if (dev->idVendor == 0xfff0 && dev->idProduct == 0xfff0)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* iBOT2 high speed webcam */
+	if (dev->idVendor == 0x0b62 && dev->idProduct == 0x0059)
+		return 1;
+
+	return 0;
+}
+
+static int find_testdev (const char *name, const struct stat *sb, int flag)
+{
+	int				fd;
+	struct usb_device_descriptor	dev;
+
+	if (flag != FTW_F)
+		return 0;
+	/* ignore /proc/bus/usb/{devices,drivers} */
+	if (strrchr (name, '/')[1] == 'd')
+		return 0;
+
+	if ((fd = open (name, O_RDONLY)) < 0) {
+		perror ("can't open dev file r/o");
+		return 0;
+	}
+	if (read (fd, &dev, sizeof dev) != sizeof dev)
+		fputs ("short devfile read!\n", stderr);
+	else if (is_testdev (&dev)) {
+		struct testdev		*entry;
+
+		if ((entry = calloc (1, sizeof *entry)) == 0) {
+			fputs ("no mem!\n", stderr);
+			goto done;
+		}
+		entry->name = strdup (name);
+		if (!entry->name) {
+			free (entry);
+			goto done;
+		}
+
+		// FIXME better to look at each interface and ask if it's
+		// bound to 'usbtest', rather than assume interface 0
+		entry->ifnum = 0;
+
+		// FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO
+		// so it tells about high speed etc
+
+		fprintf (stderr, "%s speed\t%s\n",
+				speed (entry->speed), entry->name);
+
+		entry->next = testdevs;
+		testdevs = entry;
+	}
+
+done:
+	close (fd);
+	return 0;
+}
+
+static int
+usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
+{
+	struct usbdevfs_ioctl	wrapper;
+
+	wrapper.ifno = ifno;
+	wrapper.ioctl_code = request;
+	wrapper.data = param;
+
+	return ioctl (fd, USBDEVFS_IOCTL, &wrapper);
+}
+
+static void *handle_testdev (void *arg)
+{
+	struct testdev		*dev = arg;
+	int			fd, i;
+	int			status;
+
+	if ((fd = open (dev->name, O_RDWR)) < 0) {
+		perror ("can't open dev file r/w");
+		return 0;
+	}
+
+restart:
+	for (i = 0; i < TEST_CASES; i++) {
+		if (dev->test != -1 && dev->test != i)
+			continue;
+		dev->param.test_num = i;
+
+		status = usbdev_ioctl (fd, dev->ifnum,
+				USBTEST_REQUEST, &dev->param);
+		if (status < 0 && errno == EOPNOTSUPP)
+			continue;
+
+		/* FIXME need a "syslog it" option for background testing */
+
+		/* NOTE: each thread emits complete lines; no fragments! */
+		if (status < 0) {
+			char	buf [80];
+			int	err = errno;
+
+			if (strerror_r (errno, buf, sizeof buf)) {
+				snprintf (buf, sizeof buf, "error %d", err);
+				errno = err;
+			}
+			printf ("%s test %d --> %d (%s)\n",
+				dev->name, i, errno, buf);
+		} else
+			printf ("%s test %d, %4d.%.06d secs\n", dev->name, i,
+				(int) dev->param.duration.tv_sec,
+				(int) dev->param.duration.tv_usec);
+
+		fflush (stdout);
+	}
+	if (dev->forever)
+		goto restart;
+
+	close (fd);
+	return arg;
+}
+
+int main (int argc, char **argv)
+{
+	int			c;
+	struct testdev		*entry;
+	char			*device;
+	int			all = 0, forever = 0, not = 0;
+	int			test = -1 /* all */;
+	struct usbtest_param	param;
+
+	/* pick defaults that works with all speeds, without short packets.
+	 *
+	 * Best per-frame data rates:
+	 *     high speed, bulk       512 * 13 * 8 = 53248
+	 *                 interrupt 1024 *  3 * 8 = 24576
+	 *     full speed, bulk/intr   64 * 19     =  1216
+	 *                 interrupt   64 *  1     =    64
+	 *      low speed, interrupt    8 *  1     =     8
+	 */
+	param.iterations = 1000;
+	param.length = 512;
+	param.vary = 512;
+	param.sglen = 32;
+
+	/* for easy use when hotplugging */
+	device = getenv ("DEVICE");
+
+	while ((c = getopt (argc, argv, "D:ac:g:hns:t:v:")) != EOF)
+	switch (c) {
+	case 'D':	/* device, if only one */
+		device = optarg;
+		continue;
+	case 'a':	/* use all devices */
+		device = 0;
+		all = 1;
+		continue;
+	case 'c':	/* count iterations */
+		param.iterations = atoi (optarg);
+		if (param.iterations < 0)
+			goto usage;
+		continue;
+	case 'g':	/* scatter/gather entries */
+		param.sglen = atoi (optarg);
+		if (param.sglen < 0)
+			goto usage;
+		continue;
+	case 'l':	/* loop forever */
+		forever = 1;
+		continue;
+	case 'n':	/* no test running! */
+		not = 1;
+		continue;
+	case 's':	/* size of packet */
+		param.length = atoi (optarg);
+		if (param.length < 0)
+			goto usage;
+		continue;
+	case 't':	/* run just one test */
+		test = atoi (optarg);
+		if (test < 0)
+			goto usage;
+		continue;
+	case 'v':	/* vary packet size by ... */
+		param.vary = atoi (optarg);
+		if (param.vary < 0)
+			goto usage;
+		continue;
+	case '?':
+	case 'h':
+	default:
+usage:
+		fprintf (stderr, "usage: %s [-an] [-D dev]\n"
+			"\t[-c iterations]  [-t testnum]\n"
+			"\t[-s packetsize] [-g sglen] [-v vary]\n",
+			argv [0]);
+		return 1;
+	}
+	if (optind != argc)
+		goto usage;
+	if (!all && !device) {
+		fprintf (stderr, "must specify '-a' or '-D dev', "
+			"or DEVICE=/proc/bus/usb/BBB/DDD in env\n");
+		goto usage;
+	}
+
+	if ((c = open ("/proc/bus/usb/devices", O_RDONLY)) < 0) {
+		fputs ("usbfs files are missing\n", stderr);
+		return -1;
+	}
+
+	/* collect and list the test devices */
+	if (ftw ("/proc/bus/usb", find_testdev, 3) != 0) {
+		fputs ("ftw failed; is usbfs missing?\n", stderr);
+		return -1;
+	}
+
+	/* quit, run single test, or create test threads */
+	if (!testdevs && !device) {
+		fputs ("no test devices recognized\n", stderr);
+		return -1;
+	}
+	if (not)
+		return 0;
+	if (testdevs && testdevs->next == 0 && !device)
+		device = testdevs->name;
+	for (entry = testdevs; entry; entry = entry->next) {
+		int	status;
+
+		entry->param = param;
+		entry->forever = forever;
+		entry->test = test;
+
+		if (device) {
+			if (strcmp (entry->name, device))
+				continue;
+			return handle_testdev (entry) != entry;
+		}
+		status = pthread_create (&entry->thread, 0, handle_testdev, entry);
+		if (status) {
+			perror ("pthread_create");
+			continue;
+		}
+	}
+	if (device) {
+		struct testdev		dev;
+
+		/* kernel can recognize test devices we don't */
+		fprintf (stderr, "%s: %s may see only control tests\n",
+				argv [0], device);
+
+		memset (&dev, 0, sizeof dev);
+		dev.name = device;
+		dev.param = param;
+		dev.forever = forever;
+		dev.test = test;
+		return handle_testdev (&dev) != &dev;
+	}
+
+	/* wait for tests to complete */
+	for (entry = testdevs; entry; entry = entry->next) {
+		void	*retval;
+
+		if (pthread_join (entry->thread, &retval))
+			perror ("pthread_join");
+		/* testing errors discarded! */
+	}
+
+	return 0;
+}
diff --git a/tools/tsutool/Makefile b/tools/tsutool/Makefile
new file mode 100644
index 0000000..a7e58cd
--- /dev/null
+++ b/tools/tsutool/Makefile
@@ -0,0 +1,34 @@
+# kernel sources 
+srctree  := $(shell /bin/pwd)
+
+ifndef KSRC
+KSRC  := $(srctree)/../..
+endif
+
+include $(KSRC)/.config
+
+ifdef CONFIG_CPU_BIG_ENDIAN
+CC := armeb-mv5sft-linux-gnueabi-gcc
+LD := armeb-mv5sft-linux-gnueabi-ld
+CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
+else
+CC := arm-mv5sft-linux-gnueabi-gcc
+LD := arm-mv5sft-linux-gnueabi-ld
+endif
+CFLAGS  := $(EXTRA_CFLAGS) -static
+CFLAGS  += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tsu/
+
+SRCS := mv_tsu_tool.c
+OBJS := mv_tsu_tool.o
+
+TARGET := mvTsuTool
+
+default :
+	$(CC) $(CFLAGS) $(SRCS) -o $(TARGET)
+
+clean:
+	rm -f $(TARGET) $(OBJS)
+
+
+all : clean default
+
diff --git a/tools/tsutool/mv_tsu_tool.c b/tools/tsutool/mv_tsu_tool.c
new file mode 100644
index 0000000..7696e76
--- /dev/null
+++ b/tools/tsutool/mv_tsu_tool.c
@@ -0,0 +1,769 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <string.h>
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+
+#include "mv_tsu_ioctl.h"
+
+
+/*
+ Usage:
+	TsuTool <device> <read/write> <file> <options>
+*/
+
+
+#define BUFSIZE		2048
+#define TIMESTAMP_SIZE	4
+#define TSU_TOOL_STAMP	0x4D52564C
+#define FILE_HDR_SIZE	64
+
+#define READ 		1
+#define WRITE 		0
+
+char 			*util_name;
+char 			*data_buff = NULL;
+
+int 			g_is_read = -1;
+struct tsu_buff_info 	g_buff_info;
+int			g_raw_mode = 0;
+int			g_b2b_mode = 0;
+int			g_auto_ts_mode = 0;
+int 			retry_on_fail = 0;
+int 			g_data_blk_sz = 0;	// Actual block size <= g_buf_size
+int			g_buf_size =0;		// Buffer size
+unsigned int 		g_frequency = -1;
+FILE 			*g_stat_fd = NULL;
+int 			g_ts_data_size = 0;
+int 			g_tms_data_size = 0;
+
+void data_read(int dev_fd, FILE *file_fd);
+void data_write(int dev_fd, FILE *file_fd);
+int get_buff_info(int dev_fd);
+
+void usage(void)
+{
+	fprintf(stderr,"Usage: %s <device> <r/w> <file> <options>\n",util_name);
+	fprintf(stderr,"<file> can be set to stdout.\n");
+	fprintf(stderr,"Where <options> are:\n");
+	fprintf(stderr,"-r <tms file>: Write / Read data in raw TS format.\n"
+	       "               <tms file> is the file that holds / will hold the timestamp information.\n");
+	fprintf(stderr,"-f <freq>: The frequency at which data is to be received / transmitted.\n"
+	       "           In Rx mode, this is mandatory.\n"
+	       "           In Tx mode, this will override the file header frequency.\n");
+	fprintf(stderr,"-b: Transmit the TS file in Back-to-Back mode, no timestamps are needed.\n");
+	fprintf(stderr,"-a: Enable automatic timestamp mode, timestamps are generated by TS driver.\n");
+	exit(1);
+}
+
+/*
+ * Helper function for printing the TSU statistics.
+ */
+void tsu_print_stat(struct tsu_stat *stat)
+{
+	fprintf(stderr,"\tTS Interface Error Interrupts: %d.\n",stat->ts_if_err);
+	fprintf(stderr,"\tTS Fifo Overflow Interrupts: %d.\n",stat->fifo_ovfl);
+	fprintf(stderr,"\tTS Clock Sync Expired Interrupts: %d.\n",stat->clk_sync_exp);
+	fprintf(stderr,"\tTS Connection Error Interrupts: %d.\n",stat->ts_conn_err);
+	fprintf(stderr,"\n");
+}
+
+int main(int argc, char *argv[])
+{
+	char *dev_name;
+	char *file_name;
+	int dev_fd = 0;
+	FILE *file_fd = NULL;
+	int cnt = 0;
+	struct tsu_stat tsu_stat;
+
+	/* Eecutable name.		*/
+	util_name = argv[cnt++];
+
+	if(argc < 4) {
+		if(argc > 1)
+			fprintf(stderr,"Missing parameters.\n");
+		usage();
+	}
+
+	/* Device name			*/
+	dev_name = argv[cnt++];
+
+	/* Read / Write operation.	*/
+	if(!strcmp(argv[cnt],"r")) {
+		g_is_read = 1;
+	} else if(!strcmp(argv[cnt],"w")) {
+		g_is_read = 0;
+	} else {
+		fprintf(stderr,"Bad read / write option.\n");
+		usage();
+	}
+	cnt++;
+
+	/* Open the device.		*/
+	if(g_is_read)
+		dev_fd = open(dev_name, O_RDONLY);
+	else
+		dev_fd = open(dev_name, O_WRONLY);
+
+	if(dev_fd <= 0) {
+		fprintf(stderr,"%s - Cannot open device %s.\n",util_name,dev_name);
+		exit(2);
+	}
+
+	/* Input / Output file name.	*/
+	file_name = argv[cnt++];
+	if(g_is_read) {
+		if(!strncmp(file_name,"stdout",strlen("stdout")))
+			file_fd = stdout;
+	else
+			file_fd = fopen(file_name, "w+");
+	}else{
+		file_fd = fopen(file_name, "r");
+	}
+	if(file_fd == NULL) {
+		fprintf(stderr,"%s - Cannot open file %s.\n",util_name,file_name);
+		goto error;
+	}
+
+	if(get_buff_info(dev_fd) < 0){
+		fprintf(stderr,"%s - Failed to retrieve device buffer configuration.\n");
+		goto error;
+	}
+
+	/* Allocate buffer.		*/
+	data_buff = malloc(g_buf_size);
+	if(data_buff == NULL) {
+		fprintf(stderr,"%s - Failed to allocate memory (%d Bytes).\n",util_name,
+		       BUFSIZE);
+		goto error;
+	}
+
+	if(process_options(argc,argv,cnt,dev_fd) < 0) {
+		fprintf(stderr,"Bad options.\n");
+		goto error;
+	}
+
+	/* Clear statistics.			*/
+	if(ioctl(dev_fd,MVTSU_IOCCLEARSTAT,0) < 0) {
+		fprintf(stderr,"Error Clearing statistics.\n");
+		goto error;
+	}
+
+	if(g_is_read)
+		data_read(dev_fd,file_fd);
+	else
+		data_write(dev_fd,file_fd);
+
+	/* Print statistics.			*/
+	if(ioctl(dev_fd,MVTSU_IOCGETSTAT,&tsu_stat) < 0) {
+		fprintf(stderr,"Error Printing statistics.\n");
+		goto error;
+	}
+	tsu_print_stat(&tsu_stat);
+
+error:
+	if(dev_fd != 0)
+		close(dev_fd);
+	if(file_fd != NULL)
+		fclose(file_fd);
+	if(data_buff != NULL)
+		free(data_buff);
+	if(g_stat_fd != NULL)
+		fclose(g_stat_fd);
+	return 0;
+}
+
+
+int check_write_file_device_params(struct tsu_buff_info *buff_info)
+{
+	if(!g_raw_mode) {
+		/* buffer configuration for input data & TSU must match.*/
+		if(buff_info->aggr_mode == g_buff_info.aggr_mode) {
+			if((g_buff_info.aggr_mode == aggrMode1) &&
+			   (g_buff_info.aggr_num_packets !=
+			    buff_info->aggr_num_packets)) {
+				fprintf(stderr,"Mismtach in Num of Aggregation packets (%d, %d).\n",
+				       g_buff_info.aggr_num_packets,
+				       buff_info->aggr_num_packets);
+				return -1;
+			}
+			if((g_buff_info.aggr_mode == aggrMode2) &&
+			   (g_buff_info.aggr_mode2_tmstmp_off !=
+			    buff_info->aggr_mode2_tmstmp_off)) {
+				fprintf(stderr,"Mismtach in Aggregation Timestamp offset (%d, %d).\n",
+				       g_buff_info.aggr_mode2_tmstmp_off,
+				       buff_info->aggr_mode2_tmstmp_off);
+				return -1;
+			}
+		}
+
+		if(buff_info->aggr_mode != g_buff_info.aggr_mode) {
+			if(g_buff_info.aggr_mode == aggrMode1){
+				fprintf(stderr,"Device configured in aggregation mode 1 while file is not.\n");
+				return -1;
+			}
+			if(buff_info->aggr_mode == aggrMode1) {
+				fprintf(stderr,"File configured in aggregation mode 1 while port is not.\n");
+				return -1;
+			}
+			/* File @ mode2, Device @ Aggr-Disabled.	*/
+			if((buff_info->aggr_mode == aggrMode2) &&
+			   (buff_info->aggr_mode2_tmstmp_off != TIMESTAMP_SIZE)) {
+				fprintf(stderr,"File is in aggr-mode-2 mode with timestamp "
+				       "offset != 4, and device is at aggr-dis mode.\n");
+				return -1;
+			}
+
+			/* Device @ mode2, File @ Aggr-Disabled.	*/
+			if((g_buff_info.aggr_mode == aggrMode2) &&
+			   (g_buff_info.aggr_mode2_tmstmp_off != TIMESTAMP_SIZE)) {
+				fprintf(stderr,"Device is in aggr-mode-2 mode with timestamp "
+				       "offset != 4, and file is at aggr-dis mode.\n");
+				return -1;
+			}
+		}
+	}
+	return 0;
+}
+
+
+int single_read_write(int is_read, int fd, char *buf, int count)
+{
+	int tmp = 0;
+	int ret;
+
+	while(tmp < count) {
+
+		if(is_read) {
+			ret = read(fd,buf + tmp,count - tmp);
+                } else {
+			ret = write(fd,buf + tmp,count - tmp);
+		}
+
+		if(ret <= 0)
+			return ret;
+		tmp += ret;
+	}
+	return count;
+}
+
+
+int single_fread_fwrite(int is_read, FILE *fd, char *buf, int count)
+{
+	int tmp = 0;
+	int ret;
+
+	while(tmp < count) {
+
+		if(is_read) {
+			ret = fread(buf + tmp,1,count - tmp,fd);
+                } else {
+			ret = fwrite(buf + tmp,1,count - tmp,fd);
+		}
+
+		if(ret <= 0)
+			return ret;
+		tmp += ret;
+	}
+	return count;
+}
+
+
+void setup_buffer_timestamps(char *buff, int *s_offs, int *init_tms,int *new_size)
+{
+	int i;
+	int total_diffs = 0;
+	int first_tms = -1;
+	int tmp;
+
+	memcpy(&first_tms,buff,TIMESTAMP_SIZE);
+	*init_tms = first_tms;
+
+	if(g_buff_info.aggr_mode == aggrMode1) {
+		/* Calculate the timestamp interval.		*/
+		memcpy(&tmp,
+		       buff + ((g_buff_info.aggr_num_packets - 1) * TIMESTAMP_SIZE),
+		       TIMESTAMP_SIZE);
+		total_diffs = tmp - first_tms;
+		total_diffs = total_diffs / (g_buff_info.aggr_num_packets - 1);
+
+		/* Copy timestamp interval	*/
+		memcpy(buff + (g_buff_info.aggr_num_packets - 2) * TIMESTAMP_SIZE,
+		       &total_diffs,TIMESTAMP_SIZE);
+
+		/* Copy initial timestamp	*/
+		memcpy(buff + (g_buff_info.aggr_num_packets - 1) * TIMESTAMP_SIZE,
+		       &first_tms,TIMESTAMP_SIZE);
+
+		*s_offs = (g_buff_info.aggr_num_packets - 2) * TIMESTAMP_SIZE;
+		*new_size -= (*s_offs);
+	} else {
+		*s_offs = 0;
+	}
+	return;
+}
+
+
+void data_write(int dev_fd, FILE *file_fd)
+{
+	int cnt;
+	FILE *fd;
+	int tmp;
+	int s_offs, e_offs;
+	int pkt_size;
+	int first_write = 1;
+	struct tsu_buff_info buff_info;
+	int init_tms;
+	unsigned int freq;
+
+	if(!g_b2b_mode && !g_auto_ts_mode) {
+		/* Read TS info from file header.		*/
+		/* pktsize mode aggr_pkts_num tmstmp_offset	*/
+		if(!g_raw_mode)
+			fd = file_fd;
+		else
+			fd = g_stat_fd;
+
+		if(fread(data_buff,1,FILE_HDR_SIZE,fd) < FILE_HDR_SIZE) {
+			fprintf(stderr,"Failed to read file information header.\n");
+			return;
+		}
+
+		sscanf(data_buff,"%d %d %d %d %d %d",&tmp,&pkt_size,&buff_info.aggr_mode,
+		       &buff_info.aggr_num_packets,&buff_info.aggr_mode2_tmstmp_off,
+		       &freq);
+		if(tmp != TSU_TOOL_STAMP) {
+			fprintf(stderr,"Bad stamp at file header (0x%x).\n",tmp);
+			return;
+		}
+
+		/* If user did not specify a frequency for TX, take the file frequency.	*/
+		if(g_frequency == -1)
+			g_frequency = freq;
+
+		if(pkt_size != g_buff_info.pkt_size) {
+			fprintf(stderr,"File Packet size (%d) & TSU packet size (%d) do not match.\n",
+			       pkt_size,g_buff_info.pkt_size);
+			return;
+		}
+
+		if(check_write_file_device_params(&buff_info) < 0)
+			return;
+	}
+
+	/* Calculate the values of g_ts_data_size & g_tms_data_size.	*/
+	if(g_raw_mode) {
+		if(g_buff_info.aggr_mode == aggrMode1) {
+			g_ts_data_size =
+				(g_buff_info.pkt_size *
+				 g_buff_info.aggr_num_packets);
+			g_tms_data_size = (TIMESTAMP_SIZE *
+					   g_buff_info.aggr_num_packets);
+		}
+		else if(g_buff_info.aggr_mode == aggrMode2) {
+			g_ts_data_size = g_buff_info.pkt_size;
+			g_tms_data_size = TIMESTAMP_SIZE;
+		}
+		else { /* Aggregation disabled.	*/
+			g_ts_data_size = g_buff_info.pkt_size;
+			g_tms_data_size = TIMESTAMP_SIZE;
+		}
+	} else {
+		g_ts_data_size = g_data_blk_sz;
+		g_tms_data_size = 0;
+	}
+
+	/* Setup Tx frequency.		*/
+        if(ioctl(dev_fd,MVTSU_IOCFREQSET,&g_frequency) < 0) {
+		fprintf(stderr,"Error configuring port frequency.\n");
+		goto done;
+	}
+#if 0
+	printf("g_ts_data_size = %d, g_data_blk_sz = %d.\n",
+	       g_ts_data_size,g_tms_data_size);
+#endif
+	while(1) {
+		cnt = 0;
+		s_offs = 0;
+		e_offs = 0;
+		while(cnt < g_data_blk_sz) {
+//			printf("cnt = %d, ",cnt);
+			if(g_tms_data_size) {
+				if(g_buff_info.aggr_mode == aggrMode2) {
+					e_offs += (g_buff_info.aggr_mode2_tmstmp_off -
+						   g_tms_data_size);
+					cnt += (g_buff_info.aggr_mode2_tmstmp_off -
+						   g_tms_data_size);
+				}
+//				printf("sread %d, ",g_tms_data_size);
+				tmp = single_fread_fwrite(READ,g_stat_fd,data_buff + e_offs,
+							g_tms_data_size);
+				if(tmp != g_tms_data_size) {
+					fprintf(stderr,"Error reading from timestamp file.\n");
+					goto done;
+				}
+                                e_offs += tmp;
+				cnt += tmp;
+			}
+
+//			printf("dread %d, ",g_ts_data_size);
+			tmp = single_fread_fwrite(READ,file_fd,data_buff + e_offs,
+						g_ts_data_size);
+			if(tmp < 0) {
+				fprintf(stderr,"Error reading from source file.\n");
+				goto done;
+			}
+			if(tmp == 0) {
+				/* No more input.	*/
+				goto done;
+			}
+			e_offs += tmp;
+			cnt += tmp;
+                        setup_buffer_timestamps(data_buff,&s_offs,&init_tms,&cnt);
+		}
+
+		if(first_write) {
+			struct tsu_tmstmp_info tms_info;
+			tms_info.enable_tms = !g_b2b_mode;
+			tms_info.timestamp = init_tms;
+			if(ioctl(dev_fd,MVTSU_IOCTXTMSSET,&tms_info) < 0) {
+				fprintf(stderr,"Cannot set initial timestamp for TX operation.\n");
+				goto done;
+			}
+			first_write = 0;
+		}
+
+//		printf("twrite %d.\n",g_data_blk_sz);
+		cnt = single_read_write(WRITE,dev_fd,data_buff + s_offs,
+					g_data_blk_sz);
+		if(cnt <= 0) {
+			fprintf(stderr,"Error writing to target device.\n");
+			break;
+		}
+	}
+
+done:
+	/* tell device that tx is over.		*/
+	if(ioctl(dev_fd,MVTSU_IOCTXDONE,0) < 0) {
+		fprintf(stderr,"Error in TX-Done IOCTL.\n");
+		return;
+	}
+        return;
+}
+
+void data_read(int dev_fd, FILE *file_fd)
+{
+	int cnt = 0;
+	int tmp;
+	int offs = 0;
+	int drop = 10;
+
+	/* Write TS info the file header.		*/
+	/* pktsize mode aggr_pkts_num tmstmp_offset	*/
+	sprintf(data_buff,"%d %d %d %d %d %d",
+		TSU_TOOL_STAMP,g_buff_info.pkt_size,g_buff_info.aggr_mode,
+		g_buff_info.aggr_num_packets,
+		g_buff_info.aggr_mode2_tmstmp_off, g_frequency);
+	tmp = strlen(data_buff);
+	while(tmp < FILE_HDR_SIZE)
+		data_buff[tmp++] = ' ';
+	data_buff[tmp] = '\0';
+
+	if(!g_raw_mode)
+		cnt = fwrite(data_buff,1,strlen(data_buff),file_fd);
+	else
+		cnt = fwrite(data_buff,1,strlen(data_buff),g_stat_fd);
+
+	if(cnt != strlen(data_buff)) {
+		fprintf(stderr,"Error wrting file header.\n");
+		return;
+        }
+
+	/* Calculate the values of g_ts_data_size & g_tms_data_size.	*/
+	if(g_raw_mode) {
+		if(g_buff_info.aggr_mode == aggrMode1) {
+			g_ts_data_size =
+				(g_buff_info.pkt_size *
+				 g_buff_info.aggr_num_packets);
+			g_tms_data_size = (TIMESTAMP_SIZE *
+					   g_buff_info.aggr_num_packets);
+		}
+		else if(g_buff_info.aggr_mode == aggrMode2) {
+			g_ts_data_size = g_buff_info.pkt_size;
+			g_tms_data_size = g_buff_info.aggr_mode2_tmstmp_off;
+		}
+		else { /* Aggregation disabled.	*/
+			g_ts_data_size = g_buff_info.pkt_size;
+			g_tms_data_size = TIMESTAMP_SIZE;
+		}
+	} else {
+		g_ts_data_size = g_data_blk_sz;
+		g_tms_data_size = 0;
+	}
+
+	/* Setup frequency.		*/
+        if(ioctl(dev_fd,MVTSU_IOCFREQSET,&g_frequency) < 0) {
+		fprintf(stderr,"Error configuring port frequency.\n");
+		goto done;
+	}
+
+//	fprintf(stderr,"g_raw_mode = %d, g_ts_data_size = %d, g_tms_data_size = %d.\n",
+//	       g_raw_mode, g_ts_data_size,g_tms_data_size);
+	cnt = 0;
+	while(1) {
+
+		if(offs != 0)
+			fprintf(stderr,"offs = %d.\n");
+		tmp = single_read_write(READ,dev_fd,data_buff + offs,
+					g_data_blk_sz - offs);
+		if(tmp < 0) {
+			fprintf(stderr,"Error reading from source device / file.\n");
+			break;
+		}
+		if(drop) {
+			drop--;
+			continue;
+		}
+
+		cnt += tmp;
+		if(cnt == 0)
+			break;
+		while(cnt >= (g_ts_data_size + g_tms_data_size)) {
+ //                       fprintf(stderr,"cnt - %d, ",cnt);
+			tmp = 0;
+			if(g_tms_data_size > 0) {
+				if(g_buff_info.aggr_mode == aggrMode2) {
+//					fprintf(stderr,"TMSW = %d, ",offs);
+					/* write only the timestamp part.	*/
+					tmp = single_fread_fwrite(WRITE,g_stat_fd,
+								  data_buff + offs,
+						    TIMESTAMP_SIZE);
+					if(tmp < TIMESTAMP_SIZE) {
+						fprintf(stderr,"Error writing to timestamps file.\n");
+						goto done;
+					}
+				} else {
+					tmp = single_fread_fwrite(WRITE,g_stat_fd,
+								data_buff + offs,
+								g_tms_data_size);
+					if(tmp < g_tms_data_size) {
+						fprintf(stderr,"Error writing to timestamps file.\n");
+						goto done;
+					}
+				}
+
+				offs += tmp;
+			}
+//			fprintf(stderr,"TSDW = %d.\n",offs);
+			tmp = single_fread_fwrite(WRITE,file_fd,data_buff + offs,
+						g_ts_data_size);
+			if(tmp < g_ts_data_size) {
+				fprintf(stderr,"Error writing to data file.\n");
+				goto done;
+			}
+			offs += g_ts_data_size;
+			cnt -= (g_ts_data_size + g_tms_data_size);
+		}
+
+		if(cnt > 0) {
+			memmove(data_buff,data_buff + offs, cnt);
+			offs = cnt;
+		}
+		else {
+			offs = 0;
+		}
+	}
+done:
+	return;
+}
+
+
+int get_buff_info(int dev_fd)
+{
+	char *tmp;
+
+	if(ioctl(dev_fd,MVTSU_IOCBUFFPARAMGET,&g_buff_info) < 0){
+		fprintf(stderr,"Error reading device buffer information.\n");
+		return -1;
+	}
+
+	if(g_buff_info.aggr_mode == aggrMode1) {
+		if(g_is_read)
+			g_data_blk_sz = ((g_buff_info.pkt_size + TIMESTAMP_SIZE) *
+					 g_buff_info.aggr_num_packets);
+		else
+			g_data_blk_sz = ((g_buff_info.pkt_size *
+					  g_buff_info.aggr_num_packets) +
+					 (2 * TIMESTAMP_SIZE));
+		g_buf_size = ((g_buff_info.pkt_size + TIMESTAMP_SIZE) *
+			      g_buff_info.aggr_num_packets);
+		tmp = "Mode 1";
+	} else if(g_buff_info.aggr_mode == aggrMode2) {
+		g_data_blk_sz = ((g_buff_info.pkt_size +
+				  g_buff_info.aggr_mode2_tmstmp_off) *
+				 g_buff_info.aggr_num_packets);
+		g_buf_size = g_data_blk_sz;
+		tmp = "Mode 2";
+	} else {
+		g_data_blk_sz = (g_buff_info.pkt_size + TIMESTAMP_SIZE);
+		g_buf_size = g_data_blk_sz;
+		tmp = "Disabled";
+	}
+#if 0
+	fprintf(stderr,"\n");
+        fprintf(stderr,"\tPacket Size: %d Bytes\n",g_buff_info.pkt_size);
+	fprintf(stderr,"\tAggregation %s\n",tmp);
+	if(g_buff_info.aggr_mode != aggrModeDisabled)
+		fprintf(stderr,"\tAggregation packets: %d.\n",g_buff_info.aggr_num_packets);
+	if(g_buff_info.aggr_mode == aggrMode2)
+		fprintf(stderr,"\tAggregation Timestamp offset: %d.\n",
+		       g_buff_info.aggr_mode2_tmstmp_off);
+#endif
+//	fprintf(stderr,"\tCalculated data buffer size: %d Bytes.\n",g_buf_size);
+//	fprintf(stderr,"\tCalculated data-block size: %d Bytes.\n",g_data_blk_sz);
+	return 0;
+}
+
+
+int process_options(int argc, char *argv[],int idx,int dev_fd)
+{
+	char *stat_file = NULL;
+
+	while(idx < argc) {
+		if(argv[idx][0] != '-')
+			goto error;
+		switch (argv[idx][1]) {
+		case 'r':
+			g_raw_mode = 1;
+			stat_file = argv[idx+1];
+			idx+=2;
+			break;
+		case 'f':
+			g_frequency = atoi(argv[idx+1]);
+			idx+=2;
+			break;
+		case 'b':
+			g_raw_mode = 1;
+			g_b2b_mode = 1;
+			stat_file = "/dev/zero";
+			idx += 1;
+			break;
+		case 'a':
+			g_auto_ts_mode = 1;
+			g_raw_mode = 1;
+			stat_file = "/dev/zero";
+			idx += 1;
+			break;
+		default:
+			goto error;
+		}
+	}
+
+	if(g_b2b_mode && g_is_read) {
+		fprintf(stderr,"%s - Cannot work in Back-To-Back mode in read direction.",
+		       util_name);
+		goto error;
+	}
+
+	if(g_raw_mode) {
+		if(g_is_read)
+                        g_stat_fd = fopen(stat_file, "w+");
+		else
+                        g_stat_fd = fopen(stat_file, "r");
+		if(g_stat_fd == NULL){
+			fprintf(stderr,"%s - Cannot open file %s.\n",util_name,stat_file);
+			goto error;
+		}
+	}
+
+	if(g_is_read || g_auto_ts_mode) {
+		if(g_frequency == -1) {
+			fprintf(stderr,
+				"%s - Must provide data frequency (For Rx & auto timestamp mode).\n",util_name);
+			goto error;
+		}
+	}
+
+	if(g_auto_ts_mode) {
+		if(ioctl(dev_fd,MVTSU_IOCAUTOTMS,&g_auto_ts_mode) < 0) {
+			fprintf(stderr,"Error enabling auto timestamp mode.\n");
+			goto error;
+		}
+	}
+
+	return 0;
+
+error:
+	return -1;
+}
diff --git a/tools/voice/silabs/Makefile b/tools/voice/silabs/Makefile
new file mode 100644
index 0000000..1832f85
--- /dev/null
+++ b/tools/voice/silabs/Makefile
@@ -0,0 +1,58 @@
+# kernel sources 
+srctree  := $(shell /bin/pwd)
+
+ifndef KSRC
+KSRC  := $(srctree)/../../..
+endif
+
+include $(KSRC)/.config
+
+CFLAGS  := $(EXTRA_CFLAGS)
+
+ifdef CONFIG_CPU_BIG_ENDIAN
+CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
+endif
+
+CC := $(CROSS_COMPILE)gcc
+LD := $(CROSS_COMPILE)ld
+AR := $(CROSS_COMPILE)ar
+
+#CFLAGS += -I$(KSRC)/tools/voice/
+
+ifeq ($(CONFIG_SILABS_SLIC_SUPPORT),y)
+TARGETS += siapi_lib.o
+LIBS := libsiapi.a
+TOOL := mv_voice_tool.c
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/silabs/arch_marvell/
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/silabs/inc
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/silabs/custom/
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/test/
+
+ifeq ($(CONFIG_SILAB_SLIC_SI3217x),y)
+ CFLAGS += -DSI3217x
+endif
+ifeq ($(CONFIG_SILAB_SLIC_SI3226x),y)
+ CFLAGS += -DSI3226x
+endif
+
+ifeq ($(CONFIG_MV_TDM_USE_DCO),y)
+ CFLAGS += -DMV_TDM_USE_DCO
+endif
+
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/test/
+
+all:
+	$(CC) $(CFLAGS) -static -c silabs_lib.c -o $(TARGETS)
+	$(AR) rcs $(LIBS) $(TARGETS)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+mv_voice_tool: $(PROFILE) $(TOOL)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+clean:
+	rm -f *.o *.a mv_voice_tool
+	@for subdir in $(SUBDIRS); do \
+                (cd $$subdir && $(MAKE) $@) || exit 1; \
+        done
+endif #CONFIG_SILABS_SLIC_SUPPORT
diff --git a/tools/voice/silabs/mv_voice_tool.c b/tools/voice/silabs/mv_voice_tool.c
new file mode 100644
index 0000000..fc5c46a
--- /dev/null
+++ b/tools/voice/silabs/mv_voice_tool.c
@@ -0,0 +1,1335 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+#include "tdm/test/tdm_dev.h"
+
+#include "silabs_lib.h"
+
+#if defined(SI3217x)
+/* SILABS si3217x */
+#include "si3217x_constants.h"
+#define MAX_DEVICES		1
+#define MAX_DEVICE_LINES	1
+#define MAX_LINES		1
+
+#elif defined(SI3226x)
+/* SILABS si3226x */
+#include "si3226x_constants.h"
+#define MAX_DEVICES		1
+#define MAX_DEVICE_LINES	2
+#define MAX_LINES		2
+#endif
+
+#define TOOL_PREFIX		">> "
+#define TIMEOUT			11000 /* usec */
+/* Line calibration increases init time significantly */
+#define LINE_CALIBRATION_SUPPORT
+
+/* Defines */
+#define GET_DEVICE(line_id)	(line_id/MAX_DEVICE_LINES)
+#define GET_LINE(line_id)	(line_id % MAX_DEVICE_LINES)
+#define N_A			0
+#define ON_HOOK			0
+#define OFF_HOOK		1
+#define CH_BUFF_SIZE		(80 * pcm_bytes)
+#define BUFF_ADDR(buff, line)	((unsigned char*)buff + (line*80*pcm_bytes))
+
+/* GLobals */
+static unsigned short total_lines = 0;
+static unsigned short total_devs = 0;
+static unsigned char pcm_bytes = 0;
+static unsigned char cal_devs = 0;
+#ifdef LINE_CALIBRATION_SUPPORT
+static unsigned short cal_lines = 0;
+#endif
+static unsigned char time_slot_table[MAX_LINES];
+static unsigned char hook_state[MAX_LINES];
+static char dev_name[] = "/dev/tdm";
+static int buff_size = 0;
+static unsigned char aud_buf[2][320 * MAX_LINES];
+static unsigned short f1Mem = 0;
+static unsigned short f2Mem = 0;
+static int offhook_count = 0;
+static unsigned int event_count = 0;
+static int tdm_fd = 0;
+static unsigned char data_buff[MAX_SLIC_RDWR_BUFF_SIZE];
+static unsigned int data_buff_ram[3];
+static int slic_init = 0;
+
+/* sin table, 256 points */
+static short sinTbl[] = {0,402,804,1205,1606,2005,2404,2801,3196,3590,3981,4370,4756,
+5139,5519,5896,6270,6639,7005,7366,7723,8075,8423,8765,9102,9433,9759,10079,10393,
+10701,11002,11297,11585,11865,12139,12405,12664,12915,13159,13394,13622,13841,14052,
+14255,14449,14634,14810,14977,15136,15285,15425,15556,15678,15790,15892,15985,16068,
+16142,16206,16260,16304,16339,16363,16378,16383,16378,16363,16339,16304,16260,16206,
+16142,16068,15985,15892,15790,15678,15556,15425,15285,15136,14977,14810,14634,14449,
+14255,14052,13841,13622,13394,13159,12915,12664,12405,12139,11865,11585,11297,11002,
+10701,10393,10079,9759,9433,9102,8765,8423,8075,7723,7366,7005,6639,6270,5896,5519,
+5139,4756,4370,3981,3590,3196,2801,2404,2005,1606,1205,804,402,0,-402,-804,-1205,-1606,
+-2005,-2404,-2801,-3196,-3590,-3981,-4370,-4756,-5139,-5519,-5896,-6270,-6639,-7005,
+-7366,-7723,-8075,-8423,-8765,-9102,-9433,-9759,-10079,-10393,-10701,-11002,-11297,
+-11585,-11865,-12139,-12405,-12664,-12915,-13159,-13394,-13622,-13841,-14052,-14255,
+-14449,-14634,-14810,-14977,-15136,-15285,-15425,-15556,-15678,-15790,-15892,-15985,
+-16068,-16142,-16206,-16260,-16304,-16339,-16363,-16378,-16383,-16378,-16363,-16339,
+-16304,-16260,-16206,-16142,-16068,-15985,-15892,-15790,-15678,-15556,-15425,-15285,
+-15136,-14977,-14810,-14634,-14449,-14255,-14052,-13841,-13622,-13394,-13159,-12915,
+-12664,-12405,-12139,-11865,-11585,-11297,-11002,-10701,-10393,-10079,-9759,-9433,-9102,
+-8765,-8423,-8075,-7723,-7366,-7005,-6639,-6270,-5896,-5519,-5139,-4756,-4370,-3981,
+-3590,-3196,-2801,-2404,-2005,-1606,-1205,-804,-402,0};
+
+/* Static APIs */
+static inline void wait_for_silabs_event(void);
+static int silabs_init(void);
+static void silabs_release(void);
+static void release(int signum);
+static void sw_tone_test(int tdm_fd, unsigned char line_id);
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff);
+static void sw_loopback(int tdm_fd, unsigned char line_id);
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1);
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations);
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line);
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations);
+static inline int slic_dl_data_compare(int offset);
+static void set_tdm_clk_config(void);
+#if defined(MV_TDM_USE_DCO)
+static int get_tdm_clk_correction(void);
+static void set_tdm_clk_correction(int correction);
+#endif
+
+int main(void)
+{
+	int ret = 0, cmd = 0, val = 0, tdm_init = 0, toneEna = 0, preset = 0;
+	int proc_fd, fdflags, cmd_len, i, status;
+	char str[32];
+	unsigned char line0_id, line1_id;
+	tdm_dev_params_t tdm_params;
+	unsigned long int iterations;
+
+	event_count = 0;
+	slic_init = 0;
+
+	/* open tdm device */
+	tdm_fd = open(dev_name, O_RDWR); 
+	if (tdm_fd <= 0) {
+		printf("%s Cannot open %s device\n", TOOL_PREFIX, dev_name);
+		return 1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(tdm_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(tdm_fd, F_SETFL, fdflags);
+
+	printf("\n%s Please enter total lines number: ", TOOL_PREFIX);
+	gets(str);
+	total_lines = atoi(str);
+
+	printf("%s Please enter PCM sample size(1/2/4): ",TOOL_PREFIX);
+	gets(str);
+	pcm_bytes = atoi(str);
+
+	/* Calculate total lines buffer size */
+	buff_size = (80 * pcm_bytes * total_lines);
+
+	/* Fill TDM info */
+	tdm_params.pcm_format = pcm_bytes;
+	tdm_params.total_lines = total_lines;
+	
+	total_devs = (total_lines/MAX_DEVICE_LINES);
+	if((total_lines % MAX_DEVICE_LINES))
+		total_devs++;
+
+	/* Handle termination gracefully */
+	if (signal (SIGINT, release) == SIG_IGN)
+		signal (SIGINT, SIG_IGN);
+
+	printf("\n !!! Remember to start phone devices before performing any action !!!\n", TOOL_PREFIX);
+
+	/* Issue main menu */
+	while(1) {
+		printf("\n  Marvell Voice Tool (Silabs Edition):\n");
+		printf("  0. Read from SLIC register\n");
+		printf("  1. Write to SLIC register\n");
+		printf("  2. Start ring\n");
+		printf("  3. Stop ring\n");
+		printf("  4. Start/Stop HW Dial tone\n");
+		printf("  5. Start SW Dial tone\n");
+		printf("  6. Self echo on local phone\n");
+		printf("  7. Loopback two local phones\n");
+		printf("  8. Digital Loopback\n");
+		printf("  9. Channel balancing\n");
+		printf("  c. Config TDM PCLK\n");
+		printf("  m. Multiple local phone pairs loopback\n");
+#if defined(DEBUG)
+		printf("  r. Read from SLIC RAM\n");
+		printf("  w. Write to SLIC RAM\n");
+#endif
+#if defined(MV_TDM_USE_DCO)
+		printf("  g. Get current TDM PCLK frequency correction (DCO)\n");
+		printf("  s. Set TDM PCLK frequency correction (DCO)\n");
+#endif
+		printf("  t. Start Phone devices\n");
+		printf("  u. Stop Phone devices\n");
+		printf("  q. Quit\n");
+		printf("\n%s Please select option: ", TOOL_PREFIX);
+
+		/* Clear write buffer */
+		memset(aud_buf[1], 0, buff_size);
+		gets(str);
+		switch(str[0]) {
+			case '0':
+				printf("%s Enter channel id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register address (decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				cmd_len = 1;
+				silabs_slic_reg_read(line0_id, cmd, cmd_len, data_buff);
+				printf("%s Return value: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++)
+					printf("0x%x ", data_buff[i]);
+				printf("\n");
+				break;
+
+			case '1':
+				printf("%s Enter channel id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register address (decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				cmd_len = 1;
+				printf("%s Enter data: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++) {
+					gets(str);
+					data_buff[i] = atoi(str);
+				}
+				silabs_slic_reg_write(line0_id, cmd, cmd_len, data_buff);
+				break;
+
+			case '2':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Start ringing on line %d\n", line0_id);
+				silabs_channel_operation(SI_CHANNEL_OP_RING_START, line0_id);
+				break;
+
+			case '3':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Stop ringing on line %d\n", line0_id);
+				silabs_channel_operation(SI_CHANNEL_OP_RING_STOP, line0_id);
+				break;
+
+			case '4':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				toneEna = 1-toneEna;
+				if (toneEna) {
+					printf("%s Enter preset: ", TOOL_PREFIX);
+					gets(str);
+					preset = atoi(str);
+					status = silabs_channel_setup(SI_CHANNEL_SETUP_TONEGEN, line0_id, preset);
+					if (status != RC_NONE) {
+						printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_TONEGEN) failed (status=%d) ##\n", status);
+						return -1;
+					}
+					status = silabs_channel_operation(SI_CHANNEL_OP_TONE_GEN_START, line0_id);
+				} else {
+					status = silabs_channel_operation(SI_CHANNEL_OP_TONE_GEN_STOP, line0_id);
+				}
+
+				if (status != RC_NONE) {
+					printf("## Error, silabs_channel_operation (SI_CHANNEL_OP_TONE_GEN_START) failed (status=%d) ##\n", status);
+					return -1;
+				}
+				break;
+
+			case '5':
+				if(pcm_bytes < 2) {
+					printf("Test is supported for linear mode only - try again\n");
+					break;
+				}
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				sw_tone_test(tdm_fd, line0_id);
+				break;
+
+			case '6':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+				line0_id = atoi(str);
+				sw_loopback(tdm_fd, line0_id);
+				break;
+
+			case '7':
+				printf("%s Enter line #0: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter line #1: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if(line0_id >= MAX_LINES || line1_id >= MAX_LINES) {
+					printf("%s Error, line must be in the range of 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_two_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case '8':
+				printf("%s Enter number of iterations(must be greater than 3): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				if(iterations < 4) {
+					printf("Requires at least 4 iterations  - try again\n");
+					break;
+				}
+				slic_digital_loopback(tdm_fd, iterations);
+				break;
+
+			case '9':
+				printf("%s Enter number of iterations('0' - for infinite loop): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				channel_balancing_test(tdm_fd, iterations);
+				break;
+#if defined(DEBUG)
+			case 'r':
+				printf("%s Enter channel id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC RAM address (decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				cmd_len = 1;
+				data_buff_ram[0] = 0;
+				silabs_slic_ram_read(line0_id, cmd, cmd_len, data_buff_ram);
+				printf("%s Return value: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++)
+					printf("0x%x ", data_buff_ram[i]);
+				printf("\n");
+				wait_for_silabs_event();
+				break;
+
+			case 'w':
+				printf("%s Enter channel id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC RAM address (decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				cmd_len = 1;
+				printf("%s Enter data: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++) {
+					gets(str);
+					data_buff_ram[i] = atoi(str);
+				}
+				silabs_slic_ram_write(line0_id, cmd, cmd_len, data_buff_ram);
+				break;
+#endif
+			case 'm':
+				printf("%s Enter starting line range: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter ending line range: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if((line0_id >= MAX_LINES) || (line1_id >= MAX_LINES) || ((line1_id-line0_id) % 2 == 0)) {
+					printf("%s Error, lines range must be even and \
+						between 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_multi_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case 'c':
+				set_tdm_clk_config();
+				break;
+
+			case 'g':
+				printf("%s Current PPM correction is (+/-1000): %d", TOOL_PREFIX, get_tdm_clk_correction());
+				break;
+
+			case 's':
+				printf("%s Enter number of PPM for correction (+/-1000, 0 to disable correction): ", TOOL_PREFIX);
+				gets(str);
+				set_tdm_clk_correction((int)atoi(str));
+				break;
+
+			case 't':
+				/* Start Telephony */
+				if(ioctl(tdm_fd, TDM_DEV_TDM_START, &tdm_params)) {
+					printf("%s Error, unable to init TDM\n", TOOL_PREFIX);
+					return 1;
+				}
+
+				if(silabs_open_device()) {
+					printf("%s Error, could not open vpapi device\n", TOOL_PREFIX);
+					return 1;
+				}
+
+				if(silabs_init()) {
+					printf("%s Error, init failed\n", TOOL_PREFIX);
+					ret = 1;
+					goto voice_out;
+				}
+				slic_init = 1;
+
+				wait_for_silabs_event();
+
+				break;
+
+			case 'u':
+				/* Stop Telephony */
+				release(0);
+				break;
+
+			case 'q':
+				goto voice_out;
+
+			default:
+				printf("Option is not supported - try again\n");
+				break;
+		}
+	}
+
+voice_out:
+	release(1);
+
+	return ret;
+}
+
+void release(int signum)
+{
+	int i, status;
+
+	if (signum) {
+		printf("\n%s Stopping Phone devices and exit\n", TOOL_PREFIX);
+		sleep(1);
+	} else {
+		printf("\n%s Stopping Phone devices\n", TOOL_PREFIX);
+	}
+
+	/* Stop SLIC/s */
+	if(slic_init) {
+		/* Destroy ProSLIC channel objects. */
+		for(i=0;i<total_lines;i++) {
+			status = silabs_channel_init(SI_CHANNEL_DESTROY, i);
+			if (status != RC_NONE) {
+				printf("## Error, silabs_channel_init (SI_CHANNEL_DESTROY) failed (line=%d, status=%d) ##\n", i, status);
+				return;
+			}
+		}
+
+		/* Destroy ProSLIC Device Objects */
+		status = silabs_device_init(SI_DEVICE_DESTROY, 0);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_device_init (SI_DEVICE_CREATE) failed (status=%d) ##\n", status);
+			return;
+		}
+
+		/* Destroy ProSLIC Control Interface Object  */
+		status = silabs_control_interface(SI_IF_DESTROY);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_control_interface (SI_IF_DESTROY) failed (status=%d) ##\n", status);
+			return;
+		}
+	} else {
+		printf("\n%s SLIC already stopped\n", TOOL_PREFIX);
+	}
+
+	/* Stop TDM */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_STOP, 0)) {
+		printf("\n%s Error, unable to stop TDM\n", TOOL_PREFIX);
+		return;
+	} else {
+		printf("\n%s TDM stopped\n", TOOL_PREFIX);
+	}
+
+	if (signum)
+		close(tdm_fd);
+
+	if(silabs_close_device()) {
+		printf("\n%s Error, could not close SLIC device ##\n", TOOL_PREFIX);
+		return;
+	} else {
+		printf("\n%s SLIC device closed\n", TOOL_PREFIX);
+	}
+
+	if (signum)
+		exit(signum);
+}
+
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch, cb_loop = 0, i;
+	unsigned long int loops = 0, index;
+	int status;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index+=2)
+			*((unsigned short*)&aud_buf[1][(80 * pcm_bytes * ch) + index]) = (((index+3) << 8)+ (index+1));
+	}
+
+	/* Put SLIC/s in loopback mode and On-Hook transmission */
+	for(ch = 0; ch < total_lines; ch++) {
+		status = silabs_channel_set_loopback(ch, PROSLIC_LOOPBACK_DIG);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (PROSLIC_LOOPBACK_DIG) failed (status=%d) ##\n", status);
+			return;
+		}
+
+		status = silabs_channel_set_line_feed(ch, LF_FWD_OHT);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_set_line_feed (LF_FWD_ACTIVE) failed (line=%d, status=%d) ##\n", i, status);
+			return;
+		}
+	}
+
+	/* Wait a bit */
+	sleep(1);
+
+	if (iterations == 0)
+		iterations = (unsigned long int)(-1); /* Assume infinite */
+
+	while (loops < iterations) {
+		cb_loop = 0;
+		i = 0;
+
+		if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		while (cb_loop == 0) {
+			FD_ZERO(&rd_fds);
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &rd_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				goto cb_out;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds)) {
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len < buff_size) {
+					printf("write() failed\n");
+					goto cb_out;
+				}
+			}
+
+			/* Read */
+			if (FD_ISSET(tdm_fd, &rd_fds)) {
+				memset(aud_buf[0], 0, buff_size);
+				msg_len = read(tdm_fd, aud_buf[0], buff_size);
+				if (msg_len < buff_size) {
+					printf("read() failed\n");
+					goto cb_out;
+				}
+
+				if(i > 3) {
+					for(ch = 1; ch < total_lines; ch++) {
+						if(memcmp(aud_buf[0], &aud_buf[0][(ch * pcm_bytes * 80)], (pcm_bytes * 80))) {
+							printf("\nERROR - data miscompare(ch=%d) !!!\n", ch);
+							cmp_status = 1;
+							goto cb_out;
+						}
+					}
+
+					cb_loop = 1;
+				}
+				i++;
+			}
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+
+		loops++;
+		if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+			printf("Error, unable to stop pcm bus\n");
+			return;
+		}
+		printf("loop #%u\n", loops);
+		sleep(1);
+	}
+
+cb_out:
+	if(cmp_status == 0) {
+		printf("\nChannel balancing test PASSED !!!\n");
+	} else {
+		printf("Dump Rx buffer:\n");
+		for(ch = 0; ch < total_lines; ch++) {
+			printf("Buffer #%d: ", ch);
+			for(i = 0; i < (pcm_bytes * 80); i++) {
+				printf("0x%x ", aud_buf[0][(ch * pcm_bytes * 80) + i]);
+			}
+			printf("\n\n");
+			sleep(1);
+		}
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	/*  Return SLIC/s to no-loopback mode and Off-Hook transmission */
+	for(ch = 0; ch < total_lines; ch++) {
+		status = silabs_channel_set_loopback(ch, PROSLIC_LOOPBACK_NONE);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (PROSLIC_LOOPBACK_DIG) failed (status=%d) ##\n", status);
+			return;
+		}
+
+		status = silabs_channel_set_line_feed(ch, LF_FWD_ACTIVE);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_set_line_feed (LF_FWD_ACTIVE) failed (line=%d, status=%d) ##\n", i, status);
+			return;
+		}
+	}
+}
+
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch;
+	unsigned long int loops = 0, index;
+	int i, status;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Put SLIC/s in loopback mode and On-Hook transmission */
+	for(ch = 0; ch < total_lines; ch++) {
+		status = silabs_channel_set_loopback(ch, PROSLIC_LOOPBACK_DIG);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (PROSLIC_LOOPBACK_DIG) failed (status=%d) ##\n", status);
+			return;
+		}
+
+		status = silabs_channel_set_line_feed(ch, LF_FWD_OHT);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_set_line_feed (LF_FWD_ACTIVE) failed (line=%d, status=%d) ##\n", i, status);
+			return;
+		}
+	}
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index++)
+			aud_buf[1][index + (80 * pcm_bytes * ch)] = (index+ch+2);
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while (loops < iterations) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			goto slic_dl_out;
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len < buff_size) {
+				printf("write() failed\n");
+				goto slic_dl_out;
+			}
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			memset(aud_buf[0], 0, buff_size);
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len < buff_size) {
+				printf("read() failed\n");
+				goto slic_dl_out;
+			}
+
+			if(loops++ > 3) {
+				for(ch = 0; ch < total_lines; ch++) {
+					if(slic_dl_data_compare(ch)) {
+						printf("\nERROR - data miscompare(loops=%d) !!!\n",loops);
+						cmp_status = 1;
+						goto slic_dl_out;
+					}
+				}
+			}
+		}
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+slic_dl_out:
+	if(cmp_status == 0)
+		printf("\nDigital loopback test(%d lines) - PASS !!!\n",total_lines);
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	/*  Return SLIC/s to no-loopback mode and Off-Hook transmission */
+	for(ch = 0; ch < total_lines; ch++) {
+		status = silabs_channel_set_loopback(ch, PROSLIC_LOOPBACK_NONE);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (PROSLIC_LOOPBACK_DIG) failed (status=%d) ##\n", status);
+			return;
+		}
+		
+		status = silabs_channel_set_line_feed(ch, LF_FWD_ACTIVE);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_set_line_feed (LF_FWD_ACTIVE) failed (line=%d, status=%d) ##\n", i, status);
+			return;
+		}
+	}
+}
+
+static inline int slic_dl_data_compare(int ch)
+{
+	int i = 0, offset = (ch * pcm_bytes * 80);
+
+	/* Align Tx & Rx data start */
+	while((aud_buf[1][offset] != aud_buf[0][offset+i]) && (i < (pcm_bytes * 80)))
+		i++;
+
+	if(i >= (offset + (pcm_bytes * 80))) {
+		printf("\nError, first Tx byte not found inside Rx buffer\n");
+		return -1;
+	}
+
+	if(memcmp(&aud_buf[0][offset+i], &aud_buf[1][offset], ((pcm_bytes * 80) - i))) {
+		printf("\nDump buffers:\n");
+		for(i = offset; i < (offset +(pcm_bytes * 80)); i++)
+			printf("write[%d] = 0x%x, read[%d] = 0x%x\n", i, aud_buf[1][i], i, aud_buf[0][i]);
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+static void sw_loopback(int tdm_fd, unsigned char line_id)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, status;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until line goes off-hook */
+	while(hook_state[line_id] == 0) {
+		wait_for_silabs_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(hook_state[line_id] == 1) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			printf("Rd\n");
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			printf("Wr\n");
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_silabs_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff)
+{
+	short i;
+	short buf[80];
+	short sample;
+
+	for(i = 0; i < 80; i++) {
+		sample = (sinTbl[f1Mem >> 8] + sinTbl[f2Mem >> 8]) >> 2;
+#ifndef CONFIG_CPU_BIG_ENDIAN 
+		buf[i] = sample;
+#else
+		buf[i] = ((sample & 0xff) << 8)+ (sample >> 8);
+#endif
+		f1Mem += freq;
+		f2Mem += freq;
+	}
+	memcpy(BUFF_ADDR(tx_buff, line_id), (void *)buf, 160);
+}
+
+static void sw_tone_test(int tdm_fd, unsigned char line_id)
+{
+	fd_set wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, x, status;
+	char str[4];
+
+	if (tdm_fd <= 0) {
+		printf("%s Device %s is not accessible\n", TOOL_PREFIX, dev_name);
+		return;
+	}
+
+	while(1) {
+		if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+			printf("Error, unable to stop pcm bus\n");
+			return;
+		}
+
+		printf("%s Choose frequency: (1) 300HZ (2) 630HZ (3) 1000HZ (4) Back to main menu: ", TOOL_PREFIX);
+		gets(str);
+		printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+
+		if(str[0] == '1') {
+			x = 2457;
+			//printf("%s Generating 300HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '2') {
+			x = 5161;
+			//printf("%s Generating 630HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '3') {
+			x = 8192;
+			//printf("%s Generating 1000HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '4') {
+			return;
+		}
+		else {
+			printf("%s Input error - try again\n", TOOL_PREFIX);
+			continue;
+		}
+
+		/* Wait until both lines go off-hook */
+		while(hook_state[line_id] == 0) {
+			wait_for_silabs_event();
+		}
+
+		if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		printf("%s Waiting for on-hook to return to menu.\n", TOOL_PREFIX);
+
+		while(hook_state[line_id] == 1) {
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, NULL, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds)) {
+				gen_tone(x, line_id, aud_buf[1]);
+				if (pcm_bytes == 4)
+					gen_tone(x, line_id, (aud_buf[1]+160));
+
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len <= 0) {
+					printf("write() failed\n");
+					return;
+				}
+			}
+
+			/* Check hook state */
+			wait_for_silabs_event();
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+	}
+}
+
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+	unsigned char line_id;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until at least one line goes off-hook */
+	while(offhook_count == 0) {
+		wait_for_silabs_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(offhook_count) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+
+			for(line_id = start_line; line_id < end_line; line_id+=2) {
+				memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], (line_id+1)), CH_BUFF_SIZE);
+				memcpy(BUFF_ADDR(aud_buf[1], (line_id+1)), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+			}
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_silabs_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until both lines go off-hook */
+	while((hook_state[line0] == 0) || (hook_state[line1] == 0)) {
+		wait_for_silabs_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while((hook_state[line0] == 1) && (hook_state[line1] == 1)) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line0), BUFF_ADDR(aud_buf[0], line1), CH_BUFF_SIZE);
+			memcpy(BUFF_ADDR(aud_buf[1], line1), BUFF_ADDR(aud_buf[0], line0), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_silabs_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static int silabs_init(void)
+{
+	int i, status;
+
+	/* Set lines status to on-hook */
+	memset(hook_state, 0, MAX_LINES);
+
+	/* Fill time slot table */
+	memset(time_slot_table, 0, MAX_LINES);
+	for(i = 0; i < total_lines; i++)
+		time_slot_table[i] = ((i+1) * pcm_bytes);
+
+	/* Create ProSLIC Control Interface Object  */
+	status = silabs_control_interface(SI_IF_CREATE);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_control_interface (SI_IF_CREATE) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Create ProSLIC Device Objects */
+	status = silabs_device_init(SI_DEVICE_CREATE, 0);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_device_init (SI_DEVICE_CREATE) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Create and initialize ProSLIC channel objects. Also initialize array pointers to users proslic 
+	channel object members to simplify initialization process. */
+	for(i=0;i<total_lines;i++) {
+		status = silabs_channel_init(SI_CHANNEL_CREATE, i);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_init (SI_CHANNEL_CREATE) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+		status = silabs_channel_init(SI_CHANNEL_SW_INIT, i);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_init (SI_CHANNEL_SW_INIT) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+	}
+
+	/* Establish linkage between host objects/functions and ProSLIC API */
+	status = silabs_control_interface(SI_IF_SET_FUNCS);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_control_interface (SI_IF_SET_FUNCS) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Assert hardware Reset  ensure VDD, PCLK, and FSYNC are present and stable before releasing reset */
+	status = silabs_channel_operation(SI_CHANNEL_OP_RESET, 0);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_channel_operation (SI_CHANNEL_OP_RESET) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Initialize device (loading of general parameters, calibrations, dc-dc powerup, etc.) */
+	status = silabs_channel_all(SI_CHANNEL_ALL_INIT);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_channel_all (SI_CHANNEL_ALL_INIT) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Execute longitudinal balance calibration or reload coefficients from factory LB cal
+	Note: all batteries should be up and stable prior to executing the lb cal */
+	status = silabs_channel_all(SI_CHANNEL_ALL_LBCAL);
+	if (status != RC_NONE) {
+		printf("## Error, silabs_channel_all (SI_CHANNEL_ALL_LBCAL) failed (status=%d) ##\n", status);
+		return -1;
+	}
+
+	/* Load custom configuration presets (generated using ProSLIC API Config Tool) */
+	for(i=0;i<total_lines;i++) {
+		status = silabs_channel_setup(SI_CHANNEL_SETUP_DC_FEED, i, DCFEED_48V_20MA);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_DC_FEED) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+		status = silabs_channel_setup(SI_CHANNEL_SETUP_RING, i, RING_F20_45VRMS_0VDC_BAL);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_RING) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+		status = silabs_channel_setup(SI_CHANNEL_SETUP_ZSYNTH, i, ZSYN_600_0_0_30_0);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_ZSYNTH) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+		status = silabs_channel_setup(SI_CHANNEL_SETUP_TONEGEN, i, TONEGEN_FCC_DIAL);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_TONEGEN) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+
+		/* Extract PCM format */
+		switch(pcm_bytes) {
+			case 1:
+				status = silabs_channel_setup(SI_CHANNEL_SETUP_PCM, i, PCM_8ALAW);
+				break;
+			case 2:
+				status = silabs_channel_setup(SI_CHANNEL_SETUP_PCM, i, PCM_16LIN);
+				break;
+			case 4:
+				status = silabs_channel_setup(SI_CHANNEL_SETUP_PCM, i, PCM_16LIN_WB);
+				break;
+			default:
+				status = silabs_channel_setup(SI_CHANNEL_SETUP_PCM, i, PCM_8ALAW);
+				printf("## Warning, wrong PCM size - set to default(ALAW) ##\n");
+				break;
+		}
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_setup (SI_CHANNEL_SETUP_PCM) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+	}
+
+	/* Set Time slot parameters and line feed.*/
+	for(i=0;i<total_lines;i++) {
+		/* Configure PCM timeslots */
+		//printf("## INFO: line(%d): rx-slot(%d) , tx-slot(%d) ##\n",i ,(time_slot_table[i] * 8) + 1, (time_slot_table[i] * 8) + 1);
+		status = silabs_PCM_TS_setup(i, (time_slot_table[i] * 8) + 1, (time_slot_table[i] * 8) + 1);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_PCM_TS_setup failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+
+		status = silabs_channel_set_line_feed(i, LF_FWD_ACTIVE);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_set_line_feed (LF_FWD_ACTIVE) failed (line=%d, status=%d) ##\n", i, status);
+			return -1;
+		}
+	}
+
+	/*  Enable Interrupts. */
+	for(i=0;i<total_lines;i++) {
+		status = silabs_channel_operation(SI_CHANNEL_OP_ENA_INT, i);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (SI_CHANNEL_OP_ENA_INT) failed (status=%d) ##\n", status);
+			return -1;
+		}
+	}
+
+	/* PCM Start. */
+	for(i=0;i<total_lines;i++)  {
+		status = silabs_channel_operation(SI_CHANNEL_OP_PCM_START, i);
+		if (status != RC_NONE) {
+			printf("## Error, silabs_channel_operation (SI_CHANNEL_OP_PCM_START) failed (status=%d) ##\n", status);
+			return;
+		}
+	}
+	return 0;
+}
+
+static inline void wait_for_silabs_event(void)
+{
+	bool status;
+	SiEventType event;
+	uInt8 hookStatus;
+
+	while(silabs_get_event(&event) == true) {
+		while(event.eventsNum > 0) {
+			event.eventsNum--;
+			switch(event.irqs[event.eventsNum]) {
+				case IRQ_LOOP_STATUS:
+					silabs_channel_read_hook_status(event.chanNum, &hookStatus);
+					hook_state[event.chanNum] = hookStatus;
+					if (hook_state[event.chanNum]) {
+						printf("off-hook(%d)\n", event.chanNum);
+						offhook_count++;
+					} else {
+						printf("on-hook(%d)\n", event.chanNum);
+						offhook_count--;
+					}
+					break;
+				default:
+					break;
+			}
+		}
+	}
+}
+
+static void set_tdm_clk_config(void)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	/* Config TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_CONFIG, &tdm_dev_clk)) {
+		printf("%s Error, unable to config TDM clock.\n", TOOL_PREFIX);
+	}
+}
+
+static int get_tdm_clk_correction(void)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	/* Get TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_GET, &tdm_dev_clk)) {
+		printf("%s Error, unable to get TDM clock.\n", TOOL_PREFIX);
+		return 0;
+	}
+
+	return tdm_dev_clk.correction;
+}
+
+static void set_tdm_clk_correction(int correction)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	tdm_dev_clk.correction=correction;
+
+	/* Set TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_SET, &tdm_dev_clk)) {
+		printf("%s Error, unable to set TDM clock.\n", TOOL_PREFIX);
+	}
+}
diff --git a/tools/voice/silabs/mv_voice_tool.h b/tools/voice/silabs/mv_voice_tool.h
new file mode 100644
index 0000000..f3e4abb
--- /dev/null
+++ b/tools/voice/silabs/mv_voice_tool.h
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef _MVZARLINKIF_H_
+#define _MVZARLINKIF_H_
+
+#include "mvSysTdmConfig.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+MV_STATUS mvZarlinkIfInit(MV_U16 totalSLICs, MV_U16 pSlotInfo[][2], 
+				MV_BAND_MODE bandMode, MV_PCM_FORMAT pcmFormat);
+MV_STATUS mvZarlinkIfTimerTick(MV_SLIC_EVENT_INFO* slic_event_info);
+MV_VOID mvZarlinkIfISR(MV_U8 deviceId);
+MV_VOID mvZarlinkIfActivateRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfStopRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfHookStateGet(MV_U16 lineId, MV_U8* hookstate);
+MV_VOID mvZarlinkIfLinefeedControlSet(MV_U16 lineId, MV_LINEFEED_STATE lfState);
+MV_VOID mvZarlinkIfLinefeedControlGet(MV_U16 lineId, MV_LINEFEED_STATE* lfState);
+MV_VOID mvZarlinkIfReverseDcPolarity(MV_U16 lineId);
+MV_VOID mvZarlinkIfRelease(MV_VOID);
+MV_VOID mvZarlinkIfRegRead(MV_U8 lineId, MV_U8 cmd, MV_U8 cmdLen,MV_U8* dataBuff);
+
+#endif /* _MVZARLINKIF_H_ */
diff --git a/tools/voice/silabs/silabs_lib.c b/tools/voice/silabs/silabs_lib.c
new file mode 100644
index 0000000..0e49ad6
--- /dev/null
+++ b/tools/voice/silabs/silabs_lib.c
@@ -0,0 +1,442 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include "silabs_lib.h"
+
+/* Locals */
+static char dev_name[] = "/dev/silabs";
+static int dev_fd = 0;
+static char lib_str[] = "[silabs_lib]:";
+
+int silabs_open_device(void)
+{
+	int fdflags;
+
+	/* open the device */
+	dev_fd = open(dev_name, O_RDWR); 
+	if (dev_fd <= 0) {
+		printf("Cannot open %s device\n", dev_name);
+		return -1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(dev_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(dev_fd, F_SETFL, fdflags);
+
+	return 0;
+}
+
+int silabs_close_device(void)
+{
+	if(dev_fd > 0)
+		close(dev_fd);
+
+	return 0;	
+}
+
+int silabs_slic_reg_read(int line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	SilabsRegObjType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.chanNum = line_id;
+	data.func = SI_REG_READ;
+	data.regAddr = cmd;
+	data.value = 0;
+	data.ramValue = 0;
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_REG_CTRL, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_REG_CTRL) failed\n");
+		return -1;
+	}
+
+	*buff = data.value;
+
+	return 0;
+}
+
+int silabs_slic_reg_write(int line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	SilabsRegObjType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.chanNum = line_id;
+	data.func = SI_REG_WRITE;
+	data.regAddr = cmd;
+	data.value = buff[0];
+	data.ramValue = 0;
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_REG_CTRL, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_REG_CTRL) failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int silabs_slic_ram_read(int line_id, uInt16 cmd, unsigned char cmd_len, unsigned int *buff)
+{
+	SilabsRegObjType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.chanNum = line_id;
+	data.func = SI_RAM_READ;
+	data.ramAddr = cmd;
+	data.ramValue = 0;
+	data.value = 0;
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_REG_CTRL, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_REG_CTRL) failed\n");
+		return -1;
+	}
+
+	*buff = data.ramValue;
+
+	return 0;
+}
+
+int silabs_slic_ram_write(int line_id, uInt16 cmd, unsigned char cmd_len, unsigned int *buff)
+{
+	SilabsRegObjType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.chanNum = line_id;
+	data.func = SI_RAM_WRITE;
+	data.ramAddr = cmd;
+	data.ramValue = buff[0];
+	data.value = 0;
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_REG_CTRL, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_REG_CTRL) failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int silabs_control_interface(ControlFuncType func)
+{
+	SilabsModCtrlObjType data;
+
+	data.func = func;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CTRL_IF, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CTRL_IF) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_device_init(DeviceFuncType func, int devNum)
+{
+	SilabsModDevObjType data;
+
+	data.func = func;
+	data.devNum = devNum;
+			
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_DEVICE_INIT, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_DEVICE_INIT) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+
+int silabs_channel_init(ChannelFuncType func, int chanNum)
+{
+	SilabsModChannelObjType data;
+	
+	data.func = func;
+	data.chanNum = chanNum;
+			
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_INIT, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_INIT) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_channel_all(ChannelAllFuncType func)
+{
+	SilabsModChannelAllObjType data;
+	
+	data.func = func;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_ALL, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_ALL) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_channel_setup(ChannelSetupFuncType func, int chanNum, int preset)
+{
+	SilabsModChannelSetupObjType data;
+	
+	data.chanNum = chanNum;
+	data.func = func;
+	data.preset = preset;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_SETUP, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_SETUP) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_channel_operation(ChannelOPFuncType func, int chanNum)
+{
+	SilabsModChannelOpObjType data;
+	
+	data.func = func;
+	data.chanNum = chanNum;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_OP, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_OP) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_PCM_TS_setup(int chanNum, uInt16 rxcount, uInt16 txcount)
+{
+	SilabsModPCMTSSetupObjType data;
+	
+	data.chanNum = chanNum;
+	data.rxcount = rxcount;
+	data.txcount = txcount;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_PCM_TS_SETUP, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_PCM_TS_SETUP) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_channel_set_line_feed(int chanNum, uInt8 newLineFeed)
+{
+	SilabsModChannelLineFeedObjType data;
+	
+	data.chanNum = chanNum;
+	data.newLineFeed = newLineFeed;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_LINE_FEED, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_LINE_FEED) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int silabs_channel_read_hook_status(int chanNum, uInt8 *pHookStatus)
+{
+	SilabsModChannelReadHookStatObjType data;
+	
+	data.chanNum = chanNum;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_HOOK_STATUS, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_HOOK_STATUS) failed\n");
+		return -1;
+	}
+	
+	*pHookStatus = data.hookStatus;
+
+	return data.status;
+}
+
+int silabs_channel_set_loopback(int chanNum, ProslicLoopbackModes newMode)
+{
+	SilabsModChannelSetLoopbackObjType data;
+	
+	data.chanNum = chanNum;
+	data.newMode = newMode;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, SILABS_MOD_IOX_CHAN_LOOPBACK, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_CHAN_LOOPBACK) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+bool silabs_get_event(SiEventType *event_p)
+{
+	SilabsModGetEventType data;
+	
+	data.pEvent = event_p;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return false;
+	}
+
+	
+	if (ioctl(dev_fd, SILABS_MOD_IOX_GET_EVENT, &data) < 0) {
+		printf("ioctl(SILABS_MOD_IOX_GET_EVENT) failed\n");
+		return false;
+	}
+
+	return data.newEvent;
+}
+
+int silabs_check_event(void)
+{
+	fd_set ex_fds;
+	struct timeval timeout = {0, 1};
+	int ret;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return 1;
+	}
+
+	FD_ZERO(&ex_fds);
+	FD_SET(dev_fd, &ex_fds);
+
+	/* Wait for event  */
+	ret = select(dev_fd+1, NULL, NULL, &ex_fds, &timeout);
+
+	if(FD_ISSET(dev_fd, &ex_fds))
+		return 0;
+	else
+		return 1;
+}
diff --git a/tools/voice/silabs/silabs_lib.h b/tools/voice/silabs/silabs_lib.h
new file mode 100644
index 0000000..6e4ab67
--- /dev/null
+++ b/tools/voice/silabs/silabs_lib.h
@@ -0,0 +1,92 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _SILABS_LIB_H
+#define _SILABS_LIB_H
+
+#include <stdbool.h>
+#include <slic/silabs_dev.h>
+
+int silabs_open_device(void);
+int silabs_close_device(void);
+
+int silabs_slic_reg_read(int line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+int silabs_slic_reg_write(int line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+int silabs_slic_ram_read(int line_id, uInt16 cmd, unsigned char cmd_len, unsigned int *buff);
+int silabs_slic_ram_write(int line_id, uInt16 cmd, unsigned char cmd_len, unsigned int *buff);
+
+int silabs_control_interface(ControlFuncType func);
+int silabs_device_init(DeviceFuncType func, int devNum);
+int silabs_channel_init(ChannelFuncType func, int chanNum);
+int silabs_channel_all(ChannelAllFuncType func);
+int silabs_channel_setup(ChannelSetupFuncType func, int chanNum, int preset);
+int silabs_channel_operation(ChannelOPFuncType func, int chanNum);
+int silabs_PCM_TS_setup(int chanNum, uInt16 rxcount, uInt16 txcount);
+int silabs_channel_set_line_feed(int chanNum, uInt8 newLineFeed);
+int silabs_channel_read_hook_status(int chanNum, uInt8 *pHookStatus);
+int silabs_channel_set_loopback(int chanNum, ProslicLoopbackModes newMode);
+bool silabs_get_event(SiEventType *event_p);
+int silabs_check_event(void);
+
+#endif /* _SILABS_LIB_H */
diff --git a/tools/voice/zarlink/Makefile b/tools/voice/zarlink/Makefile
new file mode 100644
index 0000000..479d4c3
--- /dev/null
+++ b/tools/voice/zarlink/Makefile
@@ -0,0 +1,58 @@
+# kernel sources 
+srctree  := $(shell /bin/pwd)
+
+ifndef KSRC
+KSRC  := $(srctree)/../../..
+endif
+
+include $(KSRC)/.config
+
+CFLAGS  := $(EXTRA_CFLAGS)
+
+ifdef CONFIG_CPU_BIG_ENDIAN
+CFLAGS  += -DCONFIG_CPU_BIG_ENDIAN
+endif
+
+CC := $(CROSS_COMPILE)gcc
+LD := $(CROSS_COMPILE)ld
+AR := $(CROSS_COMPILE)ar
+
+#CFLAGS += -I$(KSRC)/tools/voice/
+
+ifeq ($(CONFIG_ZARLINK_SLIC_SUPPORT),y)
+TARGETS += vpapi_lib.o
+LIBS := libvpapi.a
+TOOL := mv_voice_tool.c
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/zarlink/arch_marvell/
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/
+ifeq ($(CONFIG_ZARLINK_SLIC_VE792),y)
+ CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/zarlink/vp792_api_lib/includes/
+ CFLAGS += -DZARLINK_SLIC_VE792
+ PROFILE = profile_79238.c
+endif
+ifeq ($(CONFIG_ZARLINK_SLIC_VE880),y)
+ CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_hal/voiceband/slic/zarlink/api_lib/includes/
+ CFLAGS += -DZARLINK_SLIC_VE880
+ PROFILE = profile_88266.c
+endif
+
+ifeq ($(CONFIG_MV_TDM_USE_DCO),y)
+ CFLAGS += -DMV_TDM_USE_DCO
+endif
+
+CFLAGS += -I$(KSRC)/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/test/
+
+all:
+	$(CC) $(CFLAGS) -static -c vpapi_lib.c -o $(TARGETS)
+	$(AR) rcs $(LIBS) $(TARGETS)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+mv_voice_tool: $(PROFILE) $(TOOL)
+	$(CC) $(CFLAGS) -static $(PROFILE) $(TOOL) -L. $(LIBS) -o mv_voice_tool
+
+clean:
+	rm -f *.o *.a mv_voice_tool
+	@for subdir in $(SUBDIRS); do \
+                (cd $$subdir && $(MAKE) $@) || exit 1; \
+        done
+endif #CONFIG_ZARLINK_SLIC_SUPPORT
diff --git a/tools/voice/zarlink/mv_voice_tool.c b/tools/voice/zarlink/mv_voice_tool.c
new file mode 100644
index 0000000..d5b7b73
--- /dev/null
+++ b/tools/voice/zarlink/mv_voice_tool.c
@@ -0,0 +1,1388 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+#include "tdm/test/tdm_dev.h"
+
+#include "vpapi_lib.h"
+
+#if defined(ZARLINK_SLIC_VE880)
+/* Zarlink VE880 */
+#include "profile_88266.h"
+#define MAX_DEVICES		2
+#define MAX_DEVICE_LINES	2
+#define MAX_LINES		4
+#define VP_DEV_SERIES		VP_DEV_880_SERIES
+#define DEV_PROFILE		ABS_VBL_FLYBACK
+#define DC_COEFF		DC_22MA_CC
+#define AC_COEFF		AC_FXS_RF14_DEF
+#define WB_AC_COEFF		AC_FXS_RF14_WB_US
+#define RING_PROFILE		RING_DEF
+
+#elif defined(ZARLINK_SLIC_VE792)
+/* Zarlink VE792 */
+#include "profile_79238.h"
+#define MAX_DEVICES		4
+#define MAX_DEVICE_LINES	8
+#define MAX_LINES		32
+#define VP_DEV_SERIES		VP_DEV_792_SERIES
+#define DEV_PROFILE		VE792_DEV_PROFILE
+#define DC_COEFF		VE792_DC_COEFF
+#define AC_COEFF		VE792_AC_COEFF_600
+#define WB_AC_COEFF		TBD /* TBD: AC profile for WideBand support */
+#define RING_PROFILE		RING_20HZ_SINE
+
+/* Power-supply related parameters */
+#define VBH			-50
+#define VBL			-25
+#define VBP			50
+#endif
+
+#define TOOL_PREFIX		">> "
+#define TIMEOUT			11000 /* usec */
+/* Line calibration increases init time significantly */
+#define LINE_CALIBRATION_SUPPORT
+
+/* Defines */
+#define GET_DEVICE(line_id)	(line_id/MAX_DEVICE_LINES)
+#define GET_LINE(line_id)	(line_id % MAX_DEVICE_LINES)
+#define N_A			0
+#define ON_HOOK			0
+#define OFF_HOOK		1
+#define CH_BUFF_SIZE		(80 * pcm_bytes)
+#define BUFF_ADDR(buff, line)	((unsigned char*)buff + (line*80*pcm_bytes))
+
+/* Extern */
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/* GLobals */
+static unsigned short total_lines = 0;
+static unsigned short total_devs = 0;
+static unsigned char pcm_bytes = 0;
+static unsigned char cal_devs = 0;
+#ifdef LINE_CALIBRATION_SUPPORT
+static unsigned short cal_lines = 0;
+#endif
+static VpOptionCodecType codec = VP_OPTION_ALAW;
+static unsigned char time_slot_table[MAX_LINES];
+static unsigned char hook_state[MAX_LINES];
+static char dev_name[] = "/dev/tdm";
+static int buff_size = 0;
+static unsigned char aud_buf[2][320 * MAX_LINES];
+static unsigned short f1Mem = 0;
+static unsigned short f2Mem = 0;
+static int offhook_count = 0;
+static unsigned int event_count = 0;
+static int tdm_fd = 0;
+static unsigned char data_buff[MAX_SLIC_RDWR_BUFF_SIZE];
+static int slic_init = 0;
+
+/* sin table, 256 points */
+static short sinTbl[] = {0,402,804,1205,1606,2005,2404,2801,3196,3590,3981,4370,4756,
+5139,5519,5896,6270,6639,7005,7366,7723,8075,8423,8765,9102,9433,9759,10079,10393,
+10701,11002,11297,11585,11865,12139,12405,12664,12915,13159,13394,13622,13841,14052,
+14255,14449,14634,14810,14977,15136,15285,15425,15556,15678,15790,15892,15985,16068,
+16142,16206,16260,16304,16339,16363,16378,16383,16378,16363,16339,16304,16260,16206,
+16142,16068,15985,15892,15790,15678,15556,15425,15285,15136,14977,14810,14634,14449,
+14255,14052,13841,13622,13394,13159,12915,12664,12405,12139,11865,11585,11297,11002,
+10701,10393,10079,9759,9433,9102,8765,8423,8075,7723,7366,7005,6639,6270,5896,5519,
+5139,4756,4370,3981,3590,3196,2801,2404,2005,1606,1205,804,402,0,-402,-804,-1205,-1606,
+-2005,-2404,-2801,-3196,-3590,-3981,-4370,-4756,-5139,-5519,-5896,-6270,-6639,-7005,
+-7366,-7723,-8075,-8423,-8765,-9102,-9433,-9759,-10079,-10393,-10701,-11002,-11297,
+-11585,-11865,-12139,-12405,-12664,-12915,-13159,-13394,-13622,-13841,-14052,-14255,
+-14449,-14634,-14810,-14977,-15136,-15285,-15425,-15556,-15678,-15790,-15892,-15985,
+-16068,-16142,-16206,-16260,-16304,-16339,-16363,-16378,-16383,-16378,-16363,-16339,
+-16304,-16260,-16206,-16142,-16068,-15985,-15892,-15790,-15678,-15556,-15425,-15285,
+-15136,-14977,-14810,-14634,-14449,-14255,-14052,-13841,-13622,-13394,-13159,-12915,
+-12664,-12405,-12139,-11865,-11585,-11297,-11002,-10701,-10393,-10079,-9759,-9433,-9102,
+-8765,-8423,-8075,-7723,-7366,-7005,-6639,-6270,-5896,-5519,-5139,-4756,-4370,-3981,
+-3590,-3196,-2801,-2404,-2005,-1606,-1205,-804,-402,0};
+
+/* Static APIs */
+static void vpapi_dev_init(VpDeviceIdType dev_id);
+static inline void wait_for_vpapi_event(void);
+static int vpapi_init(void);
+static void vpapi_init_done(void);
+static void vpapi_release(void);
+static void release(int signum);
+static void sw_tone_test(int tdm_fd, unsigned char line_id);
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff);
+static void sw_loopback(int tdm_fd, unsigned char line_id);
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1);
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations);
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line);
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations);
+static inline int slic_dl_data_compare(int offset);
+#if defined(MV_TDM_USE_DCO)
+static void set_tdm_clk_config(void);
+static int get_tdm_clk_correction(void);
+static void set_tdm_clk_correction(int correction);
+#endif
+
+int main(void)
+{
+	int ret = 0, cmd = 0, val = 0, tdm_init = 0;
+	int proc_fd, fdflags, cmd_len, i;
+	char str[32];
+	unsigned char line0_id, line1_id;
+	tdm_dev_params_t tdm_params;
+	unsigned long int iterations;
+
+	event_count = 0;
+	slic_init = 0;
+
+	/* open tdm device */
+	tdm_fd = open(dev_name, O_RDWR); 
+	if (tdm_fd <= 0) {
+		printf("%s Cannot open %s device\n", TOOL_PREFIX, dev_name);
+		return 1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(tdm_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(tdm_fd, F_SETFL, fdflags);
+
+	printf("\n%s Please enter total lines number: ", TOOL_PREFIX);
+	gets(str);
+	total_lines = atoi(str);
+
+	printf("%s Please enter PCM sample size(1/2/4): ",TOOL_PREFIX);
+	gets(str);
+	pcm_bytes = atoi(str);
+
+	/* Calculate total lines buffer size */
+	buff_size = (80 * pcm_bytes * total_lines);
+
+	/* Fill TDM info */
+	tdm_params.pcm_format = pcm_bytes;
+	tdm_params.total_lines = total_lines;
+	
+	total_devs = (total_lines/MAX_DEVICE_LINES);
+	if((total_lines % MAX_DEVICE_LINES))
+		total_devs++;
+
+	/* Handle termination gracefully */
+	if (signal (SIGINT, release) == SIG_IGN)
+		signal (SIGINT, SIG_IGN);
+
+	printf("\n !!! Remember to start phone devices before performing any action !!!\n", TOOL_PREFIX);
+
+	/* Issue main menu */
+	while(1) {
+		printf("\n  Marvell Voice Tool (Zarlink/Ligerity Edition):\n");
+		printf("  0. Read from SLIC register (VE880 only)\n");
+		printf("  1. Write to SLIC register (VE880 only)\n");
+		printf("  2. Start ring\n");
+		printf("  3. Stop ring\n");
+		printf("  4. Start SW Dial tone\n");
+		printf("  5. Self echo on local phone\n");
+		printf("  6. Loopback two local phones\n");
+		printf("  7. Multiple local phone pairs loopback\n");
+		printf("  8. Digital Loopback (incremental pattern)\n");
+		printf("  9. Channel balancing\n");
+		printf("  a. Start Phone devices\n");
+		printf("  b. Stop Phone devices\n");
+#if defined(MV_TDM_USE_DCO)
+		printf("  c. Config TDM PCLK\n");
+		printf("  d. Get current TDM PCLK frequency correction (DCO)\n");
+		printf("  e. Set TDM PCLK frequency correction (DCO)\n");
+#endif
+		printf("  q. Quit\n");
+		printf("\n%s Please select option: ", TOOL_PREFIX);
+
+		/* Clear write buffer */
+		memset(aud_buf[1], 0, buff_size);
+		gets(str);
+		switch(str[0]) {
+			case '0':
+#if defined(ZARLINK_SLIC_VE880)
+				printf("%s Enter line id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register command(decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				printf("%s Enter SLIC register command size: ",TOOL_PREFIX);
+				gets(str);
+				cmd_len = atoi(str);
+				vpapi_slic_reg_read(line0_id, cmd, cmd_len, data_buff);
+				printf("\n%s Sent command 0x%x to line(%d)\n", TOOL_PREFIX, cmd, line0_id);
+				printf("%s Return value: ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++)
+					printf("0x%x ", data_buff[i]);
+				printf("\n");
+#else
+				printf("%s operation not supported\n",TOOL_PREFIX);
+#endif
+				break;
+
+			case '1':
+#if defined(ZARLINK_SLIC_VE880)
+				printf("%s Enter line id: ",TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter SLIC register command(decimal): ",TOOL_PREFIX);
+				gets(str);
+				cmd = atoi(str);
+				printf("%s Enter SLIC register command size: ",TOOL_PREFIX);
+				gets(str);
+				cmd_len = atoi(str);
+				printf("%s Enter data(press Enter after each byte): ",TOOL_PREFIX);
+				for(i = 0; i < cmd_len; i++) {
+					gets(str);
+					data_buff[i] = atoi(str);
+				}
+				vpapi_slic_reg_write(line0_id, cmd, cmd_len, data_buff);
+				printf("\n%s Sent command 0x%x to line(%d)\n", TOOL_PREFIX, cmd, line0_id);
+#else
+				printf("%s operation not supported\n",TOOL_PREFIX);
+#endif
+				break;
+
+			case '2':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Start ringing on line %d\n", line0_id);
+				vpapi_set_line_state(line0_id, VP_LINE_RINGING);
+				break;
+
+			case '3':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("Stop ringing on line %d\n", line0_id);
+				vpapi_set_line_state(line0_id, VP_LINE_STANDBY);
+				break;
+
+			case '4':
+				if(pcm_bytes < 2) {
+					printf("Test is supported for linear mode only - try again\n");
+					break;
+				}
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				sw_tone_test(tdm_fd, line0_id);
+				break;
+
+			case '5':
+				printf("%s Enter line id: ", TOOL_PREFIX);
+				gets(str);
+				printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+				line0_id = atoi(str);
+				sw_loopback(tdm_fd, line0_id);
+				break;
+
+			case '6':
+				printf("%s Enter line #0: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter line #1: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if(line0_id >= MAX_LINES || line1_id >= MAX_LINES) {
+					printf("%s Error, line must be in the range of 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_two_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case '7':
+				printf("%s Enter starting line range: ", TOOL_PREFIX);
+				gets(str);
+				line0_id = atoi(str);
+				printf("%s Enter ending line range: ", TOOL_PREFIX);
+				gets(str);
+				printf("Waiting for off-hook...\n");
+				line1_id = atoi(str);
+				if((line0_id >= MAX_LINES) || (line1_id >= MAX_LINES) || ((line1_id-line0_id) % 2 == 0)) {
+					printf("%s Error, lines range must be even and \
+						between 0-%d\n", TOOL_PREFIX, (MAX_LINES-1));
+					break;
+				}
+				sw_loopback_multi_phones_test(tdm_fd, line0_id, line1_id);
+				break;
+
+			case '8':
+				printf("%s Enter number of iterations(must be greater than 3): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				if(iterations < 4) {
+					printf("Requires at least 4 iterations  - try again\n");
+					break;
+				}
+				slic_digital_loopback(tdm_fd, iterations);
+				break;
+
+			case '9':
+				printf("%s Enter number of iterations('0' - for infinite loop): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				channel_balancing_test(tdm_fd, iterations);
+				break;
+
+			case 'a':
+				/* Start Telephony */
+				if(ioctl(tdm_fd, TDM_DEV_TDM_START, &tdm_params)) {
+					printf("%s Error, unable to init TDM\n", TOOL_PREFIX);
+					return 1;
+				}
+
+				if(vpapi_open_device()) {
+					printf("%s Error, could not open vpapi device\n", TOOL_PREFIX);
+					return 1;
+				}
+
+				if(vpapi_init()) {
+					printf("%s Error, init failed\n", TOOL_PREFIX);
+					ret = 1;
+					goto voice_out;
+				}
+				slic_init = 1;
+
+				/* Wait to device/s and line/s calibration to finish */
+#ifdef LINE_CALIBRATION_SUPPORT
+				while((cal_devs < total_devs) || (cal_lines < total_lines)) {
+#else
+				while(cal_devs < total_devs) {
+#endif
+					wait_for_vpapi_event();
+				}
+				break;
+
+			case 'b':
+				/* Stop Telephony */
+				release(0);
+				break;
+
+#if defined(MV_TDM_USE_DCO)
+			case 'c':
+				set_tdm_clk_config();
+				break;
+			
+			case 'd':
+				printf("%s Current PPM correction is (+/-1000): %d", TOOL_PREFIX, get_tdm_clk_correction());
+				break;
+
+			case 'e':
+				printf("%s Enter number of PPM for correction (+/-1000, 0 to disable correction): ", TOOL_PREFIX);
+				gets(str);
+				set_tdm_clk_correction((int)atoi(str));
+				break;
+#endif
+			
+			case 'q':
+				goto voice_out;
+
+			default:
+				printf("Option is not supported - try again\n");
+				break;
+		}
+	}
+
+voice_out:
+	release(1);
+
+	return ret;
+}
+
+void release(int signum)
+{
+	if (signum) {
+		printf("\n%s Stopping Phone devices and exit\n", TOOL_PREFIX);
+		sleep(1);
+	} else {
+		printf("\n%s Stopping Phone devices\n", TOOL_PREFIX);
+	}
+
+	/* Stop SLIC/s */
+	if(slic_init) {
+		printf("\n%s Stopping SLIC\n", TOOL_PREFIX);
+		vpapi_release();
+		printf("\n%s Stopped SLIC\n", TOOL_PREFIX);
+		slic_init = 0;
+	} else {
+		printf("\n%s SLIC already stopped\n", TOOL_PREFIX);
+	}
+
+	/* Stop TDM */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_STOP, 0)) {
+		printf("\n%s Error, unable to stop TDM\n", TOOL_PREFIX);
+		return;
+	} else {
+		printf("\n%s TDM stopped\n", TOOL_PREFIX);
+	}
+
+	if (signum)
+		close(tdm_fd);
+
+	if(vpapi_close_device()) {
+		printf("\n%s Error, could not close SLIC device ##\n", TOOL_PREFIX);
+		return;
+	} else {
+		printf("\n%s SLIC device closed\n", TOOL_PREFIX);
+	}
+
+	if (signum)
+		exit(signum);
+}
+
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch, cb_loop = 0, i;
+	unsigned long int loops = 0, index;
+	VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index+=2)
+			*((unsigned short*)&aud_buf[1][(80 * pcm_bytes * ch) + index]) = (((index+3) << 8)+ (index+1));
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_TALK);
+
+	/* Wait a bit */
+	sleep(1);
+
+	if (iterations == 0)
+		iterations = (unsigned long int)(-1); /* Assume infinite */
+
+	while (loops < iterations) {
+		cb_loop = 0;
+		i = 0;
+
+		if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		while (cb_loop == 0) {
+			FD_ZERO(&rd_fds);
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &rd_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				goto cb_out;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds)) {
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len < buff_size) {
+					printf("write() failed\n");
+					goto cb_out;
+				}
+			}
+
+			/* Read */
+			if (FD_ISSET(tdm_fd, &rd_fds)) {
+				memset(aud_buf[0], 0, buff_size);
+				msg_len = read(tdm_fd, aud_buf[0], buff_size);
+				if (msg_len < buff_size) {
+					printf("read() failed\n");
+					goto cb_out;
+				}
+
+				if(i > 3) {
+					for(ch = 1; ch < total_lines; ch++) {
+						if(memcmp(aud_buf[0], &aud_buf[0][(ch * pcm_bytes * 80)], (pcm_bytes * 80))) {
+							printf("\nERROR - data miscompare(ch=%d) !!!\n", ch);
+							cmp_status = 1;
+							goto cb_out;
+						}
+					}
+
+					cb_loop = 1;
+				}
+				i++;
+			}
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+
+		loops++;
+		if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+			printf("Error, unable to stop pcm bus\n");
+			return;
+		}
+		printf("loop #%u\n", loops);
+		sleep(1);
+	}
+
+cb_out:
+	if(cmp_status == 0) {
+		printf("\nChannel balancing test PASSED !!!\n");
+	} else {
+		printf("Dump Rx buffer:\n");
+		for(ch = 0; ch < total_lines; ch++) {
+			printf("Buffer #%d: ", ch);
+			for(i = 0; i < (pcm_bytes * 80); i++) {
+				printf("0x%x ", aud_buf[0][(ch * pcm_bytes * 80) + i]);
+			}
+			printf("\n\n");
+			sleep(1);
+		}
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	lp = VP_OPTION_LB_OFF;
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_STANDBY);
+}
+
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch;
+	unsigned long int loops = 0, index;
+	VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_TALK);
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index++)
+			aud_buf[1][index + (80 * pcm_bytes * ch)] = (index+ch+2);
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while (loops < iterations) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			goto slic_dl_out;
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len < buff_size) {
+				printf("write() failed\n");
+				goto slic_dl_out;
+			}
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			memset(aud_buf[0], 0, buff_size);
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len < buff_size) {
+				printf("read() failed\n");
+				goto slic_dl_out;
+			}
+
+			if(loops++ > 3) {
+				for(ch = 0; ch < total_lines; ch++) {
+					if(slic_dl_data_compare(ch)) {
+						printf("\nERROR - data miscompare(loops=%d) !!!\n",loops);
+						cmp_status = 1;
+						goto slic_dl_out;
+					}
+				}
+			}
+		}
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+slic_dl_out:
+	if(cmp_status == 0)
+		printf("\nDigital loopback test(%d lines) - PASS !!!\n",total_lines);
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	lp = VP_OPTION_LB_OFF;
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_option(1, ch, GET_DEVICE(ch), VP_OPTION_ID_LOOPBACK, &lp);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		vpapi_set_line_state(ch, VP_LINE_STANDBY);
+}
+
+static inline int slic_dl_data_compare(int ch)
+{
+	int i = 0, offset = (ch * pcm_bytes * 80);
+
+	/* Align Tx & Rx data start */
+	while((aud_buf[1][offset] != aud_buf[0][offset+i]) && (i < (pcm_bytes * 80)))
+		i++;
+
+	if(i >= (offset + (pcm_bytes * 80))) {
+		printf("\nError, first Tx byte not found inside Rx buffer\n");
+		return -1;
+	}
+
+	if(memcmp(&aud_buf[0][offset+i], &aud_buf[1][offset], ((pcm_bytes * 80) - i))) {
+		printf("\nDump buffers:\n");
+		for(i = offset; i < (offset +(pcm_bytes * 80)); i++)
+			printf("write[%d] = 0x%x, read[%d] = 0x%x\n", i, aud_buf[1][i], i, aud_buf[0][i]);
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+static void sw_loopback(int tdm_fd, unsigned char line_id)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until line goes off-hook */
+	while(hook_state[line_id] == 0) {
+		wait_for_vpapi_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(hook_state[line_id] == 1) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			printf("Rd\n");
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			printf("Wr\n");
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char* tx_buff)
+{
+	short i;
+	short buf[80];
+	short sample;
+
+	for(i = 0; i < 80; i++) {
+		sample = (sinTbl[f1Mem >> 8] + sinTbl[f2Mem >> 8]) >> 2;
+#ifndef CONFIG_CPU_BIG_ENDIAN 
+		buf[i] = sample;
+#else
+		buf[i] = ((sample & 0xff) << 8)+ (sample >> 8);
+#endif
+		f1Mem += freq;
+		f2Mem += freq;
+	}
+	memcpy(BUFF_ADDR(tx_buff, line_id), (void *)buf, 160);
+}
+
+static void sw_tone_test(int tdm_fd, unsigned char line_id)
+{
+	fd_set wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, x;
+	char str[4];
+
+	if (tdm_fd <= 0) {
+		printf("%s Device %s is not accessible\n", TOOL_PREFIX, dev_name);
+		return;
+	}
+
+	while(1) {
+		printf("%s Choose frequency: (1) 300HZ (2) 630HZ (3) 1000HZ (4) Back to main menu: ", TOOL_PREFIX);
+		gets(str);
+		printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+
+		if(str[0] == '1') {
+			x = 2457;
+			//printf("%s Generating 300HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '2') {
+			x = 5161;
+			//printf("%s Generating 630HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '3') {
+			x = 8192;
+			//printf("%s Generating 1000HZ tone\n", TOOL_PREFIX);
+		}
+		else if (str[0] == '4') {
+			return;
+		}
+		else {
+			printf("%s Input error - try again\n", TOOL_PREFIX);
+			continue;
+		}
+
+		/* Wait until both lines go off-hook */
+		while(hook_state[line_id] == 0) {
+			wait_for_vpapi_event();
+		}
+
+		if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		printf("%s Waiting for on-hook to return to menu.\n", TOOL_PREFIX);
+
+		while(hook_state[line_id] == 1) {
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, NULL, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds)) {
+				gen_tone(x, line_id, aud_buf[1]);
+				if (pcm_bytes == 4)
+					gen_tone(x, line_id, (aud_buf[1]+160));
+
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len <= 0) {
+					printf("write() failed\n");
+					return;
+				}
+			}
+
+			/* Check hook state */
+			wait_for_vpapi_event();
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+	}
+}
+
+static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+	unsigned char line_id;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until at least one line goes off-hook */
+	while(offhook_count == 0) {
+		wait_for_vpapi_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while(offhook_count) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+
+			for(line_id = start_line; line_id < end_line; line_id+=2) {
+				memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], (line_id+1)), CH_BUFF_SIZE);
+				memcpy(BUFF_ADDR(aud_buf[1], (line_id+1)), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+			}
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Wait until both lines go off-hook */
+	while((hook_state[line0] == 0) || (hook_state[line1] == 0)) {
+		wait_for_vpapi_event();
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while((hook_state[line0] == 1) && (hook_state[line1] == 1)) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line0), BUFF_ADDR(aud_buf[0], line1), CH_BUFF_SIZE);
+			memcpy(BUFF_ADDR(aud_buf[1], line1), BUFF_ADDR(aud_buf[0], line0), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_vpapi_event();
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if(ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static int vpapi_init(void)
+{
+	int i = 0;
+	VpDeviceIdType dev_id = 0;
+	VpLineIdType line_id = 0;
+	VpStatusType status;
+	vpapi_init_device_params_t params;
+
+	/* Check params */
+	if(total_lines > MAX_LINES) {
+		printf("## Error, total number of lines(%d) exceeded maximum(%d) ##\n", total_lines, MAX_LINES);
+		return -1;
+	}
+
+	/* Set lines status to on-hook */
+	memset(hook_state, 0, MAX_LINES);
+
+	cal_devs = 0;
+#ifdef LINE_CALIBRATION_SUPPORT
+	cal_lines = 0;
+#endif
+	/* Fill time slot table */
+	memset(time_slot_table, 0, MAX_LINES);
+	for(i = 0; i < total_lines; i++)
+		time_slot_table[i] = ((i+1) * pcm_bytes); /* skip slot #0 */
+
+	/* Extract PCM format */
+	switch(pcm_bytes) {
+		case 1:
+			codec = VP_OPTION_ALAW;
+			break;
+		case 2:
+			codec = VP_OPTION_LINEAR;
+			break;
+		case 4:
+			codec = VP_OPTION_WIDEBAND;
+			break;
+		default:
+			codec = VP_OPTION_ALAW;
+			printf("## Warning, wrong PCM size - set to default(ALAW) ##\n");
+			break;
+	}
+
+#if defined(ZARLINK_SLIC_VE792)
+	/* Bring up the power supply */
+	if(vpapi_battary_on(VBH, VBL, VBP)) {
+		printf("## Error, VE792 power supply could not initialized properly ##\n");
+		return -1;
+	}
+#endif
+	/* Create max device objects */
+	for(dev_id = 0; dev_id < total_devs; dev_id++) {
+		status = vpapi_make_dev_object(VP_DEV_SERIES, dev_id);
+		if (status != VP_STATUS_SUCCESS) {
+			printf("## Error, device %d could not initialized properly(status=%d) ##\n", dev_id, status);
+			return -1;
+		}
+
+#if defined(ZARLINK_SLIC_VE792)
+		status = vpapi_map_slac_id(dev_id, 0);
+		if (status != VP_STATUS_SUCCESS) {
+			printf("## Error, SLAC %d could not be mapped(status=%d) ##\n", dev_id, status);
+			return -1;
+		}
+#endif
+		/* Create requested channels for each device */
+		while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+			status = vpapi_make_line_object(VP_TERM_FXS_GENERIC, line_id);
+			if (status != VP_STATUS_SUCCESS) {
+				printf("## Error, line %d of device %d could not initialized \
+					roperly(status=%d) ##\n", line_id, dev_id, status);
+				return -1;
+			}
+
+			/* Map unique LineId to LineCtx */
+			status = vpapi_map_line_id(line_id);
+
+			if (status != VP_STATUS_SUCCESS) {
+				printf("## Error, line %d for device %d could not \
+					mapped(status=%d) ##\n", line_id, dev_id, status);
+				return -1;
+			}
+			line_id++;
+		}
+
+		params.dev_size = dev_profile_size;
+		params.ac_size = ac_profile_size;
+		params.dc_size = dc_profile_size;
+		params.ring_size = ring_profile_size;
+		params.fxo_ac_size = 0;
+		params.fxo_cfg_size = 0;
+
+		if (pcm_bytes < 4)
+			status = vpapi_init_device(dev_id, DEV_PROFILE, AC_COEFF, DC_COEFF, RING_PROFILE, NULL, NULL, &params);
+		else
+			status = vpapi_init_device(dev_id, DEV_PROFILE, WB_AC_COEFF, DC_COEFF, RING_PROFILE, NULL, NULL, &params);
+
+		if (status != VP_STATUS_SUCCESS) {
+			printf("## Error, device(%d) init failed(status=%d)\n", dev_id, status);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static inline void wait_for_vpapi_event(void)
+{
+	bool status;
+	VpEventType event;
+	VpDeviceIdType dev_id;
+
+	for(dev_id = 0; dev_id < total_devs ; dev_id++) {
+		while(vpapi_get_event(dev_id, &event) == true) {
+			switch(event.eventCategory) {
+				case VP_EVCAT_SIGNALING:
+					switch(event.eventId) {
+						case VP_LINE_EVID_HOOK_OFF:
+							if(cal_devs == total_devs) {
+								printf("off-hook(%d)\n", event.lineId);
+								hook_state[event.lineId] = 1;
+								offhook_count++;
+								vpapi_set_line_state(event.lineId, VP_LINE_TALK);
+							}
+							break;
+
+						case VP_LINE_EVID_HOOK_ON:
+							if(cal_devs == total_devs) {
+								printf("on-hook(%d)\n", event.lineId);
+								hook_state[event.lineId] = 0;
+								offhook_count--;
+								vpapi_set_line_state(event.lineId, VP_LINE_STANDBY);
+							}
+							break;
+
+						default:
+							/*printf("Unknown SIGNALING event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);*/
+							break;
+					}
+					break;
+
+				case VP_EVCAT_RESPONSE:
+					switch(event.eventId) {
+						case VP_DEV_EVID_DEV_INIT_CMP:
+							printf("Zarlink telephony device(%d) initialized successfully\n", event.deviceId);
+							vpapi_dev_init(event.deviceId);
+							cal_devs++;
+							break;
+
+						case VP_EVID_CAL_CMP:
+#ifdef LINE_CALIBRATION_SUPPORT
+							cal_lines++;
+							if(cal_lines == total_lines) {
+								/*VpOptionLoopbackType lp = VP_OPTION_LB_TIMESLOT;
+								vpapi_set_option(1, 0, 0, VP_OPTION_ID_LOOPBACK, &lp); */
+								printf("Zarlink telephony lines(%d) calibrated successfully\n", total_lines);
+								vpapi_init_done();
+							}
+#endif
+							break;
+
+						default:
+							/*printf("Unknown RESPONSE event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);*/
+							break;
+					}
+					break;
+
+				case VP_EVCAT_FAULT:
+					printf("Got FAULT event[id-0x%x][lineId-%d]\n",event.eventId, event.lineId);
+					break;
+
+				default:
+					printf("Got event[category-0x%x][id-%d]\n",event.eventCategory,event.eventId);
+					break;
+			}
+		}
+	}
+}
+
+static void vpapi_init_done(void)
+{
+	VpStatusType status;
+	VpDeviceIdType dev_id;
+	VpLineIdType line_id, base_line_id;
+
+	for (dev_id = 0; dev_id < total_devs; dev_id++) {
+		base_line_id = (dev_id * MAX_DEVICE_LINES);
+		for (line_id = base_line_id; line_id < (base_line_id + MAX_DEVICE_LINES); line_id++) {
+			/* Set CODEC options */
+			status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_CODEC, &codec);
+			if(status != VP_STATUS_SUCCESS) {
+				printf("## Error setting VP_OPTION_ID_CODEC (%d) ##\n", status);
+				return;
+			}
+		}
+	}
+
+	return;
+}
+
+static void vpapi_dev_init(VpDeviceIdType dev_id)
+{
+	VpOptionEventMaskType event_mask;
+	VpStatusType status;
+	VpOptionTimeslotType time_slot;
+	VpLineIdType line_id;
+
+	/* Clear all events */
+	memset(&event_mask, 0xff, sizeof(VpOptionEventMaskType));
+
+	event_mask.faults = (unsigned short)VP_EVCAT_FAULT_UNMASK_ALL;
+	event_mask.signaling = (unsigned short)(~(VP_LINE_EVID_HOOK_OFF | VP_LINE_EVID_HOOK_ON));
+#ifdef LINE_CALIBRATION_SUPPORT
+	event_mask.response = (unsigned short)(~VP_EVID_CAL_CMP);
+#endif
+	status = vpapi_set_option(0, N_A, dev_id, VP_OPTION_ID_EVENT_MASK, &event_mask);
+	if(status != VP_STATUS_SUCCESS) {
+		printf("## Error while setting VP_OPTION_ID_EVENT_MASK (%d) ##\n", status);
+		return;
+	}
+
+	line_id = (dev_id * MAX_DEVICE_LINES);
+	while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+		vpapi_set_line_state(line_id, VP_LINE_STANDBY);
+
+		/* Configure PCM timeslots */
+		time_slot.tx = time_slot.rx = time_slot_table[line_id];
+
+		/*printf("## INFO: line(%d): rx-slot(%d) , tx-slot(%d) ##\n", line_id, time_slot.rx, time_slot.tx);*/
+
+		status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_TIMESLOT, &time_slot);
+		if(status != VP_STATUS_SUCCESS) {
+			printf("## Error setting VP_OPTION_ID_TIMESLOT (%d) ##\n", status);
+			return;
+		}
+#if 0
+		/* Set CODEC options */
+		status = vpapi_set_option(1, line_id, dev_id, VP_OPTION_ID_CODEC, &codec);
+		if(status != VP_STATUS_SUCCESS) {
+			printf("## Error setting VP_OPTION_ID_CODEC (%d) ##\n", status);
+			return;
+		}
+#endif		
+#ifdef LINE_CALIBRATION_SUPPORT	
+		/* Start line calibration */
+		vpapi_cal_line(line_id);
+#endif
+		line_id++;
+	}
+}
+
+static void vpapi_release(void)
+{
+	VpDeviceIdType dev_id = 0;
+	VpLineIdType line_id = 0;
+	VpOptionEventMaskType event_mask;
+	VpStatusType status;
+
+
+	/* Clear all events */
+	memset(&event_mask, 0xff, sizeof(VpOptionEventMaskType));
+
+	for(dev_id = 0; dev_id < total_devs; dev_id++) {
+		/* Mask all interrupts */
+		status = vpapi_set_option(0, N_A, dev_id, VP_OPTION_ID_EVENT_MASK, &event_mask);
+
+		if(status != VP_STATUS_SUCCESS) {
+			printf("Error while setting VP_OPTION_ID_EVENT_MASK (%d)\n", status);
+			continue;
+		}
+
+		while((line_id < ((dev_id+1)*MAX_DEVICE_LINES)) && (line_id < total_lines)) {
+			/* Place each line in DISCONNECT state */
+			vpapi_set_line_state(line_id, VP_LINE_DISCONNECT);
+
+			/* Free line context */
+			status = vpapi_free_line_context(line_id);
+			if(status != VP_STATUS_SUCCESS) {
+				printf("Error while free line %d context\n", line_id);
+				continue;
+			}
+			line_id++;
+		}
+	}
+#if defined(ZARLINK_SLIC_VE792)
+	/* Shut down the power supply */
+	if(vpapi_battery_off()) {
+		printf("## Error while shutting down VE792 power supply ##\n");
+		sleep(1);
+	}
+#endif
+}
+
+#if defined(MV_TDM_USE_DCO)
+static void set_tdm_clk_config(void)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	/* Config TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_CONFIG, &tdm_dev_clk)) {
+		printf("%s Error, unable to config TDM clock.\n", TOOL_PREFIX);
+	}
+}
+
+static int get_tdm_clk_correction(void)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	/* Get TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_GET, &tdm_dev_clk)) {
+		printf("%s Error, unable to get TDM clock.\n", TOOL_PREFIX);
+		return 0;
+	}
+
+	return tdm_dev_clk.correction;
+}
+
+static void set_tdm_clk_correction(int correction)
+{
+	tdm_dev_clk_t tdm_dev_clk;
+
+	tdm_dev_clk.correction=correction;
+
+	/* Set TDM clock */
+	if(ioctl(tdm_fd, TDM_DEV_TDM_CLK_SET, &tdm_dev_clk)) {
+		printf("%s Error, unable to set TDM clock.\n", TOOL_PREFIX);
+	}
+}
+#endif
diff --git a/tools/voice/zarlink/mv_voice_tool.h b/tools/voice/zarlink/mv_voice_tool.h
new file mode 100644
index 0000000..f3e4abb
--- /dev/null
+++ b/tools/voice/zarlink/mv_voice_tool.h
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef _MVZARLINKIF_H_
+#define _MVZARLINKIF_H_
+
+#include "mvSysTdmConfig.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+MV_STATUS mvZarlinkIfInit(MV_U16 totalSLICs, MV_U16 pSlotInfo[][2], 
+				MV_BAND_MODE bandMode, MV_PCM_FORMAT pcmFormat);
+MV_STATUS mvZarlinkIfTimerTick(MV_SLIC_EVENT_INFO* slic_event_info);
+MV_VOID mvZarlinkIfISR(MV_U8 deviceId);
+MV_VOID mvZarlinkIfActivateRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfStopRinging(MV_U16 lineId);
+MV_VOID mvZarlinkIfHookStateGet(MV_U16 lineId, MV_U8* hookstate);
+MV_VOID mvZarlinkIfLinefeedControlSet(MV_U16 lineId, MV_LINEFEED_STATE lfState);
+MV_VOID mvZarlinkIfLinefeedControlGet(MV_U16 lineId, MV_LINEFEED_STATE* lfState);
+MV_VOID mvZarlinkIfReverseDcPolarity(MV_U16 lineId);
+MV_VOID mvZarlinkIfRelease(MV_VOID);
+MV_VOID mvZarlinkIfRegRead(MV_U8 lineId, MV_U8 cmd, MV_U8 cmdLen,MV_U8* dataBuff);
+
+#endif /* _MVZARLINKIF_H_ */
diff --git a/tools/voice/zarlink/profile_79238.c b/tools/voice/zarlink/profile_79238.c
new file mode 100644
index 0000000..a42477d
--- /dev/null
+++ b/tools/voice/zarlink/profile_79238.c
@@ -0,0 +1,1248 @@
+/*
+ * profile_79238.c --
+ *
+ * This file contains profile data in byte format
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\profile_792\792.vpw
+ *   Type:  VCP2-792 Project (Line Module Le51HR0128)
+ *   Date:  Wednesday, June 30, 2010 14:29:56
+ *
+ *   This file was generated with Profile Wizard Version: P1.14.1
+ */
+
+#include "profile_79238.h"
+
+/*** Device_Parameters for VE792 Device Family ***/
+const VpProfileDataType VE792_DEV_PROFILE[] =
+{
+    /* Device Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0xFF,       /* 0xFF = device profile */
+        /* number of sections */    0x02,
+        /* content length */        0x24,        /* (2 + 5) + (2 + 27)      */
+    /* Section 0 ----------------------------------------------(PRE-BOOT)-- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x05,
+        /* Access 0 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x0B,       /* CLK_CFG register */
+            /* length */            0x01,
+            /* data */              0x00, 0x0A, /* PCLK = 8192 KHz */
+    /* Section 1 ---------------------------------------------(POST-BOOT)-- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x1B,       /* 5 + 11 + 11 */
+        /* Access 0 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x09,       /* PCM_CFG register */
+            /* length */            0x01,
+            /* data */              0x00, 0x40, /* Pos. edge, RCS 0, TCS 0 */
+        /* Access 1 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x32,       /* HBAT_ADJ + TBAT register */
+            /* length */            0x04,
+            /* data */              0x00, 0x00, /* HBAT_ADJ = 0 V */
+            /* data */              0xEC, 0xCD, /* THBAT = -30 V */
+            /* data */              0xF6, 0x66, /* TLBAT = -15 V */
+            /* data */              0x13, 0x33, /* TPBAT = 30 V */
+        /* Access 2 */
+            /* access type */       0x00,       /* 0x00 = direct page write */
+            /* page offset */       0x38,
+            /* length */            0x04,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x7F, 0xFF,
+            /* data */              0x00, 0x00
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** AC_Coefficients **************/
+
+/* AC Parameters (600) */
+const VpProfileDataType VE792_AC_COEFF_600[] = 
+{
+    /* AC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x00,       /* 0x00 = AC profile */
+        /* number of sections */    0x01,
+        /* content length */        0x74,     /* (2 + 81) + 1 + 32 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x51,       /* 81 */
+        /* command ID */            0x2A,       /* 0x2A = WR_AC_PARAM */
+        /* data */
+            /* AC_MASK */           0x01, 0xFF,
+            /* Z FIR */             0x00, 0x22, 0xBA, 0x74, 0x45, 0x3E, 0x33,
+                                    0x5A, 0x24, 0xDC, 0x4B,
+            /* Z IIR */             0x22, 0x22, 0x97, 0x9F, 0x01,
+            /* GR */                0xA2, 0xA0,
+            /* R IIR */             0xDC, 0x01,
+            /* R FIR */             0x2A, 0x10, 0xAD, 0xC9, 0x22, 0x27, 0x22,
+                                    0x52, 0x3F, 0xBA, 0xC3, 0xB4,
+            /* B FIR */             0x00, 0x3C, 0x7A, 0x4B, 0xAF, 0x9A, 0xA9,
+                                    0xC6, 0xBA, 0x37, 0x24, 0x6B, 0x8F, 0x3B,
+                                    0x70,
+            /* B IIR */             0x2E, 0x01,
+            /* GX */                0x3A, 0x30,
+            /* X FIR */             0x3D, 0x20, 0x9F, 0x2A, 0xA3, 0x4E, 0x4B,
+                                    0x23, 0x52, 0xAB, 0xBB, 0x97, 0x00,
+            /* AISN */              0x00, 0x05,
+            /* DISN */              0x00, 0x01, 0x00, 0x07, 0x00, 0x6F, 0x00,
+                                    0x1C, 0x00, 0x80,
+            /* MTR_CFG */           0x00, 0x00,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00,         /* VP_CFG2 bit LRG = 0 */
+        /* Meter LUT */             0x11, 0x5F,   /* Shadow Register 1 12KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x2F,   /* Shadow Register 1 12KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 8/8 */
+                                    0x0C, 0x12,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x9F,   /* Shadow Register 1 16KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x67,   /* Shadow Register 1 16KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 8/8 */
+                                    0x0C, 0x12    /* Shadow Register 2 */
+
+};
+
+/* AC Parameters (900) */
+const VpProfileDataType AC_COEFF_900[] = 
+{
+    /* AC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x00,       /* 0x00 = AC profile */
+        /* number of sections */    0x01,
+        /* content length */        0x74,     /* (2 + 81) + 1 + 32 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x51,       /* 81 */
+        /* command ID */            0x2A,       /* 0x2A = WR_AC_PARAM */
+        /* data */
+            /* AC_MASK */           0x01, 0xFF,
+            /* Z FIR */             0x00, 0x4A, 0xCA, 0xBD, 0xA5, 0x43, 0x23,
+                                    0x2B, 0xA3, 0xC2, 0x3B,
+            /* Z IIR */             0xA3, 0xA1, 0x97, 0x9F, 0x01,
+            /* GR */                0xA2, 0xB0,
+            /* R IIR */             0xDC, 0x01,
+            /* R FIR */             0x3A, 0x10, 0xAD, 0xD9, 0xC3, 0xA7, 0x42,
+                                    0x42, 0xA3, 0xBA, 0x2B, 0xA4,
+            /* B FIR */             0x00, 0xAA, 0x73, 0x4B, 0x2F, 0x9B, 0xA9,
+                                    0xA5, 0xB3, 0xA6, 0x2A, 0x5C, 0x87, 0xCA,
+                                    0x70,
+            /* B IIR */             0x2E, 0x01,
+            /* GX */                0xA3, 0xA0,
+            /* X FIR */             0x27, 0x20, 0xC2, 0x2A, 0x4A, 0x2E, 0x23,
+                                    0x23, 0x22, 0x2C, 0x2A, 0x87, 0x00,
+            /* AISN */              0x00, 0x0A,
+            /* DISN */              0x00, 0x01, 0x00, 0x07, 0x00, 0x72, 0x00,
+                                    0x35, 0x00, 0x80,
+            /* MTR_CFG */           0x00, 0x00,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00,         /* VP_CFG2 bit LRG = 0 */
+        /* Meter LUT */             0x11, 0x5F,   /* Shadow Register 1 12KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x2F,   /* Shadow Register 1 12KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x11, 0x77,   /* Shadow Register 1 12KHz 8/8 */
+                                    0x0C, 0x12,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x9F,   /* Shadow Register 1 16KHz 2/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x67,   /* Shadow Register 1 16KHz 4/8 */
+                                    0x06, 0x09,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 6/8 */
+                                    0x08, 0x0C,   /* Shadow Register 2 */
+        /* Meter LUT */             0x01, 0x2F,   /* Shadow Register 1 16KHz 8/8 */
+                                    0x0C, 0x12    /* Shadow Register 2 */
+
+};
+
+/************** DC_Parameters **************/
+
+/* DC Parameters */
+const VpProfileDataType VE792_DC_COEFF[] = 
+{
+    /* DC Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x01,       /* 0x01 = DC profile */
+        /* number of sections */    0x02,
+        /* content length */        0x25,       /* (2 + 13) + (2 + 20) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x01,       /* 0x01 = mailbox command */
+        /* content length */        0x0D,       /* 13 */
+        /* command ID */            0x2C,       /* 0x2C = WR_DC_PARAM */
+        /* data */                  0x11, 0x11, /* V1 */
+        /* data */                  0x11, 0xEC, /* VAS */
+        /* data */                  0x01, 0x1C, /* VAS_OFFSET */
+        /* data */                  0x55, 0x55, /* RFD */
+        /* data */                  0x80, 0x00, /* RPTC */
+        /* data */                  0x49, 0x25, /* ILA */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x14,       /* 20 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x33,       /* LOOP_SUP register */
+            /* length */            0x06,
+            /* data */              0xF3, 0x33, /* TGK */
+            /* data */              0x00, 0xC8, /* PGK */
+            /* data */              0x0B, 0xB8, /* TSH */
+            /* data */              0x00, 0x1E, /* DSH */
+            /* data */              0x40, 0x00, /* IFTA */
+            /* data */              0x0C, 0xCD, /* IFTD */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3C,       /* LOOP_SUP register, HSH */
+            /* length */            0x01,
+            /* data */              0x03, 0xE8  /* HSH */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Ring_Parameters **************/
+
+/* Ringing 20Hz, Sine Wave, 40Vrms */
+const VpProfileDataType RING_20HZ_SINE[] = 
+{
+    /* Ring Profile */
+    /* Balanced, Sinusoidal, Crest Factor 1.4142 */
+    /* 20 Hz, 82.86 Vpk, 15.33 V Tip Bias, 4.67 V Ring Bias */
+    /* Ring Trip: Short Loop 41.9 mA, Long Loop 8 mA */
+    /*            Current Spike Threshold 100 mA */
+    /*            Averaging Period 50 ms */
+    /* Ring Exit Hook Switch Debounce: Threshold 0 ms, Duration 0 ms */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x04,       /* 0x04 = ringing profile */
+        /* number of sections */    0x01,
+        /* content length */        0x22,       /* (2 + 32) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x20,       /* 32 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x22,       /* RING register */
+            /* length */            0x0B,       /* 11 */
+            /* data */              0x30, 0x00, /* R control / FRQR[23:16] */
+            /* data */              0xA3, 0xD7, /* FRQR[15:0] */
+            /* data */              0x46, 0xB6, /* AMPR */
+            /* data */              0x0D, 0x15, /* RBA */
+            /* data */              0x03, 0xFC, /* RBB */
+            /* data */              0x04, 0x05, /* EBR */
+            /* data */              0x35, 0xAB, /* RTSL */
+            /* data */              0x0A, 0x3D, /* RTLL */
+            /* data */              0x00, 0x19, /* RTAP */
+            /* data */              0x00, 0x00, /* RSVD */
+            /* data */              0x7F, 0xFF, /* IST */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3A,       /* REDSH, REDD */
+            /* length */            0x02,
+            /* data */              0x00, 0x00, /* REDSH */
+            /* data */              0x00, 0x00  /* REDD */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing 25Hz, Sine Wave, 40Vrms */
+const VpProfileDataType RING_25HZ_SINE[] = 
+{
+    /* Ring Profile */
+    /* Balanced, Sinusoidal, Crest Factor 1.4142 */
+    /* 25 Hz, 66.31 Vpk, 15.33 V Tip Bias, 4.67 V Ring Bias */
+    /* Ring Trip: Short Loop 19 mA, Long Loop 8 mA */
+    /*            Current Spike Threshold 100 mA */
+    /*            Averaging Period 40 ms */
+    /* Ring Exit Hook Switch Debounce: Threshold 0 ms, Duration 0 ms */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x04,       /* 0x04 = ringing profile */
+        /* number of sections */    0x01,
+        /* content length */        0x22,       /* (2 + 32) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x20,       /* 32 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x22,       /* RING register */
+            /* length */            0x0B,       /* 11 */
+            /* data */              0x30, 0x00, /* R control / FRQR[23:16] */
+            /* data */              0xCC, 0xCD, /* FRQR[15:0] */
+            /* data */              0x38, 0x97, /* AMPR */
+            /* data */              0x0D, 0x15, /* RBA */
+            /* data */              0x03, 0xFC, /* RBB */
+            /* data */              0x04, 0x05, /* EBR */
+            /* data */              0x18, 0x49, /* RTSL */
+            /* data */              0x0A, 0x3D, /* RTLL */
+            /* data */              0x00, 0x14, /* RTAP */
+            /* data */              0x00, 0x00, /* RSVD */
+            /* data */              0x7F, 0xFF, /* IST */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x3A,       /* REDSH, REDD */
+            /* length */            0x02,
+            /* data */              0x00, 0x00, /* REDSH */
+            /* data */              0x00, 0x00  /* REDD */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Call_Progress_Tones **************/
+
+/* US Dial Tone */
+const VpProfileDataType TONE_DIAL[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0B,
+            /* data */              0x33, 0x33, /* FreqA = 350Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x0E, 0x14, /* FreqB = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Ringback Tone */
+const VpProfileDataType TONE_RINGBACK[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x0F, 0x5C, /* FreqB = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Busy Tone */
+const VpProfileDataType TONE_BUSY[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0F,
+            /* data */              0x5C, 0x29, /* FreqA = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x13, 0xD7, /* FreqB = 620Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Reorder Tone */
+const VpProfileDataType TONE_REORDER[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0F,
+            /* data */              0x5C, 0x29, /* FreqA = 480Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x13, 0xD7, /* FreqB = 620Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* US Howler Tone (ROH) */
+const VpProfileDataType TONE_US_HOWLER[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x2C,
+            /* data */              0xCC, 0xCD, /* FreqA = 1400Hz */
+            /* data */              0x58, 0xD6, /* AmpA  = 0dBm0 */
+            /* data */              0x41, 0xEC, /* FreqB = 2060Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x4E, 0x66, /* FreqC = 2450Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x53, 0x33, /* FreqD = 2600Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x0F  /* Generator control = ABCD */
+};
+
+/* UK Howler Tone */
+const VpProfileDataType TONE_UK_HOWLER[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x13,       /* (2 + 15) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0F,       /* 15 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x02,       /* SIG_GEN register */
+            /* length */            0x06,
+            /* data */              0x34, 0xCD, /* 1650Hz Offset */
+            /* data */              0x20, 0x00, /* Periodic, Linear */
+            /* data */              0x08, 0x31, /* FreqA = 1Hz */
+            /* data */              0x1B, 0x33, /* AmpA = 850Hz */
+            /* data */              0x80, 0x00, /* FreqB = Freq Modulated */
+            /* data */              0x00, 0x00, /* AmpB = Sequence control */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x13  /* Generators = Bias+AB */
+};
+
+/* Australia Howler Tone */
+const VpProfileDataType TONE_AUS_HOWLER[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x13,       /* (2 + 15) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0F,       /* 15 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x02,       /* SIG_GEN register */
+            /* length */            0x06,
+            /* data */              0x4B, 0x33, /* 2350Hz Offset */
+            /* data */              0x20, 0x00, /* Periodic, Linear */
+            /* data */              0x08, 0x31, /* FreqA = 1Hz */
+            /* data */              0x1B, 0x33, /* AmpA = 850Hz */
+            /* data */              0x80, 0x00, /* FreqB = Freq Modulated */
+            /* data */              0x00, 0x00, /* AmpB = Sequence control */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x13  /* Generators = Bias+AB */
+};
+
+/* Japan Howler Tone */
+const VpProfileDataType TONE_NTT_HOWLER[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x11,       /* (2 + 13) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0D,       /* 13 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x05,
+            /* data */              0x00, 0x00, /* One-shot, Linear */
+            /* data */              0x00, 0x23, /* FreqA = 15s Ramp */
+            /* data */              0x7F, 0xFF, /* AmpA = Maximum */
+            /* data */              0x0C, 0xCD, /* FreqB = 400Hz */
+            /* data */              0x80, 0x00, /* AmpB = Ampl Modulated */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/* Special Information Tone (Called Number Not Connected) */
+const VpProfileDataType TONE_SIT[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x1E,
+            /* data */              0x66, 0x66, /* FreqA = 950Hz */
+            /* data */              0x23, 0x5D, /* AmpA  = -8dBm0 */
+            /* data */              0x2C, 0xCD, /* FreqB = 1400Hz */
+            /* data */              0x23, 0x5D, /* AmpB  = -8dBm0 */
+            /* data */              0x39, 0x9A, /* FreqC = 1800Hz */
+            /* data */              0x23, 0x5D, /* AmpC  = -8dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x07  /* Generator control = ABC */
+};
+
+/* A 1kHz tone at -10dBm0 */
+const VpProfileDataType TONE_ONEKHZ_L[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x20,
+            /* data */              0x00, 0x00, /* FreqA = 1000Hz */
+            /* data */              0x1C, 0x17, /* AmpA  = -10dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* A 1kHz tone at 0dBm0 */
+const VpProfileDataType TONE_ONEKHZ_H[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x20,
+            /* data */              0x00, 0x00, /* FreqA = 1000Hz */
+            /* data */              0x58, 0xD6, /* AmpA  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* Call Waiting Beep */
+const VpProfileDataType TONE_CALLWAIT[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x01  /* Generator control = A */
+};
+
+/* Caller ID Alert Tone */
+const VpProfileDataType TONE_CLI[] = 
+{
+    /* Tone Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x02,       /* 0x02 = tone prof */
+        /* number of sections */    0x01,
+        /* content length */        0x19,       /* (2 + 21) + 2 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x15,       /* 21 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x09,
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x03  /* Generator control = AB */
+};
+
+/************** Cadence_Definitions **************/
+
+/* US Dial Tone Cadence */
+const VpProfileDataType TONE_CAD_DIAL[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x06,       /* (2 + 4) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x04,       /* 4 */
+        /* data */                  0x00, 0x00, /* sequence length = 1 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Stutter Dial Tone Cadence */
+const VpProfileDataType TONE_CAD_STUTTER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x10,       /* (2 + 14) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0E,       /* 14 */
+        /* data */                  0x00, 0x05, /* sequence length = 6 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x60, /* 04 - Branch to 00 */
+        /* data */                  0x05, 0x03, /* 05 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Ringback Tone Cadence */
+const VpProfileDataType TONE_CAD_RINGBACK[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x4F, 0xA0, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Busy Tone Cadence */
+const VpProfileDataType TONE_CAD_BUSY[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x41, 0xF4, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x41, 0xF4, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Reorder Tone Cadence */
+const VpProfileDataType TONE_CAD_REORDER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0xFA, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0xFA, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* US Howler Tone Cadence (ROH) */
+const VpProfileDataType TONE_CAD_US_HOWLER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x0E,       /* (2 + 12) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x05, 0x0F, /* 00 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 02 - Generator Ctrl */
+        /* data */                  0x40, 0x64, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* UK Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_UK_HOWLER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = Tone cadence prof */
+        /* number of sections */    0x01,
+        /* content length */        0x38,       /* (2 + 54) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x36,       /* 54 */
+        /* data */                  0x00, 0x19, /* sequence length = 26 */
+        /* data */                  0x05, 0x13,
+        /* data */                  0x82, 0x04,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x8A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x83, 0x33,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x84, 0x07,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x85, 0x12,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x86, 0x62,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x88, 0x09,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8A, 0x1E,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8C, 0xBD,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x90, 0x09,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x94, 0x30,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x99, 0x6A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x9F, 0xFF
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Australia Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_AUS_HOWLER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = Tone cadence prof */
+        /* number of sections */    0x01,
+        /* content length */        0x44,       /* (2 + 66) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x42,       /* 66 */
+        /* data */                  0x00, 0x1F, /* sequence length = 32 */
+        /* data */                  0x05, 0x13,
+        /* data */                  0x81, 0x03,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x81, 0x46,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x81, 0x9B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x05,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x82, 0x8B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x83, 0x33,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x84, 0x07,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x85, 0x12,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x86, 0x62,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x88, 0x0A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8A, 0x1E,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x8C, 0xBD,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x90, 0x0A,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x94, 0x31,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x99, 0x6B,
+        /* data */                  0x43, 0xE8,
+        /* data */                  0x9F, 0xFF
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Japan Howler Tone Cadence */
+const VpProfileDataType TONE_CAD_NTT_HOWLER[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x06,       /* (2 + 4) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x04,       /* 4 */
+        /* data */                  0x00, 0x00, /* sequence length = 1 */
+        /* data */                  0x05, 0x03, /* 00 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Special Information Tone Cadence */
+const VpProfileDataType TONE_CAD_SIT[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x03,       /* 0x03 = tone cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x12,       /* (2 + 16) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x10,       /* 16 */
+        /* data */                  0x00, 0x06, /* sequence length = 7 */
+        /* data */                  0x05, 0x01, /* 00 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 01 - Sequential Delay */
+        /* data */                  0x05, 0x02, /* 02 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 03 - Sequential Delay */
+        /* data */                  0x05, 0x04, /* 04 - Generator Ctrl */
+        /* data */                  0x41, 0x2C, /* 05 - Sequential Delay */
+        /* data */                  0x05, 0x00, /* 06 - Generator Ctrl */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Standard Ringing Cadence */
+const VpProfileDataType RING_CAD_STD[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x12,       /* (2 + 16) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x10,       /* 16 */
+        /* data */                  0x00, 0x06, /* sequence length = 7 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 02 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x4F, 0xA0, /* 03 - Sequential Delay */
+        /* data */                  0x10, 0x00, /* 04 - Branch to 00 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing Cadence with CallerID */
+const VpProfileDataType RING_CAD_CID[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x28,       /* (2 + 38) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x26,       /* 38 */
+        /* data */                  0x00, 0x11, /* sequence length = 18 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 01 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 02 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x0A, 0x00, /* 03 - Relative Time Marker */
+        /* data */                  0x40, 0xC8, /* 04 - Sequential Delay */
+        /* data */                  0x02, 0x85, /* 05 - Line State */
+        /* data */                  0x01, 0x3A,
+        /* data */                  0x01, 0x22, /* 06 - Start CallerID */
+        /* data */                  0x6F, 0xA0, /* 07 - Relative Delay */
+        /* data */                  0x02, 0x86, /* 08 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x47, 0xD0, /* 09 - Sequential Delay */
+        /* data */                  0x02, 0x83, /* 10 - Line State */
+        /* data */                  0x01, 0x3B,
+        /* data */                  0x4F, 0xA0, /* 11 - Sequential Delay */
+        /* data */                  0x10, 0x0B, /* 12 - Branch to 08 */
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/* Ringing Always On */
+const VpProfileDataType RING_CAD_ON[] = 
+{
+    /* Cadence Profile */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x08,       /* 0x08 = ring cadence */
+        /* number of sections */    0x01,
+        /* content length */        0x08,       /* (2 + 6) */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequence */
+        /* content length */        0x06,       /* 6 */
+        /* data */                  0x00, 0x01, /* sequence length = 2 */
+        /* data */                  0x02, 0x86, /* 00 - Line State */
+        /* data */                  0x01, 0x3B,
+    /* Unstructured data -------------------------------------------------- */
+        /* none */
+};
+
+/************** Caller_ID **************/
+
+/* US Caller ID Type II */
+const VpProfileDataType CID_TYPE2_US[] = 
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x04,
+        /* content length */        0x70,       /* 112 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x24,       /* 36 */
+        /* data */                  0x00, 0x10, /* sequence length = 17 */
+        /* data */                  0x01, 0x3B, /* Mute on */
+        /* data */                  0x01, 0x3D, /* Alert tone 300ms */
+        /* data */                  0x41, 0x2C, /* - TONE_CALLWAIT */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x40, 0x0A, /* Silence 10ms */
+        /* data */                  0x01, 0x3E, /* Alert tone 80ms */
+        /* data */                  0x40, 0x50, /* - TONE_CLI */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x01, 0x32, /* Detect interval 160ms */
+        /* data */                  0x40, 0xA0, /* - Tones: A, D */
+        /* data */                  0x09, 0xB2,
+        /* data */                  0x40, 0x64, /* Silence 100ms */
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+        /* data */                  0x01, 0x3A, /* Mute off */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x29, 0x9A, /* mark freq. 1300Hz  */
+                                    0x43, 0x33, /* space freq. 2100Hz */
+                                    0x12, 0xC6, /* amplitude = -13.5dBm0 */
+    /* Section 2 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x0E,
+            /* data */              0x14, 0x7B, /* FreqA = 440Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqB = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpB  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x01, /* Generator control = A */
+    /* Section 3 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x03, /* Generator control = AB */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x00, 0x00, /* 0-bit channel seizure */
+                                    0x00, 0x58, /* 88-bit mark period */
+                                    0x00, 0x0D, /* Detect Tones A, D */
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/* UK Caller ID Type I */
+const VpProfileDataType CID_TYPE1_UK[] = 
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x03,
+        /* content length */        0x55,       /* 85 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x22,       /* 34 */
+        /* data */                  0x00, 0x0F, /* sequence length = 16 */
+        /* data */                  0x40, 0x32, /* Silence 50ms */
+        /* data */                  0x03, 0x00, /* Line Reversal */
+        /* data */                  0x40, 0x64, /* Silence 100ms */
+        /* data */                  0x01, 0x3D, /* Alert tone 100ms */
+        /* data */                  0x40, 0x64, /* - TONE_CLI */
+        /* data */                  0x05, 0x00,
+        /* data */                  0x01, 0x2F, /* Mask hooks 20ms, */
+        /* data */                  0x40, 0x14, /*    Silence 100ms */
+        /* data */                  0x01, 0x2F,
+        /* data */                  0x40, 0x50,
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+        /* data */                  0x40, 0xC8, /* Silence 200ms */
+        /* data */                  0x03, 0x00, /* Line Reversal */
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x29, 0x9A, /* mark freq. 1300Hz  */
+                                    0x43, 0x33, /* space freq. 2100Hz */
+                                    0x27, 0xAE, /* amplitude = -7dBm0 */
+    /* Section 2 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x17,       /* 23 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x03,       /* SIG_GEN register */
+            /* length */            0x0A,       /* 10 */
+            /* data */              0x30, 0x44,
+            /* data */              0x28, 0xF6, /* FreqA = 2130Hz */
+            /* data */              0x13, 0xE3, /* AmpA  = -13dBm0 */
+            /* data */              0x58, 0x00, /* FreqB = 2750Hz */
+            /* data */              0x13, 0xE3, /* AmpB  = -13dBm0 */
+            /* data */              0x00, 0x00, /* FreqC = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpC  = 0dBm0 */
+            /* data */              0x00, 0x00, /* FreqD = 0Hz */
+            /* data */              0x58, 0xD6, /* AmpD  = 0dBm0 */
+            /* data */              0x00, 0x03, /* Generator control = AB */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x00, 0x78, /* 120-bit channel seizure */
+                                    0x00, 0x40, /* 64-bit mark period */
+                                    0x00, 0x00,
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/* US Caller ID (Type 1 - On-Hook) */
+const VpProfileDataType CLI_TYPE1_US[] = 
+{
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x01,
+        /* type */                  0x05,       /* 0x05 = caller ID profile */
+        /* number of sections */    0x02,
+        /* content length */        0x26,       /* 38 */
+    /* Section 0 ---------------------------------------------------------- */
+        /* section type */          0x02,       /* 0x02 = sequencer program */
+        /* content length */        0x0C,       /* 12 */
+        /* data */                  0x00, 0x04, /* sequence length = 5 */
+        /* data */                  0x42, 0x08, /* Silence 520ms */
+        /* data */                  0x01, 0x26, /* Send FSK */
+        /* data */                  0x0B, 0x01,
+        /* data */                  0x09, 0x00,
+        /* data */                  0x01, 0x27,
+    /* Section 1 ---------------------------------------------------------- */
+        /* section type */          0x00,       /* 0x00 = register list */
+        /* content length */        0x0E,       /* 14 */
+        /* Access 0 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x1F,       /* FSK_GEN register */
+            /* length */            0x01,
+            /* data */              0x00, 0x04, /* stop = 1, start = 0 */
+        /* Access 1 */
+            /* access type */       0x01,       /* 0x01 = chan. page write */
+            /* page offset */       0x10,       /* FSK_GEN register */
+            /* length */            0x03,
+            /* data */              0x26, 0x66, /* mark freq. 1200Hz  */
+                                    0x46, 0x66, /* space freq. 2200Hz */
+                                    0x27, 0xAE, /* amplitude = -7dBm0 */
+    /* Unstructured data -------------------------------------------------- */
+                                    0x01, 0x30, /* 304-bit channel seizure */
+                                    0x00, 0xB8, /* 184-bit mark period */
+                                    0x00, 0x00,
+                                    0x01,       /* API checksum */
+                                    0x00        /* FSK Message Data */
+};
+
+/************** Metering_Profile **************/
+
+/* Metering Profile 12 kHz Tone */
+const VpProfileDataType METER_12KHZ[] = 
+{
+    /* Metering Profile */
+    /* 12KHz Tone Metering */
+    /* Ramp Time: 10ms, Amplitude: 2000mVrms (Normal Gain) */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x07,       /* 0x07 = Metering profile */
+        /* number of sections */    0x00,
+        /* content length */        0x06,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x02, /* MTR_TYPE */
+        /* data */                  0x00, 0x0A, /* RAMP_TIME */
+        /* data */                  0x09, 0x94  /* RAMP_STEP */
+};
+
+/* Metering Profile Polarity Reversal */
+const VpProfileDataType METER_POLREV[] = 
+{
+    /* Metering Profile */
+    /* Polrev Pulse Metering */
+    /* Profile header ----------------------------------------------------- */
+        /* version */               0x00,
+        /* type */                  0x07,       /* 0x07 = Metering profile */
+        /* number of sections */    0x00,
+        /* content length */        0x02,
+    /* Unstructured data -------------------------------------------------- */
+        /* data */                  0x00, 0x00  /* MTR_TYPE */
+};
+
+int dev_profile_size = sizeof(VE792_DEV_PROFILE);
+int dc_profile_size = sizeof(VE792_DC_COEFF);
+int ac_profile_size = sizeof(VE792_AC_COEFF_600);
+int ring_profile_size = sizeof(RING_20HZ_SINE);
+
+/* end of file profile_79238.c */
diff --git a/tools/voice/zarlink/profile_79238.h b/tools/voice/zarlink/profile_79238.h
new file mode 100644
index 0000000..0cdcda0
--- /dev/null
+++ b/tools/voice/zarlink/profile_79238.h
@@ -0,0 +1,83 @@
+/*
+ * profile_79238.h --
+ *
+ * This header file exports the Profile data types
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\profile_792\792.vpw
+ *   Type:  VCP2-792 Project (Line Module Le51HR0128)
+ *   Date:  Thursday, June 03, 2010 13:40:38
+ *
+ *   This file was generated with Profile Wizard Version: P1.14.1
+ */
+
+#ifndef PROFILE_79238_H
+#define PROFILE_79238_H
+
+#ifdef VP_API_TYPES_H
+#include "vp_api_types.h"
+#else
+typedef unsigned char VpProfileDataType;
+#endif
+
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/************** Device_Parameters **************/
+/* Device Profile */
+extern const VpProfileDataType VE792_DEV_PROFILE[];
+
+/************** AC_Coefficients **************/
+extern const VpProfileDataType VE792_AC_COEFF_600[]; /* AC Parameters (600) */
+extern const VpProfileDataType AC_COEFF_900[];       /* AC Parameters (900) */
+
+/************** DC_Parameters **************/
+extern const VpProfileDataType VE792_DC_COEFF[];     /* DC Parameters */
+
+/************** Ring_Parameters **************/
+extern const VpProfileDataType RING_20HZ_SINE[];     /* Ringing 20Hz, Sine Wave, 40Vrms */
+extern const VpProfileDataType RING_25HZ_SINE[];     /* Ringing 25Hz, Sine Wave, 40Vrms */
+
+/************** Call_Progress_Tones **************/
+extern const VpProfileDataType TONE_DIAL[];          /* US Dial Tone */
+extern const VpProfileDataType TONE_RINGBACK[];      /* US Ringback Tone */
+extern const VpProfileDataType TONE_BUSY[];          /* US Busy Tone */
+extern const VpProfileDataType TONE_REORDER[];       /* US Reorder Tone */
+extern const VpProfileDataType TONE_US_HOWLER[];     /* US Howler Tone (ROH) */
+extern const VpProfileDataType TONE_UK_HOWLER[];     /* UK Howler Tone */
+extern const VpProfileDataType TONE_AUS_HOWLER[];    /* Australia Howler Tone */
+extern const VpProfileDataType TONE_NTT_HOWLER[];    /* Japan Howler Tone */
+extern const VpProfileDataType TONE_SIT[];           /* Special Information Tone (Called Number Not Connected) */
+extern const VpProfileDataType TONE_ONEKHZ_L[];      /* A 1kHz tone at -10dBm0 */
+extern const VpProfileDataType TONE_ONEKHZ_H[];      /* A 1kHz tone at 0dBm0 */
+extern const VpProfileDataType TONE_CALLWAIT[];      /* Call Waiting Beep */
+extern const VpProfileDataType TONE_CLI[];           /* Caller ID Alert Tone */
+
+/************** Cadence_Definitions **************/
+extern const VpProfileDataType TONE_CAD_DIAL[];      /* US Dial Tone Cadence */
+extern const VpProfileDataType TONE_CAD_STUTTER[];   /* Stutter Dial Tone Cadence */
+extern const VpProfileDataType TONE_CAD_RINGBACK[];  /* US Ringback Tone Cadence */
+extern const VpProfileDataType TONE_CAD_BUSY[];      /* US Busy Tone Cadence */
+extern const VpProfileDataType TONE_CAD_REORDER[];   /* US Reorder Tone Cadence */
+extern const VpProfileDataType TONE_CAD_US_HOWLER[]; /* US Howler Tone Cadence (ROH) */
+extern const VpProfileDataType TONE_CAD_UK_HOWLER[]; /* UK Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_AUS_HOWLER[];/* Australia Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_NTT_HOWLER[];/* Japan Howler Tone Cadence */
+extern const VpProfileDataType TONE_CAD_SIT[];       /* Special Information Tone Cadence */
+extern const VpProfileDataType RING_CAD_STD[];       /* Standard Ringing Cadence */
+extern const VpProfileDataType RING_CAD_CID[];       /* Ringing Cadence with CallerID */
+extern const VpProfileDataType RING_CAD_ON[];        /* Ringing Always On */
+
+/************** Caller_ID **************/
+extern const VpProfileDataType CID_TYPE2_US[];       /* US Caller ID Type II */
+extern const VpProfileDataType CID_TYPE1_UK[];       /* UK Caller ID Type I */
+extern const VpProfileDataType CLI_TYPE1_US[];       /* US Caller ID (Type 1 - On-Hook) */
+
+/************** Metering_Profile **************/
+extern const VpProfileDataType METER_12KHZ[];        /* Metering Profile 12 kHz Tone */
+extern const VpProfileDataType METER_POLREV[];       /* Metering Profile Polarity Reversal */
+
+#endif /* PROFILE_79238_H */
+
diff --git a/tools/voice/zarlink/profile_88266.c b/tools/voice/zarlink/profile_88266.c
new file mode 100644
index 0000000..e45b8e6
--- /dev/null
+++ b/tools/voice/zarlink/profile_88266.c
@@ -0,0 +1,644 @@
+/*
+ * profile_8266.c --
+ *
+ * This file contains profile data in byte format
+ *
+ *   This file was generated with Profile Wizard Version: P1.12.3
+ */
+
+#include "profile_88266.h"
+
+
+/*** Device Parameters for VoicePort Device Family ***/
+const VpProfileDataType ABS_VBL_FLYBACK[] = 
+{
+  /* Device Profile */
+ 0x00, 0xFF, 0x00, 0x1A, /* Profile Index and Length */
+ 0x04, 0x00, /* Version and MPI Command */
+ 0x20, 0x00, /* PCLK Frequency */
+ 0x8A, 0x00, /* Device Config 1 and MCLK Correction */
+ 0x40, 0x02, /* Clock Slot and Max Events */
+ 0x0A, 0x00, /* Device Tickrate */
+ 0xE4, 0x00, 0x05, 0x00, /* Switching Regulator Parameters */
+ 0x00, 0x00, /* RSVD */
+ 0x22, 0x00, 0x55, 0x55, /* Linecard Parameters */
+ 0xB2, 0x00, 0xB1, 0x00, 0xB0, 0x40  /* Regulator Timing Parameters */
+};
+
+/************** AC Filter Coefficients **************/
+
+/* AC FXS RF14 600 Ohm Coefficients [Default} */
+const VpProfileDataType AC_FXS_RF14_DEF[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 900 Ohm Coefficients */
+const VpProfileDataType AC_FXS_RF14_900[] = 
+{
+  /* AC Profile */
+ 0xE4, 0x00, 0xF7, 0x4C, 0x01, 0x49, 0xCA, 0x0B, 0x98, 0x34, 0x3B, 0xB2,
+ 0x2C, 0x9F, 0xA4, 0xD2, 0xA3, 0x22, 0xAC, 0x9A, 0xA4, 0xAA, 0x67, 0x9F,
+ 0x01, 0x8A, 0xB3, 0xD0, 0xA6, 0x21, 0xAA, 0x34, 0x2B, 0x2F, 0x4A, 0xA6,
+ 0xAB, 0x2F, 0x4A, 0x37, 0x88, 0x2A, 0xC0, 0x23, 0xAC, 0x2A, 0x26, 0x32,
+ 0xA5, 0x3C, 0xAD, 0xA4, 0xA7, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xAB, 0x49, 0xF1, 0x2A, 0x0A, 0x43, 0xC9, 0xF3, 0x27, 0xBC,
+ 0xE2, 0xAF, 0xAD, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Australia 220+820//220nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_AU[] = 
+{
+  /* AC Profile */
+ 0xBF, 0x00, 0xAF, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0xBA, 0x41, 0x54,
+ 0xA2, 0x2A, 0x5B, 0xA4, 0xAA, 0x3A, 0xB3, 0x9A, 0x87, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x23, 0x20, 0x3E, 0xA8, 0x2A, 0x57, 0xCB, 0x34,
+ 0xBA, 0xAC, 0xBB, 0xA6, 0x88, 0xAA, 0xB0, 0x49, 0xF6, 0x3B, 0x2E, 0x49,
+ 0xFF, 0xBC, 0xA5, 0x3A, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x34, 0x5C, 0x32, 0x25, 0x1A, 0xA1, 0x3B, 0x23, 0xB3, 0x5B,
+ 0x4D, 0xB5, 0xDC, 0x60, 0x96, 0x3B, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Austria 220+820//115nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_AT[] = 
+{
+  /* AC Profile */
+ 0x6D, 0x00, 0xA7, 0x4C, 0x01, 0x49, 0xCA, 0xEA, 0x98, 0xFA, 0xE1, 0x23,
+ 0xA2, 0xEA, 0xCB, 0xB3, 0xAA, 0xA3, 0xB3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0xB3, 0x20, 0xAB, 0xA8, 0xCC, 0x24, 0x22, 0x97,
+ 0xAF, 0x8F, 0xD3, 0xBF, 0x88, 0x3B, 0xB0, 0x33, 0x46, 0x2A, 0x2E, 0x33,
+ 0x4F, 0xAE, 0xA5, 0xB3, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0x22, 0x98, 0x02, 0x42, 0xA2, 0x43, 0xA6, 0xD8,
+ 0xFA, 0x8F, 0x29, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Belgium 150+830//72 Coefficients */
+const VpProfileDataType AC_FXS_RF14_BE[] = 
+{
+  /* AC Profile */
+ 0x8F, 0x00, 0x2E, 0x4C, 0x01, 0x49, 0xCA, 0xF3, 0x98, 0x2C, 0xA1, 0xB4,
+ 0xE3, 0x34, 0xCB, 0x2C, 0x2B, 0xA3, 0xA3, 0x9A, 0x87, 0xA6, 0x97, 0x9F,
+ 0x01, 0x8A, 0x42, 0xD0, 0xBA, 0x30, 0xC2, 0x49, 0xA3, 0x4C, 0xDC, 0xC2,
+ 0x22, 0x2B, 0xBA, 0xA4, 0x88, 0xB3, 0xB0, 0xA3, 0xA4, 0x4A, 0xDD, 0xCA,
+ 0xAD, 0x43, 0xA4, 0x22, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3A, 0x42, 0xA1, 0xA4, 0x19, 0x81, 0x5A, 0x4B, 0x2F, 0xA2,
+ 0xFB, 0xAF, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Brazil 900 Coefficients */
+const VpProfileDataType AC_FXS_RF14_BR[] = 
+{
+  /* AC Profile */
+ 0xE4, 0x00, 0xF7, 0x4C, 0x01, 0x49, 0xCA, 0x0B, 0x98, 0x34, 0x3B, 0xB2,
+ 0x2C, 0x9F, 0xA4, 0xD2, 0xA3, 0x22, 0xAC, 0x9A, 0xA4, 0xAA, 0x67, 0x9F,
+ 0x01, 0x8A, 0xB3, 0xD0, 0xA6, 0x21, 0xAA, 0x34, 0x2B, 0x2F, 0x4A, 0xA6,
+ 0xAB, 0x2F, 0x4A, 0x37, 0x88, 0x2A, 0xC0, 0xA2, 0xAC, 0x2A, 0x26, 0x32,
+ 0xA5, 0x4C, 0xAD, 0xA4, 0xA7, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3D, 0x53, 0x22, 0x52, 0x1A, 0x22, 0x2B, 0x6A, 0x87, 0x29,
+ 0xFB, 0x2F, 0xFC, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXA RF14 China 200+680//100nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_CN[] = 
+{
+  /* AC Profile */
+ 0xB9, 0x00, 0x1F, 0x4C, 0x01, 0x49, 0xCA, 0xE9, 0x98, 0x5C, 0xB1, 0xAA,
+ 0x23, 0x43, 0xEB, 0x32, 0xAA, 0x23, 0xB3, 0x9A, 0x98, 0x94, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x22, 0x30, 0x6A, 0x59, 0x2A, 0xCB, 0xB4, 0xB2,
+ 0xBF, 0x3B, 0xA3, 0x25, 0x88, 0x43, 0xC0, 0x3A, 0x45, 0x2B, 0xBD, 0x4C,
+ 0x2E, 0x4C, 0x25, 0x42, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA4, 0x5A, 0x32, 0xB5, 0x12, 0xA1, 0xA2, 0x3A, 0xA4, 0xB5,
+ 0x64, 0x97, 0xAA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Czech Republic 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_CZ[] = 
+{
+  /* AC Profile */
+ 0x1A, 0x00, 0x03, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x22, 0xBA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0xAA, 0xC0, 0x97, 0xA0, 0xAA, 0x33, 0xD2, 0xDB, 0x7C, 0x23,
+ 0x2A, 0xEB, 0x32, 0xB4, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5A, 0x22, 0xC7, 0x16, 0xE2, 0x2B, 0x42, 0xC6, 0xC8,
+ 0xFA, 0x9F, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Denmark 300+1000//220nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_DK[] = 
+{
+  /* AC Profile */
+ 0x7D, 0x00, 0x9A, 0x4C, 0x01, 0x49, 0xCA, 0xE6, 0x98, 0x22, 0xA1, 0x52,
+ 0xD2, 0xE7, 0x24, 0xF4, 0xCD, 0xAA, 0x97, 0x9A, 0xCA, 0xB3, 0xA5, 0x6E,
+ 0x01, 0x8A, 0x32, 0xD0, 0xAB, 0x20, 0xAA, 0x49, 0x29, 0x7A, 0x32, 0xD6,
+ 0xA2, 0xED, 0xC5, 0x97, 0x88, 0xBA, 0xC0, 0x22, 0xA7, 0x2C, 0xFE, 0x42,
+ 0xDE, 0x22, 0xB6, 0xB3, 0x9F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x23, 0x53, 0x32, 0x2C, 0x1B, 0x22, 0xCA, 0x23, 0x63, 0x2A,
+ 0x33, 0xD4, 0x2A, 0x40, 0x96, 0xA2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 ETSI 270+750//150nF Harmonized Coefficients */
+const VpProfileDataType AC_FXS_RF14_EU[] = 
+{
+  /* AC Profile */
+ 0xD5, 0x00, 0xEC, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0x4A, 0xA1, 0x34,
+ 0xA2, 0xA2, 0xAC, 0x2C, 0xBB, 0x2B, 0xA4, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x9C, 0xD0, 0x2B, 0x20, 0x8F, 0x39, 0x2A, 0xBB, 0xA4, 0x24,
+ 0xB2, 0xBC, 0x4B, 0x26, 0x88, 0xA3, 0xC0, 0xC2, 0x27, 0xBA, 0x3E, 0xAC,
+ 0xAF, 0xB4, 0x26, 0x24, 0x3F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5F, 0x32, 0x98, 0x03, 0xA1, 0xAA, 0x23, 0xB3, 0x2C,
+ 0x4B, 0x55, 0x25, 0x60, 0x96, 0xF2, 0xC1, 0x00
+};
+
+/* AC FXS RF14 Finland 270+910//120 Coefficients */
+const VpProfileDataType AC_FXS_RF14_FI[] = 
+{
+  /* AC Profile */
+ 0xFF, 0x00, 0x8D, 0x4C, 0x01, 0x49, 0xCA, 0xEF, 0x98, 0x2A, 0xB1, 0x23,
+ 0x33, 0xB2, 0xAB, 0x44, 0xEB, 0xA4, 0x44, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x24, 0x20, 0x25, 0xB8, 0x2D, 0x42, 0xDB, 0xBA,
+ 0xE3, 0x43, 0xF2, 0xAC, 0x88, 0xC4, 0xB0, 0xA2, 0xA7, 0x42, 0x3E, 0xA2,
+ 0x9F, 0x32, 0x26, 0xBE, 0x2F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA2, 0x5C, 0x22, 0xA2, 0x13, 0xC1, 0xB3, 0x22, 0x23, 0x7A,
+ 0x3D, 0xB4, 0xD4, 0x50, 0x96, 0x3C, 0x41, 0x00
+};
+
+/* AC FXS RF14 France 215+1000//137nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_FR[] = 
+{
+  /* AC Profile */
+ 0xFC, 0x00, 0xA4, 0x4C, 0x01, 0x49, 0xCA, 0xE7, 0x98, 0xBA, 0x31, 0xA5,
+ 0x62, 0x35, 0xAB, 0xAA, 0xAA, 0xAC, 0xA3, 0x9A, 0xAA, 0xA2, 0xC7, 0x6F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xBB, 0x10, 0xC2, 0x38, 0x2A, 0xA1, 0xC2, 0xA9,
+ 0x23, 0xA2, 0x22, 0x2D, 0x88, 0xA3, 0xB0, 0x53, 0x55, 0x4A, 0xAD, 0xB2,
+ 0xAD, 0x5A, 0x25, 0x72, 0x5E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x43, 0x22, 0x9F, 0x1A, 0x22, 0x4B, 0x33, 0xD5, 0x2C,
+ 0x7A, 0x87, 0xA8, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 German 220+820//115nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_DE[] = 
+{
+  /* AC Profile */
+ 0xEB, 0x00, 0xDC, 0x4C, 0x01, 0x49, 0xCA, 0xEA, 0x98, 0xA2, 0xE1, 0x24,
+ 0xA2, 0x2A, 0xCB, 0xB3, 0xAA, 0xD3, 0xB3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0x24, 0x20, 0x2C, 0xA8, 0xAB, 0x24, 0x22, 0x97,
+ 0xAF, 0x8F, 0x23, 0xBF, 0x88, 0x3B, 0xB0, 0x33, 0x46, 0x2A, 0x2E, 0x33,
+ 0x4F, 0xAE, 0xA5, 0xB3, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x53, 0x54, 0x32, 0xC4, 0x1A, 0xA1, 0x2B, 0x2A, 0xA3, 0xAA,
+ 0x4A, 0xA5, 0xBA, 0x60, 0x96, 0xD2, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Greece 400+500//50nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_GR[] = 
+{
+  /* AC Profile */
+ 0x63, 0x00, 0x7D, 0x4C, 0x01, 0x49, 0xCA, 0x03, 0x98, 0x22, 0xA6, 0x2C,
+ 0x3E, 0x2B, 0x87, 0x44, 0x36, 0x2A, 0x9F, 0x9A, 0x22, 0xBA, 0xA7, 0x9F,
+ 0x01, 0x8A, 0x7D, 0xD0, 0xAA, 0xA0, 0x22, 0xAA, 0x98, 0xB4, 0x23, 0xBE,
+ 0xAB, 0xBF, 0xAA, 0x97, 0x88, 0x3C, 0xC0, 0x3A, 0xBD, 0xED, 0x8F, 0xEB,
+ 0xA6, 0x3A, 0x8F, 0x2B, 0x6F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xD2, 0x52, 0x22, 0xA2, 0x13, 0xA1, 0x97, 0x32, 0x25, 0xCA,
+ 0x6B, 0x87, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Hungary 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_HU[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 India 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_IN[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Italy 180+630//60nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_IT[] = 
+{
+  /* AC Profile */
+ 0xEE, 0x00, 0xBD, 0x4C, 0x01, 0x49, 0xCA, 0xF3, 0x98, 0x22, 0xD2, 0xBA,
+ 0x34, 0x22, 0x3C, 0x53, 0xAB, 0xAA, 0xB4, 0x9A, 0x98, 0x1B, 0x97, 0x9F,
+ 0x01, 0x8A, 0x9C, 0xD0, 0xBC, 0xD0, 0x2A, 0x2A, 0x3C, 0x4C, 0x4E, 0x23,
+ 0xD2, 0xBB, 0xDB, 0x55, 0x88, 0xAA, 0xC0, 0x2C, 0xB5, 0x23, 0xAD, 0x4A,
+ 0x5E, 0xAD, 0xB5, 0x2B, 0x2E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xA2, 0x52, 0xA1, 0xA3, 0x1A, 0x32, 0xAA, 0x4A, 0xAF, 0x3B,
+ 0xF4, 0x9F, 0x3A, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Japan 600+1uF Coefficients */
+const VpProfileDataType AC_FXS_RF14_JP[] = 
+{
+  /* AC Profile */
+ 0x0C, 0x00, 0x79, 0x4C, 0x01, 0x49, 0xCA, 0xF9, 0x98, 0xAC, 0xEE, 0x2A,
+ 0x87, 0x2A, 0x3F, 0xA3, 0x97, 0xE5, 0xC3, 0x9A, 0xAB, 0xA2, 0x24, 0xA6,
+ 0xD0, 0x8A, 0x42, 0xB0, 0x2A, 0xA0, 0x34, 0xAA, 0x3B, 0xA2, 0xCA, 0xAA,
+ 0xA4, 0x24, 0x3B, 0x4D, 0x88, 0xBA, 0x30, 0xAC, 0x2D, 0xAA, 0xCE, 0xAA,
+ 0x25, 0x22, 0x2C, 0xB2, 0x65, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x3B, 0x52, 0xA1, 0xA5, 0x14, 0xA2, 0x23, 0x44, 0x24, 0xA5,
+ 0x4B, 0xA4, 0xAC, 0x40, 0x96, 0x32, 0xD0, 0x00
+};
+
+/* AC FXS RF14 S. Korea 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_KR[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Mexico 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_MX[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Netherlands 600/340+422//100 Coefficients */
+const VpProfileDataType AC_FXS_RF14_NL[] = 
+{
+  /* AC Profile */
+ 0x7D, 0x00, 0x38, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x22, 0xBA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x34, 0xD0, 0xCD, 0xA0, 0xAB, 0xD3, 0x22, 0xAB, 0x4A, 0xA3,
+ 0xA2, 0x2C, 0xAB, 0x45, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x62, 0x52, 0x22, 0xCD, 0x12, 0x23, 0x44, 0x7A, 0x87, 0x3B,
+ 0xFC, 0xBF, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 New Zealand 370+620//310nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_NZ[] = 
+{
+  /* AC Profile */
+ 0x14, 0x00, 0x00, 0x4C, 0x01, 0x49, 0xCA, 0xE9, 0x98, 0xAA, 0xB3, 0xB2,
+ 0xA2, 0xDA, 0xA3, 0x2B, 0x36, 0xAA, 0x25, 0x9A, 0x2B, 0xA2, 0x27, 0x6F,
+ 0x01, 0x8A, 0x1D, 0x01, 0x52, 0x50, 0x2A, 0x3B, 0x45, 0xA9, 0xCA, 0xA3,
+ 0x2C, 0xAB, 0xAA, 0x27, 0x88, 0xC3, 0x50, 0xBA, 0x8F, 0x37, 0x2F, 0xC2,
+ 0xBE, 0xEA, 0x87, 0xAA, 0x87, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x53, 0x53, 0x32, 0xCB, 0x1C, 0x42, 0x32, 0x3B, 0xB3, 0xA2,
+ 0x42, 0xB4, 0x23, 0x50, 0x96, 0x42, 0xA0, 0x00
+};
+
+/* AC FXS RF14 Norway 120+820//110nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_NO[] = 
+{
+  /* AC Profile */
+ 0x04, 0x00, 0xA8, 0x4C, 0x01, 0x49, 0xCA, 0xE4, 0x98, 0xAA, 0x41, 0x22,
+ 0xA1, 0xAA, 0x3B, 0x23, 0x2A, 0xD4, 0x23, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xEA, 0x10, 0x22, 0xB8, 0x22, 0x3B, 0x23, 0xA1,
+ 0xAA, 0xBA, 0x32, 0xC4, 0x88, 0x25, 0xB0, 0x3B, 0x24, 0x2C, 0x2D, 0xA3,
+ 0xAC, 0xF4, 0xC4, 0xAB, 0xAD, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xBB, 0x52, 0xE2, 0xBD, 0x1B, 0xA1, 0x3B, 0x2A, 0xA3, 0x3A,
+ 0x4A, 0x26, 0x29, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Portugal 600 Coefficients */
+const VpProfileDataType AC_FXS_RF14_PT[] = 
+{
+  /* AC Profile */
+ 0xA4, 0x00, 0xF4, 0x4C, 0x01, 0x49, 0xCA, 0xF5, 0x98, 0xAA, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2A, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0xA3, 0xA0, 0x2E, 0xB2, 0xB2, 0xBA, 0xAC, 0xA2,
+ 0xA6, 0xCB, 0x3B, 0x45, 0x88, 0x2A, 0x20, 0x3C, 0xBC, 0x4E, 0xA6, 0x2B,
+ 0xA5, 0x2B, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x42, 0xA1, 0xCB, 0x1B, 0xA3, 0xA8, 0xFB, 0x87, 0xAA,
+ 0xFB, 0x9F, 0xA9, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Slovenia 600/220+820//115 Coefficients */
+const VpProfileDataType AC_FXS_RF14_SI[] = 
+{
+  /* AC Profile */
+ 0x00, 0x00, 0x00, 0x4C, 0x00, 0x49, 0xCA, 0xF5, 0x98, 0x2A, 0x7B, 0xAB,
+ 0x2C, 0xA3, 0x25, 0xA5, 0x24, 0xB2, 0x3D, 0x9A, 0x2B, 0xAA, 0xA6, 0x9F,
+ 0x01, 0x8A, 0x1D, 0x01, 0x55, 0xA0, 0xA2, 0xA2, 0x57, 0x2B, 0xC6, 0x23,
+ 0x34, 0xBB, 0x6A, 0xC5, 0x88, 0x2A, 0x20, 0x6C, 0xBC, 0xCE, 0xA6, 0x2B,
+ 0xA5, 0xAA, 0x3E, 0xBA, 0x8F, 0x82, 0xA8, 0x71, 0x80, 0xC8, 0xF0, 0x50,
+ 0x00, 0x86, 0xC3, 0x5A, 0x22, 0xC7, 0x16, 0xE2, 0x2B, 0x42, 0xC6, 0xC8,
+ 0xFA, 0x9F, 0x2B, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 Spain 220+820//120nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_ES[] = 
+{
+  /* AC Profile */
+ 0xBF, 0x00, 0xAF, 0x4C, 0x01, 0x49, 0xCA, 0xE8, 0x98, 0xBA, 0x41, 0x54,
+ 0xA2, 0x2A, 0x5B, 0xA4, 0xAA, 0x3A, 0xB3, 0x9A, 0x87, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x23, 0x20, 0x3E, 0xA8, 0x2A, 0x57, 0xCB, 0x34,
+ 0xBA, 0xAC, 0xBB, 0xA6, 0x88, 0xAA, 0xB0, 0x49, 0xF6, 0x3B, 0x2E, 0x49,
+ 0xFF, 0xBC, 0xA5, 0x3A, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x34, 0x5C, 0x32, 0x25, 0x1A, 0xA1, 0x3B, 0x23, 0xB3, 0x5B,
+ 0x4D, 0xB5, 0xDC, 0x60, 0x96, 0x3B, 0xA1, 0x00
+};
+
+/* AC FXS RF14 Sweden 200+1000//100nF_900//30nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_SE[] = 
+{
+  /* AC Profile */
+ 0x0E, 0x00, 0x42, 0x4C, 0x01, 0x49, 0xCA, 0xF0, 0x98, 0x24, 0xF1, 0xB4,
+ 0xA2, 0xAB, 0x4B, 0x4B, 0xAA, 0xA7, 0xC3, 0x9A, 0x98, 0x92, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2D, 0x01, 0xB3, 0x20, 0x5B, 0xB8, 0x24, 0xA2, 0x3C, 0xAC,
+ 0xAA, 0x27, 0x32, 0x9F, 0x88, 0x3A, 0xA0, 0x3A, 0x25, 0x3A, 0xAD, 0x22,
+ 0xAD, 0xBE, 0x25, 0xA5, 0x2E, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x73, 0x52, 0x22, 0xD2, 0x12, 0xB1, 0x4A, 0x23, 0xC4, 0xC3,
+ 0x6A, 0x97, 0xA8, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 U.K. 300+1000//220_370+620//310nF Coefficients */
+const VpProfileDataType AC_FXS_RF14_GB[] = 
+{
+  /* AC Profile */
+ 0x24, 0x00, 0x0A, 0x4C, 0x01, 0x49, 0xCA, 0xE6, 0x98, 0x22, 0xA1, 0x52,
+ 0xD2, 0xE7, 0x24, 0xF4, 0xCD, 0xAA, 0x97, 0x9A, 0x2B, 0xA2, 0x27, 0x6E,
+ 0x01, 0x8A, 0x32, 0xD0, 0xCB, 0x20, 0xBB, 0x59, 0x5A, 0x4A, 0xAA, 0xB5,
+ 0x2C, 0x2D, 0x42, 0xC7, 0x88, 0xAA, 0xC0, 0xA3, 0xA7, 0xBA, 0xDE, 0x5C,
+ 0xCE, 0xAA, 0xA6, 0xA2, 0x9F, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x43, 0x5B, 0x32, 0x2C, 0x1D, 0x22, 0xAA, 0x2B, 0x33, 0xBA,
+ 0x3C, 0x34, 0xBA, 0x40, 0x96, 0xA2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 US 900//2.16uF_1650//(100+5nF) Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_loaded[] = 
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2B, 0x4C, 0x21, 0xAC, 0x03, 0xB2, 0xA5, 0x5A, 0xE4, 0x74,
+ 0xF3, 0xA5, 0xBE, 0x60, 0x96, 0xAA, 0xC0, 0x00
+};
+
+/* AC FXS RF14 US 900//2,16uF_800//(100+50nF) Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_Nonloaded[] = 
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xBD, 0x52, 0xA1, 0x62, 0x1B, 0x22, 0x3A, 0x4B, 0xB5, 0x2A,
+ 0x65, 0xA7, 0xB6, 0x70, 0x96, 0x23, 0xC0, 0x00
+};
+
+/* AC FXS RF14 US 900//2.16uF Coefficients */
+const VpProfileDataType AC_FXS_RF14_US_SS[] = 
+{
+  /* AC Profile */
+ 0x01, 0x00, 0x90, 0x4C, 0x01, 0x49, 0xCA, 0x0E, 0x98, 0x32, 0x2B, 0x24,
+ 0x7C, 0x4A, 0x24, 0x55, 0xA3, 0x3A, 0xBC, 0x9A, 0xBA, 0xB3, 0xF4, 0x2D,
+ 0x01, 0x8A, 0xEB, 0xC0, 0x26, 0x21, 0xB2, 0x35, 0xB3, 0xA6, 0x2A, 0xAD,
+ 0xD4, 0xA6, 0x52, 0x4F, 0x88, 0xA3, 0xD0, 0x23, 0xAA, 0xAF, 0x62, 0xEA,
+ 0xBA, 0x2A, 0xB3, 0x4A, 0x3D, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xDA, 0x4A, 0x41, 0x3A, 0x02, 0x23, 0x3A, 0x42, 0x25, 0xAA,
+ 0x72, 0xA5, 0x2B, 0x50, 0x96, 0x1D, 0x01, 0x00
+};
+
+/************** WideBand AC Filter Coefficients **************/
+/* AC FXS RF14 600 Ohm Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_US[] =
+{
+  /* AC Profile */
+ 0xED, 0x00, 0xA9, 0x4C, 0x01, 0x49, 0xCA, 0xFC, 0x98, 0xCC, 0x2A, 0xA2,
+ 0x3B, 0x98, 0xB3, 0x43, 0xA2, 0x3A, 0xAB, 0x9A, 0x2D, 0xAA, 0xB6, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0xC4, 0xA0, 0x2E, 0x23, 0x3A, 0x2E, 0x9F, 0x87,
+ 0x4C, 0xCE, 0xB2, 0x27, 0x88, 0xDE, 0x20, 0xAA, 0xCA, 0x22, 0x32, 0x23,
+ 0xAA, 0xA2, 0xB4, 0x2A, 0x87, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xCB, 0x5E, 0x22, 0xBC, 0x12, 0xA3, 0xA9, 0xFA, 0xC6, 0x34,
+ 0xE2, 0x9F, 0xBA, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 European Union Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_EU[] =
+{
+  /* AC Profile */
+ 0xAA, 0x00, 0x9C, 0x4C, 0x01, 0x49, 0xCA, 0xE0, 0x98, 0xAA, 0xA3, 0x6B,
+ 0x22, 0x43, 0xA2, 0xAC, 0xBF, 0x22, 0xA6, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xBA, 0x10, 0xA2, 0x3A, 0xBA, 0xE9, 0xAA, 0xB5,
+ 0x2A, 0xBC, 0xAF, 0x97, 0x88, 0xAB, 0xC0, 0x4A, 0xBE, 0xBA, 0x9F, 0xC3,
+ 0xAF, 0x3A, 0x3F, 0xCD, 0xA7, 0x82, 0xC8, 0x71, 0x80, 0x69, 0xF0, 0x50,
+ 0x00, 0x86, 0xBA, 0x52, 0xB2, 0xBA, 0x12, 0x42, 0x4A, 0x2A, 0x33, 0xBA,
+ 0x33, 0x34, 0x4B, 0x40, 0x96, 0xB2, 0xA0, 0x00
+};
+
+/* AC FXS RF14 France Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_FR[] =
+{
+  /* AC Profile */
+ 0x98, 0x00, 0x26, 0x4C, 0x01, 0x49, 0xCA, 0xD7, 0x98, 0x4F, 0x22, 0xB5,
+ 0xB1, 0xC6, 0x23, 0x3A, 0xAB, 0x24, 0xB5, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x01, 0x11, 0x22, 0x10, 0x3A, 0x29, 0x3C, 0x29, 0x32, 0xB3,
+ 0x4A, 0x2C, 0x2E, 0xB6, 0x88, 0xAC, 0xB0, 0x43, 0x37, 0xAB, 0x3E, 0xB4,
+ 0x3E, 0x22, 0x37, 0x22, 0xAF, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0xAA, 0x52, 0xE2, 0x2B, 0x12, 0x62, 0x63, 0x3A, 0x24, 0xA2,
+ 0x5C, 0x36, 0x39, 0xF0, 0x96, 0x2E, 0x01, 0x00
+};
+
+/* AC FXS RF14 German Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_DE[] =
+{
+  /* AC Profile */
+ 0x27, 0x00, 0xD7, 0x4C, 0x01, 0x49, 0xCA, 0xDB, 0x98, 0xBA, 0xA1, 0xBA,
+ 0x22, 0x2A, 0xF4, 0xAA, 0xAB, 0x22, 0x65, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xA3, 0x10, 0x2B, 0x29, 0x53, 0xB9, 0xBD, 0xB3,
+ 0x7B, 0xCC, 0xDB, 0xA6, 0x88, 0x2A, 0xB0, 0x2B, 0x9F, 0x2E, 0x3E, 0x22,
+ 0xBE, 0xC3, 0x26, 0x35, 0x2F, 0x82, 0xB8, 0x71, 0x80, 0xAB, 0xF0, 0x50,
+ 0x00, 0x86, 0xCA, 0x5A, 0xA2, 0xBA, 0x1F, 0x22, 0x3B, 0x2A, 0x23, 0x2B,
+ 0x3A, 0x24, 0x4B, 0x40, 0x96, 0x22, 0x21, 0x00
+};
+
+/* AC FXS RF14 China Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_CN[] =
+{
+  /* AC Profile */
+ 0xEF, 0x00, 0x46, 0x4C, 0x01, 0x49, 0xCA, 0xDA, 0x98, 0xB3, 0xB1, 0x23,
+ 0x32, 0x64, 0x97, 0xAA, 0x2B, 0x4A, 0xA4, 0x9A, 0x01, 0x90, 0x01, 0x01,
+ 0x90, 0x8A, 0x2E, 0x01, 0xCD, 0x10, 0x2B, 0x29, 0x22, 0x2A, 0xA2, 0x33,
+ 0x4B, 0x4C, 0xBD, 0xF6, 0x88, 0x2A, 0xC0, 0x52, 0x97, 0xF2, 0x2E, 0xAA,
+ 0x4E, 0xAC, 0xB5, 0x5B, 0xBE, 0x82, 0xA8, 0x71, 0x80, 0xA9, 0xF0, 0x50,
+ 0x00, 0x86, 0x2A, 0x5A, 0xA2, 0xBA, 0x1B, 0x22, 0xCA, 0x24, 0xC3, 0x43,
+ 0x42, 0xA4, 0x4B, 0x50, 0x96, 0x3C, 0x41, 0x00
+};
+
+/* AC FXS RF14 Australia Wideband Coefficients */
+const VpProfileDataType AC_FXS_RF14_WB_AU[] =
+{
+  /* AC Profile */
+ 0xC2, 0x00, 0x2E, 0x4C, 0x01, 0x49, 0xCA, 0xF0, 0x98, 0xBA, 0xA1, 0xAD,
+ 0xA3, 0xA2, 0x2C, 0x2D, 0xAB, 0x22, 0xD4, 0x9A, 0xCC, 0xA2, 0x97, 0x9F,
+ 0x01, 0x8A, 0x2E, 0x01, 0x7A, 0x10, 0xBA, 0x29, 0x2A, 0x3A, 0xA2, 0x32,
+ 0xB2, 0xAA, 0xF2, 0xA4, 0x88, 0xBA, 0xA0, 0x5C, 0x3F, 0x2C, 0xCE, 0xAA,
+ 0x87, 0xC2, 0x66, 0xDB, 0x7E, 0x82, 0xA8, 0x71, 0x80, 0x39, 0x70, 0x50,
+ 0x00, 0x86, 0xAA, 0x59, 0x81, 0x25, 0x1A, 0xA1, 0xBB, 0x2B, 0xB3, 0x2C,
+ 0x46, 0xD5, 0xBC, 0x60, 0x96, 0xAA, 0xB1, 0x00
+};
+
+/************** DC Feed Parameters **************/
+
+/* 22mA  current feed */
+const VpProfileDataType DC_22MA_CC[] = 
+{
+ /* DC Profile */
+ 0x00, 0x01, 0x01, 0x0B, 0x01, 0x08, 0xC2, 0x1A, 0x88, 0xD0, 0x05, 0xC6,
+ 0x11, 0x04, 0x01
+};
+
+/************** Ring Signal Parameters **************/
+
+/* Default Rnging, 25Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_DEF[] = 
+{
+  /* Sine, 25 Hz, 1.41 CF, 70.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x44,
+ 0x3A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* US Ringing, 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_US[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Canada Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_CA[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* France Ringing 50Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_FR[] = 
+{
+  /* Sine, 50 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x88,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Japan Ringing 16Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_JP[] = 
+{
+  /* Sine, 16 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x2B,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* S. Korea Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_KR[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Taiwan Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_TW[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Hong Kong Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_HK[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Singapore Rnging, 24Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_SG[] = 
+{
+  /* Sine, 24 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x41,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Austria Ringing 50Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_AT[] = 
+{
+  /* Sine, 50 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x88,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+/* Australia Ringing 20Hz, Sinewave, 80Vpk */
+const VpProfileDataType RING_AU[] = 
+{
+  /* Sine, 20 Hz, 1.41 CF, 80.00 Vpk, 0.00 Bias */
+  /* Ringing Profile */
+ 0x00, 0x04, 0x00, 0x12, 0x00, 0x0E, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x36,
+ 0x42, 0x55, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00
+};
+
+
+/************** Call Progress Tones **************/
+
+/************** Cadence Definitions **************/
+/* RING Cadence Profile */
+const VpProfileDataType RING_CAD_STD[] = 
+{
+  /* Cadence Profile */
+ 0x00, 0x08, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x07, 0x21, 0x90,
+ 0x01, 0x00, 0x23, 0x20, 0x40, 0x00
+};
+
+/************** Caller ID **************/
+
+/************** Metering Profile **************/
+
+int dev_profile_size = sizeof(ABS_VBL_FLYBACK);
+int dc_profile_size = sizeof(DC_22MA_CC);
+int ac_profile_size = sizeof(AC_FXS_RF14_DEF);
+int ring_profile_size = sizeof(RING_DEF);
+
+/* end of file profile_8266.c */
diff --git a/tools/voice/zarlink/profile_88266.h b/tools/voice/zarlink/profile_88266.h
new file mode 100644
index 0000000..f53a0ad
--- /dev/null
+++ b/tools/voice/zarlink/profile_88266.h
@@ -0,0 +1,98 @@
+/*
+ * profile_8266.h --
+ *
+ * This header file exports the Profile data types
+ *
+ * Project Info --
+ *   File:  C:\Documents and Settings\benavi\Desktop\tmp\NewProject.vpw
+ *   Type:  Le71HR0865G Line Module Project - VBL Reg ABS Power Supply and 8.192MHz PCLK
+ *   Date:  Thursday, February 25, 2010 16:58:41
+ *
+ *   This file was generated with Profile Wizard Version: P1.12.3
+ */
+
+#ifndef PROFILE_8266_H
+#define PROFILE_8266_H
+
+#ifdef VP_API_TYPES_H
+#include "vp_api_types.h"
+#else
+typedef unsigned char VpProfileDataType;
+#endif
+
+extern int dev_profile_size;
+extern int dc_profile_size;
+extern int ac_profile_size;
+extern int ring_profile_size;
+
+/************** Device Parameters **************/
+/* Device Profile */
+extern const VpProfileDataType ABS_VBL_FLYBACK[];
+
+/************** AC Filter Coefficients **************/
+extern const VpProfileDataType AC_FXS_RF14_DEF[];    /* AC FXS RF14 600 Ohm Coefficients [Default} */
+extern const VpProfileDataType AC_FXS_RF14_900[];    /* AC FXS RF14 900 Ohm Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_AU[];     /* AC FXS RF14 Australia 220+820//220nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_AT[];     /* AC FXS RF14 Austria 220+820//115nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_BE[];     /* AC FXS RF14 Belgium 150+830//72 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_BR[];     /* AC FXS RF14 Brazil 900 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_CN[];     /* AC FXA RF14 China 200+680//100nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_CZ[];     /* AC FXS RF14 Czech Republic 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_DK[];     /* AC FXS RF14 Denmark 300+1000//220nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_EU[];     /* AC FXS RF14 ETSI 270+750//150nF Harmonized Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_FI[];     /* AC FXS RF14 Finland 270+910//120 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_FR[];     /* AC FXS RF14 France 215+1000//137nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_DE[];     /* AC FXS RF14 German 220+820//115nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_GR[];     /* AC FXS RF14 Greece 400+500//50nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_HU[];     /* AC FXS RF14 Hungary 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_IN[];     /* AC FXS RF14 India 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_IT[];     /* AC FXS RF14 Italy 180+630//60nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_JP[];     /* AC FXS RF14 Japan 600+1uF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_KR[];     /* AC FXS RF14 S. Korea 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_MX[];     /* AC FXS RF14 Mexico 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NL[];     /* AC FXS RF14 Netherlands 600/340+422//100 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NZ[];     /* AC FXS RF14 New Zealand 370+620//310nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_NO[];     /* AC FXS RF14 Norway 120+820//110nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_PT[];     /* AC FXS RF14 Portugal 600 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_SI[];     /* AC FXS RF14 Slovenia 600/220+820//115 Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_ES[];     /* AC FXS RF14 Spain 220+820//120nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_SE[];     /* AC FXS RF14 Sweden 200+1000//100nF_900//30nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_GB[];     /* AC FXS RF14 U.K. 300+1000//220_370+620//310nF Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_loaded[];/* AC FXS RF14 US 900//2.16uF_1650//(100+5nF) Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_Nonloaded[];/* AC FXS RF14 US 900//2,16uF_800//(100+50nF) Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_US_SS[];  /* AC FXS RF14 US 900//2.16uF Coefficients */
+
+/************** WideBand AC Filter Coefficients **************/
+extern const VpProfileDataType AC_FXS_RF14_WB_US[];  /* AC FXS RF14 600 Ohm Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_EU[];  /* AC FXS RF14 European Union Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_FR[];  /* AC FXS RF14 France Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_DE[];  /* AC FXS RF14 German Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_CN[];  /* AC FXS RF14 China Wideband Coefficients */
+extern const VpProfileDataType AC_FXS_RF14_WB_AU[];  /* AC FXS RF14 Australia Wideband Coefficients */
+
+/************** DC Feed Parameters **************/
+extern const VpProfileDataType DC_22MA_CC[];         /* 22mA  current feed */
+
+/************** Ring Signal Parameters **************/
+extern const VpProfileDataType RING_DEF[];           /* Default Rnging, 25Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_US[];            /* US Ringing, 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_CA[];            /* Canada Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_FR[];            /* France Ringing 50Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_JP[];            /* Japan Ringing 16Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_KR[];            /* S. Korea Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_TW[];            /* Taiwan Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_HK[];            /* Hong Kong Ringing 20Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_SG[];            /* Singapore Rnging, 24Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_AT[];            /* Austria Ringing 50Hz, Sinewave, 80Vpk */
+extern const VpProfileDataType RING_AU[];            /* Australia Ringing 20Hz, Sinewave, 80Vpk */
+
+/************** Call Progress Tones **************/
+
+/************** Cadence Definitions **************/
+extern const VpProfileDataType RING_CAD_STD[]; 
+/************** Caller ID **************/
+
+/************** Metering Profile **************/
+
+#endif /* PROFILE_8266_H */
+
diff --git a/tools/voice/zarlink/vpapi_lib.c b/tools/voice/zarlink/vpapi_lib.c
new file mode 100644
index 0000000..8332b2e
--- /dev/null
+++ b/tools/voice/zarlink/vpapi_lib.c
@@ -0,0 +1,432 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include "vpapi_lib.h"
+
+/* Locals */
+static char dev_name[] = "/dev/vpapi";
+static int dev_fd = 0;
+static char lib_str[] = "[vpapi_lib]:";
+
+int vpapi_open_device(void)
+{
+	int fdflags;
+
+	/* open the device */
+	dev_fd = open(dev_name, O_RDWR); 
+	if (dev_fd <= 0) {
+		printf("Cannot open %s device\n", dev_name);
+		return -1;
+	}
+
+	/* set some flags */
+	fdflags = fcntl(dev_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(dev_fd, F_SETFL, fdflags);
+
+	return 0;
+}
+
+int vpapi_close_device(void)
+{
+	if(dev_fd > 0)
+		close(dev_fd);
+
+	return 0;	
+}
+
+VpStatusType vpapi_make_dev_object(VpDeviceType dev_type, VpDeviceIdType dev_id)
+{
+	VpApiModMkDevObjType data;
+
+	data.deviceType = dev_type;
+	data.deviceId = dev_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MK_DEV_OBJ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MK_DEV_OBJ) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_make_line_object(VpTermType term_type, VpLineIdType line_id)
+{
+	VpApiModMkLnObjType data;
+
+	data.termType = term_type;
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MK_LN_OBJ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MK_LN_OBJ) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_map_line_id(VpLineIdType line_id)
+{
+	VpApiModMapLnIdType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MAP_LN_ID, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MAP_LN_ID) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_map_slac_id(VpDeviceIdType dev_id, unsigned char slac_id)
+{
+	VpApiModMapSlacIdType data;
+
+	data.deviceId = dev_id;
+	data.slacId = slac_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_MAP_SLAC_ID, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_MAP_SLAC_ID) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_free_line_context(VpLineIdType line_id)
+{
+	VpApiModFreeLnCtxType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_FREE_LN_CTX, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_FREE_LN_CTX) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_init_device(VpDeviceIdType dev_id, VpProfilePtrType dev_profile_ptr,
+				VpProfilePtrType ac_profile_ptr, VpProfilePtrType dc_profile_ptr,
+				VpProfilePtrType ring_profile_ptr, VpProfilePtrType fxo_ac_profile_ptr,
+				VpProfilePtrType fxo_cfg_profile_ptr, vpapi_init_device_params_t *params_ptr)
+{
+	VpApiModInitDeviceType data;
+
+	data.deviceId = dev_id;
+	data.pDevProfile = dev_profile_ptr;
+	data.pAcProfile = ac_profile_ptr;
+	data.pDcProfile = dc_profile_ptr;
+	data.pRingProfile = ring_profile_ptr;
+	data.pFxoAcProfile = fxo_ac_profile_ptr;
+	data.pFxoCfgProfile = fxo_cfg_profile_ptr;
+	data.devProfileSize = params_ptr->dev_size;
+	data.acProfileSize = params_ptr->ac_size;
+	data.dcProfileSize = params_ptr->dc_size;
+	data.ringProfileSize = params_ptr->ring_size;
+	data.fxoAcProfileSize = params_ptr->fxo_ac_size;
+	data.fxoCfgProfileSize = params_ptr->fxo_cfg_size;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_INIT_DEV, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_INIT_DEV) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_cal_line(VpLineIdType line_id)
+{
+	VpApiModCalLnType data;
+
+	data.lineId = line_id;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_CAL_LN, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_CAL_LN) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_set_line_state(VpLineIdType line_id, VpLineStateType state)
+{
+	VpApiModSetLnStType data;
+
+	data.lineId = line_id;
+	data.state = state;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_SET_LN_ST, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_SET_LN_ST) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+VpStatusType vpapi_set_option(unsigned char line_request, VpLineIdType line_id, 
+				VpDeviceIdType dev_id, VpOptionIdType option, void *value_p)
+{
+	VpApiModSetOptionType data;
+	
+	data.lineRequest = line_request;
+	data.lineId = line_id;
+	data.deviceId = dev_id;
+	data.option = option;
+	data.pValue = value_p;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return VP_STATUS_FAILURE;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_SET_OPTION, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_SET_OPTION) failed\n");
+		return VP_STATUS_FAILURE;
+	}
+
+	return data.status;
+}
+
+bool vpapi_get_event(VpDeviceIdType dev_id, VpEventType *event_p)
+{
+	VpApiModGetEventType data;
+
+	data.deviceId = dev_id;
+	data.pEvent = event_p;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return false;
+	}
+
+	
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_GET_EVENT, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_GET_EVENT) failed\n");
+		return false;
+	}
+
+	return data.newEvent;
+}
+
+int vpapi_check_event(void)
+{
+	fd_set ex_fds;
+	struct timeval timeout = {0, 1};
+	int ret;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return 1;
+	}
+
+	FD_ZERO(&ex_fds);
+	FD_SET(dev_fd, &ex_fds);
+
+	/* Wait for event  */
+	ret = select(dev_fd+1, NULL, NULL, &ex_fds, &timeout);
+
+	if(FD_ISSET(dev_fd, &ex_fds))
+		return 0;
+	else
+		return 1;
+}
+
+int vpapi_battary_on(int vbh, int vbl, int vbp)
+{
+	VpModBatteryOnType data;
+
+	data.vbh = vbh;
+	data.vbl = vbl;
+	data.vbp = vbp;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_BATT_ON, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_BATT_ON) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int vpapi_battery_off(void)
+{
+	VpModBatteryOffType data;
+
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_BATT_OFF, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_BATT_OFF) failed\n");
+		return -1;
+	}
+
+	return data.status;
+}
+
+int vpapi_slic_reg_read(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	VpModRegOpType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.lineId = line_id;
+	data.cmd = cmd;
+	data.cmdLen = cmd_len;
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_REG_READ, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_REG_READ) failed\n");
+		return -1;
+	}
+
+	memcpy(buff, data.buff, cmd_len);
+
+	return 0;
+}
+
+int vpapi_slic_reg_write(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff)
+{
+	VpModRegOpType data;
+	
+	if (dev_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return -1;
+	}
+
+	data.lineId = line_id;
+	data.cmd = cmd;
+	data.cmdLen = cmd_len;
+	memcpy(data.buff, buff, cmd_len);
+
+	if (ioctl(dev_fd, VPAPI_MOD_IOX_REG_WRITE, &data) < 0) {
+		printf("ioctl(VPAPI_MOD_IOX_REG_WRITE) failed\n");
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/tools/voice/zarlink/vpapi_lib.h b/tools/voice/zarlink/vpapi_lib.h
new file mode 100644
index 0000000..da4ab0b
--- /dev/null
+++ b/tools/voice/zarlink/vpapi_lib.h
@@ -0,0 +1,102 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _VPAPI_LIB_H
+#define _VPAPI_LIB_H
+
+#include <stdbool.h>
+#include <slic/vpapi_dev.h>
+
+typedef struct vpapi_init_device_params {
+	unsigned short dev_size;
+	unsigned short ac_size;
+	unsigned short dc_size;
+	unsigned short ring_size;
+	unsigned short fxo_ac_size;
+	unsigned short fxo_cfg_size;
+} vpapi_init_device_params_t;
+
+int vpapi_open_device(void);
+int vpapi_close_device(void);
+int vpapi_check_event(void);
+VpStatusType vpapi_make_dev_object(VpDeviceType dev_type, VpDeviceIdType dev_id);
+VpStatusType vpapi_make_line_object(VpTermType term_type, VpLineIdType line_id);
+VpStatusType vpapi_map_line_id(VpLineIdType line_id);
+VpStatusType vpapi_map_slac_id(VpDeviceIdType dev_id, unsigned char slac_id);
+VpStatusType vpapi_free_line_context(VpLineIdType line_id);
+VpStatusType vpapi_init_device(VpDeviceIdType dev_id, VpProfilePtrType dev_profile_ptr,
+				VpProfilePtrType ac_profile_ptr, VpProfilePtrType dc_profile_ptr,
+				VpProfilePtrType ring_profile_ptr, VpProfilePtrType fxo_ac_profile_ptr,
+				VpProfilePtrType fxo_cfg_profile_ptr, vpapi_init_device_params_t *params_ptr);
+VpStatusType vpapi_cal_line(VpLineIdType line_id);
+VpStatusType vpapi_set_line_state(VpLineIdType line_id, VpLineStateType state);
+VpStatusType vpapi_set_option(unsigned char line_request, VpLineIdType line_id, VpDeviceIdType dev_id,
+				VpOptionIdType option, void *value_p);
+bool vpapi_get_event(VpDeviceIdType dev_id, VpEventType *event_p);
+int vpapi_battary_on(int vbh, int vbl, int vbp);
+int vpapi_battery_off(void);
+int vpapi_slic_reg_read(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+int vpapi_slic_reg_write(VpLineIdType line_id, unsigned char cmd, unsigned char cmd_len, unsigned char *buff);
+
+#endif /* _VPAPI_LIB_H */
-- 
1.7.5.4

