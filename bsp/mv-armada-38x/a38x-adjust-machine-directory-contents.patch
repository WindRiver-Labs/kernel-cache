From 3f23b59add384d4d143f80b67983a5c1e021bdc3 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Thu, 10 Oct 2013 12:30:11 +0200
Subject: [PATCH 1094/1825] a38x: adjust machine directory contents

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit bd3726912fc6ee9a0e61aad5fa50ef5ab2b085b7

	- substitute all references to a375 by a38x
	- disable LFPS frequency workaround for USB3 as it causes
	  kernel hang while booting linux on db-a375

Change-Id: Ib744afe9f5000f1540bc2398b6b5d2ab3f352e11
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3631
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/Kconfig                    |   56 ++--
 arch/arm/mach-armada38x/Makefile                   |   53 ++--
 arch/arm/mach-armada38x/ca9x2.h                    |   10 +-
 arch/arm/mach-armada38x/config/mvRules.mk          |   18 +-
 arch/arm/mach-armada38x/core.c                     |  292 ++++++++++----------
 arch/arm/mach-armada38x/core.h                     |    8 +-
 arch/arm/mach-armada38x/headsmp.S                  |   18 +-
 arch/arm/mach-armada38x/hwmon.c                    |  118 ++++----
 arch/arm/mach-armada38x/include/mach/armada380.h   |  141 ----------
 arch/arm/mach-armada38x/include/mach/armada38x.h   |  141 ++++++++++
 arch/arm/mach-armada38x/include/mach/debug-macro.S |    2 +-
 arch/arm/mach-armada38x/include/mach/gpio.h        |    2 +-
 arch/arm/mach-armada38x/include/mach/hardware.h    |    2 +-
 arch/arm/mach-armada38x/include/mach/io.h          |    2 +-
 arch/arm/mach-armada38x/include/mach/serial.h      |    2 +-
 arch/arm/mach-armada38x/include/mach/smp.h         |    2 +-
 arch/arm/mach-armada38x/include/mach/uncompress.h  |    2 +-
 arch/arm/mach-armada38x/include/mach/vmalloc.h     |    2 +-
 arch/arm/mach-armada38x/irq.c                      |   66 +++---
 arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c       |    2 +-
 arch/arm/mach-armada38x/platsmp.c                  |    4 +-
 arch/arm/mach-armada38x/sysmap.c                   |    8 +-
 arch/arm/mach-armada38x/time.c                     |   68 +++---
 arch/arm/mach-armada38x/usb.c                      |    4 +-
 24 files changed, 510 insertions(+), 513 deletions(-)
 delete mode 100644 arch/arm/mach-armada38x/include/mach/armada380.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/armada38x.h

diff --git a/arch/arm/mach-armada38x/Kconfig b/arch/arm/mach-armada38x/Kconfig
index b94f9a1..1843428 100644
--- a/arch/arm/mach-armada38x/Kconfig
+++ b/arch/arm/mach-armada38x/Kconfig
@@ -1,29 +1,32 @@
-if ARCH_ARMADA380
+if ARCH_ARMADA38X
 
-config  MV_HAL_RULES_PATH
+config MV_HAL_RULES_PATH
 	string "path of the mvRules.mk file for HAL drivers"
-	default "arch/arm/mach-armada380/mv_hal_support/mvRules.mk"
-	help
-	  No help currently.
+	default "arch/arm/mach-armada38x/mv_hal_support/mvRules.mk"
 
-config A380_CPU1_ENABLE_WA
+config A38X_CPU1_ENABLE_WA
 	depends on SMP
 	bool "SMP CPU1 Enable WA"
 	default y
+	help
+	  Due to internal bootrom issue, CPU[1] initial jump code
+	  (four instructions) should be placed in SoC SRAM memory.
+	  Furthermore, MMU and SoC memory windows should be configured
+	  appropriately to enable CPU[1] to boot.
 
-menu "Marvell Armada-380 Options"
+menu "Marvell Armada-38x Options"
 
-config ARMADA_380
-	bool "Armada-380 SoC Family"
+config ARMADA_38X
+	bool "Armada-38x SoC Family"
 	default y
 
 choice
-	prompt "Armada-380 Chip revision"
-	depends on ARMADA_380
-	default ARMADA_380_REV_XX
+	prompt "Armada-38x Chip revision"
+	depends on ARMADA_38X
+	default ARMADA_38X_REV_XX
 
-config  ARMADA_380_REV_XX
-	bool "Armada-380 SoC devices"
+config  ARMADA_38X_REV_XX
+	bool "Armada-38x SoC devices"
 	select ARM_GIC
 	select ARM_ERRATA_720789
 	select ARM_ERRATA_751472
@@ -31,21 +34,16 @@ config  ARMADA_380_REV_XX
 	select NEON
 	help
 	  Choosing this option will generate a linux kernel for the
-	  Armada-380 devices
+	  Armada-38x devices
 
 endchoice
 
-config MACH_ARMADA_380
-	bool "Marvell Armada-380 SoC Family"
+config MACH_ARMADA_38X
+	bool "Marvell Armada-38x SoC Family"
 	default y
 	help
-	  No help currently.
-
-config CFU_DRAM_BYPASS
-        bool "Bypass CFU to DRAM via Punit"
-	default n
-	help
-	  No help currently.
+	  Choosing this option will generate a linux kernel for the
+	  MV68XX devices
 
 config A375_FIRST_DABT_WA
 	bool "Discard first data abort"
@@ -54,22 +52,20 @@ config A375_FIRST_DABT_WA
 	  Workaround that discards first data abort to avoid getting
 	  unhandled fault on boot.
 
-config A380_Z1_USB3_LFPS_FREQ_WA
+config A38X_Z1_USB3_LFPS_FREQ_WA
 	bool "Enable the LFPS frequency workaround for USB3"
 	default n
 	help
-	  This flag enables a workaround for USB3 in Armada 380. It
+	  This flag enables a workaround for USB3 in Armada 38x. It
 	  fixes the USB3 LFPS timing to fix some clock issues
 	  in the integration of USB3. This WA is needed only
 	  for Z1 devices
 
-
-
-config ARMADA_380_USE_LEGACY_USB2
+config ARMADA_38X_USE_LEGACY_USB2
 	bool "Use legacy USB2 IP instead of USB3 IP"
 	default n
 	help
-	 Armada 380 contain 2 USB host controllers: A legacy USB2
+	 Armada 38x contain 2 USB host controllers: A legacy USB2
 	 only controller and a new USB3 controller which also supports USB2.
 	 This flag enables to choose which of the host controllers to use.
 	 It mainly affects the USB2 PHY to host connectivity
diff --git a/arch/arm/mach-armada38x/Makefile b/arch/arm/mach-armada38x/Makefile
index 2aae2cc..8801146 100644
--- a/arch/arm/mach-armada38x/Makefile
+++ b/arch/arm/mach-armada38x/Makefile
@@ -13,7 +13,7 @@
 # DISCLAIMED.  The GPL License provides additional details about this warranty
 # disclaimer.
 #*******************************************************************************/
-include		  $(srctree)/arch/arm/mach-armada380/config/mvRules.mk
+include		  $(srctree)/arch/arm/mach-armada38x/config/mvRules.mk
 
 
 # Objects list
@@ -54,25 +54,25 @@ QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrv
 
 LSP_OBJS        = core.o irq.o sysmap.o export.o time.o
 
-obj-y					:= armada380.o
+obj-y					:= armada38x.o
 obj-$(CONFIG_LOCAL_TIMERS)		+= localtimer.o
-armada380-objs				:= $(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS)	\
+armada38x-objs				:= $(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS)	\
 					   $(KW_FAM_OBJS)
 
-armada380-$(CONFIG_MV_INCLUDE_SDIO)	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
-armada380-$(CONFIG_MV_INCLUDE_XOR)	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
+armada38x-$(CONFIG_MV_INCLUDE_SDIO)	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
+armada38x-$(CONFIG_MV_INCLUDE_XOR)	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
 					   $(HAL_IF_DIR)/mvSysXor.o
-armada380-$(CONFIG_MV_INCLUDE_PEX)	+= $(HAL_PEX_DIR)/mvPex.o					\
+armada38x-$(CONFIG_MV_INCLUDE_PEX)	+= $(HAL_PEX_DIR)/mvPex.o					\
 					   $(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
-armada380-$(CONFIG_MV_INCLUDE_PCI)	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
-armada380-$(CONFIG_MV_INCLUDE_USB)	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
+armada38x-$(CONFIG_MV_INCLUDE_PCI)	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+armada38x-$(CONFIG_MV_INCLUDE_USB)	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
 					   $(HAL_IF_DIR)/mvSysUsb.o
-armada380-$(CONFIG_MV_INCLUDE_ETH_PHY)	+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
+armada38x-$(CONFIG_MV_INCLUDE_ETH_PHY)	+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
 
 # PP2 Giga driver
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PP2_DIR)/
 
-armada380-$(CONFIG_MV_INCLUDE_CESA)	+= $(HAL_CESA_DIR)/mvCesa.o					\
+armada38x-$(CONFIG_MV_INCLUDE_CESA)	+= $(HAL_CESA_DIR)/mvCesa.o					\
 					   $(HAL_CESA_DIR)/mvCesaDebug.o				\
 					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
 					   $(HAL_CESA_DIR)/mvMD5.o $(HAL_CESA_DIR)/mvSHA1.o		\
@@ -80,17 +80,17 @@ armada380-$(CONFIG_MV_INCLUDE_CESA)	+= $(HAL_CESA_DIR)/mvCesa.o					\
 					   $(HAL_CESA_AES_DIR)/mvAesAlg.o $(HAL_CESA_AES_DIR)/mvAesApi.o\
 					   $(HAL_IF_DIR)/mvSysCesa.o
 
-armada380-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
+armada38x-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
 					   $(HAL_SATA_DIR)/mvSataAddrDec.o
-armada380-$(CONFIG_MV_INCLUDE_SPI)	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o		\
+armada38x-$(CONFIG_MV_INCLUDE_SPI)	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o		\
 					   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
 					   $(HAL_IF_DIR)/mvSysSpi.o
-armada380-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
-armada380-$(CONFIG_MV_INCLUDE_AUDIO)	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
+armada38x-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
+armada38x-$(CONFIG_MV_INCLUDE_AUDIO)	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
 					   $(HAL_AUDIO_DIR)/mvAudioAddrDec.o
-armada380-$(CONFIG_MV_CPU_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
-armada380-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
-armada380-$(CONFIG_MV_CPU_L2_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+armada38x-$(CONFIG_MV_CPU_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
+armada38x-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
+armada38x-$(CONFIG_MV_CPU_L2_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
 
 obj-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(QD_OBJS)
 
@@ -108,18 +108,19 @@ obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)		+= $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(LSP_SWITCH_DIR)/
 obj-y					+= $(LSP_MUX_DIR)/
-obj-$(CONFIG_SENSORS_A380)		+= hwmon.o
+obj-$(CONFIG_SENSORS_A38X)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
 
 
 # LSP part
-armada380-$(CONFIG_MV_INCLUDE_USB)	+= usb.o
-armada380-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
-armada380-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
-armada380-$(CONFIG_FEROCEON_PROC)	+= $(PLAT_DRIVERS)/mv_proc/proc.o
-armada380-$(CONFIG_SMP)			+= platsmp.o headsmp.o
-armada380-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
-armada380-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvSemaphore.o
-armada380-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
+armada38x-$(CONFIG_MV_INCLUDE_USB)	+= usb.o
+armada38x-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+armada38x-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+armada38x-$(CONFIG_FEROCEON_PROC)	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+armada38x-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+armada38x-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
+armada38x-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvSemaphore.o
+armada38x-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
 obj-$(CONFIG_FB_DOVE_CLCD)		+= clcd.o
 obj-$(CONFIG_MV_ETH_NFP) += nfp.o
+
diff --git a/arch/arm/mach-armada38x/ca9x2.h b/arch/arm/mach-armada38x/ca9x2.h
index 4a2fac4..6a1cb16 100644
--- a/arch/arm/mach-armada38x/ca9x2.h
+++ b/arch/arm/mach-armada38x/ca9x2.h
@@ -1,12 +1,12 @@
 #ifndef __MACH_MV_CA9X2_H
 #define __MACH_MV_CA9X2_H
 
-#if defined(CONFIG_SMP) && defined(CONFIG_A380_CPU1_ENABLE_WA)
-void a380_secondary_startup(void);
-void a380_smp_cpu1_enable_wa(void);
+#if defined(CONFIG_SMP) && defined(CONFIG_A38X_CPU1_ENABLE_WA)
+void a38x_secondary_startup(void);
+void a38x_smp_cpu1_enable_wa(void);
 
-extern void *a380_smp_cpu1_enable_code_start;
-extern void *a380_smp_cpu1_enable_code_end;
+extern void *a38x_smp_cpu1_enable_code_start;
+extern void *a38x_smp_cpu1_enable_code_end;
 #endif
 
 /*
diff --git a/arch/arm/mach-armada38x/config/mvRules.mk b/arch/arm/mach-armada38x/config/mvRules.mk
index 790cbab..e7180af 100644
--- a/arch/arm/mach-armada38x/config/mvRules.mk
+++ b/arch/arm/mach-armada38x/config/mvRules.mk
@@ -82,23 +82,23 @@ LSP_PHY_DIR	  = $(PLAT_DRIVERS)/mv_phy
 LSP_MUX_DIR	  = $(PLAT_DRIVERS)/mv_mux
 
 # Environment components
-A380_FAM_DIR	= armada_380_family
-SOC_DEVICE_DIR	= $(A380_FAM_DIR)/device
-SOC_CPU_DIR	= $(A380_FAM_DIR)/cpu
-BOARD_ENV_DIR	= $(A380_FAM_DIR)/boardEnv
-SOC_ENV_DIR	= $(A380_FAM_DIR)/ctrlEnv
-SOC_SYS_DIR	= $(A380_FAM_DIR)/ctrlEnv/sys
+A38X_FAM_DIR	= armada_38x_family
+SOC_DEVICE_DIR	= $(A38X_FAM_DIR)/device
+SOC_CPU_DIR	= $(A38X_FAM_DIR)/cpu
+BOARD_ENV_DIR	= $(A38X_FAM_DIR)/boardEnv
+SOC_ENV_DIR	= $(A38X_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	= $(A38X_FAM_DIR)/ctrlEnv/sys
 HAL_IF_DIR	= mv_hal_if
 
 #####################################################################################################
 # Include path
 ###################################################################################################
 
-LSP_PATH_I	= $(srctree)/arch/arm/mach-armada380
+LSP_PATH_I	= $(srctree)/arch/arm/mach-armada38x
 PLAT_PATH_I	= $(srctree)/arch/arm/plat-armada
 
 HAL_PATH	= -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
-A380_FAM_PATH	= -I$(LSP_PATH_I)/$(A380_FAM_DIR)
+A38X_FAM_PATH	= -I$(LSP_PATH_I)/$(A38X_FAM_DIR)
 QD_PATH		= -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi	\
 		  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
 
@@ -111,7 +111,7 @@ HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF) -I$(LSP_PATH_I)/$(HAL_PP2_DIR)
 DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_PP2_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
 		   -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
 
-EXTRA_INCLUDE	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(A380_FAM_PATH) \
+EXTRA_INCLUDE	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(A38X_FAM_PATH) \
 		  $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
 
 ###################################################################################################
diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 831e335..fbe2641 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -99,7 +99,7 @@ MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = { 0 };
 #define TARGET_DDR              0
 #define COHERENCY_STATUS_SHARED_NO_L2_ALLOC     0x1
 
-struct mbus_dram_target_info a380_mbus_dram_info;
+struct mbus_dram_target_info a38x_mbus_dram_info;
 
 /*******************************************************************************
  * Early Printk Support
@@ -206,7 +206,7 @@ static int __init nfcConfig_setup(char *s)
 
 __setup("nfcConfig=", nfcConfig_setup);
 
-static void __init a380_init_cpu_mbus(void)
+static void __init a38x_init_cpu_mbus(void)
 {
 	void __iomem *addr;
 	int i;
@@ -220,7 +220,7 @@ static void __init a380_init_cpu_mbus(void)
 	/*
 	 * Setup MBUS dram target info.
 	 */
-	a380_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	a38x_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
 	addr = (void __iomem *)BRIDGE_VIRT_BASE;
 
 	for (i = 0, cs = 0; i < 4; i++) {
@@ -235,7 +235,7 @@ static void __init a380_init_cpu_mbus(void)
 			if (base & 0xf)
 				/* BaseExtension is used (> 4GB). */
 				continue;
-			w = &a380_mbus_dram_info.cs[cs++];
+			w = &a38x_mbus_dram_info.cs[cs++];
 			w->cs_index = i;
 			w->mbus_attr = 0xf & ~(1 << i);
 			w->mbus_attr |= coherency_status << 4;
@@ -243,7 +243,7 @@ static void __init a380_init_cpu_mbus(void)
 			w->size = (size | 0x00ffffff) + 1;
 		}
 	}
-	a380_mbus_dram_info.num_cs = cs;
+	a38x_mbus_dram_info.num_cs = cs;
 }
 
 #ifdef CONFIG_MV_INCLUDE_CESA
@@ -266,13 +266,13 @@ unsigned char *mv_sram_usage_get(int *sram_size_ptr)
  * I2C (TWSI)
  */
 #ifdef CONFIG_I2C_MV64XXX
-static struct mv64xxx_i2c_pdata a380_i2c_pdata = {
+static struct mv64xxx_i2c_pdata a38x_i2c_pdata = {
 	.freq_m = 8, /* assumes 166 MHz TCLK */
 	.freq_n = 3,
 	.timeout = 1000, /* Default timeout of 1 second */
 };
 
-static struct resource a380_i2c_0_resources[] = {
+static struct resource a38x_i2c_0_resources[] = {
 	{
 		.name = "i2c base",
 		.start = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0),
@@ -287,17 +287,17 @@ static struct resource a380_i2c_0_resources[] = {
 	},
 };
 
-static struct platform_device a380_i2c0 = {
+static struct platform_device a38x_i2c0 = {
 	.name = MV64XXX_I2C_CTLR_NAME,
 	.id = 0,
-	.num_resources = ARRAY_SIZE(a380_i2c_0_resources),
-	.resource = a380_i2c_0_resources,
+	.num_resources = ARRAY_SIZE(a38x_i2c_0_resources),
+	.resource = a38x_i2c_0_resources,
 	.dev = {
-		.platform_data = &a380_i2c_pdata,
+		.platform_data = &a38x_i2c_pdata,
 	},
 };
 
-static struct resource a380_i2c_1_resources[] = {
+static struct resource a38x_i2c_1_resources[] = {
 	{
 		.name = "i2c base",
 		.start = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(1),
@@ -312,26 +312,26 @@ static struct resource a380_i2c_1_resources[] = {
 	},
 };
 
-static struct platform_device a380_i2c1 = {
+static struct platform_device a38x_i2c1 = {
 	.name = MV64XXX_I2C_CTLR_NAME,
 	.id = 1,
-	.num_resources = ARRAY_SIZE(a380_i2c_1_resources),
-	.resource = a380_i2c_1_resources,
+	.num_resources = ARRAY_SIZE(a38x_i2c_1_resources),
+	.resource = a38x_i2c_1_resources,
 	.dev = {
-		.platform_data = &a380_i2c_pdata,
+		.platform_data = &a38x_i2c_pdata,
 	},
 };
 #endif
 
-static void __init a380_i2c_init(void)
+static void __init a38x_i2c_init(void)
 {
 #ifdef CONFIG_I2C_MV64XXX
 	if (mvUnitMapIsMine(I2C0) == MV_TRUE)
-		platform_device_register(&a380_i2c0);
+		platform_device_register(&a38x_i2c0);
 
 	if (mvCtrlSocUnitInfoNumGet(I2C_UNIT_ID) >= 1 &&
 	    mvUnitMapIsMine(I2C1) == MV_TRUE)
-		platform_device_register(&a380_i2c1);
+		platform_device_register(&a38x_i2c1);
 #endif
 }
 
@@ -476,7 +476,7 @@ static struct platform_device mv_sdio_plat = {
 };
 #endif
 
-void __init a380_sdio_init(void)
+void __init a38x_sdio_init(void)
 {
 #ifdef CONFIG_MV_INCLUDE_SDIO
 	if (mvUnitMapIsMine(SDIO) != MV_TRUE)
@@ -508,10 +508,10 @@ void __init a380_sdio_init(void)
  * USB
  */
 
-void __init a380_usb_init(void)
+void __init a38x_usb_init(void)
 {
 #ifdef CONFIG_MV_INCLUDE_USB
-	mv_usb_init(&a380_mbus_dram_info);
+	mv_usb_init(&a38x_mbus_dram_info);
 #endif
 }
 
@@ -694,7 +694,7 @@ static void __init eth_init(void)
 
 #endif /* CONFIG_MV_ETHERNET */
 
-static void a380_init_eth(void)
+static void a38x_init_eth(void)
 {
 #ifdef CONFIG_MV_ETHERNET
 	mvSysEthPhyInit();
@@ -711,7 +711,7 @@ static struct platform_device mv_gpio = {
 	.num_resources = 0,
 };
 
-static void __init a380_gpio_init(void)
+static void __init a38x_gpio_init(void)
 {
 	platform_device_register(&mv_gpio);
 }
@@ -730,7 +730,7 @@ static struct resource rtc_resource[] = {
 	     }
 };
 
-static void __init a380_rtc_init(void)
+static void __init a38x_rtc_init(void)
 {
 	platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
 }
@@ -741,11 +741,11 @@ static void __init a380_rtc_init(void)
 #ifdef CONFIG_SATA_MV
 #define SATA_PHYS_BASE (INTER_REGS_PHYS_BASE | 0xA0000)
 
-static struct mv_sata_platform_data a380_sata_data = {
+static struct mv_sata_platform_data a38x_sata_data = {
 	.n_ports = 1,
 };
 
-static struct resource a380_sata_resources[] = {
+static struct resource a38x_sata_resources[] = {
 	{
 	 .name = "sata base",
 	 .start = SATA_PHYS_BASE,
@@ -759,43 +759,43 @@ static struct resource a380_sata_resources[] = {
 	     },
 };
 
-static struct platform_device a380_sata = {
+static struct platform_device a38x_sata = {
 	.name = "sata_mv",
 	.id = 0,
 	.dev = {
 		.coherent_dma_mask = 0xffffffff,
 		},
-	.num_resources = ARRAY_SIZE(a380_sata_resources),
-	.resource = a380_sata_resources,
+	.num_resources = ARRAY_SIZE(a38x_sata_resources),
+	.resource = a38x_sata_resources,
 };
 #endif
 
-static void __init a380_sata_init(struct mv_sata_platform_data *sata_data)
+static void __init a38x_sata_init(struct mv_sata_platform_data *sata_data)
 {
 #ifdef CONFIG_SATA_MV
 	if (mvUnitMapIsMine(SATA) != MV_TRUE)
 		return;
 
-	a380_sata.dev.platform_data = sata_data;
-	sata_data->dram = &a380_mbus_dram_info;
-	platform_device_register(&a380_sata);
+	a38x_sata.dev.platform_data = sata_data;
+	sata_data->dram = &a38x_mbus_dram_info;
+	platform_device_register(&a38x_sata);
 #endif
 }
 
 /*******************************************************************************
  * SoC hwmon Thermal Sensor
  */
-static void __init a380_hwmon_init(void)
+static void __init a38x_hwmon_init(void)
 {
 	if (mvUnitMapIsMine(HWMON) == MV_TRUE)
-		platform_device_register_simple("a380-temp", 0, NULL, 0);
+		platform_device_register_simple("a38x-temp", 0, NULL, 0);
 }
 
 /*******************************************************************************
  * NAND controller
  */
 #ifdef CONFIG_MTD_NAND_NFC
-static struct resource a380_nfc_resources[] = {
+static struct resource a38x_nfc_resources[] = {
 	{
 	 .start = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET,
 	 .end = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET + 0x400 - 1,
@@ -816,7 +816,7 @@ static struct mtd_partition nand_parts_info[] = {
 						   .size = MTDPART_SIZ_FULL},
 };
 
-static struct nfc_platform_data a380_nfc_data = {
+static struct nfc_platform_data a38x_nfc_data = {
 	.nfc_width = 8,
 	.num_devs = 1,
 	.num_cs = 1,
@@ -826,18 +826,18 @@ static struct nfc_platform_data a380_nfc_data = {
 	.nr_parts = ARRAY_SIZE(nand_parts_info),
 };
 
-static struct platform_device a380_nfc = {
+static struct platform_device a38x_nfc = {
 	.name = "armada-nand",
 	.id = 0,
 	.dev = {
-		.platform_data = &a380_nfc_data,
+		.platform_data = &a38x_nfc_data,
 		},
-	.num_resources = ARRAY_SIZE(a380_nfc_resources),
-	.resource = a380_nfc_resources,
+	.num_resources = ARRAY_SIZE(a38x_nfc_resources),
+	.resource = a38x_nfc_resources,
 };
 #endif
 
-static void __init a380_nand_nfc_init(void)
+static void __init a38x_nand_nfc_init(void)
 {
 #ifdef CONFIG_MTD_NAND_NFC
 	if (mvUnitMapIsMine(NAND) != MV_TRUE)
@@ -846,23 +846,23 @@ static void __init a380_nand_nfc_init(void)
 	/* Check for ganaged mode */
 	if (nfcConfig) {
 		if (strncmp(nfcConfig, "ganged", 6) == 0) {
-			a380_nfc_data.nfc_width = 16;
-			a380_nfc_data.num_devs = 2;
+			a38x_nfc_data.nfc_width = 16;
+			a38x_nfc_data.num_devs = 2;
 			nfcConfig += 7;
 		}
 
 		/* Check for ECC type directive */
 		if (strcmp(nfcConfig, "8bitecc") == 0)
-			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
+			a38x_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
 		else if (strcmp(nfcConfig, "12bitecc") == 0)
-			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
+			a38x_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
 		else if (strcmp(nfcConfig, "16bitecc") == 0)
-			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
+			a38x_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
 	}
 
-	a380_nfc_data.tclk = mvBoardTclkGet();
+	a38x_nfc_data.tclk = mvBoardTclkGet();
 
-	platform_device_register(&a380_nfc);
+	platform_device_register(&a38x_nfc);
 #endif
 }
 
@@ -870,16 +870,16 @@ static void __init a380_nand_nfc_init(void)
  * XOR
  */
 #ifdef CONFIG_MV_INCLUDE_XOR
-static struct mv_xor_platform_shared_data a380_xor_shared_data = {
-	.dram = &a380_mbus_dram_info,
+static struct mv_xor_platform_shared_data a38x_xor_shared_data = {
+	.dram = &a38x_mbus_dram_info,
 };
 
-static u64 a380_xor_dmamask = DMA_BIT_MASK(32);
+static u64 a38x_xor_dmamask = DMA_BIT_MASK(32);
 
 /*
  * XOR0
  */
-static struct resource a380_xor0_shared_resources[] = {
+static struct resource a38x_xor0_shared_resources[] = {
 	{
 	 .name = "xor 0 low",
 	 .start = XOR0_PHYS_BASE,
@@ -893,17 +893,17 @@ static struct resource a380_xor0_shared_resources[] = {
 	     },
 };
 
-static struct platform_device a380_xor0_shared = {
+static struct platform_device a38x_xor0_shared = {
 	.name = MV_XOR_SHARED_NAME,
 	.id = 0,
 	.dev = {
-		.platform_data = &a380_xor_shared_data,
+		.platform_data = &a38x_xor_shared_data,
 		},
-	.num_resources = ARRAY_SIZE(a380_xor0_shared_resources),
-	.resource = a380_xor0_shared_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor0_shared_resources),
+	.resource = a38x_xor0_shared_resources,
 };
 
-static struct resource a380_xor00_resources[] = {
+static struct resource a38x_xor00_resources[] = {
 	[0] = {
 	       .start = IRQ_GLOBAL_XOR0_CHAN0,
 	       .end = IRQ_GLOBAL_XOR0_CHAN0,
@@ -911,25 +911,25 @@ static struct resource a380_xor00_resources[] = {
 	       },
 };
 
-static struct mv_xor_platform_data a380_xor00_data = {
-	.shared = &a380_xor0_shared,
+static struct mv_xor_platform_data a38x_xor00_data = {
+	.shared = &a38x_xor0_shared,
 	.hw_id = 0,
 	.pool_size = PAGE_SIZE,
 };
 
-static struct platform_device a380_xor00_channel = {
+static struct platform_device a38x_xor00_channel = {
 	.name = MV_XOR_NAME,
 	.id = 0,
-	.num_resources = ARRAY_SIZE(a380_xor00_resources),
-	.resource = a380_xor00_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor00_resources),
+	.resource = a38x_xor00_resources,
 	.dev = {
-		.dma_mask = &a380_xor_dmamask,
+		.dma_mask = &a38x_xor_dmamask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &a380_xor00_data,
+		.platform_data = &a38x_xor00_data,
 		},
 };
 
-static struct resource a380_xor01_resources[] = {
+static struct resource a38x_xor01_resources[] = {
 	[0] = {
 	       .start = IRQ_GLOBAL_XOR0_CHAN1,
 	       .end = IRQ_GLOBAL_XOR0_CHAN1,
@@ -937,51 +937,51 @@ static struct resource a380_xor01_resources[] = {
 	       },
 };
 
-static struct mv_xor_platform_data a380_xor01_data = {
-	.shared = &a380_xor0_shared,
+static struct mv_xor_platform_data a38x_xor01_data = {
+	.shared = &a38x_xor0_shared,
 	.hw_id = 1,
 	.pool_size = PAGE_SIZE,
 };
 
-static struct platform_device a380_xor01_channel = {
+static struct platform_device a38x_xor01_channel = {
 	.name = MV_XOR_NAME,
 	.id = 1,
-	.num_resources = ARRAY_SIZE(a380_xor01_resources),
-	.resource = a380_xor01_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor01_resources),
+	.resource = a38x_xor01_resources,
 	.dev = {
-		.dma_mask = &a380_xor_dmamask,
+		.dma_mask = &a38x_xor_dmamask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &a380_xor01_data,
+		.platform_data = &a38x_xor01_data,
 		},
 };
 
-static void __init a380_xor0_init(void)
+static void __init a38x_xor0_init(void)
 {
 	if (mvUnitMapIsMine(XOR0) != MV_TRUE)
 		return;
 
-	platform_device_register(&a380_xor0_shared);
+	platform_device_register(&a38x_xor0_shared);
 
 #ifndef CONFIG_A375_IOCC_SYNC_BARRIER_WA
 	/*
 	 * two engines can't do memset simultaneously, this limitation
 	 * satisfied by removing memset support from one of the engines.
 	 */
-	dma_cap_set(DMA_MEMCPY, a380_xor00_data.cap_mask);
-	dma_cap_set(DMA_XOR, a380_xor00_data.cap_mask);
-	platform_device_register(&a380_xor00_channel);
-
-	dma_cap_set(DMA_MEMCPY, a380_xor01_data.cap_mask);
-	dma_cap_set(DMA_MEMSET, a380_xor01_data.cap_mask);
-	dma_cap_set(DMA_XOR, a380_xor01_data.cap_mask);
-	platform_device_register(&a380_xor01_channel);
+	dma_cap_set(DMA_MEMCPY, a38x_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, a38x_xor00_data.cap_mask);
+	platform_device_register(&a38x_xor00_channel);
+
+	dma_cap_set(DMA_MEMCPY, a38x_xor01_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, a38x_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, a38x_xor01_data.cap_mask);
+	platform_device_register(&a38x_xor01_channel);
 #endif
 }
 
 /*
  * XOR1
  */
-static struct resource a380_xor1_shared_resources[] = {
+static struct resource a38x_xor1_shared_resources[] = {
 	{
 	 .name = "xor 1 low",
 	 .start = XOR1_PHYS_BASE,
@@ -995,17 +995,17 @@ static struct resource a380_xor1_shared_resources[] = {
 	     },
 };
 
-static struct platform_device a380_xor1_shared = {
+static struct platform_device a38x_xor1_shared = {
 	.name = MV_XOR_SHARED_NAME,
 	.id = 1,
 	.dev = {
-		.platform_data = &a380_xor_shared_data,
+		.platform_data = &a38x_xor_shared_data,
 		},
-	.num_resources = ARRAY_SIZE(a380_xor1_shared_resources),
-	.resource = a380_xor1_shared_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor1_shared_resources),
+	.resource = a38x_xor1_shared_resources,
 };
 
-static struct resource a380_xor10_resources[] = {
+static struct resource a38x_xor10_resources[] = {
 	[0] = {
 	       .start = IRQ_GLOBAL_XOR1_CHAN0,
 	       .end = IRQ_GLOBAL_XOR1_CHAN0,
@@ -1013,25 +1013,25 @@ static struct resource a380_xor10_resources[] = {
 	       },
 };
 
-static struct mv_xor_platform_data a380_xor10_data = {
-	.shared = &a380_xor1_shared,
+static struct mv_xor_platform_data a38x_xor10_data = {
+	.shared = &a38x_xor1_shared,
 	.hw_id = 0,
 	.pool_size = PAGE_SIZE,
 };
 
-static struct platform_device a380_xor10_channel = {
+static struct platform_device a38x_xor10_channel = {
 	.name = MV_XOR_NAME,
 	.id = 2,
-	.num_resources = ARRAY_SIZE(a380_xor10_resources),
-	.resource = a380_xor10_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor10_resources),
+	.resource = a38x_xor10_resources,
 	.dev = {
-		.dma_mask = &a380_xor_dmamask,
+		.dma_mask = &a38x_xor_dmamask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &a380_xor10_data,
+		.platform_data = &a38x_xor10_data,
 		},
 };
 
-static struct resource a380_xor11_resources[] = {
+static struct resource a38x_xor11_resources[] = {
 	[0] = {
 	       .start = IRQ_GLOBAL_XOR1_CHAN1,
 	       .end = IRQ_GLOBAL_XOR1_CHAN1,
@@ -1039,56 +1039,56 @@ static struct resource a380_xor11_resources[] = {
 	       },
 };
 
-static struct mv_xor_platform_data a380_xor11_data = {
-	.shared = &a380_xor1_shared,
+static struct mv_xor_platform_data a38x_xor11_data = {
+	.shared = &a38x_xor1_shared,
 	.hw_id = 1,
 	.pool_size = PAGE_SIZE,
 };
 
-static struct platform_device a380_xor11_channel = {
+static struct platform_device a38x_xor11_channel = {
 	.name = MV_XOR_NAME,
 	.id = 3,
-	.num_resources = ARRAY_SIZE(a380_xor11_resources),
-	.resource = a380_xor11_resources,
+	.num_resources = ARRAY_SIZE(a38x_xor11_resources),
+	.resource = a38x_xor11_resources,
 	.dev = {
-		.dma_mask = &a380_xor_dmamask,
+		.dma_mask = &a38x_xor_dmamask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &a380_xor11_data,
+		.platform_data = &a38x_xor11_data,
 		},
 };
 
-static void __init a380_xor1_init(void)
+static void __init a38x_xor1_init(void)
 {
 	if (mvUnitMapIsMine(XOR1) != MV_TRUE)
 		return;
 
-	platform_device_register(&a380_xor1_shared);
+	platform_device_register(&a38x_xor1_shared);
 
 	/*
 	 * two engines can't do memset simultaneously, this limitation
 	 * satisfied by removing memset support from one of the engines.
 	 */
-	dma_cap_set(DMA_XOR, a380_xor10_data.cap_mask);
-	platform_device_register(&a380_xor10_channel);
+	dma_cap_set(DMA_XOR, a38x_xor10_data.cap_mask);
+	platform_device_register(&a38x_xor10_channel);
 
-	dma_cap_set(DMA_MEMCPY, a380_xor11_data.cap_mask);
-	dma_cap_set(DMA_MEMSET, a380_xor11_data.cap_mask);
-	platform_device_register(&a380_xor11_channel);
+	dma_cap_set(DMA_MEMCPY, a38x_xor11_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, a38x_xor11_data.cap_mask);
+	platform_device_register(&a38x_xor11_channel);
 }
 #endif
 
-static void __init a380_xor_init(void)
+static void __init a38x_xor_init(void)
 {
 #ifdef CONFIG_MV_INCLUDE_XOR
-	a380_xor0_init();
-	a380_xor1_init();
+	a38x_xor0_init();
+	a38x_xor1_init();
 #endif
 }
 
 /*******************************************************************************
  * SPI
  */
-static void a380_spi_init(void)
+static void a38x_spi_init(void)
 {
 #ifdef CONFIG_MV_INCLUDE_SPI
 	/* SPI */
@@ -1105,7 +1105,7 @@ static void print_board_info(void)
 {
 	char name_buff[50];
 
-	pr_info("\n  Marvell Armada-380");
+	pr_info("\n  Marvell Armada-38x");
 
 	mvBoardNameGet(name_buff, 50);
 	pr_info(" %s Board - ", name_buff);
@@ -1134,9 +1134,9 @@ static void print_board_info(void)
  * SMP WA to enable CPU1
  * Note: This function is called before PUnit IO windows are configured.
  */
-#if defined(CONFIG_SMP) && defined(CONFIG_A380_CPU1_ENABLE_WA)
+#if defined(CONFIG_SMP) && defined(CONFIG_A38X_CPU1_ENABLE_WA)
 
-void a380_smp_cpu1_enable_wa(void)
+void a38x_smp_cpu1_enable_wa(void)
 {
 	MV_AHB_TO_MBUS_DEC_WIN mbus_win;
 	u32 code_len, win_num, sram_phys_base = 0xFFFF0000;
@@ -1162,11 +1162,11 @@ void a380_smp_cpu1_enable_wa(void)
 
 	sram_virt_base = ioremap(sram_phys_base, SZ_64K);
 
-	code_len = 4 * (&a380_smp_cpu1_enable_code_end - &a380_smp_cpu1_enable_code_start);
-	memcpy(sram_virt_base, &a380_smp_cpu1_enable_code_start, code_len);
+	code_len = 4 * (&a38x_smp_cpu1_enable_code_end - &a38x_smp_cpu1_enable_code_start);
+	memcpy(sram_virt_base, &a38x_smp_cpu1_enable_code_start, code_len);
 }
 #else
-void a380_smp_cpu1_enable_wa(void)
+void a38x_smp_cpu1_enable_wa(void)
 {
 	/* nothing */
 }
@@ -1179,7 +1179,7 @@ void a380_smp_cpu1_enable_wa(void)
 
 #ifdef CONFIG_A375_IOCC_SYNC_BARRIER_WA
 
-/*	The A380 IOCC SYNC Barrirer WA overcomes the A380 Z1 revision sync barrier issue using the XOR engine.
+/*	The A38X IOCC SYNC Barrirer WA overcomes the A38X Z1 revision sync barrier issue using the XOR engine.
 	When the dma_io_sync is called by each of the CPUs, the correct channel (CPU dependent) is activated
 	to preform a memset operation. The XOR's memset operation provides the required IO transaction that
 	guerentees that the latest data fetched from the IO is coherent.
@@ -1242,7 +1242,7 @@ static void dma_io_sync_wa_init(void)
 #else
 void dma_io_sync(void)
 {
-	/* Need to implement final dma io sync for A380 */
+	/* Need to implement final dma io sync for A38X */
 }
 #endif /* CONFIG_A375_IOCC_SYNC_BARRIER_WA */
 
@@ -1253,7 +1253,7 @@ void dma_io_sync(void)
  *     SMP + HWCC
  *     SMP + SWCC
  */
-static void __init a380_init_iocc(void)
+static void __init a38x_init_iocc(void)
 {
 
 #if !defined(CONFIG_SMP)
@@ -1273,7 +1273,7 @@ void dma_io_sync(void)
 }
 #endif /* CONFIG_AURORA_IO_CACHE_COHERENCY */
 
-static void __init a380_init_l2x0_cache(void)
+static void __init a38x_init_l2x0_cache(void)
 {
 #ifdef CONFIG_CACHE_L2X0
 	void __iomem *l2x0_base =
@@ -1282,14 +1282,14 @@ static void __init a380_init_l2x0_cache(void)
 #endif
 }
 
-static void __init a380_board_init(void)
+static void __init a38x_board_init(void)
 {
 	mvBoardEnvInit();
 	if (mvCtrlEnvInit())
 		pr_err("%s: Error: ctrlEnv init failed.\n", __func__);
 
-	a380_init_cpu_mbus();
-	a380_init_l2x0_cache();
+	a38x_init_cpu_mbus();
+	a38x_init_l2x0_cache();
 
 	/* Init the CPU windows setting and the access protection windows. */
 	if (mvCpuIfInit(mv_sys_map())) {
@@ -1298,7 +1298,7 @@ static void __init a380_board_init(void)
 	}
 
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
-	a380_init_iocc();
+	a38x_init_iocc();
 #endif
 
 	elf_hwcap &= ~HWCAP_JAVA;
@@ -1308,26 +1308,26 @@ static void __init a380_board_init(void)
 	mvCpuIfAddDecShow();
 	print_board_info();
 
-	a380_rtc_init();
-	a380_i2c_init();
-	a380_init_eth();
-	a380_sata_init(&a380_sata_data);
-	a380_xor_init();
-	a380_spi_init();
-	a380_sdio_init();
-	a380_nand_nfc_init();
+	a38x_rtc_init();
+	a38x_i2c_init();
+	a38x_init_eth();
+	a38x_sata_init(&a38x_sata_data);
+	a38x_xor_init();
+	a38x_spi_init();
+	a38x_sdio_init();
+	a38x_nand_nfc_init();
 
-	a380_usb_init();
+	a38x_usb_init();
 #if 0
-	a380_gpio_init();
-	a380_hwmon_init();
+	a38x_gpio_init();
+	a38x_hwmon_init();
 #endif
 }
 
-MACHINE_START(ARMADA_380, "Marvell Armada-380 Board")
+MACHINE_START(ARMADA_38X, "Marvell Armada-38x Board")
 	.atag_offset = BOOT_PARAMS_OFFSET,
-	.map_io = a380_map_io,
-	.init_irq = a380_init_irq,
-	.timer = &a380_timer,
-	.init_machine = a380_board_init,
+	.map_io = a38x_map_io,
+	.init_irq = a38x_init_irq,
+	.timer = &a38x_timer,
+	.init_machine = a38x_board_init,
 MACHINE_END
diff --git a/arch/arm/mach-armada38x/core.h b/arch/arm/mach-armada38x/core.h
index 18f4e7f..31b2f3c 100644
--- a/arch/arm/mach-armada38x/core.h
+++ b/arch/arm/mach-armada38x/core.h
@@ -20,11 +20,11 @@ struct amba_device name##_device = {		\
 
 void __init mv_usb_init(struct mbus_dram_target_info *dram);
 
-extern void a380_init_irq(void);
-extern void a380_secondary_startup(void);
-extern void __init a380_map_io(void);
+extern void a38x_init_irq(void);
+extern void a38x_secondary_startup(void);
+extern void __init a38x_map_io(void);
 extern void __init set_core_count(unsigned int cpu_count);
-extern struct sys_timer a380_timer;
+extern struct sys_timer a38x_timer;
 extern unsigned int elf_hwcap;
 extern u32 mvIsUsbHost;
 extern MV_CPU_DEC_WIN *mv_sys_map(void);
diff --git a/arch/arm/mach-armada38x/headsmp.S b/arch/arm/mach-armada38x/headsmp.S
index 4d910b6..2c12869 100644
--- a/arch/arm/mach-armada38x/headsmp.S
+++ b/arch/arm/mach-armada38x/headsmp.S
@@ -3,23 +3,23 @@
 
 	__INIT
 
-#ifdef CONFIG_A380_CPU1_ENABLE_WA
+#ifdef CONFIG_A38X_CPU1_ENABLE_WA
 
 #define CPU_RESUME_ADDR_REG 0xf10182d4
 
-.global a380_smp_cpu1_enable_code_start
-.global a380_smp_cpu1_enable_code_end
+.global a38x_smp_cpu1_enable_code_start
+.global a38x_smp_cpu1_enable_code_end
 
-ENTRY(a380_smp_cpu1_enable_code_start)
-a380_smp_cpu1_enable_code_start:
+ENTRY(a38x_smp_cpu1_enable_code_start)
+a38x_smp_cpu1_enable_code_start:
 	ldr	r0, [pc, #4]
 	ldr	r1, [r0]
 	mov	pc, r1
 	.word	CPU_RESUME_ADDR_REG
-a380_smp_cpu1_enable_code_end:
-ENDPROC(a380_smp_cpu1_enable_code_end)
+a38x_smp_cpu1_enable_code_end:
+ENDPROC(a38x_smp_cpu1_enable_code_end)
 
-#endif /* CONFIG_A380_CPU1_ENABLE_WA */
+#endif /* CONFIG_A38X_CPU1_ENABLE_WA */
 
 /*
  *   The secondary kernel init calls v7_flush_dcache_all before it enables
@@ -67,7 +67,7 @@ ENDPROC(v7_invalidate_l1)
  * This provides a "holding pen" into which all secondary cores are held
  * until we're ready for them to initialise.
  */
-ENTRY(a380_secondary_startup)
+ENTRY(a38x_secondary_startup)
 	bl      v7_invalidate_l1
 	mrc	p15, 0, r0, c0, c0, 5
 	and	r0, r0, #15
diff --git a/arch/arm/mach-armada38x/hwmon.c b/arch/arm/mach-armada38x/hwmon.c
index c843b15..5b5ded3 100644
--- a/arch/arm/mach-armada38x/hwmon.c
+++ b/arch/arm/mach-armada38x/hwmon.c
@@ -39,14 +39,14 @@
 #define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
 #define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
 
-#define A380_OVERHEAT_TEMP	105	/* milidegree Celsius */
-#define A380_OVERHEAT_DELAY	0x700
-#define A380_OVERCOOL_TEMP	10	/* milidegree Celsius */
-#define	A380_OVERCOOL_DELAY	0x700
-#define A380_OVERHEAT_MIN	0
-#define A380_OVERHEAT_MAX	110000
-#define A380_OVERCOOL_MIN	0
-#define A380_OVERCOOL_MAX	110000
+#define A38X_OVERHEAT_TEMP	105	/* milidegree Celsius */
+#define A38X_OVERHEAT_DELAY	0x700
+#define A38X_OVERCOOL_TEMP	10	/* milidegree Celsius */
+#define	A38X_OVERCOOL_DELAY	0x700
+#define A38X_OVERHEAT_MIN	0
+#define A38X_OVERHEAT_MAX	110000
+#define A38X_OVERCOOL_MIN	0
+#define A38X_OVERCOOL_MAX	110000
 #define PMU_THERMAL_MNGR_REG	0x184c4
 #define	PMU_INT_MASK_REG        0x1C124
 #define	PMU_INT_CAUSE_REG	0x1c120
@@ -65,13 +65,13 @@
 #define	PMU_TM_COOLING_DLY_REG	0x184c8
 
 /* Junction Temperature */
-#define A380_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
-#define A380_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+#define A38X_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define A38X_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
 
 #define LABEL "T-junction"
 static struct device *hwmon_dev;
-unsigned int temp_min = A380_OVERCOOL_TEMP;
-unsigned int temp_max = A380_OVERHEAT_TEMP;
+unsigned int temp_min = A38X_OVERCOOL_TEMP;
+unsigned int temp_max = A38X_OVERHEAT_TEMP;
 
 typedef enum {
 	SHOW_TEMP,
@@ -82,7 +82,7 @@ typedef enum {
 	SHOW_LABEL
 } SHOW;
 
-static void a380_temp_set_thresholds(unsigned int max, unsigned int min)
+static void a38x_temp_set_thresholds(unsigned int max, unsigned int min)
 {
 	u32 temp, reg;
 
@@ -91,21 +91,21 @@ static void a380_temp_set_thresholds(unsigned int max, unsigned int min)
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the overheat threashold & delay */
-	temp = A380_TSEN_TEMP2RAW(max);
+	temp = A38X_TSEN_TEMP2RAW(max);
 	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
 	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the cool threshole & delay */
-	temp = A380_TSEN_TEMP2RAW(min);
+	temp = A38X_TSEN_TEMP2RAW(min);
 	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_COOL_THRSH_MASK;
 	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 }
 
-static int a380_temp_init_sensor(void)
+static int a38x_temp_init_sensor(void)
 {
 	u32 reg;
 
@@ -141,12 +141,12 @@ static int a380_temp_init_sensor(void)
 	/* udelay(10000); */
 
 	/* Set thresholds */
-	a380_temp_set_thresholds(temp_max, temp_min);
+	a38x_temp_set_thresholds(temp_max, temp_min);
 
 	/* Set delays */
-	writel(A380_OVERHEAT_DELAY,
+	writel(A38X_OVERHEAT_DELAY,
 	       (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
-	writel(A380_OVERCOOL_DELAY,
+	writel(A38X_OVERCOOL_DELAY,
 	       (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
 
 	/* Clear & unmask cooling/overheat interrupts */
@@ -157,13 +157,13 @@ static int a380_temp_init_sensor(void)
 	return 0;
 }
 
-static int a380_temp_read_temp(void)
+static int a38x_temp_read_temp(void)
 {
 	int reg;
 
 	reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
 	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
-	return A380_TSEN_RAW2TEMP(reg);
+	return A38X_TSEN_RAW2TEMP(reg);
 }
 
 /*
@@ -173,7 +173,7 @@ static int a380_temp_read_temp(void)
 static ssize_t show_name(struct device *dev, struct device_attribute
 			 *devattr, char *buf)
 {
-	return sprintf(buf, "%s\n", "a380-hwmon");
+	return sprintf(buf, "%s\n", "a38x-hwmon");
 }
 
 static ssize_t show_alarm(struct device *dev, struct device_attribute
@@ -218,7 +218,7 @@ static ssize_t show_temp(struct device *dev,
 	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
 
 	if (attr->index == SHOW_TEMP)
-		ret = sprintf(buf, "%d\n", a380_temp_read_temp());
+		ret = sprintf(buf, "%d\n", a38x_temp_read_temp());
 	else if (attr->index == TEMP_MAX)
 		ret = sprintf(buf, "%d\n", temp_max);
 	else if (attr->index == TEMP_MIN)
@@ -240,25 +240,25 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 		printk(KERN_WARNING "Invalid input string for temperature!");
 
 	if (attr->index == TEMP_MAX) {
-		if ((temp < A380_OVERHEAT_MIN) || (temp > A380_OVERHEAT_MAX))
+		if ((temp < A38X_OVERHEAT_MIN) || (temp > A38X_OVERHEAT_MAX))
 			printk(KERN_WARNING
 			       "Invalid max temperature input (out of range: %d-%d)!",
-			       A380_OVERHEAT_MIN, A380_OVERHEAT_MAX);
+			       A38X_OVERHEAT_MIN, A38X_OVERHEAT_MAX);
 		else {
 			temp_max = temp;
-			a380_temp_set_thresholds(temp_max, temp_min);
+			a38x_temp_set_thresholds(temp_max, temp_min);
 		}
 	} else if (attr->index == TEMP_MIN) {
-		if ((temp < A380_OVERCOOL_MIN) || (temp > A380_OVERCOOL_MAX))
+		if ((temp < A38X_OVERCOOL_MIN) || (temp > A38X_OVERCOOL_MAX))
 			printk(KERN_WARNING
 			       "Invalid min temperature input (out of range: %d-%d)!",
-			       A380_OVERCOOL_MIN, A380_OVERCOOL_MAX);
+			       A38X_OVERCOOL_MIN, A38X_OVERCOOL_MAX);
 		else {
 			temp_min = temp;
-			a380_temp_set_thresholds(temp_max, temp_min);
+			a38x_temp_set_thresholds(temp_max, temp_min);
 		}
 	} else
-		printk(KERN_ERR "a380-temp: Invalid sensor attribute!");
+		printk(KERN_ERR "a38x-temp: Invalid sensor attribute!");
 
 	/* Clear & unmask cooling/overheat interrupts */
 	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
@@ -269,7 +269,7 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 	return count;
 }
 
-static irqreturn_t a380_temp_irq_handler(int irq, void *data)
+static irqreturn_t a38x_temp_irq_handler(int irq, void *data)
 {
 	u32 val, mask;
 	mask = readl(INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG);
@@ -300,7 +300,7 @@ static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp, TEMP_MIN);
 static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
 static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
 
-static struct attribute *a380_temp_attributes[] = {
+static struct attribute *a38x_temp_attributes[] = {
 	&sensor_dev_attr_name.dev_attr.attr,
 	&dev_attr_temp1_crit_alarm.attr,
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
@@ -311,19 +311,19 @@ static struct attribute *a380_temp_attributes[] = {
 	NULL
 };
 
-static const struct attribute_group a380_temp_group = {
-	.attrs = a380_temp_attributes,
+static const struct attribute_group a38x_temp_group = {
+	.attrs = a38x_temp_attributes,
 };
 
-static int __devinit a380_temp_probe(struct platform_device *pdev)
+static int __devinit a38x_temp_probe(struct platform_device *pdev)
 {
 	int err, irq;
 
-	err = a380_temp_init_sensor();
+	err = a38x_temp_init_sensor();
 	if (err)
 		goto exit;
 
-	err = sysfs_create_group(&pdev->dev.kobj, &a380_temp_group);
+	err = sysfs_create_group(&pdev->dev.kobj, &a38x_temp_group);
 	if (err)
 		goto exit;
 
@@ -335,58 +335,58 @@ static int __devinit a380_temp_probe(struct platform_device *pdev)
 
 	/* Register cooling/overheat interrupt */
 	irq = IRQ_AURORA_PMU;
-	err = request_irq(irq, a380_temp_irq_handler, IRQF_DISABLED,
-			  "a380-temp", NULL);
+	err = request_irq(irq, a38x_temp_irq_handler, IRQF_DISABLED,
+			  "a38x-temp", NULL);
 	if (err)
-		printk(KERN_INFO "unable to request IRQ%d for a380-temp\n",
+		printk(KERN_INFO "unable to request IRQ%d for a38x-temp\n",
 		       irq);
-	printk(KERN_INFO "Armada 380 hwmon thermal sensor initialized.\n");
+	printk(KERN_INFO "Armada 38x hwmon thermal sensor initialized.\n");
 
 	return 0;
 exit:
-	sysfs_remove_group(&pdev->dev.kobj, &a380_temp_group);
+	sysfs_remove_group(&pdev->dev.kobj, &a38x_temp_group);
 	return err;
 }
 
-static int __devexit a380_temp_remove(struct platform_device *pdev)
+static int __devexit a38x_temp_remove(struct platform_device *pdev)
 {
-	struct a380_temp_data *data = platform_get_drvdata(pdev);
+	struct a38x_temp_data *data = platform_get_drvdata(pdev);
 
 	hwmon_device_unregister(hwmon_dev);
-	sysfs_remove_group(&pdev->dev.kobj, &a380_temp_group);
+	sysfs_remove_group(&pdev->dev.kobj, &a38x_temp_group);
 	platform_set_drvdata(pdev, NULL);
 	kfree(data);
 	return 0;
 }
 
-static int a380_temp_resume(struct platform_device *dev)
+static int a38x_temp_resume(struct platform_device *dev)
 {
-	return a380_temp_init_sensor();
+	return a38x_temp_init_sensor();
 }
 
-static struct platform_driver a380_temp_driver = {
+static struct platform_driver a38x_temp_driver = {
 	.driver = {
 		   .owner = THIS_MODULE,
-		   .name = "a380-temp",
+		   .name = "a38x-temp",
 		   },
-	.probe = a380_temp_probe,
-	.remove = __devexit_p(a380_temp_remove),
-	.resume = a380_temp_resume,
+	.probe = a38x_temp_probe,
+	.remove = __devexit_p(a38x_temp_remove),
+	.resume = a38x_temp_resume,
 };
 
-static int __init a380_temp_init(void)
+static int __init a38x_temp_init(void)
 {
-	return platform_driver_register(&a380_temp_driver);
+	return platform_driver_register(&a38x_temp_driver);
 }
 
-static void __exit a380_temp_exit(void)
+static void __exit a38x_temp_exit(void)
 {
-	platform_driver_unregister(&a380_temp_driver);
+	platform_driver_unregister(&a38x_temp_driver);
 }
 
 MODULE_AUTHOR("Marvell Semiconductors");
-MODULE_DESCRIPTION("Marvell Armada 380 LP SoC hwmon driver");
+MODULE_DESCRIPTION("Marvell Armada 38x LP SoC hwmon driver");
 MODULE_LICENSE("GPL");
 
-module_init(a380_temp_init)
-module_exit(a380_temp_exit)
+module_init(a38x_temp_init)
+module_exit(a38x_temp_exit)
diff --git a/arch/arm/mach-armada38x/include/mach/armada380.h b/arch/arm/mach-armada38x/include/mach/armada380.h
deleted file mode 100644
index ab86f0b..0000000
--- a/arch/arm/mach-armada38x/include/mach/armada380.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#ifndef __ASM_ARCH_AURORA_H
-#define __ASM_ARCH_AURORA_H
-
-/*
- * The base address of memory that should be reserved for IO windows.
- * The reserved end address is 0xFFFFFFFF.
- */
-#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
-
-/*
- * SDRAM Address decoding
- * These values are dummy. Uboot configures these values.
- */
-#define SDRAM_CS0_BASE			0x00000000
-#define SDRAM_CS0_SIZE			_256M
-#define SDRAM_CS1_BASE			0x10000000
-#define SDRAM_CS1_SIZE			_256M
-#define SDRAM_CS2_BASE			0x20000000
-#define SDRAM_CS2_SIZE			_256M
-#define SDRAM_CS3_BASE			0x30000000
-#define SDRAM_CS3_SIZE			_256M
-
-/*
- * Physical address map
- */
-#define INTER_REGS_PHYS_BASE		0xF1000000
-
-#define PEX0_MEM_PHYS_BASE		0xE0000000
-#define PEX0_MEM_SIZE			_32M
-#define PEX1_MEM_PHYS_BASE		0xE2000000
-#define PEX1_MEM_SIZE			_32M
-
-#define PEX0_IO_PHYS_BASE		0xF1100000
-#define PEX0_IO_SIZE			_1M
-#define PEX1_IO_PHYS_BASE		0xF1200000
-#define PEX1_IO_SIZE			_1M
-
-#define SPI_CS0_PHYS_BASE		0xF0000000
-#define SPI_CS0_SIZE			_16M
-
-#define UART_REGS_BASE			0xF1B00000
-#define UART_SIZE			_1M
-
-#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
-#define DEVICE_BOOTCS_SIZE		_32M
-
-#define DEVICE_CS0_PHYS_BASE		0xF4000000
-#define DEVICE_CS0_SIZE			_1M
-#define DEVICE_CS1_PHYS_BASE		0xF4100000
-#define DEVICE_CS1_SIZE			_1M
-#define DEVICE_CS2_PHYS_BASE		0xF4200000
-#define DEVICE_CS2_SIZE			_1M
-#define DEVICE_CS3_PHYS_BASE		0xF4300000
-#define DEVICE_CS3_SIZE			_1M
-
-#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
-#define CRYPT_ENG_SIZE			_64K
-
-#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60800)
-#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
-#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60A00)
-#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
-
-#define PP2_CPU0_PHYS_BASE		0xF4500000
-#define PP2_CPU1_PHYS_BASE		0xF4510000
-#define PP2_SIZE			_64K
-
-#define BOOTROM_PHYS_BASE		0xFFF00000
-#define BOOTROM_SIZE			_1M
-
-#define LEGACY_NAND_PHYS_BASE		0xF4800000
-#define LEGACY_NAND_SIZE		_1M
-
-#define NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
-
-#define IOCC_WA_WIN0_PHYS_BASE		0xFF000000
-
-#define USB3_REGS_PHYS_BASE		0xFF100000
-#define USB3_REGS_SIZE			_128K
-
-
-/*
- * Virtual address map
- */
-#define SPI_CS0_VIRT_BASE		0xFAB00000
-#define INTER_REGS_VIRT_BASE		0xFBB00000
-
-#define PEX0_IO_VIRT_BASE		0xFBC00000
-#define PEX1_IO_VIRT_BASE		0xFBD00000
-
-#define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
-
-#define USB3_REGS_VIRT_BASE		0xFBF00000
-
-#define UART_VIRT_BASE			0xFC600000
-
-#define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
-#define DEVICE_CS0_VIRT_BASE		0xFE700000
-#define DEVICE_CS1_VIRT_BASE		0xFE800000
-#define DEVICE_CS2_VIRT_BASE		0xFE900000
-#define DEVICE_CS3_VIRT_BASE		0xFEA00000
-
-#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
-#define PP2_CPU0_VIRT_BASE		0xFEC00000
-#define PP2_CPU1_VIRT_BASE		0xFEC10000
-#define BOOTROM_VIRT_BASE		0xFED00000
-#define LEGACY_NAND_VIRT_BASE		0xFEF00000
-
-/*
- * Linux native definitiotns
- */
-#define SDRAM_OPERATION_REG		(INTER_REGS_VIRT_BASE | 0x1418)
-#define SDRAM_CONFIG_REG		(INTER_REGS_VIRT_BASE | 0x1400)
-#define SDRAM_DLB_EVICT_REG		(INTER_REGS_VIRT_BASE | 0x170C)
-
-#define UART_PHYS_BASE(port)		(INTER_REGS_PHYS_BASE | \
-						(0x12000 + (port * 0x100)))
-#define DDR_VIRT_BASE			(INTER_REGS_VIRT_BASE | 0x00000)
-#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
-
-#define BRIDGE_VIRT_BASE		(INTER_REGS_VIRT_BASE | 0x20000)
-#define BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
-#define SW_TRIG_IRQ			(BRIDGE_VIRT_BASE | 0x0A04)
-#define SW_TRIG_IRQ_PHYS		(BRIDGE_PHYS_BASE | 0x0A04)
-#define SW_TRIG_IRQ_CPU_TARGET_OFFS	8
-#define SW_TRIG_IRQ_INITID_MASK	0x1F
-#define PER_CPU_BASE			(BRIDGE_VIRT_BASE | 0x1000)
-#define IRQ_VIRT_BASE			(PER_CPU_BASE)
-#define CPU_INTACK			0xB4
-#define IRQ_SEL_CAUSE_OFF		0xA0
-#define IN_DOORBELL_CAUSE		0x78
-#define IN_DRBEL_CAUSE			(PER_CPU_BASE | 0x78)
-#define IN_DRBEL_MSK			(PER_CPU_BASE | 0x7c)
-
-#endif /* __ASM_ARCH_AURORA_H */
diff --git a/arch/arm/mach-armada38x/include/mach/armada38x.h b/arch/arm/mach-armada38x/include/mach/armada38x.h
new file mode 100644
index 0000000..ab86f0b
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/armada38x.h
@@ -0,0 +1,141 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_AURORA_H
+#define __ASM_ARCH_AURORA_H
+
+/*
+ * The base address of memory that should be reserved for IO windows.
+ * The reserved end address is 0xFFFFFFFF.
+ */
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE			0x00000000
+#define SDRAM_CS0_SIZE			_256M
+#define SDRAM_CS1_BASE			0x10000000
+#define SDRAM_CS1_SIZE			_256M
+#define SDRAM_CS2_BASE			0x20000000
+#define SDRAM_CS2_SIZE			_256M
+#define SDRAM_CS3_BASE			0x30000000
+#define SDRAM_CS3_SIZE			_256M
+
+/*
+ * Physical address map
+ */
+#define INTER_REGS_PHYS_BASE		0xF1000000
+
+#define PEX0_MEM_PHYS_BASE		0xE0000000
+#define PEX0_MEM_SIZE			_32M
+#define PEX1_MEM_PHYS_BASE		0xE2000000
+#define PEX1_MEM_SIZE			_32M
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_SIZE			_1M
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_SIZE			_16M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_SIZE		_32M
+
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_SIZE			_64K
+
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60A00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+
+#define PP2_CPU0_PHYS_BASE		0xF4500000
+#define PP2_CPU1_PHYS_BASE		0xF4510000
+#define PP2_SIZE			_64K
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_SIZE			_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_SIZE		_1M
+
+#define NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#define IOCC_WA_WIN0_PHYS_BASE		0xFF000000
+
+#define USB3_REGS_PHYS_BASE		0xFF100000
+#define USB3_REGS_SIZE			_128K
+
+
+/*
+ * Virtual address map
+ */
+#define SPI_CS0_VIRT_BASE		0xFAB00000
+#define INTER_REGS_VIRT_BASE		0xFBB00000
+
+#define PEX0_IO_VIRT_BASE		0xFBC00000
+#define PEX1_IO_VIRT_BASE		0xFBD00000
+
+#define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
+
+#define USB3_REGS_VIRT_BASE		0xFBF00000
+
+#define UART_VIRT_BASE			0xFC600000
+
+#define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
+#define DEVICE_CS0_VIRT_BASE		0xFE700000
+#define DEVICE_CS1_VIRT_BASE		0xFE800000
+#define DEVICE_CS2_VIRT_BASE		0xFE900000
+#define DEVICE_CS3_VIRT_BASE		0xFEA00000
+
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
+#define PP2_CPU0_VIRT_BASE		0xFEC00000
+#define PP2_CPU1_VIRT_BASE		0xFEC10000
+#define BOOTROM_VIRT_BASE		0xFED00000
+#define LEGACY_NAND_VIRT_BASE		0xFEF00000
+
+/*
+ * Linux native definitiotns
+ */
+#define SDRAM_OPERATION_REG		(INTER_REGS_VIRT_BASE | 0x1418)
+#define SDRAM_CONFIG_REG		(INTER_REGS_VIRT_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG		(INTER_REGS_VIRT_BASE | 0x170C)
+
+#define UART_PHYS_BASE(port)		(INTER_REGS_PHYS_BASE | \
+						(0x12000 + (port * 0x100)))
+#define DDR_VIRT_BASE			(INTER_REGS_VIRT_BASE | 0x00000)
+#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
+
+#define BRIDGE_VIRT_BASE		(INTER_REGS_VIRT_BASE | 0x20000)
+#define BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define SW_TRIG_IRQ			(BRIDGE_VIRT_BASE | 0x0A04)
+#define SW_TRIG_IRQ_PHYS		(BRIDGE_PHYS_BASE | 0x0A04)
+#define SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define SW_TRIG_IRQ_INITID_MASK	0x1F
+#define PER_CPU_BASE			(BRIDGE_VIRT_BASE | 0x1000)
+#define IRQ_VIRT_BASE			(PER_CPU_BASE)
+#define CPU_INTACK			0xB4
+#define IRQ_SEL_CAUSE_OFF		0xA0
+#define IN_DOORBELL_CAUSE		0x78
+#define IN_DRBEL_CAUSE			(PER_CPU_BASE | 0x78)
+#define IN_DRBEL_MSK			(PER_CPU_BASE | 0x7c)
+
+#endif /* __ASM_ARCH_AURORA_H */
diff --git a/arch/arm/mach-armada38x/include/mach/debug-macro.S b/arch/arm/mach-armada38x/include/mach/debug-macro.S
index a4b6f40..23ec407 100644
--- a/arch/arm/mach-armada38x/include/mach/debug-macro.S
+++ b/arch/arm/mach-armada38x/include/mach/debug-macro.S
@@ -6,7 +6,7 @@
  * published by the Free Software Foundation.
 */
 
-#include <mach/armada380.h>
+#include <mach/armada38x.h>
 
 
 	.macro  addruart, rp, rv, tmp
diff --git a/arch/arm/mach-armada38x/include/mach/gpio.h b/arch/arm/mach-armada38x/include/mach/gpio.h
index 948c4f5..f59566e 100644
--- a/arch/arm/mach-armada38x/include/mach/gpio.h
+++ b/arch/arm/mach-armada38x/include/mach/gpio.h
@@ -8,7 +8,7 @@
 #define __MACH_GPIO_H__
 
 #include <asm/errno.h>
-#include <mach/armada380.h>
+#include <mach/armada38x.h>
 #include <mach/irqs.h>
 #include <plat/gpio.h>
 #include <asm-generic/gpio.h>
diff --git a/arch/arm/mach-armada38x/include/mach/hardware.h b/arch/arm/mach-armada38x/include/mach/hardware.h
index 11ea3b4..e336dee 100644
--- a/arch/arm/mach-armada38x/include/mach/hardware.h
+++ b/arch/arm/mach-armada38x/include/mach/hardware.h
@@ -9,6 +9,6 @@
 #ifndef __ASM_ARCH_HARDWARE_H
 #define __ASM_ARCH_HARDWARE_H
 
-#include "armada380.h"
+#include "armada38x.h"
 
 #endif
diff --git a/arch/arm/mach-armada38x/include/mach/io.h b/arch/arm/mach-armada38x/include/mach/io.h
index dba029a..72de183 100644
--- a/arch/arm/mach-armada38x/include/mach/io.h
+++ b/arch/arm/mach-armada38x/include/mach/io.h
@@ -7,7 +7,7 @@
 #ifndef __ASM_ARCH_IO_H
 #define __ASM_ARCH_IO_H
 
-#include "armada380.h"
+#include "armada38x.h"
 
 #define IO_SPACE_LIMIT		0xffffffff
 #define IO_SPACE_REMAP		PEX0_IO_PHYS_BASE
diff --git a/arch/arm/mach-armada38x/include/mach/serial.h b/arch/arm/mach-armada38x/include/mach/serial.h
index 246d769..7bf8ac87 100644
--- a/arch/arm/mach-armada38x/include/mach/serial.h
+++ b/arch/arm/mach-armada38x/include/mach/serial.h
@@ -23,7 +23,7 @@
 #include <asm/irq.h>
 /* #include <linux/autoconf.h> */
 
-#include "../arch/arm/mach-armada380/config/mvSysHwConfig.h"
+#include "../arch/arm/mach-armada38x/config/mvSysHwConfig.h"
 
 extern unsigned int mvTclk;
 
diff --git a/arch/arm/mach-armada38x/include/mach/smp.h b/arch/arm/mach-armada38x/include/mach/smp.h
index 812bb54..62561b3 100644
--- a/arch/arm/mach-armada38x/include/mach/smp.h
+++ b/arch/arm/mach-armada38x/include/mach/smp.h
@@ -2,7 +2,7 @@
 #define ASMARM_ARCH_SMP_H
 
 #include <asm/io.h>
-#include <mach/armada380.h>
+#include <mach/armada38x.h>
 
 extern unsigned int master_cpu_id;
 extern unsigned int group_cpu_mask;
diff --git a/arch/arm/mach-armada38x/include/mach/uncompress.h b/arch/arm/mach-armada38x/include/mach/uncompress.h
index 09acaa7..fff4879 100644
--- a/arch/arm/mach-armada38x/include/mach/uncompress.h
+++ b/arch/arm/mach-armada38x/include/mach/uncompress.h
@@ -6,7 +6,7 @@
  * warranty of any kind, whether express or implied.
  */
 
-#include <mach/armada380.h>
+#include <mach/armada38x.h>
 
 #ifndef CONFIG_MV_UART_PORT
 #define UART_THR ((unsigned char *)(UART_PHYS_BASE(0) + 0x0))
diff --git a/arch/arm/mach-armada38x/include/mach/vmalloc.h b/arch/arm/mach-armada38x/include/mach/vmalloc.h
index 26ace24..93b9dfe 100644
--- a/arch/arm/mach-armada38x/include/mach/vmalloc.h
+++ b/arch/arm/mach-armada38x/include/mach/vmalloc.h
@@ -1,5 +1,5 @@
 /*
- * arch/arm/mach-armada380/include/mach/vmalloc.h
+ * arch/arm/mach-armada38x/include/mach/vmalloc.h
  */
 
 
diff --git a/arch/arm/mach-armada38x/irq.c b/arch/arm/mach-armada38x/irq.c
index 745fe78..5439f20 100644
--- a/arch/arm/mach-armada38x/irq.c
+++ b/arch/arm/mach-armada38x/irq.c
@@ -28,7 +28,7 @@ static DEFINE_RAW_SPINLOCK(irq_controller_lock);
 /*
  * Global GPIO interrupt handling
  */
-static void a380_gpio_irq_mask(struct irq_data *d)
+static void a38x_gpio_irq_mask(struct irq_data *d)
 {
 	u32 irq = d->irq, bitmask, reg;
 
@@ -43,7 +43,7 @@ static void a380_gpio_irq_mask(struct irq_data *d)
 	MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
 }
 
-static void a380_gpio_irq_unmask(struct irq_data *d)
+static void a38x_gpio_irq_unmask(struct irq_data *d)
 {
 	u32 irq = d->irq, bitmask, reg;
 
@@ -58,19 +58,19 @@ static void a380_gpio_irq_unmask(struct irq_data *d)
 	MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
 }
 
-static struct irq_chip a380_irq_chip = {
-	.name = "a380_gpio_irq",
-	.irq_mask = a380_gpio_irq_mask,
-	.irq_mask_ack = a380_gpio_irq_mask,
-	.irq_unmask = a380_gpio_irq_unmask,
-	.irq_disable = a380_gpio_irq_mask,
-	.irq_enable = a380_gpio_irq_unmask,
+static struct irq_chip a38x_irq_chip = {
+	.name = "a38x_gpio_irq",
+	.irq_mask = a38x_gpio_irq_mask,
+	.irq_mask_ack = a38x_gpio_irq_mask,
+	.irq_unmask = a38x_gpio_irq_unmask,
+	.irq_disable = a38x_gpio_irq_mask,
+	.irq_enable = a38x_gpio_irq_unmask,
 };
 
 /*
  * gpio_cascade_irq is in [85:88] or [90:94]
  */
-static void a380_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
+static void a38x_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
 					  struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
@@ -102,7 +102,7 @@ static void a380_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
 	chained_irq_exit(chip, desc);
 }
 
-static void __init a380_cascade_irq_gpio_global(void)
+static void __init a38x_cascade_irq_gpio_global(void)
 {
 	int irq, irq_base;
 
@@ -113,28 +113,28 @@ static void __init a380_cascade_irq_gpio_global(void)
 
 	for (irq = IRQ_START_GLOBAL_GPIO;
 	     irq < IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO; irq++) {
-		irq_set_chip_and_handler(irq, &a380_irq_chip, handle_level_irq);
+		irq_set_chip_and_handler(irq, &a38x_irq_chip, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66,
-				a380_gpio_cascade_irq_handler);
+				a38x_gpio_cascade_irq_handler);
 }
 
 /*
@@ -214,7 +214,7 @@ out:
 	chained_irq_exit(chip, desc);
 }
 
-static void __init a380_cascade_irq_mpic(int irq_start, int nr_irqs)
+static void __init a38x_cascade_irq_mpic(int irq_start, int nr_irqs)
 {
 	struct mpic_data *mpic = &mpic_data;
 	unsigned int i, intr;
@@ -236,22 +236,22 @@ static void __init a380_cascade_irq_mpic(int irq_start, int nr_irqs)
 	irq_set_chained_handler(irq_start, mpic_handle_cascade_irq);
 }
 
-static void __init a380_cascade_irq_gpio_private(void)
+static void __init a38x_cascade_irq_gpio_private(void)
 {
 	/* TBD */
 }
 
-static void __init a380_cascade_irq_msi_global(void)
+static void __init a38x_cascade_irq_msi_global(void)
 {
 	/* TBD */
 }
 
-static void __init a380_cascade_irq_msi_private(void)
+static void __init a38x_cascade_irq_msi_private(void)
 {
 	/* TBD */
 }
 
-static void __init a380_cascade_irq_errors(void)
+static void __init a38x_cascade_irq_errors(void)
 {
 	/* TBD */
 }
@@ -260,19 +260,19 @@ static void __init a380_cascade_irq_errors(void)
  * Init GIC and MPIC and setup cascade irq
  * handling for GPIO, MSI and Error interrupts.
  */
-void __init a380_init_irq(void)
+void __init a38x_init_irq(void)
 {
 	gic_init(0, 29,
 		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
 		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
 
-	a380_cascade_irq_mpic(IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
+	a38x_cascade_irq_mpic(IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
 
-	a380_cascade_irq_gpio_global();
-	a380_cascade_irq_gpio_private();
+	a38x_cascade_irq_gpio_global();
+	a38x_cascade_irq_gpio_private();
 
-	a380_cascade_irq_msi_global();
-	a380_cascade_irq_msi_private();
+	a38x_cascade_irq_msi_global();
+	a38x_cascade_irq_msi_private();
 
-	a380_cascade_irq_errors();
+	a38x_cascade_irq_errors();
 }
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
index 9b25bc8..77c54c8 100644
--- a/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
@@ -89,7 +89,7 @@ MV_STATUS mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
 	MV_STATUS status;
 	MV_BOOL usb3Init = 0;
 
-#ifndef CONFIG_ARMADA_380_USE_LEGACY_USB2
+#ifndef CONFIG_ARMADA_38X_USE_LEGACY_USB2
 	usb3Init = 1;
 #endif
 
diff --git a/arch/arm/mach-armada38x/platsmp.c b/arch/arm/mach-armada38x/platsmp.c
index 11ad331..dca1f6f 100644
--- a/arch/arm/mach-armada38x/platsmp.c
+++ b/arch/arm/mach-armada38x/platsmp.c
@@ -53,7 +53,7 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 */
 	scu_enable(scu_base);
 
-	a380_smp_cpu1_enable_wa();
+	a38x_smp_cpu1_enable_wa();
 
 	/*
 	 * Write the address of secondary startup into the
@@ -61,7 +61,7 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * until it receives a soft interrupt, and then the
 	 * secondary CPU branches to this address.
 	 */
-	writel(virt_to_phys(a380_secondary_startup),
+	writel(virt_to_phys(a38x_secondary_startup),
 	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG);
 }
 
diff --git a/arch/arm/mach-armada38x/sysmap.c b/arch/arm/mach-armada38x/sysmap.c
index c6bcc36..c3a1990 100644
--- a/arch/arm/mach-armada38x/sysmap.c
+++ b/arch/arm/mach-armada38x/sysmap.c
@@ -32,7 +32,7 @@ struct map_desc MEM_TABLE[] = {
 	{ IOCC_WA_WIN0_VIRT_BASE,	__phys_to_pfn(IOCC_WA_WIN0_PHYS_BASE),	SZ_64K,		MT_DEVICE},
 };
 
-MV_CPU_DEC_WIN SYSMAP_A380_6810[] = {
+MV_CPU_DEC_WIN SYSMAP_A38X_68XX[] = {
 	/* base low             base high       size                            WinNum          enable */
 	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS0 */
 	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS1 */
@@ -76,12 +76,12 @@ MV_CPU_DEC_WIN *mv_sys_map(void)
 
 	switch (ctrlModel) {
 	case MV_6720_DEV_ID:
-		map = SYSMAP_A380_6810;
+		map = SYSMAP_A38X_68XX;
 		break;
 	default:
 		pr_warn("%s: Error: Wrong ctrlModel (%d)\n", __func__,
 			ctrlModel);
-		map = SYSMAP_A380_6810;
+		map = SYSMAP_A38X_68XX;
 	}
 
 	return map;
@@ -99,7 +99,7 @@ u32 mv_crypto_virt_base_get(u8 chan)
 }
 #endif
 
-void __init a380_map_io(void)
+void __init a38x_map_io(void)
 {
 	iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
 }
diff --git a/arch/arm/mach-armada38x/time.c b/arch/arm/mach-armada38x/time.c
index 3c45612..0c1c107 100644
--- a/arch/arm/mach-armada38x/time.c
+++ b/arch/arm/mach-armada38x/time.c
@@ -1,5 +1,5 @@
 /*
- * arch/arm/mach-armada380/time.c
+ * arch/arm/mach-armada38x/time.c
  *
  * Marvell SoC timer handling.
  *
@@ -48,21 +48,21 @@ static int source_timer_id;
 
 static u32 ticks_per_jiffy;
 
-static cycle_t a380_clksrc_read(struct clocksource *cs)
+static cycle_t a38x_clksrc_read(struct clocksource *cs)
 {
 	return 0xffffffff - MV_REG_READ(TIMER_VAL(source_timer_id));
 }
 
-static struct clocksource a380_clksrc = {
-	.name = "a380_clocksource",
+static struct clocksource a38x_clksrc = {
+	.name = "a38x_clocksource",
 	.shift = 20,
 	.rating = 300,
-	.read = a380_clksrc_read,
+	.read = a38x_clksrc_read,
 	.mask = CLOCKSOURCE_MASK(32),
 	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
-int a380_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
+int a38x_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
 {
 	unsigned long flags;
 	u32 u, t = event_timer_id;
@@ -87,7 +87,7 @@ int a380_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
 	return 0;
 }
 
-static void a380_clkevt_mode(enum clock_event_mode mode,
+static void a38x_clkevt_mode(enum clock_event_mode mode,
 			     struct clock_event_device *evt)
 {
 	unsigned long flags;
@@ -116,24 +116,24 @@ static void a380_clkevt_mode(enum clock_event_mode mode,
 	local_irq_restore(flags);
 }
 
-static struct clock_event_device a380_clkevt;
+static struct clock_event_device a38x_clkevt;
 
-static irqreturn_t a380_timer_interrupt(int irq, void *dev_id)
+static irqreturn_t a38x_timer_interrupt(int irq, void *dev_id)
 {
 	u32 t = event_timer_id;
 
 	/* Ack timer interrupt */
 	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
 
-	a380_clkevt.event_handler(&a380_clkevt);
+	a38x_clkevt.event_handler(&a38x_clkevt);
 	return IRQ_HANDLED;
 }
 
-static struct irqaction a380_timer_irq = {
-	.name = "a380_clk_evt",
+static struct irqaction a38x_timer_irq = {
+	.name = "a38x_clk_evt",
 	.flags = IRQF_DISABLED | IRQF_TIMER,
-	.handler = a380_timer_interrupt,
-	.dev_id = &a380_clkevt,
+	.handler = a38x_timer_interrupt,
+	.dev_id = &a38x_clkevt,
 };
 
 /*
@@ -157,7 +157,7 @@ unsigned long long notrace sched_clock(void)
 	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
 }
 
-static void notrace a380_update_sched_clock(void)
+static void notrace a38x_update_sched_clock(void)
 {
 	u32 cyc = ~MV_REG_READ(TIMER_VAL(source_timer_id));
 	update_sched_clock(&cd, cyc, (u32)~0);
@@ -165,11 +165,11 @@ static void notrace a380_update_sched_clock(void)
 
 static void __init setup_sched_clock(unsigned long tclk)
 {
-	init_sched_clock(&cd, a380_update_sched_clock, 32, tclk);
+	init_sched_clock(&cd, a38x_update_sched_clock, 32, tclk);
 }
 
 /* Setup free-running clocksource timer */
-static void a380_setup_clocksource(int timer, long rate)
+static void a38x_setup_clocksource(int timer, long rate)
 {
 	u32 i = timer, u;
 	void __iomem *base =
@@ -183,63 +183,63 @@ static void a380_setup_clocksource(int timer, long rate)
 	u |= TIMER_EN(i) | TIMER_RELOAD_EN(i);
 	MV_REG_WRITE(TIMER_CTRL, u);
 
-	clocksource_mmio_init(base, "a380_clk_source",
+	clocksource_mmio_init(base, "a38x_clk_source",
 			      rate, 200, 32, clocksource_mmio_readl_down);
 
-	a380_clksrc.mult = clocksource_hz2mult(rate, a380_clksrc.shift);
+	a38x_clksrc.mult = clocksource_hz2mult(rate, a38x_clksrc.shift);
 	setup_sched_clock(rate);
-	clocksource_register(&a380_clksrc);
+	clocksource_register(&a38x_clksrc);
 }
 
-static void a380_setup_clockevent(int irq, long rate)
+static void a38x_setup_clockevent(int irq, long rate)
 {
-	struct clock_event_device *evt = &a380_clkevt;
+	struct clock_event_device *evt = &a38x_clkevt;
 	unsigned int cpu = smp_processor_id();
 
-	evt->name = "a380_clkevt";
+	evt->name = "a38x_clkevt";
 	evt->irq = irq;
 	evt->features = (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
 	    evt->shift = 32,
 	    evt->rating = 300,
-	    evt->set_next_event = a380_clkevt_next_event,
-	    evt->set_mode = a380_clkevt_mode, evt->cpumask = cpumask_of(cpu);
+	    evt->set_next_event = a38x_clkevt_next_event,
+	    evt->set_mode = a38x_clkevt_mode, evt->cpumask = cpumask_of(cpu);
 	evt->mult = div_sc(rate, NSEC_PER_SEC, evt->shift);
 	evt->max_delta_ns = clockevent_delta2ns(0xffffffff, evt);
 	evt->min_delta_ns = clockevent_delta2ns(0x1, evt);
 
-	setup_irq(irq, &a380_timer_irq);
+	setup_irq(irq, &a38x_timer_irq);
 	clockevents_config_and_register(evt, rate, 0x1, 0xffffffff);
 }
 
-static void a380_clear_timer_config(void)
+static void a38x_clear_timer_config(void)
 {
 	MV_REG_WRITE(TIMER_CTRL, 0);
 	MV_REG_WRITE(TIMER_CAUSE, 0);
 }
 
-static void __init a380_timer_init(void)
+static void __init a38x_timer_init(void)
 {
 	u32 rate;
 
 	rate = 200000000;
 
-	printk(KERN_INFO "Initializing Armada-380 SoC Timers\n");
+	printk(KERN_INFO "Initializing Armada-38x SoC Timers\n");
 	ticks_per_jiffy = (rate + HZ / 2) / HZ;
 
-	a380_clear_timer_config();
+	a38x_clear_timer_config();
 
 	/* Define timers used for event and source */
 	event_timer_id = 1;
 	source_timer_id = 0;
 
-	a380_setup_clocksource(source_timer_id, rate);
-	a380_setup_clockevent(IRQ_GLOBAL_TIMER(event_timer_id), rate);
+	a38x_setup_clocksource(source_timer_id, rate);
+	a38x_setup_clockevent(IRQ_GLOBAL_TIMER(event_timer_id), rate);
 
 #ifdef CONFIG_HAVE_ARM_TWD
 	twd_base = (INTER_REGS_VIRT_BASE + A9_MPCORE_TWD);
 #endif
 }
 
-struct sys_timer a380_timer = {
-	.init = a380_timer_init,
+struct sys_timer a38x_timer = {
+	.init = a38x_timer_init,
 };
diff --git a/arch/arm/mach-armada38x/usb.c b/arch/arm/mach-armada38x/usb.c
index a317598..714f72f 100644
--- a/arch/arm/mach-armada38x/usb.c
+++ b/arch/arm/mach-armada38x/usb.c
@@ -243,7 +243,7 @@ void __init mv_usb3_init(struct mbus_dram_target_info *dram)
 	mv_usb3_conf_mbus_windows((void *)(INTER_REGS_VIRT_BASE +
 				MV_USB3_REGS_BASE(0)), dram);
 
-#ifdef CONFIG_A380_Z1_USB3_LFPS_FREQ_WA
+#ifdef CONFIG_A38X_Z1_USB3_LFPS_FREQ_WA
 /*
  * All defines below are used for a temporary workaround and therefore
  * are placed inside the code and not in an include file
@@ -290,7 +290,7 @@ void __init mv_usb_init(struct mbus_dram_target_info *dram)
 	int use_usb3_ip = 0;
 	MV_STATUS status;
 
-#ifndef CONFIG_ARMADA_380_USE_LEGACY_USB2
+#ifndef CONFIG_ARMADA_38X_USE_LEGACY_USB2
 	use_usb3_ip = 1;
 	/* Initialize the USB2 PHY needed for USB3 functionality */
 	status = mvSysUsbInit(0, 1);
-- 
1.7.5.4

