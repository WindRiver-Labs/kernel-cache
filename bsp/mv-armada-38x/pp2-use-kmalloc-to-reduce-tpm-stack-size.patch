From 0d60ce3335e1915bb0b14bc1114694879145da77 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Thu, 15 May 2014 16:50:41 +0800
Subject: [PATCH 1668/1825] pp2: use kmalloc to reduce tpm stack size

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit a5740c0378938091c7f6755675820e3cf76603de

	use kmalloc to reduce tpm stack size. All tpm functions's stack
	memorys are reduced under 333 bytes except those tpm sysfs dump
	functions. Tpm sysfs dump functions are only used for sysfs cmd
	dump and will not called by others, so since their memory stack
	will not reach page_size(4k), there is no problem.

Signed-off-by: Ken Ma <make@marvell.com>

Change-Id: I3c44baf20a087e9e9e4b91f1501127a7f19e132a
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8050
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Hua Jing <jinghua@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_tpm/inc/tpm_log.h            |   71 ++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c        |   10 +-
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c       |  780 ++++++++++++--------
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c        |  278 +++++---
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c        |   82 ++-
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c       |  149 +++--
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c        |   59 +-
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c       |   37 +-
 8 files changed, 932 insertions(+), 534 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
index 18d1fd8..632ff7e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
@@ -113,6 +113,25 @@ extern unsigned int g_tpm_trace_flag;
 			} \
 		}
 
+#define IF_ERROR_FREE(module, ret, ptr)	\
+		{ \
+			if (ret) {\
+				TPM_OS_ERROR(module, " recvd ret_code(%d)\n", ret);\
+				mvOsFree(ptr);\
+				return ret;\
+			} \
+		}
+
+#define IF_ERROR_FREE_2(module, ret, ptr1, ptr2) \
+		{ \
+			if (ret) {\
+				TPM_OS_ERROR(module, " recvd ret_code(%d)\n", ret);\
+				mvOsFree(ptr1);\
+				mvOsFree(ptr2);\
+				return ret;\
+			} \
+		}
+
 #define IF_ERROR_STR(module, ret, format, ...)									\
 	{ \
 		if (ret) {											\
@@ -122,6 +141,39 @@ extern unsigned int g_tpm_trace_flag;
 		} \
 	}
 
+#define IF_ERROR_STR_FREE(module, ret, ptr, format, ...)							\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			mvOsFree(ptr);										\
+			return ret;										\
+		} \
+	}
+
+#define IF_ERROR_STR_FREE_2(module, ret, ptr1, ptr2, format, ...)						\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			mvOsFree(ptr1);										\
+			mvOsFree(ptr2);										\
+			return ret;										\
+		} \
+	}
+
+#define IF_ERROR_STR_FREE_3(module, ret, ptr1, ptr2, ptr3, format, ...)						\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			mvOsFree(ptr1);										\
+			mvOsFree(ptr2);										\
+			mvOsFree(ptr3);										\
+			return ret;										\
+		} \
+	}
+
 #define IF_ERROR_STR_REL_API_DATA(module, ret, api_data, format, ...)						\
 	{ \
 		if (ret) {											\
@@ -132,6 +184,17 @@ extern unsigned int g_tpm_trace_flag;
 		} \
 	}
 
+#define IF_ERROR_STR_REL_API_DATA_FREE(module, ret, api_data, ptr, format, ...)					\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			tpm_db_mng_api_data_release(api_data);							\
+			mvOsFree(ptr);										\
+			return ret;										\
+		} \
+	}
+
 #define IF_ERROR_STR_REL_TWO_API_DATA(module, ret, api_data1, api_data2, format, ...)				\
 	{ \
 		if (ret) {											\
@@ -186,6 +249,14 @@ extern unsigned int g_tpm_trace_flag;
 		} \
 	}
 
+#define IF_MALLOC_FAIL(module, ptr)										\
+	{ \
+		if (ptr == NULL) {										\
+			TPM_OS_ERROR(module, "%s(%d) Error allocating memory!\n", __func__, __LINE__);		\
+			return TPM_OUT_OF_CPU_MEM;								\
+		} \
+	}
+
 #define TPM_DECIMAL_RANGE_VALIDATE(module, value, min, max) { \
 	if (((value) > (max)) || ((value) < (min))) { \
 		if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
index 9dbcf23..73d6474 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
@@ -1916,7 +1916,7 @@ unsigned int tpm_db_c4_port_to_ruleset_get(
 		return TPM_OK;
 	}
 
-	return TPM_NOT_FOUND;
+	return TPM_NO_SUCH;
 }
 
 /*******************************************************************************
@@ -3039,7 +3039,7 @@ int tpm_db_mng_mc_atu_del(unsigned int switch_port, unsigned char *mac, unsigned
 		}
 	}
 
-	return TPM_NOT_FOUND;
+	return TPM_NO_SUCH;
 }
 
 /*******************************************************************************
@@ -3082,7 +3082,7 @@ int tpm_db_mng_mc_atu_get(unsigned int switch_port, unsigned char *mac, struct t
 		}
 	}
 
-	return TPM_NOT_FOUND;
+	return TPM_NO_SUCH;
 }
 
 /*******************************************************************************
@@ -3371,7 +3371,7 @@ int tpm_db_mng_cm_ruleset_get(
 		return TPM_OK;
 	}
 
-	return TPM_NOT_FOUND;
+	return TPM_NO_SUCH;
 }
 
 /*******************************************************************************
@@ -3827,7 +3827,7 @@ int tpm_db_cls_rl_off_lkp_dcod_get(unsigned short		rl_off,
 
 	if (i == TPM_MNG_FLOW_ID_MAX) {
 		TPM_OS_ERROR(TPM_DB_MOD, "rule offset [%d] not found\n", rl_off);
-		return TPM_NOT_FOUND;
+		return TPM_NO_SUCH;
 	}
 
 	memcpy(lkp_dcod, &g_tpm_db->cls_db.lkp_dcod[i], sizeof(struct tpm_db_cls_lkp_dcod_t));
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
index 740d4b1..4523e64 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
@@ -839,7 +839,7 @@ int tpm_mng_rule_id_get(
 
 	/* release api data */
 	tpm_db_mng_api_data_release(api_data);
-	return TPM_NOT_FOUND;
+	return TPM_NO_SUCH;
 }
 
 /*******************************************************************************
@@ -1168,8 +1168,8 @@ int tpm_mng_def_flow_entry_crt(
 {
 	struct tpm_cls_fl_rule_entry_t fl_rule_entry;
 	struct tpm_mng_pkt_key_t  tpm_pkt_key;
-	struct tpm_field_match_info field_info[TPM_MNG_MAX_FIELD_NUM];
-	struct tpm_pkt_key_t pkt_key;
+	struct tpm_field_match_info *field_info;	/*use heap to reduce stack size*/
+	struct tpm_pkt_key_t *pkt_key;			/*use heap to reduce stack size*/
 	int cur_number = flow_rules->fl_len;
 	int way;
 	int loop;
@@ -1195,10 +1195,19 @@ int tpm_mng_def_flow_entry_crt(
 	fl_rule_entry.prio = cap_arr->cls_pri;
 
 	/* get field ID */
-	TPM_MEMSET_ZERO(field_info);
+	field_info = mvOsMalloc(TPM_MNG_MAX_FIELD_NUM * sizeof(struct tpm_field_match_info));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, field_info);
+	memset(field_info, 0, TPM_MNG_MAX_FIELD_NUM * sizeof(struct tpm_field_match_info));
+	pkt_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	if (pkt_key == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(field_info);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(pkt_key, 0, sizeof(struct tpm_pkt_key_t));
+
 	TPM_MEMSET_ZERO(tpm_pkt_key);
-	TPM_MEMSET_ZERO(pkt_key);
-	tpm_pkt_key.pkt_key = &pkt_key;
+	tpm_pkt_key.pkt_key = pkt_key;
 
 	/* if using C3_B & proto match do not check L4_Prot in HEK, use L4_info of C3 */
 	if ((cap_arr->eng_no == TPM_ENGINE_C3_B) && (TPM_MATCH_IP_PROTO & cap_arr->cap_field_bm))
@@ -1215,7 +1224,7 @@ int tpm_mng_def_flow_entry_crt(
 	tpm_ret = tpm_field_bm_to_field_info(cap_arr->c2_key_bm,
 			&tpm_pkt_key, TPM_MNG_MAX_FIELD_NUM,
 			l4_prot_check, field_info);
-	IF_ERROR(TPM_MNG_MOD, tpm_ret);
+	IF_ERROR_FREE_2(TPM_MNG_MOD, tpm_ret, field_info, pkt_key);
 
 	for (loop = 0; loop < TPM_MNG_MAX_FIELD_NUM; loop++) {
 		if (field_info[loop].valid)
@@ -1223,6 +1232,10 @@ int tpm_mng_def_flow_entry_crt(
 		else
 			break;
 	}
+
+	mvOsFree(field_info);
+	mvOsFree(pkt_key);
+
 	fl_rule_entry.field_id_cnt = loop;
 	/* vir/uni port */
 	if ((TPM_WAY_PON == way) && (src_port_cfg & TPM_CAP_PORT_VIR)) {
@@ -1343,7 +1356,7 @@ int tpm_mng_def_flow_entry_crt(
 int tpm_mng_def_flow_tbl_create(void)
 {
 	enum tpm_mng_flow_log_id_t flow_id;
-	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;		/*use heap to reduce stack size*/
 	struct tpm_cls_fl_rule_entry_t *flow_rules;
 	struct tpm_cls_fl_rule_list_t *flow_rules_list = &g_tpm_mng_flow_rules;
 	enum tpm_mng_src_port_type_t src_port_cfg;
@@ -1358,11 +1371,15 @@ int tpm_mng_def_flow_tbl_create(void)
 	int cap_num;
 	flow_rules = flow_rules_list->fl;
 
+	cap_arr = mvOsMalloc(TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &uni_num);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get max uni port number failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "get max uni port number failed\n");
 
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "get ipv6 enable failed\n");
 
 	/* get uni_port_bm */
 	for (loop = 0; loop < uni_num; loop++)
@@ -1375,11 +1392,11 @@ int tpm_mng_def_flow_tbl_create(void)
 			continue;
 		flow_rules_list->fl_len = 0;
 		memset(flow_rules_list, 0, sizeof(g_tpm_mng_flow_rules));
-		TPM_MEMSET_ZERO(cap_arr);
+		memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 		/* get all the cap in this flow */
 		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "get CAPs failed for flow_id(%d)\n", flow_id);
 
 		/* go through caps */
 		for (loop = 0; loop < cap_num; loop++) {
@@ -1399,7 +1416,7 @@ int tpm_mng_def_flow_tbl_create(void)
 					cap_arr[loop].rule_type, cap_arr[loop].cap_field_bm,
 					cap_arr[loop].vlan_num, &hit_num);
 
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr,
 				"get CAP hit num failed, cap_type(%d), field_bm(0x%x), vlan_num(%d), rule_type(%d)\n",
 				cap_arr[loop].cap_api_type, cap_arr[loop].cap_field_bm,
 				cap_arr[loop].vlan_num, cap_arr[loop].rule_type);
@@ -1429,7 +1446,7 @@ int tpm_mng_def_flow_tbl_create(void)
 				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 					flow_rules_list,
 					src_port_cfg_uni_vir, uni_port_bm);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "creat flow entry failed\n");
 
 				if (src_port_cfg_phy) {
 					/* this cap takes both phy and vir/uni port, so takes 2 cls_pri */
@@ -1437,7 +1454,7 @@ int tpm_mng_def_flow_tbl_create(void)
 					tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 						flow_rules_list,
 						src_port_cfg_phy, 0);
-					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+					IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "creat flow entry failed\n");
 				}
 
 				break;
@@ -1449,7 +1466,7 @@ int tpm_mng_def_flow_tbl_create(void)
 				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 					flow_rules_list,
 					src_port_cfg_phy, 0);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "creat flow entry failed\n");
 
 				break;
 			case TPM_API_PRIVATE_LPBK_MH:
@@ -1457,7 +1474,7 @@ int tpm_mng_def_flow_tbl_create(void)
 				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 					flow_rules_list,
 					TPM_CAP_PORT_LPBK, 0);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "creat flow entry failed\n");
 
 				break;
 			case TPM_API_PRIVATE_CNM:
@@ -1465,7 +1482,7 @@ int tpm_mng_def_flow_tbl_create(void)
 				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 					flow_rules_list,
 					src_port_cfg_uni_vir, uni_port_bm);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "creat flow entry failed\n");
 
 				break;
 
@@ -1477,6 +1494,7 @@ int tpm_mng_def_flow_tbl_create(void)
 				TPM_OS_ERROR(TPM_MNG_MOD,
 					"api_type not supported(%d)\n",
 					cap_arr[loop].cap_api_type);
+				mvOsFree(cap_arr);
 				return TPM_FAIL;
 			}
 
@@ -1484,12 +1502,13 @@ int tpm_mng_def_flow_tbl_create(void)
 
 		/* set decode table */
 		tpm_ret = tpm_mng_decode_tbl_set(flow_id, flow_rules_list->fl_len);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set decode table failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "set decode table failed for flow_id(%d)\n", flow_id);
 		tpm_ret = tpm_cls_fl_rule_add(flow_rules_list);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create flow_tbl failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "create flow_tbl failed for flow_id(%d)\n", flow_id);
 
 	}
 
+	mvOsFree(cap_arr);
 	return TPM_OK;
 }
 
@@ -1909,23 +1928,31 @@ int tpm_mng_engine_get(enum tpm_field_match_t field_bm, enum tpm_engine_no_t *en
 {
 	int tpm_ret;
 	struct tpm_mng_pkt_key_t  tpm_pkt_key;
-	struct tpm_pkt_key_t pkt_key;
-	struct tpm_c2_add_entry_t c2_entry;
+	struct tpm_pkt_key_t *pkt_key;		/*use heap to reduce stack size*/
+	struct tpm_c2_add_entry_t *c2_entry;	/*use heap to reduce stack size*/
 	unsigned char hek[TPM_C2_HEK_OFF_MAX];
 	unsigned char hek_mask[TPM_C2_HEK_OFF_MAX];
 
 	TPM_MEMSET_ZERO(tpm_pkt_key);
-	TPM_MEMSET_ZERO(pkt_key);
-	TPM_MEMSET_ZERO(c2_entry);
-
-	pkt_key.field_match_bm = field_bm;
-	tpm_pkt_key.pkt_key = &pkt_key;
-	c2_entry.field_bm = field_bm;
-	c2_entry.field_bm_mask = field_bm;
-	c2_entry.mng_pkt_key = &tpm_pkt_key;
+	pkt_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, pkt_key);
+	memset(pkt_key, 0, sizeof(struct tpm_pkt_key_t));
+	c2_entry = mvOsMalloc(sizeof(struct tpm_c2_add_entry_t));
+	if (c2_entry == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(pkt_key);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(c2_entry, 0, sizeof(struct tpm_c2_add_entry_t));
+
+	pkt_key->field_match_bm = field_bm;
+	tpm_pkt_key.pkt_key = pkt_key;
+	c2_entry->field_bm = field_bm;
+	c2_entry->field_bm_mask = field_bm;
+	c2_entry->mng_pkt_key = &tpm_pkt_key;
 
 	/* check if C2 could hold this field_bm */
-	tpm_ret = tpm_c2_tcam_hek_get(field_bm, &c2_entry, hek, hek_mask);
+	tpm_ret = tpm_c2_tcam_hek_get(field_bm, c2_entry, hek, hek_mask);
 	if (TPM_OK == tpm_ret)
 		*eng_no = TPM_ENGINE_C2;
 	else if ((field_bm == TPM_MATCH_IPV4_5T)
@@ -1935,6 +1962,8 @@ int tpm_mng_engine_get(enum tpm_field_match_t field_bm, enum tpm_engine_no_t *en
 	} else
 		*eng_no = TPM_ENGINE_C3_A;
 
+	mvOsFree(pkt_key);
+	mvOsFree(c2_entry);
 	return TPM_OK;
 }
 
@@ -2223,9 +2252,9 @@ int tpm_mng_cap_merge_flow(
 int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
 {
 	enum tpm_mng_flow_log_id_t flow_id;
-	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;			/*use heap to reduce stack size*/
 	struct tpm_db_mng_flow_cap_conf_t cap_tmp;
-	struct tpm_mng_reassigned_lu_type_t reassigned_lu_type[TPM_MNG_FLOW_ID_MAX];
+	struct tpm_mng_reassigned_lu_type_t *reassigned_lu_type;	/*use heap to reduce stack size*/
 	int reassigned_lu_type_num = 0;
 	unsigned char new_lu_type;
 	int cur_lu_type;
@@ -2236,14 +2265,25 @@ int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
 	int cap_num;
 
 	TPM_MEMSET_ZERO(reassigned_lu_type);
+	cap_arr = mvOsMalloc(TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	reassigned_lu_type = mvOsMalloc(TPM_MNG_FLOW_ID_MAX * sizeof(struct tpm_mng_reassigned_lu_type_t));
+	if (reassigned_lu_type == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(cap_arr);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(reassigned_lu_type, 0, TPM_MNG_FLOW_ID_MAX * sizeof(struct tpm_mng_reassigned_lu_type_t));
 
 	/* for the caps with the same lu_type, but different C2_key_bm, reassign lu_type to it */
 	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
-		TPM_MEMSET_ZERO(cap_arr);
+		memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 		/* get all the caps in this flow */
 		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, reassigned_lu_type,
+			"get CAPs failed for flow_id(%d)\n", flow_id);
 		for (loop = 0; loop < cap_num; loop++) {
 			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
 				continue;
@@ -2266,7 +2306,8 @@ int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
 				/* this one need to be reassigned */
 				if (loop_reassign == reassigned_lu_type_num) {
 					tpm_ret = tpm_db_mng_free_c2_lu_type_get(&new_lu_type);
-					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get free C2 lu_type failed\n");
+					IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, reassigned_lu_type,
+						"get free C2 lu_type failed\n");
 				}
 				loop_in = loop;
 				cur_lu_type = cap_arr[loop].lu_type;
@@ -2275,7 +2316,8 @@ int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
 					memcpy(&cap_tmp, &cap_arr[loop_in], sizeof(cap_tmp));
 					cap_tmp.lu_type = new_lu_type;
 					tpm_ret = tpm_db_mng_flow_cap_update(&cap_arr[loop_in], &cap_tmp);
-					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "update CAP fail, flow_id(%d)\n", flow_id);
+					IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, reassigned_lu_type,
+						"update CAP fail, flow_id(%d)\n", flow_id);
 					loop_in++;
 				}
 
@@ -2287,6 +2329,8 @@ int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
 		}
 	}
 
+	mvOsFree(cap_arr);
+	mvOsFree(reassigned_lu_type);
 	return TPM_OK;
 }
 
@@ -2311,22 +2355,31 @@ int tpm_mng_cap_merge(void)
 {
 	enum tpm_mng_flow_log_id_t flow_id;
 	struct tpm_db_mng_cap_conf_t cap_l3_tmp;
-	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
-	struct tpm_db_mng_flow_cap_conf_t *cap_arr_tmp;
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;		/*use heap to reduce stack size*/
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr_tmp;		/*use heap to reduce stack size*/
 	int loop;
 	int tpm_ret;
 	int cap_num;
 
-	TPM_MEMSET_ZERO(g_flow_cap_arr);
 	TPM_MEMSET_ZERO(cap_l3_tmp);
-	cap_arr_tmp = g_flow_cap_arr;
+
+	cap_arr = mvOsMalloc(TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	cap_arr_tmp = mvOsMalloc(TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	if (cap_arr_tmp == NULL) {
+		TPM_OS_ERROR(TPM_C4_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(cap_arr);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(cap_arr_tmp, 0, TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 	/* mark temp l3 cap to keep all L3 flows from cap merge */
 	cap_l3_tmp.cap_field_bm = TPM_MATCH_IPV4_PKT;
 
 	/* go through flow_cap_conf */
 	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
-		TPM_MEMSET_ZERO(cap_arr);
+		memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 		/* do not merge Multicast/L3 cap, since there is not so many of them,
 		     and there are some default rules could not be merged.
@@ -2340,41 +2393,46 @@ int tpm_mng_cap_merge(void)
 
 		/* get all the caps in this flow */
 		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+			"get CAPs failed for flow_id(%d)\n", flow_id);
 
 		tpm_ret = tpm_mng_cap_merge_flow(cap_num, cap_arr, cap_arr_tmp);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "merge CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+			"merge CAPs failed for flow_id(%d)\n", flow_id);
 
 		for (loop = 0; loop < cap_num; loop++) {
 			tpm_ret = tpm_db_mng_flow_cap_update(&cap_arr[loop], &cap_arr_tmp[loop]);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "update CAPs failed for flow_id(%d)\n", flow_id);
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+				"update CAPs failed for flow_id(%d)\n", flow_id);
 		}
 	}
 
 	/* set cntr for all C2 lu_type */
 	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
-		TPM_MEMSET_ZERO(cap_arr);
+		memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 		/* get all the caps in this flow */
 		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+			"get CAPs failed for flow_id(%d)\n", flow_id);
 		for (loop = 0; loop < cap_num; loop++) {
 			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
 				continue;
 
 			tpm_ret = tpm_db_mng_c2_lu_type_cntr_op(cap_arr[loop].lu_type, TPM_TRUE);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
 				     "update cntr for C2 lu_type(%d) fail\n", cap_arr[loop].lu_type);
 		}
 	}
 
 	/* for the caps with the same lu_type, but different C2_key_bm, reassign lu_type to it */
 	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
-		TPM_MEMSET_ZERO(cap_arr);
+		memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 		/* get all the caps in this flow */
 		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+			"get CAPs failed for flow_id(%d)\n", flow_id);
 		for (loop = 0; loop < cap_num; loop++) {
 			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
 				continue;
@@ -2383,9 +2441,13 @@ int tpm_mng_cap_merge(void)
 				continue;
 
 			tpm_ret = tpm_mng_cap_c2_lu_type_reassign(&cap_arr[loop]);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "not engough C2 lu_type resource\n");
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, cap_arr_tmp,
+				"not engough C2 lu_type resource\n");
 		}
 	}
+
+	mvOsFree(cap_arr);
+	mvOsFree(cap_arr_tmp);
 	return TPM_OK;
 }
 
@@ -2775,16 +2837,17 @@ int tpm_mng_c3_mask_check(
 * DESCRIPTION: The routine build mng key from exact_match API
 *
 * INPUTS:
-*	       gemport:
+*         exact_match - Contains Match parameters to perform exact match.
 *
 * OUTPUTS:
-*	       virt_port_id
+*         pkt_key     - tpm mng key for rule match.
+*         qos           - Qos info
 *
 * On success, the function returns TPM_OK. On error different types are returned
 * according to the case - see tpm_error_code_t.
 *
 * COMMENTS:
-*	    None
+*         None
 *******************************************************************************/
 int tpm_mng_5t_key_build(
 	struct tpm_pkt_key_t		*pkt_key,
@@ -3302,7 +3365,7 @@ int tpm_mng_filter_def_c3_rule_delete(
 static int tpm_mng_c2_entry_add(struct tpm_mng_eng_add_entry_t *eng_entry,
 				unsigned int                   *rule_id)
 {
-	struct tpm_c2_add_entry_t c2_entry;
+	struct tpm_c2_add_entry_t *c2_entry;	/*use heap to reduce stack size*/
 	enum tpm_qos_src_t	qos_src;
 	int tpm_ret;
 	int virt_port_id;
@@ -3330,38 +3393,42 @@ static int tpm_mng_c2_entry_add(struct tpm_mng_eng_add_entry_t *eng_entry,
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
 	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
 
-	TPM_MEMSET_ZERO(c2_entry);
-	c2_entry.port.port_type = eng_entry->match_key->pkt_key->port.port_type;
+	c2_entry = mvOsMalloc(sizeof(struct tpm_c2_add_entry_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, c2_entry);
+	memset(c2_entry, 0, sizeof(struct tpm_c2_add_entry_t));
+
+	c2_entry->port.port_type = eng_entry->match_key->pkt_key->port.port_type;
+
 	/* src port */
 	if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_PP_PORT_BM) {
 		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC)
-			c2_entry.port.port_value |= TPM_SRC_PORT_PON;
+			c2_entry->port.port_value |= TPM_SRC_PORT_PON;
 		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC0)
-			c2_entry.port.port_value |= TPM_SRC_PORT_G0;
+			c2_entry->port.port_value |= TPM_SRC_PORT_G0;
 		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC1)
-			c2_entry.port.port_value |= TPM_SRC_PORT_G1;
+			c2_entry->port.port_value |= TPM_SRC_PORT_G1;
 		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_LPBK)
-			c2_entry.port.port_value |= TPM_SRC_PORT_LPBK;
+			c2_entry->port.port_value |= TPM_SRC_PORT_LPBK;
 	} else if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM) {
-		c2_entry.port.port_value = eng_entry->match_key->pkt_key->port.class_port;
+		c2_entry->port.port_value = eng_entry->match_key->pkt_key->port.class_port;
 	} else {
 		/* get virtual port number */
 		tpm_ret = tpm_mng_virt_port_id_get(eng_entry->match_key->pkt_key->port.class_port, &virt_port_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get virtual port number failed\n");
-		c2_entry.port.port_value = virt_port_id;
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c2_entry, "get virtual port number failed\n");
+		c2_entry->port.port_value = virt_port_id;
 	}
-	c2_entry.port.port_mask = TPM_MNG_ALL_PORT_MASK;
+	c2_entry->port.port_mask = TPM_MNG_ALL_PORT_MASK;
 
-	c2_entry.lkp_type = eng_entry->cap->lu_type;
-	c2_entry.lkp_type_mask = TPM_MNG_ALL_LUTYPE_MASK;
-	c2_entry.priority = eng_entry->cap->c2_pri;
-	c2_entry.field_bm = eng_entry->cap->c2_key_bm;
-	c2_entry.field_bm_mask = eng_entry->cap->cap_field_bm;
-	c2_entry.mng_pkt_key = eng_entry->match_key;
+	c2_entry->lkp_type = eng_entry->cap->lu_type;
+	c2_entry->lkp_type_mask = TPM_MNG_ALL_LUTYPE_MASK;
+	c2_entry->priority = eng_entry->cap->c2_pri;
+	c2_entry->field_bm = eng_entry->cap->c2_key_bm;
+	c2_entry->field_bm_mask = eng_entry->cap->cap_field_bm;
+	c2_entry->mng_pkt_key = eng_entry->match_key;
 
 	if (eng_entry->policer_id != TPM_POLICER_INVALID) {
-		c2_entry.qos_info.policer_id = eng_entry->policer_id;
-		c2_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->qos_info.policer_id = eng_entry->policer_id;
+		c2_entry->action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
 	}
 	if (NULL == eng_entry->qos || eng_entry->qos->qos_sel == TPM_QOS_NONE) {
 		qos_src = TPM_QOS_SRC_ACTION_TBL;
@@ -3371,115 +3438,116 @@ static int tpm_mng_c2_entry_add(struct tpm_mng_eng_add_entry_t *eng_entry,
 		    (!(eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC)) &&
 		    (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE ||
 		     eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE))
-			c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+			c2_entry->action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
 	} else {
 		qos_src = TPM_QOS_SRC_DSCP_PBIT_TBL;
-		c2_entry.qos_info.qos_tbl_index = eng_entry->qos->qos_tbl;
+		c2_entry->qos_info.qos_tbl_index = eng_entry->qos->qos_tbl;
 		if (eng_entry->qos->qos_sel == TPM_QOS_DSCP)
-			c2_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_DSCP;
+			c2_entry->qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_DSCP;
 		else
-			c2_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_PRI;
+			c2_entry->qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_PRI;
 
-		c2_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
-		c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
-		c2_entry.action.dscp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->action.dscp_act = TPM_ACTION_TYPE_UPDT_LOCK;
 		/* CnM pbit as-is lookup type only update pbit, not lock */
 		if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
-			c2_entry.action.gemp_act = TPM_ACTION_TYPE_NO_UPDT;
-			c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT;
-			c2_entry.action.dscp_act = TPM_ACTION_TYPE_NO_UPDT;
+			c2_entry->action.gemp_act = TPM_ACTION_TYPE_NO_UPDT;
+			c2_entry->action.pri_act = TPM_ACTION_TYPE_UPDT;
+			c2_entry->action.dscp_act = TPM_ACTION_TYPE_NO_UPDT;
 		}
 	}
 
 	if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
-		c2_entry.action.q_high_act = TPM_ACTION_TYPE_NO_UPDT;
-		c2_entry.action.q_low_act = TPM_ACTION_TYPE_NO_UPDT;
+		c2_entry->action.q_high_act = TPM_ACTION_TYPE_NO_UPDT;
+		c2_entry->action.q_low_act = TPM_ACTION_TYPE_NO_UPDT;
 	} else {
-		c2_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
-		c2_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry->action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
 	}
 
-	c2_entry.qos_info.pri_dscp_src = qos_src;
-	c2_entry.qos_info.gemport_src = qos_src;
-	c2_entry.qos_info.q_low_src = qos_src;
-	c2_entry.qos_info.q_high_src = qos_src;
-	c2_entry.qos_info.color_src = qos_src;
+	c2_entry->qos_info.pri_dscp_src = qos_src;
+	c2_entry->qos_info.gemport_src = qos_src;
+	c2_entry->qos_info.q_low_src = qos_src;
+	c2_entry->qos_info.q_high_src = qos_src;
+	c2_entry->qos_info.color_src = qos_src;
 
-	c2_entry.qos_value.pri = 0;
-	c2_entry.qos_value.dscp = 0;
-	c2_entry.qos_value.q_low = eng_entry->action->dest.pp_queue;
+	c2_entry->qos_value.pri = 0;
+	c2_entry->qos_value.dscp = 0;
+	c2_entry->qos_value.q_low = eng_entry->action->dest.pp_queue;
 
 	/* Set Pbit update if need to modify, temp only for CnM */
 	if (cnm_support == TPM_CNM_SUPPORTED &&
 	    (!(eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC))) {
 		if (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE)
-			c2_entry.qos_value.pri = eng_entry->action->mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE);
+			c2_entry->qos_value.pri = eng_entry->action->mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE);
 		else if (eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE)
-			c2_entry.qos_value.pri = eng_entry->action->mod.vlan_op.inn_vlan.pbit & (~TPM_PBIT_UPDATE);
+			c2_entry->qos_value.pri = eng_entry->action->mod.vlan_op.inn_vlan.pbit & (~TPM_PBIT_UPDATE);
 	}
 
 	if (TPM_PP_DROP == eng_entry->action->dest.pp_port)
-		c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+		c2_entry->action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
 	else if (TPM_PP_CPU == eng_entry->action->dest.pp_port) {
 		/* for filter rule, do not set HWF */
 		if (eng_entry->cap->cap_api_type != TPM_API_PUBLIC_FLTR) {
-			c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF_LOCK;
-			c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK;
-			c2_entry.qos_value.q_high = tpm_mng_cpu_queue_high_get(&eng_entry->match_key->pkt_key->port);
+			c2_entry->action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF_LOCK;
+			c2_entry->action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK;
+			c2_entry->qos_value.q_high = tpm_mng_cpu_queue_high_get(&eng_entry->match_key->pkt_key->port);
 			if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_LPBK) {
 				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_G0)
-					c2_entry.qos_value.q_high = TPM_RXQ_QH_GMAC0;
+					c2_entry->qos_value.q_high = TPM_RXQ_QH_GMAC0;
 				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_G1)
-					c2_entry.qos_value.q_high = TPM_RXQ_QH_GMAC1;
+					c2_entry->qos_value.q_high = TPM_RXQ_QH_GMAC1;
 				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_PON)
-					c2_entry.qos_value.q_high = TPM_RXQ_QH_PON;
+					c2_entry->qos_value.q_high = TPM_RXQ_QH_PON;
 			}
 		} else {
-			tpm_ret = tpm_mng_action_clear_all(&c2_entry.action);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C3 entry actions failed\n");
+			tpm_ret = tpm_mng_action_clear_all(&c2_entry->action);
+			IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c2_entry, "clear all C3 entry actions failed\n");
 		}
 	} else {
-		c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
-		c2_entry.action.color_act = ((eng_entry->action->color == TPM_COL_GREEN) ?
+		c2_entry->action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+		c2_entry->action.color_act = ((eng_entry->action->color == TPM_COL_GREEN) ?
 					     TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK : TPM_COLOR_ACTION_TYPE_YELLOW);
 		/* Special handle CnM pbit as-is rule */
 		if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
-			c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
-			c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+			c2_entry->action.frwd_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+			c2_entry->action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
 		}
 		if (TPM_PP_PMAC == eng_entry->action->dest.pp_port) {
 			if (eng_entry->action->dest.port_id & TPM_PORTID_SPEC) {
-				c2_entry.qos_value.gemp = (eng_entry->action->dest.port_id & (~TPM_PORTID_SPEC));
-				c2_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+				c2_entry->qos_value.gemp = (eng_entry->action->dest.port_id & (~TPM_PORTID_SPEC));
+				c2_entry->action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
 			}
-			c2_entry.qos_value.q_high = eng_entry->action->dest.pon_tx;
+			c2_entry->qos_value.q_high = eng_entry->action->dest.pon_tx;
 		} else
-			c2_entry.qos_value.q_high = eng_entry->action->dest.pp_port + TPM_MNG_DST_PORT_G0_START;
+			c2_entry->qos_value.q_high = eng_entry->action->dest.pp_port + TPM_MNG_DST_PORT_G0_START;
 	}
 
 	/* Modification info */
-	memcpy(&c2_entry.pkt_mod, eng_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&c2_entry->pkt_mod, eng_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
 
 	/* Duplication info */
-	memcpy(&c2_entry.flow_info, eng_entry->dup_info, sizeof(struct tpm_duplicate_t));
+	memcpy(&c2_entry->flow_info, eng_entry->dup_info, sizeof(struct tpm_duplicate_t));
 
 	if (eng_entry->cap->cap_api_type == TPM_API_PRIVATE_CPU_Q) {
-		c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF;
-		c2_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT;
-		c2_entry.action.q_low_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
-		c2_entry.qos_value.q_low = 0;
-		c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+		c2_entry->action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF;
+		c2_entry->action.q_high_act = TPM_ACTION_TYPE_UPDT;
+		c2_entry->action.q_low_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+		c2_entry->qos_value.q_low = 0;
+		c2_entry->action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
 	} else if (eng_entry->cap->cap_api_type == TPM_API_PUBLIC_FLTR) {
 		/* create default rule if it is the first filter rule of this type */
-		tpm_ret = tpm_mng_filter_def_c2_rule_create(eng_entry, &c2_entry);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C2 entry actions failed\n");
+		tpm_ret = tpm_mng_filter_def_c2_rule_create(eng_entry, c2_entry);
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c2_entry, "clear all C2 entry actions failed\n");
 	}
 
-	tpm_ret = tpm_c2_rule_add(&c2_entry, rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "add C2 entry failed\n");
+	tpm_ret = tpm_c2_rule_add(c2_entry, rule_id);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c2_entry, "add C2 entry failed\n");
 
 	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
 
+	mvOsFree(c2_entry);
 	return TPM_OK;
 }
 
@@ -3708,7 +3776,7 @@ static int tpm_mng_mod_create(
 {
 	int tpm_ret;
 	unsigned int ext_mod_bm;
-	struct tpm_pme_pkt_mod_t pme_mod_data[TPM_ACT_NUM_MAX];
+	struct tpm_pme_pkt_mod_t *pme_mod_data;		/*use heap to reduce stack size*/
 	enum tpm_gmac_conn_t gmac_con;
 	int i, j, k, act_idx;
 	unsigned char merge_mod[TPM_ACT_NUM_MAX][TPM_ACT_NUM_MAX];
@@ -3722,6 +3790,10 @@ static int tpm_mng_mod_create(
 
 	TPM_MEMSET_FF(merge_mod);
 
+	pme_mod_data = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_pme_pkt_mod_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, pme_mod_data);
+	memset(pme_mod_data, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_pme_pkt_mod_t));
+
 	for (act_idx = 0; act_idx < act_num; act_idx++) {
 		/* Update mod_bm */
 		ext_mod_bm = action[act_idx].mod.mod_bm;
@@ -3733,7 +3805,7 @@ static int tpm_mng_mod_create(
 		}
 
 		/* Clear pme_mod_data array and init */
-		TPM_MEMSET_ZERO(pme_mod_data[act_idx]);
+		memset(&pme_mod_data[act_idx], 0, sizeof(struct tpm_pme_pkt_mod_t));
 		/* Init pme_mod_data */
 		memcpy(&pme_mod_data[act_idx].mod_data, &action[act_idx].mod, sizeof(struct tpm_pkt_mod_t));
 
@@ -3745,12 +3817,14 @@ static int tpm_mng_mod_create(
 		case TPM_PP_GMAC0:
 			/* Get GMAC Connect info */
 			tpm_ret = tpm_db_gmac_conn_get(TPM_ENUM_GMAC_0, &gmac_con);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC%d connect info get failed\n", TPM_ENUM_GMAC_0);
+			IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pme_mod_data,
+				"GMAC%d connect info get failed\n", TPM_ENUM_GMAC_0);
 		case TPM_PP_GMAC1:
 			if (action[act_idx].dest.pp_port == TPM_PP_GMAC1) {
 				/* Get GMAC Connect info */
 				tpm_ret = tpm_db_gmac_conn_get(TPM_ENUM_GMAC_1, &gmac_con);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC%d connect info get failed\n", TPM_ENUM_GMAC_1);
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pme_mod_data,
+					"GMAC%d connect info get failed\n", TPM_ENUM_GMAC_1);
 			}
 			if (gmac_con == TPM_GMAC_CON_SWITCH_6 ||
 			    gmac_con == TPM_GMAC_CON_SWITCH_4) {
@@ -3770,7 +3844,8 @@ static int tpm_mng_mod_create(
 #endif
 			} else {
 				tpm_ret = TPM_BAD_PARAM;
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC connection info NOT correct\n");
+				IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pme_mod_data,
+					"GMAC connection info NOT correct\n");
 			}
 			break;
 		case TPM_PP_PMAC:
@@ -3780,7 +3855,8 @@ static int tpm_mng_mod_create(
 			break;
 		default:
 			tpm_ret = TPM_BAD_VALUE;
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid target port %d\n", action[act_idx].dest.pp_port);
+			IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pme_mod_data,
+				"Invalid target port %d\n", action[act_idx].dest.pp_port);
 			break;
 		}
 
@@ -3891,7 +3967,8 @@ static int tpm_mng_mod_create(
 				}
 			}
 		}
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Act[%d], Mod create fail\n", merge_mod[act_idx][0]);
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pme_mod_data,
+			"Act[%d], Mod create fail\n", merge_mod[act_idx][0]);
 		for (i = 1; i < act_num; i++) {
 			if (merge_mod[act_idx][i] != 0xFF) {
 				pkt_mod[merge_mod[act_idx][i]].mod_cmd_idx =
@@ -3902,6 +3979,7 @@ static int tpm_mng_mod_create(
 		}
 	}
 
+	mvOsFree(pme_mod_data);
 	return TPM_OK;
 }
 
@@ -4403,26 +4481,29 @@ static int tpm_mng_dup_create(
 	struct tpm_duplicate_t      *dup_info)
 {
 	int tpm_ret;
-	struct tpm_mc_tbl_entry_t mct_entry[TPM_ACT_NUM_MAX];
+	struct tpm_mc_tbl_entry_t *mct_entry;		/*use heap to reduce stack size*/
 	unsigned int flow_id = 0, dup_count = 0;
 
 	IF_NULL(TPM_MNG_MOD, action);
 	IF_NULL(TPM_MNG_MOD, pkt_mod);
 	IF_NULL(TPM_MNG_MOD, dup_info);
 
-	TPM_MEMSET_ZERO(mct_entry);
+	mct_entry = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_mc_tbl_entry_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, mct_entry);
+	memset(mct_entry, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_mc_tbl_entry_t));
 
 	/* Build MCT entry */
 	tpm_ret = tpm_mng_mct_entry_build(src_port, act_num, action, pkt_mod, mct_entry, &dup_count);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM MNG MCT entry build fail\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, mct_entry, "TPM MNG MCT entry build fail\n");
 	/* Create dup list */
 	tpm_ret = tpm_mc_dup_list_create(dup_count, mct_entry, &flow_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM Dup list Create failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, mct_entry, "TPM Dup list Create failed\n");
 
 	/* Return dup info */
 	dup_info->flow_cnt = dup_count;
 	dup_info->flow_id = flow_id;
 
+	mvOsFree(mct_entry);
 	return TPM_OK;
 }
 
@@ -4463,7 +4544,7 @@ int tpm_mng_cap_entry_add(
 	enum tpm_qos_sel_t	qos_sel;
 	enum tpm_vlan_num_enum_t  vlan_num = TPM_ANY_VLAN;
 	struct tpm_db_mng_api_data_t *api_data = NULL;
-	struct tpm_engine_pkt_mod_t pkt_mod[TPM_ACT_NUM_MAX];
+	struct tpm_engine_pkt_mod_t *pkt_mod;		/*use heap to reduce stack size*/
 	enum tpm_engine_no_t	eng_no = TPM_ENGINE_C2;
 	unsigned int		field_match_bm;
 	unsigned int		vlan_out;
@@ -4475,6 +4556,7 @@ int tpm_mng_cap_entry_add(
 	unsigned int vlan_op_code;
 	struct tpm_duplicate_t dup_info;
 	struct tpm_pkt_action_t action_tmp;
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;	/*use heap to reduce stack size*/
 
 	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n");
 	if ((TPM_MNG_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE))
@@ -4483,14 +4565,23 @@ int tpm_mng_cap_entry_add(
 	flow_rules_list->fl_len = 0;
 	flow_rules = flow_rules_list->fl;
 	memset(flow_rules_list, 0, sizeof(struct tpm_cls_fl_rule_list_t));
-	TPM_MEMSET_ZERO(g_flow_cap_arr);
 	TPM_MEMSET_ZERO(eng_entry);
 	TPM_MEMSET_ZERO(pkt_mod);
 	TPM_MEMSET_ZERO(dup_info);
+	cap_arr = mvOsMalloc(TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	pkt_mod = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_engine_pkt_mod_t));
+	if (pkt_mod == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(cap_arr);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(pkt_mod, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_engine_pkt_mod_t));
 
 	/* get vlan_num */
 	tpm_ret = tpm_mng_vlan_num_get(match_key->pkt_key, &vlan_num);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get vlan_num failed\n");
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod, "Failed to get parameter vlan_num\n");
 
 	/* handle vlan magic number of 0x1000 */
 	vlan_out = match_key->pkt_key->out_vid;
@@ -4517,15 +4608,16 @@ int tpm_mng_cap_entry_add(
 	tpm_ret = tpm_db_mng_flow_in_cap_get(api_type,
 			match_key->pkt_key->rule_type,
 			match_key->pkt_key->field_match_bm,
-			vlan_num, g_flow_cap_arr, &flow_num);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
-		"find no cap for api_type(%d), field_bm(%x), rule_type(%d), vlan_num(%d)\n",
-			api_type, match_key->pkt_key->field_match_bm,
-			match_key->pkt_key->rule_type, vlan_num);
+			vlan_num, cap_arr, &flow_num);
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod,
+		"Find no cap for api_type(%d), field_bm(%x), rule_type(%d), vlan_num(%d), please check cap added\n",
+		api_type, match_key->pkt_key->field_match_bm,
+		match_key->pkt_key->rule_type, vlan_num);
 
 	tpm_ret = tpm_mng_add_cap_entry_check(match_key, act_num,
-			action, policer_id, qos, vlan_num, g_flow_cap_arr);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "validation failed for api entry add\n");
+		action, policer_id, qos, vlan_num, cap_arr);
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod,
+		"Input parameters for API entry adding are not valid, please check it.\n");
 
 	/* handle packet duplication, TO_CPU could not be the first action */
 	if ((act_num > 1)
@@ -4547,7 +4639,7 @@ int tpm_mng_cap_entry_add(
 
 	/* Get CnM support value */
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod, "Failed to get CnM support value\n");
 
 	/* Always support pbit update for US CLS if CnM supported */
 	if (cnm_support == TPM_CNM_SUPPORTED &&
@@ -4584,7 +4676,7 @@ int tpm_mng_cap_entry_add(
 					     action,
 					     qos_sel,
 					     pkt_mod);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM Mod Create failed\n");
+		IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod, "TPM Mod Create failed\n");
 		if ((TPM_MNG_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) {
 			for (loop = 0; loop < act_num; loop++) {
 				TPM_OS_DEBUG(TPM_MNG_MOD, "Act[%d] Mod, HWFM_IPtr=%d, HWFM_DPtr=%d, L4_Cksum_Flag=%d\n",
@@ -4631,7 +4723,8 @@ int tpm_mng_cap_entry_add(
 
 	/* allocate api data */
 	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, cap_arr, pkt_mod,
+		"Failed to allocate memory for api_data structure!\n");
 	memset(api_data, 0xff, sizeof(struct tpm_db_mng_api_data_t));
 
 	/* Create Packet replication list */
@@ -4648,16 +4741,16 @@ int tpm_mng_cap_entry_add(
 	for (loop = 0; loop < flow_num; loop++) {
 		/* C2/3 entry with different lu_type will be created */
 		for (loop_in = 0; loop_in < loop; loop_in++)
-			if ((g_flow_cap_arr[loop].lu_type == g_flow_cap_arr[loop_in].lu_type)
-			     && (g_flow_cap_arr[loop].c2_key_bm == g_flow_cap_arr[loop_in].c2_key_bm))
+			if ((cap_arr[loop].lu_type == cap_arr[loop_in].lu_type)
+			     && (cap_arr[loop].c2_key_bm == cap_arr[loop_in].c2_key_bm))
 				break;
 
 		/* if lu_type has been created, move on */
 		if (loop_in != loop)
 			continue;
 
-		eng_entry.cap = &g_flow_cap_arr[loop];
-		eng_no = g_flow_cap_arr[loop].eng_no;
+		eng_entry.cap = &cap_arr[loop];
+		eng_no = cap_arr[loop].eng_no;
 
 		/* create C2/C3 and CLS entry */
 		if (eng_no == TPM_ENGINE_C2) {
@@ -4695,24 +4788,24 @@ int tpm_mng_cap_entry_add(
 			src_port_cfg = (TPM_CAP_PORT_VIR);
 		} else {
 			src_port_cfg = match_key->pkt_key->port.class_port;
-			if (g_flow_cap_arr[loop].cap_api_type < TPM_API_PRIVATE_START) {
-				tpm_ret = tpm_db_mng_cap_hit_num_get(g_flow_cap_arr[0].cap_api_type,
-					g_flow_cap_arr[0].rule_type , g_flow_cap_arr[0].cap_field_bm,
-					g_flow_cap_arr[0].vlan_num, &hit_num);
+			if (cap_arr[loop].cap_api_type < TPM_API_PRIVATE_START) {
+				tpm_ret = tpm_db_mng_cap_hit_num_get(cap_arr[0].cap_api_type,
+					cap_arr[0].rule_type , cap_arr[0].cap_field_bm,
+					cap_arr[0].vlan_num, &hit_num);
 				if (TPM_OK != tpm_ret) {
 					TPM_OS_ERROR(TPM_MNG_MOD, "get CAP hit number failed\n");
 					goto rmv_entry;
 				}
-			} else if ((g_flow_cap_arr[loop].cap_api_type == TPM_API_PRIVATE_EXCT)
-				    || (g_flow_cap_arr[loop].cap_api_type == TPM_API_PRIVATE_MC_US))
+			} else if ((cap_arr[loop].cap_api_type == TPM_API_PRIVATE_EXCT)
+				    || (cap_arr[loop].cap_api_type == TPM_API_PRIVATE_MC_US))
 				hit_num = 2;
 			else
 				hit_num = 1;
 
 			if (hit_num == 2)
-				g_flow_cap_arr[loop].cls_pri++;
+				cap_arr[loop].cls_pri++;
 		}
-		tpm_ret = tpm_mng_def_flow_entry_crt(&g_flow_cap_arr[loop],
+		tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
 			flow_rules_list,
 			src_port_cfg, match_key->pkt_key->port.class_port);
 		if (TPM_OK != tpm_ret) {
@@ -4743,7 +4836,7 @@ int tpm_mng_cap_entry_add(
 
 	/* keep the api data */
 	memcpy(api_data->action, action, sizeof(struct tpm_pkt_action_t) * act_num);
-	memcpy(api_data->pkt_mod, &pkt_mod, sizeof(struct tpm_engine_pkt_mod_t) * act_num);
+	memcpy(api_data->pkt_mod, pkt_mod, sizeof(struct tpm_engine_pkt_mod_t) * act_num);
 	memcpy(&api_data->dup_info, &dup_info, sizeof(struct tpm_duplicate_t));
 
 	/* get api_rule index */
@@ -4781,6 +4874,8 @@ int tpm_mng_cap_entry_add(
 	tpm_db_mng_api_data_release(api_data);
 
 	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+	mvOsFree(pkt_mod);
+	mvOsFree(cap_arr);
 	return TPM_OK;
 
 rmv_entry:
@@ -4821,6 +4916,8 @@ fail:
 	/* release api data */
 	tpm_db_mng_api_data_release(api_data);
 
+	mvOsFree(pkt_mod);
+	mvOsFree(cap_arr);
 	return TPM_FAIL;
 }
 
@@ -5031,36 +5128,40 @@ int tpm_mng_filter_def_rule_cntr_get(
 	int tpm_ret = TPM_OK;
 	unsigned int rule_id;
 	int flow_num;
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;	/*use heap to reduce stack size*/
 
-	IF_NULL(TPM_API_MOD, cntr);
+	IF_NULL(TPM_MNG_MOD, cntr);
 
-	TPM_MEMSET_ZERO(g_flow_cap_arr);
+	cap_arr = mvOsMalloc(TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_FLOW_PER_CAP_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
 
 	/* find caps first */
 	tpm_ret = tpm_db_mng_flow_in_cap_get(TPM_API_PUBLIC_FLTR,
 			rule_type, field_bm, vlan_num,
-			g_flow_cap_arr, &flow_num);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
-		"find no filter with field_bm(%x), rule_type(%d), vlan_num(%d)\n",
-			field_bm, rule_type, vlan_num);
+			cap_arr, &flow_num);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr,
+		"find no filter capability with field_bm(%x), rule_type(%d), vlan_num(%d)\n",
+		field_bm, rule_type, vlan_num);
 
 	/* get default C2/C3 rule_id */
 	tpm_ret = tpm_db_mng_flt_def_rule_get(rule_type, field_bm, vlan_num, &rule_id);
 	if (tpm_ret != TPM_OK) {
-		TPM_OS_INFO(TPM_API_MOD,
-		"no filter rule, so no default rule, cntr 0 for filter of rule_type(%d),field_bm(%d),vlan_num(%d)\n",
+		TPM_OS_INFO(TPM_MNG_MOD,
+		"no filter rule, so no default rule, counter 0 for filter of rule_type(%d),field_bm(%d),vlan_num(%d)\n",
 		rule_type, field_bm, vlan_num);
 		*cntr = 0;
 		return TPM_OK;
 	}
 
-	if (TPM_ENGINE_C2 == g_flow_cap_arr[0].eng_no)
+	if (TPM_ENGINE_C2 == cap_arr[0].eng_no)
 		tpm_ret = tpm_c2_hit_cntr_get(rule_id, cntr);
 	else
 		tpm_ret = tpm_c3_hit_count_get(rule_id, cntr);
 
-	IF_ERROR_STR(TPM_API_MOD, tpm_ret, "fail to hit counter of filter rule(%d)\n", rule_id);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "fail to get hit counter of filter rule(%d)\n", rule_id);
 
+	mvOsFree(cap_arr);
 	return tpm_ret;
 }
 
@@ -5284,23 +5385,26 @@ int tpm_mng_drop_c2_entry_add(
 *******************************************************************************/
 int tpm_mng_create_cpu_q_c2_entry(void)
 {
-	struct tpm_pkt_key_t      match_key;
+	struct tpm_pkt_key_t	*match_key;			/*use heap to reduce stack size*/
 	struct tpm_mng_pkt_key_t  match_mng_key;
 	unsigned int            rule_id;
 	int			tpm_ret;
 
 	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
 	/* create CPU_Q entries */
-	TPM_MEMSET_ZERO(match_key);
+	match_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, match_key);
+	memset(match_key, 0, sizeof(struct tpm_pkt_key_t));
 	TPM_MEMSET_ZERO(match_mng_key);
 
-	match_mng_key.pkt_key = &match_key;
+	match_mng_key.pkt_key = match_key;
 
 	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_CPU_Q,
 					&match_mng_key, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add CPU_Q CAP C2 entry failed\n");
 	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
 
+	mvOsFree(match_key);
 	return TPM_OK;
 }
 #endif
@@ -5428,35 +5532,40 @@ int tpm_mng_create_mc_proto_c2_entry(struct tpm_mng_pkt_key_t *match_mng_key)
 *******************************************************************************/
 int tpm_mng_create_igmp_c2_entry(void)
 {
-	struct tpm_pkt_key_t      match_key;
+	struct tpm_pkt_key_t	*match_key;		/*use heap to reduce stack size*/
 	struct tpm_mng_pkt_key_t  match_mng_key;
 	int			tpm_ret;
 	int			ipv6_enable;
 
-	TPM_MEMSET_ZERO(match_key);
+	match_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, match_key);
+	memset(match_key, 0, sizeof(struct tpm_pkt_key_t));
 	TPM_MEMSET_ZERO(match_mng_key);
 
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6_enable failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "get ipv6_enable failed\n");
 
 	/* create IPv4 IGMP entries */
-	match_mng_key.pkt_key = &match_key;
-	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT;
-	match_key.ipvx_add.ip_proto = TPM_MNG_IGMP_PROT_VALUE;
+	match_mng_key.pkt_key = match_key;
+	match_key->field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT;
+	match_key->ipvx_add.ip_proto = TPM_MNG_IGMP_PROT_VALUE;
 
 	tpm_ret = tpm_mng_create_mc_proto_c2_entry(&match_mng_key);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add IGMP C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add IGMP C2 entry failed\n");
 
 	/* add IPv6 rules */
-	if (ipv6_enable != TPM_IPV6_SUPPORTED)
+	if (ipv6_enable != TPM_IPV6_SUPPORTED) {
+		mvOsFree(match_key);
 		return TPM_OK;
+	}
 
-	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT;
-	match_key.ipvx_add.ip_proto = TPM_MNG_MLD_NH_VALUE;
+	match_key->field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT;
+	match_key->ipvx_add.ip_proto = TPM_MNG_MLD_NH_VALUE;
 
 	tpm_ret = tpm_mng_create_mc_proto_c2_entry(&match_mng_key);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add MLD C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add MLD C2 entry failed\n");
 
+	mvOsFree(match_key);
 	return TPM_OK;
 }
 
@@ -5479,7 +5588,7 @@ int tpm_mng_create_igmp_c2_entry(void)
 *******************************************************************************/
 int tpm_mng_create_lpbk_mh_c2_entry(void)
 {
-	struct tpm_pkt_key_t      match_key;
+	struct tpm_pkt_key_t	*match_key;			/*use heap to reduce stack size*/
 	struct tpm_mng_pkt_key_t  match_mng_key;
 	int			tpm_ret;
 	unsigned int		rule_id;
@@ -5487,17 +5596,19 @@ int tpm_mng_create_lpbk_mh_c2_entry(void)
 	struct tpm_qos_t	  qos;
 	int cpu_queue;
 
-	TPM_MEMSET_ZERO(match_key);
+	match_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, match_key);
+	memset(match_key, 0, sizeof(struct tpm_pkt_key_t));
 	TPM_MEMSET_ZERO(match_mng_key);
 	TPM_MEMSET_ZERO(action);
 	TPM_MEMSET_ZERO(qos);
 
 	action.dest.pp_port = TPM_PP_CPU;
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "get CPU_RX_QUEUE failed\n");
 
 	/* create loopback MH entries */
-	match_mng_key.pkt_key = &match_key;
+	match_mng_key.pkt_key = match_key;
 	match_mng_key.pkt_key->field_match_bm = TPM_MATCH_MH;
 	match_mng_key.mh_mask = TPM_MNG_LPBK_MH_MASK;
 	match_mng_key.pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
@@ -5510,7 +5621,7 @@ int tpm_mng_create_lpbk_mh_c2_entry(void)
 	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
 					&action, TPM_POLICER_INVALID,
 					&qos, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add lpbk_mh_C2 entry failed\n");
 
 	/* Trap to CPU through GMAC1 */
 	match_mng_key.mh = TPM_PME_LPBK_MH_G1;
@@ -5518,7 +5629,7 @@ int tpm_mng_create_lpbk_mh_c2_entry(void)
 	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
 					&action, TPM_POLICER_INVALID,
 					&qos, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add lpbk_mh_C2 entry failed\n");
 
 	/* Trap to CPU through PON */
 	match_mng_key.mh = TPM_PME_LPBK_MH_PON;
@@ -5526,8 +5637,9 @@ int tpm_mng_create_lpbk_mh_c2_entry(void)
 	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
 					&action, TPM_POLICER_INVALID,
 					&qos, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add lpbk_mh_C2 entry failed\n");
 
+	mvOsFree(match_key);
 	return TPM_OK;
 }
 
@@ -5550,22 +5662,24 @@ int tpm_mng_create_lpbk_mh_c2_entry(void)
 *******************************************************************************/
 int tpm_mng_create_ipvx_c2_entry(void)
 {
-	struct tpm_pkt_key_t      match_key;
+	struct tpm_pkt_key_t      *match_key;		/*use heap to reduce stack size*/
 	struct tpm_mng_pkt_key_t  match_mng_key;
 	unsigned int            rule_id;
 	int			tpm_ret;
 	int			ttl_action;
 
 	/* create IPvx entries */
-	TPM_MEMSET_ZERO(match_key);
+	match_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, match_key);
+	memset(match_key, 0, sizeof(struct tpm_pkt_key_t));
 	TPM_MEMSET_ZERO(match_mng_key);
-	match_mng_key.pkt_key = &match_key;
+	match_mng_key.pkt_key = match_key;
 
 	/* TTL == 0, drop */
 	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_TTL_ILLEGAL_ACTION, &ttl_action);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get invalid TTL action failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "get invalid TTL action failed\n");
 
-	match_key.field_match_bm = TPM_MATCH_TTL;
+	match_key->field_match_bm = TPM_MATCH_TTL;
 	match_mng_key.ttl = 0;
 
 	if (ttl_action == TPM_TTL_ZERO_ACTION_NOT_CARE) {
@@ -5573,45 +5687,46 @@ int tpm_mng_create_ipvx_c2_entry(void)
 	} else if (ttl_action == TPM_TTL_ZERO_ACTION_DROP) {
 		tpm_ret = tpm_mng_drop_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 						&match_mng_key, &rule_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL DROP C2 entry failed\n");
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TTL DROP C2 entry failed\n");
 	} else if (ttl_action == TPM_TTL_ZERO_ACTION_TO_CPU) {
 		tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 						&match_mng_key, &rule_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL == 0 CPU C2 entry failed\n");
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TTL == 0 CPU C2 entry failed\n");
 	}
 	/* TTL == 1, to CPU */
 	match_mng_key.ttl = 1;
 	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 					&match_mng_key, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL == 1 CPU C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TTL == 1 CPU C2 entry failed\n");
 
 	/* TCP FLAG RST FIN, to CPU */
-	TPM_MEMSET_ZERO(match_key);
+	memset(match_key, 0, TPM_CNM_FIELD_MAX * sizeof(struct tpm_field_match_info));
 	TPM_MEMSET_ZERO(match_mng_key);
-	match_mng_key.pkt_key = &match_key;
+	match_mng_key.pkt_key = match_key;
 
-	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF;
+	match_key->field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF;
 	match_mng_key.pkt_key->ipvx_add.ip_proto = MV_IP_PROTO_TCP;
 	match_mng_key.tcp_flag = 0x1;
 	match_mng_key.tcp_flag_mask = 0x1;
 	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 					&match_mng_key, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG FIN CPU C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TCP FLAG FIN CPU C2 entry failed\n");
 
 	match_mng_key.tcp_flag = 0x4;
 	match_mng_key.tcp_flag_mask = 0x4;
 	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 					&match_mng_key, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG RST CPU C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TCP FLAG RST CPU C2 entry failed\n");
 
 	/* TCP FLAG SYN, to CPU */
-	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S;
+	match_key->field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S;
 	match_mng_key.tcp_flag = 0x2;
 	match_mng_key.tcp_flag_mask = 0x2;
 	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
 					&match_mng_key, &rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG SYN CPU C2 entry failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, match_key, "Add TCP FLAG SYN CPU C2 entry failed\n");
 
+	mvOsFree(match_key);
 	return TPM_OK;
 }
 
@@ -6007,7 +6122,7 @@ int tpm_mng_mc_default_set(void)
 	int tpm_ret;
 	unsigned int data_handle, mc_def_act;
 	unsigned int rule_id;
-	struct tpm_pkt_key_t pkt_key;
+	struct tpm_pkt_key_t *pkt_key;		/*use heap to reduce stack size*/
 	struct tpm_mng_pkt_key_t match_key;
 	struct tpm_pkt_action_t action;
 	struct tpm_qos_t qos;
@@ -6031,27 +6146,29 @@ int tpm_mng_mc_default_set(void)
 	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
 
 	/* Add MC default rule */
-	TPM_MEMSET_ZERO(pkt_key);
+	pkt_key = mvOsMalloc(sizeof(struct tpm_pkt_key_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, pkt_key);
+	memset(pkt_key, 0, sizeof(struct tpm_pkt_key_t));
 	TPM_MEMSET_ZERO(match_key);
 	TPM_MEMSET_ZERO(action);
 	TPM_MEMSET_ZERO(qos);
 
-	match_key.pkt_key = &pkt_key;
+	match_key.pkt_key = pkt_key;
 
 	/* Src Port */
-	pkt_key.port.port_type = TPM_CLASS_PP_PORT_BM;
-	pkt_key.port.class_port = TPM_PP_PMAC;
+	pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+	pkt_key->port.class_port = TPM_PP_PMAC;
 
 	/* QoS */
 	qos.qos_sel = TPM_QOS_NONE;
 
 	/* Add L3 default rule, check PPPoE ether type */
-	pkt_key.field_match_bm = TPM_MATCH_ETH_TYPE;
-	pkt_key.ether_type = MV_PPPOE_TYPE;
-	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+	pkt_key->field_match_bm = TPM_MATCH_ETH_TYPE;
+	pkt_key->ether_type = MV_PPPOE_TYPE;
+	pkt_key->rule_type = TPM_MC_DEF_DIP_TYPE;
 	/* Get L3 default rule action, drop or to CPU */
 	tpm_ret = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L3, &mc_def_act);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get L3 MC default action failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "get L3 MC default action failed\n");
 	if (mc_def_act == TPM_MC_FLOW_DEFAULT_DROP)
 		action.dest.pp_port = TPM_PP_DROP;
 	else
@@ -6064,18 +6181,18 @@ int tpm_mng_mc_default_set(void)
 					TPM_POLICER_INVALID,
 					&qos,
 					&rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L3 MC default rule\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "fail to add L3 MC default rule\n");
 
 	/* Add L2 MC default rule for IPVx, Check DIP or MAC */
 
 	/* IPV4 */
-	pkt_key.field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT;
-	pkt_key.ipvx_add.ip_dst.ip_add.ipv4[0] = TPM_IPV4_MC_IP;
-	pkt_key.ipvx_add.ip_dst.ip_add_mask.ipv4[0] = TPM_IPV4_MC_IP_MASK;
-	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+	pkt_key->field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT;
+	pkt_key->ipvx_add.ip_dst.ip_add.ipv4[0] = TPM_IPV4_MC_IP;
+	pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv4[0] = TPM_IPV4_MC_IP_MASK;
+	pkt_key->rule_type = TPM_MC_DEF_DIP_TYPE;
 	/* Get default rule action, drop or to CPU */
 	tpm_ret = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L2, &mc_def_act);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC default action failed\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "get MC default action failed\n");
 	if (mc_def_act == TPM_MC_FLOW_DEFAULT_DROP)
 		action.dest.pp_port = TPM_PP_DROP;
 	else
@@ -6089,14 +6206,14 @@ int tpm_mng_mc_default_set(void)
 					TPM_POLICER_INVALID,
 					&qos,
 					&rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 IPv4 MC default rule\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "fail to add L2 IPv4 MC default rule\n");
 
 	if (ipv6_enable == TPM_IPV6_SUPPORTED) {
 		/* Check IPV6 DIP prefix */
-		pkt_key.field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PKT;
-		pkt_key.ipvx_add.ip_dst.ip_add.ipv6[0] = TPM_IPV6_MC_IP;
-		pkt_key.ipvx_add.ip_dst.ip_add_mask.ipv6[0] = TPM_IPV6_MC_IP_MASK;
-		pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+		pkt_key->field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PKT;
+		pkt_key->ipvx_add.ip_dst.ip_add.ipv6[0] = TPM_IPV6_MC_IP;
+		pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv6[0] = TPM_IPV6_MC_IP_MASK;
+		pkt_key->rule_type = TPM_MC_DEF_DIP_TYPE;
 		/* Add IPv6 default rule */
 		tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
 						&match_key,
@@ -6105,14 +6222,14 @@ int tpm_mng_mc_default_set(void)
 						TPM_POLICER_INVALID,
 						&qos,
 						&rule_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 IPv6 MC default rule\n");
+		IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "fail to add L2 IPv6 MC default rule\n");
 	}
 
 	/* Add L2 MC default rule for non-ip MC */
-	pkt_key.field_match_bm = TPM_MATCH_ETH_DST;
-	pkt_key.eth_dst.eth_add[0] = TPM_MC_MAC;
-	pkt_key.eth_dst.eth_add_mask[0] = TPM_MC_MAC_MASK;
-	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+	pkt_key->field_match_bm = TPM_MATCH_ETH_DST;
+	pkt_key->eth_dst.eth_add[0] = TPM_MC_MAC;
+	pkt_key->eth_dst.eth_add_mask[0] = TPM_MC_MAC_MASK;
+	pkt_key->rule_type = TPM_MC_DEF_DIP_TYPE;
 
 	/* Add L2 MC default rule */
 	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
@@ -6122,7 +6239,7 @@ int tpm_mng_mc_default_set(void)
 					TPM_POLICER_INVALID,
 					&qos,
 					&rule_id);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 NON-IP MC default rule\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "fail to add L2 NON-IP MC default rule\n");
 
 #ifdef CONFIG_MV_INCLUDE_SWITCH
 	if (TPM_SW_MODE_INIT == switch_init) {
@@ -6131,10 +6248,11 @@ int tpm_mng_mc_default_set(void)
 			tpm_ret = tpm_sw_port_flood_control_mask_set(sw_port,
 								     TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST,
 								     TPM_MC_UNKNOWN_BLOCK);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to set switch flood mask\n");
+			IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, pkt_key, "fail to set switch flood mask\n");
 		}
 	}
 #endif
+	mvOsFree(pkt_key);
 	return TPM_OK;
 }
 
@@ -6220,16 +6338,13 @@ int tpm_mng_engine_action_update(unsigned int rule_idx,
 	int tpm_ret;
 	struct tpm_db_mng_api_data_t *api_data = NULL;
 	struct tpm_engine_sram_t entry_sram;
-	struct tpm_c2_data_t c2_data;
-	struct tpm_c3_data_t c3_data;
+	struct tpm_c3_data_t *c3_data;		/*use heap to reduce stack size*/
 
 	IF_NULL(TPM_MNG_MOD, src_port);
 	IF_NULL(TPM_MNG_MOD, action);
 	IF_NULL(TPM_MNG_MOD, pkt_mod);
 
 	TPM_MEMSET_ZERO(entry_sram);
-	TPM_MEMSET_ZERO(c2_data);
-	TPM_MEMSET_ZERO(c3_data);
 
 	/* allocate api data */
 	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
@@ -6244,13 +6359,18 @@ int tpm_mng_engine_action_update(unsigned int rule_idx,
 		tpm_ret = tpm_c2_rule_sram_get(api_data->c2_rule_id[0], &entry_sram);
 		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM get fail\n");
 	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		c3_data = mvOsMalloc(sizeof(struct tpm_c3_data_t));
+		IF_MALLOC_FAIL(TPM_MNG_MOD, c3_data);
+		memset(c3_data, 0, sizeof(struct tpm_c3_data_t));
+
 		/* Get C3 data */
-		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], &c3_data);
-		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 entry get fail\n");
+		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], c3_data);
+		IF_ERROR_STR_REL_API_DATA_FREE(TPM_MNG_MOD, tpm_ret, api_data, c3_data, "C3 entry get fail\n");
 		/* Get SRAM */
-		memcpy(&entry_sram.action, &c3_data.action, sizeof(struct tpm_engine_pkt_action_t));
-		memcpy(&entry_sram.qos_value, &c3_data.qos_value, sizeof(struct tpm_qos_value_t));
-		memcpy(&entry_sram.dup_info, &c3_data.dup_info, sizeof(struct tpm_duplicate_t));
+		memcpy(&entry_sram.action, &c3_data->action, sizeof(struct tpm_engine_pkt_action_t));
+		memcpy(&entry_sram.qos_value, &c3_data->qos_value, sizeof(struct tpm_qos_value_t));
+		memcpy(&entry_sram.dup_info, &c3_data->dup_info, sizeof(struct tpm_duplicate_t));
+		mvOsFree(c3_data);
 	}
 
 	if (TPM_PP_DROP == action->dest.pp_port) {
@@ -6319,20 +6439,17 @@ int tpm_mng_entry_dup_update(unsigned int rule_idx, unsigned int dup_cnt, unsign
 	int tpm_ret;
 	struct tpm_db_mng_api_data_t *api_data = NULL;
 	struct tpm_engine_sram_t entry_sram;
-	struct tpm_c2_data_t c2_data;
-	struct tpm_c3_data_t c3_data;
+	struct tpm_c3_data_t *c3_data;		/*use heap to reduce stack size*/
 
 	/* Parameter check */
 	TPM_DECIMAL_RANGE_VALIDATE(TPM_MNG_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
 	TPM_DECIMAL_RANGE_VALIDATE(TPM_MNG_MOD, dup_cnt, 0, TPM_MC_DUP_MAX);
 
 	TPM_MEMSET_ZERO(entry_sram);
-	TPM_MEMSET_ZERO(c2_data);
-	TPM_MEMSET_ZERO(c3_data);
 
 	/* allocate api data */
 	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Failed to allocate memory for api_data structure!\n");
 
 	/* Read API data */
 	tpm_ret = tpm_db_mng_api_entry_get(rule_idx, api_data);
@@ -6350,13 +6467,18 @@ int tpm_mng_entry_dup_update(unsigned int rule_idx, unsigned int dup_cnt, unsign
 		tpm_ret = tpm_c2_rule_sram_update(api_data->c2_rule_id[0], &entry_sram);
 		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM update fail\n");
 	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		c3_data = mvOsMalloc(sizeof(struct tpm_c3_data_t));
+		IF_MALLOC_FAIL(TPM_MNG_MOD, c3_data);
+		memset(c3_data, 0, sizeof(struct tpm_c3_data_t));
+
 		/* Get C3 data */
-		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], &c3_data);
+		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], c3_data);
 		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 entry get fail\n");
 		/* Get SRAM */
-		memcpy(&entry_sram.action, &c3_data.action, sizeof(struct tpm_engine_pkt_action_t));
-		memcpy(&entry_sram.qos_value, &c3_data.qos_value, sizeof(struct tpm_qos_value_t));
-		memcpy(&entry_sram.pkt_mod, &c3_data.pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+		memcpy(&entry_sram.action, &c3_data->action, sizeof(struct tpm_engine_pkt_action_t));
+		memcpy(&entry_sram.qos_value, &c3_data->qos_value, sizeof(struct tpm_qos_value_t));
+		memcpy(&entry_sram.pkt_mod, &c3_data->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+		mvOsFree(c3_data);
 		/* Update Dup */
 		entry_sram.dup_info.flow_cnt = dup_cnt;
 		entry_sram.dup_info.flow_id = flow_id;
@@ -6469,6 +6591,7 @@ int tpm_mng_reset(void)
 {
 	int tpm_ret;
 	int arr_len;
+	struct tpm_db_mng_cap_conf_t *cap_arr = NULL;	/*use heap to reduce stack size*/
 
 	tpm_db_mng_clear();
 
@@ -6502,12 +6625,16 @@ int tpm_mng_reset(void)
 	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add MC CAP failed\n");
 
 	/* add all public caps from user */
-	TPM_MEMSET_ZERO(g_cap_arr);
-	tpm_ret = tpm_db_mng_pub_cap_get(g_cap_arr, &arr_len);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GET PUB CAP failed\n");
+	cap_arr = mvOsMalloc(TPM_DB_MNG_CAP_MAX * sizeof(struct tpm_db_mng_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_DB_MNG_CAP_MAX * sizeof(struct tpm_db_mng_cap_conf_t));
 
-	tpm_ret = tpm_mng_cap_add(g_cap_arr, arr_len);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add PUB CAP failed\n");
+	tpm_ret = tpm_db_mng_pub_cap_get(cap_arr, &arr_len);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "GET PUB CAP failed\n");
+
+	tpm_ret = tpm_mng_cap_add(cap_arr, arr_len);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, cap_arr, "Add PUB CAP failed\n");
+	mvOsFree(cap_arr);
 
 	/* merge caps */
 	tpm_ret = tpm_mng_cap_merge();
@@ -7038,10 +7165,10 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 {
 	int tpm_ret;
 	struct tpm_mng_pkt_key_t mng_match_key;
-	struct tpm_mc_tbl_entry_t mct_entry[TPM_ACT_NUM_MAX];
+	struct tpm_mc_tbl_entry_t *mct_entry;		/*use heap to reduce stack size*/
 	struct tpm_pkt_action_t temp_act;
-	struct tpm_engine_pkt_mod_t pkt_mod[TPM_ACT_NUM_MAX];
-	struct tpm_engine_pkt_mod_t old_pkt_mod[TPM_ACT_NUM_MAX];
+	struct tpm_engine_pkt_mod_t *pkt_mod;		/*use heap to reduce stack size*/
+	struct tpm_engine_pkt_mod_t *old_pkt_mod;	/*use heap to reduce stack size*/
 	struct tpm_engine_pkt_mod_t temp_mod;
 	unsigned int old_num_dest;
 	unsigned int free_cnt = 0;
@@ -7111,7 +7238,17 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 	TPM_OS_DEBUG(TPM_MNG_MOD, "Update Original Multicast rule[%d]\n", *rule_index);
 
 	/* Build modification info */
-	TPM_MEMSET_ZERO(pkt_mod);
+	pkt_mod = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_field_match_info));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, pkt_mod);
+	memset(pkt_mod, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_field_match_info));
+	old_pkt_mod = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_pkt_key_t));
+	if (old_pkt_mod == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(pkt_mod);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(old_pkt_mod, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_pkt_key_t));
+
 	for (loop = 0; loop < num_dest; loop++) {
 		if (merge_act[loop][0] == TPM_MNG_MERGE_INVALID)
 			continue;
@@ -7131,7 +7268,7 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 				}
 				/* Update MH BM */
 				tpm_ret = tpm_mng_dst_port_bm_update(old_api_data->pkt_mod[i].mod_data_idx, uni_bm);
-				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MH BM update fail\n");
+				IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod, "MH BM update fail\n");
 				break;
 			}
 		}
@@ -7143,7 +7280,7 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 						     &action[merge_act[loop][0]],
 						     TPM_QOS_NONE,
 						     &pkt_mod[merge_act[loop][0]]);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Mod create fail\n");
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod, "Mod create fail\n");
 			uni_bm = 1 << action[merge_act[loop][0]].dest.port_id;
 			for (j = 1; j < num_dest; j++) {
 				if (merge_act[loop][j] != 0xFF) {
@@ -7155,7 +7292,7 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 			}
 			/* Update MH BM */
 			tpm_ret = tpm_mng_dst_port_bm_update(pkt_mod[merge_act[loop][0]].mod_data_idx, uni_bm);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MH BM update fail\n");
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod, "MH BM update fail\n");
 		}
 	}
 
@@ -7228,16 +7365,18 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 	}
 
 	/* Build MCT entry */
-	TPM_MEMSET_ZERO(mct_entry);
+	mct_entry = mvOsMalloc(TPM_ACT_NUM_MAX * sizeof(struct tpm_mc_tbl_entry_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, mct_entry);
+	memset(mct_entry, 0, TPM_ACT_NUM_MAX * sizeof(struct tpm_mc_tbl_entry_t));
 	tpm_ret = tpm_mng_mct_entry_build(src_port, num_dest, action, pkt_mod, mct_entry, &new_dup_cnt);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG MCT entry build fail\n");
+	IF_ERROR_STR_FREE_3(TPM_MNG_MOD, tpm_ret, mct_entry, pkt_mod, old_pkt_mod, "MNG MCT entry build fail\n");
 	if (root_act_found == false) {
 		/* Update SRAM of root rule with action[0] and pkt_mod[0] */
 		tpm_ret = tpm_mng_engine_action_update(old_api_data->api_rule_id,
 						       &old_api_data->match_key.port,
 						       &action[0],
 						       &pkt_mod[0]);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG action update fail\n");
+		IF_ERROR_STR_FREE_3(TPM_MNG_MOD, tpm_ret, mct_entry, pkt_mod, old_pkt_mod, "MNG action update fail\n");
 	}
 	/* Update dup list */
 	if (old_api_data->dup_info.flow_cnt) {
@@ -7247,20 +7386,24 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 						 mct_entry,
 						 tpm_mng_entry_dup_update,
 						 tpm_mng_dst_port_bm_update);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG dup list update fail\n");
+		IF_ERROR_STR_FREE_3(TPM_MNG_MOD, tpm_ret, mct_entry, pkt_mod, old_pkt_mod,
+			"MNG dup list update fail\n");
 	} else {
 		/* Create a new dup list */
 		tpm_ret = tpm_mc_dup_list_create(new_dup_cnt,
 						 mct_entry,
 						 &new_flow_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Dup list create fail\n");
+		IF_ERROR_STR_FREE_3(TPM_MNG_MOD, tpm_ret, mct_entry, pkt_mod, old_pkt_mod, "Dup list create fail\n");
 		/* Update it to root rule */
 		tpm_ret = tpm_mng_entry_dup_update(old_api_data->api_rule_id,
 						   new_dup_cnt,
 						   new_flow_id);
-		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Update dup info for rule(%d) fail\n", old_api_data->api_rule_id);
+		IF_ERROR_STR_FREE_3(TPM_MNG_MOD, tpm_ret, mct_entry, pkt_mod, old_pkt_mod,
+			"Update dup info for rule(%d) fail\n", old_api_data->api_rule_id);
 	}
 
+	mvOsFree(mct_entry);
+
 	/* Record original info */
 	for (loop = 0; loop < old_api_data->num_dest; loop++)
 		memcpy(&old_pkt_mod[loop], &old_api_data->pkt_mod[loop], sizeof(struct tpm_engine_pkt_mod_t));
@@ -7269,7 +7412,8 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 
 	/* Move the last entry in dup list to root action */
 	tpm_ret = tpm_db_mng_api_entry_get(*rule_index, old_api_data);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "api_entry get fail wirh rule id[%d]\n", *rule_index);
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod,
+		"api_entry get fail wirh rule id[%d]\n", *rule_index);
 
 	/* Update num dest and pkt mod to DB */
 	old_api_data->num_dest = num_dest;
@@ -7278,7 +7422,8 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 		memcpy(&old_api_data->pkt_mod[i], &pkt_mod[i], sizeof(struct tpm_engine_pkt_mod_t));
 	}
 	tpm_ret = tpm_db_mng_api_entry_set(*rule_index, old_api_data);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "api_entry set fail wirh rule id[%d]\n", *rule_index);
+	IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod,
+		"api_entry set fail wirh rule id[%d]\n", *rule_index);
 
 	/* Release pkt mod which no used any more */
 	for (loop = 0; loop < old_num_dest; loop++) {
@@ -7306,10 +7451,13 @@ static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
 					old_pkt_mod[loop].mod_cmd_idx, old_pkt_mod[loop].mod_data_idx);
 			tpm_ret = tpm_pme_mod_release(old_pkt_mod[loop].mod_cmd_idx,
 						      old_pkt_mod[loop].mod_data_idx);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to release modification entry\n");
+			IF_ERROR_STR_FREE_2(TPM_MNG_MOD, tpm_ret, pkt_mod, old_pkt_mod,
+				"fail to release modification entry\n");
 		}
 	}
 
+	mvOsFree(pkt_mod);
+	mvOsFree(old_pkt_mod);
 	return TPM_OK;
 }
 
@@ -7403,7 +7551,7 @@ int tpm_mng_mc_flow_add(struct tpm_pkt_key_t	*match_key,
 				      match_key,
 				      &old_rule_id);
 	if (tpm_ret != TPM_OK) {
-		if (tpm_ret != TPM_NOT_FOUND)
+		if (tpm_ret != TPM_NO_SUCH)
 			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Rule index get fail with match key\n");
 		old_rule_id = TPM_DB_MNG_RULE_ID_INVALID;
 	}
@@ -7551,7 +7699,7 @@ int tpm_mng_mc_flow_del_all(void)
 	int loop;
 	unsigned int data_handle;
 	struct tpm_db_mng_api_data_t *api_data = NULL;
-	unsigned short mc_api_idx[TPM_DB_MNG_MC_API_RULE_MAX] = {0};
+	unsigned short *mc_api_idx;			/*use heap to reduce stack size*/
 	unsigned int mc_api_cnt = 0;
 
 	/* Chekc the handler mod eof multicast mode, if not MC, no need to add defaut rule  */
@@ -7574,11 +7722,16 @@ int tpm_mng_mc_flow_del_all(void)
 	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "first MC api rule get fail\n");
 	tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data);
 	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Next MC api rule get fail\n");
+
+	mc_api_idx = mvOsMalloc(TPM_DB_MNG_MC_API_RULE_MAX * sizeof(unsigned short));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, mc_api_idx);
+	memset(mc_api_idx, 0, TPM_DB_MNG_MC_API_RULE_MAX * sizeof(unsigned short));
 	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
 		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data);
 		if (tpm_ret == TPM_NO_SUCH)
 			break;
-		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Next MC api rule get fail\n");
+		IF_ERROR_STR_REL_API_DATA_FREE(TPM_MNG_MOD, tpm_ret, api_data, mc_api_idx,
+			"Next MC api rule get fail\n");
 		mc_api_idx[mc_api_cnt++] = api_data->api_rule_id;
 	}
 
@@ -7589,10 +7742,12 @@ int tpm_mng_mc_flow_del_all(void)
 	if (mc_api_cnt) {
 		for (loop = 0; loop < mc_api_cnt; loop++) {
 			tpm_ret = tpm_mng_mc_flow_del(mc_api_idx[loop]);
-			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MC rule[%d] delete fail\n", mc_api_idx[loop]);
+			IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, mc_api_idx,
+				"MC rule[%d] delete fail\n", mc_api_idx[loop]);
 		}
 	}
 
+	mvOsFree(mc_api_idx);
 	return TPM_OK;
 }
 
@@ -7769,21 +7924,26 @@ int tpm_mng_cm_rule_add(struct tpm_cnm_key_t	*cnm_key,
 			    struct tpm_pkt_action_t	*action)
 {
 	int tpm_ret = TPM_OK;
-	struct tpm_c4_add_entry_t c4_entry;
+	struct tpm_c4_add_entry_t *c4_entry;		/*use heap to reduce stack size*/
 
 	tpm_ret = tpm_mng_cm_rule_add_check(cnm_key, action);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM rule add check failed\n");
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM rule input parameters are not valid\n");
+
+	c4_entry = mvOsMalloc(sizeof(struct tpm_c4_add_entry_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, c4_entry);
+	memset(c4_entry, 0, sizeof(struct tpm_c4_add_entry_t));
 
-	tpm_ret = tpm_mng_cm_c4_entry_build(cnm_key, action, &c4_entry);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "build C4 entry failed\n");
+	tpm_ret = tpm_mng_cm_c4_entry_build(cnm_key, action, c4_entry);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c4_entry, "Failed to build CnM entry (on C4 engine)\n");
 
-	tpm_ret = tpm_c4_entry_add(&c4_entry);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM rule add fail\n");
+	tpm_ret = tpm_c4_entry_add(c4_entry);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c4_entry, "Failed to add CnM rule(on C4 engine)\n");
 
 	/* update MNG DB */
 	tpm_ret = tpm_db_mng_cm_rule_add(cnm_key, action);
-	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add CnM entry into DB\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, tpm_ret, c4_entry, "Fail to record CnM entry into DB\n");
 
+	mvOsFree(c4_entry);
 	return tpm_ret;
 }
 
@@ -7808,32 +7968,38 @@ int tpm_mng_cm_rule_del(
 {
 	int rc = TPM_OK;
 	unsigned int		rule_set;
-	struct tpm_db_mng_ctc_cnm_rule_t cnm_rule;
+	struct tpm_db_mng_ctc_cnm_rule_t *cnm_rule;		/*use heap to reduce stack size*/
 
 	IF_NULL(TPM_MNG_MOD, port);
 
+	cnm_rule = mvOsMalloc(sizeof(struct tpm_db_mng_ctc_cnm_rule_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cnm_rule);
+	memset(cnm_rule, 0, sizeof(struct tpm_db_mng_ctc_cnm_rule_t));
+
 	/* get cnm rule from MNG DB */
-	rc = tpm_db_mng_cm_rule_get(port, rule_num, &cnm_rule);
-	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get CnM entry from DB\n");
+	rc = tpm_db_mng_cm_rule_get(port, rule_num, cnm_rule);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, rc, cnm_rule, "Fail to get CnM entry from DB\n");
 
-	if (!cnm_rule.valid) {
-		TPM_OS_ERROR(TPM_MNG_MOD, "there is no rule to delete for port(%d), rule_num(%d)",
+	if (!cnm_rule->valid) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "There is no rule to delete for port(%d), rule_num(%d)",
 			port->class_port, rule_num);
-		return TPM_BAD_PARAM;
+		mvOsFree(cnm_rule);
+		return TPM_NO_SUCH;
 	}
 
 	/* get ruleSet */
 	rc = tpm_db_mng_cm_ruleset_get(port, &rule_set);
-	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get ruleSet from DB\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, rc, cnm_rule, "Fail to get ruleSet from DB\n");
 
 	rc = tpm_c4_entry_del(rule_set, rule_num);
-	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to delete C4 entry rule_set(%d) rule_num(%d)\n",
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, rc, cnm_rule, "Fail to delete C4 entry rule_set(%d) rule_num(%d)\n",
 		rule_set, rule_num);
 
 	/* update MNG DB */
 	rc = tpm_db_mng_cm_rule_del(port, rule_num);
-	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to delete CnM entry from DB\n");
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, rc, cnm_rule, "Fail to delete CnM entry from DB\n");
 
+	mvOsFree(cnm_rule);
 	return TPM_OK;
 }
 
@@ -7857,7 +8023,6 @@ int tpm_mng_cm_rule_del_all(unsigned int port_bm)
 	int loop;
 	int loop_in;
 	struct tpm_class_port_t port;
-	struct tpm_db_mng_ctc_cnm_rule_t cnm_rule;
 
 	for (loop = 0; loop < TPM_NUM_MAX_UNI_PORTS; loop++) {
 
@@ -7868,15 +8033,10 @@ int tpm_mng_cm_rule_del_all(unsigned int port_bm)
 		port.class_port = (1 << loop);
 
 		for (loop_in = 0; loop_in < MV_PP2_CLS_C4_GRP_SIZE; loop_in++) {
-			/* check if rule exists */
-			rc = tpm_db_mng_cm_rule_get(&port, loop_in, &cnm_rule);
-			IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get CnM rules from DB port(%d)\n", loop);
-
-			if (!cnm_rule.valid)
-				continue;
-
 			rc = tpm_mng_cm_rule_del(&port, loop_in);
-			IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to Delete all CnM rules on port(%d)\n", port_bm);
+			if (TPM_NO_SUCH == rc)
+				continue;
+			IF_ERROR_STR(TPM_MNG_MOD, rc, "Fail to Delete all CnM rules on port(%d)\n", port_bm);
 		}
 	}
 
@@ -7995,7 +8155,7 @@ void tpm_mng_cap_merge_auto_test(void)
 	int cap_num;
 	int tpm_ret;
 	int loop;
-	struct tpm_db_mng_flow_cap_conf_t cap_arr_out[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr_out;		/*use heap to reduce stack size*/
 	static struct tpm_db_mng_flow_cap_conf_t cap_arr_in[] = {
 
 	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
@@ -8075,10 +8235,18 @@ void tpm_mng_cap_merge_auto_test(void)
 	 10, TPM_ENGINE_C2, 10, 1, (TPM_MATCH_VID_OUTER | TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE)},
 	};
 
+	cap_arr_out = mvOsMalloc(TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	if (cap_arr_out == NULL) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		return;
+	}
+	memset(cap_arr_out, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+
 	cap_num = sizeof(cap_arr_in) / sizeof(struct tpm_db_mng_flow_cap_conf_t);
 	tpm_ret = tpm_mng_cap_merge_flow(cap_num, cap_arr_in, cap_arr_out);
 	if (tpm_ret != TPM_OK) {
 		TPM_OS_ERROR(TPM_MNG_MOD, "tpm_mng_cap_merge_auto_test failed\n");
+		mvOsFree(cap_arr_out);
 		return;
 	}
 
@@ -8093,10 +8261,12 @@ void tpm_mng_cap_merge_auto_test(void)
 		for (loop = 0; loop < cap_num; loop++)
 			TPM_MNG_FLOW_CAP_PRINT(&(cap_arr_out_right[loop]));
 
+		mvOsFree(cap_arr_out);
 		return;
 	}
 
 	printk(KERN_INFO "auto test for cap merge feature is done successfully!\n");
+	mvOsFree(cap_arr_out);
 	return;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
index e011e2f..28ecbda 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
@@ -146,50 +146,56 @@ static int tpm_c2_data_entry_db_add(struct tpm_c2_add_entry_t *c2_entry,
 				    unsigned int *c2_db_idx)
 {
 	int ret_code;
-	struct tpm_c2_data_t c2_entry_db;
+	struct tpm_c2_data_t *c2_entry_db;	/*use heap to reduce stack size*/
 	unsigned int index;
 
 	IF_NULL(TPM_C2_MOD, c2_entry);
 	IF_NULL(TPM_C2_MOD, c2_db_idx);
 
+	c2_entry_db = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_db);
+	memset(c2_entry_db, 0, sizeof(struct tpm_c2_data_t));
+
 	/* Get available db entry for c2 entry */
 	for (index = 0; index < TPM_C2_ENTRY_MAX; index++) {
-		ret_code = tpm_db_c2_data_get(index, &c2_entry_db);
-		IF_ERROR(TPM_C2_MOD, ret_code);
-		if (c2_entry_db.valid == TPM_C2_ENTRY_INVALID)
+		ret_code = tpm_db_c2_data_get(index, c2_entry_db);
+		IF_ERROR_FREE(TPM_C2_MOD, ret_code, c2_entry_db);
+		if (c2_entry_db->valid == TPM_C2_ENTRY_INVALID)
 			break;
 	}
 	if (index == TPM_C2_ENTRY_MAX) {
-		TPM_OS_ERROR(TPM_C2_MOD, "No free space in DB\n");
+		TPM_OS_ERROR(TPM_C2_MOD, "No free space in DB for C2 entry\n");
+		mvOsFree(c2_entry_db);
 		return TPM_NO_RESOURCE;
 	}
 
 	/* record c2 entry to DB */
-	memcpy(&c2_entry_db.port, &c2_entry->port, sizeof(struct tpm_src_port_t));
-	c2_entry_db.lkp_type = c2_entry->lkp_type;
-	c2_entry_db.lkp_type_mask = c2_entry->lkp_type_mask;
-	c2_entry_db.priority = c2_entry->priority;
-	c2_entry_db.field_bm = c2_entry->field_bm;
+	memcpy(&c2_entry_db->port, &c2_entry->port, sizeof(struct tpm_src_port_t));
+	c2_entry_db->lkp_type = c2_entry->lkp_type;
+	c2_entry_db->lkp_type_mask = c2_entry->lkp_type_mask;
+	c2_entry_db->priority = c2_entry->priority;
+	c2_entry_db->field_bm = c2_entry->field_bm;
 	/* pkt Key */
-	c2_entry_db.mng_pkt_key.ttl = c2_entry->mng_pkt_key->ttl;
-	c2_entry_db.mng_pkt_key.tcp_flag = c2_entry->mng_pkt_key->tcp_flag;
-	c2_entry_db.mng_pkt_key.tcp_flag_mask = c2_entry->mng_pkt_key->tcp_flag_mask;
-	memcpy(&c2_entry_db.mng_pkt_key.pkt_key, c2_entry->mng_pkt_key->pkt_key, sizeof(struct tpm_pkt_key_t));
+	c2_entry_db->mng_pkt_key.ttl = c2_entry->mng_pkt_key->ttl;
+	c2_entry_db->mng_pkt_key.tcp_flag = c2_entry->mng_pkt_key->tcp_flag;
+	c2_entry_db->mng_pkt_key.tcp_flag_mask = c2_entry->mng_pkt_key->tcp_flag_mask;
+	memcpy(&c2_entry_db->mng_pkt_key.pkt_key, c2_entry->mng_pkt_key->pkt_key, sizeof(struct tpm_pkt_key_t));
 	/* Qos */
-	memcpy(&c2_entry_db.qos_info, &c2_entry->qos_info, sizeof(struct tpm_engine_qos_info_t));
-	memcpy(&c2_entry_db.action, &c2_entry->action, sizeof(struct tpm_engine_pkt_action_t));
-	memcpy(&c2_entry_db.qos_value, &c2_entry->qos_value, sizeof(struct tpm_qos_value_t));
-	memcpy(&c2_entry_db.pkt_mod, &c2_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
-	memcpy(&c2_entry_db.flow_info, &c2_entry->flow_info, sizeof(struct tpm_duplicate_t));
-	c2_entry_db.valid = TPM_C2_ENTRY_VALID;
+	memcpy(&c2_entry_db->qos_info, &c2_entry->qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&c2_entry_db->action, &c2_entry->action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&c2_entry_db->qos_value, &c2_entry->qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&c2_entry_db->pkt_mod, &c2_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&c2_entry_db->flow_info, &c2_entry->flow_info, sizeof(struct tpm_duplicate_t));
+	c2_entry_db->valid = TPM_C2_ENTRY_VALID;
 
 	/* Write to db */
-	ret_code = tpm_db_c2_data_set(index, &c2_entry_db);
-	IF_ERROR(TPM_C2_MOD, ret_code);
+	ret_code = tpm_db_c2_data_set(index, c2_entry_db);
+	IF_ERROR_FREE(TPM_C2_MOD, ret_code, c2_entry_db);
 
 	/* Return db index */
 	*c2_db_idx = index;
 
+	mvOsFree(c2_entry_db);
 	return TPM_OK;
 }
 
@@ -213,12 +219,18 @@ static int tpm_c2_data_entry_db_add(struct tpm_c2_add_entry_t *c2_entry,
 *******************************************************************************/
 static int tpm_c2_data_entry_db_del(unsigned int c2_db_idx)
 {
-	struct tpm_c2_data_t c2_db_data;
+	struct tpm_c2_data_t *c2_db_data;		/*use heap to reduce stack size*/
+
+	c2_db_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_db_data);
+	memset(c2_db_data, 0, sizeof(struct tpm_c2_data_t));
 
-	memset(&c2_db_data, 0, sizeof(struct tpm_c2_data_t));
-	if (tpm_db_c2_data_set(c2_db_idx, &c2_db_data))
+	if (tpm_db_c2_data_set(c2_db_idx, c2_db_data)) {
+		mvOsFree(c2_db_data);
 		return TPM_SET_ERROR;
+	}
 
+	mvOsFree(c2_db_data);
 	return TPM_OK;
 }
 
@@ -247,7 +259,7 @@ static int tpm_c2_lkp_type_list_pri_get(unsigned char lkp_type,
 {
 	struct list_head *lkp_type_list_head;
 	struct tpm_c2_index_t *c2_index_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;		/*use heap to reduce stack size*/
 
 	/* param check */
 	IF_NULL(TPM_C2_MOD, hignest_pri);
@@ -257,7 +269,7 @@ static int tpm_c2_lkp_type_list_pri_get(unsigned char lkp_type,
 	lkp_type_list_head = tpm_db_c2_lkp_type_list_head_get(lkp_type);
 
 	if (list_empty(lkp_type_list_head)) {
-		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list (%d) is empty\n", lkp_type);
+		TPM_OS_ERROR(TPM_C2_MOD, "C2 engine lookup type list (%d) is empty\n", lkp_type);
 		return TPM_BAD_PARAM;
 	}
 
@@ -265,22 +277,32 @@ static int tpm_c2_lkp_type_list_pri_get(unsigned char lkp_type,
 	c2_index_node = list_first_entry(lkp_type_list_head,
 					 struct tpm_c2_index_t,
 					 list_node);
+
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	/* get C2 db entry data */
-	if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+	if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+		mvOsFree(c2_entry_data);
 		return TPM_GET_ERROR;
-	*hignest_pri = c2_entry_data.priority;
-	*lowest_pri = c2_entry_data.priority;
+	}
+	*hignest_pri = c2_entry_data->priority;
+	*lowest_pri = c2_entry_data->priority;
 
 	/* Search the list */
 	list_for_each_entry(c2_index_node, lkp_type_list_head, list_node) {
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if ((*hignest_pri) > c2_entry_data.priority)
-			*hignest_pri = c2_entry_data.priority;
-		if ((*lowest_pri) < c2_entry_data.priority)
-			*lowest_pri = c2_entry_data.priority;
+		}
+		if ((*hignest_pri) > c2_entry_data->priority)
+			*hignest_pri = c2_entry_data->priority;
+		if ((*lowest_pri) < c2_entry_data->priority)
+			*lowest_pri = c2_entry_data->priority;
 	}
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
@@ -314,7 +336,7 @@ static int tpm_c2_lkp_type_list_neighbour_pri_get(unsigned int lkp_type,
 						  unsigned int *pri_next)
 {
 	struct tpm_c2_index_t *c2_index_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;		/*use heap to reduce stack size*/
 	unsigned int pri_temp_h = 0, pri_temp_l = 0;
 
 	/* para check */
@@ -323,7 +345,7 @@ static int tpm_c2_lkp_type_list_neighbour_pri_get(unsigned int lkp_type,
 
 
 	if (priority < highest_pri || priority > lowest_pri) {
-		TPM_OS_ERROR(TPM_C2_MOD, "Invalid internal priority %d\n", priority);
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid C2 internal priority %d\n", priority);
 		return TPM_BAD_PARAM;
 	}
 
@@ -333,24 +355,30 @@ static int tpm_c2_lkp_type_list_neighbour_pri_get(unsigned int lkp_type,
 		return TPM_OK;
 	}
 
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	/* Traverse lookup type list */
 	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
 		/* get C2 db entry data */
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if (priority > c2_entry_data.priority)
-			pri_temp_h = c2_entry_data.priority;
-		if (priority < c2_entry_data.priority && pri_temp_l == 0)
-			pri_temp_l = c2_entry_data.priority;
+		}
+		if (priority > c2_entry_data->priority)
+			pri_temp_h = c2_entry_data->priority;
+		if (priority < c2_entry_data->priority && pri_temp_l == 0)
+			pri_temp_l = c2_entry_data->priority;
 	}
 
 	*pri_prev = pri_temp_h;
 	*pri_next = pri_temp_l;
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
-
 /*******************************************************************************
 * tpm_c2_lkp_type_pri_node_info_get()
 *
@@ -380,7 +408,7 @@ static int tpm_c2_lkp_type_pri_node_info_get(unsigned char lkp_type,
 					     unsigned int *node_count)
 {
 	struct tpm_c2_index_t *c2_index_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;		/*use heap to reduce stack size*/
 	int i;
 
 	/* param check */
@@ -388,13 +416,19 @@ static int tpm_c2_lkp_type_pri_node_info_get(unsigned char lkp_type,
 	IF_NULL(TPM_C2_MOD, c2_hw_last_node);
 	IF_NULL(TPM_C2_MOD, node_count);
 
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	i = 0;
 	/* Traverse lookup type list */
 	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
 		/* get C2 db entry data */
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if (c2_entry_data.priority == priority) {
+		}
+		if (c2_entry_data->priority == priority) {
 			if (i == 0) {
 				*c2_hw_first_node = c2_index_node;
 				*c2_hw_last_node = c2_index_node;
@@ -417,6 +451,7 @@ static int tpm_c2_lkp_type_pri_node_info_get(unsigned char lkp_type,
 	}
 	*node_count = i;
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
@@ -447,7 +482,7 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 					  unsigned int *c2_search_end)
 {
 	struct tpm_c2_index_t *c2_index_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;		/*use heap to reduce stack size*/
 	unsigned int first_pri_find, prev_pri_find;
 	unsigned int next_pri;
 
@@ -455,6 +490,10 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 	IF_NULL(TPM_C2_MOD, c2_search_start);
 	IF_NULL(TPM_C2_MOD, c2_search_end);
 
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	first_pri_find = 0;
 	prev_pri_find = 0;
 	next_pri = 0;
@@ -463,9 +502,11 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 				    tpm_db_c2_lkp_type_list_head_get(lkp_type),
 				    list_node) {
 		/* get C2 db entry data */
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if (c2_entry_data.priority == pri_start) {
+		}
+		if (c2_entry_data->priority == pri_start) {
 			if (first_pri_find == 0) {
 					*c2_search_end = c2_index_node->c2_hw_idx;
 			} else {
@@ -476,9 +517,9 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 			first_pri_find++;
 		}
 		/* Find the next priority */
-		if (first_pri_find != 0 && c2_entry_data.priority != pri_start) {
+		if (first_pri_find != 0 && c2_entry_data->priority != pri_start) {
 			if (prev_pri_find == 0) {
-				next_pri = c2_entry_data.priority;
+				next_pri = c2_entry_data->priority;
 				*c2_search_start = c2_index_node->c2_hw_idx;
 			} else {
 				/* Find the last C2 HW entry in HW table */
@@ -488,7 +529,7 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 			prev_pri_find++;
 		}
 		/* Stop search */
-		if (prev_pri_find != 0 && c2_entry_data.priority != next_pri)
+		if (prev_pri_find != 0 && c2_entry_data->priority != next_pri)
 			break;
 	}
 	/* if no node with pri, return invalid index */
@@ -501,6 +542,7 @@ static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
 			*c2_search_start = TPM_C2_FIRST_ENTRY;
 	}
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
@@ -531,7 +573,7 @@ static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
 					    unsigned int *c2_search_end)
 {
 	struct tpm_c2_index_t *c2_index_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;		/*use heap to reduce stack size*/
 	unsigned int first_pri_find, next_pri_find;
 	unsigned int next_pri;
 
@@ -539,15 +581,21 @@ static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
 	IF_NULL(TPM_C2_MOD, c2_search_start);
 	IF_NULL(TPM_C2_MOD, c2_search_end);
 
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	first_pri_find = 0;
 	next_pri_find = 0;
 	next_pri = 0;
 	/* Traverse lookup type list */
 	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
 		/* get C2 db entry data */
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if (c2_entry_data.priority == pri_start) {
+		}
+		if (c2_entry_data->priority == pri_start) {
 			if (first_pri_find == 0) {
 					*c2_search_start = c2_index_node->c2_hw_idx;
 			} else {
@@ -558,9 +606,9 @@ static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
 			first_pri_find++;
 		}
 		/* Find the next priority */
-		if (first_pri_find != 0 && c2_entry_data.priority > pri_start) {
+		if (first_pri_find != 0 && c2_entry_data->priority > pri_start) {
 			if (next_pri_find == 0) {
-				next_pri = c2_entry_data.priority;
+				next_pri = c2_entry_data->priority;
 				*c2_search_end = c2_index_node->c2_hw_idx;
 			} else {
 				/* Find the first C2 HW entry in HW table */
@@ -570,7 +618,7 @@ static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
 			next_pri_find++;
 		}
 		/* Stop search */
-		if (next_pri_find != 0 && c2_entry_data.priority > next_pri)
+		if (next_pri_find != 0 && c2_entry_data->priority > next_pri)
 			break;
 	}
 	/* if no node with pri, return invalid index */
@@ -583,6 +631,7 @@ static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
 			*c2_search_end = TPM_C2_LAST_ENTRY;
 	}
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
@@ -614,7 +663,7 @@ static int tpm_c2_lkp_type_list_add(unsigned char lkp_type,
 	int ret_code;
 	struct list_head *lkp_type_list_head;
 	struct tpm_c2_index_t *c2_index_node, *temp_node;
-	struct tpm_c2_data_t c2_entry_data;
+	struct tpm_c2_data_t *c2_entry_data;			/*use heap to reduce stack size*/
 	unsigned int highest_pri, lowest_pri;
 	unsigned int index;
 
@@ -666,19 +715,26 @@ static int tpm_c2_lkp_type_list_add(unsigned char lkp_type,
 		return TPM_OK;
 	}
 
+	c2_entry_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_entry_data);
+	memset(c2_entry_data, 0, sizeof(struct tpm_c2_data_t));
+
 	/* New node not the highest and lowest, add it after first node with priority lower than new priority */
 	/* Traverse lookup type list */
 	list_for_each_entry(temp_node, lkp_type_list_head, list_node) {
 		/* get C2 db entry data */
-		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, c2_entry_data)) {
+			mvOsFree(c2_entry_data);
 			return TPM_GET_ERROR;
-		if (c2_entry_data.priority > priority) {
+		}
+		if (c2_entry_data->priority > priority) {
 			list_add_tail(&c2_index_node->list_node, &temp_node->list_node);
 			/* Change Valid status to valid */
 			c2_index_node->valid = TPM_C2_ENTRY_VALID;
 		}
 	}
 
+	mvOsFree(c2_entry_data);
 	return TPM_OK;
 }
 
@@ -816,7 +872,7 @@ static int tpm_c2_make_slot_high(unsigned int lkp_type,
 						     &c2_last_node,
 						     &node_count);
 	if (ret_code) {
-		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list(%d) priority (%d) node info get failed\n",
+		TPM_OS_ERROR(TPM_C2_MOD, "C2 lookup type list(%d) priority (%d) node info get failed\n",
 			     lkp_type, highest_pri);
 		return TPM_GET_ERROR;
 	}
@@ -825,7 +881,7 @@ static int tpm_c2_make_slot_high(unsigned int lkp_type,
 		/* Find the available slot */
 		ret_code = tpm_c2_free_slot_find(TPM_C2_FIRST_ENTRY, c2_first_node->c2_hw_idx, &free_idx);
 		if (ret_code) {
-			TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+			TPM_OS_ERROR(TPM_C2_MOD, "No found free slot between entry(%d) and entry(%d)\n",
 				     TPM_C2_FIRST_ENTRY, c2_first_node->c2_hw_idx);
 			return TPM_GET_ERROR;
 		}
@@ -850,7 +906,7 @@ static int tpm_c2_make_slot_high(unsigned int lkp_type,
 		if (c2_search_start != TPM_C2_ENTRY_INVALID_IDX) {
 			ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
 			if (ret_code) {
-				TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+				TPM_OS_ERROR(TPM_C2_MOD, "No found free slot between (%d) and (%d)\n",
 					     c2_search_start, c2_search_end);
 				return TPM_GET_ERROR;
 			}
@@ -952,7 +1008,7 @@ static int tpm_c2_make_slot_middle(unsigned int lkp_type,
 	/* Find the available before first node */
 	ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
 	if (ret_code) {
-		TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+		TPM_OS_ERROR(TPM_C2_MOD, "No found free slot between (%d) and (%d) on C2 engine\n",
 			     c2_search_start, c2_search_end);
 		return TPM_GET_ERROR;
 	}
@@ -982,7 +1038,7 @@ static int tpm_c2_make_slot_middle(unsigned int lkp_type,
 			} else {
 				ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
 				if (ret_code) {
-					TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+					TPM_OS_ERROR(TPM_C2_MOD, "No found free slot between (%d) and (%d) failed\n",
 						     c2_search_start, c2_search_end);
 					return TPM_GET_ERROR;
 				}
@@ -1025,7 +1081,7 @@ static int tpm_c2_make_slot_middle(unsigned int lkp_type,
 		if (c2_search_start != TPM_C2_ENTRY_INVALID_IDX) {
 			ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
 			if (ret_code) {
-				TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+				TPM_OS_ERROR(TPM_C2_MOD, "No found free slot between (%d) and (%d) failed\n",
 					     c2_search_start, c2_search_end);
 				return TPM_GET_ERROR;
 			}
@@ -1633,7 +1689,7 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 		       unsigned char hek_mask[])
 {
 	int ret_code = TPM_OK;
-	struct tpm_field_match_info field_info[TPM_FLOW_FIELD_COUNT_MAX], field_unmask[TPM_FLOW_FIELD_COUNT_MAX];
+	struct tpm_field_match_info *field_info, *field_unmask;	/*use heap to reduce stack size*/
 	unsigned char c2_hek[TPM_C2_HEK_OFF_MAX];
 	unsigned char c2_hek_mask[TPM_C2_HEK_OFF_MAX];
 	unsigned int field_bytes, field_id, field_size, pkt_value, pkt_value_mask;
@@ -1648,6 +1704,18 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 	IF_NULL(TPM_C2_MOD, hek);
 	IF_NULL(TPM_C2_MOD, hek_mask);
 
+	field_info = mvOsMalloc(TPM_FLOW_FIELD_COUNT_MAX * sizeof(struct tpm_field_match_info));
+	IF_MALLOC_FAIL(TPM_C2_MOD, field_info);
+	memset(field_info, 0, TPM_FLOW_FIELD_COUNT_MAX * sizeof(struct tpm_field_match_info));
+
+	field_unmask = mvOsMalloc(TPM_FLOW_FIELD_COUNT_MAX * sizeof(struct tpm_field_match_info));
+	if (field_unmask == NULL) {
+		TPM_OS_ERROR(TPM_C4_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(field_info);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(field_unmask, 0, TPM_FLOW_FIELD_COUNT_MAX * sizeof(struct tpm_field_match_info));
+
 	/* clear related structure */
 	memset(&field_info[0], 0, sizeof(struct tpm_field_match_info) * TPM_FLOW_FIELD_COUNT_MAX);
 	memset(c2_hek, 0, TPM_C2_HEK_OFF_MAX);
@@ -1658,7 +1726,7 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 					      TPM_FLOW_FIELD_COUNT_MAX,
 					      true,
 					      field_info);
-	IF_ERROR(TPM_C2_MOD, ret_code);
+	IF_ERROR_FREE_2(TPM_C2_MOD, ret_code, field_info, field_unmask);
 
 	/* Get filed need to unmask */
 	ret_code = tpm_field_bm_to_field_info(field_bm &
@@ -1667,7 +1735,7 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 					      TPM_FLOW_FIELD_COUNT_MAX,
 					      true,
 					      field_unmask);
-	IF_ERROR(TPM_C2_MOD, ret_code);
+	IF_ERROR_FREE_2(TPM_C2_MOD, ret_code, field_info, field_unmask);
 
 	/* Set C2 TCAM HEK */
 	field_num = 0;
@@ -1708,10 +1776,12 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 								    c2_hek,
 								    c2_hek_mask,
 								    &c2_hek_bytes_used);
-			IF_ERROR(TPM_C2_MOD, ret_code);
+			IF_ERROR_FREE_2(TPM_C2_MOD, ret_code, field_info, field_unmask);
 			/* Check HEK bytes number */
 			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
 				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				mvOsFree(field_info);
+				mvOsFree(field_unmask);
 				return TPM_BAD_PARAM;
 			}
 			break;
@@ -1768,10 +1838,12 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 								    c2_hek,
 								    c2_hek_mask,
 								    &c2_hek_bytes_used);
-			IF_ERROR(TPM_C2_MOD, ret_code);
+			IF_ERROR_FREE_2(TPM_C2_MOD, ret_code, field_info, field_unmask);
 			/* Check HEK bytes number */
 			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
 				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				mvOsFree(field_info);
+				mvOsFree(field_unmask);
 				return TPM_BAD_PARAM;
 			}
 			break;
@@ -1804,6 +1876,8 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 			/* Check HEK bytes number */
 			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
 				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				mvOsFree(field_info);
+				mvOsFree(field_unmask);
 				return TPM_BAD_PARAM;
 			}
 			break;
@@ -1823,6 +1897,8 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 			/* Check HEK bytes number */
 			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
 				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				mvOsFree(field_info);
+				mvOsFree(field_unmask);
 				return TPM_BAD_PARAM;
 			}
 			break;
@@ -1843,17 +1919,23 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 			/* Check HEK bytes number */
 			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
 				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				mvOsFree(field_info);
+				mvOsFree(field_unmask);
 				return TPM_BAD_PARAM;
 			}
 			break;
 
 		case IPV6_SA_FIELD_ID:
 		case IPV6_DA_FIELD_ID:
-			/* IPv6 SIP and DIP cant fit into C2 SRAM */
+			/* IPv6 SIP and DIP cant not fit into C2 SRAM */
+			mvOsFree(field_info);
+			mvOsFree(field_unmask);
 			return TPM_BAD_PARAM;
 
 		default:
 			TPM_OS_ERROR(TPM_C2_MOD, "Invalid field ID (%d) on C2 engine\n", field_id);
+			mvOsFree(field_info);
+			mvOsFree(field_unmask);
 			return TPM_BAD_PARAM;
 		}
 		/* record previous id */
@@ -1881,6 +1963,8 @@ int tpm_c2_tcam_hek_get(unsigned int field_bm,
 	hek[TPM_C2_HEK_OFF_PORT_ID] = c2_entry->port.port_value;
 	hek_mask[TPM_C2_HEK_OFF_PORT_ID] = c2_entry->port.port_mask;
 
+	mvOsFree(field_info);
+	mvOsFree(field_unmask);
 	return TPM_OK;
 }
 
@@ -2381,7 +2465,7 @@ int tpm_c2_rule_del(unsigned int c2_logic_index)
 int tpm_c2_rule_sram_get(unsigned int logic_index, struct tpm_engine_sram_t *sram)
 {
 	int ret_code;
-	struct tpm_c2_data_t c2_data;
+	struct tpm_c2_data_t *c2_data;		/*use heap to reduce stack size*/
 	unsigned int hw_idx, db_idx;
 
 	IF_NULL(TPM_MNG_MOD, sram);
@@ -2390,19 +2474,24 @@ int tpm_c2_rule_sram_get(unsigned int logic_index, struct tpm_engine_sram_t *sra
 	ret_code = tpm_c2_get_hw_idx_from_logic_idx(logic_index,
 						    &hw_idx,
 						    &db_idx);
-	IF_ERROR_STR(TPM_MNG_MOD, ret_code, "C2 db idx get fail\n");
+	IF_ERROR_STR(TPM_MNG_MOD, ret_code, "C2 DB entry index get fail\n");
+
+	c2_data = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, c2_data);
+	memset(c2_data, 0, sizeof(struct tpm_c2_data_t));
 
 	/* Get DB data */
-	ret_code = tpm_db_c2_data_get(db_idx, &c2_data);
-	IF_ERROR_STR(TPM_MNG_MOD, ret_code, "C2 db get fail\n");
+	ret_code = tpm_db_c2_data_get(db_idx, c2_data);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, ret_code, c2_data, "C2 DB entry get fail\n");
 
 	/* Get SRAM */
-	memcpy(&sram->action, &c2_data.action, sizeof(struct tpm_engine_pkt_action_t));
-	memcpy(&sram->qos_info, &c2_data.qos_info, sizeof(struct tpm_engine_qos_info_t));
-	memcpy(&sram->qos_value, &c2_data.qos_value, sizeof(struct tpm_qos_value_t));
-	memcpy(&sram->pkt_mod, &c2_data.pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
-	memcpy(&sram->dup_info, &c2_data.flow_info, sizeof(struct tpm_duplicate_t));
+	memcpy(&sram->action, &c2_data->action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&sram->qos_info, &c2_data->qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&sram->qos_value, &c2_data->qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&sram->pkt_mod, &c2_data->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&sram->dup_info, &c2_data->flow_info, sizeof(struct tpm_duplicate_t));
 
+	mvOsFree(c2_data);
 	return TPM_OK;
 }
 
@@ -2425,7 +2514,7 @@ int tpm_c2_rule_sram_update(unsigned int logic_index, struct tpm_engine_sram_t *
 {
 	int ret_code;
 	MV_PP2_CLS_C2_ENTRY hw_entry;
-	struct tpm_c2_data_t db_entry;
+	struct tpm_c2_data_t *db_entry;		/*use heap to reduce stack size*/
 	unsigned int hw_idx, db_idx;
 
 	IF_NULL(TPM_C2_MOD, sram);
@@ -2527,19 +2616,24 @@ int tpm_c2_rule_sram_update(unsigned int logic_index, struct tpm_engine_sram_t *
 	ret_code = mvPp2ClsC2HwWrite(hw_idx, &hw_entry);
 	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to call mvPp2ClsC2HwWrite\n");
 
+	db_entry = mvOsMalloc(sizeof(struct tpm_c2_data_t));
+	IF_MALLOC_FAIL(TPM_C2_MOD, db_entry);
+	memset(db_entry, 0, sizeof(struct tpm_c2_data_t));
+
 	/* Update DB */
-	ret_code = tpm_db_c2_data_get(db_idx, &db_entry);
-	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to read DB\n");
+	ret_code = tpm_db_c2_data_get(db_idx, db_entry);
+	IF_ERROR_STR_FREE(TPM_C2_MOD, ret_code, db_entry, "failed to read DB\n");
 
-	memcpy(&db_entry.action, &sram->action, sizeof(struct tpm_engine_pkt_action_t));
-	memcpy(&db_entry.qos_info, &sram->qos_info, sizeof(struct tpm_engine_qos_info_t));
-	memcpy(&db_entry.qos_value, &sram->qos_value, sizeof(struct tpm_qos_value_t));
-	memcpy(&db_entry.pkt_mod, &sram->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
-	memcpy(&db_entry.flow_info, &sram->dup_info, sizeof(struct tpm_duplicate_t));
+	memcpy(&db_entry->action, &sram->action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&db_entry->qos_info, &sram->qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&db_entry->qos_value, &sram->qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&db_entry->pkt_mod, &sram->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&db_entry->flow_info, &sram->dup_info, sizeof(struct tpm_duplicate_t));
 
-	ret_code = tpm_db_c2_data_set(db_idx, &db_entry);
-	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to set DB\n");
+	ret_code = tpm_db_c2_data_set(db_idx, db_entry);
+	IF_ERROR_STR_FREE(TPM_C2_MOD, ret_code, db_entry, "failed to set DB\n");
 
+	mvOsFree(db_entry);
 	return TPM_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
index 65bf081..22458da 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
@@ -224,8 +224,19 @@ int tpm_c4_field_build(
 	struct tpm_c4_field_t *field_0_3 = &c4_field[TPM_C4_FIELD_ID_3];
 	struct tpm_cnm_field_op_t field_op_tmp[TPM_CNM_FIELD_MAX];
 	struct tpm_mng_pkt_key_t mng_pkt_key;
-	struct tpm_field_match_info	field_info[TPM_CNM_FIELD_MAX];
-	struct tpm_field_match_info	field_info_tmp[TPM_CNM_FIELD_MAX];
+	struct tpm_field_match_info	*field_info;		/*use heap to reduce stack size*/
+	struct tpm_field_match_info	*field_info_tmp;	/*use heap to reduce stack size*/
+
+	field_info = mvOsMalloc(TPM_CNM_FIELD_MAX * sizeof(struct tpm_field_match_info));
+	IF_MALLOC_FAIL(TPM_C4_MOD, field_info);
+	memset(field_info, 0, TPM_CNM_FIELD_MAX * sizeof(struct tpm_field_match_info));
+	field_info_tmp = mvOsMalloc(TPM_CNM_FIELD_MAX * sizeof(struct tpm_field_match_info));
+	if (field_info_tmp == NULL) {
+		TPM_OS_ERROR(TPM_C4_MOD, "%s(%d) Error allocating memory!\n", __func__, __LINE__);
+		mvOsFree(field_info);
+		return TPM_OUT_OF_CPU_MEM;
+	}
+	memset(field_info_tmp, 0, TPM_CNM_FIELD_MAX * sizeof(struct tpm_field_match_info));
 
 	memset(c4_field, 0, (sizeof(struct tpm_c4_field_t) * TPM_CNM_FIELD_MAX));
 	/* set all c4_field to be invalid */
@@ -242,8 +253,8 @@ int tpm_c4_field_build(
 	for (loop = 0; loop < field_num; loop++) {
 		ret = tpm_field_bm_to_field_info(field_op_tmp[loop].field, &mng_pkt_key,
 			1, false, &field_info_tmp[loop]);
-		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get field_info field_id(0x%x)\n",
-			field_op[loop].field);
+		IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
+			"fail to get field_info field_id(0x%x)\n", field_op[loop].field);
 		field_op_tmp[loop].field = field_info_tmp[loop].field_id;
 	}
 
@@ -263,13 +274,12 @@ int tpm_c4_field_build(
 	}
 
 	for (loop = field_num - 1; loop >= 0; loop--) {
-
 		ret = tpm_c4_pkt_field_len_get(field_op_tmp[loop].field, &len);
-		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of field_id(0x%x)\n",
-			field_op_tmp[loop].field);
+		IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
+			"fail to get size of field_id(0x%x)\n", field_op_tmp[loop].field);
 
 		if (len > TPM_C4_FIELD4_SIZE) {
-			TPM_OS_ERROR(TPM_C4_MOD, "field_len(%d) should not be bigger than (%d), field_id(0x%x)\n",
+			TPM_OS_ERROR(TPM_C4_MOD, "field_len(%d) can not be greater than (%d), field_id(0x%x)\n",
 				len, TPM_C4_FIELD4_SIZE, field_op_tmp[loop].field);
 			return TPM_BAD_PARAM;
 		} else if (len > TPM_C4_FIELD5_SIZE) {
@@ -278,8 +288,9 @@ int tpm_c4_field_build(
 				&field_op_tmp[loop],
 				&field_info[loop],
 				&c4_field[TPM_C4_FIELD_ID_4]);
-			IF_ERROR_STR(TPM_C4_MOD, ret,
-			"CnM key comb invalid, refer to the help.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
+
+			IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
+			"CnM key comb invalid, refer to the help. Invalid op(%d), field_len(%d), field_id(0x%x)\n",
 			field_op_tmp[loop].op, len, field_op_tmp[loop].field);
 		} else if (len > TPM_C4_FIELD0_3_SIZE) {
 			/* try to put it in field 5 first */
@@ -293,7 +304,7 @@ int tpm_c4_field_build(
 					&field_op_tmp[loop],
 					&field_info[loop],
 					&c4_field[TPM_C4_FIELD_ID_4]);
-				IF_ERROR_STR(TPM_C4_MOD, ret,
+				IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
 						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
 						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
 			}
@@ -304,7 +315,7 @@ int tpm_c4_field_build(
 							  &field_op_tmp[loop],
 							  &field_info[loop],
 							  field_0_3);
-				IF_ERROR_STR(TPM_C4_MOD, ret,
+				IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
 						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
 						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
 				if (field_0_3 != &c4_field[TPM_C4_FIELD_ID_0])
@@ -322,7 +333,7 @@ int tpm_c4_field_build(
 					ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
 						&field_op_tmp[loop], &field_info[loop],
 						&c4_field[TPM_C4_FIELD_ID_4]);
-					IF_ERROR_STR(TPM_C4_MOD, ret,
+					IF_ERROR_STR_FREE_2(TPM_C4_MOD, ret, field_info, field_info_tmp,
 						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
 						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
 				}
@@ -330,6 +341,8 @@ int tpm_c4_field_build(
 		}
 	}
 
+	mvOsFree(field_info);
+	mvOsFree(field_info_tmp);
 	return TPM_OK;
 }
 
@@ -419,7 +432,7 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 	unsigned int loop_in_max;
 	unsigned short short_value;
 	unsigned int int_value;
-	struct tpm_c4_field_t c4_field[TPM_CNM_FIELD_MAX];
+	struct tpm_c4_field_t *c4_field;	/*use heap to reduce stack size*/
 
 	IF_NULL(TPM_C4_MOD, c4_entry);
 	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, c4_entry->rule_num,
@@ -427,6 +440,10 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, c4_entry->ruleSet,
 		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet\n");
 
+	c4_field = mvOsMalloc(TPM_CNM_FIELD_MAX * sizeof(struct tpm_c4_field_t));
+	IF_MALLOC_FAIL(TPM_C4_MOD, c4_field);
+	memset(c4_field, 0, TPM_CNM_FIELD_MAX * sizeof(struct tpm_c4_field_t));
+
 	/* clear hw entry */
 	mvPp2ClsC4SwClear(&c4_hw_entry);
 
@@ -436,46 +453,46 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 
 	/* set vlan_num */
 	ret = mvPp2ClsC4SwVlanSet(&c4_hw_entry, c4_entry->vlan_num);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set vlan number(%d)\n", c4_entry->vlan_num);
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to set vlan number(%d)\n", c4_entry->vlan_num);
 
 	/* set pppoe */
 	ret = mvPp2ClsC4SwPppoeSet(&c4_hw_entry, c4_entry->pppoe);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set pppoe(%d)\n", c4_entry->pppoe);
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to set pppoe(%d)\n", c4_entry->pppoe);
 
 	/* set mac_to_me */
 	ret = mvPp2ClsC4SwMacMeSet(&c4_hw_entry, c4_entry->mac_to_me);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set mac_to_me(%d)\n", c4_entry->mac_to_me);
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to set mac_to_me(%d)\n", c4_entry->mac_to_me);
 
 	/* set l3_info */
 	ret = mvPp2ClsC4SwL3InfoSet(&c4_hw_entry, c4_entry->l3_info);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set l3_info(%d)\n", c4_entry->l3_info);
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to set l3_info(%d)\n", c4_entry->l3_info);
 
 	/* set l4_info */
 	ret = mvPp2ClsC4SwL4InfoSet(&c4_hw_entry, c4_entry->l4_info);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set l4_info(%d)\n", c4_entry->l4_info);
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to set l4_info(%d)\n", c4_entry->l4_info);
 
 	/* build C4 key */
 	ret = tpm_c4_field_build(c4_entry->field_num, &c4_entry->pkt_key, c4_entry->field_op, c4_field);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to build c4_field\n");
+	IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to build c4_field\n");
 
 	for (loop = 0; loop < TPM_CNM_FIELD_MAX; loop++) {
 
 		/* set field_id and op */
 		ret = mvPp2ClsC4FieldsParamsSet(&c4_hw_entry, loop,
 			c4_field[loop].field_info.field_id, c4_field[loop].op);
-		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param\n");
+		IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,  "fail to set c4 field param\n");
 
 		if (c4_field[loop].op == TPM_C4_OP_ALWAYS_TRUE)
 			continue;
 
 		/* get pkt field length */
 		ret = tpm_c4_pkt_field_len_get(c4_field[loop].field_info.field_id, &len);
-		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of field_id(0x%x)\n",
+		IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to get size of field_id(0x%x)\n",
 			c4_field[loop].field_info.field_id);
 
 		/* get eng field length */
 		ret = tpm_c4_eng_field_len_get(loop, &eng_field_len);
-		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of eng field(0x%x)\n", loop);
+		IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field, "fail to get size of eng field(0x%x)\n", loop);
 
 		/* set field data value */
 		loop_in_max = (len / 2);
@@ -497,22 +514,26 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 				c4_field[loop].field_info.filed_value.ipv6_addr.parsed_ipv6_addr[(loop_in * 2) + 1];
 				ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop,
 					((eng_field_len - 2) - (loop_in * 2)), short_value);
-				IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+				IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,
+					"fail to set c4 field param, field_id(%d)\n", loop);
 			}
 		} else if (len == 3) {
 			/* IPv6 flow lable */
 			int_value = (unsigned int)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
 			short_value = (int_value & 0xffff);
 			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, (eng_field_len - 2), short_value);
-			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,
+				"fail to set c4 field param, field_id(%d)\n", loop);
 			short_value = (int_value >> SHORT_BITS);
 			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, (eng_field_len - 1), short_value);
-			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,
+				"fail to set c4 field param, field_id(%d)\n", loop);
 
 		} else if (len == 2) {
 			short_value = (unsigned short)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
 			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, 0, short_value);
-			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,
+				"fail to set c4 field param, field_id(%d)\n", loop);
 
 		} else if (len == 1) {
 			short_value = (unsigned char)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
@@ -534,11 +555,14 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 				short_value >>= TPM_C4_IP_VER_OFFSET;
 			}
 			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, 0, short_value);
-			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			IF_ERROR_STR_FREE(TPM_C4_MOD, ret, c4_field,
+				"fail to set c4 field param, field_id(%d)\n", loop);
 
 		}
 	}
 
+	mvOsFree(c4_field);
+
 	/* set dscp */
 	ret = mvPp2ClsC4DscpSet(&c4_hw_entry, c4_entry->action.dscp_act, c4_entry->qos_value.dscp);
 	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set dscp cmd(%d) and value(%d)\n",
@@ -551,7 +575,7 @@ int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
 
 	/* set Pri */
 	ret = mvPp2ClsC4PrioSet(&c4_hw_entry, c4_entry->action.pri_act, c4_entry->qos_value.pri);
-	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set pri cmd(%d) and value(%d)\n",
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set priority cmd(%d) and value(%d)\n",
 		c4_entry->action.pri_act, c4_entry->qos_value.pri);
 
 	/* set gpid */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
index b0536d2..29a307a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
@@ -186,7 +186,7 @@ static int tpm_cls_lkp_dcod_hw_set(struct tpm_cls_fl_t	*fl)
 	int					rc;
 	unsigned short				luid, rl = 0;
 	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
-	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_db_cls_fl_rule_list_t	*fl_rl_db;	/*use heap to reduce stack size*/
 	unsigned short				rl_off;
 
 	IF_NULL(TPM_CLS_MOD, fl)
@@ -201,8 +201,12 @@ static int tpm_cls_lkp_dcod_hw_set(struct tpm_cls_fl_t	*fl)
 	}
 
 	/* get the rule list for this logical flow ID */
-	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
-	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+	fl_rl_db = mvOsMalloc(sizeof(struct tpm_db_cls_fl_rule_list_t));
+	IF_MALLOC_FAIL(TPM_CLS_MOD, fl_rl_db);
+	memset(fl_rl_db, 0, sizeof(struct tpm_db_cls_fl_rule_list_t));
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db->flow[0]);
+	IF_ERROR_STR_FREE(TPM_CLS_MOD, rc, fl_rl_db,
+				"failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
 				fl->fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
 
 	/* iterate over all LUIDs */
@@ -212,37 +216,37 @@ static int tpm_cls_lkp_dcod_hw_set(struct tpm_cls_fl_t	*fl)
 			continue;
 
 		/* found the rule, get it`s offset */
-		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db.flow[rl].rl_log_id);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db->flow[rl].rl_log_id);
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		/* updated the HW */
 		mvPp2ClsSwLkpClear(&fe);
 
 		rc = mvPp2ClsSwLkpFlowSet(&fe, rl_off);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsSwLkpRxqSet(&fe, lkp_dcod_db.cpu_q);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsSwLkpEnSet(&fe, lkp_dcod_db.enabled);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsHwLkpWrite(lkp_dcod_db.luid_list[luid].luid, lkp_dcod_db.way, &fe);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		TPM_OS_DEBUG(TPM_CLS_MOD,
 				"fl_log_id[%2d] lid_nr[%2d] rl_log_id[%3d] prio[%2d] rl_off[%3d] luid[%2d] way[%d]\n",
-				fl->fl_log_id, luid, fl_rl_db.flow[rl].rl_log_id,
-				fl_rl_db.flow[rl].prio,
+				fl->fl_log_id, luid, fl_rl_db->flow[rl].rl_log_id,
+				fl_rl_db->flow[rl].prio,
 				rl_off,
 				lkp_dcod_db.luid_list[luid].luid,
 				lkp_dcod_db.way);
 	}
 
+	mvOsFree(fl_rl_db);
 	return TPM_OK;
 }
 
-
 /*******************************************************************************
 * tpm_cls_lkp_dcod_hw_clear_all
 *
@@ -304,7 +308,7 @@ int tpm_cls_lkp_dcod_enable(unsigned short	fl_log_id)
 	int					rc;
 	unsigned short				luid, rl = 0;
 	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
-	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_db_cls_fl_rule_list_t	*fl_rl_db;	/*use heap to reduce stack size*/
 	unsigned short				rl_off;
 
 	/* get the lookup DB for this logical flow ID */
@@ -324,11 +328,15 @@ int tpm_cls_lkp_dcod_enable(unsigned short	fl_log_id)
 	}
 
 	/* get the rule list for this logical flow ID */
-	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
-	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
-				fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+	fl_rl_db = mvOsMalloc(sizeof(struct tpm_db_cls_fl_rule_list_t));
+	IF_MALLOC_FAIL(TPM_CLS_MOD, fl_rl_db);
+	memset(fl_rl_db, 0, sizeof(struct tpm_db_cls_fl_rule_list_t));
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db->flow[0]);
+	IF_ERROR_STR_FREE(TPM_CLS_MOD, rc, fl_rl_db,
+		"failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+		fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
 
-	fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+	fl_rl_db->flow_len = lkp_dcod_db.flow_len;
 
 	/* iterate over all LUIDs */
 	for (luid = 0; luid < lkp_dcod_db.luid_num; luid++) {
@@ -337,28 +345,28 @@ int tpm_cls_lkp_dcod_enable(unsigned short	fl_log_id)
 			continue;
 
 		/* found the rule, get it`s offset */
-		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db.flow[rl].rl_log_id);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db->flow[rl].rl_log_id);
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		/* updated the HW */
 		mvPp2ClsSwLkpClear(&fe);
 
 		rc = mvPp2ClsSwLkpFlowSet(&fe, rl_off);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsSwLkpRxqSet(&fe, lkp_dcod_db.cpu_q);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsSwLkpEnSet(&fe, 1);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		rc = mvPp2ClsHwLkpWrite(lkp_dcod_db.luid_list[luid].luid, lkp_dcod_db.way, &fe);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
 		TPM_OS_DEBUG(TPM_CLS_MOD,
 				"fl_log_id[%2d] luid_nr[%2d] rl_log_id[%3d] prio[%2d] rl_off[%3d] luid[%2d] way[%d]\n",
-				fl_log_id, luid, fl_rl_db.flow[rl].rl_log_id,
-				fl_rl_db.flow[rl].prio,
+				fl_log_id, luid, fl_rl_db->flow[rl].rl_log_id,
+				fl_rl_db->flow[rl].prio,
 				rl_off,
 				lkp_dcod_db.luid_list[luid].luid,
 				lkp_dcod_db.way);
@@ -367,8 +375,9 @@ int tpm_cls_lkp_dcod_enable(unsigned short	fl_log_id)
 	/* update lkp_dcod DB */
 	lkp_dcod_db.enabled = true;
 	rc = tpm_db_cls_lkp_dcod_set(fl_log_id, &lkp_dcod_db);
-	IF_ERROR(TPM_CLS_MOD, rc)
+	IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 
+	mvOsFree(fl_rl_db);
 	return TPM_OK;
 }
 
@@ -1432,7 +1441,7 @@ static int tpm_cls_fl_rls_set(struct tpm_cls_fl_t	*fl_rls)
 static int tpm_cls_fl_cur_get(unsigned short		fl_log_id,
 				struct tpm_cls_fl_t	*cur_fl)
 {
-	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_db_cls_fl_rule_list_t	*fl_rl_db;	/*use heap to reduce stack size*/
 	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
 	int					rc;
 	unsigned short				i;
@@ -1448,51 +1457,57 @@ static int tpm_cls_fl_cur_get(unsigned short		fl_log_id,
 #endif
 
 	memset(cur_fl, 0, sizeof(struct tpm_cls_fl_t));
-	memset(&fl_rl_db, 0, sizeof(fl_rl_db));
+	fl_rl_db = mvOsMalloc(sizeof(struct tpm_db_cls_fl_rule_list_t));
+	IF_MALLOC_FAIL(TPM_CLS_MOD, fl_rl_db);
+	memset(fl_rl_db, 0, sizeof(struct tpm_db_cls_fl_rule_list_t));
 
 	/* update DB flow length */
-	fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+	fl_rl_db->flow_len = lkp_dcod_db.flow_len;
 	cur_fl->fl_log_id = fl_log_id;
 
-	if (lkp_dcod_db.flow_len == 0)
+	if (lkp_dcod_db.flow_len == 0) {
+		mvOsFree(fl_rl_db);
 		return TPM_OK;
+	}
 
-	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
-	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
-				fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db->flow[0]);
+	IF_ERROR_STR_FREE(TPM_CLS_MOD, rc, fl_rl_db,
+		"Fail to get flow rule list DB data, fl_log_id=%d, flow_off=%d, flow_len=%d",
+		fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
 
 	/* set the current flow additional configurations */
-	cur_fl->fl_len = fl_rl_db.flow_len;
+	cur_fl->fl_len = fl_rl_db->flow_len;
 
-	for (i = 0; i < fl_rl_db.flow_len; i++) {
-		cur_fl->fl[i].enabled	= fl_rl_db.flow[i].enabled;
-		cur_fl->fl[i].engine	= fl_rl_db.flow[i].engine;
-		cur_fl->fl[i].field_id_cnt = fl_rl_db.flow[i].field_id_cnt;
+	for (i = 0; i < fl_rl_db->flow_len; i++) {
+		cur_fl->fl[i].enabled	= fl_rl_db->flow[i].enabled;
+		cur_fl->fl[i].engine	= fl_rl_db->flow[i].engine;
+		cur_fl->fl[i].field_id_cnt = fl_rl_db->flow[i].field_id_cnt;
 
 		memcpy(cur_fl->fl[i].field_id,
-			fl_rl_db.flow[i].field_id,
+			fl_rl_db->flow[i].field_id,
 			sizeof(cur_fl->fl[i].field_id));
 
 		cur_fl->fl[i].rl_off	= lkp_dcod_db.flow_off + i;
-		cur_fl->fl[i].lu_type	= fl_rl_db.flow[i].lu_type;
-		cur_fl->fl[i].port_bm	= fl_rl_db.flow[i].port_bm;
-		cur_fl->fl[i].port_type = fl_rl_db.flow[i].port_type;
-		cur_fl->fl[i].prio	= fl_rl_db.flow[i].prio;
+		cur_fl->fl[i].lu_type	= fl_rl_db->flow[i].lu_type;
+		cur_fl->fl[i].port_bm	= fl_rl_db->flow[i].port_bm;
+		cur_fl->fl[i].port_type = fl_rl_db->flow[i].port_type;
+		cur_fl->fl[i].prio	= fl_rl_db->flow[i].prio;
 #ifndef CONFIG_MV_ETH_PP2_1
-		cur_fl->fl[i].ref_cnt	= fl_rl_db.flow[i].ref_cnt;
+		cur_fl->fl[i].ref_cnt	= fl_rl_db->flow[i].ref_cnt;
 #else
 		memcpy(&cur_fl->fl[i].ref_cnt[0],
-			&fl_rl_db.flow[i].ref_cnt[0],
+			&fl_rl_db->flow[i].ref_cnt[0],
 			TPM_MAX_NUM_GMACS * sizeof(unsigned short));
 #endif
-		cur_fl->fl[i].rl_log_id = fl_rl_db.flow[i].rl_log_id;
+		cur_fl->fl[i].rl_log_id = fl_rl_db->flow[i].rl_log_id;
 		cur_fl->fl[i].state	= TPM_MRG_NOT_NEW;
 		cur_fl->fl[i].skip	= 0;
 
-		rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC, fl_rl_db.flow[i].engine, &cur_fl->eng_cnt);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC, fl_rl_db->flow[i].engine, &cur_fl->eng_cnt);
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 	}
 
+	mvOsFree(fl_rl_db);
 	return TPM_OK;
 }
 
@@ -1780,7 +1795,7 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 {
 	unsigned short				rl_off, i;
 	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
-	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_db_cls_fl_rule_list_t	*fl_rl_db;	/*use heap to reduce stack size*/
 	struct tpm_cls_fl_rule_entry_t		*rl_en;
 	struct tpm_db_cls_fl_rule_t		*rl_db = NULL;
 	int					rc;
@@ -1789,27 +1804,31 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 
 	IF_NULL(TPM_CLS_MOD, fl_rls)
 
+	fl_rl_db = mvOsMalloc(sizeof(struct tpm_db_cls_fl_rule_list_t));
+	IF_MALLOC_FAIL(TPM_CLS_MOD, fl_rl_db);
+
 	/* iterate over all rule list */
 	for (i = 0; i < fl_rls->fl_len; i++) {
 		/* get the lookup DB for this logical flow ID */
 		rc = tpm_db_cls_lkp_dcod_get(fl_rls->fl[i].fl_log_id, &lkp_dcod_db);
-		IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d",
+		IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode DB data for fl_log_id %d",
 				fl_rls->fl[i].fl_log_id)
 
 		/* get all rules for this logical flow ID */
-		rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
-		IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+		memset(fl_rl_db, 0, sizeof(struct tpm_db_cls_fl_rule_list_t));
+		rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db->flow[0]);
+		IF_ERROR_STR_FREE(TPM_CLS_MOD, rc, fl_rl_db,
+				"failed to get flow rule list, fl_log_id=%d flow_off=%d flow_len=%d",
 				fl_rls->fl[i].fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
 
 		/* set the flow length in the DB entry */
-		fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+		fl_rl_db->flow_len = lkp_dcod_db.flow_len;
 
 		rl_en = &fl_rls->fl[i];
 
 		/* search for enabled rule (valid port_type and port_bm) to enable */
-		for (rl_off = 0; rl_off < fl_rl_db.flow_len; rl_off++) {
-			rl_db = &fl_rl_db.flow[rl_off];
-
+		for (rl_off = 0; rl_off < fl_rl_db->flow_len; rl_off++) {
+			rl_db = &fl_rl_db->flow[rl_off];
 			if (rl_en->engine		== rl_db->engine	&&
 				rl_en->field_id_cnt	== rl_db->field_id_cnt  &&
 				rl_en->lu_type		== rl_db->lu_type	&&
@@ -1832,7 +1851,7 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 						/* Update Port BM */
 						rl_en->rl_log_id = rl_db->rl_log_id;
 						rc = tpm_cls_fl_rl_hw_ena(rl_en);
-						IF_ERROR(TPM_CLS_MOD, rc)
+						IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 					}
 					break;
 				}
@@ -1840,11 +1859,11 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 			}
 		}
 
-		if (rl_off == fl_rl_db.flow_len) {
+		if (rl_off == fl_rl_db->flow_len) {
 			/* did not find identical rule, search for first rule with
 			   invalid port_type and port_bm				*/
-			for (rl_off = 0; rl_off < fl_rl_db.flow_len; rl_off++) {
-				rl_db = &fl_rl_db.flow[rl_off];
+			for (rl_off = 0; rl_off < fl_rl_db->flow_len; rl_off++) {
+				rl_db = &fl_rl_db->flow[rl_off];
 				if (rl_en->engine	== rl_db->engine	&&
 				    rl_en->field_id_cnt == rl_db->field_id_cnt	&&
 				    rl_en->lu_type	== rl_db->lu_type	&&
@@ -1863,7 +1882,7 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 		}
 
 		/* verify that we found a rule */
-		if (rl_off == fl_rl_db.flow_len) {
+		if (rl_off == fl_rl_db->flow_len) {
 			TPM_OS_ERROR(TPM_CLS_MOD, "failed to find flow rule #%d to enable\n", i);
 			TPM_OS_ERROR(TPM_CLS_MOD, "fl_id(%d),port_type(%d),port_bm(%d),",
 				fl_rls->fl[i].fl_log_id, fl_rls->fl[i].port_type, fl_rls->fl[i].port_bm);
@@ -1873,6 +1892,7 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 			TPM_OS_ERROR(TPM_CLS_MOD, "field_id_0(%x), field_id_1(%x),field_id_2(%x),field_id_3(%x)\n",
 				fl_rls->fl[i].field_id[0], fl_rls->fl[i].field_id[1], fl_rls->fl[i].field_id[2],
 				fl_rls->fl[i].field_id[3]);
+			mvOsFree(fl_rl_db);
 			return TPM_FAIL;
 		}
 
@@ -1890,7 +1910,7 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 
 			/* rule disabled, enable the HW */
 			rc = tpm_cls_fl_rl_hw_ena(rl_en);
-			IF_ERROR(TPM_CLS_MOD, rc)
+			IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 		}
 
 		/* increment the reference counter */
@@ -1912,10 +1932,11 @@ int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
 
 		/* update the DB */
 		rc = tpm_db_cls_fl_rule_set(lkp_dcod_db.flow_off + rl_off, rl_db);
-		IF_ERROR(TPM_CLS_MOD, rc)
+		IF_ERROR_FREE(TPM_CLS_MOD, rc, fl_rl_db)
 	}
 
-	 return TPM_OK;
+	mvOsFree(fl_rl_db);
+	return TPM_OK;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
index 4a15e36..f3132f9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
@@ -557,8 +557,8 @@ static int tpm_mc_dup_list_node_del(unsigned int mc_log_idx,
 		}
 	}
 	if (found == false) {
-		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the dup list\n", hw_idx);
-		return TPM_NOT_FOUND;
+		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the duplication list\n", hw_idx);
+		return TPM_NO_SUCH;
 	}
 	/* Get DB data */
 	ret_code = tpm_db_mc_data_get(mct_index_node->mct_hw_idx, &mct_entry_db);
@@ -839,8 +839,8 @@ static int tpm_mc_dup_list_node_keep(unsigned int flow_id,
 		}
 	}
 	if (found == false) {
-		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the dup list\n", hw_idx);
-		return TPM_NOT_FOUND;
+		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the duplication list\n", hw_idx);
+		return TPM_NO_SUCH;
 	}
 
 	/* Get DB data */
@@ -1116,7 +1116,7 @@ int tpm_mc_dup_list_update(unsigned int rule_index,
 	int ret_code;
 	unsigned int tpm_flow_id = 0;
 	struct list_head *dup_list_head;
-	struct tpm_mc_update_t mct_update;
+	struct tpm_mc_update_t *mct_update;	/*use heap to reduce stack size*/
 	unsigned int old_cnt = 0;
 	int i;
 
@@ -1157,18 +1157,22 @@ int tpm_mc_dup_list_update(unsigned int rule_index,
 		}
 	}
 
+	mct_update = mvOsMalloc(sizeof(struct tpm_mc_update_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, mct_update);
+	memset(mct_update, 0, sizeof(struct tpm_mc_update_t));
+
 	/* Get full update info */
 	ret_code = tpm_mc_update_info_get(flow_id,
 					  new_dup_cnt,
 					  new_mct_entry,
-					  &mct_update);
-	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT update info get fail\n");
+					  mct_update);
+	IF_ERROR_STR_FREE(TPM_MC_MOD, ret_code, mct_update, "MCT update info get fail\n");
 	/* Debug Info */
 	if ((TPM_MC_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) {
 		for (i = 0; i < TPM_MC_DUP_MAX; i++) {
-			if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID) {
+			if (mct_update->info[i].valid == TPM_MC_UPDATE_VALID) {
 				TPM_OS_DEBUG(TPM_MC_MOD, "update state %d, old_hw_idx %d\n",
-						mct_update.info[i].state, mct_update.info[i].old_hw_idx);
+						mct_update->info[i].state, mct_update->info[i].old_hw_idx);
 			}
 		}
 	}
@@ -1178,47 +1182,48 @@ int tpm_mc_dup_list_update(unsigned int rule_index,
 	/* Handle dup list update */
 	for (i = 0; i < TPM_MC_DUP_MAX; i++) {
 		/* Handle existed node keep, maybe need to update dest UNI bitmap */
-		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
-		    mct_update.info[i].state == TPM_MC_ENTRY_KEEP) {
+		if (mct_update->info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update->info[i].state == TPM_MC_ENTRY_KEEP) {
 			ret_code = tpm_mc_dup_list_node_keep(tpm_flow_id,
-							     mct_update.info[i].old_hw_idx,
-							     &mct_update.info[i].new_entry,
+							     mct_update->info[i].old_hw_idx,
+							     &mct_update->info[i].new_entry,
 							     dest_bm_set);
-			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT keep handle fail\n");
+			IF_ERROR_STR_FREE(TPM_MC_MOD, ret_code, mct_update, "MCT keep handle fail\n");
 		}
 
 		/* Handle existed node update */
-		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
-		    mct_update.info[i].state == TPM_MC_ENTRY_UPDATE) {
+		if (mct_update->info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update->info[i].state == TPM_MC_ENTRY_UPDATE) {
 			ret_code = tpm_mc_dup_list_node_update(rule_index,
 							       &tpm_flow_id,
-							       mct_update.info[i].old_hw_idx,
-							       &mct_update.info[i].new_entry,
+							       mct_update->info[i].old_hw_idx,
+							       &mct_update->info[i].new_entry,
 							       dup_info_set);
-			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT update hw entry fail\n");
+			IF_ERROR_STR_FREE(TPM_MC_MOD, ret_code, mct_update, "MCT update hw entry fail\n");
 		}
 
 		/* Handle add new node */
-		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
-		    mct_update.info[i].state == TPM_MC_ENTRY_ADD) {
+		if (mct_update->info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update->info[i].state == TPM_MC_ENTRY_ADD) {
 			ret_code = tpm_mc_dup_list_node_add(rule_index,
 							    tpm_flow_id,
-							    &mct_update.info[i].new_entry,
+							    &mct_update->info[i].new_entry,
 							    dup_info_set);
-			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT add new hw entry fail\n");
+			IF_ERROR_STR_FREE(TPM_MC_MOD, ret_code, mct_update, "MCT add new hw entry fail\n");
 		}
 
 		/* Handle del existed node */
-		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
-		    mct_update.info[i].state == TPM_MC_ENTRY_DEL) {
+		if (mct_update->info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update->info[i].state == TPM_MC_ENTRY_DEL) {
 			ret_code = tpm_mc_dup_list_node_del(rule_index,
 							    &tpm_flow_id,
-							    mct_update.info[i].old_hw_idx,
+							    mct_update->info[i].old_hw_idx,
 							    dup_info_set);
-			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT del existed hw entry fail\n");
+			IF_ERROR_STR_FREE(TPM_MC_MOD, ret_code, mct_update, "MCT del existed hw entry fail\n");
 		}
 	}
 
+	mvOsFree(mct_update);
 	return TPM_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
index cc8925e..8ea660d3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
@@ -2285,18 +2285,25 @@ static int tpm_pme_data_unit_free_get(unsigned int tbl_idx,
 	int rc;
 	int i, bit_off, unit_idx = 0;
 	struct tpm_pme_tbl_rng_t rng_mng_data;
-	unsigned int state[TPM_PME_STATE_INT_NUM] = {0};
+	unsigned int *state;			/*use heap to reduce stack size*/
+
+	state = mvOsMalloc(TPM_PME_STATE_INT_NUM * sizeof(unsigned int));
+	IF_MALLOC_FAIL(TPM_PME_MOD, state);
+	memset(state, 0, TPM_PME_STATE_INT_NUM * sizeof(unsigned int));
 
 	TPM_MEMSET_ZERO(rng_mng_data);
 	rc = tpm_db_pme_data_rng_info_get(tbl_idx, rng_idx, &rng_mng_data);
-	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) management info get fail\n", tbl_idx, rng_idx);
-	memcpy(state, rng_mng_data.unit_state, sizeof(state));
+	IF_ERROR_STR_FREE(TPM_PME_MOD, rc, state, "Data Table(%d) range(%d) management info get fail\n",
+		tbl_idx, rng_idx);
+	memcpy(state, rng_mng_data.unit_state, sizeof(rng_mng_data.unit_state));
 	for (i = 0; i < TPM_PME_STATE_INT_NUM; i++) {
 		if (state[i] != TPM_PME_UNIT_ALL_OCCUPIED)
 			break;
 	}
 	if (i == TPM_PME_STATE_INT_NUM)
-		IF_ERROR_STR(TPM_PME_MOD, TPM_FULL, "Table(%d) range(%d) all unit are occupied\n", tbl_idx, rng_idx);
+		IF_ERROR_STR_FREE(TPM_PME_MOD, TPM_FULL, state,
+			"Mod data table(%d) range(%d) all units are occupied, no free space for new modification!\n",
+			tbl_idx, rng_idx);
 	for (bit_off = 0; bit_off < (sizeof(unsigned int) * BYTE_BITS); bit_off++) {
 		if (!(state[i] & (1 << bit_off)))
 			break;
@@ -2308,6 +2315,7 @@ static int tpm_pme_data_unit_free_get(unsigned int tbl_idx,
 	*data_unit_idx = unit_idx;
 	*unit_size = rng_mng_data.unit_size;
 
+	mvOsFree(state);
 	return TPM_OK;
 }
 
@@ -2334,13 +2342,17 @@ static int tpm_pme_data_unit_state_op(unsigned int tbl_idx,
 				      unsigned int op)
 {
 	int rc;
-	unsigned int state[TPM_PME_STATE_INT_NUM] = {0};
+	unsigned int *state;	/*use heap to reduce stack size*/
+
+	state = mvOsMalloc(TPM_PME_STATE_INT_NUM * sizeof(unsigned int));
+	IF_MALLOC_FAIL(TPM_PME_MOD, state);
+	memset(state, 0, TPM_PME_STATE_INT_NUM * sizeof(unsigned int));
 
 	if (op >= TPM_DATA_STATE_OP_MAX)
-		IF_ERROR_STR(TPM_PME_MOD, TPM_BAD_PARAM, "Invalid input unit state op(%d)\n", op);
+		IF_ERROR_STR_FREE(TPM_PME_MOD, TPM_BAD_PARAM, state, "Invalid input unit state op(%d)\n", op);
 	/* Read unit state */
 	rc = tpm_db_pme_data_rng_unit_state_get(tbl_idx, rng_idx, state);
-	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) unit state get fail\n", tbl_idx, rng_idx);
+	IF_ERROR_STR_FREE(TPM_PME_MOD, rc, state, "Data Table(%d) range(%d) unit state get fail\n", tbl_idx, rng_idx);
 	if (op == TPM_DATA_STATE_CLEAR) {
 		state[data_unit_idx / (sizeof(unsigned int) * BYTE_BITS)] &=
 		(~(1 << (data_unit_idx % (sizeof(unsigned int) * BYTE_BITS))));
@@ -2351,8 +2363,9 @@ static int tpm_pme_data_unit_state_op(unsigned int tbl_idx,
 	}
 	/* Update unit state */
 	rc = tpm_db_pme_data_rng_unit_state_set(tbl_idx, rng_idx, state);
-	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) unit state set fail\n", tbl_idx, rng_idx);
+	IF_ERROR_STR_FREE(TPM_PME_MOD, rc, state, "Data Table(%d) range(%d) unit state set fail\n", tbl_idx, rng_idx);
 
+	mvOsFree(state);
 	return TPM_OK;
 }
 
@@ -2750,7 +2763,7 @@ static int tpm_pme_mod_templ_sel(struct tpm_pme_pkt_mod_t *pme_mod_data,
 	if (templ_idx == TPM_PME_INSTR_TEMPL_MAX) {
 		/* Unlock template */
 		tpm_db_pme_templ_unlock();
-		rc = TPM_NOT_FOUND;
+		rc = TPM_NO_SUCH;
 		IF_ERROR_STR(TPM_PME_MOD,
 			     rc,
 			     "Template, ext_mod_bm=0x%x(original ext_mod_bm=0x%x), int_mod_bm=0x%x, NOT Found\n",
@@ -2830,7 +2843,7 @@ int tpm_pme_priv_first_data_update(unsigned int index, unsigned short data)
 			break;
 	}
 	if (data_db_idx == TPM_PME_PRIVATE_SET_MAX) {
-		rc = TPM_NOT_FOUND;
+		rc = TPM_NO_SUCH;
 		IF_ERROR_STR(TPM_PME_MOD, rc, "DB entry not found\n");
 	}
 
@@ -2843,8 +2856,8 @@ int tpm_pme_priv_first_data_update(unsigned int index, unsigned short data)
 			break;
 	}
 	if (templ_db_idx == TPM_PME_INSTR_TEMPL_MAX) {
-		rc = TPM_NOT_FOUND;
-		IF_ERROR_STR(TPM_PME_MOD, rc, "Templ DB entry not found\n");
+		rc = TPM_NO_SUCH;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Template DB entry not found\n");
 	}
 
 	/* DS NAPT, MH in instruction data, can not modify */
-- 
1.7.5.4

