From 85a6ba93da2401aba185011bbf8095bdfb02ea43 Mon Sep 17 00:00:00 2001
From: Jing Hua <jinghua@marvell.com>
Date: Wed, 9 Jul 2014 11:18:07 +0800
Subject: [PATCH 1777/1825] fix: alp: tpm: fix error of adding TPM rules with
 src port being UNI/PHY

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f9baaf1c1ff2ac8637383ce3958817486eb614df

	when two CAPs are merged into one C2 hit, its hit_number is changed
	to 2 automatically, when adding rule with src port UNI, it takes
	the first hit, when adding rule with src port PHY, it should take
	the second hit. But in routine tpm_mng_cap_entry_add, hit number
	is taken from TPM INIT configuration, so it is 1 instead of 2, which
	cause the failing of rule add.
	SYSTEMSW-839 - <TPM API could add two rules with src port being UNI and PHY>

Signed-off-by: Jing Hua <jinghua@marvell.com>

Change-Id: I70c9f979214e2fe250e7b854820f57a34a328d90
Reviewed-on: http://vgitil04.il.marvell.com:8080/9079
Reviewed-by: Ken Ma <make@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c       |   60 ++++++++++++++++++++
 1 files changed, 60 insertions(+), 0 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
index 6c5b7f3..07f8d94 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
@@ -2587,6 +2587,64 @@ int tpm_mng_cpu_qhigh_cap_add(void)
 	return TPM_OK;
 }
 #endif
+/*******************************************************************************
+* tpm_mng_cap_is_merged
+*
+* DESCRIPTION: The routine checks if this cap has been merged with other caps in this flow.
+*
+* INPUTS:
+*           cap_arr
+*
+* OUTPUTS:
+*           NONE
+*
+* On true, the function returns true. On false returns false.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+bool tpm_mng_cap_is_merged(struct tpm_db_mng_flow_cap_conf_t *cap)
+{
+
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr;
+	int cap_num;
+	int ret;
+	int loop;
+	bool merged = false;
+
+	cap_arr = mvOsMalloc(TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	IF_MALLOC_FAIL(TPM_MNG_MOD, cap_arr);
+	memset(cap_arr, 0, TPM_MNG_CAP_PER_FLOW_MAX * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+
+	ret = tpm_db_mng_cap_in_flow_get(cap->flow_log_id, cap_arr, &cap_num);
+	IF_ERROR_STR_FREE(TPM_MNG_MOD, ret, cap_arr, "get caps in flow(%d) failed\n", cap->flow_log_id);
+
+	/* this cap has been merged into other cap */
+	if (cap->c2_pri != 0) {
+		mvOsFree(cap_arr);
+		return true;
+	}
+
+	for (loop = 0; loop < cap_num; loop++) {
+		if (memcmp(cap, &cap_arr[loop], sizeof(struct tpm_db_mng_flow_cap_conf_t)))
+			continue;
+
+		/* here is the input cap */
+		/* this is the last cap, could not have other caps merged into it */
+		if (loop == (cap_num - 1)) {
+			merged = false;
+			break;
+		}
+
+		if (cap_arr[loop + 1].c2_pri != 0) {
+			merged = true;
+			break;
+		}
+	}
+
+	mvOsFree(cap_arr);
+	return merged;
+}
 
 /*******************************************************************************
 * tpm_mng_cnm_pbit_asis_cap_add
@@ -4892,6 +4950,8 @@ int tpm_mng_cap_entry_add(
 					TPM_OS_ERROR(TPM_MNG_MOD, "get CAP hit number failed\n");
 					goto rmv_entry;
 				}
+				if (tpm_mng_cap_is_merged(&cap_arr[loop]))
+					hit_num = 2;
 			} else if ((cap_arr[loop].cap_api_type == TPM_API_PRIVATE_EXCT)
 				    || (cap_arr[loop].cap_api_type == TPM_API_PRIVATE_MC_US))
 				hit_num = 2;
-- 
1.7.5.4

