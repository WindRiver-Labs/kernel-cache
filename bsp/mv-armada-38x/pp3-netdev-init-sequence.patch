From f8ea941e71a50e954deb86489d3d21f57bc0cbfd Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Thu, 30 Jan 2014 19:22:40 +0200
Subject: [PATCH 1329/1825] pp3: netdev init sequence

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 71f0ffb27dd5b51988e6396846881cdd40ca7c9a

Change-Id: I6c982e68022b550b15a7ea3e5ae7706cd7968d7e
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5400
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |  157 +++++++++++++++++---
 .../marvell/pp3/net_dev/mv_netdev_structs.h        |   13 ++-
 2 files changed, 147 insertions(+), 23 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index f397e34..dbeed64 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -26,6 +26,8 @@ struct pp3_cpu **pp3_cpus;
 static int pp3_ports_num;
 static int pp3_initialized;
 
+/* functions */
+static int mv_pp3_poll(struct napi_struct *napi, int budget);
 
 /****************************************************************
  * mv_pp3_netdev_init						*
@@ -34,22 +36,15 @@ static int pp3_initialized;
 
 struct net_device *mv_pp3_netdev_init(int mtu, u8 *mac, struct platform_device *pdev)
 {
+	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+
 	struct net_device *dev;
-	struct pp3_dev_priv *dev_priv;
 	struct resource *res;
 
-	dev = alloc_etherdev_mq(sizeof(struct pp3_dev_priv), CONFIG_MV_ETH_TXQ);
+	dev = alloc_etherdev_mqs(sizeof(struct pp3_dev_priv), plat_data->tx_queue_count, plat_data->tx_queue_count);
 	if (!dev)
 		return NULL;
 
-	dev_priv = (struct pp3_dev_priv *)netdev_priv(dev);
-	if (!dev_priv)
-		return NULL;
-
-	memset(dev_priv, 0, sizeof(struct pp3_dev_priv));
-
-	dev_priv->dev = dev;
-
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	BUG_ON(!res);
 	dev->irq = res->start;
@@ -57,7 +52,7 @@ struct net_device *mv_pp3_netdev_init(int mtu, u8 *mac, struct platform_device *
 	dev->mtu = mtu;
 	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
 
-	dev->tx_queue_len = CONFIG_MV_ETH_TXQ_DESC;
+	dev->tx_queue_len = plat_data->tx_queue_size;
 	dev->watchdog_timeo = 5 * HZ;
 
 	/* TODO: init eth_tools */
@@ -68,24 +63,117 @@ struct net_device *mv_pp3_netdev_init(int mtu, u8 *mac, struct platform_device *
 
 }
 
-static int mv_pp3_config_get(struct platform_device *pdev, unsigned char *mac_addr)
+/****************************************************************
+ * mv_pp3_priv_init						*
+ *	Allocate and initialize net_device private structures	*
+ ***************************************************************/
+
+static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
+{
+	struct pp3_dev_priv *dev_priv;
+	int cpu, num, first, frame, i;
+
+	dev_priv = MV_PP3_PRIV(dev);
+
+	memset(dev_priv, 0, sizeof(struct pp3_dev_priv));
+
+	dev_priv->dev = dev;
+	dev_priv->index = index;
+
+	/* create group per each cpu */
+	for_each_possible_cpu(cpu) {
+		struct pp3_group *group;
+
+		dev_priv->groups[cpu] = kmalloc(sizeof(struct pp3_dev_priv), GFP_KERNEL);
+		memset(dev_priv->groups[cpu], 0, sizeof(struct pp3_dev_priv));
+
+		group = dev_priv->groups[cpu];
+
+		/* init group rxqs */
+		/*pp3_config_mngr_rxq(emac_map, cpu, &first, &num, &frame);*/
+		group->rxqs_num = num;
+		group->rxqs = kmalloc(sizeof(struct pp3_rxq *) * num, GFP_KERNEL);
+		memset(group->rxqs, 0, sizeof(struct pp3_rxq *) * num);
+
+		for (i = 0; i < num; i++) {
+			group->rxqs[i] = kmalloc(sizeof(struct pp3_rxq), GFP_KERNEL);
+			memset(group->rxqs[i], 0, sizeof(struct pp3_rxq) * num);
+			group->rxqs[i]->frame_num = frame;
+			group->rxqs[i]->logic_q = i;
+			group->rxqs[i]->phys_q = first + i;
+			group->rxqs[i]->type = PP3_Q_TYPE_QM;
+			/*mv_pp3_hmac_rxq_init(frame, first + i);*/
+			/*group->rxqs[i]->hmac_queue = mv_pp3_hmac_rxq_get(frame, firts + i);*/
+			group->rxqs[i]->dev_priv = dev_priv;
+			group->rxqs[i]->pkt_coal = CONFIG_PP3_RX_COAL_PKTS;
+			group->rxqs[i]->time_coal = CONFIG_PP3_RX_COAL_USEC;
+		}
+
+		/* get emac bitmap */
+		/*pp3_config_mngr_emac_map(dev_priv->index, &dev_priv->emac_map);*/
+
+		/* init group txqs */
+		/*pp3_config_mngr_txq(dev_priv->index, cpu, &first, &num, &frame);*/
+		group->txqs_num = num;
+		group->txqs = kmalloc(sizeof(struct pp3_txq *) * num, GFP_KERNEL);
+		memset(group->txqs, 0, sizeof(struct pp3_txq *) * num);
+
+		for (i = 0; i < num; i++) {
+			group->txqs[i] = kmalloc(sizeof(struct pp3_txq) * num, GFP_KERNEL);
+			memset(group->txqs[i], 0, sizeof(struct pp3_txq) * num);
+			group->txqs[i]->frame_num = frame;
+			group->txqs[i]->logic_q = i;
+			group->txqs[i]->phys_q = first + i;
+			group->txqs[i]->type = PP3_Q_TYPE_QM;
+			/*mv_pp3_hmac_txq_init(frame, first + i);*/
+			/*group->txqs[i]->hmac_queue = mv_pp3_hmac_txq_get(frame, firts + i);*/
+			group->txqs[i]->dev_priv = dev_priv;
+		}
+
+		/* set group cpu control */
+		group->cpu_ctrl = pp3_cpus[cpu];
+
+		/* init group napi */
+		group->napi = kmalloc(sizeof(struct napi_struct), GFP_KERNEL);
+
+		if (!group->napi) {
+			/* TODO: call cleanup function */
+			return -EIO;
+		}
+
+		memset(group->napi, 0, sizeof(struct napi_struct));
+		netif_napi_add(dev, group->napi, mv_pp3_poll, CONFIG_MV_ETH_RX_POLL_WEIGHT);
+
+
+		/* TODO: init pools */
+
+	} /* for */
+
+	return 0;
+}
+
+
+static int mv_pp3_config_get(struct platform_device *pdev, unsigned char *mac_addr, int *index)
 {
 	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
 
 	if (mac_addr)
 		memcpy(mac_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
 
+	if (index)
+		*index = pdev->id;
+
 	return plat_data->mtu;
 }
 
 static int mv_pp3_load_network_interfaces(struct platform_device *pdev)
 {
-	int mtu;
-	struct pp3_dev_priv *priv;
+	int mtu, ret, index;
 	struct net_device *dev;
 	u8 mac[MV_MAC_ADDR_SIZE];
 
-	mtu = mv_pp3_config_get(pdev, mac);
+	/* TODO: move function to configure block */
+	mtu = mv_pp3_config_get(pdev, mac, &index);
 
 	pr_info("  o Loading network interface(s) for port #%d: mtu=%d\n", pdev->id, mtu);
 
@@ -96,10 +184,12 @@ static int mv_pp3_load_network_interfaces(struct platform_device *pdev)
 		return -EIO;
 	}
 
-	priv = MV_PP3_PRIV(dev);
-	priv->plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+	ret = mv_pp3_dev_priv_init(pdev->id, dev);
+
+	if (ret)
+		return ret;
 
-	pp3_ports[pdev->id] = priv;
+	pp3_ports[pdev->id] = MV_PP3_PRIV(dev);
 
 	return 0;
 }
@@ -256,7 +346,7 @@ irqreturn_t mv_pp3_isr(int irq, int group_id)
  * mv_pp3_poll							*
  *	napi func - call to mv_pp3_rx for group's rxqs		*
  ***************************************************************/
-int mv_pp3_poll(struct napi_struct *napi, int budget)
+static int mv_pp3_poll(struct napi_struct *napi, int budget)
 {
 	int rx_done = 0;
 	struct pp3_dev_priv *priv = MV_PP3_PRIV(napi->dev);
@@ -310,7 +400,7 @@ irqreturn_t mv_pp3_linux_pool_isr(int irq, int group_id)
 
 }
 
-void mv_pp3_bm_msg_tasklet(unsigned long data)
+void mv_pp3_bm_tasklet(unsigned long data)
 {
 	/* TODO
 		while (pool is not empty)
@@ -324,6 +414,33 @@ void mv_pp3_bm_msg_tasklet(unsigned long data)
 	*/
 }
 
+/****************************************************************
+ * mv_pp3_fw_isr					*
+ *	linux poll full interrupt handler			*
+ ***************************************************************/
+irqreturn_t mv_pp3_fw_isr(int irq, int group_id)
+{
+	int cpu = smp_processor_id();
+	struct pp3_cpu *cpu_ctrl = pp3_cpus[cpu];
+
+	STAT_INFO(cpu_ctrl->stats.lnx_fw_irq++);
+
+	/* TODO: interrupts Mask */
+
+	tasklet_schedule(&cpu_ctrl->fw_msg_tasklet);
+
+	/* TODO: interrupts UnMask */
+
+	return IRQ_HANDLED;
+
+}
+
+void mv_pp3_fw_tasklet(unsigned long data)
+{
+	/* TODO */
+}
+
+
 MODULE_DESCRIPTION("Marvell PPv3 Network Driver - www.marvell.com");
 MODULE_AUTHOR("Dmitri Epshtein <dima@marvell.com>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
index 2fc7199..753bbb9 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
@@ -31,12 +31,16 @@ disclaimer.
 
 /* according to num of emac units */
 #define MAX_ETH_DEVICES	4
+#define CONFIG_MV_ETH_RX_POLL_WEIGHT 64
+#define CONFIG_PP3_RX_COAL_USEC 10
+#define CONFIG_PP3_RX_COAL_PKTS 100
+
 
 #define MV_PP3_PRIV(dev)	((struct pp3_dev_priv *)(netdev_priv(dev)))
 
 struct pp3_dev_priv {
 	int			index;
-	struct mv_pp3_port_data *plat_data;
+	/* struct mv_pp3_port_data *plat_data; */
 	struct pp3_group	*groups[CONFIG_NR_CPUS];
 	struct net_device	*dev;
 	unsigned long		flags;
@@ -93,6 +97,9 @@ struct pp3_group {
 struct pp3_cpu_stats {
 	unsigned int lnx_pool_irq;
 	unsigned int lnx_pool_irq_err;
+	unsigned int lnx_fw_irq;
+	unsigned int lnx_fw_irq_err;
+
 };
 
 struct pp3_cpu {
@@ -128,7 +135,7 @@ struct pp3_rxq {
 	int	logic_q;
 	int	phys_q;
 	enum	pp3_q_type		type;
-	struct	mv_pp3_queue_ctrl	*queue;
+	struct	mv_pp3_queue_ctrl	*hmac_queue;
 	struct	pp3_dev_priv		*dev_priv;
 	int	pkt_coal;
 	int	time_coal;
@@ -144,7 +151,7 @@ struct pp3_txq {
 	int	logic_q;
 	int	phys_q;
 	enum	pp3_q_type		type;
-	struct	mv_pp3_queue_ctrl	*queue;
+	struct	mv_pp3_queue_ctrl	*hmac_queue;
 	struct	pp3_dev_priv		*dev_priv;
 	struct	pp3_xq_stats		stats;
 	/*
-- 
1.7.5.4

