From 3ffccdef4b9f05b1938035f4d222e3020110ffec Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Wed, 26 Feb 2014 09:46:29 +0200
Subject: [PATCH 1396/1825] fix: eth: a38x: fixed disabled egiga1 in RD board
 when define serdes 4 as sgmii

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5e141f8ac73f78e0b76ee12fa378a868f8368c72

	The bug is in SGMII serdes detection: in case only 1 serdes eth interface found, it cause invalid
	value in eth max count, and then causes to ignore the current on board RGMII ports.

	The fix is  to update the table, only when found more serdes eth interfaces than the on-board eth ports num.
	Added routine to detect port interface (SerDes/ On-board ) : mvCtrlPortIsSerdesSgmii
	Fixed the routine mvBoardIsPortInSgmii detect from the Common PHYs Selectors Register.

Change-Id: I1786924ade1b39d87f3c8d7886089be5d4b60cc3
Signed-off-by: Eli Nidam <elini@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5943
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |    6 +--
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.c       |   55 +++++++++++++++----
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |    1 +
 3 files changed, 45 insertions(+), 17 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index e02b8dc..aaa3fa8 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -270,11 +270,7 @@ MV_STATUS mvBoardNameGet(char *pNameBuff, MV_U32 size)
 *******************************************************************************/
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
 {
-	if ((mvBoardIsModuleConnected(MV_CONFIG_SGMII)) && /* when SGMII connected the SGMII ports are 1 & 2 */
-	    ((ethPortNum == 1) || (ethPortNum == 2)))
-		return MV_TRUE;
-
-	return MV_FALSE;
+	return mvCtrlPortIsSerdesSgmii(ethPortNum);
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
index e2266ea..065060e 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
@@ -140,6 +140,32 @@ MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_68xx_INDEX_MAX] = {
 /* PNC_UNIT_ID          */ { 0,				0},
 /* I2C_UNIT_ID          */ { 2,				2},
 };
+#define ON_BOARD_RGMII(x)	(1 << x)
+#define SERDES_SGMII(x)		(4 << x)
+
+/* ethComPhy will be updated by mvCtrlSerdesConfigDetect in case SGMII is set */
+static MV_U32	ethComPhy = ON_BOARD_RGMII(0) | ON_BOARD_RGMII(1);
+/*******************************************************************************
+* mvCtrlPortIsSerdesSgmii
+*
+* DESCRIPTION:
+*       Check if serdes configuration for input port is SGMII
+*
+* INPUT:
+*	eth port.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SERDES configure for input port is SGMII
+*******************************************************************************/
+MV_BOOL mvCtrlPortIsSerdesSgmii(MV_U32 ethPort)
+{
+	if (ethComPhy & SERDES_SGMII(ethPort))
+		return MV_TRUE;
+	return MV_FALSE;
+}
 /*******************************************************************************
 * mvCtrlGetCpuNum
 *
@@ -258,7 +284,7 @@ MV_U32 mvCtrlSocUnitInfoNumSet(MV_UNIT_ID unit, MV_U32 maxValue)
 *******************************************************************************/
 MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 {
-	MV_U32 pexIf, commPhyConfigReg, comPhyCfg, serdesNum, serdesCongigField, maxSerdesLane;
+	MV_U32 ifNo, commPhyConfigReg, comPhyCfg, serdesNum, serdesCongigField, maxSerdesLane;
 	MV_U32 ethIfCount = 0;
 	MV_U32 sataIfCount = 0;
 	MV_U32 usbIfCount = 0;
@@ -278,31 +304,34 @@ MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 		comPhyCfg = serdesCfg[serdesNum][serdesCongigField];
 		DB(printf("serdesCongigField=0x%x, comPhyCfg=0x%02x SERDES %d detect as ",	\
 			  serdesCongigField, comPhyCfg, serdesNum));
+		ifNo = comPhyCfg & 0x0f;
 		switch (comPhyCfg & 0xF0) {
 		case SERDES_UNIT_PEX:
-			pexIf = comPhyCfg & 0x0f;
-			if ((pexIf == PEX0_IF) && (commPhyConfigReg & PCIE0_X4_EN_MASK))
-				boardPexInfo->pexUnitCfg[pexIf] = PEX_BUS_MODE_X4;
+			if ((ifNo == PEX0_IF) && (commPhyConfigReg & PCIE0_X4_EN_MASK))
+				boardPexInfo->pexUnitCfg[ifNo] = PEX_BUS_MODE_X4;
 			else
-				boardPexInfo->pexUnitCfg[pexIf] = PEX_BUS_MODE_X1;
-			boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = pexIf;
+				boardPexInfo->pexUnitCfg[ifNo] = PEX_BUS_MODE_X1;
+			boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = ifNo;
 			boardPexInfo->boardPexIfNum++;
-			DB(printf("PEX, if=%d\n", pexIf));
+			DB(printf("PEX, if=%d\n", ifNo));
 			break;
 		case SERDES_UNIT_SATA:
-			DB(printf("SATA, if=%d\n", (comPhyCfg & 0x0f)));
+			DB(printf("SATA, if=%d\n", ifNo));
 			sataIfCount++;
 			break;
 		case SERDES_UNIT_GBE:
-			DB(printf("SGMII, if=%d\n", (comPhyCfg & 0x0f)));
+			if (ifNo < 2) /* detected SGMII will replace the same Ob-Board compatible port */
+				ethComPhy &= ON_BOARD_RGMII(ifNo);
+			ethComPhy |= SERDES_SGMII(ifNo);
+			DB(printf("SGMII, if=%d\n", ifNo));
 			ethIfCount++;
 			break;
 		case SERDES_UNIT_USB_H:
-		DB(printf("USB_H, if=%d\n", (comPhyCfg & 0x0f)));
+		DB(printf("USB_H, if=%d\n", ifNo));
 			usbHIfCount++;
 			break;
 		case SERDES_UNIT_USB:
-			DB(printf("USB, if=%d\n", (comPhyCfg & 0x0f)));
+			DB(printf("USB, if=%d\n", ifNo));
 			usbIfCount++;
 			break;
 		case SERDES_UNIT_NA:
@@ -312,7 +341,9 @@ MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 	mvCtrlSocUnitInfoNumSet(PEX_UNIT_ID, boardPexInfo->boardPexIfNum);
 	mvCtrlSocUnitInfoNumSet(SATA_UNIT_ID , sataIfCount);
 	mvCtrlSocUnitInfoNumSet(USB3_UNIT_ID, usbHIfCount);
-	if (ethIfCount) /* if serdes configuration found SGMII ports replace the existing RGMII gonfiguration*/
+	/* only if found more serdes eth interfaces than on-board ports,than update max eth count.
+	   (needed by phy + giga init sequence)				*/
+	if (ethIfCount > MV_ETH_MAX_ON_BOARD_PORTS)
 		mvCtrlSocUnitInfoNumSet(ETH_GIG_UNIT_ID, ethIfCount);
 	else
 		mvCtrlSocUnitInfoNumSet(ETH_GIG_UNIT_ID, MV_ETH_MAX_ON_BOARD_PORTS);
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
index edb9312..7ab7b02 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -185,6 +185,7 @@ typedef enum {
 /* mcspLib.h API list */
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
 MV_U32 mvCtrlbootSrcGet(void);
+MV_BOOL mvCtrlPortIsSerdesSgmii(MV_U32 ethPort);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
-- 
1.7.5.4

