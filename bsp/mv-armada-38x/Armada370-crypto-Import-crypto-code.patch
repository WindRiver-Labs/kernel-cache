From 963ac9de7d0092bd04c9312b07443f1475df82e3 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Wed, 24 Oct 2012 11:14:18 +0200
Subject: [PATCH 1794/1825] Armada370, crypto: Import crypto code.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit d1c3ab6bb10c8f729875105637c6bca17ea548fa

Change-Id: Ic23c23643059a462db8ca13723032c0d2418c55a
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 cesa/openssl/README                          |   20 +
 cesa/openswan/README                         |   62 +
 cesa/openswan/ipsec_routing_setup.sh         |   36 +
 crypto/Kconfig                               |   26 +-
 crypto/Makefile                              |    2 -
 crypto/aes_generic.c                         |    1 +
 crypto/ansi_cprng.c                          |   63 +-
 crypto/anubis.c                              |    1 +
 crypto/blowfish_generic.c                    |    1 +
 crypto/camellia_generic.c                    |    1 +
 crypto/cast5.c                               |    1 +
 crypto/cast6.c                               |    1 +
 crypto/crypto_null.c                         |   57 +-
 crypto/deflate.c                             |    1 +
 crypto/des_generic.c                         |   25 +-
 crypto/fcrypt.c                              |    1 +
 crypto/ghash-generic.c                       |    1 +
 crypto/khazad.c                              |    1 +
 crypto/krng.c                                |    1 +
 crypto/lzo.c                                 |    1 +
 crypto/ocf/ChangeLog                         | 1960 ++++++++++++++++++++++++++
 crypto/ocf/Config.in                         |    4 -
 crypto/ocf/Kconfig                           |   28 +-
 crypto/ocf/Makefile                          |  109 +-
 crypto/ocf/criov.c                           |   11 +-
 crypto/ocf/crypto.c                          |  243 ++--
 crypto/ocf/cryptodev.c                       |  111 +-
 crypto/ocf/cryptodev.h                       |    7 +-
 crypto/ocf/cryptosoft.c                      | 1344 ++++++------------
 crypto/ocf/ep80579/Makefile                  |   38 +-
 crypto/ocf/ep80579/environment.mk            |   75 +
 crypto/ocf/ep80579/icp_asym.c                |  305 +++--
 crypto/ocf/ep80579/icp_common.c              |  576 +++++---
 crypto/ocf/ep80579/icp_ocf.h                 |  337 +++---
 crypto/ocf/ep80579/icp_sym.c                 |  423 +++++--
 crypto/ocf/ep80579/linux_2.6_kernel_space.mk |   69 +
 crypto/ocf/hifn/hifn7751.c                   |   42 +-
 crypto/ocf/hifn/hifn7751var.h                |    1 +
 crypto/ocf/hifn/hifnHIPP.c                   |    4 +-
 crypto/ocf/ixp4xx/ixp4xx.c                   |   41 +-
 crypto/ocf/ocf-bench.c                       |  136 +--
 crypto/ocf/ocf-compat.h                      |  109 +--
 crypto/ocf/ocfnull/ocfnull.c                 |    9 +-
 crypto/ocf/pasemi/pasemi.c                   |   10 +-
 crypto/ocf/random.c                          |   10 +-
 crypto/ocf/rndtest.c                         |    8 +-
 crypto/ocf/safe/safe.c                       |   76 +-
 crypto/ocf/safe/safevar.h                    |    3 +-
 crypto/ocf/talitos/talitos.c                 |   16 +-
 crypto/ocf/talitos/talitos_soft.h            |    1 +
 crypto/ocf/uio.h                             |    4 +-
 crypto/salsa20_generic.c                     |    1 +
 crypto/seed.c                                |    1 +
 crypto/serpent_generic.c                     |   53 +-
 crypto/sha256_generic.c                      |   36 +-
 crypto/sha512_generic.c                      |   33 +-
 crypto/shash.c                               |   36 -
 crypto/tcrypt.c                              |   54 +-
 crypto/tea.c                                 |   41 +-
 crypto/tgr192.c                              |   38 +-
 crypto/twofish_generic.c                     |    1 +
 crypto/wp512.c                               |   39 +-
 62 files changed, 4355 insertions(+), 2391 deletions(-)
 create mode 100644 cesa/openssl/README
 create mode 100644 cesa/openswan/README
 create mode 100644 cesa/openswan/ipsec_routing_setup.sh
 create mode 100644 crypto/ocf/ChangeLog
 create mode 100644 crypto/ocf/ep80579/environment.mk
 create mode 100644 crypto/ocf/ep80579/linux_2.6_kernel_space.mk

diff --git a/cesa/openssl/README b/cesa/openssl/README
new file mode 100644
index 0000000..d5b6b62
--- /dev/null
+++ b/cesa/openssl/README
@@ -0,0 +1,20 @@
+OpenSSL
+===========
+ In order to explore the CESA unit through the OpenSSL, you have to use the
+ OpenSSL OCF cryptodev engine.
+ By default the cryptodev engine will use the CESA
+ accelerator.
+
+ o In case missing, create a crypto device: mknod /dev/crypto c 10 70
+ o download openssl-1.0.0g (http://www.openssl.org/), then untar+unzip it.
+ o In case missing, copy from kernel crypto/ocf/cryptodev.h to file-system path: /usr/include/crypto .
+ o Run: ./config -DHAVE_CRYPTODEV no-shared
+ o and compile ...('make' and 'make install')
+
+ you can run a speed test to make sure everything is working:
+	openssl speed -evp des3 -elapsed
+ Modify /dev/crypto to /dev/crypto_tmp so that the speed test will use
+ now software encryption.
+ Run again:
+        openssl speed -evp des3 -elapsed
+ Compare results.
diff --git a/cesa/openswan/README b/cesa/openswan/README
new file mode 100644
index 0000000..fcd68f4
--- /dev/null
+++ b/cesa/openswan/README
@@ -0,0 +1,62 @@
+OpenSWAN
+=========
+In order to explore the CESA through the OpenSWAN, please follow the next steps:
+
+1. Download openswan-2.6.37 (http://www.openswan.org/), then untar+unzip it.
+ 
+2. Apply the patch:
+	- mv_openswan_2_6_37.patch:
+		> Disable default DEBUG support.
+		> Enable OCF support.
+
+3. Compile:
+
+ + ipsec module (cross compilation) :
+  'make KERNELSRC=<path to this release, after config> module ARCH=arm CC=<path_to_cross_compile> LD=<path_to_cross_loader>'
+  then copy the module to the host FS: /lib/modules/<kernel_name>/kernel/net/ipsec/
+
+ + ipsec user (native) :
+  make sure that you have the kernel source on the FS.
+  'make KERNELSRC=<path to this release, after config> programs'
+  'make install'
+
+Note: before tunnel is enabled on target, reverse path filtering(rp_filter) must be disabled under sysfs, using
+      the following commands:
+      - echo 0  > /proc/sys/net/ipv4/conf/eth<x>/rp_filter
+      - echo 0  > /proc/sys/net/ipv4/conf/all/rp_filter
+
+Reverse Path Filtering(rp_filter): it is a technology that is used on IP routers to try and prevent source address spoofing,
+which is often used for DenialOfService attacks. RPF works by checking the source IP of each packet received on an interface
+against the routing table. If the best route for the source IP address does not use the same interface that the packet was received on the packet is dropped.
+
+IPSec routing using encryption/authentication only:
+
+  basic vpn connection:
+  +++++++++++++++++++++
+ - platform: conncted with egiga.
+ - make sure you have 'ip' (part of the iproute package) installed.
+ - edit /etc/ipsec.conf (on both sides) ,check the "man ipsec.conf" :
+
+config setup
+        interfaces="ipsec0=eth0"    # Virtual/physical interfaces
+        klipsdebug="none"             # Debug KLIPS
+        plutodebug="none"             # Debug PLUTO
+
+conn dsmp_psk_vpn
+    type=tunnel                    # type of the connection: tunnel(default),passthrough,transport,reject,drop
+    authby=secret
+    left=192.168.1.1
+    leftsubnet=192.168.1.0/16
+    right=192.168.0.1              # Remote information
+    rightsubnet=192.168.0.0/16
+    auto=start                     # start this connection at startup
+
+
+ - edit /etc/ipsec.secrets (on both sides) to have shared secret.
+192.168.1.1 192.168.0.1 : PSK "123456"
+
+ - side1: 'ifconfig eth0 192.168.0.1 netmask 255.255.0.0'
+ - side2: 'ifconfig eth0 192.168.1.1 netmask 255.255.0.0'
+ - check connectivity: ping from side1 to 192.168.1.1
+ - '/etc/init.d/ipsec start' (on both sides), create new interface ipsec0.
+ - check connectivity: ping from side1 to 192.168.1.1 --> VPN is working (make sure by sniffing)
diff --git a/cesa/openswan/ipsec_routing_setup.sh b/cesa/openswan/ipsec_routing_setup.sh
new file mode 100644
index 0000000..28fe3a2
--- /dev/null
+++ b/cesa/openswan/ipsec_routing_setup.sh
@@ -0,0 +1,36 @@
+# This is an example how to setup the network interfaces in order to run IPSec routing
+
+ifconfig eth0 192.168.0.1 hw ether 00:00:00:00:61:92 netmask 255.255.0.0
+ifconfig eth1 192.167.0.1 hw ether 00:00:00:00:62:81 netmask 255.255.0.0
+echo 1 > /proc/sys/net/ipv4/ip_forward
+arp -s 192.167.0.250 00:00:00:00:00:12
+arp -s 192.168.1.1 00:00:00:00:00:11
+#IPSec Configuration
+insmod /ipsec.ko
+
+#SmartBit Configuration
+#eth0 - 192.168.1.1 --> 192.167.0.250
+#         00:00:00:00:00:12 --> 00:00:00:00:61:92
+#eth1   - 192.167.0.250 --> 192.168.1.1
+#         00:00:00:00:00:11 -> 00:00:00:00:62:81
+
+
+# unmark this to disble flow control for Yukon/E1000 NICs
+#ethtool -A eth0 tx off
+#ethtool -A eth0 rx off
+#ethtool -A eth2 tx off
+#ethtool -A eth2 rx off
+
+# Here we build static SA database since it is not supported anymore from OpenSWAN 2.6.18 and on
+# This is example setup for ESP 3DES/SHA1
+ipsec spi --clear
+ipsec eroute --clear
+enckey=0x0123456789abcdef02468ace13579bdf123456789abcdef0
+authkey=0x0123456789abcdef02468ace13579bdf12345678
+ipsec spi --af inet --edst 192.168.1.1 --spi 0x12345678 --proto esp --src 192.168.0.1 --esp 3des-sha1 --enckey $enckey --authkey $authkey
+ipsec spi --af inet --edst 192.168.1.1 --spi 0x12345678 --proto tun --src 192.168.0.1 --dst 192.168.1.1 --ip4
+ipsec spigrp inet 192.168.1.1 0x12345678 tun inet 192.168.1.1 0x12345678 esp
+ipsec eroute --add --eraf inet --src 192.167.0.0/16 --dst 192.168.1.0/24 --said tun0x12345678@192.168.1.1
+ipsec tncfg --attach --virtual ipsec0 --physical eth0
+ifconfig ipsec0 inet 192.168.0.1 netmask 255.255.0.0 broadcast 192.168.255.255 up
+route add -host 192.168.1.1 gw 192.168.0.1 dev ipsec0
diff --git a/crypto/Kconfig b/crypto/Kconfig
index 991e5ef..b7ca96c 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -423,28 +423,6 @@ config CRYPTO_SHA1_SSSE3
 	  using Supplemental SSE3 (SSSE3) instructions or Advanced Vector
 	  Extensions (AVX), when available.
 
-config CRYPTO_SHA256_SSSE3
-	tristate "SHA256 digest algorithm (SSSE3/AVX/AVX2)"
-	depends on X86 && 64BIT
-	select CRYPTO_SHA256
-	select CRYPTO_HASH
-	help
-	SHA-256 secure hash standard (DFIPS 180-2) implemented
-	  using Supplemental SSE3 (SSSE3) instructions, or Advanced Vector
-	  Extensions version 1 (AVX1), or Advanced Vector Extensions
-	  version 2 (AVX2) instructions, when available.
-
-config CRYPTO_SHA512_SSSE3
-	tristate "SHA512 digest algorithm (SSSE3/AVX/AVX2)"
-	depends on X86 && 64BIT
-	select CRYPTO_SHA512
-	select CRYPTO_HASH
-	help
-	  SHA-512 secure hash standard (DFIPS 180-2) implemented
-	  using Supplemental SSE3 (SSSE3) instructions, or Advanced Vector
-	  Extensions version 1 (AVX1), or Advanced Vector Extensions
-	  version 2 (AVX2) instructions, when available.
-
 config CRYPTO_SHA256
 	tristate "SHA224 and SHA256 digest algorithm"
 	select CRYPTO_HASH
@@ -1001,7 +979,5 @@ config CRYPTO_USER_API_SKCIPHER
 
 source "drivers/crypto/Kconfig"
 
-endif	# if CRYPTO
-
 source "crypto/ocf/Kconfig"
-
+endif	# if CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
index 21ae324..e05fd2e 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -90,9 +90,7 @@ obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
 obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
 obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
 obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
-
 obj-$(CONFIG_OCF_OCF) += ocf/
-
 #
 # generic algorithms and the async_tx api
 #
diff --git a/crypto/aes_generic.c b/crypto/aes_generic.c
index 47f2e5c..a68c73d 100644
--- a/crypto/aes_generic.c
+++ b/crypto/aes_generic.c
@@ -1448,6 +1448,7 @@ static struct crypto_alg aes_alg = {
 	.cra_ctxsize		=	sizeof(struct crypto_aes_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(aes_alg.cra_list),
 	.cra_u			=	{
 		.cipher = {
 			.cia_min_keysize	=	AES_MIN_KEY_SIZE,
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index 666f196..c21f761 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -382,6 +382,26 @@ static int cprng_reset(struct crypto_rng *tfm, u8 *seed, unsigned int slen)
 	return 0;
 }
 
+static struct crypto_alg rng_alg = {
+	.cra_name		= "stdrng",
+	.cra_driver_name	= "ansi_cprng",
+	.cra_priority		= 100,
+	.cra_flags		= CRYPTO_ALG_TYPE_RNG,
+	.cra_ctxsize		= sizeof(struct prng_context),
+	.cra_type		= &crypto_rng_type,
+	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(rng_alg.cra_list),
+	.cra_init		= cprng_init,
+	.cra_exit		= cprng_exit,
+	.cra_u			= {
+		.rng = {
+			.rng_make_random	= cprng_get_random,
+			.rng_reset		= cprng_reset,
+			.seedsize = DEFAULT_PRNG_KSZ + 2*DEFAULT_BLK_SZ,
+		}
+	}
+};
+
 #ifdef CONFIG_CRYPTO_FIPS
 static int fips_cprng_get_random(struct crypto_rng *tfm, u8 *rdata,
 			    unsigned int dlen)
@@ -418,27 +438,8 @@ static int fips_cprng_reset(struct crypto_rng *tfm, u8 *seed, unsigned int slen)
 out:
 	return rc;
 }
-#endif
 
-static struct crypto_alg rng_algs[] = { {
-	.cra_name		= "stdrng",
-	.cra_driver_name	= "ansi_cprng",
-	.cra_priority		= 100,
-	.cra_flags		= CRYPTO_ALG_TYPE_RNG,
-	.cra_ctxsize		= sizeof(struct prng_context),
-	.cra_type		= &crypto_rng_type,
-	.cra_module		= THIS_MODULE,
-	.cra_init		= cprng_init,
-	.cra_exit		= cprng_exit,
-	.cra_u			= {
-		.rng = {
-			.rng_make_random	= cprng_get_random,
-			.rng_reset		= cprng_reset,
-			.seedsize = DEFAULT_PRNG_KSZ + 2*DEFAULT_BLK_SZ,
-		}
-	}
-#ifdef CONFIG_CRYPTO_FIPS
-}, {
+static struct crypto_alg fips_rng_alg = {
 	.cra_name		= "fips(ansi_cprng)",
 	.cra_driver_name	= "fips_ansi_cprng",
 	.cra_priority		= 300,
@@ -446,6 +447,7 @@ static struct crypto_alg rng_algs[] = { {
 	.cra_ctxsize		= sizeof(struct prng_context),
 	.cra_type		= &crypto_rng_type,
 	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(rng_alg.cra_list),
 	.cra_init		= cprng_init,
 	.cra_exit		= cprng_exit,
 	.cra_u			= {
@@ -455,18 +457,33 @@ static struct crypto_alg rng_algs[] = { {
 			.seedsize = DEFAULT_PRNG_KSZ + 2*DEFAULT_BLK_SZ,
 		}
 	}
+};
 #endif
-} };
 
 /* Module initalization */
 static int __init prng_mod_init(void)
 {
-	return crypto_register_algs(rng_algs, ARRAY_SIZE(rng_algs));
+	int rc = 0;
+
+	rc = crypto_register_alg(&rng_alg);
+#ifdef CONFIG_CRYPTO_FIPS
+	if (rc)
+		goto out;
+
+	rc = crypto_register_alg(&fips_rng_alg);
+
+out:
+#endif
+	return rc;
 }
 
 static void __exit prng_mod_fini(void)
 {
-	crypto_unregister_algs(rng_algs, ARRAY_SIZE(rng_algs));
+	crypto_unregister_alg(&rng_alg);
+#ifdef CONFIG_CRYPTO_FIPS
+	crypto_unregister_alg(&fips_rng_alg);
+#endif
+	return;
 }
 
 MODULE_LICENSE("GPL");
diff --git a/crypto/anubis.c b/crypto/anubis.c
index 008c8a4..77530d5 100644
--- a/crypto/anubis.c
+++ b/crypto/anubis.c
@@ -678,6 +678,7 @@ static struct crypto_alg anubis_alg = {
 	.cra_ctxsize		=	sizeof (struct anubis_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(anubis_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	ANUBIS_MIN_KEY_SIZE,
 	.cia_max_keysize	=	ANUBIS_MAX_KEY_SIZE,
diff --git a/crypto/blowfish_generic.c b/crypto/blowfish_generic.c
index 8baf544..6f269b5 100644
--- a/crypto/blowfish_generic.c
+++ b/crypto/blowfish_generic.c
@@ -115,6 +115,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize		=	sizeof(struct bf_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	BF_MIN_KEY_SIZE,
 	.cia_max_keysize	=	BF_MAX_KEY_SIZE,
diff --git a/crypto/camellia_generic.c b/crypto/camellia_generic.c
index 75efa20..f7aaaaf 100644
--- a/crypto/camellia_generic.c
+++ b/crypto/camellia_generic.c
@@ -1072,6 +1072,7 @@ static struct crypto_alg camellia_alg = {
 	.cra_ctxsize		=	sizeof(struct camellia_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(camellia_alg.cra_list),
 	.cra_u			=	{
 		.cipher = {
 			.cia_min_keysize	=	CAMELLIA_MIN_KEY_SIZE,
diff --git a/crypto/cast5.c b/crypto/cast5.c
index fffcb37..4a230dd 100644
--- a/crypto/cast5.c
+++ b/crypto/cast5.c
@@ -779,6 +779,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize 	= sizeof(struct cast5_ctx),
 	.cra_alignmask	= 3,
 	.cra_module 	= THIS_MODULE,
+	.cra_list 	= LIST_HEAD_INIT(alg.cra_list),
 	.cra_u 		= {
 		.cipher = {
 			.cia_min_keysize = CAST5_MIN_KEY_SIZE,
diff --git a/crypto/cast6.c b/crypto/cast6.c
index 04264f5..e0c15a6 100644
--- a/crypto/cast6.c
+++ b/crypto/cast6.c
@@ -519,6 +519,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize = sizeof(struct cast6_ctx),
 	.cra_alignmask = 3,
 	.cra_module = THIS_MODULE,
+	.cra_list = LIST_HEAD_INIT(alg.cra_list),
 	.cra_u = {
 		  .cipher = {
 			     .cia_min_keysize = CAST6_MIN_KEY_SIZE,
diff --git a/crypto/crypto_null.c b/crypto/crypto_null.c
index fee7265..07a8a96 100644
--- a/crypto/crypto_null.c
+++ b/crypto/crypto_null.c
@@ -94,6 +94,18 @@ static int skcipher_null_crypt(struct blkcipher_desc *desc,
 	return err;
 }
 
+static struct crypto_alg compress_null = {
+	.cra_name		=	"compress_null",
+	.cra_flags		=	CRYPTO_ALG_TYPE_COMPRESS,
+	.cra_blocksize		=	NULL_BLOCK_SIZE,
+	.cra_ctxsize		=	0,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=       LIST_HEAD_INIT(compress_null.cra_list),
+	.cra_u			=	{ .compress = {
+	.coa_compress 		=	null_compress,
+	.coa_decompress		=	null_compress } }
+};
+
 static struct shash_alg digest_null = {
 	.digestsize		=	NULL_DIGEST_SIZE,
 	.setkey   		=	null_hash_setkey,
@@ -110,19 +122,22 @@ static struct shash_alg digest_null = {
 	}
 };
 
-static struct crypto_alg null_algs[3] = { {
+static struct crypto_alg cipher_null = {
 	.cra_name		=	"cipher_null",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	NULL_BLOCK_SIZE,
 	.cra_ctxsize		=	0,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(cipher_null.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	NULL_KEY_SIZE,
 	.cia_max_keysize	=	NULL_KEY_SIZE,
 	.cia_setkey		= 	null_setkey,
 	.cia_encrypt		=	null_crypt,
 	.cia_decrypt		=	null_crypt } }
-}, {
+};
+
+static struct crypto_alg skcipher_null = {
 	.cra_name		=	"ecb(cipher_null)",
 	.cra_driver_name	=	"ecb-cipher_null",
 	.cra_priority		=	100,
@@ -131,6 +146,7 @@ static struct crypto_alg null_algs[3] = { {
 	.cra_type		=	&crypto_blkcipher_type,
 	.cra_ctxsize		=	0,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(skcipher_null.cra_list),
 	.cra_u			=	{ .blkcipher = {
 	.min_keysize		=	NULL_KEY_SIZE,
 	.max_keysize		=	NULL_KEY_SIZE,
@@ -138,16 +154,7 @@ static struct crypto_alg null_algs[3] = { {
 	.setkey			= 	null_setkey,
 	.encrypt		=	skcipher_null_crypt,
 	.decrypt		=	skcipher_null_crypt } }
-}, {
-	.cra_name		=	"compress_null",
-	.cra_flags		=	CRYPTO_ALG_TYPE_COMPRESS,
-	.cra_blocksize		=	NULL_BLOCK_SIZE,
-	.cra_ctxsize		=	0,
-	.cra_module		=	THIS_MODULE,
-	.cra_u			=	{ .compress = {
-	.coa_compress		=	null_compress,
-	.coa_decompress		=	null_compress } }
-} };
+};
 
 MODULE_ALIAS("compress_null");
 MODULE_ALIAS("digest_null");
@@ -157,26 +164,40 @@ static int __init crypto_null_mod_init(void)
 {
 	int ret = 0;
 
-	ret = crypto_register_algs(null_algs, ARRAY_SIZE(null_algs));
+	ret = crypto_register_alg(&cipher_null);
 	if (ret < 0)
 		goto out;
 
+	ret = crypto_register_alg(&skcipher_null);
+	if (ret < 0)
+		goto out_unregister_cipher;
+
 	ret = crypto_register_shash(&digest_null);
 	if (ret < 0)
-		goto out_unregister_algs;
+		goto out_unregister_skcipher;
 
-	return 0;
+	ret = crypto_register_alg(&compress_null);
+	if (ret < 0)
+		goto out_unregister_digest;
 
-out_unregister_algs:
-	crypto_unregister_algs(null_algs, ARRAY_SIZE(null_algs));
 out:
 	return ret;
+
+out_unregister_digest:
+	crypto_unregister_shash(&digest_null);
+out_unregister_skcipher:
+	crypto_unregister_alg(&skcipher_null);
+out_unregister_cipher:
+	crypto_unregister_alg(&cipher_null);
+	goto out;
 }
 
 static void __exit crypto_null_mod_fini(void)
 {
+	crypto_unregister_alg(&compress_null);
 	crypto_unregister_shash(&digest_null);
-	crypto_unregister_algs(null_algs, ARRAY_SIZE(null_algs));
+	crypto_unregister_alg(&skcipher_null);
+	crypto_unregister_alg(&cipher_null);
 }
 
 module_init(crypto_null_mod_init);
diff --git a/crypto/deflate.c b/crypto/deflate.c
index b57d70e..b0165ec 100644
--- a/crypto/deflate.c
+++ b/crypto/deflate.c
@@ -199,6 +199,7 @@ static struct crypto_alg alg = {
 	.cra_flags		= CRYPTO_ALG_TYPE_COMPRESS,
 	.cra_ctxsize		= sizeof(struct deflate_ctx),
 	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(alg.cra_list),
 	.cra_init		= deflate_init,
 	.cra_exit		= deflate_exit,
 	.cra_u			= { .compress = {
diff --git a/crypto/des_generic.c b/crypto/des_generic.c
index f6cf63f..873818d 100644
--- a/crypto/des_generic.c
+++ b/crypto/des_generic.c
@@ -943,44 +943,59 @@ static void des3_ede_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 	d[1] = cpu_to_le32(L);
 }
 
-static struct crypto_alg des_algs[2] = { {
+static struct crypto_alg des_alg = {
 	.cra_name		=	"des",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	DES_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct des_ctx),
 	.cra_module		=	THIS_MODULE,
 	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(des_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	DES_KEY_SIZE,
 	.cia_max_keysize	=	DES_KEY_SIZE,
 	.cia_setkey		=	des_setkey,
 	.cia_encrypt		=	des_encrypt,
 	.cia_decrypt		=	des_decrypt } }
-}, {
+};
+
+static struct crypto_alg des3_ede_alg = {
 	.cra_name		=	"des3_ede",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	DES3_EDE_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct des3_ede_ctx),
 	.cra_module		=	THIS_MODULE,
 	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(des3_ede_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	DES3_EDE_KEY_SIZE,
 	.cia_max_keysize	=	DES3_EDE_KEY_SIZE,
 	.cia_setkey		=	des3_ede_setkey,
 	.cia_encrypt		=	des3_ede_encrypt,
 	.cia_decrypt		=	des3_ede_decrypt } }
-} };
+};
 
 MODULE_ALIAS("des3_ede");
 
 static int __init des_generic_mod_init(void)
 {
-	return crypto_register_algs(des_algs, ARRAY_SIZE(des_algs));
+	int ret = 0;
+
+	ret = crypto_register_alg(&des_alg);
+	if (ret < 0)
+		goto out;
+
+	ret = crypto_register_alg(&des3_ede_alg);
+	if (ret < 0)
+		crypto_unregister_alg(&des_alg);
+out:
+	return ret;
 }
 
 static void __exit des_generic_mod_fini(void)
 {
-	crypto_unregister_algs(des_algs, ARRAY_SIZE(des_algs));
+	crypto_unregister_alg(&des3_ede_alg);
+	crypto_unregister_alg(&des_alg);
 }
 
 module_init(des_generic_mod_init);
diff --git a/crypto/fcrypt.c b/crypto/fcrypt.c
index 3b2cf56..c33107e 100644
--- a/crypto/fcrypt.c
+++ b/crypto/fcrypt.c
@@ -396,6 +396,7 @@ static struct crypto_alg fcrypt_alg = {
 	.cra_ctxsize		=	sizeof(struct fcrypt_ctx),
 	.cra_module		=	THIS_MODULE,
 	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(fcrypt_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	8,
 	.cia_max_keysize	=	8,
diff --git a/crypto/ghash-generic.c b/crypto/ghash-generic.c
index 9d3f0c6..7835b8f 100644
--- a/crypto/ghash-generic.c
+++ b/crypto/ghash-generic.c
@@ -153,6 +153,7 @@ static struct shash_alg ghash_alg = {
 		.cra_blocksize		= GHASH_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(struct ghash_ctx),
 		.cra_module		= THIS_MODULE,
+		.cra_list		= LIST_HEAD_INIT(ghash_alg.base.cra_list),
 		.cra_exit		= ghash_exit_tfm,
 	},
 };
diff --git a/crypto/khazad.c b/crypto/khazad.c
index 60e7cd6..527e4e3 100644
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -853,6 +853,7 @@ static struct crypto_alg khazad_alg = {
 	.cra_ctxsize		=	sizeof (struct khazad_ctx),
 	.cra_alignmask		=	7,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(khazad_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	KHAZAD_KEY_SIZE,
 	.cia_max_keysize	=	KHAZAD_KEY_SIZE,
diff --git a/crypto/krng.c b/crypto/krng.c
index a2d2b72..4328bb3 100644
--- a/crypto/krng.c
+++ b/crypto/krng.c
@@ -35,6 +35,7 @@ static struct crypto_alg krng_alg = {
 	.cra_ctxsize		= 0,
 	.cra_type		= &crypto_rng_type,
 	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(krng_alg.cra_list),
 	.cra_u			= {
 		.rng = {
 			.rng_make_random	= krng_get_random,
diff --git a/crypto/lzo.c b/crypto/lzo.c
index 1c2aa69..b5e7707 100644
--- a/crypto/lzo.c
+++ b/crypto/lzo.c
@@ -81,6 +81,7 @@ static struct crypto_alg alg = {
 	.cra_flags		= CRYPTO_ALG_TYPE_COMPRESS,
 	.cra_ctxsize		= sizeof(struct lzo_ctx),
 	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(alg.cra_list),
 	.cra_init		= lzo_init,
 	.cra_exit		= lzo_exit,
 	.cra_u			= { .compress = {
diff --git a/crypto/ocf/ChangeLog b/crypto/ocf/ChangeLog
new file mode 100644
index 0000000..e913ef2
--- /dev/null
+++ b/crypto/ocf/ChangeLog
@@ -0,0 +1,1960 @@
+2008-09-18 01:27  davidm
+
+	* Makefile, README, README.sglinux,
+	patches/linux-2.6.26-natt.patch, patches/linux-2.6.26-ocf.patch,
+	patches/openssl-0.9.8g.patch, patches/openssl-0.9.8i.patch: 
+	
+	Updates for a new OCF release with openssl-0.9.8i and linux-2.6.26
+	support.
+
+2008-09-18 00:19  davidm
+
+	* Config.in, Kconfig, Makefile, ep80579/Makefile,
+	ep80579/environment.mk, ep80579/icp_asym.c, ep80579/icp_common.c,
+	ep80579/icp_ocf.h, ep80579/icp_sym.c,
+	ep80579/linux_2.6_kernel_space.mk: 
+	
+	A new driver from Intel for their Intel QuickAssist enabled EP80579
+	Integrated Processor Product Line.
+	
+	Adrian Hoban  Brad Vrabete
+	
+
+2008-07-25 01:01  gerg
+
+	* ocf-compat.h: 
+	
+	From linux-2.6.26 onwards there is now a linux/fdtable.h include
+	that contains the file_fdtable() definition.
+
+2008-07-05 01:20  davidm
+
+	* Makefile, patches/linux-2.6.25-natt.patch,
+	patches/linux-2.6.25-ocf.patch: 
+	
+	A new ocf-linux release and some patches to send to the OS guys.
+
+2008-07-03 21:21  davidm
+
+	* crypto.c: 
+	
+	Clean up a some possible deadlock/busy wait issues with
+	locking/sleeping.  This has greatly improved openswan 2.6.14
+	reliability ;-)
+	
+	Make more of our state available in /sys for debugging.
+
+2008-06-23 20:38  davidm
+
+	* Config.in, Kconfig: 
+	
+	Some settings should be bool's John Gumb 
+
+2008-05-28 03:43  philipc
+
+	* ixp4xx/ixp4xx.c:  Revert previous checkin since the
+	callbacks are meant to complete the crypto request.  Before
+	reverting this, CONFIG_DEBUG_SLAB gives: slab error in
+	verify_redzone_free(): cache `ixp4xx_q': double free detected when
+	trying to ssh to the device.
+
+2008-04-27 19:31  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	We were not completing a crypto request under some error
+	conditions.
+
+2008-04-02 01:51  davidm
+
+	* talitos/talitos.c: 
+	
+	This patch is for crypto/ocf/talitos for use on linux 2.6.23.  It
+	is applied to the ocf-linux-20071215 release.
+	
+	Signed-off-by: Lee Nipper 
+
+2008-02-29 00:43  davidm
+
+	* crypto.c, ocf-compat.h, ixp4xx/ixp4xx.c: 
+	
+	freshen  up the 2.4 support,  some recent OCF changes and openswan
+	changes are not that old-os friendly.
+	
+	Force OCF to select HW/SW,  otherwise it may get stuck on the first
+	device.  This change means we will favour HW over SW,  but we will
+	use both as required.  Passing in a crid of 0 to crypto_newsession
+	effectively meant we were stuck on the first device registered with
+	OCF,  not good.  This only applied to ipsec,  cryptodev already did
+	the right thing.
+
+2008-01-31 07:37  gerg
+
+	* hifn/hifn7751.c: 
+	
+	The linux-2.6.24 modules build fails if the pci ID table doesn't
+	have a NULL entry at the end. So add one.
+
+2008-01-29 09:16  gerg
+
+	* cryptosoft.c, ocf-compat.h: 
+	
+	Added some compatability macros for scatterlist changes from 2.6.24
+	onwards.
+
+2007-12-16 07:31  davidm
+
+	* Makefile: 
+	
+	missed an openssl patch name change
+
+2007-12-16 07:27  davidm
+
+	* Makefile, README, README.sglinux, patches/linux-2.6.23-ocf.patch,
+	patches/openssl-0.9.8e.patch, patches/openssl-0.9.8g.patch,
+	patches/ssl.patch: 
+	
+	updates for a new ocf release and associated bits
+
+2007-12-16 06:36  davidm
+
+	* crypto.c: 
+	
+	Be very careful what you do while potentially in an driver unload
+	state or we will call through NULL pointers.
+	
+	Reported by Nawang Chhetan .
+
+2007-12-14 22:32  davidm
+
+	* cryptodev.c: 
+	
+	Add in an unlock_ioctl when available to help SMP systems a lot. 
+	Otherwise all ioctls get a BKL :-(
+	
+	Problem found by Egor N. Martovetsky 
+
+2007-12-14 18:29  davidm
+
+	* cryptosoft.c: 
+	
+	reformat the alg table to make it easier to read.
+
+2007-12-14 18:29  davidm
+
+	* crypto.c: 
+	
+	Fix more driver locking/sleeping bugs report by Nawang Chhetan
+	
+
+2007-12-12 21:36  davidm
+
+	* Config.in, Kconfig, Makefile, pasemi/Makefile, pasemi/pasemi.c,
+	pasemi/pasemi_fnu.h: 
+	
+	Here I'm including my PA Semi driver patch to OCF.  Please consider
+	it for inclusion into next OCF release.
+	
+	Egor N. Martovetsky 
+
+2007-12-05 00:37  davidm
+
+	* patches/: linux-2.4.35-ocf.patch, linux-2.6.22-ocf.patch: 
+	
+	More correct count setting if we get a signal
+	
+	Adrian Hoban 
+
+2007-12-05 00:02  davidm
+
+	* random.c: 
+	
+	OCF has a static array for holding random data. The random number
+	generator I have can write directly into physically contiguous
+	memory. Static memory comes from the heap and isn't physically
+	contiguous. I could use kmalloc'd memory and then copy into the OCF
+	static buf but I'd like to avoid a memory copy. The following patch
+	(Physically_Contig_Rand.patch) allows me to avoid a memory copy and
+	should not impact the other OCF drivers:
+	
+	Adrian Hoban 
+
+2007-12-05 00:01  davidm
+
+	* Kconfig: 
+	
+	Fix a typo in the Kconfig
+
+2007-11-23 19:15  davidm
+
+	* talitos/talitos_dev.h: 
+	
+	fix the DPRINTF macro so that it actually compiles.
+
+2007-11-22 19:41  davidm
+
+	* ocf-compat.h, talitos/talitos.c, talitos/talitos_dev.h: 
+	
+	Various updates to get talitos compiling and work on real-world (ie
+	ubuntu) kernels.
+
+2007-11-08 02:21  davidm
+
+	* crypto.c: 
+	
+	keep and eye on us being completely blocked.  If we have Q's to
+	process, but all the requests are blocked,  sleep.  We do not want
+	to busy loop until a driver unblocks as it uses valuable CPU
+	resources that could be doing something much more important ;-)
+
+2007-11-07 19:04  davidm
+
+	* hifn/hifn7751.c: 
+	
+	hifn driver was failing to unblock itself under some "out of
+	resources" conditions.	It would return ERESTART to signal it was
+	full but never call crypto_unblock to start things moving again.
+
+2007-11-06 02:09  davidm
+
+	* hifn/hifn7751.c: 
+	
+	Remove some bogus trace left in the driver for the overflow (too
+	busy) case.
+
+2007-10-12 21:10  gerg
+
+	* crypto.c, ixp4xx/ixp4xx.c: 
+	
+	Fix up use of kmem_cache_create() - it takes one less argument in
+	2.6.23 onwards.
+
+2007-10-03 02:41  gerg
+
+	* ixp4xx/Makefile: 
+	
+	The directory locations for includes in CSR-2.4 is different.  Need
+	to modify the CFLAGS accordingly if using CSR-2.4.
+
+2007-09-22 00:39  philipc
+
+	* ixp4xx/Makefile:  linux 2.4 make dep was failing.  This is
+	a quick fix to get it building, need to double check this.
+
+2007-09-19 00:13  mmccreat
+
+	* Config.in:  Add config option CONFIG_OCF_IXP4XX_SHA1_MD5,
+	that enables SHA1 and MD5 hashing to be done by the IXP4xx crypto
+	accelerator (although it is much slower than using cryptosoft).
+
+2007-09-18 21:45  mmccreat
+
+	* Makefile, random.c:  - Force the inclusion of autoconf.h,
+	which contains #defines for CONFIG_xxx	 options for OCF.  -
+	Removing additional -D option, now that we are including the
+	CONFIG_xxx   #defines.
+
+2007-09-18 21:44  mmccreat
+
+	* Kconfig:  Add config option CONFIG_OCF_IXP4XX_SHA1_MD5,
+	that enables SHA1 and MD5 hashing to be done by the IXP4xx crypto
+	accelerator (although it is much slower than using cryptosoft).
+
+2007-09-18 21:37  mmccreat
+
+	* cryptodev.h:  The CRYPTO_MAX_DATA_LEN limit should be
+	0xFFFF ie 64K - 1.
+
+2007-09-18 21:19  mmccreat
+
+	* ixp4xx/ixp4xx.c:  - Rework the code so that the correct IXP
+	function, ixCryptoAccHashPerform(), is	 used to calculate SHA1 and
+	MD5 hashes.    NB: The performance of using the IXP4xx hardware is
+	really, really poor    compared to using cryptosoft (and the kernel
+	crypto).  - Only support SHA1 and MD5 hashing if the
+	CONFIG_OCF_IXP4XX_SHA1_MD5 is	enabled.
+
+2007-08-30 21:42  davidm
+
+	* Makefile: 
+	
+	do not archive build files in the crypto-tools archive
+
+2007-08-22 19:19  mmccreat
+
+	* cryptodev.c:  Fix up the checking for key lengths, when the
+	key can be of unlimited size.
+
+2007-08-16 01:50  davidm
+
+	* Makefile: 
+	
+	Better 2.4 compat for "make dep" now working with fastdep.
+
+2007-07-28 08:25  davidm
+
+	* Makefile, README, README.sglinux, patches/crypto-tools.patch,
+	patches/linux-2.4.29-ocf.patch, patches/linux-2.4.35-ocf.patch,
+	patches/linux-2.6.11-ocf.patch, patches/linux-2.6.22-ocf.patch,
+	patches/ssl.patch: 
+	
+	Update all the patches and put the patch making target back into
+	the Makefile.
+
+2007-07-28 08:25  davidm
+
+	* hifn/hifn7751.c: 
+	
+	fix an unused variable warning when HARVESTING is disabled
+
+2007-07-27 21:33  davidm
+
+	* hifn/hifn7751.c, ixp4xx/ixp4xx.c, safe/safe.c, talitos/talitos.c:
+	
+	
+	Remove all the random code if OCF does not have radom harvesting
+	enabled.
+
+2007-07-26 00:36  davidm
+
+	* Kconfig, hifn/hifnHIPP.c, hifn/hifnHIPPvar.h: 
+	
+	Changes to get the hifn HIPP stub driver to build.
+
+2007-07-25 21:25  davidm
+
+	* Makefile, hifn/Makefile, hifn/hifnHIPP.c, hifn/hifnHIPPreg.h,
+	hifn/hifnHIPPvar.h, ixp4xx/Makefile, ocfnull/Makefile,
+	safe/Makefile, talitos/Makefile: 
+	
+	Bring in the hifnHIPP driver written by Xelerance.  This is the
+	super hifn chip with full protocol offload.
+	
+	Switch to much more traditional Makefile/subdir building.  The
+	Makefiles are nicer now,  but still not beautiful,  2.6 and 2.4
+	capable builds result in a certain amount of uglyiness.
+
+2007-07-24 21:46  davidm
+
+	* cryptodev.c: 
+	
+	Clean up all the driver id checking and session management so
+	adding/removing drivers all continues to run cleanly.
+
+2007-07-24 20:14  davidm
+
+	* talitos/talitos.c: 
+	
+	From: Ahsan Kabir 
+	
+	less than .1% packet corruption was detected using the talitos
+	driver. It turns out we don't need the cipher iv out len/ptr field
+	to do ESP IPsec. Therefore we set the len field as 0, which tells
+	the SEC not to do anything with this len/ptr field.
+	
+	Signed-off-by: Ahsan Kabir 
+	Signed-off-by: Kim Phillips 
+
+2007-07-24 08:25  davidm
+
+	* cryptosoft.c, ocf-bench.c, hifn/hifn7751.c, ixp4xx/ixp4xx.c,
+	safe/safe.c, talitos/talitos.c: 
+	
+	Switch the remaining GFP_ATOMIC to the newer and not deprecated
+	SLAB_ATOMIC
+
+2007-07-23 22:16  mmccreat
+
+	* ixp4xx/ixp4xx.c:  Add missing ";" from end of dprintk()
+	call!
+
+2007-07-21 01:16  davidm
+
+	* ocf-compat.h, rndtest.c, hifn/hifn7751.c, safe/safe.c: 
+	
+	pci_register_driver is nothing like it is depending on the kernel,
+	so we need a compat function to fix it up for all kernels before
+	2.6.10, and in different ways for older and not so older versions.
+
+2007-07-20 21:54  davidm
+
+	* safe/safe.c: 
+	
+	Make the debug macro ';' safe so you do not get compiler warnings
+
+2007-07-20 21:53  davidm
+
+	* talitos/: talitos.c, talitos_dev.h, talitos_soft.h: 
+	
+	update to the latest FreeBSD driver structure and fix up the code
+	as required.
+
+2007-07-20 03:07  davidm
+
+	* rndtest.c: 
+	
+	more headers needed to compile on 2.4
+
+2007-07-20 03:00  davidm
+
+	* cryptosoft.c: 
+	
+	Put in the 2.4 stubs to support compression
+
+2007-07-20 02:53  davidm
+
+	* crypto.c, ocf-compat.h: 
+	
+	move some more compat stuff into the compat header.
+
+2007-07-20 02:47  davidm
+
+	* talitos/talitos.c: 
+	
+	support of_platform_driver for newer, ARCH=powerpc based kernels. 
+	Signed-off-by: Kim Phillips 
+
+2007-07-20 02:46  davidm
+
+	* talitos/talitos.c: 
+	
+	From: Ahsan Kabir 
+	
+	When Talitos completes job both the channel and execution unit are
+	capable of generating interrupts.  Talitos used to take two
+	interrupts per request - one for channel completion and the other
+	for execution unit completion. This patch ensures that Talitos
+	takes interrupt only for channel completion. Execution unit will
+	generate interrupt only when there is error and the error
+	interrupts for execution units are not masked.
+	
+	Signed-off-by: Ahsan Kabir 
+	Signed-off-by: Kim Phillips 
+
+2007-07-20 02:37  davidm
+
+	* cryptodev.c: 
+	
+	Unless the user specifies,  select from both HW and SW.
+	
+	Clean up some debug to report the actual ioctl name.
+	
+	Compiler warning on newer compilers.
+
+2007-07-20 02:35  davidm
+
+	* cryptodev.h: 
+	
+	moved dprintk to the compat code,  seemed nicer in there.
+
+2007-07-20 02:35  davidm
+
+	* rndtest.c: 
+	
+	Need to clean up some warnings etc,  more includes
+
+2007-07-20 02:34  davidm
+
+	* ocf-compat.h, hifn/hifn7751.c, safe/safe.c: 
+	
+	new shared IRQ flags for 2.6.22 and a safer version of the debug
+	macro
+
+2007-07-20 00:52  davidm
+
+	* cryptosoft.c: 
+	
+	Implement compression based on the code from the openswan guys.
+
+2007-07-20 00:52  davidm
+
+	* criov.c: 
+	
+	Fix compiler warning on non-value returning void func.
+
+2007-07-18 22:55  davidm
+
+	* hifn/hifn7751.c, safe/safe.c: 
+	
+	Use pci_register_driver rather than pci_module_init. 
+	pci_module_init has been dropped in 2.6.22 yet pci_register_driver
+	has always existed and used to do some crazy hotplug junk.
+
+2007-07-18 21:55  gerg
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Added a missing ";" at the end of the ixp_kproces() prototype.	It
+	is IXP465 specific, only showed up when generateing for SG720.
+
+2007-07-17 00:37  davidm
+
+	* Makefile, cryptodev.c, random.c, rndtest.c, hifn/hifn7751.c,
+	ocfnull/ocfnull.c, safe/safe.c: 
+	
+	Fixup all the debug support for 2.4 kernels,  clean up the entropy
+	harvester to be far more robust.
+
+2007-07-14 02:19  davidm
+
+	* talitos/talitos.c: 
+	
+	Old patch that had not been applied Kim Phillips
+	
+
+2007-07-14 01:12  davidm
+
+	* Config.in, Kconfig, Makefile, cryptodev.c, cryptodev.h, random.c,
+	syscall.h: 
+	
+	Finally ditched all the syscall stuff.	You can now enable/disable
+	the random harvestor.  Pulled in most of random.c from openswan
+	project and fixed some obvious bugs (that were always there).
+
+2007-07-13 21:59  davidm
+
+	* ocf-compat.h: 
+	
+	Better error printing and checking for drivers
+
+2007-07-13 21:56  davidm
+
+	* cryptosoft.c: 
+	
+	Fix some incorrect debug (reporting wrong error type)
+
+2007-07-13 21:55  davidm
+
+	* hifn/hifn7751.c, safe/safe.c: 
+	
+	Make the code more similar to Free-BSD by reverting to the same
+	debug macros
+
+2007-07-13 21:53  davidm
+
+	* ocfnull/ocfnull.c: 
+	
+	Fix up the null driver to work again in the new framework.
+
+2007-07-06 23:54  mmccreat
+
+	* cryptodev.c, cryptodev.h, cryptosoft.c:  - Update OCF to
+	work with new Crypto API introduced in 2.6.19 kerneli, and add
+	macros so it work with older kernels.  - Add support for SHA256,
+	SHA384 and SHA512 HASH and HMAC algorithms.  - Cryptosoft: Only
+	register algorithms that the kernel has implementations for.
+
+2007-07-03 19:52  davidm
+
+	* Kconfig, README, README.sglinux, criov.c, crypto.c, cryptodev.c,
+	cryptodev.h, cryptosoft.c, ocf-bench.c, ocf-compat.h, random.c,
+	rndtest.c, uio.h, hifn/hifn7751.c, hifn/hifn7751reg.h,
+	hifn/hifn7751var.h, ixp4xx/ixp4xx.c, ocfnull/ocfnull.c,
+	safe/safe.c, safe/safevar.h, talitos/talitos.c: 
+	
+	Updated OCF to the lastest FreeBSD version.
+	
+	There was a lot of change in here,  some of which will help FIP's,
+	some which won't.
+	
+	Did lots of cleaning and diff reduction against the freebsd code. 
+	Still more cleaning to do.
+
+2007-06-01 21:58  gerg
+
+	* Config.in: 
+	
+	Put the regular old Config.in back, needed for puclic releases.
+
+2007-06-01 21:58  gerg
+
+	* Kconfig: 
+	
+	Change the CONFIG_OCF_IXP400 dependencies to be the same as they
+	where in the Config.in file.
+
+2007-05-28 21:40  gerg
+
+	* Config.in, Kconfig: 
+	
+	Switch all module configuration over to new style Kconfigs.
+
+2007-05-24 18:49  davidm
+
+	* cryptodev.c, random.c: 
+	
+	Work around some problems on redhat systems with errno redefinition
+
+2007-04-30 21:09  gerg
+
+	* cryptosoft.c: 
+	
+	The CRYPTO_TFM_MODE_ family of defines no longer exists from 2.6.21
+	onwards. As far as I can tell you don't need to pass it to the
+	crypto_alloc_tfm() function anymore.
+	
+	So define it to be 0 if it doesn't exist.
+
+2007-04-03 02:13  gerg
+
+	* syscall.h: 
+	
+	Added syscall macros for SH architecture. Just temporary, 'till
+	Dave fixes the OCF code to not use syscalls from the modules :-)
+
+2007-02-16 23:10  davidm
+
+	* syscall.h: 
+	
+	ensure the temprary 2.6 fix doesn't break 2.4
+
+2007-02-07 22:23  gerg
+
+	* cryptodev.c, random.c, syscall.h: 
+	
+	Temporary fix for new 2.6 kernels no longer defining in-kernel
+	system call functions. Define them locally for now until we fix
+	properly.
+
+2007-02-07 03:10  gerg
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Changes to support the different INIT_WORK() mechanism from kernels
+	2.6.20 onwards.
+
+2007-02-06 02:38  gerg
+
+	* crypto.c: 
+	
+	Cleaned up use of kmem_cache_t and use of SLAB_ATOMIC.
+
+2006-12-05 20:50  cpascoe
+
+	* hifn/hifn7751.c, safe/safe.c, talitos/talitos.c: 
+	
+	Remove pt_regs from OCF interrupt handlers for 2.6.19+
+
+2006-12-02 03:36  gerg
+
+	* criov.c, crypto.c, cryptodev.c, cryptosoft.c, ocf-bench.c,
+	random.c, rndtest.c, hifn/hifn7751.c, ixp4xx/ixp4xx.c,
+	ocfnull/ocfnull.c, safe/safe.c, talitos/talitos.c: 
+	
+	Can no longer include linux/config.h as of 2.6.19 kernels.  Need to
+	conditionally include it based on AUTOCONF_INCLUDED not being
+	defined.
+
+2006-10-13 21:52  cpascoe
+
+	* random.c: 
+	
+	Remove another race condition that may result in us running more
+	than one random thread if modules are reloaded during heavy system
+	load.
+
+2006-10-13 21:18  cpascoe
+
+	* random.c: 
+	
+	- Permit delivery of SIGKILL to the random thread.  - Do not exit
+	prematurely if poll() is interrupted.  - Improve exit conditions so
+	that we quit immediately, rather than loop   infinitely, if the
+	last RNG source is removed while we are trying to   fill our
+	buffer.
+
+2006-10-03 20:28  cpascoe
+
+	* crypto.c, crypto.c:  AutoMerged
+	>
+	> Zero the empty half of "new driver" buffer, and not past the end
+	of the old
+	> buffer that we are about to free.
+
+2006-10-03 20:28  cpascoe
+
+	* crypto.c: 
+	
+	Zero the empty half of "new driver" buffer, and not past the end of
+	the old buffer that we are about to free.
+
+2006-08-25 23:57  davidm
+
+	* cryptosoft.c: 
+	
+	Do not print errors for failed ALG requests unless debugging
+
+2006-07-14 21:44  davidm
+
+	* cryptodev.h: 
+	
+	2.6.11 and earlier did not have the files_fdtable macro.
+
+2006-06-21 21:26  gerg
+
+	* cryptodev.h, hifn/hifn7751.c, ocfnull/ocfnull.c, safe/safe.c,
+	talitos/talitos.c: 
+	
+	Fixed up more occurrances of MODULE_PARM() needing to be converted
+	to module_param() (as of 2.6.17 and onwards).
+
+2006-06-21 00:28  gerg
+
+	* cryptosoft.c: 
+	
+	Change use of MODULE_PARM to module_param() for 2.6.17+ kernels.
+
+2006-06-20 22:13  gerg
+
+	* crypto.c, cryptodev.c, cryptodev.h, ocf-bench.c, ixp4xx/ixp4xx.c:
+	
+	
+	As of 2.6.17 and onwards module_param is used in place of
+	MODULE_PARM.
+
+2006-06-06 00:31  gerg
+
+	* Makefile: 
+	
+	Fix Makefile to find includes is using CSR-2.1.
+
+2006-05-31 01:44  gerg
+
+	* cryptodev.h: 
+	
+	The vars "crypto_usercrypto", "crypto_userasymcrypto" are declared
+	as extern in the header file, but static in the c file. I guessed
+	that they should probably be truely static, so removed the extern
+	declarations from the header.
+
+2006-05-25 21:06  davidm
+
+	* talitos/talitos.c: 
+	
+	This fixes a situation that I never provably experienced, where a
+	descriptor in memory may be reserved within the proper lock, and
+	freed immediately after, only for a few cycles, right outside the
+	lock.  Kim Phillips 
+
+2006-05-15 19:49  davidm
+
+	* criov.c, crypto.c, cryptodev.c, cryptodev.h, cryptosoft.c,
+	ocf-bench.c, random.c, rndtest.c, uio.h, ixp4xx/ixp4xx.c: 
+	
+	Remove the "all rights reserved" from the Intel copyrights.
+
+2006-05-12 21:19  davidm
+
+	* Config.in, Kconfig, Makefile, cryptodev.c, ocf-bench.c,
+	ocfnull/ocfnull.c: 
+	
+	Add in a null OCF driver that does nothing at all,  useful for
+	measuring the cost of various parts of the ipsec stack.
+
+2006-05-12 21:17  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	make sure we do not overwrite a correctly set error type.
+
+2006-05-12 06:52  davidm
+
+	* crypto.c: 
+	
+	Fix a problem where a driver would return ERESTART (full) but then
+	unblock itself before the upper layer had marked it as blocked. 
+	This caused the code to get stuck in crypto_proc and process no
+	more requests.
+
+2006-05-12 06:47  davidm
+
+	* cryptosoft.c: 
+	
+	Implement CRD_F_KEY_EXPLICIT for cryptosoft so keys can be changed
+	on an active session.
+
+2006-05-10 20:09  davidm
+
+	* README, criov.c, crypto.c, cryptodev.h, cryptosoft.c,
+	ocf-bench.c, random.c, rndtest.c, uio.h, hifn/hifn7751.c,
+	ixp4xx/ixp4xx.c, safe/safe.c, safe/safevar.h: 
+	
+	update email addresses and other house cleaning
+
+2006-05-10 20:08  davidm
+
+	* cryptodev.c: 
+	
+	pull in better error checking from openswan modifications
+
+2006-05-10 19:11  davidm
+
+	* cryptosoft.c: 
+	
+	Fix an unused variable warning when various options are disabled.
+
+2006-05-10 19:10  davidm
+
+	* cryptodev.h: 
+	
+	Add support for 2.4 kernels for the new FD cloning operation
+
+2006-05-09 19:48  davidm
+
+	* hifn/hifn7751.c: 
+	
+	remove the hifn 7855 support,  this driver will never work with
+	that chip.
+
+2006-05-08 23:34  davidm
+
+	* hifn/hifn7751var.h: 
+	
+	Contiguous buffer support so that ocf-bench can run properly.
+
+2006-05-05 23:21  davidm
+
+	* hifn/hifn7751.c: 
+	
+	Add in contiguous buffer support so that ocf-bench and run on the
+	driver.
+
+2006-05-05 23:14  davidm
+
+	* ocf-bench.c: 
+	
+	Our requests were out of order,  need to do crypto then auth on
+	encrypt requests.  Some drivers enforce this.
+
+2006-05-04 23:21  davidm
+
+	* crypto.c: 
+	
+	Do not run "newsession" with lock,  since newsession may sleep on
+	some targets.  Handle the accounting so that things are not pulled
+	from underneath us.
+
+2006-05-04 23:20  davidm
+
+	* cryptodev.c: 
+	
+	Switch to a less optimal (marginally) solution for creating a new
+	fd that appears to work in far more versions of the kernel
+	including 64bit versions.
+
+2006-05-04 18:54  davidm
+
+	* ocf-bench.c: 
+	
+	Turn off the IXP access lib benchmarking by default as most people
+	don't have it.
+	
+	Paul Wouters 
+
+2006-04-01 08:23  davidm
+
+	* Makefile: 
+	
+	Remove more temp files when cleaning
+
+2006-04-01 08:12  davidm
+
+	* hifn/hifn7751reg.h: 
+	
+	7855 PCI id's as yet untested
+
+2006-04-01 08:08  davidm
+
+	* hifn/hifn7751.c: 
+	
+	add PCI id's for the 7855 and AES support,  card is untested still
+	as it requires 128MB of PCI memory !
+
+2006-03-31 08:38  davidm
+
+	* README.sglinux: 
+	
+	small update to instructions with corrected patch name
+
+2006-03-31 00:23  davidm
+
+	* Config.in: 
+	
+	Add the Talitos driver to the 2.4 config,  even though it probably
+	won't compile.
+
+2006-03-30 07:48  davidm
+
+	* Kconfig, Makefile, talitos/talitos.c, talitos/talitos_dev.h,
+	talitos/talitos_soft.h: 
+	
+	Please find attached the freescale SEC driver for OCF.	It's been
+	(most recently) tested on an SEC2.0 based MPC8541E
+	(cryptographically identical to the MPC8555E) under 2.6.15.2, with
+	openssl-0.9.8a and openswan-2.4.3 (2.4.5rc5 won't keep the security
+	association up for me for some reason).
+	
+	Please feel free to add it to your next release of OCF-Linux :-)
+	
+	Kim Phillips 
+
+2006-03-20 19:34  davidm
+
+	* safe/: safe.c, safevar.h: 
+	
+	Safenet 1141 v1.0 chips have a DMA lockup error if you access the
+	chip while DMA'ing.  As a work around you need to limit your DMA to
+	256 byte chunks using scatter/gather descriptors.  All the SG/SME
+	products have v1.0 chips and would lockup with more than two
+	outstanding packets at one time.
+	
+	Fix the KASSERT macro
+	
+	Add some more exhaustive initialisation.
+
+2006-03-15 21:58  davidm
+
+	* cryptodev.h, random.c: 
+	
+	Switch random support to "ints" since that is what the kernel uses
+	and not using the same thing is 64bit wise a bad idea.
+	
+	Fix FIP's code to ensure correct amount of data is passed in.
+	
+	Add work around for broken 64bit OS RNG support (disable it)
+	
+	General code cleanups.
+
+2006-03-15 21:55  davidm
+
+	* hifn/hifn7751.c: 
+	
+	Fixes for 64bit OS's,  make sure PCI address are within bus space,
+	make sure we order writes to the bus so that chip functions
+	correctly.  Some small cleanups.
+
+2006-03-15 21:48  davidm
+
+	* hifn/hifn7751var.h: 
+	
+	Remove unused field from structure
+
+2006-03-15 21:47  davidm
+
+	* safe/safe.c: 
+	
+	Make the code more 64bit OS compatible,  force PCI address space
+	and so on.
+
+2006-03-09 20:42  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	If we call ixpCryptoAccInit() and it fails,  just assume that it
+	has already been called.  This allows our "rc" scripts to be
+	openswan and freeswan compatible ore easily.
+
+2006-02-28 23:21  davidm
+
+	* README: 
+	
+	generalise it a bit so rel-dates don't get in the way
+
+2006-02-28 01:52  davidm
+
+	* README, patches/ssh.patch, patches/ssl.patch: 
+	
+	Updated the README and patches for a release
+
+2006-02-25 09:21  davidm
+
+	* README, README.sglinux: 
+	
+	updates for a new release of OCF,  ssl patches and so on.
+
+2006-02-25 08:44  davidm
+
+	* crypto.c: 
+	
+	We were calling the "process"routines with interrupts disabled.  I
+	can see no good reason for this and it provokes badness warnings in
+	2.6 under some conditions.
+	
+	I am going to run with the Q's unlocked for processing,  and
+	hopefully it will allow the system to be more responsive.  It
+	hasn't affected ipsec throughput in any way.  Userland throughput
+	(multi threaded) may have improved significantly though,  but it
+	needs more testing.
+
+2006-02-24 23:32  davidm
+
+	* cryptodev.c: 
+	
+	Whoa,  set the segments with uninitted values can't be good.  Clean
+	out the rest of the old code that was accidently left in.
+
+2006-02-22 01:02  davidm
+
+	* cryptodev.c: 
+	
+	Still not sure about this one,	but this is working for all the
+	cases I can see so far.  If it gets weird,  I am going to switch to
+	a simple clone and chain the sessions rather than a new fcr per fd.
+
+2006-02-20 22:12  davidm
+
+	* cryptodev.c: 
+	
+	Error handling case could free data that was not allocated
+	
+	Ronen Shitrit  Marvell Semiconductor Israel
+	Ltd
+
+2006-02-20 21:57  davidm
+
+	* cryptosoft.c: 
+	
+	Proper SHA/MD5 (non hmac) implementation,  remove some retrictions
+	for hashes (which only applied to crypto) and fix over zealous
+	error checking.
+	
+	Ronen Shitrit  Marvell Semiconductor Israel
+	Ltd
+
+2006-02-09 21:15  davidm
+
+	* cryptodev.c: 
+	
+	The code wasn't quite right and needed some fixing for proper file
+	accounting.
+
+2006-01-24 20:08  davidm
+
+	* crypto.c, cryptodev.c, hifn/hifn7751.c: 
+	
+	We implement our own open in the CRIOGET ioctl now which does
+	pretty much the same thing as the BSD version,	rather than use an
+	open system call which gets caught out by chroot.
+
+2006-01-06 00:42  gerg
+
+	* cryptosoft.c: 
+	
+	Moved "{" block marker inside the set of
+	"defined(CONFIG_CRYPTO_HMAC) || defined(CONFIG_CRYPTO_HMAC_MODULE)"
+	code (in function swcr_process) so that it compiled if these where
+	not defined.
+
+2005-11-11 01:44  davidm
+
+	* Makefile, README: 
+	
+	cleanups for a general release of OCF
+
+2005-11-11 01:18  davidm
+
+	* patches/ssl.patch: 
+	
+	Updated the ssl patch to the latest and greatest changed we have
+	made.
+
+2005-11-10 21:41  davidm
+
+	* Makefile, ixp4xx/ixp4xx.c: 
+	
+	Better debug for bad input.
+	
+	Have make clean do more cleaning and less talking.
+
+2005-11-03 20:53  davidm
+
+	* cryptosoft.c: 
+	
+	clean up some compilation errors with various options on/off
+
+2005-10-25 00:25  davidm
+
+	* Makefile: 
+	
+	Add a patch target that generates full kernel patches to add OCF
+	into either a 2.4 or 2.6 kernel as a single patch.
+
+2005-10-25 00:24  davidm
+
+	* Kconfig: 
+	
+	Make sure all OCF settings depend on OCF_OCF
+
+2005-09-23 02:45  davidm
+
+	* README, README.sglinux: 
+	
+	new crypto-tools archive to keep the tools up to date
+
+2005-09-23 02:08  davidm
+
+	* Makefile, README, README.sglinux: 
+	
+	updates for doing OCF releases
+
+2005-09-23 01:59  davidm
+
+	* patches/: ssh.patch, ssl.patch: 
+	
+	updated the patches for the latest in fixes etc to ssh/ssl for a
+	new OCF release before the openswan 2.4.1 merge.
+
+2005-09-21 00:57  davidm
+
+	* Makefile, cryptosoft.c, hifn/hifn7751.c, ixp4xx/ixp4xx.c: 
+	
+	Fixes for building cleanly under 2.6
+
+2005-09-13 23:11  davidm
+
+	* ocf-bench.c: 
+	
+	Add an exit function for cleaner 2.6 support.  Patch from Ronen
+	Shitrit 
+
+2005-07-30 00:23  davidm
+
+	* cryptosoft.c: 
+	
+	Add proper hooks for MD5/SHA and their HMAC countrparts processing
+	from cryptodev.
+
+2005-07-29 01:50  davidm
+
+	* cryptodev.c: 
+	
+	cryptodev did not support MD5 and SHA1,  only the HMAC versions
+
+2005-07-29 01:05  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	register for MD5,  return 16 bytes for MD5 and 12 for MD5_HMAC, 
+	likewise for SHA1 (only 20 is not HMAC).
+
+2005-07-28 21:52  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	First pass fix of userland MD5 processing.  We now do as well as
+	the safenet does,  I think.
+
+2005-07-27 06:23  davidm
+
+	* cryptodev.c: 
+	
+	udelay doesn't give up the current thread, thus the kernel will get
+	locked if a process is killed but the hardware never completes the
+	crypto request.
+
+2005-07-22 02:07  davidm
+
+	* crypto.c, cryptodev.h: 
+	
+	Implement queuing limits for input/output and OCF requests.
+	
+	Implement 2.6 style work queues instead of the 2.4 task_queues.
+
+2005-07-21 20:42  davidm
+
+	* cryptodev.h, ocf-bench.c, ixp4xx/ixp4xx.c: 
+	
+	Fix OCF to use work queues,  add 2.4 version of work queues to
+	cryptodev.h for use in ipsec and elsewhere.
+	
+	Problem and initial patch provided by David Vrabel
+	.  Cleaned up and 2.4 support added by me.
+
+2005-07-21 19:08  davidm
+
+	* random.c: 
+	
+	Fix spinlock initialisation, problem reported by Andy @
+	windsorcarclub.co.uk.
+
+2005-07-20 20:24  davidm
+
+	* cryptodev.c: 
+	
+	fix a silly spelling mistake
+
+2005-07-08 00:56  gerg
+
+	* Makefile: 
+	
+	Only build ocf-bench when CONFIG_OCF_BENCH is acrually enabled.
+
+2005-06-27 20:29  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Ok,  we need a simple implentation here or we go too slow for UDP
+	tests.	For now,  if the Q is full just ditch the packet,  someone
+	has to do it.
+
+2005-06-25 01:13  davidm
+
+	* safe/safe.c: 
+	
+	bytes swapping etc all seems wrong for safenet on BE,  these fixes
+	see both MD5 and SHA1 working with OpenSwan.
+
+2005-06-22 23:10  davidm
+
+	* random.c: 
+	
+	clean up some ifdef code a little
+
+2005-06-22 21:28  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Make sure we do not call blocking functions from ISR callable
+	routines.  In this case we were calling ixCryptoAccCtxUnregister.
+	
+	Run all the random numbers through SHA1 process to ensure more
+	uniform distribution of bits (NOTE:  it is not more random in any
+	way)
+
+2005-06-21 00:11  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	do not process requests from the register callback, gets the AES
+	code all messed up.
+	
+	Align caches on HW cache boundaries ot improve speed.
+	
+	More tracking or potential errors.
+
+2005-06-15 01:55  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	technically ixCryptoAccCtxRegister cannot be called from IRQ
+	context, so run it from the immediate BH.
+
+2005-06-14 23:13  davidm
+
+	* ocf-bench.c: 
+	
+	Fix some compile warnings/errors
+
+2005-06-14 20:52  davidm
+
+	* Config.in, Kconfig, Makefile, ocf-bench.c: 
+	
+	Add in kernel benchmark driver
+	
+	Support for building under CSR 1.4 and 2.0 is now complete
+
+2005-06-14 20:51  davidm
+
+	* crypto.c: 
+	
+	Do not use immediate processing for SW drivers otherwise we hold a
+	lock for too long.  Instead force BATCH processing.
+	
+	Problem found by David Vrabel 
+
+2005-06-14 20:46  davidm
+
+	* cryptodev.c: 
+	
+	Fix up AES minimum key size
+	
+	Make some more variables static
+
+2005-06-14 20:36  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Use kernel caches as they are more efficient and faster to obtain.
+	
+	Fix some spelling
+	
+	Tune PKE to only use the space required.  Turn off go fast options
+	to reduce any speed-related cracking.
+	
+	Only zero data that needs to be zeroed (save some cycles)
+
+2005-06-02 21:42  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Added optimisations ideas from Intel the improve the PKE
+	performance for 512 and 1024 bits operations.
+
+2005-06-01 02:13  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Looks like I found the ixp bug.  Using OSAL buffer routines on
+	non-OSAL buffers is a very very bad thing to do.  Must double check
+	all the API's I am using (ie., PKE) just to be sure.
+
+2005-05-31 21:38  davidm
+
+	* Config.in, Kconfig: 
+	
+	Updated/Added the menu wrapper for the config options
+
+2005-05-31 21:18  gerg
+
+	* Config.in: 
+	
+	Reworked the config.in so that each sub-module has its own
+	Config.in.  That way it is easier to make release trees with some
+	modules left in.
+
+2005-05-30 19:46  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	Not all the Pke code was appropriately ifdef'd
+
+2005-05-28 01:49  davidm
+
+	* cryptosoft.c: 
+	
+	We were not injecting data in the right places nor calling the
+	cipher code the best was under all situations.	We are now good
+	enought to do ESP/AH processing with 3DES and SHA1-HMAC.
+
+2005-05-28 01:42  davidm
+
+	* hifn/hifn7751.c: 
+	
+	Non atomic kmallocs at IRQ time are bad and cause lockups
+
+2005-05-21 08:31  davidm
+
+	* README, README.sglinux: 
+	
+	Some small updates to email and patches that no longer exist
+
+2005-05-21 08:25  davidm
+
+	* cryptosoft.c: 
+	
+	better error message on failure,  a lot of the error check we do
+	sems to break apps like cryptotest, not sure who is right yet.
+
+2005-05-21 00:55  davidm
+
+	* criov.c, crypto.c, cryptodev.c, cryptodev.h, cryptosoft.c,
+	random.c, rndtest.c, uio.h, hifn/hifn7751.c, ixp4xx/ixp4xx.c,
+	safe/safe.c, safe/safevar.h: 
+	
+	Convert to CyberGuard email addresses for OCF files.
+
+2005-05-21 00:28  davidm
+
+	* crypto.c, cryptodev.c, cryptosoft.c, hifn/hifn7751.c,
+	ixp4xx/ixp4xx.c, safe/safe.c: 
+	
+	final round of naming changes,	hifn driver also confirmed working
+	in SG710
+
+2005-05-20 23:50  davidm
+
+	* cryptosoft.c, random.c, uio.h, ixp4xx/ixp4xx.c: 
+	
+	more copyright/author updates etc for Intel
+
+2005-05-20 23:48  davidm
+
+	* criov.c, crypto.c, cryptodev.c, cryptodev.h, cryptosoft.c,
+	random.c, rndtest.c, uio.h, ixp4xx/ixp4xx.c, safe/safe.c,
+	safe/safevar.h: 
+	
+	updated copyrights to reflect Intels interest/investment in the
+	project
+
+2005-05-20 20:31  davidm
+
+	* hifn/: hifn7751.c, hifn7751var.h: 
+	
+	Most of a working SKB implementation now
+
+2005-05-20 20:30  davidm
+
+	* safe/: md5.c, md5.h, safe.c, sha1.c, sha1.h: 
+	
+	Full AH/ESP processing now working,  just added BSD sha/md5
+	routines as needed for now.
+
+2005-05-20 20:30  davidm
+
+	* random.c: 
+	
+	use the new BSD rndtest code rather than the old GPL fips code
+
+2005-05-20 20:28  davidm
+
+	* Makefile, fips.c, fips.h, rndtest.c, rndtest.h: 
+	
+	Get rid of the GPL version of the fips test and use a BSD licensed
+	version so no one can get upset and cry derivative :-)
+
+2005-05-20 08:19  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	High throughput improvements. Can now handle multiple simultaneous
+	requests.
+
+2005-05-20 00:55  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	
+	works with openswan/OCF for ipsec receive.
+	
+	fixes ESP/AUTH processing (esp. HMAC)
+	
+	This driver needs a rework for kernel IPSEC as it's current packet
+	at a time processing is not up to the task.
+
+2005-05-20 00:53  davidm
+
+	* cryptosoft.c: 
+	
+	working ESP/AUTH code now impleneted.  Can do RX processing for
+	openswan KLIPS.
+	
+	Fixes numerous problems in skb processing
+	
+	Fixes broken HMAC code and IV processing
+
+2005-05-14 01:44  davidm
+
+	* cryptodev.c, ixp4xx/ixp4xx.c: 
+	
+	Cleanup IXP key processing to guarantee only a single outstanding
+	request rather than relying on the intel driver to get it right. 
+	Stops us losing requests.
+	
+	Tighten up the cryptodev response to "no answer" so that we don't
+	take all the CPU.  Only happens if there is a driver bug.
+
+2005-05-14 00:07  davidm
+
+	* Config.in, Kconfig, Makefile, crypto.c, fips.c, fips.h, random.c,
+	ixp4xx/ixp4xx.c, tools/bench-ocf: 
+	
+	PKE and RNG support running on the ixp driver,	added PKE bench
+	marking to script.  Still some multi-thread problems in the PKE
+	code.
+	
+	Added FIP RNG checking option to config and code.
+
+2005-05-10 19:18  davidm
+
+	* Makefile, ixp4xx/ixp4xx.c: 
+	
+	Get the OCF stuff building for the 465 and CSR-2.0
+
+2005-04-27 19:18  davidm
+
+	* cryptodev.h, random.c, hifn/hifn7751.c, safe/safe.c: 
+	cleanup the random number interface some more
+
+2005-04-27 00:57  davidm
+
+	* cryptodev.h, cryptosoft.c, random.c, hifn/hifn7751.c,
+	ixp4xx/ixp4xx.c, patches/linux-2.4.29-add_true_randomness.patch,
+	patches/linux-2.6.11-add_true_randomness.patch, safe/safe.c,
+	safe/safevar.h: 
+	
+	Switch to a more "user" like random number handling.  Drivers no
+	longer poll for RNG data,  we pull it as needed to fill
+	/dev/random's entropy.
+	
+	Implement sk_buff handling within the OCF framework.
+	
+	fixup IV handling in cryptosoft.
+
+2005-04-27 00:41  davidm
+
+	* crypto.c: 
+	
+	Fix a race condition with the starting of kernel threads.  The
+	threads were running before the pid assignment in the parent.
+
+2005-03-24 23:57  davidm
+
+	* Makefile: 
+	include crypto-tools.patch in the release file
+	
+	
+
+2005-03-24 20:14  davidm
+
+	* safe/safe.c: 
+	Fixup compile time warnings due to some left over BSDisms
+	
+
+2005-03-24 00:53  davidm
+
+	* Makefile, README, README.sglinux, patches/linux-2.4.29-ocf.patch,
+	patches/linux-2.6.11-ocf.patch, patches/ocf-linux-2.4.29.patch,
+	patches/ocf-linux-2.6.11.patch: 
+	added cleaner patch names and a tarball target to aid releases
+	
+
+2005-03-24 00:28  davidm
+
+	* patches/crypto-tools.patch,
+	patches/linux-2.4.29-add_true_randomness.patch,
+	patches/linux-2.6.11-add_true_randomness.patch,
+	patches/ocf-linux-2.4.29.patch, patches/ocf-linux-2.6.11.patch,
+	patches/ssh.patch, patches/ssl.patch, tools/bench-ocf: 
+	move all the release file patches into CVS for simplicity
+	
+
+2005-03-23 20:37  davidm
+
+	* safe/safe.c: 
+	remove excessive debug from RNG routines so that you can turn on
+	debug and live through it
+	
+	
+
+2005-03-23 02:23  davidm
+
+	* safe/safe.c: 
+	fix memory corruption for mod_exp and the safenet,  we were copying
+	back more than the space available.
+	
+	
+
+2005-03-22 21:45  davidm
+
+	* crypto.c, cryptodev.c, cryptodev.h, safe/safe.c: 
+	fixup a major sync issues with key processing (callback called
+	before sleeping).  Improve its performance while we are there with
+	a CBIMM (callback immediate) option.
+	
+	
+
+2005-03-19 00:33  davidm
+
+	* random.c: 
+	A new randomness function for both 2.4 and 2.6 that replaces out
+	previous old solution for the hifn driver with more generic code
+	that works on both kernels.
+	
+		add_true_randomness(u_int32_t *buf, int nwords);
+	
+	
+
+2005-03-18 21:01  davidm
+
+	* Makefile, cryptodev.h, random.c, hifn/hifn7751.c, safe/safe.c: 
+	RNG support in both the safenet and the hifn plus the required
+	kernel support.
+	
+	"hd /dev/random" runs much much faster now :-)
+	
+	
+
+2005-03-17 23:29  toby
+
+	* cryptodev.c:  Make sure the CIOCASYMFEAT ioctl on
+	/dev/crypto copies out the capable features.
+
+2005-03-17 01:19  davidm
+
+	* safe/: safe.c, safereg.h, safevar.h: 
+	hardware PK acceleration on the safenet (CRK_MOD_EXP only)
+	
+
+2005-03-16 04:28  davidm
+
+	* criov.c, crypto.c, cryptodev.c, safe/safe.c: 
+	fixup the FBSD id stuff to compile :-) 
+
+2005-03-16 04:02  davidm
+
+	* README, README.sglinux, TODO: 
+	Updated with versions,	removed tabs,  new kernel versions, web
+	site etc 
+
+2005-03-16 03:45  davidm
+
+	* criov.c, crypto.c, cryptodev.c, cryptodev.h: 
+	more license formatting and version id's to help keep in touch with
+	FreeBSD 
+
+2005-03-16 03:16  davidm
+
+	* safe/safe.c: 
+	up to date with FreeBSD versioning, no changes to merge 
+
+2005-03-16 03:15  davidm
+
+	* safe/safe.c: 
+	include FreeBSD version info so I can track changes better
+	
+
+2005-03-16 03:11  davidm
+
+	* hifn/: hifn7751.c, hifn7751reg.h, hifn7751var.h: 
+	incorporate latest updates from FreeBSD:
+	
+	| Update support for 795x parts: | o rework pll setup code to
+	follow h/w specification | o add hint.hifn.X.pllconfig to specify
+	reference clock setup |   requirements; default is pci66 which
+	means the clock is |   derived from the PCI bus clock and the card
+	resides in a |	 66MHz slot | | Tested on 7955 and 7956 cards;
+	support for 7954 cards not enabled | since we have no cards to test
+	against.
+	
+	
+
+2005-03-16 02:50  davidm
+
+	* Config.in, Kconfig, README, crypto.c, cryptodev.c, cryptodev.h,
+	hifn/hifn7751.c, hifn/hifn7751var.h, safe/safe.c, safe/safevar.h: 
+	cleanups to build and run on 2.6.11 and 2.4.29 for a public release
+	
+	included configs locally to reduce patch to kernel and required
+	user effort.
+	
+	pci_dma_sync_single fix from Michele Baldessari
+	,	with modifications by me to work on all
+	kernels.
+	
+	
+
+2005-03-11 23:30  davidm
+
+	* Makefile: 
+	fix up the compiling again, I had outstanding commits for this one
+	:-) 
+
+2005-03-11 21:56  danield
+
+	* Makefile: Get ocf modules building again.  
+
+2004-12-25 07:12  davidm
+
+	* TODO: 
+	safenet is all good now AKAIK 
+
+2004-12-25 07:02  davidm
+
+	* Makefile, crypto.c, cryptodev.c, cryptosoft.c, uio.h: 
+	2.6 port of the OCF framework,	tested on Xscale and compiled for
+	x86
+	
+	
+
+2004-12-10 02:41  davidm
+
+	* hifn/hifn7751.c: 
+	Fix compilation as l_flags was not defined for LOCK in pci_remove
+	
+
+2004-12-06 19:15  davidm
+
+	* hifn/hifn7751.c, safe/safe.c: 
+	* Put locking into hifn_remove to ensure interrupts are not running
+	while we   remove the driver
+	
+	  Use del_timer_sync (need to ensure timer is not running on
+	another CPU
+	* when we delete it).
+	
+	Improvements suggested by Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+	
+
+2004-12-02 09:16  davidm
+
+	* README, README.sglinux: 
+	* Fix up all tabs to be spaces * explain how to update the ocf
+	support in the patch to the current version.
+	
+	
+
+2004-12-02 09:11  davidm
+
+	* README: 
+	* fix some spelling/grammar * add more info on the ssl.patch file
+	and what it contains 
+
+2004-12-02 09:08  davidm
+
+	* README.sglinux: 
+	give some more instructions on the shar archive and extracting the
+	release.  
+
+2004-12-02 09:03  davidm
+
+	* README.sglinux: 
+	how to include crypto-tools into 3.1.6
+	
+	
+
+2004-12-02 08:48  davidm
+
+	* README.sglinux: 
+	updated for a new crypto patch for openssl-0.9.7e 
+
+2004-12-02 08:04  davidm
+
+	* README, README.sglinux: 
+	Clean up the README's to use the new SG Linux alpha and a specific
+	2.4.28 patch.
+	
+	
+
+2004-12-01 23:11  davidm
+
+	* Makefile, criov.c, crypto.c, cryptodev.c, cryptosoft.c,
+	hifn/Makefile, hifn/hifn7751.c, ixp4xx/Makefile, ixp4xx/ixp4xx.c,
+	safe/Makefile, safe/safe.c: 
+	Re-worked the Makefiles so that including the code into a standard
+	non-SG kernel is really easy.
+	
+	Fixed a non-initialised bug that was introduce into cryptosoft.c
+	with the additional error checking.
+	
+	
+
+2004-12-01 01:54  davidm
+
+	* TODO: 
+	updates based on things that have been fixed.  
+
+2004-12-01 01:53  davidm
+
+	* safe/: safe.c, safevar.h: 
+	Cleanup some old hacks based on the much cleaner port of the hifn
+	driver.  
+
+2004-12-01 01:53  davidm
+
+	* cryptosoft.c: 
+	fix some crashes due to bad buffer sizes etc.  
+
+2004-11-27 09:16  davidm
+
+	* crypto.c, cryptodev.c, ixp4xx/ixp4xx.c: 
+	Fixed some nasty problems that were stopping reliable behaviour:
+	
+	1) we were not initialising some of our lists/wait queues,  which  
+	 meant they appears to have things in them when in fact they did
+	not.	 This actually didn't seems to cause any problems but is
+	extremely bogus.
+	
+	2) While a process was waiting for the crypto engine,  if
+	itreceived a	signal we would lose sync with the engine and end
+	up allowing out-of-band    actions that were invalid (ie.,
+	unregistering a context that was still	  active in a crypto
+	operation).
+	
+	   Of source the CryptACC should probably deal with this as well
+	;-)
+	
+	
+
+2004-11-26 01:33  davidm
+
+	* TODO: 
+	We should also hook in the random number generators to linux
+	
+
+2004-11-26 01:33  davidm
+
+	* hifn/hifn7751.c: 
+	Changed all the accesses to DMS descriptors to not set the valid
+	bit until after everything else was set.  This got the driver
+	running smoothly, along with a fixup to the pci_map_uio which
+	wasn't settings lengths correctly.
+	
+	
+
+2004-11-25 21:15  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	document why using a new context for each packet is actually a
+	better idea than allocating one (actually two) per session.
+	
+	
+
+2004-11-25 08:48  davidm
+
+	* README, README.sglinux: 
+	updates from email with Intel to fix a few little things
+	
+
+2004-11-25 00:02  davidm
+
+	* README, README.sglinux, safe/safe.c: 
+	Some cleanups of doc and so on for Intel/General use 
+
+2004-11-23 07:58  davidm
+
+	* TODO: 
+	safenet is working on big endian machines now
+	
+	
+
+2004-11-23 07:56  davidm
+
+	* ixp4xx/: Makefile, ixp4xx.c: 
+	Reference the Intel library,  cleanup the IV sizes and turn on AES.
+	 Fix Makefile for new config options.
+	
+	
+
+2004-11-23 07:52  davidm
+
+	* Makefile: 
+	Complete the changes of ixp to ixp4xx (IXP4xx) as appropriate
+	
+
+2004-11-23 00:33  davidm
+
+	* Makefile, README, ixp4xx/Makefile: 
+	Changes all references to ixp to be ixp4xx at Intels request
+	
+
+2004-11-20 01:07  davidm
+
+	* safe/: safe.c, safereg.h: 
+	fully working safenet on BE machines 
+
+2004-11-19 01:03  davidm
+
+	* Makefile, hifn/Makefile, hifn/hifn7751.c, hifn/hifn7751reg.h,
+	hifn/hifn7751var.h: 
+	hifn driver code complete and compiling,  needs a test now ;-)
+	
+
+2004-11-18 21:45  davidm
+
+	* hifn/: Makefile, hifn7751.c, hifn7751var.h: 
+	Makefile for building the hifn driver 
+
+2004-11-18 21:44  davidm
+
+	* hifn/: hifn7751.c, hifn7751reg.h, hifn7751var.h: 
+	Checkin the orginal freebsd source for the hifn driver as a
+	reference in the future.
+	
+	
+
+2004-11-18 10:05  davidm
+
+	* Makefile, README, TODO, criov.c, crypto.c, cryptodev.c,
+	cryptodev.h, cryptosoft.c, uio.h, ixp4xx/Makefile, ixp4xx/ixp4xx.c,
+	safe/Makefile, safe/safe.c, safe/safevar.h: 
+	Clean up license and copyright info to be more acceptable (and
+	present) Clean up debug and trace Fixup memory freeing etc on
+	safenet Fix compiler warnings (some were bugs)
+	
+	
+
+2004-11-17 02:23  davidm
+
+	* safe/safe.c: 
+	working on Xscale (big endian) now but packet data is getting
+	stuffed up due to endian problems (at least now we are talking to
+	the chip correctly for BE).  Good enough to test packet throughput,
+	 no good for testing scp.
+	
+	
+
+2004-11-17 02:21  davidm
+
+	* criov.c: 
+	Make sure public symbols are exported by including the correct
+	header files 
+
+2004-11-17 02:15  davidm
+
+	* crypto.c: 
+	even better cleanup of kernel threads on exit 
+
+2004-11-17 02:15  davidm
+
+	* cryptosoft.c: 
+	return some trace to debug so it doesn't appear 
+
+2004-11-17 02:14  davidm
+
+	* Makefile: 
+	Make sure all drivers get built, not just IXP 
+
+2004-11-16 21:31  davidm
+
+	* crypto.c: 
+	Fix problem with reboots and driver not unloading cleanly,  we were
+	not handling signals correctly in the kernel threads, 
+
+2004-11-10 10:46  davidm
+
+	* ixp4xx/ixp4xx.c: 
+	fix serious context leak,  itturns out the context is still
+	considered busy while it is calling the perform callback,  so we
+	cleanup on closing the session and on allocating the next context
+	to work around this.
+	
+	
+
+2004-11-10 05:26  davidm
+
+	* crypto.c, cryptodev.c, ixp4xx/ixp4xx.c, safe/safe.c: 
+	cleaned out some debug,  found MAX tunnels bug,  traced it various
+	other cleanups.
+	
+	
+
+2004-11-10 04:02  davidm
+
+	* cryptodev.c, cryptosoft.c, ixp4xx/ixp4xx.c, safe/Makefile,
+	safe/safe.c: 
+	Fix up kmalloc usage to always zero resulting buffer everywhere   
+	(stops crashes in ixp)
+	
+	Add some function debug to ixp so you can see it working
+	
+	Fix safe driver to build and install in a real tree.
+	
+	
+
+2004-11-10 02:27  davidm
+
+	* Makefile, criov.c, crypto.c, cryptosoft.c, ixp4xx/Makefile,
+	ixp4xx/ixp4xx.c: 
+	Compiling OCF modules for the IXP crypto, needs testing now
+	
+
+2004-11-09 19:16  davidm
+
+	* criov.c, crypto.c, cryptodev.c, cryptodev.h, cryptosoft.c,
+	cryptosoft.h, uio.h, safe/safe.c, safe/safevar.h: 
+	The linux port of OCF with working safenet and software modules. 
+	Still some bugs with mutiple crypto threads using the safenet
+	driver.
+	
+	
+
+2004-11-09 18:49  davidm
+
+	* Makefile, criov.c, crypto.c, cryptodev.c, cryptodev.h,
+	cryptosoft.c, cryptosoft.h, uio.h, safe/Makefile, safe/safe.c,
+	safe/safereg.h, safe/safevar.h: 
+	Check in the orginal free-bsd sources for the OCF support.  This
+	allows us to diff against it later to see if we botched anything
+	major league.
+	
+	
+
diff --git a/crypto/ocf/Config.in b/crypto/ocf/Config.in
index 652f76e..cb01ea9 100644
--- a/crypto/ocf/Config.in
+++ b/crypto/ocf/Config.in
@@ -25,10 +25,6 @@ dep_tristate '  pasemi (HW crypto engine)' \
 				CONFIG_OCF_PASEMI $CONFIG_OCF_OCF
 dep_tristate '  ep80579 (HW crypto engine)' \
 				CONFIG_OCF_EP80579 $CONFIG_OCF_OCF
-dep_tristate '  Micronas c7108 (HW crypto engine)' \
-				CONFIG_OCF_C7108 $CONFIG_OCF_OCF
-dep_tristate '  uBsec BCM5365 (HW crypto engine)'
-				CONFIG_OCF_UBSEC_SSB $CONFIG_OCF_OCF
 dep_tristate '  ocfnull (does no crypto)' \
 				CONFIG_OCF_OCFNULL $CONFIG_OCF_OCF
 dep_tristate '  ocf-bench (HW crypto in-kernel benchmark)' \
diff --git a/crypto/ocf/Kconfig b/crypto/ocf/Kconfig
index 6c8f88d..74b98b2 100644
--- a/crypto/ocf/Kconfig
+++ b/crypto/ocf/Kconfig
@@ -26,7 +26,7 @@ config OCF_CRYPTODEV
 
 config OCF_CRYPTOSOFT
 	tristate "cryptosoft (software crypto engine)"
-	depends on OCF_OCF && CRYPTO_HASH2
+	depends on OCF_OCF
 	help
 	  A software driver for the OCF framework that uses
 	  the kernel CryptoAPI.
@@ -68,7 +68,7 @@ config OCF_HIFNHIPP
 
 config OCF_TALITOS
 	tristate "talitos (HW crypto engine)"
-	depends on OCF_OCF && FSL_SOC && !CRYPTO_DEV_TALITOS
+	depends on OCF_OCF
 	help
 	  OCF driver for Freescale's security engine (SEC/talitos).
 
@@ -84,30 +84,6 @@ config OCF_EP80579
 	help
 	  OCF driver for the Intel EP80579 Integrated Processor Product Line.
 
-config OCF_CRYPTOCTEON
-	tristate "cryptocteon (HW crypto engine)"
-	depends on OCF_OCF
-	help
-	  OCF driver for the Cavium OCTEON Processors.
-
-config OCF_KIRKWOOD
-	tristate "kirkwood (HW crypto engine)"
-	depends on OCF_OCF
-	help
-	  OCF driver for the Marvell Kirkwood (88F6xxx) Processors.
-
-config OCF_C7108
-	tristate "Micronas 7108 (HW crypto engine)"
-	depends on OCF_OCF
-	help
-	  OCF driver for the Microna 7108 Cipher processors.
-
-config OCF_UBSEC_SSB
-	tristate "uBsec BCM5365 (HW crypto engine)"
-	depends on OCF_OCF
-	help
-	  OCF driver for uBsec BCM5365 hardware crypto accelerator.
-
 config OCF_OCFNULL
 	tristate "ocfnull (fake crypto engine)"
 	depends on OCF_OCF
diff --git a/crypto/ocf/Makefile b/crypto/ocf/Makefile
index 110ed83..cae4b25 100644
--- a/crypto/ocf/Makefile
+++ b/crypto/ocf/Makefile
@@ -42,24 +42,11 @@ $(_obj)-$(CONFIG_OCF_HIFN)    += hifn$(_slash)
 $(_obj)-$(CONFIG_OCF_IXP4XX)  += ixp4xx$(_slash)
 $(_obj)-$(CONFIG_OCF_TALITOS) += talitos$(_slash)
 $(_obj)-$(CONFIG_OCF_PASEMI)  += pasemi$(_slash)
-$(_obj)-$(CONFIG_OCF_EP80579) += ep80579$(_slash)
-$(_obj)-$(CONFIG_OCF_CRYPTOCTEON) += cryptocteon$(_slash)
-$(_obj)-$(CONFIG_OCF_KIRKWOOD) += kirkwood$(_slash)
+#$(_obj)-$(CONFIG_OCF_EP80579) += ep80579$(_slash)
 $(_obj)-$(CONFIG_OCF_OCFNULL) += ocfnull$(_slash)
-$(_obj)-$(CONFIG_OCF_C7108) += c7108$(_slash)
-$(_obj)-$(CONFIG_OCF_UBSEC_SSB) += ubsec_ssb$(_slash)
 
 ocf-objs := $(OCF_OBJS)
 
-dummy:
-	@echo "Please consult the README for how to build OCF."
-	@echo "If you can't wait then the following should do it:"
-	@echo ""
-	@echo "    make ocf_modules"
-	@echo "    sudo make ocf_install"
-	@echo ""
-	@exit 1
-	
 $(list-multi) dummy1: $(ocf-objs)
 	$(LD) -r -o $@ $(ocf-objs)
 
@@ -67,45 +54,21 @@ $(list-multi) dummy1: $(ocf-objs)
 clean:
 	rm -f *.o *.ko .*.o.flags .*.ko.cmd .*.o.cmd .*.mod.o.cmd *.mod.c
 	rm -f */*.o */*.ko */.*.o.cmd */.*.ko.cmd */.*.mod.o.cmd */*.mod.c */.*.o.flags
-	rm -f */modules.order */modules.builtin modules.order modules.builtin
 
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
 
 #
-# targets to build easily on the current machine
-#
-
-ocf_make:
-	make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m
-	make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_CRYPTOSOFT=m
-	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_BENCH=m
-	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_OCFNULL=m
-	-make -C /lib/modules/$(shell uname -r)/build M=`pwd` $(OCF_TARGET) CONFIG_OCF_OCF=m CONFIG_OCF_HIFN=m
-
-ocf_modules:
-	$(MAKE) ocf_make OCF_TARGET=modules
-
-ocf_install:
-	$(MAKE) ocf_make OCF_TARGET="modules modules_install"
-	depmod
-	mkdir -p /usr/include/crypto
-	cp cryptodev.h /usr/include/crypto/.
-
-#
-# generate full kernel patches for 2.4 and 2.6 kernels to make patching
-# your kernel easier
+# release gen targets
 #
 
 .PHONY: patch
 patch:
-	patchbase=.; \
-		[ -d $$patchbase/patches ] || patchbase=..; \
-		patch=ocf-linux-base.patch; \
-		patch24=ocf-linux-24.patch; \
-		patch26=ocf-linux-26.patch; \
-		patch3=ocf-linux-3.patch; \
+	REL=`date +%Y%m%d`; \
+		patch=ocf-linux-$$REL.patch; \
+		patch24=ocf-linux-24-$$REL.patch; \
+		patch26=ocf-linux-26-$$REL.patch; \
 		( \
 			find . -name Makefile; \
 			find . -name Config.in; \
@@ -115,34 +78,44 @@ patch:
 		) | while read t; do \
 			diff -Nau /dev/null $$t | sed 's?^+++ \./?+++ linux/crypto/ocf/?'; \
 		done > $$patch; \
-		cat $$patchbase/patches/linux-2.4.35-ocf.patch $$patch > $$patch24; \
-		cat $$patchbase/patches/linux-2.6.38-ocf.patch $$patch > $$patch26; \
-		cat $$patchbase/patches/linux-3.2.1-ocf.patch $$patch > $$patch3; \
-
-
-#
-# this target probably does nothing for anyone but me - davidm
-#
+		cat patches/linux-2.4.35-ocf.patch $$patch > $$patch24; \
+		cat patches/linux-2.6.26-ocf.patch $$patch > $$patch26
 
-.PHONY: release
-release:
+.PHONY: tarball
+tarball:
 	REL=`date +%Y%m%d`; RELDIR=/tmp/ocf-linux-$$REL; \
 		CURDIR=`pwd`; \
 		rm -rf /tmp/ocf-linux-$$REL*; \
-		mkdir -p $$RELDIR/ocf; \
-		mkdir -p $$RELDIR/patches; \
-		mkdir -p $$RELDIR/crypto-tools; \
-		cp README* $$RELDIR/.; \
-		cp patches/[!C]* $$RELDIR/patches/.; \
-		cp tools/[!C]* $$RELDIR/crypto-tools/.; \
-		cp -r [!C]* Config.in $$RELDIR/ocf/.; \
-		rm -rf $$RELDIR/ocf/patches $$RELDIR/ocf/tools; \
-		rm -f $$RELDIR/ocf/README*; \
-		cp $$CURDIR/../../user/crypto-tools/[!C]* $$RELDIR/crypto-tools/.; \
-		make -C $$RELDIR/crypto-tools clean; \
-		make -C $$RELDIR/ocf clean; \
-		find $$RELDIR/ocf -name CVS | xargs rm -rf; \
-		cd $$RELDIR/..; \
+		mkdir -p $$RELDIR/tools; \
+		cp README* $$RELDIR; \
+		cp patches/openss*.patch $$RELDIR; \
+		cp patches/crypto-tools.patch $$RELDIR; \
+		cp tools/[!C]* $$RELDIR/tools; \
+		cd ..; \
+		tar cvf $$RELDIR/ocf-linux.tar \
+					--exclude=CVS \
+					--exclude=.* \
+					--exclude=*.o \
+					--exclude=*.ko \
+					--exclude=*.mod.* \
+					--exclude=README* \
+					--exclude=ocf-*.patch \
+					--exclude=ocf/patches/openss*.patch \
+					--exclude=ocf/patches/crypto-tools.patch \
+					--exclude=ocf/tools \
+					ocf; \
+		gzip -9 $$RELDIR/ocf-linux.tar; \
+		cd /tmp; \
 		tar cvf ocf-linux-$$REL.tar ocf-linux-$$REL; \
-		gzip -9 ocf-linux-$$REL.tar
+		gzip -9 ocf-linux-$$REL.tar; \
+		cd $$CURDIR/../../user; \
+		rm -rf /tmp/crypto-tools-$$REL*; \
+		tar cvf /tmp/crypto-tools-$$REL.tar \
+					--exclude=CVS \
+					--exclude=.* \
+					--exclude=*.o \
+					--exclude=cryptotest \
+					--exclude=cryptokeytest \
+					crypto-tools; \
+		gzip -9 /tmp/crypto-tools-$$REL.tar
 
diff --git a/crypto/ocf/criov.c b/crypto/ocf/criov.c
index a8c1a8c..eb0b677 100644
--- a/crypto/ocf/criov.c
+++ b/crypto/ocf/criov.c
@@ -1,8 +1,8 @@
 /*      $OpenBSD: criov.c,v 1.9 2002/01/29 15:48:29 jason Exp $	*/
 
 /*
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -34,10 +34,6 @@
 __FBSDID("$FreeBSD: src/sys/opencrypto/criov.c,v 1.5 2006/06/04 22:15:13 pjd Exp $");
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
-#include <linux/config.h>
-#endif
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -143,6 +139,7 @@ EXPORT_SYMBOL(cuio_copyback);
 EXPORT_SYMBOL(cuio_copydata);
 EXPORT_SYMBOL(cuio_getptr);
 
+
 static void
 skb_copy_bits_back(struct sk_buff *skb, int offset, caddr_t cp, int len)
 {
@@ -155,7 +152,7 @@ skb_copy_bits_back(struct sk_buff *skb, int offset, caddr_t cp, int len)
 	offset -= skb_headlen(skb);
 	for (i = 0; len > 0 && i < skb_shinfo(skb)->nr_frags; i++) {
 		if (offset < skb_shinfo(skb)->frags[i].size) {
-			memcpy(page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
+			memcpy(page_address(skb_shinfo(skb)->frags[i].page.p) +
 					skb_shinfo(skb)->frags[i].page_offset,
 					cp, min_t(int, skb_shinfo(skb)->frags[i].size, len));
 			len -= skb_shinfo(skb)->frags[i].size;
diff --git a/crypto/ocf/crypto.c b/crypto/ocf/crypto.c
index f48210d..e952de6 100644
--- a/crypto/ocf/crypto.c
+++ b/crypto/ocf/crypto.c
@@ -1,6 +1,6 @@
 /*-
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -62,11 +62,6 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.27 2007/03/21 03:42:51 sam E
 __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp Exp $");
  */
 
-
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
-#include <linux/config.h>
-#endif
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/list.h>
@@ -74,9 +69,7 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp E
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,4)
-#include <linux/kthread.h>
-#endif
+#include <linux/version.h>
 #include <cryptodev.h>
 
 /*
@@ -84,7 +77,7 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/crypto.c,v 1.16 2005/01/07 02:29:16 imp E
  * issue if we are linked into the kernel and a driver gets started before
  * us
  */
-static int crypto_initted = 0;
+int crypto_initted = 0;
 
 /*
  * Crypto drivers register themselves by allocating a slot in the
@@ -142,9 +135,6 @@ struct cryptocap {
 #define CRYPTOCAP_F_CLEANUP	0x80000000	/* needs resource cleanup */
 	int		cc_qblocked;		/* (q) symmetric q blocked */
 	int		cc_kqblocked;		/* (q) asymmetric q blocked */
-
-	int		cc_unqblocked;		/* (q) symmetric q blocked */
-	int		cc_unkqblocked;		/* (q) asymmetric q blocked */
 };
 static struct cryptocap *crypto_drivers = NULL;
 static int crypto_drivers_num = 0;
@@ -156,8 +146,9 @@ static int crypto_drivers_num = 0;
  * have one per-queue but having one simplifies handling of block/unblock
  * operations.
  */
-static LIST_HEAD(crp_q);		/* crypto request queue */
-static LIST_HEAD(crp_kq);		/* asym request queue */
+static	int crp_sleep = 0;
+static LIST_HEAD(crp_q);		/* request queues */
+static LIST_HEAD(crp_kq);
 
 static spinlock_t crypto_q_lock;
 
@@ -260,25 +251,11 @@ module_param(crypto_devallowsoft, int, 0644);
 MODULE_PARM_DESC(crypto_devallowsoft,
 	   "Enable/disable use of software crypto support");
 
-/*
- * This parameter controls the maximum number of crypto operations to 
- * do consecutively in the crypto kernel thread before scheduling to allow 
- * other processes to run. Without it, it is possible to get into a 
- * situation where the crypto thread never allows any other processes to run.
- * Default to 1000 which should be less than one second.
- */
-static int crypto_max_loopcount = 1000;
-module_param(crypto_max_loopcount, int, 0644);
-MODULE_PARM_DESC(crypto_max_loopcount,
-	   "Maximum number of crypto ops to do before yielding to other processes");
-
-#ifndef CONFIG_NR_CPUS
-#define CONFIG_NR_CPUS 1
-#endif
-
-static struct task_struct *cryptoproc[CONFIG_NR_CPUS];
-static struct task_struct *cryptoretproc[CONFIG_NR_CPUS];
+static pid_t	cryptoproc = (pid_t) -1;
+static struct	completion cryptoproc_exited;
 static DECLARE_WAIT_QUEUE_HEAD(cryptoproc_wait);
+static pid_t	cryptoretproc = (pid_t) -1;
+static struct	completion cryptoretproc_exited;
 static DECLARE_WAIT_QUEUE_HEAD(cryptoretproc_wait);
 
 static	int crypto_proc(void *arg);
@@ -286,7 +263,7 @@ static	int crypto_ret_proc(void *arg);
 static	int crypto_invoke(struct cryptocap *cap, struct cryptop *crp, int hint);
 static	int crypto_kinvoke(struct cryptkop *krp, int flags);
 static	void crypto_exit(void);
-static  int crypto_init(void);
+int crypto_init(void);
 
 static	struct cryptostats cryptostats;
 
@@ -314,7 +291,6 @@ driver_suitable(const struct cryptocap *cap, const struct cryptoini *cri)
 	return 1;
 }
 
-
 /*
  * Select a driver for a new session that supports the specified
  * algorithms and, optionally, is constrained according to the flags.
@@ -780,15 +756,14 @@ crypto_unblock(u_int32_t driverid, int what)
 	if (cap != NULL) {
 		if (what & CRYPTO_SYMQ) {
 			cap->cc_qblocked = 0;
-			cap->cc_unqblocked = 0;
 			crypto_all_qblocked = 0;
 		}
 		if (what & CRYPTO_ASYMQ) {
 			cap->cc_kqblocked = 0;
-			cap->cc_unkqblocked = 0;
 			crypto_all_kqblocked = 0;
 		}
-		wake_up_interruptible(&cryptoproc_wait);
+		if (crp_sleep)
+			wake_up_interruptible(&cryptoproc_wait);
 		err = 0;
 	} else
 		err = EINVAL;
@@ -804,65 +779,46 @@ int
 crypto_dispatch(struct cryptop *crp)
 {
 	struct cryptocap *cap;
-	int result = -1;
+	u_int32_t hid;
+	int result = 0;
 	unsigned long q_flags;
 
 	dprintk("%s()\n", __FUNCTION__);
-
 	cryptostats.cs_ops++;
 
 	CRYPTO_Q_LOCK();
 	if (crypto_q_cnt >= crypto_q_max) {
-		cryptostats.cs_drops++;
 		CRYPTO_Q_UNLOCK();
+		cryptostats.cs_drops++;
 		return ENOMEM;
 	}
 	crypto_q_cnt++;
+	CRYPTO_Q_UNLOCK();
 
-	/* make sure we are starting a fresh run on this crp. */
-	crp->crp_flags &= ~CRYPTO_F_DONE;
-	crp->crp_etype = 0;
-
-	/*
-	 * Caller marked the request to be processed immediately; dispatch
-	 * it directly to the driver unless the driver is currently blocked.
-	 */
-	if ((crp->crp_flags & CRYPTO_F_BATCH) == 0) {
-		int hid = CRYPTO_SESID2HID(crp->crp_sid);
-		cap = crypto_checkdriver(hid);
-		/* Driver cannot disappear when there is an active session. */
-		KASSERT(cap != NULL, ("%s: Driver disappeared.", __func__));
-		if (!cap->cc_qblocked) {
-			crypto_all_qblocked = 0;
-			crypto_drivers[hid].cc_unqblocked = 1;
-			CRYPTO_Q_UNLOCK();
-			result = crypto_invoke(cap, crp, 0);
-			CRYPTO_Q_LOCK();
-			if (result == ERESTART)
-				if (crypto_drivers[hid].cc_unqblocked)
-					crypto_drivers[hid].cc_qblocked = 1;
-			crypto_drivers[hid].cc_unqblocked = 0;
-		}
-	}
-	if (result == ERESTART) {
+	hid = CRYPTO_SESID2HID(crp->crp_sid);
+	cap = crypto_checkdriver(hid);
+	/* warning: We are using the CRYPTO_F_BATCH to mark processing by HW,
+ 	   it should be disabled for software encryption */
+	if ((crp->crp_flags & CRYPTO_F_BATCH)) {
+        /* If should be done by HW - skip OCF queue */
+		result = crypto_invoke(cap, crp, 0);
+		if (result != 0) {
+            	    cryptostats.cs_drops++;
+		} 
+	} else {
 		/*
-		 * The driver ran out of resources, mark the
-		 * driver ``blocked'' for cryptop's and put
-		 * the request back in the queue.  It would
-		 * best to put the request back where we got
-		 * it but that's hard so for now we put it
-		 * at the front.  This should be ok; putting
-		 * it at the end does not work.
+		 * Caller marked the request as ``ok to delay'';
+		 * queue it for the dispatch thread.  This is desirable
+		 * when the operation is low priority and/or suitable
+		 * for batching.
 		 */
-		list_add(&crp->crp_next, &crp_q);
-		cryptostats.cs_blocks++;
-		result = 0;
-	} else if (result == -1) {
+      		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
-		result = 0;
+		if (crp_sleep)
+			wake_up_interruptible(&cryptoproc_wait);
+		CRYPTO_Q_UNLOCK();
 	}
-	wake_up_interruptible(&cryptoproc_wait);
-	CRYPTO_Q_UNLOCK();
+	
 	return result;
 }
 
@@ -882,7 +838,8 @@ crypto_kdispatch(struct cryptkop *krp)
 	if (error == ERESTART) {
 		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_kq, krp, krp_next);
-		wake_up_interruptible(&cryptoproc_wait);
+		if (crp_sleep)
+			wake_up_interruptible(&cryptoproc_wait);
 		CRYPTO_Q_UNLOCK();
 		error = 0;
 	}
@@ -1180,7 +1137,8 @@ crypto_done(struct cryptop *crp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-		wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
+		if (CRYPTO_RETQ_EMPTY())
+			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_q, crp, crp_next);
 		CRYPTO_RETQ_UNLOCK();
 	}
@@ -1230,7 +1188,8 @@ crypto_kdone(struct cryptkop *krp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-		wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
+		if (CRYPTO_RETQ_EMPTY())
+			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_kq, krp, krp_next);
 		CRYPTO_RETQ_UNLOCK();
 	}
@@ -1271,9 +1230,8 @@ crypto_proc(void *arg)
 	u_int32_t hid;
 	int result, hint;
 	unsigned long q_flags;
-	int loopcount = 0;
 
-	set_current_state(TASK_INTERRUPTIBLE);
+	ocf_daemonize("crypto");
 
 	CRYPTO_Q_LOCK();
 	for (;;) {
@@ -1332,7 +1290,7 @@ crypto_proc(void *arg)
 			hid = CRYPTO_SESID2HID(submit->crp_sid);
 			crypto_all_qblocked = 0;
 			list_del(&submit->crp_next);
-			crypto_drivers[hid].cc_unqblocked = 1;
+			crypto_drivers[hid].cc_qblocked = 1;
 			cap = crypto_checkdriver(hid);
 			CRYPTO_Q_UNLOCK();
 			KASSERT(cap != NULL, ("%s:%u Driver disappeared.",
@@ -1352,11 +1310,8 @@ crypto_proc(void *arg)
 				/* XXX validate sid again? */
 				list_add(&submit->crp_next, &crp_q);
 				cryptostats.cs_blocks++;
-				if (crypto_drivers[hid].cc_unqblocked)
-					crypto_drivers[hid].cc_qblocked=0;
-				crypto_drivers[hid].cc_unqblocked=0;
-			}
-			crypto_drivers[hid].cc_unqblocked = 0;
+			} else
+				crypto_drivers[hid].cc_qblocked=0;
 		}
 
 		crypto_all_kqblocked = !list_empty(&crp_kq);
@@ -1425,12 +1380,13 @@ crypto_proc(void *arg)
 					__FUNCTION__,
 					list_empty(&crp_q), crypto_all_qblocked,
 					list_empty(&crp_kq), crypto_all_kqblocked);
-			loopcount = 0;
 			CRYPTO_Q_UNLOCK();
+			crp_sleep = 1;
 			wait_event_interruptible(cryptoproc_wait,
 					!(list_empty(&crp_q) || crypto_all_qblocked) ||
 					!(list_empty(&crp_kq) || crypto_all_kqblocked) ||
-					kthread_should_stop());
+					cryptoproc == (pid_t) -1);
+			crp_sleep = 0;
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
@@ -1442,23 +1398,13 @@ crypto_proc(void *arg)
 			}
 			CRYPTO_Q_LOCK();
 			dprintk("%s - awake\n", __FUNCTION__);
-			if (kthread_should_stop())
+			if (cryptoproc == (pid_t) -1)
 				break;
 			cryptostats.cs_intrs++;
-		} else if (loopcount > crypto_max_loopcount) {
-			/*
-			 * Give other processes a chance to run if we've 
-			 * been using the CPU exclusively for a while.
-			 */
-			loopcount = 0;
-			CRYPTO_Q_UNLOCK();
-			schedule();
-			CRYPTO_Q_LOCK();
 		}
-		loopcount++;
 	}
 	CRYPTO_Q_UNLOCK();
-	return 0;
+	complete_and_exit(&cryptoproc_exited, 0);
 }
 
 /*
@@ -1473,7 +1419,7 @@ crypto_ret_proc(void *arg)
 	struct cryptkop *krpt;
 	unsigned long  r_flags;
 
-	set_current_state(TASK_INTERRUPTIBLE);
+	ocf_daemonize("crypto_ret");
 
 	CRYPTO_RETQ_LOCK();
 	for (;;) {
@@ -1508,9 +1454,9 @@ crypto_ret_proc(void *arg)
 			dprintk("%s - sleeping\n", __FUNCTION__);
 			CRYPTO_RETQ_UNLOCK();
 			wait_event_interruptible(cryptoretproc_wait,
+					cryptoretproc == (pid_t) -1 ||
 					!list_empty(&crp_ret_q) ||
-					!list_empty(&crp_ret_kq) ||
-					kthread_should_stop());
+					!list_empty(&crp_ret_kq));
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
@@ -1522,7 +1468,7 @@ crypto_ret_proc(void *arg)
 			}
 			CRYPTO_RETQ_LOCK();
 			dprintk("%s - awake\n", __FUNCTION__);
-			if (kthread_should_stop()) {
+			if (cryptoretproc == (pid_t) -1) {
 				dprintk("%s - EXITING!\n", __FUNCTION__);
 				break;
 			}
@@ -1530,7 +1476,7 @@ crypto_ret_proc(void *arg)
 		}
 	}
 	CRYPTO_RETQ_UNLOCK();
-	return 0;
+	complete_and_exit(&cryptoretproc_exited, 0);
 }
 
 
@@ -1632,13 +1578,12 @@ DB_SHOW_COMMAND(kcrypto, db_show_kcrypto)
 #endif
 
 
-static int
+int
 crypto_init(void)
 {
 	int error;
-	unsigned long cpu;
 
-	dprintk("%s(%p)\n", __FUNCTION__, (void *) crypto_init);
+	dprintk("%s(0x%x)\n", __FUNCTION__, (int) crypto_init);
 
 	if (crypto_initted)
 		return 0;
@@ -1679,28 +1624,25 @@ crypto_init(void)
 
 	memset(crypto_drivers, 0, crypto_drivers_num * sizeof(struct cryptocap));
 
-	ocf_for_each_cpu(cpu) {
-		cryptoproc[cpu] = kthread_create(crypto_proc, (void *) cpu,
-									"ocf_%d", (int) cpu);
-		if (IS_ERR(cryptoproc[cpu])) {
-			error = PTR_ERR(cryptoproc[cpu]);
-			printk("crypto: crypto_init cannot start crypto thread; error %d",
+	init_completion(&cryptoproc_exited);
+	init_completion(&cryptoretproc_exited);
+
+	cryptoproc = 0; /* to avoid race condition where proc runs first */
+	cryptoproc = kernel_thread(crypto_proc, NULL, CLONE_FS|CLONE_FILES);
+	if (cryptoproc < 0) {
+		error = cryptoproc;
+		printk("crypto: crypto_init cannot start crypto thread; error %d",
+			error);
+		goto bad;
+	}
+
+	cryptoretproc = 0; /* to avoid race condition where proc runs first */
+	cryptoretproc = kernel_thread(crypto_ret_proc, NULL, CLONE_FS|CLONE_FILES);
+	if (cryptoretproc < 0) {
+		error = cryptoretproc;
+		printk("crypto: crypto_init cannot start cryptoret thread; error %d",
 				error);
-			goto bad;
-		}
-		kthread_bind(cryptoproc[cpu], cpu);
-		wake_up_process(cryptoproc[cpu]);
-
-		cryptoretproc[cpu] = kthread_create(crypto_ret_proc, (void *) cpu,
-									"ocf_ret_%d", (int) cpu);
-		if (IS_ERR(cryptoretproc[cpu])) {
-			error = PTR_ERR(cryptoretproc[cpu]);
-			printk("crypto: crypto_init cannot start cryptoret thread; error %d",
-					error);
-			goto bad;
-		}
-		kthread_bind(cryptoretproc[cpu], cpu);
-		wake_up_process(cryptoretproc[cpu]);
+		goto bad;
 	}
 
 	return 0;
@@ -1713,17 +1655,34 @@ bad:
 static void
 crypto_exit(void)
 {
-	int cpu;
+	pid_t p;
+	unsigned long d_flags;
 
 	dprintk("%s()\n", __FUNCTION__);
 
 	/*
 	 * Terminate any crypto threads.
 	 */
-	ocf_for_each_cpu(cpu) {
-		kthread_stop(cryptoproc[cpu]);
-		kthread_stop(cryptoretproc[cpu]);
-	}
+
+	CRYPTO_DRIVER_LOCK();
+	p = cryptoproc;
+	cryptoproc = (pid_t) -1;
+	kill_proc_info(SIGTERM, SEND_SIG_PRIV, p);
+	wake_up_interruptible(&cryptoproc_wait);
+	CRYPTO_DRIVER_UNLOCK();
+
+	wait_for_completion(&cryptoproc_exited);
+
+	CRYPTO_DRIVER_LOCK();
+	p = cryptoretproc;
+	cryptoretproc = (pid_t) -1;
+	kill_proc_info(SIGTERM, SEND_SIG_PRIV, p);
+	wake_up_interruptible(&cryptoretproc_wait);
+	CRYPTO_DRIVER_UNLOCK();
+
+	wait_for_completion(&cryptoretproc_exited);
+
+	/* XXX flush queues??? */
 
 	/* 
 	 * Reclaim dynamically allocated resources.
@@ -1762,5 +1721,5 @@ module_init(crypto_init);
 module_exit(crypto_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("OCF (OpenBSD Cryptographic Framework)");
diff --git a/crypto/ocf/cryptodev.c b/crypto/ocf/cryptodev.c
index 0724b57..2fa943c 100644
--- a/crypto/ocf/cryptodev.c
+++ b/crypto/ocf/cryptodev.c
@@ -1,8 +1,8 @@
 /*	$OpenBSD: cryptodev.c,v 1.52 2002/06/19 07:22:46 deraadt Exp $	*/
 
 /*-
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -39,10 +39,6 @@
 __FBSDID("$FreeBSD: src/sys/opencrypto/cryptodev.c,v 1.34 2007/05/09 19:37:02 gnn Exp $");
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
-#include <linux/config.h>
-#endif
 #include <linux/types.h>
 #include <linux/time.h>
 #include <linux/delay.h>
@@ -58,6 +54,7 @@ __FBSDID("$FreeBSD: src/sys/opencrypto/cryptodev.c,v 1.34 2007/05/09 19:37:02 gn
 #include <linux/file.h>
 #include <linux/mount.h>
 #include <linux/miscdevice.h>
+#include <linux/version.h>
 #include <asm/uaccess.h>
 
 #include <cryptodev.h>
@@ -77,7 +74,6 @@ struct csession_info {
 	u_int16_t	keysize;
 	/* u_int16_t	hashsize;  */
 	u_int16_t	authsize;
-	u_int16_t	authkey;
 	/* u_int16_t	ctxsize; */
 };
 
@@ -125,8 +121,6 @@ static	int cryptodev_find(struct crypt_find_op *);
 static int cryptodev_cb(void *);
 static int cryptodev_open(struct inode *inode, struct file *filp);
 
-static DEFINE_SPINLOCK(cselist_lock);
-
 /*
  * Check a crypto identifier to see if it requested
  * a valid crid and it's capabilities match.
@@ -200,7 +194,7 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 
 	if (cse->uio.uio_iov[0].iov_base == NULL) {
 		dprintk("%s: iov_base kmalloc(%d) failed\n", __FUNCTION__,
-				(int)cse->uio.uio_iov[0].iov_len);
+				cse->uio.uio_iov[0].iov_len);
 		return (ENOMEM);
 	}
 
@@ -211,22 +205,18 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 		goto bail;
 	}
 
-	if (cse->info.authsize && cse->info.blocksize) {
-		if (cop->op == COP_ENCRYPT) {
-			crde = crp->crp_desc;
-			crda = crde->crd_next;
-		} else {
-			crda = crp->crp_desc;
-			crde = crda->crd_next;
-		}
-	} else if (cse->info.authsize) {
+	if (cse->info.authsize) {
 		crda = crp->crp_desc;
-	} else if (cse->info.blocksize) {
-		crde = crp->crp_desc;
+		if (cse->info.blocksize)
+			crde = crda->crd_next;
 	} else {
-		dprintk("%s: bad request\n", __FUNCTION__);
-		error = EINVAL;
-		goto bail;
+		if (cse->info.blocksize)
+			crde = crp->crp_desc;
+		else {
+			dprintk("%s: bad request\n", __FUNCTION__);
+			error = EINVAL;
+			goto bail;
+		}
 	}
 
 	if ((error = copy_from_user(cse->uio.uio_iov[0].iov_base, cop->src,
@@ -307,31 +297,28 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 	 * entry and the crypto_done callback into us.
 	 */
 	error = crypto_dispatch(crp);
-	if (error) {
-		dprintk("%s error in crypto_dispatch\n", __FUNCTION__);
-		goto bail;
-	}
-
-	dprintk("%s about to WAIT\n", __FUNCTION__);
-	/*
-	 * we really need to wait for driver to complete to maintain
-	 * state,  luckily interrupts will be remembered
-	 */
-	do {
-		error = wait_event_interruptible(crp->crp_waitq,
-				((crp->crp_flags & CRYPTO_F_DONE) != 0));
+	if (error == 0) {
+		dprintk("%s about to WAIT\n", __FUNCTION__);
 		/*
-		 * we can't break out of this loop or we will leave behind
-		 * a huge mess,  however,  staying here means if your driver
-		 * is broken user applications can hang and not be killed.
-		 * The solution,  fix your driver :-)
+		 * we really need to wait for driver to complete to maintain
+		 * state,  luckily interrupts will be remembered
 		 */
-		if (error) {
-			schedule();
-			error = 0;
-		}
-	} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
-	dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
+		do {
+			error = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			/*
+			 * we can't break out of this loop or we will leave behind
+			 * a huge mess,  however,  staying here means if your driver
+			 * is broken user applications can hang and not be killed.
+			 * The solution,  fix your driver :-)
+			 */
+			if (error) {
+				schedule();
+				error = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
+	}
 
 	if (crp->crp_etype != 0) {
 		error = crp->crp_etype;
@@ -545,16 +532,11 @@ static struct csession *
 csefind(struct fcrypt *fcr, u_int ses)
 {
 	struct csession *cse;
-	unsigned long flags;
 
-	spin_lock_irqsave(&cselist_lock, flags);
 	dprintk("%s()\n", __FUNCTION__);
 	list_for_each_entry(cse, &fcr->csessions, list)
-		if (cse->ses == ses) {
-			spin_unlock_irqrestore(&cselist_lock, flags);
+		if (cse->ses == ses)
 			return (cse);
-		}
-	spin_unlock_irqrestore(&cselist_lock, flags);
 	return (NULL);
 }
 
@@ -562,31 +544,23 @@ static int
 csedelete(struct fcrypt *fcr, struct csession *cse_del)
 {
 	struct csession *cse;
-	unsigned long flags;
 
-	spin_lock_irqsave(&cselist_lock, flags);
 	dprintk("%s()\n", __FUNCTION__);
 	list_for_each_entry(cse, &fcr->csessions, list) {
 		if (cse == cse_del) {
 			list_del(&cse->list);
-			spin_unlock_irqrestore(&cselist_lock, flags);
 			return (1);
 		}
 	}
-	spin_unlock_irqrestore(&cselist_lock, flags);
 	return (0);
 }
 	
 static struct csession *
 cseadd(struct fcrypt *fcr, struct csession *cse)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&cselist_lock, flags);
 	dprintk("%s()\n", __FUNCTION__);
 	list_add_tail(&cse->list, &fcr->csessions);
 	cse->ses = fcr->sesn++;
-	spin_unlock_irqrestore(&cselist_lock, flags);
 	return (cse);
 }
 
@@ -767,27 +741,21 @@ cryptodev_ioctl(
 			break;
 		case CRYPTO_MD5_HMAC:
 			info.authsize = MD5_HASH_LEN;
-			info.authkey = 16;
 			break;
 		case CRYPTO_SHA1_HMAC:
 			info.authsize = SHA1_HASH_LEN;
-			info.authkey = 20;
 			break;
 		case CRYPTO_SHA2_256_HMAC:
 			info.authsize = SHA2_256_HASH_LEN;
-			info.authkey = 32;
 			break;
 		case CRYPTO_SHA2_384_HMAC:
 			info.authsize = SHA2_384_HASH_LEN;
-			info.authkey = 48;
   			break;
 		case CRYPTO_SHA2_512_HMAC:
 			info.authsize = SHA2_512_HASH_LEN;
-			info.authkey = 64;
 			break;
 		case CRYPTO_RIPEMD160_HMAC:
 			info.authsize = RIPEMD160_HASH_LEN;
-			info.authkey = 20;
 			break;
 		default:
 			dprintk("%s(%s) - bad mac\n", __FUNCTION__, CIOCGSESSSTR);
@@ -819,9 +787,10 @@ cryptodev_ioctl(
 		if (info.authsize) {
 			cria.cri_alg = sop.mac;
 			cria.cri_klen = sop.mackeylen * 8;
-			if (info.authkey && sop.mackeylen != info.authkey) {
-				dprintk("%s(%s) - mackeylen %d != %d\n", __FUNCTION__,
-						CIOCGSESSSTR, sop.mackeylen, info.authkey);
+			if ((info.maxkey && sop.mackeylen > info.maxkey) ||
+					sop.keylen < info.minkey) {
+				dprintk("%s(%s) - mackeylen %d\n", __FUNCTION__, CIOCGSESSSTR,
+						sop.mackeylen);
 				error = EINVAL;
 				goto bail;
 			}
@@ -1080,5 +1049,5 @@ module_init(cryptodev_init);
 module_exit(cryptodev_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("Cryptodev (user interface to OCF)");
diff --git a/crypto/ocf/cryptodev.h b/crypto/ocf/cryptodev.h
index cca0ec8..3ec926d 100644
--- a/crypto/ocf/cryptodev.h
+++ b/crypto/ocf/cryptodev.h
@@ -2,8 +2,8 @@
 /*	$OpenBSD: cryptodev.h,v 1.31 2002/06/11 11:14:29 beck Exp $	*/
 
 /*-
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -156,8 +156,7 @@
 #define CRYPTO_SHA2_384			23
 #define CRYPTO_SHA2_512			24
 #define CRYPTO_RIPEMD160		25
-#define	CRYPTO_LZS_COMP			26
-#define CRYPTO_ALGORITHM_MAX	26 /* Keep updated - see above */
+#define CRYPTO_ALGORITHM_MAX	25 /* Keep updated - see below */
 
 /* Algorithm flags */
 #define CRYPTO_ALG_FLAG_SUPPORTED	0x01 /* Algorithm is supported */
diff --git a/crypto/ocf/cryptosoft.c b/crypto/ocf/cryptosoft.c
index 075e08c..1486889 100644
--- a/crypto/ocf/cryptosoft.c
+++ b/crypto/ocf/cryptosoft.c
@@ -3,8 +3,8 @@
  * original cryptosoft for BSD by Angelos D. Keromytis (angelos@cis.upenn.edu)
  * but is mostly unrecognisable,
  *
- * Written by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2004-2011 David McCullough
+ * Written by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2004-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -34,8 +34,7 @@
  * ---------------------------------------------------------------------------
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -48,14 +47,7 @@
 #include <linux/mm.h>
 #include <linux/skbuff.h>
 #include <linux/random.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
-#include <linux/scatterlist.h>
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
-#include <crypto/hash.h>
-#endif
+#include <asm/scatterlist.h>
 
 #include <cryptodev.h>
 #include <uio.h>
@@ -66,33 +58,19 @@ struct {
 
 #define offset_in_page(p) ((unsigned long)(p) & ~PAGE_MASK)
 
-#define SW_TYPE_CIPHER		0x01
-#define SW_TYPE_HMAC		0x02
-#define SW_TYPE_HASH		0x04
-#define SW_TYPE_COMP		0x08
-#define SW_TYPE_BLKCIPHER	0x10
-#define SW_TYPE_ALG_MASK	0x1f
-
-#define SW_TYPE_ASYNC		0x8000
-
-#define SW_TYPE_INUSE		0x10000000
-
-/* We change some of the above if we have an async interface */
-
-#define SW_TYPE_ALG_AMASK	(SW_TYPE_ALG_MASK | SW_TYPE_ASYNC)
+/* Software session entry */
 
-#define SW_TYPE_ABLKCIPHER	(SW_TYPE_BLKCIPHER | SW_TYPE_ASYNC)
-#define SW_TYPE_AHASH		(SW_TYPE_HASH | SW_TYPE_ASYNC)
-#define SW_TYPE_AHMAC		(SW_TYPE_HMAC | SW_TYPE_ASYNC)
-
-#define SCATTERLIST_MAX 16
+#define SW_TYPE_CIPHER		0
+#define SW_TYPE_HMAC		1
+#define SW_TYPE_AUTH2		2
+#define SW_TYPE_HASH		3
+#define SW_TYPE_COMP		4
+#define SW_TYPE_BLKCIPHER	5
 
 struct swcr_data {
-	struct work_struct  workq;
 	int					sw_type;
 	int					sw_alg;
 	struct crypto_tfm	*sw_tfm;
-	spinlock_t			sw_tfm_lock;
 	union {
 		struct {
 			char *sw_key;
@@ -104,23 +82,6 @@ struct swcr_data {
 	struct swcr_data	*sw_next;
 };
 
-struct swcr_req {
-	struct swcr_data	*sw_head;
-	struct swcr_data	*sw;
-	struct cryptop		*crp;
-	struct cryptodesc	*crd;
-	struct scatterlist	 sg[SCATTERLIST_MAX];
-	unsigned char		 iv[EALG_MAX_BLOCK_LEN];
-	char				 result[HASH_MAX_LEN];
-	void				*crypto_req;
-};
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static kmem_cache_t *swcr_req_cache;
-#else
-static struct kmem_cache *swcr_req_cache;
-#endif
-
 #ifndef CRYPTO_TFM_MODE_CBC
 /*
  * As of linux-2.6.21 this is no longer defined, and presumably no longer
@@ -142,8 +103,8 @@ static struct kmem_cache *swcr_req_cache;
 		struct crypto_tfm *tfm;
 		void *info;
 	};
-	#define ecb(X)								#X , CRYPTO_TFM_MODE_ECB
-	#define cbc(X)								#X , CRYPTO_TFM_MODE_CBC
+	#define ecb(X)								#X
+	#define cbc(X)								#X
 	#define crypto_has_blkcipher(X, Y, Z)		crypto_alg_available(X, 0)
 	#define crypto_blkcipher_cast(X)			X
 	#define crypto_blkcipher_tfm(X)				X
@@ -155,17 +116,13 @@ static struct kmem_cache *swcr_req_cache;
 				crypto_cipher_encrypt_iv((W)->tfm, X, Y, Z, (u8 *)((W)->info))
 	#define crypto_blkcipher_decrypt_iv(W, X, Y, Z)	\
 				crypto_cipher_decrypt_iv((W)->tfm, X, Y, Z, (u8 *)((W)->info))
-	#define crypto_blkcipher_set_flags(x, y)	/* nop */
-	#define crypto_free_blkcipher(x)			crypto_free_tfm(x)
-	#define crypto_free_comp					crypto_free_tfm
-	#define crypto_free_hash					crypto_free_tfm
 
 	/* Hash/HMAC/Digest */
 	struct hash_desc
 	{
 		struct crypto_tfm *tfm;
 	};
-	#define hmac(X)							#X , 0
+	#define hmac(X)							#X
 	#define crypto_has_hash(X, Y, Z)		crypto_alg_available(X, 0)
 	#define crypto_hash_cast(X)				X
 	#define crypto_hash_tfm(X)				X
@@ -182,66 +139,53 @@ static struct kmem_cache *swcr_req_cache;
 	#define crypto_comp_tfm(X)				X
 	#define crypto_comp_cast(X)				X
 	#define crypto_alloc_comp(X, Y, Z)		crypto_alloc_tfm(X, mode)
-	#define plain(X)	#X , 0
 #else
-	#define ecb(X)	"ecb(" #X ")" , 0
-	#define cbc(X)	"cbc(" #X ")" , 0
-	#define hmac(X)	"hmac(" #X ")" , 0
-	#define plain(X)	#X , 0
+	#define ecb(X)	"ecb(" #X ")"
+	#define cbc(X)	"cbc(" #X ")"
+	#define hmac(X)	"hmac(" #X ")"
 #endif /* if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-/* no ablkcipher in older kernels */
-#define crypto_alloc_ablkcipher(a,b,c)		(NULL)
-#define crypto_ablkcipher_tfm(x)			((struct crypto_tfm *)(x))
-#define crypto_ablkcipher_set_flags(a, b)	/* nop */
-#define crypto_ablkcipher_setkey(x, y, z)	(-EINVAL)
-#define	crypto_has_ablkcipher(a,b,c)		(0)
-#else
-#define	HAVE_ABLKCIPHER
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
-/* no ahash in older kernels */
-#define crypto_ahash_tfm(x)					((struct crypto_tfm *)(x))
-#define	crypto_alloc_ahash(a,b,c)			(NULL)
-#define	crypto_ahash_digestsize(x)			0
-#else
-#define	HAVE_AHASH
-#endif
-
-struct crypto_details {
+struct crypto_details
+{
 	char *alg_name;
 	int mode;
 	int sw_type;
 };
 
-static struct crypto_details crypto_details[] = {
-	[CRYPTO_DES_CBC]         = { cbc(des),          SW_TYPE_BLKCIPHER, },
-	[CRYPTO_3DES_CBC]        = { cbc(des3_ede),     SW_TYPE_BLKCIPHER, },
-	[CRYPTO_BLF_CBC]         = { cbc(blowfish),     SW_TYPE_BLKCIPHER, },
-	[CRYPTO_CAST_CBC]        = { cbc(cast5),        SW_TYPE_BLKCIPHER, },
-	[CRYPTO_SKIPJACK_CBC]    = { cbc(skipjack),     SW_TYPE_BLKCIPHER, },
-	[CRYPTO_MD5_HMAC]        = { hmac(md5),         SW_TYPE_HMAC, },
-	[CRYPTO_SHA1_HMAC]       = { hmac(sha1),        SW_TYPE_HMAC, },
-	[CRYPTO_RIPEMD160_HMAC]  = { hmac(ripemd160),   SW_TYPE_HMAC, },
-	[CRYPTO_MD5_KPDK]        = { plain(md5-kpdk),   SW_TYPE_HASH, },
-	[CRYPTO_SHA1_KPDK]       = { plain(sha1-kpdk),  SW_TYPE_HASH, },
-	[CRYPTO_AES_CBC]         = { cbc(aes),          SW_TYPE_BLKCIPHER, },
-	[CRYPTO_ARC4]            = { ecb(arc4),         SW_TYPE_BLKCIPHER, },
-	[CRYPTO_MD5]             = { plain(md5),        SW_TYPE_HASH, },
-	[CRYPTO_SHA1]            = { plain(sha1),       SW_TYPE_HASH, },
-	[CRYPTO_NULL_HMAC]       = { hmac(digest_null), SW_TYPE_HMAC, },
-	[CRYPTO_NULL_CBC]        = { cbc(cipher_null),  SW_TYPE_BLKCIPHER, },
-	[CRYPTO_DEFLATE_COMP]    = { plain(deflate),    SW_TYPE_COMP, },
-	[CRYPTO_SHA2_256_HMAC]   = { hmac(sha256),      SW_TYPE_HMAC, },
-	[CRYPTO_SHA2_384_HMAC]   = { hmac(sha384),      SW_TYPE_HMAC, },
-	[CRYPTO_SHA2_512_HMAC]   = { hmac(sha512),      SW_TYPE_HMAC, },
-	[CRYPTO_CAMELLIA_CBC]    = { cbc(camellia),     SW_TYPE_BLKCIPHER, },
-	[CRYPTO_SHA2_256]        = { plain(sha256),     SW_TYPE_HASH, },
-	[CRYPTO_SHA2_384]        = { plain(sha384),     SW_TYPE_HASH, },
-	[CRYPTO_SHA2_512]        = { plain(sha512),     SW_TYPE_HASH, },
-	[CRYPTO_RIPEMD160]       = { plain(ripemd160),  SW_TYPE_HASH, },
+/*
+ * This needs to be kept updated with CRYPTO_xxx list (cryptodev.h).
+ * If the Algorithm is not supported, then insert a {NULL, 0, 0} entry.
+ *
+ * IMPORTANT: The index to the array IS CRYPTO_xxx.
+ */
+static struct crypto_details crypto_details[CRYPTO_ALGORITHM_MAX + 1] = {
+	{ NULL,              0,                   0 },
+	/* CRYPTO_xxx index starts at 1 */
+	{ cbc(des),          CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ cbc(des3_ede),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ cbc(blowfish),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ cbc(cast5),        CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ cbc(skipjack),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ hmac(md5),         0,                   SW_TYPE_HMAC },
+	{ hmac(sha1),        0,                   SW_TYPE_HMAC },
+	{ hmac(ripemd160),   0,                   SW_TYPE_HMAC },
+	{ "md5-kpdk??",      0,                   SW_TYPE_HASH },
+	{ "sha1-kpdk??",     0,                   SW_TYPE_HASH },
+	{ cbc(aes),          CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ ecb(arc4),         CRYPTO_TFM_MODE_ECB, SW_TYPE_BLKCIPHER },
+	{ "md5",             0,                   SW_TYPE_HASH },
+	{ "sha1",            0,                   SW_TYPE_HASH },
+	{ hmac(digest_null), 0,                   SW_TYPE_HMAC },
+	{ cbc(cipher_null),  CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ "deflate",         0,                   SW_TYPE_COMP },
+	{ hmac(sha256),      0,                   SW_TYPE_HMAC },
+	{ hmac(sha384),      0,                   SW_TYPE_HMAC },
+	{ hmac(sha512),      0,                   SW_TYPE_HMAC },
+	{ cbc(camellia),     CRYPTO_TFM_MODE_CBC, SW_TYPE_BLKCIPHER },
+	{ "sha256",          0,                   SW_TYPE_HASH },
+	{ "sha384",          0,                   SW_TYPE_HASH },
+	{ "sha512",          0,                   SW_TYPE_HASH },
+	{ "ripemd160",       0,                   SW_TYPE_HASH },
 };
 
 int32_t swcr_id = -1;
@@ -253,16 +197,6 @@ module_param(swcr_fail_if_compression_grows, int, 0644);
 MODULE_PARM_DESC(swcr_fail_if_compression_grows,
                 "Treat compression that results in more data as a failure");
 
-int swcr_no_ahash = 0;
-module_param(swcr_no_ahash, int, 0644);
-MODULE_PARM_DESC(swcr_no_ahash,
-                "Do not use async hash/hmac even if available");
-
-int swcr_no_ablk = 0;
-module_param(swcr_no_ablk, int, 0644);
-MODULE_PARM_DESC(swcr_no_ablk,
-                "Do not use async blk ciphers even if available");
-
 static struct swcr_data **swcr_sessions = NULL;
 static u_int32_t swcr_sesnum = 0;
 
@@ -282,58 +216,6 @@ int swcr_debug = 0;
 module_param(swcr_debug, int, 0644);
 MODULE_PARM_DESC(swcr_debug, "Enable debug");
 
-static void swcr_process_req(struct swcr_req *req);
-
-/*
- * somethings just need to be run with user context no matter whether
- * the kernel compression libs use vmalloc/vfree for example.
- */
-
-typedef struct {
-	struct work_struct wq;
-	void	(*func)(void *arg);
-	void	*arg;
-} execute_later_t;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-static void
-doing_it_now(struct work_struct *wq)
-{
-	execute_later_t *w = container_of(wq, execute_later_t, wq);
-	(w->func)(w->arg);
-	kfree(w);
-}
-#else
-static void
-doing_it_now(void *arg)
-{
-	execute_later_t *w = (execute_later_t *) arg;
-	(w->func)(w->arg);
-	kfree(w);
-}
-#endif
-
-static void
-execute_later(void (fn)(void *), void *arg)
-{
-	execute_later_t *w;
-
-	w = (execute_later_t *) kmalloc(sizeof(execute_later_t), SLAB_ATOMIC);
-	if (w) {
-		memset(w, '\0', sizeof(w));
-		w->func = fn;
-		w->arg = arg;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-		INIT_WORK(&w->wq, doing_it_now);
-#else
-		INIT_WORK(&w->wq, doing_it_now, w);
-#endif
-		schedule_work(&w->wq);
-	}
-}
-
-static DEFINE_SPINLOCK(session_lock);
-
 /*
  * Generate a new software session.
  */
@@ -344,15 +226,11 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 	u_int32_t i;
 	int error;
 	char *algo;
-	int mode;
-	unsigned long flags;
-
-	spin_lock_irqsave(&session_lock, flags);
+	int mode, sw_type;
 
 	dprintk("%s()\n", __FUNCTION__);
 	if (sid == NULL || cri == NULL) {
 		dprintk("%s,%d - EINVAL\n", __FILE__, __LINE__);
-		spin_unlock_irqrestore(&session_lock, flags);
 		return EINVAL;
 	}
 
@@ -378,7 +256,6 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			else
 				swcr_sesnum /= 2;
 			dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
-			spin_unlock_irqrestore(&session_lock, flags);
 			return ENOBUFS;
 		}
 		memset(swd, 0, swcr_sesnum * sizeof(struct swcr_data *));
@@ -400,17 +277,14 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		*swd = (struct swcr_data *) kmalloc(sizeof(struct swcr_data),
 				SLAB_ATOMIC);
 		if (*swd == NULL) {
-			spin_unlock_irqrestore(&session_lock, flags);
 			swcr_freesession(NULL, i);
 			dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
 			return ENOBUFS;
 		}
 		memset(*swd, 0, sizeof(struct swcr_data));
 
-		if (cri->cri_alg < 0 ||
-				cri->cri_alg>=sizeof(crypto_details)/sizeof(crypto_details[0])){
+		if (cri->cri_alg > CRYPTO_ALGORITHM_MAX) {
 			printk("cryptosoft: Unknown algorithm 0x%x\n", cri->cri_alg);
-			spin_unlock_irqrestore(&session_lock, flags);
 			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
@@ -418,16 +292,12 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		algo = crypto_details[cri->cri_alg].alg_name;
 		if (!algo || !*algo) {
 			printk("cryptosoft: Unsupported algorithm 0x%x\n", cri->cri_alg);
-			spin_unlock_irqrestore(&session_lock, flags);
 			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
 		mode = crypto_details[cri->cri_alg].mode;
-		(*swd)->sw_type = crypto_details[cri->cri_alg].sw_type;
-		(*swd)->sw_alg = cri->cri_alg;
-
-		spin_lock_init(&(*swd)->sw_tfm_lock);
+		sw_type = crypto_details[cri->cri_alg].sw_type;
 
 		/* Algorithm specific configuration */
 		switch (cri->cri_alg) {
@@ -438,104 +308,56 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			break;
 		}
 
-		if ((*swd)->sw_type & SW_TYPE_BLKCIPHER) {
-			spin_unlock_irqrestore(&session_lock, flags);
-			dprintk("%s crypto_alloc_*blkcipher(%s, 0x%x)\n", __FUNCTION__,
+		if (sw_type == SW_TYPE_BLKCIPHER) {
+			dprintk("%s crypto_alloc_blkcipher(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
-			/* try async first */
-			(*swd)->sw_tfm = swcr_no_ablk ? NULL :
-					crypto_ablkcipher_tfm(crypto_alloc_ablkcipher(algo, 0, 0));
-			spin_lock_irqsave(&session_lock, flags);
-			if ((*swd)->sw_tfm && !IS_ERR((*swd)->sw_tfm)) {
-				dprintk("%s %s cipher is async\n", __FUNCTION__, algo);
-				(*swd)->sw_type |= SW_TYPE_ASYNC;
-				spin_unlock_irqrestore(&session_lock, flags);
-			} else {
-				spin_unlock_irqrestore(&session_lock, flags);
-				(*swd)->sw_tfm = crypto_blkcipher_tfm(
-						crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC));
-				if ((*swd)->sw_tfm && !IS_ERR((*swd)->sw_tfm))
-					dprintk("%s %s cipher is sync\n", __FUNCTION__, algo);
-			}
-			spin_lock_irqsave(&session_lock, flags);
-			if (!(*swd)->sw_tfm || IS_ERR((*swd)->sw_tfm)) {
-				int err;
-				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s, 0x%x)\n",
+			(*swd)->sw_tfm = crypto_blkcipher_tfm(
+								crypto_alloc_blkcipher(algo, 0,
+									CRYPTO_ALG_ASYNC));
+			if (!(*swd)->sw_tfm) {
+				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s,0x%x)\n",
 						algo,mode);
-				err = IS_ERR((*swd)->sw_tfm) ? -(PTR_ERR((*swd)->sw_tfm)) : EINVAL;
-				(*swd)->sw_tfm = NULL; /* ensure NULL */
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
-				return err;
+				return EINVAL;
 			}
 
 			if (debug) {
 				dprintk("%s key:cri->cri_klen=%d,(cri->cri_klen + 7)/8=%d",
-						__FUNCTION__, cri->cri_klen, (cri->cri_klen + 7) / 8);
+						__FUNCTION__,cri->cri_klen,(cri->cri_klen + 7)/8);
 				for (i = 0; i < (cri->cri_klen + 7) / 8; i++)
-					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
-							cri->cri_key[i] & 0xff);
+				{
+					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",cri->cri_key[i]);
+				}
 				dprintk("\n");
 			}
-			if ((*swd)->sw_type & SW_TYPE_ASYNC) {
-				/* OCF doesn't enforce keys */
-				crypto_ablkcipher_set_flags(
-						__crypto_ablkcipher_cast((*swd)->sw_tfm),
-							CRYPTO_TFM_REQ_WEAK_KEY);
-				error = crypto_ablkcipher_setkey(
-							__crypto_ablkcipher_cast((*swd)->sw_tfm),
-								cri->cri_key, (cri->cri_klen + 7) / 8);
-			} else {
-				/* OCF doesn't enforce keys */
-				crypto_blkcipher_set_flags(
-						crypto_blkcipher_cast((*swd)->sw_tfm),
-							CRYPTO_TFM_REQ_WEAK_KEY);
-				error = crypto_blkcipher_setkey(
-							crypto_blkcipher_cast((*swd)->sw_tfm),
-								cri->cri_key, (cri->cri_klen + 7) / 8);
-			}
+			error = crypto_blkcipher_setkey(
+						crypto_blkcipher_cast((*swd)->sw_tfm), cri->cri_key,
+							(cri->cri_klen + 7) / 8);
 			if (error) {
 				printk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n", error,
 						(*swd)->sw_tfm->crt_flags);
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				return error;
 			}
-		} else if ((*swd)->sw_type & (SW_TYPE_HMAC | SW_TYPE_HASH)) {
-			spin_unlock_irqrestore(&session_lock, flags);
-			dprintk("%s crypto_alloc_*hash(%s, 0x%x)\n", __FUNCTION__,
+		} else if (sw_type == SW_TYPE_HMAC || sw_type == SW_TYPE_HASH) {
+			dprintk("%s crypto_alloc_hash(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
-			/* try async first */
-			(*swd)->sw_tfm = swcr_no_ahash ? NULL :
-					crypto_ahash_tfm(crypto_alloc_ahash(algo, 0, 0));
-			spin_lock_irqsave(&session_lock, flags);
-			if ((*swd)->sw_tfm) {
-				dprintk("%s %s hash is async\n", __FUNCTION__, algo);
-				(*swd)->sw_type |= SW_TYPE_ASYNC;
-				spin_unlock_irqrestore(&session_lock, flags);
-			} else {
-				spin_unlock_irqrestore(&session_lock, flags);
-				dprintk("%s %s hash is sync\n", __FUNCTION__, algo);
-				(*swd)->sw_tfm = crypto_hash_tfm(
-						crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
-			}
+			(*swd)->sw_tfm = crypto_hash_tfm(
+								crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
 
-			spin_lock_irqsave(&session_lock, flags);
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_hash failed(%s,0x%x)\n",
 						algo, mode);
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				return EINVAL;
 			}
 
 			(*swd)->u.hmac.sw_klen = (cri->cri_klen + 7) / 8;
 			(*swd)->u.hmac.sw_key = (char *)kmalloc((*swd)->u.hmac.sw_klen,
-					SLAB_ATOMIC);
+				SLAB_ATOMIC);
 			if ((*swd)->u.hmac.sw_key == NULL) {
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
 				return ENOBUFS;
@@ -543,43 +365,38 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			memcpy((*swd)->u.hmac.sw_key, cri->cri_key, (*swd)->u.hmac.sw_klen);
 			if (cri->cri_mlen) {
 				(*swd)->u.hmac.sw_mlen = cri->cri_mlen;
-			} else if ((*swd)->sw_type & SW_TYPE_ASYNC) {
-				(*swd)->u.hmac.sw_mlen = crypto_ahash_digestsize(
-						__crypto_ahash_cast((*swd)->sw_tfm));
-			} else  {
-				(*swd)->u.hmac.sw_mlen = crypto_hash_digestsize(
-						crypto_hash_cast((*swd)->sw_tfm));
+			} else {
+				(*swd)->u.hmac.sw_mlen =
+						crypto_hash_digestsize(
+								crypto_hash_cast((*swd)->sw_tfm));
 			}
-		} else if ((*swd)->sw_type & SW_TYPE_COMP) {
-			spin_unlock_irqrestore(&session_lock, flags);
+		} else if (sw_type == SW_TYPE_COMP) {
 			(*swd)->sw_tfm = crypto_comp_tfm(
 					crypto_alloc_comp(algo, 0, CRYPTO_ALG_ASYNC));
-			spin_lock_irqsave(&session_lock, flags);
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_comp failed(%s,0x%x)\n",
 						algo, mode);
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				return EINVAL;
 			}
 			(*swd)->u.sw_comp_buf = kmalloc(CRYPTO_MAX_DATA_LEN, SLAB_ATOMIC);
 			if ((*swd)->u.sw_comp_buf == NULL) {
-				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
 				return ENOBUFS;
 			}
 		} else {
-			printk("cryptosoft: Unhandled sw_type %d\n", (*swd)->sw_type);
-			spin_unlock_irqrestore(&session_lock, flags);
+			printk("cryptosoft: Unhandled sw_type %d\n", sw_type);
 			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
+		(*swd)->sw_alg = cri->cri_alg;
+		(*swd)->sw_type = sw_type;
+
 		cri = cri->cri_next;
 		swd = &((*swd)->sw_next);
 	}
-	spin_unlock_irqrestore(&session_lock, flags);
 	return 0;
 }
 
@@ -591,58 +408,23 @@ swcr_freesession(device_t dev, u_int64_t tid)
 {
 	struct swcr_data *swd;
 	u_int32_t sid = CRYPTO_SESID2LID(tid);
-	unsigned long flags;
 
-	spin_lock_irqsave(&session_lock, flags);
 	dprintk("%s()\n", __FUNCTION__);
 	if (sid > swcr_sesnum || swcr_sessions == NULL ||
 			swcr_sessions[sid] == NULL) {
 		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		spin_unlock_irqrestore(&session_lock, flags);
 		return(EINVAL);
 	}
 
 	/* Silently accept and return */
-	if (sid == 0) {
-		spin_unlock_irqrestore(&session_lock, flags);
+	if (sid == 0)
 		return(0);
-	}
 
 	while ((swd = swcr_sessions[sid]) != NULL) {
 		swcr_sessions[sid] = swd->sw_next;
-		if (swd->sw_tfm) {
-			switch (swd->sw_type & SW_TYPE_ALG_AMASK) {
-#ifdef HAVE_AHASH
-			case SW_TYPE_AHMAC:
-			case SW_TYPE_AHASH:
-				crypto_free_ahash(__crypto_ahash_cast(swd->sw_tfm));
-				break;
-#endif
-#ifdef HAVE_ABLKCIPHER
-			case SW_TYPE_ABLKCIPHER:
-				crypto_free_ablkcipher(__crypto_ablkcipher_cast(swd->sw_tfm));
-				break;
-#endif
-			case SW_TYPE_BLKCIPHER:
-				crypto_free_blkcipher(crypto_blkcipher_cast(swd->sw_tfm));
-				break;
-			case SW_TYPE_HMAC:
-			case SW_TYPE_HASH:
-				crypto_free_hash(crypto_hash_cast(swd->sw_tfm));
-				break;
-			case SW_TYPE_COMP:
-				if (in_interrupt())
-					execute_later((void (*)(void *))crypto_free_comp, (void *)crypto_comp_cast(swd->sw_tfm));
-				else
-					crypto_free_comp(crypto_comp_cast(swd->sw_tfm));
-				break;
-			default:
-				crypto_free_tfm(swd->sw_tfm);
-				break;
-			}
-			swd->sw_tfm = NULL;
-		}
-		if (swd->sw_type & SW_TYPE_COMP) {
+		if (swd->sw_tfm)
+			crypto_free_tfm(swd->sw_tfm);
+		if (swd->sw_type == SW_TYPE_COMP) {
 			if (swd->u.sw_comp_buf)
 				kfree(swd->u.sw_comp_buf);
 		} else {
@@ -651,623 +433,354 @@ swcr_freesession(device_t dev, u_int64_t tid)
 		}
 		kfree(swd);
 	}
-	spin_unlock_irqrestore(&session_lock, flags);
 	return 0;
 }
 
-static void swcr_process_req_complete(struct swcr_req *req)
-{
-	dprintk("%s()\n", __FUNCTION__);
-
-	if (req->sw->sw_type & SW_TYPE_INUSE) {
-		unsigned long flags;
-		spin_lock_irqsave(&req->sw->sw_tfm_lock, flags);
-		req->sw->sw_type &= ~SW_TYPE_INUSE;
-		spin_unlock_irqrestore(&req->sw->sw_tfm_lock, flags);
-	}
-
-	if (req->crp->crp_etype)
-		goto done;
-
-	switch (req->sw->sw_type & SW_TYPE_ALG_AMASK) {
-#if defined(HAVE_AHASH)
-	case SW_TYPE_AHMAC:
-	case SW_TYPE_AHASH:
-		crypto_copyback(req->crp->crp_flags, req->crp->crp_buf,
-				req->crd->crd_inject, req->sw->u.hmac.sw_mlen, req->result);
-		ahash_request_free(req->crypto_req);
-		break;
-#endif
-#if defined(HAVE_ABLKCIPHER)
-	case SW_TYPE_ABLKCIPHER:
-		ablkcipher_request_free(req->crypto_req);
-		break;
-#endif
-	case SW_TYPE_CIPHER:
-	case SW_TYPE_HMAC:
-	case SW_TYPE_HASH:
-	case SW_TYPE_COMP:
-	case SW_TYPE_BLKCIPHER:
-		break;
-	default:
-		req->crp->crp_etype = EINVAL;
-		goto done;
-	}
-
-	req->crd = req->crd->crd_next;
-	if (req->crd) {
-		swcr_process_req(req);
-		return;
-	}
-
-done:
-	dprintk("%s crypto_done %p\n", __FUNCTION__, req);
-	crypto_done(req->crp);
-	kmem_cache_free(swcr_req_cache, req);
-}
-
-#if defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH)
-static void swcr_process_callback(struct crypto_async_request *creq, int err)
-{
-	struct swcr_req *req = creq->data;
-
-	dprintk("%s()\n", __FUNCTION__);
-	if (err) {
-		if (err == -EINPROGRESS)
-			return;
-		dprintk("%s() fail %d\n", __FUNCTION__, -err);
-		req->crp->crp_etype = -err;
-	}
-
-	swcr_process_req_complete(req);
-}
-#endif /* defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH) */
-
-
-static void swcr_process_req(struct swcr_req *req)
+/*
+ * Process a software request.
+ */
+static int
+swcr_process(device_t dev, struct cryptop *crp, int hint)
 {
+	struct cryptodesc *crd;
 	struct swcr_data *sw;
-	struct cryptop *crp = req->crp;
-	struct cryptodesc *crd = req->crd;
-	struct sk_buff *skb = (struct sk_buff *) crp->crp_buf;
-	struct uio *uiop = (struct uio *) crp->crp_buf;
+	u_int32_t lid;
+#define SCATTERLIST_MAX 16
+	struct scatterlist sg[SCATTERLIST_MAX];
 	int sg_num, sg_len, skip;
+	struct sk_buff *skb = NULL;
+	struct uio *uiop = NULL;
 
 	dprintk("%s()\n", __FUNCTION__);
+	/* Sanity check */
+	if (crp == NULL) {
+		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		return EINVAL;
+	}
 
-	/*
-	 * Find the crypto context.
-	 *
-	 * XXX Note that the logic here prevents us from having
-	 * XXX the same algorithm multiple times in a session
-	 * XXX (or rather, we can but it won't give us the right
-	 * XXX results). To do that, we'd need some way of differentiating
-	 * XXX between the various instances of an algorithm (so we can
-	 * XXX locate the correct crypto context).
-	 */
-	for (sw = req->sw_head; sw && sw->sw_alg != crd->crd_alg; sw = sw->sw_next)
-		;
+	crp->crp_etype = 0;
 
-	/* No such context ? */
-	if (sw == NULL) {
-		crp->crp_etype = EINVAL;
+	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
 		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		crp->crp_etype = EINVAL;
 		goto done;
 	}
 
-	/*
-	 * for some types we need to ensure only one user as info is stored in
-	 * the tfm during an operation that can get corrupted
-	 */
-	switch (sw->sw_type & SW_TYPE_ALG_AMASK) {
-#ifdef HAVE_AHASH
-	case SW_TYPE_AHMAC:
-	case SW_TYPE_AHASH:
-#endif
-	case SW_TYPE_HMAC:
-	case SW_TYPE_HASH: {
-		unsigned long flags;
-		spin_lock_irqsave(&sw->sw_tfm_lock, flags);
-		if (sw->sw_type & SW_TYPE_INUSE) {
-			spin_unlock_irqrestore(&sw->sw_tfm_lock, flags);
-			execute_later((void (*)(void *))swcr_process_req, (void *)req);
-			return;
-		}
-		sw->sw_type |= SW_TYPE_INUSE;
-		spin_unlock_irqrestore(&sw->sw_tfm_lock, flags);
-		} break;
+	lid = crp->crp_sid & 0xffffffff;
+	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions == NULL ||
+			swcr_sessions[lid] == NULL) {
+		crp->crp_etype = ENOENT;
+		dprintk("%s,%d: ENOENT\n", __FILE__, __LINE__);
+		goto done;
 	}
 
-	req->sw = sw;
-	skip = crd->crd_skip;
-
 	/*
-	 * setup the SG list skip from the start of the buffer
+	 * do some error checking outside of the loop for SKB and IOV processing
+	 * this leaves us with valid skb or uiop pointers for later
 	 */
-	memset(req->sg, 0, sizeof(req->sg));
-	sg_init_table(req->sg, SCATTERLIST_MAX);
 	if (crp->crp_flags & CRYPTO_F_SKBUF) {
-		int i, len;
-
-		sg_num = 0;
-		sg_len = 0;
-
-		if (skip < skb_headlen(skb)) {
-			len = skb_headlen(skb) - skip;
-			if (len + sg_len > crd->crd_len)
-				len = crd->crd_len - sg_len;
-			sg_set_page(&req->sg[sg_num],
-				virt_to_page(skb->data + skip), len,
-				offset_in_page(skb->data + skip));
-			sg_len += len;
-			sg_num++;
-			skip = 0;
-		} else
-			skip -= skb_headlen(skb);
-
-		for (i = 0; sg_len < crd->crd_len &&
-					i < skb_shinfo(skb)->nr_frags &&
-					sg_num < SCATTERLIST_MAX; i++) {
-			if (skip < skb_shinfo(skb)->frags[i].size) {
-				len = skb_shinfo(skb)->frags[i].size - skip;
-				if (len + sg_len > crd->crd_len)
-					len = crd->crd_len - sg_len;
-				sg_set_page(&req->sg[sg_num],
-					skb_frag_page(&skb_shinfo(skb)->frags[i]),
-					len,
-					skb_shinfo(skb)->frags[i].page_offset + skip);
-				sg_len += len;
-				sg_num++;
-				skip = 0;
-			} else
-				skip -= skb_shinfo(skb)->frags[i].size;
-		}
-	} else if (crp->crp_flags & CRYPTO_F_IOV) {
-		int len;
-
-		sg_len = 0;
-		for (sg_num = 0; sg_len < crd->crd_len &&
-				sg_num < uiop->uio_iovcnt &&
-				sg_num < SCATTERLIST_MAX; sg_num++) {
-			if (skip <= uiop->uio_iov[sg_num].iov_len) {
-				len = uiop->uio_iov[sg_num].iov_len - skip;
-				if (len + sg_len > crd->crd_len)
-					len = crd->crd_len - sg_len;
-				sg_set_page(&req->sg[sg_num],
-					virt_to_page(uiop->uio_iov[sg_num].iov_base+skip),
-					len,
-					offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
-				sg_len += len;
-				skip = 0;
-			} else 
-				skip -= uiop->uio_iov[sg_num].iov_len;
-		}
-	} else {
-		sg_len = (crp->crp_ilen - skip);
-		if (sg_len > crd->crd_len)
-			sg_len = crd->crd_len;
-		sg_set_page(&req->sg[0], virt_to_page(crp->crp_buf + skip),
-			sg_len, offset_in_page(crp->crp_buf + skip));
-		sg_num = 1;
-	}
-	if (sg_num > 0)
-		sg_mark_end(&req->sg[sg_num-1]);
-
-	switch (sw->sw_type & SW_TYPE_ALG_AMASK) {
-
-#ifdef HAVE_AHASH
-	case SW_TYPE_AHMAC:
-	case SW_TYPE_AHASH:
-		{
-		int ret;
-
-		/* check we have room for the result */
-		if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
-			dprintk("cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d "
-					"digestsize=%d\n", crp->crp_ilen, crd->crd_skip + sg_len,
-					crd->crd_inject, sw->u.hmac.sw_mlen);
-			crp->crp_etype = EINVAL;
+		skb = (struct sk_buff *) crp->crp_buf;
+		if (skb_shinfo(skb)->nr_frags >= SCATTERLIST_MAX) {
+			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX", __FILE__, __LINE__,
+					skb_shinfo(skb)->nr_frags);
 			goto done;
 		}
-
-		req->crypto_req =
-				ahash_request_alloc(__crypto_ahash_cast(sw->sw_tfm),GFP_ATOMIC);
-		if (!req->crypto_req) {
-			crp->crp_etype = ENOMEM;
-			dprintk("%s,%d: ENOMEM ahash_request_alloc", __FILE__, __LINE__);
+	} else if (crp->crp_flags & CRYPTO_F_IOV) {
+		uiop = (struct uio *) crp->crp_buf;
+		if (uiop->uio_iovcnt > SCATTERLIST_MAX) {
+			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX", __FILE__, __LINE__,
+					uiop->uio_iovcnt);
 			goto done;
 		}
+	}
 
-		ahash_request_set_callback(req->crypto_req,
-				CRYPTO_TFM_REQ_MAY_BACKLOG, swcr_process_callback, req);
-
-		memset(req->result, 0, sizeof(req->result));
-
-		if (sw->sw_type & SW_TYPE_AHMAC)
-			crypto_ahash_setkey(__crypto_ahash_cast(sw->sw_tfm),
-					sw->u.hmac.sw_key, sw->u.hmac.sw_klen);
-		ahash_request_set_crypt(req->crypto_req, req->sg, req->result, sg_len);
-		ret = crypto_ahash_digest(req->crypto_req);
-		switch (ret) {
-		case -EINPROGRESS:
-		case -EBUSY:
-			return;
-		default:
-		case 0:
-			dprintk("hash OP %s %d\n", ret ? "failed" : "success", ret);
-			crp->crp_etype = ret;
-			goto done;
-		}
-		} break;
-#endif /* HAVE_AHASH */
-
-#ifdef HAVE_ABLKCIPHER
-	case SW_TYPE_ABLKCIPHER: {
-		int ret;
-		unsigned char *ivp = req->iv;
-		int ivsize = 
-			crypto_ablkcipher_ivsize(__crypto_ablkcipher_cast(sw->sw_tfm));
-
-		if (sg_len < crypto_ablkcipher_blocksize(
-				__crypto_ablkcipher_cast(sw->sw_tfm))) {
-			crp->crp_etype = EINVAL;
-			dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
-					sg_len, crypto_ablkcipher_blocksize(
-						__crypto_ablkcipher_cast(sw->sw_tfm)));
-			goto done;
-		}
+	/* Go through crypto descriptors, processing as we go */
+	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
+		/*
+		 * Find the crypto context.
+		 *
+		 * XXX Note that the logic here prevents us from having
+		 * XXX the same algorithm multiple times in a session
+		 * XXX (or rather, we can but it won't give us the right
+		 * XXX results). To do that, we'd need some way of differentiating
+		 * XXX between the various instances of an algorithm (so we can
+		 * XXX locate the correct crypto context).
+		 */
+		for (sw = swcr_sessions[lid]; sw && sw->sw_alg != crd->crd_alg;
+				sw = sw->sw_next)
+			;
 
-		if (ivsize > sizeof(req->iv)) {
+		/* No such context ? */
+		if (sw == NULL) {
 			crp->crp_etype = EINVAL;
 			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
 			goto done;
 		}
 
-		req->crypto_req = ablkcipher_request_alloc(
-				__crypto_ablkcipher_cast(sw->sw_tfm), GFP_ATOMIC);
-		if (!req->crypto_req) {
-			crp->crp_etype = ENOMEM;
-			dprintk("%s,%d: ENOMEM ablkcipher_request_alloc",
-					__FILE__, __LINE__);
-			goto done;
-		}
+		skip = crd->crd_skip;
 
-		ablkcipher_request_set_callback(req->crypto_req,
-				CRYPTO_TFM_REQ_MAY_BACKLOG, swcr_process_callback, req);
+		/*
+		 * setup the SG list skip from the start of the buffer
+		 */
+		memset(sg, 0, sizeof(sg));
+		if (crp->crp_flags & CRYPTO_F_SKBUF) {
+			int i, len;
 
-		if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
-			int i, error;
+			sg_num = 0;
+			sg_len = 0;
 
-			if (debug) {
-				dprintk("%s key:", __FUNCTION__);
-				for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
-					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
-							crd->crd_key[i] & 0xff);
-				dprintk("\n");
+			if (skip < skb_headlen(skb)) {
+				len = skb_headlen(skb) - skip;
+				if (len + sg_len > crd->crd_len)
+					len = crd->crd_len - sg_len;
+				sg_set_page(&sg[sg_num],
+					virt_to_page(skb->data + skip), len,
+					offset_in_page(skb->data + skip));
+				sg_len += len;
+				sg_num++;
+				skip = 0;
+			} else
+				skip -= skb_headlen(skb);
+
+			for (i = 0; sg_len < crd->crd_len &&
+						i < skb_shinfo(skb)->nr_frags &&
+						sg_num < SCATTERLIST_MAX; i++) {
+				if (skip < skb_shinfo(skb)->frags[i].size) {
+					len = skb_shinfo(skb)->frags[i].size - skip;
+					if (len + sg_len > crd->crd_len)
+						len = crd->crd_len - sg_len;
+					sg_set_page(&sg[sg_num],
+						skb_shinfo(skb)->frags[i].page,
+						len,
+						skb_shinfo(skb)->frags[i].page_offset + skip);
+					sg_len += len;
+					sg_num++;
+					skip = 0;
+				} else
+					skip -= skb_shinfo(skb)->frags[i].size;
 			}
-			/* OCF doesn't enforce keys */
-			crypto_ablkcipher_set_flags(__crypto_ablkcipher_cast(sw->sw_tfm),
-					CRYPTO_TFM_REQ_WEAK_KEY);
-			error = crypto_ablkcipher_setkey(
-						__crypto_ablkcipher_cast(sw->sw_tfm), crd->crd_key,
-						(crd->crd_klen + 7) / 8);
-			if (error) {
-				dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
-						error, sw->sw_tfm->crt_flags);
-				crp->crp_etype = -error;
+		} else if (crp->crp_flags & CRYPTO_F_IOV) {
+			int len;
+
+			sg_len = 0;
+			for (sg_num = 0; sg_len <= crd->crd_len &&
+					sg_num < uiop->uio_iovcnt &&
+					sg_num < SCATTERLIST_MAX; sg_num++) {
+				if (skip <= uiop->uio_iov[sg_num].iov_len) {
+					len = uiop->uio_iov[sg_num].iov_len - skip;
+					if (len + sg_len > crd->crd_len)
+						len = crd->crd_len - sg_len;
+					sg_set_page(&sg[sg_num],
+						virt_to_page(uiop->uio_iov[sg_num].iov_base+skip),
+						len,
+						offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
+					sg_len += len;
+					skip = 0;
+				} else 
+					skip -= uiop->uio_iov[sg_num].iov_len;
 			}
-		}
-
-		if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
-
-			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
-				ivp = crd->crd_iv;
-			else
-				get_random_bytes(ivp, ivsize);
-			/*
-			 * do we have to copy the IV back to the buffer ?
-			 */
-			if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
-				crypto_copyback(crp->crp_flags, crp->crp_buf,
-						crd->crd_inject, ivsize, (caddr_t)ivp);
+		} else {
+			sg_len = (crp->crp_ilen - skip);
+			if (sg_len > crd->crd_len)
+				sg_len = crd->crd_len;
+			sg_set_page(&sg[0], virt_to_page(crp->crp_buf + skip),
+				sg_len, offset_in_page(crp->crp_buf + skip));
+			sg_num = 1;
+		}
+
+
+		switch (sw->sw_type) {
+		case SW_TYPE_BLKCIPHER: {
+			unsigned char iv[EALG_MAX_BLOCK_LEN];
+			unsigned char *ivp = iv;
+			int ivsize = 
+				crypto_blkcipher_ivsize(crypto_blkcipher_cast(sw->sw_tfm));
+			struct blkcipher_desc desc;
+
+			if (sg_len < crypto_blkcipher_blocksize(
+					crypto_blkcipher_cast(sw->sw_tfm))) {
+				crp->crp_etype = EINVAL;
+				dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
+						sg_len, crypto_blkcipher_blocksize(
+							crypto_blkcipher_cast(sw->sw_tfm)));
+				goto done;
 			}
-			ablkcipher_request_set_crypt(req->crypto_req, req->sg, req->sg,
-					sg_len, ivp);
-			ret = crypto_ablkcipher_encrypt(req->crypto_req);
 
-		} else { /*decrypt */
-
-			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
-				ivp = crd->crd_iv;
-			else
-				crypto_copydata(crp->crp_flags, crp->crp_buf,
-						crd->crd_inject, ivsize, (caddr_t)ivp);
-			ablkcipher_request_set_crypt(req->crypto_req, req->sg, req->sg,
-					sg_len, ivp);
-			ret = crypto_ablkcipher_decrypt(req->crypto_req);
-		}
-
-		switch (ret) {
-		case -EINPROGRESS:
-		case -EBUSY:
-			return;
-		default:
-		case 0:
-			dprintk("crypto OP %s %d\n", ret ? "failed" : "success", ret);
-			crp->crp_etype = ret;
-			goto done;
-		}
-		} break;
-#endif /* HAVE_ABLKCIPHER */
-
-	case SW_TYPE_BLKCIPHER: {
-		unsigned char iv[EALG_MAX_BLOCK_LEN];
-		unsigned char *ivp = iv;
-		struct blkcipher_desc desc;
-		int ivsize = crypto_blkcipher_ivsize(crypto_blkcipher_cast(sw->sw_tfm));
-
-		if (sg_len < crypto_blkcipher_blocksize(
-				crypto_blkcipher_cast(sw->sw_tfm))) {
-			crp->crp_etype = EINVAL;
-			dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
-					sg_len, crypto_blkcipher_blocksize(
-						crypto_blkcipher_cast(sw->sw_tfm)));
-			goto done;
-		}
-
-		if (ivsize > sizeof(iv)) {
-			crp->crp_etype = EINVAL;
-			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-			goto done;
-		}
-
-		if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
-			int i, error;
-
-			if (debug) {
-				dprintk("%s key:", __FUNCTION__);
-				for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
-					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
-							crd->crd_key[i] & 0xff);
-				dprintk("\n");
+			if (ivsize > sizeof(iv)) {
+				crp->crp_etype = EINVAL;
+				dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+				goto done;
 			}
-			/* OCF doesn't enforce keys */
-			crypto_blkcipher_set_flags(crypto_blkcipher_cast(sw->sw_tfm),
-					CRYPTO_TFM_REQ_WEAK_KEY);
-			error = crypto_blkcipher_setkey(
-						crypto_blkcipher_cast(sw->sw_tfm), crd->crd_key,
-						(crd->crd_klen + 7) / 8);
-			if (error) {
-				dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
-						error, sw->sw_tfm->crt_flags);
-				crp->crp_etype = -error;
-			}
-		}
 
-		memset(&desc, 0, sizeof(desc));
-		desc.tfm = crypto_blkcipher_cast(sw->sw_tfm);
+			if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
+				int i, error;
 
-		if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
-
-			if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
-				ivp = crd->crd_iv;
-			} else {
-				get_random_bytes(ivp, ivsize);
-			}
-			/*
-			 * do we have to copy the IV back to the buffer ?
-			 */
-			if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
-				crypto_copyback(crp->crp_flags, crp->crp_buf,
-						crd->crd_inject, ivsize, (caddr_t)ivp);
+				if (debug) {
+					dprintk("%s key:", __FUNCTION__);
+					for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
+						dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
+								crd->crd_key[i]);
+					dprintk("\n");
+				}
+				error = crypto_blkcipher_setkey(
+							crypto_blkcipher_cast(sw->sw_tfm), crd->crd_key,
+							(crd->crd_klen + 7) / 8);
+				if (error) {
+					dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
+							error, sw->sw_tfm->crt_flags);
+					crp->crp_etype = -error;
+				}
 			}
-			desc.info = ivp;
-			crypto_blkcipher_encrypt_iv(&desc, req->sg, req->sg, sg_len);
-
-		} else { /*decrypt */
 
-			if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
-				ivp = crd->crd_iv;
-			} else {
-				crypto_copydata(crp->crp_flags, crp->crp_buf,
-						crd->crd_inject, ivsize, (caddr_t)ivp);
+			memset(&desc, 0, sizeof(desc));
+			desc.tfm = crypto_blkcipher_cast(sw->sw_tfm);
+
+			if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
+
+				if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
+					ivp = crd->crd_iv;
+				} else {
+					get_random_bytes(ivp, ivsize);
+				}
+				/*
+				 * do we have to copy the IV back to the buffer ?
+				 */
+				if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+					crypto_copyback(crp->crp_flags, crp->crp_buf,
+							crd->crd_inject, ivsize, (caddr_t)ivp);
+				}
+				desc.info = ivp;
+				crypto_blkcipher_encrypt_iv(&desc, sg, sg, sg_len);
+
+			} else { /*decrypt */
+
+				if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
+					ivp = crd->crd_iv;
+				} else {
+					crypto_copydata(crp->crp_flags, crp->crp_buf,
+							crd->crd_inject, ivsize, (caddr_t)ivp);
+				}
+				desc.info = ivp;
+				crypto_blkcipher_decrypt_iv(&desc, sg, sg, sg_len);
+			}
+			} break;
+		case SW_TYPE_HMAC:
+		case SW_TYPE_HASH:
+			{
+			char result[HASH_MAX_LEN];
+			struct hash_desc desc;
+
+			/* check we have room for the result */
+			if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
+				dprintk(
+			"cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d digestsize=%d\n",
+						crp->crp_ilen, crd->crd_skip + sg_len, crd->crd_inject,
+						sw->u.hmac.sw_mlen);
+				crp->crp_etype = EINVAL;
+				goto done;
 			}
-			desc.info = ivp;
-			crypto_blkcipher_decrypt_iv(&desc, req->sg, req->sg, sg_len);
-		}
-		} break;
-
-	case SW_TYPE_HMAC:
-	case SW_TYPE_HASH:
-		{
-		char result[HASH_MAX_LEN];
-		struct hash_desc desc;
-
-		/* check we have room for the result */
-		if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
-			dprintk("cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d "
-					"digestsize=%d\n", crp->crp_ilen, crd->crd_skip + sg_len,
-					crd->crd_inject, sw->u.hmac.sw_mlen);
-			crp->crp_etype = EINVAL;
-			goto done;
-		}
 
-		memset(&desc, 0, sizeof(desc));
-		desc.tfm = crypto_hash_cast(sw->sw_tfm);
+			memset(&desc, 0, sizeof(desc));
+			desc.tfm = crypto_hash_cast(sw->sw_tfm);
 
-		memset(result, 0, sizeof(result));
+			memset(result, 0, sizeof(result));
 
-		if (sw->sw_type & SW_TYPE_HMAC) {
+			if (sw->sw_type == SW_TYPE_HMAC) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-			crypto_hmac(sw->sw_tfm, sw->u.hmac.sw_key, &sw->u.hmac.sw_klen,
-					req->sg, sg_num, result);
+				crypto_hmac(sw->sw_tfm, sw->u.hmac.sw_key, &sw->u.hmac.sw_klen,
+						sg, sg_num, result);
 #else
-			crypto_hash_setkey(desc.tfm, sw->u.hmac.sw_key,
-					sw->u.hmac.sw_klen);
-			crypto_hash_digest(&desc, req->sg, sg_len, result);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
-			
-		} else { /* SW_TYPE_HASH */
-			crypto_hash_digest(&desc, req->sg, sg_len, result);
-		}
-
-		crypto_copyback(crp->crp_flags, crp->crp_buf,
-				crd->crd_inject, sw->u.hmac.sw_mlen, result);
-		}
-		break;
-
-	case SW_TYPE_COMP: {
-		void *ibuf = NULL;
-		void *obuf = sw->u.sw_comp_buf;
-		int ilen = sg_len, olen = CRYPTO_MAX_DATA_LEN;
-		int ret = 0;
-
-		/*
-		 * we need to use an additional copy if there is more than one
-		 * input chunk since the kernel comp routines do not handle
-		 * SG yet.  Otherwise we just use the input buffer as is.
-		 * Rather than allocate another buffer we just split the tmp
-		 * buffer we already have.
-		 * Perhaps we should just use zlib directly ?
-		 */
-		if (sg_num > 1) {
-			int blk;
-
-			ibuf = obuf;
-			for (blk = 0; blk < sg_num; blk++) {
-				memcpy(obuf, sg_virt(&req->sg[blk]),
-						req->sg[blk].length);
-				obuf += req->sg[blk].length;
+				crypto_hash_setkey(desc.tfm, sw->u.hmac.sw_key,
+						sw->u.hmac.sw_klen);
+				crypto_hash_digest(&desc, sg, sg_len, result);
+#endif /* #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+				
+			} else { /* SW_TYPE_HASH */
+				crypto_hash_digest(&desc, sg, sg_len, result);
 			}
-			olen -= sg_len;
-		} else
-			ibuf = sg_virt(&req->sg[0]);
-
-		if (crd->crd_flags & CRD_F_ENCRYPT) { /* compress */
-			ret = crypto_comp_compress(crypto_comp_cast(sw->sw_tfm),
-					ibuf, ilen, obuf, &olen);
-			if (!ret && olen > crd->crd_len) {
-				dprintk("cryptosoft: ERANGE compress %d into %d\n",
-						crd->crd_len, olen);
-				if (swcr_fail_if_compression_grows)
-					ret = ERANGE;
-			}
-		} else { /* decompress */
-			ret = crypto_comp_decompress(crypto_comp_cast(sw->sw_tfm),
-					ibuf, ilen, obuf, &olen);
-			if (!ret && (olen + crd->crd_inject) > crp->crp_olen) {
-				dprintk("cryptosoft: ETOOSMALL decompress %d into %d, "
-						"space for %d,at offset %d\n",
-						crd->crd_len, olen, crp->crp_olen, crd->crd_inject);
-				ret = ETOOSMALL;
-			}
-		}
-		if (ret)
-			dprintk("%s,%d: ret = %d\n", __FILE__, __LINE__, ret);
 
-		/*
-		 * on success copy result back,
-		 * linux crpyto API returns -errno,  we need to fix that
-		 */
-		crp->crp_etype = ret < 0 ? -ret : ret;
-		if (ret == 0) {
-			/* copy back the result and return it's size */
 			crypto_copyback(crp->crp_flags, crp->crp_buf,
-					crd->crd_inject, olen, obuf);
-			crp->crp_olen = olen;
-		}
-		} break;
-
-	default:
-		/* Unknown/unsupported algorithm */
-		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		crp->crp_etype = EINVAL;
-		goto done;
-	}
-
-done:
-	swcr_process_req_complete(req);
-}
+					crd->crd_inject, sw->u.hmac.sw_mlen, result);
+			}
+			break;
 
+		case SW_TYPE_COMP: {
+			void *ibuf = NULL;
+			void *obuf = sw->u.sw_comp_buf;
+			int ilen = sg_len, olen = CRYPTO_MAX_DATA_LEN;
+			int ret = 0;
 
-/*
- * Process a crypto request.
- */
-static int
-swcr_process(device_t dev, struct cryptop *crp, int hint)
-{
-	struct swcr_req *req = NULL;
-	u_int32_t lid;
+			/*
+			 * we need to use an additional copy if there is more than one
+			 * input chunk since the kernel comp routines do not handle
+			 * SG yet.  Otherwise we just use the input buffer as is.
+			 * Rather than allocate another buffer we just split the tmp
+			 * buffer we already have.
+			 * Perhaps we should just use zlib directly ?
+			 */
+			if (sg_num > 1) {
+				int blk;
+
+				ibuf = obuf;
+				for (blk = 0; blk < sg_num; blk++) {
+					memcpy(obuf, sg_virt(&sg[blk]),
+							sg[blk].length);
+					obuf += sg[blk].length;
+				}
+				olen -= sg_len;
+			} else
+				ibuf = sg_virt(&sg[0]);
+
+			if (crd->crd_flags & CRD_F_ENCRYPT) { /* compress */
+				ret = crypto_comp_compress(crypto_comp_cast(sw->sw_tfm),
+						ibuf, ilen, obuf, &olen);
+				if (!ret && olen > crd->crd_len) {
+					dprintk("cryptosoft: ERANGE compress %d into %d\n",
+							crd->crd_len, olen);
+					if (swcr_fail_if_compression_grows)
+						ret = ERANGE;
+				}
+			} else { /* decompress */
+				ret = crypto_comp_decompress(crypto_comp_cast(sw->sw_tfm),
+						ibuf, ilen, obuf, &olen);
+				if (!ret && (olen + crd->crd_inject) > crp->crp_olen) {
+					dprintk("cryptosoft: ETOOSMALL decompress %d into %d, "
+							"space for %d,at offset %d\n",
+							crd->crd_len, olen, crp->crp_olen, crd->crd_inject);
+					ret = ETOOSMALL;
+				}
+			}
+			if (ret)
+				dprintk("%s,%d: ret = %d\n", __FILE__, __LINE__, ret);
 
-	dprintk("%s()\n", __FUNCTION__);
-	/* Sanity check */
-	if (crp == NULL) {
-		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		return EINVAL;
-	}
+			/*
+			 * on success copy result back,
+			 * linux crpyto API returns -errno,  we need to fix that
+			 */
+			crp->crp_etype = ret < 0 ? -ret : ret;
+			if (ret == 0) {
+				/* copy back the result and return it's size */
+				crypto_copyback(crp->crp_flags, crp->crp_buf,
+						crd->crd_inject, olen, obuf);
+				crp->crp_olen = olen;
+			}
 
-	crp->crp_etype = 0;
 
-	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
-		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-		crp->crp_etype = EINVAL;
-		goto done;
-	}
+			} break;
 
-	lid = crp->crp_sid & 0xffffffff;
-	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions == NULL ||
-			swcr_sessions[lid] == NULL) {
-		crp->crp_etype = ENOENT;
-		dprintk("%s,%d: ENOENT\n", __FILE__, __LINE__);
-		goto done;
-	}
-
-	/*
-	 * do some error checking outside of the loop for SKB and IOV processing
-	 * this leaves us with valid skb or uiop pointers for later
-	 */
-	if (crp->crp_flags & CRYPTO_F_SKBUF) {
-		struct sk_buff *skb = (struct sk_buff *) crp->crp_buf;
-		if (skb_shinfo(skb)->nr_frags >= SCATTERLIST_MAX) {
-			printk("%s,%d: %d nr_frags > SCATTERLIST_MAX", __FILE__, __LINE__,
-					skb_shinfo(skb)->nr_frags);
-			goto done;
-		}
-	} else if (crp->crp_flags & CRYPTO_F_IOV) {
-		struct uio *uiop = (struct uio *) crp->crp_buf;
-		if (uiop->uio_iovcnt > SCATTERLIST_MAX) {
-			printk("%s,%d: %d uio_iovcnt > SCATTERLIST_MAX", __FILE__, __LINE__,
-					uiop->uio_iovcnt);
+		default:
+			/* Unknown/unsupported algorithm */
+			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+			crp->crp_etype = EINVAL;
 			goto done;
 		}
 	}
 
-	/*
-	 * setup a new request ready for queuing
-	 */
-	req = kmem_cache_alloc(swcr_req_cache, SLAB_ATOMIC);
-	if (req == NULL) {
-		dprintk("%s,%d: ENOMEM\n", __FILE__, __LINE__);
-		crp->crp_etype = ENOMEM;
-		goto done;
-	}
-	memset(req, 0, sizeof(*req));
-
-	req->sw_head = swcr_sessions[lid];
-	req->crp = crp;
-	req->crd = crp->crp_desc;
-
-	swcr_process_req(req);
-	return 0;
-
 done:
 	crypto_done(crp);
-	if (req)
-		kmem_cache_free(swcr_req_cache, req);
 	return 0;
 }
 
-
 static int
 cryptosoft_init(void)
 {
@@ -1276,34 +789,24 @@ cryptosoft_init(void)
 
 	dprintk("%s(%p)\n", __FUNCTION__, cryptosoft_init);
 
-	swcr_req_cache = kmem_cache_create("cryptosoft_req",
-				sizeof(struct swcr_req), 0, SLAB_HWCACHE_ALIGN, NULL
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
-				, NULL
-#endif
-				);
-	if (!swcr_req_cache) {
-		printk("cryptosoft: failed to create request cache\n");
-		return -ENOENT;
-	}
-
 	softc_device_init(&swcr_softc, "cryptosoft", 0, swcr_methods);
 
 	swcr_id = crypto_get_driverid(softc_get_device(&swcr_softc),
 			CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_SYNC);
 	if (swcr_id < 0) {
-		printk("cryptosoft: Software crypto device cannot initialize!");
+		printk("Software crypto device cannot initialize!");
 		return -ENODEV;
 	}
 
 #define	REGISTER(alg) \
-		crypto_register(swcr_id, alg, 0,0)
+		crypto_register(swcr_id, alg, 0,0);
 
-	for (i = 0; i < sizeof(crypto_details)/sizeof(crypto_details[0]); i++) {
-		int found;
+	for (i = CRYPTO_ALGORITHM_MIN; i <= CRYPTO_ALGORITHM_MAX; ++i)
+	{
 		
 		algo = crypto_details[i].alg_name;
-		if (!algo || !*algo) {
+		if (!algo || !*algo)
+		{
 			dprintk("%s:Algorithm %d not supported\n", __FUNCTION__, i);
 			continue;
 		}
@@ -1311,34 +814,72 @@ cryptosoft_init(void)
 		mode = crypto_details[i].mode;
 		sw_type = crypto_details[i].sw_type;
 
-		found = 0;
-		switch (sw_type & SW_TYPE_ALG_MASK) {
-		case SW_TYPE_CIPHER:
-			found = crypto_has_cipher(algo, 0, CRYPTO_ALG_ASYNC);
-			break;
-		case SW_TYPE_HMAC:
-			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
-			break;
-		case SW_TYPE_HASH:
-			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
-			break;
-		case SW_TYPE_COMP:
-			found = crypto_has_comp(algo, 0, CRYPTO_ALG_ASYNC);
-			break;
-		case SW_TYPE_BLKCIPHER:
-			found = crypto_has_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
-			if (!found && !swcr_no_ablk)
-				found = crypto_has_ablkcipher(algo, 0, 0);
-			break;
-		}
-		if (found) {
-			REGISTER(i);
-		} else {
-			dprintk("%s:Algorithm Type %d not supported (algorithm %d:'%s')\n",
+		switch (sw_type)
+		{
+			case SW_TYPE_CIPHER:
+				if (crypto_has_cipher(algo, 0, CRYPTO_ALG_ASYNC))
+				{
+					REGISTER(i);
+				}
+				else
+				{
+					dprintk("%s:CIPHER algorithm %d:'%s' not supported\n",
+								__FUNCTION__, i, algo);
+				}
+				break;
+			case SW_TYPE_HMAC:
+				if (crypto_has_hash(algo, 0, CRYPTO_ALG_ASYNC))
+				{
+					REGISTER(i);
+				}
+				else
+				{
+					dprintk("%s:HMAC algorithm %d:'%s' not supported\n",
+								__FUNCTION__, i, algo);
+				}
+				break;
+			case SW_TYPE_HASH:
+				if (crypto_has_hash(algo, 0, CRYPTO_ALG_ASYNC))
+				{
+					REGISTER(i);
+				}
+				else
+				{
+					dprintk("%s:HASH algorithm %d:'%s' not supported\n",
+								__FUNCTION__, i, algo);
+				}
+				break;
+			case SW_TYPE_COMP:
+				if (crypto_has_comp(algo, 0, CRYPTO_ALG_ASYNC))
+				{
+					REGISTER(i);
+				}
+				else
+				{
+					dprintk("%s:COMP algorithm %d:'%s' not supported\n",
+								__FUNCTION__, i, algo);
+				}
+				break;
+			case SW_TYPE_BLKCIPHER:
+				if (crypto_has_blkcipher(algo, 0, CRYPTO_ALG_ASYNC))
+				{
+					REGISTER(i);
+				}
+				else
+				{
+					dprintk("%s:BLKCIPHER algorithm %d:'%s' not supported\n",
+								__FUNCTION__, i, algo);
+				}
+				break;
+			default:
+				dprintk(
+				"%s:Algorithm Type %d not supported (algorithm %d:'%s')\n",
 					__FUNCTION__, sw_type, i, algo);
+				break;
 		}
 	}
-	return 0;
+
+	return(0);
 }
 
 static void
@@ -1347,12 +888,11 @@ cryptosoft_exit(void)
 	dprintk("%s()\n", __FUNCTION__);
 	crypto_unregister_all(swcr_id);
 	swcr_id = -1;
-	kmem_cache_destroy(swcr_req_cache);
 }
 
-late_initcall(cryptosoft_init);
+module_init(cryptosoft_init);
 module_exit(cryptosoft_exit);
 
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("Cryptosoft (OCF module for kernel crypto)");
diff --git a/crypto/ocf/ep80579/Makefile b/crypto/ocf/ep80579/Makefile
index 22dd7c4..19ff6eb 100644
--- a/crypto/ocf/ep80579/Makefile
+++ b/crypto/ocf/ep80579/Makefile
@@ -13,7 +13,7 @@
 # 
 #   GPL LICENSE SUMMARY
 # 
-#   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
 # 
 #   This program is free software; you can redistribute it and/or modify 
 #   it under the terms of version 2 of the GNU General Public License as
@@ -35,7 +35,7 @@
 # 
 #   BSD LICENSE 
 # 
-#   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
 #   All rights reserved.
 # 
 #   Redistribution and use in source and binary forms, with or without 
@@ -65,55 +65,43 @@
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 # 
 # 
-#  version: Security.L.1.0.2-229
+#  version: Security.L.1.0.130
 ############################################################################
 
 
 ####################Common variables and definitions########################
 
-ifndef ICP_ROOT
-#$(warning ICP_ROOT is undefined. Please set the path to EP80579 release package directory \
-        "-> setenv ICP_ROOT <path>")
-all fastdep:
-	:
-else
-
-ifndef KERNEL_SOURCE_ROOT
-$(error KERNEL_SOURCE_ROOT is undefined. Please set the path to the kernel source directory \
-        "-> setenv KERNEL_SOURCE_ROOT <path>")
-endif
-
 # Ensure The ENV_DIR environmental var is defined.
 ifndef ICP_ENV_DIR
-$(error ICP_ENV_DIR is undefined. Please set the path to EP80579 driver environment.mk file \
+$(error ICP_ENV_DIR is undefined. Please set the path to your environment makefile \
         "-> setenv ICP_ENV_DIR <path>")
 endif
 
 #Add your project environment Makefile
-include ${ICP_ENV_DIR}/environment.mk
+include $(ICP_ENV_DIR)/environment.mk
 
 #include the makefile with all the default and common Make variable definitions
-include ${ICP_BUILDSYSTEM_PATH}/build_files/common.mk
+include $(ICP_BUILDSYSTEM_PATH)/build_files/common.mk
 
 #Add the name for the executable, Library or Module output definitions
 OUTPUT_NAME= icp_ocf
 
 # List of Source Files to be compiled 
-SOURCES= icp_common.c icp_sym.c icp_asym.c icp_ocf_linux.c
+SOURCES= icp_common.c icp_sym.c icp_asym.c
 
 #common includes between all supported OSes
-INCLUDES= -I ${ICP_API_DIR} -I${ICP_LAC_API} \
--I${ICP_OCF_SRC_DIR}
+INCLUDES= -I $(ICP_API_DIR) -I$(ICP_LAC_API) \
+-I$(ICP_OCF_SRC_DIR)
 
 # The location of the os level makefile needs to be changed.
-include ${ICP_ENV_DIR}/${ICP_OS}_${ICP_OS_LEVEL}.mk
+include $(ICP_ENV_DIR)/$(ICP_OS)_$(ICP_OS_LEVEL).mk
 
 # On the line directly below list the outputs you wish to build for,
-# e.g "lib_static lib_shared exe module" as shown below
+# e.g "lib_static lib_shared exe module" as show below
 install: module
 
 ###################Include rules makefiles########################
-include ${ICP_BUILDSYSTEM_PATH}/build_files/rules.mk
+include $(ICP_BUILDSYSTEM_PATH)/build_files/rules.mk
 ###################End of Rules inclusion#########################
 
-endif
+
diff --git a/crypto/ocf/ep80579/environment.mk b/crypto/ocf/ep80579/environment.mk
new file mode 100644
index 0000000..a674b45
--- /dev/null
+++ b/crypto/ocf/ep80579/environment.mk
@@ -0,0 +1,75 @@
+ ###########################################################################
+ #
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#  version: Security.L.1.0.130
+ #
+ ###########################################################################
+
+
+ICP_LAC_API=$(ICP_ROOT)/Acceleration/include/lac
+ICP_BTR_API=$(ICP_ROOT)/Acceleration/include/btr
+ICP_API_DIR=$(ICP_ROOT)/Acceleration/include
+ICP_OCF_SHIM_DIR?=$(KERNEL_SOURCE_ROOT)/crypto/ocf/
+
+ICP_OS_LEVEL?=kernel_space
+
+ICP_OS?=linux_2.6
+
+ICP_CORE?=ia
+
diff --git a/crypto/ocf/ep80579/icp_asym.c b/crypto/ocf/ep80579/icp_asym.c
index d2641c5..1a9bd28 100644
--- a/crypto/ocf/ep80579/icp_asym.c
+++ b/crypto/ocf/ep80579/icp_asym.c
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.2-229
+ *  version: Security.L.1.0.130
  *
  ***************************************************************************/
 
@@ -70,94 +70,90 @@ calling program uses different input buffer positions, these defines will have
 to be changed.*/
 
 /*DIFFIE HELLMAN buffer index values*/
-#define ICP_DH_KRP_PARAM_PRIME_INDEX                            (0)
-#define ICP_DH_KRP_PARAM_BASE_INDEX                             (1)
-#define ICP_DH_KRP_PARAM_PRIVATE_VALUE_INDEX                    (2)
-#define ICP_DH_KRP_PARAM_RESULT_INDEX                           (3)
+#define ICP_DH_KRP_PARAM_PRIME_INDEX				(0)
+#define ICP_DH_KRP_PARAM_BASE_INDEX				(1)
+#define ICP_DH_KRP_PARAM_PRIVATE_VALUE_INDEX			(2)
+#define ICP_DH_KRP_PARAM_RESULT_INDEX				(3)
 
 /*MOD EXP buffer index values*/
-#define ICP_MOD_EXP_KRP_PARAM_BASE_INDEX                        (0)
-#define ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX                    (1)
-#define ICP_MOD_EXP_KRP_PARAM_MODULUS_INDEX                     (2)
-#define ICP_MOD_EXP_KRP_PARAM_RESULT_INDEX                      (3)
+#define ICP_MOD_EXP_KRP_PARAM_BASE_INDEX			(0)
+#define ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX			(1)
+#define ICP_MOD_EXP_KRP_PARAM_MODULUS_INDEX			(2)
+#define ICP_MOD_EXP_KRP_PARAM_RESULT_INDEX			(3)
+
+#define SINGLE_BYTE_VALUE					(4)
 
 /*MOD EXP CRT buffer index values*/
-#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_P_INDEX                 (0)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_Q_INDEX                 (1)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_I_INDEX                       (2)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DP_INDEX             (3)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DQ_INDEX             (4)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_COEFF_QINV_INDEX              (5)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_RESULT_INDEX                  (6)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_P_INDEX			(0)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_Q_INDEX			(1)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_I_INDEX			(2)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DP_INDEX		(3)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DQ_INDEX		(4)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_COEFF_QINV_INDEX		(5)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_RESULT_INDEX			(6)
 
 /*DSA sign buffer index values*/
-#define ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX                       (0)
-#define ICP_DSA_SIGN_KRP_PARAM_PRIME_P_INDEX                    (1)
-#define ICP_DSA_SIGN_KRP_PARAM_PRIME_Q_INDEX                    (2)
-#define ICP_DSA_SIGN_KRP_PARAM_G_INDEX                          (3)
-#define ICP_DSA_SIGN_KRP_PARAM_X_INDEX                          (4)
-#define ICP_DSA_SIGN_KRP_PARAM_R_RESULT_INDEX                   (5)
-#define ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX                   (6)
+#define ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX			(0)
+#define ICP_DSA_SIGN_KRP_PARAM_PRIME_P_INDEX			(1)
+#define ICP_DSA_SIGN_KRP_PARAM_PRIME_Q_INDEX			(2)
+#define ICP_DSA_SIGN_KRP_PARAM_G_INDEX				(3)
+#define ICP_DSA_SIGN_KRP_PARAM_X_INDEX				(4)
+#define ICP_DSA_SIGN_KRP_PARAM_R_RESULT_INDEX			(5)
+#define ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX			(6)
 
 /*DSA verify buffer index values*/
-#define ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX                     (0)
-#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_P_INDEX                  (1)
-#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_Q_INDEX                  (2)
-#define ICP_DSA_VERIFY_KRP_PARAM_G_INDEX                        (3)
-#define ICP_DSA_VERIFY_KRP_PARAM_PUBKEY_INDEX                   (4)
-#define ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX                    (5)
-#define ICP_DSA_VERIFY_KRP_PARAM_SIG_S_INDEX                    (6)
+#define ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX			(0)
+#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_P_INDEX			(1)
+#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_Q_INDEX			(2)
+#define ICP_DSA_VERIFY_KRP_PARAM_G_INDEX			(3)
+#define ICP_DSA_VERIFY_KRP_PARAM_PUBKEY_INDEX			(4)
+#define ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX			(5)
+#define ICP_DSA_VERIFY_KRP_PARAM_SIG_S_INDEX			(6)
 
 /*DSA sign prime Q vs random number K size check values*/
-#define DONT_RUN_LESS_THAN_CHECK                                (0)
-#define FAIL_A_IS_GREATER_THAN_B                                (1)
-#define FAIL_A_IS_EQUAL_TO_B                                    (1)
-#define SUCCESS_A_IS_LESS_THAN_B                                (0)
-#define DSA_SIGN_RAND_GEN_VAL_CHECK_MAX_ITERATIONS              (500)
+#define DONT_RUN_LESS_THAN_CHECK				(0)
+#define FAIL_A_IS_GREATER_THAN_B				(1)
+#define FAIL_A_IS_EQUAL_TO_B					(1)
+#define SUCCESS_A_IS_LESS_THAN_B				(0)
+#define DSA_SIGN_RAND_GEN_VAL_CHECK_MAX_ITERATIONS		(500)
 
 /* We need to set a cryptokp success value just in case it is set or allocated
    and not set to zero outside of this module */
-#define CRYPTO_OP_SUCCESS                                       (0)
+#define CRYPTO_OP_SUCCESS					(0)
 
-/*Function to compute Diffie Hellman (DH) phase 1 or phase 2 key values*/
 static int icp_ocfDrvDHComputeKey(struct cryptkop *krp);
 
-/*Function to compute a Modular Exponentiation (Mod Exp)*/
 static int icp_ocfDrvModExp(struct cryptkop *krp);
 
-/*Function to compute a Mod Exp using the Chinease Remainder Theorem*/
 static int icp_ocfDrvModExpCRT(struct cryptkop *krp);
 
-/*Helper function to compute whether the first big number argument is less than
- the second big number argument */
 static int
 icp_ocfDrvCheckALessThanB(CpaFlatBuffer * pK, CpaFlatBuffer * pQ, int *doCheck);
 
-/*Function to sign an input with DSA R and S keys*/
 static int icp_ocfDrvDsaSign(struct cryptkop *krp);
 
-/*Function to Verify a DSA buffer signature*/
 static int icp_ocfDrvDsaVerify(struct cryptkop *krp);
 
-/*Callback function for DH operation*/
 static void
 icp_ocfDrvDhP1CallBack(void *callbackTag,
 		       CpaStatus status,
 		       void *pOpData, CpaFlatBuffer * pLocalOctetStringPV);
 
-/*Callback function for ME operation*/
 static void
 icp_ocfDrvModExpCallBack(void *callbackTag,
 			 CpaStatus status,
 			 void *pOpData, CpaFlatBuffer * pResult);
 
-/*Callback function for ME CRT operation*/
 static void
 icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 			    CpaStatus status,
 			    void *pOpData, CpaFlatBuffer * pOutputData);
 
-/*Callback function for DSA sign operation*/
+static void
+icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
+			    CpaStatus status,
+			    void *pOpData, CpaBoolean verifyStatus);
+
 static void
 icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 			    CpaStatus status,
@@ -165,18 +161,12 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 			    CpaBoolean protocolStatus,
 			    CpaFlatBuffer * pR, CpaFlatBuffer * pS);
 
-/*Callback function for DSA Verify operation*/
-static void
-icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
-			    CpaStatus status,
-			    void *pOpData, CpaBoolean verifyStatus);
-
 /* Name        : icp_ocfDrvPkeProcess
  *
  * Description : This function will choose which PKE process to follow
  * based on the input arguments
  */
-int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint)
+int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 
@@ -186,7 +176,7 @@ int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint)
 		return EINVAL;
 	}
 
-	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
 		krp->krp_status = ECANCELED;
 		return ECANCELED;
 	}
@@ -268,7 +258,8 @@ int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint)
  * It has been seen that in general we are passed little endian byte order
  * buffers, but LAC only accepts big endian byte order buffers.
  */
-static void inline icp_ocfDrvSwapBytes(u_int8_t * num, u_int32_t buff_len_bytes)
+static void inline
+icp_ocfDrvSwapBytes(u_int8_t * num, u_int32_t buff_len_bytes)
 {
 
 	int i;
@@ -328,9 +319,7 @@ static int icp_ocfDrvDHComputeKey(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-/*All allocations are set to ICP_M_NOWAIT due to the possibility of getting
-called in interrupt context*/
-	pPhase1OpData = icp_kmem_cache_zalloc(drvDH_zone, ICP_M_NOWAIT);
+	pPhase1OpData = kmem_cache_zalloc(drvDH_zone, GFP_KERNEL);
 	if (NULL == pPhase1OpData) {
 		APRINTK("%s():Failed to get memory for key gen data\n",
 			__FUNCTION__);
@@ -338,12 +327,11 @@ called in interrupt context*/
 		return ENOMEM;
 	}
 
-	pLocalOctetStringPV =
-	    icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
+	pLocalOctetStringPV = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
 	if (NULL == pLocalOctetStringPV) {
 		APRINTK("%s():Failed to get memory for pLocalOctetStringPV\n",
 			__FUNCTION__);
-		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
+		kmem_cache_free(drvDH_zone, pPhase1OpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -391,7 +379,7 @@ called in interrupt context*/
 		EPRINTK("%s(): DH Phase 1 Key Gen failed (%d).\n",
 			__FUNCTION__, lacStatus);
 		icp_ocfDrvFreeFlatBuffer(pLocalOctetStringPV);
-		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
+		kmem_cache_free(drvDH_zone, pPhase1OpData);
 	}
 
 	return lacStatus;
@@ -430,7 +418,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-	pModExpOpData = icp_kmem_cache_zalloc(drvLnModExp_zone, ICP_M_NOWAIT);
+	pModExpOpData = kmem_cache_zalloc(drvLnModExp_zone, GFP_KERNEL);
 	if (NULL == pModExpOpData) {
 		APRINTK("%s():Failed to get memory for key gen data\n",
 			__FUNCTION__);
@@ -438,11 +426,11 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 		return ENOMEM;
 	}
 
-	pResult = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
+	pResult = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
 	if (NULL == pResult) {
 		APRINTK("%s():Failed to get memory for ModExp result\n",
 			__FUNCTION__);
-		ICP_CACHE_FREE(drvLnModExp_zone, pModExpOpData);
+		kmem_cache_free(drvLnModExp_zone, pModExpOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -457,15 +445,35 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(pModExpOpData->modulus.pData,
 			    pModExpOpData->modulus.dataLenInBytes);
 
-	DPRINTK("%s : base (%d)\n", __FUNCTION__, krp->
-		krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
-	pModExpOpData->base.pData =
-	    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_p;
-	BITS_TO_BYTES(pModExpOpData->base.dataLenInBytes,
-		      krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
-		      crp_nbits);
-	icp_ocfDrvSwapBytes(pModExpOpData->base.pData,
-			    pModExpOpData->base.dataLenInBytes);
+	/*OCF patch to Openswan Pluto regularly sends the base value as 2
+	   bits in size. In this case, it has been found it is better to
+	   use the base size memory space as the input buffer (if the number
+	   is in bits is less than a byte, the number of bits is the input
+	   value) */
+	if (krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits <
+	    NUM_BITS_IN_BYTE) {
+		DPRINTK("%s : base is small (%d)\n", __FUNCTION__, krp->
+			krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
+		pModExpOpData->base.dataLenInBytes = SINGLE_BYTE_VALUE;
+		pModExpOpData->base.pData =
+		    (uint8_t *) & (krp->
+				   krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
+				   crp_nbits);
+		*((uint32_t *) pModExpOpData->base.pData) =
+		    htonl(*((uint32_t *) pModExpOpData->base.pData));
+
+	} else {
+
+		DPRINTK("%s : base is big (%d)\n", __FUNCTION__, krp->
+			krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
+		pModExpOpData->base.pData =
+		    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_p;
+		BITS_TO_BYTES(pModExpOpData->base.dataLenInBytes,
+			      krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
+			      crp_nbits);
+		icp_ocfDrvSwapBytes(pModExpOpData->base.pData,
+				    pModExpOpData->base.dataLenInBytes);
+	}
 
 	pModExpOpData->exponent.pData =
 	    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX].crp_p;
@@ -491,7 +499,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 			__FUNCTION__, lacStatus);
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pResult);
-		ICP_CACHE_FREE(drvLnModExp_zone, pModExpOpData);
+		kmem_cache_free(drvLnModExp_zone, pModExpOpData);
 	}
 
 	return lacStatus;
@@ -507,6 +515,7 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
  * numbers. Although basic primality checks are done in LAC, it is up to the
  * user to do any correct prime number checking before passing the inputs.
  */
+
 static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
@@ -518,8 +527,7 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	   them here. */
 	callbackTag = krp;
 
-	rsaDecryptOpData =
-	    icp_kmem_cache_zalloc(drvRSADecrypt_zone, ICP_M_NOWAIT);
+	rsaDecryptOpData = kmem_cache_zalloc(drvRSADecrypt_zone, GFP_KERNEL);
 	if (NULL == rsaDecryptOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for MOD EXP CRT Op data struct\n", __FUNCTION__);
@@ -528,11 +536,11 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	}
 
 	rsaDecryptOpData->pRecipientPrivateKey
-	    = icp_kmem_cache_zalloc(drvRSAPrivateKey_zone, ICP_M_NOWAIT);
+	    = kmem_cache_zalloc(drvRSAPrivateKey_zone, GFP_KERNEL);
 	if (NULL == rsaDecryptOpData->pRecipientPrivateKey) {
 		APRINTK("%s():Failed to get memory for MOD EXP CRT"
 			" private key values struct\n", __FUNCTION__);
-		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
+		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -542,13 +550,13 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 	rsaDecryptOpData->pRecipientPrivateKey->
 	    privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
 
-	pOutputData = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
+	pOutputData = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
 	if (NULL == pOutputData) {
 		APRINTK("%s():Failed to get memory"
 			" for MOD EXP CRT output data\n", __FUNCTION__);
-		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-			       rsaDecryptOpData->pRecipientPrivateKey);
-		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
+		kmem_cache_free(drvRSAPrivateKey_zone,
+				rsaDecryptOpData->pRecipientPrivateKey);
+		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -650,9 +658,9 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 			__FUNCTION__, lacStatus);
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pOutputData);
-		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-			       rsaDecryptOpData->pRecipientPrivateKey);
-		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
+		kmem_cache_free(drvRSAPrivateKey_zone,
+				rsaDecryptOpData->pRecipientPrivateKey);
+		kmem_cache_free(drvRSADecrypt_zone, rsaDecryptOpData);
 	}
 
 	return lacStatus;
@@ -739,8 +747,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		return EDOM;
 	}
 
-	dsaRsSignOpData =
-	    icp_kmem_cache_zalloc(drvDSARSSign_zone, ICP_M_NOWAIT);
+	dsaRsSignOpData = kmem_cache_zalloc(drvDSARSSign_zone, GFP_KERNEL);
 	if (NULL == dsaRsSignOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA RS Sign Op data struct\n", __FUNCTION__);
@@ -749,35 +756,35 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 	}
 
 	dsaRsSignOpData->K.pData =
-	    icp_kmem_cache_alloc(drvDSARSSignKValue_zone, ICP_M_NOWAIT);
+	    kmem_cache_alloc(drvDSARSSignKValue_zone, GFP_ATOMIC);
 
 	if (NULL == dsaRsSignOpData->K.pData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA RS Sign Op Random value\n", __FUNCTION__);
-		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
 
-	pR = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
+	pR = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
 	if (NULL == pR) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA signature R\n", __FUNCTION__);
-		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-			       dsaRsSignOpData->K.pData);
-		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+		kmem_cache_free(drvDSARSSignKValue_zone,
+				dsaRsSignOpData->K.pData);
+		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
 
-	pS = icp_kmem_cache_zalloc(drvFlatBuffer_zone, ICP_M_NOWAIT);
+	pS = kmem_cache_zalloc(drvFlatBuffer_zone, GFP_KERNEL);
 	if (NULL == pS) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA signature S\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-			       dsaRsSignOpData->K.pData);
-		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+		kmem_cache_free(drvDSARSSignKValue_zone,
+				dsaRsSignOpData->K.pData);
+		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
 	}
@@ -823,9 +830,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 				"value\n", __FUNCTION__);
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
-			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-				       dsaRsSignOpData->K.pData);
-			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+			kmem_cache_free(drvDSARSSignKValue_zone,
+					dsaRsSignOpData->K.pData);
+			kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
 		}
@@ -836,9 +843,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 				"value less than Q value\n", __FUNCTION__);
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
-			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-				       dsaRsSignOpData->K.pData);
-			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+			kmem_cache_free(drvDSARSSignKValue_zone,
+					dsaRsSignOpData->K.pData);
+			kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
 		}
@@ -862,13 +869,13 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(dsaRsSignOpData->X.pData,
 			    dsaRsSignOpData->X.dataLenInBytes);
 
-	/*OpenSSL dgst parameter is left in big endian byte order, 
-	   therefore no byte swap is required */
 	dsaRsSignOpData->M.pData =
 	    krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX].crp_p;
 	BITS_TO_BYTES(dsaRsSignOpData->M.dataLenInBytes,
 		      krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX].
 		      crp_nbits);
+	icp_ocfDrvSwapBytes(dsaRsSignOpData->M.pData,
+			    dsaRsSignOpData->M.dataLenInBytes);
 
 	/* Output Parameters */
 	pS->pData = krp->krp_param[ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX].crp_p;
@@ -892,9 +899,9 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pS);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-			       dsaRsSignOpData->K.pData);
-		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
+		kmem_cache_free(drvDSARSSignKValue_zone,
+				dsaRsSignOpData->K.pData);
+		kmem_cache_free(drvDSARSSign_zone, dsaRsSignOpData);
 	}
 
 	return lacStatus;
@@ -914,8 +921,7 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 
 	callbackTag = krp;
 
-	dsaVerifyOpData =
-	    icp_kmem_cache_zalloc(drvDSAVerify_zone, ICP_M_NOWAIT);
+	dsaVerifyOpData = kmem_cache_zalloc(drvDSAVerify_zone, GFP_KERNEL);
 	if (NULL == dsaVerifyOpData) {
 		APRINTK("%s():Failed to get memory"
 			" for DSA Verify Op data struct\n", __FUNCTION__);
@@ -956,13 +962,13 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 	icp_ocfDrvSwapBytes(dsaVerifyOpData->Y.pData,
 			    dsaVerifyOpData->Y.dataLenInBytes);
 
-	/*OpenSSL dgst parameter is left in big endian byte order, 
-	   therefore no byte swap is required */
 	dsaVerifyOpData->M.pData =
 	    krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX].crp_p;
 	BITS_TO_BYTES(dsaVerifyOpData->M.dataLenInBytes,
 		      krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX].
 		      crp_nbits);
+	icp_ocfDrvSwapBytes(dsaVerifyOpData->M.pData,
+			    dsaVerifyOpData->M.dataLenInBytes);
 
 	dsaVerifyOpData->R.pData =
 	    krp->krp_param[ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX].crp_p;
@@ -987,13 +993,48 @@ static int icp_ocfDrvDsaVerify(struct cryptkop *krp)
 	if (CPA_STATUS_SUCCESS != lacStatus) {
 		EPRINTK("%s(): DSA Verify Operation failed (%d).\n",
 			__FUNCTION__, lacStatus);
-		ICP_CACHE_FREE(drvDSAVerify_zone, dsaVerifyOpData);
+		kmem_cache_free(drvDSAVerify_zone, dsaVerifyOpData);
 		krp->krp_status = ECANCELED;
 	}
 
 	return lacStatus;
 }
 
+/* Name        : icp_ocfDrvReadRandom
+ *
+ * Description : This function will map RNG functionality calls from OCF
+ * to the LAC API.
+ */
+int icp_ocfDrvReadRandom(void *arg, uint32_t * buf, int maxwords)
+{
+	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
+	CpaCyRandGenOpData randGenOpData;
+	CpaFlatBuffer randData;
+
+	if (NULL == buf) {
+		APRINTK("%s(): Invalid input parameters\n", __FUNCTION__);
+		return EINVAL;
+	}
+
+	/* maxwords here is number of integers to generate data for */
+	randGenOpData.generateBits = CPA_TRUE;
+
+	randGenOpData.lenInBytes = maxwords * sizeof(uint32_t);
+
+	icp_ocfDrvPtrAndLenToFlatBuffer((Cpa8U *) buf,
+					randGenOpData.lenInBytes, &randData);
+
+	lacStatus = cpaCyRandGen(CPA_INSTANCE_HANDLE_SINGLE,
+				 NULL, NULL, &randGenOpData, &randData);
+	if (CPA_STATUS_SUCCESS != lacStatus) {
+		EPRINTK("%s(): icp_LacSymRandGen failed (%d). \n",
+			__FUNCTION__, lacStatus);
+		return RETURN_RAND_NUM_GEN_FAILED;
+	}
+
+	return randGenOpData.lenInBytes / sizeof(uint32_t);
+}
+
 /* Name        : icp_ocfDrvDhP1Callback
  *
  * Description : When this function returns it signifies that the LAC
@@ -1027,7 +1068,7 @@ icp_ocfDrvDhP1CallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameters - "
 			"pLocalOctetStringPV Data is NULL\n", __FUNCTION__);
 		memset(pPhase1OpData, 0, sizeof(CpaCyDhPhase1KeyGenOpData));
-		ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
+		kmem_cache_free(drvDH_zone, pPhase1OpData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1046,7 +1087,7 @@ icp_ocfDrvDhP1CallBack(void *callbackTag,
 
 	icp_ocfDrvFreeFlatBuffer(pLocalOctetStringPV);
 	memset(pPhase1OpData, 0, sizeof(CpaCyDhPhase1KeyGenOpData));
-	ICP_CACHE_FREE(drvDH_zone, pPhase1OpData);
+	kmem_cache_free(drvDH_zone, pPhase1OpData);
 
 	crypto_kdone(krp);
 
@@ -1087,7 +1128,7 @@ icp_ocfDrvModExpCallBack(void *callbackTag,
 			"pResult data is NULL\n", __FUNCTION__);
 		krp->krp_status = ECANCELED;
 		memset(pLnModExpOpData, 0, sizeof(CpaCyLnModExpOpData));
-		ICP_CACHE_FREE(drvLnModExp_zone, pLnModExpOpData);
+		kmem_cache_free(drvLnModExp_zone, pLnModExpOpData);
 		crypto_kdone(krp);
 		return;
 	}
@@ -1112,7 +1153,7 @@ icp_ocfDrvModExpCallBack(void *callbackTag,
 	}
 	icp_ocfDrvFreeFlatBuffer(pResult);
 	memset(pLnModExpOpData, 0, sizeof(CpaCyLnModExpOpData));
-	ICP_CACHE_FREE(drvLnModExp_zone, pLnModExpOpData);
+	kmem_cache_free(drvLnModExp_zone, pLnModExpOpData);
 
 	crypto_kdone(krp);
 
@@ -1155,10 +1196,10 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 			"pOutputData is NULL\n", __FUNCTION__);
 		memset(pDecryptData->pRecipientPrivateKey, 0,
 		       sizeof(CpaCyRsaPrivateKey));
-		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-			       pDecryptData->pRecipientPrivateKey);
+		kmem_cache_free(drvRSAPrivateKey_zone,
+				pDecryptData->pRecipientPrivateKey);
 		memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
-		ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
+		kmem_cache_free(drvRSADecrypt_zone, pDecryptData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1177,10 +1218,10 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 	icp_ocfDrvFreeFlatBuffer(pOutputData);
 	memset(pDecryptData->pRecipientPrivateKey, 0,
 	       sizeof(CpaCyRsaPrivateKey));
-	ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-		       pDecryptData->pRecipientPrivateKey);
+	kmem_cache_free(drvRSAPrivateKey_zone,
+			pDecryptData->pRecipientPrivateKey);
 	memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
-	ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
+	kmem_cache_free(drvRSADecrypt_zone, pDecryptData);
 
 	crypto_kdone(krp);
 
@@ -1223,7 +1264,7 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameter - "
 			"pR sign is NULL\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pS);
-		ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
+		kmem_cache_free(drvDSARSSign_zone, pSignData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1233,7 +1274,7 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 		DPRINTK("%s(): Invalid input parameter - "
 			"pS sign is NULL\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pR);
-		ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
+		kmem_cache_free(drvDSARSSign_zone, pSignData);
 		krp->krp_status = ECANCELED;
 		crypto_kdone(krp);
 		return;
@@ -1263,9 +1304,9 @@ icp_ocfDrvDsaRSSignCallBack(void *callbackTag,
 	icp_ocfDrvFreeFlatBuffer(pR);
 	icp_ocfDrvFreeFlatBuffer(pS);
 	memset(pSignData->K.pData, 0, pSignData->K.dataLenInBytes);
-	ICP_CACHE_FREE(drvDSARSSignKValue_zone, pSignData->K.pData);
+	kmem_cache_free(drvDSARSSignKValue_zone, pSignData->K.pData);
 	memset(pSignData, 0, sizeof(CpaCyDsaRSSignOpData));
-	ICP_CACHE_FREE(drvDSARSSign_zone, pSignData);
+	kmem_cache_free(drvDSARSSign_zone, pSignData);
 	crypto_kdone(krp);
 
 	return;
@@ -1327,7 +1368,7 @@ icp_ocfDrvDsaVerifyCallBack(void *callbackTag,
 	}
 
 	memset(pVerData, 0, sizeof(CpaCyDsaVerifyOpData));
-	ICP_CACHE_FREE(drvDSAVerify_zone, pVerData);
+	kmem_cache_free(drvDSAVerify_zone, pVerData);
 	crypto_kdone(krp);
 
 	return;
diff --git a/crypto/ocf/ep80579/icp_common.c b/crypto/ocf/ep80579/icp_common.c
index 5d46c0a..461370c 100644
--- a/crypto/ocf/ep80579/icp_common.c
+++ b/crypto/ocf/ep80579/icp_common.c
@@ -1,11 +1,11 @@
-/*************************************************************************
+/***************************************************************************
  *
  * This file is provided under a dual BSD/GPLv2 license.  When using or 
  *   redistributing this file, you may do so under either license.
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.2-229
+ *  version: Security.L.1.0.130
  *
  ***************************************************************************/
 
@@ -71,57 +71,38 @@
 
 #include "icp_ocf.h"
 
-#define ICP_OCF_COMP_NAME                       "ICP_OCF"
-#define ICP_OCF_VER_MAIN                        (2)
-#define ICP_OCF_VER_MJR                         (1)
-#define ICP_OCF_VER_MNR                         (0)
+#define ICP_OCF_COMP_NAME 			"ICP_OCF"
+#define ICP_OCF_VER_MAIN			(2)
+#define ICP_OCF_VER_MJR				(0)
+#define ICP_OCF_VER_MNR 			(0)
 
-#define MAX_DEREG_RETRIES                       (100)
+#define MAX_DEREG_RETRIES 			(100)
 #define DEFAULT_DEREG_RETRIES 			(10)
 #define DEFAULT_DEREG_DELAY_IN_JIFFIES		(10)
 
 /* This defines the maximum number of sessions possible between OCF
-   and the OCF EP80579 Driver. If set to zero, there is no limit. */
-#define DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT    (0)
-#define NUM_SUPPORTED_CAPABILITIES              (21)
-
-/*Slab zone names*/
-#define ICP_SESSION_DATA_NAME   "icp_ocf.SesDat"
-#define ICP_OP_DATA_NAME        "icp_ocf.OpDat"
-#define ICP_DH_NAME             "icp_ocf.DH"
-#define ICP_MODEXP_NAME         "icp_ocf.ModExp"
-#define ICP_RSA_DECRYPT_NAME    "icp_ocf.RSAdec"
-#define ICP_RSA_PKEY_NAME       "icp_ocf.RSApk"
-#define ICP_DSA_SIGN_NAME       "icp_ocf.DSAsg"
-#define ICP_DSA_VER_NAME        "icp_ocf.DSAver"
-#define ICP_RAND_VAL_NAME       "icp_ocf.DSArnd"
-#define ICP_FLAT_BUFF_NAME      "icp_ocf.FB"
+   and the OCF Tolapai Driver. If set to zero, there is no limit. */
+#define DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT	(0)
+#define NUM_SUPPORTED_CAPABILITIES		(21)
 
 /*Slabs zones*/
-icp_kmem_cache drvSessionData_zone = NULL;
-icp_kmem_cache drvOpData_zone = NULL;
-icp_kmem_cache drvDH_zone = NULL;
-icp_kmem_cache drvLnModExp_zone = NULL;
-icp_kmem_cache drvRSADecrypt_zone = NULL;
-icp_kmem_cache drvRSAPrivateKey_zone = NULL;
-icp_kmem_cache drvDSARSSign_zone = NULL;
-icp_kmem_cache drvDSARSSignKValue_zone = NULL;
-icp_kmem_cache drvDSAVerify_zone = NULL;
+struct kmem_cache *drvSessionData_zone = NULL;
+struct kmem_cache *drvOpData_zone = NULL;
+struct kmem_cache *drvDH_zone = NULL;
+struct kmem_cache *drvLnModExp_zone = NULL;
+struct kmem_cache *drvRSADecrypt_zone = NULL;
+struct kmem_cache *drvRSAPrivateKey_zone = NULL;
+struct kmem_cache *drvDSARSSign_zone = NULL;
+struct kmem_cache *drvDSARSSignKValue_zone = NULL;
+struct kmem_cache *drvDSAVerify_zone = NULL;
 
 /*Slab zones for flatbuffers and bufferlist*/
-icp_kmem_cache drvFlatBuffer_zone = NULL;
+struct kmem_cache *drvFlatBuffer_zone = NULL;
 
-static inline int icp_cache_null_check(void)
-{
-	return (drvSessionData_zone && drvOpData_zone
-		&& drvDH_zone && drvLnModExp_zone && drvRSADecrypt_zone
-		&& drvRSAPrivateKey_zone && drvDSARSSign_zone
-		&& drvDSARSSign_zone && drvDSARSSignKValue_zone
-		&& drvDSAVerify_zone && drvFlatBuffer_zone);
-}
-
-/*Function to free all allocated slab caches before exiting the module*/
+static int icp_ocfDrvInit(void);
+static void icp_ocfDrvExit(void);
 static void icp_ocfDrvFreeCaches(void);
+static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg);
 
 int32_t icp_ocfDrvDriverId = INVALID_DRIVER_ID;
 
@@ -134,42 +115,66 @@ int num_dereg_retries = DEFAULT_DEREG_RETRIES;
 int dereg_retry_delay_in_jiffies = DEFAULT_DEREG_DELAY_IN_JIFFIES;
 
 /* Module parameter - gives the maximum number of sessions possible between
-   OCF and the OCF EP80579 Driver. If set to zero, there is no limit.*/
+   OCF and the OCF Tolapai Driver. If set to zero, there is no limit.*/
 int max_sessions = DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT;
 
 /* This is set when the module is removed from the system, no further
    processing can take place if this is set */
-icp_atomic_t icp_ocfDrvIsExiting = ICP_ATOMIC_INIT(0);
+atomic_t icp_ocfDrvIsExiting = ATOMIC_INIT(0);
 
 /* This is used to show how many lac sessions were not deregistered*/
-icp_atomic_t lac_session_failed_dereg_count = ICP_ATOMIC_INIT(0);
+atomic_t lac_session_failed_dereg_count = ATOMIC_INIT(0);
 
 /* This is used to track the number of registered sessions between OCF and
- * and the OCF EP80579 driver, when max_session is set to value other than
+ * and the OCF Tolapai driver, when max_session is set to value other than
  * zero. This ensures that the max_session set for the OCF and the driver
  * is equal to the LAC registered sessions */
-icp_atomic_t num_ocf_to_drv_registered_sessions = ICP_ATOMIC_INIT(0);
+atomic_t num_ocf_to_drv_registered_sessions = ATOMIC_INIT(0);
 
 /* Head of linked list used to store session data */
-icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead;
-icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead_FreeMemList;
+struct list_head icp_ocfDrvGlobalSymListHead;
+struct list_head icp_ocfDrvGlobalSymListHead_FreeMemList;
 
-icp_spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
+spinlock_t icp_ocfDrvSymSessInfoListSpinlock = SPIN_LOCK_UNLOCKED;
+rwlock_t icp_kmem_cache_destroy_alloc_lock = RW_LOCK_UNLOCKED;
 
-/*Below pointer is only used in linux, FreeBSD uses the name to
-create its own variable name*/
-icp_workqueue *icp_ocfDrvFreeLacSessionWorkQ = NULL;
-ICP_WORKQUEUE_DEFINE_THREAD(icp_ocfDrvFreeLacSessionWorkQ);
+struct workqueue_struct *icp_ocfDrvFreeLacSessionWorkQ;
 
 struct icp_drvBuffListInfo defBuffListInfo;
 
+static struct {
+	softc_device_decl sc_dev;
+} icpDev;
+
+static device_method_t icp_methods = {
+	/* crypto device methods */
+	DEVMETHOD(cryptodev_newsession, icp_ocfDrvNewSession),
+	DEVMETHOD(cryptodev_freesession, icp_ocfDrvFreeLACSession),
+	DEVMETHOD(cryptodev_process, icp_ocfDrvSymProcess),
+	DEVMETHOD(cryptodev_kprocess, icp_ocfDrvPkeProcess),
+};
+
+module_param(num_dereg_retries, int, S_IRUGO);
+module_param(dereg_retry_delay_in_jiffies, int, S_IRUGO);
+module_param(max_sessions, int, S_IRUGO);
+
+MODULE_PARM_DESC(num_dereg_retries,
+		 "Number of times to retry LAC Sym Session Deregistration. "
+		 "Default 10, Max 100");
+MODULE_PARM_DESC(dereg_retry_delay_in_jiffies, "Delay in jiffies "
+		 "(added to a schedule() function call) before a LAC Sym "
+		 "Session Dereg is retried. Default 10");
+MODULE_PARM_DESC(max_sessions, "This sets the maximum number of sessions "
+		 "between OCF and this driver. If this value is set to zero, "
+		 "max session count checking is disabled. Default is zero(0)");
+
 /* Name        : icp_ocfDrvInit
  *
  * Description : This function will register all the symmetric and asymmetric
  * functionality that will be accelerated by the hardware. It will also
  * get a unique driver ID from the OCF and initialise all slab caches
  */
-ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
+static int __init icp_ocfDrvInit(void)
 {
 	int ocfStatus = 0;
 
@@ -179,7 +184,7 @@ ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
 	if (MAX_DEREG_RETRIES < num_dereg_retries) {
 		EPRINTK("Session deregistration retry count set to greater "
 			"than %d", MAX_DEREG_RETRIES);
-		icp_module_return_code(EINVAL);
+		return -1;
 	}
 
 	/* Initialize and Start the Cryptographic component */
@@ -187,133 +192,130 @@ ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
 	    cpaCyStartInstance(CPA_INSTANCE_HANDLE_SINGLE)) {
 		EPRINTK("Failed to initialize and start the instance "
 			"of the Cryptographic component.\n");
-		return icp_module_return_code(EINVAL);
+		return -1;
 	}
 
-	icp_spin_lock_init(&icp_ocfDrvSymSessInfoListSpinlock);
-
 	/* Set the default size of BufferList to allocate */
 	memset(&defBuffListInfo, 0, sizeof(struct icp_drvBuffListInfo));
 	if (ICP_OCF_DRV_STATUS_SUCCESS !=
 	    icp_ocfDrvBufferListMemInfo(ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS,
 					&defBuffListInfo)) {
 		EPRINTK("Failed to get bufferlist memory info.\n");
-		return icp_module_return_code(ENOMEM);
+		return -1;
 	}
 
-	/*Register OCF EP80579 Driver with OCF */
-	icp_ocfDrvDriverId = ICP_CRYPTO_GET_DRIVERID();
+	/*Register OCF Tolapai Driver with OCF */
+	memset(&icpDev, 0, sizeof(icpDev));
+	softc_device_init(&icpDev, "icp", 0, icp_methods);
+
+	icp_ocfDrvDriverId = crypto_get_driverid(softc_get_device(&icpDev),
+						 CRYPTOCAP_F_HARDWARE);
 
 	if (icp_ocfDrvDriverId < 0) {
 		EPRINTK("%s : ICP driver failed to register with OCF!\n",
 			__FUNCTION__);
-		return icp_module_return_code(ENODEV);
+		return -ENODEV;
 	}
 
-	/*Create all the slab caches used by the OCF EP80579 Driver */
+	/*Create all the slab caches used by the OCF Tolapai Driver */
 	drvSessionData_zone =
-	    ICP_CACHE_CREATE(ICP_SESSION_DATA_NAME, struct icp_drvSessionData);
+	    ICP_CACHE_CREATE("ICP Session Data", struct icp_drvSessionData);
+	ICP_CACHE_NULL_CHECK(drvSessionData_zone);
 
 	/* 
 	 * Allocation of the OpData includes the allocation space for meta data.
 	 * The memory after the opData structure is reserved for this meta data.
 	 */
 	drvOpData_zone =
-	    icp_kmem_cache_create(ICP_OP_DATA_NAME,
-				  sizeof(struct icp_drvOpData) +
-				  defBuffListInfo.metaSize,
-				  ICP_KERNEL_CACHE_ALIGN,
-				  ICP_KERNEL_CACHE_NOINIT);
+	    kmem_cache_create("ICP Op Data", sizeof(struct icp_drvOpData) +
+	            defBuffListInfo.metaSize ,0, SLAB_HWCACHE_ALIGN, NULL, NULL);
 
-	drvDH_zone = ICP_CACHE_CREATE(ICP_DH_NAME, CpaCyDhPhase1KeyGenOpData);
+
+	ICP_CACHE_NULL_CHECK(drvOpData_zone);
+
+	drvDH_zone = ICP_CACHE_CREATE("ICP DH data", CpaCyDhPhase1KeyGenOpData);
+	ICP_CACHE_NULL_CHECK(drvDH_zone);
 
 	drvLnModExp_zone =
-	    ICP_CACHE_CREATE(ICP_MODEXP_NAME, CpaCyLnModExpOpData);
+	    ICP_CACHE_CREATE("ICP ModExp data", CpaCyLnModExpOpData);
+	ICP_CACHE_NULL_CHECK(drvLnModExp_zone);
 
 	drvRSADecrypt_zone =
-	    ICP_CACHE_CREATE(ICP_RSA_DECRYPT_NAME, CpaCyRsaDecryptOpData);
+	    ICP_CACHE_CREATE("ICP RSA decrypt data", CpaCyRsaDecryptOpData);
+	ICP_CACHE_NULL_CHECK(drvRSADecrypt_zone);
 
 	drvRSAPrivateKey_zone =
-	    ICP_CACHE_CREATE(ICP_RSA_PKEY_NAME, CpaCyRsaPrivateKey);
+	    ICP_CACHE_CREATE("ICP RSA private key data", CpaCyRsaPrivateKey);
+	ICP_CACHE_NULL_CHECK(drvRSAPrivateKey_zone);
 
 	drvDSARSSign_zone =
-	    ICP_CACHE_CREATE(ICP_DSA_SIGN_NAME, CpaCyDsaRSSignOpData);
+	    ICP_CACHE_CREATE("ICP DSA Sign", CpaCyDsaRSSignOpData);
+	ICP_CACHE_NULL_CHECK(drvDSARSSign_zone);
 
 	/*too awkward to use a macro here */
 	drvDSARSSignKValue_zone =
-	    ICP_CACHE_CREATE(ICP_RAND_VAL_NAME,
-			     DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES);
+	    kmem_cache_create("ICP DSA Sign Rand Val",
+			      DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES, 0,
+			      SLAB_HWCACHE_ALIGN, NULL, NULL);
+	ICP_CACHE_NULL_CHECK(drvDSARSSignKValue_zone);
 
 	drvDSAVerify_zone =
-	    ICP_CACHE_CREATE(ICP_DSA_VER_NAME, CpaCyDsaVerifyOpData);
+	    ICP_CACHE_CREATE("ICP DSA Verify", CpaCyDsaVerifyOpData);
+	ICP_CACHE_NULL_CHECK(drvDSAVerify_zone);
 
 	drvFlatBuffer_zone =
-	    ICP_CACHE_CREATE(ICP_FLAT_BUFF_NAME, CpaFlatBuffer);
-
-	if (0 == icp_cache_null_check()) {
-		icp_ocfDrvFreeCaches();
-		EPRINTK("%s() line %d: Not enough memory!\n",
-			__FUNCTION__, __LINE__);
-		return ENOMEM;
-	}
+	    ICP_CACHE_CREATE("ICP Flat Buffers", CpaFlatBuffer);
+	ICP_CACHE_NULL_CHECK(drvFlatBuffer_zone);
 
 	/* Register the ICP symmetric crypto support. */
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_NULL_CBC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_DES_CBC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_3DES_CBC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_AES_CBC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_ARC4, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_MD5, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_MD5_HMAC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA1, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA1_HMAC, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_256, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_256_HMAC,
-			     ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_384, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_384_HMAC,
-			     ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_512, ocfStatus);
-	ICP_REG_SYM_WITH_OCF(icp_ocfDrvDriverId, CRYPTO_SHA2_512_HMAC,
-			     ocfStatus);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_NULL_CBC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_DES_CBC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_3DES_CBC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_AES_CBC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_ARC4);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_MD5);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_MD5_HMAC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA1);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA1_HMAC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_256);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_256_HMAC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_384);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_384_HMAC);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_512);
+	ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(CRYPTO_SHA2_512_HMAC);
 
 	/* Register the ICP asymmetric algorithm support */
-	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DH_COMPUTE_KEY,
-			      ocfStatus);
-	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_MOD_EXP, ocfStatus);
-	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_MOD_EXP_CRT, ocfStatus);
-	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DSA_SIGN, ocfStatus);
-	ICP_REG_ASYM_WITH_OCF(icp_ocfDrvDriverId, CRK_DSA_VERIFY, ocfStatus);
+	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DH_COMPUTE_KEY);
+	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_MOD_EXP);
+	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_MOD_EXP_CRT);
+	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DSA_SIGN);
+	ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(CRK_DSA_VERIFY);
 
 	/* Register the ICP random number generator support */
-	ICP_REG_RAND_WITH_OCF(icp_ocfDrvDriverId,
-			      icp_ocfDrvReadRandom, NULL, ocfStatus);
+	if (OCF_REGISTRATION_STATUS_SUCCESS ==
+	    crypto_rregister(icp_ocfDrvDriverId, icp_ocfDrvReadRandom, NULL)) {
+		ocfStatus++;
+	}
 
 	if (OCF_ZERO_FUNCTIONALITY_REGISTERED == ocfStatus) {
 		DPRINTK("%s: Failed to register any device capabilities\n",
 			__FUNCTION__);
 		icp_ocfDrvFreeCaches();
 		icp_ocfDrvDriverId = INVALID_DRIVER_ID;
-		return icp_module_return_code(ECANCELED);
+		return -ECANCELED;
 	}
 
 	DPRINTK("%s: Registered %d of %d device capabilities\n",
 		__FUNCTION__, ocfStatus, NUM_SUPPORTED_CAPABILITIES);
 
-	/*Session data linked list used during module exit */
-	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead);
-	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead_FreeMemList);
+/*Session data linked list used during module exit*/
+	INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead);
+	INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead_FreeMemList);
 
-	ICP_WORKQUEUE_CREATE(icp_ocfDrvFreeLacSessionWorkQ, "icpwq");
-	if (ICP_WORKQUEUE_NULL_CHECK(icp_ocfDrvFreeLacSessionWorkQ)) {
-		EPRINTK("%s: Failed to create single "
-			"thread workqueue\n", __FUNCTION__);
-		icp_ocfDrvFreeCaches();
-		icp_ocfDrvDriverId = INVALID_DRIVER_ID;
-		return icp_module_return_code(ENOMEM);
-	}
+	icp_ocfDrvFreeLacSessionWorkQ =
+	    create_singlethread_workqueue("ocfLacDeregWorkQueue");
 
-	return icp_module_return_code(0);
+	return 0;
 }
 
 /* Name        : icp_ocfDrvExit
@@ -323,46 +325,31 @@ ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
  * and asymmetric functionality that can be accelerated by the hardware via OCF
  * and random number generation if it is enabled.
  */
-ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
+static void icp_ocfDrvExit(void)
 {
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 	struct icp_drvSessionData *sessionData = NULL;
 	struct icp_drvSessionData *tempSessionData = NULL;
 	int i, remaining_delay_time_in_jiffies = 0;
-
-	/* For FreeBSD the invariant macro below makes function to return     */
-	/* with EBUSY value in the case of any session which has been regi-   */
-	/* stered with LAC not being deregistered.                            */
-	/* The Linux implementation is empty since it is purely to compensate */
-	/* for a limitation of the FreeBSD 7.1 Opencrypto framework.          */
-
-    ICP_MODULE_EXIT_INV();
-
 	/* There is a possibility of a process or new session command being   */
 	/* sent before this variable is incremented. The aim of this variable */
 	/* is to stop a loop of calls creating a deadlock situation which     */
 	/* would prevent the driver from exiting.                             */
-	icp_atomic_set(&icp_ocfDrvIsExiting, 1);
+
+	atomic_inc(&icp_ocfDrvIsExiting);
 
 	/*Existing sessions will be routed to another driver after these calls */
 	crypto_unregister_all(icp_ocfDrvDriverId);
 	crypto_runregister_all(icp_ocfDrvDriverId);
 
-	if (ICP_WORKQUEUE_NULL_CHECK(icp_ocfDrvFreeLacSessionWorkQ)) {
-		DPRINTK("%s: workqueue already "
-			"destroyed, therefore module exit "
-			" function already called. Exiting.\n", __FUNCTION__);
-		return ICP_MODULE_EXIT_FUNC_RETURN_VAL;
-	}
 	/*If any sessions are waiting to be deregistered, do that. This also 
 	   flushes the work queue */
-	ICP_WORKQUEUE_DESTROY(icp_ocfDrvFreeLacSessionWorkQ);
+	destroy_workqueue(icp_ocfDrvFreeLacSessionWorkQ);
 
 	/*ENTER CRITICAL SECTION */
-	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
-
-	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
-				     &icp_ocfDrvGlobalSymListHead, listNode) {
+	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
+	list_for_each_entry_safe(tempSessionData, sessionData,
+				 &icp_ocfDrvGlobalSymListHead, listNode) {
 		for (i = 0; i < num_dereg_retries; i++) {
 			/*No harm if bad input - LAC will handle error cases */
 			if (ICP_SESSION_RUNNING == tempSessionData->inUse) {
@@ -374,7 +361,7 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 					/* Succesfully deregistered */
 					break;
 				} else if (CPA_STATUS_RETRY != lacStatus) {
-					icp_atomic_inc
+					atomic_inc
 					    (&lac_session_failed_dereg_count);
 					break;
 				}
@@ -385,9 +372,8 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 				    dereg_retry_delay_in_jiffies;
 				while (0 > remaining_delay_time_in_jiffies) {
 					remaining_delay_time_in_jiffies =
-					    icp_schedule_timeout
-					    (&icp_ocfDrvSymSessInfoListSpinlock,
-					     remaining_delay_time_in_jiffies);
+					    schedule_timeout
+					    (remaining_delay_time_in_jiffies);
 				}
 
 				DPRINTK
@@ -397,48 +383,44 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 		}
 
 		/*remove from current list */
-		ICP_LIST_DEL(tempSessionData, listNode);
+		list_del(&(tempSessionData->listNode));
 		/*add to free mem linked list */
-		ICP_LIST_ADD(tempSessionData,
-			     &icp_ocfDrvGlobalSymListHead_FreeMemList,
-			     listNode);
+		list_add(&(tempSessionData->listNode),
+			 &icp_ocfDrvGlobalSymListHead_FreeMemList);
 
 	}
 
 	/*EXIT CRITICAL SECTION */
-	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
+	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	/*set back to initial values */
 	sessionData = NULL;
 	/*still have a reference in our list! */
 	tempSessionData = NULL;
 	/*free memory */
+	list_for_each_entry_safe(tempSessionData, sessionData,
+				 &icp_ocfDrvGlobalSymListHead_FreeMemList,
+				 listNode) {
 
-	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
-				     &icp_ocfDrvGlobalSymListHead_FreeMemList,
-				     listNode) {
-
-		ICP_LIST_DEL(tempSessionData, listNode);
+		list_del(&(tempSessionData->listNode));
 		/* Free allocated CpaCySymSessionCtx */
 		if (NULL != tempSessionData->sessHandle) {
-			icp_kfree(tempSessionData->sessHandle);
+			kfree(tempSessionData->sessHandle);
 		}
 		memset(tempSessionData, 0, sizeof(struct icp_drvSessionData));
-		ICP_CACHE_FREE(drvSessionData_zone, tempSessionData);
+		kmem_cache_free(drvSessionData_zone, tempSessionData);
 	}
 
-	if (0 != icp_atomic_read(&lac_session_failed_dereg_count)) {
+	if (0 != atomic_read(&lac_session_failed_dereg_count)) {
 		DPRINTK("%s(): %d LAC sessions were not deregistered "
 			"correctly. This is not a clean exit! \n",
 			__FUNCTION__,
-			icp_atomic_read(&lac_session_failed_dereg_count));
+			atomic_read(&lac_session_failed_dereg_count));
 	}
 
 	icp_ocfDrvFreeCaches();
 	icp_ocfDrvDriverId = INVALID_DRIVER_ID;
 
-	icp_spin_lock_destroy(&icp_ocfDrvSymSessInfoListSpinlock);
-
 	/* Shutdown the Cryptographic component */
 	lacStatus = cpaCyStopInstance(CPA_INSTANCE_HANDLE_SINGLE);
 	if (CPA_STATUS_SUCCESS != lacStatus) {
@@ -447,7 +429,6 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 			__FUNCTION__, lacStatus);
 	}
 
-	return ICP_MODULE_EXIT_FUNC_RETURN_VAL;
 }
 
 /* Name        : icp_ocfDrvFreeCaches
@@ -456,7 +437,9 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
  */
 static void icp_ocfDrvFreeCaches(void)
 {
-	icp_atomic_set(&icp_ocfDrvIsExiting, 1);
+	if (atomic_read(&icp_ocfDrvIsExiting) != CPA_TRUE) {
+		atomic_set(&icp_ocfDrvIsExiting, 1);
+	}
 
 	/*Sym Zones */
 	ICP_CACHE_DESTROY(drvSessionData_zone);
@@ -482,6 +465,7 @@ static void icp_ocfDrvFreeCaches(void)
  * off to a work queue. If it fails, nothing more can be done and it
  * returns an error
  */
+
 int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 {
 	struct icp_ocfDrvFreeLacSession *workstore = NULL;
@@ -491,11 +475,11 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 
 	/*make sure the session is not available to be allocated during this
 	   process */
-	icp_atomic_inc(&lac_session_failed_dereg_count);
+	atomic_inc(&lac_session_failed_dereg_count);
 
 	/*Farm off to work queue */
 	workstore =
-	    icp_kmalloc(sizeof(struct icp_ocfDrvFreeLacSession), ICP_M_NOWAIT);
+	    kmalloc(sizeof(struct icp_ocfDrvFreeLacSession), GFP_ATOMIC);
 	if (NULL == workstore) {
 		DPRINTK("%s(): unable to free session - no memory available "
 			"for work queue\n", __FUNCTION__);
@@ -504,11 +488,9 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
 
 	workstore->sessionToDeregister = sessionToDeregister;
 
-	icp_init_work(&(workstore->work),
-		      icp_ocfDrvDeferedFreeLacSessionTaskFn, workstore);
-
-	ICP_WORKQUEUE_ENQUEUE(icp_ocfDrvFreeLacSessionWorkQ,
-			      &(workstore->work));
+	INIT_WORK(&(workstore->work), icp_ocfDrvDeferedFreeLacSessionProcess,
+		  workstore);
+	queue_work(icp_ocfDrvFreeLacSessionWorkQ, &(workstore->work));
 
 	return ICP_OCF_DRV_STATUS_SUCCESS;
 
@@ -521,7 +503,7 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister)
  * CPA_STATUS_RETRY message from the LAC component. This function is run in
  * Thread context because it is called from a worker thread
  */
-void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
+static void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 {
 	struct icp_ocfDrvFreeLacSession *workstore = NULL;
 	CpaCySymSessionCtx sessionToDeregister = NULL;
@@ -537,10 +519,10 @@ void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 	}
 
 	sessionToDeregister = workstore->sessionToDeregister;
-	icp_kfree(workstore);
+	kfree(workstore);
 
 	/*if exiting, give deregistration one more blast only */
-	if (icp_atomic_read(&icp_ocfDrvIsExiting) == CPA_TRUE) {
+	if (atomic_read(&icp_ocfDrvIsExiting) == CPA_TRUE) {
 		lacStatus = cpaCySymRemoveSession(CPA_INSTANCE_HANDLE_SINGLE,
 						  sessionToDeregister);
 
@@ -551,7 +533,7 @@ void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 			return;
 		}
 
-		icp_atomic_dec(&lac_session_failed_dereg_count);
+		atomic_dec(&lac_session_failed_dereg_count);
 		return;
 	}
 
@@ -560,7 +542,7 @@ void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 						  sessionToDeregister);
 
 		if (lacStatus == CPA_STATUS_SUCCESS) {
-			icp_atomic_dec(&lac_session_failed_dereg_count);
+			atomic_dec(&lac_session_failed_dereg_count);
 			return;
 		}
 		if (lacStatus != CPA_STATUS_RETRY) {
@@ -572,17 +554,16 @@ void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 		/*schedule_timout returns the time left for completion if this
 		   task is set to TASK_INTERRUPTIBLE */
 		remaining_delay_time_in_jiffies = dereg_retry_delay_in_jiffies;
-		while (0 < remaining_delay_time_in_jiffies) {
+		while (0 > remaining_delay_time_in_jiffies) {
 			remaining_delay_time_in_jiffies =
-			    icp_schedule_timeout(NULL,
-						 remaining_delay_time_in_jiffies);
+			    schedule_timeout(remaining_delay_time_in_jiffies);
 		}
 
 	}
 
 	DPRINTK("%s(): Unable to deregister session\n", __FUNCTION__);
 	DPRINTK("%s(): Number of unavailable LAC sessions = %d\n", __FUNCTION__,
-		icp_atomic_read(&lac_session_failed_dereg_count));
+		atomic_read(&lac_session_failed_dereg_count));
 }
 
 /* Name        : icp_ocfDrvPtrAndLenToFlatBuffer 
@@ -600,6 +581,131 @@ icp_ocfDrvPtrAndLenToFlatBuffer(void *pData, uint32_t len,
 	pFlatBuffer->dataLenInBytes = len;
 }
 
+/* Name        : icp_ocfDrvSingleSkBuffToFlatBuffer 
+ *
+ * Description : This function converts a single socket buffer (sk_buff)
+ * structure to a Fredericksburg Flat Buffer (CpaFlatBuffer) format.
+ *
+ * This function assumes that the data passed in are valid.
+ */
+static inline void
+icp_ocfDrvSingleSkBuffToFlatBuffer(struct sk_buff *pSkb,
+				   CpaFlatBuffer * pFlatBuffer)
+{
+	pFlatBuffer->pData = pSkb->data;
+	pFlatBuffer->dataLenInBytes = skb_headlen(pSkb);
+}
+
+/* Name        : icp_ocfDrvSkBuffToBufferList 
+ *
+ * Description : This function converts a socket buffer (sk_buff) structure to
+ * Fredericksburg Scatter/Gather (CpaBufferList) buffer format.
+ *
+ * This function assumes that the bufferlist has been allocated with the correct
+ * number of buffer arrays.
+ * 
+ */
+inline int
+icp_ocfDrvSkBuffToBufferList(struct sk_buff *pSkb, CpaBufferList * bufferList)
+{
+	CpaFlatBuffer *curFlatBuffer = NULL;
+	char *skbuffPageAddr = NULL;
+	struct sk_buff *pCurFrag = NULL;
+	struct skb_shared_info *pShInfo = NULL;
+	uint32_t page_offset = 0, i = 0;
+
+	DPRINTK("%s(): Entry Point\n", __FUNCTION__);
+
+	/*
+	 * In all cases, the first skb needs to be translated to FlatBuffer.
+	 * Perform a buffer translation for the first skbuff
+	 */
+	curFlatBuffer = bufferList->pBuffers;
+	icp_ocfDrvSingleSkBuffToFlatBuffer(pSkb, curFlatBuffer);
+
+	/* Set the userData to point to the original sk_buff */
+	bufferList->pUserData = (void *)pSkb;
+
+	/* We now know we'll have at least one element in the SGL */
+	bufferList->numBuffers = 1;
+
+	if (0 == skb_is_nonlinear(pSkb)) {
+		/* Is a linear buffer - therefore it's a single skbuff */
+		DPRINTK("%s(): Exit Point\n", __FUNCTION__);
+		return ICP_OCF_DRV_STATUS_SUCCESS;
+	}
+
+	curFlatBuffer++;
+	pShInfo = skb_shinfo(pSkb);
+	if (pShInfo->frag_list != NULL && pShInfo->nr_frags != 0) {
+		EPRINTK("%s():"
+			"Translation for a combination of frag_list "
+			"and frags[] array not supported!\n", __FUNCTION__);
+		return ICP_OCF_DRV_STATUS_FAIL;
+	} else if (pShInfo->frag_list != NULL) {
+		/*
+		 * Non linear skbuff supported through frag_list 
+		 * Perform translation for each fragment (sk_buff)
+		 * in the frag_list of the first sk_buff.
+		 */
+		for (pCurFrag = pShInfo->frag_list;
+		     pCurFrag != NULL; pCurFrag = pCurFrag->next) {
+			icp_ocfDrvSingleSkBuffToFlatBuffer(pCurFrag,
+							   curFlatBuffer);
+			curFlatBuffer++;
+			bufferList->numBuffers++;
+		}
+	} else if (pShInfo->nr_frags != 0) {
+		/*
+		 * Perform translation for each fragment in frags array
+		 * and add to the BufferList
+		 */
+		for (i = 0; i < pShInfo->nr_frags; i++) {
+			/* Get the page address and offset of this frag */
+			skbuffPageAddr = (char *)pShInfo->frags[i].page;
+			page_offset = pShInfo->frags[i].page_offset;
+
+			/* Convert a pointer and length to a flat buffer */
+			icp_ocfDrvPtrAndLenToFlatBuffer(skbuffPageAddr +
+							page_offset,
+							pShInfo->frags[i].size,
+							curFlatBuffer);
+			curFlatBuffer++;
+			bufferList->numBuffers++;
+		}
+	} else {
+		EPRINTK("%s():" "Could not recognize skbuff fragments!\n",
+			__FUNCTION__);
+		return ICP_OCF_DRV_STATUS_FAIL;
+	}
+
+	DPRINTK("%s(): Exit Point\n", __FUNCTION__);
+	return ICP_OCF_DRV_STATUS_SUCCESS;
+}
+
+/* Name        : icp_ocfDrvBufferListToSkBuff 
+ *
+ * Description : This function converts a Fredericksburg Scatter/Gather 
+ * (CpaBufferList) buffer format to socket buffer structure.
+ */
+inline int
+icp_ocfDrvBufferListToSkBuff(CpaBufferList * bufferList, struct sk_buff **skb)
+{
+	DPRINTK("%s(): Entry Point\n", __FUNCTION__);
+
+	/* Retrieve the orignal skbuff */
+	*skb = (struct sk_buff *)bufferList->pUserData;
+	if (NULL == *skb) {
+		EPRINTK("%s():"
+			"Error on converting from a BufferList. "
+			"The BufferList does not contain an sk_buff.\n",
+			__FUNCTION__);
+		return ICP_OCF_DRV_STATUS_FAIL;
+	}
+	DPRINTK("%s(): Exit Point\n", __FUNCTION__);
+	return ICP_OCF_DRV_STATUS_SUCCESS;
+}
+
 /* Name        : icp_ocfDrvPtrAndLenToBufferList
  *
  * Description : This function converts a "pointer and length" buffer
@@ -655,6 +761,45 @@ icp_ocfDrvBufferListMemInfo(uint16_t numBuffers,
 	return ICP_OCF_DRV_STATUS_SUCCESS;
 }
 
+/* Name        : icp_ocfDrvGetSkBuffFrags
+ *
+ * Description : This function will determine the number of 
+ * fragments in a socket buffer(sk_buff).
+ */
+inline uint16_t icp_ocfDrvGetSkBuffFrags(struct sk_buff * pSkb)
+{
+	uint16_t numFrags = 0;
+	struct sk_buff *pCurFrag = NULL;
+	struct skb_shared_info *pShInfo = NULL;
+
+	if (NULL == pSkb)
+		return 0;
+
+	numFrags = 1;
+	if (0 == skb_is_nonlinear(pSkb)) {
+		/* Linear buffer - it's a single skbuff */
+		return numFrags;
+	}
+
+	pShInfo = skb_shinfo(pSkb);
+	if (NULL != pShInfo->frag_list && 0 != pShInfo->nr_frags) {
+		EPRINTK("%s(): Combination of frag_list "
+			"and frags[] array not supported!\n", __FUNCTION__);
+		return 0;
+	} else if (0 != pShInfo->nr_frags) {
+		numFrags += pShInfo->nr_frags;
+		return numFrags;
+	} else if (NULL != pShInfo->frag_list) {
+		for (pCurFrag = pShInfo->frag_list;
+		     pCurFrag != NULL; pCurFrag = pCurFrag->next) {
+			numFrags++;
+		}
+		return numFrags;
+	} else {
+		return 0;
+	}
+}
+
 /* Name        : icp_ocfDrvFreeFlatBuffer
  *
  * Description : This function will deallocate flat buffer.
@@ -663,7 +808,7 @@ inline void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer)
 {
 	if (pFlatBuffer != NULL) {
 		memset(pFlatBuffer, 0, sizeof(CpaFlatBuffer));
-		ICP_CACHE_FREE(drvFlatBuffer_zone, pFlatBuffer);
+		kmem_cache_free(drvFlatBuffer_zone, pFlatBuffer);
 	}
 }
 
@@ -674,14 +819,14 @@ inline void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer)
  */
 inline int
 icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
-			struct icp_drvOpData *pOpData)
+        const struct icp_drvOpData *pOpData)
 {
 	Cpa32U metaSize = 0;
 
-	if (pBufferList->numBuffers <= ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
-		uint8_t *pOpDataStartAddr = (uint8_t *) pOpData;
+	if (pBufferList->numBuffers <= ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS){
+	    void *pOpDataStartAddr = (void *)pOpData;
 
-		if (0 == defBuffListInfo.metaSize) {
+	    if (0 == defBuffListInfo.metaSize) {
 			pBufferList->pPrivateMetaData = NULL;
 			return ICP_OCF_DRV_STATUS_SUCCESS;
 		}
@@ -690,9 +835,8 @@ icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 		 * op data.  It has been pre-allocated in memory just after the
 		 * icp_drvOpData structure.
 		 */
-		pBufferList->pPrivateMetaData = (void *)(pOpDataStartAddr +
-							 sizeof(struct
-								icp_drvOpData));
+		pBufferList->pPrivateMetaData = pOpDataStartAddr +
+		        sizeof(struct icp_drvOpData);
 	} else {
 		if (CPA_STATUS_SUCCESS !=
 		    cpaCyBufferListGetMetaSize(CPA_INSTANCE_HANDLE_SINGLE,
@@ -708,8 +852,7 @@ icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 			return ICP_OCF_DRV_STATUS_SUCCESS;
 		}
 
-		pBufferList->pPrivateMetaData =
-		    icp_kmalloc(metaSize, ICP_M_NOWAIT);
+		pBufferList->pPrivateMetaData = kmalloc(metaSize, GFP_ATOMIC);
 	}
 	if (NULL == pBufferList->pPrivateMetaData) {
 		EPRINTK("%s() Failed to allocate pPrivateMetaData.\n",
@@ -736,38 +879,13 @@ inline void icp_ocfDrvFreeMetaData(CpaBufferList * pBufferList)
 	 * Otherwise, the meta data shall be freed when the icp_drvOpData is
 	 * freed.
 	 */
-	if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < pBufferList->numBuffers) {
-		icp_kfree(pBufferList->pPrivateMetaData);
+	if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < pBufferList->numBuffers){
+		kfree(pBufferList->pPrivateMetaData);
 	}
 }
 
-/* Module declaration, init and exit functions */
-ICP_DECLARE_MODULE(icp_ocf, icp_ocfDrvInit, icp_ocfDrvExit);
-ICP_MODULE_DESCRIPTION("OCF Driver for Intel Quick Assist crypto acceleration");
-ICP_MODULE_VERSION(icp_ocf, ICP_OCF_VER_MJR);
-ICP_MODULE_LICENSE("Dual BSD/GPL");
-ICP_MODULE_AUTHOR("Intel");
-
-/* Module parameters */
-ICP_MODULE_PARAM_INT(icp_ocf, num_dereg_retries,
-		     "Number of times to retry LAC Sym Session Deregistration. "
-		     "Default 10, Max 100");
-ICP_MODULE_PARAM_INT(icp_ocf, dereg_retry_delay_in_jiffies, "Delay in jiffies "
-		     "(added to a schedule() function call) before a LAC Sym "
-		     "Session Dereg is retried. Default 10");
-ICP_MODULE_PARAM_INT(icp_ocf, max_sessions,
-		     "This sets the maximum number of sessions "
-		     "between OCF and this driver. If this value is set to zero,"
-		     "max session count checking is disabled. Default is zero(0)");
-
-/* Module dependencies */
-#define MODULE_MIN_VER	1
-#define CRYPTO_MAX_VER	3
-#define LAC_MAX_VER	2
-
-ICP_MODULE_DEPEND(icp_ocf, crypto, MODULE_MIN_VER, MODULE_MIN_VER,
-		  CRYPTO_MAX_VER);
-ICP_MODULE_DEPEND(icp_ocf, cryptodev, MODULE_MIN_VER, MODULE_MIN_VER,
-		  CRYPTO_MAX_VER);
-ICP_MODULE_DEPEND(icp_ocf, icp_crypto, MODULE_MIN_VER, MODULE_MIN_VER,
-		  LAC_MAX_VER);
+module_init(icp_ocfDrvInit);
+module_exit(icp_ocfDrvExit);
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Intel");
+MODULE_DESCRIPTION("OCF Driver for Intel Quick Assist crypto acceleration");
diff --git a/crypto/ocf/ep80579/icp_ocf.h b/crypto/ocf/ep80579/icp_ocf.h
index d9dde87..dff0a8b 100644
--- a/crypto/ocf/ep80579/icp_ocf.h
+++ b/crypto/ocf/ep80579/icp_ocf.h
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,34 +57,42 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.2-229
+ *  version: Security.L.1.0.130
  *
  ***************************************************************************/
 
 /*
- * OCF driver header file for the Intel ICP processor.
+ * OCF drv driver header file for the Intel ICP processor.
  */
 
-#ifndef ICP_OCF_H_
-#define ICP_OCF_H_
+#ifndef ICP_OCF_H
+#define ICP_OCF_H
 
-#include <cpa.h>
-#include <cpa_cy_im.h>
-#include <cpa_cy_sym.h>
-#include <cpa_cy_rand.h>
-#include <cpa_cy_dh.h>
-#include <cpa_cy_rsa.h>
-#include <cpa_cy_ln.h>
-#include <cpa_cy_common.h>
-#include <cpa_cy_dsa.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
 
-#include "icp_os.h"
+#include "cryptodev.h"
+#include "uio.h"
+
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_cy_sym.h"
+#include "cpa_cy_rand.h"
+#include "cpa_cy_dh.h"
+#include "cpa_cy_rsa.h"
+#include "cpa_cy_ln.h"
+#include "cpa_cy_common.h"
+#include "cpa_cy_dsa.h"
 
 #define NUM_BITS_IN_BYTE (8)
 #define NUM_BITS_IN_BYTE_MINUS_ONE (NUM_BITS_IN_BYTE -1)
 #define INVALID_DRIVER_ID (-1)
 #define RETURN_RAND_NUM_GEN_FAILED (-1)
 
+/*This is define means only one operation can be chained to another
+(resulting in one chain of two operations)*/
+#define MAX_NUM_OF_CHAINED_OPS (1)
 /*This is the max block cipher initialisation vector*/
 #define MAX_IV_LEN_IN_BYTES (20)
 /*This is used to check whether the OCF to this driver session limit has
@@ -110,10 +118,61 @@
 #define ICP_OCF_PRINT_KERN_ALERT		(1)
 #define ICP_OCF_PRINT_KERN_ERRS			(1)
 
+/*DSA Prime Q size in bytes (as defined in the standard) */
+#define DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES	(20)
+
+/*MACRO DEFINITIONS*/
+
+#define BITS_TO_BYTES(bytes, bits) 					\
+	bytes = (bits + NUM_BITS_IN_BYTE_MINUS_ONE) / NUM_BITS_IN_BYTE
+
+#define ICP_CACHE_CREATE(cache_ID, cache_name) 				\
+	kmem_cache_create(cache_ID, sizeof(cache_name),0, 		\
+		SLAB_HWCACHE_ALIGN, NULL, NULL);
+
+#define ICP_CACHE_NULL_CHECK(slab_zone)					\
+{									\
+	if(NULL == slab_zone){ 						\
+		icp_ocfDrvFreeCaches(); 				\
+		EPRINTK("%s() line %d: Not enough memory!\n", 		\
+			__FUNCTION__, __LINE__); 			\
+		return ENOMEM; 						\
+	}								\
+}
+
+#define ICP_CACHE_DESTROY(slab_zone) 	                                \
+{                                                                       \
+        if(NULL != slab_zone){						\
+                kmem_cache_destroy(slab_zone);				\
+                slab_zone = NULL;					\
+        }								\
+}
+
+#define ICP_REGISTER_SYM_FUNCTIONALITY_WITH_OCF(alg)			\
+{									\
+	if(OCF_REGISTRATION_STATUS_SUCCESS ==				\
+		crypto_register(icp_ocfDrvDriverId,			\
+				    alg,				\
+				    0,					\
+				    0)) {				\
+		ocfStatus++;						\
+	}								\
+}
+
+#define ICP_REGISTER_ASYM_FUNCTIONALITY_WITH_OCF(alg)			\
+{									\
+	if(OCF_REGISTRATION_STATUS_SUCCESS ==				\
+		crypto_kregister(icp_ocfDrvDriverId,			\
+				      alg,				\
+				      0)){				\
+		ocfStatus++;						\
+	}								\
+}
+
 #if ICP_OCF_PRINT_DEBUG_MESSAGES == 1
 #define DPRINTK(args...)      \
 {			      \
-                ICP_IPRINTK(args); \
+                printk(args); \
 }
 
 #else				//ICP_OCF_PRINT_DEBUG_MESSAGES == 1
@@ -125,7 +184,7 @@
 #if ICP_OCF_PRINT_KERN_ALERT == 1
 #define APRINTK(args...)      						\
 {			      						\
-       ICP_APRINTK(args);						\
+       printk(KERN_ALERT args);						\
 }
 
 #else				//ICP_OCF_PRINT_KERN_ALERT == 1
@@ -137,7 +196,7 @@
 #if ICP_OCF_PRINT_KERN_ERRS == 1
 #define EPRINTK(args...)      \
 {			      \
-       ICP_EPRINTK(args); \
+       printk(KERN_ERR args); \
 }
 
 #else				//ICP_OCF_PRINT_KERN_ERRS == 1
@@ -148,110 +207,47 @@
 
 #define IPRINTK(args...)      \
 {			      \
-      ICP_IPRINTK(args); \
+      printk(KERN_INFO args); \
 }
 
-/*DSA Prime Q size in bytes (as defined in the standard) */
-#define DSA_RS_SIGN_PRIMEQ_SIZE_IN_BYTES	(20)
-
-#define BITS_TO_BYTES(bytes, bits) 					\
-	bytes = (bits + NUM_BITS_IN_BYTE_MINUS_ONE) / NUM_BITS_IN_BYTE
+/*END OF MACRO DEFINITIONS*/
 
 typedef enum {
 	ICP_OCF_DRV_ALG_CIPHER = 0,
 	ICP_OCF_DRV_ALG_HASH
 } icp_ocf_drv_alg_type_t;
 
-typedef ICP_LIST_HEAD(icp_drvSessionListHead_s,
-		      icp_drvSessionData) icp_drvSessionListHead_t;
-
-/*Values used to derisk chances of performs being called against
-deregistered sessions (for which the slab page has been reclaimed)
-This is not a fix - since page frames are reclaimed from a slab, one cannot
-rely on that memory not being re-used by another app.*/
-typedef enum {
-	ICP_SESSION_INITIALISED = 0x5C5C5C,
-	ICP_SESSION_RUNNING = 0x005C00,
-	ICP_SESSION_DEREGISTERED = 0xC5C5C5
-} usage_derisk;
-
-/* This struct is required for deferred session
- deregistration as a work queue function can
- only have one argument*/
-struct icp_ocfDrvFreeLacSession {
-	CpaCySymSessionCtx sessionToDeregister;
-	icp_workstruct work;
-};
-
-/*
-This is the OCF<->OCF_DRV session object:
-
-1.listNode
-  The first member is a listNode. These session objects are added to a linked
-  list in order to make it easier to remove them all at session exit time.
-
-2.inUse
-  The second member is used to give the session object state and derisk the
-  possibility of OCF batch calls executing against a deregistered session (as
-  described above).
-
-3.sessHandle
-  The third member is a LAC<->OCF_DRV session handle (initialised with the first
-  perform request for that session).
-
-4.lacSessCtx
-  The fourth is the LAC session context. All the parameters for this structure
-  are only known when the first perform request for this session occurs. That is
-  why the OCF EP80579 Driver only registers a new LAC session at perform time
-*/
-struct icp_drvSessionData {
-	ICP_LIST_ENTRY(icp_drvSessionData) listNode;
-	usage_derisk inUse;
-	CpaCySymSessionCtx sessHandle;
-	CpaCySymSessionSetupData lacSessCtx;
-};
-
 /* These are all defined in icp_common.c */
-extern icp_atomic_t lac_session_failed_dereg_count;
-extern icp_atomic_t icp_ocfDrvIsExiting;
-extern icp_atomic_t num_ocf_to_drv_registered_sessions;
+extern atomic_t lac_session_failed_dereg_count;
+extern atomic_t icp_ocfDrvIsExiting;
+extern atomic_t num_ocf_to_drv_registered_sessions;
 
-extern int32_t icp_ocfDrvDriverId;
+/*These are use inputs used in icp_sym.c and icp_common.c
+  They are instantiated in icp_common.c*/
+extern int max_sessions;
 
-extern icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead;
-extern icp_drvSessionListHead_t icp_ocfDrvGlobalSymListHead_FreeMemList;
-extern icp_workqueue *icp_ocfDrvFreeLacSessionWorkQ;
-extern icp_spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
+extern int32_t icp_ocfDrvDriverId;
+extern struct list_head icp_ocfDrvGlobalSymListHead;
+extern struct list_head icp_ocfDrvGlobalSymListHead_FreeMemList;
+extern struct workqueue_struct *icp_ocfDrvFreeLacSessionWorkQ;
+extern spinlock_t icp_ocfDrvSymSessInfoListSpinlock;
+extern rwlock_t icp_kmem_cache_destroy_alloc_lock;
 
 /*Slab zones for symettric functionality, instantiated in icp_common.c*/
-extern icp_kmem_cache drvSessionData_zone;
-extern icp_kmem_cache drvOpData_zone;
+extern struct kmem_cache *drvSessionData_zone;
+extern struct kmem_cache *drvOpData_zone;
 
 /*Slabs zones for asymettric functionality, instantiated in icp_common.c*/
-extern icp_kmem_cache drvDH_zone;
-extern icp_kmem_cache drvLnModExp_zone;
-extern icp_kmem_cache drvRSADecrypt_zone;
-extern icp_kmem_cache drvRSAPrivateKey_zone;
-extern icp_kmem_cache drvDSARSSign_zone;
-extern icp_kmem_cache drvDSARSSignKValue_zone;
-extern icp_kmem_cache drvDSAVerify_zone;
-
-/* Module parameters defined in icp_cpmmon.c*/
-
-/* Module parameters - gives the number of times LAC deregistration shall be
-   re-tried */
-extern int num_dereg_retries;
-
-/* Module parameter - gives the delay time in jiffies before a LAC session 
-   shall be attempted to be deregistered again */
-extern int dereg_retry_delay_in_jiffies;
-
-/* Module parameter - gives the maximum number of sessions possible between
-   OCF and the OCF EP80579 Driver. If set to zero, there is no limit.*/
-extern int max_sessions;
+extern struct kmem_cache *drvDH_zone;
+extern struct kmem_cache *drvLnModExp_zone;
+extern struct kmem_cache *drvRSADecrypt_zone;
+extern struct kmem_cache *drvRSAPrivateKey_zone;
+extern struct kmem_cache *drvDSARSSign_zone;
+extern struct kmem_cache *drvDSARSSignKValue_zone;
+extern struct kmem_cache *drvDSAVerify_zone;
 
 /*Slab zones for flatbuffers and bufferlist*/
-extern icp_kmem_cache drvFlatBuffer_zone;
+extern struct kmem_cache *drvFlatBuffer_zone;
 
 #define ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS     (16)
 
@@ -261,13 +257,19 @@ struct icp_drvBuffListInfo {
 	Cpa32U metaOffset;
 	Cpa32U buffListSize;
 };
-
 extern struct icp_drvBuffListInfo defBuffListInfo;
 
-/* This struct is used to keep a reference to the relevant node in the list
-   of sessionData structs, to the buffer type required by OCF and to the OCF
-   provided crp struct that needs to be returned. All this info is needed in
-   the callback function.*/
+/*
+* This struct is used to keep a reference to the relevant node in the list
+* of sessionData structs, to the buffer type required by OCF and to the OCF
+* provided crp struct that needs to be returned. All this info is needed in
+* the callback function.
+*
+* IV can sometimes be stored in non-contiguous memory (e.g. skbuff
+* linked/frag list, therefore a contiguous memory space for the IV data must be
+* created and passed to LAC
+*
+*/
 struct icp_drvOpData {
 	CpaCySymOpData lacOpData;
 	uint32_t digestSizeInBytes;
@@ -279,98 +281,83 @@ struct icp_drvOpData {
 	CpaFlatBuffer bufferListArray[ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS];
 	CpaBoolean verifyResult;
 };
+/*Values used to derisk chances of performs being called against
+deregistered sessions (for which the slab page has been reclaimed)
+This is not a fix - since page frames are reclaimed from a slab, one cannot
+rely on that memory not being re-used by another app.*/
+typedef enum {
+	ICP_SESSION_INITIALISED = 0x5C5C5C,
+	ICP_SESSION_RUNNING = 0x005C00,
+	ICP_SESSION_DEREGISTERED = 0xC5C5C5
+} usage_derisk;
+
+/*
+This is the OCF<->OCF_DRV session object:
+
+1.The first member is a listNode. These session objects are added to a linked
+  list in order to make it easier to remove them all at session exit time.
+2.The second member is used to give the session object state and derisk the
+  possibility of OCF batch calls executing against a deregistered session (as
+  described above).
+3.The third member is a LAC<->OCF_DRV session handle (initialised with the first
+  perform request for that session).
+4.The fourth is the LAC session context. All the parameters for this structure
+  are only known when the first perform request for this session occurs. That is
+  why the OCF Tolapai Driver only registers a new LAC session at perform time
+*/
+struct icp_drvSessionData {
+	struct list_head listNode;
+	usage_derisk inUse;
+	CpaCySymSessionCtx sessHandle;
+	CpaCySymSessionSetupData lacSessCtx;
+};
 
-/* Create a new session between OCF and this driver*/
-int icp_ocfDrvNewSession(icp_device_t dev, uint32_t * sild,
-			 struct cryptoini *cri);
+/* This struct is required for deferred session
+ deregistration as a work queue function can
+ only have one argument*/
+struct icp_ocfDrvFreeLacSession {
+	CpaCySymSessionCtx sessionToDeregister;
+	struct work_struct work;
+};
 
-/* Free a session between this driver and the Quick Assist Framework*/
-int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid);
+int icp_ocfDrvNewSession(device_t dev, uint32_t * sild, struct cryptoini *cri);
 
-/* Defer freeing a Quick Assist session*/
-void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg);
+int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid);
 
-/* Process OCF cryptographic request for a symmetric algorithm*/
-int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint);
+int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint);
 
-/* Process OCF cryptographic request for an asymmetric algorithm*/
-int icp_ocfDrvPkeProcess(icp_device_t dev, struct cryptkop *krp, int hint);
+int icp_ocfDrvPkeProcess(device_t dev, struct cryptkop *krp, int hint);
 
-/* Populate a buffer with random data*/
 int icp_ocfDrvReadRandom(void *arg, uint32_t * buf, int maxwords);
 
-/* Retry Quick Assist session deregistration*/
 int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister);
 
-/* Convert an OS scatter gather list to a CPA buffer list*/
-int icp_ocfDrvPacketBuffToBufferList(icp_packet_buffer_t * pPacketBuffer,
-				     CpaBufferList * bufferList);
-
-/* Convert a CPA buffer list to an OS scatter gather list*/
-int icp_ocfDrvBufferListToPacketBuff(CpaBufferList * bufferList,
-				     icp_packet_buffer_t ** pPacketBuffer);
+int icp_ocfDrvSkBuffToBufferList(struct sk_buff *skb,
+				 CpaBufferList * bufferList);
 
-/* Get the number of buffers in an OS scatter gather list*/
-uint16_t icp_ocfDrvGetPacketBuffFrags(icp_packet_buffer_t * pPacketBuffer);
+int icp_ocfDrvBufferListToSkBuff(CpaBufferList * bufferList,
+				 struct sk_buff **skb);
 
-/* Convert a single OS buffer to a CPA Flat Buffer*/
-void icp_ocfDrvSinglePacketBuffToFlatBuffer(icp_packet_buffer_t * pPacketBuffer,
-					    CpaFlatBuffer * pFlatBuffer);
-
-/* Add pointer and length to a CPA Flat Buffer structure*/
 void icp_ocfDrvPtrAndLenToFlatBuffer(void *pData, uint32_t len,
 				     CpaFlatBuffer * pFlatBuffer);
 
-/* Convert pointer and length values to a CPA buffer list*/
 void icp_ocfDrvPtrAndLenToBufferList(void *pDataIn, uint32_t length,
 				     CpaBufferList * pBufferList);
 
-/* Convert a CPA buffer list to pointer and length values*/
 void icp_ocfDrvBufferListToPtrAndLen(CpaBufferList * pBufferList,
 				     void **ppDataOut, uint32_t * pLength);
 
-/* Set the number of flat buffers in bufferlist and the size of memory
-   to allocate for the pPrivateMetaData member of the CpaBufferList.*/
 int icp_ocfDrvBufferListMemInfo(uint16_t numBuffers,
 				struct icp_drvBuffListInfo *buffListInfo);
 
-/* Find pointer position of the digest within an OS scatter gather list*/
-uint8_t *icp_ocfDrvPacketBufferDigestPointerFind(struct icp_drvOpData
-						 *drvOpData,
-						 int offsetInBytes,
-						 uint32_t digestSizeInBytes);
-
-/*This top level function is used to find a pointer to where a digest is 
-  stored/needs to be inserted. */
-uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
-				     struct cryptodesc *crp_desc);
+uint16_t icp_ocfDrvGetSkBuffFrags(struct sk_buff *pSkb);
 
-/* Free a CPA flat buffer*/
 void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer);
 
-/* This function will allocate memory for the pPrivateMetaData
-   member of CpaBufferList. */
-int icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
-			    struct icp_drvOpData *pOpData);
+int icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList, 
+                const struct icp_drvOpData *pOpData);
 
-/* Free data allocated for the pPrivateMetaData
-   member of CpaBufferList.*/
 void icp_ocfDrvFreeMetaData(CpaBufferList * pBufferList);
 
-#define ICP_CACHE_CREATE(cache_ID, cache_name) \
-	icp_kmem_cache_create(cache_ID, sizeof(cache_name),ICP_KERNEL_CACHE_ALIGN,\
-	ICP_KERNEL_CACHE_NOINIT)
-
-#define ICP_CACHE_FREE(args...) \
-	icp_kmem_cache_free (args)
-
-#define ICP_CACHE_DESTROY(slab_zone)\
-{\
-        if(NULL != slab_zone){\
-                icp_kmem_cache_destroy(slab_zone);\
-                slab_zone = NULL;\
-        }\
-}
-
 #endif
-/* ICP_OCF_H_ */
+/* ICP_OCF_H */
diff --git a/crypto/ocf/ep80579/icp_sym.c b/crypto/ocf/ep80579/icp_sym.c
index e1c7148..d632970 100644
--- a/crypto/ocf/ep80579/icp_sym.c
+++ b/crypto/ocf/ep80579/icp_sym.c
@@ -5,7 +5,7 @@
  * 
  *   GPL LICENSE SUMMARY
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  * 
  *   This program is free software; you can redistribute it and/or modify 
  *   it under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,7 @@
  * 
  *   BSD LICENSE 
  * 
- *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
+ *   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
  *   All rights reserved.
  * 
  *   Redistribution and use in source and binary forms, with or without 
@@ -57,7 +57,7 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
  * 
- *  version: Security.L.1.0.2-229
+ *  version: Security.L.1.0.130
  *
  ***************************************************************************/
 /*
@@ -96,6 +96,38 @@ static int
 icp_ocfDrvAlgorithmSetup(struct cryptoini *cri,
 			 CpaCySymSessionSetupData * lacSessCtx);
 
+/*This top level function is used to find a pointer to where a digest is 
+  stored/needs to be inserted. */
+static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
+					    struct cryptodesc *crp_desc);
+
+/*This function is called when a digest pointer has to be found within a
+  SKBUFF.*/
+static inline uint8_t *icp_ocfDrvSkbuffDigestPointerFind(struct icp_drvOpData
+							 *drvOpData,
+							 int offsetInBytes,
+							 uint32_t
+							 digestSizeInBytes);
+
+/*The following two functions are called if the SKBUFF digest pointer is not 
+  positioned in the linear portion of the buffer (i.e. it is in a linked SKBUFF
+   or page fragment).*/
+/*This function takes care of the page fragment case.*/
+static inline uint8_t *icp_ocfDrvDigestSkbNRFragsCheck(struct sk_buff *skb,
+						       struct skb_shared_info
+						       *skb_shared,
+						       int offsetInBytes,
+						       uint32_t
+						       digestSizeInBytes);
+
+/*This function takes care of the linked list case.*/
+static inline uint8_t *icp_ocfDrvDigestSkbFragListCheck(struct sk_buff *skb,
+							struct skb_shared_info
+							*skb_shared,
+							int offsetInBytes,
+							uint32_t
+							digestSizeInBytes);
+
 /*This function is used to free an OCF->OCF_DRV session object*/
 static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData);
 
@@ -110,7 +142,7 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData);
  * Notes : The callbackTag is a pointer to an icp_drvOpData. This memory
  * object was passed to LAC for the cryptographic processing and contains all
  * the relevant information for cleaning up buffer handles etc. so that the
- * OCF EP80579 Driver portion of this crypto operation can be fully completed.
+ * OCF Tolapai Driver portion of this crypto operation can be fully completed.
  */
 static void
 icp_ocfDrvSymCallBack(void *callbackTag,
@@ -156,12 +188,11 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 
 	if (CPA_STATUS_SUCCESS == status) {
 
-		if (temp_drvOpData->bufferType == ICP_CRYPTO_F_PACKET_BUF) {
+		if (temp_drvOpData->bufferType == CRYPTO_F_SKBUF) {
 			if (ICP_OCF_DRV_STATUS_SUCCESS !=
-			    icp_ocfDrvBufferListToPacketBuff(pDstBuffer,
-							     (icp_packet_buffer_t
-							      **)
-							     & (crp->crp_buf))) {
+			    icp_ocfDrvBufferListToSkBuff(pDstBuffer,
+							 (struct sk_buff **)
+							 &(crp->crp_buf))) {
 				EPRINTK("%s(): BufferList to SkBuff "
 					"conversion error.\n", __FUNCTION__);
 				crp->crp_etype = EPERM;
@@ -182,10 +213,10 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 
 	if (temp_drvOpData->numBufferListArray >
 	    ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
-		icp_kfree(pDstBuffer->pBuffers);
+		kfree(pDstBuffer->pBuffers);
 	}
 	icp_ocfDrvFreeMetaData(pDstBuffer);
-	ICP_CACHE_FREE(drvOpData_zone, temp_drvOpData);
+	kmem_cache_free(drvOpData_zone, temp_drvOpData);
 
 	/* Invoke the OCF callback function */
 	crypto_done(crp);
@@ -200,8 +231,7 @@ icp_ocfDrvSymCallBack(void *callbackTag,
  * Notes : LAC session registration happens during the first perform call.
  * That is the first time we know all information about a given session.
  */
-int icp_ocfDrvNewSession(icp_device_t dev, uint32_t * sid,
-			 struct cryptoini *cri)
+int icp_ocfDrvNewSession(device_t dev, uint32_t * sid, struct cryptoini *cri)
 {
 	struct icp_drvSessionData *sessionData = NULL;
 	uint32_t delete_session = 0;
@@ -228,44 +258,44 @@ int icp_ocfDrvNewSession(icp_device_t dev, uint32_t * sid,
 		return EINVAL;
 	}
 
-	sessionData = icp_kmem_cache_zalloc(drvSessionData_zone, ICP_M_NOWAIT);
+	sessionData = kmem_cache_zalloc(drvSessionData_zone, GFP_ATOMIC);
 	if (NULL == sessionData) {
 		DPRINTK("%s():No memory for Session Data\n", __FUNCTION__);
 		return ENOMEM;
 	}
 
 	/*ENTER CRITICAL SECTION */
-	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
+	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 	/*put this check in the spinlock so no new sessions can be added to the
 	   linked list when we are exiting */
-	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
 		delete_session++;
 
 	} else if (NO_OCF_TO_DRV_MAX_SESSIONS != max_sessions) {
-		if (icp_atomic_read(&num_ocf_to_drv_registered_sessions) >=
+		if (atomic_read(&num_ocf_to_drv_registered_sessions) >=
 		    (max_sessions -
-		     icp_atomic_read(&lac_session_failed_dereg_count))) {
+		     atomic_read(&lac_session_failed_dereg_count))) {
 			delete_session++;
 		} else {
-			icp_atomic_inc(&num_ocf_to_drv_registered_sessions);
+			atomic_inc(&num_ocf_to_drv_registered_sessions);
 			/* Add to session data linked list */
-			ICP_LIST_ADD(sessionData, &icp_ocfDrvGlobalSymListHead,
-				     listNode);
+			list_add(&(sessionData->listNode),
+				 &icp_ocfDrvGlobalSymListHead);
 		}
 
 	} else if (NO_OCF_TO_DRV_MAX_SESSIONS == max_sessions) {
-		ICP_LIST_ADD(sessionData, &icp_ocfDrvGlobalSymListHead,
-			     listNode);
+		list_add(&(sessionData->listNode),
+			 &icp_ocfDrvGlobalSymListHead);
 	}
 
 	sessionData->inUse = ICP_SESSION_INITIALISED;
 
 	/*EXIT CRITICAL SECTION */
-	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
+	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	if (delete_session) {
 		DPRINTK("%s():No Session handles available\n", __FUNCTION__);
-		ICP_CACHE_FREE(drvSessionData_zone, sessionData);
+		kmem_cache_free(drvSessionData_zone, sessionData);
 		return EPERM;
 	}
 
@@ -530,27 +560,27 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData)
 	sessionData->inUse = ICP_SESSION_DEREGISTERED;
 
 	/*ENTER CRITICAL SECTION */
-	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
+	spin_lock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 
-	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
 		/*If the Driver is exiting, allow that process to
 		   handle any deletions */
 		/*EXIT CRITICAL SECTION */
-		icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
+		spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 		return;
 	}
 
-	icp_atomic_dec(&num_ocf_to_drv_registered_sessions);
+	atomic_dec(&num_ocf_to_drv_registered_sessions);
 
-	ICP_LIST_DEL(sessionData, listNode);
+	list_del(&(sessionData->listNode));
 
 	/*EXIT CRITICAL SECTION */
-	icp_spin_lockbh_unlock(&icp_ocfDrvSymSessInfoListSpinlock);
+	spin_unlock_bh(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	if (NULL != sessionData->sessHandle) {
-		icp_kfree(sessionData->sessHandle);
+		kfree(sessionData->sessHandle);
 	}
-	ICP_CACHE_FREE(drvSessionData_zone, sessionData);
+	kmem_cache_free(drvSessionData_zone, sessionData);
 }
 
 /* Name        : icp_ocfDrvFreeLACSession
@@ -558,7 +588,7 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData)
  * Description : This attempts to deregister a LAC session. If it fails, the
  * deregistation retry function is called.
  */
-int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
+int icp_ocfDrvFreeLACSession(device_t dev, uint64_t sid)
 {
 	CpaCySymSessionCtx sessionToDeregister = NULL;
 	struct icp_drvSessionData *sessionData = NULL;
@@ -574,14 +604,14 @@ int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
 
 	sessionToDeregister = sessionData->sessHandle;
 
-	if ((ICP_SESSION_INITIALISED != sessionData->inUse) &&
-	    (ICP_SESSION_RUNNING != sessionData->inUse) &&
-	    (ICP_SESSION_DEREGISTERED != sessionData->inUse)) {
-		DPRINTK("%s() Session not initialised.\n", __FUNCTION__);
+	if (ICP_SESSION_INITIALISED == sessionData->inUse) {
+		DPRINTK("%s() Session not registered with LAC\n", __FUNCTION__);
+	} else if (NULL == sessionData->sessHandle) {
+		EPRINTK
+		    ("%s(): OCF Free session called with Null Session Handle.\n",
+		     __FUNCTION__);
 		return EINVAL;
-	}
-
-	if (ICP_SESSION_RUNNING == sessionData->inUse) {
+	} else {
 		lacStatus = cpaCySymRemoveSession(CPA_INSTANCE_HANDLE_SINGLE,
 						  sessionToDeregister);
 		if (CPA_STATUS_RETRY == lacStatus) {
@@ -599,12 +629,9 @@ int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
 			DPRINTK("%s(): LAC failed to deregister the session. "
 				"localSessionId= %p, lacStatus = %d\n",
 				__FUNCTION__, sessionToDeregister, lacStatus);
-			icp_atomic_inc(&lac_session_failed_dereg_count);
+			atomic_inc(&lac_session_failed_dereg_count);
 			retval = EPERM;
 		}
-	} else {
-		DPRINTK("%s() Session not registered with LAC.\n",
-			__FUNCTION__);
 	}
 
 	icp_ocfDrvFreeOCFSession(sessionData);
@@ -641,12 +668,13 @@ static int icp_ocfDrvAlgCheck(struct cryptodesc *crp_desc)
  * to whether session paramaters have changed (e.g. alg chain order) are
  * done.
  */
-int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
+int icp_ocfDrvSymProcess(device_t dev, struct cryptop *crp, int hint)
 {
 	struct icp_drvSessionData *sessionData = NULL;
 	struct icp_drvOpData *drvOpData = NULL;
 	CpaStatus lacStatus = CPA_STATUS_SUCCESS;
 	Cpa32U sessionCtxSizeInBytes = 0;
+	uint16_t numBufferListArray = 0;
 
 	if (NULL == crp) {
 		DPRINTK("%s(): Invalid input parameters, cryptop is NULL\n",
@@ -668,7 +696,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		return EINVAL;
 	}
 
-	if (CPA_TRUE == icp_atomic_read(&icp_ocfDrvIsExiting)) {
+	if (CPA_TRUE == atomic_read(&icp_ocfDrvIsExiting)) {
 		crp->crp_etype = EFAULT;
 		return EFAULT;
 	}
@@ -765,16 +793,14 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		if (CPA_STATUS_SUCCESS != lacStatus) {
 			EPRINTK("%s(): cpaCySymSessionCtxGetSize failed - %d\n",
 				__FUNCTION__, lacStatus);
-			crp->crp_etype = EINVAL;
 			return EINVAL;
 		}
 		sessionData->sessHandle =
-		    icp_kmalloc(sessionCtxSizeInBytes, ICP_M_NOWAIT);
+		    kmalloc(sessionCtxSizeInBytes, GFP_ATOMIC);
 		if (NULL == sessionData->sessHandle) {
 			EPRINTK
 			    ("%s(): Failed to get memory for SymSessionCtx\n",
 			     __FUNCTION__);
-			crp->crp_etype = ENOMEM;
 			return ENOMEM;
 		}
 
@@ -786,14 +812,13 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		if (CPA_STATUS_SUCCESS != lacStatus) {
 			EPRINTK("%s(): cpaCySymInitSession failed -%d \n",
 				__FUNCTION__, lacStatus);
-			crp->crp_etype = EFAULT;
 			return EFAULT;
 		}
 
 		sessionData->inUse = ICP_SESSION_RUNNING;
 	}
 
-	drvOpData = icp_kmem_cache_zalloc(drvOpData_zone, ICP_M_NOWAIT);
+	drvOpData = kmem_cache_zalloc(drvOpData_zone, GFP_ATOMIC);
 	if (NULL == drvOpData) {
 		EPRINTK("%s():Failed to get memory for drvOpData\n",
 			__FUNCTION__);
@@ -810,48 +835,28 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 	drvOpData->srcBuffer.pBuffers = drvOpData->bufferListArray;
 	drvOpData->numBufferListArray = ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS;
 
-	if (ICP_OCF_DRV_STATUS_SUCCESS !=
-	    icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->crp_desc)) {
-		crp->crp_etype = EINVAL;
-		goto err;
-	}
-
-	if (drvOpData->crp->crp_desc->crd_next != NULL) {
-		if (icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->
-					       crp_desc->crd_next)) {
-			crp->crp_etype = EINVAL;
-			goto err;
-		}
-
-	}
-
 	/* 
-	 * Allocate buffer list array memory if the data fragment is more than
-	 * the default number (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) and not 
-	 * calculated already
+	 * Allocate buffer list array memory allocation if the
+	 * data fragment is more than the default allocation
 	 */
-	if (crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
-		if (NULL == drvOpData->lacOpData.pDigestResult) {
-			drvOpData->numBufferListArray =
-			    icp_ocfDrvGetPacketBuffFrags((icp_packet_buffer_t *)
-							 crp->crp_buf);
-		}
-
-		if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS <
-		    drvOpData->numBufferListArray) {
+	if (crp->crp_flags & CRYPTO_F_SKBUF) {
+		numBufferListArray = icp_ocfDrvGetSkBuffFrags((struct sk_buff *)
+							      crp->crp_buf);
+		if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < numBufferListArray) {
 			DPRINTK("%s() numBufferListArray more than default\n",
 				__FUNCTION__);
 			drvOpData->srcBuffer.pBuffers = NULL;
 			drvOpData->srcBuffer.pBuffers =
-			    icp_kmalloc(drvOpData->numBufferListArray *
-					sizeof(CpaFlatBuffer), ICP_M_NOWAIT);
+			    kmalloc(numBufferListArray *
+				    sizeof(CpaFlatBuffer), GFP_ATOMIC);
 			if (NULL == drvOpData->srcBuffer.pBuffers) {
 				EPRINTK("%s() Failed to get memory for "
 					"pBuffers\n", __FUNCTION__);
-				ICP_CACHE_FREE(drvOpData_zone, drvOpData);
+				kmem_cache_free(drvOpData_zone, drvOpData);
 				crp->crp_etype = ENOMEM;
 				return ENOMEM;
 			}
+			drvOpData->numBufferListArray = numBufferListArray;
 		}
 	}
 
@@ -859,18 +864,17 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 	 * Check the type of buffer structure we got and convert it into
 	 * CpaBufferList format.
 	 */
-	if (crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
+	if (crp->crp_flags & CRYPTO_F_SKBUF) {
 		if (ICP_OCF_DRV_STATUS_SUCCESS !=
-		    icp_ocfDrvPacketBuffToBufferList((icp_packet_buffer_t *)
-						     crp->crp_buf,
-						     &(drvOpData->srcBuffer))) {
-			EPRINTK("%s():Failed to translate from packet buffer "
+		    icp_ocfDrvSkBuffToBufferList((struct sk_buff *)crp->crp_buf,
+						 &(drvOpData->srcBuffer))) {
+			EPRINTK("%s():Failed to translate from SK_BUF "
 				"to bufferlist\n", __FUNCTION__);
 			crp->crp_etype = EINVAL;
 			goto err;
 		}
 
-		drvOpData->bufferType = ICP_CRYPTO_F_PACKET_BUF;
+		drvOpData->bufferType = CRYPTO_F_SKBUF;
 	} else if (crp->crp_flags & CRYPTO_F_IOV) {
 		/* OCF only supports IOV of one entry. */
 		if (NUM_IOV_SUPPORTED ==
@@ -902,6 +906,21 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		drvOpData->bufferType = CRYPTO_BUF_CONTIG;
 	}
 
+	if (ICP_OCF_DRV_STATUS_SUCCESS !=
+	    icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->crp_desc)) {
+		crp->crp_etype = EINVAL;
+		goto err;
+	}
+
+	if (drvOpData->crp->crp_desc->crd_next != NULL) {
+		if (icp_ocfDrvProcessDataSetup(drvOpData, drvOpData->crp->
+					       crp_desc->crd_next)) {
+			crp->crp_etype = EINVAL;
+			goto err;
+		}
+
+	}
+
 	/* Allocate srcBuffer's private meta data */
 	if (ICP_OCF_DRV_STATUS_SUCCESS !=
 	    icp_ocfDrvAllocMetaData(&(drvOpData->srcBuffer), drvOpData)) {
@@ -922,7 +941,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		DPRINTK("%s(): cpaCySymPerformOp retry, lacStatus = %d\n",
 			__FUNCTION__, lacStatus);
 		memset(&(drvOpData->lacOpData), 0, sizeof(CpaCySymOpData));
-		crp->crp_etype = ERESTART;
+		crp->crp_etype = EINVAL;
 		goto err;
 	}
 	if (CPA_STATUS_SUCCESS != lacStatus) {
@@ -937,10 +956,10 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 
       err:
 	if (drvOpData->numBufferListArray > ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
-		icp_kfree(drvOpData->srcBuffer.pBuffers);
+		kfree(drvOpData->srcBuffer.pBuffers);
 	}
 	icp_ocfDrvFreeMetaData(&(drvOpData->srcBuffer));
-	ICP_CACHE_FREE(drvOpData_zone, drvOpData);
+	kmem_cache_free(drvOpData_zone, drvOpData);
 
 	return crp->crp_etype;
 }
@@ -1110,20 +1129,32 @@ static int icp_ocfDrvProcessDataSetup(struct icp_drvOpData *drvOpData,
  * must be traversed by the data length offset in order to find the digest start
  * address. Whether there is enough space for the digest must also be checked.
  */
-uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData * drvOpData,
-				     struct cryptodesc * crp_desc)
+
+static uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData *drvOpData,
+					    struct cryptodesc *crp_desc)
 {
 
 	int offsetInBytes = crp_desc->crd_inject;
 	uint32_t digestSizeInBytes = drvOpData->digestSizeInBytes;
 	uint8_t *flat_buffer_base = NULL;
 	int flat_buffer_length = 0;
+	struct sk_buff *skb;
 
-	if (drvOpData->crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
+	if (drvOpData->crp->crp_flags & CRYPTO_F_SKBUF) {
+		/*check if enough overall space to store hash */
+		skb = (struct sk_buff *)(drvOpData->crp->crp_buf);
+
+		if (skb->len < (offsetInBytes + digestSizeInBytes)) {
+			DPRINTK("%s() Not enough space for Digest"
+				" payload after the offset (%d), "
+				"digest size (%d) \n", __FUNCTION__,
+				offsetInBytes, digestSizeInBytes);
+			return NULL;
+		}
 
-		return icp_ocfDrvPacketBufferDigestPointerFind(drvOpData,
-							       offsetInBytes,
-							       digestSizeInBytes);
+		return icp_ocfDrvSkbuffDigestPointerFind(drvOpData,
+							 offsetInBytes,
+							 digestSizeInBytes);
 
 	} else {
 		/* IOV or flat buffer */
@@ -1151,3 +1182,201 @@ uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData * drvOpData,
 	DPRINTK("%s() Should not reach this point\n", __FUNCTION__);
 	return NULL;
 }
+
+/* Name        : icp_ocfDrvSkbuffDigestPointerFind
+ *
+ * Description : This function is used by icp_ocfDrvDigestPointerFind to process
+ * the non-linear portion of the skbuff if the fragmentation type is a linked
+ * list (frag_list is not NULL in the skb_shared_info structure)
+ */
+static inline uint8_t *icp_ocfDrvSkbuffDigestPointerFind(struct icp_drvOpData
+							 *drvOpData,
+							 int offsetInBytes,
+							 uint32_t
+							 digestSizeInBytes)
+{
+
+	struct sk_buff *skb = NULL;
+	struct skb_shared_info *skb_shared = NULL;
+
+	uint32_t skbuffisnonlinear = 0;
+
+	uint32_t skbheadlen = 0;
+
+	skb = (struct sk_buff *)(drvOpData->crp->crp_buf);
+	skbuffisnonlinear = skb_is_nonlinear(skb);
+
+	skbheadlen = skb_headlen(skb);
+
+	/*Linear skb checks */
+	if (skbheadlen > offsetInBytes) {
+
+		if (skbheadlen >= (offsetInBytes + digestSizeInBytes)) {
+			return (uint8_t *) (skb->data + offsetInBytes);
+		} else {
+			DPRINTK("%s() Auth payload stretches "
+				"accross contiguous memory\n", __FUNCTION__);
+			return NULL;
+		}
+	} else {
+		if (skbuffisnonlinear) {
+			offsetInBytes -= skbheadlen;
+		} else {
+			DPRINTK("%s() Offset outside of buffer boundaries\n",
+				__FUNCTION__);
+			return NULL;
+		}
+	}
+
+	/*Non Linear checks */
+	skb_shared = (struct skb_shared_info *)(skb->end);
+	if (unlikely(NULL == skb_shared)) {
+		DPRINTK("%s() skbuff shared info stucture is NULL! \n",
+			__FUNCTION__);
+		return NULL;
+	} else if ((0 != skb_shared->nr_frags) &&
+		   (skb_shared->frag_list != NULL)) {
+		DPRINTK("%s() skbuff nr_frags AND "
+			"frag_list not supported \n", __FUNCTION__);
+		return NULL;
+	}
+
+	/*TCP segmentation more likely than IP fragmentation */
+	if (likely(0 != skb_shared->nr_frags)) {
+		return icp_ocfDrvDigestSkbNRFragsCheck(skb, skb_shared,
+						       offsetInBytes,
+						       digestSizeInBytes);
+	} else if (skb_shared->frag_list != NULL) {
+		return icp_ocfDrvDigestSkbFragListCheck(skb, skb_shared,
+							offsetInBytes,
+							digestSizeInBytes);
+	} else {
+		DPRINTK("%s() skbuff is non-linear but does not show any "
+			"linked data\n", __FUNCTION__);
+		return NULL;
+	}
+
+}
+
+/* Name        : icp_ocfDrvDigestSkbNRFragsCheck
+ *
+ * Description : This function is used by icp_ocfDrvSkbuffDigestPointerFind to
+ * process the non-linear portion of the skbuff, if the fragmentation type is
+ * page fragments
+ */
+static inline uint8_t *icp_ocfDrvDigestSkbNRFragsCheck(struct sk_buff *skb,
+						       struct skb_shared_info
+						       *skb_shared,
+						       int offsetInBytes,
+						       uint32_t
+						       digestSizeInBytes)
+{
+	int i = 0;
+	/*nr_frags starts from 1 */
+	if (MAX_SKB_FRAGS < skb_shared->nr_frags) {
+		DPRINTK("%s error processing skbuff "
+			"page frame -- MAX FRAGS exceeded \n", __FUNCTION__);
+		return NULL;
+	}
+
+	for (i = 0; i < skb_shared->nr_frags; i++) {
+
+		if (offsetInBytes >= skb_shared->frags[i].size) {
+			/*offset still greater than data position */
+			offsetInBytes -= skb_shared->frags[i].size;
+		} else {
+			/* found the page containing start of hash */
+
+			if (NULL == skb_shared->frags[i].page) {
+				DPRINTK("%s() Linked page is NULL!\n",
+					__FUNCTION__);
+				return NULL;
+			}
+
+			if (offsetInBytes + digestSizeInBytes >
+			    skb_shared->frags[i].size) {
+				DPRINTK("%s() Auth payload stretches accross "
+					"contiguous memory\n", __FUNCTION__);
+				return NULL;
+			} else {
+				return (uint8_t *) (skb_shared->frags[i].page +
+						    skb_shared->frags[i].
+						    page_offset +
+						    offsetInBytes);
+			}
+		}
+		/*only possible if internal page sizes are set wrong */
+		if (offsetInBytes < 0) {
+			DPRINTK("%s error processing skbuff page frame "
+				"-- offset calculation \n", __FUNCTION__);
+			return NULL;
+		}
+	}
+	/*only possible if internal page sizes are set wrong */
+	DPRINTK("%s error processing skbuff page frame "
+		"-- ran out of page fragments, remaining offset = %d \n",
+		__FUNCTION__, offsetInBytes);
+	return NULL;
+
+}
+
+/* Name        : icp_ocfDrvDigestSkbFragListCheck
+ *
+ * Description : This function is used by icp_ocfDrvSkbuffDigestPointerFind to 
+ * process the non-linear portion of the skbuff, if the fragmentation type is 
+ * a linked list
+ * 
+ */
+static inline uint8_t *icp_ocfDrvDigestSkbFragListCheck(struct sk_buff *skb,
+							struct skb_shared_info
+							*skb_shared,
+							int offsetInBytes,
+							uint32_t
+							digestSizeInBytes)
+{
+
+	struct sk_buff *skb_list = skb_shared->frag_list;
+	/*check added for readability */
+	if (NULL == skb_list) {
+		DPRINTK("%s error processing skbuff "
+			"-- no more list! \n", __FUNCTION__);
+		return NULL;
+	}
+
+	for (; skb_list; skb_list = skb_list->next) {
+		if (NULL == skb_list) {
+			DPRINTK("%s error processing skbuff "
+				"-- no more list! \n", __FUNCTION__);
+			return NULL;
+		}
+
+		if (offsetInBytes >= skb_list->len) {
+			offsetInBytes -= skb_list->len;
+
+		} else {
+			if (offsetInBytes + digestSizeInBytes > skb_list->len) {
+				DPRINTK("%s() Auth payload stretches accross "
+					"contiguous memory\n", __FUNCTION__);
+				return NULL;
+			} else {
+				return (uint8_t *)
+				    (skb_list->data + offsetInBytes);
+			}
+
+		}
+
+		/*This check is only needed if internal skb_list length values
+		   are set wrong. */
+		if (0 > offsetInBytes) {
+			DPRINTK("%s() error processing skbuff object -- offset "
+				"calculation \n", __FUNCTION__);
+			return NULL;
+		}
+
+	}
+
+	/*catch all for unusual for-loop exit. 
+	   This code should never be reached */
+	DPRINTK("%s() Catch-All hit! Process error.\n", __FUNCTION__);
+	return NULL;
+}
diff --git a/crypto/ocf/ep80579/linux_2.6_kernel_space.mk b/crypto/ocf/ep80579/linux_2.6_kernel_space.mk
new file mode 100644
index 0000000..96afa9a
--- /dev/null
+++ b/crypto/ocf/ep80579/linux_2.6_kernel_space.mk
@@ -0,0 +1,69 @@
+###################
+# @par
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#  version: Security.L.1.0.130
+###################
+
+#specific include directories in kernel space
+INCLUDES+=#e.g. -I$(OSAL_DIR)/include \
+
+#Extra Flags Specific in kernel space e.g. include path or debug flags etc. e.g to add an include path EXTRA_CFLAGS += -I$(src)/../include
+EXTRA_CFLAGS += $(INCLUDES) -O2 -Wall
+EXTRA_LDFLAGS +=-whole-archive
+
diff --git a/crypto/ocf/hifn/hifn7751.c b/crypto/ocf/hifn/hifn7751.c
index d554f16..6459f35 100644
--- a/crypto/ocf/hifn/hifn7751.c
+++ b/crypto/ocf/hifn/hifn7751.c
@@ -46,8 +46,7 @@ __FBSDID("$FreeBSD: src/sys/dev/hifn/hifn7751.c,v 1.40 2007/03/21 03:42:49 sam E
 /*
  * Driver for various Hifn encryption processors.
  */
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -61,6 +60,7 @@ __FBSDID("$FreeBSD: src/sys/dev/hifn/hifn7751.c,v 1.40 2007/03/21 03:42:49 sam E
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
+#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <asm/io.h>
 
@@ -98,10 +98,6 @@ int hifn_maxbatch = 1;
 module_param(hifn_maxbatch, int, 0644);
 MODULE_PARM_DESC(hifn_maxbatch, "max ops to batch w/o interrupt");
 
-int hifn_cache_linesize = 0x10;
-module_param(hifn_cache_linesize, int, 0444);
-MODULE_PARM_DESC(hifn_cache_linesize, "PCI config cache line size");
-
 #ifdef MODULE_PARM
 char *hifn_pllconfig = NULL;
 MODULE_PARM(hifn_pllconfig, "s");
@@ -241,7 +237,7 @@ pci_map_skb(struct hifn_softc *sc,struct hifn_operand *buf,struct sk_buff *skb)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; ) {
 		buf->segs[buf->nsegs].ds_len = skb_shinfo(skb)->frags[i].size;
 		buf->segs[buf->nsegs].ds_addr = pci_map_single(sc->sc_pcidev,
-				page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
+				page_address(skb_shinfo(skb)->frags[i].page) +
 					skb_shinfo(skb)->frags[i].page_offset,
 				buf->segs[buf->nsegs].ds_len, PCI_DMA_BIDIRECTIONAL);
 		buf->mapsize += buf->segs[buf->nsegs].ds_len;
@@ -868,9 +864,7 @@ hifn_set_retry(struct hifn_softc *sc)
 	DPRINTF("%s()\n", __FUNCTION__);
 	/* NB: RETRY only responds to 8-bit reads/writes */
 	pci_write_config_byte(sc->sc_pcidev, HIFN_RETRY_TIMEOUT, 0);
-	pci_write_config_byte(sc->sc_pcidev, HIFN_TRDY_TIMEOUT, 0);
-	/* piggy back the cache line setting here */
-	pci_write_config_byte(sc->sc_pcidev, PCI_CACHE_LINE_SIZE, hifn_cache_linesize);
+	pci_write_config_dword(sc->sc_pcidev, HIFN_TRDY_TIMEOUT, 0);
 }
 
 /*
@@ -2375,6 +2369,11 @@ hifn_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 		case CRYPTO_DES_CBC:
 		case CRYPTO_3DES_CBC:
 		case CRYPTO_AES_CBC:
+			/* XXX this may read fewer, does it matter? */
+			read_random(ses->hs_iv,
+				c->cri_alg == CRYPTO_AES_CBC ?
+					HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
+			/*FALLTHROUGH*/
 		case CRYPTO_ARC4:
 			if (cry) {
 				DPRINTF("%s,%d: %s - EINVAL\n",__FILE__,__LINE__,__FUNCTION__);
@@ -2570,7 +2569,8 @@ hifn_process(device_t dev, struct cryptop *crp, int hint)
 				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
 				else
-					read_random(cmd->iv, ivlen);
+					bcopy(sc->sc_sessions[session].hs_iv,
+					    cmd->iv, ivlen);
 
 				if ((enccrd->crd_flags & CRD_F_IV_PRESENT)
 				    == 0) {
@@ -2775,7 +2775,7 @@ hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd, u_int8_t *macbuf)
 	struct hifn_dma *dma = sc->sc_dma;
 	struct cryptop *crp = cmd->crp;
 	struct cryptodesc *crd;
-	int i, u;
+	int i, u, ivlen;
 
 	DPRINTF("%s()\n", __FUNCTION__);
 
@@ -2840,6 +2840,22 @@ hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd, u_int8_t *macbuf)
 
 	hifnstats.hst_obytes += cmd->dst_mapsize;
 
+	if ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==
+	    HIFN_BASE_CMD_CRYPT) {
+		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
+			if (crd->crd_alg != CRYPTO_DES_CBC &&
+			    crd->crd_alg != CRYPTO_3DES_CBC &&
+			    crd->crd_alg != CRYPTO_AES_CBC)
+				continue;
+			ivlen = ((crd->crd_alg == CRYPTO_AES_CBC) ?
+				HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
+			crypto_copydata(crp->crp_flags, crp->crp_buf,
+			    crd->crd_skip + crd->crd_len - ivlen, ivlen,
+			    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
+			break;
+		}
+	}
+
 	if (macbuf != NULL) {
 		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
                         int len;
@@ -2950,5 +2966,5 @@ module_init(hifn_init);
 module_exit(hifn_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("OCF driver for hifn PCI crypto devices");
diff --git a/crypto/ocf/hifn/hifn7751var.h b/crypto/ocf/hifn/hifn7751var.h
index c5d30f9..9a5f231 100644
--- a/crypto/ocf/hifn/hifn7751var.h
+++ b/crypto/ocf/hifn/hifn7751var.h
@@ -113,6 +113,7 @@ struct hifn_dma {
 struct hifn_session {
 	int hs_used;
 	int hs_mlen;
+	u_int8_t hs_iv[HIFN_MAX_IV_LENGTH];
 };
 
 #define	HIFN_RING_SYNC(sc, r, i, f)					\
diff --git a/crypto/ocf/hifn/hifnHIPP.c b/crypto/ocf/hifn/hifnHIPP.c
index 4d6950a..45ad7ba 100644
--- a/crypto/ocf/hifn/hifnHIPP.c
+++ b/crypto/ocf/hifn/hifnHIPP.c
@@ -32,8 +32,7 @@
 /*
  * Driver for various Hifn encryption processors.
  */
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -47,6 +46,7 @@
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
+#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <linux/uio.h>
 #include <linux/sysfs.h>
diff --git a/crypto/ocf/ixp4xx/ixp4xx.c b/crypto/ocf/ixp4xx/ixp4xx.c
index ede598f..fba31b0 100644
--- a/crypto/ocf/ixp4xx/ixp4xx.c
+++ b/crypto/ocf/ixp4xx/ixp4xx.c
@@ -3,8 +3,8 @@
  * This driver requires the IXP400 Access Library that is available
  * from Intel in order to operate (or compile).
  *
- * Written by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2011 David McCullough
+ * Written by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -33,8 +33,7 @@
  * and/or fitness for purpose.
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -374,6 +373,9 @@ ixp_freesession(device_t dev, u_int64_t tid)
 			ixCryptoAccCtxUnregister(ixp_sessions[sid]->ixp_ctx_id);
 			ixp_sessions[sid]->ixp_ctx_id = -1;
 		}
+
+		flush_scheduled_work();
+
 		kfree(ixp_sessions[sid]);
 	}
 	ixp_sessions[sid] = NULL;
@@ -446,28 +448,14 @@ ixp_q_process(struct ixp_q *q)
 	dprintk("%s(%p)\n", __FUNCTION__, q);
 
 	if (q->ixp_q_ccrd) {
-		if (q->ixp_q_ccrd->crd_flags & CRD_F_ENCRYPT) {
-			if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT) {
-				q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
-			} else {
-				q->ixp_q_iv = q->ixp_q_iv_data;
-				read_random(q->ixp_q_iv, ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen);
-			}
-			if ((q->ixp_q_ccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
-				crypto_copyback(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
-						q->ixp_q_ccrd->crd_inject,
-						ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
-						(caddr_t) q->ixp_q_iv);
+		if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT) {
+			q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
 		} else {
-			if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT)
-				q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
-			else {
-				q->ixp_q_iv = q->ixp_q_iv_data;
-				crypto_copydata(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
-						q->ixp_q_ccrd->crd_inject,
-						ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
-						(caddr_t) q->ixp_q_iv);
-			}
+			q->ixp_q_iv = q->ixp_q_iv_data;
+			crypto_copydata(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
+					q->ixp_q_ccrd->crd_inject,
+					ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
+					(caddr_t) q->ixp_q_iv);
 		}
 
 		if (q->ixp_q_acrd) {
@@ -607,7 +595,8 @@ ixp_process_pending(void *arg)
 static void
 ixp_process_pending_wq(struct work_struct *work)
 {
-	struct ixp_data *ixp = container_of(work, struct ixp_data, ixp_pending_work);
+	struct ixp_data *ixp = container_of(work, struct ixp_data,
+								ixp_pending_work);
 	ixp_process_pending(ixp);
 }
 #endif
diff --git a/crypto/ocf/ocf-bench.c b/crypto/ocf/ocf-bench.c
index f3fe9d0..5eef6b1 100644
--- a/crypto/ocf/ocf-bench.c
+++ b/crypto/ocf/ocf-bench.c
@@ -1,7 +1,7 @@
 /*
  * A loadable module that benchmarks the OCF crypto speed from kernel space.
  *
- * Copyright (C) 2004-2010 David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com>
  *
  * LICENSE TERMS
  *
@@ -30,8 +30,7 @@
  */
 
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -41,6 +40,7 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
+#include <linux/version.h>
 #include <linux/interrupt.h>
 #include <cryptodev.h>
 
@@ -67,39 +67,23 @@
 /*
  * the number of simultaneously active requests
  */
-static int request_q_len = 40;
+static int request_q_len = 20;
 module_param(request_q_len, int, 0);
 MODULE_PARM_DESC(request_q_len, "Number of outstanding requests");
-
 /*
  * how many requests we want to have processed
  */
 static int request_num = 1024;
 module_param(request_num, int, 0);
 MODULE_PARM_DESC(request_num, "run for at least this many requests");
-
 /*
  * the size of each request
  */
-static int request_size = 1488;
+static int request_size = 1500;
 module_param(request_size, int, 0);
 MODULE_PARM_DESC(request_size, "size of each request");
 
 /*
- * OCF batching of requests
- */
-static int request_batch = 1;
-module_param(request_batch, int, 0);
-MODULE_PARM_DESC(request_batch, "enable OCF request batching");
-
-/*
- * OCF immediate callback on completion
- */
-static int request_cbimm = 1;
-module_param(request_cbimm, int, 0);
-MODULE_PARM_DESC(request_cbimm, "enable OCF immediate callback on completion");
-
-/*
  * a structure for each request
  */
 typedef struct  {
@@ -112,7 +96,6 @@ typedef struct  {
 
 static request_t *requests;
 
-static spinlock_t ocfbench_counter_lock;
 static int outstanding;
 static int total;
 
@@ -122,8 +105,6 @@ static int total;
  */
 
 static uint64_t ocf_cryptoid;
-static unsigned long jstart, jstop;
-
 static int ocf_init(void);
 static int ocf_cb(struct cryptop *crp);
 static void ocf_request(void *arg);
@@ -147,15 +128,13 @@ ocf_init(void)
 	cria.cri_klen = 20 * 8;
 	cria.cri_key  = "0123456789abcdefghij";
 
-	//crie.cri_alg  = CRYPTO_3DES_CBC;
-	crie.cri_alg  = CRYPTO_AES_CBC;
+	crie.cri_alg  = CRYPTO_3DES_CBC;
 	crie.cri_klen = 24 * 8;
 	crie.cri_key  = "0123456789abcdefghijklmn";
 
 	crie.cri_next = &cria;
 
-	error = crypto_newsession(&ocf_cryptoid, &crie,
-				CRYPTOCAP_F_HARDWARE | CRYPTOCAP_F_SOFTWARE);
+	error = crypto_newsession(&ocf_cryptoid, &crie, 0);
 	if (error) {
 		printk("crypto_newsession failed %d\n", error);
 		return -1;
@@ -167,23 +146,23 @@ static int
 ocf_cb(struct cryptop *crp)
 {
 	request_t *r = (request_t *) crp->crp_opaque;
-	unsigned long flags;
 
 	if (crp->crp_etype)
 		printk("Error in OCF processing: %d\n", crp->crp_etype);
+	total++;
 	crypto_freereq(crp);
 	crp = NULL;
 
-	/* do all requests  but take at least 1 second */
-	spin_lock_irqsave(&ocfbench_counter_lock, flags);
-	total++;
-	if (total > request_num && jstart + HZ < jiffies) {
+	if (total > request_num) {
 		outstanding--;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return 0;
 	}
-	spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	INIT_WORK(&r->work, ocf_request_wq);
+#else
+	INIT_WORK(&r->work, ocf_request, r);
+#endif
 	schedule_work(&r->work);
 	return 0;
 }
@@ -195,12 +174,9 @@ ocf_request(void *arg)
 	request_t *r = arg;
 	struct cryptop *crp = crypto_getreq(2);
 	struct cryptodesc *crde, *crda;
-	unsigned long flags;
 
 	if (!crp) {
-		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding--;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 
@@ -219,17 +195,12 @@ ocf_request(void *arg)
 	crde->crd_flags = CRD_F_IV_EXPLICIT | CRD_F_ENCRYPT;
 	crde->crd_len = request_size;
 	crde->crd_inject = request_size;
-	//crde->crd_alg = CRYPTO_3DES_CBC;
-	crde->crd_alg = CRYPTO_AES_CBC;
+	crde->crd_alg = CRYPTO_3DES_CBC;
 	crde->crd_key = "0123456789abcdefghijklmn";
 	crde->crd_klen = 24 * 8;
 
 	crp->crp_ilen = request_size + 64;
-	crp->crp_flags = 0;
-	if (request_batch)
-		crp->crp_flags |= CRYPTO_F_BATCH;
-	if (request_cbimm)
-		crp->crp_flags |= CRYPTO_F_CBIMM;
+	crp->crp_flags = CRYPTO_F_CBIMM;
 	crp->crp_buf = (caddr_t) r->buffer;
 	crp->crp_callback = ocf_cb;
 	crp->crp_sid = ocf_cryptoid;
@@ -246,12 +217,6 @@ ocf_request_wq(struct work_struct *work)
 }
 #endif
 
-static void
-ocf_done(void)
-{
-	crypto_freesession(ocf_cryptoid);
-}
-
 /*************************************************************************/
 #ifdef BENCH_IXP_ACCESS_LIB
 /*************************************************************************/
@@ -338,25 +303,24 @@ ixp_perform_cb(
 	IxCryptoAccStatus status)
 {
 	request_t *r = NULL;
-	unsigned long flags;
 
-	/* do all requests  but take at least 1 second */
-	spin_lock_irqsave(&ocfbench_counter_lock, flags);
 	total++;
-	if (total > request_num && jstart + HZ < jiffies) {
+	if (total > request_num) {
 		outstanding--;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 
 	if (!sbufp || !(r = IX_MBUF_PRIV(sbufp))) {
 		printk("crappo %p %p\n", sbufp, r);
 		outstanding--;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
-	spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	INIT_WORK(&r->work, ixp_request_wq);
+#else
+	INIT_WORK(&r->work, ixp_request, r);
+#endif
 	schedule_work(&r->work);
 }
 
@@ -365,7 +329,6 @@ ixp_request(void *arg)
 {
 	request_t *r = arg;
 	IxCryptoAccStatus status;
-	unsigned long flags;
 
 	memset(&r->mbuf, 0, sizeof(r->mbuf));
 	IX_MBUF_MLEN(&r->mbuf) = IX_MBUF_PKT_LEN(&r->mbuf) = request_size + 64;
@@ -375,9 +338,7 @@ ixp_request(void *arg)
 			0, request_size, 0, request_size, request_size, r->buffer);
 	if (IX_CRYPTO_ACC_STATUS_SUCCESS != status) {
 		printk("status1 = %d\n", status);
-		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding--;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		return;
 	}
 	return;
@@ -392,12 +353,6 @@ ixp_request_wq(struct work_struct *work)
 }
 #endif
 
-static void
-ixp_done(void)
-{
-	/* we should free the session here but I am lazy :-) */
-}
-
 /*************************************************************************/
 #endif /* BENCH_IXP_ACCESS_LIB */
 /*************************************************************************/
@@ -405,9 +360,7 @@ ixp_done(void)
 int
 ocfbench_init(void)
 {
-	int i;
-	unsigned long mbps;
-	unsigned long flags;
+	int i, jstart, jstop;
 
 	printk("Crypto Speed tests\n");
 
@@ -419,11 +372,6 @@ ocfbench_init(void)
 
 	for (i = 0; i < request_q_len; i++) {
 		/* +64 for return data */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-		INIT_WORK(&requests[i].work, ocf_request_wq);
-#else
-		INIT_WORK(&requests[i].work, ocf_request, &requests[i]);
-#endif
 		requests[i].buffer = kmalloc(request_size + 128, GFP_DMA);
 		if (!requests[i].buffer) {
 			printk("malloc failed\n");
@@ -436,31 +384,19 @@ ocfbench_init(void)
 	 * OCF benchmark
 	 */
 	printk("OCF: testing ...\n");
-	if (ocf_init() == -1)
-		return -EINVAL;
-
-	spin_lock_init(&ocfbench_counter_lock);
+	ocf_init();
 	total = outstanding = 0;
 	jstart = jiffies;
 	for (i = 0; i < request_q_len; i++) {
-		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding++;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		ocf_request(&requests[i]);
 	}
 	while (outstanding > 0)
 		schedule();
 	jstop = jiffies;
 
-	mbps = 0;
-	if (jstop > jstart) {
-		mbps = (unsigned long) total * (unsigned long) request_size * 8;
-		mbps /= ((jstop - jstart) * 1000) / HZ;
-	}
-	printk("OCF: %d requests of %d bytes in %d jiffies (%d.%03d Mbps)\n",
-			total, request_size, (int)(jstop - jstart),
-			((int)mbps) / 1000, ((int)mbps) % 1000);
-	ocf_done();
+	printk("OCF: %d requests of %d bytes in %d jiffies\n", total, request_size,
+			jstop - jstart);
 
 #ifdef BENCH_IXP_ACCESS_LIB
 	/*
@@ -471,29 +407,15 @@ ocfbench_init(void)
 	total = outstanding = 0;
 	jstart = jiffies;
 	for (i = 0; i < request_q_len; i++) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-		INIT_WORK(&requests[i].work, ixp_request_wq);
-#else
-		INIT_WORK(&requests[i].work, ixp_request, &requests[i]);
-#endif
-		spin_lock_irqsave(&ocfbench_counter_lock, flags);
 		outstanding++;
-		spin_unlock_irqrestore(&ocfbench_counter_lock, flags);
 		ixp_request(&requests[i]);
 	}
 	while (outstanding > 0)
 		schedule();
 	jstop = jiffies;
 
-	mbps = 0;
-	if (jstop > jstart) {
-		mbps = (unsigned long) total * (unsigned long) request_size * 8;
-		mbps /= ((jstop - jstart) * 1000) / HZ;
-	}
-	printk("IXP: %d requests of %d bytes in %d jiffies (%d.%03d Mbps)\n",
-			total, request_size, jstop - jstart,
-			((int)mbps) / 1000, ((int)mbps) % 1000);
-	ixp_done();
+	printk("IXP: %d requests of %d bytes in %d jiffies\n", total, request_size,
+			jstop - jstart);
 #endif /* BENCH_IXP_ACCESS_LIB */
 
 	for (i = 0; i < request_q_len; i++)
@@ -510,5 +432,5 @@ module_init(ocfbench_init);
 module_exit(ocfbench_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("Benchmark various in-kernel crypto speeds");
diff --git a/crypto/ocf/ocf-compat.h b/crypto/ocf/ocf-compat.h
index e5108b1..53f8b0c8 100644
--- a/crypto/ocf/ocf-compat.h
+++ b/crypto/ocf/ocf-compat.h
@@ -4,8 +4,8 @@
 /*
  * Provide compat routines for older linux kernels and BSD kernels
  *
- * Written by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2010 David McCullough <david_mccullough@mcafee.com>
+ * Written by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2007 David McCullough <david_mccullough@securecomputing.com>
  *
  * LICENSE TERMS
  *
@@ -34,11 +34,6 @@
  */
 /****************************************************************************/
 #ifdef __KERNEL__
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
-#include <linux/config.h>
-#endif
-
 /*
  * fake some BSD driver interface stuff specifically for OCF use
  */
@@ -189,25 +184,11 @@ struct ocf_device {
 #define DMA_32BIT_MASK  0x00000000ffffffffULL
 #endif
 
-#ifndef htole32
 #define htole32(x)	cpu_to_le32(x)
-#endif
-#ifndef htobe32
 #define htobe32(x)	cpu_to_be32(x)
-#endif
-#ifndef htole16
 #define htole16(x)	cpu_to_le16(x)
-#endif
-#ifndef htobe16
 #define htobe16(x)	cpu_to_be16(x)
-#endif
 
-/* older kernels don't have these */
-
-#include <asm/irq.h>
-#ifndef IRQF_SHARED
-#define IRQF_SHARED	SA_SHIRQ
-#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 # define strlcpy(dest,src,len) \
@@ -218,18 +199,12 @@ struct ocf_device {
 #define MAX_ERRNO	4095
 #endif
 #ifndef IS_ERR_VALUE
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,5)
-#include <linux/err.h>
-#endif
-#ifndef IS_ERR_VALUE
 #define IS_ERR_VALUE(x) ((unsigned long)(x) >= (unsigned long)-MAX_ERRNO)
 #endif
-#endif
 
 /*
  * common debug for all
  */
-#undef dprintk
 #if 1
 #define dprintk(a...)	do { if (debug) printk(a); } while(0)
 #else
@@ -262,7 +237,6 @@ struct ocf_device {
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
 
-#include <linux/mm.h>
 #include <asm/scatterlist.h>
 
 static inline void sg_set_page(struct scatterlist *sg,  struct page *page,
@@ -278,85 +252,6 @@ static inline void *sg_virt(struct scatterlist *sg)
 	return page_address(sg->page) + sg->offset;
 }
 
-#define sg_init_table(sg, n)
-
-#define sg_mark_end(sg)
-
-#endif
-
-#ifndef late_initcall
-#define late_initcall(init) module_init(init)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) || !defined(CONFIG_SMP)
-#define ocf_for_each_cpu(cpu) for ((cpu) = 0; (cpu) == 0; (cpu)++)
-#else
-#define ocf_for_each_cpu(cpu) for_each_present_cpu(cpu)
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-#include <linux/sched.h>
-#define	kill_proc(p,s,v)	send_sig(s,find_task_by_vpid(p),0)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)
-
-struct ocf_thread {
-	struct task_struct	*task;
-	int					(*func)(void *arg);
-	void				*arg;
-};
-
-/* thread startup helper func */
-static inline int ocf_run_thread(void *arg)
-{
-	struct ocf_thread *t = (struct ocf_thread *) arg;
-	if (!t)
-		return -1; /* very bad */
-	t->task = current;
-	daemonize();
-	spin_lock_irq(&current->sigmask_lock);
-	sigemptyset(&current->blocked);
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
-	return (*t->func)(t->arg);
-}
-
-#define kthread_create(f,a,fmt...) \
-	({ \
-		struct ocf_thread t; \
-		pid_t p; \
-		t.task = NULL; \
-		t.func = (f); \
-		t.arg = (a); \
-		p = kernel_thread(ocf_run_thread, &t, CLONE_FS|CLONE_FILES); \
-		while (p != (pid_t) -1 && t.task == NULL) \
-			schedule(); \
-		if (t.task) \
-			snprintf(t.task->comm, sizeof(t.task->comm), fmt); \
-		(t.task); \
-	})
-
-#define kthread_bind(t,cpu)	/**/
-
-#define kthread_should_stop()	(strcmp(current->comm, "stopping") == 0)
-
-#define kthread_stop(t) \
-	({ \
-		strcpy((t)->comm, "stopping"); \
-		kill_proc((t)->pid, SIGTERM, 1); \
-		do { \
-			schedule(); \
-		} while (kill_proc((t)->pid, SIGTERM, 1) == 0); \
-	})
-
-#else
-#include <linux/kthread.h>
-#endif
-
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
-#define	skb_frag_page(x)	((x)->page)
 #endif
 
 #endif /* __KERNEL__ */
diff --git a/crypto/ocf/ocfnull/ocfnull.c b/crypto/ocf/ocfnull/ocfnull.c
index 9cf3f6e..b4ad84c 100644
--- a/crypto/ocf/ocfnull/ocfnull.c
+++ b/crypto/ocf/ocfnull/ocfnull.c
@@ -4,8 +4,8 @@
  * zero cost encryption,  of course you will need to run it at both ends
  * since it does no crypto at all.
  *
- * Written by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough 
+ * Written by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough 
  *
  * LICENSE TERMS
  *
@@ -33,8 +33,7 @@
  * and/or fitness for purpose.
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -200,5 +199,5 @@ module_init(null_init);
 module_exit(null_exit);
 
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("ocfnull - claims a lot but does nothing");
diff --git a/crypto/ocf/pasemi/pasemi.c b/crypto/ocf/pasemi/pasemi.c
index 1b4333c..c3bb931 100644
--- a/crypto/ocf/pasemi/pasemi.c
+++ b/crypto/ocf/pasemi/pasemi.c
@@ -17,8 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -238,6 +237,11 @@ pasemi_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 
 	if (encini) {
 		ses->ccmd = ccmd;
+
+		/* get an IV */
+		/* XXX may read fewer than requested */
+		get_random_bytes(ses->civ, sizeof(ses->civ));
+
 		ses->keysz = (encini->cri_klen - 63) / 64;
 		memcpy(ses->key, encini->cri_key, (ses->keysz + 1) * 8);
 
@@ -444,8 +448,6 @@ pasemi_process(device_t dev, struct cryptop *crp, int hint)
 		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				memcpy(ivp, enccrd->crd_iv, ivsize);
-			else
-				read_random(ivp, ivsize);
 			/* If IV is not present in the buffer already, it has to be copied there */
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
diff --git a/crypto/ocf/random.c b/crypto/ocf/random.c
index 4bb773f..118575a 100644
--- a/crypto/ocf/random.c
+++ b/crypto/ocf/random.c
@@ -5,8 +5,8 @@
  *
  * This should be fast and callable from timers/interrupts
  *
- * Written by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Written by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
@@ -35,8 +35,7 @@
  * and/or fitness for purpose.
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -46,6 +45,7 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
+#include <linux/version.h>
 #include <linux/unistd.h>
 #include <linux/poll.h>
 #include <linux/random.h>
@@ -172,7 +172,7 @@ crypto_runregister_all(u_int32_t driverid)
 
 	spin_lock_irqsave(&random_lock, flags);
 	if (list_empty(&random_ops) && started)
-		kill_proc(randomproc, SIGKILL, 1);
+		kill_proc_info(SIGKILL, SEND_SIG_PRIV, randomproc);
 	spin_unlock_irqrestore(&random_lock, flags);
 	return(0);
 }
diff --git a/crypto/ocf/rndtest.c b/crypto/ocf/rndtest.c
index 7bed6a1..34b68d8 100644
--- a/crypto/ocf/rndtest.c
+++ b/crypto/ocf/rndtest.c
@@ -1,8 +1,8 @@
 /*	$OpenBSD$	*/
 
 /*
- * OCF/Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * OCF/Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  * The license and original author are listed below.
  *
@@ -36,14 +36,14 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/time.h>
+#include <linux/version.h>
 #include <linux/unistd.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
diff --git a/crypto/ocf/safe/safe.c b/crypto/ocf/safe/safe.c
index 141640e..a77e3a2 100644
--- a/crypto/ocf/safe/safe.c
+++ b/crypto/ocf/safe/safe.c
@@ -1,6 +1,6 @@
 /*-
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2004-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2004-2007 David McCullough
  * The license and original author are listed below.
  *
  * Copyright (c) 2003 Sam Leffler, Errno Consulting
@@ -31,8 +31,7 @@
 __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $");
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -47,6 +46,7 @@ __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/random.h>
+#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <asm/io.h>
 
@@ -77,11 +77,40 @@ __FBSDID("$FreeBSD: src/sys/dev/safe/safe.c,v 1.18 2007/03/21 03:42:50 sam Exp $
  */
 #define HMAC_HACK 1
 #ifdef HMAC_HACK
-#include <safe/hmachack.h>
+#define LITTLE_ENDIAN 1234
+#define BIG_ENDIAN 4321
+#ifdef __LITTLE_ENDIAN
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#ifdef __BIG_ENDIAN
+#define BYTE_ORDER BIG_ENDIAN
+#endif
 #include <safe/md5.h>
 #include <safe/md5.c>
 #include <safe/sha1.h>
 #include <safe/sha1.c>
+
+u_int8_t hmac_ipad_buffer[64] = {
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
+};
+
+u_int8_t hmac_opad_buffer[64] = {
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
+    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
+};
 #endif /* HMAC_HACK */
 
 /* add proc entry for this */
@@ -208,7 +237,7 @@ pci_map_skb(struct safe_softc *sc,struct safe_operand *buf,struct sk_buff *skb)
 
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		pci_map_linear(sc, buf,
-				page_address(skb_frag_page(&skb_shinfo(skb)->frags[i])) +
+				page_address(skb_shinfo(skb)->frags[i].page) +
 				                        skb_shinfo(skb)->frags[i].page_offset,
 				skb_shinfo(skb)->frags[i].size);
 	}
@@ -532,6 +561,10 @@ safe_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 	ses->ses_used = 1;
 
 	if (encini) {
+		/* get an IV */
+		/* XXX may read fewer than requested */
+		read_random(ses->ses_iv, sizeof(ses->ses_iv));
+
 		ses->ses_klen = encini->cri_klen;
 		if (encini->cri_key != NULL)
 			safe_setup_enckey(ses, encini->cri_key);
@@ -594,7 +627,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 	struct safe_ringentry *re;
 	struct safe_sarec *sa;
 	struct safe_pdesc *pd;
-	u_int32_t cmd0, cmd1, staterec, rand_iv[4];
+	u_int32_t cmd0, cmd1, staterec;
 	unsigned long flags;
 
 	DPRINTF(("%s()\n", __FUNCTION__));
@@ -743,7 +776,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				iv = enccrd->crd_iv;
 			else
-				read_random((iv = (caddr_t) &rand_iv[0]), sizeof(rand_iv));
+				iv = (caddr_t) ses->ses_iv;
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
@@ -1093,6 +1126,31 @@ safe_callback(struct safe_softc *sc, struct safe_ringentry *re)
 		return;
 	}
 
+	if (re->re_flags & SAFE_QFLAGS_COPYOUTIV) {
+		/* copy out IV for future use */
+		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
+			int i;
+			int ivsize;
+
+			if (crd->crd_alg == CRYPTO_DES_CBC ||
+			    crd->crd_alg == CRYPTO_3DES_CBC) {
+				ivsize = 2*sizeof(u_int32_t);
+			} else if (crd->crd_alg == CRYPTO_AES_CBC) {
+				ivsize = 4*sizeof(u_int32_t);
+			} else
+				continue;
+			crypto_copydata(crp->crp_flags, crp->crp_buf,
+			    crd->crd_skip + crd->crd_len - ivsize, ivsize,
+			    (caddr_t)sc->sc_sessions[re->re_sesn].ses_iv);
+			for (i = 0;
+					i < ivsize/sizeof(sc->sc_sessions[re->re_sesn].ses_iv[0]);
+					i++)
+				sc->sc_sessions[re->re_sesn].ses_iv[i] =
+					cpu_to_le32(sc->sc_sessions[re->re_sesn].ses_iv[i]);
+			break;
+		}
+	}
+
 	if (re->re_flags & SAFE_QFLAGS_COPYOUTICV) {
 		/* copy out ICV result */
 		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@@ -2226,5 +2284,5 @@ module_init(safe_init);
 module_exit(safe_exit);
 
 MODULE_LICENSE("BSD");
-MODULE_AUTHOR("David McCullough <david_mccullough@mcafee.com>");
+MODULE_AUTHOR("David McCullough <david_mccullough@securecomputing.com>");
 MODULE_DESCRIPTION("OCF driver for safenet PCI crypto devices");
diff --git a/crypto/ocf/safe/safevar.h b/crypto/ocf/safe/safevar.h
index 11d8304..f5b7394 100644
--- a/crypto/ocf/safe/safevar.h
+++ b/crypto/ocf/safe/safevar.h
@@ -1,6 +1,6 @@
 /*-
  * The linux port of this code done by David McCullough
- * Copyright (C) 2004-2010 David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com>
  * The license and original author are listed below.
  *
  * Copyright (c) 2003 Sam Leffler, Errno Consulting
@@ -145,6 +145,7 @@ struct safe_session {
 	u_int32_t	ses_mlen;		/* hmac length in bytes */
 	u_int32_t	ses_hminner[5];		/* hmac inner state */
 	u_int32_t	ses_hmouter[5];		/* hmac outer state */
+	u_int32_t	ses_iv[4];		/* DES/3DES/AES iv */
 };
 
 struct safe_pkq {
diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index c4bc8c0..eaf3f30 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -8,7 +8,7 @@
  *
  * This code written by Kim A. B. Phillips <kim.phillips@freescale.com>
  * some code copied from files with the following:
- * Copyright (C) 2004-2007 David McCullough <david_mccullough@mcafee.com>
+ * Copyright (C) 2004-2007 David McCullough <david_mccullough@securecomputing.com
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -107,8 +107,7 @@
  * o add statistics
  */
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) && !defined(AUTOCONF_INCLUDED)
+#ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
 #include <linux/module.h>
@@ -121,6 +120,7 @@
 #include <linux/dma-mapping.h>  /* dma_map_single() */
 #include <linux/moduleparam.h>
 
+#include <linux/version.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
 #include <linux/platform_device.h>
 #endif
@@ -418,6 +418,10 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 	ses->ses_used = 1;
 
 	if (encini) {
+		/* get an IV */
+		/* XXX may read fewer than requested */
+		read_random(ses->ses_iv, sizeof(ses->ses_iv));
+
 		ses->ses_klen = (encini->cri_klen + 7) / 8;
 		memcpy(ses->ses_key, encini->cri_key, ses->ses_klen);
 		if (macini) {
@@ -507,7 +511,6 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 	int hmac_key, hmac_data, cipher_iv, cipher_key, 
 		in_fifo, out_fifo, cipher_iv_out;
 	static int chsel = -1;
-	u_int32_t rand_iv[4];
 
 	DPRINTF("%s()\n", __FUNCTION__);
 
@@ -749,7 +752,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				iv = enccrd->crd_iv;
 			else
-				read_random((iv = (caddr_t) rand_iv), sizeof(rand_iv));
+				iv = (caddr_t) ses->ses_iv;
 			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 				crypto_copyback(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
@@ -758,8 +761,9 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			td->hdr |= TALITOS_DIR_INBOUND; 
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT) {
 				iv = enccrd->crd_iv;
+				bcopy(enccrd->crd_iv, iv, ivsize);
 			} else {
-				iv = (caddr_t) rand_iv;
+				iv = (caddr_t) ses->ses_iv;
 				crypto_copydata(crp->crp_flags, crp->crp_buf,
 				    enccrd->crd_inject, ivsize, iv);
 			}
diff --git a/crypto/ocf/talitos/talitos_soft.h b/crypto/ocf/talitos/talitos_soft.h
index eda9c2e..79efdbd 100644
--- a/crypto/ocf/talitos/talitos_soft.h
+++ b/crypto/ocf/talitos/talitos_soft.h
@@ -69,6 +69,7 @@ struct talitos_session {
 	u_int32_t	ses_key[8];		/* DES/3DES/AES key */
 	u_int32_t	ses_hmac[5];		/* hmac inner state */
 	u_int32_t	ses_hmac_len;		/* hmac length */
+	u_int32_t	ses_iv[4];		/* DES/3DES/AES iv */
 	u_int32_t	ses_mlen;		/* desired hash result len (12=ipsec or 16) */
 };
 
diff --git a/crypto/ocf/uio.h b/crypto/ocf/uio.h
index 03a6249..e82e46c 100644
--- a/crypto/ocf/uio.h
+++ b/crypto/ocf/uio.h
@@ -8,8 +8,8 @@
  * with the BSD cryptodev,  we need to keep this around.  Perhaps this can
  * be moved back into the linux/uio.h
  *
- * Linux port done by David McCullough <david_mccullough@mcafee.com>
- * Copyright (C) 2006-2010 David McCullough
+ * Linux port done by David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2007 David McCullough
  * Copyright (C) 2004-2005 Intel Corporation.
  *
  * LICENSE TERMS
diff --git a/crypto/salsa20_generic.c b/crypto/salsa20_generic.c
index 9a4770c..eac10c1 100644
--- a/crypto/salsa20_generic.c
+++ b/crypto/salsa20_generic.c
@@ -221,6 +221,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize        =   sizeof(struct salsa20_ctx),
 	.cra_alignmask      =	3,
 	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
 	.cra_u              =   {
 		.blkcipher = {
 			.setkey         =   setkey,
diff --git a/crypto/seed.c b/crypto/seed.c
index 9c904d6..d3e422f 100644
--- a/crypto/seed.c
+++ b/crypto/seed.c
@@ -449,6 +449,7 @@ static struct crypto_alg seed_alg = {
 	.cra_ctxsize		=	sizeof(struct seed_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(seed_alg.cra_list),
 	.cra_u			=	{
 		.cipher = {
 			.cia_min_keysize	=	SEED_KEY_SIZE,
diff --git a/crypto/serpent_generic.c b/crypto/serpent_generic.c
index 7ddbd7e..8f32cf3 100644
--- a/crypto/serpent_generic.c
+++ b/crypto/serpent_generic.c
@@ -567,6 +567,24 @@ static void serpent_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 	__serpent_decrypt(ctx, dst, src);
 }
 
+static struct crypto_alg serpent_alg = {
+	.cra_name		=	"serpent",
+	.cra_driver_name	=	"serpent-generic",
+	.cra_priority		=	100,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	SERPENT_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct serpent_ctx),
+	.cra_alignmask		=	3,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(serpent_alg.cra_list),
+	.cra_u			=	{ .cipher = {
+	.cia_min_keysize	=	SERPENT_MIN_KEY_SIZE,
+	.cia_max_keysize	=	SERPENT_MAX_KEY_SIZE,
+	.cia_setkey		=	serpent_setkey,
+	.cia_encrypt		=	serpent_encrypt,
+	.cia_decrypt		=	serpent_decrypt } }
+};
+
 static int tnepres_setkey(struct crypto_tfm *tfm, const u8 *key,
 			  unsigned int keylen)
 {
@@ -619,44 +637,41 @@ static void tnepres_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 	d[3] = swab32(rd[0]);
 }
 
-static struct crypto_alg srp_algs[2] = { {
-	.cra_name		=	"serpent",
-	.cra_driver_name	=	"serpent-generic",
-	.cra_priority		=	100,
-	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize		=	SERPENT_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct serpent_ctx),
-	.cra_alignmask		=	3,
-	.cra_module		=	THIS_MODULE,
-	.cra_u			=	{ .cipher = {
-	.cia_min_keysize	=	SERPENT_MIN_KEY_SIZE,
-	.cia_max_keysize	=	SERPENT_MAX_KEY_SIZE,
-	.cia_setkey		=	serpent_setkey,
-	.cia_encrypt		=	serpent_encrypt,
-	.cia_decrypt		=	serpent_decrypt } }
-}, {
+static struct crypto_alg tnepres_alg = {
 	.cra_name		=	"tnepres",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	SERPENT_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct serpent_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(serpent_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	SERPENT_MIN_KEY_SIZE,
 	.cia_max_keysize	=	SERPENT_MAX_KEY_SIZE,
 	.cia_setkey		=	tnepres_setkey,
 	.cia_encrypt		=	tnepres_encrypt,
 	.cia_decrypt		=	tnepres_decrypt } }
-} };
+};
 
 static int __init serpent_mod_init(void)
 {
-	return crypto_register_algs(srp_algs, ARRAY_SIZE(srp_algs));
+	int ret = crypto_register_alg(&serpent_alg);
+
+	if (ret)
+		return ret;
+
+	ret = crypto_register_alg(&tnepres_alg);
+
+	if (ret)
+		crypto_unregister_alg(&serpent_alg);
+
+	return ret;
 }
 
 static void __exit serpent_mod_fini(void)
 {
-	crypto_unregister_algs(srp_algs, ARRAY_SIZE(srp_algs));
+	crypto_unregister_alg(&tnepres_alg);
+	crypto_unregister_alg(&serpent_alg);
 }
 
 module_init(serpent_mod_init);
diff --git a/crypto/sha256_generic.c b/crypto/sha256_generic.c
index 5433667..c48459e 100644
--- a/crypto/sha256_generic.c
+++ b/crypto/sha256_generic.c
@@ -246,7 +246,7 @@ static int sha256_init(struct shash_desc *desc)
 	return 0;
 }
 
-int crypto_sha256_update(struct shash_desc *desc, const u8 *data,
+static int sha256_update(struct shash_desc *desc, const u8 *data,
 			  unsigned int len)
 {
 	struct sha256_state *sctx = shash_desc_ctx(desc);
@@ -277,7 +277,6 @@ int crypto_sha256_update(struct shash_desc *desc, const u8 *data,
 
 	return 0;
 }
-EXPORT_SYMBOL(crypto_sha256_update);
 
 static int sha256_final(struct shash_desc *desc, u8 *out)
 {
@@ -294,10 +293,10 @@ static int sha256_final(struct shash_desc *desc, u8 *out)
 	/* Pad out to 56 mod 64. */
 	index = sctx->count & 0x3f;
 	pad_len = (index < 56) ? (56 - index) : ((64+56) - index);
-	crypto_sha256_update(desc, padding, pad_len);
+	sha256_update(desc, padding, pad_len);
 
 	/* Append length (before padding) */
-	crypto_sha256_update(desc, (const u8 *)&bits, sizeof(bits));
+	sha256_update(desc, (const u8 *)&bits, sizeof(bits));
 
 	/* Store state in digest */
 	for (i = 0; i < 8; i++)
@@ -337,10 +336,10 @@ static int sha256_import(struct shash_desc *desc, const void *in)
 	return 0;
 }
 
-static struct shash_alg sha256_algs[2] = { {
+static struct shash_alg sha256 = {
 	.digestsize	=	SHA256_DIGEST_SIZE,
 	.init		=	sha256_init,
-	.update		=	crypto_sha256_update,
+	.update		=	sha256_update,
 	.final		=	sha256_final,
 	.export		=	sha256_export,
 	.import		=	sha256_import,
@@ -353,10 +352,12 @@ static struct shash_alg sha256_algs[2] = { {
 		.cra_blocksize	=	SHA256_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg sha224 = {
 	.digestsize	=	SHA224_DIGEST_SIZE,
 	.init		=	sha224_init,
-	.update		=	crypto_sha256_update,
+	.update		=	sha256_update,
 	.final		=	sha224_final,
 	.descsize	=	sizeof(struct sha256_state),
 	.base		=	{
@@ -366,16 +367,29 @@ static struct shash_alg sha256_algs[2] = { {
 		.cra_blocksize	=	SHA224_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-} };
+};
 
 static int __init sha256_generic_mod_init(void)
 {
-	return crypto_register_shashes(sha256_algs, ARRAY_SIZE(sha256_algs));
+	int ret = 0;
+
+	ret = crypto_register_shash(&sha224);
+
+	if (ret < 0)
+		return ret;
+
+	ret = crypto_register_shash(&sha256);
+
+	if (ret < 0)
+		crypto_unregister_shash(&sha224);
+
+	return ret;
 }
 
 static void __exit sha256_generic_mod_fini(void)
 {
-	crypto_unregister_shashes(sha256_algs, ARRAY_SIZE(sha256_algs));
+	crypto_unregister_shash(&sha224);
+	crypto_unregister_shash(&sha256);
 }
 
 module_init(sha256_generic_mod_init);
diff --git a/crypto/sha512_generic.c b/crypto/sha512_generic.c
index 4c58620..dd30f40 100644
--- a/crypto/sha512_generic.c
+++ b/crypto/sha512_generic.c
@@ -163,8 +163,8 @@ sha384_init(struct shash_desc *desc)
 	return 0;
 }
 
-int crypto_sha512_update(struct shash_desc *desc, const u8 *data,
-			unsigned int len)
+static int
+sha512_update(struct shash_desc *desc, const u8 *data, unsigned int len)
 {
 	struct sha512_state *sctx = shash_desc_ctx(desc);
 
@@ -197,7 +197,6 @@ int crypto_sha512_update(struct shash_desc *desc, const u8 *data,
 
 	return 0;
 }
-EXPORT_SYMBOL(crypto_sha512_update);
 
 static int
 sha512_final(struct shash_desc *desc, u8 *hash)
@@ -216,10 +215,10 @@ sha512_final(struct shash_desc *desc, u8 *hash)
 	/* Pad out to 112 mod 128. */
 	index = sctx->count[0] & 0x7f;
 	pad_len = (index < 112) ? (112 - index) : ((128+112) - index);
-	crypto_sha512_update(desc, padding, pad_len);
+	sha512_update(desc, padding, pad_len);
 
 	/* Append length (before padding) */
-	crypto_sha512_update(desc, (const u8 *)bits, sizeof(bits));
+	sha512_update(desc, (const u8 *)bits, sizeof(bits));
 
 	/* Store state in digest */
 	for (i = 0; i < 8; i++)
@@ -243,10 +242,10 @@ static int sha384_final(struct shash_desc *desc, u8 *hash)
 	return 0;
 }
 
-static struct shash_alg sha512_algs[2] = { {
+static struct shash_alg sha512 = {
 	.digestsize	=	SHA512_DIGEST_SIZE,
 	.init		=	sha512_init,
-	.update		=	crypto_sha512_update,
+	.update		=	sha512_update,
 	.final		=	sha512_final,
 	.descsize	=	sizeof(struct sha512_state),
 	.base		=	{
@@ -255,10 +254,12 @@ static struct shash_alg sha512_algs[2] = { {
 		.cra_blocksize	=	SHA512_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg sha384 = {
 	.digestsize	=	SHA384_DIGEST_SIZE,
 	.init		=	sha384_init,
-	.update		=	crypto_sha512_update,
+	.update		=	sha512_update,
 	.final		=	sha384_final,
 	.descsize	=	sizeof(struct sha512_state),
 	.base		=	{
@@ -267,16 +268,24 @@ static struct shash_alg sha512_algs[2] = { {
 		.cra_blocksize	=	SHA384_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-} };
+};
 
 static int __init sha512_generic_mod_init(void)
 {
-	return crypto_register_shashes(sha512_algs, ARRAY_SIZE(sha512_algs));
+        int ret = 0;
+
+        if ((ret = crypto_register_shash(&sha384)) < 0)
+                goto out;
+        if ((ret = crypto_register_shash(&sha512)) < 0)
+                crypto_unregister_shash(&sha384);
+out:
+        return ret;
 }
 
 static void __exit sha512_generic_mod_fini(void)
 {
-	crypto_unregister_shashes(sha512_algs, ARRAY_SIZE(sha512_algs));
+        crypto_unregister_shash(&sha384);
+        crypto_unregister_shash(&sha512);
 }
 
 module_init(sha512_generic_mod_init);
diff --git a/crypto/shash.c b/crypto/shash.c
index e49e79f..3b2a71f 100644
--- a/crypto/shash.c
+++ b/crypto/shash.c
@@ -630,42 +630,6 @@ int crypto_unregister_shash(struct shash_alg *alg)
 }
 EXPORT_SYMBOL_GPL(crypto_unregister_shash);
 
-int crypto_register_shashes(struct shash_alg *algs, int count)
-{
-	int i, ret;
-
-	for (i = 0; i < count; i++) {
-		ret = crypto_register_shash(&algs[i]);
-		if (ret)
-			goto err;
-	}
-
-	return 0;
-
-err:
-	for (--i; i >= 0; --i)
-		crypto_unregister_shash(&algs[i]);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(crypto_register_shashes);
-
-int crypto_unregister_shashes(struct shash_alg *algs, int count)
-{
-	int i, ret;
-
-	for (i = count - 1; i >= 0; --i) {
-		ret = crypto_unregister_shash(&algs[i]);
-		if (ret)
-			pr_err("Failed to unregister %s %s: %d\n",
-			       algs[i].base.cra_driver_name,
-			       algs[i].base.cra_name, ret);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(crypto_unregister_shashes);
-
 int shash_register_instance(struct crypto_template *tmpl,
 			    struct shash_instance *inst)
 {
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 87d0acc..8f147bf 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -809,7 +809,7 @@ static void test_acipher_speed(const char *algo, int enc, unsigned int sec,
 			       struct cipher_speed_template *template,
 			       unsigned int tcount, u8 *keysize)
 {
-	unsigned int ret, i, j, k, iv_len;
+	unsigned int ret, i, j, iv_len;
 	struct tcrypt_result tresult;
 	const char *key;
 	char iv[128];
@@ -883,23 +883,11 @@ static void test_acipher_speed(const char *algo, int enc, unsigned int sec,
 			}
 
 			sg_init_table(sg, TVMEMSIZE);
-
-			k = *keysize + *b_size;
-			if (k > PAGE_SIZE) {
-				sg_set_buf(sg, tvmem[0] + *keysize,
+			sg_set_buf(sg, tvmem[0] + *keysize,
 				   PAGE_SIZE - *keysize);
-				k -= PAGE_SIZE;
-				j = 1;
-				while (k > PAGE_SIZE) {
-					sg_set_buf(sg + j, tvmem[j], PAGE_SIZE);
-					memset(tvmem[j], 0xff, PAGE_SIZE);
-					j++;
-					k -= PAGE_SIZE;
-				}
-				sg_set_buf(sg + j, tvmem[j], k);
-				memset(tvmem[j], 0xff, k);
-			} else {
-				sg_set_buf(sg, tvmem[0] + *keysize, *b_size);
+			for (j = 1; j < TVMEMSIZE; j++) {
+				sg_set_buf(sg + j, tvmem[j], PAGE_SIZE);
+				memset(tvmem[j], 0xff, PAGE_SIZE);
 			}
 
 			iv_len = crypto_ablkcipher_ivsize(tfm);
@@ -1426,10 +1414,6 @@ static int do_test(int m)
 		test_hash_speed("ghash-generic", sec, hash_speed_template_16);
 		if (mode > 300 && mode < 400) break;
 
-	case 319:
-		test_hash_speed("crc32c", sec, generic_hash_speed_template);
-		if (mode > 300 && mode < 400) break;
-
 	case 399:
 		break;
 
@@ -1528,14 +1512,6 @@ static int do_test(int m)
 				   speed_template_16_24_32);
 		test_acipher_speed("ctr(aes)", DECRYPT, sec, NULL, 0,
 				   speed_template_16_24_32);
-		test_acipher_speed("cfb(aes)", ENCRYPT, sec, NULL, 0,
-				   speed_template_16_24_32);
-		test_acipher_speed("cfb(aes)", DECRYPT, sec, NULL, 0,
-				   speed_template_16_24_32);
-		test_acipher_speed("ofb(aes)", ENCRYPT, sec, NULL, 0,
-				   speed_template_16_24_32);
-		test_acipher_speed("ofb(aes)", DECRYPT, sec, NULL, 0,
-				   speed_template_16_24_32);
 		break;
 
 	case 501:
@@ -1551,18 +1527,6 @@ static int do_test(int m)
 		test_acipher_speed("cbc(des3_ede)", DECRYPT, sec,
 				   des3_speed_template, DES3_SPEED_VECTORS,
 				   speed_template_24);
-		test_acipher_speed("cfb(des3_ede)", ENCRYPT, sec,
-				   des3_speed_template, DES3_SPEED_VECTORS,
-				   speed_template_24);
-		test_acipher_speed("cfb(des3_ede)", DECRYPT, sec,
-				   des3_speed_template, DES3_SPEED_VECTORS,
-				   speed_template_24);
-		test_acipher_speed("ofb(des3_ede)", ENCRYPT, sec,
-				   des3_speed_template, DES3_SPEED_VECTORS,
-				   speed_template_24);
-		test_acipher_speed("ofb(des3_ede)", DECRYPT, sec,
-				   des3_speed_template, DES3_SPEED_VECTORS,
-				   speed_template_24);
 		break;
 
 	case 502:
@@ -1574,14 +1538,6 @@ static int do_test(int m)
 				   speed_template_8);
 		test_acipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,
 				   speed_template_8);
-		test_acipher_speed("cfb(des)", ENCRYPT, sec, NULL, 0,
-				   speed_template_8);
-		test_acipher_speed("cfb(des)", DECRYPT, sec, NULL, 0,
-				   speed_template_8);
-		test_acipher_speed("ofb(des)", ENCRYPT, sec, NULL, 0,
-				   speed_template_8);
-		test_acipher_speed("ofb(des)", DECRYPT, sec, NULL, 0,
-				   speed_template_8);
 		break;
 
 	case 503:
diff --git a/crypto/tea.c b/crypto/tea.c
index 0a57232..412bc74 100644
--- a/crypto/tea.c
+++ b/crypto/tea.c
@@ -219,55 +219,84 @@ static void xeta_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 	out[1] = cpu_to_le32(z);
 }
 
-static struct crypto_alg tea_algs[3] = { {
+static struct crypto_alg tea_alg = {
 	.cra_name		=	"tea",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	TEA_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof (struct tea_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(tea_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	TEA_KEY_SIZE,
 	.cia_max_keysize	=	TEA_KEY_SIZE,
 	.cia_setkey		= 	tea_setkey,
 	.cia_encrypt		=	tea_encrypt,
 	.cia_decrypt		=	tea_decrypt } }
-}, {
+};
+
+static struct crypto_alg xtea_alg = {
 	.cra_name		=	"xtea",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	XTEA_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof (struct xtea_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(xtea_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	XTEA_KEY_SIZE,
 	.cia_max_keysize	=	XTEA_KEY_SIZE,
 	.cia_setkey		= 	xtea_setkey,
 	.cia_encrypt		=	xtea_encrypt,
 	.cia_decrypt		=	xtea_decrypt } }
-}, {
+};
+
+static struct crypto_alg xeta_alg = {
 	.cra_name		=	"xeta",
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	XTEA_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof (struct xtea_ctx),
 	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(xtea_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	XTEA_KEY_SIZE,
 	.cia_max_keysize	=	XTEA_KEY_SIZE,
 	.cia_setkey		= 	xtea_setkey,
 	.cia_encrypt		=	xeta_encrypt,
 	.cia_decrypt		=	xeta_decrypt } }
-} };
+};
 
 static int __init tea_mod_init(void)
 {
-	return crypto_register_algs(tea_algs, ARRAY_SIZE(tea_algs));
+	int ret = 0;
+	
+	ret = crypto_register_alg(&tea_alg);
+	if (ret < 0)
+		goto out;
+
+	ret = crypto_register_alg(&xtea_alg);
+	if (ret < 0) {
+		crypto_unregister_alg(&tea_alg);
+		goto out;
+	}
+
+	ret = crypto_register_alg(&xeta_alg);
+	if (ret < 0) {
+		crypto_unregister_alg(&tea_alg);
+		crypto_unregister_alg(&xtea_alg);
+		goto out;
+	}
+
+out:	
+	return ret;
 }
 
 static void __exit tea_mod_fini(void)
 {
-	crypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));
+	crypto_unregister_alg(&tea_alg);
+	crypto_unregister_alg(&xtea_alg);
+	crypto_unregister_alg(&xeta_alg);
 }
 
 MODULE_ALIAS("xtea");
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
index 8740355..cbca4f20 100644
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -628,7 +628,7 @@ static int tgr128_final(struct shash_desc *desc, u8 * out)
 	return 0;
 }
 
-static struct shash_alg tgr_algs[3] = { {
+static struct shash_alg tgr192 = {
 	.digestsize	=	TGR192_DIGEST_SIZE,
 	.init		=	tgr192_init,
 	.update		=	tgr192_update,
@@ -640,7 +640,9 @@ static struct shash_alg tgr_algs[3] = { {
 		.cra_blocksize	=	TGR192_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg tgr160 = {
 	.digestsize	=	TGR160_DIGEST_SIZE,
 	.init		=	tgr192_init,
 	.update		=	tgr192_update,
@@ -652,7 +654,9 @@ static struct shash_alg tgr_algs[3] = { {
 		.cra_blocksize	=	TGR192_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg tgr128 = {
 	.digestsize	=	TGR128_DIGEST_SIZE,
 	.init		=	tgr192_init,
 	.update		=	tgr192_update,
@@ -664,16 +668,38 @@ static struct shash_alg tgr_algs[3] = { {
 		.cra_blocksize	=	TGR192_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-} };
+};
 
 static int __init tgr192_mod_init(void)
 {
-	return crypto_register_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));
+	int ret = 0;
+
+	ret = crypto_register_shash(&tgr192);
+
+	if (ret < 0) {
+		goto out;
+	}
+
+	ret = crypto_register_shash(&tgr160);
+	if (ret < 0) {
+		crypto_unregister_shash(&tgr192);
+		goto out;
+	}
+
+	ret = crypto_register_shash(&tgr128);
+	if (ret < 0) {
+		crypto_unregister_shash(&tgr192);
+		crypto_unregister_shash(&tgr160);
+	}
+      out:
+	return ret;
 }
 
 static void __exit tgr192_mod_fini(void)
 {
-	crypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));
+	crypto_unregister_shash(&tgr192);
+	crypto_unregister_shash(&tgr160);
+	crypto_unregister_shash(&tgr128);
 }
 
 MODULE_ALIAS("tgr160");
diff --git a/crypto/twofish_generic.c b/crypto/twofish_generic.c
index 2d50005..1f07b84 100644
--- a/crypto/twofish_generic.c
+++ b/crypto/twofish_generic.c
@@ -188,6 +188,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize        =   sizeof(struct twofish_ctx),
 	.cra_alignmask      =	3,
 	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
 	.cra_u              =   { .cipher = {
 	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
 	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
diff --git a/crypto/wp512.c b/crypto/wp512.c
index 180f1d6..71719a2 100644
--- a/crypto/wp512.c
+++ b/crypto/wp512.c
@@ -1119,7 +1119,7 @@ static int wp256_final(struct shash_desc *desc, u8 *out)
 	return 0;
 }
 
-static struct shash_alg wp_algs[3] = { {
+static struct shash_alg wp512 = {
 	.digestsize	=	WP512_DIGEST_SIZE,
 	.init		=	wp512_init,
 	.update		=	wp512_update,
@@ -1131,7 +1131,9 @@ static struct shash_alg wp_algs[3] = { {
 		.cra_blocksize	=	WP512_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg wp384 = {
 	.digestsize	=	WP384_DIGEST_SIZE,
 	.init		=	wp512_init,
 	.update		=	wp512_update,
@@ -1143,7 +1145,9 @@ static struct shash_alg wp_algs[3] = { {
 		.cra_blocksize	=	WP512_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-}, {
+};
+
+static struct shash_alg wp256 = {
 	.digestsize	=	WP256_DIGEST_SIZE,
 	.init		=	wp512_init,
 	.update		=	wp512_update,
@@ -1155,16 +1159,39 @@ static struct shash_alg wp_algs[3] = { {
 		.cra_blocksize	=	WP512_BLOCK_SIZE,
 		.cra_module	=	THIS_MODULE,
 	}
-} };
+};
 
 static int __init wp512_mod_init(void)
 {
-	return crypto_register_shashes(wp_algs, ARRAY_SIZE(wp_algs));
+	int ret = 0;
+
+	ret = crypto_register_shash(&wp512);
+
+	if (ret < 0)
+		goto out;
+
+	ret = crypto_register_shash(&wp384);
+	if (ret < 0)
+	{
+		crypto_unregister_shash(&wp512);
+		goto out;
+	}
+
+	ret = crypto_register_shash(&wp256);
+	if (ret < 0)
+	{
+		crypto_unregister_shash(&wp512);
+		crypto_unregister_shash(&wp384);
+	}
+out:
+	return ret;
 }
 
 static void __exit wp512_mod_fini(void)
 {
-	crypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));
+	crypto_unregister_shash(&wp512);
+	crypto_unregister_shash(&wp384);
+	crypto_unregister_shash(&wp256);
 }
 
 MODULE_ALIAS("wp384");
-- 
1.7.5.4

