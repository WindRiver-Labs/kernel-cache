From 8bd5b074477d1defbf864efe2d87d9ef393d8257 Mon Sep 17 00:00:00 2001
From: Igor Patrik <igorp@marvell.com>
Date: Wed, 9 Oct 2013 09:47:22 +0200
Subject: [PATCH 1008/1825] ipc: axp: Initial support for freeRTOS IPC

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 0bbe9c5ff7fe311e72ec302fc4379fa373dfa9d6

        Added linux_freertos layers for IPC.
                beside to AMP kernel to kernel(linux_amp) layers.
        Added defconfig define and support in makefiles
                this define not depent on AMP stuff, just enable CONFIG_MV_IPC_FREERTOS_DRIVER in smp defconfig.

Change-Id: I9b1a16190532fda49d2fcbb5c82ad09d5ddca926
Signed-off-by: Igor Patrik <igorp@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3642
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/include/asm/entry-macro-multi.S           |    2 +-
 arch/arm/mach-armadaxp/Makefile                    |    3 +-
 arch/arm/mach-armadaxp/core.c                      |    5 +-
 arch/arm/plat-armada/Kconfig                       |   10 +
 .../arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile |    8 +
 .../mv_ipc/linux_freertos/ipc_demo.c               |  207 ++++++++++++++++++++
 .../mv_ipc/linux_freertos/mv_ipc_common.c          |  172 ++++++++++++++++
 .../mv_ipc/linux_freertos/mv_ipc_common.h          |   77 ++++++++
 .../mv_ipc/linux_freertos/mv_ipc_doorbell.c        |  198 +++++++++++++++++++
 .../mv_ipc/linux_freertos/mv_ipc_doorbell.h        |   39 ++++
 .../mv_ipc/linux_freertos/mv_ipc_node.h            |   74 +++++++
 .../mv_ipc/linux_freertos/mv_ipc_os.c              |  181 +++++++++++++++++
 .../mv_ipc/linux_freertos/mv_ipc_os.h              |   40 ++++
 .../mv_ipc/linux_freertos/mv_ipc_poll.c            |  186 ++++++++++++++++++
 .../mv_ipc/linux_freertos/mv_ipc_poll.h            |   39 ++++
 15 files changed, 1235 insertions(+), 6 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/ipc_demo.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_node.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.h

diff --git a/arch/arm/include/asm/entry-macro-multi.S b/arch/arm/include/asm/entry-macro-multi.S
index 9719368..ea140e8 100644
--- a/arch/arm/include/asm/entry-macro-multi.S
+++ b/arch/arm/include/asm/entry-macro-multi.S
@@ -20,7 +20,7 @@
 	 * this macro assumes that irqstat (r2) and base (r6) are
 	 * preserved from get_irqnr_and_base above
 	 */
-#ifdef CONFIG_MV_IPC_LINUX_AMP_DRIVER
+#if (defined CONFIG_MV_IPC_LINUX_AMP_DRIVER) || (defined CONFIG_MV_IPC_FREERTOS_DRIVER)
 	test_for_ipc r0, r2, r6, lr
 	movne   r1, sp
 	adrne   lr, BSYM(1b)
diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index 3280c4c..d7126de 100755
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -103,7 +103,8 @@ obj-$(CONFIG_ERROR_HANDLING)		   += $(LSP_ERR_DIR)/mv_error.o
 
 obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
 obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
-obj-$(CONFIG_MV_IPC_LINUX_AMP_DRIVER)		+= $(COMMON_DIR)/mvIpc.o $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_LINUX_AMP_DRIVER)	+= $(COMMON_DIR)/mvIpc.o $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_FREERTOS_DRIVER)	+= $(COMMON_DIR)/mvIpc.o $(PLAT_DRIVERS)/mv_ipc/
 obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
 #obj-y					+= $(PLAT_DRIVERS)/mv_btns/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 92014bd..57d0964 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -410,7 +410,7 @@ static int __init mv_shared_mem_setup(char *s)
 __setup("mv_sh_mem=", mv_shared_mem_setup);
 #endif /* CONFIG_MV_AMP_ENABLE */
 
-#ifdef CONFIG_MV_IPC_LINUX_AMP_DRIVER
+#if (defined CONFIG_MV_IPC_LINUX_AMP_DRIVER) || (defined CONFIG_MV_IPC_FREERTOS_DRIVER)
 int ipc_target_cpu;
 static int __init mv_ipc_setup(char *s)
 {
@@ -432,9 +432,6 @@ static int __init mv_ipc_setup(char *s)
 __setup("mv_ipc=", mv_ipc_setup);
 #endif
 
-
-
-
 void __init armadaxp_setup_cpu_mbus(void)
 {
 	int i;
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 272b433..c43b0a4 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -179,6 +179,16 @@ config MV_INCLUDE_SWITCH
 
 endmenu
 
+menu "FreeRTOS IPC options"
+
+config MV_IPC_FREERTOS_DRIVER
+        bool "Enable freeRTOS IPC support"
+	depends on (ARMADA_XP || MV78XX0 || AVANTA_LP) && \
+		(!ARMADA_XP_REV_Z1) && (SMP) && (!MV_ETH_BM) && \
+		(!ARMADAXP_USE_IRQ_INDIRECT_MODE)
+	default n
+
+endmenu
 
 menu "AMP options"
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
index 94d6267..b5191c4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
@@ -1,9 +1,17 @@
 #
 # Makefile for the Marvell IPC driver
 #
+
 ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
+#kernel<->kernel AMP mode
 obj-$(CONFIG_MV_IPC_LINUX_AMP_DRIVER) += linux_amp/mv_ipc_os.o linux_amp/mv_ipc_doorbell.o \
 								linux_amp/mv_ipc_poll.o linux_amp/mv_ipc_common.o
+
+#kernel<->freeRTOS AMP mode
+obj-$(CONFIG_MV_IPC_FREERTOS_DRIVER) += linux_freertos/mv_ipc_os.o linux_freertos/mv_ipc_doorbell.o \
+								linux_freertos/mv_ipc_poll.o linux_freertos/mv_ipc_common.o \
+								linux_freertos/ipc_demo.o
+
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/ipc_demo.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/ipc_demo.c
new file mode 100644
index 0000000..c245f26
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/ipc_demo.c
@@ -0,0 +1,207 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+
+#include "include/mach/smp.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvStack.h"
+#include "mvIpc.h"
+#include "mv_ipc_common.h"
+#include "cpu/mvCpu.h"
+
+#define IPC_DEMO_LINK_ID		(0)
+#define IPC_DEMO_CHANNEL_ID		(1)
+#define IPC_MAX_MSG_SIZE		(128)
+
+#define ipc_attach_chn(linkId, chnId, cpu, ret)	mvIpcAttachChannel(linkId, chnId, cpu, ret)
+#define ipc_dettach_chn(linkId, chnId)			mvIpcDettachChannel(linkId, chnId)
+#define ipc_close_chn(linkId, chnId)			mvIpcCloseChannel(linkId, chnId)
+#define ipc_tx_msg(linkId, chnId, msg)			mvIpcTxMsg(linkId, chnId, msg)
+#define ipc_tx_ready(linkId, chnId)				mvIpcIsTxReady(linkId, chnId)
+#define ipc_release_msg(linkId, chnId, msg)		mvIpcReleaseMsg(linkId, chnId, msg)
+#define ipc_sh_malloc(linkId, size)				mvIpcShmemMalloc(linkId, size)
+#define ipc_open_chn(linkId, chnId, rx_clbk)	mvIpcOpenChannel(linkId, chnId, rx_clbk)
+#define ipc_enable_chn_rx(linkId, chnId)		mvIpcEnableChnRx(linkId, chnId)
+
+char *ipc_demo_msg_buffer;
+
+/************************************************************************
+ * ipc_demo_send()							*
+ * send a message to target cpu						*
+ ************************************************************************/
+int ipc_demo_send(const char *data)
+{
+	MV_STATUS status;
+	MV_IPC_MSG msg;
+
+	if (ipc_demo_msg_buffer == NULL) {
+		printk(KERN_ERR "IPC DEMO: Message buffer not initialized.\n");
+		return -1;
+	}
+
+	strncpy(ipc_demo_msg_buffer, data, IPC_MAX_MSG_SIZE);
+	ipc_demo_msg_buffer[IPC_MAX_MSG_SIZE - 1] = 0;
+
+	msg.type	= 0;
+	msg.ptr		= mvIpcOsVirt2Phys(IPC_DEMO_LINK_ID, ipc_demo_msg_buffer);
+	msg.size	= strlen(ipc_demo_msg_buffer);
+	msg.value	= mvIpcWhoAmI();
+
+	status = ipc_tx_msg(IPC_DEMO_LINK_ID, IPC_DEMO_CHANNEL_ID, &msg);
+
+	if (status == MV_ERROR)
+		printk(KERN_INFO "IPC DEMO: TX queue busy\n");
+
+	return (int)status;
+}
+
+/************************************************************************
+ * ipc_demo_rx()							*
+ *   demo receive function: called from IPC driver on msg arrival	*
+ ************************************************************************/
+int ipc_demo_rx(MV_IPC_MSG *msg)
+{
+	char *ptr_virt;
+	char response[IPC_MAX_MSG_SIZE];
+	int res_pos;
+
+	ptr_virt = (char *)mvIpcOsPhys2Virt(IPC_DEMO_LINK_ID, msg->ptr);
+	if (ptr_virt == 0)
+		printk(KERN_INFO "IPC DEMO: Unable to map shared buf ptr 0x%08x\n",
+				(u32)msg->ptr);
+
+	printk(KERN_INFO "IPC DEMO: Message from CPU%d \"%s\"\n", msg->value, ptr_virt);
+
+	/* Send response */
+	res_pos = snprintf(response, IPC_MAX_MSG_SIZE,
+			"Received message:", msg->value);
+
+	mvIpcReleaseMsg(IPC_DEMO_LINK_ID, IPC_DEMO_CHANNEL_ID, msg);
+
+	strncpy(&response[res_pos], ptr_virt, IPC_MAX_MSG_SIZE - res_pos);
+	response[IPC_MAX_MSG_SIZE - 1] = 0;
+
+	ipc_demo_send(response);
+
+	return 0;
+}
+
+/************************************************************************
+ * ipc_demo_init()							*
+ *   Initialize IPC demo					*
+ ************************************************************************/
+static int ipc_demo_init(void *platform_data)
+{
+	MV_STATUS status;
+	int attached;
+
+	/* Initialize IPC driver */
+	status = ipc_open_chn(IPC_DEMO_LINK_ID, IPC_DEMO_CHANNEL_ID, ipc_demo_rx);
+	if (status != MV_OK) {
+		printk(KERN_INFO "IPC DEMO: Failed to open IPC channel %d",
+				IPC_DEMO_CHANNEL_ID);
+		return -1;
+	}
+
+	status = ipc_attach_chn(IPC_DEMO_LINK_ID, IPC_DEMO_CHANNEL_ID,
+			mvIpcGetlinkRemoteNodeId(IPC_DEMO_LINK_ID), &attached);
+	if (status != MV_OK) {
+		printk(KERN_INFO "IPC DEMO: Attach returned error for target CPU %d\n",
+				mvIpcGetlinkRemoteNodeId(IPC_DEMO_LINK_ID));
+		return -1;
+	}
+
+	/* Enable channel for RX */
+	ipc_enable_chn_rx(IPC_DEMO_LINK_ID, IPC_DEMO_CHANNEL_ID);
+
+	printk(KERN_INFO "IPC DEMO: channel %d to cpu %d attached succesfully.\n",
+			 IPC_DEMO_CHANNEL_ID, mvIpcGetlinkRemoteNodeId(IPC_DEMO_LINK_ID));
+
+	/* Allocate space in shared memory for message buffer */
+	ipc_demo_msg_buffer = (char *)ipc_sh_malloc(IPC_DEMO_LINK_ID, IPC_MAX_MSG_SIZE);
+
+	return 0;
+}
+
+/************************************************************************
+ * ipc_demo_cleanup_module()						*
+ *   free IPC demo							*
+ ************************************************************************/
+static void __exit ipc_demo_cleanup_module(void)
+{
+
+}
+
+/************************************************************************
+ *	ipc_demo_probe()				*
+ *	probe IPC demo					*
+ ************************************************************************/
+static int ipc_demo_probe(struct platform_device *pdev)
+{
+	return ipc_demo_init(pdev->dev.platform_data);
+}
+
+/************************************************************************
+ * ipc_demo_shutdown()					*
+ *   probe IPC demo						*
+ ************************************************************************/
+static void ipc_demo_shutdown(struct platform_device *pdev)
+{
+	printk(KERN_INFO "Shutting Down Marvell IPC Demo\n");
+}
+
+/************************************************************************
+ * ipc_demo_remove()					*
+ *   probe IPC demo						*
+ ************************************************************************/
+static int ipc_demo_remove(struct platform_device *pdev)
+{
+	printk(KERN_INFO "Removing Marvell IPC Demo\n");
+	return 0;
+}
+
+
+static struct platform_driver ipc_demo_driver = {
+	.probe    = ipc_demo_probe,
+	.remove   = ipc_demo_remove,
+	.shutdown = ipc_demo_shutdown,
+	.driver = {
+		.name = "ipc_demo",
+	},
+};
+
+/************************************************************************
+ * ipc_demo_init_module()						*
+ *   register IPC demo							*
+ ************************************************************************/
+static int __init ipc_demo_init_module(void)
+{
+	platform_driver_register(&ipc_demo_driver);
+	return ipc_demo_init(&ipc_demo_driver);
+}
+
+module_init(ipc_demo_init_module);
+module_exit(ipc_demo_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter Processor Communication Demo");
+MODULE_AUTHOR("Michal Mazur <arg@semihalf.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.c
new file mode 100644
index 0000000..928ebe6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.c
@@ -0,0 +1,172 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "mvOs.h"
+
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "mv_ipc_os.h"
+#include "mvIpc.h"
+
+MV_IPC_LINK_INFO mv_ipc_link_info_array[MV_IPC_LINKS_NUM] = MV_IPC_LINK_INFO_TABLE;
+MV_IPC_CHN_INFO mv_ipc_chn_info_array[MV_IPC_LINKS_NUM][MV_IPC_CHN_NUM_MAX] =
+	MV_IPC_CHN_INFO_TABLE;
+MV_VOID *hwLayerAPI[MV_IPC_HW_LAYERS_NUM][2] = MV_IPC_HW_LAYER_API_TABLE;
+
+MV_U32 mv_ipc_master_free_reg_percent[MV_IPC_LINKS_NUM] =
+	MV_IPC_MASTER_FREE_REGION_PERCENT_TBL;
+
+/*#define IPC_DRV_DEBUG*/
+
+/*Return local node ID*/
+MV_U32 mvIpcWhoAmI(void)
+{
+	return  MV_IPC_NODE_ID;
+}
+
+/*Return number of link in local node*/
+MV_U32 mvIpcGetNumOfLinks(void)
+{
+	return MV_IPC_LINKS_NUM;
+}
+
+/*Return number of channels for the link*/
+MV_U32 mvIpcChnNum(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->numOfChannels;
+}
+
+/*Return max number of channels for all links*/
+MV_U32 mvIpcChnNumMax(void)
+{
+	return MV_IPC_CHN_NUM_MAX;
+}
+
+/*Return true if local node is a master for the link*/
+MV_BOOL mvIpcGetlinkMaster(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+	return str->isMaster;
+}
+
+/*Return remote node ID for the link*/
+MV_U32 mvIpcGetlinkRemoteNodeId(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+	return str->remoteNodeId;
+}
+
+/*Return Shared memory base address*/
+MV_VOID *mvIpcGetShmemAddr(MV_U32 link)
+{
+	return mvIpcOsGetVirtBase(link);
+}
+
+/*Return Shared memory Phys base size*/
+MV_U32 mvIpcGetShmemBaseAddr(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->shmemAddr;
+}
+
+/*Return Shared memory Virtual base size*/
+MV_U32 mvIpcGetShmemSize(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->shmemSize;
+}
+
+/*Return queue size*/
+MV_U32 mvIpcGetChnQueueSize(MV_U32 link, MV_U32 chn)
+{
+	MV_IPC_CHN_INFO *str = &mv_ipc_chn_info_array[link][chn];
+
+	return str->queueSize;
+}
+
+/*Return HW Layer ID */
+MV_U32 mvIpcGetHwLayerId(MV_U32 link)
+{
+	return MV_IPC_HW_LAYER_ACTUAL;
+}
+
+/*Return pointer to Send Trigger function*/
+MV_IPC_SEND_TRIGGER mvIpcGetChnTxHwPtr(MV_U32 link)
+{
+	return hwLayerAPI[mvIpcGetHwLayerId(link)][0];
+}
+
+/*Return pointer to Register channel function*/
+MV_IPC_RX_CHANNEL_REGISTER mvIpcGetChnRxHwPtr(MV_U32 link)
+{
+	return hwLayerAPI[mvIpcGetHwLayerId(link)][1];
+}
+
+/*Return percent of free memory division between master and slave*/
+MV_U32 mvIpcGetFreeMemMasterPercent(MV_U32 link)
+{
+	return mv_ipc_master_free_reg_percent[link];
+}
+
+/*Do init sequence*/
+MV_STATUS mvIpcCommonInit(void)
+{
+	MV_U32 link;
+	MV_STATUS status;
+
+#ifdef IPC_DRV_DEBUG
+	if (CONFIG_MV_DRAM_BASE == 0x0) {
+		printk(KERN_INFO "---------------------Delay to async boot sequence----------\n");
+		mvOsDelay(1000);
+	}
+#endif
+
+	/* Initialize shared memory*/
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++)
+		mvIpcOsSharedStack(link, mvIpcGetShmemBaseAddr(link), mvIpcGetShmemSize(link));
+
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++) {
+		mvIpcDoorbellInit(link);
+		mvIpcPollInit(link);
+	}
+
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++) {
+		status = mvIpcLinkStart(link);
+		if (status != MV_OK) {
+			printk(KERN_ERR "IPC: IPC HAL %d initialization failed\n", 0);
+			return status;
+		}
+	}
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.h
new file mode 100644
index 0000000..c6cf3ac
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_common.h
@@ -0,0 +1,77 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_common_h
+#define __mv_ipc_common_h
+
+#include "mv_ipc_node.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_os.h"
+
+typedef struct __ipc_link_info_struct {
+	MV_U32 numOfChannels;
+	MV_BOOL isMaster;
+	MV_U32 remoteNodeId;
+	MV_VOID *shmemVirtAddr;
+	MV_U32 shmemAddr;
+	MV_U32 shmemSize;
+} MV_IPC_LINK_INFO;
+
+typedef struct __ipc_chn_info_struct {
+	MV_U32 queueSize;
+} MV_IPC_CHN_INFO;
+
+/*Interrupt/Polling modes*/
+enum {
+	MV_IPC_HW_LAYER_POLLING_ACTIVE  = 0,
+	MV_IPC_HW_LAYER_INTERRUPT_ISR,
+	MV_IPC_HW_LAYER_POLLING_PASSIVE,
+};
+
+MV_U32 mvIpcWhoAmI(void);
+MV_U32 mvIpcGetNumOfLinks(void);
+MV_U32 mvIpcChnNum(MV_U32 link);
+MV_U32 mvIpcChnNumMax(void);
+MV_BOOL mvIpcGetlinkMaster(MV_U32 link);
+MV_U32 mvIpcGetlinkRemoteNodeId(MV_U32 link);
+MV_VOID *mvIpcGetShmemAddr(MV_U32 link);
+MV_U32 mvIpcGetShmemBaseAddr(MV_U32 link);
+MV_U32 mvIpcGetShmemSize(MV_U32 link);
+MV_U32 mvIpcGetChnQueueSize(MV_U32 link, MV_U32 chn);
+MV_U32 mvIpcGetHwLayerId(MV_U32 link);
+MV_IPC_SEND_TRIGGER mvIpcGetChnTxHwPtr(MV_U32 link);
+MV_IPC_RX_CHANNEL_REGISTER mvIpcGetChnRxHwPtr(MV_U32 link);
+MV_U32 mvIpcGetFreeMemMasterPercent(MV_U32 link);
+MV_STATUS mvIpcCommonInit(void);
+
+#endif /*__mv_ipc_common_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.c
new file mode 100644
index 0000000..67e62e5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.c
@@ -0,0 +1,198 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "include/mach/smp.h"
+
+/*#define IPC_DRV_DEBUG*/
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+static MV_U8 **enabledChannels;
+MV_BOOL	mvIpcDoorbellInitDone = MV_FALSE;
+
+/***********************************************************************************
+ * mvIpcDoorbellInit
+ *
+ * DESCRIPTION:
+ *              Init the structures
+ *
+ * INPUT:
+ *		None
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		None
+ *
+ ************************************************************************************/
+MV_VOID mvIpcDoorbellInit(MV_U32 link)
+{
+	if (NULL == enabledChannels)
+		enabledChannels = mvOsMalloc(sizeof(MV_U8 *) * mvIpcGetNumOfLinks());
+
+	if (NULL == enabledChannels)
+		ipc_debug(KERN_INFO "IPC Doorbell: Channels array malloc fail\n");
+
+	enabledChannels[link] = mvOsMalloc(sizeof(MV_U8) * mvIpcChnNumMax());
+	mvOsMemset(enabledChannels[link], '\0', mvIpcChnNumMax());
+
+	/*request_irq for doorbell done in assembly*/
+
+	mvIpcDoorbellInitDone = MV_TRUE;
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcSendDoorbell
+ *
+ * DESCRIPTION:
+ *              Send an IPC doorbell to target CPU
+ *
+ * INPUT:
+ *		cpuId - the id of the target CPU
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcSendDoorbell(MV_U32 linkId, MV_U32 chnId)
+{
+	MV_U32 doorbellNum;
+	MV_U32 cpuBitMask;
+
+	cpuBitMask   = (1 << 1/*mvIpcGetlinkRemoteNodeId(linkId)*/);
+	doorbellNum  = IPC_BASE_DOORBELL + chnId;
+
+	/* Use private doorbell 15 for IPC */
+	MV_REG_WRITE(CPU_SW_TRIG_IRQ, (cpuBitMask << 8) | doorbellNum);
+
+	return;
+}
+
+/***********************************************************************************
+ * registerChnInISRDoorbell
+ *
+ * DESCRIPTION:
+ *		Enable/disable doorbell for the given channel
+ *
+ * INPUT:
+ *		linkId - Link id
+ *		chnId -  Channel id
+ *		enable - Disable or enable the interrupt
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID registerChnInISRDoorbell(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable)
+{
+	if (MV_TRUE == enable) {
+		enabledChannels[linkId][chnId] = 1;
+		/* Set the doorbell corresponding to channel */
+		MV_REG_BIT_SET(CPU_DOORBELL_IN_MASK_REG, (1));
+	} else {
+		enabledChannels[linkId][chnId] = 0;
+		/* Reset the doorbell corresponding to channel */
+		MV_REG_BIT_RESET(CPU_DOORBELL_IN_MASK_REG, (1));
+	}
+}
+
+/*******************************************************************************
+ * do_ipc_rx_irq()                                                             *
+ *  rx interrupt service routine                                               *
+ ******************************************************************************/
+void do_ipc_rx_irq(int irq, struct pt_regs *regs)
+{
+	MV_U32 linkId, chnId;
+	int read_msgs = IPC_RX_MAX_MSGS_PER_ISR;
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	if (mvIpcDoorbellInitDone != MV_TRUE)
+		return;
+
+	ipc_debug(KERN_INFO "IPC Doorbell: RX callback. got irq no = %d\n", irq);
+
+	irq_enter();
+	/*Disable interrpt*/
+	MV_REG_BIT_RESET(CPU_DOORBELL_IN_MASK_REG, (1));
+
+	/*NOTE:
+	This ISR may be customised by user application requerements to make it more efficient*/
+
+	/* Scan all rx flags*/
+	for (linkId = 0; linkId < mvIpcGetNumOfLinks(); linkId++) {
+		for (chnId = 0; chnId < mvIpcChnNum(linkId); chnId++) {
+			/*Check if RX flag raised*/
+			if ((enabledChannels[linkId][chnId] == 1) &&
+			    (mvIpcRxMsgFlagCheck(linkId, chnId) == MV_TRUE)) {
+				/*If ready ti RX, start get the messages*/
+				ipc_debug(KERN_INFO "Got message in channel %d\n", chnId);
+				while (read_msgs) {
+					if (mvIpcRxMsg(linkId, chnId) != MV_OK)
+						break;
+					read_msgs--;
+				}
+			}
+		}
+	}
+
+	/*Enable interrpt*/
+	MV_REG_BIT_SET(CPU_DOORBELL_IN_MASK_REG, (1));
+	irq_exit();
+
+	if (read_msgs == IPC_RX_MAX_MSGS_PER_ISR)
+		ipc_debug(KERN_WARNING "IPC: Received interrupt with no messages\n");
+
+	set_irq_regs(old_regs);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.h
new file mode 100644
index 0000000..51aebc9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_doorbell.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_doorbell_h
+#define __mv_ipc_doorbell_h
+
+#define IPC_BASE_DOORBELL                       12
+#define IPC_RX_MAX_MSGS_PER_ISR         50
+
+MV_VOID mvIpcSendDoorbell(MV_U32 linkId, MV_U32 chnId);
+MV_VOID registerChnInISRDoorbell(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable);
+MV_VOID mvIpcDoorbellInit(MV_U32 linkId);
+
+#endif /*__mv_ipc_doorbell_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_node.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_node.h
new file mode 100644
index 0000000..46c7b9d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_node.h
@@ -0,0 +1,74 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_node_h
+#define __mv_ipc_node_h
+
+#include "mvTypes.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_poll.h"
+
+/*Unique ID of the IPC node, all nodes should be numbered sequentially from 0*/
+#define MV_IPC_NODE_ID 0
+
+/*Number of links established with other nodes*/
+#define MV_IPC_LINKS_NUM 1
+
+#define MV_IPC_CHN_NUM_MAX 4
+/*Sizes of TX/RX queues for each channel (slave node doesnt know the sizes)*/
+/*For slave set queue size to 0, the value will be ignored*/
+/*hw Layer indexes,*/
+#define MV_IPC_CHN_INFO_TABLE  {\
+	{ {16}, {32}, {16}, {32} }, \
+};
+
+#define MV_IPC_HW_LAYER_ACTUAL		MV_IPC_HW_LAYER_POLLING_ACTIVE
+/*#define MV_IPC_HW_LAYER_ACTUAL	MV_IPC_HW_LAYER_INTERRUPT_ISR*/
+
+#define MV_IPC_HW_LAYERS_NUM		2
+/*HW layers function, send trigger is TX done signal,
+register channel is interrupt and channel enable function*/
+#define MV_IPC_HW_LAYER_API_TABLE  {\
+{mvIpcSendTriggerPoll, registerChnInISRPoll},	 /*MV_IPC_HW_LAYER_POLLING_ACTIVE*/\
+{mvIpcSendDoorbell, registerChnInISRDoorbell},   /*MV_IPC_HW_LAYER_INTERRUPT_ISR*/\
+};
+
+/*Link info array*/
+	/*numOfChn		isMaster, remoteNodeId, shmemAddr,		shmemSize*/
+#define MV_IPC_LINK_INFO_TABLE {\
+	{4,			MV_TRUE,	2,	NULL,		0x60000000,		0x100000},\
+};
+
+
+/*Division of free malloc area between master and slave*/
+#define MV_IPC_MASTER_FREE_REGION_PERCENT_TBL { \
+	50		\
+};
+
+
+#endif /*__mv_ipc_node_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.c
new file mode 100644
index 0000000..e0e4e3e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.c
@@ -0,0 +1,181 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_os.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_poll.h"
+#include "include/mach/smp.h"
+
+unsigned int mv_ipc_sh_mem_base[MV_IPC_LINKS_NUM], mv_ipc_sh_mem_size[MV_IPC_LINKS_NUM];
+
+void   *sh_virt_base[MV_IPC_LINKS_NUM];
+unsigned int virt_phys_offset[MV_IPC_LINKS_NUM];
+bool ipcInitialized = 0;
+
+MV_U8 **enabledChannels;
+
+/*#define IPC_DRV_DEBUG*/
+#define IPC_DRV_DEBUG
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+/*******************************************************************************
+ * ipc_init_shared_stack()                                                     *
+ *   Initialize the shared stack used for communication
+ ******************************************************************************/
+int mvIpcOsSharedStack(unsigned int link, unsigned int sh_phys_base,
+		       unsigned int sh_mem_size)
+{
+	mv_ipc_sh_mem_base[link] = sh_phys_base;
+	mv_ipc_sh_mem_size[link] = sh_mem_size;
+
+	/* Map shared memory and initialize shared stack */
+	sh_virt_base[link]  = ioremap(sh_phys_base, sh_mem_size);
+	if (!sh_virt_base[link]) {
+		printk(KERN_ERR "IPC: Unable to map physical shared mem block (%#010x - %#010x)\n",
+		       sh_phys_base, sh_phys_base + sh_mem_size);
+		return 0;
+	}
+
+	virt_phys_offset[link] = (unsigned int)sh_virt_base[link] - sh_phys_base;
+
+	ipc_debug(KERN_INFO "IPC: Remaped Shared memory PA %#010x to VA %#010x\n",
+		  (unsigned int)sh_phys_base, (unsigned int)sh_virt_base[link]);
+
+	return 1;
+}
+
+/*******************************************************************************
+ * ipc_virt_to_phys()                                                          *
+ *   address translation for shared stack
+ ******************************************************************************/
+void *mvIpcOsVirt2Phys(unsigned int link, void *virt_addr)
+{
+	void *phys_addr = 0;
+
+	if ((virt_addr >= sh_virt_base[link]) && (virt_addr < (sh_virt_base[link] +
+							       mv_ipc_sh_mem_size[link])))
+		phys_addr = (void *)((unsigned int)virt_addr - virt_phys_offset[link]);
+
+	return phys_addr;
+}
+
+/*******************************************************************************
+ * ipc_phys_to_virt()                                                          *
+ *   address translation for shared stack
+ ******************************************************************************/
+void *mvIpcOsPhys2Virt(unsigned int link, void *phys_addr)
+{
+	void *virt_addr = 0;
+
+	if (((int)phys_addr >= mv_ipc_sh_mem_base[link]) &&
+			((int)phys_addr < (mv_ipc_sh_mem_base[link] + mv_ipc_sh_mem_size[link])))
+		virt_addr = (void *)((unsigned int)phys_addr + virt_phys_offset[link]);
+
+	return virt_addr;
+}
+
+/*******************************************************************************
+ * ipc_get_virt_base()                                                         *
+ *   address translation for base of shared stack
+ ******************************************************************************/
+void *mvIpcOsGetVirtBase(unsigned int link)
+{
+	return sh_virt_base[link];
+}
+
+/*******************************************************************************
+ * mvOsSync()                                                                  *
+ *   Barrier/ cache invalidate function
+ ******************************************************************************/
+void mvOsSync(void)
+{
+	dmb();
+}
+
+/*******************************************************************************
+ * ipc_init_module()                                                           *
+ *   intialize and register IPC driver interface                               *
+ ******************************************************************************/
+static int __init ipc_init_module(void)
+{
+	MV_STATUS status;
+
+	printk(KERN_INFO "IPC: Going to init driver\n");
+
+	status = mvIpcCommonInit();
+
+	ipcInitialized = 1;
+
+	printk(KERN_INFO "IPC: Driver initialized successfully\n");
+
+	return 0;
+}
+
+/*******************************************************************************
+ * ipc_cleanup_module()                                                        *
+ *   close IPC driver                                                          *
+ ******************************************************************************/
+static void __exit ipc_cleanup_module(void)
+{
+	ipcInitialized = 0;
+
+	mvIpcClose(0);
+
+	/* Unmap shared memory space */
+	iounmap(sh_virt_base[0]);
+}
+
+module_init(ipc_init_module);
+module_exit(ipc_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter Processor Communication (IPC) Driver");
+MODULE_AUTHOR("Yehuda Yitschak <yehuday@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.h
new file mode 100644
index 0000000..d4c3a00
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_os.h
@@ -0,0 +1,40 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_os_h
+#define __mv_ipc_os_h
+
+void *mvIpcOsGetVirtBase(unsigned int link);
+int mvIpcOsSharedStack(unsigned int link, unsigned int sh_phys_base,
+		       unsigned int sh_mem_size);
+void mvOsSync(void);
+
+void *mvIpcOsVirt2Phys(unsigned int link, void *virt_addr);
+void *mvIpcOsPhys2Virt(unsigned int link, void *phys_addr);
+
+#endif /*__mv_ipc_os_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.c
new file mode 100644
index 0000000..c931048
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.c
@@ -0,0 +1,186 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_poll.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "include/mach/smp.h"
+
+/*#define IPC_DRV_DEBUG*/
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+static MV_U8 **enabledChannels = NULL;
+struct timer_list poll_timer;
+void do_ipc_rx_poll(unsigned long);
+
+/***********************************************************************************
+ * mvIpcPollInit
+ *
+ * DESCRIPTION:
+ *              Init the structures
+ *
+ * INPUT:
+ *		None
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		None
+ *
+ ************************************************************************************/
+MV_VOID mvIpcPollInit(MV_U32 link)
+{
+	MV_U32 firstRunFlag = 0;
+
+	if (NULL == enabledChannels) {
+		enabledChannels = mvOsMalloc(sizeof(MV_U8 *) * mvIpcGetNumOfLinks());
+		firstRunFlag = 1;
+	}
+	enabledChannels[link] = mvOsMalloc(sizeof(MV_U8) * mvIpcChnNumMax());
+	mvOsMemset(enabledChannels[link], '\0', mvIpcChnNumMax());
+
+	/*If passive polling mode, do not start timer event*/
+	if (mvIpcGetHwLayerId(link) == MV_IPC_HW_LAYER_POLLING_PASSIVE)
+		return;
+
+	/*If timer event started before, do not start timer event*/
+	if (firstRunFlag == 0)
+		return;
+
+	/*Start timer event*/
+	init_timer(&poll_timer);
+	poll_timer.function = do_ipc_rx_poll;
+	poll_timer.expires = jiffies + MV_IPC_POLL_PERIOD;
+	add_timer(&poll_timer);
+
+	/*TODO this timer mechanism working in 10ms resolution,
+	may be not good for real application*/
+
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcSendTriggerPoll
+ *
+ * DESCRIPTION:
+ *              Trigger placeholder for polling mode, do nothing
+ *
+ * INPUT:
+ *		cpuId - the id of the target CPU
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcSendTriggerPoll(MV_U32 linkId, MV_U32 chnId)
+{
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcEnableChnRx
+ *
+ * DESCRIPTION:
+ *		Unmasks the doorbell for the given channel
+ *
+ * INPUT:
+ *		irq - number of irq/doorbell to unmask
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID registerChnInISRPoll(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable)
+{
+	if (MV_TRUE == enable)
+		enabledChannels[linkId][chnId] = 1;
+	else
+		enabledChannels[linkId][chnId] = 0;
+}
+
+/*******************************************************************************
+ * do_ipc_rx_poll()                                                            *
+ *  rx polling service routine                                                 *
+ ******************************************************************************/
+void do_ipc_rx_poll(unsigned long data)
+{
+	MV_U32 linkId, chnId;
+	int read_msgs = IPC_RX_MAX_MSGS_PER_ISR;
+
+	ipc_debug(KERN_INFO "IPC: RX polling");
+
+	/*NOTE:
+	This ISR may be customised by user application requerements to make it more efficient*/
+
+	/* Scan all rx flags*/
+	for (linkId = 0; linkId < mvIpcGetNumOfLinks(); linkId++) {
+		for (chnId = 0; chnId < mvIpcChnNum(linkId); chnId++) {
+			/*Check if RX flag raised*/
+			if ((enabledChannels[linkId][chnId] == 1) &&
+			    (mvIpcRxMsgFlagCheck(linkId, chnId) == MV_TRUE)) {
+				/*If ready ti RX, start get the messages*/
+				ipc_debug(KERN_INFO "Got message in channel %d\n", chnId);
+				while (read_msgs) {
+					if (mvIpcRxMsg(linkId, chnId) != MV_OK)
+						break;
+					read_msgs--;
+				}
+			}
+		}
+	}
+
+	if (read_msgs == IPC_RX_MAX_MSGS_PER_ISR)
+		ipc_debug(KERN_WARNING "IPC: Polling loop with no messages\n");
+
+	poll_timer.expires = jiffies + MV_IPC_POLL_PERIOD;
+	add_timer(&poll_timer);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.h
new file mode 100644
index 0000000..d164abc
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_freertos/mv_ipc_poll.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_poll_h
+#define __mv_ipc_poll_h
+
+#define IPC_RX_MAX_MSGS_PER_ISR         50
+#define MV_IPC_POLL_PERIOD                      1
+
+MV_VOID mvIpcSendTriggerPoll(MV_U32 linkId, MV_U32 chnId);
+MV_VOID registerChnInISRPoll(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable);
+MV_VOID mvIpcPollInit(MV_U32 linkId);
+
+#endif /*__mv_ipc_poll_h*/
-- 
1.7.5.4

