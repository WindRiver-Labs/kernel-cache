From 3f0b7d11e0b298867954847336b641b63f4a6a78 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Tue, 17 Sep 2013 20:36:32 +0300
Subject: [PATCH 0992/1825] fix: alp: implement workaround for smp and pcie
 deadlock

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5142a88ea58b173600f7a527235ddfb3b687e079

        According to ARM, in order to avoid CPU deadlock when
	stressing I/O over PCIe in SMP mode with Cortex-A9,
        the following workarounds should be implemented:
        - Set PCIe I/O and memory windows to strongly ordered type
        - Avoid PL310 L2 sync operation: for PL310 rev >= r3p2 no
	need for explicit L2 sync by CPU as it is done by the HW

Change-Id: I558fc657946fe27151fbcd2b6343ce0a4f878400
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3513
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.c                  |   34 ++++++++++++++++++++++++
 arch/arm/mach-avantalp/include/mach/avantalp.h |    7 +++-
 arch/arm/mach-avantalp/include/mach/io.h       |    2 -
 arch/arm/mach-avantalp/sysmap.c                |    8 +++--
 arch/arm/mm/Kconfig                            |    2 +-
 arch/arm/mm/cache-l2x0.c                       |    4 +++
 6 files changed, 49 insertions(+), 8 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 0fda871..1d9b108 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -1409,6 +1409,40 @@ static void __init alp_l2x0_cache_init(void)
 #endif
 }
 
+static inline int is_alp_pcie_memory(u32 addr)
+{
+	switch (mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)) {
+	case 0:
+		return 0;
+	case 1:
+		return ((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE)));
+	case 2:
+		return (((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE))) || \
+			((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE))));
+	default:
+		pr_err("%s: Error: invalid number of PCIe ports\n", __func__);
+		return 0;
+	}
+}
+
+static void __iomem *alp_ioremap_caller(unsigned long addr, size_t size,
+					   unsigned int mtype, void *caller)
+{
+	if (!is_alp_pcie_memory(addr))
+		return __arm_ioremap_caller(addr, size, mtype, caller);
+
+	if ((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE)))
+		return (void __iomem *)(PEX0_MEM_VIRT_BASE + (addr - PEX0_MEM_PHYS_BASE));
+	else
+		return (void __iomem *)(PEX1_MEM_VIRT_BASE + (addr - PEX1_MEM_PHYS_BASE));
+
+}
+
+void __init alp_init_early(void)
+{
+	arch_ioremap_caller = alp_ioremap_caller;
+}
+
 static void __init alp_board_init(void)
 {
 	mvBoardEnvInit();
diff --git a/arch/arm/mach-avantalp/include/mach/avantalp.h b/arch/arm/mach-avantalp/include/mach/avantalp.h
index 37802cd..dd70877 100644
--- a/arch/arm/mach-avantalp/include/mach/avantalp.h
+++ b/arch/arm/mach-avantalp/include/mach/avantalp.h
@@ -32,9 +32,9 @@
 #define INTER_REGS_PHYS_BASE		0xF1000000
 
 #define PEX0_MEM_PHYS_BASE		0xE0000000
-#define PEX0_MEM_SIZE			_32M
+#define PEX0_MEM_SIZE			_16M
 #define PEX1_MEM_PHYS_BASE		0xE2000000
-#define PEX1_MEM_SIZE			_32M
+#define PEX1_MEM_SIZE			_16M
 
 #define PEX0_IO_PHYS_BASE		0xF1100000
 #define PEX0_IO_SIZE			_1M
@@ -93,6 +93,9 @@
 #define PEX0_IO_VIRT_BASE		0xFBC00000
 #define PEX1_IO_VIRT_BASE		0xFBD00000
 
+#define PEX0_MEM_VIRT_BASE		0xF3000000
+#define PEX1_MEM_VIRT_BASE		0xF5000000
+
 #define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
 
 #define USB3_REGS_VIRT_BASE		0xFBF00000
diff --git a/arch/arm/mach-avantalp/include/mach/io.h b/arch/arm/mach-avantalp/include/mach/io.h
index a442eb3..e6b5f1e 100644
--- a/arch/arm/mach-avantalp/include/mach/io.h
+++ b/arch/arm/mach-avantalp/include/mach/io.h
@@ -13,8 +13,6 @@
 #define IO_SPACE_REMAP 		PEX0_IO_PHYS_BASE
 
 #define __io(a)			((a) + PEX0_IO_VIRT_BASE)
-#define __mem_pci(a)		((unsigned long)(a))
-#define __mem_isa(a)		(a)
 
 void dma_io_sync(void);
 
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index 5162473..8bee0cf 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -22,9 +22,11 @@
 #include "ca9x2.h"
 
 struct map_desc MEM_TABLE[] = {
-	/* no use for pex mem remap */
-	{ PEX0_IO_VIRT_BASE,		__phys_to_pfn(PEX0_IO_PHYS_BASE),	SZ_1M,		MT_DEVICE },
-	{ PEX1_IO_VIRT_BASE,		__phys_to_pfn(PEX1_IO_PHYS_BASE),	SZ_1M,		MT_DEVICE },
+	{ PEX0_IO_VIRT_BASE,		__phys_to_pfn(PEX0_IO_PHYS_BASE),	SZ_1M,		MT_MEMORY_SO },
+	{ PEX1_IO_VIRT_BASE,		__phys_to_pfn(PEX1_IO_PHYS_BASE),	SZ_1M,		MT_MEMORY_SO },
+
+	{ PEX0_MEM_VIRT_BASE,		__phys_to_pfn(PEX0_MEM_PHYS_BASE),	SZ_16M,		MT_MEMORY_SO },
+	{ PEX1_MEM_VIRT_BASE,		__phys_to_pfn(PEX1_MEM_PHYS_BASE),	SZ_16M,		MT_MEMORY_SO },
 
 	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,		MT_DEVICE },
 	{ PP2_CPU0_VIRT_BASE,		__phys_to_pfn(PP2_CPU0_PHYS_BASE),	PP2_SIZE,	MT_DEVICE },
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index fa19dc8..0677f06 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1269,7 +1269,7 @@ config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller" if MIGHT_HAVE_CACHE_L2X0
 	default MIGHT_HAVE_CACHE_L2X0
 	select OUTER_CACHE
-	select OUTER_CACHE_SYNC
+	select OUTER_CACHE_SYNC if !ARCH_AVANTA_LP
 	help
 	  This option enables the L2x0 PrimeCell.
 
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index 6683e26..05559c3 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -121,6 +121,7 @@ static inline void l2x0_flush_line(unsigned long addr)
 }
 #endif
 
+#ifdef CONFIG_OUTER_CACHE_SYNC
 static void l2x0_cache_sync(void)
 {
 	unsigned long flags;
@@ -129,6 +130,7 @@ static void l2x0_cache_sync(void)
 	cache_sync();
 	raw_spin_unlock_irqrestore(&l2x0_lock, flags);
 }
+#endif
 
 static void __l2x0_flush_all(void)
 {
@@ -387,7 +389,9 @@ void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 	outer_cache.inv_range = l2x0_inv_range;
 	outer_cache.clean_range = l2x0_clean_range;
 	outer_cache.flush_range = l2x0_flush_range;
+#ifdef CONFIG_OUTER_CACHE_SYNC
 	outer_cache.sync = l2x0_cache_sync;
+#endif
 	outer_cache.flush_all = l2x0_flush_all;
 	outer_cache.inv_all = l2x0_inv_all;
 	outer_cache.disable = l2x0_disable;
-- 
1.7.5.4

