From d7f5adf2be5896521f64012ea95c29377e6906d4 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Wed, 17 Apr 2013 19:59:11 +0300
Subject: [PATCH 0596/1825] PPv2: sync + new GW driver support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 65db33b00bd435ce3745b6095286d6add3f8afac

Change-Id: Iea7719f05f1461a098e73876e92f3d9c41defbe6
Reviewed-on: http://vgitil04.il.marvell.com:8080/1604
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Makefile                    |    5 +-
 arch/arm/mach-avantalp/core.c                      |   66 ++
 arch/arm/plat-armada/common/mv802_3.h              |   33 +
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   33 +-
 .../mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c         |    8 +-
 .../mv_pp2/net_dev/mv_eth_pme_sysfs.c              |    6 +-
 .../mv_pp2/net_dev/mv_eth_pon_sysfs.c              |   26 +-
 .../mv_pp2/net_dev/mv_eth_rx_sysfs.c               |   41 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   73 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |  203 ++++-
 .../mv_pp2/net_dev/mv_eth_tx_sysfs.c               |   71 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |   17 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_fpga_sysfs.c  |  218 ----
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c      |  119 +++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c  | 1105 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h  |   63 ++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c   |  247 +++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  462 ++++++---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   81 +-
 .../mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c        |   63 +-
 .../mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c          |   26 +-
 .../mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c     |  219 ++++
 .../mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c      |  280 +++++
 .../mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c          |  105 +--
 .../plat-armada/mv_drivers_lsp/mv_switch/Makefile  |    2 +-
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |  702 +++++++++----
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |   31 +-
 .../mv_drivers_lsp/mv_switch/mv_switch_sysfs.c     |   44 +-
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h          |    6 +-
 .../plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c   |    2 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     |   27 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |   12 +-
 .../arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c |    4 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h |  101 ++-
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c |    5 +-
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h |   24 +
 .../plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h    |   44 +
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c |    8 +-
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h |   63 +-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c     |  560 +++++++++-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h     |   19 +-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c   |   78 ++-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h   |   30 +-
 include/linux/mv_switch.h                          |   93 ++
 44 files changed, 4403 insertions(+), 1022 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_fpga_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
 create mode 100644 include/linux/mv_switch.h

diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 7c369bf..17a85c3 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -153,9 +153,8 @@ obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_NET_DEV_DIR)/mv_netdev.o \
 					   $(LSP_NET_DEV_DIR)/mv_eth_qos_sysfs.o \
 					   $(LSP_NET_DEV_DIR)/mv_eth_pon_sysfs.o \
 					   $(LSP_NET_DEV_DIR)/mv_eth_pme_sysfs.o
-obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_NET_DEV_DIR)/mv_fpga_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_BM_DIR)/mv_eth_bm.o
-obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PRS_DIR)/prs_sysfs.o
+obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PRS_DIR)/prs_low_sysfs.o $(LSP_PRS_DIR)/prs_high_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_CLS_DIR)/cls_sysfs.o \
 					   $(LSP_CLS_DIR)/cls2_sysfs.o \
 					   $(LSP_CLS_DIR)/cls3_sysfs.o \
@@ -164,6 +163,8 @@ obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_CLS_DIR)/cls_mc_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PME_DIR)/pme_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PLCR_DIR)/plcr_sysfs.o
 obj-$(CONFIG_MV_ETH_TOOL)		+= $(LSP_NET_DEV_DIR)/mv_eth_tool.o
+obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_NET_DEV_DIR)/mv_mux_netdev.o $(LSP_NET_DEV_DIR)/mv_mux_sysfs.o
+obj-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(LSP_NET_DEV_DIR)/mv_gw_mgr.o
 endif
 
 obj-$(CONFIG_MV_INCLUDE_GIG_ETH)	+= $(LSP_PHY_DIR)/phy_sysfs.o
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index e383783..200aa20 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -67,6 +67,10 @@
 #include <linux/mv_pp2.h>
 #endif
 
+#if defined(CONFIG_MV_ETH_SWITCH)
+#include <linux/mv_switch.h>
+#endif
+
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "ctrlEnv/mvCtrlEnvRegs.h"
 #include "mvSysEthPhyApi.h"
@@ -676,11 +680,73 @@ static void __init eth_init(void)
 
 #endif /* CONFIG_MV_ETHERNET */
 
+#ifdef CONFIG_MV_ETH_SWITCH
+static void mv_switch_pdev_register(struct platform_device *pdev)
+{
+	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
+
+	/* check if switch is connected to GBE port */
+	if (mvBoardSwitchConnectedPortGet(plat_data->gbe_port) == -1)
+		return;
+
+	/* get board configuration */
+	plat_data->phy_addr = mvBoardPhyAddrGet(plat_data->gbe_port);
+	plat_data->switch_cpu_port = mvBoardSwitchCpuPortGet(plat_data->index);
+	plat_data->smi_scan_mode = mvBoardSmiScanModeGet(plat_data->index);
+	plat_data->qsgmii_module = 0; /* not relevant for alp */
+	plat_data->gephy_on_port = mvBoardGePhySwitchPortGet();
+	plat_data->rgmiia_on_port = mvBoardRgmiiASwitchPortGet();
+	plat_data->switch_irq = mvBoardSwitchIrqGet();
+
+	platform_device_register(pdev);
+}
+
+static struct resource mv_switch0_resources[] = {
+        {
+                .start          = 0,
+                .end            = 0,
+                .flags          = IORESOURCE_IRQ,
+        },
+};
+
+static struct mv_switch_pdata mv_switch0_plat_data = {
+	.index = 0,
+	.phy_addr = -1,
+	.gbe_port = 0,
+	.gephy_on_port = -1,
+	.switch_cpu_port = 5,
+	.tag_mode = MV_TAG_TYPE_DSA,
+        .preset = MV_PRESET_SINGLE_VLAN,
+	.vid = 0,
+	.port_mask = 0x3f,
+	.connected_port_mask = 0x1e,
+	.mtu = 1500,
+};
+
+static struct platform_device mv_switch0_plat_dev = {
+        .name           = MV_SWITCH_SOHO_NAME,
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(mv_switch0_resources),
+        .resource       = mv_switch0_resources,
+        .dev            = {
+                .platform_data = &mv_switch0_plat_data,
+        },
+};
+
+static void __init switch_init(void)
+{
+	mv_switch_pdev_register(&mv_switch0_plat_dev);
+}
+#endif /* CONFIG_MV_ETH_SWITCH */
+
 static void alp_init_eth(void)
 {
 #ifdef CONFIG_MV_ETHERNET
 	mvSysEthPhyInit();
 	eth_init();
+#ifdef CONFIG_MV_ETH_SWITCH
+	switch_init();
+#endif
 #endif
 }
 
diff --git a/arch/arm/plat-armada/common/mv802_3.h b/arch/arm/plat-armada/common/mv802_3.h
index 1019660..85637c8 100644
--- a/arch/arm/plat-armada/common/mv802_3.h
+++ b/arch/arm/plat-armada/common/mv802_3.h
@@ -71,8 +71,41 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Defines */
 #define MV_MAX_ETH_DATA     1500
 #define MV_ETH_MH_SIZE      2
+#define MV_ETH_DSA_SIZE     4
+#define MV_ETH_EDSA_SIZE    8
+#define MV_ETH_VLAN_SIZE    4
 #define MV_ETH_CRC_SIZE     4
 
+/* Marvell tag types */
+typedef enum {
+	MV_TAG_TYPE_NONE = 0,
+	MV_TAG_TYPE_MH   = 1,
+	MV_TAG_TYPE_DSA  = 2,
+	MV_TAG_TYPE_EDSA = 3,
+	MV_TAG_TYPE_VLAN = 4,
+	MV_TAG_TYPE_LAST = 5
+} MV_TAG_TYPE;
+
+typedef union mv_tag {
+	MV_U32 edsa[2];
+	MV_U32 dsa;
+	MV_U32 vlan;
+	MV_U16 mh;
+} MV_TAG;
+
+typedef struct mv_mux_tag {
+	MV_TAG_TYPE tag_type;
+	MV_TAG      tx_tag;
+	MV_TAG      rx_tag_ptrn;
+	MV_TAG      rx_tag_mask;
+} MV_MUX_TAG;
+
+typedef enum {
+	MV_PRESET_TRANSPARENT    = 0,
+	MV_PRESET_SINGLE_VLAN    = 1,
+	MV_PRESET_PER_PORT_VLAN  = 2,
+} MV_SWITCH_PRESET_TYPE;
+
 /* 802.3 types */
 #define MV_IP_TYPE                  0x0800
 #define MV_IP_ARP_TYPE              0x0806
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index e13c5c1..0a10b05 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -1,30 +1,22 @@
-if MV_ETH_PP2
-
-config MV_ETH_PORTS_NUM
-	int "Number of Marvell GbE ports"
-	default 4
-	help
-	  Number of Marvell GbE ports supported by NETA driver
-
 config MV_ETH_PP2_CLS2
 	bool
-	prompt "cls engine 2" if (0)
 	default y
+	---help---
 
 config MV_ETH_PP2_CLS3
 	bool
-	prompt "cls engine 3" if (0)
 	default y
+	---help---
 
 config MV_ETH_PP2_CLS4
 	bool
-	prompt "cls engine 4" if (0)
 	default y
+	---help---
 
 config MV_ETH_PP2_CLS_MC
 	bool
-	prompt "cls mc" if (0)
 	default y
+	---help---
 
 menu "BM configuration"
 
@@ -170,7 +162,7 @@ config  MV_ETH_BM_HWF_PORT_1_SHORT_BUF_NUM
         ---help---
 	Number of short buffers allocated for this port.
 
-menuconfig MV_ETH_BM_HWF_PORT_2
+menuconfig  MV_ETH_BM_HWF_PORT_2
         depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) &&  (MV_ETH_PORTS_NUM != 2))
         bool "BM HWF configuration for GbE #2"
         default y
@@ -366,8 +358,7 @@ config  MV_ETH_BM_PORT_2_SHORT_BUF_NUM
         Number of short buffers allocated for this port.
 
 menuconfig  MV_ETH_BM_PORT_3
-        depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) \
-		&& (MV_ETH_PORTS_NUM != 2) && (MV_ETH_PORTS_NUM != 3))
+        depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) && (MV_ETH_PORTS_NUM != 2) && (MV_ETH_PORTS_NUM != 3))
         bool "BM configuration for GbE #3"
         default y
         ---help---
@@ -701,11 +692,10 @@ endmenu
 menu "PON support for Network driver"
 
 config MV_PON
-	bool "PON support"
-	default y
-	depends on MV_ETH_PP2 && MV_INCLUDE_PON
-	help
-	  Choose this option to support PON port in Marvell network driver
+        bool "PON support"
+        depends on MV_ETH_PP2 && MV_INCLUDE_PON
+        ---help---
+        Choose this option to support PON port in Marvell network driver
 
 config MV_PON_TXP_DEF
         int "Default T-CONT to send local generated packets"
@@ -730,7 +720,6 @@ config MV_ETH_HWF
 
 endmenu
 
-if MV_INCLUDE_SWITCH
 menu "Switch support"
 
 config MV_ETH_SWITCH
@@ -772,6 +761,4 @@ config  MV_ETH_SWITCH_LINK
 	---help---
 	  Support Phy link status change indications.
 endmenu
-endif
 
-endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
index 0bf3652..e96fe903 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
@@ -181,17 +181,17 @@ static ssize_t mv_cls3_store(struct device *dev,
 	else if (!strcmp(name, "act_sw_fwd"))
 		mvPp2ClsC3ForwardSet(&c3, a);
 	else if (!strcmp(name, "act_sw_pol"))
-		mvPp2ClsC3PolicerSet (&c3, a, b);
+		mvPp2ClsC3PolicerSet(&c3, a, b);
 	else if (!strcmp(name, "act_sw_modif"))
-		mvPp2ClsC3ModSet (&c3, a, b, c);
+		mvPp2ClsC3ModSet(&c3, a, b, c);
 	else if (!strcmp(name, "act_sw_dup"))
-		mvPp2ClsC3DupSet (&c3, a, b);
+		mvPp2ClsC3DupSet(&c3, a, b);
 	else if (!strcmp(name, "cnt_read"))
 		mvPp2ClsC3HitCntrsRead(a, NULL);
 	else if (!strcmp(name, "cnt_clr_all"))
 		mvPp2ClsC3HitCntrsClearAll();
 	else if (!strcmp(name, "cnt_clr_lkp"))
-		mvPp2ClsC3HitCntrsClear (a);
+		mvPp2ClsC3HitCntrsClear(a);
 	else if (!strcmp(name, "sc_start"))
 		mvPp2ClsC3ScanStart();
 	else if (!strcmp(name, "sc_thresh"))
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
index e2be6d7..3b9456e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
@@ -40,9 +40,9 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "echo [p] [hex]       > modCmd       - set 2 bytes of TX descriptor offset 0x16\n");
-	off += sprintf(buf+off, "echo [p] [hex]       > pmeDptr      - set 2 bytes of PME_DPTR field in TX descriptor\n");
-	off += sprintf(buf+off, "echo [p] [hex]       > pmeProgram   - set 1 bytes of PME_Prpgram field in TX descriptor\n");
+	off += sprintf(buf+off, "echo [p] [hex]       > modCmd    - set 2 bytes of PME_ATTR filed in TX descriptor (offset: 0x16)\n");
+	off += sprintf(buf+off, "echo [p] [hex]       > pmeDptr   - set 2 bytes of PME_DPTR field in TX descriptor (offset: 0x18)\n");
+	off += sprintf(buf+off, "echo [p] [hex]       > pmeProg   - set 1 bytes of PME_PROG field in TX descriptor (offset: 0x20)\n");
 
 	return off;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
index fa05c1f..de42d73 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
@@ -34,22 +34,17 @@ disclaimer.
 
 #include "mv_eth_sysfs.h"
 #include "gbe/mvPp2Gbe.h"
-#include "prs/mvPp2Prs.h"
 #include "mv_netdev.h"
 
 static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "echo [p] [0|1]       > mhEn         - enable Marvell Header\n");
-	off += sprintf(buf+off, "echo [p] [hex]       > mh_2B        - set 2 bytes of Marvell Header\n");
-
 	off += sprintf(buf+off, "echo [p] [hex]       > dsaTag       - set 2 bits of DSA tag in tx descriptor\n");
 	off += sprintf(buf+off, "echo [p] [hex]       > pktColor     - set 2 bits of packet color in tx descriptor\n");
 	off += sprintf(buf+off, "echo [p] [hex]       > gemPortId    - set 12 bits of GEM port id in tx descriptor\n");
 	off += sprintf(buf+off, "echo [p] [hex]       > ponFec       - set 1 bit of PON fec in tx descriptor\n");
 	off += sprintf(buf+off, "echo [p] [hex]       > gemOem       - set 1 bit of GEM OEM in tx descriptor\n");
-	off += sprintf(buf+off, "echo [p] [hex]       > mhRxSpecial  - set RX MH value for RX special packets\n");
 
 	return off;
 }
@@ -72,24 +67,19 @@ static ssize_t mv_eth_port_store(struct device *dev,
 {
 	const char      *name = attr->attr.name;
 	int             err;
-	unsigned int    p, v;
+	unsigned int    p, v, a;
 	unsigned long   flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
 	/* Read port and value */
-	err = p = v = 0;
-	sscanf(buf, "%d %x", &p, &v);
+	err = p = v = a = 0;
+	sscanf(buf, "%d %x %x", &p, &v, &a);
 
 	local_irq_save(flags);
 
-
-	if (!strcmp(name, "mh_2B")) {
-		err = mv_eth_ctrl_tx_mh(p, (u16)v);
-	} else if (!strcmp(name, "mhEn")) {
-		err = mv_eth_ctrl_flag(p, MV_ETH_F_MH, v);
-	} else if (!strcmp(name, "dsaTag")) {
+	if (!strcmp(name, "dsaTag")) {
 		err = mv_eth_ctrl_tx_cmd_dsa(p, v);
 	} else if (!strcmp(name, "pktColor")) {
 		err = mv_eth_ctrl_tx_cmd_color(p, v);
@@ -99,8 +89,6 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		err = mv_eth_ctrl_tx_cmd_pon_fec(p, v);
 	} else if (!strcmp(name, "gemOem")) {
 		err = mv_eth_ctrl_tx_cmd_gem_oem(p, v);
-	} else if (!strcmp(name, "mhRxSpecial")) {
-		mvPrsMhRxSpecialSet(MV_PON_PORT_ID, 1, v);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -115,25 +103,19 @@ static ssize_t mv_eth_port_store(struct device *dev,
 }
 
 static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(mh_2B,	S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(mhEn,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(dsaTag,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(pktColor,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(gemPortId,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(ponFec,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(gemOem,	S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(mhRxSpecial,	S_IWUSR, NULL, mv_eth_port_store);
 
 static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_help.attr,
-	&dev_attr_mh_2B.attr,
-	&dev_attr_mhEn.attr,
 	&dev_attr_dsaTag.attr,
 	&dev_attr_pktColor.attr,
 	&dev_attr_gemPortId.attr,
 	&dev_attr_ponFec.attr,
 	&dev_attr_gemOem.attr,
-	&dev_attr_mhRxSpecial.attr,
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
index a0f3b53..2e6ef15f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
@@ -34,6 +34,7 @@ disclaimer.
 
 #include "mv_eth_sysfs.h"
 #include "gbe/mvPp2Gbe.h"
+#include "prs/mvPp2Prs.h"
 #include "mv_netdev.h"
 
 static ssize_t mv_eth_help(char *buf)
@@ -45,6 +46,7 @@ static ssize_t mv_eth_help(char *buf)
 	off += sprintf(buf+off, "echo [rxq]           > gRxqRegs      - show RXQ registers for global <Rxq> range [0..max]\n");
 	off += sprintf(buf+off, "echo [p] [rxq] [v]   > rxqShow       - show RXQ descriptors ring for <p/rxq>. v=0-brief, v=1-full\n");
 	off += sprintf(buf+off, "echo [p] [rxq] [v]   > rxqSize       - set number of descriptors <v> for <port/rxq>.\n");
+	off += sprintf(buf+off, "echo [p] [hex] [0|1] > mhRxSpec      - set RX MH value for RX special packets\n");
 
 	return off;
 }
@@ -58,11 +60,10 @@ static ssize_t mv_eth_show(struct device *dev,
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	if (!strcmp(name, "rxDmaRegs")) {
+	if (!strcmp(name, "rxDmaRegs"))
 		mvPp2RxDmaRegsPrint();
-	} else {
+	else
 		off = mv_eth_help(buf);
-	}
 
 	return off;
 }
@@ -105,12 +106,45 @@ static ssize_t mv_eth_port_store(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
+static ssize_t mv_eth_rx_hex_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, v, a;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = p = v = a = 0;
+	sscanf(buf, "%d %x %x", &p, &v, &a);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "mhRxSpec")) {
+		mvPrsMhRxSpecialSet(MV_PPV2_PORT_PHYS(p), v, a);
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
 static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(rxDmaRegs,  	S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(rxqShow,     S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(gRxqRegs,    S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(rxFifoRegs,  S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(rxqSize,   	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(mhRxSpec,	S_IWUSR, NULL, mv_eth_rx_hex_store);
 
 static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_help.attr,
@@ -119,6 +153,7 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_gRxqRegs.attr,
 	&dev_attr_rxFifoRegs.attr,
 	&dev_attr_rxqSize.attr,
+	&dev_attr_mhRxSpec.attr,
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 8f7955f..ead4b1a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -44,26 +44,28 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "cd                       bm            - move to BM sysfs directory\n");
-	off += sprintf(buf+off, "cd                       napi          - move to NAPI groups API sysfs directory\n");
-	off += sprintf(buf+off, "cd                       rx            - move to RX sysfs directory\n");
-	off += sprintf(buf+off, "cd                       tx            - move to TX sysfs directory\n");
-	off += sprintf(buf+off, "cd                       tx_sched      - move to TX Scheduler sysfs directory\n");
-	off += sprintf(buf+off, "cd                       pon           - move to PON sysfs directory\n");
-	off += sprintf(buf+off, "cd                       pme           - move to PME sysfs directory\n");
-	off += sprintf(buf+off, "cd                       qos           - move to QoS sysfs directory\n\n");
-
-	off += sprintf(buf+off, "cat                      addrDec       - print address decode registers\n");
-	off += sprintf(buf+off, "echo p {0|1|2|3}       > tag           - None[3], Use Marvell Header[1], use DSA tag[2], Use EDSA tag[3]\n");
-	off += sprintf(buf+off, "echo p {0|1}           > etypeDsaMod   - EtherType DSA[0], EtherType EDSA[1],meaningless if port in DSA/EDSA mode\n");
-	off += sprintf(buf+off, "echo [hex]             > etypeDsa      - Set new DSA etherType value, ,meaningless if all ports in DSA/EDSA mode\n");
-	off += sprintf(buf+off, "echo {0|1}             > pnc           - enable / disable Parser and Classifier access\n");
-	off += sprintf(buf+off, "echo [p]               > port          - show a port info\n");
-	off += sprintf(buf+off, "echo [p]               > cntrs         - show a port MIB counters\n");
-	off += sprintf(buf+off, "echo [p] [hex]         > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump, bit5:buff_hdr\n");
-	off += sprintf(buf+off, "echo [p]               > stats         - show port [p] statistics\n");
-	off += sprintf(buf+off, "echo [p]               > isrRegs       - show ISR registers for port <p> range [0..max]\n");
-	off += sprintf(buf+off, "echo [p]               > dropCntrs     - show drop counters for port <p> range [0..max]\n");
+	off += sprintf(buf+off, "cd                             bm            - move to BM sysfs directory\n");
+	off += sprintf(buf+off, "cd                             napi          - move to NAPI groups API sysfs directory\n");
+	off += sprintf(buf+off, "cd                             rx            - move to RX sysfs directory\n");
+	off += sprintf(buf+off, "cd                             tx            - move to TX sysfs directory\n");
+	off += sprintf(buf+off, "cd                             tx_sched      - move to TX Scheduler sysfs directory\n");
+	off += sprintf(buf+off, "cd                             pon           - move to PON sysfs directory\n");
+	off += sprintf(buf+off, "cd                             pme           - move to PME sysfs directory\n");
+	off += sprintf(buf+off, "cd                             qos           - move to QoS sysfs directory\n\n");
+
+	off += sprintf(buf+off, "cat                            addrDec       - print address decode registers\n");
+	off += sprintf(buf+off, "echo p {0|1|2|3}             > tag           - None[3], Use Marvell Header[1], use DSA tag[2], Use EDSA tag[3]\n");
+	off += sprintf(buf+off, "echo p {0|1}                 > etypeDsaMod   - EtherType DSA[0], EtherType EDSA[1],meaningless if port in DSA/EDSA mode\n");
+	off += sprintf(buf+off, "echo [hex]                   > etypeDsa      - Set new DSA etherType value, ,meaningless if all ports in DSA/EDSA mode\n");
+	off += sprintf(buf+off, "echo {0|1}                   > pnc           - enable / disable Parser and Classifier access\n");
+	off += sprintf(buf+off, "echo [p]                     > port          - show a port info\n");
+	off += sprintf(buf+off, "echo [p]                     > cntrs         - show a port MIB counters\n");
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	off += sprintf(buf+off, "echo [p] [hex]               > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump, bit5:buff_hdr\n");
+#endif
+	off += sprintf(buf+off, "echo [p]                     > stats         - show port [p] statistics\n");
+	off += sprintf(buf+off, "echo [p]                     > isrRegs       - show ISR registers for port <p> range [0..max]\n");
+	off += sprintf(buf+off, "echo [p]                     > dropCntrs     - show drop counters for port <p> range [0..max]\n");
 
 	return off;
 }
@@ -152,16 +154,16 @@ static ssize_t mv_eth_2_hex_store(struct device *dev,
 
 	local_irq_save(flags);
 
-#ifdef CONFIG_MV_ETH_STAT_DBG
 	if (!strcmp(name, "debug")) {
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_RX,   v & 0x1);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_TX,   v & 0x2);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_ISR,  v & 0x4);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_POLL, v & 0x8);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_DUMP, v & 0x10);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_BUFF_HDR, v & 0x20);
-	}
 #endif
+	}
 
 	return err ? -EINVAL : len;
 }
@@ -185,7 +187,7 @@ static ssize_t mv_eth_reg_store(struct device *dev,
 
 	if (!strcmp(name, "regRead")) {
 		v = mvPp2RdReg(r);
-		printk("regRead val: 0x%08x\n", v);
+		printk(KERN_ERR "regRead val: 0x%08x\n", v);
 	}  else if (!strcmp(name, "regWrite")) {
 		mvPp2WrReg(r, v);
 	} else if (!strcmp(name, "etypeDsa")) {
@@ -203,18 +205,21 @@ static ssize_t mv_eth_reg_store(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
-static DEVICE_ATTR(addrDec,      S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(help,         S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(debug,        S_IWUSR, NULL, mv_eth_2_hex_store);
-static DEVICE_ATTR(isrRegs,      S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(dropCntrs,    S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(stats,        S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(pnc,        S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(tag,        S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(addrDec,	S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(help,	S_IRUSR, mv_eth_show, NULL);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+static DEVICE_ATTR(debug,	S_IWUSR, NULL, mv_eth_2_hex_store);
+#endif
+static DEVICE_ATTR(isrRegs,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(dropCntrs,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(stats,       S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(pnc,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(tag,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(etypeDsaMod,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(etypeDsa,	S_IWUSR, NULL, mv_eth_reg_store);
-static DEVICE_ATTR(port,         S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(cntrs,        S_IWUSR, NULL, mv_eth_port_store);
+
+static DEVICE_ATTR(port,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(cntrs,	S_IWUSR, NULL, mv_eth_port_store);
 
 static DEVICE_ATTR(regRead,       S_IWUSR, NULL, mv_eth_reg_store);
 static DEVICE_ATTR(regWrite,      S_IWUSR, NULL, mv_eth_reg_store);
@@ -222,7 +227,9 @@ static DEVICE_ATTR(regWrite,      S_IWUSR, NULL, mv_eth_reg_store);
 static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_addrDec.attr,
 	&dev_attr_help.attr,
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
 	&dev_attr_debug.attr,
+#endif
 	&dev_attr_port.attr,
 	&dev_attr_cntrs.attr,
 	&dev_attr_isrRegs.attr,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index c0dc4b7..a760fef 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -49,7 +49,6 @@ disclaimer.
 #include "gbe/mvPp2Gbe.h"
 #include "bm/mvBm.h"
 
-#include "mv_switch.h"
 #include "mv_netdev.h"
 
 #include "mvOs.h"
@@ -58,11 +57,6 @@ disclaimer.
 
 #define MV_ETH_TOOL_AN_TIMEOUT	5000
 
-static int isSwitch(struct eth_port *priv)
-{
-	return (priv->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH));
-}
-
 /******************************************************************************
 * mv_eth_tool_get_settings
 * Description:
@@ -84,7 +78,7 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 	MV_ETH_PORT_DUPLEX 	duplex;
 	MV_ETH_PORT_STATUS      status;
 
-	if ((priv == NULL) || (isSwitch(priv)) || (MV_PON_PORT(priv->port))) {
+	if ((priv == NULL) || (MV_PON_PORT(priv->port))) {
 		printk(KERN_ERR "%s is not supported on %s\n", __func__, netdev->name);
 		return -EOPNOTSUPP;
 	}
@@ -176,7 +170,7 @@ int mv_eth_tool_restore_settings(struct net_device *netdev)
 	MV_ETH_PORT_DUPLEX	mv_mac_duplex;
 	int			err = -EINVAL;
 
-	 if ((priv == NULL) || (isSwitch(priv)))
+	 if (priv == NULL)
 		 return -EOPNOTSUPP;
 
 	switch (priv->speed_cfg) {
@@ -256,7 +250,7 @@ int mv_eth_tool_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	struct eth_port *priv = MV_ETH_PRIV(dev);
 	int _speed, _duplex, _autoneg, _advertise, err;
 
-	if ((priv == NULL) || (isSwitch(priv)) || (MV_PON_PORT(priv->port))) {
+	if ((priv == NULL) || (MV_PON_PORT(priv->port))) {
 		printk(KERN_ERR "%s is not supported on %s\n", __func__, dev->name);
 		return -EOPNOTSUPP;
 	}
@@ -383,7 +377,7 @@ int mv_eth_tool_nway_reset(struct net_device *netdev)
 	struct eth_port *priv = MV_ETH_PRIV(netdev);
 	MV_U32	        phy_addr;
 
-	if ((priv == NULL) || (isSwitch(priv)) || (MV_PON_PORT(priv->port))) {
+	if ((priv == NULL) || (MV_PON_PORT(priv->port))) {
 		printk(KERN_ERR "interface %s is not supported\n", netdev->name);
 		return -EOPNOTSUPP;
 	}
@@ -411,18 +405,12 @@ int mv_eth_tool_nway_reset(struct net_device *netdev)
 u32 mv_eth_tool_get_link(struct net_device *netdev)
 {
 	struct eth_port     *pp = MV_ETH_PRIV(netdev);
-	struct eth_netdev   *dev_priv = MV_DEV_PRIV(netdev);
 
 	if (pp == NULL) {
 		printk(KERN_ERR "interface %s is not supported\n", netdev->name);
 		return -EOPNOTSUPP;
 	}
 
-	if (isSwitch(pp)) {
-		if (dev_priv == NULL)
-			return -EOPNOTSUPP;
-		return (dev_priv->link_map != 0);
-	}
 #ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(pp->port))
 		return mv_pon_link_status();
@@ -509,7 +497,7 @@ void mv_eth_tool_get_ringparam(struct net_device *netdev,
 
 	memset(ring, 0, sizeof(struct ethtool_ringparam));
 	ring->rx_pending = priv->rxq_ctrl[0].rxq_size;
-	//TODO: ring->tx_pending = ? aggr? txq? per cpu? what about hwf?
+	/* TODO: ring->tx_pending = ? aggr? txq? per cpu? what about hwf? */
 }
 
 /******************************************************************************
@@ -571,7 +559,7 @@ void mv_eth_tool_get_pauseparam(struct net_device *netdev,
 	MV_ETH_PORT_STATUS   portStatus;
 	MV_ETH_PORT_FC       flowCtrl;
 
-	if ((priv == NULL) || (isSwitch(priv)) || (MV_PON_PORT(priv->port))) {
+	if ((priv == NULL) || (MV_PON_PORT(priv->port))) {
 		printk(KERN_ERR "%s is not supported on %s\n", __func__, netdev->name);
 		return;
 	}
@@ -618,7 +606,7 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 	MV_U32			phy_addr;
 	MV_STATUS		status = MV_FAIL;
 
-	if ((priv == NULL) || (isSwitch(priv)) || (MV_PON_PORT(priv->port))) {
+	if ((priv == NULL) || (MV_PON_PORT(priv->port))) {
 		printk(KERN_ERR "%s is not supported on %s\n", __func__, netdev->name);
 		return -EOPNOTSUPP;
 	}
@@ -648,6 +636,112 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 }
 
 /******************************************************************************
+* mv_eth_tool_get_rx_csum
+* Description:
+*	ethtool get RX checksum offloading status
+* INPUT:
+*	netdev		Network device structure pointer
+* OUTPUT
+*	None
+* RETURN:
+*	RX checksum
+*
+*******************************************************************************/
+u32 mv_eth_tool_get_rx_csum(struct net_device *netdev)
+{
+#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
+	struct eth_port *priv = MV_ETH_PRIV(netdev);
+
+	return (priv->rx_csum_offload != 0);
+#else
+	return 0;
+#endif
+}
+
+/******************************************************************************
+* mv_eth_tool_set_rx_csum
+* Description:
+*	ethtool enable/disable RX checksum offloading
+* INPUT:
+*	netdev		Network device structure pointer
+*	data		Command data
+* OUTPUT
+*	None
+* RETURN:
+*	0 on success
+*
+*******************************************************************************/
+int mv_eth_tool_set_rx_csum(struct net_device *netdev, uint32_t data)
+{
+#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
+	struct eth_port *priv = MV_ETH_PRIV(netdev);
+
+	priv->rx_csum_offload = data;
+	return 0;
+#else
+	return -EOPNOTSUPP;
+#endif
+}
+
+/******************************************************************************
+* mv_eth_tool_set_tx_csum
+* Description:
+*	ethtool enable/disable TX checksum offloading
+* INPUT:
+*	netdev		Network device structure pointer
+*	data		Command data
+* OUTPUT
+*	None
+* RETURN:
+*	0 on success
+*
+*******************************************************************************/
+int mv_eth_tool_set_tx_csum(struct net_device *netdev, uint32_t data)
+{
+#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
+	if (data) {
+		if (netdev->mtu > MV_ETH_TX_CSUM_MAX_SIZE) {
+			printk(KERN_ERR "Cannot set TX checksum when MTU > %d\n", MV_ETH_TX_CSUM_MAX_SIZE);
+			return -EOPNOTSUPP;
+		}
+		netdev->features |= NETIF_F_IP_CSUM;
+	} else {
+		netdev->features &= ~NETIF_F_IP_CSUM;
+	}
+
+	return 0;
+#else
+	return -EOPNOTSUPP;
+#endif /* TX_CSUM_OFFLOAD */
+}
+
+/******************************************************************************
+* mv_eth_tool_set_tso
+* Description:
+*	ethtool enable/disable TCP segmentation offloading
+* INPUT:
+*	netdev		Network device structure pointer
+*	data		Command data
+* OUTPUT
+*	None
+* RETURN:
+*	0 on success
+*
+*******************************************************************************/
+int mv_eth_tool_set_tso(struct net_device *netdev, uint32_t data)
+{
+#if defined(CONFIG_MV_ETH_TSO)
+	if (data)
+		netdev->features |= NETIF_F_TSO;
+	else
+		netdev->features &= ~NETIF_F_TSO;
+
+	return 0;
+#else
+	return -EOPNOTSUPP;
+#endif
+}
+/******************************************************************************
 * mv_eth_tool_get_strings
 * Description:
 *	ethtool get strings (used for statistics and self-test descriptions)
@@ -685,7 +779,8 @@ int mv_eth_tool_get_stats_count(struct net_device *netdev)
 	return 0;
 }
 
-static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev, u32 *p)
+static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev,
+							struct ethtool_rxfh_indir *indir)
 {
 /*HW support in PPv2 step 2 */
 #if defined(MV_ETH_PNC_LB)
@@ -703,7 +798,8 @@ static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev, u32 *p)
 #endif
 }
 
-static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev, u32 *p)
+static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev,
+							   const struct ethtool_rxfh_indir *indir)
 {
 /*HW support in PPv2 step 2 */
 #if defined(MV_ETH_PNC_LB)
@@ -732,6 +828,60 @@ static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *i
 }
 
 /******************************************************************************
+* mv_eth_tool_set_rx_ntuple
+* Description:
+*	ethtool set mapping from 2t/5t rule to rxq/drop
+*	ignore mask parameters (assume mask=0xFF for each byte provided)
+*	support only tcp4 / udp4 protocols
+*	support only full 2t/5t rules:
+*		** 2t - must provide src-ip, dst-ip
+*		** 5t - must provide src-ip, dst-ip, src-port, dst-port
+* INPUT:
+*	netdev		Network device structure pointer
+*	ntuple
+* OUTPUT
+*	None
+* RETURN:
+*
+*******************************************************************************/
+static int mv_eth_tool_set_rx_ntuple(struct net_device *dev, struct ethtool_rx_ntuple *ntuple)
+{
+/*TODO*/
+	unsigned int sip, dip, ports, sport, dport, proto;
+	struct eth_port *pp;
+
+	return -EOPNOTSUPP;
+
+	if ((ntuple->fs.flow_type != TCP_V4_FLOW) && (ntuple->fs.flow_type != UDP_V4_FLOW))
+		return -EOPNOTSUPP;
+
+	if ((ntuple->fs.action >= CONFIG_MV_ETH_RXQ) || (ntuple->fs.action < ETHTOOL_RXNTUPLE_ACTION_CLEAR))
+		return -EINVAL;
+
+	if (ntuple->fs.flow_type == TCP_V4_FLOW)
+		proto = 6;/*tcp*/
+	else
+		proto = 17;/*udp*/
+
+	sip = ntuple->fs.h_u.tcp_ip4_spec.ip4src;
+	dip = ntuple->fs.h_u.tcp_ip4_spec.ip4dst;
+	sport = ntuple->fs.h_u.tcp_ip4_spec.psrc;
+	dport = ntuple->fs.h_u.tcp_ip4_spec.pdst;
+	if (!sip || !dip)
+		return -EINVAL;
+
+	pp = MV_ETH_PRIV(dev);
+	if (!sport || !dport) {/*2-tuple*/
+		/*pnc_ip4_2tuple_rxq(pp->port, sip, dip, ntuple->fs.action);*/
+	} else {
+		ports = (dport << 16) | ((sport << 16) >> 16);
+		/*pnc_ip4_5tuple_rxq(pp->port, sip, dip, ports, proto, ntuple->fs.action);*/
+	}
+
+	return 0;
+}
+
+/******************************************************************************
 * mv_eth_tool_get_ethtool_stats
 * Description:
 *	ethtool get statistics
@@ -764,6 +914,14 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.set_ringparam 				= mv_eth_tool_set_ringparam,
 	.get_pauseparam				= mv_eth_tool_get_pauseparam,
 	.set_pauseparam				= mv_eth_tool_set_pauseparam,
+	.get_rx_csum				= mv_eth_tool_get_rx_csum,
+	.set_rx_csum				= mv_eth_tool_set_rx_csum,
+	.get_tx_csum				= ethtool_op_get_tx_csum,
+	.set_tx_csum				= mv_eth_tool_set_tx_csum,
+	.get_sg					= ethtool_op_get_sg,
+	.set_sg					= ethtool_op_set_sg,
+	.get_tso				= ethtool_op_get_tso,
+	.set_tso				= mv_eth_tool_set_tso,
 	.get_strings				= mv_eth_tool_get_strings,/*TODO: complete implementation */
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 	.get_stats_count			= mv_eth_tool_get_stats_count,/*TODO: complete implementation */
@@ -771,5 +929,6 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_ethtool_stats			= mv_eth_tool_get_ethtool_stats,/*TODO: complete implementation */
 	.get_rxfh_indir				= mv_eth_tool_get_rxfh_indir,
 	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir,
-	.get_rxnfc				= mv_eth_tool_get_rxnfc,/*TODO new implementation*/
+	.get_rxnfc                  		= mv_eth_tool_get_rxnfc,/*TODO new implementation*/
+	.set_rx_ntuple				= mv_eth_tool_set_rx_ntuple,/*TODO new implementation*/
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
index c4c3793..7b912e3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
@@ -45,9 +45,11 @@ static ssize_t mv_eth_help(char *buf)
 	off += sprintf(buf+off, "echo [txq]                      > gTxqRegs      - show TXQ registers for global <txq> range [0..255]\n");
 	off += sprintf(buf+off, "echo [cpu]                      > aggrTxqRegs   - show Aggregation TXQ registers for <cpu> range [0..max]\n");
 	off += sprintf(buf+off, "echo [cpu] [v]                  > aggrTxqShow   - show aggregated TXQ descriptors ring for <cpu>.\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]        > txqShow       - show TXQ descriptors ring for <p/txp/txq>. v=0-brief, v=1-full\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]        > txqShow       - show TXQ descriptors ring for <p/txp/txq>. v: 0-brief, 1-full\n");
+	off += sprintf(buf+off, "echo [p] [hex]                  > txFlags       - bits: 0-no_pad, 1-mh, 2-hw_cmd\n");
+	off += sprintf(buf+off, "echo [p] [hex]                  > txMH          - set 2 bytes of Marvell Header for transmit\n");
 	off += sprintf(buf+off, "echo [p] [txp] [txq] [cpu]      > txqDef        - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v] [hwf]  > txqSize      - set descriptor Q size <v>, and HWF share <hwf> for <p/txp/txq>. \n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v] [hwf]  > txqSize       - set descriptor Q size <v>, and HWF share <hwf> for <p/txp/txq>. \n");
 
 	return off;
 }
@@ -65,7 +67,42 @@ static ssize_t mv_eth_show(struct device *dev,
 	return off;
 }
 
-static ssize_t mv_eth_port_store(struct device *dev,
+static ssize_t mv_eth_tx_hex_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = p = v;
+	sscanf(buf, "%d %x", &p, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txFlags")) {
+		err = mv_eth_ctrl_tx_flag(p, MV_ETH_TX_F_NO_PAD, v & 0x1);
+		err = mv_eth_ctrl_tx_flag(p, MV_ETH_TX_F_MH, v & 0x2);
+		err = mv_eth_ctrl_tx_flag(p, MV_ETH_TX_F_HW_CMD, v & 0x4);
+	} else if (!strcmp(name, "txMH")) {
+		err = mv_eth_ctrl_tx_mh(p, (u16)v);
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_txq_store(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char      *name = attr->attr.name;
@@ -110,15 +147,17 @@ static ssize_t mv_eth_port_store(struct device *dev,
 }
 
 static DEVICE_ATTR(help,         S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(aggrTxqRegs,  S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(txqShow,      S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(gTxqRegs,     S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(pTxqRegs,     S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(aggrTxqShow,  S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(txqDef,     	 S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(txqSize,    	 S_IWUSR, NULL, mv_eth_port_store);
-
-static struct attribute *mv_eth_attrs[] = {
+static DEVICE_ATTR(aggrTxqRegs,  S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqShow,      S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(gTxqRegs,     S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(pTxqRegs,     S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(aggrTxqShow,  S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqDef,     	 S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqSize,    	 S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txFlags,      S_IWUSR, NULL, mv_eth_tx_hex_store);
+static DEVICE_ATTR(txMH,         S_IWUSR, NULL, mv_eth_tx_hex_store);
+
+static struct attribute *mv_eth_tx_attrs[] = {
 	&dev_attr_txqDef.attr,
 	&dev_attr_aggrTxqRegs.attr,
 	&dev_attr_help.attr,
@@ -127,19 +166,21 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_pTxqRegs.attr,
 	&dev_attr_aggrTxqShow.attr,
 	&dev_attr_txqSize.attr,
+	&dev_attr_txFlags.attr,
+	&dev_attr_txMH.attr,
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_tx_group = {
 	.name = "tx",
-	.attrs = mv_eth_attrs,
+	.attrs = mv_eth_tx_attrs,
 };
 
 int mv_eth_tx_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
+	err = sysfs_create_group(pp2_kobj, &mv_eth_tx_group);
 	if (err) {
 		printk(KERN_INFO "sysfs group failed %d\n", err);
 		goto out;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index 09bb5e2..e023af4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -46,10 +46,6 @@ disclaimer.
 
 #include "mv_netdev.h"
 
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-#include "mv_switch.h"
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
 extern unsigned int mv_eth_pnc_ctrl_en;
 
 static int mv_eth_start(struct net_device *dev);
@@ -84,7 +80,7 @@ static int mv_eth_start(struct net_device *dev)
 			if (priv->napi_group[group] && priv->napi_group[group]->napi)
 				napi_enable(priv->napi_group[group]->napi);
 	}
-	if ((priv->flags & MV_ETH_F_LINK_UP) && !(priv->flags & MV_ETH_F_EXT_SWITCH)) {
+	if (priv->flags & MV_ETH_F_LINK_UP) {
 
 		if (mv_eth_ctrl_is_tx_enabled(priv)) {
 			netif_carrier_on(dev);
@@ -92,14 +88,7 @@ static int mv_eth_start(struct net_device *dev)
 		}
 		printk(KERN_NOTICE "%s: link up\n", dev->name);
 	}
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-	if (priv->flags & MV_ETH_F_EXT_SWITCH) {
-		struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 
-		dev_priv->link_map = 0;
-		mv_switch_link_update_event(dev_priv->port_map, 1);
-	}
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
 	if (priv->flags & MV_ETH_F_CONNECT_LINUX) {
 		/* connect to port interrupt line */
 		if (request_irq(dev->irq, mv_eth_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth", priv)) {
@@ -321,12 +310,12 @@ int mv_eth_open(struct net_device *dev)
 
 	struct	eth_port *priv = MV_ETH_PRIV(dev);
 	int	phyPort = MV_PPV2_PORT_PHYS(priv->port);
-	static u8 mac_bcast[MV_MAC_ADDR_SIZE] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+	static  u8 mac_bcast[MV_MAC_ADDR_SIZE] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
 
 	if (mv_eth_pnc_ctrl_en) {
 
 		if (mvPrsMacDaAccept(phyPort, mac_bcast, 1 /*add*/)) {
-			printk(KERN_ERR "%s: mvPrsMacDaAccept failed\n", dev->name);
+			printk(KERN_ERR "%s:mvPrsMacDaAccept\n", dev->name);
 				return -1;
 		}
 		if (mvPrsMacDaAccept(phyPort, dev->dev_addr, 1 /*add*/)) {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_fpga_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_fpga_sysfs.c
deleted file mode 100644
index 7a80c23..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_fpga_sysfs.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-
-#include "gbe/mvPp2Gbe.h"
-#include "mv_netdev.h"
-
-void	mvPp2FpgaDebugDump(void)
-{
-	int i, entry_no, dword_no;
-
-	mvEthRegPrint(0x5800, "0x5800");
-	mvEthRegPrint(0x5804, "0x5804");
-	mvEthRegPrint(0x5840, "0x5804");
-	mvEthRegPrint(0x5844, "0x5844");
-	mvEthRegPrint(0x5848, "0x5844");
-
-	for (i = 0; i < 8; i++) {
-		mvEthRegPrint2(0x5860 + 4 * i, "0x5860 + i", i);
-	}
-	for (i = 0; i < 8; i++) {
-		mvEthRegPrint2(0x5880 + 4 * i, "0x5880", i);
-	}
-
-	for (entry_no = 0; entry_no < 256; entry_no++) {
-		mvOsPrintf("\nEntry number #%d\n", entry_no);
-		for (dword_no = 0; dword_no < 8; dword_no++) {
-			MV_REG_WRITE(0x58a0, 256 * dword_no + entry_no);
-			mvEthRegPrint2(0x58a4, "0x58a4 + 256 * d + e", 256 * dword_no + entry_no);
-		}
-	}
-}
-
-void	mvPp2FpgaPtrnSet(int ptrn_no, unsigned int mask, unsigned int data)
-{
-	MV_U32	regVal;
-
-	regVal = (((mask & 0xFFFF) << 16) | ((data & 0xFFFF) << 0));
-	mvOsPrintf("ptrn_no=%d, mask=0x%04x, data=0x%04x: 0x%08x => 0x%x\n",
-				ptrn_no, mask, data, regVal, (0x5860 + 4 * ptrn_no));
-	MV_REG_WRITE(0x5860 + 4 * ptrn_no, regVal);
-}
-
-void	mvPp2FpgaStageSet(int stage_no, unsigned int find_count, unsigned int start_ptrn,
-						  unsigned int restart_stage_no, unsigned int restart_opcode,
-						  unsigned int find_opcode, unsigned int store_opcode)
-{
-	MV_U32	regVal = 0;
-
-	regVal = (((find_count       & 0xFF) << 24) |
-			  ((start_ptrn       & 0x7)  << 21) |
-			  ((restart_stage_no & 0x7)  << 18) |
-			  ((restart_opcode   & 0x3F) << 12) |
-			  ((find_opcode      & 0x3F) << 6) |
-			  ((store_opcode     & 0x3F) << 0));
-
-	mvOsPrintf("stage_no=%d: 0x%08x => 0x%x\n",
-				stage_no, regVal, (0x5880 + 4 * stage_no));
-
-	MV_REG_WRITE(0x5880 + 4 * stage_no, regVal);
-}
-
-void	mvPp2FpgaDebugInit(void)
-{
-	int ptrn_no, stage_no;
-
-	for (ptrn_no = 0; ptrn_no < 8; ptrn_no++) {
-		mvPp2FpgaPtrnSet(ptrn_no, 0xFFFF, 0x0);
-	}
-	for (stage_no = 0; stage_no < 8; stage_no++) {
-		mvPp2FpgaStageSet(stage_no, 0x1, 0x0, 0x0, 0xC, 0xF, 0xF);
-	}
-}
-
-static ssize_t mv_fpga_help(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "cat                            help     - print this help\n");
-	off += sprintf(buf+off, "cat                            dump     - print FPGA debug state\n");
-	off += sprintf(buf+off, "echo i mask data             > ptrn     - configure FPGA debug pattern\n");
-	off += sprintf(buf+off, "echo i v1 v2 v3 v4 v5 v6     > stage    - configure FPGA debug stage\n");
-
-	return off;
-}
-
-static ssize_t mv_fpga_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	const char      *name = attr->attr.name;
-	int             off = 0;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (!strcmp(name, "dump")) {
-		mvPp2FpgaDebugDump();
-	} else {
-		off = mv_fpga_help(buf);
-	}
-
-	return off;
-}
-
-static ssize_t mv_fpga_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char      *name = attr->attr.name;
-	int             err;
-	unsigned int    i, v1, v2, v3, v4, v5, v6;
-	unsigned long   flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read port and value */
-	err = i = v1 = v2 = v3 = v4 = v5 = v6 = 0;
-	sscanf(buf, "%d %x %x %x %x %x %x", &i, &v1, &v2, &v3, &v4, &v5, &v6);
-
-	local_irq_save(flags);
-
-	if (!strcmp(name, "ptrn")) {
-		mvPp2FpgaPtrnSet(i, v1, v2);
-	} else if (!strcmp(name, "stage")) {
-		mvPp2FpgaStageSet(i, v1, v2, v3, v4, v5, v6);
-	} else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-
-	local_irq_restore(flags);
-
-	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
-
-	return err ? -EINVAL : len;
-}
-
-static DEVICE_ATTR(help,        S_IRUSR, mv_fpga_show, NULL);
-static DEVICE_ATTR(dump,        S_IRUSR, mv_fpga_show, NULL);
-static DEVICE_ATTR(ptrn,       	S_IWUSR, NULL, mv_fpga_store);
-static DEVICE_ATTR(stage,       S_IWUSR, NULL, mv_fpga_store);
-
-static struct attribute *mv_fpga_attrs[] = {
-	&dev_attr_help.attr,
-	&dev_attr_dump.attr,
-	&dev_attr_ptrn.attr,
-	&dev_attr_stage.attr,
-	NULL
-};
-
-static struct attribute_group mv_fpga_group = {
-	.name = "fpga",
-	.attrs = mv_fpga_attrs,
-};
-
-int __devinit mv_fpga_sysfs_init(void)
-{
-	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	err = sysfs_create_group(&pd->kobj, &mv_fpga_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-	mvPp2FpgaDebugInit();
-out:
-	return err;
-}
-
-module_init(mv_fpga_sysfs_init);
-
-MODULE_AUTHOR("Dima Epshtein");
-MODULE_DESCRIPTION("sysfs for marvell FPGA");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
new file mode 100644
index 0000000..4caacd4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "mv_netdev.h"
+#include "mv_mux_netdev.h"
+#include "mv_switch/mv_switch.h"
+
+static struct switch_device_ops	switch_ops;
+static struct mux_device_ops 	mux_ops;
+
+static int mv_gw_mgr_mux_create(char *name, int gbe_port, int group, MV_MUX_TAG *tag)
+{
+	struct net_device *mux_dev;
+	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	char *unicast;
+	struct eth_port *pp = mv_eth_port_by_id(gbe_port);
+
+	mux_dev = mv_mux_netdev_alloc(name, group, tag);
+	if (mux_dev == NULL) {
+		printk(KERN_ERR "%s: mv_mux_netdev_alloc falied\n", __func__);
+		return MV_FAIL;
+	}
+	mv_mux_netdev_add(pp, mux_dev);
+
+	/* update switch group's cookie for mux ops */
+	mv_switch_group_cookie_set(group, mux_dev);
+
+	/* update switch's DB with mux's MAC addresses (bcast, ucast) */
+	unicast = mv_mux_get_mac(mux_dev);
+	mv_switch_mac_addr_set(unicast, group, 1);
+	mv_switch_mac_addr_set(broadcast, group, 1);
+
+	return 0;
+}
+
+static int mv_gw_mgr_mux_init(MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int gbe_port)
+{
+	char name[7] = {0, 0, 0, 0, 0, 0, 0};
+	MV_MUX_TAG tag;
+	unsigned int g, groups = mv_switch_group_map_get();
+
+	for (g = 0; g < MV_SWITCH_DB_NUM; g++) {
+		if (MV_BIT_CHECK(groups, g)) {
+			/* get tag data according to switch */
+			mv_switch_tag_get(&tag, preset, vid, tag_mode, g);
+
+			/* assign name */
+			sprintf(name, "mux%d", g);
+
+			/* create new mux device */
+			mv_gw_mgr_mux_create(name, gbe_port, g, &tag);
+		}
+	}
+
+	return 0;
+}
+
+static int __init mv_gw_mgr_init(void)
+{
+	MV_TAG_TYPE tag_mode;
+	MV_SWITCH_PRESET_TYPE preset;
+	int vid, gbe_port;
+	struct eth_port *pp;
+
+
+	/* get default switch configuration parameteres for preset init */
+	mv_switch_default_config_get(&tag_mode, &preset, &vid, &gbe_port);
+
+	/* config switch according to preset mode */
+	mv_switch_preset_init(preset, tag_mode, vid);
+
+	/* config mux interfaces according to preset mode */
+	mv_gw_mgr_mux_init(preset, vid, tag_mode, gbe_port);
+
+	/* update netdev port with tag type */
+	pp = mv_eth_port_by_id(gbe_port);
+	mv_mux_tag_type_set(pp, tag_mode);
+
+	/* set switch ops to be used by mux driver */
+	switch_ops.group_enable = mv_switch_group_enable;
+	switch_ops.group_disable = mv_switch_group_disable;
+	switch_ops.link_status = mv_switch_link_status_get;
+	switch_ops.mac_update = mv_switch_mac_update;
+	mv_mux_switch_ops_set(&switch_ops);
+
+	/* set mux ops to be used by switch driver */
+	mux_ops.update_link = mv_mux_update_link;
+	mv_switch_mux_ops_set(&mux_ops);
+
+	return 0;
+}
+
+late_initcall(mv_gw_mgr_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
new file mode 100644
index 0000000..4880461
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
@@ -0,0 +1,1105 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "mv_mux_netdev.h"
+#include "mv_netdev.h"
+
+static const struct net_device_ops mv_mux_netdev_ops;
+static inline struct net_device *mv_mux_rx_netdev_get(struct eth_port *pp, struct sk_buff *skb);
+static inline int mv_mux_rx_tag_remove(struct eth_port *pp, struct net_device *dev, struct sk_buff *skb);
+static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb);
+
+static struct switch_device_ops *switch_ops = NULL;
+
+int mv_mux_switch_ops_set(struct switch_device_ops *switch_ops_ptr)
+{
+	switch_ops = switch_ops_ptr;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_update_link(void *cookie, int link_up)
+{
+	struct net_device *mux_dev = (struct net_device *)cookie;
+
+	(link_up) ? netif_carrier_on(mux_dev) : netif_carrier_off(mux_dev);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static inline int mv_mux_get_tag_size(MV_TAG_TYPE type)
+{
+	static const int size_arr[] = {0, MV_ETH_MH_SIZE,
+					MV_ETH_DSA_SIZE,
+					MV_TAG_TYPE_EDSA,
+					MV_TAG_TYPE_VLAN};
+	return size_arr[type];
+}
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev)
+{
+	struct net_device *dev;
+	struct eth_port *pp = MV_ETH_PRIV(root_dev);
+	int    len;
+
+	dev = mv_mux_rx_netdev_get(pp, skb);
+
+	if (dev == NULL)
+		goto out;
+
+	/* mux device is down */
+	if (!(dev->flags & IFF_UP))
+		goto out1;
+
+	/* remove tag*/
+	len = mv_mux_rx_tag_remove(pp, dev, skb);
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len - len;
+
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	if (pp->flags & MV_ETH_F_DBG_RX) {
+		printk(KERN_ERR "\n%s - %s: port=%d, cpu=%d\n", dev->name, __func__, pp->port, smp_processor_id());
+		mv_eth_skb_print(skb);
+		mvDebugMemDump(skb->data, 64, 1);
+	}
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+#ifdef ETH_SKB_DEBUG
+		mv_eth_skb_check(skb);
+#endif /* ETH_SKB_DEBUG */
+
+	skb->protocol = eth_type_trans(skb, dev);
+
+#ifdef CONFIG_MV_ETH_GRO
+	if (dev->features & NETIF_F_GRO) {
+		int group = pp->cpu_config[smp_processor_id()]->napi_group_id;
+
+		/*TODO update mux priv gro counters */
+		STAT_DBG(pp->stats.rx_gro++);
+		STAT_DBG(pp->stats.rx_gro_bytes += skb->len);
+		return napi_gro_receive(pp->napi_group[group]->napi, skb);
+	}
+#endif /*CONFIG_MV_ETH_GRO*/
+
+	return netif_receive_skb(skb);
+
+out1:
+	dev->stats.rx_dropped++;
+out:
+	kfree_skb(skb);
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	if (!(netif_running(dev))) {
+		printk(KERN_ERR "!netif_running() in %s\n", __func__);
+		goto out;
+	}
+
+	if (mv_mux_tx_skb_tag_add(dev, skb)) {
+		printk(KERN_ERR "%s: mv_mux_tx_skb_tag_add failed.\n", __func__);
+		goto out;
+	}
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	if (pp->flags & MV_ETH_F_DBG_TX) {
+		printk(KERN_ERR "\n%s - %s_%lu: port=%d, cpu=%d, in_intr=0x%lx\n",
+			dev->name, __func__, dev->stats.tx_packets, pp->port, smp_processor_id(), in_interrupt());
+		mv_eth_skb_print(skb);
+		mvDebugMemDump(skb->data, 64, 1);
+	}
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	/* assign the packet to the hw interface */
+	skb->dev = pp->dev;
+
+	/*tell Linux to pass it to its device */
+	return dev_queue_xmit(skb);
+
+out:
+	dev->stats.tx_dropped++;
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Return mux device mac address							   */
+/*-----------------------------------------------------------------------------------------*/
+char *mv_mux_get_mac(struct net_device *mux_dev)
+{
+
+	if (!mux_dev) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return NULL;
+	}
+
+	return mux_dev->dev_addr;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static void mv_mux_set_rx_mode(struct net_device *dev)
+{
+/*
+	printk(KERN_ERR "Invalid operation %s is virtual interface.\n", dev->name);
+*/
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mv_mux_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	/*TODO compleate implementation*/
+	printk(KERN_ERR "Not supported yet.\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_close(struct net_device *dev)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	netif_stacked_transfer_operstate(pp->dev, dev);
+	netif_tx_stop_all_queues(dev);
+
+	if (switch_ops && switch_ops->group_enable) {
+		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
+
+		switch_ops->group_disable(pmux_priv->idx);
+	}
+
+
+	printk(KERN_NOTICE "%s: stopped\n", dev->name);
+
+	return MV_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_open(struct net_device *dev)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	if (!pp) {
+		printk(KERN_ERR "%s:Invalid operation, set master before up.\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* if master is close */
+	if (!(pp->dev->flags & IFF_UP)) {
+		printk(KERN_ERR "%s:Invalid operation, port %d is down.\n", __func__, pp->port);
+		return MV_ERROR;
+	}
+
+	netif_stacked_transfer_operstate(pp->dev, dev);
+	netif_tx_wake_all_queues(dev);
+
+	if (switch_ops && switch_ops->group_enable) {
+		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
+
+		switch_ops->group_enable(pmux_priv->idx);
+	}
+
+	printk(KERN_NOTICE "%s: started\n", dev->name);
+
+	return MV_OK;
+
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_set_mac(struct net_device *dev, void *addr)
+{
+	u8 *mac = &(((u8 *)addr)[2]);  /* skip on first 2B (ether HW addr type) */
+
+	mv_mux_close(dev);
+
+	if (switch_ops && switch_ops->mac_update) {
+		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
+
+		switch_ops->mac_update(pmux_priv->idx, dev->dev_addr, mac);
+	}
+	memcpy(dev->dev_addr, mac, ETH_ALEN);
+
+	mv_mux_open(dev);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_mtu_change(struct net_device *mux_dev, int mtu)
+{
+	printk(KERN_ERR "Invalid operation %s is virtual port.\n", mux_dev->name);
+	return MV_ERROR;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Create new mux device, if device is allready exist just change tag value                */
+/* mv_mux_netdev_add should called after mv_mux_netdev_alloc                               */
+/*-----------------------------------------------------------------------------------------*/
+struct net_device *mv_mux_netdev_alloc(char* name, int idx, MV_MUX_TAG *tag_cfg)
+{
+	struct net_device *mux_dev;
+	struct eth_netdev *pmux_priv;
+
+	if (name == NULL) {
+		printk(KERN_ERR "%s: mux net device name is missig.\n", __func__);
+		return NULL;
+	}
+
+	mux_dev = dev_get_by_name(&init_net, name);
+
+
+	if (!mux_dev) {
+	/* new net device */
+	mux_dev = alloc_netdev(sizeof(struct eth_netdev), name, ether_setup);
+		if (!mux_dev) {
+			printk(KERN_ERR "%s: out of memory, net device allocation failed.\n", __func__);
+			return NULL;
+		}
+		/* allocation succeed */
+		mux_dev->irq = NO_IRQ;
+		/* must set netdev_ops before registration */
+		mux_dev->netdev_ops = &mv_mux_netdev_ops;
+
+		if (register_netdev(mux_dev)) {
+			printk(KERN_ERR "%s: failed to register %s\n", __func__, mux_dev->name);
+			free_netdev(mux_dev);
+			return NULL;
+		}
+
+	}
+
+	pmux_priv = MV_DEV_PRIV(mux_dev);
+
+	if (tag_cfg == NULL) {
+		memset(pmux_priv, 0, sizeof(struct eth_netdev));
+	} else{
+		/* next, pp not changed*/
+		pmux_priv->tx_tag = tag_cfg->tx_tag;
+		pmux_priv->rx_tag_ptrn = tag_cfg->rx_tag_ptrn;
+		pmux_priv->rx_tag_mask = tag_cfg->rx_tag_mask;
+	}
+	pmux_priv->idx = idx;
+	return mux_dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Init mux device features								   */
+/*-----------------------------------------------------------------------------------------*/
+static inline void mv_mux_init_features(struct net_device *mux_dev)
+{
+	struct eth_port *pp = MV_ETH_PRIV(mux_dev);
+
+	mux_dev->features = pp->dev->features;
+/*
+	mux_dev->hw_features = pp->dev->hw_features;
+	mux_dev->wanted_features = pp->dev->wanted_features;
+*/
+	mux_dev->vlan_features = pp->dev->vlan_features;
+
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mv_mux_set_features(struct net_device *mux_dev, u32 features)
+{
+	u32 changed = mux_dev->features ^ features;
+	u32 old = mux_dev->features;
+
+	if (changed & NETIF_F_SG)
+		if (!(old & NETIF_F_TSO))
+			/* mux interface want to set tso */
+			/*if (!pp->dev->ethtool_ops->get_sg(pp->dev))*/
+				/* master tso is down */
+				return -EOPNOTSUPP;
+
+	if (changed & NETIF_F_IP_CSUM)
+		if (!(old & NETIF_F_IP_CSUM))
+			/* mux interface want to set tx csum */
+			/*if (!pp->dev->ethtool_ops->get_tx_csum(pp->dev))*/
+				/* master tx csum is down */
+				return -EOPNOTSUPP;
+	return MV_OK;
+}
+
+/*----------------------------------------------------------------------------------------*/
+/* Function attache mux device to root device,						  */
+/* Set mux mac address and features according to root device				  */
+/*----------------------------------------------------------------------------------------*/
+static struct net_device *mv_mux_netdev_init(struct net_device *root_dev, struct net_device *mux_dev)
+{
+	struct eth_netdev *pmux_priv;
+	struct eth_port *pp;
+
+	if (root_dev == NULL)
+		return NULL;
+
+	pp = MV_ETH_PRIV(root_dev);
+
+	if (pp && !(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
+		printk(KERN_ERR "%s: root device is not connect to linux.\n", __func__);
+		return NULL;
+	}
+
+	if (!mux_dev) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return NULL;
+	}
+
+	/* set skb header size , avoid from skb reallocation*/
+	mux_dev->hard_header_len = pp->dev->hard_header_len +
+					mv_mux_get_tag_size(pp->tag_type);
+
+	/* Copy MAC address and MTU from root netdevice */
+	mux_dev->mtu = pp->dev->mtu;
+	pmux_priv = MV_DEV_PRIV(mux_dev);
+	pmux_priv->pp = pp;
+
+	memcpy(mux_dev->dev_addr, pp->dev->dev_addr, MV_MAC_ADDR_SIZE);
+
+	/* TODO: handle features */
+	mv_mux_init_features(mux_dev);
+
+#ifdef CONFIG_MV_ETH_TOOL
+/*	SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
+#endif
+
+	return mux_dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+struct net_device *mv_mux_netdev_add(struct eth_port *pp, struct net_device *mux_dev)
+{
+
+	struct net_device *dev_temp;
+	struct eth_netdev *pdev;
+
+	if (pp == NULL)
+		return NULL;
+
+	mux_dev = mv_mux_netdev_init(pp->dev, mux_dev);
+
+	if (mux_dev == NULL)
+		return NULL;
+
+	if (pp->switch_dev == NULL) {
+		/* First tag netdev */
+		pp->switch_dev = mux_dev;
+	} else {
+		pdev = MV_DEV_PRIV(pp->switch_dev);
+		while (pdev->next != NULL) {
+			dev_temp = pdev->next;
+			pdev = MV_DEV_PRIV(dev_temp);
+		}
+		pdev->next = mux_dev;
+	}
+	return mux_dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_tag_type_set(struct eth_port *pp, int type)
+{
+	unsigned int flgs;
+
+	if ((type < MV_TAG_TYPE_NONE) || (type >= MV_TAG_TYPE_LAST)) {
+		printk(KERN_INFO "%s: Invalid tag type %d\n", __func__, type);
+		return MV_ERROR;
+	}
+
+	if (pp == NULL)
+		return MV_ERROR;
+
+	flgs = pp->dev->flags;
+
+	if (flgs & IFF_UP) {
+		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, pp->dev->name);
+		return MV_ERROR;
+	}
+
+	pp->tag_type = type;
+
+	switch (type) {
+	case MV_TAG_TYPE_MH:
+		mvPp2MhSet(pp->port, MV_PP2_MH);
+		break;
+	case MV_TAG_TYPE_DSA:
+		mvPp2MhSet(pp->port, MV_TAG_TYPE_DSA);
+		break;
+	case MV_TAG_TYPE_EDSA:
+		mvPp2MhSet(pp->port, MV_PP2_DSA_EXT);
+		break;
+	default: /* Do Nothing */
+		break;
+	}
+
+	return MV_OK;
+}
+/*-----------------------------------------------------------------------------------------*/
+/* Delete mux device                                                                       */
+/*	remove device from port linked list						   */
+/*	free mux device                                                                    */
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_netdev_delete(struct net_device *mux_dev)
+{
+	struct net_device *pdev_curr, *pdev_prev = NULL;
+	struct eth_netdev *pdev_tmp_curr, *pdev_tmp_prev;
+	struct eth_port *pp;
+	int flgs;
+
+	if (mux_dev == NULL) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return MV_ERROR;
+	}
+
+	pp = MV_ETH_PRIV(mux_dev);
+
+	/*not attached to gbe port*/
+	if (pp == NULL) {
+		/*
+		FIXME - crash */
+		synchronize_net();
+		unregister_netdev(mux_dev);
+		free_netdev(mux_dev);
+		return MV_OK;
+	}
+
+	flgs = mux_dev->flags;
+	if (flgs & IFF_UP) {
+		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, pp->dev->name);
+		return MV_ERROR;
+	}
+
+	pdev_curr = pp->switch_dev;
+
+	while (pdev_curr != NULL) {
+
+		pdev_tmp_curr = MV_DEV_PRIV(pdev_curr);
+
+		if (pdev_curr == mux_dev) {
+			if (pdev_curr == pp->switch_dev) {
+				/* first element*/
+				pp->switch_dev = pdev_tmp_curr->next;
+			} else {
+				pdev_tmp_prev = MV_DEV_PRIV(pdev_prev);
+				pdev_tmp_prev->next = pdev_tmp_curr->next;
+			}
+			/* delet current */
+			/*FIXME - crash*/
+			synchronize_net();
+			unregister_netdev(mux_dev);
+			free_netdev(mux_dev);
+			return MV_OK;
+
+		} else {
+			pdev_prev = pdev_curr;
+			pdev_curr = pdev_tmp_curr->next;
+		}
+	}
+	/* mux_dev not found */
+	return MV_ERROR;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mux_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
+{
+	struct net_device *mux_dev, *dev = ptr;
+	struct eth_netdev *pdev_priv;
+	struct eth_port *priv;
+	int flgs, link_up;
+
+	/*recognize if marvell event */
+	if (!mv_eth_netdev_find(dev->ifindex))
+		goto out;
+
+	priv = MV_ETH_PRIV(dev);
+
+	/* exit - if not mux device */
+	if (priv->tag_type == MV_TAG_TYPE_NONE)
+		goto out;
+
+	switch (event) {
+
+	case NETDEV_CHANGE:
+		mux_dev = priv->switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_DEV_PRIV(mux_dev);
+
+			if (switch_ops && (switch_ops->link_status)) {
+				/* In case of internal switch, link is determined by switch */
+				link_up = switch_ops->link_status(pdev_priv->idx);
+				mv_mux_update_link(mux_dev, link_up);
+			} else {
+				/* In case of external switch, propagate real device link state to mux devices */
+				/* change state*/
+				netif_stacked_transfer_operstate(dev, mux_dev);
+			}
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_CHANGEADDR:
+		/* Propagate real device mac adress to mux devices */
+		mux_dev = priv->switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_DEV_PRIV(mux_dev);
+			/* May be called without an actual change */
+			if (!compare_ether_addr(mux_dev->dev_addr, dev->dev_addr)) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			memcpy(mux_dev->dev_addr, dev->dev_addr, ETH_ALEN);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_CHANGEMTU:
+		mux_dev = priv->switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_DEV_PRIV(mux_dev);
+			if (mux_dev->mtu <= dev->mtu) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_set_mtu(mux_dev, dev->mtu);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_FEAT_CHANGE:
+		/* not supported */
+		break;
+
+	case NETDEV_DOWN:
+		/* Master down - Put all mux devices for this dev in the down state too.  */
+		mux_dev = priv->switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_DEV_PRIV(mux_dev);
+			flgs = mux_dev->flags;
+			if (!(flgs & IFF_UP)) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_change_flags(mux_dev, flgs & ~IFF_UP);
+			netif_stacked_transfer_operstate(dev, mux_dev);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_UP:
+		/* Master up - Put all mux devices for this dev in the up state too.  */
+		mux_dev = priv->switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_DEV_PRIV(mux_dev);
+			flgs = mux_dev->flags;
+			if (flgs & IFF_UP) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_change_flags(mux_dev, flgs | IFF_UP);
+
+			netif_stacked_transfer_operstate(dev, mux_dev);
+			mux_dev = pdev_priv->next;
+		}
+
+		break;
+	} /*switch*/
+out:
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block mux_notifier_block __read_mostly = {
+	.notifier_call = mux_device_event,
+};
+
+static int __init mux_proto_init(void)
+{
+	int err;
+
+	err = register_netdevice_notifier(&mux_notifier_block);
+
+	if (err < 0)
+		unregister_netdevice_notifier(&mux_notifier_block);
+	return err;
+
+}
+/*-----------------------------------------------------------------------------------------*/
+
+bool mv_mux_netdev_link_status(struct net_device *dev)
+{
+	return netif_carrier_ok(dev) ? true : false;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid)
+{
+
+	mux_cfg->tx_tag.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
+	mux_cfg->rx_tag_ptrn.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
+
+	/*mask priority*/
+	mux_cfg->rx_tag_mask.vlan = MV_32BIT_BE(0xFFFF0FFF);
+
+	mux_cfg->tag_type = MV_TAG_TYPE_VLAN;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg)
+{
+	if (mux_dev) {
+		struct eth_netdev *pmux_priv;
+		pmux_priv = MV_DEV_PRIV(mux_dev);
+		mux_cfg->tx_tag = pmux_priv->tx_tag;
+		mux_cfg->rx_tag_ptrn = pmux_priv->rx_tag_ptrn;
+		mux_cfg->rx_tag_mask = pmux_priv->rx_tag_mask;
+	} else
+		memset(mux_cfg, 0, sizeof(MV_MUX_TAG));
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_mh_netdev_get(struct eth_port *pp, MV_TAG *tag)
+{
+	struct net_device *dev = pp->switch_dev;
+	struct eth_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_DEV_PRIV(dev);
+		if ((tag->mh & pdev->rx_tag_mask.mh) == pdev->rx_tag_ptrn.mh)
+			return dev;
+
+		dev = pdev->next;
+	}
+	printk(KERN_ERR "%s: MH=0x%04x match no interfaces\n", __func__, tag->mh);
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_vlan_netdev_get(struct eth_port *pp, MV_TAG *tag)
+{
+	struct net_device *dev = pp->switch_dev;
+	struct eth_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_DEV_PRIV(dev);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+		if (pp->flags & MV_ETH_F_DBG_RX)
+			printk(KERN_ERR "pkt tag = 0x%x, rx_tag_ptrn = 0x%x, rx_tag_mask = 0x%x\n",
+				 tag->vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
+#endif
+		if ((tag->vlan & pdev->rx_tag_mask.vlan) ==
+			(pdev->rx_tag_ptrn.vlan & pdev->rx_tag_mask.vlan))
+			return dev;
+
+		dev = pdev->next;
+	}
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
+#endif
+
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_dsa_netdev_get(struct eth_port *pp, MV_TAG *tag)
+{
+	/*
+	   MV_TAG.vlan and MV_TAG.dsa size are equal.
+	   MV_TAG type is union.
+	   We can use in the same functins.
+	*/
+
+	return mv_mux_vlan_netdev_get(pp, tag);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_edsa_netdev_get(struct eth_port *pp, MV_TAG *tag)
+{
+	struct net_device *dev = pp->switch_dev;
+	struct eth_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_DEV_PRIV(dev);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+		if (pp->flags & MV_ETH_F_DBG_RX)
+			printk(KERN_ERR "pkt tag = 0x%x %x, rx_tag_ptrn = 0x%x %x, rx_tag_mask = 0x%x %x\n",
+				 tag->edsa[0], tag->edsa[1], pdev->rx_tag_ptrn.edsa[0], pdev->rx_tag_ptrn.edsa[1],
+				 pdev->rx_tag_mask.edsa[0], pdev->rx_tag_mask.edsa[1]);
+#endif
+		/* compare tags */
+		if (((tag->edsa[0] & pdev->rx_tag_mask.edsa[0]) ==
+			(pdev->rx_tag_ptrn.edsa[0] & pdev->rx_tag_mask.edsa[0])) &&
+			((tag->edsa[1] & pdev->rx_tag_mask.edsa[1]) ==
+			(pdev->rx_tag_ptrn.edsa[1] & pdev->rx_tag_mask.edsa[1])))
+				return dev;
+
+		dev = pdev->next;
+	}
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
+#endif
+
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+
+static inline struct net_device *mv_mux_rx_netdev_get(struct eth_port *pp, struct sk_buff *skb)
+{
+	struct net_device *dev;
+	MV_TAG tag;
+	MV_U8 *data = skb->data;
+
+	/* skb->data point to MH */
+
+	switch (pp->tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		tag.mh = *(MV_U16 *)data;
+		dev = mv_mux_mh_netdev_get(pp, &tag);
+		break;
+
+	case MV_TAG_TYPE_VLAN:
+		tag.vlan = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		dev = mv_mux_vlan_netdev_get(pp, &tag);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		tag.dsa = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		dev = mv_mux_dsa_netdev_get(pp, &tag);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		tag.edsa[0] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		tag.edsa[1] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE) + 4);
+		dev = mv_mux_edsa_netdev_get(pp, &tag);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
+		return NULL;
+	}
+
+	return dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static inline int mv_mux_mh_skb_remove(struct sk_buff *skb)
+{
+	__skb_pull(skb, MV_ETH_MH_SIZE);
+	return MV_ETH_MH_SIZE;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_vlan_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_VLAN_HLEN, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_VLAN_HLEN);
+
+	return MV_ETH_VLAN_SIZE;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_dsa_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_ETH_DSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_ETH_DSA_SIZE);
+
+	return MV_ETH_DSA_SIZE;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_edsa_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_ETH_EDSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_ETH_EDSA_SIZE);
+
+	return MV_ETH_EDSA_SIZE;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_rx_tag_remove(struct eth_port *pp, struct net_device *dev, struct sk_buff *skb)
+{
+	int shift = 0;
+	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+
+	if (pdev->leave_tag == true)
+		return 0;
+
+	switch (pp->tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		break;
+
+	case MV_TAG_TYPE_VLAN:
+		shift = mv_mux_vlan_skb_remove(skb);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		shift = mv_mux_dsa_skb_remove(skb);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		shift = mv_mux_edsa_skb_remove(skb);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
+		return -1;
+	}
+	/* MH exist in packet anycase - Skip it */
+	shift += mv_mux_mh_skb_remove(skb);
+
+	return shift;
+}
+
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
+{
+
+	/* sanity: Check that there is place for MH in the buffer */
+	if (skb_headroom(skb) < MV_ETH_MH_SIZE) {
+		printk(KERN_ERR "%s: skb (%p) doesn't have place for MH, head=%p, data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	/* Prepare place for MH header */
+	__skb_push(skb, MV_ETH_MH_SIZE);
+
+	*((u16 *) skb->data) = mh;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_mh_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+
+	return mv_eth_skb_mh_add(skb, pdev->tx_tag.mh);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_skb_vlan_add(struct sk_buff *skb, unsigned int vlan)
+{
+	unsigned char *pvlan;
+/*
+	TODO: add stat counter to mux_pp
+		mean that there is not enough bytes in header room
+		to push vlan, skb_cow will realloc skb
+
+	if (skb_headroom(skb) < MV_VLAN_HLEN) {
+		mux_skb_tx_realloc++;
+	}
+*/
+	if (skb_cow(skb, MV_VLAN_HLEN)) {
+		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	__skb_push(skb, MV_VLAN_HLEN);
+
+	memmove(skb->data, skb->data + MV_VLAN_HLEN, 2 * MV_MAC_ADDR_SIZE);
+
+	pvlan = skb->data + (2 * MV_MAC_ADDR_SIZE);
+	*(MV_U32 *)pvlan = vlan;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_vlan_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+
+	return mv_mux_skb_vlan_add(skb, pdev->tx_tag.vlan);
+}
+
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_tx_skb_dsa_add(struct net_device *dev, struct sk_buff *skb)
+{
+	/* both DSA and VLAN are 4 bytes tags, placed in the same offset in the packet */
+	return mv_mux_tx_skb_vlan_add(dev, skb);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_skb_edsa_add(struct sk_buff *skb, unsigned int edsaL, unsigned int edsaH)
+{
+	unsigned char *pedsa;
+
+	if (skb_cow(skb, MV_ETH_EDSA_SIZE)) {
+		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	__skb_push(skb, MV_ETH_EDSA_SIZE);
+
+	memmove(skb->data, skb->data + MV_ETH_EDSA_SIZE, 2 * MV_MAC_ADDR_SIZE);
+
+	pedsa = skb->data + (2 * MV_MAC_ADDR_SIZE);
+	*(MV_U32 *)pedsa = edsaL;
+	*((MV_U32 *)pedsa + 1) = edsaH;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_edsa_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+
+	return mv_mux_skb_edsa_add(skb, pdev->tx_tag.edsa[0], pdev->tx_tag.edsa[1]);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+	int err = 0;
+
+	switch (pp->tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		err = mv_mux_tx_skb_mh_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_VLAN:
+		err = mv_mux_tx_skb_vlan_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_DSA:
+		err = mv_mux_tx_skb_dsa_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_EDSA:
+		err = mv_mux_tx_skb_edsa_add(dev, skb);
+		break;
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
+		err = 1;
+	}
+	return err;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Print mux device data 								   */
+/*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_netdev_print(struct net_device *mux_dev)
+{
+
+	struct eth_netdev *pdev;
+	struct eth_port   *pp;
+
+	if (!mux_dev) {
+		printk(KERN_ERR "%s:device in NULL.\n", __func__);
+		return;
+	}
+
+	if (mv_eth_netdev_find(mux_dev->ifindex)) {
+		printk(KERN_ERR "%s: %s is not mux device.\n", __func__, mux_dev->name);
+		return;
+	}
+
+	pdev = MV_DEV_PRIV(mux_dev);
+	pp = MV_ETH_PRIV(mux_dev);
+
+	if (!pdev || !pp) {
+		printk(KERN_ERR "%s: device must be conncted to physical port\n", __func__);
+		return;
+	}
+
+	switch (pp->tag_type) {
+
+	case MV_TAG_TYPE_VLAN:
+		printk(KERN_ERR "pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
+		pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%08x, rx_dsa=0x%08x, rx_mask=0x%08x\n",
+			pp, pdev, pdev->tx_tag.dsa, pdev->rx_tag_ptrn.dsa, pdev->rx_tag_mask.dsa);
+		break;
+
+	case MV_TAG_TYPE_MH:
+		printk(KERN_ERR "pp=%p, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mh=0x%04x\n",
+			pp, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		printk(KERN_ERR "pp=%p, pdev=%p: tx_edsa=0x%08x %08x, rx_edsa=0x%08x %08x, rx_mask=0x%08x %08x\n",
+			pp, pdev, pdev->tx_tag.edsa[1], pdev->tx_tag.edsa[0],
+			pdev->rx_tag_ptrn.edsa[1], pdev->rx_tag_ptrn.edsa[0],
+			pdev->rx_tag_mask.edsa[1], pdev->rx_tag_mask.edsa[0]);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: Error, Unknown tag type\n", __func__);
+	}
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static const struct net_device_ops mv_mux_netdev_ops = {
+	.ndo_open               = mv_mux_open,
+	.ndo_stop               = mv_mux_close,
+	.ndo_start_xmit         = mv_mux_xmit,
+	.ndo_set_mac_address    = mv_mux_set_mac,
+	.ndo_do_ioctl           = mv_mux_ioctl,
+	.ndo_set_rx_mode        = mv_mux_set_rx_mode,
+/*	.ndo_set_features 	= mv_mux_set_features,*/
+};
+
+module_init(mux_proto_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
new file mode 100644
index 0000000..6ede2bf
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
@@ -0,0 +1,63 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_tag_netdev_h__
+#define __mv_tag_netdev_h__
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/ip.h>
+
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mv802_3.h"
+#include "mv_netdev.h"
+
+/* operations requested by mux device from switch device */
+struct switch_device_ops {
+	int	(*group_enable)(int group_id);
+	int	(*group_disable)(int group_id);
+	int	(*link_status)(int group_id);
+	int	(*mac_update)(int group_id, unsigned char *old_mac, unsigned char *new_mac);
+};
+
+int mv_mux_switch_ops_set(struct switch_device_ops *switch_ops_ptr);
+int mv_mux_update_link(void *cookie, int link_up);
+
+struct net_device *mv_mux_netdev_add(struct eth_port *pp, struct net_device *mux_dev);
+struct net_device *mv_mux_netdev_alloc(char* name, int idx, MV_MUX_TAG *tag_cfg);
+char *mv_mux_get_mac(struct net_device *mux_dev);
+int mv_mux_netdev_delete(struct net_device *mux_dev);
+int mv_mux_tag_type_set(struct eth_port *pp, int type);
+void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid);
+void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg);
+int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev);
+void mv_mux_netdev_print(struct net_device *mux_dev);
+
+#endif /* __mv_tag_netdev_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
new file mode 100644
index 0000000..048be06
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
@@ -0,0 +1,247 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "mv_netdev.h"
+#include "mv_mux_netdev.h"
+MV_MUX_TAG mux_cfg;
+
+static ssize_t mv_mux_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [if_name]                 > dump        - Dump mux device\n");
+	off += sprintf(buf+off, "echo [if_name] p               > add          - Attach to gbe [p] new virtual interface [if_name]\n");
+	off += sprintf(buf+off, "echo [if_name]                 > del          - Remove from gbe [p] virtual interface [if_name]\n");
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo p {0|1|2|3|4}             > tag_type     - Set gbe port [p] tag type: 0-NONE, 1-MH, 2-DSA, 3-EDSA, 4-VID.\n");
+	off += sprintf(buf+off, "echo [if_name] vid             > mux_vid      - Set virtual interface [if_name] vid value.\n");
+	off += sprintf(buf+off, "echo [if_name] mh mask         > mh_rx        - Set virtual port Marvell header RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] dsa mask        > dsa_rx       - Set virtual port DSA RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] tagL mask       > edsa_low_rx  - Set virtual port EDSA low RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] tagH mask       > edsa_high_rx - Set virtual port EDSA high RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] mh              > mh_tx        - Set virtual port Marvell header tX tag\n");
+	off += sprintf(buf+off, "echo [if_name] dsa             > dsa_tx       - Set virtual port DSA TX tag\n");
+	off += sprintf(buf+off, "echo [if_name] tagH tagL       > edsa_tx      - Set virtual port EDSA TX tag\n");
+
+	return off;
+}
+
+
+static ssize_t mv_mux_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+/*
+	const char      *name = attr->attr.name;
+	int             off = 0;
+*/
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	return mv_mux_help(buf);
+}
+
+
+static ssize_t mv_mux_netdev_store(struct device *dev,
+					struct device_attribute *attr, const char *buf, size_t len)
+{
+	struct net_device *mux_dev;
+	const char        *name = attr->attr.name;
+	int               a = 0, b = 0, err = 0;
+	char              dev_name[IFNAMSIZ];
+
+	if (!capable(CAP_NET_ADMIN))
+	return -EPERM;
+
+	sscanf(buf, "%s %x %x", dev_name, &a, &b);
+	mux_dev = dev_get_by_name(&init_net, dev_name);
+
+	if (!strcmp(name, "dump")) {
+		mv_mux_netdev_print(mux_dev);
+
+	} else if (!strcmp(name, "mux_vid")) {
+		mv_mux_vlan_set(&mux_cfg, a);
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "mh_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.mh = a;
+		mux_cfg.rx_tag_mask.mh = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "dsa_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.dsa = a;
+		mux_cfg.rx_tag_mask.dsa = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_low_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.edsa[0] = a;
+		mux_cfg.rx_tag_mask.edsa[0] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_high_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.edsa[1] = a;
+		mux_cfg.rx_tag_mask.edsa[1] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	}  else if (!strcmp(name, "mh_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.mh = a;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	}  else if (!strcmp(name, "dsa_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.dsa = a;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.edsa[0] = a;
+		mux_cfg.tx_tag.edsa[1] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "add")) {
+		struct eth_port *pp = mv_eth_port_by_id(a);
+		err =  mv_mux_netdev_add(pp, mux_dev) ? 0 : 1;
+
+	} else if (!strcmp(name, "del")) {
+		mux_dev = dev_get_by_name(&init_net, dev_name);
+		err = mv_mux_netdev_delete(mux_dev);
+	}
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_mux_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    a, b;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	a = b = err = 0;
+
+	sscanf(buf, "%x %x", &a, &b);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "tag_type")) {
+		struct eth_port *pp = mv_eth_port_by_id(a);
+		mv_mux_tag_type_set(pp, b);
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+static DEVICE_ATTR(add,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(del,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mux_vid,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mh_rx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(dsa_rx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_low_rx,  S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_high_rx, S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mh_tx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(dsa_tx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_tx,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(tag_type,     S_IWUSR, mv_mux_show, mv_mux_store);
+static DEVICE_ATTR(dump,         S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(help,         S_IRUSR, mv_mux_show, NULL);
+
+
+static struct attribute *mv_mux_attrs[] = {
+
+	&dev_attr_add.attr,
+	&dev_attr_del.attr,
+	&dev_attr_mux_vid.attr,
+	&dev_attr_mh_rx.attr,
+	&dev_attr_dsa_rx.attr,
+	&dev_attr_edsa_low_rx.attr,
+	&dev_attr_edsa_high_rx.attr,
+	&dev_attr_mh_tx.attr,
+	&dev_attr_dsa_tx.attr,
+	&dev_attr_edsa_tx.attr,
+	&dev_attr_tag_type.attr,
+	&dev_attr_help.attr,
+	&dev_attr_dump.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_group = {
+	.name = "mux",
+	.attrs = mv_mux_attrs,
+};
+
+int __devinit mv_mux_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "ppv2");
+	if (!pd) {
+		platform_device_register_simple("ppv2", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "ppv2");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR"%s: cannot find neta device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &mv_eth_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+out:
+	return err;
+}
+
+module_init(mv_mux_sysfs_init);
+
+MODULE_AUTHOR("Uri Eliyahu");
+MODULE_DESCRIPTION("sysfs for marvell GbE");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 00cfe27..3732fbd 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -34,6 +34,7 @@ disclaimer.
 #include <linux/skbuff.h>
 #include <linux/module.h>
 #include <linux/inetdevice.h>
+#include <linux/interrupt.h>
 #include <linux/mv_pp2.h>
 #include <asm/setup.h>
 #include <net/ip.h>
@@ -53,6 +54,8 @@ disclaimer.
 #include "prs/mvPp2Prs.h"
 #include "prs/mvPp2PrsHw.h"
 #include "cls/mvPp2Classifier.h"
+
+#include "mv_mux_netdev.h"
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
 
@@ -60,7 +63,6 @@ disclaimer.
 
 #define MV_ETH_TX_PENDING_TIMEOUT_MSEC     1000
 
-void handle_group_affinity(int port);
 static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb);
 
 #ifdef CONFIG_NET_SKB_RECYCLE
@@ -80,9 +82,6 @@ int mv_eth_ctrl_recycle(int en)
 }
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
-extern unsigned int switch_enabled_ports;
-unsigned int ext_switch_port_mask = 0;
-
 struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 struct eth_port **mv_eth_ports;
 struct net_device **mv_net_devs;
@@ -118,7 +117,6 @@ static int  mv_eth_config_get(struct platform_device *pdev, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
 struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 					struct platform_device *pdev);
-static void mv_eth_netdev_set_features(struct net_device *dev);
 static void mv_eth_netdev_update_features(struct net_device *dev);
 
 static MV_STATUS mv_eth_pool_create(int pool, int capacity);
@@ -455,10 +453,10 @@ struct net_device *mv_eth_netdev_by_id(unsigned int idx)
 
 static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
 {
-	/* sanity: Check that there is place for MH in the buffer */
-	if (skb_headroom(skb) < MV_ETH_MH_SIZE) {
+       /* sanity: Check that there is place for MH in the buffer */
+       if (skb_headroom(skb) < MV_ETH_MH_SIZE) {
 		printk(KERN_ERR "%s: skb (%p) doesn't have place for MH, head=%p, data=%p\n",
-		       __func__, skb, skb->head, skb->data);
+		__func__, skb, skb->head, skb->data);
 		return 1;
 	}
 
@@ -470,12 +468,18 @@ static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
 	return 0;
 }
 
+static inline int mv_eth_mh_skb_skip(struct sk_buff *skb)
+{
+	__skb_pull(skb, MV_ETH_MH_SIZE);
+	return MV_ETH_MH_SIZE;
+}
+
 void mv_eth_ctrl_txdone(int num)
 {
 	mv_ctrl_txdone = num;
 }
 
-int mv_eth_ctrl_flag(int port, u32 flag, u32 val)
+int mv_eth_ctrl_tx_flag(int port, u32 flag, u32 val)
 {
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	u32 bit_flag = (fls(flag) - 1);
@@ -483,19 +487,27 @@ int mv_eth_ctrl_flag(int port, u32 flag, u32 val)
 	if (!pp)
 		return -ENODEV;
 
-	if ((flag == MV_ETH_F_MH) && (pp->flags & MV_ETH_F_SWITCH)) {
-		printk(KERN_ERR "Error: cannot change Marvell Header on a port used by the Gateway driver\n");
-		return -EPERM;
-	}
+	if (val)
+		set_bit(bit_flag, &(pp->tx_spec.flags));
+	else
+		clear_bit(bit_flag, &(pp->tx_spec.flags));
+
+	return 0;
+}
+
+int mv_eth_ctrl_flag(int port, u32 flag, u32 val)
+{
+	struct eth_port *pp = mv_eth_port_by_id(port);
+	u32 bit_flag = (fls(flag) - 1);
+
+	if (!pp)
+		return -ENODEV;
 
 	if (val)
 		set_bit(bit_flag, &(pp->flags));
 	else
 		clear_bit(bit_flag, &(pp->flags));
 
-	if (flag == MV_ETH_F_MH)
-		mvPp2MhSet(pp->port, val ? MV_PP2_MH : MV_PP2_MH_NONE);
-
 	return 0;
 }
 
@@ -721,7 +733,7 @@ int mv_eth_ctrl_txq_cpu_def(int port, int txp, int txq, int cpu)
 	if ((pp == NULL) || (pp->txq_ctrl == NULL))
 		return -ENODEV;
 
-	pp->txp = txp;
+	pp->tx_spec.txp = txp;
 	pp->cpu_config[cpu]->txq = txq;
 
 	return 0;
@@ -734,7 +746,7 @@ int mv_eth_ctrl_tx_mh(int port, u16 mh)
 	if (!pp)
 		return -ENODEV;
 
-	pp->tx_mh = mh;
+	pp->tx_spec.tx_mh = MV_16BIT_BE(mh);
 
 	return 0;
 }
@@ -746,8 +758,8 @@ int mv_eth_ctrl_tx_cmd_dsa(int port, u16 dsa_tag)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[0] &= ~((0x3) << 14);
-	pp->hw_cmd[0] |= (dsa_tag & 0x3) << 14;
+	pp->tx_spec.hw_cmd[0] &= ~PP2_TX_DSA_ALL_MASK;
+	pp->tx_spec.hw_cmd[0] |= PP2_TX_DSA_MASK(dsa_tag);
 
 	return 0;
 }
@@ -759,8 +771,8 @@ int mv_eth_ctrl_tx_cmd_color(int port, u16 color)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[0] &= ~((0x3) << 12);
-	pp->hw_cmd[0] |= (color & 0x3) << 12;
+	pp->tx_spec.hw_cmd[0] &= ~PP2_TX_COLOR_ALL_MASK;
+	pp->tx_spec.hw_cmd[0] |= PP2_TX_COLOR_MASK(color);
 
 	return 0;
 }
@@ -772,8 +784,8 @@ int mv_eth_ctrl_tx_cmd_gem_id(int port, u16 gem_port_id)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[0] &= ~(0xfff);
-	pp->hw_cmd[0] |= (gem_port_id & 0xfff);
+	pp->tx_spec.hw_cmd[0] &= ~PP2_TX_GEMPID_ALL_MASK;
+	pp->tx_spec.hw_cmd[0] |= PP2_TX_GEMPID_MASK(gem_port_id);
 
 	return 0;
 }
@@ -785,8 +797,10 @@ int mv_eth_ctrl_tx_cmd_pon_fec(int port, u16 pon_fec)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[3] &= ~((0x1) << 11);
-	pp->hw_cmd[3] |= (pon_fec & 0x1) << 11;
+	if (pon_fec == 0)
+		pp->tx_spec.hw_cmd[2] &= ~PP2_TX_PON_FEC_MASK;
+	else
+		pp->tx_spec.hw_cmd[2] |= PP2_TX_PON_FEC_MASK;
 
 	return 0;
 }
@@ -798,8 +812,10 @@ int mv_eth_ctrl_tx_cmd_gem_oem(int port, u16 gem_oem)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[3] &= ~((0x1) << 9);
-	pp->hw_cmd[3] |= (gem_oem & 0x1) << 9;
+	if (gem_oem == 0)
+		pp->tx_spec.hw_cmd[2] &= ~PP2_TX_GEM_OEM_MASK;
+	else
+		pp->tx_spec.hw_cmd[2] |= PP2_TX_GEM_OEM_MASK;
 
 	return 0;
 }
@@ -807,11 +823,16 @@ int mv_eth_ctrl_tx_cmd_gem_oem(int port, u16 gem_oem)
 int mv_eth_ctrl_tx_cmd_mod(int port, u16 mod)
 {
 	struct eth_port *pp = mv_eth_port_by_id(port);
+	u32 mask = (PP2_TX_MOD_DSCP_MASK | PP2_TX_MOD_PRIO_MASK | PP2_TX_MOD_DSCP_EN_MASK
+			| PP2_TX_MOD_PRIO_EN_MASK | PP2_TX_MOD_GEMPID_EN_MASK);
 
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[1] = mod;
+	/* This command update all fields in the TX descriptor offset 0x14 */
+	/* MOD_DSCP - 6 bits, MOD_PRIO - 3bits, MOD_DSCP_EN - 1b, MOD_PRIO_EN - 1b, MOD_GEMPID_EN - 1b */
+	pp->tx_spec.hw_cmd[1] &= ~mask;
+	pp->tx_spec.hw_cmd[1] |= ((mod << PP2_TX_MOD_DSCP_OFFS) & mask);
 
 	return 0;
 }
@@ -823,7 +844,8 @@ int mv_eth_ctrl_tx_cmd_pme_dptr(int port, u16 pme_dptr)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[2] = pme_dptr;
+	pp->tx_spec.hw_cmd[2] &= ~PP2_TX_PME_DPTR_ALL_MASK;
+	pp->tx_spec.hw_cmd[2] |= PP2_TX_PME_DPTR_MASK(pme_dptr);
 
 	return 0;
 }
@@ -835,8 +857,8 @@ int mv_eth_ctrl_tx_cmd_pme_prog(int port, u16 pme_prog)
 	if (!pp)
 		return -ENODEV;
 
-	pp->hw_cmd[3] &= ~(0xff);
-	pp->hw_cmd[3] |= (pme_prog & 0xff);
+	pp->tx_spec.hw_cmd[2] &= ~PP2_TX_PME_IPTR_ALL_MASK;
+	pp->tx_spec.hw_cmd[2] |= PP2_TX_PME_IPTR_MASK(pme_prog);
 
 	return 0;
 }
@@ -867,8 +889,7 @@ void mv_eth_rx_special_proc_func(int port, void (*func)(int port, int rxq, struc
 }
 #endif /* CONFIG_MV_ETH_RX_SPECIAL */
 
-static inline u16 mv_eth_select_txq(struct net_device *dev,
-									struct sk_buff *skb)
+static inline u16 mv_eth_select_txq(struct net_device *dev, struct sk_buff *skb)
 {
 	struct eth_port *pp = MV_ETH_PRIV(dev);
 	return mv_eth_tx_policy(pp, skb);
@@ -889,13 +910,21 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_open = mv_eth_open,
 	.ndo_stop = mv_eth_stop,
 	.ndo_start_xmit = mv_eth_tx,
+/*TODO - this is a hack by Seif M. need to fix this to properly move to linux 3.2!!!
+.ndo_set_multicast_list = mv_eth_set_multicast_list,
+*/
 	.ndo_change_rx_flags = mv_eth_set_multicast_list,
 	.ndo_set_mac_address = mv_eth_set_mac_addr,
 	.ndo_change_mtu = mv_eth_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
 	.ndo_select_queue = mv_eth_select_txq,
+/*
+.ndo_change_rx_flags = mv_eth_change_rx_flags,
+.ndo_set_rx_mode = mv_eth_set_rx_mode,
+*/
 };
 
+
 void mv_eth_link_status_print(int port)
 {
 	MV_ETH_PORT_STATUS link;
@@ -981,11 +1010,16 @@ void mv_eth_rx_desc_print(struct pp2_rx_desc *desc)
 		printk(KERN_CONT "%8.8x ", *words++);
 	printk(KERN_CONT "\n");
 
-	printk(KERN_CONT "pkt_size=%d, L3_offs=%d, IP_hlen=%d, L3=",
+	printk(KERN_CONT "pkt_size=%d, L3_offs=%d, IP_hlen=%d, ",
 	       desc->dataSize,
 	       (desc->status & PP2_RX_L3_OFFSET_MASK) >> PP2_RX_L3_OFFSET_OFFS,
 	       (desc->status & PP2_RX_IP_HLEN_MASK) >> PP2_RX_IP_HLEN_OFFS);
 
+	printk(KERN_CONT "VLAN=");
+	printk(KERN_CONT "0x%s, ",
+		mvPrsVlanInfoStr((desc->parserInfo & PP2_RX_VLAN_INFO_MASK) >> PP2_RX_VLAN_INFO_OFFS));
+
+	printk(KERN_CONT "L3=");
 	if (PP2_RX_L3_IS_IP4(desc->status))
 		printk(KERN_CONT "IPv4 (hdr=%s), ", PP2_RX_IP4_HDR_ERR(desc->status) ? "bad" : "ok");
 	else if (PP2_RX_L3_IS_IP4_OPT(desc->status))
@@ -1012,7 +1046,9 @@ void mv_eth_rx_desc_print(struct pp2_rx_desc *desc)
 
 	printk(KERN_CONT "\n");
 
-	printk(KERN_INFO "Lookup_ID=0x%X\n", desc->parserInfo & PP2_RX_LKP_ID_MASK);
+	printk(KERN_INFO "Lookup_ID=0x%x, cpu_code=0x%x\n",
+		(desc->parserInfo & PP2_RX_LKP_ID_MASK) >> PP2_RX_LKP_ID_OFFS,
+		(desc->parserInfo & PP2_RX_CPU_CODE_MASK) >> PP2_RX_CPU_CODE_OFFS);
 }
 EXPORT_SYMBOL(mv_eth_rx_desc_print);
 
@@ -1040,27 +1076,6 @@ void mv_eth_pkt_print(struct eth_pbuf *pkt)
 }
 EXPORT_SYMBOL(mv_eth_pkt_print);
 
-static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_desc, struct sk_buff *skb)
-{
-#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
-	if (pp->rx_csum_offload) {
-		if ((PP2_RX_L3_IS_IP4(rx_desc->status) && !PP2_RX_IP4_HDR_ERR(rx_desc->status)) ||
-			(PP2_RX_L3_IS_IP6(rx_desc->status))) {
-			if ((PP2_RX_L4_IS_UDP(rx_desc->status) || PP2_RX_L4_IS_TCP(rx_desc->status)) &&
-				(PP2_RX_L4_CHK_OK(rx_desc->status))) {
-				skb->csum = 0;
-				skb->ip_summed = CHECKSUM_UNNECESSARY;
-				STAT_DBG(pp->stats.rx_csum_hw++);
-				return;
-			}
-		}
-	}
-#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
-
-	skb->ip_summed = CHECKSUM_NONE;
-	STAT_DBG(pp->stats.rx_csum_sw++);
-}
-
 static inline int mv_eth_tx_done_policy(u32 cause)
 {
 	return fls(cause) - 1;
@@ -1371,6 +1386,9 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 	int mc_id, pool_id;
 	PP2_BUFF_HDR *buff_hdr;
 	MV_U32 buff_phys_addr, buff_virt_addr, buff_phys_addr_next, buff_virt_addr_next;
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	int count = 0;
+#endif
 
 	pool_id = (rx_status & PP2_RX_BM_POOL_ALL_MASK) >> PP2_RX_BM_POOL_ID_OFFS;
 	buff_phys_addr = rx_desc->bufPhysAddr;
@@ -1408,7 +1426,7 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 
 static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 {
-	struct net_device *dev;
+	struct net_device *dev = pp->dev;
 	MV_PP2_PHYS_RXQ_CTRL *rx_ctrl = pp->rxq_ctrl[rxq].q;
 	int rx_done, rx_filled, err;
 	struct pp2_rx_desc *rx_desc;
@@ -1454,7 +1472,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 			printk(KERN_ERR "\n%s: port=%d, cpu=%d\n", __func__, pp->port, smp_processor_id());
 			mv_eth_rx_desc_print(rx_desc);
 		}
-#endif
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
 		rx_status = rx_desc->status;
 		/* check if buffer header is used */
@@ -1478,12 +1496,10 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		/* Speculative ICache prefetch WA: should be replaced with dma_unmap_single (invalidate l2) */
 		mvOsCacheMultiLineInv(NULL, pkt->pBuf + pkt->offset, rx_desc->dataSize);
 
-		dev = pp->dev;
-
 		STAT_DBG(pp->stats.rxq[rxq]++);
 		dev->stats.rx_packets++;
 
-		rx_bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
+		rx_bytes = rx_desc->dataSize;
 		dev->stats.rx_bytes += rx_bytes;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
@@ -1493,11 +1509,15 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
+		/* Linux processing */
+		skb = (struct sk_buff *)(pkt->osInfo);
+		__skb_put(skb, rx_bytes);
+
 #if defined(CONFIG_MV_ETH_RX_SPECIAL)
 		/* Special RX processing */
-		if (PP2_RX_IS_RX_SPECIAL(rx_desc->parserInfo)) {
+		if (mvPp2IsRxSpecial(rx_desc->parserInfo)) {
 			if (pp->rx_special_proc) {
-				pp->rx_special_proc(pp->port, rxq, dev, (struct sk_buff *)(pkt->osInfo), rx_desc);
+				pp->rx_special_proc(pp->port, rxq, dev, skb, rx_desc);
 				STAT_INFO(pp->stats.rx_special++);
 
 				/* Refill processing */
@@ -1512,15 +1532,6 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		}
 #endif /* CONFIG_MV_ETH_RX_SPECIAL */
 
-		/* Linux processing */
-		skb = (struct sk_buff *)(pkt->osInfo);
-
-		skb->data += MV_ETH_MH_SIZE;
-		skb->tail += (rx_bytes + MV_ETH_MH_SIZE);
-		skb->len = rx_bytes;
-
-		skb->protocol = eth_type_trans(skb, dev);
-
 #ifdef CONFIG_NET_SKB_RECYCLE
 		if (mv_eth_is_recycle()) {
 			skb->skb_recycle = mv_eth_skb_recycle;
@@ -1529,8 +1540,16 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		}
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
-		if (skb)
-			mv_eth_rx_csum(pp, rx_desc, skb);
+		mv_eth_rx_csum(pp, rx_desc, skb);
+
+		if (pp->tag_type != MV_TAG_TYPE_NONE) {
+			mv_mux_rx(skb, dev);
+			STAT_INFO(pp->stats.rx_tagged++);
+			skb = NULL;
+		} else {
+			dev->stats.rx_bytes -= mv_eth_mh_skb_skip(skb);
+			skb->protocol = eth_type_trans(skb, dev);
+		}
 
 		if (skb) {
 			STAT_DBG(pp->stats.rx_netif++);
@@ -1558,12 +1577,9 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 {
 	struct eth_port *pp = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 	int frags = 0, cpu = smp_processor_id();
-	bool tx_spec_ready = false;
-	struct mv_eth_tx_spec tx_spec;
 	u32 tx_cmd;
-	u16 mh;
+	struct mv_eth_tx_spec tx_spec, *tx_spec_ptr = NULL;
 	struct tx_queue *txq_ctrl = NULL;
 	struct txq_cpu_ctrl *txq_cpu_ptr = NULL;
 	struct aggr_tx_queue *aggr_txq_ctrl = NULL;
@@ -1593,26 +1609,23 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 				goto out;
 			} else {
 				/* Check validity of tx_spec txp/txq must be CPU owned */
-				tx_spec_ready = true;
+				tx_spec_ptr = &tx_spec;
 			}
 		}
 	}
 #endif /* CONFIG_MV_ETH_TX_SPECIAL */
+
 	/* Get TXQ (without BM) to send packet generated by Linux */
-	if (tx_spec_ready == false) {
-		tx_spec.txp = pp->txp;
-		tx_spec.txq = mv_eth_tx_policy(pp, skb);
-		tx_spec.hw_cmd[0] = pp->hw_cmd[0];
-		tx_spec.hw_cmd[1] = pp->hw_cmd[1];
-		tx_spec.hw_cmd[2] = pp->hw_cmd[2];
-		tx_spec.hw_cmd[3] = pp->hw_cmd[3];
-		tx_spec.flags = pp->flags;
+	if (tx_spec_ptr == NULL) {
+		tx_spec_ptr = &pp->tx_spec;
+		tx_spec_ptr->txq = mv_eth_select_txq(dev, skb);
 	}
 
 	aggr_txq_ctrl = &aggr_txqs[smp_processor_id()];
-	txq_ctrl = &pp->txq_ctrl[tx_spec.txp * CONFIG_MV_ETH_TXQ + tx_spec.txq];
+	txq_ctrl = &pp->txq_ctrl[tx_spec_ptr->txp * CONFIG_MV_ETH_TXQ + tx_spec_ptr->txq];
 	if (txq_ctrl == NULL) {
-		printk(KERN_ERR "%s: invalidate txp/txq (%d/%d)\n", __func__, tx_spec.txp, tx_spec.txq);
+		printk(KERN_ERR "%s: invalidate txp/txq (%d/%d)\n",
+			__func__, tx_spec_ptr->txp, tx_spec_ptr->txq);
 		goto out;
 	}
 	txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
@@ -1620,24 +1633,20 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 #ifdef CONFIG_MV_ETH_TSO
 	/* GSO/TSO */
 	if (skb_is_gso(skb)) {
-		frags = mv_eth_tx_tso(skb, dev, &tx_spec, txq_cpu_ptr, aggr_txq_ctrl);
+		frags = mv_eth_tx_tso(skb, dev, tx_spec_ptr, txq_cpu_ptr, aggr_txq_ctrl);
 		goto out;
 	}
 #endif /* CONFIG_MV_ETH_TSO */
 
 	frags = skb_shinfo(skb)->nr_frags + 1;
 
-	if (tx_spec.flags & MV_ETH_F_MH) {
-		if (tx_spec.flags & MV_ETH_F_SWITCH)
-			mh = dev_priv->tx_vlan_mh;
-		else
-			mh = pp->tx_mh;
-
-		if (mv_eth_skb_mh_add(skb, mh)) {
+	if (tx_spec_ptr->flags & MV_ETH_TX_F_MH) {
+		if (mv_eth_skb_mh_add(skb, tx_spec_ptr->tx_mh)) {
 			frags = 0;
 			goto out;
 		}
 	}
+
 	/* is enough descriptors? */
 	if ((!mv_eth_phys_desc_num_check(txq_cpu_ptr, frags)) ||
 		(!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags))) {
@@ -1647,18 +1656,17 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 
 	tx_desc = mvPp2AggrTxqNextDescGet(aggr_txq_ctrl->q);
 
-	tx_desc->physTxq = MV_PPV2_TXQ_PHYS(pp->port, tx_spec.txp, tx_spec.txq);
+	tx_desc->physTxq = MV_PPV2_TXQ_PHYS(pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq);
 
 	/* Don't use BM for Linux packets: NETA_TX_BM_ENABLE_MASK = 0 */
 	/* NETA_TX_PKT_OFFSET_MASK = 0 - for all descriptors */
 	tx_cmd = mv_eth_skb_tx_csum(pp, skb);
 
-#ifdef CONFIG_MV_PON
-	tx_desc->ponHwCmd = tx_spec.hw_cmd[0];
-	tx_desc->modifyInfo[0] = tx_spec.hw_cmd[1];
-	tx_desc->modifyInfo[1] = tx_spec.hw_cmd[2];
-	tx_desc->modifyInfo[2] = tx_spec.hw_cmd[3];
-#endif
+	if (tx_spec_ptr->flags & MV_ETH_TX_F_HW_CMD) {
+		tx_desc->hwCmd[0] = tx_spec_ptr->hw_cmd[0];
+		tx_desc->hwCmd[1] = tx_spec_ptr->hw_cmd[1];
+		tx_desc->hwCmd[2] = tx_spec_ptr->hw_cmd[2];
+	}
 
 	/* FIXME: beware of nonlinear --BK */
 	tx_desc->dataSize = skb_headlen(skb);
@@ -1669,7 +1677,7 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 		/*
 		 * First and Last descriptor
 		 */
-		if (tx_spec.flags & MV_ETH_F_NO_PAD)
+		if (tx_spec.flags & MV_ETH_TX_F_NO_PAD)
 			tx_cmd |= PP2_TX_F_DESC_MASK | PP2_TX_L_DESC_MASK | PP2_TX_PADDING_DISABLE_MASK;
 		else
 			tx_cmd |= PP2_TX_F_DESC_MASK | PP2_TX_L_DESC_MASK;
@@ -1688,14 +1696,10 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 		mv_eth_tx_desc_flush(tx_desc);
 
 		/* Continue with other skb fragments */
-		mv_eth_tx_frag_process(pp, skb, aggr_txq_ctrl, txq_ctrl, &tx_spec);
+		mv_eth_tx_frag_process(pp, skb, aggr_txq_ctrl, txq_ctrl, tx_spec_ptr);
 		STAT_DBG(pp->stats.tx_sg++);
 	}
-/*
-	printk(KERN_ERR "tx: frags=%d, tx_desc[0x0]=%x [0xc]=%x, wr_id=%d, rd_id=%d, skb=%p\n",
-			frags, tx_desc->command,tx_desc->hw_cmd,
-			txq_ctrl->shadow_txq_put_i, txq_ctrl->shadow_txq_get_i, skb);
-*/
+
 	txq_cpu_ptr->txq_count += frags;
 	aggr_txq_ctrl->txq_count += frags;
 
@@ -1704,7 +1708,7 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 		printk(KERN_ERR "\n");
 		printk(KERN_ERR "%s - eth_tx_%lu: cpu=%d, in_intr=0x%lx, port=%d, txp=%d, txq=%d\n",
 			dev->name, dev->stats.tx_packets, smp_processor_id(), in_interrupt(),
-			pp->port, tx_spec.txp, tx_spec.txq);
+			pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq);
 		printk(KERN_ERR "\t skb=%p, head=%p, data=%p, size=%d\n", skb, skb->head, skb->data, skb->len);
 		mv_eth_tx_desc_print(tx_desc);
 		/*mv_eth_skb_print(skb);*/
@@ -1730,10 +1734,14 @@ out:
 #ifndef CONFIG_MV_ETH_TXDONE_ISR
 	if (txq_ctrl) {
 		if (txq_cpu_ptr->txq_count >= mv_ctrl_txdone) {
-			STAT_DIST(u32 tx_done = )mv_eth_txq_done(pp, txq_ctrl);
-
-			STAT_DIST((tx_done < pp->dist_stats.tx_done_dist_size) ? pp->dist_stats.tx_done_dist[tx_done]++ : 0);
+#ifdef CONFIG_MV_ETH_STAT_DIST
+			u32 tx_done = mv_eth_txq_done(pp, txq_ctrl);
 
+			if (tx_done < pp->dist_stats.tx_done_dist_size)
+				pp->dist_stats.tx_done_dist[tx_done]++;
+#else
+			mv_eth_txq_done(pp, txq_ctrl);
+#endif /* CONFIG_MV_ETH_STAT_DIST */
 		}
 		/* If after calling mv_eth_txq_done, txq_ctrl->txq_count equals frags, we need to set the timer */
 		if ((txq_cpu_ptr->txq_count == frags) && (frags > 0))
@@ -1877,7 +1885,6 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 	skb_frag_t *skb_frag_ptr;
 	const struct tcphdr *th = tcp_hdr(skb);
 	struct eth_port *priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 	MV_U16 *mh = NULL;
 	int i;
 
@@ -1944,12 +1951,8 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 		aggr_txq_ctrl->txq_count++;
 		txq_ctrl->txq_count++;
 
-		if (tx_spec->flags & MV_ETH_F_MH) {
-			if (tx_spec->flags & MV_ETH_F_SWITCH)
-				mh = &dev_priv->tx_vlan_mh;
-			else
-				mh = &priv->tx_mh;
-		}
+		if (tx_spec->flags & MV_ETH_TX_F_MH)
+			mh = &tx_spec->tx_mh;
 
 		/* prepare packet headers: MAC + IP + TCP */
 		size = mv_eth_tso_build_hdr_desc(tx_desc, priv, skb, txq_ctrl, mh,
@@ -2166,7 +2169,7 @@ static void mv_eth_tx_frag_process(struct eth_port *pp, struct sk_buff *skb, str
 
 		if (i == (skb_shinfo(skb)->nr_frags - 1)) {
 			/* Last descriptor */
-			if (tx_spec->flags & MV_ETH_F_NO_PAD)
+			if (tx_spec->flags & MV_ETH_TX_F_NO_PAD)
 				tx_desc->command = (PP2_TX_L_DESC_MASK | PP2_TX_PADDING_DISABLE_MASK);
 			else
 				tx_desc->command = PP2_TX_L_DESC_MASK;
@@ -2466,6 +2469,48 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+irqreturn_t mv_eth_link_isr(int irq, void *dev_id)
+{
+	int port;
+	MV_U32 regVal, isr_ports_mask;
+	struct eth_port *pp;
+
+	regVal = mvEthIsrSummaryCauseGet();
+
+	mvEthIsrSummaryMask();
+
+	isr_ports_mask = ETH_ISR_SUM_PORT_MASK(regVal);
+
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		/* check if interrupt was caused by this port */
+		if (!(port & isr_ports_mask))
+			continue;
+
+		regVal = mvEthPortIsrCauseGet(port);
+		/* check for link change interrupt */
+		if (!(regVal & ETH_PORT_LINK_CHANGE_MASK))
+			continue;
+
+		pp = mv_eth_port_by_id(port);
+		if (pp)
+			mv_eth_link_event(pp, 1);
+	}
+
+	mvEthIsrSummaryUnmask();
+
+	return IRQ_HANDLED;
+}
+
+static bool mv_eth_link_status(struct eth_port *pp)
+{
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		return mv_pon_link_status();
+	else
+#endif /* CONFIG_MV_PON */
+		return mvEthPortIsLinkUp(pp->port);
+}
+
 void mv_eth_link_event(struct eth_port *pp, int print)
 {
 	struct net_device *dev = pp->dev;
@@ -2474,12 +2519,7 @@ void mv_eth_link_event(struct eth_port *pp, int print)
 	STAT_INFO(pp->stats.link++);
 
 	/* Check Link status on ethernet port */
-#ifdef CONFIG_MV_PON
-	if (MV_PON_PORT(pp->port))
-		link_is_up = mv_pon_link_status();
-	else
-#endif /* CONFIG_MV_PON */
-		link_is_up = mvEthPortIsLinkUp(pp->port);
+	link_is_up = mv_eth_link_status(pp);
 
 	if (link_is_up) {
 		mvPp2PortUp(pp->port);
@@ -2842,12 +2882,8 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	}
 
 	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
-	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
-		if (pp->flags & MV_ETH_F_SWITCH)
-			printk(KERN_ERR "%s: a GbE port using the Gateway driver cannot be disconnected from Linux\n", __func__);
-		else
+	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
 			mv_eth_open(pp->dev);
-	}
 
 	return 0;
 }
@@ -2877,14 +2913,20 @@ int mv_eth_port_resume(int port)
 void 	mv_eth_win_init()
 {
 
-	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_UNIT_WIN_INFO *addrWinMap;
 	MV_STATUS status;
 	int i;
 
-	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
-	if (status != MV_OK)
+	addrWinMap = kmalloc(sizeof(MV_UNIT_WIN_INFO) * (MAX_TARGETS + 1), GFP_KERNEL);
+	if (addrWinMap == NULL)
 		return;
 
+	memset(addrWinMap, 0, sizeof(MV_UNIT_WIN_INFO) * (MAX_TARGETS + 1));
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK) {
+		kfree(addrWinMap);
+		return;
+	}
 	for (i = 0; i < MAX_TARGETS; i++) {
 		if (addrWinMap[i].enable == MV_FALSE)
 			continue;
@@ -2899,6 +2941,7 @@ void 	mv_eth_win_init()
 #endif
 	}
 	mvPp2WinInit(0, addrWinMap);
+	kfree(addrWinMap);
 	return;
 }
 
@@ -2970,6 +3013,10 @@ static int	mv_eth_shared_probe(void)
 			printk(KERN_ERR "%s: Warning Classifier defauld init failed\n", __func__);
 	}
 
+	/* request IRQ for link interrupts from GOP */
+	if (request_irq(IRQ_GLOBAL_GOP, mv_eth_link_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth_link", NULL))
+		printk(KERN_ERR "%s: Could not request IRQ for GOP interrupts\n", __func__);
+
 	mv_eth_initialized = 1;
 	return 0;
 
@@ -3000,6 +3047,9 @@ static int mv_eth_probe(struct platform_device *pdev)
 
 		mv_eth_ports_num = mvCtrlEthMaxPortGet();
 		mv_net_devs_max = mv_eth_ports_num;
+#ifdef CONFIG_MV_ETH_SWITCH
+		mv_net_devs_max += (CONFIG_MV_ETH_SWITCH_NETDEV_NUM - 1);
+#endif /* CONFIG_MV_ETH_SWITCH */
 
 		if (mv_eth_shared_probe())
 			return -ENODEV;
@@ -3060,24 +3110,26 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 {
 	int cpu;
 	struct net_device *dev;
-	struct eth_dev_priv *dev_priv;
+	struct eth_netdev *dev_priv;
 	struct cpu_ctrl	*cpuCtrl;
 
-	dev = alloc_etherdev_mq(sizeof(struct eth_dev_priv), CONFIG_MV_ETH_TXQ);
+	dev = alloc_etherdev_mq(sizeof(struct eth_netdev), CONFIG_MV_ETH_TXQ);
 	if (!dev)
 		return NULL;
 
-	dev_priv = (struct eth_dev_priv *)netdev_priv(dev);
+	dev_priv = (struct eth_netdev *)netdev_priv(dev);
 	if (!dev_priv)
 		return NULL;
 
-	memset(dev_priv, 0, sizeof(struct eth_dev_priv));
-	dev_priv->port_p = pp;
+	memset(dev_priv, 0, sizeof(struct eth_netdev));
+	dev_priv->pp = pp;
+	pp->dev = dev;
 /*
 TODO:change
 	dev->irq = NET_TH_RXTX_IRQ_NUM(pp->port);
 */
 	dev->irq = 101 + pp->port;
+/* TODO	pp->link_irq = 104;*/
 
 	dev->mtu = mtu;
 	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
@@ -3186,7 +3238,7 @@ int mv_eth_hal_init(struct eth_port *pp)
 		rxq_ctrl->rxq_time_coal = CONFIG_MV_ETH_RX_COAL_USEC;
 	}
 
-	if (pp->flags & MV_ETH_F_MH)
+	if (pp->tx_spec.flags & MV_ETH_TX_F_MH)
 		mvPp2MhSet(pp->port, MV_PP2_MH);
 
 #ifdef CONFIG_MV_ETH_TOOL
@@ -3214,7 +3266,8 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o %d Giga ports supported\n", mv_eth_ports_num);
 
 #ifdef CONFIG_MV_PON
-	printk(KERN_ERR "  o Giga PON port is #%d: - %d TCONTs supported\n", MV_PON_LOGIC_PORT_GET(), MV_ETH_MAX_TCONT);
+	printk(KERN_ERR "  o xPON port is #%d: - %d of %d TCONTs supported\n",
+		MV_PON_LOGIC_PORT_GET(), CONFIG_MV_PON_TCONTS, MV_ETH_MAX_TCONT);
 #endif
 
 #ifdef CONFIG_NET_SKB_RECYCLE
@@ -3275,7 +3328,7 @@ void mv_eth_config_show(void)
 }
 
 /* Set network device features on initialization. Take into account default compile time configuration. */
-static void mv_eth_netdev_set_features(struct net_device *dev)
+void mv_eth_netdev_set_features(struct net_device *dev)
 {
 	dev->features = NETIF_F_SG | NETIF_F_LLTX;
 
@@ -3510,7 +3563,10 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 		goto out;
 	}
 
-	mvEthMaxRxSizeSet(pp->port, RX_PKT_SIZE(mtu));
+	if (!MV_PON_PORT(pp->port))
+		mvEthMaxRxSizeSet(pp->port, RX_PKT_SIZE(mtu));
+	else
+		mv_pon_mtu_config(RX_PKT_SIZE(mtu));
 
 #ifdef CONFIG_MV_ETH_HWF
 	mv_eth_hwf_bm_pool_init(pp, mtu);
@@ -3797,6 +3853,11 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 	if (mtu == dev->mtu)
 		goto mtu_out;
 
+	if (!MV_PON_PORT(pp->port))
+		mvEthMaxRxSizeSet(pp->port, pkt_size);
+	else
+		mv_pon_mtu_config(pkt_size);
+
 #ifdef CONFIG_MV_ETH_HWF
 	port_pool = pp->hwf_pool_long;
 
@@ -4072,7 +4133,8 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	pp->rxq_num = CONFIG_MV_ETH_RXQ;
 	first_rxq += pp->rxq_num;
 	pp->txp_num = 1;
-	pp->txp = 0;
+	pp->tx_spec.flags = 0;
+	pp->tx_spec.txp = 0;
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		cpuCtrl->txq = CONFIG_MV_ETH_TXQ_DEF;
@@ -4108,9 +4170,9 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 
 #ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(port)) {
-		set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
+		pp->tx_spec.flags |= MV_ETH_TX_F_MH;
 		pp->txp_num = CONFIG_MV_PON_TCONTS;
-		pp->txp = CONFIG_MV_PON_TXP_DEF;
+		pp->tx_spec.txp = CONFIG_MV_PON_TXP_DEF;
 		for_each_possible_cpu(i)
 			pp->cpu_config[i]->txq = CONFIG_MV_PON_TXQ_DEF;
 	}
@@ -4242,16 +4304,46 @@ void mv_eth_ext_pool_print(struct eth_port *pp)
  ***********************************************************************************/
 void mv_eth_netdev_print(struct net_device *dev)
 {
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
+	printk(KERN_ERR "%s net_device status: dev=%p\n\n", dev->name, dev);
+	printk(KERN_ERR "ifIdx=%d, mtu=%u, pkt_size=%d, buf_size=%d, MAC=" MV_MACQUAD_FMT "\n",
+	       dev->ifindex, dev->mtu, RX_PKT_SIZE(dev->mtu),
+		RX_BUF_SIZE(RX_PKT_SIZE(dev->mtu)), MV_MACQUAD(dev->dev_addr));
+
+	printk(KERN_ERR "features=0x%x\n",
+			(unsigned int)(dev->features));
 
-	printk(KERN_ERR "%s net_device status: dev=%p, pp=%p\n\n", dev->name, dev, MV_ETH_PRIV(dev));
-	printk(KERN_ERR "ifIdx=%d, features=0x%x, flags=0x%x, mtu=%u, size=%d, MAC=" MV_MACQUAD_FMT "\n",
-	       dev->ifindex, (unsigned int)(dev->features), (unsigned int)(dev->flags),
-	       dev->mtu, RX_PKT_SIZE(dev->mtu), MV_MACQUAD(dev->dev_addr));
+	printk(KERN_ERR "flags=0x%x, gflags=0x%x: running=%d, oper_up=%d\n",
+			(unsigned int)(dev->flags), (unsigned int)(dev->flags), netif_running(dev), netif_oper_up(dev));
+	if (mv_eth_netdev_find(dev->ifindex)) {
+		struct eth_netdev *pdev = MV_DEV_PRIV(dev);
 
-	if (dev_priv)
-		printk(KERN_ERR "group=%d, tx_vlan_mh=0x%04x, switch_port_map=0x%x, switch_port_link_map=0x%x\n",
-		       dev_priv->group, dev_priv->tx_vlan_mh, dev_priv->port_map, dev_priv->link_map);
+		if (pdev)
+			printk(KERN_ERR "pp=%p, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mask=0x%04x\n",
+				MV_ETH_PRIV(dev), pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
+	} else {
+		/* mux net device */
+		struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+		struct eth_port   *pp = MV_ETH_PRIV(dev);
+
+		if (pdev && pp) {
+			if (pp->tag_type == MV_TAG_TYPE_VLAN)
+				printk(KERN_ERR "pp=%p, pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
+					pp, pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
+			else if (pp->tag_type == MV_TAG_TYPE_DSA)
+				printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%08x, rx_dsa=0x%08x, rx_mask=0x%08x\n",
+					pp, pdev, pdev->tx_tag.dsa, pdev->rx_tag_ptrn.dsa, pdev->rx_tag_mask.dsa);
+
+			else if (pp->tag_type == MV_TAG_TYPE_MH)
+				printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%04x, rx_dsa=0x%04x, rx_mask=0x%04x\n",
+					pp, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
+
+			else if (pp->tag_type == MV_TAG_TYPE_EDSA)
+				printk(KERN_ERR "pp=%p, pdev=%p: tx_edsa=0x%08x %08x, rx_edsa=0x%08x %08x, rx_mask=0x%08x %08x\n",
+					pp, pdev, pdev->tx_tag.edsa[1], pdev->tx_tag.edsa[0],
+					pdev->rx_tag_ptrn.edsa[1], pdev->rx_tag_ptrn.edsa[0],
+					pdev->rx_tag_mask.edsa[1], pdev->rx_tag_mask.edsa[0]);
+		}
+	}
 }
 
 void mv_eth_status_print(void)
@@ -4270,16 +4362,19 @@ void mv_eth_status_print(void)
 void mv_eth_port_status_print(unsigned int port)
 {
 	int txp, q;
+	struct net_device *dev;
+	struct eth_netdev *dev_priv;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct tx_queue *txq_ctrl;
 	struct cpu_ctrl	*cpuCtrl;
+	static char *tag_type[] = {"NONE", "MH", "DSA", "EDSA", "VLAN"};
 
 	if (!pp)
 		return;
 
 	printk(KERN_ERR "\n");
 	printk(KERN_ERR "port=%d, flags=0x%lx, rx_weight=%d\n", port, pp->flags, pp->weight);
-	if ((!(pp->flags & MV_ETH_F_SWITCH)) && (pp->flags & MV_ETH_F_CONNECT_LINUX))
+	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
 		printk(KERN_ERR "%s: ", pp->dev->name);
 	else
 		printk(KERN_ERR "port %d: ", port);
@@ -4336,10 +4431,11 @@ void mv_eth_port_status_print(unsigned int port)
 	printk(KERN_ERR "Do tx_done in TX or Timer context: tx_done_threshold=%d\n", mv_ctrl_txdone);
 #endif /* CONFIG_MV_ETH_TXDONE_ISR */
 
-	printk(KERN_ERR "txp=%d, zero_pad=%s, mh_en=%s (0x%04x), tx_cmd=0x%04x 0x%04x 0x%04x 0x%04x\n",
-		pp->txp, (pp->flags & MV_ETH_F_NO_PAD) ? "Disabled" : "Enabled",
-		(pp->flags & MV_ETH_F_MH) ? "Enabled" : "Disabled",
-		pp->tx_mh, pp->hw_cmd[0], pp->hw_cmd[1], pp->hw_cmd[2], pp->hw_cmd[3]);
+	printk(KERN_ERR "txp=%d, zero_pad=%s, mh_en=%s (0x%04x), hw_cmd: 0x%08x 0x%08x 0x%08x\n",
+		pp->tx_spec.txp, (pp->tx_spec.flags & MV_ETH_TX_F_NO_PAD) ? "Disabled" : "Enabled",
+		(pp->tx_spec.flags & MV_ETH_TX_F_MH) ? "Enabled" : "Disabled",
+		MV_16BIT_BE(pp->tx_spec.tx_mh), pp->tx_spec.hw_cmd[0],
+		pp->tx_spec.hw_cmd[1], pp->tx_spec.hw_cmd[2]);
 
 	printk(KERN_CONT "\n");
 	printk(KERN_CONT "CPU:   txq_def   napi_group_id\n");
@@ -4356,6 +4452,16 @@ void mv_eth_port_status_print(unsigned int port)
 	printk(KERN_CONT "\n");
 
 	mv_eth_napi_groups_print(port);
+
+	/* Print status of all mux_dev for this port */
+	printk(KERN_CONT "TAG type = %s\n", tag_type[pp->tag_type]);
+	dev = pp->switch_dev;
+	while (dev != NULL) {
+		mv_eth_netdev_print(dev);
+		dev_priv = MV_DEV_PRIV(dev);
+		dev = dev_priv->next;
+		printk(KERN_CONT "\n\n");
+	}
 }
 
 /***********************************************************************************
@@ -4414,6 +4520,8 @@ void mv_eth_port_stats_print(unsigned int port)
 	printk(KERN_ERR "cleanup_timer_event...........%10u\n", stat->cleanup_timer);
 	printk(KERN_ERR "link..........................%10u\n", stat->link);
 	printk(KERN_ERR "netdev_stop...................%10u\n", stat->netdev_stop);
+	if (pp->tag_type != MV_TAG_TYPE_NONE)
+		printk(KERN_ERR "rx_tagged....................%10u\n",  stat->rx_tagged);
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	printk(KERN_ERR "rx_special....................%10u\n", stat->rx_special);
 #endif /* CONFIG_MV_ETH_RX_SPECIAL */
@@ -4670,6 +4778,8 @@ int mv_eth_all_ports_cleanup(void)
 #ifdef CONFIG_MV_PON
 /* PON link status api */
 PONLINKSTATUSPOLLFUNC pon_link_status_polling_func;
+/* PON MTU config api */
+PONMTUCFGFUNC         pon_mtu_config_func;
 
 void pon_link_status_notify_func(MV_BOOL link_state)
 {
@@ -4678,21 +4788,37 @@ void pon_link_status_notify_func(MV_BOOL link_state)
 }
 
 /* called by PON module */
-void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func)
+void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func,
+				PONMTUCFGFUNC mtu_func)
 {
 	pon_link_status_polling_func = poll_func;
 	*notify_func = pon_link_status_notify_func;
+	pon_mtu_config_func = mtu_func;
 }
 
 MV_BOOL mv_pon_link_status(void)
 {
-	/*TODO*/
-	return MV_TRUE;
-
 	if (pon_link_status_polling_func != NULL)
 		return pon_link_status_polling_func();
+
 	printk(KERN_ERR "pon_link_status_polling_func is uninitialized\n");
-	return MV_FALSE;
+
+	return MV_TRUE;
+}
+
+MV_BOOL mv_pon_mtu_config(MV_U32 maxEth)
+{
+	if (pon_mtu_config_func != NULL) {
+		if (pon_mtu_config_func(maxEth) != MV_OK) {
+			printk(KERN_ERR "pon_mtu_config_func failed\n");
+			return MV_FALSE;
+		}
+	} else {
+		printk(KERN_ERR "pon_mtu_config_func is uninitialized\n");
+		return MV_FALSE;
+	}
+
+	return MV_TRUE;
 }
 #endif /* CONFIG_MV_PON */
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 82a5a9f..bfbbcf3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -170,13 +170,14 @@ struct port_stats {
 	u32 cleanup_timer;
 	u32 link;
 	u32 netdev_stop;
+	u32 rx_tagged;
 
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	u32 rx_special;
 #endif /* CONFIG_MV_ETH_RX_SPECIAL */
 
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
-	u32	tx_special;
+	u32 tx_special;
 #endif /* CONFIG_MV_ETH_TX_SPECIAL */
 
 #endif /* CONFIG_MV_ETH_STAT_INF */
@@ -207,10 +208,7 @@ struct port_stats {
 
 /* Masks used for pp->flags */
 #define MV_ETH_F_STARTED_BIT        0
-#define MV_ETH_F_SWITCH_BIT         1	/* port is connected to the Switch using the Gateway driver */
-#define MV_ETH_F_MH_BIT             2
-#define MV_ETH_F_NO_PAD_BIT         3
-#define MV_ETH_F_EXT_SWITCH_BIT	    4	/* port is connected to the Switch without the Gateway driver */
+
 #define MV_ETH_F_CONNECT_LINUX_BIT  5	/* port is connected to Linux netdevice */
 #define MV_ETH_F_LINK_UP_BIT        6
 #define MV_ETH_F_SUSPEND_BIT        7
@@ -218,8 +216,6 @@ struct port_stats {
 
 #define MV_ETH_F_STARTED           (1 << MV_ETH_F_STARTED_BIT)
 #define MV_ETH_F_SWITCH            (1 << MV_ETH_F_SWITCH_BIT)
-#define MV_ETH_F_MH                (1 << MV_ETH_F_MH_BIT)
-#define MV_ETH_F_NO_PAD            (1 << MV_ETH_F_NO_PAD_BIT)
 #define MV_ETH_F_EXT_SWITCH        (1 << MV_ETH_F_EXT_SWITCH_BIT)
 #define MV_ETH_F_CONNECT_LINUX     (1 << MV_ETH_F_CONNECT_LINUX_BIT)
 #define MV_ETH_F_LINK_UP           (1 << MV_ETH_F_LINK_UP_BIT)
@@ -255,9 +251,15 @@ struct port_stats {
 
 #define TOS_TO_DSCP(tos)	((tos >> 2) & 0x3F)
 
+/* Masks used for tx_spec->flags */
+#define MV_ETH_TX_F_NO_PAD      0x0001
+#define MV_ETH_TX_F_MH          0x0002
+#define MV_ETH_TX_F_HW_CMD      0x0004
+
 struct mv_eth_tx_spec {
-	u16		hw_cmd[4];	/* tx_desc offset = 0x10 */
-	u16		flags;
+	unsigned long	flags;
+	u32             hw_cmd[3];     /* tx_desc offset = 0x10, 0x14, 0x18 */
+	u16             tx_mh;
 	u8		txp;
 	u8		txq;
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
@@ -329,6 +331,7 @@ struct napi_group_ctrl {
 
 struct eth_port {
 	int                 port;
+	int                 tag_type; /* NONE/MH/DSA/EDSA/VLAN */
 	MV_PP2_PORT_CTRL   *port_ctrl;
 	struct rx_queue     *rxq_ctrl;
 	struct tx_queue     *txq_ctrl;
@@ -336,6 +339,7 @@ struct eth_port {
 	int		    first_rxq;
 	int 		    rxq_num;
 	struct net_device   *dev;
+	struct net_device   *switch_dev;
 	rwlock_t            rwlock;
 	struct bm_pool      *pool_long;
 	int                 pool_long_num;
@@ -352,9 +356,7 @@ struct eth_port {
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	u8		    dbg_flags;
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
-	u16                 hw_cmd[4];	/* offset 0x10 in TX descriptor */
-	int                 txp;
-	u16                 tx_mh;	/* 2B MH */
+	struct mv_eth_tx_spec tx_spec;
 	struct port_stats   stats;
 	struct dist_stats   dist_stats;
 	int                 weight;
@@ -385,6 +387,7 @@ struct eth_port {
 	struct cpu_ctrl	*cpu_config[CONFIG_NR_CPUS];
 	MV_U32  sgmii_serdes;
 	int	pm_mode;
+	int	link_irq;
 };
 
 enum eth_pm_mode {
@@ -395,21 +398,17 @@ enum eth_pm_mode {
 };
 
 struct eth_netdev {
-	u16     tx_vlan_mh;		/* 2B MH */
-	u16     vlan_grp_id;		/* vlan group ID */
-	u16     port_map;		/* switch port map */
-	u16     link_map;		/* switch port link map */
-	u16     cpu_port;		/* switch CPU port */
-	u16     group;
-};
-
-struct eth_dev_priv {
-	struct eth_port     *port_p;
-	struct eth_netdev   *netdev_p;
+	int	idx;
+	bool    leave_tag;
+	MV_TAG  tx_tag;
+	MV_TAG  rx_tag_ptrn;
+	MV_TAG  rx_tag_mask;
+	struct eth_port   *pp;
+	struct net_device *next;
 };
 
-#define MV_ETH_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->port_p)
-#define MV_DEV_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->netdev_p)
+#define MV_ETH_PRIV(dev)        (((struct eth_netdev *)(netdev_priv(dev)))->pp)
+#define MV_DEV_PRIV(dev)        ((struct eth_netdev *)(netdev_priv(dev)))
 #define MV_DEV_STAT(dev)        (&((dev)->stats))
 
 /* define which Switch ports are relevant */
@@ -470,6 +469,27 @@ void mv_eth_bm_config_print(void);
 extern struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 extern struct eth_port **mv_eth_ports;
 
+static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_desc, struct sk_buff *skb)
+{
+#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
+	if (pp->rx_csum_offload) {
+		if ((PP2_RX_L3_IS_IP4(rx_desc->status) && !PP2_RX_IP4_HDR_ERR(rx_desc->status)) ||
+			(PP2_RX_L3_IS_IP6(rx_desc->status))) {
+			if ((PP2_RX_L4_IS_UDP(rx_desc->status) || PP2_RX_L4_IS_TCP(rx_desc->status)) &&
+				(PP2_RX_L4_CHK_OK(rx_desc->status))) {
+				skb->csum = 0;
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+				STAT_DBG(pp->stats.rx_csum_hw++);
+				return;
+			}
+		}
+	}
+#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
+
+	skb->ip_summed = CHECKSUM_NONE;
+	STAT_DBG(pp->stats.rx_csum_sw++);
+}
+
 static inline void mv_eth_interrupts_unmask(struct eth_port *pp)
 {
 	int cpu = smp_processor_id(), group_id;
@@ -718,6 +738,7 @@ int         mv_eth_resume_network_interfaces(struct eth_port *pp);
 int         mv_eth_pm_mode_set(int port, int mode);
 
 irqreturn_t mv_eth_isr(int irq, void *dev_id);
+irqreturn_t mv_eth_link_isr(int irq, void *dev_id);
 int         mv_eth_start_internals(struct eth_port *pp, int mtu);
 int         mv_eth_stop_internals(struct eth_port *pp);
 int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
@@ -732,6 +753,7 @@ MV_STATUS   mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 valu
 struct eth_port     *mv_eth_port_by_id(unsigned int port);
 struct net_device   *mv_eth_netdev_by_id(unsigned int idx);
 bool                 mv_eth_netdev_find(unsigned int if_index);
+void                 mv_eth_netdev_set_features(struct net_device *dev);
 
 void        mv_eth_mac_show(int port);
 void        mv_eth_dscp_map_show(int port);
@@ -765,6 +787,7 @@ int         mv_eth_ctrl_tx_cmd_pme_prog(int port, u16 pme_prog);
 
 int         mv_eth_ctrl_txq_cpu_def(int port, int txp, int txq, int cpu);
 int         mv_eth_ctrl_flag(int port, u32 flag, u32 val);
+int         mv_eth_ctrl_tx_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_dbg_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_size);
 int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
@@ -780,9 +803,15 @@ void        mv_eth_link_status_print(int port);
 #ifdef CONFIG_MV_PON
 typedef MV_BOOL(*PONLINKSTATUSPOLLFUNC)(void);		  /* prototype for PON link status polling function */
 typedef void   (*PONLINKSTATUSNOTIFYFUNC)(MV_BOOL state); /* prototype for PON link status notification function */
+typedef MV_STATUS(*PONMTUCFGFUNC)(MV_U32 maxEth);         /* prototype for PON MTU config function */
 
 MV_BOOL mv_pon_link_status(void);
-void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func);
+MV_BOOL mv_pon_mtu_config(MV_U32 maxEth);
+
+void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func,
+				PONLINKSTATUSNOTIFYFUNC *notify_func,
+				PONMTUCFGFUNC mtu_func);
+
 void mv_pon_ctrl_omci_type(MV_U16 type);
 void mv_pon_ctrl_omci_rx_gh(int en);
 void mv_pon_omci_print(void);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
index 8d7b634..4b5abfc 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
@@ -53,6 +53,7 @@ static ssize_t plcr_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo bytes    > min_pkt   - Set minimal packet length\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo 0|1      > edrop     - Enable <1> or Disable <0> early packets drop\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p 0|1    > enable    - Enable <1> or Disable <0> policer <p>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p 0|1    > color     - Set color mode for policer <p>: 0-blind, 1-aware\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p u t    > config    - Set token units <u> and update type <t> for policer <p>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p num    > tokens    - Set number of tokens for each update for policer <p>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p c e    > bucket    - Set commit <c> and exceed <e> bucket sizes for policer <p>\n");
@@ -100,33 +101,35 @@ static ssize_t plcr_dec_store(struct device *dev,
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "dump")) {
+	if (!strcmp(name, "dump"))
 		mvPp2PlcrHwDumpSingle(p);
-	} else	if (!strcmp(name, "period")) {
+	else if (!strcmp(name, "period"))
 		mvPp2PlcrHwBasePeriodSet(p);
-	} else	if (!strcmp(name, "rate")) {
+	else if (!strcmp(name, "rate"))
 		mvPp2PlcrHwBaseRateGenEnable(p);
-	} else	if (!strcmp(name, "min_pkt")) {
+	else if (!strcmp(name, "min_pkt"))
 		mvPp2PlcrHwMinPktLen(p);
-	} else	if (!strcmp(name, "edrop")) {
+	else if (!strcmp(name, "edrop"))
 		mvPp2PlcrHwEarlyDropSet(p);
-	} else	if (!strcmp(name, "enable")) {
+	else if (!strcmp(name, "enable"))
 		mvPp2PlcrHwEnable(p, i);
-	} else	if (!strcmp(name, "config")) {
+	else  if (!strcmp(name, "color"))
+		mvPp2PlcrHwColorModeSet(p, i);
+	else if (!strcmp(name, "config"))
 		mvPp2PlcrHwTokenConfig(p, i, v);
-	} else	if (!strcmp(name, "tokens")) {
+	else if (!strcmp(name, "tokens"))
 		mvPp2PlcrHwTokenValue(p, i);
-	} else	if (!strcmp(name, "bucket")) {
+	else if (!strcmp(name, "bucket"))
 		mvPp2PlcrHwBucketSizeSet(p, i, v);
-	} else	if (!strcmp(name, "cpu_tr")) {
+	else if (!strcmp(name, "cpu_tr"))
 		mvPp2PlcrHwCpuThreshSet(p, i);
-	} else	if (!strcmp(name, "hwf_tr")) {
+	else if (!strcmp(name, "hwf_tr"))
 		mvPp2PlcrHwHwfThreshSet(p, i);
-	} else	if (!strcmp(name, "rxq_tr")) {
+	else if (!strcmp(name, "rxq_tr"))
 		mvPp2PlcrHwRxqThreshSet(p, i);
-	} else	if (!strcmp(name, "txq_tr")) {
+	else if (!strcmp(name, "txq_tr"))
 		mvPp2PlcrHwTxqThreshSet(p, i);
-	} else
+	else
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
 
 	local_irq_restore(flags);
@@ -138,21 +141,22 @@ static ssize_t plcr_dec_store(struct device *dev,
 }
 
 
-static DEVICE_ATTR(help,          S_IRUSR, plcr_show, NULL);
-static DEVICE_ATTR(regs,	      S_IRUSR, plcr_show, NULL);
-static DEVICE_ATTR(dump,          S_IRUSR | S_IWUSR, plcr_show, plcr_dec_store);
-static DEVICE_ATTR(period,	      S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(rate,	      S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(min_pkt,       S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(edrop,         S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(enable,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(config,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(tokens,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(bucket,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(cpu_tr,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(hwf_tr,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(rxq_tr,        S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(txq_tr,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(help,	  S_IRUSR, plcr_show, NULL);
+static DEVICE_ATTR(regs,	  S_IRUSR, plcr_show, NULL);
+static DEVICE_ATTR(dump,	  S_IRUSR | S_IWUSR, plcr_show, plcr_dec_store);
+static DEVICE_ATTR(period,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(rate,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(min_pkt,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(edrop,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(enable,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(color,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(config,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(tokens,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(bucket,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(cpu_tr,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(hwf_tr,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(rxq_tr,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(txq_tr,	  S_IWUSR, NULL,     plcr_dec_store);
 
 
 static struct attribute *plcr_attrs[] = {
@@ -164,6 +168,7 @@ static struct attribute *plcr_attrs[] = {
 	&dev_attr_min_pkt.attr,
 	&dev_attr_edrop.attr,
 	&dev_attr_enable.attr,
+	&dev_attr_color.attr,
 	&dev_attr_config.attr,
 	&dev_attr_tokens.attr,
 	&dev_attr_bucket.attr,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
index bdb121c..cf748d5 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
@@ -173,13 +173,13 @@ static ssize_t pme_dec_hex_store(struct device *dev,
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "vlan_etype")) {
+	if (!strcmp(name, "vlan_etype"))
 		mvPp2PmeVlanEtherTypeSet(i, v);
-	} else if (!strcmp(name, "dsa_etype")) {
+	else if (!strcmp(name, "dsa_etype"))
 		mvPp2PmeDsaDefaultSet(i, v);
-	} else if (!strcmp(name, "pppoe_proto")) {
+	else if (!strcmp(name, "pppoe_proto"))
 		mvPp2PmePppoeProtoSet(i, v);
-	} else
+	else
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
 
 	local_irq_restore(flags);
@@ -204,23 +204,23 @@ static ssize_t pme_hex_store(struct device *dev,
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "sw_word")) {
+	if (!strcmp(name, "sw_word"))
 		mvPp2PmeSwWordSet(&mv_pp2_pme_e, v);
-	} else if (!strcmp(name, "sw_cmd")) {
+	else if (!strcmp(name, "sw_cmd"))
 		mvPp2PmeSwCmdSet(&mv_pp2_pme_e, v);
-	} else if (!strcmp(name, "sw_type")) {
+	else if (!strcmp(name, "sw_type"))
 		mvPp2PmeSwCmdTypeSet(&mv_pp2_pme_e, v);
-	} else if (!strcmp(name, "sw_data")) {
+	else if (!strcmp(name, "sw_data"))
 		mvPp2PmeSwCmdDataSet(&mv_pp2_pme_e, v);
-	} else if (!strcmp(name, "vlan_def")) {
+	else if (!strcmp(name, "vlan_def"))
 		mvPp2PmeVlanDefaultSet(v);
-	} else if (!strcmp(name, "dsa_src_dev")) {
+	else if (!strcmp(name, "dsa_src_dev"))
 		mvPp2PmeDsaSrcDevSet(v);
-	} else if (!strcmp(name, "pppoe_etype")) {
+	else if (!strcmp(name, "pppoe_etype"))
 		mvPp2PmePppoeEtypeSet(v);
-	} else if (!strcmp(name, "pppoe_len")) {
+	else if (!strcmp(name, "pppoe_len"))
 		mvPp2PmePppoeLengthSet(v);
-	} else
+	else
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
 
 	local_irq_restore(flags);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
new file mode 100644
index 0000000..9330b39
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
@@ -0,0 +1,219 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include "mvOs.h"
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "pp2/prs/mvPp2PrsHw.h"
+#include "pp2/prs/mvPp2Prs.h"
+
+
+static ssize_t mv_prs_high_help(char *buf)
+{
+	int off = 0;
+
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "cat                hw_dump   - dump all valid HW entries\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e   > flow      - Add flow entry to HW\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               flowId <a>, result <b>, result mask <c>, port <d>, tcam index <e>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c       > vlan1     - Single vlan entry tpid1 <a>, ports bitmap <b>, add/del <c=1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d     > vlan2     - Double vlan entry tpid1 <a>, tpid2 <b>, ports bitmap <c>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               add/del <d=1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e   > vlan3     - Triple vlan entry tpid1 <a>, tpid2 <b>, tpid3 <c>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               ports bitmap <d>, add/del <e=1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e f > mac_range - Add mac entry to HW\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               portMap <a>, da <b>, da mask <c>, ri <d>, ri mask <e>, finish <f>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c       > mac_del   - Del mac entry from HW\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               portMap <a>, da <b>, da mask <c>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e  > etype_add  - Add ethertype entry to HW\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               portMap <a>, ethertype <b>, ri <c>, ri mask <d>, finish <e>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b        > etype_del  - Del ethertype entry from HW, portMap <a>, ethertype <b>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+	return off;
+}
+
+
+static ssize_t mv_prs_high_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	const char      *name = attr->attr.name;
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "hw_dump"))
+		mvPp2PrsHwDump();
+	else
+		off += mv_prs_high_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_prs_high_store_unsigned(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0, e = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x %x %x %x", &a, &b, &c, &d, &e);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "hw_flow"))
+		mvPrsFlowIdGen(e, a, b, c, d);
+	else if (!strcmp(name, "hw_vlan1"))
+		mvPp2PrsSingleVlan(a, b, c);
+	else if (!strcmp(name, "hw_vlan2"))
+		mvPp2PrsDoubleVlan(a, b, c, d);
+	else if (!strcmp(name, "hw_vlan3"))
+		mvPp2PrsTripleVlan(a, b, c, d, e);
+	else if (!strcmp(name, "hw_etype_add"))
+		mvPrsEthTypeSet(a, b, c, d, e);
+	else if (!strcmp(name, "hw_etype_del"))
+		mvPrsEthTypeDel(a, b);
+	else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+
+static ssize_t mv_prs_high_store_str(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, prt = 0, ri = 0, ri_mask = 0, fin = 0;
+	unsigned char da[MV_MAC_ADDR_SIZE];
+	unsigned char da_mask[MV_MAC_ADDR_SIZE];
+
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf,
+		"%x %2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx %2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx %x %x %x",
+		&prt, da, da+1, da+2, da+3, da+4, da+5,
+		da_mask, da_mask+1, da_mask+2, da_mask+3, da_mask+4, da_mask+5, &ri, &ri_mask, &fin);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "hw_mac_range"))
+		mvPrsMacDaRangeSet(prt, da, da_mask, ri, ri_mask, fin);
+	else if (!strcmp(name, "hw_mac_del"))
+		mvPrsMacDaRangeDel(prt, da, da_mask);
+	else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_high_show, NULL);
+static DEVICE_ATTR(hw_flow,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_vlan1,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_vlan2,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_vlan3,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_etype_add,	S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_etype_del,	S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(hw_mac_range,	S_IWUSR, mv_prs_high_show, mv_prs_high_store_str);
+static DEVICE_ATTR(hw_mac_del,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_str);
+static DEVICE_ATTR(help,		S_IRUSR, mv_prs_high_show, NULL);
+
+
+static struct attribute *prs_high_attrs[] = {
+    &dev_attr_hw_dump.attr,
+    &dev_attr_help.attr,
+    &dev_attr_hw_flow.attr,
+    &dev_attr_hw_vlan1.attr,
+    &dev_attr_hw_vlan2.attr,
+    &dev_attr_hw_vlan3.attr,
+    &dev_attr_hw_etype_add.attr,
+    &dev_attr_hw_etype_del.attr,
+    &dev_attr_hw_mac_range.attr,
+    &dev_attr_hw_mac_del.attr,
+    NULL
+};
+
+static struct attribute_group prs_high_group = {
+	.name = "prsHigh",
+	.attrs = prs_high_attrs,
+};
+
+int __devinit prs_high_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	if (!pd) {
+		platform_device_register_simple("pp2", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &prs_high_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+out:
+	return err;
+}
+
+module_init(prs_high_sysfs_init);
+
+MODULE_AUTHOR("Uri Eliyahu");
+MODULE_DESCRIPTION("prs for Marvell Ppv2");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
new file mode 100644
index 0000000..2cec5f4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
@@ -0,0 +1,280 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include "mvOs.h"
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "pp2/prs/mvPp2PrsHw.h"
+#include "pp2/prs/mvPp2Prs.h"
+
+
+static  MV_PP2_PRS_ENTRY pe;
+
+
+static ssize_t mv_prs_low_help(char *buf)
+{
+	int off = 0;
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          sw_dump       - dump parser SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_dump       - dump all valid HW entries\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_regs       - dump parser registers.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_write    - write parser SW entry into HW place <id>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_read     - read parser entry <id> into SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo 1       > sw_clear    - clear parser SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_inv      - invalidate parser entry <id> in hw.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo         > hw_inv_all  - invalidate all parser entries in HW.\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p m     > t_port      - add<m=1> or delete<m=0> port<p> in SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo pmap    > t_port_map  - set port map <pmap> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > t_ai        - update ainfo value <v> with mask <m> in SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo o d m   > t_byte      - set byte of data <d> with mask <m> and offset <o> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > t_lu        - set lookup id <v> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > s_ri        - set result info value <v> with mask <m> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > s_ai        - set ainfo value <v> with mask <m> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_next_lu   - set next lookup id value <v> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_shift     - set packet shift value <v> for next lookup to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo t v     > s_offs      - set offset value <v> for type <t> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_lu_done   - set (v=1) or clear (v=0) lookup done bit to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_fid_gen   - set (v=1) or clear (v=0) flowid generate bit in SW entry.\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p l m o > hw_frst_itr - set values for first iteration port <p>, lookupid <l>, \n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                             max loops <m>, init offs <o>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+
+	return off;
+}
+
+
+static ssize_t mv_prs_low_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	const char      *name = attr->attr.name;
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+	if (!strcmp(name, "hw_dump"))
+		mvPp2PrsHwDump();
+	else if (!strcmp(name, "sw_dump"))
+		mvPp2PrsSwDump(&pe);
+	else if (!strcmp(name, "hw_regs"))
+		mvPp2PrsHwRegsDump();
+	else
+		off += mv_prs_low_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_prs_low_store_signed(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	int  err = 0, a = 0, b = 0, c = 0, d = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d %d", &a, &b, &c, &d);
+	local_irq_save(flags);
+
+	if (!strcmp(name, "s_shift"))
+		mvPp2PrsSwSramShiftSet(&pe, a, SRAM_OP_SEL_SHIFT_ADD);
+	else if (!strcmp(name, "s_offs"))
+		mvPp2PrsSwSramOffsetSet(&pe, a, b, SRAM_OP_SEL_SHIFT_ADD);
+	else if (!strcmp(name, "hw_frst_itr"))
+		mvPp2PrsHwPortInit(a, b, c, d);
+	else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+
+static ssize_t mv_prs_low_store_unsigned(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, a = 0, b = 0, c = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x %x", &a, &b, &c);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "hw_write")) {
+		pe.index = a;
+		mvPp2PrsHwWrite(&pe);
+	} else if (!strcmp(name, "hw_read")) {
+		pe.index = a;
+		mvPp2PrsHwRead(&pe);
+	} else if (!strcmp(name, "sw_clear"))
+		mvPp2PrsSwClear(&pe);
+	else if (!strcmp(name, "hw_inv"))
+		mvPp2PrsHwInv(a);
+	else if (!strcmp(name, "hw_inv_all"))
+		mvPp2PrsHwInvAll();
+	else if (!strcmp(name, "t_port"))
+		mvPp2PrsSwTcamPortSet(&pe, a, b);
+	else if (!strcmp(name, "t_port_map"))
+		mvPp2PrsSwTcamPortMapSet(&pe, a);
+	else if (!strcmp(name, "t_lu"))
+		mvPp2PrsSwTcamLuSet(&pe, a);
+	else if (!strcmp(name, "t_ai"))
+		mvPp2PrsSwTcamAiUpdate(&pe, a, b);
+	else if (!strcmp(name, "t_byte"))
+		mvPp2PrsSwTcamByteSet(&pe, a, b, c);
+	else if (!strcmp(name, "s_ri"))
+		mvPp2PrsSwSramRiUpdate(&pe, a, b);
+	else if (!strcmp(name, "s_ai"))
+		mvPp2PrsSwSramAiUpdate(&pe, a, b);
+	else if (!strcmp(name, "s_next_lu"))
+		mvPp2PrsSwSramNextLuSet(&pe, a);
+	else if (!strcmp(name, "s_lu_done"))
+		(a == 1) ? 	mvPp2PrsSwSramLuDoneSet(&pe) :
+				mvPp2PrsSwSramLuDoneClear(&pe);
+	else if (!strcmp(name, "s_fid_gen"))
+		(a == 1) ?	mvPp2PrsSwSramFlowidGenSet(&pe) :
+				mvPp2PrsSwSramFlowidGenClear(&pe);
+	else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+
+static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(help,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(hw_regs,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(sw_clear,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_write,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_read,     	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv_all, 		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_byte,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_port,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_port_map,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_ri,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_next_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_shift,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+static DEVICE_ATTR(s_offs,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+static DEVICE_ATTR(s_lu_done,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_fid_gen,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+
+
+
+static struct attribute *prs_low_attrs[] = {
+    &dev_attr_hw_dump.attr,
+    &dev_attr_sw_dump.attr,
+    &dev_attr_hw_regs.attr,
+    &dev_attr_hw_write.attr,
+    &dev_attr_hw_read.attr,
+    &dev_attr_hw_inv.attr,
+    &dev_attr_hw_inv_all.attr,
+    &dev_attr_sw_clear.attr,
+    &dev_attr_t_byte.attr,
+    &dev_attr_t_port.attr,
+    &dev_attr_t_port_map.attr,
+    &dev_attr_t_ai.attr,
+    &dev_attr_t_lu.attr,
+    &dev_attr_s_ri.attr,
+    &dev_attr_s_ai.attr,
+    &dev_attr_s_next_lu.attr,
+    &dev_attr_s_shift.attr,
+    &dev_attr_s_offs.attr,
+    &dev_attr_s_lu_done.attr,
+    &dev_attr_s_fid_gen.attr,
+    &dev_attr_hw_frst_itr.attr,
+    &dev_attr_help.attr,
+    NULL
+};
+
+static struct attribute_group prs_low_group = {
+	.name = "prsLow",
+	.attrs = prs_low_attrs,
+};
+
+int __devinit prs_low_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	if (!pd) {
+		platform_device_register_simple("pp2", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &prs_low_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+out:
+	return err;
+}
+
+module_init(prs_low_sysfs_init);
+
+MODULE_AUTHOR("Uri Eliyahu");
+MODULE_DESCRIPTION("prs for Marvell NetA2");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
index 6372515..d9dc89d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
@@ -41,7 +41,7 @@ disclaimer.
 static  MV_PP2_PRS_ENTRY pe;
 
 
-static ssize_t mv_prs_help(char *buf)
+static ssize_t mv_prs_low_help(char *buf)
 {
 	int off = 0;
 
@@ -73,23 +73,13 @@ static ssize_t mv_prs_help(char *buf)
 
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p l m o > hw_frst_itr - set values for first iteration port <p>, lookupid <l>, \n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "				  max loops <m>, init offs <o>.\n");
-
 	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
 
-	/* TODO- remove next command, only for debug */
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e > hw_flow     - write flow entry to HW\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "                               flowId <a>, result <b>, result mask <c>, port <d>, tcam index <e>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c     > hw_vlan1    - single vlan entry tpid1 <a>, ports bitmap <b>, add/del <c=1/0>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d   > hw_vlan2    - double vlan entry tpid1 <a>, tpid2 <b>, ports bitmap <c>\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "                               add/del <d=1/0>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e > hw_vlan3    - double vlan entry tpid1 <a>, tpid2 <b>, tpid3 <c>, ports bitmap <d>\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "                               add/del <e=1/0>.\n");
-
 	return off;
 }
 
 
-static ssize_t mv_prs_show(struct device *dev,
+static ssize_t mv_prs_low_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
@@ -104,12 +94,12 @@ static ssize_t mv_prs_show(struct device *dev,
 	else if (!strcmp(name, "hw_regs"))
 		mvPp2PrsHwRegsDump();
 	else
-		off += mv_prs_help(buf);
+		off += mv_prs_low_help(buf);
 
 	return off;
 }
 
-static ssize_t mv_prs_store_signed(struct device *dev,
+static ssize_t mv_prs_low_store_signed(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
@@ -141,17 +131,17 @@ static ssize_t mv_prs_store_signed(struct device *dev,
 }
 
 
-static ssize_t mv_prs_store_unsigned(struct device *dev,
+static ssize_t mv_prs_low_store_unsigned(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
-	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0, e = 0;
+	unsigned int  err = 0, a = 0, b = 0, c = 0;
 	unsigned long flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	sscanf(buf, "%x %x %x %x %x", &a, &b, &c, &d, &e);
+	sscanf(buf, "%x %x %x", &a, &b, &c);
 
 	local_irq_save(flags);
 
@@ -189,14 +179,6 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 	else if (!strcmp(name, "s_fid_gen"))
 		(a == 1) ?	mvPp2PrsSwSramFlowidGenSet(&pe) :
 				mvPp2PrsSwSramFlowidGenClear(&pe);
-	else if (!strcmp(name, "hw_flow"))
-		mvPrsFlowIdGen(e, a, b, c, d);
-	else if (!strcmp(name, "hw_vlan1"))
-		mvPp2PrsSingleVlan(a, b, c);
-	else if (!strcmp(name, "hw_vlan2"))
-		mvPp2PrsDoubleVlan(a, b, c, d);
-	else if (!strcmp(name, "hw_vlan3"))
-		mvPp2PrsTripleVlan(a, b, c, d, e);
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -209,34 +191,33 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
-static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_show, NULL);
-static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_prs_show, NULL);
-static DEVICE_ATTR(help,		S_IRUSR, mv_prs_show, NULL);
-static DEVICE_ATTR(hw_regs,		S_IRUSR, mv_prs_show, NULL);
-static DEVICE_ATTR(sw_clear,    	S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_write,    	S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_read,     	S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_inv,      	S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_inv_all, 		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(t_byte,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(t_port,      	S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(t_port_map,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(t_ai,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(t_lu,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(s_ri,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(s_ai,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(s_next_lu,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(s_shift,		S_IWUSR, mv_prs_show, mv_prs_store_signed);
-static DEVICE_ATTR(s_offs,		S_IWUSR, mv_prs_show, mv_prs_store_signed);
-static DEVICE_ATTR(s_lu_done,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(s_fid_gen,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_show, mv_prs_store_signed);
-static DEVICE_ATTR(hw_flow,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_vlan1,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_vlan2,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(hw_vlan3,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-
-static struct attribute *prs_attrs[] = {
+
+static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(help,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(hw_regs,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(sw_clear,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_write,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_read,     	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv_all, 		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_byte,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_port,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_port_map,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_ri,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_next_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_shift,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+static DEVICE_ATTR(s_offs,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+static DEVICE_ATTR(s_lu_done,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(s_fid_gen,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
+
+
+
+static struct attribute *prs_low_attrs[] = {
     &dev_attr_hw_dump.attr,
     &dev_attr_sw_dump.attr,
     &dev_attr_hw_regs.attr,
@@ -259,19 +240,15 @@ static struct attribute *prs_attrs[] = {
     &dev_attr_s_fid_gen.attr,
     &dev_attr_hw_frst_itr.attr,
     &dev_attr_help.attr,
-    &dev_attr_hw_flow.attr,
-    &dev_attr_hw_vlan1.attr,
-    &dev_attr_hw_vlan2.attr,
-    &dev_attr_hw_vlan3.attr,
     NULL
 };
 
-static struct attribute_group prs_group = {
-	.name = "prs",
-	.attrs = prs_attrs,
+static struct attribute_group prs_low_group = {
+	.name = "prsLow",
+	.attrs = prs_low_attrs,
 };
 
-int __devinit prs_sysfs_init(void)
+int __devinit prs_low_sysfs_init(void)
 {
 	int err;
 	struct device *pd;
@@ -287,7 +264,7 @@ int __devinit prs_sysfs_init(void)
 		pd = &platform_bus;
 	}
 
-	err = sysfs_create_group(&pd->kobj, &prs_group);
+	err = sysfs_create_group(&pd->kobj, &prs_low_group);
 	if (err) {
 		printk(KERN_INFO "sysfs group failed %d\n", err);
 		goto out;
@@ -296,9 +273,9 @@ out:
 	return err;
 }
 
-module_init(prs_sysfs_init);
+module_init(prs_low_sysfs_init);
 
 MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("prs for Marvell NetA2");
+MODULE_DESCRIPTION("prs for Marvell Ppv2");
 MODULE_LICENSE("GPL");
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
index e14c7f1..d8937ea 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
@@ -5,4 +5,4 @@ ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o
+obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o mv_switch_sysfs.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index c1aeca7..ac9f636 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -26,13 +26,14 @@ disclaimer.
 *******************************************************************************/
 
 #include <linux/etherdevice.h>
+#include <linux/platform_device.h>
 #include <linux/interrupt.h>
+#include <linux/mv_switch.h>
+#include <linux/module.h>
 
-#include "mvCommon.h"		/* Should be included before mvSysHwConfig */
 #include "mvOs.h"
 #include "mvSysHwConfig.h"
 #include "eth-phy/mvEthPhy.h"
-#include "boardEnv/mvBoardEnvLib.h"
 #ifdef MV_INCLUDE_ETH_COMPLEX
 #include "ctrlEnv/mvCtrlEthCompLib.h"
 #endif /* MV_INCLUDE_ETH_COMPLEX */
@@ -41,16 +42,24 @@ disclaimer.
 #include "h/platform/gtMiiSmiIf.h"
 #include "mv_switch.h"
 
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-extern void mv_eth_switch_update_link(unsigned int p, unsigned int link_up);
-extern void mv_eth_switch_interrupt_unmask(int qsgmii_module, int gephy_on_port);
-extern void mv_eth_switch_interrupt_clear(int qsgmii_module, int gephy_on_port);
+#ifdef CONFIG_MV_ETH_NETA
+#include "mv_neta/net_dev/mv_mux_netdev.h"
+#elif defined (CONFIG_MV_ETH_PP2)
+#include "mv_pp2/net_dev/mv_mux_netdev.h"
 #endif
 
+unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
+void mv_eth_switch_interrupt_clear(void);
+void mv_eth_switch_interrupt_unmask(void);
+
 #define MV_SWITCH_DEF_INDEX     0
 #define MV_ETH_PORT_0           0
 #define MV_ETH_PORT_1           1
 
+static u16 	db_port_mask[MV_SWITCH_DB_NUM];
+static u16 	db_link_mask[MV_SWITCH_DB_NUM];
+static void *	db_cookies[MV_SWITCH_DB_NUM];
+
 /* uncomment for debug prints */
 /* #define SWITCH_DEBUG */
 
@@ -61,7 +70,7 @@ extern void mv_eth_switch_interrupt_clear(int qsgmii_module, int gephy_on_port);
 #define SWITCH_DBG_ALL      0xffff
 
 #ifdef SWITCH_DEBUG
-static u32 switch_dbg = 0;
+static u32 switch_dbg = 0xffff;
 #define SWITCH_DBG(FLG, X) if ((switch_dbg & (FLG)) == (FLG)) printk X
 #else
 #define SWITCH_DBG(FLG, X)
@@ -74,6 +83,14 @@ static int qd_cpu_port = -1;
 static int qsgmii_module = 0;
 static int gephy_on_port = -1;
 static int rgmiia_on_port = -1;
+static int enabled_ports_mask = 0;
+static int switch_ports_mask = 0;
+static MV_TAG_TYPE tag_mode;
+static MV_SWITCH_PRESET_TYPE preset;
+static int default_vid;
+static int gbe_port;
+
+static struct mux_device_ops *mux_ops = NULL;
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
 static int switch_irq = -1;
@@ -117,9 +134,149 @@ static GT_BOOL mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned in
 	return GT_FALSE;
 }
 
-int mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db, unsigned int ports_mask, unsigned char op)
+static int mv_switch_port_db_get(int port)
+{
+	int db;
+
+	for (db = 0; db < MV_SWITCH_DB_NUM; db++) {
+		if (db_port_mask[db] & (1 << port))
+			return db;
+	}
+
+	return -1;
+}
+
+int mv_switch_default_config_get(MV_TAG_TYPE *tag_mode_val,
+			MV_SWITCH_PRESET_TYPE *preset_val, int *vid_val, int *gbe_port_val)
+{
+	*tag_mode_val = tag_mode;
+	*preset_val = preset;
+	*vid_val = default_vid;
+	*gbe_port_val = gbe_port;
+
+	return 0;
+}
+
+int mv_switch_tag_get(MV_MUX_TAG *tag, MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int db)
+{
+	unsigned int p, port_mask = db_port_mask[db];
+
+	tag->tag_type = tag_mode;
+
+	if (preset == MV_PRESET_SINGLE_VLAN) {
+		if (tag_mode == MV_TAG_TYPE_MH) {
+			tag->rx_tag_ptrn.mh = MV_16BIT_BE(vid << 12);
+			tag->rx_tag_mask.mh = MV_16BIT_BE(0xf000);
+			tag->tx_tag.mh = MV_16BIT_BE((vid << 12) | port_mask);
+		} else if (tag_mode == MV_TAG_TYPE_DSA) {
+			tag->rx_tag_ptrn.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid));
+			tag->rx_tag_mask.dsa = MV_32BIT_BE(0xff000f00);
+			tag->tx_tag.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid));
+		}
+	} else if (preset == MV_PRESET_PER_PORT_VLAN) {
+		for (p = 0; p < qd_dev->numOfPorts; p++)
+			if (MV_BIT_CHECK(port_mask, p) && (p != qd_cpu_port)) {
+				if (tag_mode == MV_TAG_TYPE_MH) {
+					tag->rx_tag_ptrn.mh = MV_16BIT_BE((vid + p) << 12);
+					tag->rx_tag_mask.mh = MV_16BIT_BE(0xf000);
+					tag->tx_tag.mh = MV_16BIT_BE(((vid + p) << 12) | (1 << p));
+				} else if (tag_mode == MV_TAG_TYPE_DSA) {
+					tag->rx_tag_ptrn.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid + p));
+					tag->rx_tag_mask.dsa = MV_32BIT_BE(0xff000f00);
+					tag->tx_tag.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid + p));
+				}
+			}
+	} /* do nothing if Transparent mode */
+
+	return 0;
+}
+
+unsigned int mv_switch_group_map_get(void)
+{
+	unsigned int res = 0, db;
+
+	for (db = 0; db < MV_SWITCH_DB_NUM; db++) {
+		if (db_port_mask[db] != 0)
+			res |= (1 << db);
+	}
+
+	return res;
+}
+
+static int mv_switch_group_state_set(int db, int en)
+{
+	unsigned int p, port_mask = db_port_mask[db];
+
+	/* enable/disable all ports in group */
+	for (p = 0; p < qd_dev->numOfPorts; p++) {
+		if (!MV_BIT_CHECK(port_mask, p))
+			continue;
+
+		if (en) {
+			if (gstpSetPortState(qd_dev, p, GT_PORT_FORWARDING) != GT_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+				return -1;
+			}
+		}
+		else {
+			if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != GT_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int mv_switch_group_enable(int db)
+{
+	return mv_switch_group_state_set(db, 1);
+}
+
+int mv_switch_group_disable(int db)
+{
+	return mv_switch_group_state_set(db, 0);
+}
+
+int mv_switch_link_status_get(int db)
+{
+	return (db_link_mask[db] > 0);
+}
+
+int mv_switch_mux_ops_set(struct mux_device_ops *mux_ops_ptr)
+{
+	mux_ops = mux_ops_ptr;
+
+	return 0;
+}
+
+int mv_switch_group_cookie_set(int db, void *cookie)
+{
+	db_cookies[db] = cookie;
+
+	return 0;
+}
+
+int mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac)
+{
+	int err;
+
+	/* remove old mac */
+	err = mv_switch_mac_addr_set(old_mac, db, 0);
+	if (err)
+		return err;
+
+	/* add new mac */
+	err = mv_switch_mac_addr_set(new_mac, db, 1);
+
+	return err;
+}
+
+int mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db, unsigned char op)
 {
 	GT_ATU_ENTRY mac_entry;
+	unsigned int ports_mask = db_port_mask[db] | (1 << qd_cpu_port);
 
 	memset(&mac_entry, 0, sizeof(GT_ATU_ENTRY));
 
@@ -184,8 +341,6 @@ int mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, uns
 	GT_VTU_ENTRY vtu_entry;
 	unsigned int p;
 
-	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
-	vtu_entry.sid = 1;
 	vtu_entry.vid = vlan_id;
 	vtu_entry.DBNum = db_num;
 	vtu_entry.vidPriOverride = GT_FALSE;
@@ -264,13 +419,13 @@ int mv_switch_promisc_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port, u8 promis
 	return 0;
 }
 
-int mv_eth_switch_vlan_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port)
+int mv_switch_vlan_set(u16 vlan_grp_id, u16 port_map)
 {
 	int p;
 
 	/* set port's default private vlan id and database number (DB per group): */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(port_map, p) && (p != cpu_port)) {
+		if (MV_BIT_CHECK(port_map, p) && (p != qd_cpu_port)) {
 			if (gvlnSetPortVid(qd_dev, p, MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, p)) != GT_OK) {
 				printk(KERN_ERR "gvlnSetPortVid failed\n");
 				return -1;
@@ -283,31 +438,34 @@ int mv_eth_switch_vlan_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port)
 	}
 
 	/* set port's port-based vlan (CPU port is not part of VLAN) */
-	if (mv_switch_port_based_vlan_set((port_map & ~(1 << cpu_port)), 0) != 0)
+	if (mv_switch_port_based_vlan_set((port_map & ~(1 << qd_cpu_port)), 0) != 0)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* set vtu with group vlan id (used in tx) */
-	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id), port_map | (1 << cpu_port)) != 0)
+	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id), port_map | (1 << qd_cpu_port)) != 0)
 		printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 
 	/* set vtu with each port private vlan id (used in rx) */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(port_map, p) && (p != cpu_port)) {
+		if (MV_BIT_CHECK(port_map, p) && (p != qd_cpu_port)) {
 			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, p),
 						      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-						      port_map & ~(1 << cpu_port)) != 0) {
+						      port_map & ~(1 << qd_cpu_port)) != 0) {
 				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 			}
 		}
 	}
 
+	/* update SW vlan DB port mask */
+	db_port_mask[MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id)] = port_map & ~(1 << qd_cpu_port);
+
 	return 0;
 }
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
 void mv_switch_link_update_event(MV_U32 port_mask, int force_link_check)
 {
-	int p;
+	int p, db;
 	unsigned short phy_cause = 0;
 
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
@@ -351,12 +509,27 @@ void mv_switch_link_update_event(MV_U32 port_mask, int force_link_check)
 						else
 							speed = "10Mbps";
 					}
-					mv_eth_switch_update_link(p, 1);
+
+					db = mv_switch_port_db_get(p);
+					if (db != -1) {
+						/* link up event for group device (i.e. mux) */
+						if ((db_link_mask[db] == 0) && (mux_ops) && (mux_ops->update_link))
+							mux_ops->update_link(db_cookies[db], 1);
+						db_link_mask[db] |= (1 << p);
+					}
+
 					printk(KERN_ERR "Port %d: Link-%s, %s-duplex, Speed-%s.\n",
-					       mvBoardSwitchPortMap(MV_SWITCH_DEF_INDEX, p), link, duplex, speed);
+					       p, link, duplex, speed);
 				} else {
-					mv_eth_switch_update_link(p, 0);
-					printk(KERN_ERR "Port %d: Link-down\n", mvBoardSwitchPortMap(MV_SWITCH_DEF_INDEX, p));
+					db = mv_switch_port_db_get(p);
+					if (db != -1) {
+						db_link_mask[db] &= ~(1 << p);
+						/* link down event for group device (i.e. mux) */
+						if ((db_link_mask[db] == 0) && (mux_ops) && (mux_ops->update_link))
+							mux_ops->update_link(db_cookies[db], 0);
+					}
+
+					printk(KERN_ERR "Port %d: Link-down\n", p);
 				}
 			}
 		}
@@ -381,35 +554,21 @@ static irqreturn_t mv_switch_isr(int irq, void *dev_id)
 	GT_DEV_INT_STATUS devIntStatus;
 	MV_U32 port_mask = 0;
 
-	if (qsgmii_module) {
-#ifdef MV_INCLUDE_ETH_COMPLEX
-		MV_U32 reg = 0;
-
-		reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_CAUSE_REG);
-
-		if (reg & MV_ETHCOMP_PCS0_LINK_INT_MASK)
-			port_mask |= 0x1;
-		if (reg & MV_ETHCOMP_PCS1_LINK_INT_MASK)
-			port_mask |= 0x2;
-		if (reg & MV_ETHCOMP_PCS2_LINK_INT_MASK)
-			port_mask |= 0x4;
-		if (reg & MV_ETHCOMP_PCS3_LINK_INT_MASK)
-			port_mask |= 0x8;
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-	} else {
+	if (!qsgmii_module) {
 		if (geventGetDevIntStatus(qd_dev, &devIntStatus) != GT_OK)
 			printk(KERN_ERR "geventGetDevIntStatus failed\n");
 
 		if (devIntStatus.devIntCause & GT_DEV_INT_PHY)
 			port_mask = devIntStatus.phyInt & 0xFF;
 	}
+	/* TODO - qsgmii */
 
 	if (gephy_on_port >= 0)
 		port_mask |= (1 << gephy_on_port);
 
 	mv_switch_link_update_event(port_mask, 0);
 
-	mv_eth_switch_interrupt_clear(qsgmii_module, gephy_on_port);
+	mv_eth_switch_interrupt_clear();
 
 	return IRQ_HANDLED;
 }
@@ -437,10 +596,9 @@ int mv_switch_jumbo_mode_set(int max_size)
 	return 0;
 }
 
-int mv_switch_load(unsigned int switch_ports_mask)
+int mv_switch_load(struct mv_switch_pdata *plat_data)
 {
 	int p;
-	GT_STU_ENTRY	stuEntry;
 
 	printk(KERN_ERR "  o Loading Switch QuarterDeck driver\n");
 
@@ -459,21 +617,14 @@ int mv_switch_load(unsigned int switch_ports_mask)
 	qd_cfg.BSPFunctions.semDelete = NULL;
 	qd_cfg.BSPFunctions.semTake = NULL;
 	qd_cfg.BSPFunctions.semGive = NULL;
-	qd_cfg.initPorts = GT_TRUE;
-	qd_cfg.cpuPortNum = mvBoardSwitchCpuPortGet(MV_SWITCH_DEF_INDEX);
-	if (mvBoardSmiScanModeGet(MV_SWITCH_DEF_INDEX) == 1) {
+	qd_cfg.initPorts = GT_FALSE;
+	qd_cfg.cpuPortNum = plat_data->switch_cpu_port;
+	if (plat_data->smi_scan_mode == 1) {
 		qd_cfg.mode.baseAddr = 0;
 		qd_cfg.mode.scanMode = SMI_MANUAL_MODE;
-	} else if (mvBoardSmiScanModeGet(MV_SWITCH_DEF_INDEX) == 2) {
+	} else if (plat_data->smi_scan_mode == 2) {
 		qd_cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;
-		if (mvBoardSwitchConnectedPortGet(MV_ETH_PORT_0) != -1) {
-			qd_cfg.mode.baseAddr = mvBoardPhyAddrGet(MV_ETH_PORT_0);
-		} else if (mvBoardSwitchConnectedPortGet(MV_ETH_PORT_1) != -1) {
-			qd_cfg.mode.baseAddr = mvBoardPhyAddrGet(MV_ETH_PORT_1);
-		} else {
-			printk(KERN_ERR "mv_switch_load failed: Wrong SCAN mode\n");
-			return -1;
-		}
+		qd_cfg.mode.baseAddr = plat_data->phy_addr;
 	}
 
 	/* load switch sw package */
@@ -484,58 +635,30 @@ int mv_switch_load(unsigned int switch_ports_mask)
 	qd_dev = &qddev;
 	qd_cpu_port = qd_cfg.cpuPortNum;
 
-	/* Create entry in STU table  */
-	memset(&stuEntry, 0, sizeof(GT_STU_ENTRY));
-	stuEntry.sid = 1; /* required: ((sid > 0) && (sid < 0x3F)) */
-	gstuAddEntry(qd_dev, &stuEntry);
-
 	printk(KERN_ERR "    o Device ID     : 0x%x\n", qd_dev->deviceId);
 	printk(KERN_ERR "    o No. of Ports  : %d\n", qd_dev->numOfPorts);
 	printk(KERN_ERR "    o CPU Port      : %ld\n", qd_dev->cpuPortNum);
 
-	qsgmii_module = mvBoardIsQsgmiiModuleConnected();
+	qsgmii_module = plat_data->qsgmii_module;
 	if (qsgmii_module)
 		printk(KERN_ERR "    o QSGMII Module Detected\n");
 
-	gephy_on_port = mvBoardGePhySwitchPortGet();
+	gephy_on_port = plat_data->gephy_on_port;
 	if (gephy_on_port >= 0)
 		printk(KERN_ERR "    o Internal GE PHY Connected to Switch Port %d Detected\n", gephy_on_port);
 
-	rgmiia_on_port = mvBoardRgmiiASwitchPortGet();
+	rgmiia_on_port = plat_data->rgmiia_on_port;
 	if (rgmiia_on_port >= 0)
 		printk(KERN_ERR "    o RGMII-A Connected to Switch Port %d Detected\n", rgmiia_on_port);
 
 	/* disable all disconnected ports */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		/* Do nothing for ports that are not part of the given switch_port_mask */
-		if (!MV_BIT_CHECK(switch_ports_mask, p))
-			continue;
-
-		if (mvBoardSwitchPortMap(MV_SWITCH_DEF_INDEX, p) != -1) {
-			/* Switch port mapped to connector on the board */
-
-			if ((gpcsSetFCValue(qd_dev, p, GT_FALSE) != GT_OK) ||
-			    (gpcsSetForcedFC(qd_dev, p, GT_FALSE) != GT_OK)) {
-				printk(KERN_ERR "Force Flow Control - Failed\n");
-				return -1;
-			}
-#if 0
-			/* TODO - decide if we want to enable auto-negotiation of Flow Control for external ports */
-			if (qsgmii_module) {
-				/* TODO - configure ports via QSGMII registers */
-			} else {
-				GT_STATUS status;
-
-				status = gprtSetPause(qd_dev, p, GT_PHY_PAUSE);
-				if (status != GT_OK)
-					printk(KERN_ERR "Failed set pause for switch port #%d: status = %d\n", p, status);
-			}
-#endif
+		if (!MV_BIT_CHECK(plat_data->port_mask, p))
 			continue;
-		}
 
-		if ((mvBoardSwitchConnectedPortGet(MV_ETH_PORT_0) == p) ||
-		    (mvBoardSwitchConnectedPortGet(MV_ETH_PORT_1) == p)) {
+		/* Force link for switch's CPU port */
+		if (p == plat_data->switch_cpu_port) {
 			/* Switch port connected to GMAC - force link UP - 1000 Full with FC */
 			printk(KERN_ERR "    o Setting Switch Port #%d connected to GMAC port for 1000 Full with FC\n", p);
 			if (gpcsSetForceSpeed(qd_dev, p, PORT_FORCE_SPEED_1000_MBPS) != GT_OK) {
@@ -562,16 +685,28 @@ int mv_switch_load(unsigned int switch_ports_mask)
 			}
 			continue;
 		}
-		printk(KERN_ERR "    o Disable disconnected Switch Port #%d and force link down\n", p);
 
-		if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != GT_OK) {
-			printk(KERN_ERR "gstpSetPortState failed\n");
+		/* Switch port mapped to connector on the board */
+
+		if ((gpcsSetFCValue(qd_dev, p, GT_FALSE) != GT_OK) ||
+		    (gpcsSetForcedFC(qd_dev, p, GT_FALSE) != GT_OK)) {
+			printk(KERN_ERR "Force Flow Control - Failed\n");
 			return -1;
 		}
-		if ((gpcsSetLinkValue(qd_dev, p, GT_FALSE) != GT_OK) ||
-		    (gpcsSetForcedLink(qd_dev, p, GT_TRUE) != GT_OK)) {
-			printk(KERN_ERR "Force Link DOWN - Failed\n");
-			return -1;
+		/* TODO - decide if we want to enable auto-negotiation of Flow Control for external ports */
+
+		/* Diable switch ports that aren't connected to CPU/PHY */
+		if (!MV_BIT_CHECK(plat_data->connected_port_mask, p)) {
+			printk(KERN_ERR "    o Disable disconnected Switch Port #%d and force link down\n", p);
+			if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != GT_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+				return -1;
+			}
+			if ((gpcsSetLinkValue(qd_dev, p, GT_FALSE) != GT_OK) ||
+			    (gpcsSetForcedLink(qd_dev, p, GT_TRUE) != GT_OK)) {
+				printk(KERN_ERR "Force Link DOWN - Failed\n");
+				return -1;
+			}
 		}
 	}
 	return 0;
@@ -641,11 +776,9 @@ int mv_switch_unload(unsigned int switch_ports_mask)
 	return 0;
 }
 
-int mv_switch_init(int mtu, unsigned int switch_ports_mask)
+int mv_switch_init(struct mv_switch_pdata *plat_data)
 {
 	unsigned int p;
-	unsigned char cnt;
-	GT_LPORT port_list[MAX_SWITCH_PORTS];
 
 	if (qd_dev == NULL) {
 		printk(KERN_ERR "%s: qd_dev not initialized, call mv_switch_load() first\n", __func__);
@@ -653,10 +786,13 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 	}
 
 	/* general Switch initialization - relevant for all Switch devices */
+	memset(db_port_mask, 0, sizeof(u16) * MV_SWITCH_DB_NUM);
+	memset(db_link_mask, 0, sizeof(u16) * MV_SWITCH_DB_NUM);
+	memset(db_cookies, 0, sizeof(void *) * MV_SWITCH_DB_NUM);
 
 	/* disable all ports */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p))
+		if (MV_BIT_CHECK(plat_data->connected_port_mask, p))
 			if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != GT_OK) {
 				printk(KERN_ERR "gstpSetPortState failed\n");
 				return -1;
@@ -669,7 +805,7 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 
 	/* set all ports not to unmodify the vlan tag on egress */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+		if (MV_BIT_CHECK(plat_data->connected_port_mask, p)) {
 			if (gprtSetEgressMode(qd_dev, p, GT_UNMODIFY_EGRESS) != GT_OK) {
 				printk(KERN_ERR "gprtSetEgressMode GT_UNMODIFY_EGRESS failed\n");
 				return -1;
@@ -683,19 +819,9 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 		return -1;
 	}
 
-	/* set all ports to work in Normal mode */
-	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p)) {
-			if (gprtSetFrameMode(qd_dev, p, GT_FRAME_MODE_NORMAL) != GT_OK) {
-				printk(KERN_ERR "gprtSetFrameMode GT_FRAME_MODE_NORMAL failed\n");
-				return -1;
-			}
-		}
-	}
-
 	/* set priorities rules */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+		if (MV_BIT_CHECK(plat_data->connected_port_mask, p)) {
 			/* default port priority to queue zero */
 			if (gcosSetPortDefaultTc(qd_dev, p, 0) != GT_OK)
 				printk(KERN_ERR "gcosSetPortDefaultTc failed (port %d)\n", p);
@@ -714,35 +840,102 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 		}
 	}
 
-	/* specific Switch initialization according to Switch ID */
+	if (gfdbFlush(qd_dev, GT_FLUSH_ALL) != GT_OK)
+		printk(KERN_ERR "gfdbFlush failed\n");
+
+	mv_switch_link_detection_init(plat_data);
+
+	mv_switch_jumbo_mode_set(plat_data->mtu);
+
+	/* Configure Ethernet related LEDs, currently according to Switch ID */
 	switch (qd_dev->deviceId) {
 	case GT_88E6161:
 	case GT_88E6165:
 	case GT_88E6171:
 	case GT_88E6351:
-	case GT_88E6172:
-	case GT_88E6176:
-		/* set Header Mode in all ports to False */
+		break;		/* do nothing */
+
+	default:
 		for (p = 0; p < qd_dev->numOfPorts; p++) {
-			if (MV_BIT_CHECK(switch_ports_mask, p)) {
-				if (gprtSetHeaderMode(qd_dev, p, GT_FALSE) != GT_OK) {
-					printk(KERN_ERR "gprtSetHeaderMode GT_FALSE failed\n");
-					return -1;
+			if ((p != qd_cpu_port) && ((p))) {
+				if (gprtSetPhyReg(qd_dev, p, 22, 0x1FFA)) {
+					/* Configure Register 22 LED0 to 0xA for Link/Act */
+					printk(KERN_ERR "gprtSetPhyReg failed (port=%d)\n", p);
 				}
 			}
 		}
+		break;
+	}
+
+	switch_ports_mask = plat_data->connected_port_mask;
+	tag_mode = plat_data->tag_mode;
+	preset = plat_data->preset;
+	default_vid = plat_data->vid;
+	gbe_port = plat_data->gbe_port;
+
+	enabled_ports_mask = switch_ports_mask;
 
-		if (gprtSetHeaderMode(qd_dev, qd_cpu_port, GT_TRUE) != GT_OK) {
+#ifdef SWITCH_DEBUG
+	/* for debug: */
+	mv_switch_status_print();
+#endif
+
+	return 0;
+}
+
+int mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, int vid)
+{
+	unsigned int p;
+	unsigned char cnt;
+	GT_LPORT port_list[MAX_SWITCH_PORTS];
+
+	/* set all ports to work in Normal mode */
+	for (p = 0; p < qd_dev->numOfPorts; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+			if (gprtSetFrameMode(qd_dev, p, GT_FRAME_MODE_NORMAL) != GT_OK) {
+				printk(KERN_ERR "gprtSetFrameMode GT_FRAME_MODE_NORMAL failed\n");
+				return -1;
+			}
+		}
+	}
+
+	/* set Header Mode in all ports to False */
+	for (p = 0; p < qd_dev->numOfPorts; p++) {
+		if (MV_BIT_CHECK(switch_ports_mask, p)) {
+			if (gprtSetHeaderMode(qd_dev, p, GT_FALSE) != GT_OK) {
+				printk(KERN_ERR "gprtSetHeaderMode GT_FALSE failed\n");
+				return -1;
+			}
+		}
+	}
+
+	/* cpu port specific intialization */
+	if (preset != MV_PRESET_TRANSPARENT) {
+		/* set tag mode for CPU port */
+		if ((tag_mode == MV_TAG_TYPE_MH) &&
+				(gprtSetHeaderMode(qd_dev, qd_cpu_port, GT_TRUE) != GT_OK)) {
 			printk(KERN_ERR "gprtSetHeaderMode GT_TRUE failed\n");
 			return -1;
+		} else if ((tag_mode == MV_TAG_TYPE_DSA) &&
+				(gprtSetFrameMode(qd_dev, qd_cpu_port, GT_FRAME_MODE_DSA) != GT_OK)) {
+			printk(KERN_ERR "gprtSetFrameMode GT_TRUE failed\n");
+			return -1;
 		}
 
-		mv_switch_jumbo_mode_set(mtu);
-		break;
-
-	default:
-		printk(KERN_ERR "Unsupported Switch. Switch ID is 0x%X.\n", qd_dev->deviceId);
-		return -1;
+		/* set cpu-port with port-based vlan to all other ports */
+		SWITCH_DBG(SWITCH_DBG_LOAD, ("cpu port-based vlan:"));
+		for (p = 0, cnt = 0; p < qd_dev->numOfPorts; p++) {
+			if (p != qd_cpu_port) {
+				SWITCH_DBG(SWITCH_DBG_LOAD, ("%d ", p));
+				port_list[cnt] = p;
+				cnt++;
+			}
+		}
+		SWITCH_DBG(SWITCH_DBG_LOAD, ("\n"));
+		if (gvlnSetPortVlanPorts(qd_dev, qd_cpu_port, port_list, cnt) != GT_OK) {
+			printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
+			return -1;
+		}
 	}
 
 	/* The switch CPU port is not part of the VLAN, but rather connected by tunneling to each */
@@ -750,7 +943,8 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 	/* at switch level to forward packets with this DA to CPU port.                           */
 	SWITCH_DBG(SWITCH_DBG_LOAD, ("Enabling Tunneling on ports: "));
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p) && (p != qd_cpu_port)) {
+		if (MV_BIT_CHECK(switch_ports_mask, p) &&
+				((p != qd_cpu_port) || (preset == MV_PRESET_TRANSPARENT))) {
 			if (gprtSetVlanTunnel(qd_dev, p, GT_TRUE) != GT_OK) {
 				printk(KERN_ERR "gprtSetVlanTunnel failed (port %d)\n", p);
 				return -1;
@@ -761,71 +955,85 @@ int mv_switch_init(int mtu, unsigned int switch_ports_mask)
 	}
 	SWITCH_DBG(SWITCH_DBG_LOAD, ("\n"));
 
-	/* set cpu-port with port-based vlan to all other ports */
-	SWITCH_DBG(SWITCH_DBG_LOAD, ("cpu port-based vlan:"));
-	for (p = 0, cnt = 0; p < qd_dev->numOfPorts; p++) {
-		if (p != qd_cpu_port) {
-			SWITCH_DBG(SWITCH_DBG_LOAD, ("%d ", p));
-			port_list[cnt] = p;
-			cnt++;
-		}
+	/* split ports to vlans according to preset */
+	if (preset == MV_PRESET_SINGLE_VLAN) {
+		mv_switch_vlan_set(MV_SWITCH_GROUP_VLAN_ID(vid), switch_ports_mask);
+	} else if (preset == MV_PRESET_PER_PORT_VLAN) {
+		for (p = 0; p < qd_dev->numOfPorts; p++)
+			if (MV_BIT_CHECK(switch_ports_mask, p) && (p != qd_cpu_port)) {
+				mv_switch_vlan_set(MV_SWITCH_GROUP_VLAN_ID(vid + p), (1 << p));
+			}
 	}
-	SWITCH_DBG(SWITCH_DBG_LOAD, ("\n"));
-	if (gvlnSetPortVlanPorts(qd_dev, qd_cpu_port, port_list, cnt) != GT_OK) {
-		printk(KERN_ERR "gvlnSetPortVlanPorts failed\n");
-		return -1;
+
+	if (preset == MV_PRESET_TRANSPARENT) {
+		/* enable all relevant ports (ports connected to the MAC or external ports) */
+		for (p = 0; p < qd_dev->numOfPorts; p++) {
+			if (!MV_BIT_CHECK(switch_ports_mask, p))
+				continue;
+
+			if (gstpSetPortState(qd_dev, p, GT_PORT_FORWARDING) != GT_OK) {
+				printk(KERN_ERR "gstpSetPortState failed\n");
+				return -1;
+			}
+		}
+	} else {
+		/* enable cpu port */
+		if (gstpSetPortState(qd_dev, qd_cpu_port, GT_PORT_FORWARDING) != GT_OK) {
+			printk(KERN_ERR "gstpSetPortState failed\n");
+			return -1;
+		}
 	}
 
-	if (gfdbFlush(qd_dev, GT_FLUSH_ALL) != GT_OK)
-		printk(KERN_ERR "gfdbFlush failed\n");
+	return 0;
+}
 
-	mv_switch_link_detection_init();
+void mv_eth_switch_interrupt_unmask(void)
+{
+#ifdef MV_INCLUDE_ETH_COMPLEX
+	MV_U32 reg;
 
-	/* Configure Ethernet related LEDs, currently according to Switch ID */
-	switch (qd_dev->deviceId) {
-	case GT_88E6161:
-	case GT_88E6165:
-	case GT_88E6171:
-	case GT_88E6351:
-	case GT_88E6172:
-	case GT_88E6176:
-		break;		/* do nothing */
+	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_MASK_REG);
 
-	default:
-		for (p = 0; p < qd_dev->numOfPorts; p++) {
-			if ((p != qd_cpu_port) && ((p))) {
-				if (gprtSetPhyReg(qd_dev, p, 22, 0x1FFA)) {
-					/* Configure Register 22 LED0 to 0xA for Link/Act */
-					printk(KERN_ERR "gprtSetPhyReg failed (port=%d)\n", p);
-				}
-			}
-		}
-		break;
+	if (qsgmii_module) {
+		reg |= (MV_ETHCOMP_PCS0_LINK_INT_MASK |
+			MV_ETHCOMP_PCS1_LINK_INT_MASK |
+			MV_ETHCOMP_PCS2_LINK_INT_MASK |
+			MV_ETHCOMP_PCS3_LINK_INT_MASK);
 	}
 
-	/* enable all relevant ports (ports connected to the MAC or external ports) */
-	for (p = 0; p < qd_dev->numOfPorts; p++) {
-		if (MV_BIT_CHECK(switch_ports_mask, p)) {
-			if ((mvBoardSwitchPortMap(MV_SWITCH_DEF_INDEX, p) != -1) ||
-			    (mvBoardSwitchConnectedPortGet(MV_ETH_PORT_0) == p) ||
-			    (mvBoardSwitchConnectedPortGet(MV_ETH_PORT_1) == p)) {
-				if (gstpSetPortState(qd_dev, p, GT_PORT_FORWARDING) != GT_OK) {
-					printk(KERN_ERR "gstpSetPortState failed\n");
-					return -1;
-				}
-			}
-		}
+	if (gephy_on_port >= 0)
+		reg |= MV_ETHCOMP_GEPHY_INT_MASK;
+
+	reg |= MV_ETHCOMP_SWITCH_INT_MASK;
+
+	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_MASK_REG, reg);
+#endif /* MV_INCLUDE_ETH_COMPLEX */
+}
+
+void mv_eth_switch_interrupt_clear(void)
+{
+#ifdef MV_INCLUDE_ETH_COMPLEX
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_CAUSE_REG);
+
+	if (qsgmii_module) {
+		reg &= ~(MV_ETHCOMP_PCS0_LINK_INT_MASK |
+			 MV_ETHCOMP_PCS1_LINK_INT_MASK |
+			 MV_ETHCOMP_PCS2_LINK_INT_MASK |
+			 MV_ETHCOMP_PCS3_LINK_INT_MASK);
 	}
 
-#ifdef SWITCH_DEBUG
-	/* for debug: */
-	mv_switch_status_print();
-#endif
+	if (gephy_on_port >= 0)
+		reg &= ~MV_ETHCOMP_GEPHY_INT_MASK;
 
-	return 0;
+	reg &= ~MV_ETHCOMP_SWITCH_INT_MASK;
+
+	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_CAUSE_REG, reg);
+#endif /* MV_INCLUDE_ETH_COMPLEX */
 }
 
-unsigned int mv_switch_link_detection_init(void)
+unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
 {
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
 
@@ -838,16 +1046,10 @@ unsigned int mv_switch_link_detection_init(void)
 		return 0;
 	}
 
-	switch_irq = mvBoardSwitchIrqGet();
+	switch_irq = plat_data->switch_irq;
 
 	if (!qsgmii_module) {
-		/* liron, TODO: find a nicer solution or use BoardEnv */
-#ifdef MV_INCLUDE_ETH_COMPLEX
-		/* QSGMII module is not connected, Switch is working in 3xFE mode */
-		connected_phys_mask = 0x0E;	/* KW2: Switch PHYs 1, 2, 3 */
-#else
-		connected_phys_mask = 0x1F;	/* KW40: Switch PHYs 0, 1, 2, 3, 4 */
-#endif
+		connected_phys_mask = plat_data->connected_port_mask & ~(1 << qd_cpu_port);
 
 		if (!link_init_done) {
 			/* Enable Phy Link Status Changed interrupt at Phy level for the all enabled ports */
@@ -862,9 +1064,7 @@ unsigned int mv_switch_link_detection_init(void)
 				/* Interrupt supported */
 
 				if ((qd_dev->deviceId == GT_88E6161) || (qd_dev->deviceId == GT_88E6165) ||
-				    (qd_dev->deviceId == GT_88E6351) || (qd_dev->deviceId == GT_88E6171) ||
-				    (qd_dev->deviceId == GT_88E6172) || (qd_dev->deviceId == GT_88E6176)) {
-
+				    (qd_dev->deviceId == GT_88E6351) || (qd_dev->deviceId == GT_88E6171)) {
 					GT_DEV_EVENT gt_event = { GT_DEV_INT_PHY, 0, connected_phys_mask };
 
 					if (eventSetDevInt(qd_dev, &gt_event) != GT_OK)
@@ -916,9 +1116,8 @@ unsigned int mv_switch_link_detection_init(void)
 
 	if (!link_init_done) {
 		if (switch_irq != -1) {
+			mv_eth_switch_interrupt_unmask();
 			/* Interrupt supported */
-			mv_eth_switch_interrupt_unmask(qsgmii_module, gephy_on_port);
-
 			if (request_irq(switch_irq, mv_switch_isr, (IRQF_DISABLED | IRQF_SAMPLE_RANDOM), "switch", NULL))
 				printk(KERN_ERR "failed to assign irq%d\n", switch_irq);
 		}
@@ -928,6 +1127,8 @@ unsigned int mv_switch_link_detection_init(void)
 
 	return connected_phys_mask;
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
+
+	return 0;
 }
 
 int mv_switch_tos_get(unsigned char tos)
@@ -1156,7 +1357,7 @@ static char *mv_str_header_mode(GT_BOOL mode)
 
 void mv_switch_status_print(void)
 {
-	int p;
+	int p, i;
 	GT_PORT_STP_STATE port_state = -1;
 	GT_EGRESS_MODE egress_mode = -1;
 	GT_FRAME_MODE frame_mode = -1;
@@ -1168,6 +1369,10 @@ void mv_switch_status_print(void)
 	}
 	printk(KERN_ERR "Printing Switch Status:\n");
 
+	for (i = 0; i < MV_SWITCH_DB_NUM; i++)
+		if (db_port_mask[i])
+			printk(KERN_ERR "%d: %d\n", i, db_port_mask[i]);
+
 	printk(KERN_ERR "Port   State     Link   Duplex   Speed    Pause     Egress     Frame    Header\n");
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 
@@ -1311,9 +1516,24 @@ int mv_switch_all_multicasts_del(int db_num)
 	return 0;
 }
 
-int mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map)
+int mv_switch_port_add(int switch_port, u16 grp_id)
 {
 	int p;
+	u16 port_map, vlan_grp_id;
+
+	if (!MV_BIT_CHECK(switch_ports_mask, switch_port)) {
+		printk(KERN_ERR "%s: switch port %d is not connected to PHY/CPU\n", __func__, switch_port);
+		return -1;
+	}
+
+	if (MV_BIT_CHECK(enabled_ports_mask, switch_port)) {
+		printk(KERN_ERR "%s: switch port %d is already enabled\n", __func__, switch_port);
+		return -1;
+	}
+
+	vlan_grp_id = MV_SWITCH_GROUP_VLAN_ID(grp_id);
+	/* Add port to port mask of VLAN group */
+	port_map = db_port_mask[grp_id] | (1 << switch_port);
 
 	/* Set default VLAN_ID for port */
 	if (gvlnSetPortVid(qd_dev, switch_port, MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, switch_port)) != GT_OK) {
@@ -1321,7 +1541,7 @@ int mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map)
 		return -1;
 	}
 	/* Map port to VLAN DB */
-	if (gvlnSetPortVlanDBNum(qd_dev, switch_port, MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id)) != GT_OK) {
+	if (gvlnSetPortVlanDBNum(qd_dev, switch_port, grp_id) != GT_OK) {
 		printk(KERN_ERR "gvlnSetPortVlanDBNum failed\n");
 		return -1;
 	}
@@ -1331,8 +1551,7 @@ int mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* Add port to vtu (used in tx) */
-	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-				      (port_map | (1 << qd_cpu_port)))) {
+	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, grp_id, (port_map | (1 << qd_cpu_port)))) {
 		printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 	}
 
@@ -1340,8 +1559,7 @@ int mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map)
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		if (MV_BIT_CHECK(port_map, p) && (p != qd_cpu_port)) {
 			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, p),
-						      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-						      port_map & ~(1 << qd_cpu_port)) != 0) {
+						      grp_id, port_map & ~(1 << qd_cpu_port)) != 0) {
 				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 			}
 		}
@@ -1358,12 +1576,42 @@ int mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map)
 	}
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
+	db_port_mask[grp_id] = port_map;
+	enabled_ports_mask |= (1 << switch_port);
+	/* TODO if new mux */
+	//mv_switch_mux_create(NULL/*TODO name*/, 0/*TODO gbe_port*/, grp_id, port_map | (1 << qd_cpu_port), NULL/*TODO tag*/);
+
 	return 0;
 }
 
-int mv_switch_port_del(int switch_port, u16 vlan_grp_id, u16 port_map)
+int mv_switch_port_del(int switch_port)
 {
 	int p;
+	u16 port_map, vlan_grp_id, grp_id;
+
+	if (!MV_BIT_CHECK(switch_ports_mask, switch_port)) {
+		printk(KERN_ERR "%s: switch port %d is not connected to PHY/CPU\n", __func__, switch_port);
+		return -1;
+	}
+
+	if (!MV_BIT_CHECK(enabled_ports_mask, switch_port)) {
+		printk(KERN_ERR "%s: switch port %d is already disabled\n", __func__, switch_port);
+		return -1;
+	}
+
+	/* Search for port's DB number */
+	for (grp_id = 0; grp_id < MV_SWITCH_DB_NUM; grp_id++)
+		if (db_port_mask[grp_id] & (1 << switch_port))
+			break;
+
+	if (grp_id == MV_SWITCH_DB_NUM) {
+		printk(KERN_ERR "%s: couldn't find port %d VLAN group\n", __func__, switch_port);
+		return -1;
+	}
+
+	vlan_grp_id = MV_SWITCH_GROUP_VLAN_ID(grp_id);
+	/* Add port to port mask of VLAN group */
+	port_map = db_port_mask[grp_id] & ~(1 << switch_port);
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
 	if (!qsgmii_module) {
@@ -1397,5 +1645,63 @@ int mv_switch_port_del(int switch_port, u16 vlan_grp_id, u16 port_map)
 		}
 	}
 
+	db_port_mask[grp_id] = port_map;
+	enabled_ports_mask &= ~(1 << switch_port);
+
 	return 0;
 }
+
+static int mv_switch_probe(struct platform_device *pdev)
+{
+	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
+
+	/* load switch driver, force link on cpu port */
+	mv_switch_load(plat_data);
+
+	/* default switch init, disable all ports */
+	mv_switch_init(plat_data);
+
+	return MV_OK;
+}
+
+static int mv_switch_remove(struct platform_device *pdev)
+{
+	printk(KERN_INFO "Removing Marvell Switch Driver\n");
+	//unload
+
+	return MV_OK;
+}
+
+static void mv_switch_shutdown(struct platform_device *pdev)
+{
+	printk(KERN_INFO "Shutting Down Marvell Switch Driver\n");
+}
+
+static struct platform_driver mv_switch_driver = {
+	.probe = mv_switch_probe,
+	.remove = mv_switch_remove,
+	.shutdown = mv_switch_shutdown,
+#ifdef CONFIG_CPU_IDLE
+	/* TBD */
+#endif /* CONFIG_CPU_IDLE */
+	.driver = {
+		.name = MV_SWITCH_SOHO_NAME,
+	},
+};
+
+static int __init mv_switch_init_module(void)
+{
+	return platform_driver_register(&mv_switch_driver);
+}
+late_initcall(mv_switch_init_module);
+
+static void __exit mv_switch_cleanup_module(void)
+{
+	platform_driver_unregister(&mv_switch_driver);
+}
+module_exit(mv_switch_cleanup_module);
+
+
+MODULE_DESCRIPTION("Marvell Internal Switch Driver - www.marvell.com");
+MODULE_AUTHOR("Dmitri Epshtein <dima@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index 5c02f89..e156c2b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -28,6 +28,10 @@ disclaimer.
 #ifndef __mv_switch_h__
 #define __mv_switch_h__
 
+#include "mv802_3.h"
+
+#define MV_SWITCH_DB_NUM			16
+
 #define MV_SWITCH_PHY_ACCESS			1
 #define MV_SWITCH_PORT_ACCESS			2
 #define MV_SWITCH_GLOBAL_ACCESS			3
@@ -38,21 +42,21 @@ disclaimer.
 #define MV_SWITCH_GROUP_VLAN_ID(grp)       (((grp) + 1) << 8)
 #define MV_SWITCH_VLAN_TO_GROUP(vid)       ((((vid) & 0xf00) >> 8) - 1)
 
-int     mv_switch_load(unsigned int switch_ports_mask);
+/* operations requested by switch device from mux device */
+struct mux_device_ops {
+	int	(*update_link)(void *cookie, int link_up);
+};
+
 int     mv_switch_unload(unsigned int switch_ports_mask);
-int     mv_switch_init(int mtu, unsigned int switch_ports_mask);
 void    mv_switch_link_update_event(MV_U32 port_mask, int force_link_check);
 int     mv_switch_jumbo_mode_set(int max_size);
 int     mv_switch_tos_get(unsigned char tos);
 int     mv_switch_tos_set(unsigned char tos, int queue);
 int     mv_switch_port_based_vlan_set(unsigned int ports_mask, int set_cpu_port);
 int     mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, unsigned int ports_mask);
-int     mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db,
-			       unsigned int ports_mask, unsigned char op);
 int     mv_switch_atu_db_flush(int db_num);
-int     mv_eth_switch_vlan_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port);
+int     mv_switch_vlan_set(u16 vlan_grp_id, u16 port_map);
 int     mv_switch_promisc_set(u16 vlan_grp_id, u16 port_map, u16 cpu_port, u8 promisc_on);
-unsigned int    mv_switch_link_detection_init(void);
 
 int     mv_switch_reg_read(int port, int reg, int type, MV_U16 *value);
 int     mv_switch_reg_write(int port, int reg, int type, MV_U16 value);
@@ -62,7 +66,18 @@ void    mv_switch_status_print(void);
 
 int     mv_switch_all_multicasts_del(int db_num);
 
-int     mv_switch_port_add(int switch_port, u16 vlan_grp_id, u16 port_map);
-int     mv_switch_port_del(int switch_port, u16 vlan_grp_id, u16 port_map);
+int     mv_switch_port_add(int switch_port, u16 vlan_grp_id);
+int     mv_switch_port_del(int switch_port);
 
+int		mv_switch_default_config_get(MV_TAG_TYPE *tag_mode, MV_SWITCH_PRESET_TYPE *preset, int *vid, int *gbe_port);
+int		mv_switch_tag_get(MV_MUX_TAG *tag, MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int db);
+unsigned int	mv_switch_group_map_get(void);
+int		mv_switch_group_enable(int db);
+int		mv_switch_group_disable(int db);
+int		mv_switch_link_status_get(int db);
+int		mv_switch_group_cookie_set(int db, void *cookie);
+int		mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac);
+int		mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db, unsigned char op);
+int		mv_switch_mux_ops_set(struct mux_device_ops *mux_ops_ptr);
+int		mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, int vid);
 #endif /* __mv_switch_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
index f6b19e8..15af68a4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
@@ -33,9 +33,8 @@ disclaimer.
 #include <linux/platform_device.h>
 #include <linux/netdevice.h>
 
-#include "mvTypes.h"
+#include "mv802_3.h"
 #include "mv_switch.h"
-#include "../mv_neta/net_dev/mv_netdev.h"
 
 static ssize_t mv_switch_help(char *buf)
 {
@@ -44,11 +43,8 @@ static ssize_t mv_switch_help(char *buf)
 	off += sprintf(buf+off, "cat help                            - show this help\n");
 	off += sprintf(buf+off, "cat stats                           - show statistics for switch all ports info\n");
 	off += sprintf(buf+off, "cat status                          - show switch status\n");
-#ifdef CONFIG_MV_ETH_SWITCH
-	off += sprintf(buf+off, "echo <eth_name>   > netdev_sts      - print network device status\n");
-	off += sprintf(buf+off, "echo <eth_name> p > port_add        - map switch port to a network device\n");
-	off += sprintf(buf+off, "echo <eth_name> p > port_del        - unmap switch port from a network device\n");
-#endif /* CONFIG_MV_ETH_SWITCH */
+	off += sprintf(buf+off, "echo p grp        > port_add        - map switch port to a network device\n");
+	off += sprintf(buf+off, "echo p            > port_del        - unmap switch port from a network device\n");
 	off += sprintf(buf+off, "echo p r t   > reg_r                - read switch register.  t: 1-phy, 2-port, 3-global, 4-global2, 5-smi\n");
 	off += sprintf(buf+off, "echo p r t v > reg_w                - write switch register. t: 1-phy, 2-port, 3-global, 4-global2, 5-smi\n");
 	return off;
@@ -106,32 +102,23 @@ static ssize_t mv_switch_store(struct device *dev, struct device_attribute *attr
 	return err ? -EINVAL : len;
 }
 
-#ifdef CONFIG_MV_ETH_SWITCH
 static ssize_t mv_switch_netdev_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char      *name = attr->attr.name;
-	int             err = 0, port = 0;
-	char            dev_name[30];
-	struct net_device *netdev;
+	int             err = 0, port = 0, group;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
 	/* Read arguments */
-	sscanf(buf, "%s %d", dev_name, &port);
-	netdev = dev_get_by_name(&init_net, dev_name);
-	if (netdev == NULL) {
-		err = 1;
-	} else {
-		if (!strcmp(name, "netdev_sts"))
-			mv_eth_netdev_print(netdev);
-		else if (!strcmp(name, "port_add"))
-			err = mv_eth_switch_port_add(netdev, port);
-		else if (!strcmp(name, "port_del"))
-			err = mv_eth_switch_port_del(netdev, port);
-
-		dev_put(netdev);
-	}
+	sscanf(buf, "%d %d", &port, &group);
+
+
+	if (!strcmp(name, "port_add"))
+		err = mv_switch_port_add(port, group);
+	else if (!strcmp(name, "port_del"))
+		err = mv_switch_port_del(port);
+
 
 	if (err)
 		printk(KERN_ERR " - FAILED, err=%d\n", err);
@@ -140,18 +127,14 @@ static ssize_t mv_switch_netdev_store(struct device *dev, struct device_attribut
 
 	return err ? -EINVAL : len;
 }
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 static DEVICE_ATTR(reg_r,       S_IWUSR, mv_switch_show, mv_switch_store);
 static DEVICE_ATTR(reg_w,       S_IWUSR, mv_switch_show, mv_switch_store);
 static DEVICE_ATTR(status,      S_IRUSR, mv_switch_show, mv_switch_store);
 static DEVICE_ATTR(stats,       S_IRUSR, mv_switch_show, mv_switch_store);
 static DEVICE_ATTR(help,        S_IRUSR, mv_switch_show, mv_switch_store);
-#ifdef CONFIG_MV_ETH_SWITCH
-static DEVICE_ATTR(netdev_sts,  S_IWUSR, mv_switch_show, mv_switch_netdev_store);
 static DEVICE_ATTR(port_add,    S_IWUSR, mv_switch_show, mv_switch_netdev_store);
 static DEVICE_ATTR(port_del,    S_IWUSR, mv_switch_show, mv_switch_netdev_store);
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 static struct attribute *mv_switch_attrs[] = {
 	&dev_attr_reg_r.attr,
@@ -159,11 +142,8 @@ static struct attribute *mv_switch_attrs[] = {
 	&dev_attr_status.attr,
 	&dev_attr_stats.attr,
 	&dev_attr_help.attr,
-#ifdef CONFIG_MV_ETH_SWITCH
-	&dev_attr_netdev_sts.attr,
 	&dev_attr_port_add.attr,
 	&dev_attr_port_del.attr,
-#endif /* CONFIG_MV_ETH_SWITCH */
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
index 817d16b..591a927 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
@@ -121,10 +121,10 @@ static INLINE void mvBmPoolMcPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAdd
 
 static INLINE MV_U32 mvBmPoolGet(int pool)
 {
-	MV_U32 bufPhysAddr, bufVirtAddr;
+	MV_U32 bufVirtAddr;
 
-	bufPhysAddr = mvPp2RdReg(MV_BM_PHY_ALLOC_REG(pool));
-	bufVirtAddr = mvPp2RdReg(MV_BM_VIRT_ALLOC_REG);
+	mvPp2RdReg(MV_BM_PHY_ALLOC_REG(pool)); /* read physical address */
+	bufVirtAddr = mvPp2RdReg(MV_BM_VIRT_ALLOC_REG); /* return virtual address */
 
 	return bufVirtAddr;
 }
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
index 3e1507c..5f959ae 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
@@ -70,7 +70,7 @@ int mvPp2ClassifierDefInit()
 		return MV_ERROR;
 
 	/* WorkAround HW bug */
-	//mvPp2ClsHwLastBitWorkAround();
+	/*mvPp2ClsHwLastBitWorkAround();*/
 #ifdef CONFIG_MV_ETH_PP2_CLS2
 	if (mvPp2ClsC2Init())
 		return MV_ERROR;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
index ee48e59..6757124 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -156,12 +156,24 @@ MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData)
 
 	/* Allocate physical TXQs */
 	status = mvPp2PhysTxqsAlloc();
+	if (status != MV_OK) {
+		mvOsPrintf("%s: mvPp2PhysTxqsAlloc failed\n", __func__);
+		return status;
+	}
 
 	/* Allocate aggregated TXQs */
 	status = mvPp2AggrTxqsAlloc(mvPp2HalData.maxCPUs);
+	if (status != MV_OK) {
+		mvOsPrintf("%s: mvPp2AggrTxqsAlloc failed\n", __func__);
+		return status;
+	}
 
 	/* Allocate physical RXQs */
 	status = mvPp2PhysRxqsAlloc();
+	if (status != MV_OK) {
+		mvOsPrintf("%s: mvPp2PhysRxqsAlloc failed\n", __func__);
+		return status;
+	}
 
 	mvBmInit();
 
@@ -796,13 +808,12 @@ void mvPp2TxpReset(int port, int txp)
 		mvPp2WrReg(MV_PP2_TXQ_INDEX_REG, 0);
 	}
 }
-
-/*
- * Allocate and initialize port structure.
- * Allocate an initialize TXQs for this port.
- * Associate <numRxqs> RXQs for Port number <port>, starting from RXQ number <firstRxq>.
- * Note: mvPp2PortCtrl must be initialized, i.e. must call mvPp2HalInit before this function.
- */
+/*-------------------------------------------------------------------------------*/
+/* Port */
+/* Allocate and initialize port structure
+   Alocate an initialize TXQs for this port
+   Associate <numRxqs> RXQs for Port number <port>, starting from RXQ number <firstRxq>
+   Note: mvPp2PortCtrl must be initialized, i.e. must call mvPp2HalInit before this function */
 void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle)
 {
 	MV_STATUS status;
@@ -1271,7 +1282,7 @@ MV_STATUS mvPp2TxpBurstSet(int port, int txp, int burst)
 		size = MV_PP2_TXP_TOKEN_SIZE_MAX;
 
 	/* Token bucket size must be larger then MTU */
-	mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG);
+	mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_MTU_REG);
 	if (mtu > size) {
 		mvOsPrintf("%s Error: Bucket size (%d bytes) < MTU (%d bytes)\n",
 					__func__, (size / 8), (mtu / 8));
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index 1ed1c68..b9f3ee9 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -74,8 +74,18 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvPp2GbeRegs.h"
 #include "pp2/gmac/mvEthGmacApi.h"
 #include "pp2/common/mvPp2Common.h"
+#include "pp2/prs/mvPp2PrsHw.h"
 
 
+#define PP2_CPU_CODE_IS_RX_SPECIAL(cpu_code)		((cpu_code) & RI_CPU_CODE_RX_SPEC_VAL)
+
+static inline int mvPp2IsRxSpecial(MV_U16 parser_info)
+{
+	MV_U16 cpu_code = (parser_info & PP2_RX_CPU_CODE_MASK) >> PP2_RX_CPU_CODE_OFFS;
+
+	return PP2_CPU_CODE_IS_RX_SPECIAL(cpu_code);
+}
+
 /************************** PPv2 HW Configuration ***********************/
 typedef struct eth_pbuf {
 	void *osInfo;
@@ -210,7 +220,7 @@ static INLINE int mvPp2LogicRxqToPhysRxq(int port, int rxq)
 #define MV_PPV2_PORT_PHYS(port)			((MV_PON_PORT(port)) ? MV_PON_PHYS_PORT_GET() : (port))
 #define MV_PPV2_TXP_PHYS(port, txp)		((MV_PON_PORT(port)) ? txp : (MV_ETH_MAX_TCONT + port))
 #define MV_PPV2_TXQ_PHYS(port, txp, txq)	((MV_PON_PORT(port)) ? txp * MV_ETH_MAX_TXQ + txq :\
-							MV_PP2_TOTAL_PON_TXQ_NUM + port * MV_ETH_MAX_TXQ + txq)
+											MV_PP2_TOTAL_PON_TXQ_NUM + port * MV_ETH_MAX_TXQ + txq)
 
 #define MV_PPV2_TXQ_LOGICAL_PORT(physTxq)	((physTxq < MV_PP2_TOTAL_PON_TXQ_NUM) ? MV_PON_LOGIC_PORT_ID_GET() :\
 							(physTxq - MV_PP2_TOTAL_PON_TXQ_NUM) / MV_ETH_MAX_TXQ)
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
index 581fa62..2054517 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
@@ -545,9 +545,9 @@ void mvPp2PortStatus(int port)
 	mvOsPrintf("\n[RXQ mapping: port=%d, ctrl=%p]\n", port, pPortCtrl);
 	if (pPortCtrl->pRxQueue) {
 		mvOsPrintf("         RXQ: ");
-		for (i = 0; i < pPortCtrl->rxqNum; i++) {
+		for (i = 0; i < pPortCtrl->rxqNum; i++)
 			mvOsPrintf(" %4d", i);
-		}
+
 		mvOsPrintf("\nphysical RXQ: ");
 		for (i = 0; i < pPortCtrl->rxqNum; i++) {
 			if (pPortCtrl->pRxQueue[i])
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
index 4afe0f1..e0eeab7 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
@@ -583,7 +583,7 @@ typedef struct pp2_rx_desc {
 #define PP2_RX_BUF_HDR_MASK                	(1 << PP2_RX_BUF_HDR_BIT)
 
 /* status field MACROs */
-#define PP2_RX_L3_IS_IP4(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4) 
+#define PP2_RX_L3_IS_IP4(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4)
 #define PP2_RX_L3_IS_IP4_OPT(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4_OPT)
 #define PP2_RX_L3_IS_IP4_OTHER(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4_OTHER)
 #define PP2_RX_L3_IS_IP6(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP6)
@@ -594,19 +594,29 @@ typedef struct pp2_rx_desc {
 #define PP2_RX_IP4_FRG(status)			((status) & PP2_RX_IP_FRAG_MASK)
 #define PP2_RX_L4_CHK_OK(status)		((status) & PP2_RX_L4_CHK_OK_MASK)
 
-/* Bits of "parserInfo" field */
+/* Sub fields of "parserInfo" field */
 #define PP2_RX_LKP_ID_OFFS              	0
-#define PP2_RX_LKP_ID_BITS			6				
+#define PP2_RX_LKP_ID_BITS			6
 #define PP2_RX_LKP_ID_MASK              	(((1 << PP2_RX_LKP_ID_BITS) - 1) << PP2_RX_LKP_ID_OFFS)
 
 #define PP2_RX_CPU_CODE_OFFS			6
-#define PP2_RX_CPU_CODE_MASK			((0x7) << PP2_RX_CPU_CODE_OFFS)
-#define PP2_RX_SPECIAL				(1 << PP2_RX_CPU_CODE_OFFS)
-#define PP2_RX_IS_RX_SPECIAL(parserInfo)	(((parserInfo) & PP2_RX_CPU_CODE_MASK) == PP2_RX_SPECIAL)
+#define PP2_RX_CPU_CODE_BITS			3
+#define PP2_RX_CPU_CODE_MASK			(((1 << PP2_RX_CPU_CODE_BITS) - 1) << PP2_RX_CPU_CODE_OFFS)
 
-#define PP2_RX_PRS_INFO_OFFS            	6
-#define PP2_RX_PRS_INFO_BITS			10				
-#define PP2_RX_PRS_INFO_MASK            	(((1 << PP2_RX_PRS_INFO_BITS) - 1) << PP2_RX_PRS_INFO_OFFS)
+#define PP2_RX_PPPOE_BIT                        9
+#define PP2_RX_PPPOE_MASK                       (1 << PP2_RX_PPPOE_BIT)
+
+#define PP2_RX_L3_CAST_OFFS                     10
+#define PP2_RX_L3_CAST_BITS                     2
+#define PP2_RX_L3_CAST_MASK                     (((1 << PP2_RX_L3_CAST_BITS) - 1) << PP2_RX_L3_CAST_OFFS)
+
+#define PP2_RX_L2_CAST_OFFS                     12
+#define PP2_RX_L2_CAST_BITS                     2
+#define PP2_RX_L2_CAST_MASK                     (((1 << PP2_RX_L2_CAST_BITS) - 1) << PP2_RX_L2_CAST_OFFS)
+
+#define PP2_RX_VLAN_INFO_OFFS                   14
+#define PP2_RX_VLAN_INFO_BITS                   2
+#define PP2_RX_VLAN_INFO_MASK                   (((1 << PP2_RX_VLAN_INFO_BITS) - 1) << PP2_RX_VLAN_INFO_OFFS)
 /*-------------------------------------------------------------------------------*/
 
 /* TXQ */
@@ -617,11 +627,8 @@ typedef struct pp2_tx_desc {
 	MV_U16 dataSize;
 	MV_U32 bufPhysAddr;
 	MV_U32 bufCookie;
-	MV_U16 ponHwCmd;
-	MV_U16 initialCsumL4;
-	MV_U16 reserved;
-	MV_U16 modifyInfo[3];
-	MV_U32 reserved2;
+	MV_U32 hwCmd[3];
+	MV_U32 reserved;
 } PP2_TX_DESC;
 
 /* Bits of "command" field */
@@ -660,6 +667,72 @@ typedef struct pp2_tx_desc {
 #define PP2_TX_F_DESC_BIT			29
 #define PP2_TX_F_DESC_MASK			(1 << PP2_TX_F_DESC_BIT)
 
+/* Bits of "hwCmd[0]" field - offset 0x10 */
+#define PP2_TX_GEMPID_OFFS                      0
+#define PP2_TX_GEMPID_BITS                      12
+#define PP2_TX_GEMPID_ALL_MASK                  (((1 << PP2_TX_GEMPID_BITS) - 1) << PP2_TX_GEMPID_OFFS)
+#define PP2_TX_GEMPID_MASK(gpid)                (((gpid) & PP2_TX_GEMPID_ALL_MASK) << PP2_TX_GEMPID_OFFS)
+
+#define PP2_TX_COLOR_OFFS                       12
+#define PP2_TX_COLOR_ALL_MASK                   (0x3 << PP2_TX_COLOR_OFFS)
+#define PP2_TX_COLOR_GREEN                      0
+#define PP2_TX_COLOR_YELLOW                     1
+#define PP2_TX_COLOR_MASK(col)                  (((col) & PP2_TX_COLOR_ALL_MASK) << PP2_TX_COLOR_OFFS)
+
+#define PP2_TX_DSA_OFFS                         14
+#define PP2_TX_DSA_ALL_MASK                     (0x3 << PP2_TX_DSA_OFFS)
+#define PP2_TX_DSA_NONE                         0
+#define PP2_TX_DSA_TAG                          1
+#define PP2_TX_EDSA_TAG                         2
+#define PP2_TX_DSA_MASK(dsa)                    (((dsa) & PP2_TX_DSA_ALL_MASK) << PP2_TX_DSA_OFFS)
+
+#define PP2_TX_L4_CSUM_INIT_OFFS                16
+#define PP2_TX_L4_CSUM_INIT_MASK                (0xffff << PP2_TX_L4_CSUM_INIT_OFFS)
+
+/* Bits of "hwCmd[1]" field - offset 0x14 */
+
+/* bits 0..15 are reserved */
+#define PP2_TX_MOD_DSCP_OFFS                    16
+#define PP2_TX_MOD_DSCP_BITS                    6
+#define PP2_TX_MOD_DSCP_MASK                    (((1 << PP2_TX_MOD_DSCP_BITS) - 1) << PP2_TX_MOD_DSCP_OFFS)
+
+#define PP2_TX_MOD_PRIO_OFFS                    22
+#define PP2_TX_MOD_PRIO_BITS                    3
+#define PP2_TX_MOD_PRIO_MASK                    (((1 << PP2_TX_MOD_PRIO_BITS) - 1) << PP2_TX_MOD_PRIO_OFFS)
+
+#define PP2_TX_MOD_DSCP_EN_BIT                  25
+#define PP2_TX_MOD_DSCP_EN_MASK                 (1 << PP2_TX_MOD_DSCP_EN_BIT)
+
+#define PP2_TX_MOD_PRIO_EN_BIT                  26
+#define PP2_TX_MOD_PRIO_EN_MASK                 (1 << PP2_TX_MOD_PRIO_EN_BIT)
+
+#define PP2_TX_MOD_GEMPID_EN_BIT                27
+#define PP2_TX_MOD_GEMPID_EN_MASK               (1 << PP2_TX_MOD_GEMPID_EN_BIT)
+
+/* Bits of "hwCmd[2]" field - offset 0x18 */
+#define PP2_TX_PME_DPTR_OFFS                    0
+#define PP2_TX_PME_DPTR_ALL_MASK                (0xffff << PP2_TX_PME_DPTR_OFFS)
+#define PP2_TX_PME_DPTR_MASK(val)               (((val) & PP2_TX_PME_DPTR_ALL_MASK) << PP2_TX_PME_DPTR_OFFS)
+
+#define PP2_TX_PME_IPTR_OFFS                    16
+#define PP2_TX_PME_IPTR_ALL_MASK                (0xff << PP2_TX_PME_IPTR_OFFS)
+#define PP2_TX_PME_IPTR_MASK(val)               (((val) & PP2_TX_PME_IPTR_ALL_MASK) << PP2_TX_PME_IPTR_OFFS)
+
+/* Bit 24 - HWF_IDB is for HWF usage only */
+
+#define PP2_TX_GEM_OEM_BIT                      25
+#define PP2_TX_GEM_OEM_MASK                     (1 << PP2_TX_GEM_OEM_BIT)
+
+/* Bit 26 - ERROR_SUM is for HWF usage only */
+
+#define PP2_TX_PON_FEC_BIT                      27
+#define PP2_TX_PON_FEC_MASK                     (1 << PP2_TX_PON_FEC_BIT)
+
+#define PP2_TX_CPU_MAP_OFFS                     28
+#define PP2_TX_CPU_MAP_BITS                     4
+#define PP2_TX_CPU_MAP_MASK                     (((1 << PP2_TX_CPU_MAP_BITS) - 1) << PP2_TX_CPU_MAP_OFFS)
+
+
 /************************** Buffer Header defines ******************************/
 typedef struct pp2_buff_hdr {
 	MV_U32 nextBuffPhysAddr;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
index 04701c9..d0f5b44 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
@@ -61,8 +61,8 @@ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-#include "pp2/gbe/mvPp2Gbe.h"
 #include "mvEthGmacApi.h"
+#include "pp2/gbe/mvPp2Gbe.h"
 
 void mvEthPortEnable(int port)
 {
@@ -573,7 +573,6 @@ MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
 void mvEthMibCountersClear(int port)
 {
 	int i;
-	MV_U32 dummy;
 
 #if defined(CONFIG_MV_PON) && !defined(MV_PON_MIB_SUPPORT)
 	if (MV_PON_PORT(port))
@@ -582,7 +581,7 @@ void mvEthMibCountersClear(int port)
 
 	/* Perform dummy reads from MIB counters */
 	for (i = ETH_MIB_GOOD_OCTETS_RECEIVED_LOW; i < ETH_MIB_LATE_COLLISION; i += 4)
-		dummy = MV_REG_READ((ETH_MIB_COUNTERS_BASE(port) + i));
+		MV_REG_READ((ETH_MIB_COUNTERS_BASE(port) + i));
 }
 
 static void mvEthMibPrint(int port, MV_U32 offset, char *mib_name)
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
index f4c7108..69b3d45 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
@@ -102,6 +102,30 @@ typedef struct eth_link_status {
 
 } MV_ETH_PORT_STATUS;
 
+/***************************************************************************/
+/*                          Inline functions                               */
+/***************************************************************************/
+static INLINE void mvEthIsrSummaryMask(MV_VOID)
+{
+	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, 0);
+}
+
+static INLINE void mvEthIsrSummaryUnmask(MV_VOID)
+{
+	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, ETH_ISR_SUM_PORTS_MASK | ETH_ISR_SUM_PORT0_MASK |
+							ETH_ISR_SUM_PORT1_MASK | ETH_ISR_SUM_PORT2_MASK);
+}
+
+static INLINE MV_U32 mvEthIsrSummaryCauseGet(MV_VOID)
+{
+	return MV_REG_READ(ETH_ISR_SUM_CAUSE_REG);
+}
+
+static INLINE MV_U32 mvEthPortIsrCauseGet(int port)
+{
+	return MV_REG_READ(ETH_PORT_ISR_CAUSE_REG(port));
+}
+
 void mvEthPortEnable(int port);
 void mvEthPortDisable(int port);
 MV_BOOL mvEthPortIsLinkUp(int port);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
index 46a671d..4404d28 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
@@ -177,12 +177,56 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define ETH_TX_FLOW_CTRL_ACTIVE_MASK       (1 << ETH_TX_FLOW_CTRL_ACTIVE_BIT)
 /*-------------------------------------------------------------------------------*/
 
+#define ETH_PORT_ISR_CAUSE_REG(p)	(ETH_REG_BASE(p) + 0x20)
+
+#define ETH_PORT_ISR_SUM_BIT		0
+#define ETH_PORT_ISR_SUM_MASK		(1 << ETH_PORT_ISR_SUM_BIT)
+
+#define ETH_PORT_LINK_CHANGE_BIT	1
+#define ETH_PORT_LINK_CHANGE_MASK	(1 << ETH_PORT_LINK_CHANGE_BIT)
+
+#define ETH_PORT_ISR_MASK_REG(p)	(ETH_REG_BASE(p) + 0x24)
+
 /****************************************/
 /*        LMS Unit Registers       	*/
 /****************************************/
 #define ETH_PHY_ADDR_REG		(LMS_REG_BASE + 0x30)
 #define ETH_PHY_ADDR_OFFS(port)		(port * 5)
 #define ETH_PHY_ADDR_MASK(port)		(0x1F << ETH_PHY_ADDR_OFFS(port))
+/*-------------------------------------------------------------------------------*/
+
+#define ETH_ISR_SUM_CAUSE_REG		(LMS_REG_BASE + 0x10)
+#define ETH_ISR_SUM_LMS_BIT		0
+#define ETH_ISR_SUM_LMS_MASK		(1 << ETH_ISR_SUM_LMS_BIT)
+
+#define ETH_ISR_SUM_LMS0_BIT		1
+#define ETH_ISR_SUM_LMS0_MASK		(1 << ETH_ISR_SUM_LMS0_BIT)
+
+#define ETH_ISR_SUM_LMS1_BIT		2
+#define ETH_ISR_SUM_LMS1_MASK		(1 << ETH_ISR_SUM_LMS1_BIT)
+
+#define ETH_ISR_SUM_LMS2_BIT		3
+#define ETH_ISR_SUM_LMS2_MASK		(1 << ETH_ISR_SUM_LMS2_BIT)
+
+#define ETH_ISR_SUM_LMS3_BIT		4
+#define ETH_ISR_SUM_LMS3_MASK		(1 << ETH_ISR_SUM_LMS3_BIT)
+
+#define ETH_ISR_SUM_PORTS_BIT		16
+#define ETH_ISR_SUM_PORTS_MASK		(1 << ETH_ISR_SUM_PORTS_BIT)
+
+#define ETH_ISR_SUM_PORT0_BIT		17
+#define ETH_ISR_SUM_PORT0_MASK		(1 << ETH_ISR_SUM_PORT0_BIT)
+
+#define ETH_ISR_SUM_PORT1_BIT		18
+#define ETH_ISR_SUM_PORT1_MASK		(1 << ETH_ISR_SUM_PORT1_BIT)
+
+#define ETH_ISR_SUM_PORT2_BIT		19
+#define ETH_ISR_SUM_PORT2_MASK		(1 << ETH_ISR_SUM_PORT2_BIT)
+
+#define ETH_ISR_SUM_PORT_MASK(p)	(1 << (ETH_ISR_SUM_PORT0_BIT + p))
+
+#define ETH_ISR_SUM_MASK_REG		(LMS_REG_BASE + 0x220c)
+/*-------------------------------------------------------------------------------*/
 
 #define ETH_SMI_REG(port)		(LMS_REG_BASE + 0x54)
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
index 71f8583..881bd59 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
@@ -130,12 +130,12 @@ static void        mvPp2PlcrHwDumpTitle(void)
 	regVal = mvPp2RdReg(MV_PP2_PLCR_MIN_PKT_LEN_REG);
 	mvOsPrintf("min_pkt=%d bytes\n", (regVal & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK) >> MV_PP2_PLCR_MIN_PKT_LEN_OFFS);
 
-	mvOsPrintf("PLCR: enable period  unit   type  tokens  c_size  e_size  c_tokens  e_tokens\n");
+	mvOsPrintf("PLCR: enable period  unit   type  tokens  color  c_size  e_size  c_tokens  e_tokens\n");
 }
 
 static void        mvPp2PlcrHwDump(int plcr)
 {
-	int units, type, tokens;
+	int units, type, tokens, color;
 	MV_U32 regVal;
 
 	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
@@ -148,9 +148,11 @@ static void        mvPp2PlcrHwDump(int plcr)
 
 	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
 	units = regVal & MV_PP2_PLCR_TOKEN_UNIT_MASK;
+	color = regVal & MV_PP2_PLCR_COLOR_MODE_MASK;
 	type = (regVal & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_TYPE_OFFS;
 	tokens =  (regVal & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_VALUE_OFFS;
-	mvOsPrintf("   %5s  %2d   %5d", units ? "pkts" : "bytes", type, tokens);
+	mvOsPrintf("   %-5s  %2d   %5d", units ? "pkts" : "bytes", type, tokens);
+	mvOsPrintf("  %-5s", color ? "aware" : "blind");
 
 	regVal = mvPp2RdReg(MV_PP2_PLCR_BUCKET_SIZE_REG);
 	mvOsPrintf("    %04x    %04x",
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
index cbe854b..6bf6c2e 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
@@ -72,64 +72,66 @@ extern "C" {
 #define MV_PP2_PLCR_NUM		16
 
 /*********************************** RX Policer Registers *******************/
-#define MV_PP2_PLCR_ENABLE_REG				(MV_PP2_REG_BASE + 0x1300)
+#define MV_PP2_PLCR_ENABLE_REG                  (MV_PP2_REG_BASE + 0x1300)
 
-#define MV_PP2_PLCR_EN_OFFS					0
-#define MV_PP2_PLCR_EN_ALL_MASK				(((1 << MV_PP2_PLCR_NUM) - 1) << MV_PP2_PLCR_EN_OFFS)
-#define MV_PP2_PLCR_EN_MASK(plcr)			((1 << (plcr)) << MV_PP2_PLCR_EN_OFFS)
+#define MV_PP2_PLCR_EN_OFFS                     0
+#define MV_PP2_PLCR_EN_ALL_MASK                 (((1 << MV_PP2_PLCR_NUM) - 1) << MV_PP2_PLCR_EN_OFFS)
+#define MV_PP2_PLCR_EN_MASK(plcr)               ((1 << (plcr)) << MV_PP2_PLCR_EN_OFFS)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_BASE_PERIOD_REG			(MV_PP2_REG_BASE + 0x1304)
+#define MV_PP2_PLCR_BASE_PERIOD_REG             (MV_PP2_REG_BASE + 0x1304)
 
-#define MV_PP2_PLCR_BASE_PERIOD_OFFS		0
-#define MV_PP2_PLCR_BASE_PERIOD_BITS		16
-#define MV_PP2_PLCR_BASE_PERIOD_ALL_MASK	(((1 << MV_PP2_PLCR_BASE_PERIOD_BITS) - 1) << MV_PP2_PLCR_BASE_PERIOD_OFFS)
-#define MV_PP2_PLCR_BASE_PERIOD_MASK(p)		(((p) << MV_PP2_PLCR_BASE_PERIOD_OFFS) & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK)
+#define MV_PP2_PLCR_BASE_PERIOD_OFFS            0
+#define MV_PP2_PLCR_BASE_PERIOD_BITS            16
+#define MV_PP2_PLCR_BASE_PERIOD_ALL_MASK        (((1 << MV_PP2_PLCR_BASE_PERIOD_BITS) - 1) << MV_PP2_PLCR_BASE_PERIOD_OFFS)
+#define MV_PP2_PLCR_BASE_PERIOD_MASK(p)         (((p) << MV_PP2_PLCR_BASE_PERIOD_OFFS) & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK)
 
-#define MV_PP2_PLCR_ADD_TOKENS_EN_BIT		16
-#define MV_PP2_PLCR_ADD_TOKENS_EN_MASK      (1 << MV_PP2_PLCR_ADD_TOKENS_EN_BIT)
+#define MV_PP2_PLCR_ADD_TOKENS_EN_BIT           16
+#define MV_PP2_PLCR_ADD_TOKENS_EN_MASK          (1 << MV_PP2_PLCR_ADD_TOKENS_EN_BIT)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_TABLE_INDEX_REG			(MV_PP2_REG_BASE + 0x130c)
+#define MV_PP2_PLCR_TABLE_INDEX_REG		(MV_PP2_REG_BASE + 0x130c)
 #define MV_PP2_PLCR_COMMIT_TOKENS_REG		(MV_PP2_REG_BASE + 0x1310)
 #define MV_PP2_PLCR_EXCESS_TOKENS_REG		(MV_PP2_REG_BASE + 0x1314)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_BUCKET_SIZE_REG			(MV_PP2_REG_BASE + 0x1318)
+#define MV_PP2_PLCR_BUCKET_SIZE_REG		(MV_PP2_REG_BASE + 0x1318)
 
 #define MV_PP2_PLCR_COMMIT_SIZE_OFFS		0
 #define MV_PP2_PLCR_COMMIT_SIZE_BITS		16
 #define MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_COMMIT_SIZE_BITS) - 1) << MV_PP2_PLCR_COMMIT_SIZE_OFFS)
-#define MV_PP2_PLCR_COMMIT_SIZE_MASK(size)  (((size)	<< MV_PP2_PLCR_COMMIT_SIZE_OFFS) & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK)
+#define MV_PP2_PLCR_COMMIT_SIZE_MASK(size)      (((size) << MV_PP2_PLCR_COMMIT_SIZE_OFFS) & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK)
 
 #define MV_PP2_PLCR_EXCESS_SIZE_OFFS		16
 #define MV_PP2_PLCR_EXCESS_SIZE_BITS		16
 #define MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_EXCESS_SIZE_BITS) - 1) << MV_PP2_PLCR_EXCESS_SIZE_OFFS)
-#define MV_PP2_PLCR_EXCESS_SIZE_MASK(size)  (((size) << MV_PP2_PLCR_EXCESS_SIZE_OFFS) & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK)
+#define MV_PP2_PLCR_EXCESS_SIZE_MASK(size)      (((size) << MV_PP2_PLCR_EXCESS_SIZE_OFFS) & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_TOKEN_CFG_REG			(MV_PP2_REG_BASE + 0x131c)
+#define MV_PP2_PLCR_TOKEN_CFG_REG		(MV_PP2_REG_BASE + 0x131c)
 
 #define MV_PP2_PLCR_TOKEN_VALUE_OFFS		0
 #define MV_PP2_PLCR_TOKEN_VALUE_BITS		10
 #define MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK	(((1 << MV_PP2_PLCR_TOKEN_VALUE_BITS) - 1) << MV_PP2_PLCR_TOKEN_VALUE_OFFS)
 #define MV_PP2_PLCR_TOKEN_VALUE_MASK(val)	(((val) << MV_PP2_PLCR_TOKEN_VALUE_OFFS) & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK)
 
-#define MV_PP2_PLCR_TOKEN_TYPE_OFFS			12
-#define MV_PP2_PLCR_TOKEN_TYPE_BITS			3
+#define MV_PP2_PLCR_TOKEN_TYPE_OFFS		12
+#define MV_PP2_PLCR_TOKEN_TYPE_BITS		3
 #define MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK		(((1 << MV_PP2_PLCR_TOKEN_TYPE_BITS) - 1) << MV_PP2_PLCR_TOKEN_TYPE_OFFS)
 #define MV_PP2_PLCR_TOKEN_TYPE_MASK(type)	(((type) << MV_PP2_PLCR_TOKEN_TYPE_OFFS) & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK)
 
-#define MV_PP2_PLCR_TOKEN_UNIT_BIT			31
-#define MV_PP2_PLCR_TOKEN_UNIT_MASK			(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
+#define MV_PP2_PLCR_TOKEN_UNIT_BIT		31
+#define MV_PP2_PLCR_TOKEN_UNIT_MASK		(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
 #define MV_PP2_PLCR_TOKEN_UNIT_BYTES		(0 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
-#define MV_PP2_PLCR_TOKEN_UNIT_PKTS			(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
+#define MV_PP2_PLCR_TOKEN_UNIT_PKTS		(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
 
-#define MV_PP2_PLCR_COLOR_MODE_BIT			30
-#define MV_PP2_PLCR_COLOR_MODE_MASK			(1 << MV_PP2_PLCR_COLOR_MODE_BIT)
+#define MV_PP2_PLCR_COLOR_MODE_BIT		30
+#define MV_PP2_PLCR_COLOR_MODE_MASK		(1 << MV_PP2_PLCR_COLOR_MODE_BIT)
+#define MV_PP2_PLCR_COLOR_MODE_BLIND            (0 << MV_PP2_PLCR_COLOR_MODE_BIT)
+#define MV_PP2_PLCR_COLOR_MODE_AWARE            (1 << MV_PP2_PLCR_COLOR_MODE_BIT)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_MIN_PKT_LEN_REG			(MV_PP2_REG_BASE + 0x1320)
+#define MV_PP2_PLCR_MIN_PKT_LEN_REG		(MV_PP2_REG_BASE + 0x1320)
 
 #define MV_PP2_PLCR_MIN_PKT_LEN_OFFS		0
 #define MV_PP2_PLCR_MIN_PKT_LEN_BITS		8
@@ -137,16 +139,16 @@ extern "C" {
 #define MV_PP2_PLCR_MIN_PKT_LEN_MASK(len)	(((len) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS) & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_EDROP_EN_REG			(MV_PP2_REG_BASE + 0x1330)
+#define MV_PP2_PLCR_EDROP_EN_REG		(MV_PP2_REG_BASE + 0x1330)
 
-#define MV_PP2_PLCR_EDROP_EN_BIT			0
-#define MV_PP2_PLCR_EDROP_EN_MASK			(1 << MV_PP2_PLCR_EDROP_EN_BIT)
+#define MV_PP2_PLCR_EDROP_EN_BIT		0
+#define MV_PP2_PLCR_EDROP_EN_MASK		(1 << MV_PP2_PLCR_EDROP_EN_BIT)
 /*---------------------------------------------------------------------------------------------*/
 
 #define MV_PP2_PLCR_EDROP_THRESH_NUM		4
 
 #define MV_PP2_PLCR_EDROP_TR_OFFS(i)		((i % 2) ? 16 : 0)
-#define MV_PP2_PLCR_EDROP_TR_BITS			16
+#define MV_PP2_PLCR_EDROP_TR_BITS		16
 #define MV_PP2_PLCR_EDROP_TR_ALL_MASK(i)	(((1 << MV_PP2_PLCR_EDROP_TR_BITS) - 1) << MV_PP2_PLCR_EDROP_TR_OFFS(i))
 #define MV_PP2_PLCR_EDROP_TR_MASK(i, tr)	(((tr) << MV_PP2_PLCR_EDROP_TR_OFFS(i)) & MV_PP2_PLCR_EDROP_TR_ALL_MASK(i))
 
@@ -154,11 +156,11 @@ extern "C" {
 #define MV_PP2_PLCR_EDROP_HWF_TR_REG(i)		(MV_PP2_REG_BASE + 0x1350 + (((i) / 2) << 2))
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_EDROP_RXQ_REG			(MV_PP2_REG_BASE + 0x1348)
+#define MV_PP2_PLCR_EDROP_RXQ_REG		(MV_PP2_REG_BASE + 0x1348)
 #define MV_PP2_PLCR_EDROP_RXQ_TR_REG		(MV_PP2_REG_BASE + 0x134c)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_EDROP_TXQ_REG			(MV_PP2_REG_BASE + 0x1358)
+#define MV_PP2_PLCR_EDROP_TXQ_REG		(MV_PP2_REG_BASE + 0x1358)
 #define MV_PP2_PLCR_EDROP_TXQ_TR_REG		(MV_PP2_REG_BASE + 0x135c)
 /*---------------------------------------------------------------------------------------------*/
 
@@ -180,7 +182,6 @@ MV_STATUS   mvPp2PlcrHwHwfThreshSet(int idx, int threshold);
 MV_STATUS   mvPp2PlcrHwRxqThreshSet(int rxq, int idx);
 MV_STATUS   mvPp2PlcrHwTxqThreshSet(int txq, int idx);
 
-
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
index 2f2ab3f..66db45a 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
@@ -119,9 +119,20 @@ static int mvPrsDblVlanAiFreeGet(void)
 /******************************************************************************
  * Common utilities
  ******************************************************************************/
-/*
- * Helper: match ethertype
- */
+static bool mvPp2PrsEtypeEquals(MV_PP2_PRS_ENTRY *pe, int offset, unsigned short ethertype)
+{
+	unsigned char etype[MV_ETH_TYPE_LEN];
+
+	PRS_DBG("%s\n", __func__);
+	etype[0] =  (ethertype >> 8) & 0xFF;
+	etype[1] =  ethertype & 0xFF;
+
+	if (mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, offset, MV_ETH_TYPE_LEN, etype) == NOT_EQUALS)
+		return MV_FALSE;
+
+	return MV_TRUE;
+}
+
 static void mvPp2PrsMatchEtype(MV_PP2_PRS_ENTRY *pe, int offset, unsigned short ethertype)
 {
 	PRS_DBG("%s\n", __func__);
@@ -145,10 +156,58 @@ static void mvPp2PrsMatchMh(MV_PP2_PRS_ENTRY *pe, unsigned short mh)
  ******************************************************************************
  */
 
-static MV_PP2_PRS_ENTRY *mvPrsMacDaFind(unsigned char *da)
+static bool mvPrsMacRangeEquals(MV_PP2_PRS_ENTRY *pe, MV_U8* da, MV_U8* mask)
+{
+	int		index;
+	unsigned char 	tcamByte, tcamMask;
+
+	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+		if (tcamMask != mask[index])
+			return	MV_FALSE;
+
+		if ((tcamMask & tcamByte) != (da[index] & mask[index]))
+			return MV_FALSE;
+	}
+
+	return MV_TRUE;
+}
+
+static bool mvPrsMacRangeIntersec(MV_PP2_PRS_ENTRY *pe, MV_U8* da, MV_U8* mask)
+{
+	int		index;
+	unsigned char 	tcamByte, tcamMask, commonMask;
+
+	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+
+		commonMask = mask[index] & tcamMask;
+
+
+		if ((commonMask & tcamByte) != (commonMask & da[index]))
+			return MV_FALSE;
+	}
+	return MV_TRUE;
+}
+
+static bool mvPrsMacInRange(MV_PP2_PRS_ENTRY *pe, MV_U8* da, MV_U8* mask)
+{
+	int		index;
+	unsigned char 	tcamByte, tcamMask;
+
+	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+		if ((tcamByte & mask[index]) != (da[index] & mask[index]))
+			return MV_FALSE;
+	}
+
+	return MV_TRUE;
+}
+
+static MV_PP2_PRS_ENTRY *mvPrsMacDaRangeFind(int portMap, unsigned char *da, unsigned char *mask, int udfType)
 {
 	MV_PP2_PRS_ENTRY *pe;
-	int tid;
+	int tid, entryPmap;
 
 	pe = mvPp2PrsSwAlloc(PRS_LU_MAC);
 
@@ -157,25 +216,96 @@ static MV_PP2_PRS_ENTRY *mvPrsMacDaFind(unsigned char *da)
 		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_MAC))
 			continue;
 
+		if (mvPp2PrsShadowUdf(tid) != udfType)
+			continue;
+
 		pe->index = tid;
 		mvPp2PrsHwRead(pe);
-		if (mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, MV_ETH_MH_SIZE, MV_MAC_ADDR_SIZE, da) == EQUALS)
+
+		mvPp2PrsSwTcamPortMapGet(pe, &entryPmap);
+
+		if (mvPrsMacRangeEquals(pe, da, mask) && (entryPmap == portMap))
 			return pe;
 	}
 	mvPp2PrsSwFree(pe);
 	return NULL;
+
+}
+
+static MV_PP2_PRS_ENTRY *mvPrsMacDaFind(int port, unsigned char *da)
+{
+	unsigned char mask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
+	return mvPrsMacDaRangeFind((1 << port), da, mask, PRS_UDF_MAC_DEF);
+}
+
+static int mvPrsMacDaRangeAccept(int portMap, MV_U8 *da, MV_U8 *mask, unsigned int ri, unsigned int riMask, bool finish)
+{
+	int	tid, len;
+	MV_PP2_PRS_ENTRY *pe = NULL;
+
+	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
+	pe = mvPrsMacDaRangeFind(portMap, da, mask, PRS_UDF_MAC_RANGE);
+
+	if (pe == NULL) {
+		/* entry not exist */
+		/* find last simple mac entry*/
+		for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--)
+			if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) == PRS_LU_MAC) &&
+				(mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_DEF))
+					break;
+
+		/* Go through the all entires from first to last */
+		tid = mvPp2PrsTcamFirstFree(tid + 1, PE_LAST_FREE_TID);
+
+		/* Can't add - No free TCAM entries */
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			mvPp2PrsSwFree(pe);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_MAC);
+		pe->index = tid;
+		mvPp2PrsSwTcamPortMapSet(pe, portMap);
+		/* shift to ethertype */
+		mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+		/* set DA range */
+		len = MV_MAC_ADDR_SIZE;
+
+		while (len--)
+			mvPp2PrsSwTcamByteSet(pe, MV_ETH_MH_SIZE + len, da[len], mask[len]);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe->index, PRS_LU_MAC, "mac-range");
+		mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_MAC_RANGE);
+
+	}
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+	finish ? mvPp2PrsSwSramFlowidGenSet(pe) : mvPp2PrsSwSramFlowidGenClear(pe);
+
+	/* Write entry to TCAM */
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
 }
 
-/* Accept special MAC DA - 6 bytes */
+/* TODO: use mvPrsMacDaRangeAccept */
 int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 {
 	MV_PP2_PRS_ENTRY *pe = NULL;
-	unsigned int     len, ports;
+	unsigned int     len, ports, ri;
 	int              tid;
-	char             *name;
+	char name[PRS_TEXT_SIZE];
+
+	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
+	pe = mvPrsMacDaFind(port, da);
 
-	/* Scan TCAM and see if entry with this MAC DA already exist */
-	pe = mvPrsMacDaFind(da);
 	if (pe == NULL) {
 		/* No such entry */
 		if (!add) {
@@ -184,12 +314,19 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 		}
 		/* Create new TCAM entry */
 
+		/* find last range mac entry*/
+		for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++)
+			if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) == PRS_LU_MAC) &&
+				(mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE))
+					break;
+
 		/* Go through the all entires from first to last */
-		tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+		tid = mvPp2PrsTcamFirstFree(0, tid - 1);
 
 		/* Can't add - No free TCAM entries */
 		if (tid == MV_PRS_OUT_OF_RAGE) {
 			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			mvPp2PrsSwFree(pe);
 			return MV_ERROR;
 		}
 
@@ -205,12 +342,14 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 
 	if (ports == 0) {
 		if (add) {
+			mvPp2PrsSwFree(pe);
 			/* Internal error, port should be set in ports bitmap */
 			return MV_ERROR;
 		}
 		/* No ports - invalidate the entry */
 		mvPp2PrsHwInv(pe->index);
 		mvPp2PrsShadowClear(pe->index);
+		mvPp2PrsSwFree(pe);
 		return MV_OK;
 
 	}
@@ -225,18 +364,20 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 
 	/* Set result info bits */
 	if (MV_IS_BROADCAST_MAC(da)) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L2_BCAST, RI_L2_CAST_MASK);
-		name = "bcast";
-	/*TODO - remove mcast ,  handled in mvPrsMacAllMultiSet */
+		ri = RI_L2_BCAST | RI_MAC_ME_MASK;
+		mvOsSPrintf(name, "bcast-port-%d", port);
+
 	} else if (MV_IS_MULTICAST_MAC(da)) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L2_MCAST, RI_L2_CAST_MASK);
-		name = "mcast";
+		ri = RI_L2_MCAST | RI_MAC_ME_MASK;
+		mvOsSPrintf(name, "mcast-port-%d", port);
 	} else {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L2_UCAST, RI_L2_CAST_MASK);
-		name = "ucast";
+		ri = RI_L2_UCAST | RI_MAC_ME_MASK;
+		mvOsSPrintf(name, "ucast-port-%d", port);
 	}
 
-	mvPp2PrsSwSramRiSetBit(pe, RI_MAC_ME_BIT);
+	/*mvPp2PrsSwSramRiSetBit(pe, RI_MAC_ME_BIT);*/
+	mvPp2PrsSwSramRiUpdate(pe, ri, RI_L2_CAST_MASK | RI_MAC_ME_MASK);
+	mvPp2PrsShadowRiSet(pe->index, ri, RI_L2_CAST_MASK | RI_MAC_ME_MASK);
 
 	/* shift to ethertype */
 	mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
@@ -246,11 +387,146 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_MAC, name);
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_MAC_DEF);
 
 	mvPp2PrsSwFree(pe);
 	return MV_OK;
 }
 
+
+static int mvPrsMacDaRangeValid(unsigned int portMap, MV_U8 *da, MV_U8 *mask)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int entryPmap;
+	int tid;
+
+	for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_MAC) ||
+			(mvPp2PrsShadowUdf(tid) != PRS_UDF_MAC_RANGE))
+				continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		if ((mvPrsMacRangeIntersec(&pe, da, mask)) & !mvPrsMacRangeEquals(&pe, da, mask)) {
+			if (entryPmap & portMap) {
+				mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
+				mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n",
+					__func__, entryPmap & portMap, tid);
+				return MV_ERROR;
+			}
+
+		} else if (mvPrsMacRangeEquals(&pe, da, mask) && (entryPmap != portMap) && (entryPmap & portMap)) {
+			mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
+			mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n", __func__, entryPmap & portMap, tid);
+
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+
+int mvPrsMacDaRangeSet(unsigned int portMap, MV_U8 *da, MV_U8 *mask, unsigned int ri, unsigned int riMask, bool finish)
+{
+	MV_PP2_PRS_ENTRY pe;
+	int tid;
+	unsigned int entryPmap;
+	bool done = MV_FALSE;
+
+	/* step 1 - validation, ranges intersections are forbidden*/
+	if (mvPrsMacDaRangeValid(portMap, da, mask))
+		return MV_ERROR;
+
+	/* step 2 - update TCAM */
+	for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || !(mvPp2PrsShadowLu(tid) == PRS_LU_MAC))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		if ((mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE) &&
+			mvPrsMacRangeEquals(&pe, da, mask) && (entryPmap == portMap)) {
+				/* portMap and range are equals to TCAM entry*/
+				done = MV_TRUE;
+				mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+				finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
+				mvPp2PrsHwWrite(&pe);
+				continue;
+		}
+
+		/* PRS_UDF_MAC_DEF */
+		if (mvPrsMacInRange(&pe, da, mask) && (entryPmap & portMap)) {
+			mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+			finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsHwWrite(&pe);
+		}
+	}
+	/* step 3 - Add new range entry */
+	if (!done)
+		return mvPrsMacDaRangeAccept(portMap, da, mask, ri, riMask, finish);
+
+	return MV_OK;
+
+}
+
+int mvPrsMacDaRangeDel(unsigned int portMap, MV_U8 *da, MV_U8 *mask)
+{
+	MV_PP2_PRS_ENTRY pe;
+	int tid;
+	unsigned int entryPmap;
+	bool found = MV_FALSE;
+
+	for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || !(mvPp2PrsShadowLu(tid) == PRS_LU_MAC))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		/* differents ports */
+		if (!(entryPmap & portMap))
+			continue;
+
+		if ((mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE) && (mvPrsMacRangeEquals(&pe, da, mask))) {
+
+			found = MV_TRUE;
+			entryPmap &= ~portMap;
+
+			if (!entryPmap) {
+				/* delete entry */
+				mvPp2PrsHwInv(pe.index);
+				mvPp2PrsShadowClear(pe.index);
+				continue;
+			}
+
+			/* update port map */
+			mvPp2PrsSwTcamPortMapSet(&pe, entryPmap);
+			mvPp2PrsHwWrite(&pe);
+			continue;
+		}
+
+		/* PRS_UDF_MAC_RANGE */
+		if (!found) {
+			/* range entry not exist */
+			mvOsPrintf("%s: Error, entry not found\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* range entry allready found, now fix all relevant default entries*/
+		if (mvPrsMacInRange(&pe, da, mask)) {
+			mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsSwSramRiSet(&pe, mvPp2PrsShadowRi(tid), mvPp2PrsShadowRiMask(tid));
+			mvPp2PrsHwWrite(&pe);
+		}
+	}
+	return MV_OK;
+}
+
 /* Drop special MAC DA - 6 bytes */
 int mvPrsMacDaDrop(int port, unsigned char *da, int add)
 {
@@ -376,7 +652,7 @@ int mvPrsMacAllMultiSet(int port, int add)
 	return MV_OK;
 }
 
-int mvPrsMhRxSpecialSet(int port, int add, unsigned short mh)
+int mvPrsMhRxSpecialSet(int port, unsigned short mh, int add)
 {
 	MV_PP2_PRS_ENTRY pe;
 
@@ -704,13 +980,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 		/* remove port from DSA entries */
 		mvPp2PrsDsaTagSet(port, 0, TAGGED, DSA);
 		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, DSA);
-/*
-		 remove port from all EtherType DSA/EDSA entries
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, DSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, DSA);
-*/
+
 		break;
 
 	case MV_PP2_DSA:
@@ -721,13 +991,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 		/* remove port from EDSA entries */
 		mvPp2PrsDsaTagSet(port, 0, TAGGED, EDSA);
 		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, EDSA);
-/*
-		remove port from all EtherType DSA/EDSA entries
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, DSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, DSA);
-*/
+
 		break;
 
 	case MV_PP2_MH:
@@ -738,13 +1002,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, DSA);
 		mvPp2PrsDsaTagSet(port, 0, TAGGED, EDSA);
 		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, EDSA);
-/*
-		Add port from all EtherType DSA/EDSA entries
-		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, EDSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, DSA);
-		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, DSA);
-*/
+
 		break;
 
 	default:
@@ -763,6 +1021,23 @@ int mvPp2PrsTagModeSet(int port, int type)
  ******************************************************************************
  */
 
+char *mvPrsVlanInfoStr(unsigned int vlan_info)
+{
+	switch (vlan_info) {
+	case RI_VLAN_NONE:
+		return "None";
+	case RI_VLAN_SINGLE:
+		return "Single";
+	case RI_VLAN_DOUBLE:
+		return "Double";
+	case RI_VLAN_TRIPLE:
+		return "Triple";
+	default:
+		return "Unknown";
+	}
+	return NULL;
+}
+
 static MV_PP2_PRS_ENTRY *mvPrsVlanFind(unsigned short tpid, int ai)
 {
 	MV_PP2_PRS_ENTRY *pe;
@@ -1051,7 +1326,7 @@ int mvPp2PrsDoubleVlanAdd(unsigned short tpid1, unsigned short tpid2, unsigned i
 int mvPp2PrsDoubleVlanDel(unsigned short tpid1, unsigned short tpid2)
 {
 	MV_PP2_PRS_ENTRY *pe = NULL;
-	int ai, enable;
+	unsigned int ai, enable;
 
 
 	pe = mvPrsDoubleVlanFind(tpid1, tpid2);
@@ -1098,7 +1373,7 @@ int mvPp2PrsDoubleVlan(unsigned short tpid1, unsigned short tpid2, unsigned int
 int mvPp2PrsTripleVlan(unsigned short tpid1, unsigned short tpid2, unsigned short tpid3, unsigned int portBmp, int add)
 {
 	MV_PP2_PRS_ENTRY *pe;
-	int ai, aiEnable;
+	unsigned int ai, aiEnable;
 	int status;
 
 	pe = mvPrsDoubleVlanFind(tpid1, tpid2);
@@ -1209,7 +1484,175 @@ static int mvPp2PrsVlanInit(void)
  *
  ******************************************************************************
  */
+/*TODO USE this function for all def etypres creation */
+static int mvPrsEthTypeCreate(int portMap, unsigned short eth_type, unsigned int ri, unsigned int riMask)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(PE_FIRST_FREE_TID, PE_LAST_FREE_TID);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, eth_type);
+
+	mvPp2PrsSwSramRiSet(pe, ri, riMask);
+	mvPp2PrsSwTcamPortMapSet(pe, portMap);
+	/* Continue - set next lookup */
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	mvPp2PrsSwSramFlowidGenSet(pe);
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-user-define");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_USER);
+	mvPp2PrsShadowRiSet(pe->index, ri, riMask);
 
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+static int mvPrsEthTypeValid(unsigned int portMap, unsigned short ethertype)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int entryPmap;
+	int tid;
+
+	for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_L2))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+
+		if (!mvPp2PrsEtypeEquals(&pe, 0, ethertype))
+			continue;
+
+		/* in default entries portmask must be 0xff */
+		if ((mvPp2PrsShadowUdf(tid) == PRS_UDF_L2_DEF) & (portMap != PORT_MASK)) {
+			mvOsPrintf("%s: operation not supported.\n", __func__);
+			mvOsPrintf("%s: ports map must be 0xFF for default ether type\n", __func__);
+			return MV_ERROR;
+
+		} else {
+
+			/* port maps cannot intersection in User entries*/
+			/* PRS_UDF_L2_USER */
+			mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+			if ((portMap & entryPmap) && (portMap != entryPmap)) {
+				mvOsPrintf("%s: operation not supported\n", __func__);
+				mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n", __func__, entryPmap & portMap, tid);
+				return MV_ERROR;
+			}
+		}
+	}
+	return MV_OK;
+}
+
+int mvPrsEthTypeSet(int portMap, unsigned short ethertype, unsigned int ri, unsigned int riMask, bool finish)
+{
+	MV_PP2_PRS_ENTRY pe;
+	int tid;
+	unsigned int  entryPmap;
+	bool done = MV_FALSE;
+
+	/* step 1 - validation */
+	if (mvPrsEthTypeValid(portMap, ethertype))
+		return MV_ERROR;
+
+
+	/* step 2 - update TCAM */
+	for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++) {
+		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_L2))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+
+		if (!mvPp2PrsEtypeEquals(&pe, 0, ethertype))
+			continue;
+
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		if (entryPmap != portMap)
+			continue;
+
+		done = MV_TRUE;
+		mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+
+		if ((mvPp2PrsShadowUdf(tid) == PRS_UDF_L2_USER) || finish)
+			mvPp2PrsSwSramFlowidGenSet(&pe);
+
+		mvPp2PrsHwWrite(&pe);
+	}
+	/* step 3 - Add new ethertype entry */
+	if (!done)
+		return mvPrsEthTypeCreate(portMap, ethertype, ri, riMask);
+
+	return MV_OK;
+}
+
+int mvPrsEthTypeDel(int portMap, unsigned short ethertype)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int entryPmap;
+	int tid;
+
+	for (tid = PE_FIRST_FREE_TID; tid <= PE_LAST_FREE_TID; tid++) {
+
+		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_L2))
+			continue;
+
+		/* EtherType entry */
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+
+		if (!mvPp2PrsEtypeEquals(&pe, 0, ethertype))
+			continue;
+
+		if (mvPp2PrsShadowUdf(tid) == PRS_UDF_L2_DEF) {
+			if (portMap != PORT_MASK) {
+				mvOsPrintf("%s: ports map must be 0xFF for default ether type\n", __func__);
+				return MV_ERROR;
+			}
+
+			mvPp2PrsSwSramRiSet(&pe, mvPp2PrsShadowRi(tid), mvPp2PrsShadowRiMask(tid));
+
+			if (!mvPp2PrsShadowFin(tid))
+				mvPp2PrsSwSramFlowidGenClear(&pe);
+
+			mvPp2PrsHwWrite(&pe);
+
+			continue;
+		}
+
+		/*PRS_UDF_L2_USER */
+
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+		/*mask ports in user entry */
+		entryPmap &= ~portMap;
+
+		if (entryPmap == 0) {
+			mvPp2PrsHwInv(tid);
+			mvPp2PrsShadowClear(tid);
+			continue;
+		}
+
+		mvPp2PrsSwTcamPortMapSet(&pe, entryPmap);
+		mvPp2PrsHwWrite(&pe);
+	}
+	return MV_OK;
+}
 
 static int mvPp2PrsEtypePppoe(void)
 {
@@ -1240,6 +1683,9 @@ static int mvPp2PrsEtypePppoe(void)
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-PPPoE");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowRiSet(pe->index, RI_PPPOE_MASK, RI_PPPOE_MASK);
+	mvPp2PrsShadowFinSet(pe->index, MV_FALSE);
 	mvPp2PrsSwFree(pe);
 
 	return MV_OK;
@@ -1283,6 +1729,9 @@ static int mvPp2PrsEtypeIp4(void)
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv4");
+	mvPp2PrsShadowFinSet(pe->index, MV_FALSE);
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowRiSet(pe->index, RI_L3_IP4, RI_L3_PROTO_MASK);
 	mvPp2PrsSwFree(pe);
 
 	/* IPv4 with options */
@@ -1313,6 +1762,9 @@ static int mvPp2PrsEtypeIp4(void)
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv4-opt");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowFinSet(pe->index, MV_FALSE);
+	mvPp2PrsShadowRiSet(pe->index, RI_L3_IP4_OPT, RI_L3_PROTO_MASK);
 
 	mvPp2PrsSwFree(pe);
 
@@ -1352,6 +1804,9 @@ static int mvPp2PrsEtypeArp(void)
 	mvPp2PrsHwWrite(pe);
 
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-arp");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowFinSet(pe->index, MV_TRUE);
+	mvPp2PrsShadowRiSet(pe->index, RI_L3_ARP, RI_L3_PROTO_MASK);
 
 	mvPp2PrsSwFree(pe);
 
@@ -1395,6 +1850,9 @@ static int mvPp2PrsEtypeIp6(void)
 	mvPp2PrsHwWrite(pe);
 
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv6");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowFinSet(pe->index, MV_FALSE);
+	mvPp2PrsShadowRiSet(pe->index, RI_L3_IP6, RI_L3_PROTO_MASK);
 
 	mvPp2PrsSwFree(pe);
 
@@ -1423,6 +1881,9 @@ static int mvPp2PrsEtypeUn(void)
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-unknown");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowFinSet(pe->index, MV_TRUE);
+	mvPp2PrsShadowRiSet(pe->index, RI_L3_UN, RI_L3_PROTO_MASK);
 
 	mvPp2PrsSwFree(pe);
 
@@ -1872,7 +2333,8 @@ static int mvPp2PrsIp6Init(void)
 static MV_PP2_PRS_ENTRY *mvPrsFlowFind(int flow)
 {
 	MV_PP2_PRS_ENTRY *pe;
-	int tid, bits, enable;
+	int tid;
+	unsigned int bits, enable;
 
 	pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
 
@@ -2002,9 +2464,7 @@ int mvPrsDefaultInit(void)
 
 	/* Always start from lookup = 0 */
 	for (port = 0; port < MV_PP2_MAX_PORTS; port++)
-		mvPp2PrsHwPortInit(port,
-					PRS_LU_MAC/*first lu id*/,
-					MV_PP2_PRS_PORT_LU_MAX, 0);
+		mvPp2PrsHwPortInit(port, PRS_LU_MAC, MV_PP2_PRS_PORT_LU_MAX, 0);
 
 	rc = mvPp2PrsMacInit();
 	if (rc)
@@ -2014,11 +2474,11 @@ int mvPrsDefaultInit(void)
 	if (rc)
 		return rc;
 
-	rc = mvPp2PrsVlanInit();
+	rc = mvPp2PrsEtypeInit();
 	if (rc)
 		return rc;
 
-	rc = mvPp2PrsEtypeInit();
+	rc = mvPp2PrsVlanInit();
 	if (rc)
 		return rc;
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
index c77bf32..d546d1e 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
@@ -89,6 +89,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define	DSA_ETHER_TYPE		0xDADA/*TODO set to default DSA ether type*/
 
 
+/* MAC entries , shadow udf */
+enum prs_udf {
+	PRS_UDF_MAC_DEF,
+	PRS_UDF_MAC_RANGE,
+	PRS_UDF_L2_DEF,
+	PRS_UDF_L2_DEF_COPY,
+	PRS_UDF_L2_USER,
+};
 
 /* LOOKUP ID */
 enum prs_lookup {
@@ -102,8 +110,9 @@ enum prs_lookup {
 	PRS_LU_FLOWS,
 	PRS_LU_LAST,
 };
-/* Tcam entries ID */
 
+
+/* Tcam entries ID */
 #define	PE_DROP_ALL					0
 #define	PE_RX_SPECIAL					1
 #define PE_FIRST_FREE_TID				2
@@ -132,7 +141,6 @@ enum prs_lookup {
 #define PE_MAC_PROMISCOUS   	(MV_PP2_PRS_TCAM_SIZE - 2) /* promiscous mode */
 #define PE_MAC_NON_PROMISCOUS   (MV_PP2_PRS_TCAM_SIZE - 1) /* non-promiscous mode */
 
-
 /*
  * Pre-defined FlowId assigment
 */
@@ -145,8 +153,10 @@ enum prs_lookup {
 int mvPrsDefFlow(int port);
 int mvPrsDefaultInit(void);
 int mvPrsMacDaAccept(int port, unsigned char *da, int add);
+int mvPrsMacDaRangeSet(unsigned portBmp, MV_U8 *da, MV_U8 *mask, unsigned int ri, unsigned int riMask, bool finish);
+int mvPrsMacDaRangeDel(unsigned portBmp, MV_U8 *da, MV_U8 *mask);
 int mvPrsMacDropAllSet(int port, int add);
-int mvPrsMhRxSpecialSet(int port, int add, unsigned short mh);
+int mvPrsMhRxSpecialSet(int port, unsigned short mh, int add);
 int mvPrsMacPromiscousSet(int port, int add);
 int mvPrsMacAllMultiSet(int port, int add);
 int mvPrsDebugBasicInit(void);
@@ -154,9 +164,12 @@ int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask,
 int mvPp2PrsTagModeSet(int port, int type);
 int mvPp2PrsEtypeDsaModeSet(int port, int extand);
 int mvPp2PrsEtypeDsaSet(unsigned int eType);
+int mvPrsEthTypeSet(int portMap, unsigned short ethertype, unsigned int ri, unsigned int riMask, bool finish);
+int mvPrsEthTypeDel(int portMap, unsigned short eth_type);
 int mvPp2PrsTripleVlan(unsigned short tpid1, unsigned short tpid2, unsigned short tpid3, unsigned int portBmp, int add);
 int mvPp2PrsDoubleVlan(unsigned short tpid1, unsigned short tpid2, unsigned int portBmp, int add);
 int mvPp2PrsSingleVlan(unsigned short tpid, unsigned int portBmp, int add);
+char *mvPrsVlanInfoStr(unsigned int vlan_info);
 /*
 int mvPrsMacDaDrop(int port, unsigned char *da, int add);
 */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
index 1098f31..1b29a49 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
@@ -87,13 +87,52 @@ int mvPp2PrsShadowLu(int index)
 	return mvPrsShadowTbl[index].lu;
 }
 
+int mvPp2PrsShadowUdf(int index)
+{
+	return mvPrsShadowTbl[index].udf;
+}
+unsigned int mvPp2PrsShadowRi(int index)
+{
+	return mvPrsShadowTbl[index].ri;
+}
+
+unsigned int mvPp2PrsShadowRiMask(int index)
+{
+	return mvPrsShadowTbl[index].riMask;
+}
+
+void mvPp2PrsShadowUdfSet(int index, int udf)
+{
+	mvPrsShadowTbl[index].udf = udf;
+}
+
 void mvPp2PrsShadowSet(int index, int lu, char *text)
 {
-	strncpy(mvPrsShadowTbl[index].text, text, PRS_TEXT_SIZE);
+	strncpy((char *)mvPrsShadowTbl[index].text, text, PRS_TEXT_SIZE);
 	mvPrsShadowTbl[index].text[PRS_TEXT_SIZE - 1] = 0;
 	mvPrsShadowTbl[index].valid = MV_TRUE;
 	mvPrsShadowTbl[index].lu = lu;
 }
+void mvPp2PrsShadowLuSet(int index, int lu)
+{
+	mvPrsShadowTbl[index].lu = lu;
+}
+
+void mvPp2PrsShadowRiSet(int index, unsigned int ri, unsigned int riMask)
+{
+	mvPrsShadowTbl[index].riMask = riMask;
+	mvPrsShadowTbl[index].ri = ri;
+}
+
+void mvPp2PrsShadowFinSet(int index, bool finish)
+{
+	mvPrsShadowTbl[index].finish = finish;
+}
+
+bool mvPp2PrsShadowFin(int index)
+{
+	return mvPrsShadowTbl[index].finish;
+}
 
 void mvPp2PrsShadowClear(int index)
 {
@@ -651,6 +690,19 @@ int mvPp2PrsSwTcamPortSet(MV_PP2_PRS_ENTRY *pe, unsigned int port, int add)
 	return MV_OK;
 }
 
+int mvPp2PrsSwTcamPortGet(MV_PP2_PRS_ENTRY *pe, unsigned int port, bool *status)
+{
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(port, 7);/*TODO define max port val*/
+
+	if (~(pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)]) & (1 << port))
+		*status = MV_TRUE;
+	else
+		*status = MV_FALSE;
+
+	return MV_OK;
+}
+
 int mvPp2PrsSwTcamPortMapSet(MV_PP2_PRS_ENTRY *pe, unsigned int ports)
 {
 	PTR_VALIDATE(pe);
@@ -726,6 +778,14 @@ int mvPp2PrsSwSramRiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit)
 /* set RI and RI_UPDATE */
 int mvPp2PrsSwSramRiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable)
 {
+/* ALTERNATIVE WAY:
+   find the bist that set in defRiMask and clear in riMask
+   maskDiff = defRiMask & (defRiMask ^ riMask);
+   update 1's: ri |= (defRi & maskDiff);
+   update 0's: ri &= ~(maskDiff & (~defRi));
+   update mask: riMask |= defRiMask;
+*/
+
 	unsigned int i;
 
 	PTR_VALIDATE(pe);
@@ -754,10 +814,19 @@ int mvPp2PrsSwSramRiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *
 	return MV_OK;
 }
 
+int mvPp2PrsSwSramRiSet(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable)
+{
+	PTR_VALIDATE(pe);
+
+	pe->sram.word[SRAM_RI_OFFS/32] = bits;
+	pe->sram.word[SRAM_RI_CTRL_OFFS/32] = enable;
+	return MV_OK;
+}
+
 static int mvPp2PrsSwSramRiDump(MV_PP2_PRS_ENTRY *pe)
 {
-	int i, data, mask;
-	int off = 0, bitsOffs = 0;
+	unsigned int data, mask;
+	int i, off = 0, bitsOffs = 0;
 	char bits[100];
 
 	PTR_VALIDATE(pe);
@@ -847,7 +916,8 @@ int mvPp2PrsSwSramAiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *
 
 static int mvPp2PrsSwSramAiDump(MV_PP2_PRS_ENTRY *pe)
 {
-	int i, data, mask, bitsOffs = 0;
+	int i, bitsOffs = 0;
+	unsigned int data, mask;
 	char bits[30];
 
 	PTR_VALIDATE(pe);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
index c55015c..ec11e20 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
@@ -285,7 +285,8 @@ reg 5 --> reg 0
 #define RI_CPU_CODE_OFFS           			4 /* bits 4 - 6 */
 #define RI_CPU_CODE_BITS				3
 #define RI_CPU_CODE_MASK				(((1 << RI_CPU_CODE_BITS) - 1) << RI_CPU_CODE_OFFS)
-#define RI_CPU_CODE_RX_SPEC				(1 << RI_CPU_CODE_OFFS)
+#define RI_CPU_CODE_RX_SPEC_VAL				1
+#define RI_CPU_CODE_RX_SPEC				(RI_CPU_CODE_RX_SPEC_VAL << RI_CPU_CODE_OFFS)
 
 /* bits 7 - 8 */
 #define RI_L2_VER_OFFS					7
@@ -396,9 +397,22 @@ typedef struct {
 	int             valid;
 	int		lu;
 	unsigned char   text[PRS_TEXT_SIZE];
+	int		udf;
+	unsigned	ri;
+	unsigned	riMask;
+	bool		finish;
 } PRS_SHADOW_ENTRY;
 
+
 void mvPp2PrsShadowSet(int index, int lu, char *text);
+void mvPp2PrsShadowLuSet(int index, int lu);
+int mvPp2PrsShadowUdf(int index);
+void mvPp2PrsShadowUdfSet(int index, int udf);
+unsigned int mvPp2PrsShadowRi(int index);
+unsigned int mvPp2PrsShadowRiMask(int index);
+void mvPp2PrsShadowRiSet(int index, unsigned int ri, unsigned int riMask);
+void mvPp2PrsShadowFinSet(int index, bool finish); /* set bit 111 (GEN_BIT) in SRAM */
+bool mvPp2PrsShadowFin(int index);
 void mvPp2PrsShadowClear(int index);
 void mvPp2PrsShadowClearAll(void);
 int mvPp2PrsShadowLu(int index);
@@ -634,7 +648,14 @@ int mvPp2PrsSwTcamAiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
  * tcam AI[bit] = 0 , tcam mask AI[bit] = 1
 */
 int mvPp2PrsSwTcamAiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
+/*
+ * mvPp2PrsSwTcamPortGet - return tcam port status in prs sw entry.
+ * @pe: sw prs entry
+ * @port: single port
+ * @status: 1 - port bit is set, 0 - port bit is not set
+*/
 
+int mvPp2PrsSwTcamPortGet(MV_PP2_PRS_ENTRY *pe, unsigned int port, bool *status);
 /*
  * mvPp2PrsSwTcamPortSet - set tcam port map in prs sw entry.
  * @pe: sw prs entry
@@ -699,7 +720,14 @@ int mvPp2PrsSwSramRiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit);
  * sram RI_EN[i] <--1 only if enable[i] is set.
  */
 int mvPp2PrsSwSramRiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable);
+/*
+ * mvPp2PrsSwSramRiSet - set sram result info bits in prs sw entry.
+ * @pe: sw prs entry
+ * @bits: bits to set
+ * @enable: bits mask
+  */
 
+int mvPp2PrsSwSramRiSet(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable);
 /*
  * mvPp2PrsSwSramRiGet - get sram result info from prs sw entry.
  * @pe: sw prs entry
diff --git a/include/linux/mv_switch.h b/include/linux/mv_switch.h
new file mode 100644
index 0000000..f0c9a84
--- /dev/null
+++ b/include/linux/mv_switch.h
@@ -0,0 +1,93 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+/*  mv_switch.h */
+
+#ifndef LINUX_MV_SWITCH_H
+#define LINUX_MV_SWITCH_H
+
+#include "mv802_3.h"
+
+#define MV_SWITCH_SOHO_NAME	"mv_switch"
+
+struct mv_switch_pdata {
+
+	int index;
+	int phy_addr;
+	int gbe_port;
+	int switch_cpu_port;
+	MV_TAG_TYPE tag_mode;
+        MV_SWITCH_PRESET_TYPE preset;
+	int vid;
+	int port_mask;
+	int connected_port_mask;
+	int mtu;
+	int smi_scan_mode;
+	int qsgmii_module;
+	int gephy_on_port;
+	int rgmiia_on_port;
+	int switch_irq;
+};
+
+
+#endif  /* LINUX_MV_SWITCH_H */
-- 
1.7.5.4

