From f0f28637cf05ef9c8f451b06dc5b0636f04eed1d Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Thu, 22 May 2014 16:52:54 +0300
Subject: [PATCH 1697/1825] prestera: msys: pci connected switches initial
 support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 57ea487c4bf76f5cdc220a3abd74d3f640cce2ec

This commit extends existing prestera driver to support for the
switches connected via PCIe.
It's operation sequence is following:
- use standard Linux PCI API (e.g. pci_register_driver)
- identifies vendor/device ID
- get endpoints INTER_REGS (BAR0)
- reconfigure BARs in order to get below layout:
  - BAR1: resize to 64MB(for Switch)
  - BAR2: resize to 1MB(for DFX)
- reassign and map all BARs after changing layout
- configure PCIe BARs to have access to different device
  resources (reconfigure PCIe decoding windows):
  - BAR1-> Switch
  - BAR2-> DFX
- add device to ppdevs table
- configure switch DMA
- initialise char device (run prestera_init() from  mv_prestera_common if
  char device not initialised)

Changes in existing code:
- create new sysmap for AXP-AMC - extend PCI0 memory space to 128MB (1MB
  for INTER_REGS, 64MB for switch and 1MB for DFX - must be power of 2)
- change major nr of prestera char device to 50 (254 already used by rtc)
- fix offset of PP window access control - PP_WIN_CTRL_AP
- in order to feature multi-switch support, split existing driver into
  two parts:
  mv_prestera_common and (mv_prestera_pltfm + mv_prestera_pci)

Change-Id: Ie73297fe2d8f531ec4777d5ac53f84f54ed77243
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8179
Tested-by: Star_Automation <star@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8417
Reviewed-by: Tawfik Bayouk <tawfik@marvell.com>
Tested-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armadaxp/Makefile                    |    1 +
 arch/arm/mach-armadaxp/config/mvRules.mk           |    6 +-
 arch/arm/mach-armadaxp/include/mach/armadaxp.h     |   33 ++
 arch/arm/mach-armadaxp/sysmap.c                    |   53 +++
 arch/arm/plat-armada/Kconfig                       |   11 +
 .../mv_drivers_lsp/mv_prestera/Makefile            |    4 +-
 .../mv_drivers_lsp/mv_prestera/mv_prestera.c       |  161 ++++----
 .../mv_drivers_lsp/mv_prestera/mv_prestera.h       |   12 +-
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pci.c   |  493 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pci.h   |   91 ++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c |  193 ++++++++
 .../mv_drivers_lsp/mv_prestera/mv_pss_api.c        |    7 +
 12 files changed, 980 insertions(+), 85 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c

diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index f9a744d..2c7b97b 100755
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -112,6 +112,7 @@ obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
 obj-y                                   += $(LSP_MUX_DIR)/
 obj-$(CONFIG_SENSORS_ARMADA)		+= hwmon.o
+obj-$(CONFIG_MV_INCLUDE_PRESTERA_PCI) 	+= $(PLAT_DRIVERS)/mv_prestera/
 # The rest of the drivers are compiled through the driver dir directly.
 
 
diff --git a/arch/arm/mach-armadaxp/config/mvRules.mk b/arch/arm/mach-armadaxp/config/mvRules.mk
index 0b607c7..a6db071 100644
--- a/arch/arm/mach-armadaxp/config/mvRules.mk
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -102,6 +102,9 @@ LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
 LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
 LSP_IPC_DIR       = $(PLAT_DRIVERS)/mv_ipc/linux_amp
 
+ifeq ($(CONFIG_MV_INCLUDE_PRESTERA_PCI),y)
+LSP_PRESTERA_DIR  = $(PLAT_DRIVERS)/mv_prestera
+endif
 
 # Environment components
 AXP_FAM_DIR	= armada_xp_family
@@ -131,7 +134,8 @@ LSP_PATH        = -I$(LSP_PATH_I)
 CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
 HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
 DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
-		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR)
+		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR) \
+		-I$(PLAT_PATH_I)/$(LSP_PRESTERA_DIR)
 
 EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(AXP_FAM_PATH) \
                   $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/mach-armadaxp/include/mach/armadaxp.h b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
index 0f57583..276cd8a 100755
--- a/arch/arm/mach-armadaxp/include/mach/armadaxp.h
+++ b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
@@ -172,6 +172,7 @@
  * system peripherals.
  */
 
+#ifndef CONFIG_MACH_ARMADA_XP_AMC
 /*
  * PHYS: 0xF8000000 to 0xFFEFFFFF
  * VIRT: @runtime
@@ -200,6 +201,7 @@
 #define PEX8_MEM_SIZE			_2M
 #define PEX9_MEM_PHYS_BASE		0xF3200000
 #define PEX9_MEM_SIZE			_2M
+#endif /* #ifdef CONFIG_MACH_ARMADA_XP_AMC */
 
 /*
  * Device Bus address decode windows.
@@ -298,5 +300,36 @@
 #define AXP_SNOOP_FILTER_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x21020)
 #define AXP_REVISION_ID_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x40008)
 #define AXP_REVISION_ID_VIRT_REG	(INTER_REGS_BASE | 0x40008)
+
+
+
+#ifdef CONFIG_MACH_ARMADA_XP_AMC
+/*
+ * AXP-AMC PEX specific defines
+ */
+
+#define PEX0_MEM_PHYS_BASE		0x80000000
+#define PEX0_MEM_SIZE			_128M
+#define PEX1_MEM_PHYS_BASE		0x88000000
+#define PEX1_MEM_SIZE			0x0
+#define PEX2_MEM_PHYS_BASE		0x88000000
+#define PEX2_MEM_SIZE			0x0
+#define PEX3_MEM_PHYS_BASE		0x88000000
+#define PEX3_MEM_SIZE			0x0
+#define PEX4_MEM_PHYS_BASE		0x88000000
+#define PEX4_MEM_SIZE			0x0
+#define PEX5_MEM_PHYS_BASE		0x88000000
+#define PEX5_MEM_SIZE			0x0
+#define PEX6_MEM_PHYS_BASE		0x88000000
+#define PEX6_MEM_SIZE			0x0
+#define PEX7_MEM_PHYS_BASE		0x88000000
+#define PEX7_MEM_SIZE			0x0
+#define PEX8_MEM_PHYS_BASE		0x88000000
+#define PEX8_MEM_SIZE			0x0
+#define PEX9_MEM_PHYS_BASE		0x88000000
+#define PEX9_MEM_SIZE			0x0
+
+#endif /* CONFIG_MACH_ARMADA_XP_AMC */
+
 #endif
 
diff --git a/arch/arm/mach-armadaxp/sysmap.c b/arch/arm/mach-armadaxp/sysmap.c
index fc868c2..c15ba1a 100644
--- a/arch/arm/mach-armadaxp/sysmap.c
+++ b/arch/arm/mach-armadaxp/sysmap.c
@@ -103,10 +103,63 @@ MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
 	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
 };
 
+MV_CPU_DEC_WIN SYSMAP_ARMADA_XP_AMC[] = {
+	/* base low		     base high        size			WinNum		enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS3 */
+	{{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	0x8,		EN},	/* DEVICE_CS0 */
+	{{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS1 */
+	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS3 */
+	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0x0,		EN},	/* PEX0_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	0x1,		DIS},	/* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX1_IO */
+	{{PEX2_MEM_PHYS_BASE,		0,	PEX2_MEM_SIZE		},	0x2,		DIS},	/* PEX2_MEM */
+	{{PEX2_IO_PHYS_BASE,		0,	PEX2_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX2_IO */
+	{{PEX3_MEM_PHYS_BASE,		0,	PEX3_MEM_SIZE		},	0x3,		DIS},	/* PEX3_MEM */
+	{{PEX3_IO_PHYS_BASE,		0,	PEX3_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX3_IO */
+	{{PEX4_MEM_PHYS_BASE,		0,	PEX4_MEM_SIZE		},	0x4,		DIS},	/* PEX4_MEM */
+	{{PEX4_IO_PHYS_BASE,		0,	PEX4_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX4_IO */
+	{{PEX5_MEM_PHYS_BASE,		0,	PEX5_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_MEM */
+	{{PEX5_IO_PHYS_BASE,		0,	PEX5_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_IO */
+	{{PEX6_MEM_PHYS_BASE,		0,	PEX6_MEM_SIZE		},	0x5,		DIS},	/* PEX6_MEM */
+	{{PEX6_IO_PHYS_BASE,		0,	PEX6_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX6_IO */
+	{{PEX7_MEM_PHYS_BASE,		0,	PEX7_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_MEM */
+	{{PEX7_IO_PHYS_BASE,		0,	PEX7_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_IO */
+	{{PEX8_MEM_PHYS_BASE,		0,	PEX8_MEM_SIZE		},	0x6,		DIS},	/* PEX8_MEM */
+	{{PEX8_IO_PHYS_BASE,		0,	PEX8_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX8_IO */
+	{{PEX9_MEM_PHYS_BASE,		0,	PEX9_MEM_SIZE		},	0x7,		DIS},	/* PEX9_MEM */
+	{{PEX9_IO_PHYS_BASE,		0,	PEX9_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX9_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS4 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		EN},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		EN},	/* DEV_BOOCS */
+	{{PMU_SCRATCH_PHYS_BASE,	0,	PMU_SCRATCH_SIZE	},	TBL_UNUSED,	DIS},	/* PMU S-PAD */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xb,		DIS},	/* CRYPT0_ENG */
+	{{CRYPT_ENG_PHYS_BASE(1),	0,	CRYPT_ENG_SIZE		},	0xc,		DIS},	/* CRYPT1_ENG */
+	{{PNC_BM_PHYS_BASE,		0,	PNC_BM_SIZE		},	0xd,		EN},	/* PNC_BM */
+	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
+};
+
 
 MV_CPU_DEC_WIN* mv_sys_map(void)
 {
+#ifdef CONFIG_MACH_ARMADA_XP_AMC
+	return SYSMAP_ARMADA_XP_AMC;
+#else
 	return SYSMAP_ARMADA_XP;
+#endif
 }
 
 
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 8cfdd47..ff9fe4a 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -213,6 +213,17 @@ config MV_INCLUDE_PRESTERA
 	Prestera Packet Procesors, currently supporting only MSYS.
 	This option should be enabled when using CPSS.
 
+config MV_INCLUDE_PRESTERA_PCI
+	bool "Prestera Switch Support for PCI endpoint"
+	depends on MACH_ARMADA_XP_AMC
+	default y
+	help
+	Add Prestera mvPP PCI device driver support,
+	used by user space to configure and interact with
+	Prestera Packet Processors, currently supporting only
+	switches connected via PCIe to AMC/AXP.
+	This option should be enabled when using CPSS.
+
 config MV_SUPPORT_COMMON_MPP_FLASH
 	bool "Flash Support"
 	depends on ARMADA_38X
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
index 29350c0..c9d4fdc 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
@@ -6,5 +6,7 @@ include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 
-obj-$(CONFIG_MV_INCLUDE_PRESTERA)	+= mvPrestera.o
+obj-$(CONFIG_MV_INCLUDE_PRESTERA)	+= mvPrestera.o mv_prestera_pltfm.o
+obj-$(CONFIG_MV_INCLUDE_PRESTERA_PCI)	+= mvPrestera.o mv_prestera_pci.o
 mvPrestera-objs				+= mv_prestera.o mv_prestera_irq.o mv_prestera_smi.o mv_pss_api.o
+
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
index cf5f22a..7591857 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
@@ -79,7 +79,6 @@
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 #include <linux/version.h>
-#include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/syscalls.h>
 #include <linux/sched.h>
@@ -87,8 +86,6 @@
 #include <linux/kallsyms.h>
 
 #include "mvOs.h"
-#include "mvDeviceId.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
 #include "mvCommon.h"
 #include "mv_prestera_glob.h"
 #include "mv_prestera_smi.h"
@@ -106,7 +103,8 @@
 #define DB(x)
 #endif
 
-#define PRV_CPSS_MAX_PP_DEVICES_CNS	3
+
+unsigned long			dma_base;
 
 /* local variables and variables */
 static int			dev_open_nr;
@@ -115,11 +113,10 @@ static struct prestera_device	*prestera_dev;
 static int			prestera_major = PRESTERA_MAJOR;
 static struct cdev		prestera_cdev;
 static const char		*prestera_dev_name = "mvPP";
-static unsigned long		pci_phys_addr[PRV_CPSS_MAX_PP_DEVICES_CNS];
+static int unsigned long	pci_phys_addr[PRV_MAX_PP_DEVICES];
 static int			pci_phys_blocks;
-static struct pp_dev		*ppdevs[PRV_CPSS_MAX_PP_DEVICES_CNS];
+static struct pp_dev		*ppdevs[PRV_MAX_PP_DEVICES];
 static int			founddevs;
-static unsigned long		dma_base;
 static unsigned int		dma_len;
 static void			*dma_area;
 static void			*dma_tmp_virt;
@@ -956,59 +953,6 @@ int prestera_read_proc_mem(char		*page,
 	return len;
 }
 
-static int ppdev_conf_set(void)
-{
-	struct pp_dev	*ppdev;
-	unsigned long	start;
-	unsigned long	len;
-
-	ppdev = kmalloc(sizeof(struct pp_dev), GFP_KERNEL);
-	if (NULL == ppdev) {
-		mvOsPrintf("kmalloc failed\n");
-		return -ENOMEM;
-	}
-
-	ppdev->devId = mvCtrlModelGet();
-	ppdev->vendorId = MARVELL_VEN_ID;
-	ppdev->instance = 0;
-	ppdev->busNo = 0;
-	ppdev->devSel = 0;
-	ppdev->funcNo = 0;
-	ppdev->on_pci_bus = 0;
-
-	/* configure the SWITCH register address space */
-	/* additional 1MB is reserved for DFX registers */
-	start = SWITCH_REGS_PHYS_BASE;
-	len = SWITCH_REGS_SIZE + _1M;
-
-	ppdev->ppregs.allocbase = start;
-	ppdev->ppregs.allocsize = len;
-	ppdev->ppregs.size = len;
-	ppdev->ppregs.phys = start;
-	ppdev->ppregs.base = (uintptr_t)(SWITCH_REGS_VIRT_BASE);
-	ppdev->ppregs.mmapbase = (uintptr_t)(CPSS_SWITCH_VIRT_ADDR);
-	ppdev->ppregs.mmapoffset = 0;
-
-	/* save phys address */
-	pci_phys_addr[pci_phys_blocks++] = start;
-
-	/* configure the CPU register address space */
-	start = INTER_REGS_PHYS_BASE;
-	len = _1M;
-
-	ppdev->config.allocbase = start;
-	ppdev->config.allocsize = len;
-	ppdev->config.size = len;
-	ppdev->config.phys = start;
-	ppdev->config.mmapbase = (uintptr_t)(CPSS_CPU_VIRT_ADDR);
-	ppdev->config.mmapoffset = 0;
-	ppdev->config.base = (uintptr_t)(INTER_REGS_VIRT_BASE);
-
-	ppdevs[founddevs++] = ppdev;
-
-	return 0;
-}
-
 static const struct file_operations prestera_fops = {
 	.llseek			= prestera_lseek,
 	.read			= prestera_smi_read,
@@ -1137,17 +1081,9 @@ static int prestera_dma_init(void)
 		return -ENOMEM;
 	}
 
-	/* open internal switch window for DMA */
-	writel(dma_base | PP_BA_ATTR,	SWITCH_REGS_VIRT_BASE | PP_WIN_BA(0));
-	writel(PP_UDID_DATTR,		SWITCH_REGS_VIRT_BASE | PP_UDID);
-	writel(PP_WIN_SIZE_VAL,		SWITCH_REGS_VIRT_BASE | PP_WIN_SR(0));
-	writel(PP_WIN_CTRL_AP,		SWITCH_REGS_VIRT_BASE | PP_WIN_CTRL(0));
-
 	return 0;
 }
 
-
-
 /************************************************************************
  *
  * prestera_cleanup:
@@ -1164,6 +1100,9 @@ static void prestera_cleanup(void)
 	for (i = 0; i < founddevs; i++) {
 		ppdev = ppdevs[i];
 
+/* XXX: not tested as a module, but do not have to iounmap and release
+ * mem_region here - pci drv does it, _pltf not have to do it */
+#if 0
 		/* Unmap the memory regions */
 		iounmap((void *)ppdev->config.base);
 		iounmap((void *)ppdev->ppregs.base);
@@ -1172,6 +1111,7 @@ static void prestera_cleanup(void)
 		release_mem_region(ppdev->config.allocbase, ppdev->config.allocsize);
 		/* relaese BAR1 */
 		release_mem_region(ppdev->ppregs.allocbase, ppdev->ppregs.allocsize);
+#endif
 
 		kfree(ppdev);
 	}
@@ -1194,18 +1134,86 @@ static void prestera_cleanup(void)
 	unregister_chrdev_region(MKDEV(prestera_major, 0), 1);
 }
 
+static uint32_t *get_instance(unsigned short vendorId, unsigned short devId)
+{
+	static uint32_t bobcat2_instance;
+
+	switch (devId) {
+	case MV_BOBCAT2_DEV_ID:
+		return &bobcat2_instance;
+	default:
+		return NULL;
+	}
+}
+
+/*
+ * XXX: probably not need to distinguish instance of bobcat, lion etc, maybe
+ * it will be enough for CPSS to remove instance variable and assign founddevs
+ * to ppdev->instance - will be check during multi-switch configuration tests
+ */
+int ppdev_conf_set(struct pp_dev *ppdev)
+{
+	uint32_t *instance;
+	static uintptr_t config_map_base = CPSS_CPU_VIRT_ADDR;
+
+	DB(mvOsPrintf("%s\n", __func__));
+
+	instance = get_instance(ppdev->vendorId, ppdev->devId);
+	if (!(instance))
+		return -ENODEV;
+
+	ppdev->instance = *instance++;
+
+	/* SWITCH register address space mapping */
+	ppdev->ppregs.mmapbase = (uintptr_t)(CPSS_SWITCH_VIRT_ADDR + (pci_phys_blocks << 26));
+	ppdev->ppregs.mmapoffset = 0;
+
+	/* Save phys address */
+	pci_phys_addr[pci_phys_blocks++] = ppdev->ppregs.phys;
+
+	/* INTER_REGS address space mapping */
+	ppdev->config.mmapbase = config_map_base;
+	config_map_base += ppdev->config.size;
+	ppdev->config.mmapoffset = 0;
+
+	/* Only for debug purpose */
+	DB(mvOsPrintf("%s:pdev: devId 0x%x, vendorId 0x%x, instance 0x%lx\n",
+	    __func__, ppdev->devId, ppdev->vendorId, ppdev->instance));
+	DB(mvOsPrintf("pdev: busNo 0x%lx, devSel 0x%lx, funcNo 0x%lx\n",
+	    ppdev->busNo, ppdev->devSel, ppdev->funcNo));
+	DB(mvOsPrintf("ppregs:  allocbase 0x%lx, allocsize 0x%lx, size 0x%lx",
+	    ppdev->ppregs.allocbase, ppdev->ppregs.allocsize, ppdev->ppregs.size));
+	DB(mvOsPrintf("ppregs: phys 0x%lx, base0x%lx, mmapbase0x%lx, mmapoffset 0x%x\n",
+	    ppdev->ppregs.phys, ppdev->ppregs.base, ppdev->ppregs.mmapbase,
+	    ppdev->ppregs.mmapoffset));
+	DB(mvOsPrintf("config: phys 0x%lx, base0x%lx, mmapbase0x%lx, mmapoffset 0x%x\n",
+	    ppdev->config.phys, ppdev->config.base, ppdev->config.mmapbase,
+	    ppdev->config.mmapoffset));
+
+	/* Add device to ppdevs */
+	ppdevs[founddevs++] = ppdev;
+
+	return 0;
+}
+
 /************************************************************************
  *
  * prestera_init:
  */
-static int prestera_init(void)
+int prestera_init(void)
 {
 	int rc = 0;
 
+	DB(mvOsPrintf("%s\n", __func__));
+
+	/* If already initialized skip it */
+	if (dev_init_done == 1) {
+		DB(mvOsPrintf("%s: already initialized\n", __func__));
+		return 0;
+	}
+
 	/* init static vars */
 	dev_open_nr = 0;
-	pci_phys_blocks = 0;
-	founddevs = 0;
 	dma_tmp_virt = NULL;
 	dma_base = 0;
 	dma_len = 0;
@@ -1254,11 +1262,6 @@ static int prestera_init(void)
 
 	memset(pci_phys_addr, 0, sizeof(pci_phys_addr));
 
-	/* configure ppdev structure */
-	rc = ppdev_conf_set();
-	if (0 != rc)
-		goto fail;
-
 	rc = prestera_smi_init();
 	if (0 != rc)
 		goto fail;
@@ -1282,8 +1285,4 @@ fail:
 }
 
 module_param(prestera_major, int, S_IRUGO);
-MODULE_AUTHOR("Ofer <oferh@marvell.com>");
-MODULE_DESCRIPTION("device driver for Marvell Prestera family switches");
-MODULE_LICENSE("GPL");
-module_init(prestera_init);
-module_exit(prestera_cleanup);
+
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
index 0d16b86..4c90ced 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
@@ -82,9 +82,10 @@
 #endif
 
 #ifndef PRESTERA_MAJOR
-#define PRESTERA_MAJOR		254   /* major number */
+#define PRESTERA_MAJOR		244   /* major number */
 #endif
 
+#define PRV_MAX_PP_DEVICES	3
 
 /* Switch registers & reg values */
 #define PP_UDID				(0x00000204)		/* Unit default ID reg	*/
@@ -99,7 +100,7 @@
 #define PP_WIN_SIZE_OFF			16
 #define PP_WIN_SIZE_VAL			(PP_WIN_MAX_SIZE << PP_WIN_SIZE_OFF)
 #define PP_WIN_CTRL_RW			0x3
-#define PP_WIN_CTRL_AP			(PP_WIN_CTRL_RW << 2)
+#define PP_WIN_CTRL_AP			(PP_WIN_CTRL_RW << 1)
 
 /* CPSS configurations */
 #define CPSS_DMA_VIRT_ADDR		0x50000000
@@ -132,7 +133,14 @@ struct pp_dev {
 	unsigned long		funcNo;
 	struct mem_region	config;       /* Configuration space */
 	struct mem_region	ppregs;       /* PP registers space */
+/* XXX: will be needed for multi-switch support */
+#if 0
+	unsigned int		irq;
+#endif
 };
 
+int prestera_init(void);
+int ppdev_conf_set(struct pp_dev *ppdev);
+extern unsigned long		dma_base;
 
 #endif /* __MV_PRESTERA */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
new file mode 100644
index 0000000..0da04bd
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
@@ -0,0 +1,493 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_pci.c
+*
+* DESCRIPTION:
+*	functions in kernel mode special for pci prestera.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <drivers/pci/pci.h>
+
+#include "mvCommon.h"
+#include "config/mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+
+#include "mv_prestera.h"
+#include "mv_prestera_pci.h"
+
+#undef MV_PP_PCI_DBG
+
+#ifdef MV_PP_PCI_DBG
+#define dprintk(a...) printk(a)
+#else
+#define dprintk(a...)
+#endif
+
+/* Macro definitions */
+#define PEX_IRQ_EN			BIT(28)
+#define PEX_IRQ_EP			BIT(31)
+
+#define ENABLE	1
+#define DISABLE	0
+
+#define PEX_0	0
+#define BAR_1	1
+#define BAR_2	2
+
+#define BAR_SIZE_64MB	(0x3FF << PXBCR_BAR_SIZE_OFFS)
+#define BAR_SIZE_1MB	(0xF << PXBCR_BAR_SIZE_OFFS)
+
+#ifndef CONFIG_ARCH_MSYS
+#define IRQ_AURORA_SW_CORE0		33
+#define SWITCH_TARGET_ID		0x3
+#define DFX_TARGET_ID			0x8
+#endif
+
+static const char prestera_drv_name[] = "mvPP_PCI";
+static void __iomem *inter_regs;
+
+static void mv_set_pex_bars(uint8_t pex_nr, uint8_t bar_nr, int enable)
+{
+	int val;
+
+	dprintk("%s: pex_nr %d, bar_nr %d, enable:%d\n", __func__, pex_nr,
+		bar_nr, enable);
+
+	val = readl(inter_regs + PEX_BAR_CTRL_REG(pex_nr, bar_nr));
+
+	if (enable == ENABLE)
+		writel(val | PXBCR_BAR_EN,
+				inter_regs + PEX_BAR_CTRL_REG(pex_nr, bar_nr));
+	else
+		writel(val & ~(PXBCR_BAR_EN),
+				inter_regs + PEX_BAR_CTRL_REG(pex_nr, bar_nr));
+}
+
+static void mv_resize_bar(uint8_t pex_nr, uint8_t bar_nr, uint32_t bar_size)
+{
+	/* Disable BAR before reconfiguration */
+	mv_set_pex_bars(pex_nr, bar_nr, DISABLE);
+
+	/* Resize */
+	writel(bar_size, inter_regs + PEX_BAR_CTRL_REG(pex_nr, bar_nr));
+	dprintk("PEX_BAR_CTRL_REG(%d, %d) = 0x%x\n", pex_nr, bar_nr,
+		readl(inter_regs + PEX_BAR_CTRL_REG(pex_nr, bar_nr)));
+
+	/* Enable BAR */
+	mv_set_pex_bars(pex_nr, bar_nr, ENABLE);
+}
+
+static int mv_configure_win_bar(uint8_t bar_nr, struct pci_dev *pdev)
+{
+	int i, io_base, val, win_ctrl_reg, win_base_reg;
+
+	if (bar_nr == BAR_1) {
+		/* Disable all windows which points to BAR1 */
+		for (i = 0; i < 4; i++)
+			writel(0, inter_regs + PEX_WIN0_3_CTRL_REG(PEX_0, i));
+
+		val = (BAR_SIZE_64MB | (SWITCH_TARGET_ID << PXWCR_TARGET_OFFS)
+		       | PXWCR_WIN_BAR_MAP_BAR1 | PXWCR_WIN_EN);
+
+		win_ctrl_reg = PEX_WIN0_3_CTRL_REG(PEX_0, 0);
+		win_base_reg = PEX_WIN0_3_BASE_REG(PEX_0, 0);
+		io_base = pci_resource_start(pdev, MV_PCI_BAR_1);
+
+	} else if (bar_nr == BAR_2) {
+		val = (BAR_SIZE_1MB | (DFX_TARGET_ID << PXWCR_TARGET_OFFS) |
+		       PXWCR_WIN_BAR_MAP_BAR2 | PXWCR_WIN_EN);
+		win_ctrl_reg = PEX_WIN4_5_CTRL_REG(PEX_0, 4);
+		win_base_reg = PEX_WIN4_5_BASE_REG(PEX_0, 4);
+		io_base = pci_resource_start(pdev, MV_PCI_BAR_2);
+	} else {
+		dev_err(&pdev->dev, "unknown BAR nr - %d\n", bar_nr);
+		return -EINVAL;
+	}
+
+	dprintk("pex_win for bar%d = 0x%x\n", bar_nr,
+		readl(inter_regs + win_ctrl_reg));
+
+	writel(val, inter_regs + win_ctrl_reg);
+	writel(io_base, inter_regs + win_base_reg);
+
+	dprintk("BAR%d: pex_win_ctrl = 0x%x, pex_win_base 0 = 0x%x\n", bar_nr,
+		readl(inter_regs + win_ctrl_reg), readl(inter_regs + win_base_reg));
+
+	return 0;
+}
+
+static int mv_read_and_assign_bars(struct pci_dev *pdev, int resno)
+{
+	struct resource *res = pdev->resource + resno;
+	int reg, err;
+
+	dprintk("before reassign: r_start 0x%x, r_end: 0x%x, r_flags 0x%lx\n",
+		res->start, res->end, res->flags);
+
+	reg = PCI_BASE_ADDRESS_0 + (resno << 2);
+	__pci_read_base(pdev, pci_bar_unknown, res, reg);
+	err = pci_assign_resource(pdev, resno);
+
+	dprintk("after reassign: r_start 0x%x, r_end: 0x%x, r_flags 0x%lx\n",
+		res->start, res->end, res->flags);
+
+	return err;
+}
+
+#ifdef MV_PP_PCI_DBG
+static void mv_dbg_pex_win(void)
+{
+	int i;
+
+	dprintk("decoding window configuration (i_reg: 0x%x: )\n",
+		(uint32_t)inter_regs);
+	for (i = PEX_WIN0_3_CTRL_REG(PEX_0, 0);
+	     i <= PEX_WIN0_3_CTRL_REG(PEX_0, 3) ;) {
+		dprintk("win(0x%x) ctrl: 0x%x \t base: 0x%x \t remap: 0x%x\n",
+			i, readl(inter_regs + i), readl(inter_regs + i + 4),
+			readl(inter_regs + i + 8));
+		i += 0x10;
+	}
+}
+#endif
+
+static void mv_enable_switch_irq(struct pci_dev *pdev)
+{
+	int tmp, i;
+	unsigned int addr;
+	uint8_t switching_core_nr = 0;
+
+	switch (pdev->device) {
+	case MV_BOBCAT2_DEV_ID:
+		switching_core_nr = 0x3;
+		break;
+	default:
+		return;
+	}
+
+	/* For all Switching Core Int */
+	for (i = 0; i < switching_core_nr; i++) {
+
+		/* Set as pci endpoint and enable */
+		addr = CPU_INT_SOURCE_CONTROL_REG((IRQ_AURORA_SW_CORE0 + i));
+		tmp = readl(inter_regs + addr);
+		dprintk("irq status and ctrl(0x%x) = 0x%x\n", addr, tmp);
+		tmp = tmp | (PEX_IRQ_EN) | (PEX_IRQ_EP);
+		writel(tmp, inter_regs + addr);
+
+		dprintk("irq status and ctrl(0x%x) = 0x%x\n",
+			addr, readl(inter_regs + addr));
+
+		/* Clear irq */
+		writel(IRQ_AURORA_SW_CORE0 + i,
+			inter_regs + CPU_INT_CLEAR_MASK_LOCAL_REG);
+		dprintk("clr reg(0x%x)\n", CPU_INT_CLEAR_MASK_LOCAL_REG);
+	}
+}
+
+static void mv_pci_dma_switch_init(unsigned long switch_reg, struct pci_dev *pdev)
+{
+	dprintk("%s\n", __func__);
+
+	writel(dma_base | PP_PCI_BA_ATTR, switch_reg | PP_WIN_BA(0));
+	writel(PP_PCI_UDID_DATTR,	switch_reg | PP_UDID);
+	writel(PP_WIN_SIZE_VAL,		switch_reg | PP_WIN_SR(0));
+	writel(PP_WIN_CTRL_AP,		switch_reg | PP_WIN_CTRL(0));
+
+	dprintk("read pp: 0x%x\n", readl(switch_reg | PP_WIN_BA(0)));
+	dprintk("read pp: 0x%x\n", readl(switch_reg | PP_UDID));
+	dprintk("read pp: 0x%x\n", readl(switch_reg | PP_WIN_SR(0)));
+	dprintk("read pp: 0x%x\n", readl(switch_reg | PP_WIN_CTRL(0)));
+
+	/* Debug dma reg - according to old code in
+	 * arch/arm/mach-armadaxp/pss/hwServices.c
+	 */
+	writel(0xaaba,	switch_reg | 0x2684);
+	dprintk("%s read pp: 0x%x\n", __func__, readl(switch_reg | 0x2684));
+
+}
+
+static int mv_ppdev_conf_set_pci(struct pci_dev *pdev)
+{
+	struct pp_dev	*ppdev;
+	unsigned long	start;
+	unsigned long	len;
+	void __iomem * const *iomap;
+	int err;
+
+	iomap = pcim_iomap_table(pdev);
+
+	dprintk("%s\n", __func__);
+
+	ppdev = kmalloc(sizeof(struct pp_dev), GFP_KERNEL);
+	if (NULL == ppdev) {
+		dev_err(&pdev->dev, "kmalloc ppdev failed\n");
+		return -ENOMEM;
+	}
+	ppdev->devId = pdev->device;
+	ppdev->vendorId = MARVELL_VEN_ID;
+	ppdev->busNo = pdev->bus->number;
+	ppdev->devSel = PCI_SLOT(pdev->devfn);
+	ppdev->funcNo = PCI_FUNC(pdev->devfn);
+	ppdev->on_pci_bus = 1;
+
+/* XXX: will be needed for multi-switch support */
+#if 0
+	ppdev->irq = pdev->irq;
+	dprintk("%s: irq: %d\n", __func__, ppdev->irq);
+#endif
+
+
+	/* Configure the SWITCH register address space */
+	/* Additional 1MB is reserved for DFX registers */
+	start = pci_resource_start(pdev, MV_PCI_BAR_1);
+	len =  pci_resource_len(pdev, MV_PCI_BAR_1) + _1M;
+
+	ppdev->ppregs.allocbase = start;
+	ppdev->ppregs.allocsize = len;
+	ppdev->ppregs.size = len;
+	ppdev->ppregs.phys = start;
+	ppdev->ppregs.base = (unsigned long)iomap[MV_PCI_BAR_1];
+
+	/* Configure the CPU register address space */
+	start = pci_resource_start(pdev, MV_PCI_BAR_INTER_REGS);
+	len = pci_resource_len(pdev, MV_PCI_BAR_INTER_REGS);
+
+	ppdev->config.allocbase = start;
+	ppdev->config.allocsize = len;
+	ppdev->config.size = len;
+	ppdev->config.phys = start;
+	ppdev->config.base = (unsigned long)iomap[MV_PCI_BAR_INTER_REGS];
+
+	err = ppdev_conf_set(ppdev);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mv_reconfig_bars(struct pci_dev *pdev)
+{
+	int i, err;
+
+	inter_regs = pci_iomap(pdev, MV_PCI_BAR_INTER_REGS, _1M);
+	if (inter_regs == NULL) {
+		dev_err(&pdev->dev, "failed to remap registers\n");
+		return -ENODEV;
+	}
+	dprintk("%s: inter_regs 0x%p\n", __func__, inter_regs);
+
+#ifdef MV_PP_PCI_DBG
+	mv_dbg_pex_win();
+#endif
+
+	/* Resize BAR1 (64MB for SWITCH) */
+	mv_resize_bar(PEX_0, BAR_1, BAR_SIZE_64MB);
+	/* Resize BAR2 (1MB for DFX) */
+	mv_resize_bar(PEX_0, BAR_2, BAR_SIZE_1MB);
+
+	/*
+	 * Unmap inter_regs - will be mapped again after BAR reassignment
+	 */
+	iounmap(inter_regs);
+
+	/* Release all resources which were assigned */
+	for (i = 0; i < PCI_STD_RESOURCE_END; i++) {
+		struct resource *res = pdev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+
+	/*
+	 * Now when all PCI BARs are reconfigured, read them again and reassign
+	 * resources
+	 */
+	err = mv_read_and_assign_bars(pdev, MV_PCI_BAR_1);
+	if (err != 0)
+		return err;
+
+	err = mv_read_and_assign_bars(pdev, MV_PCI_BAR_2);
+	if (err != 0)
+		return err;
+
+	err = mv_read_and_assign_bars(pdev, MV_PCI_BAR_INTER_REGS);
+
+	return err;
+}
+
+static int prestera_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int err;
+	void __iomem * const *iomap;
+	void __iomem *switch_reg;
+
+	dprintk("%s: started\n", __func__);
+
+	/*
+	 * Reconfigure and reassign bars:
+	 *  BAR0: 1MB  for INTER REGS (fixed size, no configuration needed)
+	 *  BAR1: 64MB for SWITCH REGS
+	 *  BAR2: 1MB  for DFX REGS
+	 */
+	err = mv_reconfig_bars(pdev);
+	if (err != 0)
+		return err;
+
+	err = pcim_enable_device(pdev);
+	if (err)
+		return err;
+
+	err = pcim_iomap_regions(pdev, (1 << MV_PCI_BAR_INTER_REGS) |
+	      (1 << MV_PCI_BAR_1) | (1 << MV_PCI_BAR_2), prestera_drv_name);
+	if (err)
+		return err;
+
+	iomap = pcim_iomap_table(pdev);
+
+	inter_regs = iomap[MV_PCI_BAR_INTER_REGS];
+	switch_reg = iomap[MV_PCI_BAR_1];
+
+	dprintk("inter_regs: %p, bar1: %p, bar2: %p\n",
+		iomap[MV_PCI_BAR_INTER_REGS], iomap[MV_PCI_BAR_1],
+		iomap[MV_PCI_BAR_2]);
+
+	/*
+	 * Configure decoding windows for BARs:
+	 *  BAR0 points to INTER REGS (dedicated to internal regs by default)
+	 *  BAR1 points to SWITCH REGS
+	 *  BAR2 points to DFX REGS
+	 */
+
+	err = mv_configure_win_bar(BAR_2, pdev);
+	if (err)
+		return err;
+	dprintk("%s: decoding win for: BAR2 <- DFX(1MB) configured\n",
+		__func__);
+
+	err = mv_configure_win_bar(BAR_1, pdev);
+	if (err)
+		return err;
+	dprintk("%s: decoding win for: BAR1 <- SWITCH(64MB) configured\n",
+		__func__);
+
+	mv_enable_switch_irq(pdev);
+
+	err = mv_ppdev_conf_set_pci(pdev);
+	if (err)
+		return err;
+
+	/*
+	 * Call existing mvPP driver, if already initialized it will return 0
+	 */
+	err = prestera_init();
+	if (err)
+		return err;
+
+	mv_pci_dma_switch_init((unsigned long)switch_reg, pdev);
+
+	dev_info(&pdev->dev, "%s init completed\n", prestera_drv_name);
+	return 0;
+}
+
+static void prestera_pci_remove(struct pci_dev *pdev)
+{
+	dprintk("%s\n", __func__);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(prestera_pci_tbl) = {
+	/* Marvell */
+	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, MV_BOBCAT2_DEV_ID)},
+	{}
+};
+
+static struct pci_driver prestera_pci_driver = {
+	.name			= prestera_drv_name,
+	.id_table		= prestera_pci_tbl,
+	.probe			= prestera_pci_probe,
+	.remove			= prestera_pci_remove,
+};
+
+static int __init prestera_pci_init(void)
+{
+	return pci_register_driver(&prestera_pci_driver);
+}
+
+static void __exit prestera_pci_cleanup(void)
+{
+	pci_unregister_driver(&prestera_pci_driver);
+}
+
+MODULE_AUTHOR("Grzegorz Jaszczyk <jaz@semihalf.com>");
+MODULE_DESCRIPTION("pci device driver for Marvell Prestera family switches");
+MODULE_LICENSE("GPL");
+
+module_init(prestera_pci_init);
+module_exit(prestera_pci_cleanup);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
new file mode 100644
index 0000000..583ba51
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
@@ -0,0 +1,91 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_pci.h
+*
+* DESCRIPTION:
+*       Includes defines and structures needed by the PCI PP device driver
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+
+#ifndef __MV_PRESTERA_PCI_H
+#define __MV_PRESTERA_PCI_H
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+enum {
+	MV_PCI_BAR_INTER_REGS	= 0,
+	MV_PCI_BAR_1		= 2,
+	MV_PCI_BAR_2		= 4,
+};
+
+/* Switch attr and target id is different for PCI */
+#define PP_PCI_ATTR			0xe
+#define PP_PCI_TARGETID			0x4
+#define PP_PCI_UDID_DATTR		(PP_PCI_ATTR << 4 | PP_PCI_TARGETID)
+#define PP_PCI_BA_ATTR			(PP_PCI_ATTR << 8 | PP_PCI_TARGETID)
+
+#endif /* __MV_PRESTERA_PCI_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c
new file mode 100644
index 0000000..49e88d9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c
@@ -0,0 +1,193 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_pltfm.c
+*
+* DESCRIPTION:
+*	functions in kernel mode special for prestera.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/semaphore.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "mv_prestera.h"
+#include "mvDeviceId.h"
+
+#undef MV_PP_DBG
+
+#ifdef MV_PP_DBG
+#define dprintk(a...) printk(a)
+#else
+#define dprintk(a...)
+#endif
+
+static int ppdev_conf_set_pltfm(void)
+{
+	struct pp_dev	*ppdev;
+	unsigned long	start;
+	unsigned long	len;
+	int err;
+
+	dprintk("%s\n", __func__);
+
+	ppdev = kmalloc(sizeof(struct pp_dev), GFP_KERNEL);
+	if (NULL == ppdev) {
+		printk("kmalloc failed\n");
+		return -ENOMEM;
+	}
+
+	ppdev->devId = mvCtrlModelGet();
+	ppdev->vendorId = MARVELL_VEN_ID;
+	ppdev->busNo = 0;
+	ppdev->devSel = 0;
+	ppdev->funcNo = 0;
+	ppdev->on_pci_bus = 0;
+
+/* XXX: will be needed for multi-switch support */
+#if 0
+	ppdev->irq = IRQ_AURORA_SW_CORE0;
+	dprintk("%s: irq: %d\n", __func__, ppdev->irq);
+#endif
+
+	/* configure the SWITCH register address space */
+	/* additional 1MB is reserved for DFX registers */
+	start = SWITCH_REGS_PHYS_BASE;
+	len = SWITCH_REGS_SIZE + _1M;
+
+	ppdev->ppregs.allocbase = start;
+	ppdev->ppregs.allocsize = len;
+	ppdev->ppregs.size = len;
+	ppdev->ppregs.phys = start;
+	ppdev->ppregs.base = (uintptr_t)(SWITCH_REGS_VIRT_BASE);
+
+	/* configure the CPU register address space */
+	start = INTER_REGS_PHYS_BASE;
+	len = _1M;
+
+	ppdev->config.allocbase = start;
+	ppdev->config.allocsize = len;
+	ppdev->config.size = len;
+	ppdev->config.phys = start;
+	ppdev->config.base = (uintptr_t)(INTER_REGS_VIRT_BASE);
+
+	err = ppdev_conf_set(ppdev);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void prestera_dma_switch_init(void)
+{
+	/* open internal switch window for DMA */
+	writel(dma_base | PP_BA_ATTR,	SWITCH_REGS_VIRT_BASE | PP_WIN_BA(0));
+	writel(PP_UDID_DATTR,		SWITCH_REGS_VIRT_BASE | PP_UDID);
+	writel(PP_WIN_SIZE_VAL,		SWITCH_REGS_VIRT_BASE | PP_WIN_SR(0));
+	writel(PP_WIN_CTRL_AP,		SWITCH_REGS_VIRT_BASE | PP_WIN_CTRL(0));
+
+	dprintk("%s read pp: 0x%x\n", __func__,
+	    readl(SWITCH_REGS_VIRT_BASE | PP_WIN_BA(0)));
+	dprintk("%s read pp: 0x%x\n", __func__,
+	    readl(SWITCH_REGS_VIRT_BASE | PP_UDID));
+	dprintk("%s read pp: 0x%x\n", __func__,
+	    readl(SWITCH_REGS_VIRT_BASE | PP_WIN_SR(0)));
+	dprintk("%s read pp: 0x%x\n", __func__,
+	    readl(SWITCH_REGS_VIRT_BASE | PP_WIN_CTRL(0)));
+}
+
+static int prestera_pltfm_cleanup(void)
+{
+	/*
+	 * do nothing, ppdev is freed during char-dev clean-up
+	 * (prestera_cleanup)
+	 */
+	return 0;
+}
+
+static int prestera_pltfm_probe(void)
+{
+	int err;
+
+	err = ppdev_conf_set_pltfm();
+	if (0 != err)
+		return err;
+
+	/* call existing mvPP driver, if already initialized it will return 0 */
+	err = prestera_init();
+	if (err)
+		return err;
+
+	prestera_dma_switch_init();
+
+	return 0;
+}
+
+MODULE_AUTHOR("Ofer <oferh@marvell.com>");
+MODULE_DESCRIPTION("device driver for Marvell Prestera family switches");
+MODULE_LICENSE("GPL");
+module_init(prestera_pltfm_probe);
+module_exit(prestera_pltfm_cleanup);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
index 64f0546..0ad4670 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
@@ -661,7 +661,14 @@ MV_STATUS bspPciGetIntVec(enum bspPciInt_PCI_INT	pciInt,
 {
 	MV_STATUS rc = MV_OK;
 
+#ifdef CONFIG_ARCH_MSYS
 	*intVec = (void *)(unsigned long)(IRQ_AURORA_SW_CORE0);
+#else
+	*intVec = (void *)(unsigned long)(IRQ_AURORA_PCIE0);
+#endif
+	mvOsPrintf("%s int vector 0x%x, pciInt 0x%x\n", __func__, *intVec,
+	    pciInt);
+
 	return rc;
 }
 
-- 
1.7.5.4

