From 07dff8b1e819d668a0353da62a836568c5a0a603 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Tue, 11 Feb 2014 11:01:33 +0800
Subject: [PATCH 1358/1825] pp2: alp: merge the pp2 modification from PON SDK
 team

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit a44d5ba5658d1e9cbb4f8021525353c50f24a41e

    1. add MH parsing field in parser
    2. fully support IPv6 parsing in parser
    3. add misc functions in cls to be used by drivers in TPM and PON

Signed-off-by: Victor Gu <xigu@marvell.com>

Change-Id: Ia25f586b026636b0c14284fdaf96ecb9fe942976
Reviewed-on: http://vgitil04.il.marvell.com:8080/5594
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c   |   37 +
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h   |    2 +
 .../plat-armada/mv_hal/pp2/common/mvPp2Common.h    |    8 +
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c     | 1497 +++++++++++++++++---
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h     |  109 ++-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c   |   57 +
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h   |   21 +-
 7 files changed, 1541 insertions(+), 190 deletions(-)

diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
index 74b8eb0..89ecd6e 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
@@ -404,6 +404,26 @@ int mvPp2ClsHwLkpRead(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe)
 }
 /*-------------------------------------------------------------------------------*/
 
+int mvPp2ClsHwLkpClear(int lkpid, int way)
+{
+	unsigned int regVal = 0;
+	MV_PP2_CLS_LKP_ENTRY fe;
+
+	POS_RANGE_VALIDATE(lkpid, MV_PP2_CLS_LKP_TBL_SIZE);
+	BIT_RANGE_VALIDATE(way);
+
+	/* clear entry */
+	mvPp2ClsSwLkpClear(&fe);
+	mvPp2ClsHwLkpWrite(lkpid, way, &fe);
+
+	/* clear shadow */
+	regVal = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | (lkpid << MV_PP2_CLS_LKP_INDEX_LKP_OFFS);
+	mvClsLkpShadowTbl[regVal] = NOT_IN_USE;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
 int mvPp2ClsSwLkpDump(MV_PP2_CLS_LKP_ENTRY *fe)
 {
 	int int32bit;
@@ -577,6 +597,23 @@ int mvPp2ClsHwFlowRead(int index, MV_PP2_CLS_FLOW_ENTRY *fe)
 }
 /*-------------------------------------------------------------------------------*/
 
+int mvPp2ClsHwFlowClear(int index)
+{
+	MV_PP2_CLS_FLOW_ENTRY fe;
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	/* Clear flow entry */
+	mvPp2ClsSwFlowClear(&fe);
+	mvPp2ClsHwFlowWrite(index, &fe);
+
+	/* clear shadow */
+	mvClsFlowShadowTbl[index] = NOT_IN_USE;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
 int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe)
 {
 	int	int32bit_1, int32bit_2, i;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
index b6ed1aa..c1f3eae 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
@@ -439,6 +439,7 @@ typedef struct mvPp2ClsLkpEntry {
 
 int mvPp2ClsHwLkpWrite(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
 int mvPp2ClsHwLkpRead(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
+int mvPp2ClsHwLkpClear(int lkpid, int way);
 int mvPp2ClsSwLkpDump(MV_PP2_CLS_LKP_ENTRY *fe);
 int mvPp2ClsHwLkpDump(void);
 /*PPv2.1 new counters MAS 3.20*/
@@ -469,6 +470,7 @@ typedef struct mvPp2ClsFlowEntry {
 
 int mvPp2ClsHwFlowWrite(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
 int mvPp2ClsHwFlowRead(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
+int mvPp2ClsHwFlowClear(int index);
 int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe);
 int mvPp2ClsHwFlowDump(void);
 int mvPp2V1ClsHwFlowHitsDump(void);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
index bd2ed71..24d11e0 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
@@ -105,6 +105,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 	} \
 }
 
+#define RET_VALIDATE(_ret_) {\
+	if (_ret_ != MV_OK) {\
+		mvOsPrintf("%s: function call fail.\n", __func__);\
+		return MV_ERROR;\
+	} \
+}
+
+
 #define WARN_OOM(cond) if (cond) { mvOsPrintf("%s: out of memory\n", __func__); return NULL; }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
index 9dafcfa..0aabb58 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
@@ -1,64 +1,64 @@
 /*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
+   Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
 
 ********************************************************************************
-Marvell Commercial License Option
+   Marvell Commercial License Option
 
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
 
 ********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
 ********************************************************************************
-Marvell BSD License Option
+   Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
 
-    *   Redistributions of source code must retain the above copyright notice,
+*   Redistributions of source code must retain the above copyright notice,
 	this list of conditions and the following disclaimer.
 
-    *   Redistributions in binary form must reproduce the above copyright
+*   Redistributions in binary form must reproduce the above copyright
 	notice, this list of conditions and the following disclaimer in the
 	documentation and/or other materials provided with the distribution.
 
-    *   Neither the name of Marvell nor the names of its contributors may be
+*   Neither the name of Marvell nor the names of its contributors may be
 	used to endorse or promote products derived from this software without
 	specific prior written permission.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 #include "mvOs.h"
@@ -67,6 +67,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvPp2Prs.h"
 #include "gbe/mvPp2Gbe.h"
 #include "mvPp2PrsHw.h"
+#include "mvPp2Prs.h"
 
 #define PRS_DBG(X...)
 
@@ -116,8 +117,8 @@ static int mvPrsDblVlanAiFreeGet(void)
 
 
 /******************************************************************************
- * Common utilities
- ******************************************************************************/
+* Common utilities
+******************************************************************************/
 static MV_BOOL mvPp2PrsEtypeEquals(MV_PP2_PRS_ENTRY *pe, int offset, unsigned short ethertype)
 {
 	unsigned char etype[MV_ETH_TYPE_LEN];
@@ -139,7 +140,7 @@ static void mvPp2PrsMatchEtype(MV_PP2_PRS_ENTRY *pe, int offset, unsigned short
 	mvPp2PrsSwTcamByteSet(pe, offset + 0, ethertype >> 8, 0xff);
 	mvPp2PrsSwTcamByteSet(pe, offset + 1, ethertype & 0xFF, 0xff);
 }
-
+#if 0
 static void mvPp2PrsMatchMh(MV_PP2_PRS_ENTRY *pe, unsigned short mh)
 {
 	PRS_DBG("%s\n", __func__);
@@ -147,6 +148,298 @@ static void mvPp2PrsMatchMh(MV_PP2_PRS_ENTRY *pe, unsigned short mh)
 	mvPp2PrsSwTcamByteSet(pe, 0, mh >> 8, 0xff);
 	mvPp2PrsSwTcamByteSet(pe, 1, mh & 0xFF, 0xff);
 }
+#endif
+
+/******************************************************************************
+ *
+ * Marvell header Section
+ *
+ ******************************************************************************
+ */
+static MV_BOOL mvPrsMhRangeEquals(MV_PP2_PRS_ENTRY *pe, MV_U8 *mh, MV_U8 *mask)
+{
+	int index;
+	unsigned char tcamByte, tcamMask;
+
+	for (index = 0; index < MV_ETH_MH_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
+		if (tcamMask != mask[index])
+			return MV_FALSE;
+
+		if ((tcamMask & tcamByte) != (mh[index] & mask[index]))
+			return MV_FALSE;
+	}
+
+	return MV_TRUE;
+}
+
+static MV_BOOL mvPrsMhRangeIntersec(MV_PP2_PRS_ENTRY *pe, MV_U8 *mh, MV_U8 *mask)
+{
+	int index;
+	unsigned char tcamByte, tcamMask, commonMask;
+
+	for (index = 0; index < MV_ETH_MH_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
+
+		commonMask = mask[index] & tcamMask;
+
+		if ((commonMask & tcamByte) != (commonMask & mh[index]))
+			return MV_FALSE;
+	}
+	return MV_TRUE;
+}
+
+static MV_BOOL mvPrsMhInRange(MV_PP2_PRS_ENTRY *pe, MV_U8 *mh, MV_U8 *mask)
+{
+	int index;
+	unsigned char tcamByte, tcamMask;
+
+	for (index = 0; index < MV_ETH_MH_SIZE; index++) {
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
+		if ((tcamByte & mask[index]) != (mh[index] & mask[index]))
+			return MV_FALSE;
+	}
+
+	return MV_TRUE;
+}
+
+static MV_PP2_PRS_ENTRY *mvPrsMhRangeFind(int portMap, unsigned char *mh, unsigned char *mask)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid;
+	unsigned int entryPmap;
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_MH);
+
+	/* Go through the all entires with PRS_LU_MAC */
+	for (tid = PE_FIRST_FREE_TID; tid <= PE_LAST_FREE_TID; tid++) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_MH))
+			continue;
+
+		pe->index = tid;
+		mvPp2PrsHwRead(pe);
+
+		mvPp2PrsSwTcamPortMapGet(pe, &entryPmap);
+
+		if (mvPrsMhRangeEquals(pe, mh, mask) && (entryPmap == (unsigned int)portMap))
+			return pe;
+	}
+	mvPp2PrsSwFree(pe);
+	return NULL;
+}
+
+static int mvPrsMhRangeAccept(int portMap, MV_U8 *mh, MV_U8 *mask, unsigned int ri, unsigned int riMask, MV_BOOL finish)
+{
+	int tid, len;
+	MV_PP2_PRS_ENTRY *pe = NULL;
+
+	/* Scan TCAM and see if entry with this <MH, port> already exist */
+	pe = mvPrsMhRangeFind(portMap, mh, mask);
+
+	if (pe == NULL) {
+		/* entry not exist */
+		/* Go through the all entires from first to last */
+		tid = mvPp2PrsTcamFirstFree(PE_FIRST_FREE_TID, PE_LAST_FREE_TID);
+
+		/* Can't add - No free TCAM entries */
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			mvPp2PrsSwFree(pe);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_MH);
+		pe->index = tid;
+		mvPp2PrsSwTcamPortMapSet(pe, portMap);
+		/* shift to MAC */
+		mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+		mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+		mvPp2PrsSwSramFlowidGenSet(pe);
+
+		/* set MH range */
+		len = MV_ETH_MH_SIZE;
+
+		while (len--)
+			mvPp2PrsSwTcamByteSet(pe, len, mh[len], mask[len]);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe->index, PRS_LU_MH, "mh-range");
+
+	}
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+	finish ? mvPp2PrsSwSramFlowidGenSet(pe) : mvPp2PrsSwSramFlowidGenClear(pe);
+
+	/* Write entry to TCAM */
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
+}
+
+static int mvPrsMhRangeValid(unsigned int portMap, MV_U8 *mh, MV_U8 *mask)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int entryPmap;
+	int tid;
+
+	for (tid = PE_LAST_FREE_TID; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_MH))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		if ((mvPrsMhRangeIntersec(&pe, mh, mask)) & !mvPrsMhRangeEquals(&pe, mh, mask)) {
+			if (entryPmap & portMap) {
+				mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
+				mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n",
+					   __func__, entryPmap & portMap, tid);
+				return MV_ERROR;
+			}
+
+		} else if (mvPrsMhRangeEquals(&pe, mh, mask) && (entryPmap != portMap) && (entryPmap & portMap)) {
+			mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
+			mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n",
+				   __func__, entryPmap & portMap, tid);
+
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+
+int mvPrsMhSet(unsigned int portMap, unsigned short mh, unsigned short mh_mask, unsigned int ri, unsigned int riMask, MV_BOOL finish)
+{
+	MV_PP2_PRS_ENTRY pe;
+	int tid;
+	unsigned int entryPmap;
+	MV_BOOL done = MV_FALSE;
+	unsigned short n_mh;
+	unsigned short n_mh_mask;
+
+	/* step 1 - validation, ranges intersections are forbidden*/
+	n_mh = htons(mh);
+	n_mh_mask = htons(mh_mask);
+	if (mvPrsMhRangeValid(portMap, (unsigned char *)&n_mh, (unsigned char *)&n_mh_mask))
+		return MV_ERROR;
+
+	/* step 2 - update TCAM */
+	for (tid = PE_LAST_FREE_TID; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || !(mvPp2PrsShadowLu(tid) == PRS_LU_MH))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		if (mvPrsMhRangeEquals(&pe, (unsigned char *)&n_mh, (unsigned char *)&n_mh_mask) &&
+				       (entryPmap == portMap)) {
+			/* portMap and range are equals to TCAM entry*/
+			done = MV_TRUE;
+			mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+			finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsHwWrite(&pe);
+			continue;
+		}
+
+		/* PRS_UDF_MAC_DEF */
+		if (mvPrsMhInRange(&pe, (unsigned char *)&n_mh, (unsigned char *)&n_mh_mask) && (entryPmap & portMap)) {
+			mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+			finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsHwWrite(&pe);
+		}
+	}
+	/* step 3 - Add new range entry */
+	if (!done)
+		return mvPrsMhRangeAccept(portMap, (unsigned char *)&n_mh,
+					 (unsigned char *)&n_mh_mask, ri, riMask, finish);
+
+	return MV_OK;
+}
+
+int mvPrsMhDel(unsigned int portMap, unsigned short mh, unsigned short mh_mask)
+{
+	MV_PP2_PRS_ENTRY pe;
+	int tid;
+	unsigned int entryPmap;
+	MV_BOOL found = MV_FALSE;
+	unsigned short n_mh;
+	unsigned short n_mh_mask;
+
+	n_mh = htons(mh);
+	n_mh_mask = htons(mh_mask);
+
+	for (tid = PE_LAST_FREE_TID; tid >= PE_FIRST_FREE_TID; tid--) {
+		if (!mvPp2PrsShadowIsValid(tid) || !(mvPp2PrsShadowLu(tid) == PRS_LU_MH))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
+
+		/* differents ports */
+		if (!(entryPmap & portMap))
+			continue;
+
+		if (mvPrsMhRangeEquals(&pe, (unsigned char *)&n_mh, (unsigned char *)&n_mh_mask)) {
+			found = MV_TRUE;
+			entryPmap &= ~portMap;
+
+			if (!entryPmap) {
+				/* delete entry */
+				mvPp2PrsHwInv(pe.index);
+				mvPp2PrsShadowClear(pe.index);
+				continue;
+			}
+
+			/* update port map */
+			mvPp2PrsSwTcamPortMapSet(&pe, entryPmap);
+			mvPp2PrsHwWrite(&pe);
+			continue;
+		}
+
+		/* PRS_UDF_MH_RANGE */
+		if (!found) {
+			/* range entry not exist */
+			mvOsPrintf("%s: Error, entry not found\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* range entry allready found, now fix all relevant default entries*/
+		if (mvPrsMhInRange(&pe, (unsigned char *)&n_mh, (unsigned char *)&n_mh_mask)) {
+			mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsSwSramRiSet(&pe, mvPp2PrsShadowRi(tid), mvPp2PrsShadowRiMask(tid));
+			mvPp2PrsHwWrite(&pe);
+		}
+	}
+	return MV_OK;
+}
+
+/* Set default entry for Marvell header field */
+static int mvPp2PrsMhInit(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	mvPp2PrsSwClear(&pe);
+
+	pe.index = PE_MH_DEFAULT;
+	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MH);
+	mvPp2PrsSwSramShiftSet(&pe, MV_ETH_MH_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_MAC);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe.index, PRS_LU_MH, "mh-default");
+
+	mvPp2PrsSwTcamPortMapSet(&pe, PORT_MASK);
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
 
 /******************************************************************************
  *
@@ -172,13 +465,13 @@ char *mvPrsL2InfoStr(unsigned int l2_info)
 
 static MV_BOOL mvPrsMacRangeEquals(MV_PP2_PRS_ENTRY *pe, MV_U8 *da, MV_U8 *mask)
 {
-	int		index;
-	unsigned char 	tcamByte, tcamMask;
+	int index;
+	unsigned char tcamByte, tcamMask;
 
 	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
-		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
 		if (tcamMask != mask[index])
-			return	MV_FALSE;
+			return MV_FALSE;
 
 		if ((tcamMask & tcamByte) != (da[index] & mask[index]))
 			return MV_FALSE;
@@ -189,11 +482,11 @@ static MV_BOOL mvPrsMacRangeEquals(MV_PP2_PRS_ENTRY *pe, MV_U8 *da, MV_U8 *mask)
 
 static MV_BOOL mvPrsMacRangeIntersec(MV_PP2_PRS_ENTRY *pe, MV_U8 *da, MV_U8 *mask)
 {
-	int		index;
-	unsigned char 	tcamByte, tcamMask, commonMask;
+	int index;
+	unsigned char tcamByte, tcamMask, commonMask;
 
 	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
-		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
 
 		commonMask = mask[index] & tcamMask;
 
@@ -206,11 +499,11 @@ static MV_BOOL mvPrsMacRangeIntersec(MV_PP2_PRS_ENTRY *pe, MV_U8 *da, MV_U8 *mas
 
 static MV_BOOL mvPrsMacInRange(MV_PP2_PRS_ENTRY *pe, MV_U8* da, MV_U8* mask)
 {
-	int		index;
-	unsigned char 	tcamByte, tcamMask;
+	int index;
+	unsigned char tcamByte, tcamMask;
 
 	for (index = 0; index < MV_MAC_ADDR_SIZE; index++) {
-		mvPp2PrsSwTcamByteGet(pe, MV_ETH_MH_SIZE + index, &tcamByte, &tcamMask);
+		mvPp2PrsSwTcamByteGet(pe, index, &tcamByte, &tcamMask);
 		if ((tcamByte & mask[index]) != (da[index] & mask[index]))
 			return MV_FALSE;
 	}
@@ -259,7 +552,7 @@ static MV_PP2_PRS_ENTRY *mvPrsMacDaFind(int port, unsigned char *da)
 
 static int mvPrsMacDaRangeAccept(int portMap, MV_U8 *da, MV_U8 *mask, unsigned int ri, unsigned int riMask, MV_BOOL finish)
 {
-	int	tid, len;
+	int tid, len;
 	MV_PP2_PRS_ENTRY *pe = NULL;
 
 	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
@@ -270,8 +563,8 @@ static int mvPrsMacDaRangeAccept(int portMap, MV_U8 *da, MV_U8 *mask, unsigned i
 		/* find last simple mac entry*/
 		for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--)
 			if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) == PRS_LU_MAC) &&
-				(mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_DEF))
-					break;
+			    (mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_DEF))
+				break;
 
 		/* Go through the all entires from first to last */
 		tid = mvPp2PrsTcamFirstFree(tid + 1, PE_LAST_FREE_TID);
@@ -287,13 +580,13 @@ static int mvPrsMacDaRangeAccept(int portMap, MV_U8 *da, MV_U8 *mask, unsigned i
 		pe->index = tid;
 		mvPp2PrsSwTcamPortMapSet(pe, portMap);
 		/* shift to ethertype */
-		mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+		mvPp2PrsSwSramShiftSet(pe, 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
 		/* set DA range */
 		len = MV_MAC_ADDR_SIZE;
 
 		while (len--)
-			mvPp2PrsSwTcamByteSet(pe, MV_ETH_MH_SIZE + len, da[len], mask[len]);
+			mvPp2PrsSwTcamByteSet(pe, len, da[len], mask[len]);
 
 		/* Update mvPrsShadowTbl */
 		mvPp2PrsShadowSet(pe->index, PRS_LU_MAC, "mac-range");
@@ -337,7 +630,7 @@ int mvPrsMcastDelAll(int port)
 
 		/* read mac addr from entry */
 		for (index = 0; index < MV_MAC_ADDR_SIZE; index++)
-			mvPp2PrsSwTcamByteGet(&pe, MV_ETH_MH_SIZE + index, &da[index], &daMask[index]);
+			mvPp2PrsSwTcamByteGet(&pe, index, &da[index], &daMask[index]);
 
 		if (MV_IS_BROADCAST_MAC(da))
 			continue;
@@ -355,8 +648,8 @@ int mvPrsMcastDelAll(int port)
 int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 {
 	MV_PP2_PRS_ENTRY *pe = NULL;
-	unsigned int     len, ports, ri;
-	int              tid;
+	unsigned int len, ports, ri;
+	int tid;
 	char name[PRS_TEXT_SIZE];
 
 	/* Scan TCAM and see if entry with this <MAC DA, port> already exist */
@@ -368,13 +661,13 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 			/* Can't remove - No such entry */
 			return MV_ERROR;
 		}
-		/* Create new TCAM entry */
+		 /* Create new TCAM entry */
 
 		/* find last range mac entry*/
 		for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++)
 			if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) == PRS_LU_MAC) &&
-				(mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE))
-					break;
+			    (mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE))
+				break;
 
 		/* Go through the all entires from first to last */
 		tid = mvPp2PrsTcamFirstFree(0, tid - 1);
@@ -416,15 +709,15 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 	/* set match on DA */
 	len = MV_MAC_ADDR_SIZE;
 	while (len--)
-		mvPp2PrsSwTcamByteSet(pe, MV_ETH_MH_SIZE + len, da[len], 0xff);
+		mvPp2PrsSwTcamByteSet(pe, len, da[len], 0xff);
 
 	/* Set result info bits */
 	if (MV_IS_BROADCAST_MAC(da)) {
-		ri = RI_L2_BCAST | RI_MAC_ME_MASK;
+		ri = RI_L2_BCAST;
 		mvOsSPrintf(name, "bcast-port-%d", port);
 
 	} else if (MV_IS_MULTICAST_MAC(da)) {
-		ri = RI_L2_MCAST | RI_MAC_ME_MASK;
+		ri = RI_L2_MCAST;
 		mvOsSPrintf(name, "mcast-port-%d", port);
 	} else {
 		ri = RI_L2_UCAST | RI_MAC_ME_MASK;
@@ -436,7 +729,7 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add)
 	mvPp2PrsShadowRiSet(pe->index, ri, RI_L2_CAST_MASK | RI_MAC_ME_MASK);
 
 	/* shift to ethertype */
-	mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+	mvPp2PrsSwSramShiftSet(pe, 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
 	/* Write entry to TCAM */
 	mvPp2PrsHwWrite(pe);
@@ -458,8 +751,8 @@ static int mvPrsMacDaRangeValid(unsigned int portMap, MV_U8 *da, MV_U8 *mask)
 
 	for (tid = PE_LAST_FREE_TID ; tid >= PE_FIRST_FREE_TID; tid--) {
 		if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_MAC) ||
-			(mvPp2PrsShadowUdf(tid) != PRS_UDF_MAC_RANGE))
-				continue;
+		    (mvPp2PrsShadowUdf(tid) != PRS_UDF_MAC_RANGE))
+			continue;
 
 		pe.index = tid;
 		mvPp2PrsHwRead(&pe);
@@ -470,13 +763,14 @@ static int mvPrsMacDaRangeValid(unsigned int portMap, MV_U8 *da, MV_U8 *mask)
 			if (entryPmap & portMap) {
 				mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
 				mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n",
-					__func__, entryPmap & portMap, tid);
+					   __func__, entryPmap & portMap, tid);
 				return MV_ERROR;
 			}
 
 		} else if (mvPrsMacRangeEquals(&pe, da, mask) && (entryPmap != portMap) && (entryPmap & portMap)) {
 			mvOsPrintf("%s: operation not supported, range intersection\n", __func__);
-			mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n", __func__, entryPmap & portMap, tid);
+			mvOsPrintf("%s: user must delete portMap 0x%x from entry %d.\n",
+				   __func__, entryPmap & portMap, tid);
 			return MV_ERROR;
 		}
 	}
@@ -504,13 +798,13 @@ int mvPrsMacDaRangeSet(unsigned int portMap, MV_U8 *da, MV_U8 *mask, unsigned in
 		mvPp2PrsSwTcamPortMapGet(&pe, &entryPmap);
 
 		if ((mvPp2PrsShadowUdf(tid) == PRS_UDF_MAC_RANGE) &&
-			mvPrsMacRangeEquals(&pe, da, mask) && (entryPmap == portMap)) {
-				/* portMap and range are equals to TCAM entry*/
-				done = MV_TRUE;
-				mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
-				finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
-				mvPp2PrsHwWrite(&pe);
-				continue;
+		    mvPrsMacRangeEquals(&pe, da, mask) && (entryPmap == portMap)) {
+			/* portMap and range are equals to TCAM entry*/
+			done = MV_TRUE;
+			mvPp2PrsSwSramRiUpdate(&pe, ri, riMask);
+			finish ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
+			mvPp2PrsHwWrite(&pe);
+			continue;
 		}
 
 		/* PRS_UDF_MAC_DEF */
@@ -604,7 +898,7 @@ int mvPrsMacDropAllSet(int port, int add)
 
 		/* Non-promiscous mode for all ports - DROP unknown packets */
 		mvPp2PrsSwSramRiSetBit(&pe, RI_DROP_BIT);
-	/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
+		/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
 
 		mvPp2PrsSwSramFlowidGenSet(&pe);
 		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_FLOWS);
@@ -646,7 +940,7 @@ int mvPrsMacPromiscousSet(int port, int add)
 		mvPp2PrsSwSramRiUpdate(&pe, RI_L2_UCAST, RI_L2_CAST_MASK);
 
 		/* shift to ethertype */
-		mvPp2PrsSwSramShiftSet(&pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+		mvPp2PrsSwSramShiftSet(&pe, 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
 		/* mask all ports */
 		mvPp2PrsSwTcamPortMapSet(&pe, 0);
@@ -661,54 +955,65 @@ int mvPrsMacPromiscousSet(int port, int add)
 
 	return MV_OK;
 }
+
 /* 0 - reject, 1 - accept */
 int mvPrsMacAllMultiSet(int port, int add)
 {
 	MV_PP2_PRS_ENTRY pe;
+	unsigned int i, idx = 0;
+	char *rule_str[MAX_MAC_MC] = { "mcast-mac-ip4", "mcast-mac-ip6" };
 
 	/* Ethernet multicast address first byte is with 0x01 */
-	unsigned char da_mc = 0x01;
-	/* all multicast */
+	unsigned char da_mc[MAX_MAC_MC] = { 0x01, 0x33 };
 
-	if (mvPp2PrsShadowIsValid(PE_MAC_MC_ALL)) {
-		/* Entry exist - update port only */
-		pe.index = PE_MAC_MC_ALL;
-		mvPp2PrsHwRead(&pe);
-	} else {
-		/* Entry doesn't exist - create new */
-		mvPp2PrsSwClear(&pe);
+	for (i = IP4_MAC_MC; i < MAX_MAC_MC; i++) {
+		if (i == IP4_MAC_MC)
+			idx = PE_MAC_MC_ALL;
+		else
+			idx = PE_MAC_MC_IP6;
+		/* all multicast */
 
-		pe.index = PE_MAC_MC_ALL;
+		if (mvPp2PrsShadowIsValid(idx)) {
+			/* Entry exist - update port only */
+			pe.index = idx;
+			mvPp2PrsHwRead(&pe);
+		} else {
+			/* Entry doesn't exist - create new */
+			mvPp2PrsSwClear(&pe);
 
-		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+			pe.index = idx;
 
-		/* Continue - set next lookup */
-		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_DSA);
+			mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
 
-		/* Set result info bits */
-		mvPp2PrsSwSramRiUpdate(&pe, RI_L2_MCAST, RI_L2_CAST_MASK);
+			/* Continue - set next lookup */
+			mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_DSA);
 
-		mvPp2PrsSwTcamByteSet(&pe, MV_ETH_MH_SIZE, da_mc, 0xff);
+			/* Set result info bits */
+			mvPp2PrsSwSramRiUpdate(&pe, RI_L2_MCAST, RI_L2_CAST_MASK);
 
-		/* shift to ethertype */
-		mvPp2PrsSwSramShiftSet(&pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+			mvPp2PrsSwTcamByteSet(&pe, 0, da_mc[i], 0xff);
 
-		/* no ports */
-		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+			/* shift to ethertype */
+		mvPp2PrsSwSramShiftSet(&pe, 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
-		/* Update mvPrsShadowTbl */
-		mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "mcast-all");
-	}
+			/* no ports */
+			mvPp2PrsSwTcamPortMapSet(&pe, 0);
 
-	mvPp2PrsSwTcamPortSet(&pe, port, add);
+			/* Update mvPrsShadowTbl */
+			mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, rule_str[i]);
+		}
 
-	mvPp2PrsHwWrite(&pe);
+		mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+		mvPp2PrsHwWrite(&pe);
+	}
 
 	return MV_OK;
 }
 
 int mvPrsMhRxSpecialSet(int port, unsigned short mh, int add)
 {
+#if 0 /* this function to be removed in future */
 	MV_PP2_PRS_ENTRY pe;
 
 	if (mvPp2PrsShadowIsValid(PE_RX_SPECIAL)) {
@@ -735,7 +1040,7 @@ int mvPrsMhRxSpecialSet(int port, unsigned short mh, int add)
 	mvPp2PrsSwTcamPortSet(&pe, port, add);
 
 	mvPp2PrsHwWrite(&pe);
-
+#endif
 	return MV_OK;
 }
 
@@ -749,11 +1054,12 @@ static int mvPp2PrsMacInit(void)
 	/* Non-promiscous mode for all ports - DROP unknown packets */
 	pe.index = PE_MAC_NON_PROMISCOUS;
 	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
-	mvPp2PrsSwSramRiSetBit(&pe, RI_DROP_BIT);
-/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
+	/*	mvPp2PrsSwSramRiSetBit(&pe, RI_DROP_BIT); */
+	/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
 
-	mvPp2PrsSwSramFlowidGenSet(&pe);
-	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_FLOWS);
+	/*	mvPp2PrsSwSramFlowidGenSet(&pe);*/
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_DSA);
+	mvPp2PrsSwSramShiftSet(&pe, 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "non-promisc");
@@ -763,12 +1069,11 @@ static int mvPp2PrsMacInit(void)
 
 	/* place holders only - no ports */
 	mvPrsMacDropAllSet(0, 0);
-	mvPrsMhRxSpecialSet(0, 0, 0);
 	mvPrsMacPromiscousSet(0, 0);
-	mvPrsMacAllMultiSet(0, 0);
 
 	return MV_OK;
 }
+
 /******************************************************************************
  *
  * DSA Section
@@ -1024,7 +1329,7 @@ int mvPp2PrsEtypeDsaModeSet(int port, int extand)
 int mvPp2PrsTagModeSet(int port, int type)
 {
 
-	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS-1);
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS - 1);
 
 	switch (type) {
 
@@ -1172,7 +1477,7 @@ static MV_PP2_PRS_ENTRY *mvPrsDoubleVlanFind(unsigned short tpid1, unsigned shor
 		pe->index = tid;
 		mvPp2PrsHwRead(pe);
 		if ((mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 0, 2, tpidArr1) == EQUALS) &&
-			(mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 4, 2, tpidArr2) == EQUALS)) {
+		    (mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 4, 2, tpidArr2) == EQUALS)) {
 
 			mvPp2PrsSwSramRiGet(pe, &bits, &enable);
 
@@ -1251,7 +1556,8 @@ static int mvPp2PrsVlanAdd(unsigned short tpid, int ai, unsigned int portBmp)
 
 		if (tid <= lastDouble) {
 			/* double vlan entries overlapping*/
-			mvOsPrintf("%s:Can't add entry, please remove unnecessary triple or single vlans entries.\n", __func__);
+			mvOsPrintf("%s:Can't add entry, please remove unnecessary triple or single vlans entries.\n",
+				   __func__);
 			return MV_ERROR;
 		}
 
@@ -1644,7 +1950,7 @@ int mvPrsEthTypeSet(int portMap, unsigned short ethertype, unsigned int ri, unsi
 {
 	MV_PP2_PRS_ENTRY pe;
 	int tid;
-	unsigned int  entryPmap;
+	unsigned int entryPmap;
 	MV_BOOL done = MV_FALSE;
 
 	/* step 1 - validation */
@@ -1894,6 +2200,46 @@ static int mvPp2PrsEtypeArp(void)
 	return MV_OK;
 }
 
+static int mvPp2PrsEtypeLbdt(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_LBDT_TYPE);
+
+	/* generate flow in the next iteration*/
+	/*mvPp2PrsSwSramAiSetBit(pe, AI_DONE_BIT);*/
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramRiUpdate(pe, RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-lbdt");
+	mvPp2PrsShadowUdfSet(pe->index, PRS_UDF_L2_DEF);
+	mvPp2PrsShadowFinSet(pe->index, MV_TRUE);
+	mvPp2PrsShadowRiSet(pe->index, RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK);
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
 
 /* match ip6 */
 static int mvPp2PrsEtypeIp6(void)
@@ -1904,7 +2250,7 @@ static int mvPp2PrsEtypeIp6(void)
 	/* Go through the all entires from first to last */
 	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
 
-		/* Can't add - No free TCAM entries */
+	/* Can't add - No free TCAM entries */
 	if (tid == MV_PRS_OUT_OF_RAGE) {
 		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
 		return MV_ERROR;
@@ -1916,13 +2262,13 @@ static int mvPp2PrsEtypeIp6(void)
 
 	mvPp2PrsMatchEtype(pe, 0, MV_IP6_TYPE);
 
-	/* Skip eth_type + 4 bytes of IPV6 header */
-	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+	/* Skip DIP of IPV6 header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 8 + MV_MAX_L3_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
 
 	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
 /*
 	there is no support in extension yet
-*/
+ */
 	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP6, RI_L3_PROTO_MASK);
 
 	/* set L3 offset */
@@ -1958,6 +2304,10 @@ static int mvPp2PrsEtypeUn(void)
 	mvPp2PrsSwSramRiUpdate(pe, RI_L3_UN, RI_L3_PROTO_MASK);
 
 	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* set L3 offset even it's unknown L3 */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
 	mvPp2PrsHwWrite(pe);
 
 	/* Update mvPrsShadowTbl */
@@ -1976,7 +2326,7 @@ static int mvPp2PrsEtypeUn(void)
  */
 static int mvPp2PrsEtypeInit(void)
 {
-	int    rc;
+	int rc;
 
 	PRS_DBG("%s\n", __func__);
 
@@ -1988,6 +2338,10 @@ static int mvPp2PrsEtypeInit(void)
 	if (rc)
 		return rc;
 
+	rc = mvPp2PrsEtypeLbdt();
+	if (rc)
+		return rc;
+
 	rc = mvPp2PrsEtypeIp4();
 	if (rc)
 		return rc;
@@ -2129,9 +2483,56 @@ static int mvPp2PrsIpv4Pppoe(void)
 	return MV_OK;
 }
 
+/* Create entry for non-ip over PPPoE (for PPP LCP, IPCPv4, IPCPv6, etc) */
+static int mvPp2PrsNonipPppoe(void)
+{
+	int ret;
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/** non-Ip over PPPoE **/
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_PPPOE);
+	PTR_VALIDATE(pe);
+
+	pe->index = tid;
+
+	ret = mvPp2PrsSwSramRiUpdate(pe, RI_L3_UN, RI_L3_PROTO_MASK);
+	RET_VALIDATE(ret);
+
+	ret = mvPp2PrsSwSramFlowidGenSet(pe);
+	RET_VALIDATE(ret);
+
+	/* set L3 offset even it's unknown L3 */
+	ret = mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+	RET_VALIDATE(ret);
+
+	ret = mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	RET_VALIDATE(ret);
+
+	ret = mvPp2PrsHwWrite(pe);
+	RET_VALIDATE(ret);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_PPPOE, "NonIP-over-PPPoE");
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
 
 /* match etype = PPPOE */
-static int mvPp2PrsPpppeInit(void)
+static int mvPp2PrsPppeInit(void)
 {
 	int rc;
 
@@ -2143,6 +2544,10 @@ static int mvPp2PrsPpppeInit(void)
 	if (rc)
 		return rc;
 
+	rc = mvPp2PrsNonipPppoe();
+	if (rc)
+		return rc;
+
 	return MV_OK;
 }
 
@@ -2156,7 +2561,7 @@ static int mvPp2PrsPpppeInit(void)
  */
 
 /* IPv4/TCP header parsing for fragmentation and L4 offset.  */
-static int mvPp2PrsIp4Proto(unsigned short proto)
+static int mvPp2PrsIp4Proto(unsigned short proto, unsigned int ri, unsigned int riMask)
 {
 	int tid;
 	MV_PP2_PRS_ENTRY *pe;
@@ -2179,11 +2584,14 @@ static int mvPp2PrsIp4Proto(unsigned short proto)
 	mvPp2PrsSwTcamByteSet(pe, 5, proto, 0xff);
 
 	if (proto == MV_IP_PROTO_TCP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
 		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-tcp");
 	} else if (proto == MV_IP_PROTO_UDP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
 		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp");
+	} else if (proto == MV_IP_PROTO_IGMP) {
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-igmp");
 	} else {
 		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
 		mvPp2PrsSwFree(pe);
@@ -2192,12 +2600,18 @@ static int mvPp2PrsIp4Proto(unsigned short proto)
 
 	/* set L4 offset */
 	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+	mvPp2PrsSwSramShiftSet(pe, 12, SRAM_OP_SEL_SHIFT_ADD);
 
-	/* Finished: go to flowid generation */
-	mvPp2PrsSwSramFlowidGenSet(pe);
-	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	/* Next: go to IPV4 */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	/* Set sram AIbits */
+	mvPp2PrsSwSramAiUpdate(pe, (1 << IPV4_DIP_AI_BIT), (1 << IPV4_DIP_AI_BIT));
 
 	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* AI bits check */
+	mvPp2PrsSwTcamAiUpdate(pe, 0, (1 << IPV4_DIP_AI_BIT));
+
 	mvPp2PrsHwWrite(pe);
 
 	mvPp2PrsSwFree(pe);
@@ -2215,11 +2629,14 @@ static int mvPp2PrsIp4Proto(unsigned short proto)
 	mvPp2PrsSwSramRiSetBit(pe, RI_IP_FRAG_BIT);
 
 	if (proto == MV_IP_PROTO_TCP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
 		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-tcp-frag");
 	} else if (proto == MV_IP_PROTO_UDP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
 		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp-frag");
+	} else if (proto == MV_IP_PROTO_IGMP) {
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-igmp-frag");
 	} else {
 		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
 		mvPp2PrsSwFree(pe);
@@ -2228,6 +2645,63 @@ static int mvPp2PrsIp4Proto(unsigned short proto)
 
 	/* set L4 offset */
 	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+	mvPp2PrsSwSramShiftSet(pe, 12, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Next: go to IPV4 */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	/* Set sram AIbits */
+	mvPp2PrsSwSramAiUpdate(pe, (1 << IPV4_DIP_AI_BIT), (1 << IPV4_DIP_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	/* AI bits check */
+	mvPp2PrsSwTcamAiUpdate(pe, 0, (1 << IPV4_DIP_AI_BIT));
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/* IPv4 L3 Multicast or borad cast.  1-MC, 2-BC */
+static int mvPp2PrsIp4Cast(unsigned short l3_cast)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	if (l3_cast != L3_MULTI_CAST &&
+	    l3_cast != L3_BROAD_CAST) {
+		mvOsPrintf("%s: Invalid Input\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* Get free entry */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
+	pe->index = tid;
+
+	if (l3_cast == L3_MULTI_CAST) {
+		mvPp2PrsSwTcamByteSet(pe, 0, 0xE0, 0xE0);
+		mvPp2PrsSwSramRiUpdate(pe, RI_L3_MCAST, RI_L3_ADDR_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-mc");
+	} else if (l3_cast == L3_BROAD_CAST) {
+		mvPp2PrsSwTcamByteSet(pe, 0, 0xFF, 0xFF);
+		mvPp2PrsSwTcamByteSet(pe, 1, 0xFF, 0xFF);
+		mvPp2PrsSwTcamByteSet(pe, 2, 0xFF, 0xFF);
+		mvPp2PrsSwTcamByteSet(pe, 3, 0xFF, 0xFF);
+		mvPp2PrsSwSramRiUpdate(pe, RI_L3_BCAST, RI_L3_ADDR_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-bc");
+	}
+
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV4_DIP_AI_BIT), (1 << IPV4_DIP_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
 
 	/* Finished: go to flowid generation */
 	mvPp2PrsSwSramFlowidGenSet(pe);
@@ -2249,12 +2723,26 @@ static int mvPp2PrsIp4Init(void)
 
 	PRS_DBG("%s\n", __func__);
 
-	/* Set entries for TCP and UDP over IPv4 */
-	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_TCP);
+	/* Set entries for TCP, UDP and IGMP over IPv4 */
+	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_TCP, RI_L4_TCP, RI_L4_PROTO_MASK);
 	if (rc)
 		return rc;
 
-	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_UDP);
+	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_UDP, RI_L4_UDP, RI_L4_PROTO_MASK);
+	if (rc)
+		return rc;
+
+	/* IPv4 Broadcast */
+	rc = mvPp2PrsIp4Cast(L3_BROAD_CAST);
+	if (rc)
+		return rc;
+
+	/* IPv4 Multicast */
+	rc = mvPp2PrsIp4Cast(L3_MULTI_CAST);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_IGMP, RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK);
 	if (rc)
 		return rc;
 
@@ -2262,16 +2750,22 @@ static int mvPp2PrsIp4Init(void)
 	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
 	pe->index = PE_IP4_PROTO_UN;
 
-	/* generate flow in the next iteration*/
-	mvPp2PrsSwSramFlowidGenSet(pe);
-	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	/* Next: go to IPV4 */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	/* Set sram AIbits */
+	mvPp2PrsSwSramAiUpdate(pe, (1 << IPV4_DIP_AI_BIT), (1 << IPV4_DIP_AI_BIT));
 
 	/* Set result info bits */
 	mvPp2PrsSwSramRiUpdate(pe, RI_L4_OTHER, RI_L4_PROTO_MASK);
 
 	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+	mvPp2PrsSwSramShiftSet(pe, 12, SRAM_OP_SEL_SHIFT_ADD);
 
 	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* AI bits check */
+	mvPp2PrsSwTcamAiUpdate(pe, 0, (1 << IPV4_DIP_AI_BIT));
+
 	mvPp2PrsHwWrite(pe);
 
 	/* Update mvPrsShadowTbl */
@@ -2279,6 +2773,26 @@ static int mvPp2PrsIp4Init(void)
 
 	mvPp2PrsSwFree(pe);
 
+	/* Default IPv4 entry for unit cast address */
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
+	pe->index = PE_IP4_ADDR_UN;
+
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV4_DIP_AI_BIT), (1 << IPV4_DIP_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_UCAST, RI_L3_ADDR_MASK);
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-uc");
+
+	/* Finished: go to flowid generation */
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
 	return MV_OK;
 }
 
@@ -2290,7 +2804,7 @@ static int mvPp2PrsIp4Init(void)
 /* TODO continue from here */
 /* IPv6 - detect TCP */
 
-static int mvPp2PrsIp6Proto(unsigned short proto)
+static int mvPp2PrsIp6Proto(unsigned short proto, unsigned int ri, unsigned int riMask, MV_BOOL ip6_ext)
 {
 	int tid;
 	MV_PP2_PRS_ENTRY *pe;
@@ -2306,32 +2820,379 @@ static int mvPp2PrsIp6Proto(unsigned short proto)
 	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
 	pe->index = tid;
 
-	/* match TCP protocol */
-	mvPp2PrsSwTcamByteSet(pe, 2, proto, 0xff);
+	/* Match Protocol */
+	mvPp2PrsSwTcamByteSet(pe, 0, proto, 0xff);
 
+	/* Set Rule Shadow */
+	switch (proto) {
+	/* TCP */
+	case MV_IP_PROTO_TCP:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-tcp" : "ipv6-ext-tcp");
+		break;
 
-	if (proto == MV_IP_PROTO_TCP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
-		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-tcp");
-	} else if (proto == MV_IP_PROTO_UDP) {
-		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
-		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp");
-	} else {
-		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
+	/* UDP */
+	case MV_IP_PROTO_UDP:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-udp" : "ipv6-ext-udp");
+		break;
+
+	/* ICMP */
+	case MV_IP_PROTO_ICMPV6:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-icmp" : "ipv6-ext-icmp");
+		break;
+
+	/* IPv4, for IPv6 DS Lite */
+	case MV_IP_PROTO_IPIP:
+		if (ip6_ext != MV_FALSE) {
+			mvOsPrintf("%s: IPv4 header not a IP6 extension header\n", __func__);
+			mvPp2PrsSwFree(pe);
+			return MV_ERROR;
+		}
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-lite-ip4");
+		break;
+
+	/* IPV6 Extension Header */
+
+	/* Hop-by-Hop Options Header, Dummy protocol for TCP */
+	case MV_IP_PROTO_NULL:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-hh" : "ipv6-ext-nh-hh");
+		break;
+
+	/* Encapsulated IPv6 Header, IPv6-in-IPv4 tunnelling */
+	case MV_IP_PROTO_IPV6:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-eh" : "ipv6-ext-nh-eh");
+		break;
+
+	/* Route header */
+	case MV_IP_PROTO_RH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-rh" : "ipv6-ext-nh-rh");
+		break;
+
+	/* Fragment Header */
+	case MV_IP_PROTO_FH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-fh" : "ipv6-ext-nh-fh");
+		break;
+#if 0
+	/* Encapsulation Security Payload protocol */
+	case MV_IP_PROTO_ESP:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-esp" : "ipv6-ext-nh-esp");
+		break;
+#endif
+	/* Authentication Header */
+	case MV_IP_PROTO_AH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-ah" : "ipv6-ext-nh-ah");
+		break;
+
+	/* Destination Options Header */
+	case MV_IP_PROTO_DH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-dh" : "ipv6-ext-nh-dh");
+		break;
+
+	/* Mobility Header */
+	case MV_IP_PROTO_MH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, (MV_FALSE == ip6_ext) ? "ipv6-nh-mh" : "ipv6-ext-nh-mh");
+		break;
+
+	default:
+		mvOsPrintf("%s: IPv6 unsupported protocol %d\n", __func__, proto);
 		mvPp2PrsSwFree(pe);
 		return MV_ERROR;
 	}
-	/* Finished: go to flowid generation */
-	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
-	mvPp2PrsSwSramFlowidGenSet(pe);
+
+	/* Set TCAM and SRAM for TCP, UDP and IGMP */
+	if (proto == MV_IP_PROTO_TCP ||
+	    proto == MV_IP_PROTO_UDP ||
+	    proto == MV_IP_PROTO_ICMPV6 ||
+	    proto == MV_IP_PROTO_IPIP) {
+		/* Set TCAM AI */
+		if (MV_FALSE == ip6_ext)
+			mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
+		else
+			mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AI_BIT), (1 << IPV6_EXT_AI_BIT));
+
+		/* Set result info */
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+
+		/* set L4 offset relatively to our current place */
+		if (MV_FALSE == ip6_ext)
+			mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP6_HEADER) - 6, SRAM_OP_SEL_OFFSET_ADD);
+		else
+			mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, 0, SRAM_OP_SEL_OFFSET_IP6_ADD);
+
+		/* Finished: go to LU Generation */
+		mvPp2PrsSwSramFlowidGenSet(pe);
+		mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	} else { /* Set TCAM and SRAM for IPV6 Extension Header */
+		if (MV_FALSE == ip6_ext) { /* Case 1: xx is first NH of IPv6 */
+			/* Skip to NH */
+			mvPp2PrsSwSramShiftSet(pe, 34, SRAM_OP_SEL_SHIFT_ADD);
+
+			/* Set AI bit */
+			mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
+		} else { /* Case 2: xx is not first NH of IPv6 */
+			/* Skip to NH */
+			mvPp2PrsSwSramShiftSet(pe, 0, SRAM_OP_SEL_SHIFT_IP6_ADD);
+
+			/* Set AI bit */
+			mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AI_BIT), (1 << IPV6_EXT_AI_BIT));
+		}
+
+		/* Next LU */
+		mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+
+		/* Set sram AIbits */
+		if (proto == MV_IP_PROTO_AH) {
+			mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_EXT_AH_AI_BIT), (1 << IPV6_EXT_AH_AI_BIT));
+			mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AI_BIT));
+			mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+		} else {
+			mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_AI_BIT));
+			mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_EXT_AI_BIT), (1 << IPV6_EXT_AI_BIT));
+			mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+		}
+
+		/* Set RI, IPv6 Ext */
+		mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP6_EXT, RI_L3_PROTO_MASK);
+	}
 
 	/* All ports */
 	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
 
-	/* set L4 offset relatively to our current place */
-	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP6_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+	/* Write HW */
+	mvPp2PrsHwWrite(pe);
+
+	/* Release SW entry */
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/* Parse the extension header on AH */
+static int mvPp2PrsIp6ProtoAh(unsigned short proto, unsigned int ri, unsigned int riMask)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* TCP, Not Fragmented */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = tid;
+
+	/* Match Protocol */
+	mvPp2PrsSwTcamByteSet(pe, 0, proto, 0xff);
+
+	/* Set Rule Shadow */
+	switch (proto) {
+	/* TCP */
+	case MV_IP_PROTO_TCP:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-tcp");
+		break;
+
+	/* UDP */
+	case MV_IP_PROTO_UDP:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-udp");
+		break;
+
+	/* ICMP */
+	case MV_IP_PROTO_ICMPV6:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-icmp");
+		break;
+
+	/* IPV6 Extension Header */
+
+	/* Hop-by-Hop Options Header, Dummy protocol for TCP */
+	case MV_IP_PROTO_NULL:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-hh");
+		break;
+
+	/* Encapsulated IPv6 Header, IPv6-in-IPv4 tunnelling */
+	case MV_IP_PROTO_IPV6:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-eh");
+		break;
+
+	/* Route header */
+	case MV_IP_PROTO_RH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-rh");
+		break;
+
+	/* Fragment Header */
+	case MV_IP_PROTO_FH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-fh");
+		break;
+
+	/* Authentication Header */
+	case MV_IP_PROTO_AH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-ah");
+		break;
+
+	/* Destination Options Header */
+	case MV_IP_PROTO_DH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-dh");
+		break;
+
+	/* Mobility Header */
+	case MV_IP_PROTO_MH:
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-ah-nh-mh");
+		break;
+
+	default:
+		mvOsPrintf("%s: IPv6 unsupported extension header %d\n", __func__, proto);
+		mvPp2PrsSwFree(pe);
+		return MV_ERROR;
+	}
+
+	/* Set TCAM and SRAM for TCP, UDP and IGMP */
+	if (proto == MV_IP_PROTO_TCP ||
+	    proto == MV_IP_PROTO_UDP ||
+	    proto == MV_IP_PROTO_ICMPV6) {
+		/* Set result info */
+		mvPp2PrsSwSramRiUpdate(pe, ri, riMask);
+		/* Set sram AIbits */
+		mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_EXT_AH_L4_AI_BIT), (1 << IPV6_EXT_AH_L4_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_LEN_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+	} else {
+		/* Set sram AIbits */
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_L4_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_EXT_AH_LEN_AI_BIT), (1 << IPV6_EXT_AH_LEN_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+	}
+
+	/* Set AI bit */
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AH_AI_BIT), (1 << IPV6_EXT_AH_AI_BIT));
 
+	/* Next LU */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+
+	/* Set RI, IPv6 Ext */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP6_EXT, RI_L3_PROTO_MASK);
+
+	/* All ports */
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* Write HW */
+	mvPp2PrsHwWrite(pe);
+
+	/* Release SW entry */
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/* Parse AH length field */
+static int mvPp2PrsIp6AhLen(unsigned char ah_len, MV_BOOL l4_off_set)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+	char tmp_buf[15];
+
+	PRS_DBG("%s\n", __func__);
+
+	/* TCP, Not Fragmented */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = tid;
+
+	/* Match AH Len */
+	mvPp2PrsSwTcamByteSet(pe, 1, ah_len, 0xff);
+
+	/* Set Rule Shadow */
+	sprintf(tmp_buf, "ipv6-ah-len%d", ah_len);
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, tmp_buf);
+
+	/* Set AI bit */
+	if (l4_off_set) {
+		mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AH_L4_AI_BIT), (1 << IPV6_EXT_AH_L4_AI_BIT));
+		/* Set L4 offset */
+		mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4,
+					(IPV6_EXT_EXCLUDE_BYTES + ah_len * IPV6_EXT_AH_UNIT_BYTES),
+					SRAM_OP_SEL_OFFSET_LKP_ADD);
+		/* Finished: go to LU Generation */
+		mvPp2PrsSwSramFlowidGenSet(pe);
+		mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	} else {
+		mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AH_LEN_AI_BIT), (1 << IPV6_EXT_AH_LEN_AI_BIT));
+		/* Set sram AIbits */
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_L4_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_LEN_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_EXT_AH_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_EXT_AI_BIT), (1 << IPV6_EXT_AI_BIT));
+		mvPp2PrsSwSramAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+
+		/* Skip to NH */
+		mvPp2PrsSwSramShiftSet(pe, (IPV6_EXT_EXCLUDE_BYTES + ah_len * IPV6_EXT_AH_UNIT_BYTES), SRAM_OP_SEL_SHIFT_ADD);
+
+		/* Next LU */
+		mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+	}
+
+	/* All ports */
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* Write HW */
 	mvPp2PrsHwWrite(pe);
+
+	/* Release SW entry */
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/* IPv6 L3 Multicast or borad cast.  1-MC */
+static int mvPp2PrsIp6Cast(unsigned short l3_cast)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	if (l3_cast != L3_MULTI_CAST) {
+		mvOsPrintf("%s: Invalid Input\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* Get free entry */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = tid;
+
+	mvPp2PrsSwTcamByteSet(pe, 0, 0xFF, 0xFF);
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_MCAST, RI_L3_ADDR_MASK);
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-mc");
+
+	mvPp2PrsSwTcamAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* Set sram AIbits */
+	mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
+
+	/* Shift back to IPV6 NH */
+	mvPp2PrsSwSramShiftSet(pe, -18, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Finished: go to flowid generation */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
 	mvPp2PrsSwFree(pe);
 
 	return MV_OK;
@@ -2355,11 +3216,13 @@ static int mvPp2PrsIp6Init(void)
 	}
 	pe->index = tid;
 
-	mvPp2PrsSwTcamByteSet(pe, 3, 0x00, 0xff);
+	mvPp2PrsSwTcamByteSet(pe, 1, 0x00, 0xff);
 	mvPp2PrsSwSramRiUpdate(pe, (RI_L3_UN | RI_DROP_BIT), (RI_L3_PROTO_MASK | RI_DROP_MASK));
 
 	mvPp2PrsSwSramFlowidGenSet(pe);
 	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	/* Update TCAM AI */
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
 
 	mvPp2PrsHwWrite(pe);
 
@@ -2369,14 +3232,36 @@ static int mvPp2PrsIp6Init(void)
 	mvPp2PrsSwFree(pe);
 
 	/* Set entries for TCP and UDP over IPv6 */
-	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_TCP);
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_TCP,
+			      RI_L4_TCP,
+			      RI_L4_PROTO_MASK,
+			      MV_FALSE);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_UDP,
+			      RI_L4_UDP,
+			      RI_L4_PROTO_MASK,
+			      MV_FALSE);
+	if (rc)
+		return rc;
+
+	/* IPv6 Multicast */
+	rc = mvPp2PrsIp6Cast(L3_MULTI_CAST);
 	if (rc)
 		return rc;
 
-	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_UDP);
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_ICMPV6,
+			      RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK,
+			      MV_FALSE);
 	if (rc)
 		return rc;
 
+	/* IPv4 is the last header. This is similar case as 6-TCP or 17-UDP */
+	/* Result Info: UDF7=1, DS lite */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_IPIP, RI_UDF7_IP6_LITE, RI_UDF7_MASK, MV_FALSE);
+	if (rc)
+		return rc;
 
 	/* Default IPv6 entry for unknown protocols */
 	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
@@ -2393,15 +3278,191 @@ static int mvPp2PrsIp6Init(void)
 	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP6_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
 
 	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* AI bits check */
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
+
 	mvPp2PrsHwWrite(pe);
 
 	/* Update mvPrsShadowTbl */
 	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-l4-unknown");
 
 	mvPp2PrsSwFree(pe);
+
+	/* Default IPv6 entry for unknown Ext protocols */
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = PE_IP6_EXT_PROTO_UN;
+
+	/* Finished: go to LU Generation */
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L4_OTHER, RI_L4_PROTO_MASK);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* AI bits check */
+	mvPp2PrsSwTcamAiUpdate(pe, (1 << IPV6_EXT_AI_BIT), (1 << IPV6_EXT_AI_BIT));
+
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-ext-l4-unknown");
+
+	mvPp2PrsSwFree(pe);
+
+	/* Default IPv6 entry for unit cast address */
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = PE_IP6_ADDR_UN;
+
+	mvPp2PrsSwTcamAiUpdate(pe, 0, (1 << IPV6_NO_EXT_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_UCAST, RI_L3_ADDR_MASK);
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP6, "ipv6-uc");
+
+	/* Finished: go to IPv6 again */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+
+	/* Shift back to IPV6 NH */
+	mvPp2PrsSwSramShiftSet(pe, -18, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Set sram AIbits */
+	mvPp2PrsSwSramAiUpdate(pe, (1 << IPV6_NO_EXT_AI_BIT), (1 << IPV6_NO_EXT_AI_BIT));
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
 	return MV_OK;
 }
 
+/* Add IPv6 Next Header parse rule set */
+int mvPrsIp6NhSet(void)
+{
+	int rc;
+	unsigned char ah_len = 0;
+
+	/* Hop-by-Hop Options Header, Dummy protocol for TCP */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_NULL, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_NULL, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* Encapsulated IPv6 Header, IPv6-in-IPv4 tunnelling */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_IPV6, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_IPV6, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* Route header */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_RH, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_RH, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* Fragment Header */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_FH, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_FH, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* Authentication Header */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_AH, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_AH, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+	/* Check NH on AH header */
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_NULL, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_IPV6, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_RH, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_FH, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_DH, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_MH, 0, 0);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_TCP, RI_L4_TCP, RI_L4_PROTO_MASK);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_UDP, RI_L4_UDP, RI_L4_PROTO_MASK);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6ProtoAh(MV_IP_PROTO_ICMPV6, RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK);
+	if (rc)
+		return rc;
+	/* Check AH length */
+	for (ah_len = IP6_AH_LEN_16B; ah_len < IP6_AH_LEN_MAX; ah_len++) {
+		rc = mvPp2PrsIp6AhLen(ah_len, MV_FALSE);
+		if (rc)
+			return rc;
+		/* Set L4 offset */
+		rc = mvPp2PrsIp6AhLen(ah_len, MV_TRUE);
+		if (rc)
+			return rc;
+	}
+
+	/* Destination Options Header */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_DH, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_DH, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* Mobility Header */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_MH, 0, 0, MV_FALSE);
+	if (rc)
+		return rc;
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_MH, 0, 0, MV_TRUE);
+	if (rc)
+		return rc;
+
+	/* L4 parse */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_TCP,
+			      RI_L4_TCP,
+			      RI_L4_PROTO_MASK,
+			      MV_TRUE);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_UDP,
+			      RI_L4_UDP,
+			      RI_L4_PROTO_MASK,
+			      MV_TRUE);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_ICMPV6,
+			      RI_CPU_CODE_RX_SPEC | RI_UDF3_RX_SPECIAL, RI_CPU_CODE_MASK | RI_UDF3_MASK,
+			      MV_TRUE);
+	if (rc)
+		return rc;
+
+	return MV_OK;
+}
 
 /*
  ******************************************************************************
@@ -2409,7 +3470,7 @@ static int mvPp2PrsIp6Init(void)
  * flows
  *
  ******************************************************************************
-*/
+ */
 
 static MV_PP2_PRS_ENTRY *mvPrsFlowFind(int flow)
 {
@@ -2420,7 +3481,7 @@ static MV_PP2_PRS_ENTRY *mvPrsFlowFind(int flow)
 	pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
 
 	/* Go through the all entires with PRS_LU_MAC */
-	for (tid = MV_PP2_PRS_TCAM_SIZE-1; tid >= 0; tid--) {
+	for (tid = MV_PP2_PRS_TCAM_SIZE - 1; tid >= 0; tid--) {
 		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_FLOWS))
 			continue;
 
@@ -2444,7 +3505,7 @@ int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask,
 	PRS_DBG("%s\n", __func__);
 
 	POS_RANGE_VALIDATE(flowId, FLOWID_MASK);
-	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE-1);
+	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE - 1);
 
 	/* Default configuration entry - overrwite is forbidden */
 	if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) != PRS_LU_FLOWS)) {
@@ -2476,6 +3537,61 @@ int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask,
 
 }
 
+int mvPrsFlowIdDel(int tid)
+{
+	PRS_DBG("%s\n", __func__);
+
+	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Only handle valid flow type rule */
+	if (!mvPp2PrsShadowIsValid(tid) || (mvPp2PrsShadowLu(tid) != PRS_LU_FLOWS)) {
+		mvOsPrintf("%s: Error, Tcam entry is not use or not flow type\n", __func__);
+		return MV_ERROR;
+	}
+
+	mvPp2PrsHwInv(tid);
+	mvPp2PrsShadowClear(tid);
+
+	return MV_OK;
+
+}
+
+int mvPrsFlowIdFirstFreeGet(void)
+{
+	int fid;
+
+	for (fid = MV_PP2_PRS_FIRST_FLOW_ID; fid <= MV_PP2_PRS_LAST_FLOW_ID; fid++)
+		if (mvPrsFlowIdGet(fid) == MV_FALSE)
+			break;
+
+	if (fid <= MV_PP2_PRS_LAST_FLOW_ID)
+		return fid;
+
+	return MV_PP2_PRS_INVALID_FLOW_ID;
+}
+
+int mvPrsFlowIdLastFreeGet(void)
+{
+	int fid;
+
+	for (fid = MV_PP2_PRS_LAST_FLOW_ID; fid >= MV_PP2_PRS_FIRST_FLOW_ID; fid--)
+		if (mvPrsFlowIdGet(fid) == MV_FALSE)
+			break;
+
+	if (fid >=  MV_PP2_PRS_FIRST_FLOW_ID)
+		return fid;
+
+	return MV_PP2_PRS_INVALID_FLOW_ID;
+}
+
+int mvPrsFlowIdRelease(int flowId)
+{
+	POS_RANGE_VALIDATE(flowId, FLOWID_MASK);
+
+	mvPrsFlowIdClear(flowId);
+
+	return MV_OK;
+}
 
 int mvPrsDefFlow(int port)
 {
@@ -2506,6 +3622,7 @@ int mvPrsDefFlow(int port)
 
 		/* set flowID*/
 		mvPp2PrsSwSramAiUpdate(pe, FLOWID_DEF(port), FLOWID_MASK);
+		mvPrsFlowIdSet(FLOWID_DEF(port));
 		mvPp2PrsSwSramLuDoneSet(pe);
 
 		mvOsSPrintf(name, "def-flowId-port-%d", port);
@@ -2525,6 +3642,46 @@ int mvPrsDefFlow(int port)
 	return MV_OK;
 }
 
+int mvPrsDefFlowInit(void)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid;
+	int port;
+	char name[PRS_TEXT_SIZE];
+
+	PRS_DBG("%s\n", __func__);
+
+	for (port = 0; port < MV_PP2_MAX_PORTS; port++) {
+		/* Go through the all entires from last to fires */
+		tid = PE_FIRST_DEFAULT_FLOW - port;
+
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
+		pe->index = tid;
+
+		mvPp2PrsSwTcamPortMapSet(pe, 0);
+
+		/* set flowID*/
+		mvPp2PrsSwSramAiUpdate(pe, FLOWID_DEF(port), FLOWID_MASK);
+		mvPrsFlowIdSet(FLOWID_DEF(port));
+		mvPp2PrsSwSramLuDoneSet(pe);
+
+		mvOsSPrintf(name, "def-flowId-port-%d", port);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe->index, PRS_LU_FLOWS, name);
+
+		mvPp2PrsHwWrite(pe);
+		mvPp2PrsSwFree(pe);
+
+	}
+	return MV_OK;
+}
+
 /******************************************************************************
  *
  * Paeser Init
@@ -2534,7 +3691,7 @@ int mvPrsDefFlow(int port)
 
 int mvPrsDefaultInit(void)
 {
-	int    port, rc;
+	int port, rc;
 
 	/*enable tcam table*/
 	mvPp2PrsSwTcam(1);
@@ -2544,12 +3701,21 @@ int mvPrsDefaultInit(void)
 
 	mvPp2PrsHwInvAll();
 	mvPp2PrsShadowClearAll();
+	mvPrsFlowIdClearAll();
 
 	/* TODO: Mask & clear all interrupts */
 
 	/* Always start from lookup = 0 */
 	for (port = 0; port < MV_PP2_MAX_PORTS; port++)
-		mvPp2PrsHwPortInit(port, PRS_LU_MAC, MV_PP2_PRS_PORT_LU_MAX, 0);
+		mvPp2PrsHwPortInit(port, PRS_LU_MH, MV_PP2_PRS_PORT_LU_MAX, 0);
+
+	rc = mvPrsDefFlowInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsMhInit();
+	if (rc)
+		return rc;
 
 	rc = mvPp2PrsMacInit();
 	if (rc)
@@ -2567,7 +3733,7 @@ int mvPrsDefaultInit(void)
 	if (rc)
 		return rc;
 
-	rc = mvPp2PrsPpppeInit();
+	rc = mvPp2PrsPppeInit();
 	if (rc)
 		return rc;
 
@@ -2580,5 +3746,4 @@ int mvPrsDefaultInit(void)
 		return rc;
 
 	return MV_OK;
-
 }
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
index 84383e2..85e42f0 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
@@ -88,6 +88,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define	DSA_ETHER_TYPE		0xDADA/*TODO set to default DSA ether type*/
 
+#define MV_PP2_PRS_INVALID_FLOW_ID	(0xFF) /* Invalid Flow ID */
 
 /* MAC entries , shadow udf */
 enum prs_udf {
@@ -100,6 +101,7 @@ enum prs_udf {
 
 /* LOOKUP ID */
 enum prs_lookup {
+	PRS_LU_MH,
 	PRS_LU_MAC,
 	PRS_LU_DSA,
 	PRS_LU_VLAN,
@@ -111,35 +113,76 @@ enum prs_lookup {
 	PRS_LU_LAST,
 };
 
+/* L3 cast enum */
+enum prs_l3_cast {
+	L3_UNIT_CAST,
+	L3_MULTI_CAST,
+	L3_BROAD_CAST
+};
 
-/* Tcam entries ID */
-#define	PE_DROP_ALL					0
-#define	PE_RX_SPECIAL					1
-#define PE_FIRST_FREE_TID				2
-
-
-#define PE_LAST_FREE_TID	(MV_PP2_PRS_TCAM_SIZE - 19)
-#define PE_ETYPE_DSA		(MV_PP2_PRS_TCAM_SIZE - 18)
-#define PE_EDSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 17)
-#define PE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 16)
-#define PE_DSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 15)
-#define PE_DSA_UNTAGGED		(MV_PP2_PRS_TCAM_SIZE - 14)
+/* PP2 GMAC enum */
+enum prs_gmacs_enum {
+	INVALID_GMAC = -1,
+	ENUM_GMAC_0,
+	ENUM_GMAC_1,
+	ENUM_GMAC_LPK,
+	ENUM_PMAC = 7,
+	MAX_GMAC = ENUM_PMAC,
+	MAX_NUM_GMACS
+};
 
-#define PE_ETYPE_EDSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 13)
-#define PE_ETYPE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 12)
-#define PE_ETYPE_DSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 11)
-#define PE_ETYPE_DSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 10)
+/* Multicast MAC kinds */
+enum prs_mac_mc {
+	IP4_MAC_MC,
+	IP6_MAC_MC,
+	MAX_MAC_MC
+};
 
+/* IPV6 extension header length supported
+*  Calculate: Length = 8B + len * 4 */
+enum prs_ip6_ext_ah_len {
+	IP6_AH_LEN_16B = 2,
+	IP6_AH_LEN_20B = 3,
+	IP6_AH_LEN_24B = 4,
+	IP6_AH_LEN_28B = 5,
+	IP6_AH_LEN_32B = 6,
+	IP6_AH_LEN_36B = 7,
+	IP6_AH_LEN_MAX
+};
 
+/* Tcam entries ID */
+#define PE_DROP_ALL				0
+/* The TCAM rule for RX Special packets based on Marvell header is allocated dynamically */
+#define PE_FIRST_FREE_TID				1
+
+#define PE_LAST_FREE_TID	(MV_PP2_PRS_TCAM_SIZE - 31)
+#define PE_IP6_EXT_PROTO_UN	(MV_PP2_PRS_TCAM_SIZE - 30)
+#define PE_MAC_MC_IP6		(MV_PP2_PRS_TCAM_SIZE - 29) /* multicast for IPv6 */
+#define PE_IP6_ADDR_UN		(MV_PP2_PRS_TCAM_SIZE - 28)
+#define PE_IP4_ADDR_UN		(MV_PP2_PRS_TCAM_SIZE - 27)
+#define PE_LAST_DEFAULT_FLOW	(MV_PP2_PRS_TCAM_SIZE - 26)
+#define PE_FIRST_DEFAULT_FLOW	(MV_PP2_PRS_TCAM_SIZE - 19)
+/*#define PE_ETYPE_DSA		(MV_PP2_PRS_TCAM_SIZE - 19)*/
+#define PE_EDSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 18)
+#define PE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 17)
+#define PE_DSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 16)
+#define PE_DSA_UNTAGGED		(MV_PP2_PRS_TCAM_SIZE - 15)
+
+#define PE_ETYPE_EDSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 14)
+#define PE_ETYPE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 13)
+#define PE_ETYPE_DSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 12)
+#define PE_ETYPE_DSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 11)
+
+#define PE_MH_DEFAULT		(MV_PP2_PRS_TCAM_SIZE - 10) /* Marvell header default rule */
 #define PE_DSA_DEFAULT		(MV_PP2_PRS_TCAM_SIZE - 9)
 #define PE_IP6_PROTO_UN		(MV_PP2_PRS_TCAM_SIZE - 8)
 #define PE_IP4_PROTO_UN		(MV_PP2_PRS_TCAM_SIZE - 7)
 #define PE_ETH_TYPE_UN		(MV_PP2_PRS_TCAM_SIZE - 6)
-#define	PE_VLAN_DBL             (MV_PP2_PRS_TCAM_SIZE - 5) /* accept double vlan*/
-#define	PE_VLAN_NONE            (MV_PP2_PRS_TCAM_SIZE - 4) /* vlan default*/
-#define PE_MAC_MC_ALL   	(MV_PP2_PRS_TCAM_SIZE - 3) /* all multicast mode */
-#define PE_MAC_PROMISCOUS   	(MV_PP2_PRS_TCAM_SIZE - 2) /* promiscous mode */
-#define PE_MAC_NON_PROMISCOUS   (MV_PP2_PRS_TCAM_SIZE - 1) /* non-promiscous mode */
+#define PE_VLAN_DBL		(MV_PP2_PRS_TCAM_SIZE - 5) /* accept double vlan*/
+#define PE_VLAN_NONE		(MV_PP2_PRS_TCAM_SIZE - 4) /* vlan default*/
+#define PE_MAC_MC_ALL		(MV_PP2_PRS_TCAM_SIZE - 3) /* all multicast mode */
+#define PE_MAC_PROMISCOUS	(MV_PP2_PRS_TCAM_SIZE - 2) /* promiscous mode */
+#define PE_MAC_NON_PROMISCOUS	(MV_PP2_PRS_TCAM_SIZE - 1) /* non-promiscous mode */
 
 /*
  * Pre-defined FlowId assigment
@@ -147,6 +190,23 @@ enum prs_lookup {
 
 #define FLOWID_DEF(_port_)	(_port_)
 #define FLOWID_MASK	 	0x3F
+
+/*
+ * AI bits assigment
+*/
+#define IPV4_DIP_AI_BIT		0
+#define IPV6_NO_EXT_AI_BIT	0
+#define IPV6_EXT_AI_BIT		1
+#define IPV6_EXT_AH_AI_BIT	2
+#define IPV6_EXT_AH_LEN_AI_BIT	3
+#define IPV6_EXT_AH_L4_AI_BIT	4
+
+/*
+ * IPv6 extension header related
+*/
+#define IPV6_EXT_EXCLUDE_BYTES	8	/* IP6 excluding bytes in extension header, 8 bytes */
+#define IPV6_EXT_AH_UNIT_BYTES	4	/* The AH length units, 4 bytes */
+
 /*
  * Export API
  */
@@ -156,12 +216,18 @@ int mvPrsMacDaAccept(int port, unsigned char *da, int add);
 int mvPrsMacDaRangeSet(unsigned portBmp, MV_U8 *da, MV_U8 *mask, unsigned int ri, unsigned int riMask, MV_BOOL finish);
 int mvPrsMacDaRangeDel(unsigned portBmp, MV_U8 *da, MV_U8 *mask);
 int mvPrsMacDropAllSet(int port, int add);
+int mvPrsMhSet(unsigned int portMap, unsigned short mh, unsigned short mh_mask, unsigned int ri, unsigned int riMask, MV_BOOL finish);
+int mvPrsMhDel(unsigned int portMap, unsigned short mh, unsigned short mh_mask);
 int mvPrsMcastDelAll(int port);
 int mvPrsMhRxSpecialSet(int port, unsigned short mh, int add);
 int mvPrsMacPromiscousSet(int port, int add);
 int mvPrsMacAllMultiSet(int port, int add);
 int mvPrsDebugBasicInit(void);
 int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask, int portBmp);
+int mvPrsFlowIdDel(int tid);
+int mvPrsFlowIdFirstFreeGet(void);
+int mvPrsFlowIdLastFreeGet(void);
+int mvPrsFlowIdRelease(int flowId);
 int mvPp2PrsTagModeSet(int port, int type);
 int mvPp2PrsEtypeDsaModeSet(int port, int extand);
 int mvPp2PrsEtypeDsaSet(unsigned int eType);
@@ -173,6 +239,7 @@ int mvPp2PrsSingleVlan(unsigned short tpid, unsigned int portBmp, int add);
 int mvPp2PrsVlanAllDel(void);
 char *mvPrsVlanInfoStr(unsigned int vlan_info);
 char *mvPrsL2InfoStr(unsigned int l2_info);
+int mvPrsIp6NhSet(void);
 /*
 int mvPrsMacDaDrop(int port, unsigned char *da, int add);
 */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
index bfa5f3d..2e13447 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
@@ -74,6 +74,7 @@ static int mvPp2PrsSwSramAiDump(MV_PP2_PRS_ENTRY *pe);
 /*-------------------------------------------------------------------------------*/
 
 PRS_SHADOW_ENTRY  mvPrsShadowTbl[MV_PP2_PRS_TCAM_SIZE];
+int  mvPrsFlowIdTbl[MV_PP2_PRS_FLOW_ID_SIZE];
 /******************************************************************************
  * Common utilities
  ******************************************************************************/
@@ -152,6 +153,41 @@ void mvPp2PrsShadowClearAll(void)
 
 }
 
+int mvPrsFlowIdGet(int flowId)
+{
+	return mvPrsFlowIdTbl[flowId];
+}
+
+void mvPrsFlowIdSet(int flowId)
+{
+	mvPrsFlowIdTbl[flowId] = MV_TRUE;
+}
+
+void mvPrsFlowIdClear(int flowId)
+{
+	mvPrsFlowIdTbl[flowId] = MV_FALSE;
+}
+
+void mvPrsFlowIdClearAll(void)
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_PRS_FLOW_ID_SIZE; index++)
+		mvPrsFlowIdTbl[index] = MV_FALSE;
+}
+
+int mvPrsFlowIdDump(void)
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_PRS_FLOW_ID_SIZE; index++) {
+		if (mvPrsFlowIdGet(index) == MV_TRUE)
+			mvOsPrintf("Flow ID[%d]: In_USE\n", index);
+	}
+
+	return MV_OK;
+}
+
 static int mvPp2PrsFirstFreeGet(int from, int to)
 {
 	int tid;
@@ -637,6 +673,27 @@ int mvPp2PrsSwTcamWordSet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int
 	return MV_OK;
 }
 
+int mvPp2PrsSwTcamWordGet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int *word, unsigned int *enable)
+{
+	int index, offset;
+	unsigned char byte, mask;
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(word);
+	PTR_VALIDATE(enable);
+
+	POS_RANGE_VALIDATE(offs, TCAM_DATA_WORD_MAX);
+
+	for (index = 0; index < DWORD_BYTES_LEN; index++) {
+		offset = (offs * DWORD_BYTES_LEN) + index;
+		mvPp2PrsSwTcamByteGet(pe, offset,  &byte, &mask);
+		((unsigned char *) word)[index] = byte;
+		((unsigned char *) enable)[index] = mask;
+	}
+
+	return MV_OK;
+}
+
 /* compare in sw.
 	return EQUALS if tcam_data[off]&tcam_mask[off] = byte
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
index 36eeb31..0fa7ace 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
@@ -223,6 +223,9 @@ reg 5 --> reg 0
 #define TCAM_INVALID				1
 #define TCAM_INV_WORD				5
 
+#define TCAM_DATA_BYTE_OFFS(_offs_)		(((_offs_) - ((_offs_) % 2)) * 2 + ((_offs_) % 2))
+#define TCAM_DATA_MASK_OFFS(_offs_)		(((_offs_) * 2) - ((_offs_) % 2)  + 2)
+#define TCAM_MASK_OFFS(_offs_)			((_offs_) + 2)
 
 /************************* SRAM structure **********************/
 /* convert bit offset to byte offset */
@@ -365,8 +368,8 @@ reg 5 --> reg 0
 #define RI_L3_ADDR_MASK					(((1 << RI_L3_ADDR_BITS) - 1) << RI_L3_ADDR_OFFS)
 #define RI_L3_UCAST            				(0 << RI_L3_ADDR_OFFS)
 #define RI_L3_MCAST            				(1 << RI_L3_ADDR_OFFS)
-#define RI_L3_BCAST            				(2 << RI_L3_ADDR_OFFS)
-#define RI_L3_ANYCAST           			(3 << RI_L3_ADDR_OFFS)
+#define RI_L3_ANYCAST					(2 << RI_L3_ADDR_OFFS)
+#define RI_L3_BCAST					(3 << RI_L3_ADDR_OFFS)
 
 /* bit 17 */
 #define RI_IP_FRAG_BIT					17
@@ -381,6 +384,8 @@ reg 5 --> reg 0
 #define RI_UDF3_OFFS					20
 #define RI_UDF3_BITS					2
 #define RI_UDF3_MASK					(((1 << RI_UDF3_BITS) - 1) << RI_UDF3_OFFS)
+#define RI_UDF3_RX_SPEC_VAL				2
+#define RI_UDF3_RX_SPECIAL				(RI_UDF3_RX_SPEC_VAL << RI_UDF3_OFFS)
 
 /* Bits 22 - 24 */
 #define RI_L4_PROTO_OFFS				22
@@ -405,6 +410,7 @@ reg 5 --> reg 0
 #define RI_UDF7_OFFS					29
 #define RI_UDF7_BITS					2
 #define RI_UDF7_MASK					(((1 << RI_UDF7_BITS) - 1) << RI_UDF7_OFFS)
+#define RI_UDF7_IP6_LITE				(1 << RI_UDF7_OFFS)/* Indicates DS lite, in A0 version */
 
 /* bit 31 - drop */
 #define RI_DROP_BIT					31
@@ -450,6 +456,11 @@ void mvPp2PrsShadowFinSet(int index, MV_BOOL finish); /* set bit 111 (GEN_BIT) i
 MV_BOOL mvPp2PrsShadowFin(int index);
 void mvPp2PrsShadowClear(int index);
 void mvPp2PrsShadowClearAll(void);
+int mvPrsFlowIdGet(int flowId);
+void mvPrsFlowIdSet(int flowId);
+void mvPrsFlowIdClear(int flowId);
+void mvPrsFlowIdClearAll(void);
+int mvPrsFlowIdDump(void);
 int mvPp2PrsShadowLu(int index);
 int mvPp2PrsShadowIsValid(int index);
 int mvPp2PrsTcamFirstFree(int start, int end);
@@ -460,7 +471,11 @@ int mvPp2PrsTcamFirstFree(int start, int end);
 /*-------------------------------------------------------------------------------*/
 
 /* Parser Public TCAM APIs */
-#define MV_PP2_PRS_TCAM_SIZE 				(256)
+#define MV_PP2_PRS_TCAM_SIZE				(256)
+
+#define MV_PP2_PRS_FLOW_ID_SIZE				(64)
+#define MV_PP2_PRS_FIRST_FLOW_ID			(8) /* Flow ID 0~7 are reserved by LSP */
+#define MV_PP2_PRS_LAST_FLOW_ID				(64 - 1 - 4) /* Flow ID 60~63 are reserved by HW */
 
 #define MV_PP2_PRC_TCAM_WORDS				6
 #define MV_PP2_PRC_SRAM_WORDS				4
-- 
1.7.5.4

