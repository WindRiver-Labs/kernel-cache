From 60e53fe14770e99c18def93aa1b8ec9ccd58ad25 Mon Sep 17 00:00:00 2001
From: orenbh <orenbh@marvell.com>
Date: Tue, 10 Jun 2014 14:46:07 +0300
Subject: [PATCH 1720/1825] fix: prestera: axp: Add support for Hooper

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4fea1d9fcf68b557f9ed37aabe410fa2dab6819e

        Add support for PCI switch configuration required for Hooper DB (Lion2)
        Update Prestera PCI driver to support Lion2

	Add support for IDT PCI Switch on Hooper RD
	Update IDT PCI Switch bridge window configuration
	Update support for interrupts

Change-Id: I3f29d5bfca143a519c0aff2847a42f4b460e65d7
Signed-off-by: orenbh <orenbh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8470
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/kernel/setup.c                            |    5 +
 arch/arm/mach-armadaxp/include/mach/armadaxp.h     |    2 +-
 arch/arm/plat-armada/common/mvDeviceId.h           |    7 +
 .../mv_drivers_lsp/mv_prestera/Makefile            |    2 +-
 .../mv_drivers_lsp/mv_prestera/mv_prestera.c       |  145 ++++++++---
 .../mv_drivers_lsp/mv_prestera/mv_prestera.h       |   31 ++-
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pci.c   |  170 +++++++----
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pci.h   |   27 ++
 .../mv_prestera/mv_prestera_pci_switch.c           |  299 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c |    2 +-
 .../mv_drivers_lsp/mv_prestera/mv_pss_api.c        |   43 ++-
 .../mv_drivers_lsp/mv_prestera/mv_pss_api.h        |   31 ++-
 12 files changed, 651 insertions(+), 113 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci_switch.c

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 69ed77ff..dcdf88b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -707,7 +707,12 @@ __tagtable(ATAG_CORE, parse_tag_core);
 
 static int __init parse_tag_mem32(const struct tag *tag)
 {
+#ifndef CONFIG_MV_INCLUDE_PRESTERA_PCI
 	return arm_add_memory(read_tag(tag->u.mem.start), read_tag(tag->u.mem.size));
+#else
+	/* limit pte's and leave room to ioremap of PP's (especially lion2 16 regions) */
+	return arm_add_memory(read_tag(tag->u.mem.start), 256*1024*1024);
+#endif
 }
 
 __tagtable(ATAG_MEM, parse_tag_mem32);
diff --git a/arch/arm/mach-armadaxp/include/mach/armadaxp.h b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
index 276cd8a..7a1cf7a 100755
--- a/arch/arm/mach-armadaxp/include/mach/armadaxp.h
+++ b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
@@ -309,7 +309,7 @@
  */
 
 #define PEX0_MEM_PHYS_BASE		0x80000000
-#define PEX0_MEM_SIZE			_128M
+#define PEX0_MEM_SIZE			(_512M)
 #define PEX1_MEM_PHYS_BASE		0x88000000
 #define PEX1_MEM_SIZE			0x0
 #define PEX2_MEM_PHYS_BASE		0x88000000
diff --git a/arch/arm/plat-armada/common/mvDeviceId.h b/arch/arm/plat-armada/common/mvDeviceId.h
index cd5df1e..aee35e2 100644
--- a/arch/arm/plat-armada/common/mvDeviceId.h
+++ b/arch/arm/plat-armada/common/mvDeviceId.h
@@ -402,9 +402,16 @@ extern "C" {
 /* BobCat2  Family */
 #define MV_BOBCAT2_DEV_ID		0xFC00
 
+ /* Lion2  Family */
+#define MV_LION2_DEV_ID		0x8000
+
 /* AlleyCat3  Family */
 #define MV_ALLEYCAT3_DEV_ID		0xF400
 
+ /* IDT Swicth  */
+#define PCI_VENDOR_ID_IDT_SWITCH	0x111D
+#define MV_IDT_SWITCH_DEV_ID_808E	0x808E
+#define MV_IDT_SWITCH_DEV_ID_802B	0x802B
 
 #ifdef __cplusplus
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
index c9d4fdc..431d38d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
@@ -7,6 +7,6 @@ endif
 
 
 obj-$(CONFIG_MV_INCLUDE_PRESTERA)	+= mvPrestera.o mv_prestera_pltfm.o
-obj-$(CONFIG_MV_INCLUDE_PRESTERA_PCI)	+= mvPrestera.o mv_prestera_pci.o
+obj-$(CONFIG_MV_INCLUDE_PRESTERA_PCI)	+= mvPrestera.o mv_prestera_pci.o mv_prestera_pci_switch.o
 mvPrestera-objs				+= mv_prestera.o mv_prestera_irq.o mv_prestera_smi.o mv_pss_api.o
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
index ed40ebb..613f6bb 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
@@ -103,8 +103,32 @@
 #define DB(x)
 #endif
 
+/* Fixed only for LION2 - require added for all devices*/
+struct prvPciDeviceQuirks quirks = {
+	PCI_DEV_LION2_DEV_ID,
+	PCI_DEV_LION2_PEX_EN,
+	PCI_DEV_LION2_CONFIG_OFFSET,
+	PCI_DEV_LION2_CONFIG_SIZE,
+	PCI_DEV_LION2_RESOURCE_REG,
+	PCI_DEV_LION2_DFX
+};
+
+/* BOBCAT2 / ALLEYCAT3 use default interrupt - 0
+** LION2 use interrupt mapping
+** should be supported for all devices
+*/
+unsigned int pciDevInterruptMappingArray[PCI_DEV_INTR_MAX_NUM] = {
+	PCI_DEV_DEF_INTR_NUM,
+	PCI_DEV_LION2_PP_1_INTR_NUM,
+	PCI_DEV_LION2_PP_2_INTR_NUM,
+	PCI_DEV_LION2_PP_3_INTR_NUM,
+	PCI_DEV_LION2_PP_4_INTR_NUM,
+	PCI_DEV_DEF_INTR_NUM,
+	PCI_DEV_DEF_INTR_NUM,
+	PCI_DEV_DEF_INTR_NUM
+};
 
-unsigned long			dma_base;
+unsigned long		dma_base;
 
 /* local variables and variables */
 static int			dev_open_nr;
@@ -112,6 +136,7 @@ static int			dev_init_done;
 static struct prestera_device	*prestera_dev;
 static int			prestera_major = PRESTERA_MAJOR;
 static struct cdev		prestera_cdev;
+static int			prestera_ppdev;
 static const char		*prestera_dev_name = "mvPP";
 static int unsigned long	pci_phys_addr[PRV_MAX_PP_DEVICES];
 static int			pci_phys_blocks;
@@ -123,6 +148,7 @@ static void			*dma_tmp_virt;
 static dma_addr_t		dma_tmp_phys;
 
 
+
 /************************************************************************
  *
  * prestera_mapped_virt2phys: convert userspace address to physical
@@ -333,7 +359,7 @@ static void ioctl_cmd_pr(unsigned int cmd)
 		dir = "*ERR*"; break;
 	}
 	mvOsPrintf("got ioctl '%c', dir=%s, #%d (0x%08x) ",
-		   _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);
+		_IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);
 
 	if (_IOC_NR(cmd) < PRESTERA_IOCTLS)
 		mvOsPrintf("%s\n", prestera_ioctls[_IOC_NR(cmd)]);
@@ -357,8 +383,10 @@ static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 	struct GT_DmaReadWrite_STC	dmaRWparams;
 	struct GT_TwsiReadWrite_STC	twsiRWparams;
 	unsigned long			temp_len;
+	unsigned long			intrline;
 	struct GT_PCI_Mapping_STC	mapping;
 
+
 	if (_IOC_TYPE(cmd) == PRESTERA_SMI_IOC_MAGIC)
 		return prestera_smi_ioctl(cmd, arg);
 
@@ -463,7 +491,7 @@ static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 		gtDev.devSel = dev->devSel;
 		gtDev.funcNo = dev->funcNo;
 
-		DB(mvOsPrintf("PCI_FIND_DEV: pci? %d bus# %ld devSel %ld func# %ld vendId 0x%X devId 0x%X inst %ld\n",
+		DB(mvOsPrintf("PCI_FIND_DEV: pci? %d bus# %ld devSel %ld func# %ld vendId 0x%X devId 0x%X inst %lx\n",
 			      dev->on_pci_bus, gtDev.busNo, gtDev.devSel,
 			      gtDev.funcNo, gtDev.vendorId, gtDev.devId, gtDev.instance));
 
@@ -525,10 +553,6 @@ static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 		if (i == founddevs)
 			return -ENODEV;
 
-		DB(mvOsPrintf("PCI_CONFIG_WRITE_REG: is_pci %d busNo %ld devSel %ld funcNo %ld regAddr %ld data %ld\n",
-			      dev->on_pci_bus, pciConfReg.busNo, pciConfReg.devSel,
-			      pciConfReg.funcNo, pciConfReg.regAddr, pciConfReg.data));
-
 		if (dev->on_pci_bus) {
 			if (bspPciConfigWriteReg(pciConfReg.busNo, pciConfReg.devSel,
 						  pciConfReg.funcNo, pciConfReg.regAddr,
@@ -570,10 +594,6 @@ static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			}
 		}
 
-		DB(mvOsPrintf("PCI_CONFIG_READ_REG: is_pci %d busNo %ld devSel %ld funcNo %ld regAddr %ld data %ld\n",
-			      dev->on_pci_bus, pciConfReg.busNo, pciConfReg.devSel,
-			      pciConfReg.funcNo, pciConfReg.regAddr, pciConfReg.data));
-
 		if (copy_to_user((struct PciConfigReg_STC *)arg, &pciConfReg, sizeof(struct PciConfigReg_STC))) {
 			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
 			return -EFAULT;
@@ -587,7 +607,15 @@ static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long ar
 			return -EFAULT;
 		}
 
-		if (MV_OK != bspPciGetIntVec(int2vec.intrLine, (void *)&int2vec.vector)) {
+		if (prestera_ppdev == MV_LION2_DEV_ID) {
+			if (int2vec.intrLine < PCI_DEV_INTR_MAX_NUM)
+				intrline = pciDevInterruptMappingArray[int2vec.intrLine];
+			else
+				return -EFAULT;
+		} else
+			intrline = PCI_DEV_DEF_INTR_NUM;
+
+		if (MV_OK != bspPciGetIntVec(intrline, (void *)&int2vec.vector)) {
 			mvOsPrintf(KERN_ERR "bspPciGetIntVec failed\n");
 			return -EFAULT;
 		}
@@ -1144,19 +1172,33 @@ static void prestera_cleanup(void)
 	unregister_chrdev_region(MKDEV(prestera_major, 0), 1);
 }
 
-static uint32_t *get_instance(unsigned short vendorId, unsigned short devId)
+static uint32_t get_instance(unsigned short vendorId, unsigned short devId)
 {
 	static uint32_t bobcat2_instance;
+	static uint32_t lion2_instance;
 	static uint32_t ac3_instance;
+	uint32_t instance = 0;
 
 	switch (devId) {
-	case MV_BOBCAT2_DEV_ID:
-		return &bobcat2_instance;
-	case MV_ALLEYCAT3_DEV_ID:
-		return &ac3_instance;
+	case MV_BOBCAT2_DEV_ID: {
+		instance = bobcat2_instance;
+		bobcat2_instance++;
+		break;
+		}
+	case MV_LION2_DEV_ID:{
+		instance = lion2_instance;
+		lion2_instance++;
+		break;
+		}
+	case MV_ALLEYCAT3_DEV_ID:{
+		instance = ac3_instance;
+		ac3_instance++;
+		break;
+		}
 	default:
-		return NULL;
+		instance = -1;
 	}
+	return instance;
 }
 
 /*
@@ -1164,20 +1206,21 @@ static uint32_t *get_instance(unsigned short vendorId, unsigned short devId)
  * it will be enough for CPSS to remove instance variable and assign founddevs
  * to ppdev->instance - will be check during multi-switch configuration tests
  */
-int ppdev_conf_set(struct pp_dev *ppdev)
+int ppdev_conf_set(struct pci_dev *pdev, struct pp_dev *ppdev)
 {
-	uint32_t *instance;
+	uint32_t instance;
+	int start, len;
 	static uintptr_t config_map_base = CPSS_CPU_VIRT_ADDR;
 
 	DB(mvOsPrintf("%s\n", __func__));
 
 	instance = get_instance(ppdev->vendorId, ppdev->devId);
-	if (!(instance)) {
+	if (instance == (-1)) {
 		mvOsPrintf(KERN_ERR "%s: instance get failed\n", __func__);
 		return -ENODEV;
 	}
 
-	ppdev->instance = *instance++;
+	ppdev->instance = instance;
 
 	/* SWITCH register address space mapping */
 	ppdev->ppregs.mmapbase = (uintptr_t)(CPSS_SWITCH_VIRT_ADDR + (pci_phys_blocks << 26));
@@ -1186,28 +1229,64 @@ int ppdev_conf_set(struct pp_dev *ppdev)
 	/* Save phys address */
 	pci_phys_addr[pci_phys_blocks++] = ppdev->ppregs.phys;
 
-	/* INTER_REGS address space mapping */
-	ppdev->config.mmapbase = config_map_base;
-	config_map_base += ppdev->config.size;
-	ppdev->config.mmapoffset = 0;
+	if (pdev == NULL /* MSYS */) {
+		/* INTER_REGS address space mapping */
+		ppdev->config.mmapbase = config_map_base;
+		ppdev->config.mmapoffset = 0;
+		config_map_base += ppdev->config.size;
+	} else {
+		if ((pdev->device == MV_BOBCAT2_DEV_ID)  ||
+		(pdev->device == MV_ALLEYCAT3_DEV_ID)) {
+			/* INTER_REGS address space mapping */
+			ppdev->config.mmapbase = config_map_base;
+			ppdev->config.mmapoffset = 0;
+			config_map_base += ppdev->config.size;
+		} else if (pdev->device == MV_LION2_DEV_ID) {
+			/* Quirks support is fixed to LION2 and should be extended to all devices */
+			if (ppdev->config.allocsize > quirks.configOffset) {
+				start = ppdev->config.phys;
+				len    = ppdev->config.size;
+
+				start += quirks.configOffset;
+				len   -= quirks.configOffset;
+
+				ppdev->config.phys = start;
+				ppdev->config.size = len;
+
+				ppdev->config.mmapbase = config_map_base;
+				ppdev->config.mmapoffset = quirks.configOffset;
+
+				config_map_base += len;
+				ppdev->config.base = (uintptr_t)ioremap_nocache(start, len);
+			} else {
+				/* INTER_REGS address space mapping */
+				ppdev->config.mmapbase = config_map_base;
+				ppdev->config.mmapoffset = 0;
+				config_map_base += ppdev->config.size;
+			}
+		}
+	}
 
 	/* Only for debug purpose */
 	DB(mvOsPrintf("%s:pdev: devId 0x%x, vendorId 0x%x, instance 0x%lx\n",
-	    __func__, ppdev->devId, ppdev->vendorId, ppdev->instance));
+			__func__, ppdev->devId, ppdev->vendorId, ppdev->instance));
 	DB(mvOsPrintf("pdev: busNo 0x%lx, devSel 0x%lx, funcNo 0x%lx\n",
-	    ppdev->busNo, ppdev->devSel, ppdev->funcNo));
+			ppdev->busNo, ppdev->devSel, ppdev->funcNo));
 	DB(mvOsPrintf("ppregs:  allocbase 0x%lx, allocsize 0x%lx, size 0x%lx",
-	    ppdev->ppregs.allocbase, ppdev->ppregs.allocsize, ppdev->ppregs.size));
+			ppdev->ppregs.allocbase, ppdev->ppregs.allocsize, ppdev->ppregs.size));
 	DB(mvOsPrintf("ppregs: phys 0x%lx, base0x%lx, mmapbase0x%lx, mmapoffset 0x%x\n",
-	    ppdev->ppregs.phys, ppdev->ppregs.base, ppdev->ppregs.mmapbase,
-	    ppdev->ppregs.mmapoffset));
+			ppdev->ppregs.phys, ppdev->ppregs.base, ppdev->ppregs.mmapbase,
+			ppdev->ppregs.mmapoffset));
 	DB(mvOsPrintf("config: phys 0x%lx, base0x%lx, mmapbase0x%lx, mmapoffset 0x%x\n",
-	    ppdev->config.phys, ppdev->config.base, ppdev->config.mmapbase,
-	    ppdev->config.mmapoffset));
+			ppdev->config.phys, ppdev->config.base, ppdev->config.mmapbase,
+			ppdev->config.mmapoffset));
 
 	/* Add device to ppdevs */
 	ppdevs[founddevs++] = ppdev;
 
+	if (pdev != NULL)
+		prestera_ppdev = pdev->device;
+
 	return 0;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
index 4c90ced..5228c64 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
@@ -85,7 +85,7 @@
 #define PRESTERA_MAJOR		244   /* major number */
 #endif
 
-#define PRV_MAX_PP_DEVICES	3
+#define PRV_MAX_PP_DEVICES	4
 
 /* Switch registers & reg values */
 #define PP_UDID				(0x00000204)		/* Unit default ID reg	*/
@@ -139,8 +139,35 @@ struct pp_dev {
 #endif
 };
 
+/* Register offset definition struct */
+struct prvPciDeviceQuirks {
+	unsigned int	pciId;
+	unsigned int	isPex;
+	unsigned int	configOffset;
+	unsigned int	configSize;
+	int		pciResourceReg;
+	unsigned int		hasDfx;
+};
+
+/* LION2 Specific definition for register access */
+/* Should be included for all devices */
+#define PCI_DEV_LION2_DEV_ID	0x800011AB
+#define PCI_DEV_LION2_CONFIG_OFFSET	0x70000
+#define PCI_DEV_LION2_CONFIG_SIZE	0x10000
+#define PCI_DEV_LION2_PEX_EN	1
+#define PCI_DEV_LION2_DFX	0
+#define PCI_DEV_LION2_RESOURCE_REG	2
+
+#define PCI_DEV_INTR_MAX_NUM	8
+#define PCI_DEV_DEF_INTR_NUM	0
+#define PCI_DEV_LION2_PP_1_INTR_NUM	3
+#define PCI_DEV_LION2_PP_2_INTR_NUM	2
+#define PCI_DEV_LION2_PP_3_INTR_NUM	1
+#define PCI_DEV_LION2_PP_4_INTR_NUM	0
+
+
 int prestera_init(void);
-int ppdev_conf_set(struct pp_dev *ppdev);
+int ppdev_conf_set(struct pci_dev *pdev, struct pp_dev *ppdev);
 extern unsigned long		dma_base;
 
 #endif /* __MV_PRESTERA */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
index 51f0308..915a057 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.c
@@ -82,6 +82,7 @@
 
 #include "mv_prestera.h"
 #include "mv_prestera_pci.h"
+#include "mv_pss_api.h"
 
 #undef MV_PP_PCI_DBG
 
@@ -271,13 +272,17 @@ static void mv_pci_dma_switch_init(unsigned long switch_reg, struct pci_dev *pde
 	dprintk("read pp: 0x%x\n", readl(switch_reg | PP_WIN_CTRL(0)));
 
 	/* Debug dma reg - according to old code in
-	 * arch/arm/mach-armadaxp/pss/hwServices.c
-	 */
+	* arch/arm/mach-armadaxp/pss/hwServices.c
+	*/
 	writel(0xaaba,	switch_reg | 0x2684);
 	dprintk("%s read pp: 0x%x\n", __func__, readl(switch_reg | 0x2684));
 
 }
 
+/**
+ * @param pdev
+ * @return int
+ */
 static int mv_ppdev_conf_set_pci(struct pci_dev *pdev)
 {
 	struct pp_dev	*ppdev;
@@ -308,11 +313,14 @@ static int mv_ppdev_conf_set_pci(struct pci_dev *pdev)
 	dprintk("%s: irq: %d\n", __func__, ppdev->irq);
 #endif
 
-
 	/* Configure the SWITCH register address space */
-	/* Additional 1MB is reserved for DFX registers */
+	/* Additional 1MB is reserved for DFX registers - Bobcat2 / Alleycat3 */
+	/* Lion2 does not have DFX */
 	start = pci_resource_start(pdev, MV_PCI_BAR_1);
-	len =  pci_resource_len(pdev, MV_PCI_BAR_1) + _1M;
+	if (pdev->device != MV_LION2_DEV_ID) /*  MV_BOBCAT2_DEV_ID / MV_ALLEYCAT3_DEV_ID */
+		len =  pci_resource_len(pdev, MV_PCI_BAR_1) + _1M;
+	else
+		len =  pci_resource_len(pdev, MV_PCI_BAR_1);
 
 	ppdev->ppregs.allocbase = start;
 	ppdev->ppregs.allocsize = len;
@@ -330,7 +338,7 @@ static int mv_ppdev_conf_set_pci(struct pci_dev *pdev)
 	ppdev->config.phys = start;
 	ppdev->config.base = (unsigned long)iomap[MV_PCI_BAR_INTER_REGS];
 
-	err = ppdev_conf_set(ppdev);
+	err = ppdev_conf_set(pdev, ppdev);
 	if (err)
 		return err;
 
@@ -389,75 +397,108 @@ static int mv_reconfig_bars(struct pci_dev *pdev)
 static int prestera_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	int err;
-	void __iomem * const *iomap;
-	void __iomem *switch_reg;
-
-	dprintk("%s: started\n", __func__);
-
-	/*
-	 * Reconfigure and reassign bars:
-	 *  BAR0: 1MB  for INTER REGS (fixed size, no configuration needed)
-	 *  BAR1: 64MB for SWITCH REGS
-	 *  BAR2: 1MB  for DFX REGS
-	 */
-	err = mv_reconfig_bars(pdev);
-	if (err != 0)
-		return err;
-
-	err = pcim_enable_device(pdev);
-	if (err)
-		return err;
-
-	err = pcim_iomap_regions(pdev, (1 << MV_PCI_BAR_INTER_REGS) |
-	      (1 << MV_PCI_BAR_1) | (1 << MV_PCI_BAR_2), prestera_drv_name);
-	if (err)
-		return err;
-
-	iomap = pcim_iomap_table(pdev);
+	static int pexSwitchConfigure;
+	void __iomem * const *iomap = NULL;
+	void __iomem *switch_reg = NULL;
 
-	inter_regs = iomap[MV_PCI_BAR_INTER_REGS];
-	switch_reg = iomap[MV_PCI_BAR_1];
-
-	dprintk("inter_regs: %p, bar1: %p, bar2: %p\n",
-		iomap[MV_PCI_BAR_INTER_REGS], iomap[MV_PCI_BAR_1],
-		iomap[MV_PCI_BAR_2]);
-
-	/*
-	 * Configure decoding windows for BARs:
-	 *  BAR0 points to INTER REGS (dedicated to internal regs by default)
-	 *  BAR1 points to SWITCH REGS
-	 *  BAR2 points to DFX REGS
-	 */
-
-	err = mv_configure_win_bar(BAR_2, pdev);
-	if (err)
-		return err;
-	dprintk("%s: decoding win for: BAR2 <- DFX(1MB) configured\n",
-		__func__);
+	switch (pdev->device) {
 
-	err = mv_configure_win_bar(BAR_1, pdev);
-	if (err)
-		return err;
-	dprintk("%s: decoding win for: BAR1 <- SWITCH(64MB) configured\n",
-		__func__);
+	case MV_IDT_SWITCH_DEV_ID_808E:
+	case MV_IDT_SWITCH_DEV_ID_802B:
+		if (pexSwitchConfigure == 0) {
+			mv_verify_idt_switch_config();
+			pexSwitchConfigure++;
+		}
+		return 0;
 
-	mv_enable_switch_irq(pdev);
+	case MV_BOBCAT2_DEV_ID:
+	case MV_ALLEYCAT3_DEV_ID:
+		/*
+		* Reconfigure and reassign bars
+		*  BAR0: 1MB  for INTER REGS (fixed size, no configuration needed)
+		*  BAR1: 64MB for SWITCH REGS
+		*  BAR2: 1MB  for DFX REGS
+		*/
+		err = mv_reconfig_bars(pdev);
+		 if (err != 0)
+			return err;
+
+		 err = pcim_enable_device(pdev);
+		 if (err)
+			return err;
+
+		 err = pcim_iomap_regions(pdev, (1 << MV_PCI_BAR_INTER_REGS) |
+				 (1 << MV_PCI_BAR_1) | (1 << MV_PCI_BAR_2), prestera_drv_name);
+		 if (err)
+			return err;
+		 iomap = pcim_iomap_table(pdev);
+		 inter_regs = iomap[MV_PCI_BAR_INTER_REGS];
+		 switch_reg = iomap[MV_PCI_BAR_1];
+
+		 dprintk("inter_regs: %p, bar1: %p, bar2: %p\n",
+			 iomap[MV_PCI_BAR_INTER_REGS], iomap[MV_PCI_BAR_1],
+			 iomap[MV_PCI_BAR_2]);
+
+		 /*
+		* Configure decoding windows for BARs:
+		*  BAR0 points to INTER REGS (dedicated to internal regs by default)
+		*  BAR1 points to SWITCH REGS
+		*  BAR2 points to DFX REGS
+		*/
+
+		 err = mv_configure_win_bar(BAR_2, pdev);
+		 if (err)
+			return err;
+		 dprintk("%s: decoding win for: BAR2 <- DFX(1MB) configured\n", __func__);
+
+		 err = mv_configure_win_bar(BAR_1, pdev);
+		 if (err)
+			return err;
+		 dprintk("%s: decoding win for: BAR1 <- SWITCH(64MB) configured\n", __func__);
+
+		 mv_enable_switch_irq(pdev);
+
+		 break;
+
+	case MV_LION2_DEV_ID:
+		/*
+		*Configure decoding windows for BARs:
+		*  BAR0: 1MB  for INTER REGS (fixed size, no configuration needed)
+		*  BAR1: 64MB for SWITCH REGS
+		*/
+		err = pcim_enable_device(pdev);
+		if (err)
+			return err;
+		err = pcim_iomap_regions(pdev, ((1 << MV_PCI_BAR_INTER_REGS) |
+						(1 << MV_PCI_BAR_1)), prestera_drv_name);
+		if (err)
+			return err;
+			iomap = pcim_iomap_table(pdev);
+			inter_regs  = iomap[MV_PCI_BAR_INTER_REGS];
+			switch_reg = iomap[MV_PCI_BAR_1];
+			dprintk("inter_regs: %p, bar1: %p\n",
+				iomap[MV_PCI_BAR_INTER_REGS], iomap[MV_PCI_BAR_1]);
+		break;
+	default:
+		 dprintk("%s: unsupported device\n", __func__);
+	}
 
 	err = mv_ppdev_conf_set_pci(pdev);
 	if (err)
 		return err;
-
 	/*
-	 * Call existing mvPP driver, if already initialized it will return 0
-	 */
+	* Call existing mvPP driver, if already initialized it will return 0
+	*/
 	err = prestera_init();
 	if (err)
 		return err;
 
-	mv_pci_dma_switch_init((unsigned long)switch_reg, pdev);
-
-	dprintk("DFX test %x and should be ..357\n",
-		readl(iomap[MV_PCI_BAR_2] + DFX_JTAG_DEVID_STAT));
+	/* MV_BOBCAT2_DEV_ID /  MV_ALLEYCAT3_DEV_ID */
+	if (pdev->device  != MV_LION2_DEV_ID) {
+		mv_pci_dma_switch_init((unsigned long)switch_reg, pdev);
+		dprintk("DFX test %x and should be ..357\n",
+			readl(iomap[MV_PCI_BAR_2] + DFX_JTAG_DEVID_STAT));
+		}
 
 	dev_info(&pdev->dev, "%s init completed\n", prestera_drv_name);
 	return 0;
@@ -470,7 +511,10 @@ static void prestera_pci_remove(struct pci_dev *pdev)
 
 static DEFINE_PCI_DEVICE_TABLE(prestera_pci_tbl) = {
 	/* Marvell */
+	{ PCI_DEVICE(PCI_VENDOR_ID_IDT_SWITCH, MV_IDT_SWITCH_DEV_ID_808E)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_IDT_SWITCH, MV_IDT_SWITCH_DEV_ID_802B)},
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, MV_BOBCAT2_DEV_ID)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, MV_LION2_DEV_ID)},
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, MV_ALLEYCAT3_DEV_ID)},
 	{}
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
index 583ba51..04460c9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci.h
@@ -88,4 +88,31 @@ enum {
 #define PP_PCI_UDID_DATTR		(PP_PCI_ATTR << 4 | PP_PCI_TARGETID)
 #define PP_PCI_BA_ATTR			(PP_PCI_ATTR << 8 | PP_PCI_TARGETID)
 
+
+/* LION2 Specific definition */
+#define LION_MAX_NUM_OF_PP	(4)
+
+/* IDT Switch definition */
+#define MV_IDT_SWITCH_MAX_NUM_OF_PORT	(LION_MAX_NUM_OF_PP)
+
+#define MV_IDT_SWITCH_PCI_MEM_BASE_REG	(0x20)
+#define MV_IDT_SWITCH_PCI_MEM_BASE_REG_MASK	(0xFFFF0000)
+#define MV_IDT_SWITCH_PCI_MEM_BASE_REG_SHIFT	(16)
+#define MV_IDT_SWITCH_PCI_LINK_STATUS_REG	(0x52)
+#define MV_IDT_SWITCH_PCI_LINK_STATUS_REG_ACTIVE_LINK	(0x2000)
+
+struct idtSwitchConfig {
+	unsigned int ppIdtSwitchUsBusNum;
+	unsigned int ppIdtSwitchDsBusNum;
+	unsigned int numOfPpInstances;
+
+	struct {
+		unsigned long startAddr[MV_IDT_SWITCH_MAX_NUM_OF_PORT];
+		unsigned long endAddr[MV_IDT_SWITCH_MAX_NUM_OF_PORT];
+		unsigned int ppBusNumArray[MV_IDT_SWITCH_MAX_NUM_OF_PORT];
+		unsigned int ppIdtSwitchDsPpDevices[MV_IDT_SWITCH_MAX_NUM_OF_PORT];
+	} idtSwPortCfg;
+};
+
+void mv_verify_idt_switch_config(void);
 #endif /* __MV_PRESTERA_PCI_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci_switch.c
new file mode 100644
index 0000000..97914a6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pci_switch.c
@@ -0,0 +1,299 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "pex/mvPexRegs.h"
+#include "mvSysPexApi.h"
+#include "mv_prestera.h"
+#include "mv_prestera_pci.h"
+#include "mv_pss_api.h"
+
+/* Global variables */
+static struct idtSwitchConfig idtSwCfg;
+
+/*******************************************************************************
+*	mv_calc_device_address_range
+*
+*	DESCRIPTION:
+*			Scan device bars and calc address range
+*
+*	INPUTS:
+*			struct pci_dev *dev
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+*	COMMENTS:
+*			None
+*
+*******************************************************************************/
+static void mv_calc_device_address_range(struct pci_dev *dev,  unsigned int devInstance)
+{
+	unsigned int i = 0;
+	unsigned long startAddr, endAddr;
+	unsigned long tempStartAddr, tempEndAddr;
+
+	startAddr = pci_resource_start(dev, i);
+	endAddr = pci_resource_end(dev, i);
+
+	for (i = 2; i < PCI_STD_RESOURCE_END; i += 2) {
+		tempStartAddr = pci_resource_start(dev, i);
+		tempEndAddr = pci_resource_end(dev, i);
+
+		if ((tempStartAddr != 0) && (tempEndAddr != 0)) {
+			if (tempStartAddr < startAddr)
+				startAddr = tempStartAddr;
+			if (tempEndAddr > endAddr)
+				endAddr = tempEndAddr;
+		}
+	}
+
+	idtSwCfg.idtSwPortCfg.startAddr[devInstance] = startAddr;
+	idtSwCfg.idtSwPortCfg.endAddr[devInstance] = endAddr;
+}
+
+/*******************************************************************************
+*	mv_find_pci_dev_pp_instances
+*
+*	DESCRIPTION:
+*			Scan for PCI devices
+*			Search for first instance if IDT Switch - defined as Uplink Bus
+*			Search for second instance if IDT Switch - defined as Downlink Bus
+*			Search for Marvell devices - count and save for further processing
+*
+*	INPUTS:
+*			None
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+*	COMMENTS:
+*			None
+*
+*******************************************************************************/
+static void mv_find_pci_dev_pp_instances(void)
+{
+	struct pci_dev *dev = NULL;
+	int instance = 0;
+
+	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		if (dev->vendor == PCI_VENDOR_ID_IDT_SWITCH) {
+			if (instance == 0)
+				idtSwCfg.ppIdtSwitchUsBusNum = dev->bus->number;
+			else if (instance == 1)
+				idtSwCfg.ppIdtSwitchDsBusNum = dev->bus->number;
+			instance++;
+			}
+		else if (dev->vendor == MARVELL_VEN_ID) {
+			mv_calc_device_address_range(dev, idtSwCfg.numOfPpInstances);
+			idtSwCfg.idtSwPortCfg.ppBusNumArray[idtSwCfg.numOfPpInstances] = dev->bus->number;
+			idtSwCfg.numOfPpInstances++;
+			}
+		}
+
+	if (idtSwCfg.numOfPpInstances >= LION_MAX_NUM_OF_PP)
+		bspSmiReadRegLionSpecificSet();
+}
+
+/*******************************************************************************
+*	mv_discover_active_pp_instances
+*
+*	DESCRIPTION:
+*			Locate the active downlink ports connected to IDT switch
+*			The idt switch downlink ports are 2 - (2 + ppInstance).
+*			ports 0 - 1 are for the IDT switch, define which idt port are connected to the pps
+*
+*	INPUTS:
+*			None
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+*	COMMENTS:
+*			None
+*
+*******************************************************************************/
+static void mv_discover_active_pp_instances(void)
+{
+	int i, num;
+	struct pci_dev *dev = NULL;
+	unsigned short pciLinkStatusRegVal;
+
+	for (num = 0, i = 0; num < idtSwCfg.numOfPpInstances; i++) {
+			dev = pci_get_bus_and_slot(idtSwCfg.ppIdtSwitchDsBusNum, PCI_DEVFN(i + 2, 0));
+			if (dev != NULL) {
+				pci_read_config_word(dev, (int)MV_IDT_SWITCH_PCI_LINK_STATUS_REG, &pciLinkStatusRegVal);
+				if (pciLinkStatusRegVal & MV_IDT_SWITCH_PCI_LINK_STATUS_REG_ACTIVE_LINK)
+					idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[num++] = i + 2;
+		}
+	}
+}
+
+/*******************************************************************************
+*	mv_configure_idt_switch_addr_range
+*
+*	DESCRIPTION:
+*
+*	INPUTS:
+*			None
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+* COMMENTS:
+*			None
+*
+*******************************************************************************/
+static void mv_configure_idt_switch_addr_range(void)
+{
+	int i;
+	int pexHWInf = 0;
+
+	/* Configure switch bridge window for DS switch ports connected to Marvell devices */
+	for (i = 0; i < idtSwCfg.numOfPpInstances; i++) {
+		mvPexConfigWrite(pexHWInf, idtSwCfg.ppIdtSwitchDsBusNum,
+				idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[i],
+				0, MV_IDT_SWITCH_PCI_MEM_BASE_REG,
+				((idtSwCfg.idtSwPortCfg.endAddr[i] &
+				MV_IDT_SWITCH_PCI_MEM_BASE_REG_MASK) |
+				(((idtSwCfg.idtSwPortCfg.startAddr[i]) &
+				MV_IDT_SWITCH_PCI_MEM_BASE_REG_MASK) >> 16)));
+	}
+
+	/* Configure switch bridge window for US switch port connected to PEX device */
+	mvPexConfigWrite(pexHWInf, idtSwCfg.ppIdtSwitchUsBusNum, 0, 0, MV_IDT_SWITCH_PCI_MEM_BASE_REG,
+				((idtSwCfg.idtSwPortCfg.endAddr[idtSwCfg.numOfPpInstances - 1] &
+				MV_IDT_SWITCH_PCI_MEM_BASE_REG_MASK) |
+				(((idtSwCfg.idtSwPortCfg.startAddr[0]) &
+				MV_IDT_SWITCH_PCI_MEM_BASE_REG_MASK) >> MV_IDT_SWITCH_PCI_MEM_BASE_REG_SHIFT)));
+}
+
+/*******************************************************************************
+*	mv_print_idt_switch_configuration
+*
+*	DESCRIPTION:
+*			Print PCI device configuration
+*
+*	INPUTS:
+*			None
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+* COMMENTS:
+*			None
+*
+*******************************************************************************/
+static void mv_print_idt_switch_configuration(void)
+{
+	int i;
+
+	mvOsPrintf("\n");
+	mvOsPrintf("PEX IDT Switch Configuration\n");
+	mvOsPrintf("============================\n");
+	mvOsPrintf("                  %02x:00.0 (IDT Uplink port)\n", idtSwCfg.ppIdtSwitchUsBusNum);
+	mvOsPrintf("                     |\n");
+	mvOsPrintf("---------------------|---------------------\n");
+	mvOsPrintf("%02x:%02x.0     %02x:%02x.0     %02x:%02x.0     %02x:%02x.0 (IDT Downlink ports)\n",
+				 idtSwCfg.ppIdtSwitchDsBusNum, idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[0],
+				 idtSwCfg.ppIdtSwitchDsBusNum, idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[1],
+				 idtSwCfg.ppIdtSwitchDsBusNum, idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[2],
+				 idtSwCfg.ppIdtSwitchDsBusNum, idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[3]);
+	mvOsPrintf("%02x:00.0     %02x:00.0     %02x:00.0     %02x:00.0 (Marvell Devices)\n",
+				 idtSwCfg.idtSwPortCfg.ppBusNumArray[0], idtSwCfg.idtSwPortCfg.ppBusNumArray[1],
+			     idtSwCfg.idtSwPortCfg.ppBusNumArray[2], idtSwCfg.idtSwPortCfg.ppBusNumArray[3]);
+	mvOsPrintf("\n");
+
+	for (i = 0; i < idtSwCfg.numOfPpInstances; i++) {
+		mvOsPrintf("PEX IDT Downlink port [bus 0x%x device 0x%x] Base address 0x%08x\n",
+			idtSwCfg.ppIdtSwitchDsBusNum, idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[i],
+			mvPexConfigRead(0, idtSwCfg.ppIdtSwitchDsBusNum,
+					idtSwCfg.idtSwPortCfg.ppIdtSwitchDsPpDevices[i],
+					0, MV_IDT_SWITCH_PCI_MEM_BASE_REG));
+	}
+
+	mvOsPrintf("PEX IDT Uplink port   [bus 0x%x device 0x%x] Base address 0x%08x\n\n",
+		   idtSwCfg.ppIdtSwitchUsBusNum, 0, mvPexConfigRead(0, idtSwCfg.ppIdtSwitchUsBusNum,
+								    0, 0, MV_IDT_SWITCH_PCI_MEM_BASE_REG));
+	mvOsPrintf("\n");
+}
+
+/*******************************************************************************
+*	mv_verify_idt_switch_config
+*
+*	DESCRIPTION:
+*			Print PCI device configuration
+*
+*	INPUTS:
+*			None
+*
+*	OUTPUTS:
+*			None
+*
+*	RETURNS:
+*			None
+*
+* COMMENTS:
+*			None
+*
+*******************************************************************************/
+void mv_verify_idt_switch_config(void)
+{
+	/* Scan for PCI devices - Marvell & IDT Switch */
+	mv_find_pci_dev_pp_instances();
+
+	/* Discover Marvell devices connected to IDT Switch */
+	mv_discover_active_pp_instances();
+
+	/* Configure IDT Switch address range */
+	mv_configure_idt_switch_addr_range();
+
+	/* Print configuration */
+	mv_print_idt_switch_configuration();
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c
index 49e88d9..9b2861a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_pltfm.c
@@ -134,7 +134,7 @@ static int ppdev_conf_set_pltfm(void)
 	ppdev->config.phys = start;
 	ppdev->config.base = (uintptr_t)(INTER_REGS_VIRT_BASE);
 
-	err = ppdev_conf_set(ppdev);
+	err = ppdev_conf_set(NULL, ppdev);
 	if (err)
 		return err;
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
index a3b069a..fc6bce2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
@@ -151,6 +151,7 @@ static inline struct pci_dev *find_bdf(u32 bus, u32 device, u32 func)
 /* interrupt routine pointer */
 static MV_VOIDFUNCPTR bspIsrRoutine = (MV_VOIDFUNCPTR)-1;
 static unsigned long bspIsrParameter = -1;
+static unsigned int lionSpecificRegMode;
 
 /*** reset ***/
 /*******************************************************************************
@@ -267,8 +268,8 @@ MV_STATUS bspCacheFlush(enum bspCacheType	cacheType,
 *
 *******************************************************************************/
 MV_STATUS bspCacheInvalidate(enum bspCacheType	cacheType,
-			     void			*address_PTR,
-			     size_t		size)
+				void			*address_PTR,
+				size_t		size)
 {
 	switch (cacheType) {
 	case bspCacheType_InstructionCache_E:
@@ -631,19 +632,27 @@ int bspPciFindDev(unsigned short	vendorId,
 *       None.
 *
 *******************************************************************************/
-MV_STATUS bspPciGetIntVec(enum bspPciInt_PCI_INT	pciInt,
-			  void				**intVec)
+MV_STATUS bspPciGetIntVec(enum bspPciInt_PCI_INT pciInt, void **intVec)
 {
-	MV_STATUS rc = MV_OK;
-
 #ifdef CONFIG_ARCH_MSYS
+	MV_STATUS rc = MV_OK;
 	*intVec = (void *)(unsigned long)(IRQ_AURORA_SW_CORE0);
 #else
-	*intVec = (void *)(unsigned long)(IRQ_AURORA_PCIE0);
-#endif
-	mvOsPrintf("%s int vector 0x%x, pciInt 0x%x\n", __func__, *intVec,
-	    pciInt);
-
+	MV_STATUS rc = MV_FAIL;
+	struct pci_dev *dev;
+	unsigned long b, d, f;
+
+	/* iterate to the instance of pp_core_number */
+	if (bspPciFindDev(MARVELL_VEN_ID, 0xffff, pciInt, &b, &d, &f) == MV_OK) {
+		dev = find_bdf(b, d, f);
+		if (dev != NULL) {
+			*intVec = (void *)(unsigned long)(dev->irq);
+			mvOsPrintf("%s int vector 0x%x, pciInt 0x%x\n", __func__, (int)*intVec, pciInt);
+			pci_dev_put(dev);
+			rc = MV_OK;
+		}
+	}
+ #endif
 	return rc;
 }
 
@@ -788,6 +797,15 @@ MV_STATUS smiWriteReg(unsigned long devSlvId, unsigned long regAddr, unsigned lo
 	return (MV_OK == ret) ? MV_OK : MV_FAIL;
 }
 
+
+/*******************************************************************************
+* bspSmiReadRegLionSpecificSet
+*******************************************************************************/
+void bspSmiReadRegLionSpecificSet(void)
+{
+	lionSpecificRegMode = 1;
+}
+
 /*******************************************************************************
 * bspSmiReadReg
 *
@@ -826,6 +844,9 @@ MV_STATUS bspSmiReadReg(unsigned long devSlvId,
 		first_time = 0;
 		bspSmiInitDriver(&smiAccessMode);
 	}
+	/*  fix erroneous devSlvId from cpss */
+	if (lionSpecificRegMode)
+		MV_FIX_DEV_SLAVE_ID_4_LION(lionSpecificRegMode);
 
 	/* write addr to read */
 	msb = regAddr >> 16;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h
index 83f4c0b..513d0c4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h
@@ -117,6 +117,14 @@ enum bspSmiAccessMode {
 	bspSmiAccessMode_inDirect_E
 };
 
+/*  fix erroneous devSlvId from cpss */
+#define MV_FIX_DEV_SLAVE_ID_4_LION(devSlvId) {\
+	if (devSlvId > 0x13)\
+		devSlvId = 0x14;\
+	if (devSlvId >= 0x10)\
+		devSlvId -= 0x10;\
+}
+
 /*******************************************************************************
 * BSP_RX_CALLBACK_FUNCPTR
 *
@@ -585,7 +593,7 @@ int bspDmaRead(unsigned long	address,
 *******************************************************************************/
 void *bspCacheDmaMalloc(size_t bytes);
 
-/*** SMI ***/
+ /*** SMI ***/
 /*******************************************************************************
 * bspSmiInitDriver
 *
@@ -633,6 +641,27 @@ int bspSmiReadReg(unsigned long devSlvId,
 		  unsigned long regAddr,
 		  unsigned long *valuePtr);
 
+
+/*******************************************************************************
+* bspSmiReadRegLionSpecificSet
+*
+* DESCRIPTION:
+*       Set lios specific register mode in bspSmiReadReg
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void bspSmiReadRegLionSpecificSet(void);
+
 /*******************************************************************************
 * bspSmiWriteReg
 *
-- 
1.7.5.4

