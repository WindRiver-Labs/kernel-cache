From 930ef9d7bbfad977e25ff67ff51982b10a276cbd Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Thu, 26 Jun 2014 15:15:52 +0300
Subject: [PATCH 1743/1825] fix: ppv2: Fixed spurious interrupt caused by
 incomplete register write

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6fc0ebb224b90b1648c2e3a10528653e6be73e52

	When running 5 thread of TCP iperf on e1000 NIC and on intergated
	port the PPv2 complained it recieved an interrupt but NAPI was
	already scheduled. It turned out the register write to the
	interrupt mask register did not complete before the ISR exited
	so a second interrupt followed immediatly. a data syncronization
	barrier (dsb) didn't resolve the problem since register file reside
	in the MBUS domain which cannot acknowledge write completion due
	to architectural bug. The only way to ensure the write is completed
	is to issue a register read. since the memory is marked as
	strongly ordered the write must be serviced before the read, thus
	ensuring the read is completed.

	SYSTEMSW-17: Wrong interrupt appeared at multiple TCP sessions traffic

Change-Id: I1f8e338633ca7dde901db44e84ea03072efb7c39
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8747
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 6e192fc..53a7017 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -3000,6 +3000,7 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 	int cpu = smp_processor_id();
 	struct napi_group_ctrl *napi_group = pp->cpu_config[cpu]->napi_group;
 	struct napi_struct *napi = napi_group->napi;
+	u32 imr;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->dbg_flags & MV_ETH_F_DBG_ISR) {
@@ -3027,6 +3028,13 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 	}
 
+	/*
+	 * Ensure mask register write is completed by issuing a read.
+	 * dsb() instruction cannot be used on registers since they are in
+	 * MBUS domain
+	 */
+	imr = mvPp2RdReg(MV_PP2_ISR_ENABLE_REG(pp->port));
+
 	return IRQ_HANDLED;
 }
 
-- 
1.7.5.4

