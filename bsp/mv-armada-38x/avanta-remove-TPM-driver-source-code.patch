From 3d52ade0e431a49cfb62ac1cdb62d0ea86755644 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Sun, 14 Jul 2013 19:34:47 +0300
Subject: [PATCH 0823/1825] avanta: remove TPM driver source code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit d45ac9f74c3af2f9f627e1a0d14a2550a336f0b3

Change-Id: I0ade5b1e2e717c4149735fc0d2daa5d7c568616b
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig    |   54 -
 .../plat-feroceon/mv_drivers_lsp/mv_tpm/Makefile   |   46 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_api.c           | 3609 ----
 .../mv_drivers_lsp/mv_tpm/core/tpm_api.h           | 4204 -----
 .../mv_drivers_lsp/mv_tpm/core/tpm_common.h        |   91 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_counter.c       |  996 --
 .../mv_drivers_lsp/mv_tpm/core/tpm_counter.h       |  338 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.c   |  579 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.h   |  277 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.c        |  787 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.h        |  198 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_db.c            |11115 ------------
 .../mv_drivers_lsp/mv_tpm/core/tpm_db.h            | 1453 --
 .../mv_drivers_lsp/mv_tpm/core/tpm_header.h        |  141 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_init.c          | 4384 -----
 .../mv_drivers_lsp/mv_tpm/core/tpm_init.h          |  113 -
 .../mv_tpm/core/tpm_internal_types.h               |  622 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_mempool.c       |  281 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_mempool.h       |  123 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_mtu.c           | 1263 --
 .../mv_drivers_lsp/mv_tpm/core/tpm_mtu.h           |  142 -
 .../mv_tpm/core/tpm_pkt_proc_logic.c               |17890 --------------------
 .../mv_tpm/core/tpm_pkt_proc_logic.h               |  936 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.c     | 3637 ----
 .../mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.h     |  350 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_print.c         | 2534 ---
 .../mv_drivers_lsp/mv_tpm/core/tpm_print.h         |  152 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_setup.c         |  932 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_sysfs.h         |   90 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_sysfs_print.c   |  536 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_sysfs_trace.c   |  211 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_tm.c            |  632 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_tm.h            |  278 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_trace.c         |  362 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_trace.h         |  220 -
 .../mv_drivers_lsp/mv_tpm/core/tpm_types.h         | 1566 --
 .../mv_drivers_lsp/mv_tpm/core/tpm_xml_params.c    | 3839 -----
 .../mv_drivers_lsp/mv_tpm/core/tpm_xml_params.h    |  380 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_bring_up.c      |  134 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.c        | 3843 -----
 .../mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.h        | 1107 --
 .../mv_drivers_lsp/mv_tpm/perf/tpm_self_check.c    | 1986 ---
 .../mv_drivers_lsp/mv_tpm/perf/tpm_self_check.h    |    1 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.c    | 1770 --
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.h    |  207 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.c  | 7085 --------
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.h  |  187 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.c | 3068 ----
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.h |  142 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.c   | 1315 --
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.h   |   89 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.c   | 1867 --
 .../mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.h   |  295 -
 .../mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.c        | 4424 -----
 .../mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.h        |   88 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_alarm.c         |  200 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_alarm.h         |  155 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.c     | 5012 ------
 .../mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.h     |  321 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.c       |  707 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.h       |  123 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_rtos.h          |  131 -
 .../mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.c    | 8038 ---------
 .../mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.h    | 1175 --
 64 files changed, 0 insertions(+), 108831 deletions(-)
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Makefile
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_common.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_header.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_internal_types.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_setup.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_print.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_trace.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_types.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_bring_up.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_rtos.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.h

diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig
deleted file mode 100644
index 5bed02b..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig
+++ /dev/null
@@ -1,54 +0,0 @@
-menu "SoC TPM support"
-depends on MV_INCLUDE_TPM
-
-config  MV_TPM
-	tristate "Support for Marvell TPM Driver"
-	default y
-	---help---
-
-comment "TPM Driver Options"
-depends on MV_TPM
-
-config  MV_TPM_Z1_VER
-	bool "Support for TPM Z1 Version"
-	depends on MV_TPM
-	default n
-	---help---
-
-config  MV_TPM_Z2_VER
-	bool "Support for TPM Z2 Version"
-	depends on MV_TPM
-	default y
-	---help---
-
-config  MV_TPM_FPGA_VER
-	bool "Support for TPM FPGA Version"
-	depends on MV_TPM
-	default n
-	---help---
-
-config  MV_TPM_INT_LOCK
-	bool "Support for TPM Protection - Int Lock"
-	depends on MV_TPM
-	default n
-	---help---
-
-config  MV_TPM_DEBUG_PRINT
-	bool "Support for tpm Debug printing"
-	depends on MV_TPM
-	default N
-	---help---
-
-config  MV_TPM_SFS_2_IOCTL
-	bool "Support for debugging ioctl API via sysfs interface"
-	depends on MV_TPM
-	default N
-	---help---
-
-config  MV_TPM_SYSFS_HELP
-	bool "Support for tpm sysfs help"
-	depends on MV_TPM
-	default Y
-	---help---
-
-endmenu
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Makefile b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Makefile
deleted file mode 100644
index 2ac53c5..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Makefile
+++ /dev/null
@@ -1,46 +0,0 @@
-#
-# Makefile for the Marvell TPM driver
-#
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifdef CONFIG_MV_HAL_RULES_PATH
-include $(srctree)/include/config/auto.conf
-include $(srctree)/$(subst ",,$(CONFIG_MV_HAL_RULES_PATH))
-endif
-
-TPM_OBJS += 	core/tpm_api.o \
-		core/tpm_db.o \
-		core/tpm_counter.o \
-		core/tpm_mempool.o \
-		core/tpm_init.o \
-		core/tpm_pkt_proc_logic.o \
-		core/tpm_tm.o \
-		core/tpm_pnc_logic.o \
-		core/tpm_print.o \
-		core/tpm_trace.o \
-		core/tpm_sysfs_trace.o \
-		core/tpm_sysfs_print.o \
-		core/tpm_setup.o \
-		core/tpm_xml_params.o \
-		core/tpm_mtu.o\
-		core/tpm_ctc_cm.o\
-		core/tpm_cpu_port_fc.o\
-		plat/tpm_modz2_mgr.o \
-		plat/tpm_pnc_mgr.o \
-		plat/tpm_switch_mgr.o \
-		plat/tpm_alarm.o \
-		perf/tpm_bring_up.o \
-		perf/tpm_mng_if.o \
-		perf/tpm_usr_if.o \
-		perf/tpm_sysfs_setup.o \
-		perf/tpm_sysfs_rule_db.o \
-		perf/tpm_sysfs_hwcall.o \
-		perf/tpm_sysfs_help.o \
-		perf/tpm_sysfs_utils.o\
-		perf/tpm_self_check.o
-
-mv_tpm-objs := $(TPM_OBJS)
-obj-$(CONFIG_MV_TPM) := mv_tpm.o
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.c
deleted file mode 100644
index 45ae3e9..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.c
+++ /dev/null
@@ -1,3609 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_api.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-#include <linux/version.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#define RET_BUSY_ERROR(ret_code, busy_ret_code)\
-		if (ret_code != TPM_OK)\
-			return(ret_code);\
-		else\
-			return (busy_ret_code);
-
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-/********************************** Packet Processor APIs *********************/
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-
-/******************************************************************************/
-/********************************** Administrative APIs ***********************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_create_ownerid()
-*
-* DESCRIPTION:      Creates an ownerId per an application group.
-*
-* INPUTS:
-*
-* OUTPUTS:
-* owner_id           - ID of an application group.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* This function is used for error prevention and not as a security mechanism.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_create_ownerid(uint32_t *owner_id)
-{
-	printk(KERN_WARNING "\n  <<tpm_create_ownerid>> NOT implemented. \n");
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_create_ownerid);
-
-/*******************************************************************************
-* tpm_request_api_ownership()
-*
-* DESCRIPTION:      Establishes an ownership between owner_id and a group of APIs.
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* api_type           - the API group whom ownership is requested.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_api_ownership_error_t tpm_request_api_ownership(uint32_t owner_id,
-						    tpm_api_type_t api_type)
-{
-	printk(KERN_WARNING "\n  <<tpm_request_api_ownership>> NOT implemented. \n");
-	return API_OWNERSHIP_SUCCESS;
-}
-EXPORT_SYMBOL(tpm_request_api_ownership);
-
-/*******************************************************************************
-* tpm_mib_reset()
-*
-* DESCRIPTION:      Performs MIB reset
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* reset_level        - The reset level determines the which elements will not be reset in the API call
-*                      ( by comparing to the element's reset level)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mib_reset(uint32_t owner_id,
-			       tpm_reset_level_enum_t reset_level)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_mib_reset(owner_id, reset_level);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_mib_reset);
-
-/*******************************************************************************
-* tpm_erase_section()
-*
-* DESCRIPTION:      Erases a section per an application group.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* api_type          - the API group area to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_erase_section(uint32_t owner_id,
-				   tpm_api_type_t api_type)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_erase_section(owner_id, api_type);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_erase_section);
-
-/*******************************************************************************
-* tpm_get_section_free_size()
-*
-* DESCRIPTION:      Returns the free size of an application group.
-*
-* INPUTS:
-* api_type         - the API group for retrieving the section size.
-*
-* OUTPUTS:
-* cur_size          - number of free entries per API group.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_section_free_size(tpm_api_type_t	api_type,
-					   int32_t	       *cur_size)
-{
-	uint32_t api_rng_size, num_valid_entries, last_valid, tbl_start;
-	tpm_pnc_ranges_t prim_pnc_range;
-	tpm_api_sections_t api_section = TPM_INVALID_SECTION;
-	int32_t int_ret_code;
-
-	if (!cur_size)
-		return ERR_NULL_POINTER;
-
-	if (ILLEGAL_API(api_type)) {
-		printk(KERN_ERR "Error, API Type does not exist (%d))\n", api_type);
-		return ERR_API_TYPE_INVALID;
-	}
-
-	int_ret_code = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-	if (int_ret_code != TPM_OK) {
-		printk(KERN_ERR "Error, API Type does not exist (%d))\n", api_type);
-		return (int_ret_code);
-	}
-
-	int_ret_code = tpm_db_api_section_get(api_section, &api_rng_size, &num_valid_entries,
-					      &prim_pnc_range, &last_valid, &tbl_start);
-	if (int_ret_code != TPM_OK) {
-		printk(KERN_ERR "Error, API Section does not exist\n");
-		return (int_ret_code);
-	}
-
-	*cur_size = api_rng_size - num_valid_entries;
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_get_section_free_size);
-
-/******************************************************************************/
-/********************************** Data Forwarding APIs **********************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_add_l2_rule()
-*
-* DESCRIPTION:      Creates a new primary L2 processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L2 API:
-*                        TPM_L2_PARSE_MAC_DA|TPM_L2_PARSE_MAC_SA|TPM_L2_PARSE_ONE_VLAN_TAG
-*                        |TPM_L2_PARSE_TWO_VLAN_TAG|TPM_L2_PARSE_ETYPE|TPM_L2_PARSE_PPPOE_SES
-*                        |TPM_L2_PARSE_PPP_PROT|TPM_L2_PARSE_GEMPORT)
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L2 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE
-* l2_key             - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frw            - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containind the set of fields in the packet to be changed.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      possible "next_phase" for L2 API   -> STAGE_L3_TYPE , STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_l2_rule(uint32_t owner_id,
-				 tpm_src_port_type_t src_port,
-				 uint32_t rule_num,
-				 uint32_t *rule_idx,
-				 tpm_parse_fields_t parse_rule_bm,
-				 tpm_parse_flags_t parse_flags_bm,
-				 tpm_l2_acl_key_t *l2_key,
-				 tpm_pkt_frwd_t *pkt_frwd,
-				 tpm_pkt_mod_t *pkt_mod,
-				 tpm_pkt_mod_bm_t pkt_mod_bm,
-				 tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_section Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_L2_PRIM, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_l2_prim_acl_rule(owner_id, src_port, rule_num, rule_idx, parse_rule_bm, parse_flags_bm,
-						 l2_key, pkt_frwd, pkt_mod, pkt_mod_bm, rule_action);
-	if (ret_code != TPM_OK)
-	{
-		/* to remove MC_AI_BITS if add l2 acl rule failed */
-		tpm_proc_mc_vid_remove_ai_bits(rule_action, src_port, l2_key, ret_code);
-	}
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_L2_PRIM, rule_num);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_l2_rule);
-
-/*******************************************************************************
-* tpm_add_l3_type_rule()
-*
-* DESCRIPTION:      Creates a new L3 type (ether type of pppoe proto) processing ACL.
-*                   It is used for operations that are not possible to be performed
-*                   in a single ACL or to ease the primary ACL processing
-*                   (as a helper of the primary L2 ACL).
-*                   The L3 type ACL is optional.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L3 API:
-*                        TPM_L2_PARSE_ETYPE|TPM_L2_PARSE_PPPOE_SES|TPM_L2_PARSE_PPP_PROT
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L3 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE
-* l3_key             - Structure for PPPoE proto or ether type. In order to define a rule for
-*                      any ether type, the ether type value should be set to 0xFFFF
-* action_drop        - If this stage is dropping the packet.
-* pkt_frw            - Information for packet forwarding decision.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      possible "next_phase" for L3 API   ->  STAGE_IPv4, STAGE_IPv6_GEN, STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_l3_type_rule(uint32_t owner_id,
-				      tpm_src_port_type_t src_port,
-				      uint32_t rule_num,
-				      uint32_t *rule_idx,
-				      tpm_parse_fields_t parse_rule_bm,
-				      tpm_parse_flags_t parse_flags_bm,
-				      tpm_l3_type_key_t *l3_key,
-				      tpm_pkt_frwd_t *pkt_frwd,
-				      tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_L3_TYPE, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_l3_type_acl_rule(owner_id, src_port, rule_num,
-						 rule_idx, parse_rule_bm, parse_flags_bm,
-						 l3_key, pkt_frwd, rule_action);
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_L3_TYPE, rule_num);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_l3_type_rule);
-
-/*******************************************************************************
-* tpm_del_l2_rule()
-*
-* DESCRIPTION:      Deletes an existing L2 ACL primary rule.
-*                   Any of the existing access-list entries may be deleted. The src_port parameter
-*                   determines if the rule to be deleted belongs to the upstream access-list
-*                   or the downstream access-list. All parameters are compulsory. If the rule number
-*                   does not match the internally stored src_port and parsing key
-*                   (parse_rule_bm and l2_key), the API will return an error.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_l2_rule(uint32_t owner_id,
-				 uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_l2_prim_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_l2_rule);
-
-/*******************************************************************************
-* tpm_del_l3_type_rule()
-*
-* DESCRIPTION:      Deletes an existing ethernet type or PPPoE proto access-list entry .
-*                   Any of the existing access-list entries may be deleted. The src_port parameter
-*                   determines if the rule to be deleted belongs to the upstream access-list
-*                   or the downstream access-list. All parameters are compulsory. If the rule number
-*                   does not match the internally stored src_port and parsing key
-*                   (parse_rule_bm and l3_key), the API will return an error.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_l3_type_rule(uint32_t owner_id,
-				      uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_l3_type_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_l3_type_rule);
-
-/*******************************************************************************
-* tpm_add_ipv4_rule()
-*
-* DESCRIPTION:      Creates a new IPv4 processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv4 API:
-*                        TPM_IPv4_PARSE_SIP|TPM_IPv4_PARSE_DIP|TPM_IPv4_PARSE_DSCP
-*                         |TPM_IPv4_PARSE_PROTO|TPM_PARSE_L4_SRC|TPM_PARSE_L4_DST
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv4 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv4_key           - Information to create an IPv4 parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - VLAN packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify (used for GWY only - in SFU is NULL)
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase.
-*                      possible "next_phase" for IPv4 API   ->  STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_rule(uint32_t owner_id,
-				   tpm_src_port_type_t src_port,
-				   uint32_t rule_num,
-				   uint32_t *rule_idx,
-				   tpm_parse_fields_t parse_rule_bm,
-				   tpm_parse_flags_t parse_flags_bm,
-				   tpm_ipv4_acl_key_t *ipv4_key,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_mod_t *pkt_mod,
-				   tpm_pkt_mod_bm_t pkt_mod_bm,
-				   tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV4, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-
-	ret_code = tpm_proc_add_ipv4_acl_rule(owner_id, src_port, rule_num, rule_idx, parse_rule_bm,
-					      parse_flags_bm, ipv4_key, pkt_frwd, pkt_mod, pkt_mod_bm, rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV4, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv4_rule);
-
-/*******************************************************************************
-* tpm_del_ipv4_rule()
-*
-* DESCRIPTION:      Deletes an existing IPv4 ACL rule.
-*                   Both rule number and key are compulsory.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv4_rule(uint32_t owner_id,
-				   uint32_t rule_idx)
-{
-
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_ipv4_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_del_ipv4_rule);
-
-/*******************************************************************************
-* tpm_add_ipv6_nh_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 NH processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_num           - Entry index to be added in the current ACL
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 NH API:
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-* nh                 - Information to create a NH parsing key for the rule.
-* pkt_frwd           - Information for packet forwarding decision.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 NH API   ->  STAGE_IPV6_L4,STAGE_DONE
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_nh_rule(uint32_t owner_id,
-				      uint32_t rule_num,
-				      uint32_t *rule_idx,
-				      tpm_parse_flags_t parse_flags_bm,
-				      tpm_nh_iter_t nh_iter,
-				      uint32_t nh,
-				      tpm_pkt_frwd_t *pkt_frwd,
-				      tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_NH, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_nh_acl_rule(owner_id, rule_num, rule_idx, parse_flags_bm,
-						 nh_iter, nh, pkt_frwd, rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_NH, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_nh_rule);
-
-/*******************************************************************************
-* tpm_del_ipv6_nh_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 NH processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_nh_rule(uint32_t owner_id,
-				      uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_ipv6_nh_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_nh_rule);
-
-/*******************************************************************************
-* tpm_add_ipv6_gen_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 gen processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv6 GEN API: 0
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 GEN API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv6_gen_key     - Information to create an IPv6 gen parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 GEN API   ->  STAGE_IPv6_DIP, ,STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx          - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_gen_rule(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t rule_num,
-					 uint32_t *rule_idx,
-					 tpm_parse_fields_t parse_rule_bm,
-					 tpm_parse_flags_t parse_flags_bm,
-					 tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_pkt_mod_t *pkt_mod,
-					 tpm_pkt_mod_bm_t pkt_mod_bm,
-					 tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_GEN, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_gen_acl_rule(owner_id, src_port, rule_num, rule_idx, parse_rule_bm,
-						    parse_flags_bm, ipv6_gen_key, pkt_frwd, pkt_mod, pkt_mod_bm,
-						    rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_GEN, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_gen_rule);
-
-/*******************************************************************************
-* tpm_del_ipv6_gen_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 gen processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_gen_rule(uint32_t owner_id,
-					 uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_gen_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_gen_rule);
-
-/*******************************************************************************
-* tpm_add_ipv6_dip_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 DIP processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv6 DIP API: TPM_IPv6_PARSE_DIP
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 DIP API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv6_dip_key       - Information to create an IPv6 DIP parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify (used for GWY only - in SFU is NULL)
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 GEN API   ->  STAGE_IPv6_NHSTAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx          - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_dip_rule(uint32_t owner_id,
-				       tpm_src_port_type_t src_port,
-				       uint32_t rule_num,
-				       uint32_t *rule_idx,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_parse_flags_t parse_flags_bm,
-				       tpm_ipv6_addr_key_t *ipv6_dip_key,
-				       tpm_pkt_frwd_t *pkt_frwd,
-				       tpm_pkt_mod_t *pkt_mod,
-				       tpm_pkt_mod_bm_t pkt_mod_bm,
-				       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_DIP, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_dip_acl_rule(owner_id, src_port, rule_num, rule_idx, parse_rule_bm,
-						parse_flags_bm, ipv6_dip_key, pkt_frwd, pkt_mod, pkt_mod_bm,
-						rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_DIP, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_dip_rule);
-
-/*******************************************************************************
-* tpm_del_ipv6_dip_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 DIP processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_dip_rule(uint32_t owner_id,
-				       uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_dip_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_dip_rule);
-
-/*******************************************************************************
-* tpm_add_ipv6_l4_ports_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 L4 processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L4 API: TPM_PARSE_L4_SRC|TPM_PARSE_L4_DST
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L4 API:
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_L4_TCP|TPM_PARSE_FLAG_L4_UDP
-* l4_key             - Information to create an L4 parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify (used for GWY only - in SFU is NULL)
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for L4 API   ->  STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx          - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_l4_ports_rule(uint32_t owner_id,
-					    tpm_src_port_type_t src_port,
-					    uint32_t rule_num,
-					    uint32_t *rule_idx,
-					    tpm_parse_fields_t parse_rule_bm,
-					    tpm_parse_flags_t parse_flags_bm,
-					    tpm_l4_ports_key_t *l4_key,
-					    tpm_pkt_frwd_t *pkt_frwd,
-					    tpm_pkt_mod_t *pkt_mod,
-					    tpm_pkt_mod_bm_t pkt_mod_bm,
-					    tpm_rule_action_t *rule_action)
-{
-
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_L4, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_l4_ports_acl_rule(owner_id, src_port, rule_num, rule_idx, parse_rule_bm,
-							parse_flags_bm, l4_key, pkt_frwd, pkt_mod, pkt_mod_bm,
-							rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_L4, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_l4_ports_rule);
-
-/*******************************************************************************
-* tpm_del_ipv6_l4_ports_rule()
-*
-* DESCRIPTION:      Deletes an existng L4 processing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_l4_ports_rule(uint32_t owner_id,
-					    uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_l4_ports_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_l4_ports_rule);
-
-
-tpm_error_code_t tpm_add_ipv6_gen_5t_rule(uint32_t owner_id,
-					  tpm_dir_t src_dir,
-					  uint32_t rule_num,
-					  uint32_t *rule_idx,
-					  tpm_parse_fields_t parse_rule_bm,
-					  tpm_parse_flags_t parse_flags_bm,
-					  tpm_l4_ports_key_t *l4_key,
-					  tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					  tpm_pkt_frwd_t *pkt_frwd,
-					  tpm_pkt_mod_t *pkt_mod,
-					  tpm_pkt_mod_bm_t pkt_mod_bm,
-					  tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_GEN, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-
-	ret_code = tpm_proc_add_ipv6_gen_5t_rule(owner_id, src_dir, rule_num, rule_idx, parse_rule_bm, parse_flags_bm,
-						l4_key, ipv6_gen_key, pkt_frwd, pkt_mod, pkt_mod_bm, rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_GEN, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_gen_5t_rule);
-
-tpm_error_code_t tpm_del_ipv6_gen_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_gen_5t_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_gen_5t_rule);
-
-tpm_error_code_t tpm_add_ipv6_dip_5t_rule(uint32_t owner_id,
-					  tpm_dir_t src_dir,
-					  uint32_t rule_num,
-					  uint32_t *rule_idx,
-					  tpm_parse_fields_t parse_rule_bm,
-					  tpm_parse_flags_t parse_flags_bm,
-					  tpm_l4_ports_key_t *l4_key,
-					  tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					  tpm_ipv6_addr_key_t *ipv6_dip_key,
-					  tpm_pkt_frwd_t *pkt_frwd,
-					  tpm_pkt_mod_t *pkt_mod,
-					  tpm_pkt_mod_bm_t pkt_mod_bm,
-					  tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_DIP, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_dip_5t_rule(owner_id, src_dir, rule_num, rule_idx, parse_rule_bm, parse_flags_bm,
-										l4_key, ipv6_gen_key, ipv6_dip_key, pkt_frwd, pkt_mod, pkt_mod_bm, rule_action);
-
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_DIP, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_dip_5t_rule);
-
-tpm_error_code_t tpm_del_ipv6_dip_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_dip_5t_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_dip_5t_rule);
-
-tpm_error_code_t tpm_add_ipv6_l4_ports_5t_rule(uint32_t owner_id,
-					       tpm_dir_t src_dir,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l4_ports_key_t *l4_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_L4, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_l4_ports_5t_rule(owner_id, src_dir, rule_num, rule_idx, parse_rule_bm, parse_flags_bm,
-						      l4_key, pkt_frwd, pkt_mod, pkt_mod_bm, rule_action);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_L4, rule_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv6_l4_ports_5t_rule);
-
-tpm_error_code_t tpm_del_ipv6_l4_ports_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	ret_code = tpm_proc_del_ipv6_l4_ports_5t_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_l4_ports_5t_rule);
-
-
-/*******************************************************************************
-* tpm_set_active_wan()
-*
-* DESCRIPTION:      Set active WAN port
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* active_wan        - active wan, GMAC0, GMAC1, PON
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_active_wan(uint32_t owner_id,
-				    tpm_gmacs_enum_t active_wan)
-{
-	tpm_error_code_t tpm_ret;
-
-	tpm_ret = tpm_proc_set_active_wan(active_wan);
-	if(TPM_OK != tpm_ret) {
-		TPM_OS_ERROR(TPM_DB_MOD, "set active wan has failed with error code (%d)\n", tpm_ret);
-		return tpm_ret;
-	}
-
-	return (TPM_OK);
-}
-EXPORT_SYMBOL(tpm_set_active_wan);
-/*******************************************************************************
-* tpm_hot_swap_profile()
-*
-* DESCRIPTION:      Swap profile and update all the ACL rules according to
-*                   the new profile
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* profile_id        - the new profile that system is swapping to
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_hot_swap_profile(uint32_t owner_id,
-				    tpm_eth_complex_profile_t profile_id)
-{
-#ifdef CONFIG_MV_ETH_WAN_SWAP
-
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_all_api_busy();
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_hot_swap_profile(owner_id, profile_id);
-
-	busy_ret_code = tpm_proc_all_api_busy_done();
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-#else
-	TPM_OS_ERROR(TPM_DB_MOD, "hot swap profile feature is not supported on this product!\n");
-	return TPM_OK;
-
-#endif /* CONFIG_MV_ETH_WAN_SWAP */
-
-}
-EXPORT_SYMBOL(tpm_hot_swap_profile);
-
-/******************************************************************************/
-/********************************** MC handling APIs **************************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_add_ipv4_mc_stream()
-*
-* DESCRIPTION:      Creates a new IPv4 MC stream.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv4_src_add       - IPv4 source IP address in network order.
-* ipv4_src_add       - IPv4 destination IP address in network order.
-* ignore_ipv4_src    - when set to 1 - the IP source is not part of the key.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_mc_stream(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv4_src_add[4],
-					uint8_t ipv4_dst_add[4],
-					uint8_t ignore_ipv4_src,
-					tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV4_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv4_mc_stream(owner_id, stream_num, igmp_mode, mc_stream_pppoe,
-						vid, ipv4_src_add, ipv4_dst_add, ignore_ipv4_src,
-						TPM_INVALID_QUEUE, dest_port_bm);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV4_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv4_mc_stream);
-
-/*******************************************************************************
-* tpm_add_ipv4_mc_stream_set_queue()
-*
-* DESCRIPTION:      Creates a new IPv4 MC stream with dest Queue.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv4_src_add       - IPv4 source IP address in network order.
-* ipv4_src_add       - IPv4 destination IP address in network order.
-* ignore_ipv4_src    - when set to 1 - the IP source is not part of the key.
-* dest_queue          - destination queue number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_mc_stream_set_queue(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv4_src_add[4],
-					uint8_t ipv4_dst_add[4],
-					uint8_t ignore_ipv4_src,
-					uint16_t dest_queue,
-					tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV4_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv4_mc_stream(owner_id, stream_num, igmp_mode, mc_stream_pppoe,
-						vid, ipv4_src_add, ipv4_dst_add, ignore_ipv4_src,
-						dest_queue, dest_port_bm);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV4_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ipv4_mc_stream_set_queue);
-
-/*******************************************************************************
-* tpm_updt_ipv4_mc_stream()
-*
-* DESCRIPTION:      Updates an existing IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_updt_ipv4_mc_stream(uint32_t owner_id,
-					 uint32_t stream_num,
-					 tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV4_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_updt_ipv4_mc_stream(owner_id, stream_num, dest_port_bm);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV4_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_updt_ipv4_mc_stream);
-
-/*******************************************************************************
-* tpm_del_ipv4_mc_stream()
-*
-* DESCRIPTION:      Deletes an existing IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv4_mc_stream(uint32_t owner_id,
-					uint32_t stream_num)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_ipv4_mc_stream(owner_id, stream_num);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv4_mc_stream);
-
-/*******************************************************************************
-* tpm_add_ipv6_mc_stream()
-*
-* DESCRIPTION:      Creates a new ipv6 MC stream.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv6_src_add       - ipv6 source IP address in network order.
-* ipv6_dst_add       - ipv6 destination IP address in network order.
-* ignore_ipv6_src    - when set to 1 - the IP source is not part of the key.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_mc_stream(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv6_src_add[16],
-					uint8_t ipv6_dst_add[16],
-					uint8_t ignore_ipv6_src,
-					tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_mc_stream(owner_id, stream_num, igmp_mode, mc_stream_pppoe,
-						vid, ipv6_src_add, ipv6_dst_add, ignore_ipv6_src,
-						TPM_INVALID_QUEUE, dest_port_bm);
-
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-
-}
-EXPORT_SYMBOL(tpm_add_ipv6_mc_stream);
-
-/*******************************************************************************
-* tpm_add_ipv6_mc_stream_set_queue()
-*
-* DESCRIPTION:      Creates a new ipv6 MC stream with specified destination queue number.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv6_src_add       - ipv6 source IP address in network order.
-* ipv6_dst_add       - ipv6 destination IP address in network order.
-* ignore_ipv6_src    - when set to 1 - the IP source is not part of the key.
-* dest_queue          - destination queue number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_mc_stream_set_queue(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv6_src_add[16],
-					uint8_t ipv6_dst_add[16],
-					uint8_t ignore_ipv6_src,
-					uint16_t dest_queue,
-					tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ipv6_mc_stream(owner_id, stream_num, igmp_mode, mc_stream_pppoe,
-						vid, ipv6_src_add, ipv6_dst_add, ignore_ipv6_src,
-						dest_queue, dest_port_bm);
-
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-
-}
-EXPORT_SYMBOL(tpm_add_ipv6_mc_stream_set_queue);
-
-/*******************************************************************************
-* tpm_updt_ipv6_mc_stream()
-*
-* DESCRIPTION:      Updates an existing ipv6 MC stream.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_updt_ipv6_mc_stream(uint32_t owner_id,
-					 uint32_t stream_num,
-					 tpm_trg_port_type_t dest_port_bm)
-{	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_type Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_IPV6_MC, stream_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_updt_ipv6_mc_stream(owner_id, stream_num, dest_port_bm);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_IPV6_MC, stream_num);
-
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_updt_ipv6_mc_stream);
-
-/*******************************************************************************
-* tpm_del_ipv6_mc_stream()
-*
-* DESCRIPTION:      Deletes an existing ipv6 MC stream.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_mc_stream(uint32_t owner_id,
-					uint32_t stream_num)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_ipv6_mc_stream(owner_id, stream_num);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ipv6_mc_stream);
-
-/******************************************************************************/
-/********************************** Management protocol APIs ******************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_omci_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OMCI management protocol.
-*                   The API sets the gemportid, the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* gem_port           - for OMCI Rx frames - the gem port wherefrom the OMCI frames are received.
-* cpu_rx_queue       - for OMCI Rx frames - the CPU rx queue number.
-* tcont_num          - for OMCI Tx frames - the TCONT number where to send the OMCI frames.
-* cpu_tx_queue       - for OMCI Tx frames - the CPU tx queue number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_add_channel(uint32_t owner_id,
-				      tpm_gem_port_key_t gem_port,
-				      uint32_t cpu_rx_queue,
-				      tpm_trg_port_type_t tcont_num,
-				      uint32_t cpu_tx_queue)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_omci_add_channel(owner_id, gem_port, cpu_rx_queue, tcont_num, cpu_tx_queue);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_omci_add_channel);
-
-/*******************************************************************************
-* tpm_omci_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OMCI management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_del_channel(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_omci_del_channel(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_omci_del_channel);
-
-/*******************************************************************************
-* tpm_oam_epon_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OAM EPON management protocol.
-*                   The API sets the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* cpu_rx_queue       - for OAM (EPON) Rx frames - the CPU rx queue number.
-* llid_num           - for OAM (EPON)Tx frames - the LLID number where to send the OMCI frames.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_add_channel(uint32_t owner_id,
-					  uint32_t cpu_rx_queue,
-					  tpm_trg_port_type_t llid_num)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_oam_epon_add_channel(owner_id, cpu_rx_queue, llid_num);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_oam_epon_add_channel);
-
-/*******************************************************************************
-* tpm_loop_detect_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for loop detection management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_loop_detect_add_channel(uint32_t owner_id, tpm_ether_type_key_t ety)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_loop_detect_add_channel(owner_id, ety);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_loop_detect_add_channel);
-
-/*******************************************************************************
-* tpm_loop_detect_del_channel()
-*
-* DESCRIPTION:      remove a communication channel for loop detection management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_loop_detect_del_channel(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_loop_detect_del_channel(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_loop_detect_del_channel);
-
-/*******************************************************************************
-* tpm_oam_loopback_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OAM remote loopback.
-*
-*
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_loopback_add_channel(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_oam_loopback_add_channel(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_oam_loopback_add_channel);
-
-/*******************************************************************************
-* tpm_oam_loopback_del_channel()
-*
-* DESCRIPTION:      Del a communication channel for the OAM remote loopback .
-*
-*
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_loopback_del_channel(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_oam_loopback_del_channel(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_oam_loopback_del_channel);
-
-/*******************************************************************************
-* tpm_oam_epon_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OAM EPON management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_del_channel(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_oam_epon_del_channel(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_oam_epon_del_channel);
-
-/*******************************************************************************
-* tpm_get_next_valid_rule()
-*
-* DESCRIPTION:      General purpose API to retrieve the internal configuration of an existing ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* direction          - direction - UpStream or DownStream - TPM_DOWNSTREAM = 0 and TPM_UPSTREAM = 1.
-* current_index      - the entry index in the section (rule_num/stream_num).
-*                      In case it is (-1) - the get next function will point to the first ruleof the section.
-* rule_type          - type of the rule to retrieve - indicates the api group where to point.
-*
-* OUTPUTS:
-* next_index         - returns the first following index (rule_num/stream_num) after the index in
-*                      the current_index parameter. It is invalid, if there is no next_index.
-* rule_idx           - Unique rule identification number. Equals to stream_num for functions that take a stream_num.
-* tpm_rule           - points to a structure holding the information of a single rule,
-*                      of the type specified in the rule_type param.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_next_valid_rule(uint32_t owner_id,
-					 int32_t current_index,
-					 tpm_api_type_t rule_type,
-					 int32_t *next_index,
-					 uint32_t *rule_idx,
-					 tpm_rule_entry_t *tpm_rule)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_get_next_valid_rule(owner_id, current_index, rule_type, next_index, rule_idx, tpm_rule);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_get_next_valid_rule);
-
-/******************************************************************************/
-/********************************** Configuration retrieval APIs **************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_omci_get_channel()
-*
-* DESCRIPTION:      Retrieves the OMCI management protocol channel information.
-*
-* INPUTS:
-*  None.
-*
-* OUTPUTS:
-* is_valid           - indicates that the OMCI channel is valid or not.
-* gem_port           - for OMCI Rx frames - the gem port wherefrom the OMCI frames are received.
-* cpu_rx_queue       - for OMCI Rx frames - the CPU rx queue number.
-* tcont_num          - for OMCI Tx frames - the TCONT number where to send the OMCI frames.
-* cpu_tx_queue       - for OMCI Tx frames - the CPU tx queue number.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_get_channel(uint32_t *is_valid,
-				      tpm_gem_port_key_t *gem_port,
-				      uint32_t *cpu_rx_queue,
-				      tpm_trg_port_type_t *tcont_num,
-				      uint32_t *cpu_tx_queue)
-{
-	if (!is_valid || !gem_port || !cpu_rx_queue || !tcont_num || !cpu_tx_queue)
-		return ERR_NULL_POINTER;
-
-	tpm_db_omci_channel_get(is_valid, gem_port, cpu_rx_queue, cpu_tx_queue, tcont_num);
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_omci_get_channel);
-
-/*******************************************************************************
-* tpm_set_port_igmp_frwd_mode()
-*
-* DESCRIPTION:      Set the IGMP status of a UNI port or WAN port.
-*
-* INPUTS:
-* src_port          - source port to set
-* state             - how to process IGMP packets
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_port_igmp_frwd_mode(tpm_src_port_type_t src_port,
-					     tpm_igmp_frwd_mode_t mode)
-{
-	tpm_error_code_t ret_code = TPM_RC_OK;
-	tpm_igmp_frwd_mode_t _mode;
-
-	tpm_db_igmp_get_port_frwd_mode(src_port, &_mode);
-
-	if (_mode != mode) {
-		if (TPM_SRC_PORT_WAN == src_port)
-			ret_code = tpm_proc_add_wan_port_igmp_rule(mode);
-		else
-			ret_code = tpm_proc_add_uni_port_igmp_rule(src_port, mode);
-
-		tpm_db_igmp_set_port_frwd_mode(src_port, mode);
-	}
-
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_set_port_igmp_frwd_mode);
-
-/*******************************************************************************
-* tpm_get_port_igmp_frwd_mode()
-*
-* DESCRIPTION:      Get the IGMP status of a UNI port or WAN port.
-*
-* INPUTS:
-* src_port          - source port to get
-*
-* OUTPUTS:
-* state             - how to process IGMP packets
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_port_igmp_frwd_mode(tpm_src_port_type_t src_port,
-					     tpm_igmp_frwd_mode_t *mode)
-{
-	if (!mode)
-		return ERR_NULL_POINTER;
-
-	tpm_db_igmp_get_port_frwd_mode(src_port, mode);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_get_port_igmp_frwd_mode);
-
-/*******************************************************************************
-* tpm_set_igmp_cpu_rx_queue()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to.
-*
-* INPUTS:
-* queue             - queue number
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_igmp_cpu_rx_queue(uint32_t queue)
-{
-	tpm_error_code_t ret_code = TPM_RC_OK;
-	uint32_t _queue;
-	tpm_igmp_frwd_mode_t _mode;
-	tpm_src_port_type_t src_port;
-
-	tpm_db_igmp_get_cpu_queue(&_queue);
-
-	if (_queue != queue) {
-		tpm_db_igmp_set_cpu_queue(queue);
-
-		for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_WAN; src_port++) {
-
-			/* virt uni do not need to add PNC entry for IGMP */
-			if (  (src_port == TPM_SRC_PORT_UNI_VIRT)
-				|| (tpm_db_eth_port_switch_port_get(src_port) == TPM_DB_ERR_PORT_NUM)){
-				TPM_OS_INFO(TPM_TPM_LOG_MOD, " src_port %d\n", src_port);
-				continue;
-			}
-			tpm_db_igmp_get_port_frwd_mode(src_port, &_mode);
-
-			if (TPM_IGMP_FRWD_MODE_SNOOPING == _mode) {
-
-				if (TPM_SRC_PORT_WAN == src_port)
-					ret_code |= tpm_proc_add_wan_port_igmp_rule(_mode);
-				else
-					ret_code |= tpm_proc_add_uni_port_igmp_rule(src_port, _mode);
-			}
-		}
-	}
-
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_set_igmp_cpu_rx_queue);
-
-/*******************************************************************************
-* tpm_get_igmp_cpu_rx_queue()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to.
-*
-* INPUTS:
-* queue             - queue number
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_igmp_cpu_rx_queue(uint32_t *queue)
-{
-	if (!queue)
-		return ERR_NULL_POINTER;
-
-	tpm_db_igmp_get_cpu_queue(queue);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_get_igmp_cpu_rx_queue);
-
-/*******************************************************************************
-* tpm_set_igmp_proxy_sa_mac()
-*
-* DESCRIPTION:      Set source mac address replaced for igmp proxy.
-*
-* INPUTS:
-* sa_mac          - source mac
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_igmp_proxy_sa_mac(uint8_t *sa_mac)
-{
-	tpm_db_set_mc_igmp_proxy_sa_mac(sa_mac);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_set_igmp_proxy_sa_mac);
-
-/*******************************************************************************
-* tpm_get_igmp_proxy_sa_mac()
-*
-* DESCRIPTION:      Get source mac address replaced for igmp proxy.
-*
-* INPUTS:
-* sa_mac          - source mac
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_igmp_proxy_sa_mac(uint8_t *sa_mac)
-{
-	uint8_t mac[6], mac_valid;
-
-	tpm_db_get_mc_igmp_proxy_sa_mac(mac, &mac_valid);
-	if (mac_valid)
-		memcpy(sa_mac, mac, 6 * sizeof(uint8_t));
-	else
-		return ERR_GENERAL;
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_get_igmp_proxy_sa_mac);
-
-/*******************************************************************************
-* tpm_oam_epon_get_channel()
-*
-* DESCRIPTION:      Retrieves OAM EPON management protocol channel information.
-*
-* INPUTS:
-*  None.
-*
-* OUTPUTS:
-* is_valid           -  indicates that the OMCI channel is valid or not.
-* cpu_rx_queue       - for OAM (EPON) Rx frames - the CPU rx queue number.
-* llid_num           - for OAM (EPON)Tx frames - the LLID number where to send the OMCI frames.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_get_channel(uint32_t *is_valid,
-					  uint32_t *cpu_rx_queue,
-					  tpm_trg_port_type_t *llid_num)
-{
-	uint32_t dummy_cpu_tx_queue;
-
-	if (!is_valid || !cpu_rx_queue || !llid_num)
-		return ERR_NULL_POINTER;
-
-	tpm_db_oam_channel_get(is_valid, cpu_rx_queue, &dummy_cpu_tx_queue, llid_num);
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_oam_epon_get_channel);
-
-/*******************************************************************************
-* tpm_get_api_ownership()
-*
-* DESCRIPTION:      Retrieves OAM EPON management protocol channel information.
-*
-* INPUTS:
-* api_type          - Specifies the API group whom owner_id is requested.
-*
-* OUTPUTS:
-* owner_id           - specifies the ownerId of the application group
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS.
-* On error:     API_TYPE_UNKNOWN  when illegal API group
-*               API_OWNERSHIP_ERROR  other errors.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_api_ownership_error_t tpm_get_api_ownership(uint32_t *owner_id,
-						tpm_api_type_t api_type)
-{
-	printk(KERN_WARNING "\n  <<tpm_oam_epon_get_channel>> NOT implemented. \n");
-	owner_id = 0;
-	return API_OWNERSHIP_SUCCESS;
-}
-EXPORT_SYMBOL(tpm_get_api_ownership);
-
-/******************************************************************************/
-/************************** Packet modification APIs **************************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_mod_entry_set()
-*
-* DESCRIPTION: The API sets a complete Modification table entry
-*
-* INPUTS:   trg_port    - target port
-*           mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           int_mod_bm  - set of internal flags
-*           mod_data    - modification entry data
-*
-* OUTPUTS:
-*           mod_entry   - start entry number which has been set for this
-*                         modification
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_set(tpm_trg_port_type_t trg_port,
-				   tpm_pkt_mod_bm_t mod_bm,
-				   tpm_pkt_mod_int_bm_t int_mod_bm,
-				   tpm_pkt_mod_t *mod_data,
-				   uint32_t *mod_entry)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-	tpm_gmacs_enum_t gmac_port;
-
-	/*printk("tpm_mod_entry_set: trg_port = %d\n", trg_port); */
-
-	tpm_proc_trg_port_gmac_map(trg_port, &gmac_port);
-	if (gmac_port == TPM_INVALID_GMAC) {
-		printk(KERN_ERR "ERROR: PKT modification not possible on this target port(%d) \n", trg_port);
-		rc = ERR_ACTION_INVALID;
-	} else
-		rc = tpm_mod2_entry_set(TPM_MOD_OWNER_CPU, gmac_port, mod_bm, int_mod_bm, mod_data, mod_entry);
-
-	return rc;
-}
-EXPORT_SYMBOL(tpm_mod_entry_set);
-
-/*******************************************************************************
-* tpm_mod_entry_get()
-*
-* DESCRIPTION: The API gets Modification table entries
-*
-* INPUTS:   trg_port    - target port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*           valid_cmds  - number of valid commands in the chunk
-*                             0 - there is no requested data
-*           pnc_ref     - Number of references from Pnc entries to this modification rule
-*           rule        - modification rule (set of modification entries)
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_get(tpm_trg_port_type_t trg_port,
-				   uint32_t mod_entry,
-				   uint16_t *valid_cmds,
-				   uint16_t *pnc_ref,
-				   tpm_mod_rule_t *rule)
-{
-	tpm_gmacs_enum_t gmac_port;
-	tpm_error_code_t rc = TPM_RC_OK;
-
-	/*printk("tpm_mod_entry_get: trg_port = %d mod_entry = %d\n", trg_port, mod_entry); */
-
-	tpm_proc_trg_port_gmac_map(trg_port, &gmac_port);
-	if (gmac_port == TPM_INVALID_GMAC) {
-		printk(KERN_ERR "ERROR: PKT modification not possible on this target port(%d) \n", trg_port);
-		rc = ERR_ACTION_INVALID;
-	} else {
-		*pnc_ref = 0;
-
-		if (tpm_mod2_entry_get(gmac_port, mod_entry, valid_cmds, rule) != TPM_OK)
-			rc = ERR_GENERAL;
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(tpm_mod_entry_get);
-
-/*******************************************************************************
-* tpm_mod_entry_del()
-*
-* DESCRIPTION: The API invalidates a modification entry chunk
-*
-* INPUTS:   trg_port    - target port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_del(tpm_trg_port_type_t trg_port,
-				   uint32_t mod_entry)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-	tpm_gmacs_enum_t gmac_port;
-
-	/*printk("tpm_mod_entry_del: trg_port = %d mod_entry = %d\n", trg_port, mod_entry); */
-
-	tpm_proc_trg_port_gmac_map(trg_port, &gmac_port);
-	if (gmac_port == TPM_INVALID_GMAC) {
-		printk(KERN_ERR "ERROR: PKT modification not possible on this target port(%d) \n", trg_port);
-		rc = ERR_ACTION_INVALID;
-	} else
-		rc = tpm_mod2_entry_del(TPM_MOD_OWNER_CPU, gmac_port, mod_entry);
-
-	return rc;
-}
-EXPORT_SYMBOL(tpm_mod_entry_del);
-
-/*******************************************************************************
-* tpm_mod_mac_inv()
-*
-* DESCRIPTION: The API resets Modification table for a specified port
-*
-* INPUTS:   trg_port    - target port
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_mac_inv(tpm_trg_port_type_t trg_port)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-	tpm_gmacs_enum_t gmac_port;
-
-	/*printk("tpm_mod_mac_inv: trg_port = %d\n", trg_port); */
-
-	tpm_proc_trg_port_gmac_map(trg_port, &gmac_port);
-	if (gmac_port == TPM_INVALID_GMAC) {
-		printk(KERN_ERR "ERROR: PKT modification not possible on this target port(%d) \n", trg_port);
-		rc = ERR_ACTION_INVALID;
-	} else {
-		if (tpm_db_mod2_inv_mac_entries(gmac_port) != TPM_OK) {
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to reset database (%d) \n", gmac_port);
-			rc = TPM_FAIL;
-		}
-
-		if (tpm_mod2_mac_inv(gmac_port) != TPM_OK) {
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to reset hardware (%d) \n", gmac_port);
-			rc = TPM_FAIL;
-		}
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(tpm_mod_mac_inv);
-
-/*******************************************************************************
-* tpm_rx_igmp_frame()
-*
-* DESCRIPTION: The API rx IGMP frames from either LAN or WAN side,
-*              it will be blocked until a packet arrived.
-*
-* INPUTS:   owner_id    - owner id
-*           buf         - Message buffer allocated by user
-*           len         - Max len of this buffer
-*
-* OUTPUTS:
-*           llid        - source LLID index in case this frame comes from WAN side
-*           src_port    - source UNI port in case this frame comes from LAN side
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_rx_igmp_frame(uint32_t owner_id,
-				   uint16_t *llid,
-				   tpm_src_port_type_t *src_port,
-				   uint8_t *buf,
-				   uint32_t *len)
-{
-	static struct socket *sock = NULL;
-	struct msghdr msg;
-	struct iovec iov;
-	int32_t length, error;
-	mm_segment_t oldfs;
-	static uint8_t temp_buf[MAX_FRAME_SIZE];
-
-	if (NULL == sock) {
-		/* First create a socket */
-		error = sock_create(AF_PACKET, SOCK_RAW, htons(0xa000), &sock);
-		if (error < 0) {
-			printk(KERN_ERR "%s: sock_create(AF_PACKET, SOCK_RAW, htons(0xbaba)) failed. errno = %d\n",
-			       __func__, error);
-			return ERR_GENERAL;
-		}
-	}
-
-	/* Set the msghdr structure */
-	msg.msg_name = 0;
-	msg.msg_namelen = 0;
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_control = NULL;
-	msg.msg_controllen = 0;
-	msg.msg_flags = 0;
-
-	/* Set the iovec structure */
-	iov.iov_base = (void *)&temp_buf[0];
-	iov.iov_len = (size_t) MAX_FRAME_SIZE;
-
-	/* Recieve the message */
-	oldfs = get_fs();
-	set_fs(KERNEL_DS);
-	length = sock_recvmsg(sock, &msg, MAX_FRAME_SIZE, msg.msg_flags);
-	set_fs(oldfs);
-
-	if (length <= 2)
-		return ERR_GENERAL;
-	else {
-		*len = length - 2;
-
-		/* Set by MV_CUST_EXT IGMP RX */
-		if (2 == temp_buf[0]) {
-			*llid = (temp_buf[1] & 0x0F) - 1;
-			*src_port = TPM_SRC_PORT_WAN;
-		} else
-			*src_port = tpm_db_phy_convert_port_index(temp_buf[1]);
-			/* How to support GMAC1? */
-
-		memcpy(buf, &(temp_buf[2]), length - 2);
-	}
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_rx_igmp_frame);
-
-/*******************************************************************************
-* tpm_tx_igmp_frame()
-*
-* DESCRIPTION: The API tx IGMP frames to either LAN or WAN side
-*
-* INPUTS:   owner_id    - owner id
-*           tgt_port    - target port, LLID0-7/TCONT0-7/UNI0-3
-*           tgt_queue   - target queue, 0-7
-*           gem_port    - target gem port ID
-*           buf         - Message buffer allocated by user
-*           len         - Len of this buffer
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tx_igmp_frame(uint32_t owner_id,
-				   tpm_trg_port_type_t tgt_port,
-				   uint8_t tgt_queue,
-				   uint16_t gem_port,
-				   uint8_t *buf,
-				   uint32_t len)
-{
-	static struct socket *sock = NULL;
-	struct msghdr msg;
-	struct iovec iov;
-	int32_t length, error;
-	mm_segment_t oldfs;
-	static uint8_t temp_buf[MAX_FRAME_SIZE];
-
-	if (NULL == sock) {
-		/* First create a socket */
-		error = sock_create(AF_PACKET, SOCK_RAW, htons(0xa000), &sock);
-		if (error < 0) {
-			printk(KERN_ERR "%s: sock_create(AF_PACKET, SOCK_RAW, htons(0xbaba)) failed. errno = %d\n",
-			       __func__, error);
-			return ERR_GENERAL;
-		}
-	}
-
-	/* Set the msghdr structure */
-	msg.msg_name = 0;
-	msg.msg_namelen = 0;
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_control = NULL;
-	msg.msg_controllen = 0;
-	msg.msg_flags = 0;
-
-	/* Set the iovec structure */
-	iov.iov_base = (void *)&temp_buf[0];
-	iov.iov_len = (size_t) (len + 4);
-
-	memcpy(&temp_buf[4], buf, len);
-	/* BYTE 0 to 3 will be used by MV_CUST_EXT */
-	temp_buf[0] = tgt_port;
-	temp_buf[1] = tgt_queue;
-	temp_buf[2] = (gem_port & 0xff00) >> 8;
-	temp_buf[3] = gem_port & 0xff;
-
-	if ((tgt_port & TPM_TRG_TCONT_0) || (tgt_port & TPM_TRG_TCONT_1) ||
-	    (tgt_port & TPM_TRG_TCONT_2) || (tgt_port & TPM_TRG_TCONT_3) ||
-	    (tgt_port & TPM_TRG_TCONT_4) || (tgt_port & TPM_TRG_TCONT_5) ||
-	    (tgt_port & TPM_TRG_TCONT_6) || (tgt_port & TPM_TRG_TCONT_7)) {
-		struct net_device *dev = NULL;
-		struct sockaddr sockAddr;
-		struct sockaddr_ll *sockAddr_ll = (struct sockaddr_ll *)&sockAddr;
-
-		/*strcpy(ifReq.ifr_name, "pon0"); */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-		dev = dev_get_by_name("pon0");
-#else
-		dev = dev_get_by_name(sock_net(sock->sk), "pon0");
-#endif
-		if (dev == NULL) {
-			printk(KERN_ERR "%s: pon0 interface not found \n", __func__);
-			return ERR_GENERAL;
-		}
-		sockAddr_ll->sll_ifindex = dev->ifindex;
-		sockAddr_ll->sll_family = AF_PACKET;
-		sockAddr_ll->sll_protocol = htons(0xa000);
-
-		oldfs = get_fs();
-		set_fs(KERNEL_DS);
-		if (sock->ops->bind(sock, &sockAddr, sizeof(struct sockaddr_ll)) < 0) {
-			set_fs(oldfs);
-			printk(KERN_ERR "%s: sock->ops->ioctl(sock,SIOCGIFINDEX,&ifReq) failed.\n", __func__);
-			return ERR_GENERAL;
-		}
-		set_fs(oldfs);
-
-		if (tgt_port & TPM_TRG_TCONT_0) {
-			temp_buf[0] = 0;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_1) {
-			temp_buf[0] = 1;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_2) {
-			temp_buf[0] = 2;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_3) {
-			temp_buf[0] = 3;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_4) {
-			temp_buf[0] = 4;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_5) {
-			temp_buf[0] = 5;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_6) {
-			temp_buf[0] = 6;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-		if (tgt_port & TPM_TRG_TCONT_7) {
-			temp_buf[0] = 7;
-			oldfs = get_fs();
-			set_fs(KERNEL_DS);
-			length = sock_sendmsg(sock, &msg, len + 4);
-			set_fs(oldfs);
-		}
-	} else {
-		struct net_device *dev = NULL;
-		struct sockaddr sockAddr;
-		struct sockaddr_ll *sockAddr_ll = (struct sockaddr_ll *)&sockAddr;
-
-		/*strcpy(ifReq.ifr_name, "pon0"); */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-		dev = dev_get_by_name("eth0");
-#else
-		dev = dev_get_by_name(sock_net(sock->sk), "eth0");
-#endif
-		if (dev == NULL) {
-			printk(KERN_ERR "%s: eth0 interface not found \n", __func__);
-			return ERR_GENERAL;
-		}
-		sockAddr_ll->sll_ifindex = dev->ifindex;
-		sockAddr_ll->sll_family = AF_PACKET;
-		sockAddr_ll->sll_protocol = htons(0xa000);
-
-		oldfs = get_fs();
-		set_fs(KERNEL_DS);
-		if (sock->ops->bind(sock, &sockAddr, sizeof(struct sockaddr_ll)) < 0) {
-			set_fs(oldfs);
-			printk(KERN_ERR "%s: sock->ops->ioctl(sock,SIOCGIFINDEX,&ifReq) failed.\n", __func__);
-			return ERR_GENERAL;
-		}
-		set_fs(oldfs);
-
-		/* Always go to queue 7 */
-		temp_buf[1] = 7;
-		if (TPM_TRG_PORT_UNI_ANY & tgt_port)
-			temp_buf[3] = 0;
-		else
-			temp_buf[3] = tpm_db_trg_port_switch_port_get(tgt_port);
-
-		oldfs = get_fs();
-		set_fs(KERNEL_DS);
-		length = sock_sendmsg(sock, &msg, len + 4);
-		set_fs(oldfs);
-
-		/* How to support GMAC1? */
-	}
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_tx_igmp_frame);
-
-/*******************************************************************************
-* tpm_add_cpu_wan_loopback()
-*
-* DESCRIPTION: The API add CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:   owner_id    - APP owner id  should be used for all API calls.
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-*
-* OUTPUTS:
-*           mod_idx     - Returned by HW modification, to fill Tx description
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_cpu_wan_loopback(uint32_t owner_id,
-					  tpm_pkt_frwd_t *pkt_frwd,
-					  uint32_t *mod_idx)
-{
-	tpm_error_code_t ret_code;
-	ret_code = tpm_proc_add_cpu_wan_loopback(owner_id, pkt_frwd, mod_idx);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_add_cpu_wan_loopback);
-
-/*******************************************************************************
-* tpm_del_cpu_wan_loopback()
-*
-* DESCRIPTION: The API delete CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:   owner_id    - APP owner id  should be used for all API calls.
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_cpu_wan_loopback(uint32_t owner_id,
-					  tpm_pkt_frwd_t *pkt_frwd)
-{
-	tpm_error_code_t ret_code;
-	ret_code = tpm_proc_del_cpu_wan_loopback(owner_id, pkt_frwd);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_del_cpu_wan_loopback);
-
-/*******************************************************************************
-* tpm_get_pnc_lu_entry()
-*
-* DESCRIPTION: The API get least used PnC rule by in specific PnC range
-*
-* INPUTS:   owner_id        - APP owner id  should be used for all API calls
-*           api_type       - TPM API group type
-*           lu_num          - The required number of least used PnC entries
-*           lu_reset        - Whether need to reset counter after read LU
-*
-*
-* OUTPUTS:
-*           valid_num       - The valid number of least used PnC entries
-*           count_array     - The least used PnC entry index  and hit counter array
-*           unrelated_num   - The unlelated number of least used PnC entries
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_lu_entry(uint32_t owner_id,
-				      tpm_api_type_t api_type,
-				      uint16_t lu_num,
-				      uint8_t lu_reset,
-				      uint16_t *valid_num,
-				      tpm_api_entry_count_t *count_array,
-				      uint16_t *unrelated_num)
-{
-	tpm_error_code_t ret_code;
-	ret_code = tpm_count_get_pnc_lu_entry(owner_id, api_type, lu_num, lu_reset, valid_num, count_array,
-					      unrelated_num);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_get_pnc_lu_entry);
-/*******************************************************************************
-* tpm_get_pnc_all_hit_counters
-*
-* DESCRIPTION: The API returns all PnC hit counters per API type lower than a given threshold
-*
-* INPUTS:   owner_id            - APP owner id  should be used for all API calls
-*           api_type            - TPM API group type
-*           high_thresh_pkts    - High threashold watermark, counters lower than will be returned
-*           counters_reset      - Reset API group type counters after read (0-false, 1-true)
-*           valid_counters      - The count_array size (entry number, not byte count)
-*
-* OUTPUTS:  valid_counters      - The valid number of entries copied to count_array
-*           count_array         - The PnC entries for the API type lower than high_thresh_pkts
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_all_hit_counters(uint32_t owner_id,
-					      tpm_api_type_t api_type,
-					      uint32_t high_thresh_pkts,
-					      uint8_t counters_reset,
-					      uint16_t *valid_counters,
-					      tpm_api_entry_count_t *count_array)
-{
-	tpm_error_code_t ret_code;
-	ret_code = tpm_count_get_pnc_all_hit_counters(owner_id, api_type, high_thresh_pkts,
-						      counters_reset, valid_counters, count_array);
-	return(ret_code);
-}
-/*******************************************************************************
-* tpm_set_pnc_counter_mask()
-*
-* DESCRIPTION: The API set the least used scanner ability, to mask or enable it
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           lu_rule_mask - The least used scanner mask, 1: maskscanner ,
-*                          0:enable scanner
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pnc_counter_mask(uint32_t owner_id,
-					  tpm_api_type_t api_type,
-					  uint32_t rule_idx,
-					  uint32_t lu_rule_mask)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_count_set_pnc_counter_mask(owner_id, api_type, rule_idx, lu_rule_mask);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_set_pnc_counter_mask);
-
-/*******************************************************************************
-* tpm_get_pnc_hit_count()
-*
-* DESCRIPTION: The API get the hit counter according to rule_idx
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           hit_reset    - Should the API reset the hit counters after after reading
-*
-* OUTPUTS:
-*           rule_idx     - The hitted times of specific PnC rule
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_hit_count(uint32_t owner_id,
-				       tpm_api_type_t api_type,
-				       uint32_t rule_idx,
-				       uint8_t  hit_reset,
-				       uint32_t *hit_count)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_count_get_pnc_hit_count(owner_id, api_type, rule_idx, hit_reset, hit_count);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_get_pnc_hit_count);
-
-/*******************************************************************************
-* tpm_set_pnc_lu_threshold()
-*
-* DESCRIPTION: The API set the theshold packets number for least used scanner
-*
-* INPUTS:   owner_id       - APP owner id  should be used for all API calls
-*           api_type      - TPM API group type
-*           lu_thresh_pkts - The theshold number(hitted packets number) to be used
-*                            for least used scanner
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pnc_lu_threshold(uint32_t owner_id,
-					  tpm_api_type_t api_type,
-					  uint32_t lu_thresh_pkts)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_count_set_pnc_lu_threshold(owner_id, api_type, lu_thresh_pkts);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_set_pnc_lu_threshold);
-
-/*******************************************************************************
-* tpm_reset_pnc_age_group()
-*
-* DESCRIPTION: The API reset the hitted counter of all the PnC entries of specific
-*              group
-*
-* INPUTS:   owner_id      - APP owner id  should be used for all API calls
-*           api_type     - TPM API group type
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_reset_pnc_age_group(uint32_t owner_id,
-					 tpm_api_type_t api_type)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_count_reset_pnc_age_group(owner_id, api_type);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_reset_pnc_age_group);
-
-/*******************************************************************************
-* tpm_set_mc_vid_port_vids()
-*
-* DESCRIPTION: The API sets the multicast vid configuration for each UNI port
-*
-* INPUTS:   owner_id - APP owner id  should be used for all API calls
-*               mc_vid - multicast VID
-*               mc_vid_uniports_config - VID configurations for different uni ports
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mc_vid_port_vids(uint32_t owner_id,
-					  uint32_t mc_vid,
-					  tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	tpm_error_code_t ret;
-
-	ret = tpm_proc_set_mc_vid_port_vids(owner_id, mc_vid, mc_vid_uniports_config);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "set VID error\n");
-		return ERR_GENERAL;
-	}
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_set_mc_vid_port_vids);
-/*******************************************************************************
-* tpm_set_mtu_enable()
-*
-* DESCRIPTION:      enable or disable MTU checking.
-*
-* INPUTS:
-*           enable   - set MTU checking to enable or disable.
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu_enable(tpm_init_mtu_setting_enable_t  enable)
-{
-	tpm_db_set_mtu_enable(enable);
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_set_mtu()
-*
-* DESCRIPTION:      set the MTU value for PNC to check.
-*
-* INPUTS:
-*           mtu           - MTU value
-*           ethertype     - IPv4 or IPv6
-*           direction     - US or DS
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu(uint32_t mtu,
-			     tpm_mtu_ethertype_t ethertype,
-			     uint32_t direction)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_set_mtu(ethertype, direction, mtu);
-	return(ret_code);
-}
-
-/*******************************************************************************
-* tpm_set_pppoe_mtu()
-*
-* DESCRIPTION:      set the PPPoE packets MTU value for PNC to check.
-*
-* INPUTS:
-*           pppoe_mtu     - MTU value
-*           ethertype     - IPv4 or IPv6
-*           direction     - US or DS
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pppoe_mtu(uint32_t		pppoe_mtu,
-				   tpm_mtu_ethertype_t	ethertype,
-				   uint32_t		direction)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_set_pppoe_mtu(ethertype, direction, pppoe_mtu);
-	return(ret_code);
-}
-
-/*******************************************************************************
-* tpm_add_ctc_cm_acl_rule()
-*
-* DESCRIPTION:      Creates a new CTC CnM ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-* l2_parse_rule_bm
-* ipv4_parse_rule_bm
-*                    - Bitmap containing the significant flags for parsing fields of the packet.
-* l2_key
-* ipv4_key
-*                    - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frw            - Information for packet forwarding decision.
-* pkt_act            - Action associated to the rule
-*
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct precedence of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ctc_cm_acl_rule(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence,
-					 tpm_parse_fields_t l2_parse_rule_bm,
-					 tpm_parse_fields_t ipv4_parse_rule_bm,
-					 tpm_l2_acl_key_t *l2_key,
-					 tpm_ipv4_acl_key_t  *ipv4_key,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_pkt_action_t pkt_act,
-					 uint32_t pbits)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-	uint32_t rule_num;
-	tpm_parse_fields_t ipv6_parse_rule_bm = 0;
-	tpm_ipv6_acl_key_t ipv6_key;
-
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	/* Check API_section Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_CNM, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_ctc_cm_acl_rule_add(owner_id, src_port, precedence, l2_parse_rule_bm, ipv4_parse_rule_bm,
-					   ipv6_parse_rule_bm, l2_key, ipv4_key, &ipv6_key, pkt_frwd, pkt_act, pbits);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_CNM, rule_num);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ctc_cm_acl_rule);
-
-/*******************************************************************************
-* tpm_del_ctc_cm_acl_rule()
-*
-* DESCRIPTION:      Deletes an existing CTC CnM rule.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ctc_cm_acl_rule(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_ctc_cm_acl_rule_del(owner_id, src_port, precedence);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_del_ctc_cm_acl_rule);
-/*******************************************************************************
-* tpm_flush_vtu()
-*
-* DESCRIPTION:      Flush VTU on the Switch.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_flush_vtu(uint32_t owner_id)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_sw_flush_vtu(owner_id);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_flush_vtu);
-/*******************************************************************************
-* tpm_flush_atu()
-*
-* DESCRIPTION:      Flush ATU on the Switch.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* flush_type         - FLUSH all or FLUSH all dynamic
-* db_num             - ATU DB Num, only 0 should be used, since there is only one ATU DB right now.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_flush_atu(uint32_t owner_id, tpm_flush_atu_type_t flush_type, uint16_t db_num)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_sw_flush_atu(owner_id, flush_type, db_num);
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_flush_atu);
-
-/*******************************************************************************
-* tpm_rule_self_check()
-*
-* DESCRIPTION:      Performs TPM self check
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* check_level        - The check level determines to correct bad tpm rule or not in the API call
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_rule_self_check(uint32_t owner_id,
-				     tpm_self_check_level_enum_t check_level)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_self_check(owner_id, check_level);
-
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_rule_self_check);
-
-/*******************************************************************************
-* tpm_add_ctc_cm_ipv6_acl_rule()
-*
-* DESCRIPTION:      Creates a new CTC IPv6 CnM ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-* ipv6_parse_rule_bm
-*                    - Bitmap containing the significant flags for parsing fields of the packet.
-* ipv6_key
-*                    - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frw            - Information for packet forwarding decision.
-* pkt_act            - Action associated to the rule
-*
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct precedence of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ctc_cm_ipv6_acl_rule(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      uint32_t precedence,
-					      tpm_parse_fields_t ipv6_parse_rule_bm,
-					      tpm_ipv6_acl_key_t  *ipv6_key,
-					      tpm_pkt_frwd_t *pkt_frwd,
-					      tpm_pkt_action_t pkt_act,
-					      uint32_t pbits)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-	uint32_t rule_num;
-
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	/* Check API_section Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_CNM, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_ctc_cm_ipv6_acl_rule_add(owner_id, src_port, precedence, ipv6_parse_rule_bm,
-					        ipv6_key, pkt_frwd, pkt_act, pbits);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_CNM, rule_num);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ctc_cm_ipv6_acl_rule);
-
-/*******************************************************************************
-* tpm_ctc_cm_set_ipv6_parse_window()
-*
-* DESCRIPTION:      Set IPv6 CnM rule parse window
-*     Two sets of IPv6 parse window:
-*       - first 24 bytes from IPv6 Header, include fields like: NH, TC, SIP
-*       - second 24 bytes from IPv6 Header, include fields like: L4 ports and DIP
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* check_level        - The check level determines to correct bad tpm rule or not in the API call
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_set_ipv6_parse_window(uint32_t owner_id,
-						  tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_ctc_cm_set_ipv6_parse_win(owner_id, ipv6_parse_window);
-
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_ctc_cm_set_ipv6_parse_window);
-/*******************************************************************************
-* tpm_add_mac_learn_rule()
-*
-* DESCRIPTION:      Add a PNC L2 rule for source MAC learn
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* src_mac_addr       - MAC addr to learn
-* OUTPUTS:
-* rule_idx           - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_mac_learn_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_section Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_MAC_LEARN, 0);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_static_mac_rule(owner_id, src_mac_addr);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_MAC_LEARN, 0);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_mac_learn_rule);
-
-/*******************************************************************************
-* tpm_del_mac_learn_rule()
-*
-* DESCRIPTION:      Del a PNC L2 rule for source MAC learn
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* src_mac_addr       - L2_key define the src mac addr for mac learn.
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_mac_learn_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_del_static_mac_rule(owner_id, src_mac_addr);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_del_mac_learn_rule);
-
-/*******************************************************************************
-* tpm_mac_learn_default_rule_act_set()
-*
-* DESCRIPTION:      Set the action for mac learn default rule
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* action             - rule action for mac learn default.
-* OUTPUTS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mac_learn_default_rule_act_set(uint32_t owner_id, tpm_unknown_mac_conf_t mac_conf)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_mac_learn_default_rule_act_set(owner_id, mac_conf);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_mac_learn_default_rule_act_set);
-
-/*******************************************************************************
-* tpm_mac_learn_entry_num_get()
-*
-* DESCRIPTION:      Get the mac learn entry number currently in system
-*
-* INPUTS:
-* None
-* OUTPUTS:
-* entry_num          - current MAC learn entry count in MAC_LEARN range, not including default one
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mac_learn_entry_num_get(uint32_t *entry_num)
-{
-	tpm_error_code_t ret_code;
-
-	ret_code = tpm_proc_mac_learn_entry_num_get(entry_num);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_mac_learn_entry_num_get);
-
-/*******************************************************************************
-* tpm_set_gmac_loopback()
-*
-* DESCRIPTION: The API enable/disable loopback mode of gmac.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* gmac                 -
-* enable               - 1 for enable, 0 for disable
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_gmac_loopback (uint32_t	  owner_id,
-						tpm_gmacs_enum_t  gmac,
-						uint8_t		  enable)
-{
-	tpm_error_code_t ret_code = TPM_RC_OK;
-
-	ret_code = tpm_init_gmac_loopback(gmac, enable);
-
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_set_gmac_loopback);
-
-/*******************************************************************************
-* tpm_add_ds_load_balance_rule()
-*
-* DESCRIPTION: The API adds DS load balance PnC rules to set target port to GMAC0 or GMAC1
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L2 API:
-*                        TPM_L2_PARSE_MAC_DA|TPM_L2_PARSE_MAC_SA|TPM_L2_PARSE_ONE_VLAN_TAG
-*                        |TPM_L2_PARSE_TWO_VLAN_TAG|TPM_L2_PARSE_ETYPE|TPM_L2_PARSE_PPPOE_SES
-*                        |TPM_L2_PARSE_PPP_PROT|TPM_L2_PARSE_GEMPORT)
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L2 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE
-* l2_key             - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* tgrt_port          - target Port: GMAC0, GMAC1 or CPU
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ds_load_balance_rule(uint32_t owner_id,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_l2_acl_key_t *l2_key,
-						tpm_ds_load_balance_tgrt_t tgrt_port)
-{
-	tpm_error_code_t ret_code, busy_ret_code;
-
-	/* Check API_section Busy */
-	ret_code = tpm_proc_check_api_busy(TPM_API_DS_LOAD_BALANCE, rule_num);
-	if (ret_code != TPM_OK)
-		return(ret_code);
-
-	ret_code = tpm_proc_add_ds_load_balance_acl_rule(owner_id, rule_num, rule_idx,
-		parse_rule_bm, parse_flags_bm, l2_key, tgrt_port);
-
-	busy_ret_code = tpm_proc_api_busy_done(TPM_API_DS_LOAD_BALANCE, rule_num);
-	RET_BUSY_ERROR(ret_code, busy_ret_code);
-}
-EXPORT_SYMBOL(tpm_add_ds_load_balance_rule);
-
-/*******************************************************************************
-* tpm_del_ds_load_balance_rule()
-*
-* DESCRIPTION: The API delete CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ds_load_balance_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	tpm_error_code_t ret_code;
-	ret_code = tpm_proc_del_ds_load_balance_acl_rule(owner_id, rule_idx, TPM_EXT_CALL);
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_del_ds_load_balance_rule);
-
-/*******************************************************************************
-* tpm_xlate_uni_2_switch_port()
-*
-* DESCRIPTION: The API translates TPM logic UNI port into Switch port.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* uni_port           - TPM logic port that need to be translated.
-*
-* OUTPUTS:
-* switch_port      - switch port.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_xlate_uni_2_switch_port (uint32_t		  owner_id,
-						     tpm_src_port_type_t  uni_port,
-						     uint32_t		 *switch_port)
-{
-	tpm_error_code_t ret_code = TPM_RC_OK;
-
-	*switch_port = tpm_db_eth_port_switch_port_get(uni_port);
-	if (TPM_DB_ERR_PORT_NUM == *switch_port)
-		ret_code = ERR_SRC_PORT_INVALID;
-
-	return (ret_code);
-}
-EXPORT_SYMBOL(tpm_xlate_uni_2_switch_port);
-/*******************************************************************************
-* tpm_active_tcont()
-*
-* DESCRIPTION:    Function used to enable hwf to certain tcont.
-*
-* INPUTS:
-* tcont_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_active_tcont(uint32_t tcont_num)
-{
-	tpm_error_code_t ret_code;
-
-	/* active tcont hwf */
-	ret_code = tpm_proc_hwf_admin_set(TPM_ENUM_PMAC, tcont_num, true);
-
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_active_tcont);
-/*******************************************************************************
-* tpm_deactive_tcont()
-*
-* DESCRIPTION:    Function used to disable hwf to certain tcont.
-*
-* INPUTS:
-* tcont_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_deactive_tcont(uint32_t tcont_num)
-{
-	tpm_error_code_t ret_code;
-	/* deactive tcont hwf */
-	ret_code = tpm_proc_hwf_admin_set(TPM_ENUM_PMAC, tcont_num, false);
-
-	return ret_code;
-}
-EXPORT_SYMBOL(tpm_deactive_tcont);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.h
deleted file mode 100644
index d66aad8..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_api.h
+++ /dev/null
@@ -1,4204 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_api.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_API_H_
-#define _TPM_API_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "tpm_types.h"
-
-
-/******************************************************************************/
-/********************************** Administrative APIs ***********************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_create_ownerid()
-*
-* DESCRIPTION:      Creates an ownerId per an application group.
-*
-* INPUTS:
-*
-* OUTPUTS:
-* owner_id           - ID of an application group.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* This function is used for error prevention and not as a security mechanism.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_create_ownerid(uint32_t *owner_id);
-
-/*******************************************************************************
-* tpm_request_api_ownership()
-*
-* DESCRIPTION:      Establishes an ownership between owner_id and a group of APIs.
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* api_type          - the API type for which ownership is requested.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS.
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_api_ownership_error_t tpm_request_api_ownership(uint32_t 		owner_id,
-						    tpm_api_type_t 	api_type);
-
-/*******************************************************************************
-* tpm_erase_section()
-*
-* DESCRIPTION:      Erases a section per an application group.
-*
-* INPUTS:
-* owner_id          - API owner id  should be used for all API calls.
-* api_type          - the API PnC section to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_erase_section(uint32_t 		owner_id,
-				   tpm_api_type_t 	api_type);
-
-/*******************************************************************************
-* tpm_get_section_free_size()
-*
-* DESCRIPTION:      Returns the free size of an application group.
-*
-* INPUTS:
-* api_type          - the API type to retrieve section size for.
-*
-* OUTPUTS:
-* cur_size          - number of free entries for the API type.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_section_free_size(tpm_api_type_t 	 api_type,
-					   int32_t 		*cur_size);
-
-/******************************************************************************/
-/********************************** Data Forwarding APIs **********************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_add_l2_rule()
-*
-* DESCRIPTION:      Creates a new L2 processing ACL. Supports Table mode and ACL mode.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L2 API:
-*                        TPM_L2_PARSE_GEMPORT|
-*                        TPM_L2_PARSE_MAC_DA|TPM_L2_PARSE_MAC_SA|
-*                        TPM_L2_PARSE_ONE_VLAN_TAG|TPM_L2_PARSE_TWO_VLAN_TAG|
-*                        TPM_L2_PARSE_ETYPE| (Note: ETYPE recommended in tpm_add_l3_type_acl_rule)
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L2 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE
-* l2_key             - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap contains the set of packet fields to modify.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      possible "next_phase" for L2 API   -> STAGE_L3_TYPE , STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - If this API is in Table mode, this will equal to the rule_num,
-*                     otherwise it will be a unique number acrosss all API's.
-*
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_l2_rule(uint32_t 		owner_id,
-				 tpm_src_port_type_t 	src_port,
-				 uint32_t 		rule_num,
-				 uint32_t 	        *rule_idx,
-				 tpm_parse_fields_t 	parse_rule_bm,
-				 tpm_parse_flags_t 	parse_flags_bm,
-				 tpm_l2_acl_key_t      *l2_key,
-				 tpm_pkt_frwd_t        *pkt_frwd,
-				 tpm_pkt_mod_t         *pkt_mod,
-				 tpm_pkt_mod_bm_t 	pkt_mod_bm,
-				 tpm_rule_action_t     *rule_action);
-
-/*******************************************************************************
-* tpm_del_l2_rule()
-*
-* DESCRIPTION:      Deletes an existing L2 ACL primary rule.
-*                   Any of the existing entries may be deleted.
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - Rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_l2_rule(uint32_t owner_id,
-				 uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_l3_type_rule()
-*
-* DESCRIPTION:      Creates a new L3 (ether_type or pppoe proto) processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L3 API:
-*                        TPM_L2_PARSE_ETYPE|TPM_L2_PARSE_PPPOE_SES|TPM_L2_PARSE_PPP_PROT
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L3 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE
-* l3_key             - Structure for PPPoE proto or ether type.
-* pkt_frwd           - Information for packet forwarding decision.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      possible "next_phase" for L3 API   ->  STAGE_IPv4, STAGE_IPv6_GEN, STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, acrosss all API's.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_l3_type_rule(uint32_t 			owner_id,
-				      tpm_src_port_type_t 	src_port,
-				      uint32_t 			rule_num,
-				      uint32_t 		       *rule_idx,
-				      tpm_parse_fields_t 	parse_rule_bm,
-				      tpm_parse_flags_t 	parse_flags_bm,
-				      tpm_l3_type_key_t        *l3_key,
-				      tpm_pkt_frwd_t           *pkt_frwd,
-				      tpm_rule_action_t        *rule_action);
-
-/*******************************************************************************
-* tpm_del_l3_type_rule()
-*
-* DESCRIPTION:      Deletes an existing ethernet type or PPPoE proto access-list entry .
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_l3_type_rule(uint32_t owner_id,
-				      uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_ipv4_rule()
-*
-* DESCRIPTION:      Creates a new IPv4 processing ACL. Supports Table mode and ACL mode.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv4 API:
-*                        TPM_IPv4_PARSE_SIP|TPM_IPv4_PARSE_DIP|
-*                        TPM_IPv4_PARSE_DSCP|TPM_IPv4_PARSE_PROTO|
-*                        TPM_PARSE_L4_SRC|TPM_PARSE_L4_DST
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv4 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv4_key           - Information to create an IPv4 parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - VLAN packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify (used for GWY only - in SFU is NULL)
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase.
-*                      possible "next_phase" for IPv4 API   ->  STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - If this API is in Table mode, this will equal to the rule_num,
-*                     otherwise it will be a unique number acrosss all API's.
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_rule(uint32_t 		owner_id,
-				   tpm_src_port_type_t 	src_port,
-				   uint32_t 		rule_num,
-				   uint32_t 	       *rule_idx,
-				   tpm_parse_fields_t 	parse_rule_bm,
-				   tpm_parse_flags_t 	parse_flags_bm,
-				   tpm_ipv4_acl_key_t  *ipv4_key,
-				   tpm_pkt_frwd_t      *pkt_frwd,
-				   tpm_pkt_mod_t       *pkt_mod,
-				   tpm_pkt_mod_bm_t 	pkt_mod_bm,
-				   tpm_rule_action_t   *rule_action);
-
-/*******************************************************************************
-* tpm_del_ipv4_rule()
-*
-* DESCRIPTION:      Deletes an existing IPv4 ACL rule.
-*                   Both rule number and key are compulsory.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv4_rule(uint32_t owner_id,
-				   uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_ipv6_nh_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 NH processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_num           - Entry index to be added in the current ACL
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 NH API:
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* nh                 - Information to create a NH parsing key for the rule.
-* pkt_frwd           - Information for packet forwarding decision.
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 NH API   ->  STAGE_IPV6_L4,STAGE_DONE
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, acrosss all API's.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-* This version does not support HWF for IPV6. Therefore (pkt_frwd) params are N/A in this version.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_nh_rule(uint32_t 			owner_id,
-				      uint32_t 			rule_num,
-				      uint32_t 	       	       *rule_idx,
-				      tpm_parse_flags_t 	parse_flags_bm,
-				      tpm_nh_iter_t 		nh_iter,
-				      uint32_t 			nh,
-				      tpm_pkt_frwd_t   	       *pkt_frwd,
-				      tpm_rule_action_t        *rule_action);
-
-/*******************************************************************************
-* tpm_del_ipv6_nh_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 NH processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_nh_rule(uint32_t owner_id,
-				      uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_ipv6_gen_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 gen processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv6 GEN API:
-*                        TPM_IPv6_PARSE_SIP|TPM_IPv6_PARSE_DSCP|TPM_IPv6_PARSE_HOPL
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 GEN API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv6_gen_key     - Information to create an IPv6 gen parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 GEN API   ->  STAGE_IPv6_DIP, ,STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, acrosss all API's.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-* This version does not support HWF for IPV6. Therefore (pkt_mod_bm, pkt_mod, pkt_frwd) params are N/A in this version.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_gen_rule(uint32_t 			owner_id,
-					 tpm_src_port_type_t 		src_port,
-					 uint32_t 			rule_num,
-					 uint32_t 		       *rule_idx,
-					 tpm_parse_fields_t 		parse_rule_bm,
-					 tpm_parse_flags_t 		parse_flags_bm,
-					 tpm_ipv6_gen_acl_key_t      *ipv6_gen_key,
-					 tpm_pkt_frwd_t 	       *pkt_frwd,
-					 tpm_pkt_mod_t 		       *pkt_mod,
-					 tpm_pkt_mod_bm_t 		pkt_mod_bm,
-					 tpm_rule_action_t             *rule_action);
-
-/*******************************************************************************
-* tpm_del_ipv6_gen_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 gen processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_gen_rule(uint32_t owner_id,
-					 uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_ipv6_dip_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 DIP processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for IPv6 DIP API:
-*                        TPM_IPv6_PARSE_DIP
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for IPv6 DIP API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_PPPOE_TRUE|TPM_PARSE_FLAG_PPPOE_FALSE
-* ipv6_dip_key       - Information to create an IPv6 DIP parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for IPv6 GEN API   ->  STAGE_IPv6_NHSTAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx          - Unique rule identification number, acrosss all API's.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-* This version does not support HWF for IPV6. Therefore (pkt_mod_bm, pkt_mod, pkt_frwd) params are N/A in this version.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_dip_rule(uint32_t 		owner_id,
-				       tpm_src_port_type_t 	src_port,
-				       uint32_t 		rule_num,
-				       uint32_t 	       *rule_idx,
-				       tpm_parse_fields_t 	parse_rule_bm,
-				       tpm_parse_flags_t 	parse_flags_bm,
-				       tpm_ipv6_addr_key_t     *ipv6_dip_key,
-				       tpm_pkt_frwd_t          *pkt_frwd,
-				       tpm_pkt_mod_t           *pkt_mod,
-				       tpm_pkt_mod_bm_t 	pkt_mod_bm,
-				       tpm_rule_action_t       *rule_action);
-
-/*******************************************************************************
-* tpm_del_ipv6_dip_rule()
-*
-* DESCRIPTION:      Deletes an existng IPv6 DIP processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_dip_rule(uint32_t owner_id,
-				       uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_add_ipv6_l4_ports_rule()
-*
-* DESCRIPTION:      Creates a new IPv6 L4 processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter determines if the packet is arriving
-*                      from the WAN port, a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L4 API:
-*                        TPM_PARSE_L4_SRC|TPM_PARSE_L4_DST
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L4 API:
-*                        TPM_PARSE_FLAG_MTM_TRUE|TPM_PARSE_FLAG_MTM_FALSE|
-*                        TPM_PARSE_FLAG_TO_CPU_TRUE|TPM_PARSE_FLAG_TO_CPU_FALSE|
-*                        TPM_PARSE_FLAG_L4_TCP|TPM_PARSE_FLAG_L4_UDP
-* l4_key             - Information to create an L4 parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frwd           - Information for packet forwarding decision.
-* pkt_mod            - Packet modification information.
-* pkt_mod_bm         - Bitmap containing the significant fields to modify (used for GWY only - in SFU is NULL)
-* rule_action        - Action associated to the rule = drop/set target/set packet modification/to CPU
-*                      and the next phase (for GWY only).
-*                      possible "next_phase" for L4 API   ->  STAGE_DONE
-*
-* OUTPUTS:
-*  rule_idx          - Unique rule identification number, acrosss all API's.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-* This version does not support HWF for IPV6. Therefore (pkt_mod_bm, pkt_mod, pkt_frwd) params are N/A in this version.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_l4_ports_rule(uint32_t 			owner_id,
-					    tpm_src_port_type_t 	src_port,
-					    uint32_t 			rule_num,
-					    uint32_t 		       *rule_idx,
-					    tpm_parse_fields_t 		parse_rule_bm,
-					    tpm_parse_flags_t 		parse_flags_bm,
-					    tpm_l4_ports_key_t 	       *l4_key,
-					    tpm_pkt_frwd_t 	       *pkt_frwd,
-					    tpm_pkt_mod_t 	       *pkt_mod,
-					    tpm_pkt_mod_bm_t 		pkt_mod_bm,
-					    tpm_rule_action_t 	       *rule_action);
-
-/*******************************************************************************
-* tpm_del_ipv6_l4_ports_rule()
-*
-* DESCRIPTION:      Deletes an existng L4 processing ACL.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* rule_idx           - rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_l4_ports_rule(uint32_t owner_id,
-					    uint32_t rule_idx);
-
-
-tpm_error_code_t tpm_add_ipv6_gen_5t_rule(uint32_t owner_id,
-										tpm_dir_t src_dir,
-										uint32_t rule_num,
-										uint32_t *rule_idx,
-										tpm_parse_fields_t parse_rule_bm,
-										tpm_parse_flags_t parse_flags_bm,
-										tpm_l4_ports_key_t *l4_key,
-										tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-										tpm_pkt_frwd_t *pkt_frwd,
-										tpm_pkt_mod_t *pkt_mod,
-										tpm_pkt_mod_bm_t pkt_mod_bm,
-										tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_del_ipv6_gen_5t_rule(uint32_t owner_id, uint32_t rule_idx);
-
-tpm_error_code_t tpm_add_ipv6_dip_5t_rule(uint32_t owner_id,
-										tpm_dir_t src_dir,
-										uint32_t rule_num,
-										uint32_t *rule_idx,
-										tpm_parse_fields_t parse_rule_bm,
-										tpm_parse_flags_t parse_flags_bm,
-										tpm_l4_ports_key_t *l4_key,
-										tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-										tpm_ipv6_addr_key_t *ipv6_dip_key,
-										tpm_pkt_frwd_t *pkt_frwd,
-										tpm_pkt_mod_t *pkt_mod,
-										tpm_pkt_mod_bm_t pkt_mod_bm,
-										tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_del_ipv6_dip_5t_rule(uint32_t owner_id, uint32_t rule_idx);
-
-tpm_error_code_t tpm_add_ipv6_l4_ports_5t_rule(uint32_t owner_id,
-											tpm_dir_t src_dir,
-											uint32_t rule_num,
-											uint32_t *rule_idx,
-											tpm_parse_fields_t parse_rule_bm,
-											tpm_parse_flags_t parse_flags_bm,
-											tpm_l4_ports_key_t *l4_key,
-											tpm_pkt_frwd_t *pkt_frwd,
-											tpm_pkt_mod_t *pkt_mod,
-											tpm_pkt_mod_bm_t pkt_mod_bm,
-											tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_del_ipv6_l4_ports_5t_rule(uint32_t owner_id, uint32_t rule_idx);
-
-
-/******************************************************************************/
-/********************************** MC handling APIs **************************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_add_ipv4_mc_stream()
-*
-* DESCRIPTION:      Creates a new IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* igmp_mode          - Defines if stream is in snooping or in proxy mode. Not relevant when sending stream to CPU.
-*                        snooping_mode: Vlan_translation only
-*                        proxy_mode   : snooping_mode + Replace SA_MAC, and reduce TTL.
-*                                       For pppoe stream, replace unicast DA to MC DA, and delete pppoe header.
-* mc_stream_pppoe    - The stream's underlying L2 protocol.  0(IPv4oE), 1(IPv4oPPPoE)
-* vid                - VLAN ID (0-4095).
-*                      If set to 0xFFFF - do not care about vid.
-* ipv4_src_add       - IPv4 source IP address in network order.
-* ipv4_src_add       - IPv4 destination IP address in network order.
-* ignore_ipv4_src    - when set to 1 - the IP source is not part of the key.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*                   It is APIs caller responsibility to maintain the correct number of
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_mc_stream(uint32_t		 owner_id,
-					uint32_t 		stream_num,
-					tpm_mc_igmp_mode_t 	igmp_mode,
-					uint8_t 		mc_stream_pppoe,
-					uint16_t 		vid,
-					uint8_t 		ipv4_src_add[4],
-					uint8_t 		ipv4_dst_add[4],
-					uint8_t 		ignore_ipv4_src,
-					tpm_trg_port_type_t 	dest_port_bm);
-
-/*******************************************************************************
-* tpm_add_ipv4_mc_stream_set_queue()
-*
-* DESCRIPTION:      Creates a new IPv4 MC stream with dest Queue.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv4_src_add       - IPv4 source IP address in network order.
-* ipv4_src_add       - IPv4 destination IP address in network order.
-* ignore_ipv4_src    - when set to 1 - the IP source is not part of the key.
-* dest_queue          - destination queue number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv4_mc_stream_set_queue(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv4_src_add[4],
-					uint8_t ipv4_dst_add[4],
-					uint8_t ignore_ipv4_src,
-					uint16_t dest_queue,
-					tpm_trg_port_type_t dest_port_bm);
-
-/*******************************************************************************
-* tpm_updt_ipv4_mc_stream()
-*
-* DESCRIPTION:      Updates an existing IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_updt_ipv4_mc_stream(uint32_t 		owner_id,
-					 uint32_t 		stream_num,
-					 tpm_trg_port_type_t 	dest_port_bm);
-
-/*******************************************************************************
-* tpm_del_ipv4_mc_stream()
-*
-* DESCRIPTION:      Deletes an existing IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv4_mc_stream(uint32_t owner_id,
-					uint32_t stream_num);
-
-/*******************************************************************************
-* tpm_add_ipv6_mc_stream()
-*
-* DESCRIPTION:      Creates a new ipv6 MC stream.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv6_src_add       - ipv6 source IP address in network order.
-* ipv6_dst_add       - ipv6 destination IP address in network order.
-* ignore_ipv6_src    - when set to 1 - the IP source is not part of the key.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_mc_stream(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv6_src_add[16],
-					uint8_t ipv6_dst_add[16],
-					uint8_t ignore_ipv6_src,
-					tpm_trg_port_type_t dest_port_bm);
-
-/*******************************************************************************
-* tpm_add_ipv6_mc_stream_set_queue()
-*
-* DESCRIPTION:      Creates a new ipv6 MC stream with dest Queue.
-*                   It is APIs caller responsibility to maintain the correct number of
-*                   each stream number.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* vid                - VLAN ID (0-4095). If set to 4096 - stream is untagged.
-*                      If set to 0xFFFF - do not care.
-* ipv6_src_add       - ipv6 source IP address in network order.
-* ipv6_dst_add       - ipv6 destination IP address in network order.
-* ignore_ipv6_src    - when set to 1 - the IP source is not part of the key.
-* dest_queue          - destination queue number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ipv6_mc_stream_set_queue(uint32_t owner_id,
-					uint32_t stream_num,
-					tpm_mc_igmp_mode_t igmp_mode,
-					uint8_t mc_stream_pppoe,
-					uint16_t vid,
-					uint8_t ipv6_src_add[16],
-					uint8_t ipv6_dst_add[16],
-					uint8_t ignore_ipv6_src,
-					uint16_t dest_queue,
-					tpm_trg_port_type_t dest_port_bm);
-
-/*******************************************************************************
-* tpm_updt_ipv6_mc_stream()
-*
-* DESCRIPTION:      Updates an existing ipv6 MC stream.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-* dest_port_bm       - bitmap which includes all destination UNI ports.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_updt_ipv6_mc_stream(uint32_t 		owner_id,
-					 uint32_t 		stream_num,
-					 tpm_trg_port_type_t 	dest_port_bm);
-
-/*******************************************************************************
-* tpm_del_ipv6_mc_stream()
-*
-* DESCRIPTION:      Deletes an existing ipv6 MC stream.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ipv6_mc_stream(uint32_t owner_id,
-					uint32_t stream_num);
-
-/*******************************************************************************
-* tpm_set_mc_vid_port_vids()
-*
-* DESCRIPTION:         Sets the port_participation for a Multicast VID.
-*                      Each uni_port can be excluded, or member in (transparent, vlan_strip, vlan_translate) mode.
-* INPUTS:
-* owner_id                      - API owner id  should be used for all API calls.
-* mc_vid                        - The Multicast VID.
-* mc_vid_uniports_config        - Array of per_uni_port configurations.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mc_vid_port_vids(uint32_t 			owner_id,
-					  uint32_t 			mc_vid,
-					  tpm_mc_vid_port_vid_set_t    *mc_vid_uniports_config);
-
-/*******************************************************************************
-* tpm_set_port_igmp_frwd_mode()
-*
-* DESCRIPTION:      Set the IGMP status of a UNI port or WAN port.
-*
-* INPUTS:
-* src_port         - source port to set IGMP behavior for, valid values (WAN, UNI_0/1/2/3/4)
-* mode             - how to process IGMP packets (drop, forward, snoop_to_cpu)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_port_igmp_frwd_mode(tpm_src_port_type_t  src_port,
-					     tpm_igmp_frwd_mode_t mode);
-
-/*******************************************************************************
-* tpm_set_igmp_cpu_rx_queue()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to.
-*
-* INPUTS:
-* queue             - cpu queue number to send IGMP packets to.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_igmp_cpu_rx_queue(uint32_t queue);
-
-/*******************************************************************************
-* tpm_mib_reset()
-*
-* DESCRIPTION:      Performs MIB reset
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* reset_level        - The reset level determines the which elements will not be reset in the API call
-*                      (by comparing to the element's reset level)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mib_reset(uint32_t 		owner_id,
-			       tpm_reset_level_enum_t	reset_level);
-
-/******************************************************************************/
-/********************************** Management protocol APIs ******************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_omci_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OMCI management protocol.
-*                   The API sets the gemportid, the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* gem_port           - for OMCI Rx frames - the gem port wherefrom the OMCI frames are received.
-* cpu_rx_queue       - for OMCI Rx frames - the CPU rx queue number.
-* tcont_num          - for OMCI Tx frames - the TCONT number where to send the OMCI frames.
-* cpu_tx_queue       - for OMCI Tx frames - the CPU tx queue number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_add_channel(uint32_t 			owner_id,
-				      tpm_gem_port_key_t 	gem_port,
-				      uint32_t 			cpu_rx_queue,
-				      tpm_trg_port_type_t 	tcont_num,
-				      uint32_t 			cpu_tx_queue);
-
-/*******************************************************************************
-* tpm_omci_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OMCI management protocol.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_del_channel(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_oam_epon_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OAM EPON management protocol.
-*                   The API sets the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-* cpu_rx_queue       - for OAM (EPON) Rx frames - the CPU rx queue number.
-* llid_num           - for OAM (EPON)Tx frames - the LLID number where to send the OMCI frames.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_add_channel(uint32_t		owner_id,
-					  uint32_t		cpu_rx_queue,
-					  tpm_trg_port_type_t	llid_num);
-
-/*******************************************************************************
-* tpm_oam_epon_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OAM EPON management protocol.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_del_channel(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_oam_loopback_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the EPON OAM remote loopback.
-*
-*
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_loopback_add_channel(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_oam_loopback_del_channel()
-*
-* DESCRIPTION:      Delete the communication channel for the OAM remote loopback .
-*
-*
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_loopback_del_channel(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_loop_detect_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for loop detection application.
-*
-* INPUTS:
-* owner_id           - API owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_loop_detect_add_channel(uint32_t owner_id, tpm_ether_type_key_t ety);
-
-/*******************************************************************************
-* tpm_loop_detect_del_channel()
-*
-* DESCRIPTION:      remove a communication channel for loop detection management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_loop_detect_del_channel(uint32_t owner_id);
-
-/******************************************************************************/
-/********************************** Configuration retrieval APIs **************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_get_next_valid_rule()
-*
-* DESCRIPTION:      General purpose API to retrieve the internal configuration of an existing ACL.
-*
-* INPUTS:
-* owner_id            - API owner id  should be used for all API calls.
-* current_index       - the entry index in the section (rule_num/stream_num). In case it is (-1) - the get next function
-*                      will point to the first ruleof the section.
-* api_type            - TPM API type
-*
-* OUTPUTS:
-* next_index         - returns the first following index (rule_num/stream_num) after the index in the current_index
-*                      parameter. It is invalid, if there is no next_index.
-* rule_idx           - Unique rule identification number. Equals to stream_num for API's that are operating
-*                      in table mode.
-* tpm_rule           - points to a structure holding the information of a single rule,
-*                      of the type specified in the rule_type param.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_next_valid_rule(uint32_t		owner_id,
-					 int32_t 		current_index,
-					 tpm_api_type_t 	api_type,
-					 int32_t       	       *next_index,
-					 uint32_t	       *rule_idx,
-					 tpm_rule_entry_t      *tpm_rule);
-
-/*******************************************************************************
-* tpm_omci_get_channel()
-*
-* DESCRIPTION:      Retrieves the OMCI management protocol channel information.
-*
-* INPUTS:
-*  None.
-*
-* OUTPUTS:
-* is_valid           - indicates that the OMCI channel is valid or not.
-* gem_port           - for OMCI Rx frames - the gem port wherefrom the OMCI frames are received.
-* cpu_rx_queue       - for OMCI Rx frames - the CPU rx queue number.
-* tcont_num          - for OMCI Tx frames - the TCONT number where to send the OMCI frames.
-* cpu_tx_queue       - for OMCI Tx frames - the CPU tx queue number.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_omci_get_channel(uint32_t 			*is_valid,
-				      tpm_gem_port_key_t 	*gem_port,
-				      uint32_t 			*cpu_rx_queue,
-				      tpm_trg_port_type_t 	*tcont_num,
-				      uint32_t 			*cpu_tx_queue);
-
-/*******************************************************************************
-* tpm_get_port_igmp_frwd_mode()
-*
-* DESCRIPTION:      Get the IGMP status of a UNI port or WAN port.
-*
-* INPUTS:
-* src_port          - source port to get
-*
-* OUTPUTS:
-* state             - how to process IGMP packets
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_port_igmp_frwd_mode(tpm_src_port_type_t   src_port,
-					     tpm_igmp_frwd_mode_t *mode);
-
-/*******************************************************************************
-* tpm_get_igmp_cpu_rx_queue()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to.
-*
-* INPUTS:
-* queue             - queue number
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_igmp_cpu_rx_queue(uint32_t *queue);
-
-/*******************************************************************************
-* tpm_set_igmp_proxy_sa_mac()
-*
-* DESCRIPTION:      Set source mac address replaced for igmp proxy.
-*
-* INPUTS:
-* sa_mac          - source mac
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_igmp_proxy_sa_mac(uint8_t *sa_mac);
-
-/*******************************************************************************
-* tpm_get_igmp_proxy_sa_mac()
-*
-* DESCRIPTION:      Get source mac address replaced for igmp proxy.
-*
-* INPUTS:
-* sa_mac          - source mac
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_igmp_proxy_sa_mac(uint8_t *sa_mac);
-
-/*******************************************************************************
-* tpm_oam_epon_get_channel()
-*
-* DESCRIPTION:      Retrieves OAM EPON management protocol channel information.
-*
-* INPUTS:
-*  None.
-*
-* OUTPUTS:
-* is_valid           -  indicates that the OMCI channel is valid or not.
-* cpu_rx_queue       - for OAM (EPON) Rx frames - the CPU rx queue number.
-* llid_num           - for OAM (EPON)Tx frames - the LLID number where to send the OMCI frames.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_oam_epon_get_channel(uint32_t		*is_valid,
-					  uint32_t 		*cpu_rx_queue,
-					  tpm_trg_port_type_t 	*llid_num);
-
-/*******************************************************************************
-* tpm_get_api_ownership()
-*
-* DESCRIPTION:      Retrieves OAM EPON management protocol channel information.
-*
-* INPUTS:
-* api_group          - Specifies the API group whom owner_id is requested.
-*
-* OUTPUTS:
-* owner_id           - specifies the ownerId of the application group
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS.
-* On error:     API_TYPE_UNKNOWN  when illegal API group
-*               API_OWNERSHIP_ERROR  other errors.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_api_ownership_error_t tpm_get_api_ownership(uint32_t      *owner_id,
-						tpm_api_type_t api_type);
-
-/******************************************************************************/
-/************************** Packet modification APIs **************************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_mod_entry_set()
-*
-* DESCRIPTION: The API sets a complete Modification table entry
-*
-* INPUTS:   trg_port    - target port
-*           mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           int_mod_bm  - set of internal flags
-*           mod_data    - modification entry data
-*
-* OUTPUTS:
-*           mod_entry   - start entry number which has been set for this
-*                         modification
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_set(tpm_trg_port_type_t 		trg_port,
-				   tpm_pkt_mod_bm_t 		mod_bm,
-				   tpm_pkt_mod_int_bm_t 	int_mod_bm,
-				   tpm_pkt_mod_t 	       *mod_data,
-				   uint32_t 		       *mod_entry);
-
-/*******************************************************************************
-* tpm_mod_entry_get()
-*
-* DESCRIPTION: The API gets Modification table entries
-*
-* INPUTS:   trg_port    - target port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*           valid_cmds  - number of valid commands in the chunk
-*                             0 - there is no requested data
-*           pnc_ref     - Number of references from Pnc entries to this modification rule
-*           rule        - modification rule (set of modification entries)
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_get(tpm_trg_port_type_t	trg_port,
-				   uint32_t 		mod_entry,
-				   uint16_t 	       *valid_cmds,
-				   uint16_t	       *pnc_ref,
-				   tpm_mod_rule_t      *rule);
-
-/*******************************************************************************
-* tpm_mod_entry_del()
-*
-* DESCRIPTION: The API invalidates a modification entry chunk
-*
-* INPUTS:   trg_port    - target port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_entry_del(tpm_trg_port_type_t 	trg_port,
-				   uint32_t 		mod_entry);
-
-/*******************************************************************************
-* tpm_mod_mac_inv()
-*
-* DESCRIPTION: The API resets Modification table for a specified port
-*
-* INPUTS:   trg_port    - target port
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mod_mac_inv(tpm_trg_port_type_t trg_port);
-
-/******************************************************************************/
-/*************************** Least Used & Hit Counters APIs *******************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_get_pnc_lu_entry()
-*
-* DESCRIPTION: The API get least used PnC rule by in specific PnC range
-*
-* INPUTS:   owner_id        - API owner id  should be used for all API calls
-*           api_type        - TPM API type
-*           lu_num          - The required number of least used PnC entries
-*           lu_reset        - Should the API reset the counters after after reading the LU Counters
-*
-*
-* OUTPUTS:
-*           valid_num       - Number of valid least used PnC entries
-*           count_array     - Array of the returned least used PnC entry rule_idx  and hit_counter.
-*           unrelated_num   - Number of unrelated  least used PnC entries
-*                             (PnC entries which were not part of this API_type)
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_lu_entry(uint32_t			owner_id,
-				      tpm_api_type_t 		api_type,
-				      uint16_t 			lu_num,
-				      uint8_t 			lu_reset,
-				      uint16_t 		       *valid_num,
-				      tpm_api_entry_count_t    *count_array,
-				      uint16_t 		       *unrelated_num);
-/*******************************************************************************
-* tpm_get_pnc_all_hit_counters
-*
-* DESCRIPTION: The API returns all PnC hit counters per API type lower than a given threshold
-*
-* INPUTS:   owner_id            - APP owner id  should be used for all API calls
-*           api_type            - TPM API group type
-*           high_thresh_pkts    - High threashold watermark, counters lower than will be returned
-*           counters_reset      - Reset API group type counters after read (0-false, 1-true)
-*           valid_counters      - The count_array size (entry number, not byte count)
-*
-* OUTPUTS:
-*           valid_counters      - The valid number of entries copied to count_array
-*           count_array         - The PnC entries for the API type lower than high_thresh_pkts
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_all_hit_counters(uint32_t                owner_id,
-					      tpm_api_type_t          api_type,
-					      uint32_t                high_thresh_pkts,
-					      uint8_t                 counters_reset,
-					      uint16_t               *valid_counters,
-					      tpm_api_entry_count_t  *count_array);
-
-/*******************************************************************************
-* tpm_set_pnc_counter_mask()
-*
-* DESCRIPTION: The API set the ability to mask or unmask a specific API entry from being LU scanned.
-*
-* INPUTS:   owner_id     - API owner id  should be used for all API calls
-*           api_type     - TPM API type
-*           rule_idx     - The rule index of the requested entry.
-*           lu_rule_mask - The least used scanner mask
-*                            0:enable_scanner, 1: mask_from_scanner
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pnc_counter_mask(uint32_t		owner_id,
-					  tpm_api_type_t 	api_type,
-					  uint32_t 		rule_idx,
-					  uint32_t 		lu_rule_mask);
-
-/*******************************************************************************
-* tpm_get_pnc_hit_count()
-*
-* DESCRIPTION: The API get the hit counter according to rule_idx
-*
-* INPUTS:   owner_id     - API owner id  should be used for all API calls
-*           api_type     - TPM API type
-*           rule_idx     - The rule index of the requested entry.
-*           hit_reset    - Should the API reset the hit counters after after reading
-*
-* OUTPUTS:
-*           hit_count    - The number of hits of the rule.
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_pnc_hit_count(uint32_t 	owner_id,
-				       tpm_api_type_t 	api_type,
-				       uint32_t 	rule_idx,
-				       uint8_t		hit_reset,
-				       uint32_t        *hit_count);
-
-/*******************************************************************************
-* tpm_set_pnc_lu_threshold()
-*
-* DESCRIPTION: The API set the theshold packets number for least used scanner
-*
-* INPUTS:   owner_id       - API owner id  should be used for all API calls
-*           api_type       - TPM API type
-*           lu_thresh_pkts - The least_used theshold to be used for the lu_scanner, in number of packets.
-*                            Hit_counts above this threshold are not returned by the scanner,
-*                            even if they are the lowest amoung their peers.
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pnc_lu_threshold(uint32_t 		owner_id,
-					  tpm_api_type_t 	api_type,
-					  uint32_t 		lu_thresh_pkts);
-
-/*******************************************************************************
-* tpm_reset_pnc_age_group()
-*
-* DESCRIPTION: This API resets the hit counters of all the PnC entries of a specific
-*              API. It may reset other PnC entries as well, if they share the same hit_group.
-*
-* INPUTS:   owner_id       - API owner id  should be used for all API calls
-*           api_type       - TPM API type
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_reset_pnc_age_group(uint32_t 	owner_id,
-					 tpm_api_type_t api_type);
-
-/*******************************************************************************
-* tpm_add_cpu_wan_loopback()
-*
-* DESCRIPTION: The API allows the CPU to set the target for packets that will be
-*              loopbacked to the WAN port to a HWF queue, by means of packet_modification.
-*              It returns to the CPU the mod_idx to put in the Tx_Descriptor, so that the
-*              packet will be forwarded to the correct target. The cpu_loopback mechanism is
-*              done by use of GMAC1, it is assumed that GMAC0&GMAC1 are both connected to the Internal Switch.
-*
-* INPUTS:   owner_id    - owner id
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-* OUTPUTS:
-*           mod_idx     - Returned by HW modification, to fill Tx description
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_cpu_wan_loopback(uint32_t 		owner_id,
-					  tpm_pkt_frwd_t       *pkt_frwd,
-					  uint32_t 	       *mod_idx);
-
-/*******************************************************************************
-* tpm_del_cpu_wan_loopback()
-*
-* DESCRIPTION: The API delete CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:   owner_id    - owner id
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_cpu_wan_loopback(uint32_t 	  owner_id,
-					  tpm_pkt_frwd_t *pkt_frwd);
-
-/*******************************************************************************
-* tpm_rx_igmp_frame()
-*
-* DESCRIPTION: The API receives IGMP frames from either LAN or WAN side,
-*              it will be blocked until a packet arrived.
-*
-* INPUTS:   owner_id    - owner id
-*           buf         - Message buffer allocated by user
-*           len         - Max len of this buffer
-*
-* OUTPUTS:
-*           llid        - source LLID index in case this frame comes from WAN side
-*           src_port    - source UNI port in case this frame comes from LAN side
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_rx_igmp_frame(uint32_t 		owner_id,
-				   uint16_t 	       *llid,
-				   tpm_src_port_type_t *src_port,
-				   uint8_t 	       *buf,
-				   uint32_t 	       *len);
-/*******************************************************************************
-* tpm_tx_igmp_frame()
-*
-* DESCRIPTION: The API sends IGMP frames to either LAN or WAN side
-*
-* INPUTS:   owner_id    - owner id
-*           tgt_port    - target port, LLID0-7/TCONT0-7/UNI0-3
-*           tgt_queue   - target queue, 0-7
-*           gem_port    - target gem port ID
-*           buf         - Message buffer allocated by user
-*           len         - Len of this buffer
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tx_igmp_frame(uint32_t owner_id,
-				   tpm_trg_port_type_t tgt_port,
-				   uint8_t tgt_queue,
-				   uint16_t gem_port,
-				   uint8_t *buf,
-				   uint32_t len);
-
-/*******************************************************************************
-* tpm_set_mtu_enable()
-*
-* DESCRIPTION:      enable or disable MTU checking.
-*
-* INPUTS:
-*           enable   - set MTU checking to enable or disable.
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu_enable(tpm_init_mtu_setting_enable_t enable);
-
-/*******************************************************************************
-* tpm_set_mtu()
-*
-* DESCRIPTION:      set the MTU value for PNC to check.
-*
-* INPUTS:
-*           mtu           - MTU value
-*           ethertype     - IPv4 or IPv6
-*           direction     - US or DS
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu(uint32_t mtu,
-			     tpm_mtu_ethertype_t ethertype,
-			     uint32_t direction);
-
-/*******************************************************************************
-* tpm_set_pppoe_mtu()
-*
-* DESCRIPTION:      set the PPPoE packets MTU value for PNC to check.
-*
-* INPUTS:
-*           pppoe_mtu     - MTU value
-*           ethertype     - IPv4 or IPv6
-*           direction     - US or DS
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_pppoe_mtu(uint32_t pppoe_mtu,
-				   tpm_mtu_ethertype_t ethertype,
-				   uint32_t direction);
-
-tpm_error_code_t tpm_rule_self_check(uint32_t owner_id,
-				     tpm_self_check_level_enum_t check_level);
-
-/******************************************************************************/
-/********************************** Switch APIs *******************************/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_sw_add_static_mac
-*
-* DESCRIPTION:
-*       This function creates a static MAC entry in the MAC address table for a
-*       specific lport in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id, should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       static_mac  - 6 byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_add_static_mac(uint32_t owner_id,
-				       tpm_src_port_type_t src_port,
-				       uint8_t static_mac[6]);
-
-/*******************************************************************************
-* tpm_sw_del_static_mac
-*
-* DESCRIPTION:
-*       This function removes an existing static MAC entry from the MAC address
-*       table  in the integrated switch.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       static_mac  - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_del_static_mac(uint32_t owner_id,
-				       uint8_t static_mac[6]);
-
-/*******************************************************************************
-* tpm_sw_set_port_max_macs
-*
-* DESCRIPTION:
-*       This function limits the number of MAC addresses per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id  should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mac_per_port - maximum number of MAC addresses per port (1-255).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       The following care is needed when enabling this feature:
-*            1) disable learning on the ports
-*            2) flush all non-static addresses in the ATU
-*            3) define the desired limit for the ports
-*            4) re-enable learing on the ports
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_max_macs(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  uint8_t mac_per_port);
-
-/*******************************************************************************
-* tpm_sw_clear_dynamic_mac
-*
-* DESCRIPTION:
-*       Clear all dynamic MAC.
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_dynamic_mac(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_sw_set_port_mirror
-*
-* DESCRIPTION:
-*       Set port mirror.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       sport      - Source port.
-*       dport      - Destination port.
-*       mode       - mirror mode.
-*       enable     - enable/disable mirror.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_mirror(uint32_t owner_id,
-					uint32_t sport,
-					uint32_t dport,
-					tpm_sw_mirror_type_t mode,
-					bool enable);
-/*******************************************************************************
-* tpm_sw_set_trunk_ports
-*
-* DESCRIPTION:
-*       This function creates trunk ports and trunk id on switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       trunk_id    - valid from 0x0 to 0xf
-*       ports_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_trunk_ports
-(
-    uint32_t owner_id,
-    uint32_t trunk_id,
-    uint32_t ports_mask
-);
-/*******************************************************************************
-* tpm_sw_set_trunk_mask
-*
-* DESCRIPTION:
-*       This function sets trunk mask on switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       mask_num    - trunk mask number, valid from 0 to 7.
-*       trunk_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_trunk_mask
-(
-    uint32_t owner_id,
-    uint32_t mask_num,
-    uint32_t trunk_mask
-);
-
-/*******************************************************************************
-* tpm_sw_get_port_mirror
-*
-* DESCRIPTION:
-*       Get port mirror status.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       sport      - Source port.
-*       dport      - Destination port.
-*       mode       - mirror mode.
-*
-* OUTPUTS:
-*       enable     - enable/disable mirror.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_mirror(uint32_t owner_id,
-					uint32_t sport,
-					uint32_t dport,
-					tpm_sw_mirror_type_t mode,
-					bool *enable);
-
-/*******************************************************************************
-* tpm_sw_set_isolate_eth_port_vector()
-*
-* DESCRIPTION:      Isolate port vector.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       port_vector - port vector.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_isolate_eth_port_vector(uint32_t owner_id,
-						    tpm_src_port_type_t src_port,
-						    uint32_t port_vector);
-
-/*******************************************************************************
-* tpm_sw_get_isolate_eth_port_vector()
-*
-* DESCRIPTION:      Isolate port vector.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       port_vector - port vector.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_isolate_eth_port_vector(uint32_t owner_id,
-						    tpm_src_port_type_t src_port,
-						    uint32_t *port_vector);
-
-/*******************************************************************************
-* tpm_set_mtu_size
-*
-* DESCRIPTION:
-*       Set switch MTU size.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       type       - MRU type:GMAC0, GMAC1, PONMAC, switch
-*       mtu        - MTU size.
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu_size(uint32_t owner_id,
-				  tpm_mru_type_t type,
-				  uint32_t mtu);
-
-/*******************************************************************************
-* tpm_get_mtu_size
-*
-* DESCRIPTION:
-*       Get switch MTU size.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       type       - MRU type:GMAC0, GMAC1, PONMAC, switch
-*
-* OUTPUTS:
-*       mtu        - MTU size.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_mtu_size(uint32_t owner_id,
-				  tpm_mru_type_t type,
-				  uint32_t *mtu);
-
-/*******************************************************************************
-* tpm_sw_set_port_tagged
-*
-* DESCRIPTION:
-*       The API allows or drops tagged packets on a per lport basis.
-*
-* INPUTS:
-*       owner_id     - APP owner id should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       drop_tagged - set to 1 = drop tagged packets per lport
-*                      set to 0 = allow tagged packets per lport.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_tagged(uint32_t owner_id,
-					tpm_src_port_type_t src_port,
-					uint8_t drop_tagged);
-
-/*******************************************************************************
-* tpm_sw_get_port_tagged
-*
-* DESCRIPTION:
-*       This routine gets DiscardTagged bit for the given lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode       - MV_TRUE if DiscardTagged bit is set, MV_FALSE otherwise
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_tagged(uint32_t owner_id,
-					tpm_src_port_type_t src_port,
-					uint32_t *mode);
-
-/*******************************************************************************
-* tpm_sw_set_port_untagged
-*
-* DESCRIPTION:
-*       The API allows or drops untagged packets on a per UNI port basis.
-*
-* INPUTS:
-*       owner_id       - APP owner id should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       drop_untagged - set to 1 = drop untagged packets per lport
-*                        set to 0 = alow untagged packets per lport.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_untagged(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  uint8_t drop_untagged);
-
-/*******************************************************************************
-* tpm_sw_get_port_untagged
-*
-* DESCRIPTION:
-*       This routine gets DiscardUntagged bit for the given lport.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode        - MV_TRUE if DiscardUntagged bit is set, MV_FALSE otherwise
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_untagged(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  uint32_t *mode);
-
-/*******************************************************************************
-* tpm_sw_set_port_def_vlan
-*
-* DESCRIPTION:
-*       The API sets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - the port vlan id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_def_vlan(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  uint16_t vid);
-
-/*******************************************************************************
-* tpm_sw_get_port_def_vlan
-*
-* DESCRIPTION:
-*       The API gets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       vid        - the port vlan id
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_def_vlan(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  uint16_t *vid);
-
-/*******************************************************************************
-* tpm_sw_set_port_def_pri
-*
-* DESCRIPTION:
-*       The API sets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       pri        - the port priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_def_pri(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint8_t pri);
-
-/*******************************************************************************
-* tpm_sw_get_port_def_pri
-*
-* DESCRIPTION:
-*       The API gets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       pri        - the port priority.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_def_pri(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint8_t *pri);
-
-/*******************************************************************************
-* tpm_sw_port_add_vid
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of the allowed VIDs per lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       see the example sample802_1qSetup().
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid(uint32_t owner_id,
-				     tpm_src_port_type_t src_port,
-				     uint16_t vid);
-
-/*******************************************************************************
-* tpm_sw_port_add_vid_group()
-*
-* DESCRIPTION:  Add a group of VID to the list of the allowed VIDs per port,
-*               and set the egress mode correspondingly.
-*
-* INPUTS:
-*       owner_id - APP owner id should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode     - VLAN egress mode.
-*       min_vid  - min VLAN ID.
-*       max_vid  - max VLAN ID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid_group(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   uint8_t mode,
-					   uint16_t min_vid,
-					   uint16_t max_vid);
-
-/*******************************************************************************
-* tpm_sw_port_del_vid_group()
-*
-* DESCRIPTION:      Delete a group of VID to the list of the allowed VIDs per port,
-*                    and set the egress mode correspondingly.
-*
-* INPUTS:
-*       owner_id - APP owner id should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       min_vid  - min VLAN ID.
-*       max_vid  - max VLAN ID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_del_vid_group(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   uint16_t min_vid,
-					   uint16_t max_vid);
-
-/*******************************************************************************
-* tpm_sw_port_del_vid
-*
-* DESCRIPTION:
-*       The API delete and existing VID from the list of VIDs allowed per lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_del_vid(uint32_t owner_id,
-				     tpm_src_port_type_t src_port,
-				     uint16_t vid);
-
-/*******************************************************************************
-* tpm_sw_clear_vid_per_port
-*
-* DESCRIPTION:
-*       The API delete all VID from the list of VIDs allowed per lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_vid_per_port(uint32_t owner_id,
-					   tpm_src_port_type_t src_port);
-
-/*******************************************************************************
-* tpm_sw_add_all_vid_per_port
-*
-* DESCRIPTION:
-*       The API adds all allowed VIDs from 1 to 4095 per lport.
-*
-* INPUTS:
-*       owner_id - APP owner id should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_add_all_vid_per_port(uint32_t owner_id,
-					     tpm_src_port_type_t src_port);
-
-/*******************************************************************************
-* tpm_sw_set_port_vid_egress_mode
-*
-* DESCRIPTION:
-*       The API sets the egress mode for a member port of a vlan.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - vlan id
-*       eMode      - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_vid_egress_mode(uint32_t owner_id,
-						 tpm_src_port_type_t src_port,
-						 uint16_t vid,
-						 uint8_t eMode);
-
-/*******************************************************************************
-* tpm_sw_port_set_vid_filter
-*
-* DESCRIPTION:
-*       The API sets the filtering mode of a certain lport.
-*       If the lport is in filtering mode, only the VIDs added by the
-*       tpm_sw_port_add_vid API will be allowed to ingress and egress the lport.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid_filter  - set to 1 - means the lport will DROP all packets which are NOT in
-*                    the allowed VID list (built using API tpm_sw_port_add_vid).
-*                    set to  0 - means that the list of VIDs allowed
-*                    per lport has no significance (the list is not deleted).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_set_vid_filter(uint32_t owner_id,
-					    tpm_src_port_type_t src_port,
-					    uint8_t vid_filter);
-
-/*******************************************************************************
-* tpm_sw_set_mac_age_time
-*
-* DESCRIPTION:
-*       This function Sets the MAC address aging time.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       time_out   - MAC address aging time
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_mac_age_time(uint32_t owner_id,
-					 uint32_t time_out);
-
-/*******************************************************************************
-* tpm_sw_get_mac_age_time
-*
-* DESCRIPTION:
-*       This function Sets the MAC address aging time.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*
-* OUTPUTS:
-*       time_out   - time out value.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_mac_age_time(uint32_t owner_id,
-					 uint32_t *time_out);
-
-/*******************************************************************************
-*  tpm_sw_set_mac_learn
-*
-* DESCRIPTION:
-*       Enable/disable automatic learning of new source MAC addresses on port
-*       ingress.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       enable     - GT_TRUE for enable  or GT_FALSE otherwise
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-* GalTis:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_mac_learn(uint32_t owner_id,
-				      tpm_src_port_type_t src_port,
-				      bool enable);
-
-/*******************************************************************************
-*  tpm_sw_get_mac_learn
-*
-* DESCRIPTION:
-*       Enable/disable automatic learning of new source MAC addresses on port
-*       ingress.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       enable     - GT_TRUE for enable  or GT_FALSE otherwise
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-* GalTis:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_mac_learn(uint32_t owner_id,
-				      tpm_src_port_type_t src_port,
-				      bool *enable);
-
-/*******************************************************************************
-* tpm_sw_set_port_flooding()
-*
-* DESCRIPTION:      permit or not the flooding per port
-*
-* INPUTS:
-*   owner_id    - APP owner id should be used for all API calls.
-*   src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*   flood_mode  - flooding mode.
-*   allow_flood - set to 1 = permit flooding of unknown DA.
-*
-* OUTPUTS:
-*   None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_flooding(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  tpm_flood_type_t flood_mode,
-					  uint8_t allow_flood);
-
-/*******************************************************************************
-* tpm_sw_get_port_flooding()
-*
-* DESCRIPTION:      permit or not the flooding per port
-*
-* INPUTS:
-*   owner_id    - APP owner id should be used for all API calls.
-*   src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*   flood_mode  - flooding mode
-*
-* OUTPUTS:
-*   allow_flood - set to 1 = permit flooding .
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_flooding(uint32_t owner_id,
-					  tpm_src_port_type_t src_port,
-					  tpm_flood_type_t flood_mode,
-					  uint8_t *allow_flood);
-
-/******************************************************************************/
-/*                            MAC security APIs                               */
-/******************************************************************************/
-
-/******************************************************************************/
-/********************************** Traffic management switch APIs ************/
-/******************************************************************************/
-/*******************************************************************************
-* tpm_sw_set_uni_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per Ethernet port.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* uni_port          - UNI port for setting the scheduling mode
-* sched_mode        - scheduler mode per port
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_sched(uint32_t owner_id,
-				      tpm_src_port_type_t uni_port,
-				      tpm_sw_sched_type_t sched_mode);
-
-/*******************************************************************************
-* tpm_sw_set_uni_q_weight()
-*
-* DESCRIPTION:      Configures the weight of a queue for all Ethernet UNI ports
-*                   in the integrated switch.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* queue_id          - queueId for setting the weight.
-* weight            - weight value per queue.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_q_weight(uint32_t owner_id,
-					 uint8_t queue_id,
-					 uint8_t weight);
-
-/*******************************************************************************
-* tpm_sw_set_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures an ingress policing function for an Ethernet UNI lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id, should be used for all API calls.
-*       uni_port   - uni lport for configuring the ingress policer function.
-*       count_mode - count mode:
-*                               TPM_SW_LIMIT_FRAME
-*                               TPM_SW_LIMIT_LAYER1
-*                               TPM_SW_LIMIT_LAYER2
-*                               TPM_SW_LIMIT_LAYER3
-*       cir        - comited info rate.
-*       cbs        - Committed Burst Size limit (expected to be 2kBytes)
-*       ebs        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_ingr_police_rate(uint32_t owner_id,
-						 tpm_src_port_type_t uni_port,
-						 tpm_limit_mode_t count_mode,
-						 uint32_t cir,
-						 uint32_t cbs,
-						 uint32_t ebs);
-
-/*******************************************************************************
-* tpm_sw_get_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API gets an ingress policing function for an Ethernet UNI lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id, should be used for all API calls.
-*       uni_port   - uni lport for configuring the ingress policer function.
-*
-*
-* OUTPUTS:
-*       count_mode - count mode:
-*                               TPM_SW_LIMIT_FRAME
-*                               TPM_SW_LIMIT_LAYER1
-*                               TPM_SW_LIMIT_LAYER2
-*                               TPM_SW_LIMIT_LAYER3
-*       cir        - comited info rate.
-*       cbs        - Committed Burst Size limit (expected to be 2kBytes)
-*       ebs        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_ingr_police_rate(uint32_t owner_id,
-						 tpm_src_port_type_t uni_port,
-						 tpm_limit_mode_t *count_mode,
-						 uint32_t *cir,
-						 uint32_t *cbs,
-						 uint32_t *ebs);
-
-/*******************************************************************************
-* tpm_sw_set_uni_tc_ingr_police_rate()
-*
-* DESCRIPTION:      Configures an policer function for a traffic class.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* uni_port          - UNI port.
-* tc                - traffic class
-* cir
-* cbs
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_tc_ingr_police_rate(uint32_t owner_id,
-						    tpm_src_port_type_t uni_port,
-						    uint32_t tc,
-						    uint32_t cir,
-						    uint32_t cbs);
-
-/*******************************************************************************
-* tpm_sw_set_uni_egr_rate_limit()
-*
-* DESCRIPTION:      Configures the egress rate limit of an Ethernet UNI port.
-*
-* INPUTS:
-*       owner_id        - APP owner id  should be used for all API calls.
-*       trg_port        - UNI port for fonfig the egress rate limit
-*       limit_mode      - limit mode:  TPM_SW_LIMIT_FRAME,  TPM_SW_LIMIT_LAYER1,
-*                                      TPM_SW_LIMIT_LAYER2, TPM_SW_LIMIT_LAYER3
-*       rate_limit_val  - egress rate limit value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_egr_rate_limit(uint32_t wner_id,
-					       tpm_src_port_type_t trg_port,
-					       tpm_limit_mode_t limit_mode,
-					       uint32_t rate_limit_val);
-
-/*******************************************************************************
-* tpm_sw_get_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API return the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id        - APP owner id , should be used for all API calls.
-*       trg_lport        - uni lport for configuring the egress rate limit.
-
-*
-* OUTPUTS:
-*      limit_mode      - limit mode:    TPM_SW_LIMIT_FRAME, TPM_SW_LIMIT_LAYER1,
-*                                            TPM_SW_LIMIT_LAYER2, TPM_SW_LIMIT_LAYER3
-*      rate_limit_val    - egress rate limit value
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       Valid rate_limit_val values are:
-*                                    7600,..., 9600,
-*                                    10000, 20000, 30000, 40000, ..., 100000,
-*                                    110000, 120000, 130000, ..., 1000000.
-
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_egr_rate_limit(uint32_t owner_id,
-					       tpm_src_port_type_t trg_port,
-					       tpm_limit_mode_t *limit_mode,
-					       uint32_t *rate_limit_val);
-
-/******************************************************************************/
-/********************************** Switch PHY port management  APIs **********/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_phy_convert_port_index()
-*
-* DESCRIPTION: convert switch port index to external port index.
-*
-* INPUTS:
-* owner_id       - APP owner id  should be used for all API calls.
-* switch_port    - switch port index
-*
-* OUTPUTS:
-* extern_port    - external port index
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_convert_port_index(uint32_t owner_id,
-					    uint32_t switch_port,
-					    tpm_src_port_type_t *extern_port);
-
-/*******************************************************************************
-* tpm_phy_set_port_autoneg_mode
-*
-* DESCRIPTION:
-*       The API Configures the auto negotiation state of an Ethernet  lport.
-* INPUTS:
-*       owner_id       - APP owner id should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       autoneg_state  - autonegotiation state, enabled or disabled.
-*       autoneg_mode   - enum:
-*                        TPM_SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
-*                        TPM_SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
-*                        TPM_SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
-*                        TPM_SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
-*                        TPM_SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
-*                        TPM_SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
-*                        TPM_SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
-*                        TPM_SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
-*                        TPM_SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
-*                        TPM_SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
-*                        TPM_SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
-*                        TPM_SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_autoneg_mode(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       bool autoneg_state,
-					       tpm_autoneg_mode_t autoneg_mode);
-
-/*******************************************************************************
-* tpm_phy_get_port_autoneg_mode
-*
-* DESCRIPTION:
-*       The API return the the auto negotiation state of an Ethernet  lport.
-* INPUTS:
-*       owner_id       - APP owner id should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       autoneg_state  - autonegotiation state, enabled or disabled.
-*       autoneg_mode   - enum:
-*                        TPM_SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
-*                        TPM_SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
-*                        TPM_SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
-*                        TPM_SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
-*                        TPM_SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
-*                        TPM_SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
-*                        TPM_SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
-*                        TPM_SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
-*                        TPM_SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
-*                        TPM_SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
-*                        TPM_SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
-*                        TPM_SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
-
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_autoneg_mode(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       bool *autoneg_state,
-					       tpm_autoneg_mode_t *autoneg_mode);
-
-/*******************************************************************************
-* tpm_phy_restart_port_autoneg
-*
-* DESCRIPTION:
-*       The API restart the auto negotiation of an Ethernet  lport.
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*        NONE.
-*                                .
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_restart_port_autoneg(uint32_t owner_id,
-					      tpm_src_port_type_t src_port);
-
-/*******************************************************************************
-* tpm_phy_set_port_admin_state
-*
-* DESCRIPTION:
-*       The API Configures the PHY port  state of an Ethernet  lport.
-* INPUTS:
-*       owner_id        - APP owner id should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       phy_port_state  - PHY port  state to set.
-*                         0:normal state
-*                         1:power down
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_admin_state(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      bool phy_port_state);
-
-/*******************************************************************************
-* tpm_phy_get_port_admin_state
-*
-* DESCRIPTION:
-*       The API return the PHY port  state of an Ethernet  lport.
-* INPUTS:
-*       owner_id        - APP owner id should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       phy_port_state  -  0:normal state
-*                          1:power down                                    .
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_admin_state(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      bool *phy_port_state);
-
-/*******************************************************************************
-* tpm_phy_get_port_link_status
-*
-* DESCRIPTION:
-*       The API return realtime port link status of an Ethernet  lport.
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_link_status  -  0:port link is ON
-*                            1:port link is DOWN                                    .
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_link_status(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      bool *port_link_status);
-
-/*******************************************************************************
-* tpm_phy_get_port_duplex_status
-*
-* DESCRIPTION:
-*       The API return realtime port duplex status of an Ethernet  lport.
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_duplex_status  -  0:half deplex mode
-*                              1:full deplex mode                    .
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_duplex_status(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						bool *port_duplex_status);
-
-/*******************************************************************************
-* tpm_phy_get_port_speed_mode
-*
-* DESCRIPTION:
-*       The API return realtime port speed mode of an Ethernet  lport.
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_duplex_status  -  0:10M
-*                              1:100M
-*                              2:1000M
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_speed_mode(uint32_t owner_id,
-					     tpm_src_port_type_t src_port,
-					     uint32_t *speed);
-
-/*******************************************************************************
-* tpm_phy_set_port_flow_control_support
-*
-* DESCRIPTION:
-*       This routine will set the pause bit in Autonegotiation Advertisement
-*        Register. And restart the autonegotiation.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       state       - false:port pause is off.
-*                     true:port pause is on.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-* data sheet register 4.10 Autonegotiation Advertisement Register
-*******************************************************************************/
-
-tpm_error_code_t tpm_phy_set_port_flow_control_support(uint32_t owner_id,
-						       tpm_src_port_type_t src_port,
-						       bool state);
-
-/*******************************************************************************
-* tpm_phy_get_port_flow_control_support
-* DESCRIPTION:
-*       This routine will get the pause bit in Autonegotiation Advertisement
-*        Register.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       state      -  false:port pause is off.
-*                     true:port pause is on.
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-* data sheet register 4.10 Autonegotiation Advertisement Register
-*******************************************************************************/
-
-tpm_error_code_t tpm_phy_get_port_flow_control_support(uint32_t owner_id,
-						       tpm_src_port_type_t src_port,
-						       bool *state);
-
-/*******************************************************************************
-* tpm_phy_get_port_flow_control_state
-*
-* DESCRIPTION:
-*     This routine will get the current pause state.
-*        Register.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       state       -
-*                   false: MAC Pause not implemented in the link partner or in MyPause
-*                   rue:  MAC Pause is implemented in the link partner and in MyPause
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-*       None.
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_flow_control_state(uint32_t owner_id,
-						     tpm_src_port_type_t src_port,
-						     bool *state);
-
-/*******************************************************************************
-* tpm_phy_set_port_loopback
-*
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode        - Internal or external loopback
-*       enable      - If true, enable loopback mode
-*                     If false, disable loopback mode
-*
-* OUTPUTS:
-* None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* data sheet register 0.14 - Loop_back
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_loopback(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   tpm_phy_loopback_mode_t mode,
-					   bool enable);
-
-/*******************************************************************************
-* tpm_phy_get_port_loopback
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode        - Internal or external loopback
-*
-* OUTPUTS:
-*       enable      - If GT_TRUE,  loopback mode is enabled
-*                     If GT_FALSE,  loopback mode is disabled
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* data sheet register 0.14 - Loop_back
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_loopback(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   tpm_phy_loopback_mode_t mode,
-					   bool *enable);
-
-/*******************************************************************************
-* tpm_phy_set_port_duplex_mode
-*
-* DESCRIPTION:
-*        Sets duplex mode for a specific logical port. This function will keep
-*        the speed and loopback mode to the previous value, but disable others,
-*        such as Autonegotiation.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       enable      - Enable/Disable dulpex mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*         data sheet register 0.8 - Duplex Mode
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_duplex_mode(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      bool enable);
-
-/*******************************************************************************
-* tpm_phy_get_port_duplex_mode
-*
-* DESCRIPTION:
-*         Gets duplex mode for a specific logical port.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-
-*
-* OUTPUTS:
-*       enable      - Enable/Disable dulpex mode
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*         data sheet register 0.8 - Duplex Mode
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_duplex_mode(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      bool *enable);
-
-/*******************************************************************************
-* tpm_phy_set_port_speed
-*
-* DESCRIPTION:
-*       This routine will disable auto-negotiation and set the PHY port speed .
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       speed       -    PHY_SPEED_10_MBPS   - 10Mbps
-*                        PHY_SPEED_100_MBPS  - 100Mbps
-*                        PHY_SPEED_1000_MBPS - 1000Mbps.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case, see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_speed(uint32_t owner_id,
-					tpm_src_port_type_t src_port,
-					tpm_phy_speed_t speed);
-
-/*******************************************************************************
-* tpm_phy_get_port_speed
-*
-* DESCRIPTION:
-*       This routine will get current PHY port speed .
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-
-*
-*
-* OUTPUTS:
-*        speed      -    PHY_SPEED_10_MBPS   -10Mbps
-*                        PHY_SPEED_100_MBPS  -100Mbps
-*                        PHY_SPEED_1000_MBPS -1000Mbps.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_speed(uint32_t owner_id,
-					tpm_src_port_type_t src_port,
-					tpm_phy_speed_t *speed);
-
-/******************************************************************************/
-/**                       Traffic management packet processor APIs           **/
-/******************************************************************************/
-
-/*******************************************************************************
-* tpm_tm_set_wan_egr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per WAN queue.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the scheduling mode: ex:TPM_TRG_PORT_WAN
-* sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-* queue_id          - queue number
-* wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_egr_queue_sched(uint32_t owner_id,
-						tpm_trg_port_type_t sched_ent,
-						tpm_pp_sched_type_t sched_mode,
-						uint8_t queue_id,
-						uint16_t wrr_weight);
-
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per all downstream traffic from the WAN.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-* queue_id          - queue number
-* wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_queue_sched(uint32_t owner_id,
-						 tpm_pp_sched_type_t sched_mode,
-						 uint8_t queue_id,
-						 uint16_t wrr_weight);
-
-/*******************************************************************************
-* tpm_tm_set_wan_sched_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of upstream traffic.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-* rate_limit_val    - egress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_sched_egr_rate_lim(uint32_t owner_id,
-						   tpm_trg_port_type_t sched_ent,
-						   uint32_t rate_limit_val,
-						   uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_wan_queue_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the upstream traffic egress rate limit for a specific
-*                   queue of an upstream scheduling entity.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-* queue_id          - queue number
-* rate_limit_val    - egress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_queue_egr_rate_lim(uint32_t owner_id,
-						   tpm_trg_port_type_t sched_ent,
-						   uint32_t queue_id,
-						   uint32_t rate_limit_val,
-						   uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the rate limit of all downstream traffic from the WAN.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* rate_limit_val    - ingress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_rate_lim(uint32_t owner_id,
-					      uint32_t rate_limit_val,
-					      uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_wan_q_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of a specific queue for
-*                   downstream traffic.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* queue_id          - queue number
-* rate_limit_val    - ingress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_q_ingr_rate_lim(uint32_t owner_id,
-						uint32_t queue_id,
-						uint32_t rate_limit_val,
-						uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_alarm_get_eth_port
-*
-* DESCRIPTION:
-*       This function gets eth port alarm.
-*
-* INPUTS:
-*       owner_id     - APP owner id , should be used for all API calls.
-*
-* OUTPUTS:
-*       alarm_type  - eth alarm type
-*         port_bitmap    - port bitmap
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_alarm_get_eth_port(uint32_t owner_id,
-					uint32_t *alarm_type,
-					uint8_t *port_bitmap);
-
-/*******************************************************************************
-* tpm_sw_pm_1_read
-*
-*
-* INPUTS:
-*      owner_id          - APP owner id  should be used for all API calls.
-*       port              - The logical port number
-*      tpm_swport_pm_3   - Holds PM data
-*
-* OUTPUTS:
-* PM data is supplied structure.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_1_read(uint32_t owner_id,
-				  tpm_src_port_type_t port,
-				  tpm_swport_pm_1_t *tpm_swport_pm_1);
-
-/*******************************************************************************
-* tpm_sw_pm_3_read
-*
-*
-* INPUTS:
-*      owner_id          - APP owner id  should be used for all API calls.
-*       port              - The logical port number
-*      tpm_swport_pm_3_all_t   - Holds PM data
-*
-* OUTPUTS:
-* PM data is supplied structure.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_3_read(uint32_t owner_id,
-				  tpm_src_port_type_t port,
-				  tpm_swport_pm_3_all_t *tpm_swport_pm_3);
-
-/*******************************************************************************
-* tpm_sw_clear_port_counter
-*
-* DESCRIPTION:
-*       The API clear port pm counter.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*
-*
-* OUTPUTS:
-*       none.
-*
-* RETURNS:
-* On success - TPM_RC_OK
-* On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_port_counter(uint32_t owner_id,
-					   tpm_src_port_type_t port);
-/*******************************************************************************
-* tpm_add_ctc_cm_acl_rule()
-*
-* DESCRIPTION:      Creates a new CTC CnM ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-* l2_parse_rule_bm
-* ipv4_parse_rule_bm
-*                    - Bitmap containing the significant flags for parsing fields of the packet.
-* l2_key
-* ipv4_key
-*                    - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frw            - Information for packet forwarding decision.
-* pkt_act            - Action associated to the rule
-*
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct precedence of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t	tpm_add_ctc_cm_acl_rule(uint32_t	owner_id,
-        tpm_src_port_type_t   src_port,
-        uint32_t              precedence,
-        tpm_parse_fields_t    l2_parse_rule_bm,
-        tpm_parse_fields_t    ipv4_parse_rule_bm,
-        tpm_l2_acl_key_t      *l2_key,
-        tpm_ipv4_acl_key_t    *ipv4_key,
-        tpm_pkt_frwd_t        *pkt_frwd,
-        tpm_pkt_action_t      pkt_act,
-        uint32_t              pbits);
-
-/*******************************************************************************
-* tpm_del_ctc_cm_acl_rule()
-*
-* DESCRIPTION:      Deletes an existing CTC CnM rule.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct precedence of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ctc_cm_acl_rule(uint32_t owner_id,
-	tpm_src_port_type_t   src_port,
-	uint32_t			  precedence);
-
-/*******************************************************************************
-* tpm_add_ctc_cm_ipv6_acl_rule()
-*
-* DESCRIPTION:      Creates a new CTC IPv6 CnM ACL.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port, could be any UNI port:
-* precedence         - precedence of this CnM rule, from 0 to 7
-* ipv6_parse_rule_bm
-*                    - Bitmap containing the significant flags for parsing fields of the packet.
-* ipv6_key
-*                    - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* pkt_frw            - Information for packet forwarding decision.
-* pkt_act            - Action associated to the rule
-*
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct precedence of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ctc_cm_ipv6_acl_rule(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      uint32_t precedence,
-					      tpm_parse_fields_t ipv6_parse_rule_bm,
-					      tpm_ipv6_acl_key_t  *ipv6_key,
-					      tpm_pkt_frwd_t *pkt_frwd,
-					      tpm_pkt_action_t pkt_act,
-					      uint32_t pbits);
-/*******************************************************************************
-* tpm_ctc_cm_set_ipv6_parse_window()
-*
-* DESCRIPTION:      Set IPv6 CnM rule parse window
-*     Two sets of IPv6 parse window:
-*       - first 24 bytes from IPv6 Header, include fields like: NH, TC, SIP
-*       - second 24 bytes from IPv6 Header, include fields like: L4 ports and DIP
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* check_level        - The check level determines to correct bad tpm rule or not in the API call
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_set_ipv6_parse_window(uint32_t owner_id,
-						  tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window);
-/*******************************************************************************
-* tpm_flush_vtu()
-*
-* DESCRIPTION:      Flush VTU on the Switch.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_flush_vtu(uint32_t owner_id);
-/*******************************************************************************
-* tpm_flush_atu()
-*
-* DESCRIPTION:      Flush ATU on the Switch.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* flush_type         - FLUSH all or FLUSH all dynamic
-* db_num             - ATU DB Num, only 0 should be used, since there is only one ATU DB right now.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_flush_atu(uint32_t owner_id, tpm_flush_atu_type_t flush_type, uint16_t db_num);
-
-/*******************************************************************************
-* tpm_add_mac_learn_rule()
-*
-* DESCRIPTION:      Add a PNC L2 rule for source MAC learn
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* rule_num           - Entry index to be added in the current ACL
-* queue              - GMAC1 queue send packet to
-* src_mac_addr       - MAC addr to learn
-* OUTPUTS:
-* rule_idx           - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_mac_learn_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr);
-
-/*******************************************************************************
-* tpm_del_mac_learn_rule()
-*
-* DESCRIPTION:      Del a PNC L2 rule for source MAC learn
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* rule_idx           - Unique rule identification number, which is used when deleting the rule.
-*                      (this is not the rule_num)
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_mac_learn_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr);
-
-/*******************************************************************************
-* tpm_mac_learn_default_rule_act_set()
-*
-* DESCRIPTION:      Set the action for mac learn default rule
-*
-* INPUTS:
-* owner_id           - ID of an application which requests ownership on a group of APIs.
-* mac_conf           - MAC conf determine rule action for mac learn default.
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mac_learn_default_rule_act_set(uint32_t owner_id, tpm_unknown_mac_conf_t mac_conf);
-
-/*******************************************************************************
-* tpm_mac_learn_entry_num_get()
-*
-* DESCRIPTION:      Get the mac learn entry number currently in system
-*
-* INPUTS:
-* None
-* OUTPUTS:
-* entry_num          - current MAC learn entry count in MAC_LEARN range, not including default one
-* RETURNS:
-* On success, the function returns API_OWNERSHIP_SUCCESS. On error, see tpm_api_ownership_error_t.
-*
-* COMMENTS: none
-*
-*******************************************************************************/
-tpm_error_code_t tpm_mac_learn_entry_num_get(uint32_t *entry_num);
-
-/*******************************************************************************
-* tpm_add_ds_load_balance_rule()
-*
-* DESCRIPTION: The API adds DS load balance PnC rules to set target port to GMAC0 or GMAC1
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-*                      possible values for L2 API:
-*                        TPM_L2_PARSE_MAC_DA|TPM_L2_PARSE_MAC_SA|TPM_L2_PARSE_ONE_VLAN_TAG
-*                        |TPM_L2_PARSE_TWO_VLAN_TAG|TPM_L2_PARSE_ETYPE|TPM_L2_PARSE_PPPOE_SES
-*                        |TPM_L2_PARSE_PPP_PROT|TPM_L2_PARSE_GEMPORT)
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-*                      possible values for L2 API:
-*                        TPM_PARSE_FLAG_TAG1_TRUE|TPM_PARSE_FLAG_TAG1_FLASE|
-*                        TPM_PARSE_FLAG_TAG2_TRUE|TPM_PARSE_FLAG_TAG2_FALSE
-* l2_key             - Information to create a parsing key for the rule.
-*                      Some pointers may be NULL depending on the parse_rule_bm.
-* tgrt_port          - target Port: GMAC0, GMAC1 or CPU
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number which is used when deleting the rule.
-*                     (this is not the rule_num)
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_add_ds_load_balance_rule(uint32_t owner_id,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_l2_acl_key_t *l2_key,
-						tpm_ds_load_balance_tgrt_t tgrt_port);
-
-/*******************************************************************************
-* tpm_del_ds_load_balance_rule()
-*
-* DESCRIPTION: The API delete CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_del_ds_load_balance_rule(uint32_t owner_id, uint32_t rule_idx);
-
-/*******************************************************************************
-* tpm_set_active_wan()
-*
-* DESCRIPTION:      Set active WAN port
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* active_wan        - active wan, GMAC0, GMAC1, PON
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_active_wan(uint32_t owner_id,
-				    tpm_gmacs_enum_t active_wan);
-/*******************************************************************************
-* tpm_hot_swap_profile()
-*
-* DESCRIPTION:      Swap profile and update all the ACL rules according to
-*                   the new profile
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* profile_id        - the new profile that system is swapping to
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_hot_swap_profile(uint32_t owner_id,
-				    tpm_eth_complex_profile_t profile_id);
-
-/*******************************************************************************
-* tpm_xlate_uni_2_switch_port()
-*
-* DESCRIPTION: The API translates TPM logic UNI port into Switch port.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* uni_port           - TPM logic port that need to be translated.
-*
-* OUTPUTS:
-* switch_port      - switch port.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_xlate_uni_2_switch_port (uint32_t		  owner_id,
-					     tpm_src_port_type_t  uni_port,
-					     uint32_t		 *switch_port);
-
-/*******************************************************************************
-* tpm_set_gmac_loopback()
-*
-* DESCRIPTION: The API enable/disable loopback mode of gmac.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* gmac                 -
-* enable               - 1 for enable, 0 for disable
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_gmac_loopback (uint32_t	  owner_id,
-						tpm_gmacs_enum_t  gmac,
-						uint8_t		  enable);
-
-/*******************************************************************************
-* tpm_sw_port_add_vid_set_egrs_mode
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of the allowed VIDs per UNI port,
-*       and sets the egress mode for the port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - vlan id
-*       eMode      - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid_set_egrs_mode (uint32_t            owner_id,
-                                                    tpm_src_port_type_t port,
-                                                    uint16_t            vid,
-                                                    uint8_t             eMode);
-/*******************************************************************************
-* tpm_active_tcont()
-*
-* DESCRIPTION:    Function used to enable hwf to certain tcont.
-*
-* INPUTS:
-* tcont_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_active_tcont(uint32_t tcont_num);
-/*******************************************************************************
-* tpm_deactive_tcont()
-*
-* DESCRIPTION:    Function used to disable hwf to certain tcont.
-*
-* INPUTS:
-* tcont_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_deactive_tcont(uint32_t tcont_num);
-
-/* OLD API functions */
-#define tpm_add_l2_prim_acl_rule                            tpm_add_l2_rule
-#define tpm_add_l3_type_acl_rule                            tpm_add_l3_type_rule
-#define tpm_add_ipv4_acl_rule                               tpm_add_ipv4_rule
-#define tpm_add_ipv6_step1_acl_rule                         tpm_add_ipv6_gen_rule
-#define tpm_add_ipv6_dip_acl_rule                           tpm_add_ipv6_dip_rule
-#define tpm_add_ipv6_nh_acl_rule                            tpm_add_ipv6_nh_rule
-#define tpm_add_ipv6_l4_ports_acl_rule                      tpm_add_ipv6_l4_ports_rule
-
-#define tpm_del_l2_prim_acl_rule(owner, src, idx)           tpm_del_l2_rule(owner, idx)
-#define tpm_del_l3_type_acl_rule(owner, src, idx)           tpm_del_l3_type_rule(owner, idx)
-#define tpm_del_ipv4_acl_rule(owner, src, idx)              tpm_del_ipv4_rule(owner, idx)
-#define tpm_del_ipv6_step1_acl_rule(owner, src, idx)        tpm_del_ipv6_gen_rule(owner, idx)
-#define tpm_del_ipv6_dip_acl_rule(owner, src, idx)          tpm_del_ipv6_dip_rule(owner, idx)
-#define tpm_del_ipv6_nh_acl_rule                            tpm_del_ipv6_nh_rule
-#define tpm_del_ipv6_l4_ports_acl_rule(owner, src, idx)     tpm_del_ipv6_l4_ports_rule(owner, idx)
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_common.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_common.h
deleted file mode 100644
index 0e938bb..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_common.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_common.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-
-#ifndef __TPM_COMMON_TYPES_H__
-#define __TPM_COMMON_TYPES_H__
-
-#include "tpm_rtos.h"
-#include "tpm_types.h"
-#include "tpm_api.h"
-#include "tpm_internal_types.h"
-
-#endif /* __TPM_COMMON_TYPES_H__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.c
deleted file mode 100644
index 05e468a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.c
+++ /dev/null
@@ -1,996 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_api.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Victor
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1
-*
-*
-*******************************************************************************/
-#include <linux/version.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "mvOs.h"
-
-/*#define TPM_COUNTER_DEBUG_TIME*/
-
-#define IF_ERROR(ret)	\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_PNCL_MOD, " recvd ret_code(%d)\n", ret);\
-			return(ret);\
-		}
-
-spinlock_t tpmTcamAgingLock;
-
-static uint32_t gs_tcam_array[TPM_MAX_LU_ENTRY_NUM];
-static uint32_t gs_valid_tcam_array[TPM_MAX_LU_ENTRY_NUM];
-
-/*******************************************************************************
-* tpm_tcam_get_lu_entry()
-*
-* DESCRIPTION: The API get least used PnC rule by in specific aging couter group
-*
-* INPUTS:   group  - TCAM hit counter group number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           LU entry
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline MV_U32 tpm_tcam_get_lu_entry(int32_t group)
-{
-	unsigned long flags;
-	MV_U32 lu_entry;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Read LU entry */
-	lu_entry = mvPncAgingLogEntryRead(group, 0);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return lu_entry;
-}
-
-/*******************************************************************************
-* tpm_tcam_set_triger()
-*
-* DESCRIPTION: The API set the triger to re-start LU scan
-*
-* INPUTS:   None
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_set_triger(void)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Set triger */
-	mvPncAgingTrigerSet();
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_get_aging_cntr()
-*
-* DESCRIPTION: The API get hit counter of specific TCAM entry
-*
-* INPUTS:   tid   - - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           Hit counter
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline MV_U32 tpm_tcam_get_aging_cntr(int32_t tid)
-{
-	unsigned long flags;
-	MV_U32 hit_count;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* read aging hit counter by TID */
-	hit_count = mvPncAgingCntrRead(tid);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return hit_count;
-}
-
-/*******************************************************************************
-* tpm_tcam_clear_aging_cntr()
-*
-* DESCRIPTION: The API clear hit counter of specific TCAM entry
-*
-* INPUTS:   tid   - - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           Hit counter
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_clear_aging_cntr(int32_t tid)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* clear aging hit counter by TID */
-	mvPncAgingCntrClear(tid);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_clear_lu_read_flag()
-*
-* DESCRIPTION: The API clear the LU read flag to let the TCAM entries to be
-*              scaned again
-*
-* INPUTS:   tid   - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_clear_lu_read_flag(int32_t tid)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Clear LU read flag */
-	mvPncAgingLuReadClear(tid);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_clear_lu_read_cntr()
-*
-* DESCRIPTION: The API clear the hit counter of LU read TCAM entry
-*
-* INPUTS:   tid   - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_clear_lu_read_cntr(int32_t tid)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Clear hit counter of LU entry */
-	mvPncAgingCouterClear(tid);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_set_lu_threshold()
-*
-* DESCRIPTION: The API set the LU threshold
-*
-* INPUTS:   group - TCAM aging counter group number
-*           thesh - threshold value in packet number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_set_lu_threshold(int32_t group, int32_t thesh)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Set aging LU threshold */
-	mvPncAgingLuThreshSet(group, thesh);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_clear_lu_group()
-*
-* DESCRIPTION: The API clear the hit counter of all the TCAM entries in one group
-*
-* INPUTS:   group - TCAM aging counter group number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_tcam_clear_lu_group(int32_t group)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Clear aging counter group */
-	mvPncAgingGroupCntrClear(group);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_set_cntr_group()
-*
-* DESCRIPTION: The API set the counter group of aging counter
-*
-* INPUTS:   tid   - TCAM aging entry
-*           group - TCAM aging counter group number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_tcam_set_cntr_group(int32_t tid, int32_t group)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Set aging LU counter group */
-	mvPncAgingCntrGroupSet(tid, group);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_get_cntr_group()
-*
-* DESCRIPTION: The API get the counter group of aging counter
-*
-* INPUTS:   tid   - TCAM aging entry
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           group - TCAM aging counter group number the PNC belong to
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-MV_U32 tpm_tcam_get_cntr_group(int32_t tid)
-{
-	uint32_t w32;
-
-	/* Reading counter reg */
-	w32 = mvPncAgingCntrRead(tid);
-	w32 = (w32 & PNC_AGING_GROUP_ALL_MASK) >> PNC_AGING_GROUP_OFFS;
-
-	return w32;
-}
-
-/*******************************************************************************
-* tpm_tcam_set_lu_mask()
-*
-* DESCRIPTION: The API set the LU mask
-*
-* INPUTS:   tid   - TCAM entry number
-*           mask  - mask flag, 0: do not mask, 1:mask LU scan
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_tcam_set_lu_mask(int32_t tid, int32_t mask)
-{
-	unsigned long flags;
-
-	/* Lock the TCAM hit counter */
-	spin_lock_irqsave(&tpmTcamAgingLock, flags);
-
-	/* Set LU scan mask */
-	mvPncAgingCntrLuMaskSet(tid, mask);
-
-	/* Unlock TCAM hit counter */
-	spin_unlock_irqrestore(&tpmTcamAgingLock, flags);
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_tcam_get_lu_mask()
-*
-* DESCRIPTION: The API get the LU mask flag
-*
-* INPUTS:   tid   - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           mask flag, 0: do not mask, non-zero: mask LU scan
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-MV_U32 tpm_tcam_get_lu_mask(int32_t tid)
-{
-	uint32_t w32;
-
-	/* Reading counter reg */
-	w32 = mvPncAgingCntrRead(tid);
-	w32 &= PNC_AGING_SKIP_LU_SCAN_MASK;
-
-	return w32;
-}
-
-/*******************************************************************************
-* tpm_count_get_api_section_range_id()
-*
-* DESCRIPTION: The API get API section and PnC range ID according to API group
-*              type
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type     - TPM API group type
-*
-* OUTPUTS:
-*           api_section  - API section ID
-*           range_id     - PnC range ID
-
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_api_section_range_id(uint32_t owner_id,
-						    tpm_api_type_t api_type,
-						    tpm_api_sections_t *api_section,
-						    tpm_pnc_ranges_t *range_id)
-{
-	tpm_api_sections_t l_api_section;
-	tpm_pnc_ranges_t l_range_id;
-	int32_t ret_code = TPM_RC_OK;
-
-	/* Convert to API section ID */
-	ret_code = tpm_db_api_section_get_from_api_type(api_type, &l_api_section);
-	IF_ERROR(ret_code);
-
-	/* Get PnC range ID */
-	ret_code = tpm_db_api_section_main_pnc_get(l_api_section, &l_range_id);
-	IF_ERROR(ret_code);
-
-	/* Save API section ID and PnC range ID */
-	if (api_section != NULL)
-		*api_section = l_api_section;
-	if (range_id != NULL)
-		*range_id = l_range_id;
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_count_get_pnc_lu_entry()
-*
-* DESCRIPTION: The API get least used PnC rule by in specific PnC range
-*
-* INPUTS:   owner_id        - APP owner id  should be used for all API calls
-*           api_type       - TPM API group type
-*           lu_num          - The required number of least used PnC entries
-*           lu_reset        - Whether need to reset counter after read LU
-*
-*
-* OUTPUTS:
-*           valid_num       - The valid number of least used PnC entries
-*           count_array     - The least used PnC entry index  and hit counter array
-*           unrelated_num   - The unlelated number of least used PnC entries
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_lu_entry(uint32_t owner_id,
-					    tpm_api_type_t api_type,
-					    uint16_t lu_num,
-					    uint8_t lu_reset,
-					    uint16_t *valid_num,
-					    tpm_api_entry_count_t *count_array,
-					    uint16_t *unrelated_num)
-{
-	tpm_api_lu_conf_t lu_conf;
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	int16_t l_lu_num = 0;
-	uint16_t l_valid_num = 0;
-	uint16_t l_invalid_num = 0;
-	uint32_t l_rule_idx = 0;
-	uint32_t l_tcam_val = 0;
-	uint32_t l_tcam_num = 0;
-	uint32_t range_start = 0;
-	uint32_t range_end = 0;
-	uint32_t w32 = 0;
-	int32_t count_group = 0;
-	int32_t ret_code = TPM_RC_OK;
-	tpm_error_code_t tpm_ret_code = TPM_RC_OK;
-	uint32_t l_retry_time  = 0;
-#ifdef TPM_COUNTER_DEBUG_TIME
-	unsigned long t_start;
-	unsigned long t_dif;
-#endif
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d], lu_num[%d], lu_reset[%d]\n",
-		     __func__, owner_id, api_type, lu_num, lu_reset);
-
-	/* Get API section and PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, &api_section, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Check the required number */
-	if (lu_num > TPM_MAX_LU_ENTRY_NUM) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "lu_num[%d] is illegal, allowed number[0~%d] \n", lu_num,
-			     TPM_MAX_LU_ENTRY_NUM);
-		return(ERR_GENERAL);
-	}
-
-	/* Get counter group number and mask all flag */
-	ret_code = tpm_db_pnc_get_lu_conf(range_id, &lu_conf);
-	IF_ERROR(ret_code);
-	count_group = lu_conf.cntr_grp;
-
-	/* Get range start number */
-	ret_code = tpm_db_pnc_rng_get_range_start_end(range_id, &range_start, &range_end);
-	IF_ERROR(ret_code);
-
-	/* Get valid LU entries */
-	memset(gs_tcam_array, 0, sizeof(gs_tcam_array));
-	memset(gs_valid_tcam_array, 0, sizeof(gs_valid_tcam_array));
-
-#ifdef TPM_COUNTER_DEBUG_TIME
-	t_start = MV_REG_READ(0xAC40C);
-#endif
-	for (l_lu_num = 0; l_lu_num < CONFIG_MV_PNC_TCAM_LINES; l_lu_num++) {
-		w32 = tpm_tcam_get_lu_entry(count_group);
-		if ((w32 & TPM_PNC_AGING_LOG_VALID_MASK) == 0) {
-			l_retry_time++;
-			if (l_retry_time > 1)
-				break;
-
-			tpm_tcam_set_triger();
-			mvOsUDelay(100);
-			if (l_lu_num > 0)
-				l_lu_num--;
-			else
-				l_lu_num = -1;
-
-			continue;
-		} else
-			l_retry_time = 0;
-
-		l_tcam_val = w32 & TPM_PNC_AGING_LOG_CNTR_IDX_MASK;
-
-		gs_tcam_array[l_tcam_num++] = l_tcam_val;
-
-		/*printk("l_tcam_val[%d], range_start[%d], range_end[%d] \n", l_tcam_val, range_start, range_end); */
-
-		/* Check whether the TCAM is in current PnC range */
-		if ((l_tcam_val < range_start) || (l_tcam_val > range_end))
-			l_invalid_num++;
-		else {
-			/* Get rule index */
-			ret_code = tpm_db_api_tcam_rule_idx_get(api_section, l_tcam_val, &l_rule_idx);
-			if (ret_code == TPM_DB_OK) {
-				/*IF_ERROR(ret_code); */
-
-				/* Save rule index, hit counter and valid TCAM index */
-				(count_array + l_valid_num)->rule_idx = l_rule_idx;
-				(count_array + l_valid_num)->hit_count = tpm_tcam_get_aging_cntr(l_tcam_val)&TPM_PNC_AGING_CNTR_MASK;
-				gs_valid_tcam_array[l_valid_num++] = l_tcam_val;
-
-				/* The required number */
-				if (l_valid_num >= lu_num)
-					break;
-			} else {
-				l_invalid_num++;
-			}
-		}
-		/* Triger LU */
-		if (!((l_tcam_num) % TPM_PNC_AGING_TID_NUM_PER_SCAN)) {
-			tpm_tcam_set_triger();
-			mvOsUDelay(100);
-		}
-	}
-
-	/* Save valid and unrelated number */
-	*valid_num = l_valid_num;
-	*unrelated_num = l_invalid_num;
-
-	/* Clear LU read flag */
-	for (l_lu_num = 0; l_lu_num < l_tcam_num; l_lu_num++)
-		tpm_tcam_clear_lu_read_flag(gs_tcam_array[l_lu_num]);
-
-	/* Reset counter if needed */
-	if (lu_reset != 0) {
-		tpm_ret_code = tpm_count_reset_pnc_age_group(owner_id, api_type);
-		if ((TPM_RC_OK != tpm_ret_code)) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "Failed to call tpm_count_reset_pnc_age_group, ret_code[%d] \n",
-				     tpm_ret_code);
-			return(ERR_GENERAL);
-		}
-/* Followings are old codes, just remain them for reference */
-/*
-	for(l_lu_num = 0; l_lu_num < l_valid_num; l_lu_num++)
-		tpm_tcam_clear_lu_read_cntr(gs_valid_tcam_array[l_lu_num]);
-*/
-	}
-
-#ifdef TPM_COUNTER_DEBUG_TIME
-	t_dif = MV_REG_READ(0xAC40C) - t_start;
-	printk(KERN_ERR "(victor) %s(%d):  %ld\n", __func__, __LINE__, t_dif);
-#endif
-	/* Debug info */
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s out, valid_num[%d], unrelated_num[%d]\n",
-		     __func__, *valid_num, *unrelated_num);
-	for (l_lu_num = 0; l_lu_num < *valid_num; l_lu_num++) {
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "Index[%d] rule_idx_array[%d], hit_count[%d]\n",
-			     l_lu_num, (count_array + l_lu_num)->rule_idx, (count_array + l_lu_num)->hit_count);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_count_get_pnc_all_hit_counters
-*
-* DESCRIPTION: The API returns all PnC hit counters per API type lower than a given threshold
-*
-* INPUTS:   owner_id            - APP owner id  should be used for all API calls
-*           api_type            - TPM API group type
-*           high_thresh_pkts    - High threashold watermark, counters lower than will be returned
-*           counters_reset      - Reset API group type counters after read (0-false, 1-true)
-*           valid_counters      - The count_array size (entry number, not byte count)
-*
-* OUTPUTS:  valid_counters      - The valid number of entries copied to count_array
-*           count_array         - The PnC entries for the API type lower than high_thresh_pkts
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_all_hit_counters(uint32_t owner_id,
-						    tpm_api_type_t api_type,
-						    uint32_t high_thresh_pkts,
-						    uint8_t counters_reset,
-						    uint16_t *valid_counters,
-						    tpm_api_entry_count_t *count_array)
-{
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t   range_id;
-	uint16_t           count_array_size;
-	uint32_t           rule_idx;
-	uint32_t           tcam_val;
-	uint32_t           range_start;
-	uint32_t           range_end;
-	uint32_t           hit_counter;
-	uint16_t           cntrs_nr;
-	int32_t            ret_code;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d], counters_reset[%d] high_thresh_pkts[%d]\n",
-		     __func__, owner_id, api_type, counters_reset, high_thresh_pkts);
-
-	/* Get API section and PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, &api_section, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get range start number */
-	ret_code = tpm_db_pnc_rng_get_range_start_end(range_id, &range_start, &range_end);
-	IF_ERROR(ret_code);
-
-	if (*valid_counters > TPM_MAX_PNC_COUNTER_NUM) {
-	    TPM_OS_ERROR(TPM_PNCL_MOD, "valid_counters[%d] is illegal, allowed number[1~%d] \n",
-			    (*valid_counters), TPM_MAX_PNC_COUNTER_NUM);
-	    return(ERR_GENERAL);
-	}
-	/* save the array size */
-	count_array_size = *valid_counters;
-	cntrs_nr = 0;
-
-	/* traverse all pnc tcam lines */
-	for (tcam_val = range_start; tcam_val <= range_end; tcam_val++) {
-	/* Get rule index */
-		ret_code = tpm_db_api_tcam_rule_idx_get(api_section, tcam_val, &rule_idx);
-		if (ret_code == TPM_DB_OK) {
-			/* read counter from HW  */
-			hit_counter = tpm_tcam_get_aging_cntr(tcam_val);
-			hit_counter = (hit_counter & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS;
-
-			/* skip low counters */
-			if (hit_counter >= high_thresh_pkts)
-				continue;
-
-			/* Save rule index, hit counter and valid TCAM index */
-			count_array[cntrs_nr].rule_idx = rule_idx;
-			count_array[cntrs_nr].hit_count = hit_counter;
-
-			cntrs_nr++;
-
-			/* The table is full */
-			if (count_array_size == cntrs_nr)
-				break;
-		} else {
-			continue;
-		}
-	}
-
-	/* update the number of entries updated in count_array */
-	*valid_counters = cntrs_nr;
-
-	/* Reset counter if needed */
-	if (counters_reset != 0) {
-		tpm_error_code_t tpm_ret_code = tpm_count_reset_pnc_age_group(owner_id, api_type);
-
-		if (TPM_RC_OK != tpm_ret_code) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "Failed to call tpm_count_reset_pnc_age_group, ret_code[%d] \n", tpm_ret_code);
-			return(ERR_GENERAL);
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_count_set_pnc_counter_mask()
-*
-* DESCRIPTION: The API set the least used scanner ability, to mask or enable it
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           lu_rule_mask - The least used scanner mask, 1: mask scanner,
-*                          0:enable scanner
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_set_pnc_counter_mask(uint32_t owner_id,
-						tpm_api_type_t api_type,
-						uint32_t rule_idx,
-						uint32_t lu_rule_mask)
-{
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	int32_t tcam_num = 0;
-	int32_t ret_code = TPM_RC_OK;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d], rule_idx[%d], lu_rule_mask[%d]\n",
-		     __func__, owner_id, api_type, rule_idx, lu_rule_mask);
-
-	/* Get API section and PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, &api_section, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get TCAM number */
-	ret_code = tpm_db_api_tcam_num_get(api_section, rule_idx, &tcam_num);
-	IF_ERROR(ret_code);
-
-	/* Set to PnC TCAM aging counter register */
-	tpm_tcam_set_lu_mask((int32_t) tcam_num, (int32_t) lu_rule_mask);
-
-	return (TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_count_get_pnc_hit_count()
-*
-* DESCRIPTION: The API get the hit counter according to rule_idx
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           hit_reset    - Should the API reset the hit counters after after reading
-*
-* OUTPUTS:
-*           rule_idx     - The hitted times of specific PnC rule
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_hit_count(uint32_t owner_id,
-					     tpm_api_type_t api_type,
-					     uint32_t rule_idx,
-					     uint8_t  hit_reset,
-					     uint32_t *hit_count)
-{
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	int32_t tcam_num = 0;
-	int32_t ret_code = TPM_RC_OK;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d], rule_idx[%d]\n",
-		     __func__, owner_id, api_type, rule_idx);
-
-	/* Get API section and PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, &api_section, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get TCAM number */
-	ret_code = tpm_db_api_tcam_num_get(api_section, rule_idx, &tcam_num);
-	IF_ERROR(ret_code);
-
-	/* Set to PnC TCAM aging counter register */
-	*hit_count = tpm_tcam_get_aging_cntr((int32_t) tcam_num);
-
-	*hit_count &= TPM_PNC_AGING_CNTR_MASK;
-
-	if (hit_reset)
-		tpm_tcam_clear_aging_cntr((int32_t) tcam_num);
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s out, tcam_num[%d], hit_count[%d\n", __func__, tcam_num, *hit_count);
-
-	return (TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_count_set_pnc_lu_threshold()
-*
-* DESCRIPTION: The API set the theshold packets number for least used scanner
-*
-* INPUTS:   owner_id       - APP owner id  should be used for all API calls
-*           api_type      - TPM API group type
-*           lu_thresh_pkts - The theshold number(hitted packets number) to be used
-*                            for least used scanner
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_set_pnc_lu_threshold(uint32_t owner_id,
-						tpm_api_type_t api_type,
-						uint32_t lu_thresh_pkts)
-{
-	tpm_api_lu_conf_t lu_conf;
-	tpm_pnc_ranges_t range_id;
-	int32_t ret_code = TPM_RC_OK;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d], lu_thresh_pkts[%d]\n",
-		     __func__, owner_id, api_type, lu_thresh_pkts);
-
-	/* Get PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, NULL, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get counter group number */
-	ret_code = tpm_db_pnc_get_lu_conf(range_id, &lu_conf);
-	IF_ERROR(ret_code);
-
-	/* Check LU threshold */
-	if (lu_thresh_pkts > TPM_MAX_LU_THRESH_VAL) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "lu_thresh_pkts[%d]is illegal, exceeds maximum value(%d)\n",
-			     lu_thresh_pkts, TPM_PNC_AGING_CNTR_MAX);
-		return (ERR_GENERAL);
-	}
-
-	tpm_tcam_set_lu_threshold(lu_conf.cntr_grp, lu_thresh_pkts);
-
-	return (TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_count_reset_pnc_age_group()
-*
-* DESCRIPTION: The API reset the hitted counter of all the PnC entries of specific
-*              group
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_reset_pnc_age_group(uint32_t owner_id,
-					       tpm_api_type_t api_type)
-{
-	tpm_api_lu_conf_t lu_conf;
-	tpm_pnc_ranges_t range_id;
-	int32_t ret_code = TPM_RC_OK;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "%s in, owner_id[%d], api_type[%d]\n", __func__, owner_id, api_type);
-
-	/* Get PnC range ID */
-	ret_code = tpm_count_get_api_section_range_id(owner_id, api_type, NULL, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get counter group number */
-	ret_code = tpm_db_pnc_get_lu_conf(range_id, &lu_conf);
-	IF_ERROR(ret_code);
-
-	tpm_tcam_clear_lu_group(lu_conf.cntr_grp);
-
-	return (TPM_RC_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.h
deleted file mode 100644
index b7198b4..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_counter.h
+++ /dev/null
@@ -1,338 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_api.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Victor
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_COUNTER_H_
-#define _TPM_COUNTER_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define TPM_PNC_AGING_CNTR_OFFS             0
-#define TPM_PNC_AGING_CNTR_MAX              0x3ffffff
-#define TPM_PNC_AGING_CNTR_MASK             (TPM_PNC_AGING_CNTR_MAX << TPM_PNC_AGING_CNTR_OFFS)
-
-#define TPM_PNC_AGING_LOG_CNTR_IDX_OFFS     0
-#define TPM_PNC_AGING_LOG_CNTR_IDX_MASK     (0x3FF << TPM_PNC_AGING_LOG_CNTR_IDX_OFFS)
-
-#define TPM_PNC_AGING_LOG_VALID_BIT         31
-#define TPM_PNC_AGING_LOG_VALID_MASK        (1 << TPM_PNC_AGING_LOG_VALID_BIT)
-
-#define TPM_PNC_AGING_TID_NUM_PER_SCAN      8
-
-/*******************************************************************************
-* tpm_tcam_set_cntr_group()
-*
-* DESCRIPTION: The API set the counter group of aging counter
-*
-* INPUTS:   tid   - TCAM aging entry
-*           group - TCAM aging counter group number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_tcam_set_cntr_group(int32_t tid, int32_t group);
-
-/*******************************************************************************
-* tpm_tcam_get_cntr_group()
-*
-* DESCRIPTION: The API get the counter group of aging counter
-*
-* INPUTS:   tid   - TCAM aging entry
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           group - TCAM aging counter group number the PNC belong to
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-MV_U32 tpm_tcam_get_cntr_group(int32_t tid);
-
-/*******************************************************************************
-* tpm_tcam_set_lu_mask()
-*
-* DESCRIPTION: The API set the LU mask
-*
-* INPUTS:   tid   - TCAM entry number
-*           mask  - mask flag, 0: do not mask, 1:mask LU scan
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_tcam_set_lu_mask(int32_t tid, int32_t mask);
-
-/*******************************************************************************
-* tpm_tcam_get_lu_mask()
-*
-* DESCRIPTION: The API get the LU mask flag
-*
-* INPUTS:   tid   - TCAM entry number
-*
-* OUTPUTS:
-*           None
-* RETURNS:
-*           mask flag, 0: do not mask, non-zero: mask LU scan
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-MV_U32 tpm_tcam_get_lu_mask(int32_t tid);
-
-/*******************************************************************************
-* tpm_count_get_pnc_lu_entry()
-*
-* DESCRIPTION: The API get least used PnC rule by in specific PnC range
-*
-* INPUTS:   owner_id        - APP owner id  should be used for all API calls
-*           api_type       - TPM API group type
-*           lu_num          - The required number of least used PnC entries
-*           lu_reset        - Whether need to reset counter after read LU
-*
-*
-* OUTPUTS:
-*           valid_num       - The valid number of least used PnC entries
-*           count_array     - The least used PnC entry index  and hit counter array
-*           unrelated_num   - The unlelated number of least used PnC entries
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_lu_entry(uint32_t owner_id,
-					    tpm_api_type_t api_type,
-					    uint16_t lu_num,
-					    uint8_t lu_reset,
-					    uint16_t *valid_num,
-					    tpm_api_entry_count_t *count_array,
-					    uint16_t *unrelated_num);
-
-/*******************************************************************************
-* tpm_count_get_pnc_all_hit_counters
-*
-* DESCRIPTION: The API returns all PnC hit counters per API type lower than a given threshold
-*
-* INPUTS:   owner_id            - APP owner id  should be used for all API calls
-*           api_type            - TPM API group type
-*           high_thresh_pkts    - High threashold watermark, counters lower than will be returned
-*           counters_reset      - Reset API group type counters after read (0-false, 1-true)
-*           valid_counters      - The count_array size (entry number, not byte count)
-*
-* OUTPUTS:  valid_counters      - The valid number of entries copied to count_array
-*           count_array         - The PnC entries for the API type lower than high_thresh_pkts
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_all_hit_counters(uint32_t owner_id,
-						    tpm_api_type_t api_type,
-						    uint32_t high_thresh_pkts,
-						    uint8_t counters_reset,
-						    uint16_t *valid_counters,
-						    tpm_api_entry_count_t *count_array);
-
-/*******************************************************************************
-* tpm_count_set_pnc_counter_mask()
-*
-* DESCRIPTION: The API set the least used scanner ability, to mask or enable it
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           lu_rule_mask - The least used scanner mask, 1: maskscanner ,
-*                          0:enable scanner
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_set_pnc_counter_mask(uint32_t owner_id,
-						tpm_api_type_t api_type,
-						uint32_t rule_idx,
-						uint32_t lu_rule_mask);
-
-/*******************************************************************************
-* tpm_count_get_pnc_hit_count()
-*
-* DESCRIPTION: The API get the hit counter according to rule_idx
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*           rule_idx     - The PnC rule index returned when created PnC rules
-*           hit_reset    - Should the API reset the hit counters after after reading
-*
-* OUTPUTS:
-*           rule_idx     - The hitted times of specific PnC rule
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_get_pnc_hit_count(uint32_t owner_id,
-					     tpm_api_type_t api_type,
-					     uint32_t rule_idx,
-					     uint8_t  hit_reset,
-					     uint32_t *hit_count);
-
-/*******************************************************************************
-* tpm_count_set_pnc_lu_threshold()
-*
-* DESCRIPTION: The API set the theshold packets number for least used scanner
-*
-* INPUTS:   owner_id       - APP owner id  should be used for all API calls
-*           api_type      - TPM API group type
-*           lu_thresh_pkts - The theshold number(hitted packets number) to be used
-*                            for least used scanner
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_set_pnc_lu_threshold(uint32_t owner_id,
-						tpm_api_type_t api_type,
-						uint32_t lu_thresh_pkts);
-
-/*******************************************************************************
-* tpm_count_reset_pnc_age_group()
-*
-* DESCRIPTION: The API reset the hitted counter of all the PnC entries of specific
-*              group
-*
-* INPUTS:   owner_id     - APP owner id  should be used for all API calls
-*           api_type    - TPM API group type
-*
-* OUTPUTS:
-*            None
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_count_reset_pnc_age_group(uint32_t owner_id,
-					       tpm_api_type_t api_type);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_COUNTER_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.c
deleted file mode 100644
index 046c82e..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_cpu_port_fc.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager CPU port flow control module
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   KostaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1
-*
-*
-*******************************************************************************/
-#include <linux/version.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_cpu_port_fc.h"
-#include "dbg-trace.h"
-
-static tpm_fc_info_t fc_info;
-
-extern int mv_enable_fc_events(void*, unsigned long);
-extern void mv_disable_fc_events(void);
-void tpm_fc_hr_timer_handler(void);
-
-/*******************************************************************************
-**
-**  tpm_fc_rate_limit
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function periodically switches FC on/off on specific port
-**               if specific queue reaches pre-configured threshold
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     None
-**
-*******************************************************************************/
-void tpm_fc_rate_limit(void)
-{
-	MV_U32    queue_desc_number;
-	MV_U32    reg_val;
-
-	if (fc_info.cfg.tgt_port_changed == MV_TRUE) {
-		/* Enable FC for target port */
-		MV_U32   phy_addr = mvBoardPhyAddrGet(fc_info.cfg.tgt_port);
-
-		reg_val  = MV_REG_READ(NETA_GMAC_AN_CTRL_REG(fc_info.cfg.tgt_port));
-		reg_val |= NETA_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
-		reg_val |= NETA_SET_FLOW_CONTROL_MASK;
-		MV_REG_WRITE(NETA_GMAC_AN_CTRL_REG(fc_info.cfg.tgt_port), reg_val);
-
-		/* Reatart AN on target port PHY */
-		mvEthPhyRestartAN(phy_addr, 0);
-
-		fc_info.cfg.tgt_port_changed = MV_FALSE;
-	}
-
-	/* Manage FC mode on target port if needed */
-	reg_val  = MV_REG_READ(ETH_PORT_SERIAL_CTRL_REG(fc_info.cfg.tgt_port));
-	reg_val &= ~ETH_TX_FC_MODE_MASK;
-
-	queue_desc_number = mvNetaTxqPendDescNumGet(fc_info.cfg.port, fc_info.cfg.tx_port, fc_info.cfg.tx_queue);
-	if (queue_desc_number >= fc_info.cfg.thresh_high)
-		reg_val |= ETH_TX_FC_SEND_PAUSE;
-	else if (queue_desc_number <= fc_info.cfg.thresh_low)
-		reg_val |= ETH_TX_FC_NO_PAUSE;
-	else
-		return;
-
-	MV_REG_WRITE(ETH_PORT_SERIAL_CTRL_REG(fc_info.cfg.tgt_port), reg_val);
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_get_info
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function returns FC module configuration and statistics
-**
-**  PARAMETERS:  tpm_fc_info_t  **info
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_get_info(tpm_fc_info_t **info)
-{
-	*info = &fc_info;
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_clear_stat
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function clears FC module  statistics
-**
-**  PARAMETERS:  none
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_clear_stat(void)
-{
-#ifdef TPM_FC_DEBUG
-	memset(&fc_info.stat, 0, sizeof(tpm_fc_stat_t));
-#endif
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_set_config
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure Rate limiting parameters
-**
-**  PARAMETERS:  tpm_fc_cfg_t  *cfg
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_set_config(tpm_fc_cfg_t *cfg)
-{
-	tpm_init_fc_params_t db_fc_conf;
-
-	fc_info.cfg.thresh_high = cfg->thresh_high;
-	fc_info.cfg.thresh_low  = cfg->thresh_low;
-	fc_info.cfg.port        = cfg->port;
-
-	if (fc_info.cfg.tgt_port != cfg->tgt_port) {
-		fc_info.cfg.tgt_port         = cfg->tgt_port;
-		fc_info.cfg.tgt_port_changed = MV_TRUE;
-	}
-
-	fc_info.cfg.tx_port     = cfg->tx_port;
-	fc_info.cfg.tx_queue    = cfg->tx_queue;
-
-	/* update DB with new settings */
-	tpm_db_fc_conf_get(&db_fc_conf);
-
-	db_fc_conf.port		= cfg->tx_port;
-	db_fc_conf.tgt_port 	= cfg->tgt_port;
-	db_fc_conf.thresh_high 	= cfg->thresh_high;
-	db_fc_conf.thresh_low 	= cfg->thresh_low;
-	db_fc_conf.tx_port	= cfg->tx_port;
-	db_fc_conf.tx_queue	= cfg->tx_queue;
-
-	tpm_db_fc_conf_set(&db_fc_conf);
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_set_period
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure Rate limiting parameters
-**
-**  PARAMETERS:  MV_U32 us_period
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_set_period(MV_U32 us_period)
-{
-	MV_U32 ns_period = us_period * 1000;
-	tpm_init_fc_params_t db_fc_conf;
-
-	if (ns_period < us_period)
-		return (MV_ERROR);
-
-	/* update DB entry */
-	tpm_db_fc_conf_get(&db_fc_conf);
-       db_fc_conf.queue_sample_freq = us_period;
-	tpm_db_fc_conf_set(&db_fc_conf);
-
-	fc_info.cfg.hrt_hit_time = ktime_set(0, ns_period);
-	mv_enable_fc_events(&tpm_fc_hr_timer_handler, ns_period);
-
-	return (MV_OK);
-}
-
-#ifdef TPM_FC_DEBUG
-/*******************************************************************************
-**
-**  tpm_fc_set_oneshot
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure oneshot counter value
-**
-**  PARAMETERS:  MV_U32 oneshot
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_set_oneshot(MV_U32 oneshot)
-{
-	fc_info.cfg.oneshot_count = oneshot;
-
-	return (MV_OK);
-}
-#endif
-
-/*******************************************************************************
-**
-**  tpm_fc_hr_timer_handler
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: PON periodic high resolution timer handler
-**
-**  PARAMETERS:  none
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     hr_timer_RESTART
-**
-*******************************************************************************/
-#if 0
-static enum hrtimer_restart tpm_fc_hr_timer_handler(struct hrtimer *timer)
-{
-	ktime_t current_time    = timer->base->get_time();
-#else
-void tpm_fc_hr_timer_handler(void)
-{
-	ktime_t current_time    = ktime_get_real();
-#endif
-
-	s64     current_time_ns = ktime_to_ns(current_time);
-	s64     last_hit_ns     = ktime_to_ns(fc_info.hrt_last_hit);
-	s64     time_slip_ns;
-	s64     hit_time_ns     = ktime_to_ns(fc_info.cfg.hrt_hit_time);
-
-#ifdef TPM_FC_DEBUG
-	fc_info.stat.hrt_hits_num++;
-	if (fc_info.stat.hrt_hits_num < 100)
-		TRC_REC("Hit %ld\n", fc_info.stat.hrt_hits_num);
-
-	if ((fc_info.cfg.oneshot_count != 0) && (fc_info.oneshot_stat.hrt_hits_num < fc_info.cfg.oneshot_count))
-		fc_info.oneshot_stat.hrt_hits_num++;
-#endif
-#if 0
-	/* Update timer for the next hit at the beginning for better precision */
-	hrtimer_forward(timer, current_time, fc_info.cfg.hrt_hit_time);
-#endif
-	/* First compute the real timer period */
-	time_slip_ns = current_time_ns - last_hit_ns;
-
-	if (time_slip_ns < 0) {
-#ifdef TPM_FC_DEBUG
-		fc_info.stat.hrt_wraparound++;
-		if ((fc_info.cfg.oneshot_count != 0) && (fc_info.oneshot_stat.hrt_hits_num < fc_info.cfg.oneshot_count))
-			fc_info.oneshot_stat.hrt_wraparound++;
-#endif
-		time_slip_ns = KTIME_MAX - last_hit_ns + current_time_ns;
-	}
-
-	/* Update last hit with the current time */
-	fc_info.hrt_last_hit = current_time;
-
-#ifdef TPM_FC_DEBUG
-	if (fc_info.pre_stat_cnt) {
-		fc_info.pre_stat_cnt--;
-
-		/* Flow Control the port */
-		tpm_fc_rate_limit();
-#if 0
-		return (HRTIMER_RESTART);
-#else
-		return;
-#endif
-	}
-#endif
-
-	/* Calculate the slip from the requested time period */
-	time_slip_ns -= hit_time_ns;
-
-#ifdef TPM_FC_DEBUG
-	/* Collect more statistics */
-	if (time_slip_ns != 0) {
-
-		/* Total counters */
-		fc_info.stat.hrt_lost_num++;
-
-		if (time_slip_ns > fc_info.stat.hrt_lost_max_ns)
-			fc_info.stat.hrt_lost_max_ns = time_slip_ns;
-
-		if (time_slip_ns >= (hit_time_ns << 1))
-			fc_info.stat.hrt_lost_200_up++;
-		else if (time_slip_ns >= (hit_time_ns + (hit_time_ns >> 1)))
-			fc_info.stat.hrt_lost_150_200++;
-		else if (time_slip_ns >= hit_time_ns)
-			fc_info.stat.hrt_lost_100_150++;
-		else if (time_slip_ns >= (hit_time_ns >> 1))
-			fc_info.stat.hrt_lost_50_100++;
-		else if (time_slip_ns >= (hit_time_ns >> 2))
-			fc_info.stat.hrt_lost_25_50++;
-		else
-			fc_info.stat.hrt_lost_25_less++;
-
-		/* One-shot counters */
-		if ((fc_info.cfg.oneshot_count != 0) && (fc_info.oneshot_stat.hrt_hits_num < fc_info.cfg.oneshot_count)) {
-			fc_info.oneshot_stat.hrt_lost_num++;
-
-			if (time_slip_ns > fc_info.oneshot_stat.hrt_lost_max_ns)
-				fc_info.oneshot_stat.hrt_lost_max_ns = time_slip_ns;
-
-			if (time_slip_ns >= (hit_time_ns << 1))
-				fc_info.oneshot_stat.hrt_lost_200_up++;
-			else if (time_slip_ns >= (hit_time_ns + (hit_time_ns >> 1)))
-				fc_info.oneshot_stat.hrt_lost_150_200++;
-			else if (time_slip_ns >= hit_time_ns)
-				fc_info.oneshot_stat.hrt_lost_100_150++;
-			else if (time_slip_ns >= (hit_time_ns >> 1))
-				fc_info.oneshot_stat.hrt_lost_50_100++;
-			else if (time_slip_ns >= (hit_time_ns >> 2))
-				fc_info.oneshot_stat.hrt_lost_25_50++;
-			else
-				fc_info.oneshot_stat.hrt_lost_25_less++;
-		}
-	}
-#endif
-
-	/* Flow Control the port */
-	tpm_fc_rate_limit();
-#if 0
-	return (HRTIMER_RESTART);
-#endif
-}
-
-
-/*******************************************************************************
-**
-**  tpm_fc_enable
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function enable the SW Flow-Control
-**
-**  PARAMETERS:  MV_BOOL enable
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_enable(MV_BOOL enable)
-{
-	MV_BOOL fc_is_running = tpm_fc_is_running();
-	tpm_init_fc_params_t db_fc_conf;
-	MV_BOOL config_change = false;
-
-	if (MV_FALSE == enable)
-	{
-		/* Disable FC for target port if mode changed */
-		if (true == fc_is_running) {
-			MV_U32  phy_addr = mvBoardPhyAddrGet(fc_info.cfg.tgt_port);
-			MV_U32	reg_val;
-
-#if 0
-			hrtimer_cancel(&fc_info.hr_timer);
-#else
-			mv_disable_fc_events();
-#endif
-			reg_val  = MV_REG_READ(NETA_GMAC_AN_CTRL_REG(fc_info.cfg.tgt_port));
-			reg_val |= NETA_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
-			reg_val &= ~NETA_SET_FLOW_CONTROL_MASK;
-			MV_REG_WRITE(NETA_GMAC_AN_CTRL_REG(fc_info.cfg.tgt_port), reg_val);
-
-			/* Reatart AN on target port PHY */
-			mvEthPhyRestartAN(phy_addr, 0);
-
-			/* set FC not running indication */
-			fc_info.magic = 0;
-			config_change = true;
-		}
-
-#ifdef TPM_FC_DEBUG
-		fc_info.cfg.oneshot_count = 0;
-#endif
-		TRC_RELEASE();
-	}
-	else
-	{
-		if (false == fc_is_running){
-#ifdef TPM_FC_DEBUG
-			/* clear up statistics */
-			memset(&fc_info.oneshot_stat, 0, sizeof(tpm_fc_stat_t));
-			memset(&fc_info.stat, 0, sizeof(tpm_fc_stat_t));
-			fc_info.pre_stat_cnt = 64;
-#endif
-			/* force port setting */
-			fc_info.cfg.tgt_port_changed = MV_TRUE;
-
-			/* set FC running indication */
-			fc_info.magic = TPM_FC_MAGIC_NUMBER;
-
-			/* save the current time in the last hit */
-			fc_info.hrt_last_hit = ktime_get_real();
-#if 0
-			hrtimer_init(&fc_info.hr_timer, CLOCK_REALTIME, HRTIMER_MODE_REL);
-			fc_info.hr_timer.function = &tpm_fc_hr_timer_handler;
-			hrtimer_start(&fc_info.hr_timer, fc_info.cfg.hrt_hit_time, HRTIMER_MODE_REL);
-#else
-			//TRC_INIT();
-			mv_enable_fc_events(&tpm_fc_hr_timer_handler, ktime_to_ns(fc_info.cfg.hrt_hit_time));
-#endif
-			config_change = true;
-		}
-	}
-
-	if (config_change) {
-		/* update current DB settings */
-		tpm_db_fc_conf_get(&db_fc_conf);
-		db_fc_conf.enabled = (enable == MV_TRUE) ? 1 : 0;
-		tpm_db_fc_conf_set(&db_fc_conf);
-	}
-
-
-	return (MV_OK);
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_is_running
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: Return the running status of FC engine
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     MV_TRUE/MV_FALSE
-**
-*******************************************************************************/
-MV_BOOL tpm_fc_is_running(void)
-{
-	if (fc_info.magic == TPM_FC_MAGIC_NUMBER)
-		return(MV_TRUE);
-	else
-		return(MV_FALSE);
-}
-
-/*******************************************************************************
-**
-**  tpm_fc_engine_init
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: Init fc engine
-**
-**  PARAMETERS:  MV_U32           us_period
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     MV_OK/MV_ERROR
-**
-*******************************************************************************/
-int32_t tpm_fc_engine_init(void)
-{
-	tpm_init_fc_params_t 	db_fc_conf;
-	MV_U32 			ns_q_sample_freq;
-	MV_BOOL			fc_is_running;
-
-	/* save the current state, for runtime MIB reset */
-	fc_is_running = tpm_fc_is_running();
-
-	/* get current DB settings */
-	tpm_db_fc_conf_get(&db_fc_conf);
-
-	/* FC was enabled before MIB reset */
-	if (fc_is_running) {
-		TPM_OS_DEBUG(TPM_MTU_MOD, "SW port FC disabled!\n");
-		tpm_fc_enable(MV_FALSE);
-	}
-
-	memset(&fc_info, 0, sizeof(tpm_fc_info_t));
-
-	ns_q_sample_freq = db_fc_conf.queue_sample_freq * 1000;
-
-	if (ns_q_sample_freq < db_fc_conf.queue_sample_freq)
-		return (MV_ERROR);
-
-	fc_info.cfg.hrt_hit_time	= ktime_set(0, ns_q_sample_freq);
-	fc_info.cfg.thresh_high		= db_fc_conf.thresh_high;
-	fc_info.cfg.thresh_low		= db_fc_conf.thresh_low;
-	fc_info.cfg.port		    = db_fc_conf.port;
-	fc_info.cfg.tgt_port		= db_fc_conf.tgt_port;
-	fc_info.cfg.tgt_port_changed	= MV_TRUE;
-
-#ifdef TPM_FC_DEBUG
-	fc_info.cfg.oneshot_count = 0;
-#endif
-
-	if (db_fc_conf.enabled){
-		TPM_OS_DEBUG(TPM_MTU_MOD, "SW port FC enabled!\n");
-		tpm_fc_enable(MV_TRUE);
-	}
-
-	return MV_OK;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.h
deleted file mode 100644
index 2c8067b..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_cpu_port_fc.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_ctc_cm.h
-*
-* DESCRIPTION:
-*               header file for tpm_cpu_port_fc.c
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   KostaP
-*
-* DATE CREATED: 6 June 2012
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1
-*
-*
-*******************************************************************************/
-#ifndef _TPM_CPU_PORT_FC_H_
-#define _TPM_CPU_PORT_FC_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <linux/hrtimer.h>
-#include <linux/ktime.h>
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-#define TPM_FC_MAGIC_NUMBER		0xFCFACED
-#define TPM_FC_DEBUG
-
-typedef struct tpm_fc_cfg_t_ {
-	MV_U32   thresh_high;
-	MV_U32   thresh_low;
-	MV_U32   port;
-	MV_U32   tgt_port;
-	MV_BOOL  tgt_port_changed;
-	MV_U32   tx_port;
-	MV_U32   tx_queue;
-	ktime_t  hrt_hit_time;
-	ktime_t  hrt_hit_time_delay;
-	MV_U32   oneshot_count;
-
-} tpm_fc_cfg_t;
-
-#ifdef  TPM_FC_DEBUG
-typedef struct tpm_fc_stat_t_ {
-	MV_U32   hrt_hits_num;
-	MV_U32   hrt_lost_num;
-	MV_U32   hrt_wraparound;
-	s64      hrt_lost_max_ns;
-	s64      hrt_lost_200_up;  /* timer slips 200% and more than set time */
-	s64      hrt_lost_150_200; /* timer slips 150%-200% out of set time */
-	s64      hrt_lost_100_150; /* timer slips 100%-150% out of set time */
-	s64      hrt_lost_50_100;  /* timer slips 50%-100% out of set time */
-	s64      hrt_lost_25_50;   /* timer slips 25%-50% out of set time */
-	s64      hrt_lost_25_less; /* timer slips less than 25% out of set time */
-} tpm_fc_stat_t;
-#endif
-
-typedef struct tpm_fc_info_t_ {
-	tpm_fc_cfg_t    cfg;
-	MV_U32          magic;
-	struct hrtimer  hr_timer;
-	ktime_t  	hrt_last_hit;
-#ifdef  TPM_FC_DEBUG
-	tpm_fc_stat_t   stat;
-	tpm_fc_stat_t   oneshot_stat;
-	ktime_t  	oneshot_hrt_last_hit;
-	MV_U32      	pre_stat_cnt;
-#endif
-} tpm_fc_info_t;
-
-/*******************************************************************************
-**
-**  tpm_fc_set_period
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure Rate limiting parameters
-**
-**  PARAMETERS:  MV_U32 us_period
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_set_period(MV_U32 us_period);
-
-/*******************************************************************************
-**
-**  tpm_fc_set_config
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure Rate limiting parameters
-**
-**  PARAMETERS:  tpm_fc_cfg_t  *cf
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_set_config(tpm_fc_cfg_t *cfg);
-
-/*******************************************************************************
-**
-**  tpm_fc_set_oneshot
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure oneshot counter value
-**
-**  PARAMETERS:  MV_U32 oneshot
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_set_oneshot(MV_U32 oneshot);
-
-/*******************************************************************************
-**
-**  tpm_fc_enable
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function configure oneshot counter value
-**
-**  PARAMETERS:  MV_U32 oneshot
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_enable(MV_BOOL enable);
-
-
-/*******************************************************************************
-**
-**  tpm_fc_get_info
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function returns FC module configuration and statistics
-**
-**  PARAMETERS:  tpm_fc_info_t  **info
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_get_info(tpm_fc_info_t **info);
-
-/*******************************************************************************
-**
-**  tpm_fc_clear_stat
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function clears FC module  statistics
-**
-**  PARAMETERS:  none
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     void
-**
-*******************************************************************************/
-void tpm_fc_clear_stat(void);
-
-/*******************************************************************************
-**
-**  tpm_fc_engine_init
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: Init fc engine
-**
-**  PARAMETERS:  none
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     MV_OK/MV_ERROR
-**
-*******************************************************************************/
-MV_STATUS tpm_fc_engine_init(void);
-
-/*******************************************************************************
-**
-**  tpm_fc_is_running
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: Return the running status of FC engine
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     none
-**
-**  RETURNS:     MV_TRUE/MV_FALSE
-**
-*******************************************************************************/
-MV_BOOL tpm_fc_is_running(void);
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif    /* _TPM_CPU_PORT_FC_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.c
deleted file mode 100644
index 1ead8e3..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.c
+++ /dev/null
@@ -1,787 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_ctc_cm.c
-*
-*
-*  MODULE : TPM
-*
-*  DESCRIPTION : This file config CTC CnM rule
-*
-*  MODIFICATION HISTORY:
-*           7Feb12   jinghua - initial version created.
-*
-* FILE REVISION NUMBER:
-*       Revision: 1.12
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_ctc_cm.h"
-#include "tpm_pkt_proc_logic.h"
-
-#define IF_ERROR(ret)		\
-	if (ret != TPM_OK) {\
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, " recvd ret_code(%d)\n", ret);\
-		return(ret);\
-	}
-
-/*******************************************************************************
-* tpm_ctc_cm_rule_add()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-* ipv4_key_idx       - key for IPv4 sub pattern.
-* Other inputs/outputs are same as API call
-*
-* OUTPUTS:
-* rule_index         - CTC CnM rule index
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_rule_add(uint32_t owner_id,
-				     tpm_src_port_type_t src_port,
-				     uint32_t precedence,
-				     tpm_parse_fields_t l2_parse_rule_bm,
-				     tpm_parse_fields_t ipv4_parse_rule_bm,
-				     tpm_parse_fields_t ipv6_parse_rule_bm,
-				     tpm_l2_acl_key_t   *l2_key,
-				     tpm_ipv4_acl_key_t *ipv4_key,
-				     tpm_ipv6_acl_key_t *ipv6_key,
-				     tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_pkt_action_t pkt_act,
-				     uint32_t pbits,
-				     uint32_t ipv4_key_idx,
-				     uint32_t *rule_index)
-{
-	tpm_error_code_t ret_code = ERR_GENERAL;
-
-	if (l2_parse_rule_bm)
-		ret_code = tpm_proc_add_l2_cnm_rule(owner_id, src_port, precedence, l2_parse_rule_bm, l2_key,
-						    ipv4_parse_rule_bm, ipv4_key, ipv4_key_idx, pkt_frwd,
-						    pkt_act, pbits, rule_index);
-	else if (ipv4_parse_rule_bm)
-		ret_code = tpm_proc_add_ipv4_cnm_rule(owner_id, src_port, precedence, ipv4_parse_rule_bm,
-						      ipv4_key, pkt_frwd, pkt_act, pbits, rule_index);
-	else if (ipv6_parse_rule_bm)
-		ret_code = tpm_proc_add_ipv6_cnm_rule(owner_id, src_port, precedence, ipv6_parse_rule_bm,
-						      ipv6_key, pkt_frwd, pkt_act, pbits, rule_index);
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_ctc_cm_acl_rule_del()
-*
-* DESCRIPTION:    Main function for deleting CnM API rule.
-*
-* INPUTS:
-*
-* owner_id           - APP owner id  should be used for all API calls.
-* cm_rule            - CTC CnM rule data pointer
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_rule_del(uint32_t owner_id, tpm_db_ctc_cm_rule_entry_t  *cm_rule)
-{
-	tpm_error_code_t ret_code = ERR_GENERAL;
-
-	if ((cm_rule)->l2_parse_rule_bm)
-		ret_code = tpm_proc_del_l2_cnm_rule(owner_id, cm_rule->cm_main_rule_index);
-	else if ((cm_rule)->ipv4_parse_rule_bm)
-		ret_code = tpm_proc_del_ipv4_cnm_rule(owner_id, cm_rule->cm_main_rule_index);
-	else if ((cm_rule)->ipv6_parse_rule_bm)
-		ret_code = tpm_proc_del_ipv4_cnm_rule(owner_id, cm_rule->cm_main_rule_index);
-
-	return ret_code;
-}
-/*******************************************************************************
-* tpm_ctc_cm_add_rule_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_ctc_cm_acl_rule_add params.
-*
-* INPUTS:
-*                 - See tpm_ctc_cm_acl_rule_add
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_add_rule_check(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   uint32_t precedence,
-					   tpm_parse_fields_t l2_parse_rule_bm,
-					   tpm_parse_fields_t ipv4_parse_rule_bm,
-					   tpm_parse_fields_t ipv6_parse_rule_bm,
-					   tpm_l2_acl_key_t *l2_key,
-					   tpm_ipv4_acl_key_t *ipv4_key,
-					   tpm_ipv6_acl_key_t *ipv6_key,
-					   tpm_pkt_frwd_t *pkt_frwd,
-					   tpm_pkt_action_t pkt_act,
-					   uint32_t pbits)
-{
-	int32_t int_ret_code;
-	uint32_t num_rules, dummy_entry = 0;
-	uint8_t is_range_full;
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-	tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win;
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	/* if CTC CnM enabled */
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "CTC CnM is disabled!\n");
-		return(ERR_GENERAL);
-	}
-
-	if (src_port < TPM_SRC_PORT_UNI_0 || src_port > TPM_SRC_PORT_UNI_VIRT) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "src_port (%d) illegal!\n", src_port);
-		return(ERR_SRC_PORT_INVALID);
-	}
-
-	if (!tpm_db_eth_port_valid(src_port)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "src_port (%d) illegal!\n", src_port);
-		return(ERR_SRC_PORT_INVALID);
-	}
-
-	if (precedence >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "precedence (%d) illegal!\n", precedence);
-		return(ERR_CTC_CM_PREC_INVALID);
-	}
-
-	num_rules = tpm_db_ctc_cm_get_num_rules(src_port);
-	if (precedence > num_rules) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "precedence (%d) must be continous!\n", precedence);
-		return(ERR_CTC_CM_PREC_INVALID);
-	}
-
-	if (!l2_parse_rule_bm && !ipv4_parse_rule_bm && !ipv6_parse_rule_bm) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "both l2_parse_rule_bm and ipv4_parse_rule_bm are Zero!\n");
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	if (l2_parse_rule_bm & ~(TPM_L2_PARSE_MAC_DA | TPM_L2_PARSE_MAC_SA | TPM_L2_PARSE_ONE_VLAN_TAG |
-				 TPM_L2_PARSE_TWO_VLAN_TAG | TPM_L2_PARSE_ETYPE)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "l2_parse_rule_bm (%d) is invalid!\n", l2_parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	if (ipv4_parse_rule_bm & ~(TPM_IPv4_PARSE_SIP | TPM_IPv4_PARSE_DIP | TPM_IPv4_PARSE_DSCP |
-				   TPM_IPv4_PARSE_PROTO | TPM_PARSE_L4_SRC | TPM_PARSE_L4_DST)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "ipv4_parse_rule_bm (%d) is invalid!\n", ipv4_parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* ipv6_parse_rule_bm depends on ipv6 CnM parse window */
-	tpm_db_ctc_cm_ipv6_parse_win_get(&ctc_cm_ipv6_parse_win);
-	if(TPM_CTC_CM_IPv6_FIRST_24B == ctc_cm_ipv6_parse_win) {
-		if (ipv6_parse_rule_bm & ~(TPM_IPv6_PARSE_SIP | TPM_IPv6_PARSE_DSCP | TPM_IPv6_PARSE_NH |
-					   TPM_IPv6_PARSE_HOPL)) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, "ipv6_parse_rule_bm (%d) is invalid!\n", ipv6_parse_rule_bm);
-			return(ERR_PARSE_MAP_INVALID);
-		}
-	} else {
-		if (ipv6_parse_rule_bm & ~(TPM_IPv6_PARSE_DIP | TPM_PARSE_L4_SRC | TPM_PARSE_L4_DST)) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, "ipv6_parse_rule_bm (%d) is invalid!\n", ipv6_parse_rule_bm);
-			return(ERR_PARSE_MAP_INVALID);
-		}
-	}
-
-	if (l2_parse_rule_bm && (NULL == l2_key)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "l2_key can not be NULL!\n");
-		return(ERR_NULL_POINTER);
-	}
-
-	if (ipv4_parse_rule_bm && (NULL == ipv4_key)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "ipv4_key can not be NULL!\n");
-		return(ERR_NULL_POINTER);
-	}
-
-	if (ipv6_parse_rule_bm && (NULL == ipv6_key)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "ipv6_key can not be NULL!\n");
-		return(ERR_NULL_POINTER);
-	}
-
-	if (!pkt_act) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "pkt_act is Zero!\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_act & (TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE)) &&
-		(NULL == pkt_frwd)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "pkt_frwd is NULL when TPM_ACTION_SET_TARGET_PORT or"
-					     " TPM_ACTION_SET_TARGET_QUEUE!\n");
-		return(ERR_NULL_POINTER);
-	}
-
-	if (pkt_frwd->trg_port < TPM_TRG_PORT_WAN || pkt_frwd->trg_port > TPM_TRG_LLID_7) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "trg_port (%d) is invalid!\n", pkt_frwd->trg_port);
-		return(ERR_FRWD_INVALID);
-	}
-
-	if (pkt_act & ~(TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE | TPM_ACTION_SET_PKT_MOD)) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "pkt_act (%d) is invalid!\n", pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	if (pkt_act & TPM_ACTION_SET_PKT_MOD) {
-		if (pbits > 7) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, "pbits (%d) is invalid!\n", pbits);
-			return(ERR_L2_KEY_INVALID);
-		}
-
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pbits, &dummy_entry);
-		if (int_ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " unsupported p-bit value: %d\n", pbits);
-			return(ERR_MOD_INVALID);
-		}
-	}
-
-	if (l2_parse_rule_bm && ipv4_parse_rule_bm) {
-		is_range_full = tpm_proc_if_ipv4_pre_range_is_full(src_port, ipv4_parse_rule_bm, ipv4_key);
-		if (is_range_full != TPM_FALSE) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, "not enough room for new ipv4 pre-filter key!\n");
-			return(ERR_OUT_OF_RESOURCES);
-		}
-	}
-
-	is_range_full = tpm_proc_if_cnm_main_range_is_full(src_port, precedence);
-	if (is_range_full != TPM_FALSE) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "not enough room for new cnm rule!\n");
-		return(ERR_OUT_OF_RESOURCES);
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_ctc_cm_acl_rule_add()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_acl_rule_add(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence,
-					 tpm_parse_fields_t l2_parse_rule_bm,
-					 tpm_parse_fields_t ipv4_parse_rule_bm,
-					 tpm_parse_fields_t ipv6_parse_rule_bm,
-					 tpm_l2_acl_key_t *l2_key,
-					 tpm_ipv4_acl_key_t *ipv4_key,
-					 tpm_ipv6_acl_key_t *ipv6_key,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_pkt_action_t pkt_act,
-					 uint32_t pbits)
-{
-	tpm_error_code_t            ret_code;
-	tpm_db_error_t              db_ret;
-	tpm_db_ctc_cm_rule_entry_t  cm_rule;
-	uint32_t                    ipv4_sub_pattern_key_idx = TPM_CNM_INVALID_IPV4_PRE_FILTER_KEY_ID;
-	uint32_t                    rule_index;
-	uint32_t                    rule_index_tmp;
-	uint32_t                    num_prec;
-	int32_t                     loop;
-	int32_t                     prece_tmp;
-
-	/* Check parameters */
-	ret_code = tpm_ctc_cm_add_rule_check(owner_id, src_port, precedence, l2_parse_rule_bm, ipv4_parse_rule_bm,
-					     ipv6_parse_rule_bm, l2_key, ipv4_key, ipv6_key, pkt_frwd, pkt_act, pbits);
-	IF_ERROR(ret_code);
-
-	/* add IPv4_Pre of Combo rule */
-	if (l2_parse_rule_bm && ipv4_parse_rule_bm) {
-		ret_code = tpm_proc_add_cnm_ipv4_pre_filter_key(owner_id, src_port, ipv4_parse_rule_bm, ipv4_key,
-								&ipv4_sub_pattern_key_idx);
-		IF_ERROR(ret_code);
-	}
-
-	/* insert new rule */
-	ret_code = tpm_ctc_cm_rule_add(owner_id, src_port, precedence, l2_parse_rule_bm, ipv4_parse_rule_bm,
-				       ipv6_parse_rule_bm, l2_key, ipv4_key, ipv6_key, pkt_frwd, pkt_act, pbits,
-				       ipv4_sub_pattern_key_idx, &rule_index);
-	IF_ERROR(ret_code);
-
-	/* update existing rules if needed */
-	num_prec = tpm_db_ctc_cm_get_num_rules(src_port);
-
-	/* from the lowest precedence to current precedence, decreased by 1 */
-	for (loop = num_prec; loop > precedence; loop--) {
-
-		prece_tmp = loop - 1;
-		db_ret = tpm_db_ctc_cm_rule_get(src_port, prece_tmp, &cm_rule);
-		if (TPM_DB_OK != db_ret) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-			return ERR_CTC_CM_DB_ERR;
-		}
-
-		/* first remvoe the old one, then add the new one  */
-		ret_code = tpm_ctc_cm_rule_del(owner_id, &cm_rule);
-		IF_ERROR(ret_code);
-
-		/* last prece is 7, do not need to add the rule which has just
-		 * been remvoed.
-		 */
-		if ((TPM_MAX_NUM_CTC_PRECEDENCE - 1) == prece_tmp)
-			continue;
-
-		/* add this rule with prece++ */
-		ret_code = tpm_ctc_cm_rule_add(owner_id, src_port, prece_tmp + 1, cm_rule.l2_parse_rule_bm,
-					       cm_rule.ipv4_parse_rule_bm, cm_rule.ipv6_parse_rule_bm,
-					       &(cm_rule.l2_key), &(cm_rule.ipv4_key), &(cm_rule.ipv6_key),
-					       &(cm_rule.pkt_frwd), (cm_rule.pkt_act), cm_rule.pbits,
-					       cm_rule.ipv4_sub_pattern_key, &rule_index_tmp);
-		IF_ERROR(ret_code);
-
-		/* overwrite DB entry of lower precedence */
-		db_ret = tpm_db_ctc_cm_rule_set(src_port, prece_tmp + 1, cm_rule.l2_parse_rule_bm,
-						cm_rule.ipv4_parse_rule_bm, cm_rule.ipv6_parse_rule_bm,
-						&(cm_rule.l2_key), &(cm_rule.ipv4_key), &(cm_rule.ipv6_key),
-						&(cm_rule.pkt_frwd), (cm_rule.pkt_act),
-						cm_rule.pbits, cm_rule.ipv4_sub_pattern_key, rule_index_tmp);
-		if (TPM_DB_OK != db_ret) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-			return ERR_CTC_CM_DB_ERR;
-		}
-
-	}
-
-	/* set db of this CnM rule */
-	db_ret = tpm_db_ctc_cm_rule_set(src_port, precedence, l2_parse_rule_bm, ipv4_parse_rule_bm,
-					ipv6_parse_rule_bm, l2_key, ipv4_key,
-					ipv6_key, pkt_frwd, pkt_act, pbits,
-					ipv4_sub_pattern_key_idx, rule_index);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-		return ERR_CTC_CM_DB_ERR;
-	}
-
-	return TPM_RC_OK;
-}
-/*******************************************************************************
-* tpm_ctc_cm_del_rule_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_ctc_cm_del_rule_check params.
-*
-* INPUTS:
-*                 - See tpm_ctc_cm_del_rule_check
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_del_rule_check(uint32_t owner_id,
-					   tpm_src_port_type_t src_port,
-					   uint32_t precedence)
-{
-	tpm_db_error_t   db_ret;
-	tpm_db_ctc_cm_rule_entry_t    cm_rule;
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	/* if CTC CnM enabled */
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "CTC CnM is disabled!\n");
-		return(ERR_GENERAL);
-	}
-
-	if (src_port < TPM_SRC_PORT_UNI_0 || src_port > TPM_SRC_PORT_UNI_VIRT) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "src_port (%d) illegal!\n", src_port);
-		return(ERR_SRC_PORT_INVALID);
-	}
-
-	if (precedence >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "precedence (%d) illegal!\n", precedence);
-		return(ERR_CTC_CM_PREC_INVALID);
-	}
-
-	db_ret = tpm_db_ctc_cm_rule_get(src_port, precedence, &cm_rule);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "get DB failed, ret_code: (%d), src_port: (%d), precedence: (%d)\n",
-			 db_ret, src_port, precedence);
-		return(ERR_CTC_CM_DB_ERR);
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_ctc_cm_acl_rule_del()
-*
-* DESCRIPTION:    Main function for deleting CnM API rule.
-*
-* INPUTS:
-*		  All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_acl_rule_del(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence)
-{
-	tpm_error_code_t ret_code;
-	tpm_db_error_t   db_ret;
-	tpm_db_ctc_cm_rule_entry_t  cm_rule;
-	uint32_t                    rule_index;
-	uint32_t                    num_prec;
-	uint32_t                    loop;
-
-	/* Check parameters */
-	ret_code = tpm_ctc_cm_del_rule_check(owner_id, src_port, precedence);
-	IF_ERROR(ret_code);
-
-	db_ret = tpm_db_ctc_cm_rule_get(src_port, precedence, &cm_rule);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "get DB failed, ret_code: (%d), src_port: (%d), precedence: (%d)\n",
-			     db_ret, src_port, precedence);
-		return(ERR_CTC_CM_DB_ERR);
-	}
-
-	/* remove rule */
-	ret_code = tpm_ctc_cm_rule_del(owner_id, &cm_rule);
-	IF_ERROR(ret_code);
-
-	/* remove IPv4_Pre of Combo rule */
-	if (cm_rule.l2_parse_rule_bm && cm_rule.ipv4_parse_rule_bm) {
-		ret_code = tpm_proc_del_cnm_ipv4_pre_filter_key(owner_id, src_port, cm_rule.ipv4_sub_pattern_key);
-		IF_ERROR(ret_code);
-	}
-
-	/* update existing rules if needed */
-	num_prec = tpm_db_ctc_cm_get_num_rules(src_port);
-
-	/* from the next lower-to current precedence to the lowest precedence, increased by 1 */
-	for (loop = precedence + 1; loop < num_prec; loop++) {
-
-		db_ret = tpm_db_ctc_cm_rule_get(src_port, loop, &cm_rule);
-		if (TPM_DB_OK != db_ret) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-			return ERR_CTC_CM_DB_ERR;
-		}
-
-		/* add this rule with prece++ */
-		ret_code = tpm_ctc_cm_rule_add(owner_id, src_port, loop - 1, cm_rule.l2_parse_rule_bm, cm_rule.ipv4_parse_rule_bm,
-					       cm_rule.ipv6_parse_rule_bm, &(cm_rule.l2_key), &(cm_rule.ipv4_key),
-					       &(cm_rule.ipv6_key), &(cm_rule.pkt_frwd),
-					       cm_rule.pkt_act, cm_rule.pbits, cm_rule.ipv4_sub_pattern_key, &rule_index);
-		IF_ERROR(ret_code);
-
-		/* overwrite DB entry of higher precedence */
-		db_ret = tpm_db_ctc_cm_rule_set(src_port, loop - 1, cm_rule.l2_parse_rule_bm, cm_rule.ipv4_parse_rule_bm,
-					cm_rule.ipv6_parse_rule_bm, &(cm_rule.l2_key),
-					&(cm_rule.ipv4_key), &(cm_rule.ipv6_key),
-					&(cm_rule.pkt_frwd), cm_rule.pkt_act,
-					cm_rule.pbits, cm_rule.ipv4_sub_pattern_key, rule_index);
-		if (TPM_DB_OK != db_ret) {
-			TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-			return ERR_CTC_CM_DB_ERR;
-		}
-
-		/* remove the old one */
-		ret_code = tpm_ctc_cm_rule_del(owner_id, &cm_rule);
-		IF_ERROR(ret_code);
-	}
-
-	/* reset the db of last rule */
-	db_ret = tpm_db_ctc_cm_rule_delete(src_port, num_prec - 1);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, " DB failed, recvd ret_code(%d)\n", db_ret);
-		return ERR_CTC_CM_DB_ERR;
-	}
-
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_ctc_cm_ipv4_rule2cm()
-*
-* DESCRIPTION:    check if this rule can goto CnM stage from IPv4 stage.
-*
-* INPUTS:
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-* pkt_act            - Action associated to the rule
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns true. On error returns false.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-bool tpm_ctc_cm_ipv4_rule2cm(tpm_parse_flags_t parse_flags_bm, tpm_rule_action_t *rule_action)
-{
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED) {
-		/* CTC CnM is disabled */
-		return false;
-	}
-
-	/* not MTM, not to CPU */
-	if (     (parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)
-	     && !(rule_action->pkt_act & TPM_ACTION_TO_CPU))
-		return true;
-	else
-		return false;
-}
-/*******************************************************************************
-* tpm_ctc_cm_l3_rule2cm_sram()
-*
-* DESCRIPTION:    check if this rule can goto CnM stage from ETH stage when building sram of ETH rule.
-*
-* INPUTS:
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-* pkt_act            - Action associated to the rule
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns true. On error returns false.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-bool tpm_ctc_cm_l3_rule2cm_sram(tpm_parse_flags_t parse_flags_bm, tpm_rule_action_t *rule_action)
-{
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED) {
-		/* CTC CnM is disabled */
-		return false;
-	}
-
-	/* [!mac-to-me] */
-	if (parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)
-		return true;
-	else
-		return false;
-}
-/*******************************************************************************
-* tpm_ctc_cm_l3_rule2cm_sram()
-*
-* DESCRIPTION:    check if this rule can goto CnM stage from ETH stage when building tcam of ETH rule.
-*
-* INPUTS:
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-* l3_key             - Structure for PPPoE proto or ether type. In order to define a rule for
-*                      any ether type, the ether type value should be set to 0xFFFF
-* rule_action        -used to get the next_stage of this rule
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns true. On error returns false.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-bool tpm_ctc_cm_l3_rule2cm_tcam(tpm_parse_flags_t parse_flags_bm, tpm_l3_type_key_t *l3_key, tpm_rule_action_t *rule_action)
-{
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED) {
-		/* CTC CnM is disabled */
-		return false;
-	}
-
-	/* not ipv4/6 or pppoe and [!mac-to-me] */
-	if (   (0x0800 != l3_key->ether_type_key)
-	    && (0x86dd != l3_key->ether_type_key)
-	    && (ETH_P_PPP_SES != l3_key->ether_type_key)
-	    && (parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)
-	    && (STAGE_CTC_CM == rule_action->next_phase))
-		return true;
-	else
-		return false;
-}
-
-/*******************************************************************************
-* tpm_ctc_cm_ipv6_acl_rule_add()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_ipv6_acl_rule_add(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      uint32_t precedence,
-					      tpm_parse_fields_t ipv6_parse_rule_bm,
-					      tpm_ipv6_acl_key_t *ipv6_key,
-					      tpm_pkt_frwd_t *pkt_frwd,
-					      tpm_pkt_action_t pkt_act,
-					      uint32_t pbits)
-{
-	tpm_error_code_t            ret_code;
-	tpm_parse_fields_t          ipv4_parse_rule_bm = 0;
-	tpm_parse_fields_t	    l2_parse_rule_bm = 0;
-	tpm_l2_acl_key_t            l2_key;
-	tpm_ipv4_acl_key_t          ipv4_key;
-
-	ret_code = tpm_ctc_cm_acl_rule_add(owner_id, src_port, precedence, l2_parse_rule_bm,
-					   ipv4_parse_rule_bm, ipv6_parse_rule_bm, &l2_key,
-					   &ipv4_key, ipv6_key, pkt_frwd, pkt_act, pbits);
-	IF_ERROR(ret_code);
-
-	return TPM_RC_OK;
-}
-/*******************************************************************************
-* tpm_ctc_cm_set_ipv6_parse_win()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_set_ipv6_parse_win(uint32_t owner_id, tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window)
-{
-	uint32_t                    entry_id;
-	uint32_t                    ipv6_rule_nums;
-	int32_t                     ret_code = TPM_OK;
-	tpm_db_ctc_cm_ipv6_parse_win_t ipv6_parse_win_orig;
-
-	tpm_db_ctc_cm_ipv6_parse_win_get(&ipv6_parse_win_orig);
-	if (ipv6_parse_window == ipv6_parse_win_orig) {
-		TPM_OS_INFO(TPM_CTC_CM_MOD, "ipv6 parse win remains the same\n");
-		return TPM_OK;
-	}
-
-	/* if there is still IPv6 CnM rule exist, reture error */
-	ipv6_rule_nums = tpm_db_ctc_cm_get_ipv6_num_rules();
-	if (0 != ipv6_rule_nums) {
-		TPM_OS_ERROR(TPM_CTC_CM_MOD, "there is still IPv6 CnM rule exist, remove first!\n");
-		return ERR_CTC_CM_DB_ERR;
-	}
-
-	/* get ipv6_ety_rule_num */
-	tpm_db_ctc_cm_ipv6_ety_rule_num_get(&entry_id);
-
-	ret_code = tpm_pncl_init_cnm_main_ety_ipv6(entry_id, ipv6_parse_window);
-	IF_ERROR(ret_code);
-
-	/* set new ipv6 parse window */
-	tpm_db_ctc_cm_ipv6_parse_win_set(ipv6_parse_window);
-
-	return TPM_RC_OK;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.h
deleted file mode 100644
index 5f13837..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_ctc_cm.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_ctc_cm.h
-*
-* DESCRIPTION:
-*               header file for tpm_ctc_cm.c
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   jinghua
-*
-* DATE CREATED: 7 Feb 2012
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.2
-*
-*
-*******************************************************************************/
-#ifndef _TPM_CTC_CM_H_
-#define _TPM_CTC_CM_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-
-/*******************************************************************************
-* tpm_ctc_cm_acl_rule_add()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_acl_rule_add(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence,
-					 tpm_parse_fields_t l2_parse_rule_bm,
-					 tpm_parse_fields_t ipv4_parse_rule_bm,
-					 tpm_parse_fields_t ipv6_parse_rule_bm,
-					 tpm_l2_acl_key_t *l2_key,
-					 tpm_ipv4_acl_key_t *ipv4_key,
-					 tpm_ipv6_acl_key_t *ipv6_key,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_pkt_action_t pkt_act,
-					 uint32_t pbits);
-
-/*******************************************************************************
-* tpm_ctc_cm_acl_rule_del()
-*
-* DESCRIPTION:    Main function for deleting CnM API rule.
-*
-* INPUTS:
-*		  All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_acl_rule_del(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t precedence);
-/*******************************************************************************
-* tpm_ctc_cm_ipv6_acl_rule_add()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_ipv6_acl_rule_add(uint32_t owner_id,
-					      tpm_src_port_type_t src_port,
-					      uint32_t precedence,
-					      tpm_parse_fields_t ipv6_parse_rule_bm,
-					      tpm_ipv6_acl_key_t *ipv6_key,
-					      tpm_pkt_frwd_t *pkt_frwd,
-					      tpm_pkt_action_t pkt_act,
-					      uint32_t pbits);
-
-bool tpm_ctc_cm_ipv4_rule2cm(tpm_parse_flags_t parse_flags_bm, tpm_rule_action_t *rule_action);
-bool tpm_ctc_cm_l3_rule2cm_sram(tpm_parse_flags_t parse_flags_bm, tpm_rule_action_t *rule_action);
-bool tpm_ctc_cm_l3_rule2cm_tcam(tpm_parse_flags_t parse_flags_bm, tpm_l3_type_key_t *l3_key, tpm_rule_action_t *rule_action);
-/*******************************************************************************
-* tpm_ctc_cm_set_ipv6_parse_win()
-*
-* DESCRIPTION:    Main function for adding CnM API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_ctc_cm_set_ipv6_parse_win(uint32_t owner_id, tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window);
-
-#ifdef __cplusplus
-}
-#endif
-#endif    /* _TPM_CTC_CM_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.c
deleted file mode 100644
index 57bdb86..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.c
+++ /dev/null
@@ -1,11115 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-*
-* tpm_db.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.4
-*
-*
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include <linux/vmalloc.h>
-
-/* Local definitions */
-#define PNC_RANGE_OPER(x)         tpm_db.pnc_range[x].pnc_range_oper
-#define PNC_RANGE_CONF(x)         tpm_db.pnc_range[x].pnc_range_conf
-#define TPM_DBVAL_CON(dbval)      ((dbval == TPM_DB_VALID) ? TPM_TRUE : TPM_FALSE)
-#define TPM_DB_DIVIDED_BY_32(x)   (x >> 5)
-#define TPM_DB_MOD_32(x)          (x & 0x1f)
-
-#define MEM_MARGIN_PATTERN        (0xA3)
-#define API_ENT_I(api_sec, i) tpm_db.api_ent_mem_area[(tpm_db.api_section[api_sec].table_start) + i]
-#define IF_ERROR(ret) \
-	if (ret != TPM_DB_OK) { \
-		TPM_OS_ERROR(TPM_DB_MOD, " recvd ret_code(%d)\n", ret); \
-		return(ret); \
-	}
-#define IF_ERROR_I(ret, i) \
-	if (ret != TPM_DB_OK) { \
-		TPM_OS_ERROR(TPM_DB_MOD, " For index(%d), recvd ret_code(%d)\n", i, ret); \
-		return(ret); \
-	}
-
-/* TODO - change to static variable after updating print functions */
-tpm_db_t tpm_db;
-tpm_db_hot_swap_bak_db_t hot_swap_bak_db;
-
-static uint32_t mem_alloc_start_ind;
-
-const char *entry_state_str[TPM_MOD_ENTRY_STATUS_MAX] = { "F", "B", "O", "R", "S" };
-
-uint32_t *tpm_db_mod2_jump_booked_entry_bm[TPM_MAX_NUM_GMACS];
-uint32_t *tpm_db_mod2_jump_occupied_entry_bm[TPM_MAX_NUM_GMACS];
-uint32_t *tpm_db_mod2_jump_split_mod_occupied_entry_bm[TPM_MAX_NUM_GMACS];
-uint32_t *tpm_db_mod2_jump_split_mod_all_entry_bm[TPM_MAX_NUM_GMACS];
-
-uint32_t tpm_db_mod2_jump_bm_group;
-
-uint32_t *tpm_db_mod2_chain_booked_entry_bm[TPM_MAX_NUM_GMACS][TPM_CHAIN_TYPE_MAX];
-uint32_t *tpm_db_mod2_chain_occupied_entry_bm[TPM_MAX_NUM_GMACS][TPM_CHAIN_TYPE_MAX];
-
-uint32_t tpm_db_mod2_chain_bm_group[TPM_CHAIN_TYPE_MAX];
-
-tpm_mod2_jump_pmt_info_t *tpm_db_mod2_jump_pmt_info[TPM_MAX_NUM_GMACS];
-tpm_mod2_chain_pmt_info_t *tpm_db_mod2_chain_pmt_info[TPM_MAX_NUM_GMACS];
-
-tpm_mod2_chain_info_t *tpm_db_mod2_chain_info[TPM_MAX_NUM_GMACS][TPM_CHAIN_TYPE_MAX];
-
-tpm_mod2_jump_cfg_t tpm_db_mod2_jump_area_cfg;
-tpm_mod2_chain_cfg_t tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAX];
-
-uint16_t tpm_mod2_chain_area_base;
-uint16_t tpm_mod2_total_chain_num;
-
-uint8_t tpm_mod2_multicast_mh_enable;
-uint8_t tpm_mod2_pppoe_add_mod_enable;
-uint8_t tpm_mod2_double_tag_enable;
-uint8_t tpm_mod2_udp_checksum_use_init_bm_enable;
-uint8_t tpm_mod2_udp_checksum_enable;
-
-tpm_db_mc_stream_entry_t *tpm_db_mc_stream_table[TPM_MC_MAX_STREAM_NUM];
-tpm_db_mc_mac_entry_t *tpm_db_mc_mac_table[TPM_MC_MAX_MAC_NUM];
-
-uint32_t tpm_db_mc_lpbk_entries_num;
-tpm_db_mc_lpbk_entry_t *tpm_db_mc_lpbk_table[TPM_MC_MAX_LPBK_ENTRIES_NUM];
-tpm_db_mc_vlan_entry_t *tpm_db_mc_vlan_xits_table[TPM_MC_MAX_MVLAN_XITS_NUM];
-
-uint8_t tpm_db_mc_virt_uni_entry_state_table[TPM_MC_MAX_STREAM_NUM];
-
-uint8_t tpm_db_mc_igmp_proxy_sa_mac[6];
-uint8_t tpm_db_mc_igmp_proxy_sa_mac_valid;
-
-static uint32_t tpm_db_global_rule_idx = 1000;
-
-/* Function Declarations */
-int32_t tpm_db_api_freeentry_get(tpm_api_sections_t api_section, int32_t *index);
-int32_t tpm_db_api_entry_ind_get(tpm_api_sections_t api_section, uint32_t rule_num, int32_t *index);
-int32_t tpm_db_mod_shdw_par_check(tpm_gmacs_enum_t gmac, uint32_t mod_entry);
-
-
-/*******************************************************************************
-* tpm_db_eth_port_conf_get()
-*
-* DESCRIPTION:      Function to get an ethernet port physical configuration from the DB
-*
-* INPUTS:
-* ext_port         - External Port Identifier, can be any positive number
-*
-* OUTPUTS:
-*                 - See explanation in tpm_db_eth_port_conf_t structure
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-bool tpm_db_eth_port_valid(tpm_src_port_type_t src_port_num)
-{
-	uint32_t i;
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if ((tpm_db.eth_ports[i].port_src == src_port_num)
-		    && (tpm_db.eth_ports[i].valid == TPM_DB_VALID))
-			return (true);
-	}
-
-	return false;
-}
-
-/*******************************************************************************
-* tpm_db_eth_port_conf_get()
-*
-* DESCRIPTION:      Function to get an ethernet port physical configuration from the DB
-*
-* INPUTS:
-* ext_port         - External Port Identifier, can be any positive number
-*
-* OUTPUTS:
-*                 - See explanation in tpm_db_eth_port_conf_t structure
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_eth_port_conf_get(tpm_src_port_type_t src_port_num,
-				 tpm_db_chip_conn_t *chip_con,
-				 tpm_db_int_conn_t *int_con,
-				 uint32_t *switch_port)
-{
-	uint32_t i;
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if ((tpm_db.eth_ports[i].port_src == src_port_num)
-		    && (tpm_db.eth_ports[i].valid == TPM_DB_VALID)) {
-			*chip_con = tpm_db.eth_ports[i].chip_connect;
-			*int_con = tpm_db.eth_ports[i].int_connect;
-			*switch_port = tpm_db.eth_ports[i].switch_port;
-			return (TPM_DB_OK);
-		}
-	}
-
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_eth_port_switch_port_get()
-*
-* DESCRIPTION:      Function to get an ethernet port physical configuration from the DB
-*
-* INPUTS:
-* ext_port         - UNI Port Identifier, can be any positive number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns the switch port number.
-* On error, TPM_DB_ERR_PORT_NUM = 0xFF is returned.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_eth_port_switch_port_get(tpm_src_port_type_t src_port)
-{
-	uint32_t i;
-
-       if (TPM_SRC_PORT_UNI_VIRT == src_port) {
-                if (TPM_DB_VALID == tpm_db.func_profile.virt_uni_info.enabled)
-                        return tpm_db.func_profile.virt_uni_info.switch_port;
-               else
-                        return TPM_DB_ERR_PORT_NUM;
-       } else if (TPM_SRC_PORT_WAN == src_port) {
-               for (i = TPM_ENUM_GMAC_0; i < TPM_MAX_GMAC; i++) {
-			/*  in case traffic from WAN, the dest is LAN,
-			    so we search for switch port connected to GMAC LAN functionality */
-                       if (TPM_GMAC_FUNC_LAN == tpm_db.gmac_func[i]){
-                               if (TPM_GMAC_CON_SWITCH_4 == tpm_db.gmac_port_conf[i].conn)
-                                       return TPM_GMAC0_AMBER_PORT_NUM;
-                               else
-                                       return TPM_GMAC1_AMBER_PORT_NUM;
-                       }
-               }
-       } else {
-               for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-                       if ((tpm_db.eth_ports[i].port_src == src_port) &&
-                           (TPM_DB_VALID == tpm_db.eth_ports[i].valid))
-                               return (tpm_db.eth_ports[i].switch_port);
-		}
-
-	}
-	return (TPM_DB_ERR_PORT_NUM);
-}
-uint32_t tpm_db_rule_index_get(void)
-{
-	return tpm_db_global_rule_idx;
-}
-int32_t tpm_db_rule_index_set(uint32_t rule_index)
-{
-	tpm_db_global_rule_idx = rule_index;
-	return TPM_DB_OK;
-}
-void tpm_db_rule_index_incrs(void)
-{
-	tpm_db_global_rule_idx++;
-}
-bool tpm_db_gmac1_lpbk_en_get(void)
-{
-	return tpm_db.func_profile.gmac1_loopback_en;
-}
-void tpm_db_gmac1_lpbk_en_set(bool en)
-{
-	tpm_db.func_profile.gmac1_loopback_en = en;
-}
-bool tpm_db_cpu_wan_lpbk_en_get(void)
-{
-	return tpm_db.func_profile.cpu_wan_loopback_en;
-}
-void tpm_db_cpu_wan_lpbk_en_set(bool en)
-{
-	tpm_db.func_profile.cpu_wan_loopback_en = en;
-}
-bool tpm_db_ds_load_bal_en_get(void)
-{
-	return tpm_db.func_profile.ds_load_bal_en;
-}
-void tpm_db_ds_load_bal_en_set(bool en)
-{
-	tpm_db.func_profile.ds_load_bal_en = en;
-}
-bool tpm_db_switch_active_wan_en_get(void)
-{
-	return tpm_db.func_profile.switch_active_wan_en;
-}
-void tpm_db_switch_active_wan_en_set(bool en)
-{
-	tpm_db.func_profile.switch_active_wan_en = en;
-}
-
-int32_t tpm_db_get_valid_uni_ports_num(uint32_t *num_ports)
-{
-	uint32_t i, _num_ports = 0;
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (tpm_db.eth_ports[i].valid == TPM_DB_VALID) {
-			if (tpm_db.eth_ports[i].port_src >= TPM_SRC_PORT_UNI_0 &&
-				tpm_db.eth_ports[i].port_src <= TPM_SRC_PORT_UNI_7)
-				_num_ports++;
-		}
-	}
-
-    if (tpm_db.func_profile.virt_uni_info.enabled == TPM_DB_VALID)
-		_num_ports++;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_phy_convert_port_index()
-*
-* DESCRIPTION:      Function to get an ethernet port physical configuration from the DB
-*
-* INPUTS:
-* switch_port         - External Port Identifier, can be any positive number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns the switch port number.
-* On error, TPM_DB_ERR_PORT_NUM = 0xFF is returned.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_phy_convert_port_index(int32_t switch_port)
-{
-	uint32_t i;
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if ((tpm_db.eth_ports[i].switch_port == switch_port)
-		    && (tpm_db.eth_ports[i].valid == TPM_DB_VALID))
-			return (tpm_db.eth_ports[i].port_src);
-	}
-
-	return (TPM_DB_ERR_PORT_NUM);
-}
-EXPORT_SYMBOL(tpm_db_phy_convert_port_index);
-
-/*******************************************************************************
-* tpm_db_eth_cmplx_profile_set()
-*
-* DESCRIPTION:      Function to set the Ethernet Complex Profile in the DB
-*
-* INPUTS:
-* eth_cmplx_profile	- the profile enumartion number
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_eth_cmplx_profile_set(tpm_eth_complex_profile_t eth_cmplx_profile)
-{
-	tpm_db.eth_cmplx_profile = eth_cmplx_profile;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_eth_cmplx_profile_get()
-*
-* DESCRIPTION:      Function returns the Ethernet Complex Profile from the DB
-*
-* INPUTS:
-*
-* OUTPUTS:
-*		the profile enumartion number
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_eth_complex_profile_t tpm_db_eth_cmplx_profile_get(void)
-{
-	return tpm_db.eth_cmplx_profile;
-}
-
-
-/*******************************************************************************
-* tpm_db_mac_func_set()
-*
-* DESCRIPTION:	Sets all gmacs functionality according to EthCmplx profile
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-* 	On success, returns TPM_OK
-* 	On error, returns tpm_db_gmac_func_set error
-*******************************************************************************/
-int32_t tpm_db_mac_func_set(void)
-{
-	tpm_db_gmac_func_t pon = 0,
-			   gmac0 = 0,
-			   gmac1 = 0;
-	int32_t ret_code;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	switch(tpm_db.eth_cmplx_profile)
-	{
-	case TPM_PON_WAN_DUAL_MAC_INT_SWITCH:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-	if (0 != tpm_db.func_profile.virt_uni_info.enabled)
-			gmac1 = TPM_GMAC_FUNC_VIRT_UNI;
-	else
-			gmac1 = TPM_GMAC_FUNC_NONE;
-		break;
-
-	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
-	/* ofer: phase#2, diferentiate between gmacs */
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		gmac1 = TPM_GMAC_FUNC_NONE;
-		break;
-
-	case TPM_PON_WAN_G1_LAN_G0_INT_SWITCH:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		gmac1 = TPM_GMAC_FUNC_LAN_UNI;
-		break;
-
-	case TPM_PON_WAN_G0_INT_SWITCH:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		gmac1 = TPM_GMAC_FUNC_NONE;
-		break;
-
-	case TPM_PON_WAN_G0_SINGLE_PORT:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		gmac1 = TPM_GMAC_FUNC_NONE;
-		break;
-
-	case TPM_G0_WAN_G1_INT_SWITCH:
-		pon = TPM_GMAC_FUNC_NONE;
-		gmac0 = TPM_GMAC_FUNC_WAN;
-		gmac1 = TPM_GMAC_FUNC_LAN;
-		break;
-
-	case TPM_G1_WAN_G0_INT_SWITCH:
-		pon = TPM_GMAC_FUNC_NONE;
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		gmac1 = TPM_GMAC_FUNC_WAN;
-		break;
-
-	case TPM_PON_G1_WAN_G0_INT_SWITCH:
-		if (TPM_ENUM_GMAC_1 == tpm_db.init_misc.active_wan) {
-			pon = TPM_GMAC_FUNC_NONE;
-			gmac1 = TPM_GMAC_FUNC_WAN;
-		}else{
-			gmac1 = TPM_GMAC_FUNC_NONE;
-			pon = TPM_GMAC_FUNC_WAN;
-		}
-		gmac0 = TPM_GMAC_FUNC_LAN;
-		break;
-
-	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
-		if (TPM_ENUM_GMAC_1 == tpm_db.init_misc.active_wan) {
-			pon = TPM_GMAC_FUNC_NONE;
-			gmac1 = TPM_GMAC_FUNC_WAN;
-		}else{
-			gmac1 = TPM_GMAC_FUNC_NONE;
-			pon = TPM_GMAC_FUNC_WAN;
-	}
-		gmac0 = TPM_GMAC_FUNC_LAN_UNI;
-		break;
-
-	case TPM_PON_G0_WAN_G1_INT_SWITCH:
-		if (TPM_ENUM_GMAC_0 == tpm_db.init_misc.active_wan) {
-			pon = TPM_GMAC_FUNC_NONE;
-			gmac0 = TPM_GMAC_FUNC_WAN;
-		}else{
-			gmac0 = TPM_GMAC_FUNC_NONE;
-			pon = TPM_GMAC_FUNC_WAN;
-	}
-		gmac1 = TPM_GMAC_FUNC_LAN_UNI;
-		break;
-
-	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
-		if (TPM_ENUM_GMAC_0 == tpm_db.init_misc.active_wan) {
-			pon = TPM_GMAC_FUNC_NONE;
-			gmac0 = TPM_GMAC_FUNC_WAN;
-		}else{
-			gmac0 = TPM_GMAC_FUNC_NONE;
-			pon = TPM_GMAC_FUNC_WAN;
-	}
-		gmac1 = TPM_GMAC_FUNC_LAN;
-		break;
-
-	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
-	case TPM_PON_WAN_G1_SINGLE_PORT:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_NONE;
-		gmac1 = TPM_GMAC_FUNC_LAN_UNI;
-		break;
-
-	case TPM_PON_WAN_G0_G1_LPBK:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI;
-		gmac1 = TPM_GMAC_FUNC_LAN;
-		break;
-	case TPM_PON_WAN_G0_G1_DUAL_LAN:
-		pon = TPM_GMAC_FUNC_WAN;
-		gmac0 = TPM_GMAC_FUNC_LAN_UNI;
-		gmac1 = TPM_GMAC_FUNC_LAN_UNI;
-		break;
-	}
-
-	/* when ds load balance on G0 and G1 is enabled, G0/1 are both LAN */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	if (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable)
-		gmac1 = TPM_GMAC_FUNC_LAN;
-
-	ret_code = tpm_db_gmac_func_set(TPM_ENUM_PMAC, pon);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_func_set(TPM_ENUM_GMAC_0, gmac0);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_func_set(TPM_ENUM_GMAC_1, gmac1);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_db_eth_max_uni_port_set()
-*
-* DESCRIPTION:	Sets the max_uni_port_nr according to EthCmplx profile
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-* 	On success, returns TPM_OK
-* 	On error, returns tpm_db_gmac_func_set error
-*******************************************************************************/
-int32_t tpm_db_eth_max_uni_port_set(void)
-{
-	switch (tpm_db.eth_cmplx_profile) {
-	case TPM_PON_WAN_G0_SINGLE_PORT:
-	case TPM_PON_WAN_G1_SINGLE_PORT:
-	case TPM_PON_WAN_G0_G1_LPBK:
-		tpm_db.max_uni_port_nr = TPM_SRC_PORT_UNI_0;
-	break;
-
-	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
-	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
-	case TPM_PON_WAN_G0_G1_DUAL_LAN:
-		tpm_db.max_uni_port_nr = TPM_SRC_PORT_UNI_1;
-	break;
-
-	case TPM_PON_WAN_G0_INT_SWITCH:
-	case TPM_PON_WAN_G1_LAN_G0_INT_SWITCH:
-	case TPM_PON_WAN_DUAL_MAC_INT_SWITCH:
-       case TPM_G0_WAN_G1_INT_SWITCH:
-	case TPM_G1_WAN_G0_INT_SWITCH:
-	case TPM_PON_G1_WAN_G0_INT_SWITCH:
-	case TPM_PON_G0_WAN_G1_INT_SWITCH:
-		tpm_db.max_uni_port_nr = TPM_SRC_PORT_UNI_3;
-		break;
-
-	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
-		tpm_db.max_uni_port_nr = TPM_SRC_PORT_UNI_6;
-	break;
-
-	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
-		tpm_db.max_uni_port_nr = TPM_SRC_PORT_UNI_7;
-	break;
-
-	default:
-		return TPM_DB_ERR_REC_EXIST;
-	}
-
-	/* increment the counter since UNI enumeration starts @ zero */
-	tpm_db.max_uni_port_nr++;
-
-	return (TPM_DB_OK);
-}
-
-tpm_src_port_type_t tpm_db_trg_port_uni_any_bmp_get(bool inc_virt_uni)
-{
-	uint32_t dst_port, trg_port_uni_any_bmp = 0;
-	tpm_src_port_type_t src_port;
-
-	for (dst_port = TPM_TRG_UNI_0, src_port = TPM_SRC_PORT_UNI_0;
-	     dst_port <= TPM_TRG_UNI_7;
-	     dst_port = (dst_port << 1), src_port += 1) {
-
-		/* if port is valid */
-		if(tpm_db_eth_port_valid(src_port))
-			trg_port_uni_any_bmp |= dst_port;
-	}
-
-	if (tpm_db.func_profile.virt_uni_info.enabled != 0 && true == inc_virt_uni)
-		trg_port_uni_any_bmp |= TPM_TRG_UNI_VIRT;
-
-	return trg_port_uni_any_bmp;
-}
-
-bool tpm_db_gmac_valid(tpm_gmacs_enum_t gmac)
-{
-	if (((TPM_ENUM_PMAC == gmac) && (TPM_NONE != tpm_db.init_misc.pon_type)) ||
-	    ((1 == tpm_db.gmac_port_conf[gmac].valid) && (TPM_GMAC_CON_DISC != tpm_db.gmac_port_conf[gmac].conn)))
-	    return true;
-
-	return false;
-}
-
-int32_t tpm_db_target_to_gmac(tpm_pnc_trg_t pnc_target, tpm_gmacs_enum_t *gmac)
-{
-	if (TPM_PNC_TRG_GMAC0 == pnc_target)
-		*gmac = TPM_ENUM_GMAC_0;
-	else if (TPM_PNC_TRG_GMAC1 == pnc_target)
-		*gmac = TPM_ENUM_GMAC_1;
-	else if (TPM_PNC_TRG_CPU == pnc_target) {
-		TPM_OS_ERROR(TPM_DB_MOD, "target to CPU, no GMAC valid\n");
-		return TPM_DB_ERR_INV_INPUT;
-	} else
-		*gmac = TPM_ENUM_PMAC;
-
-	return TPM_DB_OK;
-}
-
-/*******************************************************************************
-* tpm_db_to_lan_gmac_get()
-*
-* DESCRIPTION: returns the GMAC target for traffic to LAN according to target
-*		port bitmap
-* INPUTS:
-* trg_port	target port bitmap
-*
-* OUTPUTS:
-* pnc_target	gmac target
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_to_lan_gmac_get(tpm_trg_port_type_t trg_port, tpm_pnc_trg_t *pnc_target)
-{
-	uint32_t i;
-	tpm_pnc_trg_t gmac_vec = 0;
-	bool trg_port_on_switch = false;
-
-
-	if (NULL == pnc_target)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	*pnc_target = TPM_INVALID_PNC_TRG;
-
-	/* for UNI_ANY we search the gmac_func for lan cababilities */
-	if (TPM_TRG_PORT_UNI_ANY == trg_port) {
-	       for (i = TPM_ENUM_GMAC_0; i < TPM_MAX_GMAC; i++) {
-			if (!tpm_db_gmac_valid(i))
-					continue;
-			if (!tpm_db_gmac1_lpbk_en_get()) {
-				if (TPM_GMAC_FUNC_LAN == tpm_db.gmac_func[i]      ||
-				    TPM_GMAC_FUNC_LAN_UNI == tpm_db.gmac_func[i]) {
-					gmac_vec |= (TPM_ENUM_GMAC_0 == i) ? TPM_PNC_TRG_GMAC0 : TPM_PNC_TRG_GMAC1;
-					break;/* target only one, no others */
-				}
-			} else {
-				gmac_vec |= TPM_PNC_TRG_GMAC0;
-				break;
-			}
-		}
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "trg_port(%x) gmac_vec(%x)\n", trg_port, gmac_vec);
-		*pnc_target = gmac_vec;
-		return TPM_DB_OK;
-	}
-
-	/* if target is virt uni, search for the gmac that acts as LAN */
-	if (TPM_TRG_UNI_VIRT & trg_port) {
-		for (i = TPM_ENUM_GMAC_0; i < TPM_MAX_GMAC; i++) {
-			if (!tpm_db_gmac_valid(i))
-				continue;
-
-			/* need only virt uni lan ports */
-			if (TPM_GMAC_FUNC_LAN == tpm_db.gmac_func[i]){
-				 gmac_vec |= (TPM_ENUM_GMAC_0 == i) ? TPM_PNC_TRG_GMAC0 : TPM_PNC_TRG_GMAC1;
-				 break;
-			}
-		}
-	}
-
-	/* search ethernet ports */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_DB_VALID != tpm_db.eth_ports[i].valid ||
-		    TPM_SRC_PORT_ILLEGAL == tpm_db.eth_ports[i].port_src ||
-		    TPM_SRC_PORT_WAN == tpm_db.eth_ports[i].port_src)
-		continue;
-
-		if ((1 << tpm_db.eth_ports[i].port_src) & (trg_port >> TPM_TRG_UNI_OFFSET)){
-			if (TPM_INTCON_SWITCH == tpm_db.eth_ports[i].int_connect) {
-				/* port on switch, set the flag */
-				trg_port_on_switch = true;
-			} else if (TPM_INTCON_GMAC0 == tpm_db.eth_ports[i].int_connect){
-				/* port on GMAC0 */
-				gmac_vec |= TPM_PNC_TRG_GMAC0;
-			} else if (TPM_INTCON_GMAC1 == tpm_db.eth_ports[i].int_connect){
-				/* port on GMAC1 */
-				gmac_vec |= TPM_PNC_TRG_GMAC1;
-			}
-		}
-       }
-
-	/* if port connected to switch, search gmac_func for the connected GMAC */
-	if (true == trg_port_on_switch) {
-		for (i = TPM_ENUM_GMAC_0; i < TPM_MAX_GMAC; i++) {
-			if (!tpm_db_gmac_valid(i))
-				continue;
-
-			/* need only LAN ports */
-			if (TPM_GMAC_FUNC_LAN == tpm_db.gmac_func[i] ||
-			    TPM_GMAC_FUNC_LAN_UNI == tpm_db.gmac_func[i]){
-				if (TPM_GMAC_CON_SWITCH_4 == tpm_db.gmac_port_conf[i].conn ||
-				    TPM_GMAC_CON_SWITCH_5 == tpm_db.gmac_port_conf[i].conn) {
-					gmac_vec |= (TPM_ENUM_GMAC_0 == i) ? TPM_PNC_TRG_GMAC0 : TPM_PNC_TRG_GMAC1;
-				}
-			}
-		}
-	}
-
-	if (TPM_INVALID_PNC_TRG == gmac_vec)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "trg_port(%x) gmac_vec(%x)\n", trg_port, gmac_vec);
-	*pnc_target = gmac_vec;
-	return TPM_DB_OK;
-}
-
-/*******************************************************************************
-* tpm_db_src_gmac_func_get()
-*
-* DESCRIPTION: returns the GMAC target for traffic to LAN according to target
-*		port bitmap
-* INPUTS:
-* trg_port	target port bitmap
-*
-* OUTPUTS:
-* pnc_target	gmac target
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_src_gmac_func_get(tpm_src_port_type_t src_port, tpm_db_gmac_func_t *gmac_func)
-{
-	uint32_t i;
-
-	if (NULL == gmac_func)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	*gmac_func = TPM_GMAC_FUNC_NONE;
-
-	if (TPM_SRC_PORT_WAN == src_port){
-		*gmac_func = TPM_GMAC_FUNC_WAN;
-		return TPM_DB_OK;
-	}
-
-	if (TPM_SRC_PORT_UNI_VIRT == src_port){
-		if (TPM_FALSE == tpm_db.func_profile.virt_uni_info.enabled)
-			return TPM_DB_ERR_REC_NOT_EXIST;
-
-		tpm_db_gmac_func_get(TPM_ENUM_GMAC_1, gmac_func);
-		return TPM_DB_OK;
-	}
-
-	/* start gmac ports */
-	for (i = 0; i < TPM_NUM_GMACS; i++) {
-		if (TPM_FALSE == tpm_db.gmac_port_conf[i].valid)
-		continue;
-
-		if (tpm_db.gmac_port_conf[i].port_src == src_port){
-			*gmac_func = tpm_db.gmac_func[i];
-		return TPM_DB_OK;
-		}
-	}
-
-	/* search switch ports */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_DB_VALID != tpm_db.eth_ports[i].valid)
-		continue;
-
-		/* port_src found on switch */
-		if (tpm_db.eth_ports[i].port_src == src_port){
-		uint32_t j;
-
-			/* now search gmac table to find connecting port */
-			for (j = 0; j < TPM_NUM_GMACS-1; j++) {
-				if (TPM_FALSE == tpm_db.gmac_port_conf[j].valid)
-				continue;
-
-				if ((TPM_SRC_PORT_ILLEGAL == tpm_db.gmac_port_conf[j].port_src) &&
-				    ((TPM_GMAC_CON_SWITCH_5 == tpm_db.gmac_port_conf[j].conn) ||
-				     (TPM_GMAC_CON_SWITCH_4 == tpm_db.gmac_port_conf[j].conn))){
-					*gmac_func = (TPM_ENUM_GMAC_0 == i) ? tpm_db.gmac_func[0] : tpm_db.gmac_func[1];
-					return TPM_DB_OK;
-				}
-		}
-
-	}
-       }
-
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-int32_t tpm_db_src_port_on_switch(tpm_src_port_type_t src_port)
-{
-	uint32_t i;
-
-	/* switch ports can not act as WAN source port */
-	if (TPM_SRC_PORT_WAN == src_port)
-		return TPM_FALSE;
-
-	/* start gmac ports */
-	for (i = 0; i < TPM_NUM_GMACS; i++) {
-		if (TPM_FALSE == tpm_db.gmac_port_conf[i].valid)
-		continue;
-
-		if (tpm_db.gmac_port_conf[i].port_src == src_port)
-			return TPM_FALSE;
-	}
-
-	/* search switch ports */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_DB_VALID != tpm_db.eth_ports[i].valid)
-		continue;
-
-		if (tpm_db.eth_ports[i].port_src == src_port)
-			return TPM_TRUE;
-	}
-	return TPM_FALSE;
-}
-
-/*******************************************************************************
-* tpm_db_trg_port_switch_port_get()
-*
-* DESCRIPTION:      Function to get the target port bitmap
-*
-* INPUTS:
-* ext_port         - External Port Identifier, can be any positive number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* The function returns the target ports bitmap for an external port.
-* In case of no matching - it returns empty bitmap 0x0.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_trg_port_switch_port_get(tpm_trg_port_type_t ext_port)
-{
-	uint32_t portVec = 0;
-
-	if (ext_port & TPM_TRG_PORT_UNI_ANY) {
-		ext_port |= (TPM_TRG_UNI_0 | TPM_TRG_UNI_1 | TPM_TRG_UNI_2 | TPM_TRG_UNI_3 |
-			    TPM_TRG_UNI_4 | TPM_TRG_UNI_5 | TPM_TRG_UNI_6 | TPM_TRG_UNI_7);
-
-		if (tpm_db.func_profile.virt_uni_info.enabled != 0)
-			ext_port |= TPM_TRG_UNI_VIRT;
-	}
-	if (ext_port & TPM_TRG_UNI_0)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_0);
-
-	if (ext_port & TPM_TRG_UNI_1)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_1);
-
-	if (ext_port & TPM_TRG_UNI_2)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_2);
-
-	if (ext_port & TPM_TRG_UNI_3)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_3);
-
-	if (ext_port & TPM_TRG_UNI_4)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_4);
-
-	if (ext_port & TPM_TRG_UNI_5)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_5);
-
-	if (ext_port & TPM_TRG_UNI_6)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_6);
-
-	if (ext_port & TPM_TRG_UNI_7)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_7);
-
-	if (ext_port & TPM_TRG_UNI_VIRT)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_UNI_VIRT);
-
-	if (ext_port & TPM_TRG_PORT_CPU)
-		portVec |= 1 << tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_WAN);
-
-	return (portVec);
-}
-
-/*******************************************************************************
-* tpm_db_eth_port_conf_set()
-*
-* DESCRIPTION:      Function to set an ethernet physical and internal configuration in the DB
-*
-* INPUTS:
-* ext_port         - External Port Identifier, can be any positive number
-* other inputs     - See explanation in tpm_db_eth_port_conf_t structure
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_eth_port_conf_set(tpm_init_eth_port_conf_t *eth_port_conf)
-{
-	uint32_t i;
-	int32_t free_entry = -1;
-
-	if (NULL == eth_port_conf)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "src_port (%d)\n", eth_port_conf->port_src);
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		/* Check entry does not exist */
-	if ((tpm_db.eth_ports[i].port_src == eth_port_conf->port_src)
-		    && (tpm_db.eth_ports[i].valid == TPM_DB_VALID))
-			return (TPM_DB_ERR_REC_EXIST);
-
-		/* Find first invalid entry */
-		if ((free_entry == -1) && (tpm_db.eth_ports[i].valid == TPM_DB_INVALID))
-			free_entry = i;
-	}
-	/* No free Entry */
-	if (free_entry == -1)
-		return (TPM_DB_ERR_DB_TBL_FULL);
-
-	/* Set entry */
-	tpm_db.eth_ports[free_entry].port_src = eth_port_conf->port_src;
-	tpm_db.eth_ports[free_entry].int_connect = eth_port_conf->int_connect;
-	tpm_db.eth_ports[free_entry].chip_connect = eth_port_conf->chip_connect;
-	tpm_db.eth_ports[free_entry].switch_port = eth_port_conf->switch_port;
-	tpm_db.eth_ports[free_entry].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-
-}
-
-int32_t tpm_db_gmac_conn_conf_set(tpm_init_gmac_conn_conf_t *gmac_port_conf, uint32_t arr_size)
-{
-	uint32_t i;
-
-	if (NULL == gmac_port_conf)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	for (i = 0; i < arr_size; i++) {
-		TPM_OS_DEBUG(TPM_DB_MOD, "gmac src_port (%d)\n", gmac_port_conf[i].port_src);
-
-		/* Set entry */
-		tpm_db.gmac_port_conf[i].port_src = gmac_port_conf[i].port_src;
-		tpm_db.gmac_port_conf[i].conn = gmac_port_conf[i].conn;
-		tpm_db.gmac_port_conf[i].valid = gmac_port_conf[i].valid;
-	}
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_conn_conf_get()
-*
-* DESCRIPTION:      Function to get GMAC connection information from DB
-*
-* INPUTS:
-* gmac                   - GMAC port
-*
-* OUTPUTS:
-* gmac_port_conf         - connection info
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK.
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_conn_conf_get(tpm_gmacs_enum_t gmac, tpm_init_gmac_conn_conf_t *gmac_port_conf)
-{
-	if (NULL == gmac_port_conf)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memcpy(gmac_port_conf, &tpm_db.gmac_port_conf[gmac], sizeof(tpm_init_gmac_conn_conf_t));
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_tcont_llid_set()
-*
-* DESCRIPTION:      Function to set the GMAC connection and T-CONTs  in the DB
-*
-* INPUTS:
-* num_tcont_llid   - Number of T-CONTs/LLIDs
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_tcont_llid_set(uint32_t num_tcont_llid)
-{
-	tpm_db.num_valid_tcont_llid = num_tcont_llid;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_conn_get()
-*
-* DESCRIPTION:      Function to get the Connection of an Ethernet GMAC
-*
-* INPUTS:
-* gmac             - GMAC number
-* OUTPUTS:
-* gmac_con         - GMAC internal Physical connection (see tpm_db_gmac_conn_t)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_conn_get(tpm_gmacs_enum_t gmac, tpm_db_gmac_conn_t *gmac_con)
-{
-	if (gmac == TPM_ENUM_GMAC_0)
-		*gmac_con = tpm_db.gmac_port_conf[0].conn;
-	else if (gmac == TPM_ENUM_GMAC_1)
-		*gmac_con = tpm_db.gmac_port_conf[1].conn;
-	else
-		return (TPM_DB_ERR_INV_INPUT);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_mh_en_conf_set()
-*
-* DESCRIPTION:      Function to set the GMAC connection and T-CONTs  in the DB
-*
-* INPUTS:
-* gmac             - GMAC
-* mh_en            - MH enable TRUE/FALSE
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_mh_en_conf_set(tpm_gmacs_enum_t gmac, uint32_t mh_en)
-{
-
-	tpm_db.gmac_mh_en[gmac] = mh_en;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_mh_en_conf_get()
-*
-* DESCRIPTION:      Function to set the GMAC connection and T-CONTs  in the DB
-*
-* INPUTS:
-* gmac             - GMAC
-*
-* OUTPUTS:
-* mh_en            - MH enable TRUE/FALSE
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_mh_en_conf_get(tpm_gmacs_enum_t gmac, uint32_t *mh_en)
-{
-
-	*mh_en = tpm_db.gmac_mh_en[gmac];
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_bm_bufs_conf_set()
-*
-* DESCRIPTION:      Function to set the GMAC number of Buffer Mngmt large_bufers, short_buffers
-*
-* INPUTS:
-* gmac              - GMAC
-* large_pkt_buffers - number of buffers in the GMAC long packets pool
-* small_pkt_buffers - number of buffers in the GMAC short packets pool
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_bm_bufs_conf_set(tpm_gmacs_enum_t gmac, uint32_t large_pkt_buffers, uint32_t small_pkt_buffers)
-{
-	tpm_db.gmac_bp_bufs[gmac].valid = TPM_DB_VALID;
-	tpm_db.gmac_bp_bufs[gmac].large_pkt_buffers = large_pkt_buffers;
-	tpm_db.gmac_bp_bufs[gmac].small_pkt_buffers = small_pkt_buffers;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_bm_bufs_conf_get()
-*
-* DESCRIPTION:      Function to set the GMAC number of Buffer Mngmt large_bufers, short_buffers
-*
-* INPUTS:
-* gmac              - GMAC
-* valid             - Is the entry valid in the db
-* large_pkt_buffers - number of buffers in the GMAC long packets pool
-* small_pkt_buffers - number of buffers in the GMAC short packets pool
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_bm_bufs_conf_get(tpm_gmacs_enum_t gmac,
-				     uint32_t *valid, uint32_t *large_pkt_buffers, uint32_t *small_pkt_buffers)
-{
-	if ((valid == NULL) || (gmac >= TPM_MAX_NUM_GMACS))
-		return (TPM_DB_ERR_INV_INPUT);
-	*valid = (tpm_db.gmac_bp_bufs[gmac].valid == TPM_DB_VALID ? 1 : 0);
-
-	if (large_pkt_buffers != NULL)
-		*large_pkt_buffers = tpm_db.gmac_bp_bufs[gmac].large_pkt_buffers;
-
-	if (small_pkt_buffers != NULL)
-		*small_pkt_buffers = tpm_db.gmac_bp_bufs[gmac].small_pkt_buffers;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_intport_int_con_get()
-*
-* DESCRIPTION:      Function returns internal connectivity of an internal port num
-*
-* INPUTS:
-* int_port_num     - Internal Port Identifier, UNI#0..UNI#4 or WAN Port
-*
-* OUTPUTS:
-* int_con          - Port internal L2 Connection (G0, G1, Amber switch)
-* switch_port      - Amber Switch Port number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_intport_int_con_get(tpm_src_port_type_t int_port_num,
-				   tpm_db_int_conn_t	*int_con,
-				   uint32_t		*switch_port)
-{
-	int32_t ret_code;
-	tpm_db_chip_conn_t dummy_chip_con;
-	tpm_db_int_conn_t l_int_conn;
-	uint32_t l_switch_port;
-
-	if (int_port_num == TPM_SRC_PORT_UNI_VIRT) {
-		*int_con = TPM_INTCON_SWITCH;
-		*switch_port = tpm_db.func_profile.virt_uni_info.switch_port;
-		return (TPM_DB_OK);
-	}
-
-	/* Get External Port Config */
-	ret_code = tpm_db_eth_port_conf_get(int_port_num,
-					    &dummy_chip_con,
-					    &l_int_conn,
-					    &l_switch_port);
-	IF_ERROR(ret_code);
-
-	/* Return data */
-	*int_con = l_int_conn;
-	*switch_port = l_switch_port;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_num_tcont_llid_get()
-*
-* DESCRIPTION:      Function to get the number of T-CONTs/LLIDs
-*
-* INPUTS:
-* OUTPUTS:
-* num_tcont_llid   - Number of GPON TCONTs or EPON LLIDs
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-*
-*******************************************************************************/
-int32_t tpm_db_num_tcont_llid_get(uint32_t *num_tcont_llid)
-{
-	*num_tcont_llid = tpm_db.num_valid_tcont_llid;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_tx_q_conf_set()
-*
-* DESCRIPTION:      Function to set the parameters of a Packet Processor Component Tx queue
-*
-* INPUTS:
-* tx_mod           - Tx module (G0, G1, or TCONT/LLID0-7)
-* OUTPUTS:
-* gmac_con         - GMAC0 connection
-* queue_num        - Queue number in this Tx
-* sched_method     - The Tx Scheduler this queue is added to (the WRR or the Strict scheduler)
-* queue_owner      - The single hardware owner, that is feeding this queue.
-*                    Can be the CPU, or one of the PAcket Processor Rx components.
-* owner_queue_num  - The relative queue number of the owner of this queue.
-* queue_weight     - Weight, if the queue is added to the WRR Scheduler.
-* queue_size       -
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_tx_q_conf_set(tpm_db_tx_mod_t tx_mod,
-				  uint32_t queue_num,
-				  tpm_db_sched_t sched_method,
-				  tpm_db_txq_owner_t queue_owner,
-				  uint32_t owner_queue_num, uint32_t queue_size, uint32_t queue_weight)
-{
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_owner = queue_owner;
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].owner_queue_num = owner_queue_num;
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].sched_method = sched_method;
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_size = queue_size;
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_weight = queue_weight;
-	tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_tx_q_conf_get()
-*
-* DESCRIPTION:      Function to set the parameters of a Packet Processor Tx Component
-*
-* INPUTS:
-* tx_mod           - Tx module (G0, G1, or TCONT/LLID0-7)
-* queue_num        - Queue number in this Tx
-*
-* OUTPUTS:
-* valid             - Queue exists
-* sched_method     - The Tx Scheduler this queue is added to (the WRR or the Strict scheduler)
-* queue_owner      - The single hardware owner, that is feeding this queue.
-*                    Can be the CPU, or one of the PAcket Processor Rx components.
-* owner_queue_num  - The relative queue number of the owner of this queue.
-* queue_weight     - Weight, if the queue is added to the WRR Scheduler.
-* queue_size       -
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_tx_q_conf_get(tpm_db_tx_mod_t tx_mod,
-				  uint32_t queue_num,
-				  uint32_t *valid,
-				  tpm_db_sched_t *sched_method,
-				  tpm_db_txq_owner_t *queue_owner,
-				  uint32_t *owner_queue_num, uint32_t *queue_size, uint32_t *queue_weight)
-{
-	if (valid == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].valid == TPM_DB_VALID) {
-		*valid = TPM_TRUE;
-		if (sched_method != NULL)
-			*sched_method = tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].sched_method;
-		if (queue_owner != NULL)
-			*queue_owner = tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_owner;
-		if (owner_queue_num != NULL)
-			*owner_queue_num = tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].owner_queue_num;
-		if (queue_size != NULL)
-			*queue_size = tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_size;
-		if (queue_weight != NULL)
-			*queue_weight = tpm_db.gmac_tx[tx_mod].tx_queue[queue_num].queue_weight;
-	} else {
-		*valid = TPM_FALSE;
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_rx_q_conf_set()
-*
-* DESCRIPTION:      Function to set the parameters of a Packet Processor Tx Component
-*
-* INPUTS:
-* gmac             - GMAC
-* OUTPUTS:
-* queue_num        - Queue number in this Tx
-* queue_size       -
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_rx_q_conf_set(tpm_gmacs_enum_t gmac, uint32_t queue_num, uint32_t queue_size)
-{
-	if ((gmac >= TPM_MAX_NUM_GMACS) || (queue_num >= TPM_MAX_NUM_RX_QUEUE))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.gmac_rx[gmac].rx_queue[queue_num].queue_size = queue_size;
-	tpm_db.gmac_rx[gmac].rx_queue[queue_num].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_gmac_rx_q_conf_get(tpm_gmacs_enum_t gmac, uint32_t queue_num, uint32_t *valid, uint32_t *queue_size)
-{
-
-	if ((valid == NULL) || (gmac >= TPM_MAX_NUM_GMACS) || (queue_num >= TPM_MAX_NUM_RX_QUEUE))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (tpm_db.gmac_rx[gmac].rx_queue[queue_num].valid == TPM_DB_VALID) {
-		*valid = TPM_TRUE;
-		if (queue_size != NULL)
-			*queue_size = tpm_db.gmac_rx[gmac].rx_queue[queue_num].queue_size;
-	} else
-		*valid = TPM_FALSE;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_tx_val_set()
-*
-* DESCRIPTION:      Function to set the parameters of a Tx module
-*
-* INPUTS:
-* tx_mod           - Tx Module to validate
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_tx_val_set(tpm_db_tx_mod_t tx_mod)
-{
-	tpm_db.gmac_tx[tx_mod].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_rx_val_set()
-*
-* DESCRIPTION:      Function to set the parameters of a Tx module
-*
-* INPUTS:
-* gmac           - GMAC to set active
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_rx_val_set(tpm_gmacs_enum_t gmac)
-{
-	tpm_db.gmac_rx[gmac].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-uint32_t tpm_db_gmac_rx_val_get(tpm_gmacs_enum_t gmac)
-{
-	if (tpm_db.gmac_rx[gmac].valid == TPM_DB_VALID)
-		return (TPM_TRUE);
-	else
-		return (TPM_FALSE);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_func_get()
-*
-* DESCRIPTION:      Check the Function of a GMAC (LAN, WAN or no function)
-*
-* INPUTS:
-* gmac              - GMAC to check
-* OUTPUTS:
-* gfunc             - Functionality the GMAC is performing (None, LAN or WAN)
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_func_get(tpm_gmacs_enum_t gmac, tpm_db_gmac_func_t *gfunc)
-{
-	if (gmac > TPM_MAX_GMAC)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	*gfunc = tpm_db.gmac_func[gmac];
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_func_set()
-*
-* DESCRIPTION:      Sets the Function of a GMAC (LAN, WAN or no function)
-*
-* INPUTS:
-* gmac              - GMAC to set
-* gfunc             - Functionality the GMAC is performing (None, LAN or WAN)
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_func_set(tpm_gmacs_enum_t gmac, tpm_db_gmac_func_t gfunc)
-{
-	if (gmac > TPM_MAX_GMAC)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.gmac_func[gmac] = gfunc;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_tx_val_get()
-*
-* DESCRIPTION:      Function check the validity of a Tx module
-*
-* INPUTS:
-* tx_mod           - Tx module to check
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-uint32_t tpm_db_gmac_tx_val_get(tpm_db_tx_mod_t tx_mod)
-{
-	if (tpm_db.gmac_tx[tx_mod].valid == TPM_DB_VALID)
-		return (TPM_TRUE);
-	else
-		return (TPM_FALSE);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_lpk_queue_get()
-*
-* DESCRIPTION:      Function to get the queue id used to do gmac loopback on MC, min queue id for data traffic,
-*                   max queue id for MAC learning
-* INPUTS:
-* queue_type     - queue type for GMAC1 loopback, for data traffic or for MAC learning
-* OUTPUTS:
-* gmac           - gmac on which loopback is done
-* queue_idx      - queue index which do loopback
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*******************************************************************************/
-uint32_t tpm_db_gmac_lpk_queue_get(tpm_gmacs_enum_t *gmac,
-				   uint32_t *queue_idx,
-				   tpm_db_gmac1_lpk_queue_type_t queue_type)
-{
-	uint32_t queue_id, q_valid, gmac_id;
-	tpm_db_txq_owner_t queue_owner, lpk_queue_owner = TPM_Q_OWNER_GMAC0;
-	tpm_db_gmac_func_t lpk_gmac_func;
-	tpm_db_tx_mod_t tx_mod;
-	uint32_t q_expected = TPM_MAX_NUM_TX_QUEUE;
-
-	/*check input parameters*/
-	if (NULL == gmac || NULL == queue_idx) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input \n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	/*check func profile*/
-	if (!tpm_db_gmac1_lpbk_en_get()) {
-		TPM_OS_ERROR(TPM_DB_MOD, "GMAC1 loopback has not been enabled!\n");
-		return TPM_FALSE;
-	}
-
-	/*Find the GMAC used to do loopback*/
-	for (gmac_id = TPM_ENUM_GMAC_0; gmac_id < TPM_MAX_NUM_GMACS; gmac_id ++) {
-		if (TPM_DB_OK == tpm_db_gmac_func_get(gmac_id, &lpk_gmac_func)) {
-			if (TPM_GMAC_FUNC_LAN == lpk_gmac_func)
-				break;
-		} else {
-			continue;
-		}
-	}
-
-	if (gmac_id == TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Loopback GMAC get failed \n");
-		return TPM_FALSE;
-	} else {
-		tx_mod = (tpm_db_tx_mod_t)gmac_id;
-		lpk_queue_owner = TPM_Q_OWNER_GMAC0;
-	}
-
-	/* get the Tx queue of GMAC1, if more than 1 queue belong to gmac0, lowest index is selected */
-	for (queue_id = 0; queue_id < TPM_MAX_NUM_TX_QUEUE; queue_id++) {
-		if (TPM_DB_OK != tpm_db_gmac_tx_q_conf_get(tx_mod, queue_id, &q_valid, NULL,
-							   &queue_owner, NULL, NULL, NULL))
-			continue;
-		if (q_valid == TPM_TRUE && queue_owner == lpk_queue_owner) {
-			q_expected = queue_id;
-			if (TPM_GMAC1_QUEUE_DATA_TRAFFIC == queue_type)
-				break;
-			else if (TPM_GMAC1_QUEUE_MAC_LEARN_TRAFFIC == queue_type)
-				continue;
-		}
-	}
-	if (q_expected >= TPM_MAX_NUM_TX_QUEUE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid Tx queue %d of GMAC1 assigned to GMAC0 \n", q_expected);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	*gmac = gmac_id;
-	*queue_idx = q_expected;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_create()
-*
-* DESCRIPTION:      Function to create a range in the DB
-*
-* INPUTS:
-* pnc_range_conf      - Pointer to all config information needed for an entry
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_create(tpm_db_pnc_range_conf_t *pnc_range_conf)
-{
-	uint32_t i;
-	int32_t free_entry = -1;
-
-	/* Check NULL Pointer */
-	if (pnc_range_conf == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	/* Check range_id is not already in DB, and that DB is not full */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID && PNC_RANGE_CONF(i).range_id == pnc_range_conf->range_id)
-			return (TPM_DB_ERR_RANGE_EXIST);
-
-		if ((tpm_db.pnc_range[i].valid == TPM_DB_INVALID) && (free_entry == -1))
-			free_entry = i;
-	}
-	if (free_entry == -1)
-		return (TPM_DB_ERR_DB_TBL_FULL);
-
-	/* Copy Config Structure into DB */
-	memcpy(&(tpm_db.pnc_range[free_entry].pnc_range_conf), pnc_range_conf, sizeof(tpm_db_pnc_range_conf_t));
-
-	/* Init Operational Data */
-	PNC_RANGE_OPER(free_entry).free_entries = (pnc_range_conf->api_end - pnc_range_conf->api_start + 1);
-	PNC_RANGE_OPER(free_entry).num_resets = 0;
-
-	tpm_db.pnc_range[free_entry].valid = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_delete()
-*
-* DESCRIPTION:      Initializes and invalidates PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that is deleted
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_delete(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		/* Reset Operational values */
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID &&
-		    tpm_db.pnc_range[i].pnc_range_conf.range_id == pnc_range) {
-			memset(&(tpm_db.pnc_range[i]), 0, sizeof(tpm_pnc_ranges_t));
-			tpm_db.pnc_range[i].valid = TPM_DB_INVALID;
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_reset()
-*
-* DESCRIPTION:      Resets PnC range, all entries are returned to free
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that is reset
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_reset(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		/* reach the range to be reset */
-		if (tpm_db.pnc_range[i].pnc_range_conf.range_id == pnc_range) {
-			/* Reset Operational values */
-			if (tpm_db.pnc_range[i].valid == TPM_DB_VALID) {
-				/* both hardcoded and non-hardcoded entries will behave the same from free_entries point of view */
-				PNC_RANGE_OPER(i).free_entries =
-					PNC_RANGE_CONF(i).api_end - PNC_RANGE_CONF(i).api_start + 1;
-				(PNC_RANGE_OPER(i).num_resets)++;
-				return (TPM_DB_OK);
-			}
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_free_ent_inc()
-*
-* DESCRIPTION:      Increases number of free entries for a PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that it's free entries is increased
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_free_ent_inc(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == pnc_range) {
-			/* Check number of free entries is not too big */
-			if (PNC_RANGE_OPER(i).free_entries
-			    < (PNC_RANGE_CONF(i).api_end - PNC_RANGE_CONF(i).api_start + 1)) {
-				(PNC_RANGE_OPER(i).free_entries)++;
-				return (TPM_DB_OK);
-			} else
-				return (TPM_DB_ERR_DB_INCONSISTENCY);
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_free_ent_dec()
-*
-* DESCRIPTION:      Decreases number of free entries for a PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that it's free entries is decreased
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_free_ent_dec(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID && PNC_RANGE_CONF(i).range_id == pnc_range) {
-			TPM_OS_DEBUG(TPM_DB_MOD, "range_id(%d), free_ent(%d)\n", pnc_range,
-				     PNC_RANGE_OPER(i).free_entries);
-			/* Check number of free entries is not zero */
-			if (PNC_RANGE_OPER(i).free_entries > 0) {
-				(PNC_RANGE_OPER(i).free_entries)--;
-				return (TPM_DB_OK);
-			} else {
-				TPM_OS_ERROR(TPM_DB_MOD, "no free entries \n");
-				return (TPM_DB_ERR_DB_INCONSISTENCY);
-			}
-		}
-	}
-	/* pnc_range not found */
-	TPM_OS_ERROR(TPM_DB_MOD, "range_id(%d) not found\n", pnc_range);
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_get_lu_conf()
-*
-* DESCRIPTION:      Get PnC least used config for specific PnC range
-*
-* INPUTS:
-* range_id         - The PnC range id
-*
-* OUTPUTS:
-* lu_conf          - Least used configuration for PnC range
-
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_get_lu_conf(tpm_pnc_ranges_t range_id, tpm_api_lu_conf_t *lu_conf)
-{
-	tpm_pnc_ranges_t l_range_idx;
-
-	/* Check PnC range */
-	if ((range_id < 0) || (range_id > (TPM_MAX_NUM_RANGES - 1))) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Error, range_id(%d) is illegal \n", range_id);
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Check input param */
-	if (lu_conf == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Error, lu_conf is NULL \n");
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Get the config from TPM db */
-	for (l_range_idx = 0; l_range_idx < TPM_MAX_RANGE; l_range_idx++) {
-		if (tpm_db.pnc_range[l_range_idx].valid == TPM_DB_VALID
-				&& (PNC_RANGE_CONF(l_range_idx).range_id == range_id)) {
-			lu_conf->cntr_grp    = tpm_db.pnc_range[l_range_idx].pnc_range_conf.cntr_grp;
-			lu_conf->lu_mask     = tpm_db.pnc_range[l_range_idx].pnc_range_conf.lu_mask;
-			break;
-		}
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_api_start_inc()
-*
-* DESCRIPTION:      Increases number of free entries for a PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that it's free entries is increased
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_api_start_inc(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == pnc_range) {
-			/* Check number of free entries is not too big */
-			if (PNC_RANGE_OPER(i).free_entries >= 1) {
-				(PNC_RANGE_CONF(i).api_start)++;
-				(PNC_RANGE_OPER(i).free_entries)--;
-				return (TPM_DB_OK);
-			} else
-				return (TPM_DB_ERR_DB_INCONSISTENCY);
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_api_end_dec()
-*
-* DESCRIPTION:      Decrease number of api_end for a PnC range
-*                   The reason might be addition of an entry at the end of the range.
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range that it's free entries is increased
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_api_end_dec(tpm_pnc_ranges_t pnc_range)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == pnc_range) {
-			/* Check number of free entries is not too big */
-			if (PNC_RANGE_OPER(i).free_entries >= 1) {
-				(PNC_RANGE_CONF(i).api_end)--;
-				(PNC_RANGE_OPER(i).free_entries)--;
-				return (TPM_DB_OK);
-			} else
-				return (TPM_DB_ERR_DB_INCONSISTENCY);
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-int32_t tpm_db_api_section_get_from_api_type(tpm_api_type_t api_type, tpm_api_sections_t *api_section)
-{
-	int32_t error_code = TPM_DB_OK;
-
-	/*TODO - replace this w/ conf structure */
-
-	switch (api_type) {
-	case TPM_API_MAC_LEARN:
-		*api_section = TPM_PNC_MAC_LEARN_ACL;
-		break;
-	case TPM_API_CPU_LOOPBACK:
-		*api_section = TPM_CPU_LOOPBACK_ACL;
-		break;
-	case TPM_API_DS_LOAD_BALANCE:
-		*api_section = TPM_DS_LOAD_BALANCE_ACL;
-		break;
-	case TPM_API_L2_PRIM:
-		*api_section = TPM_L2_PRIM_ACL;
-		break;
-	case TPM_API_L3_TYPE:
-		*api_section = TPM_L3_TYPE_ACL;
-		break;
-	case TPM_API_IPV4:
-		*api_section = TPM_IPV4_ACL;
-		break;
-	case TPM_API_IPV4_MC:
-		*api_section = TPM_IPV4_MC;
-		break;
-	case TPM_API_IPV6_GEN:
-		*api_section = TPM_IPV6_GEN_ACL;
-		break;
-	case TPM_API_IPV6_MC:
-		*api_section = TPM_IPV6_MC_ACL;
-		break;
-	case TPM_API_IPV6_DIP:
-		*api_section = TPM_IPV6_DIP_ACL;
-		break;
-	case TPM_API_IPV6_NH:
-		*api_section = TPM_IPV6_NH_ACL;
-		break;
-	case TPM_API_IPV6_L4:
-		*api_section = TPM_L4_ACL;
-		break;
-	case TPM_API_CNM:
-		*api_section = TPM_CNM_MAIN_ACL;
-		break;
-	default:
-		error_code = TPM_DB_ERR_REC_NOT_EXIST;
-	}
-
-	return (error_code);
-}
-
-
-int32_t tpm_db_api_type_get_from_api_section(tpm_api_sections_t api_section, tpm_api_type_t *api_type)
-{
-	int32_t error_code = TPM_DB_OK;
-
-	/*TODO - replace this w/ conf structure */
-
-	switch (api_section) {
-	case TPM_PNC_MAC_LEARN_ACL:
-		*api_type = TPM_API_MAC_LEARN;
-		break;
-	case TPM_CPU_LOOPBACK_ACL:
-		*api_type = TPM_API_CPU_LOOPBACK;
-		break;
-	case TPM_DS_LOAD_BALANCE_ACL:
-		*api_type = TPM_API_DS_LOAD_BALANCE;
-		break;
-	case TPM_L2_PRIM_ACL:
-		*api_type = TPM_API_L2_PRIM;
-		break;
-	case TPM_L3_TYPE_ACL:
-		*api_type = TPM_API_L3_TYPE;
-		break;
-	case TPM_IPV4_ACL:
-		*api_type = TPM_API_IPV4;
-		break;
-	case TPM_IPV4_MC:
-		*api_type = TPM_API_IPV4_MC;
-		break;
-	case TPM_IPV6_GEN_ACL:
-		*api_type = TPM_API_IPV6_GEN;
-		break;
-	case TPM_IPV6_DIP_ACL:
-		*api_type = TPM_API_IPV6_DIP;
-		break;
-	case TPM_IPV6_NH_ACL:
-		*api_type = TPM_API_IPV6_NH;
-		break;
-	case TPM_L4_ACL:
-		*api_type = TPM_API_IPV6_L4;
-		break;
-	default:
-		error_code = TPM_DB_ERR_REC_NOT_EXIST;
-	}
-
-	return (error_code);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_get()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range to get data for
-
-* OUTPUTS:
-* range_data       - Returned DB structure of returned entry.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_get(tpm_pnc_ranges_t pnc_range, tpm_db_pnc_range_t *range_data)
-{
-	uint32_t i;
-
-	if ((pnc_range < 0) || (pnc_range > (TPM_MAX_NUM_RANGES - 1)))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID && PNC_RANGE_CONF(i).range_id == pnc_range) {
-			memcpy(range_data, &(tpm_db.pnc_range[i]), sizeof(tpm_db_pnc_range_t));
-			return (TPM_DB_OK);
-		}
-	}
-
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_get_range_start_end()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* pnc_range         - The id of the pnc range to get data for
-
-* OUTPUTS:
-* range_start      - Returned the start of specific PnC range.
-* range_end        - Returned the end of specific PnC range.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_get_range_start_end(tpm_pnc_ranges_t pnc_range, uint32_t *range_start, uint32_t *range_end)
-{
-	uint32_t i;
-
-	if ((pnc_range < 0) || (pnc_range > (TPM_MAX_NUM_RANGES - 1)))
-		return(TPM_DB_ERR_INV_INPUT);
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if ((tpm_db.pnc_range[i].valid == TPM_DB_VALID)
-				&& (PNC_RANGE_CONF(i).range_id == pnc_range)) {
-			*range_start = PNC_RANGE_CONF(i).range_start + PNC_RANGE_CONF(i).api_start;
-			*range_end   = PNC_RANGE_CONF(i).range_end;
-			return(TPM_DB_OK);
-		}
-	}
-
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_tbl_val_get_next()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* cur_ind          - The current index (handle) to the pnc_range table. Function returns the next valid
-*                    pnc range  entry > cur_index. cur_index < 0 indicates to return first valid entry in table,
-*                    valid next_ind values are 0 or higher
-* OUTPUTS:
-* next_ind         - See cur_ind. If end of table was reached before valid entry, (-1) is returned in next_ind
-* range_data       - Returned DB structure of returned entry. When entry is invalid, range_data filled with zero.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_tbl_val_get_next(int32_t cur_ind, int32_t *next_ind, tpm_db_pnc_range_t *range_data)
-{
-	int32_t i;
-
-	/* Initialize first next_ind */
-	if (cur_ind < 0)
-		i = 0;
-	else
-		i = cur_ind + 1;
-
-	/* Check PnC range exists in DB */
-	for (; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID) {
-			/* Return Data Structure */
-			memcpy(range_data, &(tpm_db.pnc_range[i]), sizeof(tpm_db_pnc_range_t));
-			*next_ind = i;
-			return (TPM_DB_OK);
-		}
-	}
-	*next_ind = -1;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_val_get_next()
-*
-* DESCRIPTION:      Returns DB info of the next valid PnC range.
-*                   Similar to "tpm_db_pnc_rng_tbl_val_get_next", but the handle is the range_id, not the table_index.
-*
-* INPUTS:
-* cur_range        - The current pnc_range  in  the pnc_range table. Function returns the next valid
-*                    pnc_range  > cur_range. cur_range < 0 indicates to return first valid entry in table,
-*                    valid next_ind values are 0 or higher
-* OUTPUTS:
-* next_range       - See cur_range. If end of table was reached before valid entry, (-1) is returned in next_range
-* range_data       - Returned DB structure of returned entry. When entry is invalid, range_data filled with zero.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_val_get_next(tpm_pnc_ranges_t cur_range,
-				    tpm_pnc_ranges_t *next_range, tpm_db_pnc_range_t *range_data)
-{
-	uint32_t i;
-	uint32_t l_min_index = 0;	/* oren - add init value, need to check */
-	tpm_pnc_ranges_t l_min_range = TPM_MAX_RANGE + 1;
-
-	/* Check  smallest valid next_PnC range in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		/*printf("i(%d) valid(%x) range_id(%d), cur_range(%d) l_min_range(%d)\n",
-		   i,tpm_db.pnc_range[i].valid, PNC_RANGE_CONF(i).range_id, cur_range,l_min_range); */
-		if ((tpm_db.pnc_range[i].valid == TPM_DB_VALID) && (PNC_RANGE_CONF(i).range_id > cur_range)
-		    && (PNC_RANGE_CONF(i).range_id < l_min_range)) {
-			l_min_range = PNC_RANGE_CONF(i).range_id;
-			l_min_index = i;
-		}
-	}
-	if (l_min_range <= TPM_MAX_RANGE) {
-		/* Return Data Structure */
-		memcpy(range_data, &(tpm_db.pnc_range[l_min_index]), sizeof(tpm_db_pnc_range_t));
-		*next_range = l_min_range;
-		return (TPM_DB_OK);
-	}
-
-	/* No valid next range found */
-	*next_range = -1;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_conf_get()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* range_id         - Range number to retrieve configuration for
-
-* OUTPUTS:
-* range_conf       - Structure for pnc_range Configuration Info
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_conf_get(tpm_pnc_ranges_t range_id, tpm_db_pnc_range_conf_t *range_conf)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == range_id) {
-			/* Return Data Structure */
-			memcpy(range_conf, &(tpm_db.pnc_range[i].pnc_range_conf), sizeof(tpm_db_pnc_range_conf_t));
-			return (TPM_DB_OK);
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_oper_get()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* range_id         - Range number to retrieve configuration for
-
-* OUTPUTS:
-* range_oper       - Structure for pnc_range Operational Info
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_oper_get(tpm_pnc_ranges_t range_id, tpm_db_pnc_range_oper_t *range_oper)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == range_id) {
-			/* Return Data Structure */
-			memcpy(range_oper, &(tpm_db.pnc_range[i].pnc_range_oper), sizeof(tpm_db_pnc_range_oper_t));
-			return (TPM_DB_OK);
-		}
-	}
-	/* pnc_range not found */
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_rng_free_ent_get()
-*
-* DESCRIPTION:      Returns number of free entries of PnC range
-*
-* INPUTS:
-* range_id         - Range number to retrieve number of free entries
-
-* OUTPUTS:
-* free_entries      - Number of free entries in Table
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_rng_free_ent_get(tpm_pnc_ranges_t range_id, uint32_t *free_entries)
-{
-	uint32_t i;
-
-	/* Check PnC range exists in DB */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_db.pnc_range[i].valid == TPM_DB_VALID
-		    && tpm_db.pnc_range[i].pnc_range_conf.range_id == range_id) {
-			/* Return Free Entries */
-			*free_entries = PNC_RANGE_OPER(i).free_entries;
-			return (TPM_DB_OK);
-		}
-	}
-	/* pnc_range not found */
-	*free_entries = 0;
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_owner_set()
-*
-* DESCRIPTION:      Creates an owner_id in the DB.
-*
-* INPUTS:
-* owner_id         - Id of new owner
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_owner_set(uint32_t owner_id)
-{
-	uint32_t i;
-	int32_t free_ind = -1;
-
-	/* Check owner was not already set */
-	for (i = 0; i < TPM_MAX_API_TYPES; i++) {
-		if ((tpm_db.owners[i].valid == TPM_DB_VALID) && (tpm_db.owners[i].owner_id == owner_id))
-			return (TPM_DB_ERR_REC_EXIST);
-		if ((free_ind == -1) && (tpm_db.owners[i].valid == TPM_DB_INVALID))
-			free_ind = i;
-	}
-	if (free_ind == -1)
-		return (TPM_DB_ERR_DB_TBL_FULL);
-
-	/* Set on first free index */
-	tpm_db.owners[free_ind].valid = TPM_DB_VALID;
-	tpm_db.owners[free_ind].owner_id = owner_id;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_owner_get_next()
-*
-* DESCRIPTION:      Returns DB info of PnC range
-*
-* INPUTS:
-* cur_ind          - The current index (handle) to the owner table. Function returns the next
-*                    valid table entry > cur_index. cur_index < 0 indicates to return first valid entry in table,
-*                    valid next_ind values are 0 or higher.
-* OUTPUTS:
-* next_ind         - See cur_ind. If end of table was reached before valid entry, (-1) is returned in next_ind
-* owner            - Returns the owner of the next index.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t. No more owners is not considered error.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_owner_get_next(int32_t cur_ind, int32_t *next_ind, uint32_t *owner)
-{
-	uint32_t i;
-
-	/* Initialize first next_ind */
-	if (cur_ind < 0)
-		i = 0;
-	else
-		i = cur_ind + 1;
-
-	/* Check owner exists in DB */
-	for (; i < TPM_MAX_API_TYPES; i++) {
-		if (tpm_db.owners[i].valid == TPM_DB_VALID) {	/* oren - changed = to ==, need to check */
-			/* Return Data Structure */
-			*next_ind = i;
-			*owner = tpm_db.owners[i].owner_id;
-			return (TPM_DB_OK);
-		}
-	}
-	/* No valid entry found */
-	*next_ind = -1;
-
-	return (TPM_DB_OK);
-}
-
-#if 0
-/*******************************************************************************
-* tpm_db_apig_set()
-*
-* DESCRIPTION:      Creates an API Group in the DB.
-*
-* INPUTS:
-* owner_id         - owner of the API Group
-* api_type        - API Group being created
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-
-int32_t tpm_db_apig_set(uint32_t owner_id, tpm_api_type_t api_type)
-{
-	uint32_t i;
-
-	/* Check owner exists */
-	for (i = 0; i < TPM_MAX_API_TYPES; i++) {
-		if ((tpm_db.owners[i].valid == TPM_DB_VALID) && (tpm_db.owners[i].owner_id == owner_id))
-			break;
-	}
-	if (i == TPM_MAX_API_TYPES)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	/* Check api_type does not exist */
-	if (tpm_db.api_groups[api_type].valid == TPM_DB_VALID)
-		return (TPM_DB_ERR_REC_EXIST);
-
-	tpm_db.api_groups[api_type].valid = TPM_DB_VALID;
-	tpm_db.api_groups[api_type].api_owner_id = owner_id;
-	tpm_db.api_groups[api_type].api_type = api_type;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_apig_get_next()
-*
-* DESCRIPTION:      Returns DB info of API Group
-*
-* INPUTS:
-* cur_ind          - The current index (handle) to the owner table. Function returns the next
-*                    valid table entry > cur_index. cur_index < 0 indicates to return first valid entry in table,
-*                    valid next_ind values are 0 or higher.
-* OUTPUTS:
-* next_ind         - See cur_ind. If end of table was reached before valid entry, (-1) is returned in next_ind
-* api_type         - Returns the API Group.
-* owner            - Returns the owner of the API Group.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_apig_get_next(int32_t cur_ind, int32_t *next_ind, uint32_t *owner, tpm_api_type_t *api_type)
-{
-	uint32_t i;
-
-	/* Initialize first next_ind */
-	if (cur_ind < 0)
-		i = 0;
-	else
-		i = cur_ind + 1;
-
-	/* Check API Group exists in DB */
-	for (; i < TPM_MAX_API_TYPES; i++) {
-		if (tpm_db.api_groups[i].valid == TPM_DB_VALID) {
-			/* Return Data  */
-			*next_ind = i;
-			*api_type = tpm_db.api_groups[i].api_type;
-			*owner = tpm_db.api_groups[i].api_owner_id;
-			return (TPM_DB_OK);
-		}
-	}
-	/* No valid entry found */
-	*next_ind = -1;
-	return (TPM_DB_OK);
-}
-#endif
-
-/*******************************************************************************
-* tpm_db_igmp_set_port_frwd_mode()
-*
-* DESCRIPTION:      Set the IGMP status of a UNI port or WAN port
-*
-* INPUTS:
-* src_port          - source port to set
-* igmp_state       - how to process IGMP packets
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_set_port_frwd_mode(uint32_t port, uint32_t mode)
-{
-	tpm_db.igmp_def.frwd_mode[port] = mode;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_igmp_get_port_frwd_mode()
-*
-* DESCRIPTION:      Get the IGMP status of a UNI port or WAN port
-*
-* INPUTS:
-* src_port          - source port to get
-*
-* OUTPUTS:
-* igmp_state       - how to process IGMP packets
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_get_port_frwd_mode(uint32_t port, uint32_t *mode)
-{
-	*mode = tpm_db.igmp_def.frwd_mode[port];
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_igmp_set_cpu_queue()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_set_cpu_queue(uint32_t queue)
-{
-	tpm_db.igmp_def.cpu_queue = queue;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_igmp_get_cpu_queue()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_get_cpu_queue(uint32_t *queue)
-{
-	*queue = tpm_db.igmp_def.cpu_queue;
-	return (TPM_DB_OK);
-}
-
-
-/*******************************************************************************
-* tpm_db_igmp_set_snoop_enable()
-*
-* DESCRIPTION:      Set IGMP snoop enable
-*
-* INPUTS:
-* igmp_snoop_enable       - IGMP snoop enable
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_set_snoop_enable(uint32_t igmp_snoop_enable)
-{
-	tpm_db.igmp_def.igmp_snoop_enable = igmp_snoop_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_igmp_get_snoop_enable()
-*
-* DESCRIPTION:      Get IGMP snoop enable
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop_enable       - IGMP snoop enable
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_igmp_get_snoop_enable(uint32_t *igmp_snoop_enable)
-{
-	*igmp_snoop_enable = tpm_db.igmp_def.igmp_snoop_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_type_set()
-*
-* DESCRIPTION:      Set OMCI ethertype
-*
-* INPUTS:
-* omci_etype       - OMCI Ethertype
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_omci_type_set(uint32_t omci_etype)
-{
-	tpm_db.init_misc.omci_etype = omci_etype;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_type_get()
-*
-* DESCRIPTION:      Get OMCI ethertype
-*
-* OUTPUTS:
-* omci_etype       - OMCI Ethertype
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_omci_type_get(uint32_t *omci_etype)
-{
-	*omci_etype = tpm_db.init_misc.omci_etype;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_channel_set()
-*
-* DESCRIPTION:      Set OMCI channel parameters
-*
-* INPUTS:
-* gemport       - OMCI GEM port ID
-* cpu_rx_q      - OMCI cpu rx queue
-* cpu_tx_q      - OMCI cpu tx queue
-* tcont_id      - OMCI tcont ID
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_omci_channel_set(uint16_t gemport, uint32_t cpu_rx_q, uint32_t cpu_tx_q, uint32_t tcont_id)
-{
-	tpm_db.init_misc.omci_gemport = gemport;
-	tpm_db.init_misc.oam_cpu_rx_q = cpu_rx_q;
-	tpm_db.init_misc.oam_cpu_tx_q = cpu_tx_q;
-	tpm_db.init_misc.oam_cpu_tx_port = tcont_id;
-	tpm_db.init_misc.oam_channel_configured = 1;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_channel_remove()
-*
-* DESCRIPTION:      Remove OMCI channel parameters
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_omci_channel_remove(void)
-{
-	tpm_db.init_misc.omci_gemport = 0;
-	tpm_db.init_misc.oam_cpu_rx_q = 0;
-	tpm_db.init_misc.oam_cpu_tx_q = 0;
-	tpm_db.init_misc.oam_cpu_tx_port = 0;
-	tpm_db.init_misc.oam_channel_configured = 0;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_oam_loopback_state_get()
-*
-* DESCRIPTION:      Get OAM loopback configure state
-*
-* OUTPUTS:
-* omci_etype       - OMCI Ethertype
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_loopback_state_get(uint32_t *loopback)
-{
-	*loopback = tpm_db.init_misc.oam_loopback_channel_configured;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_oam_loopback_channel_set()
-*
-* DESCRIPTION:      Set OAM loopback channel state
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_loopback_channel_set(void)
-{
-	tpm_db.init_misc.oam_loopback_channel_configured = 1;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_channel_remove()
-*
-* DESCRIPTION:      Remove OMCI channel parameters
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_loopback_channel_remove(void)
-{
-	tpm_db.init_misc.oam_loopback_channel_configured = 0;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_omci_channel_get()
-*
-* DESCRIPTION:      Get OMCI channel parameters
-*
-* INPUTS:
-* gemport       - OMCI GEM port ID
-* cpu_rx_q      - OMCI cpu rx queue
-* cpu_tx_q      - OMCI cpu tx queue
-* tcont_id      - OMCI tcont ID
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_omci_channel_get(uint32_t *valid, uint16_t *gemport, uint32_t *cpu_rx_q, uint32_t *cpu_tx_q,
-				uint32_t *tcont_id)
-{
-	*gemport = tpm_db.init_misc.omci_gemport;
-	*cpu_rx_q = tpm_db.init_misc.oam_cpu_rx_q;
-	*cpu_tx_q = tpm_db.init_misc.oam_cpu_tx_q;
-	*tcont_id = tpm_db.init_misc.oam_cpu_tx_port;
-	*valid = tpm_db.init_misc.oam_channel_configured;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_oam_channel_set()
-*
-* DESCRIPTION:      Set OAM channel parameters
-*
-* INPUTS:
-* cpu_rx_q      - OAM cpu rx queue
-* cpu_tx_q      - OAM cpu tx queue
-* llid          - OAM LLID
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_channel_set(uint32_t cpu_rx_q, uint32_t cpu_tx_q, uint32_t llid)
-{
-	tpm_db.init_misc.oam_cpu_rx_q = cpu_rx_q;
-	tpm_db.init_misc.oam_cpu_tx_q = cpu_tx_q;
-	tpm_db.init_misc.oam_cpu_tx_port = llid;
-	tpm_db.init_misc.oam_channel_configured = 1;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_oam_channel_remove()
-*
-* DESCRIPTION:      Remove OAM channel parameters
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_channel_remove(void)
-{
-	tpm_db.init_misc.omci_gemport = 0;
-	tpm_db.init_misc.oam_cpu_rx_q = 0;
-	tpm_db.init_misc.oam_cpu_tx_q = 0;
-	tpm_db.init_misc.oam_cpu_tx_port = 0;
-	tpm_db.init_misc.oam_channel_configured = 0;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_oam_channel_get()
-*
-* DESCRIPTION:      Get OAM channel parameters
-*
-* INPUTS:
-* cpu_rx_q      - OAM cpu rx queue
-* cpu_tx_q      - OAM cpu tx queue
-* tcont_id      - OAM llid
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_oam_channel_get(uint32_t *valid, uint32_t *cpu_rx_q, uint32_t *cpu_tx_q, uint32_t *llid)
-{
-	*cpu_rx_q = tpm_db.init_misc.oam_cpu_rx_q;
-	*cpu_tx_q = tpm_db.init_misc.oam_cpu_tx_q;
-	*llid = tpm_db.init_misc.oam_cpu_tx_port;
-	*valid = tpm_db.init_misc.oam_channel_configured;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_init_deb_port_set()
-*
-* DESCRIPTION:      Set Init Debug Port
-*
-* INPUTS:
-* pnc_init_debug_port       - Set the debug Port, which will be preconfigured to send
-*                             all traffic to CPU (NFS port for development)
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-#if 0
-int32_t tpm_db_pnc_init_deb_port_set(uint32_t pnc_init_debug_port)
-{
-	tpm_db.init_misc.pnc_init_debug_port = pnc_init_debug_port;
-
-	return (TPM_DB_OK);
-
-}
-#endif
-
-/*******************************************************************************
-* tpm_db_pnc_init_deb_port_get()
-*
-* DESCRIPTION:      Get Debug Port
-*
-* OUTPUTS:
-* pnc_init_debug_port  - Get the debug Port, which will be preconfigured to send all
-*                        traffic to CPU (NFS port for development)
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-#if 0
-int32_t tpm_db_pnc_init_deb_port_get(uint32_t *pnc_init_debug_port)
-{
-	*pnc_init_debug_port = tpm_db.init_misc.pnc_init_debug_port;
-
-	return (TPM_DB_OK);
-}
-#endif
-
-/*******************************************************************************
-* tpm_db_init_done_set()
-*
-* DESCRIPTION:      Set TPM was successfully Initialized
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_init_done_set(void)
-{
-	tpm_db.init_misc.tpm_init_succeeded = TPM_DB_VALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_init_done_get()
-*
-* DESCRIPTION:      Get value if TPM was successfully Initialized
-*
-* OUTPUTS:
-* tpm_init_succeeded  -
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_init_done_get(void)
-{
-	if (tpm_db.init_misc.tpm_init_succeeded == TPM_DB_VALID)
-		return (1);
-	return (0);
-}
-
-/*******************************************************************************
-* tpm_db_pon_type_set()
-*
-* DESCRIPTION:      Set WAN technology
-*
-* INPUTS:
-* pon_type          - GPON, EPON, Ethernet or None
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pon_type_set(tpm_db_pon_type_t pon_type)
-{
-	tpm_db.init_misc.pon_type = pon_type;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pon_type_get()
-*
-* DESCRIPTION:      Get WAN technology
-*
-* OUTPUTS:
-* pon_type          - GPON, EPON, Ethernet or None
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pon_type_get(tpm_db_pon_type_t *pon_type)
-{
-	*pon_type = tpm_db.init_misc.pon_type;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_active_wan_set()
-*
-* DESCRIPTION:      Set WAN technology
-*
-* INPUTS:
-* pon_type          - GPON, EPON, Ethernet or None
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_active_wan_set(tpm_gmacs_enum_t active_wan)
-{
-	tpm_db.init_misc.active_wan = active_wan;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_active_wan_get()
-*
-* DESCRIPTION:      Set WAN technology
-*
-* INPUTS:
-* pon_type          - GPON, EPON, Ethernet or None
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_gmacs_enum_t tpm_db_active_wan_get()
-{
-	return tpm_db.init_misc.active_wan;
-}
-
-/*******************************************************************************
-* tpm_db_pnc_mac_learn_enable_set()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_mac_learn_enable_set(tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable)
-{
-	tpm_db.init_misc.pnc_mac_learn_enable = pnc_mac_learn_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_mac_learn_enable_get()
-*
-* DESCRIPTION:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_mac_learn_enable_get(tpm_init_pnc_mac_learn_enable_t *pnc_mac_learn_enable)
-{
-	*pnc_mac_learn_enable = tpm_db.init_misc.pnc_mac_learn_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_fc_conf_set()
-*
-* DESCRIPTION:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_fc_conf_set(tpm_init_fc_params_t *port_fc_conf)
-{
-	memcpy(&tpm_db.port_fc_conf, port_fc_conf, sizeof(tpm_db_fc_params_t));
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_fc_conf_get()
-*
-* DESCRIPTION:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_fc_conf_get(tpm_init_fc_params_t *port_fc_conf)
-{
-	memcpy(port_fc_conf, &tpm_db.port_fc_conf, sizeof(tpm_db_fc_params_t));
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_switch_init_set()
-*
-* DESCRIPTION: Set Amber Initialization
-*
-* INPUTS:
-* switch_init
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_switch_init_set(uint32_t switch_init)
-{
-	tpm_db.func_profile.switch_init = switch_init;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_switch_init_get()
-*
-* DESCRIPTION: Get Amber Initialization
-*
-* INPUTS:
-* switch_init
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_switch_init_get(uint32_t *switch_init)
-{
-	*switch_init = tpm_db.func_profile.switch_init;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_ds_mh_set_conf_set()
-*
-* DESCRIPTION:      Set downstream marvell header source select
-*
-* INPUTS:
-* ds_mh_set_conf    - Allow set MH in Pnc or not
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ds_mh_set_conf_set(tpm_db_mh_src_t ds_mh_set_conf)
-{
-	tpm_db.init_misc.ds_mh_set_conf = ds_mh_set_conf;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_ds_mh_get_conf_set()
-*
-* DESCRIPTION:      Set downstream marvell header source select
-*
-* INPUTS:
-*
-* OUTPUTS:
-* ds_mh_set_conf    - Allow set MH in Pnc or not
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ds_mh_get_conf_set(tpm_db_mh_src_t *ds_mh_set_conf)
-{
-	*ds_mh_set_conf = tpm_db.init_misc.ds_mh_set_conf;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_cfg_pnc_parse_set()
-*
-* DESCRIPTION:      Set config PNC parse enabled/disabled in DB
-*
-* INPUTS:
-* cfg_pnc_parse          0=DISABLED  /  1=ENABLED
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_cfg_pnc_parse_set(tpm_init_cfg_pnc_parse_t cfg_pnc_parse)
-{
-	tpm_db.init_misc.cfg_pnc_parse = cfg_pnc_parse;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_cpu_loopback_set()
-*
-* DESCRIPTION:      Set cpu loopback enabled/disabled in DB
-*
-* INPUTS:
-* cpu_loopback          0=DISABLED  /  1=ENABLED
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_cpu_loopback_set(tpm_init_cpu_loopback_t cpu_loopback)
-{
-	tpm_db.init_misc.cpu_loopback = cpu_loopback;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_cfg_pnc_parse_get()
-*
-* DESCRIPTION:      Get config PNC parse enabled/disabled in DB
-*
-* OUTPUTS:
-* cfg_pnc_parse_val          0=DISABLED  /  1=ENABLED
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_cfg_pnc_parse_get(tpm_init_cfg_pnc_parse_t *cfg_pnc_parse_val)
-{
-	*cfg_pnc_parse_val = tpm_db.init_misc.cfg_pnc_parse;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_cpu_loopback_get()
-*
-* DESCRIPTION:      Get CPU loopback enabled/disabled in DB
-*
-* OUTPUTS:
-* cpu_loopback_val          0=DISABLED  /  1=ENABLED
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_cpu_loopback_get(tpm_init_cpu_loopback_t *cpu_loopback_val)
-{
-	*cpu_loopback_val = tpm_db.init_misc.cpu_loopback;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_double_tag_support_set()
-*
-* DESCRIPTION:      Set config double tagged supported in DB
-*
-* INPUTS:
-* dbl_tag          0=DISABLED  /  1=ENABLED
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_double_tag_support_set(tpm_init_double_tag_t dbl_tag)
-{
-	tpm_db.init_misc.dbl_tag = dbl_tag;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_double_tag_support_get()
-*
-* DESCRIPTION:      Get config double tagged supported in DB
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_double_tag_support_get(tpm_init_double_tag_t *dbl_tag)
-{
-	*dbl_tag = tpm_db.init_misc.dbl_tag;
-
-	return (TPM_DB_OK);
-}
-
-#if 0
-/*******************************************************************************
-* tpm_db_default_tag_tpid_set()
-*
-* DESCRIPTION:      Set tpid of one/two vlan tag in DB
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_default_tag_tpid_set(uint16_t vlan1_tpid, uint16_t vlan2_tpid)
-{
-	tpm_db.init_misc.vlan1_tpid = vlan1_tpid;
-	tpm_db.init_misc.vlan2_tpid = vlan2_tpid;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_default_tag_tpid_get()
-*
-* DESCRIPTION:      Get tpid of one/two vlan tag in DB
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_default_tag_tpid_get(uint16_t *vlan1_tpid, uint16_t *vlan2_tpid)
-{
-	*vlan1_tpid = tpm_db.init_misc.vlan1_tpid;
-	*vlan2_tpid = tpm_db.init_misc.vlan2_tpid;
-
-	return (TPM_DB_OK);
-}
-#endif
-
-/*******************************************************************************
-* tpm_db_default_tag_tpid_set()
-*
-* DESCRIPTION:      Set tpid of one/two vlan tag in DB
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_default_tag_tpid_set(tpm_init_tpid_opt_t *tag_tpid)
-{
-	memcpy(&tpm_db.init_misc.tag_tpid, tag_tpid, sizeof(tpm_init_tpid_opt_t));
-	return(TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_default_tag_tpid_get()
-*
-* DESCRIPTION:      Get tpid of one/two vlan tag in DB
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_default_tag_tpid_get(tpm_init_tpid_opt_t *tag_tpid)
-{
-	memcpy(tag_tpid, &tpm_db.init_misc.tag_tpid, sizeof(tpm_init_tpid_opt_t));
-	return(TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_virt_info_set()
-*
-* DESCRIPTION:      Set wifi via UNI in TPM DB
-*
-* INPUTS:
-* virt_uni_info.enabled          0=DISABLED  /  1=ENABLED
-* virt_uni_info.uni_port             port#
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_virt_info_set(tpm_init_virt_uni_t virt_uni_info)
-{
-	tpm_db.func_profile.virt_uni_info.enabled = virt_uni_info.enabled;
-	tpm_db.func_profile.virt_uni_info.uni_port = virt_uni_info.uni_port;
-	tpm_db.func_profile.virt_uni_info.switch_port = virt_uni_info.switch_port;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_virt_info_get()
-*
-* DESCRIPTION:      Get wifi via UNI in TPM DB
-*
-* OUTPUTS:
-* virt_uni_info.enabled          0=DISABLED  /  1=ENABLED
-* virt_uni_info.uni_port             port#
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_virt_info_get(tpm_init_virt_uni_t *virt_uni_info)
-{
-	virt_uni_info->enabled 		= tpm_db.func_profile.virt_uni_info.enabled;
-	virt_uni_info->uni_port 	= tpm_db.func_profile.virt_uni_info.uni_port;
-	virt_uni_info->switch_port 	= tpm_db.func_profile.virt_uni_info.switch_port;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_ipv6_5t_enable_set()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ipv6_5t_enable_set(tpm_init_ipv6_5t_enable_t ipv6_5t_enable)
-{
-	tpm_db.init_misc.ipv6_5t_enable = ipv6_5t_enable;
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_ipv6_5t_enable_get()
-*
-* DESCRIPTION:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ipv6_5t_enable_get(tpm_init_ipv6_5t_enable_t *ipv6_5t_enable)
-{
-	*ipv6_5t_enable = tpm_db.init_misc.ipv6_5t_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_port_vector_tbl_info_set()
-*
-* DESCRIPTION:      Set MH port vector table in TPM DB.
-*
-* OUTPUTS:
-* tpm_mh_port_vector_tbl_new
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_port_vector_tbl_info_set(uint32_t reg_num, uint32_t uni_vector, uint16_t amber_port_vector,
-					uint32_t pnc_vector)
-{
-	if (TPM_TX_MAX_MH_REGS <= reg_num)
-		return TPM_DB_ERR_REC_INV;
-
-	tpm_db.tpm_mh_port_vector_tbl[reg_num].uni_vector = uni_vector;
-	tpm_db.tpm_mh_port_vector_tbl[reg_num].pnc_vector = pnc_vector;
-	tpm_db.tpm_mh_port_vector_tbl[reg_num].amber_port_vector = amber_port_vector;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_port_vector_tbl_info_get()
-*
-* DESCRIPTION:      Get MH port vector table in TPM DB.
-*
-* OUTPUTS:
-* tpm_mh_port_vector_tbl_new
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_port_vector_tbl_info_get(uint32_t reg_num, uint32_t *uni_vector, uint16_t *amber_port_vector,
-					uint32_t *pnc_vector)
-{
-	if (TPM_TX_MAX_MH_REGS <= reg_num)
-		return TPM_DB_ERR_REC_INV;
-
-	*uni_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].uni_vector;
-	*pnc_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].pnc_vector;
-	*amber_port_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].amber_port_vector;
-	return (TPM_DB_OK);
-}
-
-
-/*******************************************************************************
-* tpm_db_port_vector_tbl_info_search()
-*
-* DESCRIPTION:      Search in the MH port vector table in TPM DB for matching target port
-*
-* OUTPUTS:
-* tpm_mh_port_vector_tbl_new
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_port_vector_tbl_info_search(tpm_trg_port_type_t  trg_port, uint32_t *uni_vector,
-					    uint16_t *amber_port_vector, uint32_t *pnc_vector)
-{
-	uint32_t reg_num;
-
-	for (reg_num = 0; reg_num < TPM_TX_MAX_MH_REGS; reg_num++) {
-		if (trg_port == tpm_db.tpm_mh_port_vector_tbl[reg_num].uni_vector) {
-			*uni_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].uni_vector;
-			*pnc_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].pnc_vector;
-			*amber_port_vector = tpm_db.tpm_mh_port_vector_tbl[reg_num].amber_port_vector;
-			return TPM_DB_OK;
-		}
-	}
-
-	return TPM_DB_ERR_REC_INV;
-}
-
-
-
-/*******************************************************************************
-* tpm_db_api_section_ent_tbl_reset()
-*
-* DESCRIPTION:      Reset an API table/acl
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_ent_tbl_reset(uint32_t start_entry, uint32_t num_entries)
-{
-	uint32_t i;
-
-	/*Init API Rng Entries */
-	memset(&(tpm_db.api_ent_mem_area[mem_alloc_start_ind]), 0, (num_entries) * (sizeof(tpm_db_api_entry_t)));
-
-	/* Invalidate API Rng Entries */
-	for (i = start_entry; i < (start_entry + num_entries); i++)
-		tpm_db.api_ent_mem_area[i].valid = TPM_DB_INVALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_ent_tbl_get()
-*
-* DESCRIPTION:      get an API table/acl entry
-*
-* INPUTS:
-* api_sec      - Section of the API acl/table
-* index        - rule index
-* OUTPUTS:
-* api_ent_mem_area - table/acl entry
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_ent_tbl_get(tpm_api_sections_t api_sec, tpm_db_api_entry_t *api_ent_mem_area, uint32_t index)
-{
-	if (ILLEGAL_API_SEC(api_sec))
-		IF_ERROR_I(TPM_DB_ERR_REC_NOT_EXIST, api_sec);
-
-	if (NULL == api_ent_mem_area)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memcpy(api_ent_mem_area, &tpm_db.api_ent_mem_area[(tpm_db.api_section[api_sec].table_start) + index], sizeof(tpm_db_api_entry_t));
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_init()
-*
-* DESCRIPTION:      Initialize an API table/acl
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* api_rng_size     - Size of the table/acl
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_init(tpm_api_sections_t api_section, tpm_pnc_ranges_t prim_pnc_range, uint32_t api_rng_size)
-{
-
-	/* Check that new api_rng table does not cross allocation boundaries */
-	if ((mem_alloc_start_ind + api_rng_size) > TPM_DB_API_ENTRIES_TBL_SIZE) {
-		TPM_OS_ERROR(TPM_DB_MOD, " API Range not created, Entries Area overflow, "
-			     "ind_start(%d), api_rng_size(%d), mem_area_size(%d) \n",
-			     mem_alloc_start_ind, api_rng_size, TPM_DB_API_ENTRIES_TBL_SIZE);
-
-		return (TPM_DB_ERR_DB_TBL_FULL);
-	}
-	if ((mem_alloc_start_ind + api_rng_size) > (TPM_DB_API_ENTRIES_TBL_SIZE - TPM_DB_API_SECTION_MARGIN_SIZE)) {
-		TPM_OS_WARN(TPM_DB_MOD, "Entries Area has less than calculated end margin, "
-			    "ind_start(%d), api_rng_size(%d), mem_area_size(%d)\n",
-			    mem_alloc_start_ind, api_rng_size, TPM_DB_API_ENTRIES_TBL_SIZE);
-	}
-
-	/*Init API Range */
-	memset(&(tpm_db.api_section[api_section]), 0, sizeof(tpm_db_api_section_t));
-
-	tpm_db_api_section_ent_tbl_reset(mem_alloc_start_ind, api_rng_size);
-
-	tpm_db.api_section[api_section].table_size = api_rng_size;
-	tpm_db.api_section[api_section].table_start = mem_alloc_start_ind;
-	tpm_db.api_section[api_section].valid = TPM_DB_VALID;
-	tpm_db.api_section[api_section].prim_pnc_range = prim_pnc_range;
-	tpm_db.api_section[api_section].last_valid_entry = -1;
-	tpm_db.api_section[api_section].last_valid_index = -1;
-	tpm_db.api_section[api_section].num_valid_entries = 0;
-
-	/* Forward to next 'API Entries table' start_index.
-	 * This also inserts 'margin_size' between subsequent 'API Entries table' */
-	mem_alloc_start_ind += (api_rng_size + TPM_DB_API_SECTION_MARGIN_SIZE);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entries_area_reset()
-*
-* DESCRIPTION:      Reset an API table/acl
-*
-* INPUTS:
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entries_area_reset(void)
-{
-	/* Stripe API Entries Area */
-	memset(tpm_db.api_ent_mem_area, MEM_MARGIN_PATTERN, sizeof(tpm_db.api_ent_mem_area));
-
-	/* Reset Area Index, Start Area offset at margin_size */
-	mem_alloc_start_ind = TPM_DB_API_SECTION_MARGIN_SIZE;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_invalidate()
-*
-* DESCRIPTION:      Reset an API table/acl
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_invalidate(tpm_api_sections_t api_section)
-{
-	/*Init API Range */
-	memset(&(tpm_db.api_section[api_section]), 0, sizeof(tpm_db_api_section_t));
-
-	/* Invalidate Range */
-	tpm_db.api_section[api_section].valid = TPM_DB_INVALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_reset()
-*
-* DESCRIPTION:      Initialize an API table/acl
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_reset(tpm_api_sections_t api_section)
-{
-	/* prim_pnc_range, table_size, table_start attributes are retained from init */
-
-	tpm_db.api_section[api_section].num_valid_entries = 0;
-	tpm_db.api_section[api_section].last_valid_entry = -1;
-	tpm_db.api_section[api_section].last_valid_index = -1;
-
-	/* Invalidate all API entries */
-	tpm_db_api_section_ent_tbl_reset(tpm_db.api_section[api_section].table_start,
-					 tpm_db.api_section[api_section].table_size);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_get()
-*
-* DESCRIPTION:      Get
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-* api_rng_size      - API range size
-* num_valid_entries- Number of valid entries
-* last_valid - Last valid entry
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_get(tpm_api_sections_t api_section,
-			       uint32_t 	*api_rng_size,
-			       uint32_t 	*num_valid_entries,
-			       tpm_pnc_ranges_t	*prim_pnc_range,
-			       int32_t 		*last_valid_entry,
-			       uint32_t 	*tbl_start)
-{
-	if (ILLEGAL_API_SEC(api_section))
-		IF_ERROR_I(TPM_DB_ERR_REC_NOT_EXIST, api_section);
-
-	if (tpm_db.api_section[api_section].valid == TPM_DB_INVALID)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	*api_rng_size = tpm_db.api_section[api_section].table_size;
-	*num_valid_entries = tpm_db.api_section[api_section].num_valid_entries;
-	*prim_pnc_range = tpm_db.api_section[api_section].prim_pnc_range;
-	*last_valid_entry = tpm_db.api_section[api_section].last_valid_entry;
-	*tbl_start = tpm_db.api_section[api_section].table_start;
-
-	TPM_OS_DEBUG(TPM_DB_MOD,
-		     "returned size(%d), num_entries(%d), prim_pnc_range(%d), last_valid_entry (%d) tbl_start(%d)\n",
-		     *api_rng_size, *num_valid_entries, *prim_pnc_range, *last_valid_entry, *tbl_start);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_lastentry_get()
-*
-* DESCRIPTION:      Get
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-* last_valid - Last valid entry
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_lastentry_get(tpm_api_sections_t api_section, int32_t *last_valid_entry)
-{
-	if (tpm_db.api_section[api_section].valid == TPM_DB_INVALID)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	*last_valid_entry = tpm_db.api_section[api_section].last_valid_entry;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_main_pnc_get()
-*
-* DESCRIPTION:      Get
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-* prim_pnc_range - Primary PNC Range for this API ACL/Table
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_main_pnc_get(tpm_api_sections_t api_section, tpm_pnc_ranges_t *prim_pnc_range)
-{
-	if (tpm_db.api_section[api_section].valid == TPM_DB_INVALID)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	*prim_pnc_range = tpm_db.api_section[api_section].prim_pnc_range;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_num_entries_get()
-*
-* DESCRIPTION:      Get
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* OUTPUTS:
-* num_entries - Number of valid entries
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_num_entries_get(tpm_api_sections_t api_section, uint32_t *num_entries)
-{
-	if (tpm_db.api_section[api_section].valid == TPM_DB_INVALID)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	*num_entries = tpm_db.api_section[api_section].num_valid_entries;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_section_val_get_next()
-*
-* DESCRIPTION:      Get next valid API range
-*
-* INPUTS:
-* cur_api_section      - Section of the API acl/table
-* OUTPUTS:
-* api_rng_size      - API range size
-* num_valid_entries- Number of valid entries
-* last_valid - Last valid entry
-* next_section
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_val_get_next(int32_t cur_api_section,
-					int32_t *next_section,
-					uint32_t *api_rng_size,
-					uint32_t *num_valid_entries, int32_t *last_valid_entry, uint32_t *tbl_start)
-{
-	uint32_t x;
-
-	/* Check Params */
-	if (cur_api_section < -1 || cur_api_section >= TPM_MAX_NUM_API_SECTIONS)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	/* Initialize next section  */
-	x = (uint32_t) (cur_api_section + 1);
-
-	/* Check PnC range exists in DB */
-	for (; x < TPM_MAX_NUM_API_SECTIONS; x++) {
-		if (tpm_db.api_section[x].valid == TPM_DB_VALID) {
-			/* Return Data */
-			*api_rng_size = tpm_db.api_section[x].table_size;
-			*num_valid_entries = tpm_db.api_section[x].num_valid_entries;
-			*last_valid_entry = tpm_db.api_section[x].last_valid_entry;
-			*tbl_start = tpm_db.api_section[x].table_start;
-			*next_section = x;
-			return (TPM_DB_OK);
-		}
-	}
-	/* No valid entry found */
-	*next_section = -1;
-
-	return (TPM_DB_OK);
-}
-
-#if 0	/* YUVAL_OK */
-void tpm_db_api_area_bubble_sort(tpm_db_api_check_t *array, uint8_t num_elements)
-{
-	int32_t i, j;
-	tpm_db_api_check_t temp_var;
-
-	if (num_elements <= 1)
-		return;
-
-	for (i = 0; i < num_elements; i++) {
-		/* back through the area bringing smallest remaining element to position i */
-		for (j = num_elements - 1; j > i; j--) {
-			if (array[j - 1].table_start > array[j].table_start) {
-				memcpy(&temp_var, &(array[j]), sizeof(tpm_db_api_check_t));
-				memcpy(&(array[j]), &(array[j - 1]), sizeof(tpm_db_api_check_t));
-				memcpy(&(array[j - 1]), &temp_var, sizeof(tpm_db_api_check_t));
-
-			}
-		}
-	}
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_db_api_section_margins_check()
-*
-* DESCRIPTION:      Get next valid API range
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_rng_margins_self_check(void)
-{
-
-	tpm_api_sections_t cur_section = -1, next_section = 0;
-	int32_t last_valid;
-	int32_t ret_code, margin_area;
-	uint32_t margin_entry, api_rng_size = 0, num_valid_entries;
-	uint32_t tbl_start_ind = 0, table_size, margin_start_ind, area_num, num_ranges;
-	uint32_t i = 0, k = 0;
-	uint8_t *margin_p;
-	tpm_db_api_check_t api_sections_areas[TPM_MAX_NUM_API_SECTIONS];
-
-	/* Loop through valid API ranges read them into local array */
-	ret_code = tpm_db_api_section_val_get_next(cur_section, &next_section, &api_rng_size,
-						   &num_valid_entries, &last_valid, &tbl_start_ind);
-	IF_ERROR(ret_code);
-
-	while (next_section != TPM_INVALID_SECTION) {
-		api_sections_areas[i].table_size = api_rng_size;
-		api_sections_areas[i].table_start = tbl_start_ind;
-
-		cur_section = next_section;
-		i++;
-
-		ret_code = tpm_db_api_section_val_get_next(cur_section, &next_section, &api_rng_size,
-							   &num_valid_entries, &last_valid, &tbl_start_ind);
-		IF_ERROR(ret_code);
-	}
-
-	num_ranges = i;
-
-	/* Simple Ordering */
-	tpm_db_api_area_bubble_sort(api_sections_areas, num_ranges);
-	if (1) {
-		printk("%s (%d)\n", __func__, __LINE__);
-		for (k = 0; k < num_ranges; k++) {
-			printk("entry(%d) table_start(%d) table_size(%d)\n", k, api_sections_areas[k].table_start,
-			       api_sections_areas[k].table_size);
-		}
-	}
-
-	/* Check margins */
-	margin_start_ind = 0;
-	i = 0;
-
-	for (area_num = 0; area_num < num_ranges; area_num++) {
-		tbl_start_ind = api_sections_areas[area_num].table_start;
-		table_size = api_sections_areas[area_num].table_size;
-
-		margin_p = (uint8_t *) &(tpm_db.api_ent_mem_area[margin_start_ind]);
-		margin_area = (tbl_start_ind - margin_start_ind) * (sizeof(tpm_db_api_entry_t));
-		i = 0;
-
-		while (i < margin_area) {
-			if (*(margin_p + i) != MEM_MARGIN_PATTERN) {
-				/* Print complete tpm_db_api_entry_t from start to end, and also skips checking the rest of it */
-				margin_entry = i / (sizeof(tpm_db_api_entry_t));
-
-				printk("margin entry(%d):\n", margin_entry);
-				for (i = margin_entry * sizeof(tpm_db_api_entry_t);
-				     i < (margin_entry + 1) * sizeof(tpm_db_api_entry_t); i++) {
-					printk("%x ", *(margin_p + i));
-				}
-
-				/* i now points to start of next entry */
-			} else {
-				i++;
-			}
-		}
-		margin_start_ind = tbl_start_ind + api_sections_areas[area_num].table_size;
-	}
-
-	printk("===========================================\n");
-	return (TPM_OK);
-
-}
-#endif
-
-/*******************************************************************************
-* tpm_db_api_section_entry_add()
-*
-* DESCRIPTION:      Update Range params to add new entry
-*
-* INPUTS:
-* api_section       - Section of the API acl/table
-* new_last_valid    - Update the last valid entry with this value
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_section_entry_add(tpm_api_sections_t api_section, int32_t new_last_valid)
-{
-	if (tpm_db.api_section[api_section].valid == TPM_DB_INVALID)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	(tpm_db.api_section[api_section].num_valid_entries)++;
-	tpm_db.api_section[api_section].last_valid_entry = new_last_valid;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_freeentry_get()
-*
-* DESCRIPTION:      Get free API entry
-*
-* INPUTS:
-* api_section       - Section of the API acl/table
-* OUTPUTS:
-* ind               - Return Free Index
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_freeentry_get(tpm_api_sections_t api_section, int32_t *index)
-{
-	uint32_t i;
-
-	/* Find Empty Index */
-	for (i = 0; i < tpm_db.api_section[api_section].table_size; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_INVALID)
-			break;
-	}
-	if (i == tpm_db.api_section[api_section].table_size) {
-		*index = -1;
-		return (TPM_DB_ERR_DB_TBL_FULL);
-	}
-
-	*index = i;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_ind_get()
-*
-* DESCRIPTION:      Get Index (handle) of a rulenum
-*
-* INPUTS:
-* api_section       - Section of the API acl/table
-* rulenum           - Rulenum of the API acl/table
-* OUTPUTS:
-* index             - Return rule number's index
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_ind_get(tpm_api_sections_t api_section, uint32_t rule_num, int32_t *index)
-{
-	int32_t i;
-
-	/* Find the rulenum index */
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID && API_ENT_I(api_section, i).rule_num == rule_num)
-			break;
-	}
-
-	if (i > tpm_db.api_section[api_section].last_valid_index) {
-		*index = -1;
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-	}
-
-	*index = i;
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_api_tcam_rule_idx_get()
-*
-* DESCRIPTION:      Get PnC rule index by API section and TCAM number
-*
-* INPUTS:
-* api_section       - Section of the API acl/table
-* tcam_num          - TCAM number of the API acl/table
-* OUTPUTS:
-* rule_idx          - Return rule index for PnC rule
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_tcam_rule_idx_get(tpm_api_sections_t api_section, uint32_t tcam_num, uint32_t *rule_idx)
-{
-	int32_t i;
-
-	/* Find the rule index */
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		/*
-		   printk("tpm_db_api_tcam_rule_idx_get index[%d], valid[%d], num_pnc_ranges[%d], pnc_index[%d] \n",
-		   i, API_ENT_I(api_section, i).valid, API_ENT_I(api_section, i).pnc_tbl_conn.num_pnc_ranges,
-		   API_ENT_I(api_section, i).pnc_tbl_conn.pnc_conn_tbl[0].pnc_index);
-		 */
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID
-		    && API_ENT_I(api_section, i).pnc_tbl_conn.num_pnc_ranges > 0
-		    && API_ENT_I(api_section, i).pnc_tbl_conn.pnc_conn_tbl[0].pnc_index == tcam_num)
-			break;
-	}
-
-	if (i > tpm_db.api_section[api_section].last_valid_index) {
-		*rule_idx = 0;
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-	}
-
-	*rule_idx = API_ENT_I(api_section, i).rule_idx;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_set()
-*
-* DESCRIPTION:      Set an API Entry
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_num         - Rule number in the API range
-* bi_dir           - Is this rule Bi-directional
-* api_data         - The API key data for this entry
-* mod_con          - Definition of connection to modification tables
-* pnc_con          - Definition of connection to PNC tables
-* OUTPUTS:
-* rule_idx         - Unique Rule Identifier, that does not change over the life span of the rule.
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_set(tpm_api_sections_t api_section,
-			     uint32_t rule_num,
-			     uint32_t bi_dir,
-			     tpm_rule_entry_t *api_data,
-			     tpm_db_mod_conn_t *mod_con, tpm_db_pnc_conn_t *pnc_con, uint32_t *rule_idx)
-{
-	int32_t ind;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pnc_range_conf_t rangConf;
-	int32_t ret_code;
-	uint32_t l_rule_idx;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d), - rule_num(%d)\n", api_section, rule_num);
-
-	/* Find Empty Index */
-	tpm_db_api_freeentry_get(api_section, &ind);
-	if (ind == -1)
-		return (TPM_DB_ERR_DB_TBL_FULL);
-
-	/* Get Range_Id, rang configuration, to get range type */
-	ret_code = tpm_db_api_section_main_pnc_get(api_section, &range_id);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Fill in API entry */
-	memcpy(&(API_ENT_I(api_section, ind).api_rule_data), api_data, sizeof(tpm_rule_entry_t));
-	if (mod_con)
-		memcpy(&(API_ENT_I(api_section, ind).mod_tbl_conn), mod_con, sizeof(tpm_db_mod_conn_t));
-
-	memcpy(&(API_ENT_I(api_section, ind).pnc_tbl_conn), pnc_con, sizeof(tpm_db_pnc_conn_t));
-
-	API_ENT_I(api_section, ind).bi_dir = bi_dir;
-	l_rule_idx = tpm_db_rule_index_get();
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type)
-		API_ENT_I(api_section, ind).rule_idx = l_rule_idx;
-	else
-		API_ENT_I(api_section, ind).rule_idx = rule_num;
-
-	API_ENT_I(api_section, ind).rule_num = rule_num;
-	API_ENT_I(api_section, ind).valid = TPM_DB_VALID;
-
-	/* Increase highest tbl_index if needed */
-	if (ind > tpm_db.api_section[api_section].last_valid_index)
-		tpm_db.api_section[api_section].last_valid_index = ind;
-
-
-	/* Set last_valid to rule_num if needed */
-	if ((tpm_db.api_section[api_section].last_valid_entry < 0)
-	    || ((int32_t) rule_num > tpm_db.api_section[api_section].last_valid_entry))
-		tpm_db.api_section[api_section].last_valid_entry = (int32_t) rule_num;
-
-	(tpm_db.api_section[api_section].num_valid_entries)++;
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-		*rule_idx = l_rule_idx;
-		tpm_db_rule_index_incrs();
-	} else
-		*rule_idx = rule_num;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_invalidate()
-*
-* DESCRIPTION:      Invalidate an API Entry
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_num         - Rule number in the API range
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_invalidate(tpm_api_sections_t api_section, uint32_t rule_num)
-{
-	int32_t ind;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d), - rule_num(%d)\n", api_section, rule_num);
-
-	/* Find rule_num Index */
-	tpm_db_api_entry_ind_get(api_section, rule_num, &ind);
-	if (ind == -1)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " ind(%d), \n", ind);
-
-	/* Invalidate the entry on the api_table */
-	memset(&(API_ENT_I(api_section, ind)), 0, sizeof(tpm_db_api_entry_t));
-	API_ENT_I(api_section, ind).valid = TPM_DB_INVALID;
-
-	/* Decrease highest tbl_index if needed */
-	if (ind == tpm_db.api_section[api_section].last_valid_index)
-		tpm_db.api_section[api_section].last_valid_index--;
-
-	/* Decrease last_valid if needed */
-	if ((int32_t) rule_num == tpm_db.api_section[api_section].last_valid_entry)
-		tpm_db.api_section[api_section].last_valid_entry--;
-
-	/* Decrease the number of valid entries */
-	(tpm_db.api_section[api_section].num_valid_entries)--;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " last_valid_entry(%d), num_valid_entries(%d), \n",
-		     tpm_db.api_section[api_section].last_valid_entry,
-		     tpm_db.api_section[api_section].num_valid_entries);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_rulenum_inc()
-*
-* DESCRIPTION:      Increase rulenum of a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_inc_start   - Start of Range of API entries to increase the rule_num
-* rule_inc_end     - End of Range of API entries to increase the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_rulenum_inc(tpm_api_sections_t api_section, uint32_t rule_inc_start, uint32_t rule_inc_end)
-{
-	int32_t i;
-	int32_t ind, ret_code;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d) - range_inc_start(%d) range_inc_end(%d) \n",
-		     api_section, rule_inc_start, rule_inc_end);
-
-	if (rule_inc_end >= (tpm_db.api_section[api_section].table_size - 1)) {
-		TPM_OS_ERROR(TPM_DB_MOD, " for api_section(%d), - range_inc_end(%d) too large \n",
-			     api_section, rule_inc_end);
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Increase all entries */
-	for (i = rule_inc_end; i >= (int32_t) (rule_inc_start); i--) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-		(API_ENT_I(api_section, ind).rule_num)++;
-	}
-
-	/* Increase last_valid rule_num, if necessary */
-	if (tpm_db.api_section[api_section].last_valid_entry == (int32_t) rule_inc_end)
-		(tpm_db.api_section[api_section].last_valid_entry)++;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_rulenum_dec()
-*
-* DESCRIPTION:      Decrease rulenum of a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_dec_start   - Start of Range of API entries to decrease the rule_num
-* rule_dec_end     - End of Range of API entries to decrease the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_rulenum_dec(tpm_api_sections_t api_section, uint32_t rule_dec_start, uint32_t rule_dec_end)
-{
-
-	uint32_t i;
-	int32_t ind, ret_code;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d) - rule_dec_start(%d) rule_dec_end(%d) \n",
-		     api_section, rule_dec_start, rule_dec_end);
-
-	if (rule_dec_start == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "for api_section(%d) -  rule_dec_start cannot be 0\n", api_section);
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Decrease all entries */
-	for (i = rule_dec_start; i <= rule_dec_end; i++) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-		(API_ENT_I(api_section, ind).rule_num)--;
-	}
-
-	/* Decrease last_valid, if it equaled last in range */
-	if (tpm_db.api_section[api_section].last_valid_entry == (int32_t) rule_dec_end)
-		(tpm_db.api_section[api_section].last_valid_entry)--;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_specific_pnc_dec()
-*
-* DESCRIPTION:      Decrease the connected PCN entry of a specific pnc range
-*                   for a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* range_id         - Pnc range id
-* rule_inc_start   - Start of Range of API entries to decrease the rule_num
-* rule_inc_end     - End of Range of API entries to decrease the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_specific_pnc_dec(tpm_api_sections_t api_section,
-				    tpm_pnc_ranges_t range_id, uint32_t rule_inc_start, uint32_t rule_inc_end)
-{
-	uint32_t i, j;
-	int32_t ret_code, ind;
-	tpm_db_pnc_conn_t *pnc_tbl_conn;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d), range(%d) - rule_inc_start(%d) rule_inc_end(%d) \n",
-		     api_section, range_id, rule_inc_start, rule_inc_end);
-
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Increase pnc_entries of all rule_nums in the range */
-	for (i = rule_inc_start; i <= rule_inc_end; i++) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-		if (API_ENT_I(api_section, ind).valid == TPM_DB_INVALID)
-			continue;
-
-		pnc_tbl_conn = &(API_ENT_I(api_section, ind).pnc_tbl_conn);
-
-		/* Loop over all then pnc_entries of this api_entry */
-		for (j = 0; j < (pnc_tbl_conn->num_pnc_ranges); j++) {
-
-			if (pnc_tbl_conn->pnc_conn_tbl[j].pnc_range == (uint32_t) range_id)
-				pnc_tbl_conn->pnc_conn_tbl[j].pnc_index--;
-		}
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_specific_pnc_inc()
-*
-* DESCRIPTION:      Increase the connected PCN entry of a specific pnc range
-*                   for a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* range_id         - Pnc range id
-* rule_inc_start   - Start of Range of API entries to decrease the rule_num
-* rule_inc_end     - End of Range of API entries to decrease the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_specific_pnc_inc(tpm_api_sections_t api_section,
-				    tpm_pnc_ranges_t range_id, uint32_t rule_inc_start, uint32_t rule_inc_end)
-{
-	uint32_t i, j;
-	int32_t ret_code, ind;
-	tpm_db_pnc_conn_t *pnc_tbl_conn;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d), range(%d) - rule_inc_start(%d) rule_inc_end(%d) \n",
-		     api_section, range_id, rule_inc_start, rule_inc_end);
-
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Increase pnc_entries of all rule_nums in the range */
-	for (i = rule_inc_start; i <= rule_inc_end; i++) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-
-		pnc_tbl_conn = &(API_ENT_I(api_section, ind).pnc_tbl_conn);
-
-		/* Loop over all then pnc_entries of this api_entry */
-		for (j = 0; j < (pnc_tbl_conn->num_pnc_ranges); j++) {
-
-			if (pnc_tbl_conn->pnc_conn_tbl[j].pnc_range == (uint32_t) range_id)
-				pnc_tbl_conn->pnc_conn_tbl[j].pnc_index++;
-		}
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_conn_inc()
-*
-* DESCRIPTION:      Increase the connected PCN entry for a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_inc_start   - Start of Range of API entries to decrease the rule_num
-* rule_inc_end     - End of Range of API entries to decrease the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_conn_inc(tpm_api_sections_t api_section, uint32_t rule_inc_start, uint32_t rule_inc_end)
-{
-	int32_t i;
-	uint32_t j;
-	int32_t ind, ret_code;
-	tpm_db_pnc_conn_t *pnc_tbl_conn;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d) - rule_inc_start(%d) rule_inc_end(%d) \n",
-		     api_section, rule_inc_start, rule_inc_end);
-
-	if (rule_inc_end >= (tpm_db.api_section[api_section].table_size - 1)) {
-		TPM_OS_ERROR(TPM_DB_MOD, " for api_section(%d)- range_inc_end(%d) too large \n",
-			     api_section, rule_inc_end);
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Increase pnc_entries of all rule_nums in the range */
-	for (i = rule_inc_end; i >= (int32_t) (rule_inc_start); i--) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-		pnc_tbl_conn = &(API_ENT_I(api_section, ind).pnc_tbl_conn);
-
-		/* Loop over all then pnc_entries of this api_entry */
-		for (j = 0; j < (pnc_tbl_conn->num_pnc_ranges); j++) {
-			/* INcrease only the entries of the PNC Ranges that are TYPE_ACL */
-			ret_code = tpm_db_pnc_rng_conf_get(pnc_tbl_conn->pnc_conn_tbl[j].pnc_range, &range_conf);
-			IF_ERROR_I(ret_code, i);
-			if (range_conf.range_type == TPM_RANGE_TYPE_ACL)
-				pnc_tbl_conn->pnc_conn_tbl[j].pnc_index++;
-		}
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_conn_dec()
-*
-* DESCRIPTION:      Decrease the connected PCN entry for a range of API entries
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_dec_start   - Start of Range of API entries to decrease the rule_num
-* rule_dec_end     - End of Range of API entries to decrease the rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_conn_dec(tpm_api_sections_t api_section, uint32_t rule_dec_start, uint32_t rule_dec_end)
-{
-	uint32_t i, j;
-	int32_t ind, ret_code;
-	tpm_db_pnc_conn_t *pnc_tbl_conn;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d) - rule_dec_start(%d) rule_dec_end(%d) \n",
-		     api_section, rule_dec_start, rule_dec_end);
-
-	if (rule_dec_start == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, " for api_section(%d) - rule_dec_start is zero \n", api_section);
-		return (TPM_DB_ERR_INV_INPUT);
-	}
-
-	/* Decrease pnc_entries of all rule_nums in the range */
-	for (i = rule_dec_start; i <= rule_dec_end; i++) {
-		ret_code = tpm_db_api_entry_ind_get(api_section, i, &ind);
-		IF_ERROR_I(ret_code, i);
-		pnc_tbl_conn = &(API_ENT_I(api_section, ind).pnc_tbl_conn);
-
-		/* Loop over all then pnc_entries of this api_entry */
-		for (j = 0; j < (pnc_tbl_conn->num_pnc_ranges); j++) {
-			/* Decrease only the entries of the PNC Ranges that are TYPE_ACL */
-			ret_code = tpm_db_pnc_rng_conf_get(pnc_tbl_conn->pnc_conn_tbl[j].pnc_range, &range_conf);
-			IF_ERROR_I(ret_code, i);
-			if (range_conf.range_type == TPM_RANGE_TYPE_ACL)
-				pnc_tbl_conn->pnc_conn_tbl[j].pnc_index--;
-		}
-	}
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_tcam_num_get()
-*
-* DESCRIPTION:      Get API TCAM number according to API section and rule index
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_idx         - Unique Rule Identifier, that does not change over the life span of the rule.
-*
-* OUTPUTS:
-* tcam_num         - PnC TCAM number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_tcam_num_get(tpm_api_sections_t api_section, uint32_t rule_idx, uint32_t *tcam_num)
-{
-	int32_t ret_code;
-	uint32_t rule_num;
-	uint32_t dummy_idx;
-	uint32_t bi_dir;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0 };
-	tpm_db_pnc_conn_t pnc_con;
-
-	/* Get rule number */
-	ret_code = tpm_db_api_rulenum_get(api_section, rule_idx, &rule_num);
-	IF_ERROR(ret_code);
-
-	/* Get API entry */
-	ret_code = tpm_db_api_entry_get(api_section, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	/* Get TCAM number, always return the first TCAM number even there are multiple  */
-	/* TCAM entries to one rule index                                                */
-	*tcam_num = pnc_con.pnc_conn_tbl[0].pnc_index;
-
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_api_entry_update_rule_idx(tpm_api_sections_t api_section,
-						uint32_t rule_idx_pre,
-						uint32_t rule_idx_new)
-{
-	int32_t ind;
-	int32_t ret_code;
-	uint32_t rule_num = 0;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, " api_section(%d), - rule_num(%d)\n", api_section, rule_num);
-
-	/* Get the rule_num */
-	ret_code = tpm_db_api_rulenum_get(api_section, rule_idx_pre, &rule_num);
-	if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-		TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-		return ERR_RULE_IDX_INVALID;
-	}
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-
-	tpm_db_api_entry_ind_get(api_section, rule_num, &ind);
-	if (ind == -1)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	/* update rule_index */
-	API_ENT_I(api_section, ind).rule_idx = rule_idx_new;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_rulenum_get()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_idx         - Unique Rule Identifier, that does not change over the life span of the rule.
-*
-* OUTPUTS:
-* rule_num         - The API entry number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_rulenum_get(tpm_api_sections_t api_section, uint32_t rule_idx, uint32_t *rule_num)
-{
-	int32_t i;
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID && API_ENT_I(api_section, i).rule_idx == rule_idx) {
-			*rule_num = API_ENT_I(api_section, i).rule_num;
-			return (TPM_DB_OK);
-		}
-	}
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_api_rulenum_get_from_l2_key()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* parse_bm         - fields to be parsed in the key.
-* l2_key           - structure of l2_key
-*
-* OUTPUTS:
-* rule_num         - The API entry number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_rulenum_get_from_l2_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-					   tpm_l2_acl_key_t *l2_key, uint32_t *rule_num)
-{
-	int32_t i, cmp_res;
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID) {
-			cmp_res = memcmp(&(API_ENT_I(api_section, i).api_rule_data.l2_prim_key.l2_key),
-					 l2_key, sizeof(tpm_l2_acl_key_t));
-			if (cmp_res == 0) {	/* found entry */
-				/* check the parse_bm */
-				if (parse_rule_bm == API_ENT_I(api_section, i).api_rule_data.l2_prim_key.parse_rule_bm) {
-					*rule_num = API_ENT_I(api_section, i).rule_num;
-					return (TPM_DB_OK);
-				}
-			}
-		}
-	}
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_api_rulenum_get_from_l3_key()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* parse_bm         - fields to be parsed in the key.
-* l3_key           - structure of l3_key
-*
-* OUTPUTS:
-* rule_num         - The API entry number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_rulenum_get_from_l3_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-					   tpm_l3_type_key_t *l3_key, uint32_t *rule_num)
-{
-	int32_t i, cmp_res;
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID) {
-			cmp_res = memcmp(&API_ENT_I(api_section, i).api_rule_data.l3_type_key.l3_key,
-					 l3_key, sizeof(tpm_l3_type_key_t));
-			if (cmp_res == 0) {	/* found entry */
-				/* check the parse_bm */
-				if (parse_rule_bm == API_ENT_I(api_section, i).api_rule_data.l3_type_key.parse_rule_bm) {
-					*rule_num = API_ENT_I(api_section, i).rule_num;
-					return (TPM_DB_OK);
-				}
-			}
-		}
-	}
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_api_rulenum_get_from_ipv4_key()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* parse_bm         - fields to be parsed in the key.
-* ipv4_key         - structure of ipv4_key
-*
-* OUTPUTS:
-* rule_num         - The API entry number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_rulenum_get_from_ipv4_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-					     tpm_ipv4_acl_key_t *ipv4_key, uint32_t *rule_num)
-{
-	int32_t i, cmp_res;
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID) {
-			cmp_res = memcmp(&API_ENT_I(api_section, i).api_rule_data.ipv4_key.ipv4_key,
-					 ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-			if (cmp_res == 0) {	/* found entry */
-				/* check the parse_bm */
-				if (parse_rule_bm == API_ENT_I(api_section, i).api_rule_data.ipv4_key.parse_rule_bm) {
-					*rule_num = API_ENT_I(api_section, i).rule_num;
-					return (TPM_DB_OK);
-				}
-			}
-		}
-	}
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_api_rulenum_get_from_ipv6_key()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* parse_bm         - fields to be parsed in the key.
-* ipv6_key         - structure of ipv6_key
-*
-* OUTPUTS:
-* rule_num         - The API entry number
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_rulenum_get_from_ipv6_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-					     tpm_ipv6_acl_key_t *ipv6_key, uint32_t *rule_num)
-{
-	int32_t i, cmp_res;
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (API_ENT_I(api_section, i).valid == TPM_DB_VALID) {
-			cmp_res = memcmp(&API_ENT_I(api_section, i).api_rule_data.ipv6_key.ipv6_key,
-					 ipv6_key, sizeof(tpm_ipv6_acl_key_t));
-			if (cmp_res == 0) {	/* found entry */
-				/* check the parse_bm */
-				if (parse_rule_bm == API_ENT_I(api_section, i).api_rule_data.ipv6_key.parse_rule_bm) {
-					*rule_num = API_ENT_I(api_section, i).rule_num;
-					return (TPM_DB_OK);
-				}
-			}
-		}
-	}
-	return (TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_get()
-*
-* DESCRIPTION:      Get  API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* rule_num         - The API entry number
-*
-* OUTPUTS:
-* rule_idx         - Unique Rule Identifier, that does not change over the life span of the rule.
-* bi_dir           - Is this rule bi-directional (currently not used)
-* api_data         - All config information received for this API call
-* mod_con          - Connection to modification tables
-* pnc_con          - Connection to PNC
-*
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_get(tpm_api_sections_t api_section,
-			     uint32_t rule_num,
-			     uint32_t *rule_idx,
-			     uint32_t *bi_dir,
-			     tpm_rule_entry_t *api_data, tpm_db_mod_conn_t *mod_con, tpm_db_pnc_conn_t *pnc_con)
-{
-	int32_t ind;
-
-	tpm_db_api_entry_ind_get(api_section, rule_num, &ind);
-	if (ind == -1)
-		return (TPM_DB_ERR_REC_NOT_EXIST);
-
-	memcpy(api_data, &(API_ENT_I(api_section, ind).api_rule_data), sizeof(tpm_rule_entry_t));
-	memcpy(mod_con, &(API_ENT_I(api_section, ind).mod_tbl_conn), sizeof(tpm_db_mod_conn_t));
-	memcpy(pnc_con, &(API_ENT_I(api_section, ind).pnc_tbl_conn), sizeof(tpm_db_pnc_conn_t));
-	*bi_dir = API_ENT_I(api_section, ind).bi_dir;
-	*rule_idx = API_ENT_I(api_section, ind).rule_idx;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_api_entry_valid_get_next()
-*
-* DESCRIPTION:      Get  Next API Entry  Data
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* cur_rule          - The current rule_num in  the API Range.
-*                     Function returns the next valid rule number next_rule  > cur_rule
-*
-* OUTPUTS:
-* next_rule        - See cur_rule. If end of table was reached before valid entry, (-1) is returned in next_rule
-*                    All of the following outputs relate to rule_num=next_rule.
-* rule_idx         - See tpm_db_api_entry_get
-* bi_dir           - See tpm_db_api_entry_get
-* api_data         - See tpm_db_api_entry_get
-* mod_con          - See tpm_db_api_entry_get
-* pnc_con          - See tpm_db_api_entry_get
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_api_entry_val_get_next(tpm_api_sections_t api_section,
-				      int32_t cur_rule,
-				      int32_t *next_rule,
-				      uint32_t *rule_idx,
-				      uint32_t *bi_dir,
-				      tpm_rule_entry_t *api_data,
-				      tpm_db_mod_conn_t *mod_con, tpm_db_pnc_conn_t *pnc_con)
-{
-	int32_t ind = -1;
-	int32_t i;
-	uint32_t min_rule, l_next_rule = ~0;
-	tpm_db_api_entry_t *api_tbl = &(API_ENT_I(api_section, 0));
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "api_section(%d) cur_rule(%d)\n", api_section, cur_rule); */
-
-	if (cur_rule <= -1)
-		min_rule = 0;
-	else
-		min_rule = cur_rule + 1;
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "min_rule(%d) \n", min_rule); */
-
-	for (i = 0; i <= tpm_db.api_section[api_section].last_valid_index; i++) {
-		if (((api_tbl + i)->valid == TPM_DB_VALID) &&
-		    ((api_tbl + i)->rule_num >= min_rule) && ((api_tbl + i)->rule_num < l_next_rule)) {
-			l_next_rule = (api_tbl + i)->rule_num;
-			ind = i;
-		}
-	}
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "l_next_rule(%d) ind(%d) \n", l_next_rule, ind); */
-
-	if ((l_next_rule < (uint32_t) (~0)) && (ind != -1)) {
-		memcpy(api_data, &(API_ENT_I(api_section, ind).api_rule_data), sizeof(tpm_rule_entry_t));
-		memcpy(mod_con, &(API_ENT_I(api_section, ind).mod_tbl_conn), sizeof(tpm_db_mod_conn_t));
-		memcpy(pnc_con, &(API_ENT_I(api_section, ind).pnc_tbl_conn), sizeof(tpm_db_pnc_conn_t));
-		*bi_dir = API_ENT_I(api_section, ind).bi_dir;
-		*rule_idx = API_ENT_I(api_section, ind).rule_idx;
-
-		*next_rule = l_next_rule;
-	} else		/* Not found */
-		*next_rule = -1;
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "next_rule(%d) \n", *next_rule); */
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_shdw_ent_set()
-*
-* DESCRIPTION:      Set PNC  Entry in Shadow Table
-*
-* INPUTS:
-* pnc_entry       - PnC Entry
-*
-* OUTPUTS:
-* pnc_data        - PnC Data
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_shdw_ent_set(uint32_t pnc_entry, tpm_pnc_all_t *pnc_data)
-{
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "pnc_entry(%d)\n", pnc_entry);
-	if (pnc_entry >= TPM_PNC_SIZE)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.pnc_shadow[pnc_entry].valid = TPM_DB_VALID;
-	memcpy(&(tpm_db.pnc_shadow[pnc_entry].pnc_data), pnc_data, sizeof(tpm_pnc_all_t));
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_shdw_ent_inv()
-*
-* DESCRIPTION:      Invalidate PNC  Entry in Shadow Table
-*
-* INPUTS:
-* pnc_entry       - PnC Entry
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_shdw_ent_inv(uint32_t pnc_entry)
-{
-	if (pnc_entry >= TPM_PNC_SIZE)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memset(&(tpm_db.pnc_shadow[pnc_entry].pnc_data), 0, sizeof(tpm_pnc_all_t));
-	tpm_db.pnc_shadow[pnc_entry].valid = TPM_DB_INVALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_shdw_ent_get()
-*
-* DESCRIPTION:      Get PNC Entry from Shadow Table
-*
-* INPUTS:
-* pnc_entry       - PnC Entry
-*
-* OUTPUTS:
-* valid           - Is the PNC Entry valid in Shadow
-* pnc_data        - PnC Data
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_shdw_ent_get(uint32_t pnc_entry, uint32_t *valid, tpm_pnc_all_t *pnc_data)
-{
-	if (pnc_entry >= TPM_PNC_SIZE)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memcpy(pnc_data, &(tpm_db.pnc_shadow[pnc_entry].pnc_data), sizeof(tpm_pnc_all_t));
-	if (tpm_db.pnc_shadow[pnc_entry].valid == TPM_DB_VALID)
-		*valid = TPM_TRUE;
-	else
-		*valid = TPM_FALSE;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mod_shdw_par_check()
-*
-* DESCRIPTION:      Function checks legality of modification table params
-*
-* INPUTS:
-* gmac            - GMAC In
-* entry           - modification entry
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mod_shdw_par_check(tpm_gmacs_enum_t gmac, uint32_t mod_entry)
-{
-	if ((mod_entry >= TPM_MOD_TABL_SIZE)
-	    || /*(gmac < TPM_ENUM_GMAC_0) || */ (gmac >= TPM_MAX_NUM_GMACS))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_pnc_shdw_ent_del()
-*
-* DESCRIPTION:      Function deletes a PNC entry and "pushes up" the PNC Range
-*
-* INPUTS:
-* pnc_start_entry   -
-* pnc_stop_entry    -
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_shdw_ent_del(uint32_t pnc_start_entry, uint32_t pnc_stop_entry)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "pnc_start_entry(%d) pnc_stop_entry(%d)\n", pnc_start_entry, pnc_stop_entry);
-
-	if ((pnc_start_entry >= TPM_PNC_SIZE) || (pnc_stop_entry >= TPM_PNC_SIZE))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	/* Push up the existing range, except for the first one that is deleted */
-	for (i = pnc_start_entry; i < pnc_stop_entry; i++)
-		memcpy(&(tpm_db.pnc_shadow[i]), &(tpm_db.pnc_shadow[i + 1]), sizeof(tpm_db_pnc_shadow_t));
-
-	/* Set last entry in range to invalid */
-	memset(&(tpm_db.pnc_shadow[pnc_stop_entry].pnc_data), 0, sizeof(tpm_pnc_all_t));
-	tpm_db.pnc_shadow[pnc_stop_entry].valid = TPM_DB_INVALID;
-
-	return (TPM_DB_OK);
-
-}
-
-/*******************************************************************************
-* tpm_db_pnc_shdw_ent_ins()
-*
-* DESCRIPTION:      Function inserts an empty entry into a PNC Range ("pushes down the range")
-*
-* INPUTS:
-* pnc_start_entry   -
-* pnc_stop_entry    -
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_pnc_shdw_ent_ins(uint32_t pnc_start_entry, uint32_t pnc_stop_entry)
-{
-	int32_t i;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "pnc_start_entry(%d) pnc_stop_entry(%d)\n", pnc_start_entry, pnc_stop_entry);
-
-	if ((pnc_start_entry >= (TPM_PNC_SIZE - 1)) || (pnc_stop_entry >= (TPM_PNC_SIZE - 1)))
-		return (TPM_DB_ERR_INV_INPUT);
-
-	/* Push down the existing range */
-	for (i = (int32_t) pnc_stop_entry; i >= (int32_t) pnc_start_entry; i--)
-		memcpy(&(tpm_db.pnc_shadow[i + 1]), &(tpm_db.pnc_shadow[i]), sizeof(tpm_db_pnc_shadow_t));
-
-	/* Set empty (invalid) entry */
-	memset(&(tpm_db.pnc_shadow[pnc_start_entry].pnc_data), 0, sizeof(tpm_pnc_all_t));
-	tpm_db.pnc_shadow[pnc_start_entry].valid = TPM_DB_INVALID;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mod_etype_sel_get()
-*
-* DESCRIPTION:      Get select of Vlan Ethertype
-*
-* INPUTS:
-* tpid            - Requested Vlan tpid
-*
-*
-* OUTPUTS:
-* etype_sel       - selector that matches this tpid
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mod_etype_sel_get(uint32_t tpid, uint32_t *etype_sel)
-{
-	uint32_t i;
-
-	if (etype_sel == NULL) {
-		TPM_OS_DEBUG(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
-		if (tpm_db.vlan_etype[i].tpid_ether_type == tpid && tpm_db.vlan_etype[i].valid == TPM_DB_VALID) {
-			*etype_sel = i;
-			return (TPM_DB_OK);
-		}
-	}
-	return (TPM_DB_ERR_REC_EXIST);
-}
-
-/*******************************************************************************
-* tpm_db_mod_etype_sel_free_get()
-*
-* DESCRIPTION:      Get an unused tpid selector
-*
-* INPUTS:
-*
-* OUTPUTS:
-* etype_sel       - selector
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mod_etype_sel_free_get(uint32_t *etype_sel)
-{
-	uint32_t i;
-
-	if (etype_sel == NULL) {
-		TPM_OS_DEBUG(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
-		if (tpm_db.vlan_etype[i].valid == TPM_DB_INVALID) {
-			*etype_sel = i;
-			return (TPM_DB_OK);
-		}
-	}
-
-	return (TPM_DB_ERR_DB_TBL_FULL);
-}
-
-/*******************************************************************************
-* tpm_db_mod_etype_sel_set()
-*
-* DESCRIPTION:      Set a tpid in a selector
-*
-* INPUTS:
-* tpid            - Requested Vlan tpid
-* etype_sel       - selector that matches this tpid
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mod_etype_sel_set(uint32_t tpid, uint32_t etype_sel)
-{
-	if (etype_sel >= TPM_NUM_VLAN_ETYPE_REGS) {
-		TPM_OS_DEBUG(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	tpm_db.vlan_etype[etype_sel].valid = TPM_DB_VALID;
-	tpm_db.vlan_etype[etype_sel].tpid_ether_type = tpid;
-
-	return (TPM_DB_OK);
-}
-
-void tpm_db_set_mc_filter_mode(uint32_t mode)
-{
-	tpm_db.igmp_def.filter_mode = mode;
-}
-
-uint32_t tpm_db_get_mc_filter_mode(void)
-{
-	return tpm_db.igmp_def.filter_mode;
-}
-
-void tpm_db_set_mc_pppoe_enable(uint32_t enable)
-{
-	tpm_db.igmp_def.mc_pppoe_enable = enable;
-}
-
-uint8_t tpm_db_get_mc_pppoe_enable(void)
-{
-	return tpm_db.igmp_def.mc_pppoe_enable;
-}
-void tpm_db_split_mod_set_enable(tpm_db_split_mod_enable_t enable)
-{
-	tpm_db.split_mod_conf.split_mod_enable = enable;
-}
-
-tpm_db_split_mod_enable_t tpm_db_split_mod_get_enable(void)
-{
-	return tpm_db.split_mod_conf.split_mod_enable;
-}
-
-void tpm_db_split_mod_set_num_vlans(uint32_t num_vlans)
-{
-	/* as default, vlan 0 is added during Init */
-	tpm_db.split_mod_conf.num_vlans = (num_vlans + TPM_DB_SPLIT_MOD_INIT_VLANS_NUM);
-}
-
-uint32_t tpm_db_split_mod_get_num_vlans(void)
-{
-	return tpm_db.split_mod_conf.num_vlans;
-}
-void tpm_db_split_mod_set_mode(tpm_db_split_mod_mode_t mode)
-{
-	tpm_db.split_mod_conf.split_mod_mode = mode;
-}
-
-tpm_db_split_mod_mode_t tpm_db_split_mod_get_mode(void)
-{
-	return tpm_db.split_mod_conf.split_mod_mode;
-}
-void tpm_db_split_mod_set_num_p_bits(uint32_t num_p_bits, uint8_t  p_bits[TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX])
-{
-	tpm_db.split_mod_conf.num_p_bits = num_p_bits;
-	memcpy(&(tpm_db.split_mod_conf.p_bits), p_bits, TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX);
-}
-
-uint32_t tpm_db_split_mod_get_num_p_bits(void)
-{
-	return tpm_db.split_mod_conf.num_p_bits;
-}
-int32_t tpm_db_split_mod_get_p_bits_by_index(uint8_t  index, uint8_t  *p_bits)
-{
-	if (p_bits == NULL)
-		return TPM_DB_ERR_INV_INPUT;
-
-	*p_bits = index;
-	return TPM_DB_OK;
-}
-int32_t tpm_db_split_mod_get_index_by_p_bits(uint8_t  p_bits, uint32_t *index)
-{
-	uint32_t i;
-	for(i = 0; i < tpm_db.split_mod_conf.num_p_bits; i++)
-		if (p_bits == tpm_db.split_mod_conf.p_bits[i]) {
-			*index = p_bits;
-			return TPM_DB_OK;
-		}
-
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-#if 0
-void tpm_db_set_mc_igmp_mode(uint32_t mode)
-{
-   tpm_db.igmp_def.igmp_mode = mode;
-}
-
-uint32_t tpm_db_get_mc_igmp_mode(void)
-{
-   return tpm_db.igmp_def.igmp_mode;
-}
-#endif
-void tpm_db_set_mc_per_uni_vlan_xlate(uint32_t enable)
-{
-	tpm_db.igmp_def.per_uni_vlan_xlat = enable;
-}
-
-uint8_t tpm_db_get_mc_per_uni_vlan_xlate(void)
-{
-	return tpm_db.igmp_def.per_uni_vlan_xlat;
-}
-
-void tpm_db_set_mc_hwf_queue(uint8_t hwf_queue)
-{
-	tpm_db.igmp_def.mc_hwf_queue = hwf_queue;
-}
-
-uint8_t tpm_db_get_mc_hwf_queue(void)
-{
-	return tpm_db.igmp_def.mc_hwf_queue;
-}
-
-void tpm_db_set_mc_cpu_queue(uint8_t cpu_queue)
-{
-	tpm_db.igmp_def.mc_cpu_queue = cpu_queue;
-}
-
-uint8_t tpm_db_get_mc_cpu_queue(void)
-{
-	return tpm_db.igmp_def.mc_cpu_queue;
-}
-
-void tpm_db_set_mc_igmp_proxy_sa_mac(uint8_t *sa_mac)
-{
-	memcpy(tpm_db_mc_igmp_proxy_sa_mac, sa_mac, 6 * sizeof(uint8_t));
-	tpm_db_mc_igmp_proxy_sa_mac_valid = 1;
-}
-
-void tpm_db_get_mc_igmp_proxy_sa_mac(uint8_t *sa_mac, uint8_t *valid)
-{
-	*valid = tpm_db_mc_igmp_proxy_sa_mac_valid;
-	if (tpm_db_mc_igmp_proxy_sa_mac_valid)
-		memcpy(sa_mac, tpm_db_mc_igmp_proxy_sa_mac, 6 * sizeof(uint8_t));
-}
-
-void tpm_db_set_mc_lpbk_enable(tpm_ip_ver_t ver, uint8_t enable)
-{
-	if (ver < TPM_IP_VER_MAX)
-		tpm_db.igmp_def.mc_lpbk_enable[ver] = enable;
-}
-
-void tpm_db_get_mc_lpbk_enable(tpm_ip_ver_t ver, uint8_t *enable)
-{
-	if (ver < TPM_IP_VER_MAX)
-		*enable = tpm_db.igmp_def.mc_lpbk_enable[ver];
-}
-
-int32_t tpm_db_set_mc_stream_entry(uint32_t stream_num, tpm_db_mc_stream_entry_t *mc_stream)
-{
-	if (tpm_db_mc_stream_table[stream_num] == NULL) {
-		tpm_db_mc_stream_table[stream_num] =
-		/*(tpm_db_mc_stream_entry_t *)*/ kmalloc(sizeof(tpm_db_mc_stream_entry_t), GFP_KERNEL);
-		if (tpm_db_mc_stream_table[stream_num] == NULL)
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-
-		memcpy(tpm_db_mc_stream_table[stream_num], mc_stream, sizeof(tpm_db_mc_stream_entry_t));
-	} else {
-		if (tpm_db_mc_stream_table[stream_num]->igmp_mode == mc_stream->igmp_mode &&
-		    tpm_db_mc_stream_table[stream_num]->mc_stream_pppoe == mc_stream->mc_stream_pppoe &&
-		    tpm_db_mc_stream_table[stream_num]->vid == mc_stream->vid &&
-		    tpm_db_mc_stream_table[stream_num]->src_valid == mc_stream->src_valid &&
-		    !memcmp(tpm_db_mc_stream_table[stream_num]->src_addr, mc_stream->src_addr, 4 * sizeof(uint8_t)) &&
-		    !memcmp(tpm_db_mc_stream_table[stream_num]->group_addr, mc_stream->group_addr, 4 * sizeof(uint8_t))) {
-			tpm_db_mc_stream_table[stream_num]->dest_port_bm = mc_stream->dest_port_bm;
-			tpm_db_mc_stream_table[stream_num]->u4_entry = mc_stream->u4_entry;
-		} else
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_mc_stream_entry(uint32_t stream_num, tpm_db_mc_stream_entry_t *mc_stream)
-{
-	if (tpm_db_mc_stream_table[stream_num] == NULL)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	memcpy(mc_stream, tpm_db_mc_stream_table[stream_num], sizeof(tpm_db_mc_stream_entry_t));
-	return TPM_DB_OK;
-}
-
-void tpm_db_reset_mc_stream_entry(uint32_t stream_num)
-{
-	if (tpm_db_mc_stream_table[stream_num] != NULL) {
-		kfree(tpm_db_mc_stream_table[stream_num]);
-		tpm_db_mc_stream_table[stream_num] = NULL;
-	}
-}
-
-int32_t tpm_db_set_ipv6_mc_stream_entry(uint32_t stream_num, tpm_db_ipv6_mc_stream_entry_t *mc_stream)
-{
-	if (0 == tpm_db.ipv6_mc_stream[stream_num].valid) {
-		memcpy(&(tpm_db.ipv6_mc_stream[stream_num]), mc_stream, sizeof(tpm_db_ipv6_mc_stream_entry_t));
-		tpm_db.ipv6_mc_stream[stream_num].valid = 1;
-	} else {
-		if (tpm_db.ipv6_mc_stream[stream_num].igmp_mode == mc_stream->igmp_mode &&
-			tpm_db.ipv6_mc_stream[stream_num].mc_stream_pppoe == mc_stream->mc_stream_pppoe &&
-			tpm_db.ipv6_mc_stream[stream_num].vid == mc_stream->vid &&
-			!memcmp(tpm_db.ipv6_mc_stream[stream_num].group_addr, mc_stream->group_addr, 16 * sizeof(uint8_t))) {
-			tpm_db.ipv6_mc_stream[stream_num].dest_port_bm = mc_stream->dest_port_bm;
-			tpm_db.ipv6_mc_stream[stream_num].u4_entry = mc_stream->u4_entry;
-		} else
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv6_mc_stream_entry(uint32_t stream_num, tpm_db_ipv6_mc_stream_entry_t *mc_stream)
-{
-	if (0 == tpm_db.ipv6_mc_stream[stream_num].valid)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	memcpy(mc_stream, &(tpm_db.ipv6_mc_stream[stream_num]), sizeof(tpm_db_ipv6_mc_stream_entry_t));
-	return TPM_DB_OK;
-}
-
-void tpm_db_reset_ipv6_mc_stream_entry(uint32_t stream_num)
-{
-	memset(&(tpm_db.ipv6_mc_stream[stream_num]), 0, sizeof(tpm_db_ipv6_mc_stream_entry_t));
-}
-
-int32_t tpm_db_increase_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port)
-{
-	uint32_t entry_id, first_free = TPM_MC_MAX_MAC_NUM;
-	uint32_t port_nr;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MAC_NUM; entry_id++) {
-		if (tpm_db_mc_mac_table[entry_id] != NULL) {
-			if (!memcmp(tpm_db_mc_mac_table[entry_id]->mac_addr, mac_addr, 6 * sizeof(uint8_t)))
-				break;
-		} else if (first_free == TPM_MC_MAX_MAC_NUM)
-			first_free = entry_id;
-	}
-
-	if (entry_id == TPM_MC_MAX_MAC_NUM) {
-		if (first_free == TPM_MC_MAX_MAC_NUM)
-			return TPM_DB_ERR_DB_TBL_FULL;
-
-		tpm_db_mc_mac_table[first_free] =
-		/*(tpm_db_mc_mac_entry_t *)*/ kmalloc(sizeof(tpm_db_mc_mac_entry_t), GFP_KERNEL);
-		if (tpm_db_mc_mac_table[first_free] == NULL)
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-
-		memset(tpm_db_mc_mac_table[first_free], 0, sizeof(tpm_db_mc_mac_entry_t));
-		memcpy(tpm_db_mc_mac_table[first_free]->mac_addr, mac_addr, 6 * sizeof(uint8_t));
-		entry_id = first_free;
-	}
-
-	switch (uni_port) {
-	case TPM_TRG_UNI_0:	port_nr = TPM_SRC_PORT_UNI_0;	break;
-	case TPM_TRG_UNI_1:	port_nr = TPM_SRC_PORT_UNI_1;	break;
-	case TPM_TRG_UNI_2:	port_nr = TPM_SRC_PORT_UNI_2;	break;
-	case TPM_TRG_UNI_3:	port_nr = TPM_SRC_PORT_UNI_3;	break;
-	case TPM_TRG_UNI_4:	port_nr = TPM_SRC_PORT_UNI_4;	break;
-	case TPM_TRG_UNI_5:	port_nr = TPM_SRC_PORT_UNI_5;	break;
-	case TPM_TRG_UNI_6:	port_nr = TPM_SRC_PORT_UNI_6;	break;
-	case TPM_TRG_UNI_7:	port_nr = TPM_SRC_PORT_UNI_7;	break;
-	case TPM_TRG_UNI_VIRT:	port_nr = TPM_SRC_PORT_UNI_VIRT;break;
-	default:
-		return TPM_DB_ERR_INV_INPUT;
-	}
-	tpm_db_mc_mac_table[entry_id]->user_num[port_nr] += 1;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_decrease_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port)
-{
-	uint32_t entry_id;
-	uint32_t port_nr;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MAC_NUM; entry_id++) {
-		if (tpm_db_mc_mac_table[entry_id] != NULL) {
-			if (!memcmp(tpm_db_mc_mac_table[entry_id]->mac_addr, mac_addr, 6 * sizeof(uint8_t)))
-				break;
-		}
-	}
-
-	if (entry_id == TPM_MC_MAX_MAC_NUM)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	switch (uni_port) {
-	case TPM_TRG_UNI_0:	port_nr = TPM_SRC_PORT_UNI_0;	break;
-	case TPM_TRG_UNI_1:	port_nr = TPM_SRC_PORT_UNI_1;	break;
-	case TPM_TRG_UNI_2:	port_nr = TPM_SRC_PORT_UNI_2;	break;
-	case TPM_TRG_UNI_3:	port_nr = TPM_SRC_PORT_UNI_3;	break;
-	case TPM_TRG_UNI_4:	port_nr = TPM_SRC_PORT_UNI_4;	break;
-	case TPM_TRG_UNI_5:	port_nr = TPM_SRC_PORT_UNI_5;	break;
-	case TPM_TRG_UNI_6:	port_nr = TPM_SRC_PORT_UNI_6;	break;
-	case TPM_TRG_UNI_7:	port_nr = TPM_SRC_PORT_UNI_7;	break;
-	case TPM_TRG_UNI_VIRT:	port_nr = TPM_SRC_PORT_UNI_VIRT;break;
-	default:
-		return TPM_DB_ERR_INV_INPUT;
-	}
-	tpm_db_mc_mac_table[entry_id]->user_num[port_nr] -= 1;
-
-	return TPM_DB_OK;
-}
-
-uint8_t tpm_db_get_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port)
-{
-	uint32_t entry_id;
-	uint32_t port_nr;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MAC_NUM; entry_id++) {
-		if (tpm_db_mc_mac_table[entry_id] != NULL) {
-			if (!memcmp(tpm_db_mc_mac_table[entry_id]->mac_addr, mac_addr, 6 * sizeof(uint8_t)))
-				break;
-		}
-	}
-
-	if (entry_id == TPM_MC_MAX_MAC_NUM)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	switch (uni_port) {
-	case TPM_TRG_UNI_0:	port_nr = TPM_SRC_PORT_UNI_0;	break;
-	case TPM_TRG_UNI_1:	port_nr = TPM_SRC_PORT_UNI_1;	break;
-	case TPM_TRG_UNI_2:	port_nr = TPM_SRC_PORT_UNI_2;	break;
-	case TPM_TRG_UNI_3:	port_nr = TPM_SRC_PORT_UNI_3;	break;
-	case TPM_TRG_UNI_4:	port_nr = TPM_SRC_PORT_UNI_4;	break;
-	case TPM_TRG_UNI_5:	port_nr = TPM_SRC_PORT_UNI_5;	break;
-	case TPM_TRG_UNI_6:	port_nr = TPM_SRC_PORT_UNI_6;	break;
-	case TPM_TRG_UNI_7:	port_nr = TPM_SRC_PORT_UNI_7;	break;
-	case TPM_TRG_UNI_VIRT:	port_nr = TPM_SRC_PORT_UNI_VIRT;break;
-	default:
-		return 0;
-	}
-
-	if (TRG_UNI(uni_port)) {
-		if (port_nr < TPM_MAX_NUM_UNI_PORTS)
-			return tpm_db_mc_mac_table[entry_id]->user_num[port_nr];
-	}
-
-	return 0;
-}
-
-void tpm_db_reset_mc_mac_entry(uint8_t *mac_addr)
-{
-	uint32_t entry_id;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MAC_NUM; entry_id++) {
-		if (tpm_db_mc_mac_table[entry_id] != NULL) {
-			if (!memcmp(tpm_db_mc_mac_table[entry_id]->mac_addr, mac_addr, 6 * sizeof(uint8_t))) {
-				kfree(tpm_db_mc_mac_table[entry_id]);
-				tpm_db_mc_mac_table[entry_id] = NULL;
-				return;
-			}
-		}
-	}
-}
-
-uint32_t tpm_db_mc_lpbk_entries_num_get(void)
-{
-	return tpm_db_mc_lpbk_entries_num;
-}
-
-int32_t tpm_db_mc_lpbk_entry_set(uint32_t ip_ver, uint16_t mvlan, uint16_t in_vid, uint16_t out_vid, uint32_t rule_num,
-				 uint32_t mod_entry)
-{
-	static uint32_t _rule_index = 1000;
-	uint32_t entry_id, first_free = TPM_MC_MAX_MVLAN_XITS_NUM;
-	tpm_db_mc_lpbk_entry_t *lpbk_entry = NULL;
-	tpm_db_mc_vlan_entry_t *mvlan_entry = NULL;
-
-	if (rule_num >= TPM_MC_MAX_LPBK_ENTRIES_NUM)
-		return TPM_DB_ERR_DB_TBL_FULL;
-
-	if (rule_num > tpm_db_mc_lpbk_entries_num)
-		return TPM_DB_ERR_INV_INPUT;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MVLAN_XITS_NUM; entry_id++) {
-		if (tpm_db_mc_vlan_xits_table[entry_id] != NULL) {
-			if (mvlan == tpm_db_mc_vlan_xits_table[entry_id]->mvlan &&
-				ip_ver == tpm_db_mc_vlan_xits_table[entry_id]->ip_ver) {
-				mvlan_entry = tpm_db_mc_vlan_xits_table[entry_id];
-				break;
-			}
-		} else if (first_free == TPM_MC_MAX_MVLAN_XITS_NUM)
-			first_free = entry_id;
-	}
-
-	if (entry_id == TPM_MC_MAX_MVLAN_XITS_NUM) {
-		if (first_free == TPM_MC_MAX_MVLAN_XITS_NUM)
-			return TPM_DB_ERR_DB_TBL_FULL;
-
-		mvlan_entry = /*(tpm_db_mc_vlan_entry_t *)*/ kmalloc(sizeof(tpm_db_mc_vlan_entry_t), GFP_KERNEL);
-		if (mvlan_entry == NULL)
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-
-		memset(mvlan_entry, 0, sizeof(tpm_db_mc_vlan_entry_t));
-		mvlan_entry->mvlan = mvlan;
-		mvlan_entry->ip_ver = ip_ver;
-
-		tpm_db_mc_vlan_xits_table[first_free] = mvlan_entry;
-	}
-
-	first_free = TPM_DB_MAX_TRANSITION_NUM;
-
-	for (entry_id = 0; entry_id < TPM_DB_MAX_TRANSITION_NUM; entry_id++) {
-		if (mvlan_entry->xits[entry_id].valid == 0) {
-			first_free = entry_id;
-			break;
-		}
-	}
-
-	if (first_free == TPM_DB_MAX_TRANSITION_NUM)
-		return TPM_DB_ERR_DB_TBL_FULL;
-
-	lpbk_entry = /*(tpm_db_mc_lpbk_entry_t *)*/ kmalloc(sizeof(tpm_db_mc_lpbk_entry_t), GFP_KERNEL);
-	if (lpbk_entry == NULL)
-		return TPM_DB_ERR_MEM_ALLOC_FAIL;
-
-	memset(lpbk_entry, 0, sizeof(tpm_db_mc_lpbk_entry_t));
-
-	mvlan_entry->xits[first_free].valid = 1;
-	mvlan_entry->xits[first_free].in_vid = in_vid;
-	mvlan_entry->xits[first_free].out_vid = out_vid;
-	mvlan_entry->xits[first_free].lpbk_entry = lpbk_entry;
-	mvlan_entry->xits_num++;
-
-	_rule_index++;
-
-	lpbk_entry->rule_index = _rule_index;
-	lpbk_entry->mod_cmd = mod_entry;
-
-	for (entry_id = tpm_db_mc_lpbk_entries_num; entry_id > rule_num; entry_id--)
-		tpm_db_mc_lpbk_table[entry_id] = tpm_db_mc_lpbk_table[entry_id - 1];
-
-	tpm_db_mc_lpbk_table[rule_num] = lpbk_entry;
-	tpm_db_mc_lpbk_entries_num++;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mc_vlan_xits_num_get(uint32_t ip_ver, uint16_t mvlan, uint32_t *xits_num)
-{
-	uint32_t entry_id;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MVLAN_XITS_NUM; entry_id++) {
-		if (tpm_db_mc_vlan_xits_table[entry_id] != NULL) {
-			if (tpm_db_mc_vlan_xits_table[entry_id]->mvlan == mvlan &&
-				tpm_db_mc_vlan_xits_table[entry_id]->ip_ver == ip_ver) {
-				*xits_num = tpm_db_mc_vlan_xits_table[entry_id]->xits_num;
-				return TPM_DB_OK;
-			}
-		}
-	}
-
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-int32_t tpm_db_mc_vlan_xit_entry_get(uint32_t ip_ver, uint16_t mvlan, uint32_t xit_id, uint32_t *rule_index, uint32_t *mod_entry)
-{
-	uint32_t entry_id, xit_cnt = 0;
-	uint8_t found;
-	tpm_db_mc_vlan_entry_t *mvlan_entry = NULL;
-	tpm_db_mc_lpbk_entry_t *lpbk_entry = NULL;
-
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MVLAN_XITS_NUM; entry_id++) {
-		if (tpm_db_mc_vlan_xits_table[entry_id] != NULL) {
-			if (tpm_db_mc_vlan_xits_table[entry_id]->mvlan == mvlan &&
-				tpm_db_mc_vlan_xits_table[entry_id]->ip_ver == ip_ver) {
-				mvlan_entry = tpm_db_mc_vlan_xits_table[entry_id];
-				break;
-			}
-		}
-	}
-
-	if (mvlan_entry == NULL)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	found = 0;
-	for (entry_id = 0; entry_id < TPM_DB_MAX_TRANSITION_NUM; entry_id++) {
-		if (xit_cnt == xit_id) {
-			found = 1;
-			break;
-		}
-		xit_cnt++;
-	}
-
-	if (found == 0)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	lpbk_entry = mvlan_entry->xits[entry_id].lpbk_entry;
-
-	*rule_index = lpbk_entry->rule_index;
-	*mod_entry = lpbk_entry->mod_cmd;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mc_lpbk_rule_num_get(uint32_t rule_index, uint32_t *rule_num)
-{
-	uint32_t entry_id;
-
-	for (entry_id = 0; entry_id < tpm_db_mc_lpbk_entries_num; entry_id++) {
-		if (tpm_db_mc_lpbk_table[entry_id] != NULL) {
-			if (tpm_db_mc_lpbk_table[entry_id]->rule_index == rule_index) {
-				*rule_num = entry_id;
-				return TPM_DB_OK;
-			}
-		}
-	}
-
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-int32_t tpm_db_mc_lpbk_entry_invalidate(uint32_t rule_num)
-{
-	uint32_t entry_id, xit_id;
-	uint8_t found;
-	tpm_db_mc_lpbk_entry_t *lpbk_entry = NULL;
-	tpm_db_mc_vlan_entry_t *mvlan_entry = NULL;
-
-	if (rule_num > tpm_db_mc_lpbk_entries_num)
-		return TPM_DB_ERR_INV_INPUT;
-
-	lpbk_entry = tpm_db_mc_lpbk_table[rule_num];
-
-	for (entry_id = rule_num; entry_id < (tpm_db_mc_lpbk_entries_num - 1); entry_id++)
-		tpm_db_mc_lpbk_table[entry_id] = tpm_db_mc_lpbk_table[entry_id + 1];
-
-	kfree(lpbk_entry);
-	tpm_db_mc_lpbk_table[tpm_db_mc_lpbk_entries_num - 1] = NULL;
-	tpm_db_mc_lpbk_entries_num--;
-
-	found = 0;
-	for (entry_id = 0; entry_id < TPM_MC_MAX_MVLAN_XITS_NUM; entry_id++) {
-		mvlan_entry = tpm_db_mc_vlan_xits_table[entry_id];
-		if (mvlan_entry != NULL) {
-			if (mvlan_entry->xits_num > 0) {
-				for (xit_id = 0; xit_id < TPM_DB_MAX_TRANSITION_NUM; xit_id++) {
-					if (mvlan_entry->xits[xit_id].valid) {
-						if (lpbk_entry == mvlan_entry->xits[xit_id].lpbk_entry) {
-							mvlan_entry->xits[xit_id].valid = 0;
-							found = 1;
-							break;
-						}
-					}
-				}
-
-				if (found) {
-					mvlan_entry->xits_num--;
-					if (mvlan_entry->xits_num == 0) {
-						kfree(mvlan_entry);
-						tpm_db_mc_vlan_xits_table[entry_id] = NULL;
-					}
-					break;
-				}
-			}
-		}
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mc_alloc_virt_uni_entry(uint32_t *entry_id)
-{
-	uint32_t free;
-
-	for (free = 0; free < TPM_MC_MAX_STREAM_NUM; free++) {
-		if (tpm_db_mc_virt_uni_entry_state_table[free] == 0) {
-			tpm_db_mc_virt_uni_entry_state_table[free] = 1;
-			*entry_id = free;
-			return TPM_DB_OK;
-		}
-	}
-
-	return TPM_DB_ERR_DB_TBL_FULL;
-}
-
-int32_t tpm_db_mc_free_virt_uni_entry(uint32_t entry_id)
-{
-	if (entry_id >= TPM_MC_MAX_STREAM_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	tpm_db_mc_virt_uni_entry_state_table[entry_id] = 0;
-	return TPM_DB_OK;
-}
-
-void tpm_db_mc_rule_reset(void)
-{
-	uint32_t i;
-
-	/* Reset multicast stream table */
-	for (i = 0; i < TPM_MC_MAX_STREAM_NUM; i++) {
-		if (tpm_db_mc_stream_table[i] != NULL) {
-			kfree(tpm_db_mc_stream_table[i]);
-			tpm_db_mc_stream_table[i] = NULL;
-		}
-	}
-
-	/* Reset multicast mac table */
-	for (i = 0; i < TPM_MC_MAX_MAC_NUM; i++) {
-		if (tpm_db_mc_mac_table[i] != NULL) {
-			kfree(tpm_db_mc_mac_table[i]);
-			tpm_db_mc_mac_table[i] = NULL;
-		}
-	}
-
-	/* Reset multicast loopback tables */
-	tpm_db_mc_lpbk_entries_num = 0;
-	for (i = 0; i < TPM_MC_MAX_LPBK_ENTRIES_NUM; i++) {
-		if (tpm_db_mc_lpbk_table[i] != NULL) {
-			kfree(tpm_db_mc_lpbk_table[i]);
-			tpm_db_mc_lpbk_table[i] = NULL;
-		}
-	}
-
-	for (i = 0; i < TPM_MC_MAX_MVLAN_XITS_NUM; i++) {
-		if (tpm_db_mc_vlan_xits_table[i] != NULL) {
-			kfree(tpm_db_mc_vlan_xits_table[i]);
-			tpm_db_mc_vlan_xits_table[i] = NULL;
-		}
-	}
-
-	/* Reset state table of virt_uni entries */
-	memset(tpm_db_mc_virt_uni_entry_state_table, 0, TPM_MC_MAX_STREAM_NUM * sizeof(uint8_t));
-
-	/* reset IPv6 MC rule */
-	memset(tpm_db.ipv6_mc_stream, 0, sizeof(tpm_db.ipv6_mc_stream));
-
-}
-int32_t tpm_db_mc_vlan_get_ai_bit_by_vid(uint32_t mc_vlan, uint32_t *ai_bit)
-{
-	uint32_t i;
-	int32_t ret_val;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vlan(%d) \n", mc_vlan);
-
-	/* first, get ai bits if mc vlan already exists */
-	ret_val = tpm_db_mc_vlan_get_ai_bit(mc_vlan, ai_bit);
-	if (TPM_DB_OK == ret_val) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc vlan already exists, ai bits(%d)\n", *ai_bit);
-		return TPM_DB_OK;
-	}
-
-	/* alloc a new ai bits */
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if (!tpm_db.mc_ai_bits_table[i].valid) {
-			tpm_db.mc_ai_bits_table[i].valid = true;
-			tpm_db.mc_ai_bits_table[i].mc_vlan = mc_vlan;
-			tpm_db.mc_ai_bits_table[i].pnc_index_num = 0;
-			memset(tpm_db.mc_ai_bits_table[i].pnc_index, 0xff,
-			       sizeof(tpm_db.mc_ai_bits_table[i].pnc_index));
-			*ai_bit = i;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " alloc a new ai bits(%d)\n", i);
-			return TPM_DB_OK;
-		}
-	}
-	return (TPM_DB_ERR_DB_TBL_FULL);
-}
-
-bool tpm_db_mc_vlan_l2_rule_exist(uint32_t mc_vlan, uint32_t rule_num)
-{
-	uint32_t loop_in;
-	uint32_t i;
-	uint32_t ret_code;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pnc_range_conf_t rangConf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vlan(%d), rule_num(%d) \n", mc_vlan, rule_num);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_L2_PRIM_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	if (TPM_OK != ret_code) {
-		TPM_OS_ERROR(TPM_DB_MOD, " recvd ret_code(%d)\n", ret_code);
-		return false;
-	}
-
-	if (TPM_RANGE_TYPE_TABLE != rangConf.range_type) {
-		/* not TABLE mode */
-		return false;
-	}
-
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((mc_vlan == tpm_db.mc_ai_bits_table[i].mc_vlan) && (tpm_db.mc_ai_bits_table[i].valid)) {
-			for (loop_in = 0; loop_in < TPM_MC_VLAN_MAX_PNC_RULE_NUM; loop_in++) {
-				if (rule_num == tpm_db.mc_ai_bits_table[i].pnc_index[loop_in])
-					return true;
-			}
-		}
-	}
-	return false;
-}
-
-int32_t tpm_db_mc_vlan_set_ai_bit_pnc_index(uint32_t mc_vlan, uint32_t l2_pnc_rule_index)
-{
-	uint32_t i;
-	uint32_t loop_in;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vlan(%d) l2_pnc_rule_index(%d)\n", mc_vlan, l2_pnc_rule_index);
-
-	/* in table mode, and rule_num already exist, do not record again */
-	if (tpm_db_mc_vlan_l2_rule_exist(mc_vlan, l2_pnc_rule_index))
-		return TPM_DB_OK;
-
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((mc_vlan == tpm_db.mc_ai_bits_table[i].mc_vlan) && (tpm_db.mc_ai_bits_table[i].valid)) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " ai_index(%d)\n", i);
-			for (loop_in = 0; loop_in < TPM_MC_VLAN_MAX_PNC_RULE_NUM; loop_in++) {
-				if (~0 == tpm_db.mc_ai_bits_table[i].pnc_index[loop_in]) {
-					tpm_db.mc_ai_bits_table[i].pnc_index[loop_in] = l2_pnc_rule_index;
-					tpm_db.mc_ai_bits_table[i].pnc_index_num++;
-					return TPM_DB_OK;
-				}
-			}
-			return TPM_DB_ERR_DB_TBL_FULL;
-		}
-	}
-	return (TPM_DB_ERR_DB_TBL_FULL);
-}
-
-int32_t tpm_db_mc_vlan_get_pnc_index_free_slot(uint32_t mc_vlan, uint32_t rule_num)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vlan(%d) \n", mc_vlan);
-
-	/* in table mode, and rule_num already exist, always has free slot */
-	if (tpm_db_mc_vlan_l2_rule_exist(mc_vlan, rule_num))
-		return 1;
-
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((mc_vlan == tpm_db.mc_ai_bits_table[i].mc_vlan) && (tpm_db.mc_ai_bits_table[i].valid)) {
-
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " ai_index(%d), pnc_index_num(%d)\n",
-				i, tpm_db.mc_ai_bits_table[i].pnc_index_num);
-			/* ACL mode */
-			if (TPM_MC_VLAN_MAX_PNC_RULE_NUM <= tpm_db.mc_ai_bits_table[i].pnc_index_num)
-				return 0;
-			return (TPM_MC_VLAN_MAX_PNC_RULE_NUM - tpm_db.mc_ai_bits_table[i].pnc_index_num);
-		}
-	}
-	return TPM_MC_VLAN_MAX_PNC_RULE_NUM;
-}
-
-int32_t tpm_db_mc_vlan_reset_ai_bit(uint32_t l2_pnc_rule_index)
-{
-	uint32_t i;
-	uint32_t loop_in;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "l2_pnc_rule_index(%d)\n", l2_pnc_rule_index);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if (!tpm_db.mc_ai_bits_table[i].valid)
-			continue;
-
-		for (loop_in = 0; loop_in < TPM_MC_VLAN_MAX_PNC_RULE_NUM; loop_in++) {
-			if (l2_pnc_rule_index == tpm_db.mc_ai_bits_table[i].pnc_index[loop_in]) {
-				tpm_db.mc_ai_bits_table[i].pnc_index_num--;
-				tpm_db.mc_ai_bits_table[i].pnc_index[loop_in] = ~0;
-
-				if (0 == tpm_db.mc_ai_bits_table[i].pnc_index_num) {
-					TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " remove this mc vlan(%d), ai_bits(%d)\n",
-						     tpm_db.mc_ai_bits_table[i].mc_vlan, i);
-					tpm_db.mc_ai_bits_table[i].valid = false;
-					tpm_db.mc_ai_bits_table[i].mc_vlan = 0;
-					memset(tpm_db.mc_ai_bits_table[i].pnc_index, 0xff,
-					       sizeof(tpm_db.mc_ai_bits_table[i].pnc_index));
-				} else {
-					TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-						     " decrease pnc_index_num of this mc vlan(%d), pnc_index_num(%d)\n",
-						     tpm_db.mc_ai_bits_table[i].mc_vlan,
-						     tpm_db.mc_ai_bits_table[i].pnc_index_num);
-				}
-
-				return TPM_DB_OK;
-			}
-		}
-		continue;
-	}
-	return (TPM_DB_ERR_DB_TBL_FULL);
-}
-
-int32_t tpm_db_mc_vlan_reset_mc_vlan(uint32_t mc_vlan)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vlan);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((tpm_db.mc_ai_bits_table[i].valid) && (mc_vlan == tpm_db.mc_ai_bits_table[i].mc_vlan)) {
-			if (0 == tpm_db.mc_ai_bits_table[i].pnc_index_num) {
-				tpm_db.mc_ai_bits_table[i].valid = false;
-				tpm_db.mc_ai_bits_table[i].mc_vlan = 0;
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " reset this vlan(%d)\n", mc_vlan);
-			}
-			return TPM_DB_OK;
-		}
-	}
-	return (TPM_DB_ERR_DB_TBL_FULL);
-}
-
-int32_t tpm_db_mc_vlan_get_ai_bit(uint32_t mc_vlan, uint32_t *ai_bit)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vlan);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if (mc_vlan == tpm_db.mc_ai_bits_table[i].mc_vlan) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " ai_index(%d)\n", i);
-			*ai_bit = i;
-			return TPM_DB_OK;
-		}
-	}
-	return (TPM_DB_ERR_INV_INPUT);
-}
-
-int32_t tpm_db_set_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if (false == tpm_db.mc_vid_port_cfg[i].valid) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vid_index(%d)\n", i);
-			tpm_db.mc_vid_port_cfg[i].valid = true;
-			tpm_db.mc_vid_port_cfg[i].mc_vid = mc_vid;
-			memcpy(&tpm_db.mc_vid_port_cfg[i].mc_vid_port_vids, mc_vid_uniports_config,
-			       sizeof(tpm_mc_vid_port_vid_set_t));
-			return TPM_DB_OK;
-		}
-	}
-	return (TPM_DB_ERR_INV_INPUT);
-}
-
-int32_t tpm_db_get_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_cfg_t **mc_vid_uniports_config)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((true == tpm_db.mc_vid_port_cfg[i].valid) && (mc_vid == tpm_db.mc_vid_port_cfg[i].mc_vid)) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vid_index(%d)\n", i);
-			*mc_vid_uniports_config = &(tpm_db.mc_vid_port_cfg[i].mc_vid_port_vids[0]);
-			return TPM_DB_OK;
-		}
-	}
-
-	return (TPM_DB_ERR_INV_INPUT);
-}
-
-bool tpm_db_mc_vid_exist(uint32_t mc_vid)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((true == tpm_db.mc_vid_port_cfg[i].valid) && (mc_vid == tpm_db.mc_vid_port_cfg[i].mc_vid)) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vid_index(%d)\n", i);
-			return true;
-		}
-	}
-	return (false);
-}
-
-uint32_t tpm_db_remove_mc_vid_cfg(uint32_t mc_vid)
-{
-	uint32_t i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if ((true == tpm_db.mc_vid_port_cfg[i].valid) && (mc_vid == tpm_db.mc_vid_port_cfg[i].mc_vid)) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mc_vid_index(%d)\n", i);
-			tpm_db.mc_vid_port_cfg[i].valid = false;
-			tpm_db.mc_vid_port_cfg[i].mc_vid = 0;
-			return TPM_DB_OK;
-		}
-	}
-	return (TPM_DB_ERR_INV_INPUT);
-}
-/*******************************************************************************
-* tpm_db_mc_cfg_reset()
-*
-* DESCRIPTION:      Reset MC configuration part in DB. Set all structures to 0,
-*                   and all valid fields to false
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_db_mc_cfg_reset(void)
-{
-    memset(&tpm_db.mc_ai_bits_table, 0, sizeof(tpm_db.mc_ai_bits_table));
-    memset(&tpm_db.mc_vid_port_cfg, 0, sizeof(tpm_db.mc_vid_port_cfg));
-
-    tpm_db_mc_igmp_proxy_sa_mac_valid = 0;
-    memset(tpm_db_mc_igmp_proxy_sa_mac, 0, 6 * sizeof(uint8_t));
-
-    return;
-}
-
-void tpm_db_mod2_init_jump_area_cfg(void)
-{
-	tpm_db_mod2_jump_area_cfg.base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.total_num = 0;
-	tpm_db_mod2_jump_area_cfg.split_num = 0;
-
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_PMAC] = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_GMAC_0] = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_GMAC_1] = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_PMAC] = TPM_MOD2_NULL_ENT_IDX;
-
-	tpm_db_mod2_jump_area_cfg.split_pbit_num = 0;
-}
-
-void tpm_db_mod2_init_chain_cfg(void)
-{
-	tpm_mod2_multicast_mh_enable = 1;
-	tpm_mod2_pppoe_add_mod_enable = 1;
-	tpm_mod2_double_tag_enable = 1;
-	tpm_mod2_udp_checksum_use_init_bm_enable = 0;
-	tpm_mod2_udp_checksum_enable = 1;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].subr_chain = 1;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].max_size = TPM_MOD2_MAX_MH_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].subr_chain = 1;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].max_size = TPM_MOD2_MAX_MAC_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].subr_chain = 1;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].max_size = TPM_MOD2_MAX_VLAN_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].subr_chain = 1;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].max_size = TPM_MOD2_MAX_PPPOE_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].subr_chain = 1;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].max_size = TPM_MOD2_MAX_IPV6_PPPOE_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].subr_chain = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].max_size = TPM_MOD2_MAX_L2_TWO_TAG_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].subr_chain = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].max_size = TPM_MOD2_MAX_IPV4_NAPT_W_PPPOE_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].subr_chain = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].max_size = TPM_MOD2_MAX_IPV4_MC_W_MH_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].subr_chain = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].max_size = TPM_MOD2_MAX_ROUTE_W_PPPOE_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].base_entry = TPM_MOD2_NULL_ENT_IDX;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].subr_chain = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].max_size = TPM_MOD2_MAX_IPV6_MC_W_MH_CHAIN_SIZE;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num = 0;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].next_free[TPM_ENUM_GMAC_0] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].next_free[TPM_ENUM_GMAC_1] = TPM_MOD2_INVALID_CHAIN_ID;
-	tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].next_free[TPM_ENUM_PMAC] = TPM_MOD2_INVALID_CHAIN_ID;
-
-}
-
-void tpm_db_mod2_init_pmt_info(void)
-{
-	tpm_mod2_chain_area_base = TPM_MOD2_NULL_ENT_IDX;
-	tpm_mod2_total_chain_num = 0;
-
-	memset(tpm_db_mod2_jump_pmt_info, 0, TPM_MAX_NUM_GMACS * sizeof(tpm_mod2_jump_pmt_info_t *));
-	memset(tpm_db_mod2_chain_pmt_info, 0, TPM_MAX_NUM_GMACS * sizeof(tpm_mod2_jump_pmt_info_t *));
-}
-
-void tpm_db_mod2_init_chain_info(void)
-{
-	memset(tpm_db_mod2_jump_booked_entry_bm, 0, TPM_MAX_NUM_GMACS * sizeof(uint32_t *));
-	memset(tpm_db_mod2_jump_occupied_entry_bm, 0, TPM_MAX_NUM_GMACS * sizeof(uint32_t *));
-
-	tpm_db_mod2_jump_bm_group = 0;
-
-	memset(tpm_db_mod2_chain_booked_entry_bm, 0, TPM_MAX_NUM_GMACS * TPM_CHAIN_TYPE_MAX * sizeof(uint32_t *));
-	memset(tpm_db_mod2_chain_occupied_entry_bm, 0, TPM_MAX_NUM_GMACS * TPM_CHAIN_TYPE_MAX * sizeof(uint32_t *));
-
-	memset(tpm_db_mod2_chain_bm_group, 0, TPM_CHAIN_TYPE_MAX * sizeof(uint32_t));
-
-	memset(tpm_db_mod2_chain_info, 0, TPM_MAX_NUM_GMACS * TPM_CHAIN_TYPE_MAX * sizeof(tpm_mod2_chain_info_t *));
-}
-
-void tpm_db_mod2_set_chain_num(tpm_chain_type_t chain_type, uint16_t chain_num)
-{
-	if (chain_type < TPM_CHAIN_TYPE_MAX && chain_type != TPM_CHAIN_TYPE_NONE)
-		tpm_db_mod2_chain_cfg[chain_type].total_num = chain_num;
-}
-
-uint16_t tpm_db_mod2_get_chain_max_size(tpm_chain_type_t chain_type)
-{
-	if (chain_type < TPM_CHAIN_TYPE_MAX && chain_type != TPM_CHAIN_TYPE_NONE)
-		return tpm_db_mod2_chain_cfg[chain_type].max_size;
-
-	return 0;
-}
-
-void tpm_db_mod2_set_multicast_mh_state(uint8_t enable)
-{
-	if (enable) {
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].max_size = TPM_MOD2_MAX_IPV4_MC_W_MH_CHAIN_SIZE;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].max_size = TPM_MOD2_MAX_IPV6_MC_W_MH_CHAIN_SIZE;
-	} else {
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].max_size = TPM_MOD2_MAX_IPV4_MC_WO_MH_CHAIN_SIZE;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].max_size = TPM_MOD2_MAX_IPV6_MC_WO_MH_CHAIN_SIZE;
-	}
-
-	tpm_mod2_multicast_mh_enable = enable;
-}
-
-uint8_t tpm_db_mod2_get_multicast_mh_state(void)
-{
-	return tpm_mod2_multicast_mh_enable;
-}
-
-void tpm_db_mod2_set_pppoe_add_mod_state(uint8_t enable)
-{
-	if (enable) {
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].max_size = TPM_MOD2_MAX_IPV4_NAPT_W_PPPOE_CHAIN_SIZE;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].max_size = TPM_MOD2_MAX_ROUTE_W_PPPOE_CHAIN_SIZE;
-	} else {
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].max_size = TPM_MOD2_MAX_IPV4_NAPT_WO_PPPOE_CHAIN_SIZE;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].max_size = TPM_MOD2_MAX_ROUTE_WO_PPPOE_CHAIN_SIZE;
-	}
-
-	tpm_mod2_pppoe_add_mod_enable = enable;
-}
-
-uint8_t tpm_db_mod2_get_pppoe_add_mod_state(void)
-{
-	return tpm_mod2_pppoe_add_mod_enable;
-}
-
-void tpm_db_mod2_set_double_tag_state(uint8_t enable)
-{
-	if (enable)
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].max_size = TPM_MOD2_MAX_L2_TWO_TAG_CHAIN_SIZE;
-	else
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].max_size = TPM_MOD2_MAX_L2_ONE_TAG_CHAIN_SIZE;
-
-	tpm_mod2_double_tag_enable = enable;
-}
-
-uint8_t tpm_db_mod2_get_double_tag_state(void)
-{
-	return tpm_mod2_double_tag_enable;
-}
-
-void tpm_db_mod2_set_udp_checksum_use_init_bm_state(uint8_t enable)
-{
-	tpm_mod2_udp_checksum_use_init_bm_enable = enable;
-}
-
-uint8_t tpm_db_mod2_get_udp_checksum_init_bm_state(void)
-{
-	return tpm_mod2_udp_checksum_use_init_bm_enable;
-}
-
-void tpm_db_mod2_set_udp_checksum_state(uint8_t enable)
-{
-	tpm_mod2_udp_checksum_enable = enable;
-}
-
-uint8_t tpm_db_mod2_get_udp_checksum_state(void)
-{
-	return tpm_mod2_udp_checksum_enable;
-}
-
-int32_t tpm_db_mod2_set_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id, tpm_mod2_entry_t *pattern)
-{
-	tpm_mod2_jump_pmt_info_t *info_p = NULL;
-
-	if (pattern == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (entry_id >= tpm_db_mod2_jump_area_cfg.total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	info_p = &tpm_db_mod2_jump_pmt_info[gmac_port][entry_id];
-
-	if (info_p->status != TPM_MOD_ENTRY_BOOKED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	memcpy(&(info_p->pattern), pattern, sizeof(tpm_mod2_entry_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_activate_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id)
-{
-	tpm_mod2_jump_pmt_info_t *info_p = NULL;
-	uint32_t i, j, mask;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (entry_id >= tpm_db_mod2_jump_area_cfg.total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	info_p = &tpm_db_mod2_jump_pmt_info[gmac_port][entry_id];
-
-	if (info_p->status != TPM_MOD_ENTRY_BOOKED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-	/* TODO: Check if the entry is split mod entry */
-
-	i = j = 0;
-	j = entry_id & 0x1f;
-	i = entry_id >> 5;
-	mask = 1 << j;
-
-	tpm_db_mod2_jump_booked_entry_bm[gmac_port][i] &= ~mask;
-
-	if (tpm_db_mod2_jump_split_mod_all_entry_bm[gmac_port][i] & mask) {
-		/* this is a split mod entry */
-		info_p->status = TPM_MOD_ENTRY_SPLIT_MOD;
-		tpm_db_mod2_jump_split_mod_occupied_entry_bm[gmac_port][i] |= mask;
-	}
-	else {
-		info_p->status = TPM_MOD_ENTRY_OCCUPIED;
-		tpm_db_mod2_jump_occupied_entry_bm[gmac_port][i] |= mask;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_get_jump_entry_pattern_data(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-						tpm_mod2_entry_t *pattern)
-{
-	tpm_mod2_jump_pmt_info_t *info_p = NULL;
-
-	if (pattern == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (entry_id >= tpm_db_mod2_jump_area_cfg.total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	info_p = &tpm_db_mod2_jump_pmt_info[gmac_port][entry_id];
-
-	if (    (info_p->status != TPM_MOD_ENTRY_OCCUPIED)
-		 && (info_p->status != TPM_MOD_ENTRY_SPLIT_MOD)) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	memcpy(pattern, &(info_p->pattern), sizeof(tpm_mod2_entry_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_del_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id)
-{
-	tpm_mod2_jump_pmt_info_t *info_p = NULL;
-	uint32_t i, j, mask;
-	/*uint16_t jump_to; */
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (entry_id >= tpm_db_mod2_jump_area_cfg.total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	info_p = &tpm_db_mod2_jump_pmt_info[gmac_port][entry_id];
-
-	if (   info_p->status != TPM_MOD_ENTRY_OCCUPIED
-		&& info_p->status != TPM_MOD_ENTRY_SPLIT_MOD) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	/* delete jump entry in db */
-	memset(info_p, 0, sizeof(tpm_mod2_jump_pmt_info_t));
-
-	/* TODO: Check if the entry is split mod entry */
-
-	info_p->status = TPM_MOD_ENTRY_FREE;
-
-	i = j = 0;
-	j = entry_id & 0x1f;
-	i = entry_id >> 5;
-	mask = 1 << j;
-
-	if (tpm_db_mod2_jump_split_mod_all_entry_bm[gmac_port][i] & mask) {
-		/* this is a split mod pmt entry */
-		tpm_db_mod2_jump_split_mod_occupied_entry_bm[gmac_port][i] &= ~mask;
-	}
-	else {
-		tpm_db_mod2_jump_occupied_entry_bm[gmac_port][i] &= ~mask;
-	}
-
-    tpm_db_mod2_flush_jump_area(gmac_port, entry_id, 1, 0);
-
-	return TPM_DB_OK;
-}
-
-uint16_t tpm_db_mod2_find_matched_chain(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t total_num,
-					tpm_mod2_chain_info_t *chains, tpm_mod2_chain_pmt_info_t *pmt_data,
-					uint16_t entry_num, tpm_mod2_entry_t *pattern)
-{
-	uint16_t chain_id, entry_id;
-	uint32_t bm_idx, data;
-	uint32_t *booked_bm = NULL, *occupied_bm = NULL;
-	tpm_mod2_chain_pmt_info_t *pmt_ptr = NULL;
-
-	booked_bm = tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type];
-	occupied_bm = tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type];
-
-	for (bm_idx = 0; bm_idx < tpm_db_mod2_chain_bm_group[chain_type]; bm_idx++) {
-		data = (booked_bm[bm_idx] | occupied_bm[bm_idx]);
-		if (data) {
-			chain_id = bm_idx << 5;	/* multiply 32 */
-			while (data) {
-				if (data & 0x1) {
-					if (entry_num == chains[chain_id].entry_num) {
-						pmt_ptr = &pmt_data[chains[chain_id].base_entry];
-						for (entry_id = 0; entry_id < entry_num; entry_id++) {
-							if (memcmp
-							    (&(pmt_ptr[entry_id].pattern), &pattern[entry_id],
-							     sizeof(tpm_mod2_entry_t))) {
-								break;
-							}
-						}
-
-						if (entry_id == entry_num)
-							return chain_id;
-					}
-				}
-				chain_id++;
-				data = data >> 1;
-			}
-		}
-	}
-
-	return TPM_MOD2_INVALID_CHAIN_ID;
-}
-
-void tpm_db_mod2_increase_chain_user(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num++;
-}
-
-void tpm_db_mod2_decrease_chain_user(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num != 0)
-		tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num--;
-}
-
-uint16_t tpm_db_mod2_chain_user_num(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	return tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num;
-}
-
-uint16_t tpm_db_mod2_get_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t entry_num,
-				     tpm_mod2_entry_t *pattern)
-{
-	if (pattern == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_MOD2_INVALID_CHAIN_ID;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_MOD2_INVALID_CHAIN_ID;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_MOD2_INVALID_CHAIN_ID;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (tpm_db_mod2_chain_pmt_info[gmac_port] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid pmt data\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	return tpm_db_mod2_find_matched_chain(gmac_port, chain_type,
-					      tpm_db_mod2_chain_cfg[chain_type].total_num,
-					      tpm_db_mod2_chain_info[gmac_port][chain_type],
-					      tpm_db_mod2_chain_pmt_info[gmac_port], entry_num, pattern);
-}
-
-int32_t tpm_db_mod2_set_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id,
-				    uint16_t entry_num, tpm_mod2_entry_t *pattern)
-{
-	uint16_t /*match_chain, */ base_offset, entry_idx;
-	tpm_mod2_chain_info_t *info_p;
-	tpm_mod2_chain_pmt_info_t *pmt_array;
-
-	if (pattern == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-	if (info_p->status == TPM_MOD_ENTRY_OCCUPIED) {
-		tpm_db_mod2_increase_chain_user(gmac_port, chain_type, chain_id);
-	} else if (info_p->status == TPM_MOD_ENTRY_BOOKED) {
-		if (tpm_db_mod2_chain_user_num(gmac_port, chain_type, chain_id) == 0) {
-			base_offset = tpm_db_mod2_chain_cfg[chain_type].base_entry - tpm_mod2_chain_area_base
-			    + chain_id * tpm_db_mod2_chain_cfg[chain_type].max_size;
-
-			pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][base_offset];
-
-			for (entry_idx = 0; entry_idx < entry_num; entry_idx++) {
-				if (pmt_array[entry_idx].status != TPM_MOD_ENTRY_FREE) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain status\n");
-					return TPM_DB_ERR_REC_STATUS_ERR;
-				}
-
-				pmt_array[entry_idx].status = TPM_MOD_ENTRY_BOOKED;
-				pmt_array[entry_idx].chain_type = chain_type;
-				pmt_array[entry_idx].chain_id = chain_id;
-				memcpy(&pmt_array[entry_idx].pattern, &pattern[entry_idx], sizeof(tpm_mod2_entry_t));
-			}
-
-			info_p->base_entry = base_offset;
-			info_p->entry_num = entry_num;
-		}
-
-		tpm_db_mod2_increase_chain_user(gmac_port, chain_type, chain_id);
-	} else {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_activate_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	tpm_mod2_chain_info_t *info_p;
-	uint32_t i, j, mask;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-
-	if (info_p->status == TPM_MOD_ENTRY_BOOKED) {
-		info_p->status = TPM_MOD_ENTRY_OCCUPIED;
-
-		i = j = 0;
-		j = chain_id & 0x1f;
-		i = chain_id >> 5;
-		mask = 1 << j;
-
-		tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type][i] &= ~mask;
-		tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type][i] |= mask;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_activate_chain_pmt_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	uint16_t base_offset, entry_idx, entry_num;
-	tpm_mod2_chain_info_t *info_p = NULL;
-	tpm_mod2_chain_pmt_info_t *pmt_array = NULL;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-
-	if (info_p->status != TPM_MOD_ENTRY_BOOKED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	base_offset = info_p->base_entry;
-	entry_num = info_p->entry_num;
-
-	pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][base_offset];
-
-	for (entry_idx = 0; entry_idx < entry_num; entry_idx++)
-		pmt_array[entry_idx].status = TPM_MOD_ENTRY_OCCUPIED;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_if_chain_pmt_entries_exist(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					       uint16_t chain_id, uint8_t *exist)
-{
-	uint16_t base_offset, entry_idx, entry_num;
-	tpm_mod2_chain_info_t *info_p = NULL;
-	tpm_mod2_chain_pmt_info_t *pmt_array = NULL;
-
-	if (exist == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-
-	*exist = 0;
-
-	if (info_p->status == TPM_MOD_ENTRY_BOOKED) {
-		base_offset = info_p->base_entry;
-		entry_num = info_p->entry_num;
-
-		pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][base_offset];
-
-		for (entry_idx = 0; entry_idx < entry_num; entry_idx++) {
-			if (pmt_array[entry_idx].status != TPM_MOD_ENTRY_OCCUPIED)
-				break;
-		}
-
-		if (entry_idx == entry_num)
-			*exist = 1;
-
-	} else if (info_p->status == TPM_MOD_ENTRY_OCCUPIED)
-		*exist = 1;
-	else {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_get_chain_entry_num(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					uint16_t chain_id, uint16_t *entry_num)
-{
-	tpm_mod2_chain_info_t *info_p;
-
-	if (entry_num == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	*entry_num = 0;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-	if (info_p->status != TPM_MOD_ENTRY_OCCUPIED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	*entry_num = info_p->entry_num;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_get_chain_entry_pattern_data(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-						 uint16_t chain_id, uint16_t pattern_id, tpm_mod2_entry_t *pattern)
-{
-	tpm_mod2_chain_info_t *info_p;
-	tpm_mod2_chain_pmt_info_t *entry_p;
-
-	if (pattern == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero chain\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	if (chain_id >= tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain index\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain info\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-	if (info_p->status != TPM_MOD_ENTRY_OCCUPIED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-
-	if (pattern_id >= info_p->entry_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid pattern index\n");
-		return TPM_DB_ERR_DB_TBL_INV;
-	}
-
-	entry_p = &tpm_db_mod2_chain_pmt_info[gmac_port][info_p->base_entry + pattern_id];
-	if (entry_p->status != TPM_MOD_ENTRY_OCCUPIED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid entry status\n");
-		return TPM_DB_ERR_REC_STATUS_ERR;
-	}
-	memcpy(pattern, &(entry_p->pattern), sizeof(tpm_mod2_entry_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_del_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	uint16_t /*entry_offset, chain_type, chain_id, */ entry_num, /*jump_to, */ entry_index;
-	uint8_t remove_it;
-	tpm_mod2_chain_info_t *info_p = NULL;
-	tpm_mod2_chain_pmt_info_t *pmt_array = NULL;
-	uint32_t i, j, mask;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain type \n");
-		return TPM_DB_ERR_REC_INV;
-	}
-
-	if (chain_id > tpm_db_mod2_chain_cfg[chain_type].total_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain id \n");
-		return TPM_DB_ERR_REC_INV;
-	}
-
-	info_p = &tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id];
-
-	if (info_p->status != TPM_MOD_ENTRY_OCCUPIED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid chain entry \n");
-		return TPM_DB_ERR_REC_INV;
-	}
-
-	pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][info_p->base_entry];
-
-	tpm_db_mod2_decrease_chain_user(gmac_port, chain_type, chain_id);
-
-	remove_it = 0;
-	if (tpm_db_mod2_chain_user_num(gmac_port, chain_type, chain_id) == 0)
-		remove_it = 1;
-
-	entry_num = info_p->entry_num;
-
-	for (entry_index = 0; entry_index < entry_num; entry_index++) {
-		if (remove_it) {
-			memset(&pmt_array[entry_index], 0, sizeof(tpm_mod2_chain_pmt_info_t));
-			pmt_array[entry_index].status = TPM_MOD_ENTRY_FREE;
-		}
-	}
-
-	if (remove_it) {
-		memset(info_p, 0, sizeof(tpm_mod2_chain_info_t));
-		info_p->status = TPM_MOD_ENTRY_FREE;
-
-		i = j = 0;
-		j = chain_id & 0x1f;
-		i = chain_id >> 5;
-		mask = 1 << j;
-
-		tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type][i] &= ~mask;
-
-		tpm_db_mod2_flush_chain_entry(gmac_port, chain_type, chain_id, 1, 0);
-	}
-
-	return TPM_DB_OK;
-}
-
-void tpm_db_mod2_update_next_free_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type)
-{
-	uint16_t chain_id;
-	uint32_t bm_idx, bit_idx, data;
-	uint32_t *booked_bm = NULL, *occupied_bm = NULL;
-
-	booked_bm = tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type];
-	occupied_bm = tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type];
-
-	for (bm_idx = 0; bm_idx < tpm_db_mod2_chain_bm_group[chain_type]; bm_idx++) {
-		data = ((booked_bm[bm_idx] | occupied_bm[bm_idx]) ^ 0xffffffff);
-		if (data) {
-			chain_id = bm_idx << 5;	/* multiply 32 */
-			bit_idx = 0;
-			while (data) {
-				if (data & 0x1) {
-					chain_id += bit_idx;
-					if (chain_id < tpm_db_mod2_chain_cfg[chain_type].total_num) {
-						tpm_db_mod2_chain_cfg[chain_type].next_free[gmac_port] = chain_id;
-						return;
-					}
-					break;
-				}
-				bit_idx++;
-				data = data >> 1;
-			}
-		}
-	}
-
-	tpm_db_mod2_chain_cfg[chain_type].next_free[gmac_port] = TPM_MOD2_INVALID_CHAIN_ID;
-	return;
-}
-
-uint16_t tpm_db_mod2_get_next_free_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type)
-{
-	uint16_t next_free;
-	uint32_t i, j, mask;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return TPM_MOD2_INVALID_CHAIN_ID;
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE)
-		return TPM_MOD2_INVALID_CHAIN_ID;
-
-	next_free = tpm_db_mod2_chain_cfg[chain_type].next_free[gmac_port];
-	if (next_free != TPM_MOD2_INVALID_CHAIN_ID) {
-		tpm_db_mod2_chain_info[gmac_port][chain_type][next_free].status = TPM_MOD_ENTRY_BOOKED;
-
-		i = j = 0;
-		j = TPM_DB_MOD_32(next_free);
-		i = TPM_DB_DIVIDED_BY_32(next_free);
-		mask = 1 << j;
-
-		tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type][i] |= mask;
-	}
-
-	tpm_db_mod2_update_next_free_chain_entry(gmac_port, chain_type);
-
-	return next_free;
-}
-
-uint16_t tpm_db_mod2_convert_chain_to_pmt_entry(tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-	tpm_mod2_chain_cfg_t *cfg_p = NULL;
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE)
-		return TPM_MOD2_NULL_ENT_IDX;
-
-	cfg_p = &tpm_db_mod2_chain_cfg[chain_type];
-
-	if (chain_id >= cfg_p->total_num)
-		return TPM_MOD2_NULL_ENT_IDX;
-
-	return (chain_id * cfg_p->max_size + cfg_p->base_entry);
-}
-
-int32_t tpm_db_mod2_get_chain_id_by_pmt_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-					      tpm_chain_type_t *chain_type, uint16_t *chain_id)
-{
-	uint16_t entry_offset;
-	tpm_mod2_chain_pmt_info_t *pmt_array = NULL;
-
-	if (chain_type == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_id == NULL) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (entry_id >= TPM_MOD2_TOTAL_PMT_SIZE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	entry_offset = entry_id - tpm_mod2_chain_area_base;
-	if (entry_offset >= tpm_mod2_total_chain_num) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][entry_offset];
-
-	if (pmt_array->status != TPM_MOD_ENTRY_OCCUPIED) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid pmt entry \n");
-		return TPM_DB_ERR_REC_INV;
-	}
-
-	*chain_type = pmt_array->chain_type;
-	*chain_id = pmt_array->chain_id;
-
-	return TPM_DB_OK;
-}
-
-void tpm_db_mod2_update_next_free_jump_entry(tpm_gmacs_enum_t gmac_port)
-{
-	uint16_t entry_id /*, total_num */ ;
-	/*tpm_mod2_jump_pmt_info_t *info_array = NULL; */
-	uint32_t bm_idx, bit_idx, data;
-	uint32_t *booked_bm = NULL, *occupied_bm = NULL, *split_mod_occupied_bm = NULL;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return;
-	}
-
-	booked_bm = tpm_db_mod2_jump_booked_entry_bm[gmac_port];
-	occupied_bm = tpm_db_mod2_jump_occupied_entry_bm[gmac_port];
-	split_mod_occupied_bm = tpm_db_mod2_jump_split_mod_all_entry_bm[gmac_port];
-#if 0
-	info_array = tpm_db_mod2_jump_pmt_info[gmac_port];
-	total_num  = tpm_db_mod2_jump_area_cfg.total_num;
-
-	for (entry_id = 0; entry_id < total_num; entry_id++)
-#endif
-	for (bm_idx = 0; bm_idx < tpm_db_mod2_jump_bm_group; bm_idx++) {
-		/*if (info_array[entry_id].status == TPM_MOD_ENTRY_FREE) */
-		data = ((booked_bm[bm_idx] | occupied_bm[bm_idx] | split_mod_occupied_bm[bm_idx]) ^ 0xffffffff);
-		if (data) {
-			entry_id = bm_idx << 5;	/* multiply 32 */
-			bit_idx = 0;
-			while (data) {
-				if (data & 0x1) {
-					entry_id += bit_idx;
-					if (entry_id < tpm_db_mod2_jump_area_cfg.total_num) {
-						tpm_db_mod2_jump_area_cfg.next_free[gmac_port] = entry_id;
-						return;
-					}
-					break;
-				}
-				bit_idx++;
-				data = data >> 1;
-			}
-		}
-	}
-
-	tpm_db_mod2_jump_area_cfg.next_free[gmac_port] = TPM_MOD2_NULL_ENT_IDX;
-	return;
-}
-
-uint16_t tpm_db_mod2_get_next_free_jump_entry(tpm_gmacs_enum_t gmac_port)
-{
-	uint16_t next_free;
-	uint32_t i, j, mask;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return TPM_MOD2_NULL_ENT_IDX;
-
-	next_free = tpm_db_mod2_jump_area_cfg.next_free[gmac_port];
-	if (next_free != TPM_MOD2_NULL_ENT_IDX) {
-		tpm_db_mod2_jump_pmt_info[gmac_port][next_free].status = TPM_MOD_ENTRY_BOOKED;
-
-		i = j = 0;
-		j = TPM_DB_MOD_32(next_free);
-		i = TPM_DB_DIVIDED_BY_32(next_free);
-		mask = 1 << j;
-
-		tpm_db_mod2_jump_booked_entry_bm[gmac_port][i] |= mask;
-	}
-
-	tpm_db_mod2_update_next_free_jump_entry(gmac_port);
-
-	return next_free;
-}
-
-uint32_t tpm_db_mod2_split_mod_get_vlan_num_in_use(tpm_gmacs_enum_t gmac_port)
-{
-	uint32_t i;
-	uint32_t vlan_num = 0;
-
-	for (i = 0; i < TPM_DB_SPLIT_MOD_NUM_VLANS_MAX; i++) {
-		if (tpm_db.split_mod_conf.gmac_vlan_conf[gmac_port].split_mod_vlan[i].valid)
-			vlan_num++;
-	}
-
-	return vlan_num;
-}
-
-uint16_t tpm_db_mod2_get_next_split_mod_free_jump_entry(tpm_gmacs_enum_t gmac_port, tpm_pkt_mod_t *mod_data)
-{
-	uint16_t next_free;
-	uint32_t i, j, mask;
-	uint32_t vlan_index, db_ret;
-	uint32_t  pbit_index = 0;
-	tpm_vlan_key_t  *vlan_out;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return TPM_MOD2_NULL_ENT_IDX;
-
-	db_ret = tpm_db_mod2_split_mod_get_vlan_index(gmac_port, mod_data, &vlan_index);
-	if (TPM_DB_OK != db_ret)
-		return TPM_MOD2_NULL_ENT_IDX;
-
-	/* get next_free pmt index from vid index */
-	if (0 == vlan_index)
-		/* first vlan, means vlan 0, default */
-		next_free = 1;
-	else
-		next_free = (16 * vlan_index);
-
-	if (VLANOP_EXT_TAG_MOD_INS == mod_data->vlan_mod.vlan_op)
-		vlan_out = &mod_data->vlan_mod.vlan2_out;
-	else
-		vlan_out = &mod_data->vlan_mod.vlan1_out;
-
-	if (0 == vlan_out->pbit_mask)
-		/* pbit AS_IS */
-		pbit_index = 0;
-	else {
-		pbit_index = vlan_out->pbit;
-		if (next_free != 1)
-			pbit_index++;
-	}
-
-	next_free += pbit_index;
-
-	if (next_free != TPM_MOD2_NULL_ENT_IDX) {
-		tpm_db_mod2_jump_pmt_info[gmac_port][next_free].status = TPM_MOD_ENTRY_BOOKED;
-
-		i = j = 0;
-		j = TPM_DB_MOD_32(next_free);
-		i = TPM_DB_DIVIDED_BY_32(next_free);
-		mask = 1 << j;
-
-		tpm_db_mod2_jump_booked_entry_bm[gmac_port][i] |= mask;
-	}
-
-	return next_free;
-}
-int32_t tpm_db_mod2_split_mod_insert_vlan(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data)
-{
-	uint32_t i;
-	uint32_t vlan_num;
-
-	/* check vlan num right now */
-	vlan_num = tpm_db_mod2_split_mod_get_vlan_num_in_use(port);
-	if (vlan_num >= tpm_db_split_mod_get_num_vlans()){
-		TPM_OS_ERROR(TPM_DB_MOD, "already has %d num_vlans\n", vlan_num - TPM_DB_SPLIT_MOD_INIT_VLANS_NUM);
-		return TPM_DB_ERR_DB_TBL_FULL;
-	}
-
-	for (i = 0; i < TPM_DB_SPLIT_MOD_NUM_VLANS_MAX; i++) {
-		if (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].valid)
-			continue;
-
-		//here finds a spot
-		tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].valid = 1;
-
-		if (mod_data->vlan_mod.vlan1_out.vid_mask)
-			tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_1 = mod_data->vlan_mod.vlan1_out.vid;
-
-		if (mod_data->vlan_mod.vlan2_out.vid_mask)
-			tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_2 = mod_data->vlan_mod.vlan2_out.vid;
-
-		if (mod_data->vlan_mod.vlan1_out.tpid_mask)
-			tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_1 = mod_data->vlan_mod.vlan1_out.tpid;
-
-		if (mod_data->vlan_mod.vlan2_out.tpid_mask)
-			tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_2 = mod_data->vlan_mod.vlan2_out.tpid;
-
-		tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_op = mod_data->vlan_mod.vlan_op;
-		tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].user_num = 1;
-
-		return TPM_DB_OK;
-	}
-
-	return TPM_DB_ERR_DB_TBL_FULL;
-}
-int32_t tpm_db_mod2_split_mod_get_vlan_index(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data, uint32_t *index)
-{
-	uint32_t i;
-	//printk("input: port: %d, vlan_op: %d, vlan1: %d(%d), vlan2: %d(%d)\n",
-		//port, mod_data->vlan_mod.vlan_op, mod_data->vlan_mod.vlan1_out.vid, mod_data->vlan_mod.vlan1_out.vid_mask,
-		//mod_data->vlan_mod.vlan2_out.vid, mod_data->vlan_mod.vlan2_out.vid_mask);
-	for (i = 0; i < TPM_DB_SPLIT_MOD_NUM_VLANS_MAX; i++) {
-		//printk("output: port: %d, vlan_op: %d, vlan1: %d, vlan2: %d\n",
-			//tpm_db.split_mod_conf.gmac_vlan_conf[i].gmac_port, tpm_db.split_mod_conf.gmac_vlan_conf[i].vlan_op,
-			//tpm_db.split_mod_conf.gmac_vlan_conf[i].vlan_1, tpm_db.split_mod_conf.gmac_vlan_conf[i].vlan_2);
-		if (!tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].valid)
-			continue;
-
-		if (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_op != mod_data->vlan_mod.vlan_op)
-			continue;
-
-		if (    (mod_data->vlan_mod.vlan1_out.vid_mask)
-			 && (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_1 != mod_data->vlan_mod.vlan1_out.vid))
-			continue;
-
-		if (    (mod_data->vlan_mod.vlan2_out.vid_mask)
-			 && (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_2 != mod_data->vlan_mod.vlan2_out.vid))
-			continue;
-
-		if (    (mod_data->vlan_mod.vlan1_out.tpid_mask)
-			 && (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_1 != mod_data->vlan_mod.vlan1_out.tpid))
-			continue;
-
-		if (    (mod_data->vlan_mod.vlan2_out.tpid_mask)
-			 && (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_2 != mod_data->vlan_mod.vlan2_out.tpid))
-			continue;
-
-		if (    (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_1)
-			 && (!mod_data->vlan_mod.vlan1_out.vid_mask))
-			continue;
-
-		if (    (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].vlan_2)
-			 && (!mod_data->vlan_mod.vlan2_out.vid_mask))
-			continue;
-
-		if (    (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_1)
-			 && (!mod_data->vlan_mod.vlan1_out.tpid_mask))
-			continue;
-
-		if (    (tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[i].tpid_2)
-			 && (!mod_data->vlan_mod.vlan2_out.tpid_mask))
-			continue;
-
-		//here finds the vlan
-		*index = i;
-		return TPM_DB_OK;
-	}
-
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-int32_t tpm_db_mod2_split_mod_increase_vlan_user_num(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data)
-{
-	uint32_t index;
-	int32_t int_ret_code;
-
-	int_ret_code = tpm_db_mod2_split_mod_get_vlan_index(port, mod_data, &index);
-	if (TPM_DB_OK != int_ret_code) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "failed to get split mod vlan index\n");
-		return TPM_DB_ERR_REC_NOT_EXIST;
-	}
-
-	tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[index].user_num++;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_split_mod_decrease_vlan_user_num(tpm_gmacs_enum_t port,
-						     uint32_t       vlan_index,
-						     uint32_t      *user_num)
-{
-	if (port > TPM_MAX_GMAC) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid port: %d\n", port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (vlan_index >= TPM_DB_SPLIT_MOD_NUM_VLANS_MAX) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid vlan_index: %d\n", vlan_index);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (!tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[vlan_index].valid) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid vlan entry: %d\n", vlan_index);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[vlan_index].user_num--;
-	*user_num = tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[vlan_index].user_num;
-
-	if (!tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[vlan_index].user_num) {
-		TPM_OS_INFO(TPM_DB_MOD, "user num is 0, remove this vlan\n");
-		memset(&(tpm_db.split_mod_conf.gmac_vlan_conf[port].split_mod_vlan[vlan_index]), 0, sizeof(tpm_db_split_mod_vlan_t));
-	}
-
-	return TPM_DB_OK;
-}
-
-uint8_t tpm_db_mod2_rollback_jump_area(tpm_gmacs_enum_t gmac_port, uint16_t entry_id, uint8_t on_failure)
-{
-	/*uint16_t entry_idx, total_num; */
-	uint8_t dirty = 0;
-	tpm_mod2_jump_pmt_info_t *info_array = NULL;
-	uint32_t i, j, mask;
-
-	if (tpm_db_mod2_jump_pmt_info[gmac_port] == NULL)
-		return 0;
-
-	info_array = tpm_db_mod2_jump_pmt_info[gmac_port];
-	if (info_array[entry_id].status == TPM_MOD_ENTRY_BOOKED) {
-		/* TODO: check if the pmt entry is for split mod */
-		i = j = 0;
-		j = entry_id & 0x1f;
-		i = entry_id >> 5;
-		mask = 1 << j;
-
-		tpm_db_mod2_jump_booked_entry_bm[gmac_port][i] &= ~mask;
-
-		info_array[entry_id].status = TPM_MOD_ENTRY_FREE;
-		dirty = 1;
-	} else if (info_array[entry_id].status == TPM_MOD_ENTRY_OCCUPIED) {
-		if (on_failure) {
-			/* TODO: check if the pmt entry is for split mod */
-			i = j = 0;
-			j = entry_id & 0x1f;
-			i = entry_id >> 5;
-			mask = 1 << j;
-
-			tpm_db_mod2_jump_occupied_entry_bm[gmac_port][i] &= ~mask;
-
-			info_array[entry_id].status = TPM_MOD_ENTRY_FREE;
-			dirty = 1;
-		}
-	}
-
-	return dirty;
-}
-
-uint8_t tpm_db_mod2_rollback_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					 uint16_t chain_id, uint8_t on_failure)
-{
-	uint8_t dirty = 0;
-	uint16_t entry_index, entry_num;
-	tpm_mod2_chain_info_t *info_array = NULL;
-	tpm_mod2_chain_pmt_info_t *pmt_array = NULL;
-	uint32_t i, j, mask;
-
-	if (tpm_db_mod2_chain_info[gmac_port][chain_type] == NULL)
-		return 0;
-
-	info_array = tpm_db_mod2_chain_info[gmac_port][chain_type];
-	if (info_array[chain_id].status == TPM_MOD_ENTRY_BOOKED) {
-		tpm_db_mod2_decrease_chain_user(gmac_port, chain_type, chain_id);
-
-		if (tpm_db_mod2_chain_user_num(gmac_port, chain_type, chain_id) == 0) {
-			pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][info_array[chain_id].base_entry];
-
-			entry_num = info_array[chain_id].entry_num;
-
-			for (entry_index = 0; entry_index < entry_num; entry_index++) {
-				memset(&pmt_array[entry_index], 0, sizeof(tpm_mod2_chain_pmt_info_t));
-				pmt_array[entry_index].status = TPM_MOD_ENTRY_FREE;
-			}
-
-			i = j = 0;
-			j = chain_id & 0x1f;
-			i = chain_id >> 5;
-			mask = 1 << j;
-
-			tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type][i] &= ~mask;
-			info_array[chain_id].status = TPM_MOD_ENTRY_FREE;
-			dirty = 1;
-		}
-	} else if (info_array[chain_id].status == TPM_MOD_ENTRY_OCCUPIED) {
-		if (on_failure)
-			tpm_db_mod2_decrease_chain_user(gmac_port, chain_type, chain_id);
-
-		if (tpm_db_mod2_chain_user_num(gmac_port, chain_type, chain_id) == 0) {
-			pmt_array = &tpm_db_mod2_chain_pmt_info[gmac_port][info_array[chain_id].base_entry];
-
-			entry_num = info_array[chain_id].entry_num;
-
-			for (entry_index = 0; entry_index < entry_num; entry_index++) {
-				memset(&pmt_array[entry_index], 0, sizeof(tpm_mod2_chain_pmt_info_t));
-				pmt_array[entry_index].status = TPM_MOD_ENTRY_FREE;
-			}
-
-			i = j = 0;
-			j = chain_id & 0x1f;
-			i = chain_id >> 5;
-			mask = 1 << j;
-
-			tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type][i] &= ~mask;
-
-			info_array[chain_id].status = TPM_MOD_ENTRY_FREE;
-			dirty = 1;
-		}
-	}
-	return dirty;
-}
-
-int32_t tpm_db_mod2_flush_jump_area(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-				    uint8_t updt_next_free, uint8_t on_failure)
-{
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_rollback_jump_area(gmac_port, entry_id, on_failure) || updt_next_free)
-		tpm_db_mod2_update_next_free_jump_entry(gmac_port);
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_flush_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-				      uint16_t chain_id, uint8_t updt_next_free, uint8_t on_failure)
-{
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Invalid input\n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE)
-		return TPM_DB_ERR_INV_INPUT;
-
-    if (tpm_db_mod2_rollback_chain_entry(gmac_port, chain_type, chain_id, on_failure) || updt_next_free)
-		tpm_db_mod2_update_next_free_chain_entry(gmac_port, chain_type);
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_validate_chain_config(void)
-{
-	uint16_t chain_type, total_entries, jump_entries, napt_chains, l2_chains, free_entries;
-	uint16_t split_jump_entries, split_jump_free_entries, least_jump_entries;
-	uint8_t naptv4_unlimited, l2_unlimited, main_chain_empty, subr_chain_empty;
-	uint32_t split_vlan_num, split_pbit_num;
-
-	main_chain_empty = subr_chain_empty = 1;
-	/* check subroutine chain size */
-	if (tpm_db_mod2_get_multicast_mh_state()) {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num == 0) {
-			TPM_OS_WARN(TPM_DB_MOD, "Zero mh chain \n");
-		} else {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-				TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", TPM_CHAIN_TYPE_MH);
-				return TPM_DB_ERR_INV_INPUT;
-			}
-			subr_chain_empty = 0;
-		}
-	} else {
-		TPM_OS_WARN(TPM_DB_MOD, "multicast mh is disabled, mh chain size should be zero \n");
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num = 0;
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero mac chain \n");
-	} else {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", TPM_CHAIN_TYPE_MAC);
-			return TPM_DB_ERR_INV_INPUT;
-		}
-		subr_chain_empty = 0;
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero vlan chain \n");
-	} else {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", TPM_CHAIN_TYPE_VLAN);
-			return TPM_DB_ERR_INV_INPUT;
-		}
-		subr_chain_empty = 0;
-	}
-
-	if (tpm_db_mod2_get_pppoe_add_mod_state()) {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num != 0 ||
-			tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num != 0) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD, "Zero pppoev4 chain \n");
-			} else {
-				if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", TPM_CHAIN_TYPE_PPPOE);
-					return TPM_DB_ERR_INV_INPUT;
-				}
-				subr_chain_empty = 0;
-			}
-		}
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num != 0 ||
-			tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD, "Zero pppoev6 chain \n");
-			} else {
-				if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", TPM_CHAIN_TYPE_IPV6_PPPOE);
-					return TPM_DB_ERR_INV_INPUT;
-				}
-				subr_chain_empty = 0;
-			}
-		}
-	} else {
-		TPM_OS_WARN(TPM_DB_MOD, "pppoe mod is disabled, pppoe chain size should be zero \n");
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num = 0;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].total_num = 0;
-	}
-
-	if (subr_chain_empty) {
-		TPM_OS_ERROR(TPM_DB_MOD, "All subr chain is zero \n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero l2 main chain \n");
-	} else {
-		main_chain_empty = 0;
-	}
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero naptv4 main chain \n");
-	} else {
-		main_chain_empty = 0;
-	}
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero mcv4 main chain \n");
-	} else {
-		main_chain_empty = 0;
-	}
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero routev6 main chain \n");
-	} else {
-		main_chain_empty = 0;
-	}
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num == 0) {
-		TPM_OS_WARN(TPM_DB_MOD, "Zero mcv6 main chain \n");
-	} else {
-		main_chain_empty = 0;
-	}
-	if (main_chain_empty) {
-		TPM_OS_ERROR(TPM_DB_MOD, "All main chain is zero \n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	/* check total pmt entries for all the chains */
-	total_entries = 0;
-	naptv4_unlimited = l2_unlimited = 0;
-	for (chain_type = TPM_CHAIN_TYPE_MH; chain_type < TPM_CHAIN_TYPE_MAX; chain_type++) {
-		if (tpm_db_mod2_chain_cfg[chain_type].total_num == TPM_CHAIN_NUM_UNLIMITED) {
-			if (naptv4_unlimited || l2_unlimited) {
-				TPM_OS_ERROR(TPM_DB_MOD, "Only one chain type could be assigned unlimited size \n");
-				return TPM_DB_ERR_INV_INPUT;
-			}
-
-			if (chain_type == TPM_CHAIN_TYPE_IPV4_NAPT) {
-				naptv4_unlimited = 1;
-				continue;
-			} else if (chain_type == TPM_CHAIN_TYPE_L2) {
-				l2_unlimited = 1;
-				continue;
-			} else {
-				TPM_OS_ERROR(TPM_DB_MOD, "Invalid unlimited chain type %d \n", chain_type);
-				return TPM_DB_ERR_INV_INPUT;
-			}
-		}
-		total_entries +=
-		    tpm_db_mod2_chain_cfg[chain_type].max_size * tpm_db_mod2_chain_cfg[chain_type].total_num;
-		if (total_entries >= TPM_MOD2_TOTAL_PMT_SIZE) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Not enough chain area space \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-	}
-
-	/*the jump entries need at least without split mod*/
-	if (l2_unlimited)
-		least_jump_entries = tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num;
-	else if (naptv4_unlimited)
-		least_jump_entries = tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num;
-	else
-		least_jump_entries = tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num +
-				tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num;
-
-	/*take split mod in consider*/
-	split_jump_entries = 0;
-	split_jump_free_entries = 0;
-	if (TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) {
-		split_vlan_num = tpm_db_split_mod_get_num_vlans() - TPM_DB_SPLIT_MOD_INIT_VLANS_NUM;
-		split_pbit_num = TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX;
-		split_jump_entries = 16 * 2/*init added*/ +
-					(split_vlan_num - 1) * 16/*internal VLAN*/ +
-					split_pbit_num + 1/*last VLAN*/;
-		split_jump_free_entries = 2 * (15 - split_pbit_num)/*init occupy*/ +
-					(split_vlan_num - 1) * (16 - split_pbit_num - 1)/*internal VLAN*/;
-	}
-
-	if (l2_unlimited) {
-		if (split_jump_free_entries >= least_jump_entries)
-			free_entries = TPM_MOD2_TOTAL_PMT_SIZE - total_entries - split_jump_entries;
-		else
-			free_entries = TPM_MOD2_TOTAL_PMT_SIZE - total_entries - split_jump_entries -
-				(least_jump_entries - split_jump_free_entries);
-		l2_chains = free_entries / (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].max_size + 1);
-		if (l2_chains == 0) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Zero naptv4 main chain \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-		total_entries += l2_chains * tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].max_size;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num = l2_chains;
-	} else if (naptv4_unlimited) {
-		if (split_jump_free_entries >= least_jump_entries)
-			free_entries = TPM_MOD2_TOTAL_PMT_SIZE - total_entries - split_jump_entries;
-		else
-			free_entries = TPM_MOD2_TOTAL_PMT_SIZE - total_entries - split_jump_entries -
-				(least_jump_entries - split_jump_free_entries);
-		napt_chains = free_entries / (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].max_size + 1);
-		if (napt_chains == 0) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Zero naptv4 main chain \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-		total_entries += napt_chains * tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].max_size;
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num = napt_chains;
-	}
-
-	if (total_entries >= TPM_MOD2_TOTAL_PMT_SIZE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Zero jump area \n");
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	jump_entries = TPM_MOD2_TOTAL_PMT_SIZE - total_entries;
-	if (jump_entries > TPM_MOD2_MAX_JUMP_ENTRIES_NUM)
-		jump_entries = TPM_MOD2_MAX_JUMP_ENTRIES_NUM;
-
-	if ((tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num +
-	     tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num +
-	     tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num +
-	     tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num +
-	     tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num) > jump_entries - (split_jump_entries - split_jump_free_entries))
-		TPM_OS_WARN(TPM_DB_MOD, "jump entries are not enough for main chain \n");
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num > 32)
-		TPM_OS_WARN(TPM_DB_MOD, "mh sub chain is too large \n");
-
-	if ((tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num < tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num)
-	    && (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num <
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num))
-		TPM_OS_WARN(TPM_DB_MOD, "mac sub chain is too large \n");
-
-	if (((tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num + (split_jump_entries - split_jump_free_entries) <
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num))
-	    && ((tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num + (split_jump_entries - split_jump_free_entries) <
-		tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num)))
-		TPM_OS_WARN(TPM_DB_MOD, "vlan sub chain is too large \n");
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num <
-	    tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num)
-		TPM_OS_WARN(TPM_DB_MOD, "pppoe sub chain is too large \n");
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_L2].total_num > 0) {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num == 0) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Zero vlan subr chain while naptv4 main chain is activated \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_NAPT].total_num > 0) {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num == 0) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Zero mac subr chain while naptv4 main chain is activated \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num == 0) {
-			TPM_OS_WARN(TPM_DB_MOD, "Zero vlan subr chain while naptv4 main chain is activated \n");
-		}
-
-		if (tpm_db_mod2_get_pppoe_add_mod_state()) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_PPPOE].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD,
-					     "Zero pppoe subr chain while naptv4 main chain is activated \n");
-			}
-		}
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_ROUTE].total_num > 0) {
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MAC].total_num == 0) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Zero mac subr chain while routev6 main chain is activated \n");
-			return TPM_DB_ERR_INV_INPUT;
-		}
-
-		if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_VLAN].total_num == 0) {
-			TPM_OS_WARN(TPM_DB_MOD, "Zero vlan subr chain while routev6 main chain is activated \n");
-		}
-
-		if (tpm_db_mod2_get_pppoe_add_mod_state()) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_PPPOE].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD,
-					     "Zero pppoe subr chain while routev6 main chain is activated \n");
-			}
-		}
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV4_MC].total_num > 0) {
-		if (tpm_db_mod2_get_multicast_mh_state()) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD, "Zero mh subr chain while mcv4 main chain is activated \n");
-			}
-		}
-	}
-
-	if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_IPV6_MC].total_num > 0) {
-		if (tpm_db_mod2_get_multicast_mh_state()) {
-			if (tpm_db_mod2_chain_cfg[TPM_CHAIN_TYPE_MH].total_num == 0) {
-				TPM_OS_WARN(TPM_DB_MOD, "Zero mh subr chain while mcv6 main chain is activated \n");
-			}
-		}
-	}
-
-	if (jump_entries < split_jump_entries)
-		TPM_OS_WARN(TPM_DB_MOD, "jump entries are not enough for split mod \n");
-
-	/* TODO: Check if jump entries are  enough for split modification */
-
-	tpm_mod2_chain_area_base = jump_entries + 1;
-	tpm_mod2_total_chain_num = total_entries;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_setup_jump_area(tpm_gmacs_enum_t port)
-{
-	uint32_t info_size, bm_size /*, port */ ;
-	uint32_t	vlan_nums;
-	uint32_t	p_bits_nums;
-	uint32_t	i, j;
-	uint32_t	loop;
-	uint32_t	loop_in;
-	uint32_t	cur_entry, mask;
-
-	tpm_db_mod2_jump_area_cfg.base_entry = 0;
-	tpm_db_mod2_jump_area_cfg.total_num = tpm_mod2_chain_area_base;
-#if 0
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_0] = 1;
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_1] = 1;
-	tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_PMAC]   = 1;
-#endif
-	tpm_db_mod2_jump_area_cfg.next_free[port] = 1;
-
-	info_size = tpm_db_mod2_jump_area_cfg.total_num * sizeof(tpm_mod2_jump_pmt_info_t);
-	if (tpm_db_mod2_jump_area_cfg.total_num % 32) {
-		bm_size = (tpm_db_mod2_jump_area_cfg.total_num / 32 + 1) * sizeof(uint32_t);
-		tpm_db_mod2_jump_bm_group = tpm_db_mod2_jump_area_cfg.total_num / 32 + 1;
-	} else {
-		bm_size = (tpm_db_mod2_jump_area_cfg.total_num / 32) * sizeof(uint32_t);
-		tpm_db_mod2_jump_bm_group = tpm_db_mod2_jump_area_cfg.total_num / 32;
-	}
-
-	/*for (port = TPM_ENUM_GMAC_0; port < TPM_MAX_NUM_GMACS; port++) */
-	{
-		if (tpm_db_mod2_jump_pmt_info[port] != NULL) {
-			vfree(tpm_db_mod2_jump_pmt_info[port]);
-			tpm_db_mod2_jump_pmt_info[port] = NULL;
-		}
-		tpm_db_mod2_jump_pmt_info[port] = (tpm_mod2_jump_pmt_info_t *) vmalloc(info_size);
-		if (tpm_db_mod2_jump_pmt_info[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_jump_pmt_info[port], 0, info_size);
-		tpm_db_mod2_jump_pmt_info[port][0].status = TPM_MOD_ENTRY_OCCUPIED;
-
-		if (tpm_db_mod2_jump_booked_entry_bm[port] != NULL) {
-			vfree(tpm_db_mod2_jump_booked_entry_bm[port]);
-			tpm_db_mod2_jump_booked_entry_bm[port] = NULL;
-		}
-		tpm_db_mod2_jump_booked_entry_bm[port] = (uint32_t *) vmalloc(bm_size);
-		if (tpm_db_mod2_jump_booked_entry_bm[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_jump_booked_entry_bm[port], 0, bm_size);
-
-		if (tpm_db_mod2_jump_occupied_entry_bm[port] != NULL) {
-			vfree(tpm_db_mod2_jump_occupied_entry_bm[port]);
-			tpm_db_mod2_jump_occupied_entry_bm[port] = NULL;
-		}
-		tpm_db_mod2_jump_occupied_entry_bm[port] = (uint32_t *) vmalloc(bm_size);
-		if (tpm_db_mod2_jump_occupied_entry_bm[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_jump_occupied_entry_bm[port], 0, bm_size);
-		tpm_db_mod2_jump_occupied_entry_bm[port][0] |= 0x1;
-
-		if (tpm_db_mod2_jump_split_mod_occupied_entry_bm[port] != NULL) {
-			vfree(tpm_db_mod2_jump_split_mod_occupied_entry_bm[port]);
-			tpm_db_mod2_jump_split_mod_occupied_entry_bm[port] = NULL;
-		}
-		tpm_db_mod2_jump_split_mod_occupied_entry_bm[port] = (uint32_t *) vmalloc(bm_size);
-		if (tpm_db_mod2_jump_split_mod_occupied_entry_bm[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_jump_split_mod_occupied_entry_bm[port], 0xff, bm_size);
-		tpm_db_mod2_jump_split_mod_occupied_entry_bm[port][0] |= 0x1;
-
-		if (tpm_db_mod2_jump_split_mod_all_entry_bm[port] != NULL) {
-			vfree(tpm_db_mod2_jump_split_mod_all_entry_bm[port]);
-			tpm_db_mod2_jump_split_mod_all_entry_bm[port] = NULL;
-		}
-		tpm_db_mod2_jump_split_mod_all_entry_bm[port] = (uint32_t *) vmalloc(bm_size);
-		if (tpm_db_mod2_jump_split_mod_all_entry_bm[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_jump_split_mod_all_entry_bm[port], 0, bm_size);
-	}
-
-	/* split mod init */
-	if (TPM_SPLIT_MOD_DISABLED == tpm_db_split_mod_get_enable())
-	{
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "SPLIT_MOD_DISABLED\n");
-		return(TPM_OK);
-	}
-
-	vlan_nums = tpm_db_split_mod_get_num_vlans();
-	p_bits_nums = TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX;
-
-
-	tpm_db_mod2_jump_area_cfg.next_free[port] = p_bits_nums + 1;
-	//tpm_db_mod2_jump_area_cfg.next_split[port] = 16;
-
-	for (loop = 0; loop <= vlan_nums; loop++) {
-		for (loop_in = 0; loop_in <= p_bits_nums; loop_in++) {
-			cur_entry = (loop * 16) + loop_in;
-			i = j = 0;
-			j = cur_entry & 0x1f;
-			i = cur_entry >> 5;
-			mask = 1 << j;
-			tpm_db_mod2_jump_split_mod_all_entry_bm[port][i] |= mask;
-			//tpm_db_mod2_jump_occupied_entry_bm[port][i] |= mask;
-			//tpm_db_mod2_jump_split_mod_occupied_entry_bm[port][i] &= (~mask);
-		}
-	}
-	//tpm_db_mod2_jump_split_mod_occupied_entry_bm[port][0] |= (0x1);
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_setup_chain_area(tpm_gmacs_enum_t port)
-{
-	uint32_t size, /* port, */ chain;
-	uint16_t base;
-
-	printk(" ===== chain_area: base entry 0x%0x ===== \r\n", tpm_mod2_chain_area_base);
-
-	/*for (port = TPM_ENUM_GMAC_0; port < TPM_MAX_NUM_GMACS; port++) */
-	{
-		printk("[GMAC%d]:\r\n", port);
-		base = tpm_mod2_chain_area_base;
-		for (chain = TPM_CHAIN_TYPE_MH; chain < TPM_CHAIN_TYPE_MAX; chain++) {
-			if (tpm_db_mod2_chain_cfg[chain].total_num != 0) {
-				tpm_db_mod2_chain_cfg[chain].base_entry = base;
-				tpm_db_mod2_chain_cfg[chain].next_free[TPM_ENUM_GMAC_0] = 0;
-				tpm_db_mod2_chain_cfg[chain].next_free[TPM_ENUM_GMAC_1] = 0;
-				tpm_db_mod2_chain_cfg[chain].next_free[TPM_ENUM_PMAC] = 0;
-
-				size = tpm_db_mod2_chain_cfg[chain].total_num * sizeof(tpm_mod2_chain_info_t);
-
-				printk("\t chain-%d, 0x%0x - 0x%0x, chain_num: %d\r\n",
-				       chain, base,
-				       base +
-				       tpm_db_mod2_chain_cfg[chain].total_num * tpm_db_mod2_chain_cfg[chain].max_size -
-				       1, tpm_db_mod2_chain_cfg[chain].total_num);
-
-				if (tpm_db_mod2_chain_info[port][chain] != NULL) {
-					vfree(tpm_db_mod2_chain_info[port][chain]);
-					tpm_db_mod2_chain_info[port][chain] = NULL;
-				}
-				tpm_db_mod2_chain_info[port][chain] = (tpm_mod2_chain_info_t *) vmalloc(size);
-				if (tpm_db_mod2_chain_info[port][chain] == NULL) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-					return TPM_DB_ERR_MEM_ALLOC_FAIL;
-				}
-				memset(tpm_db_mod2_chain_info[port][chain], 0, size);
-
-				if (tpm_db_mod2_chain_cfg[chain].total_num % 32) {
-					size = (tpm_db_mod2_chain_cfg[chain].total_num / 32 + 1) * sizeof(uint32_t);
-					tpm_db_mod2_chain_bm_group[chain] =
-					    tpm_db_mod2_chain_cfg[chain].total_num / 32 + 1;
-				} else {
-					size = (tpm_db_mod2_chain_cfg[chain].total_num / 32) * sizeof(uint32_t);
-					tpm_db_mod2_chain_bm_group[chain] = tpm_db_mod2_chain_cfg[chain].total_num / 32;
-				}
-
-				if (tpm_db_mod2_chain_booked_entry_bm[port][chain] != NULL) {
-					vfree(tpm_db_mod2_chain_booked_entry_bm[port][chain]);
-					tpm_db_mod2_chain_booked_entry_bm[port][chain] = NULL;
-				}
-				tpm_db_mod2_chain_booked_entry_bm[port][chain] = (uint32_t *) vmalloc(size);
-				if (tpm_db_mod2_chain_booked_entry_bm[port][chain] == NULL) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-					return TPM_DB_ERR_MEM_ALLOC_FAIL;
-				}
-				memset(tpm_db_mod2_chain_booked_entry_bm[port][chain], 0, size);
-
-				if (tpm_db_mod2_chain_occupied_entry_bm[port][chain] != NULL) {
-					vfree(tpm_db_mod2_chain_occupied_entry_bm[port][chain]);
-					tpm_db_mod2_chain_occupied_entry_bm[port][chain] = NULL;
-				}
-				tpm_db_mod2_chain_occupied_entry_bm[port][chain] = (uint32_t *) vmalloc(size);
-				if (tpm_db_mod2_chain_occupied_entry_bm[port][chain] == NULL) {
-					TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-					return TPM_DB_ERR_MEM_ALLOC_FAIL;
-				}
-				memset(tpm_db_mod2_chain_occupied_entry_bm[port][chain], 0, size);
-
-				base += tpm_db_mod2_chain_cfg[chain].total_num * tpm_db_mod2_chain_cfg[chain].max_size;
-			}
-		}
-
-		if (tpm_db_mod2_chain_pmt_info[port] != NULL) {
-			vfree(tpm_db_mod2_chain_pmt_info[port]);
-			tpm_db_mod2_chain_pmt_info[port] = NULL;
-		}
-		size = tpm_mod2_total_chain_num * sizeof(tpm_mod2_chain_pmt_info_t);
-		tpm_db_mod2_chain_pmt_info[port] = (tpm_mod2_chain_pmt_info_t *) vmalloc(size);
-		if (tpm_db_mod2_chain_pmt_info[port] == NULL) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Memory allocation failure \n");
-			return TPM_DB_ERR_MEM_ALLOC_FAIL;
-		}
-		memset(tpm_db_mod2_chain_pmt_info[port], 0, size);
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_setup(void)
-{
-	uint32_t port;
-
-	if (tpm_db_mod2_validate_chain_config() != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Chain config validation failure \n");
-		return TPM_FAIL;
-	}
-
-	for (port = TPM_ENUM_GMAC_0; port < TPM_MAX_NUM_GMACS; port++) {
-		if (tpm_db_mod2_setup_jump_area(port) != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Failed to setup jump area \n");
-			return TPM_FAIL;
-		}
-		if (tpm_db_mod2_setup_chain_area(port) != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_DB_MOD, "Failed to setup chain area \n");
-			return TPM_FAIL;
-		}
-	}
-
-	/* init split mod data */
-	memset(&(tpm_db.split_mod_conf.gmac_vlan_conf), 0, sizeof(tpm_db.split_mod_conf.gmac_vlan_conf));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_mod2_inv_mac_entries(tpm_gmacs_enum_t gmac_port)
-{
-	if (tpm_db_mod2_setup_jump_area(gmac_port) != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Failed to setup jump area \n");
-		return TPM_FAIL;
-	}
-	if (tpm_db_mod2_setup_chain_area(gmac_port) != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "Failed to setup chain area \n");
-		return TPM_FAIL;
-	}
-
-	return TPM_DB_OK;
-}
-
-void tpm_db_mod2_show_jump_pmt_entries(tpm_gmacs_enum_t gmac_port)
-{
-	uint16_t entry_idx;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return;
-
-	printk("              STATUS        OPCODE | DATA | LAST | UPDT_IP | UPDT_CHK \r\n");
-	for (entry_idx = 0; entry_idx < tpm_db_mod2_jump_area_cfg.total_num; entry_idx++) {
-		if (tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].status != TPM_MOD_ENTRY_FREE) {
-			printk("[PMT 0x%04x]: %s             0x%04x | 0x%04x | %d | %d | %d \r\n", entry_idx,
-			       entry_state_str[tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].status],
-			       tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].pattern.opcode,
-			       tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].pattern.data,
-			       tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].pattern.last,
-			       tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].pattern.updt_ipv4,
-			       tpm_db_mod2_jump_pmt_info[gmac_port][entry_idx].pattern.updt_tcp);
-		}
-	}
-}
-
-void tpm_db_mod2_show_jump_cfg_data(void)
-{
-	uint32_t i;
-	printk("[JUMP AREA]: base_entry 0x%04x, total_num %d, split_mod_num %d, split_mod_pbit_num %d\r\n",
-	       tpm_db_mod2_jump_area_cfg.base_entry, tpm_db_mod2_jump_area_cfg.total_num,
-	       tpm_db_mod2_jump_area_cfg.split_num, tpm_db_mod2_jump_area_cfg.split_pbit_num);
-
-	printk("[NEXT FREE]: GMAC0(G/S)       GMAC1(G/S)       PMAC(G/S)    \r\n");
-	printk("[NEXT FREE]: 0x%04x/0x%04x    0x%04x/0x%04x    0x%04x/0x%04x    \r\n",
-	       tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_0],
-	       tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_GMAC_0],
-	       tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_GMAC_1],
-	       tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_GMAC_1],
-	       tpm_db_mod2_jump_area_cfg.next_free[TPM_ENUM_PMAC], tpm_db_mod2_jump_area_cfg.next_split[TPM_ENUM_PMAC]);
-#if 1
-	printk("[BOOKED_MAP]:\r\n");
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		 printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_booked_entry_bm[TPM_ENUM_GMAC_0][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_booked_entry_bm[TPM_ENUM_GMAC_1][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_booked_entry_bm[TPM_ENUM_PMAC][i]);
-
-	printk("[OCCUPIED_MAP]:\r\n");
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_occupied_entry_bm[TPM_ENUM_GMAC_0][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_occupied_entry_bm[TPM_ENUM_GMAC_1][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_occupied_entry_bm[TPM_ENUM_PMAC][i]);
-
-	printk("[SPLIT MOD OCCUPIED_MAP]:\r\n");
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_split_mod_occupied_entry_bm[TPM_ENUM_GMAC_0][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_split_mod_occupied_entry_bm[TPM_ENUM_GMAC_1][i]);
-
-	for (i = 0; i < tpm_db_mod2_jump_bm_group; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_jump_split_mod_occupied_entry_bm[TPM_ENUM_PMAC][i]);
-#endif
-}
-
-void tpm_db_mod2_show_chain_pmt_entries(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type)
-{
-	uint16_t entry_idx, pmt_idx, entry_num;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return;
-
-	if (chain_type >= TPM_CHAIN_TYPE_MAX)
-		return;
-
-	printk("              STATUS  CHAIN/ID     OPCODE | DATA | LAST | UPDT_IP | UPDT_CHK \r\n");
-	if (chain_type == TPM_CHAIN_TYPE_NONE) {
-		for (chain_type = TPM_CHAIN_TYPE_MH; chain_type < TPM_CHAIN_TYPE_MAX; chain_type++) {
-			if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0)
-				continue;
-
-			entry_num = tpm_db_mod2_chain_cfg[chain_type].total_num * tpm_db_mod2_chain_cfg[chain_type].max_size;
-
-			for (entry_idx = 0; entry_idx < entry_num; entry_idx++) {
-				pmt_idx = entry_idx + tpm_db_mod2_chain_cfg[chain_type].base_entry - tpm_mod2_chain_area_base;
-				if (tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].status != TPM_MOD_ENTRY_FREE) {
-					printk("[PMT 0x%04x]: %s       %d/%d          0x%04x | 0x%04x | %d | %d | %d \r\n",
-					       tpm_mod2_chain_area_base + pmt_idx,
-					       entry_state_str[tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].status],
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].chain_type,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].chain_id,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.opcode,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.data,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.last,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.updt_ipv4,
-					       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.updt_tcp);
-				}
-			}
-		}
-	} else {
-		if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0)
-			return;
-
-		entry_num = tpm_db_mod2_chain_cfg[chain_type].total_num * tpm_db_mod2_chain_cfg[chain_type].max_size;
-
-		for (entry_idx = 0; entry_idx < entry_num; entry_idx++) {
-			pmt_idx = entry_idx + tpm_db_mod2_chain_cfg[chain_type].base_entry - tpm_mod2_chain_area_base;
-			if (tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].status != TPM_MOD_ENTRY_FREE) {
-				printk("[PMT 0x%04x]: %s       %d/%d          0x%04x | 0x%04x | %d | %d | %d \r\n",
-				       tpm_mod2_chain_area_base + pmt_idx,
-				       entry_state_str[tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].status],
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].chain_type,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].chain_id,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.opcode,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.data,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.last,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.updt_ipv4,
-				       tpm_db_mod2_chain_pmt_info[gmac_port][pmt_idx].pattern.updt_tcp);
-			}
-		}
-	}
-}
-
-void tpm_db_mod2_show_chain_info_entries(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id)
-{
-    uint32_t i;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS)
-		return;
-
-	if (chain_type > TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE)
-		return;
-
-	if (tpm_db_mod2_chain_cfg[chain_type].total_num == 0)
-		return;
-
-	printk("[CHAIN-%d Valid Entries]:\r\n", chain_type);
-
-	if (chain_id == TPM_MOD2_INVALID_CHAIN_ID) {
-		for (chain_id = 0; chain_id < tpm_db_mod2_chain_cfg[chain_type].total_num; chain_id++) {
-			if (tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].status != TPM_MOD_ENTRY_FREE) {
-				if (chain_id < tpm_db_mod2_chain_cfg[chain_type].total_num) {
-					printk("                   STATUS   BASE_ENTR   ENTR_NUM USER_NUM\r\n");
-					printk("[CHAIN-%d  0x%04x]: %s        0x%04x      %d        %d \r\n",
-					       chain_type, chain_id,
-					       entry_state_str[tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].
-							       status],
-					       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].base_entry +
-					       tpm_mod2_chain_area_base,
-					       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].entry_num,
-					       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num);
-				}
-			}
-		}
-	} else {
-		if (tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].status != TPM_MOD_ENTRY_FREE) {
-			if (chain_id < tpm_db_mod2_chain_cfg[chain_type].total_num) {
-				printk("[CHAIN-%d  0x%04x]: %s        0x%04x     %d      %d \r\n", chain_type, chain_id,
-				       entry_state_str[tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].status],
-				       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].base_entry +
-				       tpm_mod2_chain_area_base,
-				       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].entry_num,
-				       tpm_db_mod2_chain_info[gmac_port][chain_type][chain_id].user_num);
-			}
-		}
-	}
-#if 1
-	printk("[CHAIN-%d BOOKED_MAP]:\r\n", chain_type);
-
-	for (i = 0; i < tpm_db_mod2_chain_bm_group[chain_type]; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_chain_booked_entry_bm[gmac_port][chain_type][i]);
-
-	printk("[CHAIN-%d OCCUPIED_MAP]:\r\n", chain_type);
-
-	for (i = 0; i < tpm_db_mod2_chain_bm_group[chain_type]; i++)
-		printk("%02d - 0x%08x\r\n", i, tpm_db_mod2_chain_occupied_entry_bm[gmac_port][chain_type][i]);
-#endif
-	printk("\r\n");
-}
-
-void tpm_db_mod2_show_all_chain(tpm_gmacs_enum_t gmac_port)
-{
-	uint16_t chain_idx;
-
-	for (chain_idx = TPM_CHAIN_TYPE_MH; chain_idx < TPM_CHAIN_TYPE_MAX; chain_idx++)
-		tpm_db_mod2_show_chain_info_entries(gmac_port, chain_idx, TPM_MOD2_INVALID_CHAIN_ID);
-}
-
-void tpm_db_mod2_show_chain_cfg_data(tpm_chain_type_t chain_type)
-{
-	if (chain_type >= TPM_CHAIN_TYPE_MAX || chain_type == TPM_CHAIN_TYPE_NONE)
-		return;
-
-	printk("[CHAIN   %d]: base_entry 0x%04x, total_num %d, max_size %d, subr_chain %d\r\n", chain_type,
-	       tpm_db_mod2_chain_cfg[chain_type].base_entry, tpm_db_mod2_chain_cfg[chain_type].total_num,
-	       tpm_db_mod2_chain_cfg[chain_type].max_size, tpm_db_mod2_chain_cfg[chain_type].subr_chain);
-	printk("[NEXT FREE]: GMAC0     GMAC1     PMAC    \r\n");
-	printk("[NEXT FREE]: 0x%04x    0x%04x    0x%04x    \r\n",
-	       tpm_db_mod2_chain_cfg[chain_type].next_free[TPM_ENUM_GMAC_0],
-	       tpm_db_mod2_chain_cfg[chain_type].next_free[TPM_ENUM_GMAC_1],
-	       tpm_db_mod2_chain_cfg[chain_type].next_free[TPM_ENUM_PMAC]);
-}
-
-/*******************************************************************************
-* tpm_db_mod2_init()
-*
-* DESCRIPTION: The API initializes shadow DB and modification patterns
-*
-* INPUTS:   None
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_db_mod2_init(void)
-{
-	tpm_db_mod2_init_jump_area_cfg();
-	tpm_db_mod2_init_chain_cfg();
-
-	tpm_db_mod2_init_pmt_info();
-	tpm_db_mod2_init_chain_info();
-
-	return TPM_DB_OK;
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv4_us()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv4_mtu_us(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv4_mtu_us = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv4_mtu_us()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv4_mtu_us(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv4_mtu_us;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv4_pppoe_mtu_us()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv4_pppoe_mtu_us(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv4_pppoe_mtu_us = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv4_pppoe_mtu_us()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv4_pppoe_mtu_us(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv4_pppoe_mtu_us;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_mtu_us()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv6_mtu_us(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv6_mtu_us = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_mtu_us()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv6_mtu_us(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv6_mtu_us;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_pppoe_mtu_us()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv6_pppoe_mtu_us(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv6_pppoe_mtu_us = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_pppoe_mtu_us()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv6_pppoe_mtu_us(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv6_pppoe_mtu_us;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv4_mtu_ds()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv4_mtu_ds(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv4_mtu_ds = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv4_mtu_ds()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv4_mtu_ds(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv4_mtu_ds;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_set_ipv6_mtu_ds(uint32_t mtu)
-{
-	tpm_db.tpm_mtu_cfg.ipv6_mtu_ds = mtu;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mtu_get_ipv6_mtu_ds(uint32_t *mtu)
-{
-	*mtu = tpm_db.tpm_mtu_cfg.ipv6_mtu_ds;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_set_num_vlan_tags(uint32_t number)
-{
-	tpm_db.num_vlan_tags = number;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_get_num_vlan_tags(uint32_t *number)
-{
-	*number = tpm_db.num_vlan_tags;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_set_pppoe_add_enable(tpm_db_pppoe_add_enable_t enable)
-{
-	tpm_db.tpm_pppoe_add_enable = enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_get_pppoe_add_enable(tpm_db_pppoe_add_enable_t *enable)
-{
-	*enable = tpm_db.tpm_pppoe_add_enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_set_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Set queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-* igmp_snoop       - queue number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_set_mtu_enable(tpm_db_mtu_setting_enable_t enable)
-{
-	tpm_db.tpm_mtu_cfg.mtu_enable = enable;
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mtu_get_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Get queue number which IGMP packets are forwarded to
-*
-* INPUTS:
-*
-* OUTPUTS:
-* igmp_snoop       - queue number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_get_mtu_enable(tpm_db_mtu_setting_enable_t *enable)
-{
-	*enable = tpm_db.tpm_mtu_cfg.mtu_enable;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_cpu_rx_queue(uint32_t cpu_rx_queue)
-{
-	tpm_db.cpu_rx_queue = cpu_rx_queue;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_cpu_rx_queue(uint32_t *cpu_rx_queue)
-{
-	*cpu_rx_queue = tpm_db.cpu_rx_queue;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_ttl_illegal_action(uint32_t ttl_illegal_action)
-{
-	tpm_db.ttl_illegal_action = ttl_illegal_action;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_ttl_illegal_action(uint32_t *ttl_illegal_action)
-{
-	*ttl_illegal_action = tpm_db.ttl_illegal_action;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_tcp_flag_check(uint32_t tcp_flag_check)
-{
-	tpm_db.tcp_flag_check = tcp_flag_check;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_tcp_flag_check(uint32_t *tcp_flag_check)
-{
-	*tcp_flag_check = tpm_db.tcp_flag_check;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_mru(uint32_t mru)
-{
-	tpm_db.tpm_mtu_cfg.mru = mru;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_mru(uint32_t *mru)
-{
-	*mru = tpm_db.tpm_mtu_cfg.mru;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_catch_all_pkt_action(tpm_init_pnc_last_init_t catch_all_pkt_action)
-{
-	tpm_db.catch_all_pkt_action = catch_all_pkt_action;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_catch_all_pkt_action(tpm_init_pnc_last_init_t *catch_all_pkt_action)
-{
-	*catch_all_pkt_action = tpm_db.catch_all_pkt_action;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_switch_dev_num(int32_t switch_dev_num)
-{
-	tpm_db.switch_dev_num = switch_dev_num;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_switch_dev_num(int32_t *switch_dev_num)
-{
-	*switch_dev_num = tpm_db.switch_dev_num;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_set_ety_dsa_enable(tpm_db_ety_dsa_enable_t ety_dsa_enable)
-{
-	tpm_db.func_profile.ety_dsa_enable = ety_dsa_enable;
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_get_ety_dsa_enable(tpm_db_ety_dsa_enable_t *ety_dsa_enable)
-{
-	*ety_dsa_enable = tpm_db.func_profile.ety_dsa_enable;
-	return (TPM_DB_OK);
-}
-
-void tpm_db_show_mtu_cfg(void)
-{
-	tpm_db_mtu_setting_enable_t mtu_setting_enable;
-	uint32_t mtu, mru;
-	uint32_t num_vlan_tags;
-	tpm_db_pppoe_add_enable_t pppoe_add_enable;
-
-	tpm_db_get_mtu_enable(&mtu_setting_enable);
-	printk("mtu_config: %d, \n", mtu_setting_enable);
-
-	tpm_db_mtu_get_ipv4_mtu_us(&mtu);
-	printk("ipv4_mtu_us: %d, \n", mtu);
-
-	tpm_db_mtu_get_ipv4_pppoe_mtu_us(&mtu);
-	printk("ipv4_pppoe_mtu_us: %d, \n", mtu);
-
-	tpm_db_mtu_get_ipv6_mtu_us(&mtu);
-	printk("ipv6_mtu_us: %d, \n", mtu);
-
-	tpm_db_mtu_get_ipv6_pppoe_mtu_us(&mtu);
-	printk("ipv6_pppoe_mtu_us: %d, \n", mtu);
-
-	tpm_db_mtu_get_ipv4_mtu_ds(&mtu);
-	printk("ipv4_mtu_ds: %d, \n", mtu);
-
-	tpm_db_mtu_get_ipv6_mtu_ds(&mtu);
-	printk("ipv6_mtu_ds: %d, \n", mtu);
-
-	tpm_db_get_pppoe_add_enable(&pppoe_add_enable);
-	printk("pppoe_add_enable: %d, \n", pppoe_add_enable);
-
-	tpm_db_get_num_vlan_tags(&num_vlan_tags);
-	printk("num_vlan_tags: %d, \n", num_vlan_tags);
-
-	tpm_db_get_mru(&mru);
-	printk("mru: %d, \n", mru);
-}
-
-void tpm_db_api_busy_init(void)
-{
-	memset(tpm_db.tpm_busy_apis, TPM_DB_API_NOT_BUSY, sizeof(tpm_db.tpm_busy_apis));
-}
-
-uint32_t tpm_db_get_api_busy(tpm_api_type_t api_type)
-{
-	uint32_t i;
-
-	for (i=0;i<TPM_MAX_PARALLEL_API_CALLS;i++) {
-		if (tpm_db.tpm_busy_apis[api_type][i] != TPM_DB_API_NOT_BUSY)
-			return(TPM_TRUE);
-	}
-	return(TPM_FALSE);
-}
-
-uint32_t tpm_db_get_api_rule_num_busy(tpm_api_type_t api_type, uint32_t rule_num)
-{
-	uint32_t i;
-
-	for (i=0;i<TPM_MAX_PARALLEL_API_CALLS;i++) {
-		if ( tpm_db.tpm_busy_apis[api_type][i] == rule_num)
-			return(TPM_TRUE);
-	}
-	return(TPM_FALSE);
-}
-
-
-void tpm_db_get_api_all_busy(tpm_api_type_t api_type, uint32_t *num_busy, uint32_t *rule_num_list)
-{
-	uint32_t i, l_num_busy=0;
-
-	for (i=0;i<TPM_MAX_PARALLEL_API_CALLS;i++) {
-		if ( tpm_db.tpm_busy_apis[api_type][i] != TPM_DB_API_NOT_BUSY) {
-			rule_num_list[l_num_busy] = tpm_db.tpm_busy_apis[api_type][i];
-			l_num_busy++;
-		}
-	}
-	*num_busy = l_num_busy;
-	return;
-}
-
-
-
-uint32_t tpm_db_set_api_busy(tpm_api_type_t api_type, uint32_t rule_num)
-{
-	uint32_t i;
-
-	for (i=0;i<TPM_MAX_PARALLEL_API_CALLS;i++) {
-		if ( tpm_db.tpm_busy_apis[api_type][i] == TPM_DB_API_NOT_BUSY){
-			tpm_db.tpm_busy_apis[api_type][i] = rule_num;
-			return (TPM_DB_OK);
-		}
-	}
-	return(TPM_DB_ERR_DB_TBL_FULL);
-}
-
-
-uint32_t tpm_db_set_api_free(tpm_api_type_t api_type, uint32_t rule_num)
-{
-	uint32_t i;
-
-	for (i=0;i<TPM_MAX_PARALLEL_API_CALLS;i++) {
-		if ( tpm_db.tpm_busy_apis[api_type][i] == rule_num){
-			tpm_db.tpm_busy_apis[api_type][i] = -1;
-			return (TPM_DB_OK);
-		}
-	}
-	return(TPM_DB_ERR_REC_NOT_EXIST);
-}
-
-
-
-uint32_t tpm_db_find_matched_ipv6_gen_key(tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	uint32_t i;
-	tpm_db_ipv6_gen_key_t *key_array = &tpm_db.ipv6_key_shadow.gen_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE)
-			continue;
-		if (!memcmp(&key_array[i].gen_key, gen_key, sizeof(tpm_ipv6_gen_acl_key_t)))
-			return i;
-	}
-
-	return TPM_DB_INVALID_IPV6_KEY_ID;
-}
-
-uint32_t tpm_db_get_ipv6_gen_key_user_num(uint32_t key_id)
-{
-	return tpm_db.ipv6_key_shadow.gen_key[key_id].user_num;
-}
-
-void tpm_db_increase_ipv6_gen_key_user_num(uint32_t key_id)
-{
-	tpm_db.ipv6_key_shadow.gen_key[key_id].user_num++;
-}
-
-void tpm_db_decrease_ipv6_gen_key_user_num(uint32_t key_id)
-{
-	if (tpm_db.ipv6_key_shadow.gen_key[key_id].user_num > 0)
-		tpm_db.ipv6_key_shadow.gen_key[key_id].user_num--;
-}
-
-uint32_t tpm_db_set_ipv6_gen_key(tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	uint32_t i, key_id = TPM_DB_INVALID_IPV6_KEY_ID;
-	tpm_db_ipv6_gen_key_t *key_array = &tpm_db.ipv6_key_shadow.gen_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE) {
-			key_id = i;
-			break;
-		}
-	}
-
-	if (key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-		return TPM_DB_INVALID_IPV6_KEY_ID;
-	}
-
-	memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_gen_key_t));
-
-	key_array[key_id].valid = TPM_TRUE;
-	memcpy(&key_array[i].gen_key, gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	return key_id;
-}
-
-int32_t tpm_db_get_ipv6_gen_key(uint32_t key_id, tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	tpm_db_ipv6_gen_key_t *key_array = &tpm_db.ipv6_key_shadow.gen_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	memcpy(gen_key, &key_array[key_id].gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_gen_key(uint32_t key_id)
-{
-	uint32_t user_num;
-	tpm_db_ipv6_gen_key_t *key_array = &tpm_db.ipv6_key_shadow.gen_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	user_num = tpm_db_get_ipv6_gen_key_user_num(key_id);
-
-	if (user_num == 0)
-		memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_gen_key_t));
-
-	return TPM_DB_OK;
-}
-
-uint32_t tpm_db_find_matched_ipv6_dip_key(tpm_ipv6_addr_key_t *dip_key)
-{
-	uint32_t i;
-	tpm_db_ipv6_dip_key_t *key_array = &tpm_db.ipv6_key_shadow.dip_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE)
-			continue;
-		if (!memcmp(&key_array[i].dip_key, dip_key, sizeof(tpm_ipv6_addr_key_t)))
-			return i;
-	}
-
-	return TPM_DB_INVALID_IPV6_KEY_ID;
-}
-
-uint32_t tpm_db_get_ipv6_dip_key_user_num(uint32_t key_id)
-{
-	return tpm_db.ipv6_key_shadow.dip_key[key_id].user_num;
-}
-
-void tpm_db_increase_ipv6_dip_key_user_num(uint32_t key_id)
-{
-	tpm_db.ipv6_key_shadow.dip_key[key_id].user_num++;
-}
-
-void tpm_db_decrease_ipv6_dip_key_user_num(uint32_t key_id)
-{
-	if (tpm_db.ipv6_key_shadow.dip_key[key_id].user_num > 0)
-		tpm_db.ipv6_key_shadow.dip_key[key_id].user_num--;
-}
-
-uint32_t tpm_db_set_ipv6_dip_key(tpm_ipv6_addr_key_t *dip_key)
-{
-	uint32_t i, key_id = TPM_DB_INVALID_IPV6_KEY_ID;
-	tpm_db_ipv6_dip_key_t *key_array = &tpm_db.ipv6_key_shadow.dip_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE) {
-			key_id = i;
-			break;
-		}
-	}
-
-	if (key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-		return TPM_DB_INVALID_IPV6_KEY_ID;
-	}
-
-	memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_dip_key_t));
-
-	key_array[key_id].valid = TPM_TRUE;
-	memcpy(&key_array[i].dip_key, dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	return key_id;
-}
-
-int32_t tpm_db_get_ipv6_dip_key(uint32_t key_id, tpm_ipv6_addr_key_t *dip_key)
-{
-	tpm_db_ipv6_dip_key_t *key_array = &tpm_db.ipv6_key_shadow.dip_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	memcpy(dip_key, &key_array[key_id].dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_dip_key(uint32_t key_id)
-{
-	uint32_t user_num;
-	tpm_db_ipv6_dip_key_t *key_array = &tpm_db.ipv6_key_shadow.dip_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	user_num = tpm_db_get_ipv6_dip_key_user_num(key_id);
-
-	if (user_num == 0)
-		memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_dip_key_t));
-
-	return TPM_DB_OK;
-}
-
-uint32_t tpm_db_find_matched_ipv6_l4_key(uint32_t protocol, tpm_l4_ports_key_t *l4_key)
-{
-	uint32_t i;
-	tpm_db_ipv6_l4_key_t *key_array = &tpm_db.ipv6_key_shadow.l4_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE)
-			continue;
-		if (!memcmp(&key_array[i].l4_key, l4_key, sizeof(tpm_l4_ports_key_t)) &&
-			key_array[i].protocol == protocol)
-			return i;
-	}
-
-	return TPM_DB_INVALID_IPV6_KEY_ID;
-}
-
-uint32_t tpm_db_get_ipv6_l4_key_user_num(uint32_t key_id)
-{
-	return tpm_db.ipv6_key_shadow.l4_key[key_id].user_num;
-}
-
-void tpm_db_increase_ipv6_l4_key_user_num(uint32_t key_id)
-{
-	tpm_db.ipv6_key_shadow.l4_key[key_id].user_num++;
-}
-
-void tpm_db_decrease_ipv6_l4_key_user_num(uint32_t key_id)
-{
-	if (tpm_db.ipv6_key_shadow.l4_key[key_id].user_num > 0)
-		tpm_db.ipv6_key_shadow.l4_key[key_id].user_num--;
-}
-
-uint32_t tpm_db_set_ipv6_l4_key(uint32_t protocol, tpm_l4_ports_key_t *l4_key)
-{
-	uint32_t i, key_id = TPM_DB_INVALID_IPV6_KEY_ID;
-	tpm_db_ipv6_l4_key_t *key_array = &tpm_db.ipv6_key_shadow.l4_key[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_KEY_NUM; i++) {
-		if (key_array[i].valid == TPM_FALSE) {
-			key_id = i;
-			break;
-		}
-	}
-
-	if (key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-		return TPM_DB_INVALID_IPV6_KEY_ID;
-	}
-
-	memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_l4_key_t));
-
-	key_array[key_id].valid = TPM_TRUE;
-	memcpy(&key_array[i].l4_key, l4_key, sizeof(tpm_l4_ports_key_t));
-	key_array[key_id].protocol = protocol;
-
-	return key_id;
-}
-
-int32_t tpm_db_get_ipv6_l4_key(uint32_t key_id, uint32_t *protocol, tpm_l4_ports_key_t *l4_key)
-{
-	tpm_db_ipv6_l4_key_t *key_array = &tpm_db.ipv6_key_shadow.l4_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	memcpy(l4_key, &key_array[key_id].l4_key, sizeof(tpm_l4_ports_key_t));
-	*protocol = key_array[key_id].protocol;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_l4_key(uint32_t key_id)
-{
-	uint32_t user_num;
-	tpm_db_ipv6_l4_key_t *key_array = &tpm_db.ipv6_key_shadow.l4_key[0];
-
-	if (key_id >= TPM_DB_IPV6_MAX_KEY_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (key_array[key_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	user_num = tpm_db_get_ipv6_l4_key_user_num(key_id);
-
-	if (user_num == 0)
-		memset(&key_array[key_id], 0, sizeof(tpm_db_ipv6_l4_key_t));
-
-	return TPM_DB_OK;
-}
-
-uint32_t tpm_db_find_matched_ipv6_l4_subflow(uint32_t src_dir, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key)
-{
-	int32_t ret;
-	uint32_t i, _protocol;
-	tpm_db_ipv6_l4_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[0];
-	tpm_l4_ports_key_t _l4_key;
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_SUBFLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE)
-			continue;
-
-		if (parse_bm == flow_array[i].parse_bm) {
-			memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-			ret = tpm_db_get_ipv6_l4_key(flow_array[i].l4_key, &_protocol, &_l4_key);
-			if (ret != TPM_DB_OK)
-				break;
-
-			if (_protocol != protocol)
-				continue;
-
-			if (parse_bm & TPM_PARSE_L4_SRC) {
-				if (_l4_key.l4_src_port != l4_key->l4_src_port)
-					continue;
-			}
-
-			if (parse_bm & TPM_PARSE_L4_DST) {
-				if (_l4_key.l4_dst_port != l4_key->l4_dst_port)
-					continue;
-			}
-
-			return i;
-		}
-	}
-
-	if (i < TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		TPM_OS_WARN(TPM_DB_MOD, "Warning: DB inconsistency\n");
-
-	return TPM_DB_INVALID_IPV6_FLOW_ID;
-}
-
-uint32_t tpm_db_get_ipv6_l4_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	return tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[flow_id].user_num;
-}
-
-void tpm_db_increase_ipv6_l4_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[flow_id].user_num++;
-}
-
-void tpm_db_decrease_ipv6_l4_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	if (tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[flow_id].user_num > 0)
-		tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[flow_id].user_num--;
-}
-
-uint32_t tpm_db_get_free_ipv6_l4_subflow(uint32_t src_dir)
-{
-	uint32_t i;
-	tpm_db_ipv6_l4_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_SUBFLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE)
-			return i;
-	}
-
-	return TPM_DB_INVALID_IPV6_FLOW_ID;
-}
-
-int32_t tpm_db_set_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key)
-{
-	uint32_t l4_key_id;
-	tpm_db_ipv6_l4_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[0];
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid != TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	l4_key_id = tpm_db_find_matched_ipv6_l4_key(protocol, l4_key);
-
-	if (l4_key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-		l4_key_id = tpm_db_set_ipv6_l4_key(protocol, l4_key);
-		if (l4_key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-			return TPM_DB_ERR_DB_TBL_FULL;
-		}
-	}
-
-	tpm_db_increase_ipv6_l4_key_user_num(l4_key_id);
-
-	memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_l4_flow_t));
-
-	flow_array[flow_id].valid = TPM_TRUE;
-	flow_array[flow_id].parse_bm = parse_bm;
-	flow_array[flow_id].l4_key = l4_key_id;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t *parse_bm, uint32_t *protocol, tpm_l4_ports_key_t *l4_key)
-{
-	int32_t ret;
-	tpm_db_ipv6_l4_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[0];
-	uint32_t _protocol;
-	tpm_l4_ports_key_t _l4_key;
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-	ret = tpm_db_get_ipv6_l4_key(flow_array[flow_id].l4_key, &_protocol, &_l4_key);
-
-	if (ret != TPM_DB_OK)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	*parse_bm = flow_array[flow_id].parse_bm;
-	*protocol = _protocol;
-	memcpy(l4_key, &_l4_key, sizeof(tpm_l4_ports_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id)
-{
-	uint32_t user_num;
-	tpm_db_ipv6_l4_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[0];
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-
-	user_num = tpm_db_get_ipv6_l4_subflow_user_num(src_dir, flow_id);
-	if (user_num == 0) {
-		tpm_db_decrease_ipv6_l4_key_user_num(flow_array[flow_id].l4_key);
-		tpm_db_del_ipv6_l4_key(flow_array[flow_id].l4_key);
-		memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_l4_flow_t));
-	}
-
-	return TPM_DB_OK;
-}
-
-uint32_t tpm_db_find_matched_ipv6_gen_subflow(uint32_t src_dir, uint32_t parse_bm, uint32_t protocol,
-											tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	uint32_t i, l4_key_id, gen_key_id;
-	tpm_db_ipv6_gen_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_SUBFLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE)
-			continue;
-
-		if (parse_bm == flow_array[i].parse_bm) {
-			if (flow_array[i].l4_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-				l4_key_id = tpm_db_find_matched_ipv6_l4_key(protocol, l4_key);
-				if (l4_key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-					continue;
-				if (l4_key_id != flow_array[i].l4_key)
-					continue;
-			}
-
-			if (flow_array[i].gen_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-				gen_key_id = tpm_db_find_matched_ipv6_gen_key(gen_key);
-				if (gen_key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-					continue;
-				if (gen_key_id != flow_array[i].gen_key)
-					continue;
-			}
-
-			return i;
-		}
-	}
-
-	return TPM_DB_INVALID_IPV6_FLOW_ID;
-}
-
-uint32_t tpm_db_get_ipv6_gen_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	return tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[flow_id].user_num;
-}
-
-void tpm_db_increase_ipv6_gen_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[flow_id].user_num++;
-}
-
-void tpm_db_decrease_ipv6_gen_subflow_user_num(uint32_t src_dir, uint32_t flow_id)
-{
-	if (tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[flow_id].user_num > 0)
-		tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[flow_id].user_num--;
-}
-
-uint32_t tpm_db_get_free_ipv6_gen_subflow(uint32_t src_dir)
-{
-	uint32_t i;
-	tpm_db_ipv6_gen_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_SUBFLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE)
-			return i;
-	}
-
-	return TPM_DB_INVALID_IPV6_FLOW_ID;
-}
-
-int32_t tpm_db_set_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t parse_bm, uint32_t protocol,
-									tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	uint32_t l4_parse_bm, gen_parse_bm, l4_flow_id, l4_key_id, gen_key_id;
-	tpm_db_ipv6_gen_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[0];
-
-	l4_key_id = gen_key_id = TPM_DB_INVALID_IPV6_KEY_ID;
-	l4_flow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid != TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	l4_parse_bm = parse_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-
-	if (l4_parse_bm != 0) {
-		l4_flow_id = tpm_db_find_matched_ipv6_l4_subflow(src_dir, l4_parse_bm, protocol, l4_key);
-
-		if (l4_flow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-
-		l4_key_id = tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[l4_flow_id].l4_key;
-	}
-
-	gen_parse_bm = parse_bm & ~TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-
-	if (gen_parse_bm != 0) {
-		gen_key_id = tpm_db_find_matched_ipv6_gen_key(gen_key);
-
-		if (gen_key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-			gen_key_id = tpm_db_set_ipv6_gen_key(gen_key);
-			if (gen_key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-				return TPM_DB_ERR_DB_TBL_FULL;
-			}
-		}
-	}
-
-	if (l4_flow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-		tpm_db_increase_ipv6_l4_subflow_user_num(src_dir, l4_flow_id);
-
-	if (gen_key_id != TPM_DB_INVALID_IPV6_KEY_ID)
-		tpm_db_increase_ipv6_gen_key_user_num(gen_key_id);
-
-	memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_gen_flow_t));
-
-	flow_array[flow_id].valid = TPM_TRUE;
-	flow_array[flow_id].parse_bm = parse_bm;
-	flow_array[flow_id].l4_key = l4_key_id;
-	flow_array[flow_id].gen_key = gen_key_id;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t *parse_bm, uint32_t *protocol,
-				    tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	int32_t ret;
-	tpm_db_ipv6_gen_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[0];
-	uint32_t _protocol = 0;
-	tpm_l4_ports_key_t _l4_key;
-	tpm_ipv6_gen_acl_key_t _gen_key;
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	if (flow_array[flow_id].l4_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-		ret = tpm_db_get_ipv6_l4_key(flow_array[flow_id].l4_key, &_protocol, &_l4_key);
-
-		if (ret != TPM_DB_OK)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	if (flow_array[flow_id].gen_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		memset(&_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-		ret = tpm_db_get_ipv6_gen_key(flow_array[flow_id].gen_key, &_gen_key);
-
-		if (ret != TPM_DB_OK)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	*parse_bm = flow_array[flow_id].parse_bm;
-	*protocol = _protocol;
-	memcpy(l4_key, &_l4_key, sizeof(tpm_l4_ports_key_t));
-	memcpy(gen_key, &_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id)
-{
-	int32_t ret;
-	uint32_t user_num, l4_flow_id, l4_parse_bm, protocol;
-	tpm_db_ipv6_gen_flow_t *flow_array = &tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[0];
-	tpm_l4_ports_key_t l4_key;
-
-	if (flow_id >= TPM_DB_IPV6_MAX_SUBFLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_STATUS_ERR;
-
-	user_num = tpm_db_get_ipv6_gen_subflow_user_num(src_dir, flow_id);
-	if (user_num == 0) {
-		if (flow_array[flow_id].gen_key != TPM_DB_INVALID_IPV6_KEY_ID)
-			tpm_db_decrease_ipv6_gen_key_user_num(flow_array[flow_id].gen_key);
-
-		tpm_db_del_ipv6_gen_key(flow_array[flow_id].gen_key);
-
-		if (flow_array[flow_id].l4_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-			memset(&l4_key, 0, sizeof(tpm_l4_ports_key_t));
-			ret = tpm_db_get_ipv6_l4_key(flow_array[flow_id].l4_key, &protocol, &l4_key);
-
-			if (ret != TPM_DB_OK)
-				return TPM_DB_ERR_DB_INCONSISTENCY;
-
-			l4_parse_bm = flow_array[flow_id].parse_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-			l4_flow_id = tpm_db_find_matched_ipv6_l4_subflow(src_dir, l4_parse_bm, protocol, &l4_key);
-
-			if (l4_flow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-				return TPM_DB_ERR_DB_INCONSISTENCY;
-
-			tpm_db_decrease_ipv6_l4_subflow_user_num(src_dir, l4_flow_id);
-		}
-
-		memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_gen_flow_t));
-	}
-	return TPM_DB_OK;
-}
-
-uint32_t tpm_db_find_matched_ipv6_5t_flow(uint32_t src_dir, uint32_t parse_bm, uint32_t is_pppoe, uint32_t protocol,
-							tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key)
-{
-	uint32_t i, key_id;
-	tpm_db_ipv6_5t_flow_shadow_t *flow_array = &tpm_db.ipv6_5t_flow_shadow[0];
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_5T_FLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE)
-			continue;
-
-		if (parse_bm == flow_array[i].parse_bm &&
-			src_dir == flow_array[i].src_dir &&
-			is_pppoe == flow_array[i].is_pppoe) {
-			if (flow_array[i].l4_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-				key_id = tpm_db_find_matched_ipv6_l4_key(protocol, l4_key);
-				if (key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-					continue;
-				if (key_id != flow_array[i].l4_key)
-					continue;
-			}
-
-			if (flow_array[i].gen_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-				key_id = tpm_db_find_matched_ipv6_gen_key(gen_key);
-				if (key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-					continue;
-				if (key_id != flow_array[i].gen_key)
-					continue;
-			}
-
-			if (flow_array[i].dip_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-				key_id = tpm_db_find_matched_ipv6_dip_key(dip_key);
-				if (key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-					continue;
-				if (key_id != flow_array[i].dip_key)
-					continue;
-			}
-
-			return i;
-		}
-	}
-
-	return TPM_DB_INVALID_IPV6_FLOW_ID;
-}
-
-int32_t tpm_db_set_ipv6_5t_flow(uint32_t src_dir, uint32_t parse_bm,  uint32_t is_pppoe, uint32_t protocol,
-							tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key)
-{
-	uint32_t i, _parse_bm, subflow_id, l4_key_id, gen_key_id, dip_key_id, flow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-	tpm_db_ipv6_5t_flow_shadow_t *flow_array = &tpm_db.ipv6_5t_flow_shadow[0];
-
-	l4_key_id = gen_key_id = dip_key_id = TPM_DB_INVALID_IPV6_KEY_ID;
-
-	for (i = 0; i < TPM_DB_IPV6_MAX_5T_FLOW_NUM; i++) {
-		if (flow_array[i].valid == TPM_FALSE) {
-			flow_id = i;
-			break;
-		}
-	}
-
-	if (flow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-		return TPM_DB_ERR_DB_TBL_FULL;
-
-	_parse_bm = parse_bm & ~TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if (_parse_bm != 0) {
-		dip_key_id = tpm_db_find_matched_ipv6_dip_key(dip_key);
-		if (dip_key_id == TPM_DB_INVALID_IPV6_KEY_ID) {
-			dip_key_id = tpm_db_set_ipv6_dip_key(dip_key);
-			if (dip_key_id == TPM_DB_INVALID_IPV6_KEY_ID)
-				return TPM_DB_ERR_DB_INCONSISTENCY;
-		}
-	}
-
-	_parse_bm = parse_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if (_parse_bm != 0) {
-		subflow_id = tpm_db_find_matched_ipv6_gen_subflow(src_dir, _parse_bm, protocol, l4_key, gen_key);
-		if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-			tpm_db_increase_ipv6_gen_subflow_user_num(src_dir, subflow_id);
-			gen_key_id = tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[subflow_id].gen_key;
-			l4_key_id = tpm_db.ipv6_subflow_shadow[src_dir].gen_flow[subflow_id].l4_key;
-		} else {
-			_parse_bm = parse_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-			if (_parse_bm != 0) {
-				subflow_id = tpm_db_find_matched_ipv6_l4_subflow(src_dir, _parse_bm, protocol, l4_key);
-				if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-					tpm_db_increase_ipv6_l4_subflow_user_num(src_dir, subflow_id);
-					l4_key_id = tpm_db.ipv6_subflow_shadow[src_dir].l4_flow[subflow_id].l4_key;
-				}
-			}
-		}
-	}
-
-	if (dip_key_id != TPM_DB_INVALID_IPV6_KEY_ID)
-		tpm_db_increase_ipv6_dip_key_user_num(dip_key_id);
-
-	memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_5t_flow_shadow_t));
-
-	flow_array[flow_id].valid = TPM_TRUE;
-	flow_array[flow_id].src_dir = src_dir;
-	flow_array[flow_id].parse_bm = parse_bm;
-	flow_array[flow_id].is_pppoe = is_pppoe;
-	flow_array[flow_id].gen_key = gen_key_id;
-	flow_array[flow_id].dip_key = dip_key_id;
-	flow_array[flow_id].l4_key = l4_key_id;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv6_5t_flow(uint32_t flow_id, uint32_t *src_dir, uint32_t *parse_bm, uint32_t *is_pppoe, uint32_t *protocol,
-							tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key)
-{
-	int32_t ret;
-	tpm_db_ipv6_5t_flow_shadow_t *flow_array = &tpm_db.ipv6_5t_flow_shadow[0];
-	tpm_l4_ports_key_t _l4_key;
-	tpm_ipv6_gen_acl_key_t _gen_key;
-	tpm_ipv6_addr_key_t _dip_key;
-	uint32_t _protocol = 0;
-
-	memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-	memset(&_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-	memset(&_dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-	if (flow_id >= TPM_DB_IPV6_MAX_5T_FLOW_NUM)
-		return TPM_DB_ERR_INV_INPUT;
-
-	if (flow_array[flow_id].valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_INV;
-
-	if (flow_array[flow_id].l4_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		ret = tpm_db_get_ipv6_l4_key(flow_array[flow_id].l4_key, &_protocol, &_l4_key);
-		if (ret != TPM_DB_OK)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	if (flow_array[flow_id].gen_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		ret = tpm_db_get_ipv6_gen_key(flow_array[flow_id].gen_key, &_gen_key);
-		if (ret != TPM_DB_OK)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	if (flow_array[flow_id].dip_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		ret = tpm_db_get_ipv6_dip_key(flow_array[flow_id].dip_key, &_dip_key);
-		if (ret != TPM_DB_OK)
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-	}
-
-	*src_dir = flow_array[flow_id].src_dir;
-	*parse_bm = flow_array[flow_id].parse_bm;
-	*is_pppoe = flow_array[flow_id].is_pppoe;
-	*protocol = _protocol;
-	memcpy(l4_key, &_l4_key, sizeof(tpm_l4_ports_key_t));
-	memcpy(gen_key, &_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-	memcpy(dip_key, &_dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv6_5t_flow(uint32_t flow_id)
-{
-	int32_t ret;
-	tpm_db_ipv6_5t_flow_shadow_t *flow_array = &tpm_db.ipv6_5t_flow_shadow[0];
-	tpm_l4_ports_key_t l4_key;
-	tpm_ipv6_gen_acl_key_t gen_key;
-	tpm_ipv6_addr_key_t dip_key;
-	uint32_t src_dir, parse_bm, protocol, subflow_bm, subflow_id, is_pppoe;
-
-
-	ret = tpm_db_get_ipv6_5t_flow(flow_id, &src_dir, &parse_bm, &is_pppoe, &protocol, &l4_key, &gen_key, &dip_key);
-
-	if (ret != TPM_DB_OK)
-		return TPM_DB_ERR_REC_INV;
-
-	subflow_bm = parse_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if (subflow_bm != 0) {
-		subflow_id = tpm_db_find_matched_ipv6_gen_subflow(src_dir, subflow_bm, protocol, &l4_key, &gen_key);
-		if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-			tpm_db_decrease_ipv6_gen_subflow_user_num(src_dir, subflow_id);
-		else {
-			subflow_bm = parse_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-			if (subflow_bm != 0) {
-				subflow_id = tpm_db_find_matched_ipv6_l4_subflow(src_dir, subflow_bm, protocol, &l4_key);
-				if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-					tpm_db_decrease_ipv6_l4_subflow_user_num(src_dir, subflow_id);
-			}
-		}
-	}
-
-	if (flow_array[flow_id].dip_key != TPM_DB_INVALID_IPV6_KEY_ID) {
-		tpm_db_decrease_ipv6_dip_key_user_num(flow_array[flow_id].dip_key);
-		tpm_db_del_ipv6_dip_key(flow_array[flow_id].dip_key);
-	}
-
-	memset(&flow_array[flow_id], 0, sizeof(tpm_db_ipv6_5t_flow_shadow_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_init_ipv6_5t_flow_reset(void)
-{
-	memset(&tpm_db.ipv6_key_shadow, 0, sizeof(tpm_db_ipv6_key_shadow_t));
-	memset(tpm_db.ipv6_subflow_shadow, 0, TPM_NUM_DIRECTIONS * sizeof(tpm_db_ipv6_subflow_shadow_t));
-	memset(tpm_db.ipv6_5t_flow_shadow, 0, TPM_DB_IPV6_MAX_5T_FLOW_NUM * sizeof(tpm_db_ipv6_5t_flow_shadow_t));
-
-	return TPM_DB_OK;
-}
-int32_t tpm_db_ctc_cm_rule_set(tpm_src_port_type_t src_port,
-			       uint32_t precedence,
-			       tpm_parse_fields_t l2_parse_rule_bm,
-			       tpm_parse_fields_t ipv4_parse_rule_bm,
-			       tpm_parse_fields_t ipv6_parse_rule_bm,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_ipv4_acl_key_t *ipv4_key,
-			       tpm_ipv6_acl_key_t *ipv6_key,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_pkt_action_t pkt_act,
-			       uint32_t pbits,
-			       uint32_t ipv4_sub_pattern_index,
-			       uint32_t rule_index)
-{
-	tpm_db_ctc_cm_rule_entry_t *rule_entry;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if(precedence >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input precedence(%d)\n", precedence);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	rule_entry = &tpm_db.ctc_cm_data.cm_rule[src_port][precedence];
-
-	rule_entry->l2_parse_rule_bm   = l2_parse_rule_bm;
-	rule_entry->ipv4_parse_rule_bm = ipv4_parse_rule_bm;
-	rule_entry->ipv6_parse_rule_bm = ipv6_parse_rule_bm;
-	memcpy(&rule_entry->l2_key, l2_key, sizeof(tpm_l2_acl_key_t));
-	memcpy(&rule_entry->ipv4_key, ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-	memcpy(&rule_entry->ipv6_key, ipv6_key, sizeof(tpm_ipv6_acl_key_t));
-	memcpy(&rule_entry->pkt_frwd, pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	rule_entry->pkt_act                = pkt_act;
-	rule_entry->pbits                  = pbits;
-	rule_entry->cm_main_rule_index     = rule_index;
-	rule_entry->ipv4_sub_pattern_key   = ipv4_sub_pattern_index;
-	rule_entry->valid                  = 1;
-
-	if(l2_parse_rule_bm & ipv4_parse_rule_bm)
-		rule_entry->rule_type = TPM_CTC_CM_COMBO;
-	else if(l2_parse_rule_bm)
-		rule_entry->rule_type = TPM_CTC_CM_L2;
-	else if(ipv4_parse_rule_bm)
-		rule_entry->rule_type = TPM_CTC_CM_IPv4;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ctc_cm_rule_delete(tpm_src_port_type_t src_port, uint32_t precedence)
-{
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if(precedence >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input precedence(%d)\n", precedence);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	memset(&tpm_db.ctc_cm_data.cm_rule[src_port][precedence], 0, sizeof(tpm_db_ctc_cm_rule_entry_t));
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ctc_cm_rule_get(tpm_src_port_type_t src_port, uint32_t precedence, tpm_db_ctc_cm_rule_entry_t *cm_rule)
-{
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if(precedence >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input precedence(%d)\n", precedence);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	memcpy(cm_rule, &tpm_db.ctc_cm_data.cm_rule[src_port][precedence], sizeof(tpm_db_ctc_cm_rule_entry_t));
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ctc_cm_get_num_rules(tpm_src_port_type_t src_port)
-{
-	int32_t loop;
-	int32_t num_rules = 0;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	for(loop = 0; loop < TPM_MAX_NUM_CTC_PRECEDENCE; loop++)
-		if(tpm_db.ctc_cm_data.cm_rule[src_port][loop].valid)
-			num_rules++;
-
-	return num_rules;
-}
-
-int32_t tpm_db_ctc_cm_get_ipv6_num_rules(void)
-{
-	int32_t loop;
-	int32_t num_rules = 0;
-	tpm_src_port_type_t src_port;
-
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port < TPM_MAX_NUM_UNI_PORTS; src_port++)
-		for(loop = 0; loop < TPM_MAX_NUM_CTC_PRECEDENCE; loop++)
-			if(    (tpm_db.ctc_cm_data.cm_rule[src_port][loop].valid)
-			    && (tpm_db.ctc_cm_data.cm_rule[src_port][loop].ipv6_parse_rule_bm))
-				num_rules++;
-
-	return num_rules;
-}
-
-int32_t tpm_db_ctc_cm_db_reset(void)
-{
-	memset(&tpm_db.ctc_cm_data.cm_rule, 0, sizeof(tpm_db.ctc_cm_data.cm_rule));
-	memset(&tpm_db.ctc_cm_data.ipv4_pre_table, 0, sizeof(tpm_db_cnm_ipv4_pre_table_t));
-	memset(&tpm_db.ctc_cm_data.ipv4_pre_filter, 0, TPM_MAX_NUM_UNI_PORTS * sizeof(tpm_db_cnm_ipv4_pre_filter_t));
-	tpm_db.ctc_cm_data.ipv6_parse_win = tpm_db.ctc_cm_data.ipv6_parse_win_original;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ipv6_mc_sip_db_reset(void)
-{
-	memset(&tpm_db.ipv6_mc_sip, 0, sizeof(tpm_db.ipv6_mc_sip));
-	/* reserve the first IPv6 MC SIP entry for not matching any SIP */
-	tpm_db.ipv6_mc_sip[0].valid = 1;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ipv6_mc_sip_index_get(uint8_t  *src_ip)
-{
-	uint32_t i;
-	int32_t ret;
-	tpm_db_pnc_range_t range_data;
-
-	/*check param*/
-	if (src_ip == NULL)
-		return 0;
-
-	ret = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	if(ret != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "TPM_PNC_IPV6_MC_SIP is not created!\n");
-		return 0;
-	}
-
-	for (i = 1; i < range_data.pnc_range_conf.range_size; i++) {
-		if (tpm_db.ipv6_mc_sip[i].valid == 0)
-			continue;
-
-		if (memcmp(tpm_db.ipv6_mc_sip[i].src_ip, src_ip, 16)== 0)
-			return i;
-	}
-
-	/* does not find this src_ip */
-	return 0;
-}
-
-int32_t tpm_db_ipv6_mc_sip_add(uint8_t  *src_ip)
-{
-	uint32_t i;
-	int32_t ret;
-	tpm_db_pnc_range_t range_data;
-
-	/*check param*/
-	if (src_ip == NULL)
-		return 0;
-
-	ret = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	if(ret != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "TPM_PNC_IPV6_MC_SIP is not created!\n");
-		return 0;
-	}
-
-	for (i = 1; i < range_data.pnc_range_conf.range_size; i++) {
-		if (tpm_db.ipv6_mc_sip[i].valid == 1)
-			continue;
-
-		memcpy(tpm_db.ipv6_mc_sip[i].src_ip, src_ip, 16);
-		tpm_db.ipv6_mc_sip[i].valid = 1;
-		tpm_db.ipv6_mc_sip[i].reference_num = 1;
-		return i;
-	}
-
-	/* do not have slot for this src_ip */
-	return 0;
-}
-int32_t tpm_db_ipv6_mc_sip_ref_num_inc(uint8_t  src_ip_index)
-{
-	/*check param*/
-	if (src_ip_index >= TPM_MC_IPv6_SIP_NUM_MAX)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (tpm_db.ipv6_mc_sip[src_ip_index].valid == 0)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.ipv6_mc_sip[src_ip_index].reference_num++;
-
-	return TPM_DB_OK;
-}
-int32_t tpm_db_ipv6_mc_sip_ref_num_dec(uint8_t  src_ip_index, uint8_t  *new_ref_num)
-{
-	/*check param*/
-	if (src_ip_index >= TPM_MC_IPv6_SIP_NUM_MAX)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (tpm_db.ipv6_mc_sip[src_ip_index].valid == 0)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (tpm_db.ipv6_mc_sip[src_ip_index].reference_num == 0)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.ipv6_mc_sip[src_ip_index].reference_num--;
-
-	*new_ref_num = tpm_db.ipv6_mc_sip[src_ip_index].reference_num;
-	/* if new ref num is 0, remove this SIP in DB */
-	if (tpm_db.ipv6_mc_sip[src_ip_index].reference_num == 0) {
-		memset(&tpm_db.ipv6_mc_sip[src_ip_index], 0, sizeof(tpm_db.ipv6_mc_sip[src_ip_index]));
-	}
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_ipv6_mc_sip_free_slot_num_get(void)
-{
-	uint32_t i;
-	int32_t ret;
-	tpm_db_pnc_range_t range_data;
-	uint32_t free_slot_num = 0;
-
-	ret = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	if(ret != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_DB_MOD, "TPM_PNC_IPV6_MC_SIP is not created!\n");
-		return 0;
-	}
-
-	for (i = 1; i < range_data.pnc_range_conf.range_size; i++) {
-		if (tpm_db.ipv6_mc_sip[i].valid == 1)
-			continue;
-		free_slot_num++;
-	}
-
-	return free_slot_num;
-}
-
-int32_t tpm_db_ctc_cm_enable_set(tpm_db_ctc_cm_enable_t ctc_cm_enable)
-{
-	tpm_db.ctc_cm_data.enable = ctc_cm_enable;
-	return(TPM_DB_OK);
-}
-
-int32_t tpm_db_ctc_cm_enable_get(tpm_db_ctc_cm_enable_t *ctc_cm_enable)
-{
-	*ctc_cm_enable = tpm_db.ctc_cm_data.enable;
-	return(TPM_DB_OK);
-}
-int32_t tpm_db_ctc_cm_ipv6_parse_win_set(tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win)
-{
-	tpm_db.ctc_cm_data.ipv6_parse_win = ctc_cm_ipv6_parse_win;
-	return(TPM_DB_OK);
-}
-int32_t tpm_db_ctc_cm_ipv6_parse_win_orig_set(tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win)
-{
-	tpm_db.ctc_cm_data.ipv6_parse_win_original = ctc_cm_ipv6_parse_win;
-	return(TPM_DB_OK);
-}
-
-int32_t tpm_db_ctc_cm_ipv6_parse_win_get(tpm_db_ctc_cm_ipv6_parse_win_t *ctc_cm_ipv6_parse_win)
-{
-	*ctc_cm_ipv6_parse_win = tpm_db.ctc_cm_data.ipv6_parse_win;
-	return(TPM_DB_OK);
-}
-int32_t tpm_db_ctc_cm_ipv6_ety_rule_num_set(uint32_t ipv6_ety_rule_num)
-{
-	tpm_db.ctc_cm_data.ipv6_ety_rule_num = ipv6_ety_rule_num;
-	return(TPM_DB_OK);
-}
-
-int32_t tpm_db_ctc_cm_ipv6_ety_rule_num_get(uint32_t *ipv6_ety_rule_num)
-{
-	*ipv6_ety_rule_num = tpm_db.ctc_cm_data.ipv6_ety_rule_num;
-	return(TPM_DB_OK);
-}
-
-int32_t tpm_db_add_ipv4_pre_rule(tpm_src_port_type_t src_port, uint32_t key_pattern, uint32_t *rule_num)
-{
-	uint32_t rule_index, i, j;
-	uint32_t *rule_table = &tpm_db.ctc_cm_data.ipv4_pre_table.rule_index[0];
-
-	if (rule_num == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	rule_index = TPM_DB_CNM_GEN_IPV4_PRE_RULE_INDEX(src_port, key_pattern);
-	if (rule_index == TPM_DB_CNM_INVALID_IPV4_PRE_RULE_INDEX)
-		return TPM_DB_ERR_INV_INPUT;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "add rule_index(0x%x)\n", rule_index);
-
-	for (i = 0; i < tpm_db.ctc_cm_data.ipv4_pre_table.num_rules; i++) {
-		if (rule_index == rule_table[i]) {
-			TPM_OS_ERROR(TPM_DB_MOD, " ipv4_pre_rule already exists!\n");
-			return TPM_DB_ERR_DB_INCONSISTENCY;
-		} else if (rule_index > rule_table[i]) {
-			break;
-		}
-	}
-
-	for (j = tpm_db.ctc_cm_data.ipv4_pre_table.num_rules; j > i; j--)
-		rule_table[j] = rule_table[j - 1];
-
-	rule_table[j] = rule_index;
-	tpm_db.ctc_cm_data.ipv4_pre_table.num_rules++;
-
-	*rule_num = i;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv4_pre_rule(tpm_src_port_type_t src_port, uint32_t key_pattern, uint32_t *rule_num)
-{
-	uint32_t rule_index, i, j;
-	uint32_t *rule_table = &tpm_db.ctc_cm_data.ipv4_pre_table.rule_index[0];
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	rule_index = TPM_DB_CNM_GEN_IPV4_PRE_RULE_INDEX(src_port, key_pattern);
-	if (rule_index == TPM_DB_CNM_INVALID_IPV4_PRE_RULE_INDEX)
-		return TPM_DB_ERR_REC_EXIST;
-
-	TPM_OS_DEBUG(TPM_DB_MOD, "delete rule_index(0x%x)\n", rule_index);
-
-	for (i = 0; i < tpm_db.ctc_cm_data.ipv4_pre_table.num_rules; i++) {
-		if (rule_index == rule_table[i])
-			break;
-	}
-
-	if (i == tpm_db.ctc_cm_data.ipv4_pre_table.num_rules) {
-		TPM_OS_ERROR(TPM_DB_MOD, " ipv4_pre_rule does not exist!\n");
-		return TPM_DB_ERR_REC_NOT_EXIST;
-	}
-
-	for (j = i; j < tpm_db.ctc_cm_data.ipv4_pre_table.num_rules; j++)
-		rule_table[j] = rule_table[j + 1];
-
-	rule_table[j] = TPM_DB_CNM_INVALID_IPV4_PRE_RULE_INDEX;
-	tpm_db.ctc_cm_data.ipv4_pre_table.num_rules--;
-
-	*rule_num = i;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv4_pre_rule_num(uint32_t *num_rules)
-{
-	*num_rules = tpm_db.ctc_cm_data.ipv4_pre_table.num_rules;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_alloc_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t *key_idx)
-{
-	uint32_t i;
-
-	/*check param*/
-	if (key_idx == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].num_keys >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_DB_TBL_FULL;
-
-	for (i = 0; i < TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM; i++) {
-		if (tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[i].valid == TPM_FALSE)
-			break;
-	}
-
-	if (i >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_DB_INCONSISTENCY;
-
-	*key_idx = i;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_set_ipv4_pre_filter_key(tpm_src_port_type_t src_port,
-				       uint32_t key_idx,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_ipv4_acl_key_t *ipv4_key)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	/*check param*/
-	if (ipv4_key == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid != TPM_FALSE)
-		return TPM_DB_ERR_REC_EXIST;
-
-	key->valid = TPM_TRUE;
-	key->num_users = 0;
-	key->parse_rule_bm = parse_rule_bm;
-	memcpy(&key->ipv4_key, ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-
-	tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].num_keys++;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_del_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t key_idx)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	memset(key, 0, sizeof(tpm_db_cnm_ipv4_pre_filter_key_t));
-
-	tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].num_keys--;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_set_gmac_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t bucket_size,
-				   uint32_t rate_limit,
-				   uint32_t prio)
-{
-	/*check param*/
-	if (gmac_i >= TPM_MAX_NUM_TX_PORTS)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	tpm_db.gmac_tx[gmac_i].bucket_size = bucket_size;
-	tpm_db.gmac_tx[gmac_i].rate_limit = rate_limit;
-	tpm_db.gmac_tx[gmac_i].prio = prio;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_gmac_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t *bucket_size,
-				   uint32_t *rate_limit,
-				   uint32_t *prio)
-{
-	/*check param*/
-	if (gmac_i >= TPM_MAX_NUM_TX_PORTS)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	*bucket_size = tpm_db.gmac_tx[gmac_i].bucket_size;
-	*rate_limit = tpm_db.gmac_tx[gmac_i].rate_limit;
-	*prio = tpm_db.gmac_tx[gmac_i].prio;
-
-	return TPM_DB_OK;
-}
-int32_t tpm_db_set_gmac_q_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t queue,
-				   uint32_t bucket_size,
-				   uint32_t rate_limit,
-				   uint32_t wrr)
-{
-	/*check param*/
-	if (gmac_i >= TPM_MAX_NUM_TX_PORTS)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (queue >= TPM_MAX_NUM_TX_QUEUE)
-		return TPM_DB_ERR_INV_INPUT;
-
-	tpm_db.gmac_tx[gmac_i].tx_queue[queue].bucket_size = bucket_size;
-	tpm_db.gmac_tx[gmac_i].tx_queue[queue].rate_limit = rate_limit;
-	tpm_db.gmac_tx[gmac_i].tx_queue[queue].wrr = wrr;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_gmac_q_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t queue,
-				   uint32_t *bucket_size,
-				   uint32_t *rate_limit,
-				   uint32_t *wrr)
-{
-	/*check param*/
-	if (gmac_i >= TPM_MAX_NUM_TX_PORTS)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (queue >= TPM_MAX_NUM_TX_QUEUE)
-		return TPM_DB_ERR_INV_INPUT;
-
-	*bucket_size = tpm_db.gmac_tx[gmac_i].tx_queue[queue].bucket_size;
-	*rate_limit = tpm_db.gmac_tx[gmac_i].tx_queue[queue].rate_limit;
-	*wrr = tpm_db.gmac_tx[gmac_i].tx_queue[queue].wrr;
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv4_pre_filter_key_num(tpm_src_port_type_t src_port, uint32_t *num_keys)
-{
-	/*check param*/
-	if (num_keys == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	*num_keys = tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].num_keys;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv4_pre_filter_key(tpm_src_port_type_t src_port,
-				       uint32_t key_idx,
-				       tpm_parse_fields_t *parse_rule_bm,
-				       tpm_ipv4_acl_key_t *ipv4_key)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	/*check param*/
-	if (parse_rule_bm == NULL || ipv4_key == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	*parse_rule_bm = key->parse_rule_bm;
-	memcpy(ipv4_key, &key->ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_find_ipv4_pre_filter_key(tpm_src_port_type_t src_port,
-					tpm_parse_fields_t parse_rule_bm,
-					tpm_ipv4_acl_key_t *ipv4_key,
-					uint32_t *key_idx)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[0];
-	uint32_t i;
-
-	/*check param*/
-	if (key_idx == NULL || ipv4_key == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	for (i = 0; i < TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM; i++) {
-		if (key[i].valid == TPM_FALSE)
-			continue;
-		if (key[i].parse_rule_bm != parse_rule_bm)
-			continue;
-		if (parse_rule_bm & TPM_IPv4_PARSE_SIP) {
-			if (memcmp(ipv4_key->ipv4_src_ip_add, key[i].ipv4_key.ipv4_src_ip_add, 4 * sizeof(uint8_t)) ||
-				memcmp(ipv4_key->ipv4_src_ip_add_mask, key[i].ipv4_key.ipv4_src_ip_add_mask, 4 * sizeof(uint8_t)))
-				continue;
-		}
-		if (parse_rule_bm & TPM_IPv4_PARSE_DIP) {
-			if (memcmp(ipv4_key->ipv4_dst_ip_add, key[i].ipv4_key.ipv4_dst_ip_add, 4 * sizeof(uint8_t)) ||
-				memcmp(ipv4_key->ipv4_dst_ip_add_mask, key[i].ipv4_key.ipv4_dst_ip_add_mask, 4 * sizeof(uint8_t)))
-				continue;
-		}
-		if (parse_rule_bm & TPM_IPv4_PARSE_DSCP) {
-			if ((ipv4_key->ipv4_dscp & ipv4_key->ipv4_dscp_mask) != (key[i].ipv4_key.ipv4_dscp & key[i].ipv4_key.ipv4_dscp_mask))
-				continue;
-		}
-		if (parse_rule_bm & TPM_IPv4_PARSE_PROTO) {
-			if (ipv4_key->ipv4_proto != key[i].ipv4_key.ipv4_proto)
-				continue;
-		}
-		if (parse_rule_bm & TPM_PARSE_L4_SRC) {
-			if (ipv4_key->l4_src_port != key[i].ipv4_key.l4_src_port)
-				continue;
-		}
-		if (parse_rule_bm & TPM_PARSE_L4_DST) {
-			if (ipv4_key->l4_dst_port != key[i].ipv4_key.l4_dst_port)
-				continue;
-		}
-		*key_idx = i;
-		return TPM_DB_OK;
-	}
-
-	*key_idx = TPM_CNM_INVALID_IPV4_PRE_FILTER_KEY_ID;
-	return TPM_DB_ERR_REC_NOT_EXIST;
-}
-
-int32_t tpm_db_inc_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	key->num_users++;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_dec_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	if (key->num_users > 0)
-		key->num_users--;
-	return TPM_DB_OK;
-}
-
-int32_t tpm_db_get_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t *num_users)
-{
-	tpm_db_cnm_ipv4_pre_filter_key_t *key = NULL;
-
-	/*check param*/
-	if (num_users == NULL)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	if (key_idx >= TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM)
-		return TPM_DB_ERR_REC_INV;
-
-	if(src_port >= TPM_MAX_NUM_UNI_PORTS) {
-		TPM_OS_ERROR(TPM_DB_MOD, "invalid input Src Port(%d)\n", src_port);
-		return TPM_DB_ERR_INV_INPUT;
-	}
-
-	key = &tpm_db.ctc_cm_data.ipv4_pre_filter[src_port].key[key_idx];
-
-	if (key->valid == TPM_FALSE)
-		return TPM_DB_ERR_REC_NOT_EXIST;
-
-	*num_users = key->num_users;
-	return TPM_DB_OK;
-}
-
-
-/*******************************************************************************
-* tpm_db_mac_learn_mod_idx_set()
-*
-* DESCRIPTION: Set mac leanring pmt mod index, just for mac learning
-*
-* INPUTS:
-* mod_idx
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mac_learn_mod_idx_set(uint32_t mod_idx)
-{
-	tpm_db.mac_learn_mod_idx = mod_idx;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_mac_learn_mod_idx_get()
-*
-* DESCRIPTION: Get mac leanring pmt mod index, just for mac learning
-*
-* INPUTS:
-* mod_idx
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_mac_learn_mod_idx_get(uint32_t *mod_idx)
-{
-	*mod_idx = tpm_db.mac_learn_mod_idx;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_ds_mac_based_trunk_enable_set()
-*
-* DESCRIPTION: Set ds_mac_based_trunk_enable
-*
-* INPUTS:
-* enable       -   ds_mac_based_trunk_enable
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ds_mac_based_trunk_enable_set(tpm_db_ds_mac_based_trunk_enable_t enable)
-{
-	tpm_db.ds_mac_based_trunk_enable = enable;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_ds_mac_based_trunk_enable_get()
-*
-* DESCRIPTION: Get ds_mac_based_trunk_enable
-*
-* INPUTS:
-*
-* OUTPUTS:
-* enable       -   ds_mac_based_trunk_enable
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_ds_mac_based_trunk_enable_get(tpm_db_ds_mac_based_trunk_enable_t *enable)
-{
-	*enable = tpm_db.ds_mac_based_trunk_enable;
-
-	return (TPM_DB_OK);
-}
-int32_t tpm_db_api_data_backup(void)
-{
-	memcpy(hot_swap_bak_db.api_ent_mem_area_bak, tpm_db.api_ent_mem_area, sizeof(tpm_db.api_ent_mem_area));
-	memcpy(hot_swap_bak_db.api_section_bak, tpm_db.api_section, sizeof(tpm_db.api_section));
-	memcpy(hot_swap_bak_db.mc_vid_port_cfg_bak, tpm_db.mc_vid_port_cfg, sizeof(tpm_db.mc_vid_port_cfg));
-	memcpy(hot_swap_bak_db.gmac_tx_bak, tpm_db.gmac_tx, sizeof(tpm_db.gmac_tx));
-	memcpy(hot_swap_bak_db.igmp_proxy_sa_mac, tpm_db_mc_igmp_proxy_sa_mac, 6);
-	hot_swap_bak_db.igmp_proxy_sa_mac_valid = tpm_db_mc_igmp_proxy_sa_mac_valid;
-	hot_swap_bak_db.switch_init = tpm_db.func_profile.switch_init;
-
-	return (TPM_DB_OK);
-}
-int32_t tpm_db_api_data_rcvr(void)
-{
-	memcpy(tpm_db.mc_vid_port_cfg, hot_swap_bak_db.mc_vid_port_cfg_bak, sizeof(tpm_db.mc_vid_port_cfg));
-	memcpy(tpm_db.gmac_tx, hot_swap_bak_db.gmac_tx_bak, sizeof(tpm_db.gmac_tx));
-	memcpy(tpm_db_mc_igmp_proxy_sa_mac, hot_swap_bak_db.igmp_proxy_sa_mac, 6);
-	tpm_db_mc_igmp_proxy_sa_mac_valid = hot_swap_bak_db.igmp_proxy_sa_mac_valid;
-	tpm_db.func_profile.switch_init = hot_swap_bak_db.switch_init;
-
-	return (TPM_DB_OK);
-}
-void tpm_db_exchange_value(uint32_t *v1, uint32_t *v2)
-{
-	uint32_t tmp;
-
-	tmp = *v1;
-	*v1 = *v2;
-	*v2 = tmp;
-
-	return;
-}
-int32_t tpm_db_wan_lan_rate_limit_exchange_db(tpm_db_gmac_tx_t *gmac_tx)
-{
-	int32_t queue;
-
-	for (queue = 0; queue < TPM_MAX_NUM_TX_QUEUE; queue++) {
-		tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].tx_queue[queue].bucket_size),
-					&(gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[queue].bucket_size));
-		tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].tx_queue[queue].rate_limit),
-					&(gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[queue].rate_limit));
-		tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].tx_queue[queue].wrr),
-					&(gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[queue].wrr));
-	}
-
-	tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].bucket_size),
-				&(gmac_tx[TPM_TX_MOD_GMAC1].bucket_size));
-	tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].rate_limit),
-				&(gmac_tx[TPM_TX_MOD_GMAC1].rate_limit));
-	tpm_db_exchange_value(&(gmac_tx[TPM_TX_MOD_GMAC0].prio),
-				&(gmac_tx[TPM_TX_MOD_GMAC1].prio));
-
-	return (TPM_DB_OK);
-}
-int32_t tpm_db_wan_lan_rate_limit_exchange(void)
-{
-	tpm_db_wan_lan_rate_limit_exchange_db(tpm_db.gmac_tx);
-	tpm_db_wan_lan_rate_limit_exchange_db(hot_swap_bak_db.gmac_tx_bak);
-	return (TPM_DB_OK);
-}
-
-int32_t tpm_db_api_section_bak_num_entries_get(tpm_api_sections_t api_section, uint32_t *num_entries)
-{
-	if (hot_swap_bak_db.api_section_bak[api_section].valid == TPM_DB_INVALID) {
-		printk("api_section: %d is not valid\n", api_section);
-		*num_entries = 0;
-	} else
-		*num_entries = hot_swap_bak_db.api_section_bak[api_section].num_valid_entries;
-
-	printk("api_section: %d, number_valid: %d\n", api_section, *num_entries);
-	return (TPM_DB_OK);
-}
-int32_t tpm_db_api_section_bak_ent_tbl_get(tpm_api_sections_t api_sec, tpm_db_api_entry_t *api_ent_mem_area, uint32_t index)
-{
-	if (ILLEGAL_API_SEC(api_sec))
-		IF_ERROR_I(TPM_DB_ERR_REC_NOT_EXIST, api_sec);
-
-	if (NULL == api_ent_mem_area)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memcpy(api_ent_mem_area,
-		&hot_swap_bak_db.api_ent_mem_area_bak[(hot_swap_bak_db.api_section_bak[api_sec].table_start) + index],
-		sizeof(tpm_db_api_entry_t));
-
-	return (TPM_DB_OK);
-}
-int32_t tpm_db_api_entry_bak_get_next(tpm_api_sections_t api_section,
-				      int32_t cur_rule,
-				      int32_t *next_rule)
-{
-	int32_t ind = -1;
-	int32_t i;
-	uint32_t min_rule, l_next_rule = ~0;
-	tpm_db_api_entry_t *api_tbl;
-
-	api_tbl = &(hot_swap_bak_db.api_ent_mem_area_bak[hot_swap_bak_db.api_section_bak[api_section].table_start]);
-
-	if (cur_rule <= -1)
-		min_rule = 0;
-	else
-		min_rule = cur_rule + 1;
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "min_rule(%d) \n", min_rule); */
-
-	for (i = 0; i <= hot_swap_bak_db.api_section_bak[api_section].last_valid_index; i++) {
-		if (((api_tbl + i)->valid == TPM_DB_VALID) &&
-		    ((api_tbl + i)->rule_num >= min_rule) && ((api_tbl + i)->rule_num < l_next_rule)) {
-			l_next_rule = (api_tbl + i)->rule_num;
-			ind = i;
-			TPM_OS_INFO(TPM_DB_MOD, "rule_num(%d), rule_idx(%d) update\n", (api_tbl + i)->rule_num, (api_tbl + i)->rule_idx);
-		} else
-			TPM_OS_INFO(TPM_DB_MOD, "rule_num(%d), rule_idx(%d) \n", (api_tbl + i)->rule_num, (api_tbl + i)->rule_idx);
-	}
-
-	/*TPM_OS_DEBUG(TPM_DB_MOD, "l_next_rule(%d) ind(%d) \n", l_next_rule, ind); */
-
-	if ((l_next_rule < (uint32_t) (~0)) && (ind != -1)) {
-		*next_rule = ind;
-	} else		/* Not found */
-		*next_rule = -1;
-
-	TPM_OS_INFO(TPM_DB_MOD, "next_rule(%d) \n", *next_rule);
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_max_uni_port_nr_get()
-*
-* DESCRIPTION: Get max UNI port number
-*
-* INPUTS:
-*
-* OUTPUTS:
-* max_uni_port_nr       -   max UNI port number
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_max_uni_port_nr_get(uint32_t *max_uni_port_nr)
-{
-	*max_uni_port_nr = tpm_db.max_uni_port_nr + 1;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_uni_egr_rate_limit_set()
-*
-* DESCRIPTION: Set GMAC UNI egress rate limit
-*
-* INPUTS:
-*        port - GMAC UNI port to do rate limit
-*        rate_limit - rate limit value
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_uni_egr_rate_limit_set(tpm_src_port_type_t port, uint32_t rate_limit)
-{
-	tpm_db.gmac_uni_egr_rate_limit[port] = rate_limit;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_uni_egr_rate_limit_get()
-*
-* DESCRIPTION: Get GMAC UNI egress rate limit
-*
-* INPUTS:
-*        port - GMAC UNI port to do rate limit
-* OUTPUTS:
-*        rate_limit - rate limit value, if value got is 0, means no rate limit set
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_uni_egr_rate_limit_get(tpm_src_port_type_t port, uint32_t *rate_limit)
-{
-	if (NULL == rate_limit)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	*rate_limit = tpm_db.gmac_uni_egr_rate_limit[port];
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_lpk_uni_ingr_rate_limit_set()
-*
-* DESCRIPTION: Set GMAC UNI ingress rate limit only with loopback mode
-*
-* INPUTS:
-*        port - GMAC UNI port to do rate limit
-*        rate_limit - rate limit value
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_lpk_uni_ingr_rate_limit_set(tpm_src_port_type_t port, tpm_db_gmac_lpk_uni_ingr_rate_limit_t rate_limit)
-{
-	tpm_db.gmac_lpk_uni_ingr_rate_limit[port].count_mode = rate_limit.count_mode;
-	tpm_db.gmac_lpk_uni_ingr_rate_limit[port].cir = rate_limit.cir;
-	tpm_db.gmac_lpk_uni_ingr_rate_limit[port].cbs = rate_limit.cbs;
-	tpm_db.gmac_lpk_uni_ingr_rate_limit[port].ebs = rate_limit.ebs;
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_gmac_lpk_uni_ingr_rate_limit_get()
-*
-* DESCRIPTION: Get GMAC UNI ingress rate limit with loopback mode
-*
-* INPUTS:
-*        port - GMAC UNI port to do rate limit
-* OUTPUTS:
-*        rate_limit - rate limit value, if value got is 0, means no rate limit set
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_gmac_lpk_uni_ingr_rate_limit_get(tpm_src_port_type_t port, tpm_db_gmac_lpk_uni_ingr_rate_limit_t *rate_limit)
-{
-	if (NULL == rate_limit)
-		return (TPM_DB_ERR_INV_INPUT);
-
-	memcpy(rate_limit,
-	       &tpm_db.gmac_lpk_uni_ingr_rate_limit[port],
-	       sizeof(tpm_db_gmac_lpk_uni_ingr_rate_limit_t));
-
-	return (TPM_DB_OK);
-}
-
-/*******************************************************************************
-* tpm_db_init()
-*
-* DESCRIPTION:      Perform DB Initialization. Set all structures to 0, and all valid fields to TPM_DB_INVALID
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_db_init(void)
-{
-	uint32_t i, j;
-
-	/* Erase DB */
-	memset(&tpm_db, 0, sizeof(tpm_db_t));
-
-	/* Set All entries in all structures to invalid */
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-		tpm_db.eth_ports[i].valid = TPM_DB_INVALID;
-
-	/* GMAC Connect */
-	for (i = 0; i < TPM_NUM_GMACS; i++)
-		tpm_db.gmac_port_conf[i].valid = TPM_DB_INVALID;
-	tpm_db.num_valid_tcont_llid = 0;
-
-	/* GMAC Func. */
-	for (i = 0; i < TPM_MAX_NUM_GMACS; i++)
-		tpm_db.gmac_func[i] = TPM_GMAC_FUNC_NONE;
-
-	for (i = 0; i < TPM_MAX_NUM_TX_PORTS; i++) {
-		tpm_db.gmac_tx[i].valid = TPM_DB_INVALID;
-		for (j = 0; j < TPM_MAX_NUM_TX_QUEUE; j++)
-			tpm_db.gmac_tx[i].tx_queue[j].valid = TPM_DB_INVALID;
-	}
-
-	/* IGMP */
-	tpm_db.igmp_def.frwd_mode[TPM_SRC_PORT_WAN] = TPM_IGMP_FRWD_MODE_DROP;
-	for (i = TPM_SRC_PORT_UNI_0; i <= TPM_SRC_PORT_UNI_7; i++)
-		 tpm_db.igmp_def.frwd_mode[i] = TPM_IGMP_FRWD_MODE_DROP;
-	tpm_db.igmp_def.cpu_queue = 0;
-	tpm_db.igmp_def.igmp_snoop_enable = TPM_FALSE;
-
-	tpm_db.igmp_def.mc_lpbk_enable[TPM_IP_VER_4] = TPM_FALSE;
-	tpm_db.igmp_def.mc_lpbk_enable[TPM_IP_VER_6] = TPM_FALSE;
-
-	/* Misc. */
-	tpm_db.init_misc.omci_etype = TPM_DB_INVALID;
-	tpm_db.init_misc.pnc_init_debug_port = TPM_DB_INVALID;
-	tpm_db.init_misc.pon_type = TPM_DB_INVALID;
-	tpm_db.init_misc.ds_mh_set_conf = TPM_DB_INVALID;
-	tpm_db.init_misc.cfg_pnc_parse = TPM_DB_INVALID;
-	tpm_db.init_misc.cpu_loopback = TPM_DB_INVALID;
-	tpm_db.init_misc.tpm_init_succeeded = TPM_DB_INVALID;
-	tpm_db.func_profile.virt_uni_info.enabled = TPM_DB_INVALID;
-	tpm_db.func_profile.virt_uni_info.switch_port = TPM_DB_INVALID;
-	tpm_db.func_profile.virt_uni_info.uni_port = TPM_DB_INVALID;
-
-	/* Ownership */
-	for (i = 0; i < TPM_MAX_API_TYPES; i++)
-		tpm_db.owners[i].valid = TPM_DB_INVALID;
-
-	/* API Ranges */
-	for (i = 0; i < TPM_MAX_NUM_API_SECTIONS; i++) {
-		for (j = 0; j < TPM_NUM_DIRECTIONS; j++)
-			tpm_db_api_section_invalidate(i);
-	}
-
-	/* API_Busy */
-	tpm_db_api_busy_init();
-
-	/* API Entries Area, stripe whole area */
-	tpm_db_api_entries_area_reset();
-
-	/* PNC Tables */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++)
-		tpm_db.pnc_range[i].valid = TPM_DB_INVALID;
-
-	for (i = 0; i < TPM_PNC_SIZE; i++)
-		tpm_db.pnc_shadow[i].valid = TPM_DB_INVALID;
-
-	/* Modification Tables */
-	tpm_db_mod2_init();
-
-	/* Vlan Ethertype */
-	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++)
-		tpm_db.vlan_etype[i].valid = TPM_DB_INVALID;
-
-	/* Multicast Tables */
-	tpm_db_mc_lpbk_entries_num = 0;
-	memset(tpm_db_mc_stream_table, 0, TPM_MC_MAX_STREAM_NUM * sizeof(tpm_db_mc_stream_entry_t *));
-	memset(tpm_db_mc_mac_table, 0, TPM_MC_MAX_MAC_NUM * sizeof(tpm_db_mc_mac_entry_t *));
-	memset(tpm_db_mc_lpbk_table, 0, TPM_MC_MAX_LPBK_ENTRIES_NUM * sizeof(tpm_db_mc_lpbk_entry_t *));
-	memset(tpm_db_mc_vlan_xits_table, 0, TPM_MC_MAX_MVLAN_XITS_NUM * sizeof(tpm_db_mc_vlan_entry_t *));
-	memset(tpm_db_mc_virt_uni_entry_state_table, 0, TPM_MC_MAX_STREAM_NUM * sizeof(uint8_t));
-	tpm_db_mc_igmp_proxy_sa_mac_valid = 0;
-	memset(tpm_db_mc_igmp_proxy_sa_mac, 0, 6 * sizeof(uint8_t));
-
-	/* IPV6 Flow Tables */
-	tpm_db_init_ipv6_5t_flow_reset();
-
-	/* CTC CnM db */
-	tpm_db_ctc_cm_db_reset();
-
-	/* IPv6 MC SIP db */
-	tpm_db_ipv6_mc_sip_db_reset();
-
-	return (TPM_DB_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.h
deleted file mode 100644
index 434e7c9..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_db.h
+++ /dev/null
@@ -1,1453 +0,0 @@
-
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_db.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.4
-*
-*
-*******************************************************************************/
-#ifndef _TPM_DB_H_
-#define _TPM_DB_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-typedef enum tpm_db_error {
-	TPM_DB_OK = TPM_OK,
-	TPM_DB_ERR_DB_TBL_FULL,
-	TPM_DB_ERR_DB_TBL_INV,
-	TPM_DB_ERR_INV_INPUT,
-	TPM_DB_ERR_DB_INCONSISTENCY,
-	TPM_DB_ERR_RANGE_EXIST,
-	TPM_DB_ERR_REC_NOT_EXIST,
-	TPM_DB_ERR_REC_EXIST,
-	TPM_DB_ERR_REC_INV,
-	TPM_DB_ERR_REC_STATUS_ERR,
-	TPM_DB_ERR_MEM_ALLOC_FAIL,
-	TPM_DB_ERR_PORT_NUM = 0xFF
-} tpm_db_error_t;
-
-/* Possible roles an Ethernet GMAC or PON MAC can play */
-typedef enum {
-	TPM_GMAC_FUNC_NONE,
-	TPM_GMAC_FUNC_LAN,
-	TPM_GMAC_FUNC_WAN,
-	TPM_GMAC_FUNC_LAN_AND_WAN,
-	TPM_GMAC_FUNC_VIRT_UNI,
-	TPM_GMAC_FUNC_LAN_UNI,
-	TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI /* For Media Convert Loopback mode */
-} tpm_db_gmac_func_t;
-
-typedef enum {
-	TPM_MOD_ENTRY_FREE,
-	TPM_MOD_ENTRY_BOOKED,
-	TPM_MOD_ENTRY_OCCUPIED,
-	TPM_MOD_ENTRY_RESERVED,
-	TPM_MOD_ENTRY_SPLIT_MOD,
-	TPM_MOD_ENTRY_STATUS_MAX,
-} tpm_mod_entry_status_t;
-
-typedef enum {
-	TPM_PNC_RNG_LAST_INIT_DEF,	/* Last entry in PnC range is regular entry */
-	TPM_PNC_RNG_LAST_INIT_DROP,	/* Last entry in PnC range is hardcoded to DROP */
-	TPM_PNC_RNG_LAST_INIT_TRAP	/* Last entry in PnC range is hardcoded to TRAP to CPU */
-} tpm_db_pnc_rng_last_ent_t;
-
-typedef enum {
-	TPM_GMAC1_QUEUE_DATA_TRAFFIC,
-	TPM_GMAC1_QUEUE_MAC_LEARN_TRAFFIC,
-}tpm_db_gmac1_lpk_queue_type_t;
-
-typedef tpm_init_sched_t tpm_db_sched_t;
-typedef tpm_init_port_admin_t tpm_db_port_admin_t;
-typedef tpm_init_port_speed_t tpm_db_port_speed_t;
-typedef tpm_init_port_duplex_t tpm_db_port_duplex_t;
-typedef tpm_init_chip_conn_t tpm_db_chip_conn_t;
-typedef tpm_init_int_conn_t tpm_db_int_conn_t;
-typedef tpm_init_gmac_conn_t tpm_db_gmac_conn_t;
-typedef tpm_init_gmac_bufs_t tpm_db_gmac_bufs_t;
-typedef tpm_init_gmac_rx_t tpm_db_gmac_rx_t;
-typedef tpm_init_gmac_rxq_t tpm_db_gmac_rxq_t;
-typedef tpm_init_txq_owner_t tpm_db_txq_owner_t;
-typedef tpm_init_pon_type_t tpm_db_pon_type_t;
-typedef tpm_init_tx_mod_t tpm_db_tx_mod_t;
-typedef tpm_init_mh_src_t tpm_db_mh_src_t;
-typedef tpm_init_mtu_setting_enable_t tpm_db_mtu_setting_enable_t;
-typedef tpm_init_pppoe_add_enable_t tpm_db_pppoe_add_enable_t;
-typedef tpm_init_ttl_illegal_action_t tpm_db_ttl_illegal_action_t;
-typedef tpm_init_fc_params_t tpm_db_fc_params_t;
-typedef tpm_init_tcp_flag_check_t tpm_db_tcp_flag_check_t;
-typedef tpm_init_ety_dsa_enable_t tpm_db_ety_dsa_enable_t;
-typedef tpm_init_split_mod_enable_t tpm_db_split_mod_enable_t;
-typedef tpm_init_ctc_cm_enable_t    tpm_db_ctc_cm_enable_t;
-typedef tpm_init_split_mod_mode_t    tpm_db_split_mod_mode_t;
-typedef tpm_ctc_cm_ipv6_parse_win_t tpm_db_ctc_cm_ipv6_parse_win_t;
-typedef tpm_init_ds_mac_based_trunk_enable_t tpm_db_ds_mac_based_trunk_enable_t;
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-
-#define TPM_DB_TOTAL_API_SIZE               (512)
-
-/* Defines the amount of memory margin (in units of tpm_db_api_entry_t),
-	between each pair of API Range Entries Table. */
-#define TPM_DB_API_SECTION_MARGIN_SIZE      (3)
-
-#define TPM_DB_API_NOT_BUSY		    (-1)
-
-/* Define total   Margin memory allocated for the margin between each pair
-	of API Range tables, + before the first API Range Entries table.
-	(in units of tpm_db_api_entry_t) */
-#define TPM_DB_API_SECTION_MARGIN_ALLOC     \
-	(TPM_DB_API_SECTION_MARGIN_SIZE * (TPM_MAX_NUM_API_SECTIONS * TPM_NUM_DIRECTIONS + 1))
-
-/* Total table size is tot_num_api_entries + tot_margin */
-#define TPM_DB_API_ENTRIES_TBL_SIZE         (TPM_DB_TOTAL_API_SIZE + TPM_DB_API_SECTION_MARGIN_ALLOC)
-#define TPM_DB_VALID                        (1)
-#define TPM_DB_INVALID                      (0xBEEF)
-#define TPM_DB_INVALID_OWNER                (0xFF)
-
-#define TPM_MOD2_NULL_ENT_IDX               (0x1000)
-
-#define TPM_MOD2_MAIN_CHAIN_SIZE            (19)
-#define TPM_MOD2_SUBR_MAC_CHAIN_SIZE        (3)
-#define TPM_MOD2_SUBR_IP_CHAIN_SIZE         (2)
-
-#define TPM_MOD2_JUMP_AREA_SIZE             (203)
-#define TPM_MOD2_MAIN_AREA_SIZE             (TPM_MOD2_MAIN_CHAIN_SIZE * TPM_MOD2_JUMP_AREA_SIZE)
-#define TPM_MOD2_SUBR_AREA_SIZE             (0)
-#define TPM_MOD2_APPL_SUBR_AREA_SIZE        (35)
-
-#define TPM_MC_VID_NUM_MAX                  (1 << TPM_NUM_MC_VID_BITS)
-#define TPM_MC_VLAN_MAX_PNC_RULE_NUM        (16)
-
-#define TPM_MC_IPv6_SIP_NUM_MAX             (8)
-
-#define TPM_MOD2_MAX_MH_CHAIN_SIZE                   (1)
-#define TPM_MOD2_MAX_MAC_CHAIN_SIZE                  (3)
-#define TPM_MOD2_MAX_VLAN_CHAIN_SIZE                 (2)
-#define TPM_MOD2_MAX_PPPOE_CHAIN_SIZE                (2)
-#define TPM_MOD2_MAX_IPV6_PPPOE_CHAIN_SIZE           (5)
-#define TPM_MOD2_MAX_L2_TWO_TAG_CHAIN_SIZE           (4)
-#define TPM_MOD2_MAX_L2_ONE_TAG_CHAIN_SIZE           (3)
-#define TPM_MOD2_MAX_IPV4_NAPT_W_PPPOE_CHAIN_SIZE    (14)	/* Single Vlan Modification */
-#define TPM_MOD2_MAX_IPV4_NAPT_WO_PPPOE_CHAIN_SIZE   (13)
-#define TPM_MOD2_MAX_IPV4_MC_W_MH_CHAIN_SIZE         (8)	/* PPPoE + Proxy (Single Vlan Modification) */
-#define TPM_MOD2_MAX_IPV4_MC_WO_MH_CHAIN_SIZE        (7)
-#define TPM_MOD2_MAX_ROUTE_W_PPPOE_CHAIN_SIZE   (7)
-#define TPM_MOD2_MAX_ROUTE_WO_PPPOE_CHAIN_SIZE  (6)
-#define TPM_MOD2_MAX_IPV6_MC_W_MH_CHAIN_SIZE         (8)
-#define TPM_MOD2_MAX_IPV6_MC_WO_MH_CHAIN_SIZE        (7)
-
-#define TPM_MOD2_TOTAL_PMT_SIZE                (4096 - 1/* zero entry is reserved */)
-#define TPM_MOD2_MAX_JUMP_ENTRIES_NUM          (1024 - 1/* zero entry is reserved */)
-
-#define TPM_DB_IPV6_MAX_KEY_NUM               (128)
-
-#define TPM_DB_IPV6_MAX_SUBFLOW_NUM           ((1 << TPM_NUM_IPV6_SUBFLOW_BITS) - 1)
-#define TPM_DB_IPV6_MAX_5T_FLOW_NUM           (128)
-
-#define TPM_DB_INVALID_IPV6_KEY_ID            (0xFFFF)
-#define TPM_DB_INVALID_IPV6_FLOW_ID           (0xFFFF)
-
-#define TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK  (TPM_IPv6_PARSE_NH | TPM_PARSE_L4_SRC | TPM_PARSE_L4_DST)
-#define TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK (TPM_IPv6_PARSE_SIP | TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK)
-
-#define TPM_DB_SPLIT_MOD_P_BIT_MAX (7)
-#define TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX (8)
-#define TPM_DB_SPLIT_MOD_P_BIT_NO_SET (0)
-#define TPM_DB_SPLIT_MOD_NUM_VLANS_MAX (18)
-#define TPM_DB_SPLIT_MOD_INIT_VLANS_NUM (2)
-
-#define TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM    (TPM_CNM_IPV4_PRE_FILTER_KEY_MAX)
-#define TPM_DB_CNM_MAX_IPV4_PRE_FILTER_RULE_NUM   (TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_PORT * TPM_MAX_NUM_UNI_PORTS)
-
-#define TPM_DB_CNM_INVALID_IPV4_PRE_RULE_INDEX    (0x0)
-
-#define TPM_DB_CNM_GEN_IPV4_PRE_RULE_INDEX(p, k)  \
-			((((k) & TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_MASK) << TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_OFFSET) | \
-			(((p) & TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_MASK) << TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_OFFSET))
-
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_OFFSET    (0)
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_LEN       (16)
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_MASK      ((1 << TPM_DB_CNM_IPV4_PRE_RULE_INDEX_PORT_LEN) - 1)
-
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_OFFSET     (16)
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_LEN        (16)
-#define TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_MASK       ((1 << TPM_DB_CNM_IPV4_PRE_RULE_INDEX_KEY_LEN) - 1)
-
-/*************************************************************/
-/*               STRUCTURES                                  */
-/*************************************************************/
-
-/*****************************/
-/* API DB related structures */
-/*****************************/
-
-/* Structure represents the connection between an API call and the modification table entry (if exists)
- * that implemented the modification request in that API call */
-typedef struct {
-	uint32_t mod_cmd_ind;	/* Index to the modification command table related to this API entry */
-	tpm_gmacs_enum_t mod_cmd_mac; /* Only a single "dest MAC" can be set.If none are set, mod_cmd_ind is not used. */
-} tpm_db_mod_conn_t;
-
-/* Structure represents the connection between an API call and a PnC entry that implemented
- * or partially implemented that API call */
-typedef struct {
-	uint32_t pnc_range;	/* The pnc_range where the API call was implemented */
-	uint32_t pnc_index;	/* The index in the PnC range where the API call is implemented */
-} tpm_db_pnc_conn_entry_t;
-
-/* Structure represents the connection between an API call and all the PnC entries that implemented the API call */
-typedef struct {
-	uint32_t num_pnc_ranges;	/* Number of PNC entries associated with this API entry,
-					 * equals to '1' unless the API call spans over multiple PnC ranges,
-					 * e.g. IPv6 DIP+SIP */
-	/* Upto TPM_MAX_API_MULTI_RANGES PnC entries may be needed to implement an API call */
-	tpm_db_pnc_conn_entry_t pnc_conn_tbl[TPM_MAX_API_MULTI_RANGES];
-} tpm_db_pnc_conn_t;
-
-/* Structure represents an API call, including all param data and the link to Pnc and modif_table implementation */
-typedef struct {
-	uint32_t valid;		/* invalid - 0xBEEF */
-	uint32_t bi_dir;	/* Some API entries may be bi-directional */
-	uint32_t rule_num;	/* Current rule number in acl/table */
-	uint32_t rule_idx;	/* Original rule number in acl/table, when entry was created */
-	tpm_rule_entry_t api_rule_data;	/* tpm_rule_entry_t is defined in tpm_types.h */
-	tpm_db_mod_conn_t mod_tbl_conn;	/* API connection to the modification table */
-	tpm_db_pnc_conn_t pnc_tbl_conn;	/* API connection to the PnC */
-} tpm_db_api_entry_t;
-
-/* Structure represents an API acl/table */
-typedef struct {
-	uint32_t valid;
-	/* The primary pnc_range_id, for those api_sections that a uniquely linked onc_range. */
-	tpm_pnc_ranges_t prim_pnc_range;
-	uint32_t table_size;	/* (cont.) e.g. - All API's except for IPV6, IPV6 MC */
-	uint32_t table_start;	/* Start index in the api_ent_mem_area */
-	uint32_t num_valid_entries;
-	int32_t last_valid_entry;	/* Equals to rule with highest rulenum in the api_table */
-	int32_t last_valid_index;	/* Highest Occupied Index in the api_table */
-} tpm_db_api_section_t;
-
-typedef struct {
-	uint32_t table_size;	/* (cont.) e.g. - All API's except for IPV6, IPV6 MC */
-	uint32_t table_start;	/* Start index in the api_ent_mem_area */
-} tpm_db_api_check_t;
-
-/*****************************/
-/* PNC  related structures   */
-/*****************************/
-
-typedef struct {
-	tpm_range_type_t range_type;	/* Pnc Range type, ACL or Table */
-	/* PnC range LookupId. If range spans over multiple lookupIds
-		(e.g. IPV6 DIP/DIP), this is the first one. */
-	uint32_t base_lu_id;
-	/* Determines the minimum reset_level that will perform a reset to this PnC range */
-	tpm_reset_level_enum_t min_reset_level;
-	uint32_t num_luids;	/* Number of LookupIds this PnC range spans over, usually '1'.
-					* Multiple lu_ids, when PnC range must support large number of sessions in the TCAM */
-	tpm_pnc_ranges_t range_id;
-	uint32_t range_start;	/* Range's Physical PnC start entry */
-	uint32_t range_end;	/* Range's Physical PnC end entry */
-	uint32_t range_size;	/* Range's Physical PnC size */
-	uint32_t cntr_grp;	/* Range's counter group number, from 0 to 3 */
-	/* Range's least used mask flag, 1: mask least used functions,
-		0:enbale least used function of this PnC range */
-	uint32_t lu_mask;
-	uint32_t api_start;	/* First available entry for api's. (Relative to range_start) */
-	uint32_t api_end;	/* Last available entry for api's. (Relative to range_start) */
-	/* How to init last entry of the PNC range (drop, trap to CPU, or no special treatment). */
-	tpm_db_pnc_rng_last_ent_t init_last_entry;
-	/* For pnc_ranges with multiple lu_id, init_last_entry must be repeated for each lu_id. */
-	/* GMAC's that are included in TCAM in last_entry (drop/trap) treatment. */
-	tpm_gmac_bm_t last_ent_portid;
-} tpm_db_pnc_range_conf_t;
-
-/* Structure represents a PnC range */
-typedef struct {
-	uint32_t free_entries;	/* Number of unused PnC entries in Range */
-	uint32_t num_resets;	/* Number of resets the range has been through */
-} tpm_db_pnc_range_oper_t;
-
-/* Structure represents a PnC range */
-typedef struct {
-	uint32_t valid;	/* invalid - 0xBEEF */
-	tpm_db_pnc_range_conf_t pnc_range_conf;
-	tpm_db_pnc_range_oper_t pnc_range_oper;
-} tpm_db_pnc_range_t;
-
-/* Structure represents DB info for a PnC entry */
-typedef struct {
-	uint32_t valid;		/* invalid - 0xBEEF */
-	tpm_pnc_all_t pnc_data;	/* Shadow of the PnC configuration of this entry */
-} tpm_db_pnc_shadow_t;
-
-typedef struct {
-	uint32_t valid;			/* invalid - 0xBEEF */
-	uint32_t tpid_ether_type;	/* Modification data associated with this entry */
-} tpm_db_etype_sel_t;
-
-typedef struct {
-	uint32_t tpm_reserved;	/* Reserved modification entries for TPM rules */
-} tpm_db_mod_config_t;
-
-typedef struct {
-	tpm_mod2_entry_t entry;	/* Modification table entry */
-	uint16_t pnc_num_ref;	/* Number of references from Pnc entries to this modification rule */
-	uint16_t owner;		/* Owner of modification entry - TPM rule or CPU application */
-	uint32_t valid;
-} tpm_db_mod2_shadow_t;
-
-typedef struct {
-	uint8_t mac[TPM_SA_LEN];
-	uint16_t mod_idx;	/* Start index of the commands chain in the modification table */
-	uint16_t mod_num_ref;	/* Number of references from modification table to this MAC entry */
-	uint32_t valid;
-
-} tpm_mod2_mac_translation_t;
-
-typedef struct {
-	uint8_t ip[TPM_IPV4_SIP_LEN];
-	uint16_t mod_idx;	/* Start index of the commands chain in the modification table */
-	uint16_t mod_num_ref;	/* Number of references from modification table to this MAC entry */
-	uint32_t valid;
-
-} tpm_mod2_ip_translation_t;
-
-/*typedef uint16_t (*parse_jump_index_func_t)(tpm_mod2_entry_t *pattern); */
-
-typedef struct {
-	tpm_mod_entry_status_t status;
-	tpm_mod2_entry_t pattern;
-} tpm_mod2_jump_pmt_info_t;
-
-typedef struct {
-	tpm_mod_entry_status_t status;
-	tpm_chain_type_t chain_type;
-	tpm_mod2_entry_t pattern;
-	uint16_t chain_id;
-} tpm_mod2_chain_pmt_info_t;
-
-typedef struct {
-	tpm_mod_entry_status_t status;
-	uint16_t base_entry;
-	uint16_t entry_num;
-	uint16_t user_num;
-} tpm_mod2_chain_info_t;
-
-typedef struct {
-	uint16_t base_entry;
-	uint16_t total_num;
-	uint16_t split_num;
-	uint16_t next_free[TPM_MAX_NUM_GMACS];
-	uint16_t next_split[TPM_MAX_NUM_GMACS];
-	uint16_t split_pbit_num;
-} tpm_mod2_jump_cfg_t;
-
-typedef struct {
-	uint16_t base_entry;
-	uint16_t subr_chain;
-	uint16_t total_num;
-	uint16_t max_size;
-	uint16_t next_free[TPM_MAX_NUM_GMACS];
-} tpm_mod2_chain_cfg_t;
-
-/*****************************/
-/* API Ownership Structures  */
-/*****************************/
-/*
-TBD
-Structures
-API Group enum
-*/
-/*****************************/
-/* Initialization Structures */
-/*****************************/
-
-typedef struct {
-	uint32_t omci_etype;
-	uint32_t tpm_init_succeeded;
-
-	uint32_t oam_channel_configured;/* omci or oam channel configured */
-	uint16_t omci_gemport;
-	uint32_t oam_cpu_rx_q;		/* omci cpu rx q or oam cpu rx q */
-	uint32_t oam_cpu_tx_q;		/* omci cpu tx q or oam cpu tx q */
-	uint32_t oam_cpu_tx_port;	/* omci tcount or oam llid */
-
-	uint32_t pnc_init_debug_port;
-	uint32_t oam_loopback_channel_configured;
-	tpm_db_pon_type_t pon_type;
-	tpm_gmacs_enum_t active_wan;
-
-	tpm_db_mh_src_t ds_mh_set_conf;
-
-	tpm_init_cfg_pnc_parse_t cfg_pnc_parse;
-
-	tpm_init_cpu_loopback_t cpu_loopback;
-
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	tpm_init_double_tag_t dbl_tag;
-
-#if 0
-	uint16_t vlan1_tpid;
-	uint16_t vlan2_tpid;
-#endif
-	tpm_init_tpid_opt_t tag_tpid;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable;
-
-} tpm_db_misc_t;
-
-/* Structure holds the IGMP/MLD settings */
-typedef struct {
-	uint32_t igmp_snoop_enable;
-	uint32_t frwd_mode[TPM_MAX_NUM_PORTS];
-	uint32_t cpu_queue;
-	tpm_mc_filter_mode_t filter_mode;
-	/*tpm_mc_igmp_mode_t      igmp_mode; */
-	uint8_t per_uni_vlan_xlat;
-	uint8_t mc_pppoe_enable;
-	uint8_t mc_hwf_queue;
-	uint8_t mc_cpu_queue;
-	uint8_t mc_lpbk_enable[TPM_IP_VER_MAX];
-} tpm_db_igmp_t;
-
-/* Structure holds the physical connections of all external Ethernet ports */
-typedef struct {
-	uint32_t valid;
-	tpm_src_port_type_t port_src;		/* Port number according to Device port numbering scheme 	*/
-	tpm_db_chip_conn_t chip_connect;	/* Connection to physical output lines on SoC 			*/
-	tpm_db_int_conn_t int_connect;		/* Internal Ethernet device port is connected to 		*/
-	uint32_t switch_port;			/* Port of Internal_Switch, the port is connected to 		*/
-} tpm_db_eth_port_conf_t;
-
-/* Structure holds the physical connections of the KW2 SoC */
-typedef struct {
-	uint32_t		valid;
-	tpm_init_gmac_conn_t	conn;
-	tpm_src_port_type_t	port_src;
-} tpm_db_gmac_conn_conf_t;
-
-typedef struct {
-	uint32_t valid;
-	tpm_db_sched_t sched_method;
-	tpm_db_txq_owner_t queue_owner;
-	uint32_t owner_queue_num;
-	uint32_t queue_size;
-	uint32_t queue_weight;
-	uint32_t bucket_size;
-	uint32_t rate_limit;
-	uint32_t wrr;
-} tpm_db_gmac_txq_t;
-
-/*Structure defines the details of a Packet Processor Tx component  */
-typedef struct {
-	uint32_t valid;						/* Defines if the Tx component is used */
-	uint32_t bucket_size;
-	uint32_t rate_limit;
-	uint32_t prio;
-	tpm_db_gmac_txq_t tx_queue[TPM_MAX_NUM_TX_QUEUE];	/* Config. of each of the 8 Tx queue of this Tx component */
-} tpm_db_gmac_tx_t;
-
-#if 0
-/* Structure contains user ownership of an API Group */
-typedef struct {
-	uint32_t valid;
-	uint32_t api_owner_id;
-	tpm_api_type_t api_type;
-} tpm_db_api_group_t;
-#endif
-
-/* */
-typedef struct {
-	uint32_t valid;
-	uint32_t owner_id;
-} tpm_db_owners_t;
-
-/* Structure for defining MH_select to uni_vector and to amber_port_vector */
-typedef struct {
-	uint32_t uni_vector;
-	uint16_t amber_port_vector;
-	uint32_t pnc_vector;
-} tpm_db_tx_ds_mh_sel_mapping_t;
-
-typedef struct {
-	tpm_init_mtu_setting_enable_t mtu_enable;
-	uint32_t ipv4_mtu_us;
-	uint32_t ipv4_pppoe_mtu_us;
-	uint32_t ipv6_mtu_us;
-	uint32_t ipv6_pppoe_mtu_us;
-	uint32_t ipv4_mtu_ds;
-	uint32_t ipv6_mtu_ds;
-	uint32_t mru;
-} tpm_db_mtu_t;
-
-typedef struct {
-	uint32_t mc_vlan;
-	uint32_t valid;
-	uint32_t pnc_index_num;
-	uint32_t pnc_index[TPM_MC_VLAN_MAX_PNC_RULE_NUM];
-} tpm_db_mc_ai_bits_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t pnc_index_num;
-	uint32_t reference_num;
-	uint8_t  src_ip[16];
-} tpm_db_ipv6_mc_sip_t;
-
-typedef struct {
-	tpm_mc_vid_port_cfg_t mc_vid_port_vids[TPM_MAX_NUM_UNI_PORTS];
-	uint32_t valid;
-	uint32_t mc_vid;
-} tpm_mc_vid_cfg_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	tpm_ipv6_gen_acl_key_t gen_key;
-} tpm_db_ipv6_gen_key_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	tpm_ipv6_addr_key_t dip_key;
-} tpm_db_ipv6_dip_key_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	uint32_t protocol;
-	tpm_l4_ports_key_t l4_key;
-} tpm_db_ipv6_l4_key_t;
-
-typedef struct {
-	tpm_db_ipv6_gen_key_t gen_key[TPM_DB_IPV6_MAX_KEY_NUM];
-	tpm_db_ipv6_dip_key_t dip_key[TPM_DB_IPV6_MAX_KEY_NUM];
-	tpm_db_ipv6_l4_key_t l4_key[TPM_DB_IPV6_MAX_KEY_NUM];
-} tpm_db_ipv6_key_shadow_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	tpm_parse_fields_t parse_bm;
-	uint32_t l4_key;
-} tpm_db_ipv6_l4_flow_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	tpm_parse_fields_t parse_bm;
-	uint32_t gen_key;
-	uint32_t l4_key;
-} tpm_db_ipv6_gen_flow_t;
-
-typedef struct {
-	tpm_db_ipv6_l4_flow_t l4_flow[TPM_DB_IPV6_MAX_SUBFLOW_NUM];
-	tpm_db_ipv6_gen_flow_t gen_flow[TPM_DB_IPV6_MAX_SUBFLOW_NUM];
-} tpm_db_ipv6_subflow_shadow_t;
-
-typedef struct {
-	uint32_t valid;
-	tpm_dir_t src_dir;
-	tpm_parse_fields_t parse_bm;
-	uint32_t is_pppoe;
-	uint32_t gen_key;
-	uint32_t dip_key;
-	uint32_t l4_key;
-} tpm_db_ipv6_5t_flow_shadow_t;
-
-typedef struct {
-	uint32_t igmp_mode;
-	uint8_t mc_stream_pppoe;
-	uint8_t valid;
-	uint16_t vid;
-	uint8_t group_addr[16];
-	uint8_t src_addr[16];
-	uint8_t ignore_src_addr;
-	uint16_t dest_queue;
-	uint32_t dest_port_bm;
-	uint32_t u4_entry;
-} tpm_db_ipv6_mc_stream_entry_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t user_num;
-	tpm_vlan_oper_t   vlan_op;
-	uint32_t vlan_1;
-	uint32_t vlan_2;
-	uint32_t tpid_1;
-	uint32_t tpid_2;
-} tpm_db_split_mod_vlan_t;
-
-typedef struct {
-	tpm_db_split_mod_vlan_t split_mod_vlan[TPM_DB_SPLIT_MOD_NUM_VLANS_MAX];
-} tpm_db_split_mod_gmac_vlan_t;
-
-typedef struct {
-	tpm_db_split_mod_enable_t   split_mod_enable;
-	tpm_db_split_mod_mode_t   split_mod_mode;
-	uint32_t num_p_bits;
-	uint32_t num_vlans;
-	uint8_t  p_bits[8];
-	tpm_db_split_mod_gmac_vlan_t     gmac_vlan_conf[TPM_MAX_NUM_GMACS];
-} tpm_db_split_mod_t;
-
-typedef enum {
-	TPM_CTC_CM_L2,
-	TPM_CTC_CM_IPv4,
-	TPM_CTC_CM_COMBO
-} tpm_ctc_cm_rule_type_t;
-
-typedef struct {
-	uint32_t                    valid;
-	uint32_t                    cm_main_rule_index;
-	uint32_t                    ipv4_sub_pattern_key;
-	tpm_ctc_cm_rule_type_t      rule_type;
-	tpm_parse_fields_t          l2_parse_rule_bm;
-	tpm_parse_fields_t          ipv4_parse_rule_bm;
-	tpm_parse_fields_t          ipv6_parse_rule_bm;
-	tpm_l2_acl_key_t            l2_key;
-	tpm_ipv4_acl_key_t          ipv4_key;
-	tpm_ipv6_acl_key_t          ipv6_key;
-	tpm_pkt_frwd_t              pkt_frwd;
-	tpm_pkt_action_t            pkt_act;
-	uint32_t                    pbits;
-} tpm_db_ctc_cm_rule_entry_t;
-
-typedef struct {
-	uint32_t num_rules;
-	uint32_t rule_index[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_RULE_NUM];
-} tpm_db_cnm_ipv4_pre_table_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t num_users;
-    tpm_parse_fields_t parse_rule_bm;
-    tpm_ipv4_acl_key_t ipv4_key;
-} tpm_db_cnm_ipv4_pre_filter_key_t;
-
-typedef struct {
-	uint32_t num_keys;
-	tpm_db_cnm_ipv4_pre_filter_key_t key[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM];
-} tpm_db_cnm_ipv4_pre_filter_t;
-
-typedef struct {
-	/* api_ent_mem_area backup used for hot swap profile feature */
-	tpm_db_api_entry_t api_ent_mem_area_bak[TPM_DB_API_ENTRIES_TBL_SIZE];
-
-	/* API section backup used for hot swap profile feature */
-	tpm_db_api_section_t api_section_bak[TPM_MAX_NUM_API_SECTIONS];
-
-	/* MC VID setting backup */
-	tpm_mc_vid_cfg_t mc_vid_port_cfg_bak[TPM_MC_VID_NUM_MAX];
-	tpm_db_gmac_tx_t gmac_tx_bak[TPM_MAX_NUM_TX_PORTS];
-
-	uint32_t igmp_proxy_sa_mac[6];
-	uint32_t igmp_proxy_sa_mac_valid;
-
-	bool     switch_init;
-}tpm_db_hot_swap_bak_db_t;
-
-typedef struct {
-	tpm_db_ctc_cm_enable_t enable;
-	tpm_db_ctc_cm_ipv6_parse_win_t ipv6_parse_win;
-	/* init value from XML */
-	tpm_db_ctc_cm_ipv6_parse_win_t ipv6_parse_win_original;
-	uint32_t ipv6_ety_rule_num;
-	tpm_db_cnm_ipv4_pre_table_t ipv4_pre_table;
-	tpm_db_cnm_ipv4_pre_filter_t ipv4_pre_filter[TPM_MAX_NUM_UNI_PORTS];
-	/* U0~U7 and vir_uni, 8 prec */
-	tpm_db_ctc_cm_rule_entry_t cm_rule[TPM_MAX_NUM_UNI_PORTS][TPM_MAX_NUM_CTC_PRECEDENCE];
-} tpm_db_ctc_cm_t;
-
-typedef struct {
-	bool switch_init;
-	bool gmac1_loopback_en;
-	bool cpu_wan_loopback_en;
-	bool ds_load_bal_en;
-	bool switch_active_wan_en;
-	tpm_db_ety_dsa_enable_t  ety_dsa_enable;
-	tpm_init_virt_uni_t virt_uni_info;
-
-} tpm_db_func_profile_t;
-
-typedef struct {
-	tpm_limit_mode_t count_mode;
-	uint32_t cir;
-	uint32_t cbs;
-	uint32_t ebs;
-} tpm_db_gmac_lpk_uni_ingr_rate_limit_t;
-
-typedef struct {
-	/* Physical chip config */
-	tpm_eth_complex_profile_t eth_cmplx_profile;
-	tpm_src_port_type_t max_uni_port_nr;
-	tpm_db_eth_port_conf_t eth_ports[TPM_MAX_NUM_ETH_PORTS];
-	uint32_t num_valid_tcont_llid;
-	tpm_db_gmac_tx_t gmac_tx[TPM_MAX_NUM_TX_PORTS];
-	tpm_init_fc_params_t	port_fc_conf;
-	tpm_db_gmac_rx_t gmac_rx[TPM_MAX_NUM_GMACS];
-
-	/* GMAC Functional Info */
-	tpm_db_gmac_func_t gmac_func[TPM_MAX_NUM_GMACS];
-
-	tpm_db_gmac_conn_conf_t gmac_port_conf[TPM_NUM_GMACS];
-
-	/* GMAC Marvell Header Info */
-	uint32_t gmac_mh_en[TPM_MAX_NUM_GMACS];
-
-	/* GMAC Buffer Mngmt Pools buffers Info */
-	tpm_db_gmac_bufs_t gmac_bp_bufs[TPM_MAX_NUM_GMACS];
-
-	/* IGMP */
-	tpm_db_igmp_t igmp_def;
-
-	/* Misc. */
-	tpm_db_misc_t init_misc;
-
-	/* Ownership */
-	tpm_db_owners_t owners[TPM_MAX_API_TYPES];
-#if 0
-	tpm_db_api_group_t api_groups[TPM_MAX_API_TYPES];
-#endif
-
-	/* API Ranges and Entries */
-	tpm_db_api_section_t api_section[TPM_MAX_NUM_API_SECTIONS];
-
-	/* Memory place holder array to be used for the api_section api_entry tables */
-	tpm_db_api_entry_t api_ent_mem_area[TPM_DB_API_ENTRIES_TBL_SIZE];
-
-	/* PNC Ranges */
-	tpm_db_pnc_range_t pnc_range[TPM_MAX_NUM_RANGES];
-
-	/* PNC Shadow Table */
-	tpm_db_pnc_shadow_t pnc_shadow[TPM_PNC_SIZE];
-
-	/* EtherType registers */
-	tpm_db_etype_sel_t vlan_etype[TPM_NUM_VLAN_ETYPE_REGS];
-
-	/* MH register selection per UNI and SWITCH port */
-	tpm_db_tx_ds_mh_sel_mapping_t tpm_mh_port_vector_tbl[TPM_TX_MAX_MH_REGS];
-
-	/* mtu setting */
-	tpm_db_mtu_t tpm_mtu_cfg;
-	tpm_db_pppoe_add_enable_t tpm_pppoe_add_enable;
-	uint32_t num_vlan_tags;
-	uint32_t cpu_rx_queue;
-	tpm_db_ttl_illegal_action_t ttl_illegal_action;
-	tpm_db_tcp_flag_check_t tcp_flag_check;
-	tpm_db_mc_ai_bits_t mc_ai_bits_table[TPM_MC_VID_NUM_MAX];
-
-	/* MC IPv6 SIP data */
-	tpm_db_ipv6_mc_sip_t ipv6_mc_sip[TPM_MC_IPv6_SIP_NUM_MAX];
-
-	/* MC VID setting */
-	tpm_mc_vid_cfg_t mc_vid_port_cfg[TPM_MC_VID_NUM_MAX];
-
-	tpm_init_pnc_last_init_t catch_all_pkt_action;
-	uint32_t                 switch_dev_num;
-
-	tpm_db_ipv6_key_shadow_t ipv6_key_shadow;
-	tpm_db_ipv6_subflow_shadow_t ipv6_subflow_shadow[TPM_NUM_DIRECTIONS];
-	tpm_db_ipv6_5t_flow_shadow_t ipv6_5t_flow_shadow[TPM_DB_IPV6_MAX_5T_FLOW_NUM];
-
-	tpm_db_ipv6_mc_stream_entry_t  ipv6_mc_stream[TPM_MC_MAX_STREAM_NUM];
-	tpm_db_split_mod_t   split_mod_conf;
-
-	/* Array indicates which API's are currently called for synch purposes.
-	   When API is not in called, invalid=-1 When API is called, it will set it's rule_num */
-	int32_t tpm_busy_apis[TPM_MAX_API_TYPES][TPM_MAX_PARALLEL_API_CALLS];
-	tpm_db_ctc_cm_t    ctc_cm_data;
-
-	/* func profile, based on chip type and board profile */
-	tpm_db_func_profile_t    func_profile;
-
-	/* MC MAC learning pmt mod index */
-	uint32_t mac_learn_mod_idx;
-
-	tpm_db_ds_mac_based_trunk_enable_t  ds_mac_based_trunk_enable;
-
-	/* To record GMAC UNI egress rate limit */
-	uint32_t gmac_uni_egr_rate_limit[TPM_MAX_NUM_UNI_PORTS];
-	/* To record GMAC LPK UNI ingress rate limit */
-	tpm_db_gmac_lpk_uni_ingr_rate_limit_t gmac_lpk_uni_ingr_rate_limit[TPM_MAX_NUM_UNI_PORTS];
-} tpm_db_t;
-
-typedef struct {
-	uint32_t igmp_mode;
-	uint8_t mc_stream_pppoe;
-	uint8_t src_valid;
-	uint16_t vid;
-	uint8_t group_addr[4];
-	uint8_t src_addr[4];
-	uint16_t dest_queue;
-	uint32_t dest_port_bm;
-	uint32_t u4_entry;
-} tpm_db_mc_stream_entry_t;
-
-typedef struct {
-	uint8_t mac_addr[6];
-	uint8_t user_num[TPM_MAX_NUM_UNI_PORTS];
-} tpm_db_mc_mac_entry_t;
-
-typedef struct {
-	uint32_t rule_index;
-	uint32_t mod_cmd;
-} tpm_db_mc_lpbk_entry_t;
-
-#define TPM_DB_MAX_TRANSITION_NUM    (TPM_MAX_NUM_UNI_PORTS)
-
-typedef struct {
-	uint8_t valid;
-	uint16_t in_vid;
-	uint16_t out_vid;
-	tpm_db_mc_lpbk_entry_t *lpbk_entry;
-} tpm_db_mc_vid_transit_t;
-
-typedef struct {
-	uint32_t ip_ver;
-	uint16_t mvlan;
-	uint16_t xits_num;
-	tpm_db_mc_vid_transit_t xits[TPM_DB_MAX_TRANSITION_NUM];
-} tpm_db_mc_vlan_entry_t;
-
-/************/
-/*  APIs    */
-/************/
-
-/* Init */
-
-int32_t tpm_db_init(void);
-
-/* Ethernet Port Config */
-bool tpm_db_eth_port_valid(tpm_src_port_type_t src_port_num);
-int32_t tpm_db_eth_port_conf_get(tpm_src_port_type_t src_port_num,
-				  tpm_db_chip_conn_t *chip_con,
-				  tpm_db_int_conn_t *int_con,
-				  uint32_t *switch_port);
-int32_t tpm_db_eth_port_switch_port_get(uint32_t ext_port);
-int32_t tpm_db_get_valid_uni_ports_num(uint32_t *num_ports);
-int32_t tpm_db_phy_convert_port_index(int32_t switch_port);
-int32_t tpm_db_trg_port_switch_port_get(tpm_trg_port_type_t ext_port);
-int32_t tpm_db_eth_port_conf_set(tpm_init_eth_port_conf_t *eth_port_conf);
-int32_t tpm_db_gmac_conn_conf_set(tpm_init_gmac_conn_conf_t *gmac_port_conf, uint32_t arr_size);
-int32_t tpm_db_gmac_conn_conf_get(tpm_gmacs_enum_t gmac, tpm_init_gmac_conn_conf_t *gmac_port_conf);
-
-/* GMAC Config */
-int32_t tpm_db_gmac_tcont_llid_set(uint32_t num_tcont_llid);
-int32_t tpm_db_gmac_conn_get(tpm_gmacs_enum_t gmac, tpm_db_gmac_conn_t *gmac_con);
-int32_t tpm_db_gmac_mh_en_conf_set(tpm_gmacs_enum_t gmac, uint32_t mh_en);
-int32_t tpm_db_gmac_mh_en_conf_get(tpm_gmacs_enum_t gmac, uint32_t *mh_en);
-int32_t tpm_db_target_to_gmac(tpm_pnc_trg_t pnc_target, tpm_gmacs_enum_t *gmac);
-int32_t tpm_db_gmac_bm_bufs_conf_set(tpm_gmacs_enum_t gmac, uint32_t large_pkt_buffers,
-					uint32_t small_pkt_buffers);
-int32_t tpm_db_gmac_bm_bufs_conf_get(tpm_gmacs_enum_t gmac, uint32_t *valid, uint32_t *large_pkt_buffers,
-					uint32_t *small_pkt_buffers);
-int32_t tpm_db_num_tcont_llid_get(uint32_t *num_tcont_llid);
-
-int32_t tpm_db_gmac_func_get(tpm_gmacs_enum_t gmac, tpm_db_gmac_func_t *gfunc);
-int32_t tpm_db_gmac_func_set(tpm_gmacs_enum_t gmac, tpm_db_gmac_func_t gfunc);
-
-/* TX Entities and queues Config */
-int32_t tpm_db_gmac_tx_q_conf_set(tpm_db_tx_mod_t tx_mod,
-					uint32_t queue_num,
-					tpm_db_sched_t sched_method,
-					tpm_db_txq_owner_t queue_owner,
-					uint32_t owner_queue_num, uint32_t queue_size, uint32_t queue_weight);
-
-int32_t tpm_db_gmac_tx_q_conf_get(tpm_db_tx_mod_t tx_mod,
-					uint32_t queue_num,
-					uint32_t *valid,
-					tpm_db_sched_t *sched_method,
-					tpm_db_txq_owner_t *queue_owner,
-					uint32_t *owner_queue_num, uint32_t *queue_size, uint32_t *queue_weight);
-
-int32_t tpm_db_gmac_tx_val_set(tpm_db_tx_mod_t tx_mod);
-uint32_t tpm_db_gmac_tx_val_get(tpm_db_tx_mod_t tx_mod);
-uint32_t tpm_db_gmac_lpk_queue_get(tpm_gmacs_enum_t *gmac,
-				   uint32_t *queue_idx,
-				   tpm_db_gmac1_lpk_queue_type_t queue_type);
-
-/* RX queues Config */
-int32_t tpm_db_gmac_rx_val_set(tpm_gmacs_enum_t gmac);
-uint32_t tpm_db_gmac_rx_val_get(tpm_gmacs_enum_t gmac);
-
-int32_t tpm_db_gmac_rx_q_conf_set(tpm_gmacs_enum_t gmac, uint32_t queue_num, uint32_t queue_size);
-
-int32_t tpm_db_gmac_rx_q_conf_get(tpm_gmacs_enum_t gmac,
-					uint32_t queue_num, uint32_t *valid, uint32_t *queue_size);
-
-/* Get params by Internal Port (WAN, UNI#0, etc). */
-int32_t tpm_db_intport_int_con_get(tpm_src_port_type_t int_port_num, tpm_db_int_conn_t *int_con,
-					uint32_t *switch_port);
-
-/* Ownership */
-int32_t tpm_db_owner_set(uint32_t owner_id);
-/* TODO - tpm_db_owner_del(uint32_t owner_id); */
-int32_t tpm_db_owner_get_next(int32_t cur_ind, int32_t *next_ind, uint32_t *owner);
-
-#if 0
-	int32_t tpm_db_apig_set(uint32_t owner_id, tpm_api_type_t api_type);
-/* TODO - tpm_db_apig_get(...) */
-	int32_t tpm_db_apig_get_next(int32_t cur_ind, int32_t *next_ind, uint32_t *owner, tpm_api_type_t *api_type);
-#endif
-
-/* IGMP */
-/*int32_t tpm_db_igmp_set(uint32_t igmp_snoop, uint32_t igmp_cpu_queue);*/
-/*int32_t tpm_db_igmp_get(uint32_t *igmp_snoop, uint32_t *igmp_cpu_queue); */
-int32_t tpm_db_igmp_set_port_frwd_mode(uint32_t port, uint32_t mode);
-int32_t tpm_db_igmp_get_port_frwd_mode(uint32_t port, uint32_t *mode);
-int32_t tpm_db_igmp_set_cpu_queue(uint32_t queue);
-int32_t tpm_db_igmp_get_cpu_queue(uint32_t *queue);
-int32_t tpm_db_igmp_get_snoop_enable(uint32_t *igmp_snoop_enable);
-int32_t tpm_db_igmp_set_snoop_enable(uint32_t igmp_snoop_enable);
-
-/* MISC */
-int32_t tpm_db_omci_type_set(uint32_t omci_etype);
-int32_t tpm_db_omci_type_get(uint32_t *omci_etype);
-int32_t tpm_db_omci_channel_get(uint32_t *valid, uint16_t *gemport, uint32_t *cpu_rx_q, uint32_t *cpu_tx_q,
-				uint32_t *tcont_id);
-int32_t tpm_db_omci_channel_set(uint16_t gemport, uint32_t cpu_rx_q, uint32_t cpu_tx_q, uint32_t tcont_id);
-int32_t tpm_db_omci_channel_remove(void);
-
-int32_t tpm_db_oam_channel_get(uint32_t *valid, uint32_t *cpu_rx_q, uint32_t *cpu_tx_q, uint32_t *llid);
-int32_t tpm_db_oam_channel_set(uint32_t cpu_rx_q, uint32_t cpu_tx_q, uint32_t llid);
-int32_t tpm_db_oam_channel_remove(void);
-
-int32_t tpm_db_oam_loopback_state_get(uint32_t *loopback);
-int32_t tpm_db_oam_loopback_channel_set(void);
-int32_t tpm_db_oam_loopback_channel_remove(void);
-
-int32_t tpm_db_pon_type_set(tpm_db_pon_type_t pon_type);
-int32_t tpm_db_pon_type_get(tpm_db_pon_type_t *pon_type);
-
-int32_t tpm_db_ds_mh_set_conf_set(tpm_db_mh_src_t ds_mh_set_conf);
-int32_t tpm_db_ds_mh_get_conf_set(tpm_db_mh_src_t *ds_mh_set_conf);
-
-int32_t tpm_db_active_wan_set(tpm_gmacs_enum_t active_wan);
-tpm_gmacs_enum_t tpm_db_active_wan_get(void);
-
-#if 0				/*Keep to be added in future version */
-	int32_t tpm_db_pnc_init_deb_port_set(uint32_t pnc_init_debug_port);
-	int32_t tpm_db_pnc_init_deb_port_get(uint32_t *pnc_init_debug_port);
-#endif
-int32_t tpm_db_init_done_set(void);
-int32_t tpm_db_init_done_get(void);
-
-int32_t tpm_db_cfg_pnc_parse_set(tpm_init_cfg_pnc_parse_t cfg_pnc_parse);
-int32_t tpm_db_cfg_pnc_parse_get(tpm_init_cfg_pnc_parse_t *cfg_pnc_parse_val);
-
-int32_t tpm_db_cpu_loopback_set(tpm_init_cpu_loopback_t cpu_loopback);
-int32_t tpm_db_cpu_loopback_get(tpm_init_cpu_loopback_t *cpu_loopback_val);
-
-int32_t tpm_db_double_tag_support_set(tpm_init_double_tag_t dbl_tag);
-int32_t tpm_db_double_tag_support_get(tpm_init_double_tag_t *dbl_tag);
-
-#if 0
-int32_t tpm_db_default_tag_tpid_set(uint16_t vlan1_tpid, uint16_t vlan2_tpid);
-int32_t tpm_db_default_tag_tpid_get(uint16_t *vlan1_tpid, uint16_t *vlan2_tpid);
-#endif
-int32_t tpm_db_default_tag_tpid_set(tpm_init_tpid_opt_t *tag_tpid);
-int32_t tpm_db_default_tag_tpid_get(tpm_init_tpid_opt_t *tag_tpid);
-
-int32_t tpm_db_virt_info_set(tpm_init_virt_uni_t virt_uni_info);
-int32_t tpm_db_virt_info_get(tpm_init_virt_uni_t *virt_uni_info);
-
-int32_t tpm_db_ipv6_5t_enable_set(tpm_init_ipv6_5t_enable_t ipv6_5t_enable);
-int32_t tpm_db_ipv6_5t_enable_get(tpm_init_ipv6_5t_enable_t *ipv6_5t_enable);
-
-int32_t tpm_db_port_vector_tbl_info_get(uint32_t reg_num, uint32_t *uni_vector, uint16_t *amber_port_vector,
-					uint32_t *pnc_vector);
-int32_t tpm_db_port_vector_tbl_info_set(uint32_t reg_num, uint32_t un_vector, uint16_t amber_port_vector,
-					uint32_t pnc_vector);
-int32_t tpm_db_port_vector_tbl_info_search(tpm_trg_port_type_t  trg_port, uint32_t *uni_vector,
-					    uint16_t *amber_port_vector, uint32_t *pnc_vector);
-/* API Section */
-int32_t tpm_db_api_section_init(tpm_api_sections_t api_section, tpm_pnc_ranges_t prim_pnc_range,
-				uint32_t api_rng_size);
-int32_t tpm_db_api_section_invalidate(tpm_api_sections_t api_section);
-
-int32_t tpm_db_api_section_get_from_api_type(tpm_api_type_t api_type, tpm_api_sections_t *api_section);
-int32_t tpm_db_api_type_get_from_api_section(tpm_api_sections_t api_section, tpm_api_type_t *api_type);
-int32_t tpm_db_api_section_reset(tpm_api_sections_t api_section);
-int32_t tpm_db_api_section_get(tpm_api_sections_t api_section, uint32_t *api_rng_size,
-				uint32_t *num_valid_entries, tpm_pnc_ranges_t * prim_pnc_range,
-				int32_t *last_valid, uint32_t *tbl_start);
-int32_t tpm_db_api_section_lastentry_get(tpm_api_sections_t api_section, int32_t *last_valid_entry);
-int32_t tpm_db_api_section_main_pnc_get(tpm_api_sections_t api_section, tpm_pnc_ranges_t *prim_pnc_range);
-int32_t tpm_db_api_section_num_entries_get(tpm_api_sections_t api_section, uint32_t *num_entries);
-int32_t tpm_db_api_section_val_get_next(int32_t cur_api_section, int32_t *next_section,
-					uint32_t *api_rng_size, uint32_t *num_valid_entries,
-					int32_t *last_valid_entry, uint32_t * tbl_start);
-int32_t tpm_db_api_section_ent_tbl_get(tpm_api_sections_t api_sec,
-					tpm_db_api_entry_t *api_ent_mem_area,
-					uint32_t index);
-
-
-int32_t tpm_db_api_section_entry_add(tpm_api_sections_t api_section, int32_t new_last_valid);
-int32_t tpm_db_api_entries_area_reset(void);
-
-/* API Entry */
-int32_t tpm_db_api_entry_set(tpm_api_sections_t api_section,
-				uint32_t rule_num, uint32_t bi_dir, tpm_rule_entry_t *api_data,
-				tpm_db_mod_conn_t *mod_con, tpm_db_pnc_conn_t *pnc_con, uint32_t *rule_idx);
-
-/*TODO: int32_t tpm_db_api_entry_del(tpm_api_sections_t api_section, uint32_t dir, uint32_t rule_num); */
-int32_t tpm_db_api_entry_rulenum_inc(tpm_api_sections_t api_section, uint32_t rule_inc_start,
-					uint32_t rule_inc_end);
-int32_t tpm_db_api_entry_rulenum_dec(tpm_api_sections_t api_section, uint32_t rule_dec_start,
-					uint32_t rule_dec_end);
-int32_t tpm_db_api_entry_get(tpm_api_sections_t api_section, uint32_t rule_num, uint32_t *rule_idx,
-				uint32_t *bi_dir, tpm_rule_entry_t *api_data, tpm_db_mod_conn_t *mod_con,
-				tpm_db_pnc_conn_t *pnc_con);
-
-int32_t tpm_db_api_tcam_num_get(tpm_api_sections_t api_section, uint32_t rule_idx, uint32_t *tcam_num);
-int32_t tpm_db_api_entry_update_rule_idx(tpm_api_sections_t api_section,
-						uint32_t rule_idx_pre,
-						uint32_t rule_idx_new);
-int32_t tpm_db_api_rulenum_get(tpm_api_sections_t api_section, uint32_t rule_idx, uint32_t *rule_num);
-int32_t tpm_db_api_rulenum_get_from_l2_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-						tpm_l2_acl_key_t *l2_key, uint32_t *rule_num);
-int32_t tpm_db_api_rulenum_get_from_l3_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-						tpm_l3_type_key_t *l3_key, uint32_t *rule_num);
-int32_t tpm_db_api_rulenum_get_from_ipv4_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-						tpm_ipv4_acl_key_t *ipv4_key, uint32_t *rule_num);
-int32_t tpm_db_api_rulenum_get_from_ipv6_key(tpm_api_sections_t api_section, tpm_parse_fields_t parse_rule_bm,
-						tpm_ipv6_acl_key_t *ipv6_key, uint32_t *rule_num);
-
-int32_t tpm_db_api_entry_val_get_next(tpm_api_sections_t api_section, int32_t cur_rule, int32_t *next_rule,
-					uint32_t *rule_idx, uint32_t *bi_dir, tpm_rule_entry_t *api_data,
-					tpm_db_mod_conn_t *mod_con, tpm_db_pnc_conn_t *pnc_con);
-int32_t tpm_db_rule_index_set(uint32_t rule_index);
-int32_t tpm_db_api_entry_invalidate(tpm_api_sections_t api_section, uint32_t rule_num);
-int32_t tpm_db_api_entry_ind_get(tpm_api_sections_t api_section, uint32_t rule_num, int32_t *index);
-int32_t tpm_db_api_tcam_rule_idx_get(tpm_api_sections_t api_section, uint32_t tcam_num, uint32_t *rule_idx);
-
-int32_t tpm_db_pnc_conn_inc(tpm_api_sections_t api_section, uint32_t rule_inc_start, uint32_t rule_inc_end);
-int32_t tpm_db_pnc_conn_dec(tpm_api_sections_t api_section, uint32_t rule_dec_start, uint32_t rule_dec_end);
-int32_t tpm_db_pnc_get_lu_conf(tpm_pnc_ranges_t range_id, tpm_api_lu_conf_t *lu_conf);
-
-int32_t tpm_db_api_specific_pnc_inc(tpm_api_sections_t api_section,
-					tpm_pnc_ranges_t range_id, uint32_t rule_inc_start, uint32_t rule_inc_end);
-int32_t tpm_db_api_specific_pnc_dec(tpm_api_sections_t api_section,
-					tpm_pnc_ranges_t range_id, uint32_t rule_inc_start, uint32_t rule_inc_end);
-/* PnC Range */
-/*Set */
-int32_t tpm_db_pnc_rng_create(tpm_db_pnc_range_conf_t *pnc_range_conf);
-int32_t tpm_db_pnc_rng_delete(tpm_pnc_ranges_t pnc_range);
-int32_t tpm_db_pnc_rng_reset(tpm_pnc_ranges_t pnc_range);
-int32_t tpm_db_pnc_rng_free_ent_inc(tpm_pnc_ranges_t pnc_range);
-int32_t tpm_db_pnc_rng_free_ent_dec(tpm_pnc_ranges_t pnc_range);
-int32_t tpm_db_pnc_rng_api_start_inc(tpm_pnc_ranges_t pnc_range);
-int32_t tpm_db_pnc_rng_api_end_dec(tpm_pnc_ranges_t pnc_range);
-/*Get */
-int32_t tpm_db_pnc_rng_get(tpm_pnc_ranges_t pnc_range, tpm_db_pnc_range_t *range_data);
-int32_t tpm_db_pnc_rng_get_range_start_end(tpm_pnc_ranges_t pnc_range, uint32_t *range_start,
-						uint32_t *range_end);
-
-/*int32_t tpm_db_pnc_rng_tbl_val_get_next(int32_t cur_ind, int32_t *next_ind, tpm_db_pnc_range_t *range_data); */
-int32_t tpm_db_pnc_rng_val_get_next(tpm_pnc_ranges_t cur_range, tpm_pnc_ranges_t *next_range,
-					tpm_db_pnc_range_t *range_data);
-int32_t tpm_db_pnc_rng_conf_get(tpm_pnc_ranges_t range_id, tpm_db_pnc_range_conf_t *range_conf);
-int32_t tpm_db_pnc_rng_oper_get(tpm_pnc_ranges_t range_id, tpm_db_pnc_range_oper_t *range_oper);
-int32_t tpm_db_pnc_rng_free_ent_get(tpm_pnc_ranges_t range_id, uint32_t *free_entries);
-
-/* PnC Shadow */
-int32_t tpm_db_pnc_shdw_ent_set(uint32_t pnc_entry, tpm_pnc_all_t *pnc_data);
-int32_t tpm_db_pnc_shdw_ent_inv(uint32_t pnc_entry);
-int32_t tpm_db_pnc_shdw_ent_ins(uint32_t pnc_start_entry, uint32_t pnc_stop_entry);
-int32_t tpm_db_pnc_shdw_ent_del(uint32_t pnc_start_entry, uint32_t pnc_stop_entry);
-int32_t tpm_db_pnc_shdw_ent_get(uint32_t pnc_entry, uint32_t *valid, tpm_pnc_all_t *pnc_data);
-
-/* Mod2 Shadow */
-int32_t tpm_db_mod2_set_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id, tpm_mod2_entry_t *pattern);
-int32_t tpm_db_mod2_activate_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id);
-int32_t tpm_db_mod2_get_jump_entry_pattern_data(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-						tpm_mod2_entry_t *pattern);
-int32_t tpm_db_mod2_del_jump_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id);
-int32_t tpm_db_mod2_get_chain_entry_num(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					uint16_t chain_id, uint16_t *entry_num);
-int32_t tpm_db_mod2_get_chain_entry_pattern_data(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-							uint16_t chain_id, uint16_t pattern_id,
-							tpm_mod2_entry_t *pattern);
-int32_t tpm_db_mod2_del_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id);
-int32_t  tpm_db_mod2_flush_jump_area(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-				     uint8_t updt_next_free, uint8_t on_failure);
-int32_t  tpm_db_mod2_flush_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id,
-				       uint8_t updt_next_free, uint8_t on_failure);
-int32_t tpm_db_mod2_set_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type, uint16_t chain_id,
-					uint16_t entry_num, tpm_mod2_entry_t *pattern);
-int32_t tpm_db_mod2_activate_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-						uint16_t chain_id);
-int32_t tpm_db_mod2_activate_chain_pmt_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-						uint16_t chain_id);
-int32_t tpm_db_mod2_if_chain_pmt_entries_exist(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-						uint16_t chain_id, uint8_t *exist);
-uint16_t tpm_db_mod2_get_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					uint16_t entry_num, tpm_mod2_entry_t *pattern);
-uint16_t tpm_db_mod2_get_next_free_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type);
-uint16_t tpm_db_mod2_convert_chain_to_pmt_entry(tpm_chain_type_t chain_type, uint16_t chain_id);
-int32_t tpm_db_mod2_get_chain_id_by_pmt_entry(tpm_gmacs_enum_t gmac_port, uint16_t entry_id,
-						tpm_chain_type_t *chain_type, uint16_t *chain_id);
-uint16_t tpm_db_mod2_get_next_free_jump_entry(tpm_gmacs_enum_t gmac_port);
-uint8_t tpm_db_mod2_rollback_chain_entry(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					 uint16_t chain_id, uint8_t on_failure);
-
-uint16_t tpm_db_mod2_get_next_split_mod_free_jump_entry(tpm_gmacs_enum_t gmac_port, tpm_pkt_mod_t *mod_data);
-//void tpm_db_mod2_update_split_mod_next_free_jump_entry(tpm_gmacs_enum_t gmac_port);
-int32_t tpm_db_mod2_split_mod_insert_vlan(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data);
-int32_t tpm_db_mod2_split_mod_get_vlan_index(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data, uint32_t *index);
-int32_t tpm_db_mod2_split_mod_increase_vlan_user_num(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data);
-int32_t tpm_db_mod2_split_mod_decrease_vlan_user_num(tpm_gmacs_enum_t port,
-													 uint32_t       vlan_index,
-													 uint32_t      *user_num);
-void tpm_db_mod2_set_multicast_mh_state(uint8_t enable);
-void tpm_db_mod2_set_pppoe_add_mod_state(uint8_t enable);
-void tpm_db_mod2_set_double_tag_state(uint8_t enable);
-void tpm_db_mod2_set_udp_checksum_use_init_bm_state(uint8_t enable);
-void tpm_db_mod2_set_udp_checksum_state(uint8_t enable);
-void tpm_db_mod2_set_chain_num(tpm_chain_type_t chain_type, uint16_t chain_num);
-uint16_t tpm_db_mod2_get_chain_max_size(tpm_chain_type_t chain_type);
-uint8_t tpm_db_mod2_get_multicast_mh_state(void);
-uint8_t tpm_db_mod2_get_pppoe_add_mod_state(void);
-uint8_t tpm_db_mod2_get_double_tag_state(void);
-uint8_t tpm_db_mod2_get_udp_checksum_init_bm_state(void);
-uint8_t tpm_db_mod2_get_udp_checksum_state(void);
-int32_t tpm_db_mod2_setup(void);
-int32_t tpm_db_mod2_inv_mac_entries(tpm_gmacs_enum_t gmac_port);
-
-void tpm_db_mod2_show_jump_pmt_entries(tpm_gmacs_enum_t gmac_port);
-void tpm_db_mod2_show_jump_cfg_data(void);
-void tpm_db_mod2_show_chain_pmt_entries(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type);
-void tpm_db_mod2_show_chain_info_entries(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-						uint16_t chain_id);
-void tpm_db_mod2_show_chain_cfg_data(tpm_chain_type_t chain_type);
-void tpm_db_mod2_show_all_chain(tpm_gmacs_enum_t gmac_port);
-
-/* Vlan Ethertype Shadow */
-int32_t tpm_db_mod_etype_sel_get(uint32_t tpid, uint32_t *etype_sel);
-int32_t tpm_db_mod_etype_sel_free_get(uint32_t *etype_sel);
-int32_t tpm_db_mod_etype_sel_set(uint32_t tpid, uint32_t etype_sel);
-
-/* Multicast Shadow */
-void tpm_db_set_mc_filter_mode(uint32_t mode);
-void tpm_db_set_mc_pppoe_enable(uint32_t enable);
-void tpm_db_split_mod_set_enable(tpm_db_split_mod_enable_t enable);
-tpm_db_split_mod_enable_t tpm_db_split_mod_get_enable(void);
-void tpm_db_split_mod_set_num_vlans(uint32_t num_vlans);
-uint32_t tpm_db_split_mod_get_num_vlans(void);
-void tpm_db_split_mod_set_mode(tpm_db_split_mod_mode_t mode);
-tpm_db_split_mod_mode_t tpm_db_split_mod_get_mode(void);
-void tpm_db_split_mod_set_num_p_bits(uint32_t num_p_bits, uint8_t  p_bits[8]);
-uint32_t tpm_db_split_mod_get_num_p_bits(void);
-int32_t tpm_db_split_mod_get_p_bits_by_index(uint8_t  index, uint8_t  *p_bits);
-int32_t tpm_db_split_mod_get_index_by_p_bits(uint8_t  p_bits, uint32_t *index);
-void tpm_db_set_mc_per_uni_vlan_xlate(uint32_t enable);
-void tpm_db_set_mc_hwf_queue(uint8_t hwf_queue);
-void tpm_db_set_mc_cpu_queue(uint8_t cpu_queue);
-void tpm_db_set_mc_igmp_proxy_sa_mac(uint8_t *sa_mac);
-uint32_t tpm_db_get_mc_filter_mode(void);
-uint8_t tpm_db_get_mc_pppoe_enable(void);
-uint8_t tpm_db_get_mc_per_uni_vlan_xlate(void);
-uint8_t tpm_db_get_mc_hwf_queue(void);
-uint8_t tpm_db_get_mc_cpu_queue(void);
-void tpm_db_get_mc_igmp_proxy_sa_mac(uint8_t *sa_mac, uint8_t *valid);
-int32_t tpm_db_set_mc_stream_entry(uint32_t stream_num, tpm_db_mc_stream_entry_t *mc_stream);
-int32_t tpm_db_get_mc_stream_entry(uint32_t stream_num, tpm_db_mc_stream_entry_t *mc_stream);
-void tpm_db_reset_mc_stream_entry(uint32_t stream_num);
-int32_t tpm_db_set_ipv6_mc_stream_entry(uint32_t stream_num, tpm_db_ipv6_mc_stream_entry_t *mc_stream);
-int32_t tpm_db_get_ipv6_mc_stream_entry(uint32_t stream_num, tpm_db_ipv6_mc_stream_entry_t *mc_stream);
-void tpm_db_reset_ipv6_mc_stream_entry(uint32_t stream_num);
-int32_t tpm_db_increase_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port);
-int32_t tpm_db_decrease_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port);
-uint8_t tpm_db_get_mc_mac_port_user_num(uint8_t *mac_addr, uint32_t uni_port);
-void tpm_db_reset_mc_mac_entry(uint8_t *mac_addr);
-uint32_t tpm_db_mc_lpbk_entries_num_get(void);
-int32_t tpm_db_mc_lpbk_entry_set(uint32_t ip_ver, uint16_t mvlan, uint16_t in_vid, uint16_t out_vid, uint32_t rule_num,
-					uint32_t mod_entry);
-int32_t tpm_db_mc_vlan_xits_num_get(uint32_t ip_ver, uint16_t mvlan, uint32_t *xits_num);
-int32_t tpm_db_mc_vlan_xit_entry_get(uint32_t ip_ver, uint16_t mvlan, uint32_t xit_id, uint32_t *rule_index,
-					uint32_t *mod_entry);
-int32_t tpm_db_mc_lpbk_rule_num_get(uint32_t rule_index, uint32_t *rule_num);
-int32_t tpm_db_mc_lpbk_entry_invalidate(uint32_t rule_num);
-int32_t tpm_db_mc_alloc_virt_uni_entry(uint32_t *entry_id);
-int32_t tpm_db_mc_free_virt_uni_entry(uint32_t entry_id);
-int32_t tpm_db_mc_vlan_set_ai_bit_pnc_index(uint32_t mc_vlan, uint32_t l2_pnc_rule_index);
-int32_t tpm_db_mc_vlan_get_ai_bit_by_vid(uint32_t mc_vlan, uint32_t *ai_bit);
-int32_t tpm_db_mc_vlan_reset_ai_bit(uint32_t l2_pnc_rule_index);
-int32_t tpm_db_mc_vlan_get_pnc_index_free_slot(uint32_t mc_vlan, uint32_t rule_num);
-int32_t tpm_db_mc_vlan_get_ai_bit(uint32_t mc_vlan, uint32_t *ai_bit);
-int32_t tpm_db_mc_vlan_reset_mc_vlan(uint32_t mc_vlan);
-uint32_t tpm_db_remove_mc_vid_cfg(uint32_t mc_vid);
-bool tpm_db_mc_vid_exist(uint32_t mc_vid);
-int32_t tpm_db_set_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config);
-int32_t tpm_db_get_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_cfg_t **mc_vid_uniports_config);
-void     tpm_db_mc_rule_reset(void);
-void     tpm_db_mc_cfg_reset(void);
-void tpm_db_set_mc_lpbk_enable(tpm_ip_ver_t ver, uint8_t enable);
-void tpm_db_get_mc_lpbk_enable(tpm_ip_ver_t ver, uint8_t *enable);
-
-/* MTU shadow */
-int32_t tpm_db_mtu_set_ipv4_mtu_us(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv4_mtu_us(uint32_t *mtu);
-int32_t tpm_db_mtu_set_ipv4_pppoe_mtu_us(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv4_pppoe_mtu_us(uint32_t *mtu);
-int32_t tpm_db_mtu_set_ipv6_mtu_us(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv6_mtu_us(uint32_t *mtu);
-int32_t tpm_db_mtu_set_ipv6_pppoe_mtu_us(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv6_pppoe_mtu_us(uint32_t *mtu);
-int32_t tpm_db_mtu_set_ipv4_mtu_ds(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv4_mtu_ds(uint32_t *mtu);
-int32_t tpm_db_mtu_set_ipv6_mtu_ds(uint32_t mtu);
-int32_t tpm_db_mtu_get_ipv6_mtu_ds(uint32_t *mtu);
-int32_t tpm_db_get_pppoe_add_enable(tpm_db_pppoe_add_enable_t *enable);
-int32_t tpm_db_set_pppoe_add_enable(tpm_db_pppoe_add_enable_t enable);
-int32_t tpm_db_get_num_vlan_tags(uint32_t *number);
-int32_t tpm_db_set_num_vlan_tags(uint32_t number);
-
-int32_t tpm_db_get_mtu_enable(tpm_db_mtu_setting_enable_t *enable);
-int32_t tpm_db_set_mtu_enable(tpm_db_mtu_setting_enable_t enable);
-
-int32_t tpm_db_set_cpu_rx_queue(uint32_t cpu_rx_queue);
-int32_t tpm_db_get_cpu_rx_queue(uint32_t *cpu_rx_queue);
-int32_t tpm_db_set_ttl_illegal_action(uint32_t ttl_illegal_action);
-int32_t tpm_db_get_ttl_illegal_action(uint32_t *ttl_illegal_action);
-int32_t tpm_db_set_tcp_flag_check(uint32_t tcp_flag_check);
-int32_t tpm_db_get_tcp_flag_check(uint32_t *tcp_flag_check);
-int32_t tpm_db_set_mru(uint32_t mru);
-int32_t tpm_db_get_mru(uint32_t *mru);
-int32_t tpm_db_set_catch_all_pkt_action(tpm_init_pnc_last_init_t catch_all_pkt_action);
-int32_t tpm_db_get_catch_all_pkt_action(tpm_init_pnc_last_init_t *catch_all_pkt_action);
-int32_t tpm_db_set_switch_dev_num(int32_t switch_dev_num);
-int32_t tpm_db_get_switch_dev_num(int32_t *switch_dev_num);
-int32_t tpm_db_set_ety_dsa_enable(tpm_db_ety_dsa_enable_t ety_dsa_enable);
-int32_t tpm_db_get_ety_dsa_enable(tpm_db_ety_dsa_enable_t *ety_dsa_enable);
-
-/* IPV6 5T flow shadow */
-uint32_t tpm_db_find_matched_ipv6_l4_subflow(uint32_t src_dir, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key);
-uint32_t tpm_db_get_ipv6_l4_subflow_user_num(uint32_t src_dir, uint32_t flow_id);
-uint32_t tpm_db_get_free_ipv6_l4_subflow(uint32_t src_dir);
-int32_t  tpm_db_set_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key);
-int32_t  tpm_db_get_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t *parse_bm, uint32_t *protocol, tpm_l4_ports_key_t *l4_key);
-int32_t  tpm_db_del_ipv6_l4_subflow(uint32_t src_dir, uint32_t flow_id);
-
-uint32_t tpm_db_find_matched_ipv6_gen_subflow(uint32_t src_dir, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key);
-uint32_t tpm_db_get_ipv6_gen_subflow_user_num(uint32_t src_dir, uint32_t flow_id);
-uint32_t tpm_db_get_free_ipv6_gen_subflow(uint32_t src_dir);
-int32_t  tpm_db_set_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t parse_bm, uint32_t protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key);
-int32_t  tpm_db_get_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id, uint32_t *parse_bm, uint32_t *protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key);
-int32_t  tpm_db_del_ipv6_gen_subflow(uint32_t src_dir, uint32_t flow_id);
-
-uint32_t tpm_db_find_matched_ipv6_5t_flow(uint32_t src_dir, uint32_t parse_bm, uint32_t is_pppoe, uint32_t protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key);
-int32_t  tpm_db_set_ipv6_5t_flow(uint32_t src_dir, uint32_t parse_bm, uint32_t is_pppoe, uint32_t protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key);
-int32_t  tpm_db_get_ipv6_5t_flow(uint32_t flow_id, uint32_t *src_dir, uint32_t *parse_bm, uint32_t *is_pppoe, uint32_t *protocol, tpm_l4_ports_key_t *l4_key, tpm_ipv6_gen_acl_key_t *gen_key, tpm_ipv6_addr_key_t *dip_key);
-int32_t  tpm_db_del_ipv6_5t_flow(uint32_t flow_id);
-int32_t  tpm_db_init_ipv6_5t_flow_reset(void);
-
-int32_t tpm_db_ctc_cm_rule_set(tpm_src_port_type_t src_port,
-			       uint32_t precedence,
-			       tpm_parse_fields_t l2_parse_rule_bm,
-			       tpm_parse_fields_t ipv4_parse_rule_bm,
-			       tpm_parse_fields_t ipv6_parse_rule_bm,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_ipv4_acl_key_t *ipv4_key,
-			       tpm_ipv6_acl_key_t *ipv6_key,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_pkt_action_t pkt_act,
-			       uint32_t pbits,
-			       uint32_t ipv4_sub_pattern_index,
-			       uint32_t rule_index);
-int32_t tpm_db_ctc_cm_rule_delete(tpm_src_port_type_t src_port, uint32_t precedence);
-int32_t tpm_db_ctc_cm_rule_get(tpm_src_port_type_t src_port, uint32_t precedence, tpm_db_ctc_cm_rule_entry_t *cm_rule);
-int32_t tpm_db_ctc_cm_get_num_rules(tpm_src_port_type_t src_port);
-int32_t tpm_db_ctc_cm_get_ipv6_num_rules(void);
-
-int32_t tpm_db_ctc_cm_db_reset(void);
-int32_t tpm_db_ipv6_mc_sip_db_reset(void);
-int32_t tpm_db_ipv6_mc_sip_index_get(uint8_t  *src_ip);
-int32_t tpm_db_ipv6_mc_sip_free_slot_num_get(void);
-int32_t tpm_db_ipv6_mc_sip_add(uint8_t  *src_ip);
-int32_t tpm_db_ipv6_mc_sip_ref_num_inc(uint8_t  src_ip_index);
-int32_t tpm_db_ipv6_mc_sip_ref_num_dec(uint8_t  src_ip_index, uint8_t  *new_ref_num);
-
-int32_t tpm_db_ctc_cm_enable_set(tpm_db_ctc_cm_enable_t ctc_cm_enable);
-int32_t tpm_db_ctc_cm_enable_get(tpm_db_ctc_cm_enable_t *ctc_cm_enable);
-
-int32_t tpm_db_ctc_cm_ipv6_parse_win_set(tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win);
-int32_t tpm_db_ctc_cm_ipv6_parse_win_orig_set(tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win);
-int32_t tpm_db_ctc_cm_ipv6_parse_win_get(tpm_db_ctc_cm_ipv6_parse_win_t *ctc_cm_ipv6_parse_win);
-int32_t tpm_db_ctc_cm_ipv6_ety_rule_num_set(uint32_t ipv6_ety_rule_num);
-int32_t tpm_db_ctc_cm_ipv6_ety_rule_num_get(uint32_t *ipv6_ety_rule_num);
-
-uint32_t tpm_db_get_api_busy(tpm_api_type_t api_type);
-uint32_t tpm_db_get_api_rule_num_busy(tpm_api_type_t api_type, uint32_t rule_num);
-void     tpm_db_get_api_all_busy(tpm_api_type_t api_type, uint32_t *num_busy, uint32_t *rule_num_list);
-uint32_t tpm_db_set_api_busy(tpm_api_type_t api_type, uint32_t rule_num);
-uint32_t tpm_db_set_api_free(tpm_api_type_t api_type, uint32_t rule_num);
-
-void tpm_db_show_mtu_cfg(void);
-
-int32_t tpm_db_eth_cmplx_profile_set(tpm_eth_complex_profile_t eth_cmplx_profile);
-tpm_eth_complex_profile_t tpm_db_eth_cmplx_profile_get(void);
-int32_t tpm_db_mac_func_set(void);
-int32_t tpm_db_eth_max_uni_port_set(void);
-tpm_src_port_type_t tpm_db_trg_port_uni_any_bmp_get(bool);
-int32_t tpm_db_to_lan_gmac_get(tpm_trg_port_type_t trg_port, tpm_pnc_trg_t *pnc_target);
-int32_t tpm_db_src_gmac_func_get(tpm_src_port_type_t src_port, tpm_db_gmac_func_t *gmac_func);
-int32_t tpm_db_src_port_on_switch(tpm_src_port_type_t src_port);
-bool    tpm_db_gmac_valid(tpm_gmacs_enum_t gmac);
-
-int32_t tpm_db_add_ipv4_pre_rule(tpm_src_port_type_t src_port, uint32_t key_pattern, uint32_t *rule_num);
-int32_t tpm_db_del_ipv4_pre_rule(tpm_src_port_type_t src_port, uint32_t key_pattern, uint32_t *rule_num);
-int32_t tpm_db_get_ipv4_pre_rule_num(uint32_t *num_rules);
-int32_t tpm_db_alloc_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t *key_idx);
-int32_t tpm_db_set_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t key_idx, tpm_parse_fields_t parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_db_del_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t key_idx);
-int32_t tpm_db_get_ipv4_pre_filter_key_num(tpm_src_port_type_t src_port, uint32_t *num_keys);
-int32_t tpm_db_get_ipv4_pre_filter_key(tpm_src_port_type_t src_port, uint32_t key_idx, tpm_parse_fields_t *parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_db_find_ipv4_pre_filter_key(tpm_src_port_type_t src_port, tpm_parse_fields_t parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key, uint32_t *key_idx);
-int32_t tpm_db_inc_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx);
-int32_t tpm_db_dec_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx);
-int32_t tpm_db_get_ipv4_pre_filter_key_user_num(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t *num_users);
-int32_t tpm_db_set_gmac_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t bucket_size,
-				   uint32_t rate_limit,
-				   uint32_t prio);
-int32_t tpm_db_get_gmac_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t *bucket_size,
-				   uint32_t *rate_limit,
-				   uint32_t *prio);
-int32_t tpm_db_set_gmac_q_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t queue,
-				   uint32_t bucket_size,
-				   uint32_t rate_limit,
-				   uint32_t wrr);
-int32_t tpm_db_get_gmac_q_rate_limit(tpm_db_tx_mod_t gmac_i,
-				   uint32_t queue,
-				   uint32_t *bucket_size,
-				   uint32_t *rate_limit,
-				   uint32_t *wrr);
-int32_t tpm_db_fc_conf_set(tpm_init_fc_params_t *port_fc_conf);
-int32_t tpm_db_fc_conf_get(tpm_init_fc_params_t *port_fc_conf);
-/* switch_init */
-int32_t tpm_db_switch_init_set(uint32_t switch_init);
-int32_t tpm_db_switch_init_get(uint32_t *switch_init);
-int32_t tpm_db_pnc_mac_learn_enable_set(tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable);
-int32_t tpm_db_pnc_mac_learn_enable_get(tpm_init_pnc_mac_learn_enable_t *pnc_mac_learn_enable);
-
-bool tpm_db_gmac1_lpbk_en_get(void);
-void tpm_db_gmac1_lpbk_en_set(bool en);
-bool tpm_db_cpu_wan_lpbk_en_get(void);
-void tpm_db_cpu_wan_lpbk_en_set(bool en);
-bool tpm_db_ds_load_bal_en_get(void);
-void tpm_db_ds_load_bal_en_set(bool en);
-bool tpm_db_switch_active_wan_en_get(void);
-void tpm_db_switch_active_wan_en_set(bool en);
-int32_t tpm_db_api_data_backup(void);
-int32_t tpm_db_api_data_rcvr(void);
-int32_t tpm_db_api_section_bak_num_entries_get(tpm_api_sections_t api_section, uint32_t *num_entries);
-int32_t tpm_db_api_section_bak_ent_tbl_get(tpm_api_sections_t api_sec, tpm_db_api_entry_t *api_ent_mem_area, uint32_t index);
-int32_t tpm_db_api_entry_bak_get_next(tpm_api_sections_t api_section,
-				      int32_t cur_rule,
-				      int32_t *next_rule);
-int32_t tpm_db_wan_lan_rate_limit_exchange(void);
-
-int32_t tpm_db_mac_learn_mod_idx_set(uint32_t mod_idx);
-int32_t tpm_db_mac_learn_mod_idx_get(uint32_t *mod_idx);
-int32_t tpm_db_ds_mac_based_trunk_enable_set(tpm_db_ds_mac_based_trunk_enable_t enable);
-int32_t tpm_db_ds_mac_based_trunk_enable_get(tpm_db_ds_mac_based_trunk_enable_t *enable);
-
-int32_t tpm_db_max_uni_port_nr_get(uint32_t *max_uni_port_nr);
-
-int32_t tpm_db_gmac_uni_egr_rate_limit_set(tpm_src_port_type_t port, uint32_t rate_limit);
-int32_t tpm_db_gmac_uni_egr_rate_limit_get(tpm_src_port_type_t port, uint32_t *rate_limit);
-int32_t tpm_db_gmac_lpk_uni_ingr_rate_limit_set(tpm_src_port_type_t port, tpm_db_gmac_lpk_uni_ingr_rate_limit_t rate_limit);
-int32_t tpm_db_gmac_lpk_uni_ingr_rate_limit_get(tpm_src_port_type_t port, tpm_db_gmac_lpk_uni_ingr_rate_limit_t *rate_limit);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_DB_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_header.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_header.h
deleted file mode 100644
index 7ae56cb..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_header.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_header.h                                               **
-**                                                                           **
-**  DESCRIPTION : This file tpm module header files                          **
-*******************************************************************************
-*                                                                             *
-*  MODIFICATION HISTORY:                                                      *
-*                                                                             *
-*   10Aug10  Oren Ben Hayun   created                                         *
-* =========================================================================== *
-******************************************************************************/
-#ifndef _TPM_HEADER_H
-#define _TPM_HEADER_H
-
-/* Include Files
-------------------------------------------------------------------------------*/
-
-#include "pnc/mvPnc.h"
-#include "pnc/mvTcam.h"
-#include "pnc/mvPnc.h"
-#include "bm/mvBmRegs.h"
-#include "gbe/mvNeta.h"
-#include "pmt/mvPmt.h"
-#include "mvSysHwConfig.h"
-#include "eth-phy/mvEthPhy.h"
-#include "boardEnv/mvBoardEnvLib.h"
-#include "msApiDefs.h"
-#include "msApi.h"
-#include "msApiPrototype.h"
-#include <gtHwCntl.h>
-#include "mv_switch.h"
-#include "mv_switch_wrap.h"
-#include "net_dev/mv_netdev.h"
-
-#include "tpm_db.h"
-#include "tpm_init.h"
-#include "tpm_api.h"
-#include "tpm_trace.h"
-#include "tpm_print.h"
-#include "tpm_mng_if.h"
-#include "tpm_usr_if.h"
-#include "tpm_pnc_logic.h"
-#include "tpm_sysfs.h"
-#include "tpm_pkt_proc_logic.h"
-#include "tpm_tm.h"
-#include "tpm_pnc_mgr.h"
-#include "tpm_modz2_mgr.h"
-#include "tpm_switch_mgr.h"
-#include "tpm_alarm.h"
-
-#include "tpm_mtu.h"
-#include "tpm_counter.h"
-
-#include "tpm_ctc_cm.h"
-
-#include "tpm_self_check.h"
-#include "tpm_cpu_port_fc.h"
-
-/* Definitions
-------------------------------------------------------------------------------*/
-
-/* Enums
-------------------------------------------------------------------------------*/
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Macros
-------------------------------------------------------------------------------*/
-
-#endif /* _TPM_HEADER_H */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.c
deleted file mode 100644
index 4ccd7f0..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.c
+++ /dev/null
@@ -1,4384 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_init.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.13
-*
-*
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-/* Global  Variables */
-extern spinlock_t tpmPncLock;
-extern spinlock_t tpmModLock;
-extern spinlock_t tpmTcamAgingLock;
-
-/* Local definitions */
-#define TPM_L2_BASE_LUID   0
-#define TPM_L3_BASE_LUID   (TPM_L2_BASE_LUID + 1)
-#define TPM_IPV4_BASE_LUID (TPM_L3_BASE_LUID + 1)
-#define TPM_IPV6_BASE_LUID (TPM_IPV4_BASE_LUID + 3)
-
-#define IF_ERROR(ret)       \
-	if (ret != TPM_OK) {\
-		TPM_OS_ERROR(TPM_INIT_MOD, " recvd ret_code(%d)\n", ret);\
-		return(ret);\
-	}
-#define IF_ERROR_I(ret, i)  \
-	if (ret != TPM_OK) {\
-		TPM_OS_ERROR(TPM_INIT_MOD, " For index(%d), recvd ret_code(%d)\n", i, ret);\
-		return(ret);\
-	}
-
-/* Local Variables */
-static char buff[1024];
-
-static tpm_init_t tpm_init;
-
-static tpm_tx_mod_hal_map_t tpm_tx_mod_hal_attrs[TPM_MAX_NUM_TX_PORTS] = {
-	/* <TCONT number> */
-	/*TPM_TX_MOD_GMAC0 */ {0, 0},
-	/*TPM_TX_MOD_GMAC1 */ {1, 0},
-	/*TPM_TX_MOD_PMAC_0 */ {2, 0},
-	/*TPM_TX_MOD_PMAC_1 */ {2, 1},
-	/*TPM_TX_MOD_PMAC_2 */ {2, 2},
-	/*TPM_TX_MOD_PMAC_3 */ {2, 3},
-	/*TPM_TX_MOD_PMAC_4 */ {2, 4},
-	/*TPM_TX_MOD_PMAC_5 */ {2, 5},
-	/*TPM_TX_MOD_PMAC_6 */ {2, 6},
-	/*TPM_TX_MOD_PMAC_7 */ {2, 7}
-};
-
-
-#define INIT_GMAC_VALID(gmac)							\
-	(((TPM_ENUM_PMAC == gmac) && (TPM_NONE != tpm_init.pon_type)) ||	\
-	 ((1 == tpm_init.gmac_port_conf[gmac].valid) && (TPM_GMAC_CON_DISC != tpm_init.gmac_port_conf[gmac].conn)))
-
-uint32_t opt_tbl[] = { 	ESC_OPT_RGMIIA_MAC0, ESC_OPT_RGMIIA_MAC1, ESC_OPT_RGMIIA_SW_P5, ESC_OPT_RGMIIA_SW_P6,
-				ESC_OPT_RGMIIB_MAC0, ESC_OPT_MAC0_2_SW_P4, ESC_OPT_MAC1_2_SW_P5, ESC_OPT_GEPHY_MAC1,
-				ESC_OPT_GEPHY_SW_P0, ESC_OPT_GEPHY_SW_P5, ESC_OPT_FE3PHY, ESC_OPT_SGMII_2_SW_P1, ESC_OPT_SGMII,
-				ESC_OPT_QSGMII,	ESC_OPT_SATA, ESC_OPT_SGMII_2_5 };
-char *opt_str_tlb[] = { "RGMIIA_MAC0", "RGMIIA_MAC1", "RGMIIA_SW_P5", "RGMIIA_SW_P6",
-			"RGMIIB_MAC0", "MAC0_2_SW_P4", "MAC1_2_SW_P5", "GEPHY_MAC1",
-			"GEPHY_SW_P0", "GEPHY_SW_P5", "FE3PHY", "PCS", "SGMII", "QSGMII", "SATA" , "SGMII_2_5"};
-char *prof_str_tlb[] = { "", "PON_WAN_DUAL_MAC_INT_SWITCH", 	"PON_WAN_G0_INT_SWITCH",
-			"PON_WAN_G1_LAN_G0_INT_SWITCH", 	"G0_WAN_G1_INT_SWITCH",
-			"G1_WAN_G0_INT_SWITCH", 		"PON_G1_WAN_G0_INT_SWITCH",
-			"PON_G0_WAN_G1_INT_SWITCH",		"PON_WAN_DUAL_MAC_EXT_SWITCH",
-			"PON_WAN_G1_MNG_EXT_SWITCH",		"PON_WAN_G0_SINGLE_PORT",
-			"PON_WAN_G1_SINGLE_PORT",		"PON_G1_WAN_G0_SINGLE_PORT",
-			"PON_G0_WAN_G1_SINGLE_PORT",		"PON_WAN_G0_G1_LPBK",
-			"TPM_PON_WAN_G0_G1_DUAL_LAN"};
-
-static tpm_pnc_range_lookup_map_t pnc_range_lookup_tbl[TPM_MAX_NUM_RANGES] = {
-/*  Range_num             lu_id  last_range  valid */
-	{TPM_PNC_MNGMT_DS, 0, 0, 1},
-	{TPM_PNC_MAC_LEARN, 0, 1, 1},
-	{TPM_PNC_CPU_WAN_LPBK_US, 0, 0, 1},
-	{TPM_PNC_NUM_VLAN_TAGS, 0, 0, 1},
-	{TPM_PNC_DS_LOAD_BALANCE, 0, 0, 1},
-	{TPM_PNC_MULTI_LPBK, 0, 0, 1},
-	{TPM_PNC_VIRT_UNI, 0, 0, 1},
-	{TPM_PNC_LOOP_DET_US, 0, 0, 1},
-	{TPM_PNC_L2_MAIN, 0, 1, 1},
-	{TPM_PNC_ETH_TYPE, 1, 1, 1},
-	{TPM_PNC_IGMP, 2, 0, 1},
-	{TPM_PNC_IPV4_MC_DS, 2, 0, 1},
-	{TPM_PNC_IPV4_MAIN, 2, 1, 1},
-	{TPM_PNC_IPV4_TCP_FLAG, 3, 1, 1},
-	{TPM_PNC_TTL, 4, 1, 1},
-	{TPM_PNC_IPV4_PROTO, 5, 0, 1},
-	{TPM_PNC_IPV4_FRAG, 5, 0, 1},
-	{TPM_PNC_IPV4_LEN, 5, 1, 1},
-	{TPM_PNC_IPV6_NH, 6, 1, 1},
-	{TPM_PNC_IPV6_L4_MC_DS, 7, 1, 1},
-	{TPM_PNC_IPV6_TCP_FLAG, 7, 1, 1},
-	{TPM_PNC_IPV6_L4, 7, 1, 1},
-	{TPM_PNC_IPV6_HOPL, 8, 1, 1},
-	{TPM_PNC_IPV6_MC_SIP, 8, 1, 1},
-	{TPM_PNC_IPV6_GEN, 8, 1, 1},
-	{TPM_PNC_IPV6_MC_DS, 9, 1, 1},
-	{TPM_PNC_IPV6_DIP, 9, 1, 1},
-	{TPM_PNC_CNM_IPV4_PRE, 10, 1, 1},
-	/* The range 'TPM_PNC_CNM_MAIN' spans over two lookup ids.
-		LU_ID_CNM_BASE := 11
-		LU_ID_L2_CNM   := LU_ID_CNM_BASE+0[/11]
-		LU_ID_IPV4_CNM := LU_ID_CNM_BASE+1[/12] */
-	{TPM_PNC_CNM_MAIN, 11, 1, 1},
-	{TPM_PNC_CATCH_ALL, 0, 0, 1},
-
-};
-
-bool tpm_init_check_gmac_init(tpm_gmacs_enum_t gmac_i)
-{
-	/* Check Port Available or not */
-	if (mvNetaPortCheck(gmac_i) || (NULL == mvNetaPortHndlGet(gmac_i))) {
-		return false;
-	}
-	return true;
-}
-
-bool tpm_init_gmac_in_gateway_mode(tpm_gmacs_enum_t gmac_i)
-{
-	struct eth_port *pp = NULL;
-
-	pp = mv_eth_port_by_id(gmac_i);
-	if (!pp) {
-		TPM_OS_WARN(TPM_INIT_MOD, "Port (%d) has not been initialized\n", gmac_i);
-		return true;
-	}
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		TPM_OS_INFO(TPM_INIT_MOD, "Port (%d) is in GateWay mode, driver has already set MH\n", gmac_i);
-		return true;
-	}
-
-	return false;
-}
-
-uint32_t tpm_init_check_gmac_mh_gtwy_mode(tpm_gmacs_enum_t gmac_i, uint32_t mh)
-{
-	struct eth_port *pp = NULL;
-
-	pp = mv_eth_port_by_id(gmac_i);
-	if (!pp) {
-		TPM_OS_WARN(TPM_INIT_MOD, "Port (%d) has not been initialized\n", gmac_i);
-		return TPM_OK;
-	}
-
-	if (tpm_init_gmac_in_gateway_mode(gmac_i) && (0 == mh)) {
-		/* Port is in GateWay mode, MH must be enabled */
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-void tpm_init_config_params_init(tpm_init_t *tpm_init_params)
-{
-	tpm_init.omci_etype = tpm_init_params->omci_etype;
-	tpm_init.pon_type = tpm_init_params->pon_type;
-	tpm_init.ds_mh_set_conf = tpm_init_params->ds_mh_set_conf;
-	tpm_init.validation_en = tpm_init_params->validation_en;
-	tpm_init.igmp_snoop = tpm_init_params->igmp_snoop;
-	tpm_init.igmp_cpu_queue = tpm_init_params->igmp_cpu_queue;
-	memcpy(&(tpm_init.igmp_pkt_frwd_mod), &(tpm_init_params->igmp_pkt_frwd_mod),
-	       sizeof(tpm_init.igmp_pkt_frwd_mod));
-	tpm_init.num_tcont_llid = tpm_init_params->num_tcont_llid;
-	tpm_init.gmac0_mh_en = tpm_init_params->gmac0_mh_en;
-	tpm_init.gmac1_mh_en = tpm_init_params->gmac1_mh_en;
-#if 0				/*Keep to be added in future version */
-	tpm_init.deb_port_valid = tpm_init_params->deb_port_valid;
-	tpm_init.deb_port = tpm_init_params->deb_port;
-#endif
-	tpm_init.cfg_pnc_parse = tpm_init_params->cfg_pnc_parse;
-	tpm_init.cpu_loopback = tpm_init_params->cpu_loopback;
-	tpm_init.trace_debug_info = tpm_init_params->trace_debug_info;
-	tpm_init.virt_uni_info.enabled = tpm_init_params->virt_uni_info.enabled;
-	tpm_init.virt_uni_info.uni_port = tpm_init_params->virt_uni_info.uni_port;
-	tpm_init.virt_uni_info.switch_port = tpm_init_params->virt_uni_info.switch_port;
-	tpm_init.ipv6_5t_enable = tpm_init_params->ipv6_5t_enable;
-	tpm_init.ctc_cm_enable = tpm_init_params->ctc_cm_enable;
-	tpm_init.ctc_cm_ipv6_parse_window = tpm_init_params->ctc_cm_ipv6_parse_window;
-	tpm_init.pnc_mac_learn_enable = tpm_init_params->pnc_mac_learn_enable;
-#if 0
-	tpm_init.vlan1_tpid = tpm_init_params->vlan1_tpid;
-	tpm_init.vlan2_tpid = tpm_init_params->vlan2_tpid;
-#endif
-
-	memcpy(&(tpm_init.eth_port_conf), &(tpm_init_params->eth_port_conf),
-	       ((sizeof(tpm_init_eth_port_conf_t)) * TPM_MAX_NUM_ETH_PORTS));
-	memcpy(&(tpm_init.gmac_tx), &(tpm_init_params->gmac_tx), ((sizeof(tpm_init_gmac_tx_t)) * TPM_MAX_NUM_TX_PORTS));
-	memcpy(&(tpm_init.gmac_rx), &(tpm_init_params->gmac_rx), ((sizeof(tpm_init_gmac_rx_t)) * TPM_MAX_NUM_GMACS));
-	memcpy(&(tpm_init.gmac_bp_bufs), &(tpm_init_params->gmac_bp_bufs),
-	       ((sizeof(tpm_init_gmac_bufs_t)) * TPM_MAX_NUM_GMACS));
-	memcpy(&(tpm_init.pnc_range), &(tpm_init_params->pnc_range),
-	       ((sizeof(tpm_init_pnc_range_t)) * TPM_MAX_NUM_RANGES));
-	memcpy(&(tpm_init.vlan_etypes), &(tpm_init_params->vlan_etypes),
-	       ((sizeof(uint32_t)) * TPM_NUM_VLAN_ETYPE_REGS));
-	memcpy(&(tpm_init.tpid_opt), &(tpm_init_params->tpid_opt), sizeof(tpm_init_tpid_opt_t));
-	memcpy(&(tpm_init.mod_config), &(tpm_init_params->mod_config), sizeof(tpm_init_mod_params_t));
-	memcpy(&(tpm_init.mod_chain), &(tpm_init_params->mod_chain), sizeof(tpm_init_mod_chain_t));
-	memcpy(&(tpm_init.mc_setting), &(tpm_init_params->mc_setting), sizeof(tpm_init_mc_setting_t));
-
-	memcpy(&(tpm_init.mtu_config), &(tpm_init_params->mtu_config), sizeof(tpm_init_mtu_params_t));
-	memcpy(&(tpm_init.port_fc_conf), &(tpm_init_params->port_fc_conf), sizeof(tpm_init_fc_params_t));
-	tpm_init.pppoe_add_enable = tpm_init_params->pppoe_add_enable;
-	tpm_init.num_vlan_tags = tpm_init_params->num_vlan_tags;
-	tpm_init.cpu_rx_queue = tpm_init_params->cpu_rx_queue;
-	tpm_init.ttl_illegal_action = tpm_init_params->ttl_illegal_action;
-	tpm_init.tcp_flag_check = tpm_init_params->tcp_flag_check;
-	tpm_init.catch_all_pkt_action = tpm_init_params->catch_all_pkt_action;
-	tpm_init.ety_dsa_enable = tpm_init_params->ety_dsa_enable;
-
-	tpm_init.eth_cmplx_profile = tpm_init_params->eth_cmplx_profile;
-	memcpy(&(tpm_init.gmac_port_conf), &(tpm_init_params->gmac_port_conf),
-		sizeof(tpm_init.gmac_port_conf));
-	tpm_init.active_wan = tpm_init_params->active_wan;
-	memcpy(&(tpm_init.split_mod_config), &(tpm_init_params->split_mod_config), sizeof(tpm_init_split_mod_params_t));
-	tpm_init.switch_init = tpm_init_params->switch_init;
-	tpm_init.ds_mac_based_trunk_enable = tpm_init_params->ds_mac_based_trunk_enable;
-}
-
-void tpm_init_pon_type_get(void)
-{
-	if (tpm_init.pon_type == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.pon_type = TPM_NONE;
-
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "\n PON_TYPE - missing initialization. ");
-	}
-}
-
-void tpm_init_ds_mh_set_conf_get(void)
-{
-	if (tpm_init.ds_mh_set_conf == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.ds_mh_set_conf = TPM_MH_SRC_RX_CTRL;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_WARN(TPM_INIT_MOD,
-				    " MH_SRC_RX_CTRL - missing initialization - set to default = TPM_MH_SRC_RX_CTRL = 0. \n");
-	}
-}
-
-void tpm_init_validation_get(void)
-{
-	if (tpm_init.validation_en == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.validation_en = TPM_VALID_DISABLED;
-}
-
-void tpm_init_cfg_pnc_parse_get(void)
-{
-	if (tpm_init.cfg_pnc_parse == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.cfg_pnc_parse = TPM_CFG_PNC_PARSE_ENABLED;
-}
-
-void tpm_init_cpu_loopback_get(void)
-{
-	if (tpm_init.cpu_loopback == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.cpu_loopback = TPM_CPU_LOOPBACK_DISABLED;
-}
-
-void tpm_init_trace_debug_info_get(void)
-{
-	if (tpm_init.trace_debug_info == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.trace_debug_info = 0xE000FFFF;
-
-	/* update the global param with debug info from xml */
-	tpm_glob_trace = tpm_init.trace_debug_info;
-}
-
-void tpm_init_vitual_uni_info_get(void)
-{
-	if (tpm_init.virt_uni_info.enabled == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.virt_uni_info.enabled = 0;
-		tpm_init.virt_uni_info.uni_port = TPM_SRC_PORT_UNI_VIRT;
-		tpm_init.virt_uni_info.switch_port = 5;
-	}
-}
-
-void tpm_init_omci_get(void)
-{
-	if (tpm_init.omci_etype == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.omci_etype = 0xBABA;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "\n OMCI type - missing initialization. ");
-	}
-}
-
-void tpm_init_igmp_get(void)
-{
-	tpm_src_port_type_t src_port;
-
-	if (tpm_init.igmp_snoop == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.igmp_snoop = 1;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "IGMP snooping - missing initialization. \n ");
-	}
-
-	if (tpm_init.igmp_cpu_queue == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.igmp_cpu_queue = 0;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "IGMP cpu_queue - missing initialization. \n ");
-	}
-
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_UNI_VIRT; src_port++) {
-		if (tpm_init.igmp_pkt_frwd_mod[src_port] == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-			tpm_init.igmp_pkt_frwd_mod[src_port] = TPM_IGMP_FRWD_MODE_SNOOPING;
-			if (tpm_init.validation_en == TPM_VALID_ENABLED)
-				TPM_OS_ERROR(TPM_INIT_MOD, "IGMP pkt_frwd_mod port: %d - missing initialization. \n ",
-					     src_port);
-		}
-	}
-
-}
-
-void tpm_init_mc_get(void)
-{
-
-	if (tpm_init.mc_setting.filter_mode == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mc_setting.filter_mode = TPM_MC_COMBINED_IP_MAC_FILTER;
-#if 0
-	if (tpm_init.mc_setting.igmp_mode == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-	   tpm_init.mc_setting.igmp_mode = TPM_MC_IGMP_SNOOPING;
-#endif
-	if (tpm_init.mc_setting.per_uni_vlan_xlat == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mc_setting.per_uni_vlan_xlat = false;
-
-	if (tpm_init.mc_setting.mc_pppoe_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mc_setting.mc_pppoe_enable = false;
-
-	if (tpm_init.mc_setting.ipv4_mc_support == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mc_setting.ipv4_mc_support = TPM_TRUE;
-
-	if (tpm_init.mc_setting.ipv6_mc_support == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mc_setting.ipv6_mc_support = TPM_FALSE;
-
-}
-
-uint32_t tpm_init_pkt_len_max_us_get(void)
-{
-	if (TPM_GPON == tpm_init.pon_type)
-		return 2000;
-	else
-		return 1593;
-}
-
-uint32_t tpm_init_ipv4_mtu_us_default_get(void)
-{
-	uint32_t ipv4_mtu_default;
-
-	ipv4_mtu_default = tpm_init_pkt_len_max_us_get();
-
-	/* vlan */
-	ipv4_mtu_default -= (4 * tpm_init.num_vlan_tags);
-	/* da + sa + ety */
-	ipv4_mtu_default -= 14;
-
-	return ipv4_mtu_default;
-}
-
-uint32_t tpm_init_ipv4_pppoe_mtu_us_default_get(void)
-{
-	uint32_t ipv4_pppoe_mtu_default;
-
-	ipv4_pppoe_mtu_default = tpm_init_pkt_len_max_us_get();
-
-	if (TPM_PPPOE_ADD_ENABLED == tpm_init.pppoe_add_enable)
-		ipv4_pppoe_mtu_default -= 8;
-
-	ipv4_pppoe_mtu_default -= (4 * tpm_init.num_vlan_tags);
-	/* da + sa + ety */
-	ipv4_pppoe_mtu_default -= 14;
-
-	return ipv4_pppoe_mtu_default;
-}
-
-uint32_t tpm_init_ipv6_mtu_us_default_get(void)
-{
-	uint32_t ipv6_mtu_default;
-
-	ipv6_mtu_default = tpm_init_pkt_len_max_us_get();
-
-	ipv6_mtu_default -= (4 * tpm_init.num_vlan_tags);
-
-	/* in ipv6 header, payload length does not contain the ipv6 header itself */
-	ipv6_mtu_default -= 40;
-	/* da + sa + ety */
-	ipv6_mtu_default -= 14;
-
-	return ipv6_mtu_default;
-}
-
-uint32_t tpm_init_ipv6_pppoe_mtu_us_default_get(void)
-{
-	uint32_t ipv6_pppoe_mtu_default;
-
-	ipv6_pppoe_mtu_default = tpm_init_pkt_len_max_us_get();
-
-	if (TPM_PPPOE_ADD_ENABLED == tpm_init.pppoe_add_enable)
-		ipv6_pppoe_mtu_default -= 8;
-
-	ipv6_pppoe_mtu_default -= (4 * tpm_init.num_vlan_tags);
-
-	/* in ipv6 header, payload length does not contain the ipv6 header itself */
-	ipv6_pppoe_mtu_default -= 40;
-	/* da + sa + ety */
-	ipv6_pppoe_mtu_default -= 14;
-
-	return ipv6_pppoe_mtu_default;
-}
-
-void tpm_init_mtu_get(void)
-{
-
-	if (tpm_init.pppoe_add_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.pppoe_add_enable = TPM_PPPOE_ADD_ENABLED;
-
-	if (tpm_init.num_vlan_tags == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.num_vlan_tags = 1;
-
-	if (tpm_init.mtu_config.mtu_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mtu_config.mtu_enable = TPM_MTU_CHECK_ENABLED;
-
-	if (tpm_init.mtu_config.ipv4_mtu_us == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mtu_config.ipv4_mtu_us = tpm_init_ipv4_mtu_us_default_get();
-
-	if (tpm_init.mtu_config.ipv6_mtu_us == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mtu_config.ipv6_mtu_us = tpm_init_ipv6_mtu_us_default_get();
-
-	if (tpm_init.cpu_rx_queue == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.cpu_rx_queue = 0;
-
-	if (tpm_init.ttl_illegal_action == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ttl_illegal_action = TPM_TTL_ZERO_ACTION_NOTHING;
-
-	if (tpm_init.tcp_flag_check == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.tcp_flag_check = TPM_TCP_FLAG_NOT_CHECK;
-
-	/* if the pppoe is not enabled, do not need to set
-	   ipv4_pppoe_mtu_us and ipv6_pppoe_mtu_us */
-	if (TPM_PPPOE_ADD_DISABLED == tpm_init.pppoe_add_enable)
-		return;
-
-	if (tpm_init.mtu_config.ipv4_pppoe_mtu_us == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mtu_config.ipv4_pppoe_mtu_us = tpm_init_ipv4_pppoe_mtu_us_default_get();
-
-	if (tpm_init.mtu_config.ipv6_pppoe_mtu_us == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.mtu_config.ipv6_pppoe_mtu_us = tpm_init_ipv6_pppoe_mtu_us_default_get();
-
-	/* in DS, mtu is optional, so do not set default value */
-
-}
-
-void tpm_init_pnc_config_get(void)
-{
-	if (tpm_init.catch_all_pkt_action == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.catch_all_pkt_action = TPM_PNC_LAST_ENTRY_INIT_DROP;
-}
-
-void tpm_init_ety_dsa_enable_get(void)
-{
-	if (tpm_init.ety_dsa_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ety_dsa_enable = TPM_ETY_DSA_DISABLE;
-}
-
-void tpm_init_ctc_cm_enable_get(void)
-{
-	if (tpm_init.ctc_cm_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ctc_cm_enable = TPM_CTC_CM_DISABLED;
-}
-
-void tpm_init_ctc_cm_ipv6_parse_window_get(void)
-{
-	if (tpm_init.ctc_cm_ipv6_parse_window == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ctc_cm_ipv6_parse_window = TPM_CTC_CM_IPv6_FIRST_24B;
-}
-
-void tpm_init_split_mod_get(void)
-{
-	uint32_t i = 0;
-	if (tpm_init.split_mod_config.split_mod_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.split_mod_config.split_mod_enable = TPM_SPLIT_MOD_DISABLED;
-	if (tpm_init.split_mod_config.p_bit_num == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.split_mod_config.p_bit_num = 8;
-		for(i = 0; i < tpm_init.split_mod_config.p_bit_num; i++) {
-			tpm_init.split_mod_config.p_bit[i] = i;
-		}
-	}
-	if (tpm_init.split_mod_config.vlan_num == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.split_mod_config.vlan_num = 10;
-	if (tpm_init.split_mod_config.split_mod_mode == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.split_mod_config.split_mod_mode = TPM_SPLIT_MOD_MODE_CTC;
-}
-void tpm_init_switch_init_get(void)
-{
-	if (tpm_init.switch_init == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		if (   tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_SINGLE_PORT
-		    || tpm_init.eth_cmplx_profile == TPM_PON_WAN_G1_SINGLE_PORT
-		    || tpm_init.eth_cmplx_profile == TPM_PON_G1_WAN_G0_SINGLE_PORT
-		    || tpm_init.eth_cmplx_profile == TPM_PON_G0_WAN_G1_SINGLE_PORT
-		    || tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_LPBK
-		    || tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_DUAL_LAN)
-			tpm_init.switch_init = 0;
-		else
-			tpm_init.switch_init = 1;
-	}
-}
-void tpm_init_ds_mac_based_trunk_enable_get(void)
-{
-	if (tpm_init.ds_mac_based_trunk_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ds_mac_based_trunk_enable = TPM_DS_MAC_BASED_TRUNK_DISABLED;
-}
-
-void tpm_init_ipv6_5t_enable_get(void)
-{
-	if (tpm_init.ipv6_5t_enable == MV_TPM_UN_INITIALIZED_INIT_PARAM)
-		tpm_init.ipv6_5t_enable = TPM_IPV6_5T_DISABLED;
-}
-
-#define	HW_OPT_ON(on, hw) ((hw & on)  == on)
-#define	VALID_ONLY(on, hw) (((hw & on)  == on) & ((hw & ~on)  == 0))
-
-void tpm_init_eth_cmplx_setup_error_print(uint32_t hwEthCmplx, bool sysfs_call)
-{
-	uint32_t i,j, off = 0;
-	uint32_t profile[7]= {0};
-
-	memset(buff, 0, sizeof(buff));
-
-	off += sprintf(buff+off, "\nSelected Eth Complex Profile: %s", prof_str_tlb[tpm_init.eth_cmplx_profile]);
-	off += sprintf(buff+off, "\nHW enabled options:\n\t");
-	for (i = 0;  i<sizeof(opt_tbl)/sizeof(uint32_t); i++) {
-		if (opt_tbl[i] & hwEthCmplx)
-			off += sprintf(buff+off, "%s ", opt_str_tlb[i]);
-	}
-
-	switch (tpm_init.eth_cmplx_profile)
-	{
-	case TPM_PON_WAN_DUAL_MAC_INT_SWITCH:
-		profile[0] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII;
-		profile[2] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6;
-		profile[3] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY;
-		break;
-
-	case TPM_PON_WAN_G0_INT_SWITCH:
-		profile[0] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII;
-		profile[2] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6;
-		profile[3] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY;
-		break;
-
-	case TPM_PON_WAN_G1_LAN_G0_INT_SWITCH:
-		profile[0] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_QSGMII;
-		profile[2] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY;
-		profile[3] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY | ESC_OPT_RGMIIA_SW_P6;
-		profile[4] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII;
-		profile[5] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6;
-		break;
-
-	case TPM_G0_WAN_G1_INT_SWITCH:
-		profile[0] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII;
-		break;
-
-	case TPM_G1_WAN_G0_INT_SWITCH:
-		profile[0] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_QSGMII;
-		profile[2] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY;
-		profile[3] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY;
-		profile[4] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII;
-		profile[5] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6;
-		break;
-
-	case TPM_PON_G1_WAN_G0_INT_SWITCH:
-		profile[0] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_QSGMII;
-		profile[2] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY;
-		profile[3] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY;
-		profile[4] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII;
-		profile[5] = ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6;
-		break;
-
-	case TPM_PON_G0_WAN_G1_INT_SWITCH:
-		profile[0] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY;
-		profile[1] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII;
-		break;
-
-	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
-		profile[0] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1;
-		break;
-
-	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
-		profile[0] = ESC_OPT_GEPHY_MAC1;
-		break;
-
-	case TPM_PON_WAN_G0_SINGLE_PORT:
-		profile[0] = ESC_OPT_RGMIIB_MAC0;
-		break;
-
-	case TPM_PON_WAN_G1_SINGLE_PORT:
-		profile[0] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1;
-		profile[1] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_GEPHY_MAC1;
-		break;
-
-	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
-	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
-		profile[0] = ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1;
-		profile[1] = ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_MAC0;
-		break;
-
-	case TPM_PON_WAN_G0_G1_LPBK:
-		if (DB_88F6535_BP_ID == mvBoardIdGet())
-			profile[0] = ESC_OPT_RGMIIA_MAC0 | ESC_OPT_GEPHY_MAC1;
-		if (DB_88F6601_BP_ID == mvBoardIdGet())
-			profile[0] = ESC_OPT_SGMII | ESC_OPT_GEPHY_MAC0 | ESC_OPT_LP_SERDES_FE_GE_PHY;
-		if (RD_88F6601_MC_ID == mvBoardIdGet())
-			profile[0] = ESC_OPT_GEPHY_MAC0;
-		break;
-	case TPM_PON_WAN_G0_G1_DUAL_LAN:
-		profile[0] = ESC_OPT_GEPHY_MAC0 | ESC_OPT_RGMIIA_MAC1;
-		break;
-	}
-
-	off += sprintf(buff+off, "\nProfile supported options:\n");
-	for (i = 0; profile[i]; i++) {
-		off += sprintf(buff+off, "\t");
-		for (j = 0; j<32; j++) {
-			if (profile[i] & (1<<j)) {
-				off += sprintf(buff+off, "%s ", opt_str_tlb[j]);
-			}
-		}
-		off += sprintf(buff+off, "\n");
-	}
-
-	off += sprintf(buff+off, "\n");
-	if (true == sysfs_call)
-		printk("%s", buff);
-	else
-		TPM_OS_ERROR(TPM_INIT_MOD, "%s", buff);
-}
-
-static uint32_t tpm_init_eth_cmplx_update_conf(void)
-{
-	uint32_t i;
-	uint32_t hwEthCmplx = mvBoardEthComplexConfigGet();
-
-	if (hwEthCmplx & (ESC_OPT_AUTO | ESC_OPT_ILLEGAL))
-	{
-		TPM_OS_ERROR(TPM_INIT_MOD, "\n Illegal values in mvBoardEthComplexConfigGet 0x%x\n", hwEthCmplx);
-		return TPM_FAIL;
-	}
-
-	/* do not check SATA */
-	hwEthCmplx &= (~ESC_OPT_SATA);
-
-	if (tpm_init.eth_cmplx_profile == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		if (TPM_VALID_ENABLED == tpm_init.validation_en){
-			TPM_OS_ERROR(TPM_INIT_MOD, "\n ETH COMPLEX PROFILE - missing initialization\n");
-		return TPM_FAIL;
-		}
-	}
-
-	if (MV_TPM_UN_INITIALIZED_INIT_PARAM == tpm_init.active_wan)
-		tpm_init.active_wan = TPM_ENUM_PMAC;
-
-	/* set default values for all ports and GMACs */
-	switch (tpm_init.eth_cmplx_profile)
-	{
-	case TPM_PON_WAN_DUAL_MAC_INT_SWITCH:
-		if (!VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_SWITCH_4;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_SWITCH_5;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIA_SW_P6, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 6))
-					tpm_init.eth_port_conf[i].chip_connect =TPM_CONN_RGMII1;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-		}
-
-		if (tpm_init.virt_uni_info.enabled) {
-			tpm_init.virt_uni_info.uni_port = TPM_SRC_PORT_UNI_VIRT;
-			tpm_init.virt_uni_info.switch_port = TPM_GMAC1_AMBER_PORT_NUM;
-		}
-		break;
-
-	case TPM_PON_WAN_G0_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_SWITCH_4;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_FALSE;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_DISC;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIA_SW_P6, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 6))
-					tpm_init.eth_port_conf[i].chip_connect =TPM_CONN_RGMII1;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-		}
-		break;
-
-	case TPM_PON_WAN_G1_LAN_G0_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_SWITCH_4;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		// tpm_init.gmac_port_conf[1].port_src = according to XML
-		// tpm_init.gmac_port_conf[1].conn = configured above
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-		if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-				tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIA_SW_P6, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 6))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-
-		if (VALID_ONLY((ESC_OPT_RGMIIA_MAC1 | ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-		    VALID_ONLY((ESC_OPT_RGMIIA_MAC1 | ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII), hwEthCmplx))
-		{
-			for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-				if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-					tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-					tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-					tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-					tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-					break;
-				}
-		} else if (VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6), hwEthCmplx))
-		{
-				for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-					if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-						tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-						tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-						tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-						tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-						tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-						break;
-				 }
-		} else
-			goto setup_err;
-
-		break;
-
-	case TPM_G0_WAN_G1_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_RGMIIA_SW_P6 |ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.pon_type = TPM_NONE;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_WAN;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_SWITCH_5;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_FALSE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIB_MAC0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 5))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII2;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-				 tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-				 tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_WAN;
-				 tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII2;
-				 tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-				 break;
-			}
-		}
-		break;
-
-	case TPM_G1_WAN_G0_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		tpm_init.pon_type = TPM_NONE;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_SWITCH_4;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_WAN;
-		// tpm_init.gmac_port_conf[1].conn = set below
-
-		tpm_init.gmac_port_conf[2].valid = TPM_FALSE;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-		if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					(tpm_init.eth_port_conf[i].switch_port == 0))
-				tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIA_SW_P6, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 6))
-				tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-
-		if (VALID_ONLY((ESC_OPT_RGMIIA_MAC1 | ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-		    VALID_ONLY((ESC_OPT_RGMIIA_MAC1 | ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_QSGMII), hwEthCmplx)){
-			for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-				if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-					tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-					tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-					tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-					tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-					break;
-				}
-			}
-		} else if (VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII | ESC_OPT_RGMIIA_SW_P6), hwEthCmplx)){
-			for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-				if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-					tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-					tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-					tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-					tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-					break;
-			 }
-			}
-		} else
-			goto setup_err;
-
-		break;
-
-	case TPM_PON_G1_WAN_G0_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_SWITCH_4;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_WAN;
-		// tpm_init.gmac_port_conf[1].conn = set in XML
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-		if (TPM_TRUE == tpm_init.eth_port_conf[i].valid) {
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_RGMIIA_SW_P6, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 6))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-
-		if (VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-		    VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_RGMIIA_MAC1 | ESC_OPT_QSGMII), hwEthCmplx))	{
-			for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-				if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-					tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-					tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-					tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-					tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-					break;
-				}
-		} else if (VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_SW_P6 | ESC_OPT_FE3PHY), hwEthCmplx) ||
-			   VALID_ONLY((ESC_OPT_MAC0_2_SW_P4 | ESC_OPT_GEPHY_MAC1 | ESC_OPT_QSGMII), hwEthCmplx)){
-				for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-					if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-						tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-						tpm_init.eth_port_conf[i].port_src = tpm_init.gmac_port_conf[1].port_src;
-						tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-						tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-						tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-						break;
-				 }
-		} else
-			goto setup_err;
-
-		break;
-
-	case TPM_PON_G0_WAN_G1_INT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_GEPHY_SW_P0 | ESC_OPT_FE3PHY), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_MAC1_2_SW_P5 | ESC_OPT_QSGMII), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_WAN;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_SWITCH_5;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			if (TPM_TRUE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_SWITCH;
-
-				if (HW_OPT_ON(ESC_OPT_QSGMII, hwEthCmplx) &&
-				    (tpm_init.eth_port_conf[i].switch_port >= 0) &&
-				    (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_QSGMII;
-				else if (HW_OPT_ON(ESC_OPT_GEPHY_SW_P0, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port == 0))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				else if (HW_OPT_ON(ESC_OPT_FE3PHY, hwEthCmplx) &&
-					 (tpm_init.eth_port_conf[i].switch_port >= 1) &&
-					 (tpm_init.eth_port_conf[i].switch_port <= 3))
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_FE_PHY;
-				else
-				{
-					TPM_OS_WARN(TPM_INIT_MOD, "switch port %d could not be configured\n",
-						tpm_init.eth_port_conf[i].switch_port);
-					tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_DISC;
-				}
-			}
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-				tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_WAN;
-				tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-				break;
-			}
-		}
-		break;
-
-	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		}
-		break;
-
-	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_GEPHY_MAC1), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_FALSE;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			if (TPM_FALSE == tpm_init.eth_port_conf[i].valid){
-				tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-				tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-				tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-				tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-				break;
-			}
-		}
-		break;
-
-	case TPM_PON_WAN_G0_SINGLE_PORT:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		/* FIXME - Add correct condition, after answers from lsp team.
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0), hwEthCmplx))
-			goto setup_err;*/
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_FALSE;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_DISC;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII2;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-		i++;
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-
-	case TPM_PON_WAN_G1_SINGLE_PORT:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIA_MAC1), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_GEPHY_MAC1), hwEthCmplx))
-			goto setup_err;
-
-		if (HW_OPT_ON((ESC_OPT_RGMIIA_MAC1), hwEthCmplx)){
-			 tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-			 tpm_init.eth_port_conf[0].chip_connect = TPM_CONN_RGMII1;
-		}else if (HW_OPT_ON((ESC_OPT_GEPHY_MAC1), hwEthCmplx)){
-			 tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-			 tpm_init.eth_port_conf[0].chip_connect = TPM_CONN_GE_PHY;
-		}
-
-		tpm_init.gmac_port_conf[0].valid = TPM_FALSE;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_DISC;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_UNI_0;
-		// tpm_init.gmac_port_conf[1].conn = set above
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		//tpm_init.eth_port_conf[i].chip_connect = set by XML
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-		i++;
-
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-
-	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_MAC0), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_UNI_0;
-
-		if (HW_OPT_ON(ESC_OPT_RGMIIB_MAC0, hwEthCmplx))
-			tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-		else if (HW_OPT_ON(ESC_OPT_RGMIIA_MAC0, hwEthCmplx))
-			tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII1;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_WAN;
-
-		if (HW_OPT_ON(ESC_OPT_RGMIIA_MAC1, hwEthCmplx))
-			tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-		else if (HW_OPT_ON(ESC_OPT_GEPHY_MAC1, hwEthCmplx))
-			tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-		i++;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_WAN;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-		i++;
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-
-	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		if (!VALID_ONLY((ESC_OPT_RGMIIB_MAC0 | ESC_OPT_RGMIIA_MAC1), hwEthCmplx) &&
-		    !VALID_ONLY((ESC_OPT_GEPHY_MAC1 | ESC_OPT_RGMIIA_MAC0), hwEthCmplx))
-			goto setup_err;
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_WAN;
-
-		if (HW_OPT_ON(ESC_OPT_RGMIIB_MAC0, hwEthCmplx))
-			tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII2;
-		else if (HW_OPT_ON(ESC_OPT_RGMIIA_MAC0, hwEthCmplx))
-			tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_RGMII1;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_UNI_0;
-
-		if (HW_OPT_ON(ESC_OPT_RGMIIA_MAC1, hwEthCmplx))
-			tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-		else if (HW_OPT_ON(ESC_OPT_GEPHY_MAC1, hwEthCmplx))
-			tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_WAN;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-		i++;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-		i++;
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-
-	case TPM_PON_WAN_G0_G1_LPBK:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		/* FIXME - Add correct condition, after answers from lsp team. */
-		/*if (!VALID_ONLY((ESC_OPT_SGMII | ESC_OPT_GEPHY_MAC0 | ESC_OPT_LP_SERDES_FE_GE_PHY), hwEthCmplx))
-			goto setup_err;*/
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_GE_PHY;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_ILLEGAL;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_GE_PHY;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-		i++;
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-	case TPM_PON_WAN_G0_G1_DUAL_LAN:
-		if (1 == tpm_init.virt_uni_info.enabled)
-			goto virt_uni_err;
-
-		/* FIXME - Add correct condition, after answers from lsp team. */
-		/*if (!VALID_ONLY((ESC_OPT_GEPHY_MAC0 | ESC_OPT_RGMIIA_MAC1), hwEthCmplx))
-			goto setup_err;*/
-
-		tpm_init.gmac_port_conf[0].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[0].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.gmac_port_conf[0].conn = TPM_GMAC_CON_GE_PHY;
-
-		tpm_init.gmac_port_conf[1].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[1].port_src = TPM_SRC_PORT_UNI_1;
-		tpm_init.gmac_port_conf[1].conn = TPM_GMAC_CON_RGMII1;
-
-		tpm_init.gmac_port_conf[2].valid = TPM_TRUE;
-		tpm_init.gmac_port_conf[2].port_src = TPM_SRC_PORT_WAN;
-
-		i = 0;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_0;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_GE_PHY;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC0;
-		i++;
-		tpm_init.eth_port_conf[i].valid = TPM_TRUE;
-		tpm_init.eth_port_conf[i].port_src = TPM_SRC_PORT_UNI_1;
-		tpm_init.eth_port_conf[i].chip_connect = TPM_CONN_RGMII1;
-		tpm_init.eth_port_conf[i].int_connect = TPM_INTCON_GMAC1;
-		i++;
-		for (; i < TPM_MAX_NUM_ETH_PORTS; i++)
-			tpm_init.eth_port_conf[i].valid = TPM_FALSE;
-		break;
-	}
-
-	return TPM_OK;
-
-setup_err:
-	TPM_OS_ERROR(TPM_INIT_MOD, "\n\nHW enabled options and Eth Complex setting do not comply!");
-	tpm_init_eth_cmplx_setup_error_print(hwEthCmplx, false);
-	return (TPM_FAIL);
-
-virt_uni_err:
-	TPM_OS_ERROR(TPM_INIT_MOD, "\n Virt-UNI not supported in profile %s\n",	prof_str_tlb[tpm_init.eth_cmplx_profile]);
-	return (TPM_FAIL);
-}
-
-uint32_t tpm_init_tcont_llid_get(void)
-{
-	if (tpm_init.num_tcont_llid == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		tpm_init.num_tcont_llid = 1;	/* for ZTE fix - changed from 8; */
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_WARN(TPM_INIT_MOD, "\n TCONT / LLID - missing initialization - set to default <8>.\n ");
-	}
-	return (TPM_OK);
-}
-
-void tpm_init_gmac_mh_en_get(void)
-{
-	if (tpm_init.gmac0_mh_en == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		if (tpm_init_gmac_in_gateway_mode(TPM_ENUM_GMAC_0))
-			tpm_init.gmac0_mh_en = TPM_TRUE;
-		else
-			tpm_init.gmac0_mh_en = TPM_FALSE;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "\n GMAC_0 MH - missing initialization. ");
-	} else if (tpm_init.gmac0_mh_en == 2) {
-		if (tpm_init.gmac_port_conf[0].conn == TPM_GMAC_CON_SWITCH_4)
-			tpm_init.gmac0_mh_en = 1;
-		else
-			tpm_init.gmac0_mh_en = 0;
-	}
-
-	if (tpm_init.gmac1_mh_en == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-		if (tpm_init_gmac_in_gateway_mode(TPM_ENUM_GMAC_1))
-			tpm_init.gmac1_mh_en = TPM_TRUE;
-		else
-			tpm_init.gmac1_mh_en = TPM_FALSE;
-		if (tpm_init.validation_en == TPM_VALID_ENABLED)
-			TPM_OS_ERROR(TPM_INIT_MOD, "\n GMAC_1 MH - missing initialization. ");
-	} else if (tpm_init.gmac1_mh_en == 2) {
-		if (tpm_init.gmac_port_conf[1].conn == TPM_GMAC_CON_SWITCH_5)
-			tpm_init.gmac1_mh_en = 1;
-		else
-			tpm_init.gmac1_mh_en = 0;
-	}
-}
-
-void tpm_init_lookup_get(tpm_pnc_ranges_t range_num, uint32_t *lu_id, uint32_t *last_lu_range, uint32_t *valid)
-{
-	uint32_t i;
-
-	*valid = 0;
-
-	for (i = 0; i < (sizeof(pnc_range_lookup_tbl) / sizeof(pnc_range_lookup_tbl[0])); i++) {
-		if (range_num == pnc_range_lookup_tbl[i].pnc_range) {
-			*lu_id = pnc_range_lookup_tbl[i].lookup_id;
-			*last_lu_range = pnc_range_lookup_tbl[i].last_lookup_range;
-			*valid = pnc_range_lookup_tbl[i].valid;
-		}
-	}
-	return;
-}
-
-int32_t tpm_init_config_params_update(void)
-{
-
-	int32_t rc;
-
-	tpm_init_trace_debug_info_get();
-	tpm_init_pon_type_get();
-	tpm_init_ds_mh_set_conf_get();
-	tpm_init_ipv6_5t_enable_get();
-	tpm_init_ctc_cm_ipv6_parse_window_get();
-	tpm_init_ctc_cm_enable_get();
-	tpm_init_vitual_uni_info_get();
-	tpm_init_omci_get();
-	tpm_init_igmp_get();
-	tpm_init_cpu_loopback_get();
-	tpm_init_mtu_get();
-	tpm_init_cfg_pnc_parse_get();
-	tpm_init_mc_get();
-	rc = tpm_init_eth_cmplx_update_conf();
-	if (rc != TPM_OK) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "\n Ethernet Complex configuration failed!\n");
-		return (TPM_FAIL);
-	}
-
-	rc = tpm_init_tcont_llid_get();	/* LLID / TCONT taken from XML */
-	if (rc != TPM_OK) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "\n GMAC internal configuration READ failed!.\n");
-		return (TPM_FAIL);
-	}
-
-	tpm_init_gmac_mh_en_get();
-	tpm_init_pnc_config_get();
-	tpm_init_ety_dsa_enable_get();
-	tpm_init_split_mod_get();
-	tpm_init_switch_init_get();
-	tpm_init_ds_mac_based_trunk_enable_get();
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_info_validate(void)
-{
-	int i = 0, j = 0, rc = 0;
-	tpm_init_tx_mod_t tx_mod;
-	unsigned int config_pnc_parser_val;
-	int txp, txq, min_tcont_llid;
-	tpm_gmacs_enum_t gmac_i;
-	uint8_t found_ipv4_pre, found_cnm_main;
-	uint32_t ipv4_pre_size, cnm_main_size, exp_range_size, num_uni_ports = 0;
-	uint32_t gmac0_owner = 0;
-	uint32_t cpu_owner = 0;
-
-	/********************************************************************/
-	if (tpm_init.validation_en != TPM_VALID_ENABLED)
-		return TPM_OK;
-
-	/******************** EPON/GPON system - check num of LLID / TCONT : legal values: 1..8 *********************/
-	if ((tpm_init.pon_type == TPM_EPON) || (tpm_init.pon_type == TPM_GPON)) {
-		if ((tpm_init.num_tcont_llid <= 0) || (tpm_init.num_tcont_llid > 8)) {
-			TPM_OS_FATAL(TPM_INIT_MOD, "\n TCONT/LLID: illegal value(%d) => legal values <1-8>.\n",
-				tpm_init.num_tcont_llid);
-			return (TPM_FAIL);
-		}
-	}
-	/***** EPON case: validate vs .config value for EPON *****/
-	if (tpm_init.pon_type == TPM_EPON) {
-		min_tcont_llid = min(TPM_GPON_MAX_NUM_OF_T_CONTS, TPM_EPON_MAX_MAC_NUM);
-		if (tpm_init.num_tcont_llid > min_tcont_llid) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n LLID: illegal value(%d) => max legal value defined in kernel is %d.\n",
-				tpm_init.num_tcont_llid, TPM_EPON_MAX_MAC_NUM);
-			return (TPM_FAIL);
-		}
-	}
-	/***** GPON case: validate vs .config value for GPON *****/
-	if (tpm_init.pon_type == TPM_GPON) {
-		if (tpm_init.num_tcont_llid > TPM_GPON_MAX_NUM_OF_T_CONTS) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n TCONT: illegal value(%d) => max legal value defined in kernel is %d.\n",
-				tpm_init.num_tcont_llid, TPM_GPON_MAX_NUM_OF_T_CONTS);
-			return (TPM_FAIL);
-		}
-	}
-#if 0				/*Keep to be added in future version */
-/******************** Debug port setting - validation **********************************/
-	if ((tpm_init.deb_port_valid != 0) && (tpm_init.deb_port_valid != 1)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n Debug port valid is wrong => legal values <0=invalid/1=valid>. \n");
-		return (TPM_FAIL);
-	}
-	if ((tpm_init.deb_port_valid == 1) &&
-	    ((tpm_init.deb_port < TPM_SRC_PORT_UNI_0) || (tpm_init.deb_port > TPM_SRC_PORT_UNI_3))) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n Bad debug port => legal values <TPM_SRC_PORT_UNI_0-TPM_SRC_PORT_UNI_3>. \n");
-		return (TPM_FAIL);
-	}
-#endif
-	/********************* pon type validation *********************************************/
-	/* for FPGA systems - the WAN tech is defined as TPM_NONE */
-	if (tpm_init.pon_type > TPM_NONE) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n pon type: wrong init value(%d) => legal values "
-			"<%d=TPM_EPON/%d=TPM_GPON/%d=TPM_P2P/%d=TPM_NONE>. \n",
-			tpm_init.pon_type, TPM_EPON, TPM_GPON, TPM_P2P, TPM_NONE);
-		return (TPM_FAIL);
-	}
-
-	/********************* CFG PNC PARSE validation *******************************************/
-	if ((tpm_init.cfg_pnc_parse < TPM_CFG_PNC_PARSE_DISABLED)
-	    || (tpm_init.cfg_pnc_parse > TPM_CFG_PNC_PARSE_ENABLED)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n CFG PNC parse: wrong init value(%d) => legal values <0=DISABLED/1=ENABLED. \n",
-			tpm_init.cfg_pnc_parse);
-		return (TPM_FAIL);
-	}
-	/* get the config_pnc_parser value */
-	config_pnc_parser_val = mv_eth_ctrl_pnc_get();
-
-        /* logical validation */
-
-#ifdef CONFIG_MV_ETH_PNC
-	if (tpm_init.cfg_pnc_parse == 0) {
-		if (config_pnc_parser_val == 0) {
-			/* the intention is to give the control to mv neta PNC configuration
-			   do not permit moving from 0 to 1 */
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n CFG PNC bad value: PNC in LSP cannot move from 0 to 1 \n");
-			return (TPM_FAIL);
-		} else {
-			/* config_pnc_parser == 1 */
-			/* nothing to do - the control is in LSP config */
-		}
-	}
-	if (tpm_init.cfg_pnc_parse == 1) {
-		if (config_pnc_parser_val == 0) {
-			/* nothing to do - the control is in TPM */
-		} else {	/* config_pnc_parser == 1 */
-			/* set the config_pnc_parser to 0 - control is set to TPM */
-			rc = mv_eth_ctrl_pnc(0);
-			if (rc != 0) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n Failed to SET the config PNC parse parameter. \n");
-				return (TPM_FAIL);
-			}
-		}
-	}
-#else
-	/* if compilation flag is turned off - there are no relevant functions for PNC_PARSER
-	   therefore do not permit the flag to be 0 - meaning the LSP is taking the responsibility */
-	if (tpm_init.cfg_pnc_parse == 0) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "\n CFG PNC bad value: PNC in LSP does not support PNC PARSER \n");
-		return (TPM_FAIL);
-	} else {
-		if (config_pnc_parser_val == 0) {
-			/*do nothing */
-		} else {
-			/* set the config_pnc_parser to 0 - control is set to TPM */
-			rc = mv_eth_ctrl_pnc(0);
-			if (rc != 0) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n Failed to SET the config PNC parse parameter. \n");
-				return (TPM_FAIL);
-			}
-		}
-	}
-#endif
-
-	/********************* CPU loopback type validation  ********************************************/
-		if ((tpm_init.cpu_loopback < TPM_CPU_LOOPBACK_DISABLED)
-		    || (tpm_init.cpu_loopback > TPM_CPU_LOOPBACK_ENABLED)) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n CPU loopback type: wrong init value(%d) => legal values <0=disabled/1=enabled. \n",
-				tpm_init.cpu_loopback);
-			return (TPM_FAIL);
-		}
-		if (tpm_init.cpu_loopback == TPM_CPU_LOOPBACK_ENABLED) {
-			if (tpm_init.gmac_port_conf[1].valid == TPM_TRUE &&
-			    tpm_init.gmac_port_conf[1].port_src != TPM_SRC_PORT_ILLEGAL) {
-				TPM_OS_FATAL(TPM_INIT_MOD, "\n CPU loopback not supported for GMAC function \n");
-				return (TPM_FAIL);
-			}
-		}
-
-	/********************* TRACE DEBUG INFO validation *******************************************/
-	if (tpm_init.trace_debug_info == 0) {
-		TPM_OS_WARN(TPM_INIT_MOD,
-			"\n TRACE DEBUG info: init value is %d - no ERRORs will be displayed. \n ",
-			tpm_init.trace_debug_info);
-	}
-
-	/********************* IGMP snooping validation *********************************************/
-	if ((tpm_init.igmp_snoop != 0) && (tpm_init.igmp_snoop != 1)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n IGMP snooping: wrong init value(%d) => legal values <0=disabled/1=enabled>. \n",
-			     tpm_init.igmp_snoop);
-		return (TPM_FAIL);
-	}
-	if (tpm_init.igmp_snoop == 1) {
-		if (tpm_init.igmp_cpu_queue > 7) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				     "\n IGMP snooping: wrong CPU queue(%d) => legal values <0-7>. \n",
-				     tpm_init.igmp_cpu_queue);
-			return (TPM_FAIL);
-		}
-	}
-
-	/********************* Multicast validation *********************************************/
-	if (tpm_init.mc_setting.per_uni_vlan_xlat) {
-		if (tpm_init.mc_setting.filter_mode != TPM_MC_COMBINED_IP_MAC_FILTER) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				     "\n multicast per uni vlan translation is not supported in filter_mode (%d). \n",
-				     tpm_init.mc_setting.filter_mode);
-			return (TPM_FAIL);
-		}
-#if 0
-		if (tpm_init.mc_setting.igmp_mode == TPM_MC_IGMP_SNOOPING && tpm_init.mc_setting.mc_pppoe_enable) {
-		   TPM_OS_FATAL(TPM_INIT_MOD, "\n multicast per uni vlan translation is not supported "
-					"in igmp snooping over pppoe. \n");
-		   return(TPM_FAIL);
-		}
-#endif
-	}
-
-	/* check that igmp_cpu_queue is CPU's reserved queue */
-	/* oct*>>> to do - if per system Q6 is the IGMP CPU - check in all GMACs that Q6 is of CPU ownership */
-
-	if (tpm_init.mc_setting.mc_hwf_queue > 7) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "\n MC setting: wrong MC HWF queue(%d) => legal values <0-7>. \n",
-			     tpm_init.mc_setting.mc_hwf_queue);
-		return (TPM_FAIL);
-	}
-
-	if (tpm_init.mc_setting.mc_cpu_queue > 7) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "\n MC setting: wrong MC CPU queue(%d) => legal values <0-7>. \n",
-			     tpm_init.mc_setting.mc_cpu_queue);
-		return (TPM_FAIL);
-	}
-
-	/********************** GMAC_0 connectivity validation *************************************/
-	if ((tpm_init.gmac_port_conf[0].conn < TPM_GMAC_CON_DISC) || (tpm_init.gmac_port_conf[0].conn > TPM_GMAC_CON_GE_PHY)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_0 connectivity: wrong init value(%d) => legal values <0-7> \n",
-			     tpm_init.gmac_port_conf[0].conn);
-		return (TPM_FAIL);
-	}
-	/********************** GMAC_1 connectivity validation *************************************/
-	if ((tpm_init.gmac_port_conf[1].conn < TPM_GMAC_CON_DISC) || (tpm_init.gmac_port_conf[1].conn > TPM_GMAC_CON_GE_PHY)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_1 connectivity: wrong init value(%d) => legal values <0-7> \n",
-			     tpm_init.gmac_port_conf[1].conn);
-		return (TPM_FAIL);
-	}
-	/********************** GMAC_0 MH enable validation   *************************************/
-	if ((tpm_init.gmac0_mh_en != 0) && (tpm_init.gmac0_mh_en != 1)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_0 MH enable: wrong init value(%d) => legal values <0=disabled,1=enabled> \n",
-			     tpm_init.gmac0_mh_en);
-		return (TPM_FAIL);
-	}
-	rc = tpm_init_check_gmac_mh_gtwy_mode(TPM_ENUM_GMAC_0, tpm_init.gmac0_mh_en);
-	if (rc != TPM_OK) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_0 is in GateWay mode, MH can not be disabled\n");
-		return (TPM_FAIL);
-	}
-	/********************** GMAC_1 MH enable validation   *************************************/
-	if ((tpm_init.gmac1_mh_en != 0) && (tpm_init.gmac1_mh_en != 1)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_1 MH enable: wrong init value(%d) => legal values <0=disabled,1=enabled> \n",
-			     tpm_init.gmac1_mh_en);
-		return (TPM_FAIL);
-	}
-	rc = tpm_init_check_gmac_mh_gtwy_mode(TPM_ENUM_GMAC_1, tpm_init.gmac1_mh_en);
-	if (rc != TPM_OK) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n GMAC_1 is in GateWay mode, MH can not be disabled\n");
-		return (TPM_FAIL);
-	}
-	/********************** GMAC_ Buffer Mngmt Pool_sizes validation ***********************************/
-	for (i = 0; i < sizeof(tpm_init.gmac_bp_bufs) / sizeof(tpm_init_gmac_bufs_t); i++) {
-		if (tpm_init.gmac_bp_bufs[i].valid) {
-			if (((tpm_init.gmac_bp_bufs[i].large_pkt_buffers != 0) &&
-			     (tpm_init.gmac_bp_bufs[i].large_pkt_buffers < MV_BM_POOL_CAP_MIN)) ||
-			    ((tpm_init.gmac_bp_bufs[i].small_pkt_buffers != 0) &&
-			     (tpm_init.gmac_bp_bufs[i].small_pkt_buffers < MV_BM_POOL_CAP_MIN))) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n GMAC%d BM Pool has too small buffer assigment "
-					"large_buf %d, small_buf %d\n",
-					i, tpm_init.gmac_bp_bufs[i].large_pkt_buffers,
-					tpm_init.gmac_bp_bufs[i].small_pkt_buffers);
-				return (TPM_FAIL);
-			}
-		}
-	}
-	/********************** PNC MH enabled allow for DS   *************************************/
-	if ((tpm_init.ds_mh_set_conf != 0) && (tpm_init.ds_mh_set_conf != 1)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n PNC - DS MH allow: wrong init value(%d) => "
-			"legal values <0=MH not allowed/DS,1=MH allowed/DS> \n",
-			tpm_init.ds_mh_set_conf);
-		return (TPM_FAIL);
-	}
-
-	if (tpm_init.port_fc_conf.enabled) {
-		MV_U32 device_id = mvCtrlModelGet();
-
-		if (device_id != MV_6601_DEV_ID) {
-			TPM_OS_FATAL(TPM_INIT_MOD, "\n port SW Flow-Control is not supported by this device");
-			return (TPM_FAIL);
-		}
-
-		if ((tpm_init.port_fc_conf.port > TPM_MAX_GMAC) 	||
-		    (tpm_init.port_fc_conf.tgt_port > TPM_MAX_GMAC)	||
-		    (tpm_init.port_fc_conf.tx_port > TPM_MAX_GMAC)){
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n port SW Flow-Control invalid port number:"
-				"port=%d tgt_port=%d tx_port=%d\n",
-				tpm_init.port_fc_conf.port,
-				tpm_init.port_fc_conf.tgt_port,
-				tpm_init.port_fc_conf.tx_port);
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.port_fc_conf.tx_queue >= TPM_MAX_NUM_TX_QUEUE){
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n port SW Flow-Control invalid port number: tx_queue=%d",
-				tpm_init.port_fc_conf.tx_queue);
-			return (TPM_FAIL);
-		}
-	}
-	/********************** ethernet ports validation ******************************************/
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (tpm_init.eth_port_conf[i].valid == TPM_TRUE) {
-			if ((tpm_init.eth_port_conf[i].chip_connect < TPM_CONN_DISC) ||
-					(tpm_init.eth_port_conf[i].chip_connect > TPM_CONN_RGMII2)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n ETH_port[(%d)]: chip_connect - wrong init value(%d)"
-					" => legal values <0-5> \n",
-					i, tpm_init.eth_port_conf[i].chip_connect);
-				return (TPM_FAIL);
-			}
-			if ((tpm_init.eth_port_conf[i].int_connect < TPM_INTCON_GMAC0) ||
-					(tpm_init.eth_port_conf[i].int_connect > TPM_INTCON_SWITCH)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n ETH_port[(%d)]: chip_connect - wrong init "
-					"value(%d) => legal values <0-2> \n",
-					i, tpm_init.eth_port_conf[i].int_connect);
-				return (TPM_FAIL);
-			}
-			if ((tpm_init.eth_port_conf[i].int_connect == TPM_INTCON_SWITCH) &&
-					(tpm_init.eth_port_conf[i].switch_port > 6)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n ETH_port[(%d)]: switch_port - wrong init "
-					"value(%d) => legal values <0-6> \n",
-					i, tpm_init.eth_port_conf[i].switch_port);
-				return (TPM_FAIL);
-			}
-
-			if ((tpm_init.eth_port_conf[i].int_connect == TPM_INTCON_SWITCH) &&
-				 (tpm_init.eth_port_conf[i].switch_port <= 6)) {
-				num_uni_ports++;
-			}
-		}
-	}
-	/********************* Virtual UNI validation *************************************/
-
-	if ((tpm_init.virt_uni_info.enabled < TPM_VIRT_UNI_DISABLED) ||
-			(tpm_init.virt_uni_info.enabled > TPM_VIRT_UNI_ENABLED)) {
-		TPM_OS_FATAL(TPM_INIT_MOD,
-			"\n Virtual UNI: wrong init value(%d) => legal "
-			"values <0=TPM_WIFI_VIRT_UNI_DISABLED/1=TPM_VIRT_UNI_ENABLED. \n",
-			tpm_init.virt_uni_info.enabled);
-		return (TPM_FAIL);
-	}
-	if (tpm_init.virt_uni_info.enabled == TPM_VIRT_UNI_ENABLED) {
-	/*oct* - open this validation in next LSP - meantime it works only on RD */
-#if 0
-		/* check that GMAC1 is connected to internal switch port #5 */
-		rc = mvBoardIsInternalSwitchConnected(1);
-		if (rc == 0) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n WiFi virtual UNI: feature ENABLED - GMAC1 "
-				"is NOT HW-connected to Switch  port #5. \n");
-			return (TPM_FAIL);
-		}
-#endif
-		/* fail eth complex other than dual MAC */
-		if (TPM_PON_WAN_DUAL_MAC_INT_SWITCH != tpm_init.eth_cmplx_profile)
-		{
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n Virtual UNI suppoerted only by ethernet Complex %x (used %x) \n",
-				TPM_PON_WAN_DUAL_MAC_INT_SWITCH, tpm_init.eth_cmplx_profile);
-			return (TPM_FAIL);
-		}
-
-		/* currently support only UNI_VIRT port for WIFI virtual UNI port */
-		if (tpm_init.virt_uni_info.uni_port != TPM_SRC_PORT_UNI_VIRT) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n Virtual UNI: wrong port value(%d) => "
-				"legal values <0-%d> - default value<%d. \n",
-				tpm_init.virt_uni_info.uni_port, TPM_SRC_PORT_UNI_VIRT ,TPM_SRC_PORT_UNI_VIRT);
-			return (TPM_FAIL);
-		}
-
-		num_uni_ports++;
-
-		/* if feature enabled and missing PNC range in the xml - return ERROR */
-		for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-			if (tpm_init.pnc_range[i].range_num == TPM_PNC_VIRT_UNI) {
-				if (tpm_init.pnc_range[i].valid != TPM_TRUE) {
-					TPM_OS_FATAL(TPM_INIT_MOD,
-						"\n Virtual UNI: feature ENABLED - missing "
-						"PNC range <TPM_PNC_VIRT_UNI> in XML config file. \n");
-					return (TPM_FAIL);
-				}
-			}
-		}	/* for */
-		/* TODO: check all GMAC1 TX queues are owned by CPU */
-
-	}
-
-	/*if wifi feature enabled - end validation */
-	/********************* PNC validations *****************************************************/
-	found_ipv4_pre = found_cnm_main = TPM_FALSE;
-	ipv4_pre_size = cnm_main_size = 0;
-
-	/* Validate total number of Pnc Entries */
-	for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-		if (tpm_init.pnc_range[i].valid == TPM_TRUE) {
-			j += tpm_init.pnc_range[i].range_size;
-			if (tpm_init.pnc_range[i].range_num >= TPM_MAX_NUM_RANGES) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"PNC range[%d]: range_num - wrong init value(%d) => "
-					"legal values <0-%d>\n",
-					i, tpm_init.pnc_range[i].range_num, TPM_MAX_RANGE);
-				return (TPM_FAIL);
-			}
-			if (tpm_init.pnc_range[i].range_type > TPM_RANGE_TYPE_TABLE) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"PNC range[%d]: range_type - wrong init value(%d) => "
-					"legal values <0=TYPE_ACL,1=TYPE_TABLE>\n",
-					i, tpm_init.pnc_range[i].range_type);
-				return (TPM_FAIL);
-			}
-			if ((tpm_init.pnc_range[i].cntr_grp < 0) || (tpm_init.pnc_range[i].cntr_grp > 3)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					     "PNC range[%d] cntr_grp - wrong init value(%d) => legal values <0-3>\n",
-					     i, tpm_init.pnc_range[i].cntr_grp);
-				return (TPM_FAIL);
-			}
-			if ((tpm_init.pnc_range[i].lu_mask < 0) || (tpm_init.pnc_range[i].lu_mask > 1)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					     "PNC range[%d] lu_mask - wrong init value(%d) => legal values <0-1>\n",
-					     i, tpm_init.pnc_range[i].lu_mask);
-				return (TPM_FAIL);
-			}
-			if (tpm_init.pnc_range[i].range_num == TPM_PNC_CNM_IPV4_PRE) {
-				found_ipv4_pre = TPM_TRUE;
-				ipv4_pre_size = tpm_init.pnc_range[i].range_size;
-			} else if (tpm_init.pnc_range[i].range_num == TPM_PNC_CNM_MAIN) {
-				found_cnm_main = TPM_TRUE;
-				cnm_main_size = tpm_init.pnc_range[i].range_size;
-			}
-		}
-	}
-	if (j > TPM_PNC_SIZE) {
-		TPM_OS_FATAL(TPM_INIT_MOD, "Sum of Pnc ranges(%d) is bigger than PnC size(%d)\n", j,
-			     TPM_PNC_SIZE);
-		return (TPM_FAIL);
-	}
-
-	/********************* MOD validations *****************************************************/
-	/* Validate TPM reserved modification entries */
-	/********************* TX module validations *****************************************************/
-
-	for (tx_mod = TPM_TX_MOD_GMAC0; tx_mod < TPM_MAX_NUM_TX_PORTS; (tx_mod)++) {
-		/* validate gmac_tx - according to tpm_init.num_tcont_llid */
-		if (tx_mod >= TPM_TX_MOD_PMAC_0) {
-			if (((tx_mod - TPM_TX_MOD_GMAC1) > tpm_init.num_tcont_llid) &&
-			    (tpm_init.gmac_tx[tx_mod].valid == 1)) {
-				tpm_init.gmac_tx[tx_mod].valid = 0;
-				TPM_OS_WARN(TPM_INIT_MOD,
-					    " Illegal TCONT/LLID %d configuration - max legal value is %d.\n ",
-					    tx_mod, tpm_init.num_tcont_llid);
-			}
-		}
-		for (i = 0; i < TPM_MAX_NUM_TX_QUEUE; i++) {
-			if (tpm_init.gmac_tx[tx_mod].tx_queue[i].valid != 1)
-				continue;
-
-			if ((tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_owner < TPM_Q_OWNER_CPU) ||
-			    (tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_owner >= TPM_Q_OWNER_MAX)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"TX module queue [%d]: queue_owner - wrong init value(%d)"
-					" => legal values <%d-%d>\n",
-					tx_mod, tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_owner,
-					TPM_Q_OWNER_CPU, TPM_Q_OWNER_PMAC);
-				return (TPM_FAIL);
-			}
-			if (tpm_init.gmac_tx[tx_mod].tx_queue[i].owner_queue_num >= TPM_MAX_NUM_TX_QUEUE) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"TX module queue [%d]: owner_queue_num - wrong init value(%d) "
-					"is bigger than maximum queue number (%d)\n",
-					tx_mod, tpm_init.gmac_tx[tx_mod].tx_queue[i].owner_queue_num,
-					TPM_MAX_NUM_TX_QUEUE - 1);
-				return (TPM_FAIL);
-			}
-			if ((tpm_init.gmac_tx[tx_mod].tx_queue[i].sched_method < TPM_SCHED_SP) ||
-			    (tpm_init.gmac_tx[tx_mod].tx_queue[i].sched_method > TPM_SCHED_WRR)) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"TX module queue [%d]: sched_method  - wrong init value(%d) => "
-					"legal values <%d-%d>\n\n",
-					tx_mod, tpm_init.gmac_tx[tx_mod].tx_queue[i].owner_queue_num,
-					TPM_SCHED_SP, TPM_SCHED_WRR);
-				return (TPM_FAIL);
-			}
-			if (tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_weight > TPM_MAX_WRR_WEIGHT) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"TX module queue [%d]: queue_weight  - wrong init value(%d) "
-					"=> legal values <0-%d>\n\n",
-					tx_mod, tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_weight,
-					TPM_MAX_WRR_WEIGHT);
-				return (TPM_FAIL);
-			}
-		}
-	}
-
-	/********* per GMAC - validate that default TCONT & Queue - are not set as HWF in xml *****/
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		rc = mv_eth_get_txq_cpu_def(gmac_i, &txp, &txq, 0);
-		if (rc != 0) {
-			TPM_OS_WARN(TPM_INIT_MOD, "\n Failed to GET the default queue per GMAC%d - rc= %d. \n",
-				    gmac_i, rc);
-			continue;
-		}
-		if (gmac_i >= TPM_ENUM_PMAC) {
-			if (tpm_init.gmac_tx[gmac_i + txp].tx_queue[txq].queue_owner != TPM_Q_OWNER_CPU) {
-				TPM_OS_WARN(TPM_INIT_MOD,
-					" Default TX queue(%d) per GMAC (%d) must not be set in "
-					"hardware forwarding mode in config params.\n\n", txq, gmac_i);
-			}
-		} else {
-			if (tpm_init.gmac_tx[gmac_i].tx_queue[txq].queue_owner != TPM_Q_OWNER_CPU) {
-				TPM_OS_WARN(TPM_INIT_MOD,
-					" Default TX queue(%d) per GMAC (%d) must not be set in "
-					"hardware forwarding mode in config params.\n\n", txq, gmac_i);
-			}
-		}
-	}
-
-	/*****split mod setting validation******/
-	if (tpm_init.split_mod_config.split_mod_enable == TPM_SPLIT_MOD_ENABLED) {
-		if(tpm_init.split_mod_config.vlan_num > (TPM_DB_SPLIT_MOD_NUM_VLANS_MAX - TPM_DB_SPLIT_MOD_INIT_VLANS_NUM)) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-			     "\n Split Mod VLAN num %d, it should not larger than %d \n",
-			     tpm_init.split_mod_config.vlan_num, (TPM_DB_SPLIT_MOD_NUM_VLANS_MAX - TPM_DB_SPLIT_MOD_INIT_VLANS_NUM));
-			return (TPM_FAIL);
-		}
-		if (tpm_init.split_mod_config.p_bit_num > TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX || tpm_init.split_mod_config.p_bit_num == TPM_DB_SPLIT_MOD_P_BIT_NO_SET) {
-			TPM_OS_FATAL(TPM_INIT_MOD, "\n Split Mod P_bit number out of range.\n");
-			return (TPM_FAIL);
-		}
-		for (i = 0; i < tpm_init.split_mod_config.p_bit_num; i++) {
-			if(tpm_init.split_mod_config.p_bit[i] > TPM_DB_SPLIT_MOD_P_BIT_MAX) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n Split Mod P_bit %d No Valid\n",
-					tpm_init.split_mod_config.p_bit[i]);
-				return (TPM_FAIL);
-			}
-			for (j = i + 1; j < tpm_init.split_mod_config.p_bit_num; j++) {
-				if(tpm_init.split_mod_config.p_bit[i] == tpm_init.split_mod_config.p_bit[j]) {
-					TPM_OS_FATAL(TPM_INIT_MOD,
-						"\n Split Mod P_bit %d Repeat\n",
-						tpm_init.split_mod_config.p_bit[i]);
-					return (TPM_FAIL);
-				}
-			}
-		}
-	}
-
-	/********************* CTC CNM validation *************************************/
-	if (tpm_init.ctc_cm_enable != TPM_CTC_CM_DISABLED) {
-		if (tpm_init.split_mod_config.split_mod_enable == TPM_SPLIT_MOD_DISABLED) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n CTC CM: CTC CnM is enabled while split modification is disabled! \n");
-			return (TPM_FAIL);
-		}
-
-		if (!found_ipv4_pre) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n CTC CM: CTC CnM is enabled while CNM_IPV4_PRE range size is Zero! \n");
-			return (TPM_FAIL);
-		} else {
-			exp_range_size = num_uni_ports * TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_PORT + 1;
-			if (exp_range_size > ipv4_pre_size) {
-				TPM_OS_WARN(TPM_INIT_MOD,
-					"\n CTC CM: CNM IPV4 PRE FILTER is not enough for "
-					"L2 & IPV4 combo rules (%d/%d) of %d UNI ports! \n",
-					exp_range_size, ipv4_pre_size, num_uni_ports);
-			}
-		}
-
-		if (!found_cnm_main) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n CTC CM: CTC CnM is enabled while CNM_MAIN range size is Zero! \n");
-			return (TPM_FAIL);
-		} else {
-			exp_range_size = num_uni_ports * TPM_MAX_NUM_CTC_PRECEDENCE + 2;
-			if (exp_range_size > cnm_main_size) {
-				TPM_OS_WARN(TPM_INIT_MOD,
-					"\n CTC CM: CNM MAIN is not enough for "
-					"8 precedence rules (%d/%d) of %d UNI ports! \n",
-					exp_range_size, cnm_main_size, num_uni_ports);
-			}
-		}
-	} else {
-		if (found_ipv4_pre) {
-			TPM_OS_WARN(TPM_INIT_MOD,
-				"\n CTC CM: Since CTC CnM is disabled, CNM_IPV4_PRE range size should be Zero! \n");
-		}
-		if (found_cnm_main) {
-			TPM_OS_WARN(TPM_INIT_MOD,
-				"\n CTC CM: Since CTC CnM is disabled, CNM_MAIN range size should be Zero! \n");
-		}
-	}
-
-	/********************* ds_mac_based_trunking validation *************************************/
-	if (tpm_init.ds_mac_based_trunk_enable == TPM_DS_MAC_BASED_TRUNK_ENABLED) {
-		if (    (tpm_init.cpu_loopback == TPM_CPU_LOOPBACK_ENABLED)
-		     || (tpm_init.mc_setting.per_uni_vlan_xlat)
-		     || (tpm_init.virt_uni_info.enabled == TPM_VIRT_UNI_ENABLED)) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n when ds_mac_based_trunk is enabled, cpu_loopback, per_uni_vlan_xlat"
-				" and virt_uni can not be enabled! \n");
-			return (TPM_FAIL);
-		}
-
-		if (    (tpm_init.gmac0_mh_en == 0)
-		     || (tpm_init.gmac1_mh_en == 0)) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n when ds_mac_based_trunk is enabled, MH on GMAC0/1 must be enabled\n");
-			return (TPM_FAIL);
-		}
-
-		if (    (tpm_init.eth_cmplx_profile != TPM_PON_WAN_DUAL_MAC_INT_SWITCH)
-		     && (tpm_init.eth_cmplx_profile != TPM_PON_WAN_DUAL_MAC_EXT_SWITCH)) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-				"\n when ds_mac_based_trunk is enabled, eth_cmplx_profile must be "
-				"TPM_PON_WAN_DUAL_MAC_INT_SWITCH"
-				" or TPM_PON_WAN_DUAL_MAC_EXT_SWITCH! \n");
-			return (TPM_FAIL);
-		}
-
-	}
-	/********************* No switch init(MC) validation *************************************/
-	if (tpm_init.switch_init == 0) {
-		if (tpm_init.virt_uni_info.enabled == TPM_VIRT_UNI_ENABLED) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: Virt UNI is not supported! \n");
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.mc_setting.per_uni_vlan_xlat) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: MC Per UNI Xlate is not supported! \n");
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.mc_setting.filter_mode != TPM_MC_ALL_CPU_FRWD && tpm_init.mc_setting.filter_mode != TPM_MC_IP_ONLY_FILTER) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: MC filter mode(%d) not supported! \n", tpm_init.mc_setting.filter_mode);
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.ety_dsa_enable == TPM_ETY_DSA_ENABLE) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: DSA is not supported! \n");
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.gmac0_mh_en == 1) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: GMAC0 Marvell header should disabled! \n");
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.pnc_range[TPM_PNC_MAC_LEARN].range_size == 0 &&
-		    tpm_init.pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_ENABLED) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n No Switch Init: PNC range[%d] size is 0! \n", TPM_PNC_MAC_LEARN);
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_DISABLED &&
-		    tpm_init.pnc_range[TPM_PNC_MAC_LEARN].range_size > 1) {
-			TPM_OS_WARN(TPM_INIT_MOD,
-					"\n No Switch Init: MAC learn disabled, PNC range[%d] size is too bigger! \n", TPM_PNC_MAC_LEARN);
-		}
-
-		if (tpm_init.pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_ENABLED &&
-		    tpm_init.pnc_range[TPM_PNC_MAC_LEARN].range_size <= 1) {
-			TPM_OS_WARN(TPM_INIT_MOD,
-					"\n No Switch Init: MAC learn enabled, PNC range[%d] size is too small! \n", TPM_PNC_MAC_LEARN);
-		}
-
-		if (tpm_init.pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_ENABLED &&
-		    tpm_init.eth_cmplx_profile != TPM_PON_WAN_G0_G1_LPBK) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n PNC MAC learning not supported with profile (%d) \n",
-					tpm_init.eth_cmplx_profile);
-			return (TPM_FAIL);
-		}
-
-		if (tpm_init.ipv6_5t_enable == TPM_IPV6_5T_ENABLED &&
-		    tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_DUAL_LAN) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n IPV6 5-tuple supported with profile (%d) \n",
-					tpm_init.eth_cmplx_profile);
-			return (TPM_FAIL);
-		}
-	} else if ((tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_SINGLE_PORT ||
-		    tpm_init.eth_cmplx_profile == TPM_PON_WAN_G1_SINGLE_PORT ||
-		    tpm_init.eth_cmplx_profile == TPM_PON_G1_WAN_G0_SINGLE_PORT ||
-		    tpm_init.eth_cmplx_profile == TPM_PON_G0_WAN_G1_SINGLE_PORT ||
-		    tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_LPBK ||
-		    tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_DUAL_LAN)
-		 && tpm_init.switch_init == 1) {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n Switch can not be Init at this profile: [%d]! \n", tpm_init.eth_cmplx_profile);
-			tpm_init.switch_init = 0;
-	}
-
-	/* check XML Tx queue for MC chip with profile TPM_PON_WAN_G0_G1_LPBK */
-	if((MV_6601_DEV_ID == mvCtrlModelGet()) && (TPM_PON_WAN_G0_G1_LPBK == tpm_init.eth_cmplx_profile)) {
-		/* check GMAC1 Tx queue configuration in XML */
-		if (tpm_init.gmac_tx[TPM_TX_MOD_GMAC1].valid == TPM_TRUE) {
-			for (i = 0; i < TPM_MAX_NUM_TX_QUEUE; i++) {
-				if (tpm_init.gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[i].valid == TPM_TRUE) {
-					if (tpm_init.gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[i].queue_owner == TPM_Q_OWNER_GMAC0)
-						gmac0_owner++;
-					if (tpm_init.gmac_tx[TPM_TX_MOD_GMAC1].tx_queue[i].queue_owner == TPM_Q_OWNER_CPU)
-						cpu_owner++;
-				}
-			}
-			if (gmac0_owner == 0) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-						"\n TPM_PON_WAN_G0_G1_LPBK: MC chip GMAC1 Tx queue no assigned to GMAC0 \n");
-				return (TPM_FAIL);
-			} else if (gmac0_owner > 1) {
-				TPM_OS_WARN(TPM_INIT_MOD,
-						"\n TPM_PON_WAN_G0_G1_LPBK: One GMAC1 Tx queue assigned to GMAC0 enough! \n");
-			}
-			if (cpu_owner == 0) {
-				TPM_OS_FATAL(TPM_INIT_MOD,
-						"\n TPM_PON_WAN_G0_G1_LPBK: MC chip GMAC1 Tx queue no assigned to CPU \n");
-				return (TPM_FAIL);
-			}
-		} else {
-			TPM_OS_FATAL(TPM_INIT_MOD,
-					"\n TPM_PON_WAN_G0_G1_LPBK: MC chip GMAC1 Invalid! \n");
-			return (TPM_FAIL);
-		}
-
-		/* check PON Tx queue configuration in XML */
-		for (i = TPM_TX_MOD_PMAC_0; i < TPM_MAX_NUM_TX_PORTS; i++) {
-			if (tpm_init.gmac_tx[i].valid == TPM_TRUE) {
-				for(j = 0; j < TPM_MAX_NUM_TX_QUEUE; j++) {
-					if (tpm_init.gmac_tx[i].tx_queue[j].valid != TPM_TRUE ||
-					    tpm_init.gmac_tx[i].tx_queue[j].queue_owner != TPM_Q_OWNER_GMAC1) {
-						TPM_OS_WARN(TPM_INIT_MOD,
-							"\n TPM_PON_WAN_G0_G1_LPBK: All PON-%d Tx queue should be assign to GMAC1! \n", (i - TPM_TX_MOD_PMAC_0));
-						break;
-					}
-				}
-			}
-		}
-	}
-
-	/* check all the loopback features */
-	if (tpm_init.mc_setting.per_uni_vlan_xlat) {
-		if (tpm_init.virt_uni_info.enabled != TPM_VIRT_UNI_ENABLED) {
-			TPM_OS_FATAL(TPM_INIT_MOD, "\n per_uni_vlan_xlat can not be supported when virt_uni is disabled\n");
-			return (TPM_FAIL);
-		}
-	}
-	if (tpm_init.cpu_loopback == TPM_CPU_LOOPBACK_ENABLED) {
-		if (tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_LPBK)
-			;/* OK */
-		else if (    (tpm_init.gmac_port_conf[TPM_ENUM_GMAC_1].conn == TPM_GMAC_CON_SWITCH_5)
-		          && (tpm_init.eth_cmplx_profile != TPM_G0_WAN_G1_INT_SWITCH)
-		          && (tpm_init.eth_cmplx_profile != TPM_PON_G0_WAN_G1_INT_SWITCH))
-			;/* OK */
-		else {
-			TPM_OS_FATAL(TPM_INIT_MOD, "\n cpu_wan_loopback can not be supported on this profile\n");
-			return (TPM_FAIL);
-		}
-	}
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_init_tx_mod_set()
-*
-* DESCRIPTION:      Set the configuration of a Tx module
-*
-* INPUTS:
-* tx_mod           -
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-void tpm_init_tx_mod_set(tpm_db_tx_mod_t tx_mod)
-{
-	uint32_t i;
-
-	for (i = 0; i < TPM_MAX_NUM_TX_QUEUE; i++) {
-		if (tpm_init.gmac_tx[tx_mod].tx_queue[i].valid == TPM_TRUE) {
-			tpm_db_gmac_tx_q_conf_set(tx_mod, i,
-						  tpm_init.gmac_tx[tx_mod].tx_queue[i].sched_method,
-						  tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_owner,
-						  tpm_init.gmac_tx[tx_mod].tx_queue[i].owner_queue_num,
-						  tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_size,
-						  tpm_init.gmac_tx[tx_mod].tx_queue[i].queue_weight);
-		}
-	}
-
-}
-
-/*******************************************************************************
-* tpm_init_gmac_rxq_set()
-*
-* DESCRIPTION:      Set the queue configuration of a GMAC
-*
-* INPUTS:
-* tx_mod           -
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-void tpm_init_gmac_rxq_set(tpm_gmacs_enum_t gmac)
-{
-	uint32_t i;
-
-	for (i = 0; i < TPM_MAX_NUM_RX_QUEUE; i++) {
-		if (tpm_init.gmac_rx[gmac].rx_queue[i].valid == TPM_TRUE)
-			tpm_db_gmac_rx_q_conf_set(gmac, i, tpm_init.gmac_rx[gmac].rx_queue[i].queue_size);
-	}
-}
-
-/*******************************************************************************
-* tpm_init_pncranges_set()
-*
-* DESCRIPTION:      Initialize the PnC ranges
-*
-* INPUTS:
-* tx_mod           -
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_pncranges_set(tpm_reset_level_enum_t reset_type)
-{
-	tpm_db_pnc_range_conf_t pnc_range_conf;
-	uint32_t cur_pnc_entry = 0;
-	uint32_t luid = 0, last_lu_range, val;
-	uint32_t i;
-	tpm_pnc_ranges_t cur_range;
-	int32_t ret_code;
-
-	/* Init basics which are same for all Ranges */
-	pnc_range_conf.num_luids = 1;
-
-	/* Insert valid PnC Ranges by enum order */
-	for (cur_range = 0; cur_range <= TPM_MAX_RANGE; cur_range++) {
-		/* Search Input Table */
-		for (i = 0; i < TPM_MAX_NUM_RANGES; i++) {
-			if ((tpm_init.pnc_range[i].range_num == cur_range) && (tpm_init.pnc_range[i].valid == TPM_TRUE)
-			    && (tpm_init.pnc_range[i].range_size > 0)) {
-				pnc_range_conf.range_id = tpm_init.pnc_range[i].range_num;
-				pnc_range_conf.min_reset_level = tpm_init.pnc_range[i].min_reset_level;
-				pnc_range_conf.range_type = tpm_init.pnc_range[i].range_type;
-				pnc_range_conf.range_size = tpm_init.pnc_range[i].range_size;
-				pnc_range_conf.range_start = cur_pnc_entry;
-				pnc_range_conf.range_end = cur_pnc_entry + tpm_init.pnc_range[i].range_size - 1;
-				pnc_range_conf.cntr_grp = tpm_init.pnc_range[i].cntr_grp;
-				pnc_range_conf.lu_mask = tpm_init.pnc_range[i].lu_mask;
-				pnc_range_conf.api_start = 0;
-				/* For the dscp_ds or dscp_us range, reserve hardcoded  entry at the beginning
-				 * of the pnc_range (see tpm_proc_ipv4_dscp_init) */
-				if (tpm_init.pnc_range[i].range_size < (pnc_range_conf.api_start + 1)) {
-					TPM_OS_ERROR(TPM_INIT_MOD,
-						"pnc_range(%d) cannot set first api_entry to (%d), pnc_range  "
-						"is too small\n",
-						cur_range, pnc_range_conf.api_start);
-					return (TPM_FAIL);
-				}
-				tpm_init_lookup_get(tpm_init.pnc_range[i].range_num, &luid, &last_lu_range, &val);
-				if (val == 0) {
-					TPM_OS_ERROR(TPM_INIT_MOD, "pnc_range(%d) has no defined lookup_id\n",
-						     cur_range);
-					return (TPM_FAIL);
-				}
-
-				pnc_range_conf.base_lu_id = luid;
-
-				/* Set PortId for last entry drop/trap usage, currently last entry will be valid for all active gmacs */
-				pnc_range_conf.last_ent_portid = tpm_proc_all_gmac_bm();
-
-				/* Depending if this is last Range of a LookupId, reserve last entry for debug */
-				if (0 && last_lu_range == 1) {	/* YUVAL_NOW, add xml_param here */
-					if (tpm_init.pnc_range[i].range_size < ((pnc_range_conf.api_start + 1) + 1)) {
-						TPM_OS_ERROR(TPM_INIT_MOD,
-							"pnc_range(%d) cannot set last entry to trap, pnc_range "
-							" is is too small\n",
-							cur_range);
-						return (TPM_FAIL);
-					}
-					/* TODO - this is harcdoded to trap, should be configurable trap/drop/default */
-					pnc_range_conf.init_last_entry = TPM_PNC_RNG_LAST_INIT_TRAP;
-					pnc_range_conf.api_end = pnc_range_conf.range_size - 2;
-				} else {
-					pnc_range_conf.init_last_entry = TPM_PNC_RNG_LAST_INIT_DEF;
-					pnc_range_conf.api_end = pnc_range_conf.range_size - 1;
-				}
-
-				/* Create or Reset the Range (Delete+Create), or skip resetting it */
-				if (reset_type < pnc_range_conf.min_reset_level) {
-					TPM_OS_DEBUG(TPM_INIT_MOD, " skip resetting range (%d)\n",
-						     pnc_range_conf.range_id);
-				} else {
-					TPM_OS_DEBUG(TPM_INIT_MOD, " set range (%d)\n", pnc_range_conf.range_id);
-					/* Never mind if it did or did not exist */
-					ret_code = tpm_db_pnc_rng_delete(pnc_range_conf.range_id);
-					ret_code = tpm_db_pnc_rng_create(&pnc_range_conf);
-					IF_ERROR(ret_code);
-				}
-				cur_pnc_entry += tpm_init.pnc_range[i].range_size;
-
-				TPM_OS_DEBUG(TPM_INIT_MOD,
-					     "\t rng_type(%d)  rng_id(%d)    rng_start(%d)     rng_end(%d)\n"
-					     "\t rng_size(%d)  cntr_grp(%d)  lu_mask(%d)   api_start(%d) \n"
-					     "\t api_end(%d)   lu_id(%d)\n"
-					     "\t init_last_e(%d) last_ent_port_id(%x)\n",
-					     pnc_range_conf.range_type,
-					     pnc_range_conf.range_id,
-					     pnc_range_conf.range_start,
-					     pnc_range_conf.range_end,
-					     pnc_range_conf.range_size,
-					     pnc_range_conf.cntr_grp,
-					     pnc_range_conf.lu_mask,
-					     pnc_range_conf.api_start,
-					     pnc_range_conf.api_end,
-					     pnc_range_conf.base_lu_id,
-					     pnc_range_conf.init_last_entry, pnc_range_conf.last_ent_portid);
-
-				TPM_OS_DEBUG(TPM_INIT_MOD, "cur_pnc_entry(%d)\n", cur_pnc_entry);
-				break;
-			}
-		}
-	}
-	return (TPM_OK);
-}
-
-int32_t tpm_init_api_rng_init(tpm_pnc_ranges_t range, tpm_api_sections_t api_sec, tpm_dir_t dir)
-{
-	int32_t ret_code;
-	uint32_t api_size;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	ret_code = tpm_db_pnc_rng_conf_get(range, &range_conf);
-	if (ret_code != TPM_OK) {
-		TPM_OS_WARN(TPM_INIT_MOD, " PNC Range(%d) was not created - rc(%d) \n", range, ret_code);
-	} else {
-		api_size = (range_conf.api_end - range_conf.api_start + 1);
-		ret_code = tpm_db_api_section_init(api_sec, range, api_size);
-		IF_ERROR(ret_code);
-		return (ret_code);
-	}
-	return (TPM_OK);
-}
-
-int32_t tpm_init_api_rng_init_all(void)
-{
-	int32_t ret_code;
-	/* Init the API Entries Memeory Area */
-	tpm_db_api_entries_area_reset();
-
-	/* Init API Ranges - MAC LEARN */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_MAC_LEARN, TPM_PNC_MAC_LEARN_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges - CPU WAN LPBK */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_CPU_WAN_LPBK_US, TPM_CPU_LOOPBACK_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges - L2DS, L2US */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_L2_MAIN, TPM_L2_PRIM_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges - L3DS, L3US */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_ETH_TYPE, TPM_L3_TYPE_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges - IPV4 US, IPV4 DS */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV4_MAIN, TPM_IPV4_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges - IPV4 MC */
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV4_MC_DS, TPM_IPV4_MC, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV6_GEN, TPM_IPV6_GEN_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV6_NH, TPM_IPV6_NH_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV6_DIP, TPM_IPV6_DIP_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV6_L4, TPM_L4_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-	ret_code = tpm_init_api_rng_init(TPM_PNC_IPV6_MC_DS, TPM_IPV6_MC_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_init_api_rng_init(TPM_PNC_CNM_MAIN, TPM_CNM_MAIN_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_init_api_rng_init(TPM_PNC_DS_LOAD_BALANCE, TPM_DS_LOAD_BALANCE_ACL, TPM_DIR_DS);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-
-uint16_t tpm_init_uni_amber_vec_map(uint16_t uni_vec)
-{
-	uint16_t amber_vec = 0;
-	uint16_t amber_port = 0;
-	uint32_t uni_i;
-	tpm_src_port_type_t uni_src_port;
-
-	for (uni_i = 0; uni_i < TPM_MAX_NUM_ETH_PORTS; uni_i++) {
-		if (uni_vec & (1 << uni_i)) {
-			uni_src_port = TPM_SRC_PORT_UNI_0 + uni_i;
-			amber_port = (uint16_t) tpm_db_eth_port_switch_port_get(uni_src_port);
-			amber_vec |= (1 << amber_port);
-		}
-	}
-	return (amber_vec);
-}
-
-int32_t tpm_init_port_vector_tbl(void)
-{
-	uint32_t i, pnc_vector, tbl_entry, uni_port_nr;
-	int32_t ret_code, virt_uni_amber_port_bmp = 0;
-	tpm_init_virt_uni_t virt_uni_info;
-	uint16_t amber_port_vector;
-	uint32_t trg_port_uni_vec = 0, uni_vector, uni_vector_bmp;
-
-	/* use all 16 registers with straight mapping uni_vector to amber_port_vector
-	   only UNI_0 - UNI_3 are used */
-	ret_code = tpm_db_virt_info_get(&virt_uni_info);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " tpm_db_virt_info_get ret_code(%d)\n", ret_code);
-		return (ret_code);
-	}
-
-	/* virt uni not enabled */
-	if (virt_uni_info.enabled == 0) {
-		/* Convert UNI_Vector to Amber Vector, applies to uni_0..7, uni_vector from 0x00 to 0xFF */
-		for (i = 0; i < TPM_TX_MAX_MH_REGS; i++) {
-			amber_port_vector = tpm_init_uni_amber_vec_map(i + 1);
-			tpm_db_port_vector_tbl_info_set(i, i + 1, amber_port_vector, 0);
-		}
-		return TPM_DB_OK;
-       }
-
-	/* virt uni enabled */
-
-	/* first map all 8 UNI ports */
-	amber_port_vector = 0;
-	pnc_vector = 1;
-	tbl_entry = 0;
-	uni_vector_bmp = 0;
-	uni_port_nr = TPM_SRC_PORT_UNI_0;
-	for (uni_vector = TPM_TRG_UNI_0; uni_vector <= TPM_TRG_UNI_VIRT; uni_vector = uni_vector << 1) {
-	uint16_t switch_port = tpm_db_eth_port_switch_port_get(uni_port_nr);
-
-		if (TPM_DB_ERR_PORT_NUM != switch_port){
-		tpm_db_port_vector_tbl_info_set(tbl_entry, uni_vector, (1 << switch_port),
-							pnc_vector << TPM_MH_RI_OFFSET);
-
-			/* save the internal switch vector for later use */
-			amber_port_vector |= (1 << switch_port);
-
-			/* save the virt uni and target port vec w/o virt port for later use */
-			if ((1 == virt_uni_info.enabled) && (uni_port_nr == virt_uni_info.uni_port))
-				virt_uni_amber_port_bmp = (1 << switch_port);
-			else
-				uni_vector_bmp |= uni_vector;
-
-			trg_port_uni_vec |= (pnc_vector << TPM_MH_RI_OFFSET);
-		}
-		pnc_vector++;
-		tbl_entry++;
-		uni_port_nr++;
-	}
-
-	/* now add UNI_ANY mapping */
-	tpm_db_port_vector_tbl_info_set(tbl_entry, TPM_TRG_PORT_UNI_ANY, amber_port_vector,
-					pnc_vector << TPM_MH_RI_OFFSET);
-	tbl_entry++;
-
-	/* now add UNI_ANY_SPECIAL mapping (exluding virt-uni port) */
-	if (1 == virt_uni_info.enabled)
-		amber_port_vector &= ~virt_uni_amber_port_bmp;
-
-	tpm_db_port_vector_tbl_info_set(tbl_entry, uni_vector_bmp, amber_port_vector, trg_port_uni_vec);
-
-	return TPM_DB_OK;
-}
-
-int32_t tpm_init_info_set(void)
-{
-	int32_t ret_code;
-	uint32_t i;
-	tpm_src_port_type_t src_port;
-
-	tpm_db_eth_cmplx_profile_set(tpm_init.eth_cmplx_profile);
-	ret_code = tpm_db_eth_max_uni_port_set();
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pon_type_set(tpm_init.pon_type);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_active_wan_set(tpm_init.active_wan);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ds_mh_set_conf_set(tpm_init.ds_mh_set_conf);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_cfg_pnc_parse_set(tpm_init.cfg_pnc_parse);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_cpu_loopback_set(tpm_init.cpu_loopback);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ipv6_5t_enable_set(tpm_init.ipv6_5t_enable);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ctc_cm_enable_set(tpm_init.ctc_cm_enable);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ctc_cm_ipv6_parse_win_set(tpm_init.ctc_cm_ipv6_parse_window);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ctc_cm_ipv6_parse_win_orig_set(tpm_init.ctc_cm_ipv6_parse_window);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_virt_info_set(tpm_init.virt_uni_info);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_double_tag_support_set((tpm_init.num_vlan_tags > 1) ? 1 : 0);
-	IF_ERROR(ret_code);
-#if 0
-	ret_code = tpm_db_default_tag_tpid_set(tpm_init.vlan1_tpid, tpm_init.vlan2_tpid);
-	IF_ERROR(ret_code);
-#endif
-	ret_code = tpm_db_default_tag_tpid_set(&tpm_init.tpid_opt);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_switch_init_set(tpm_init.switch_init);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pnc_mac_learn_enable_set(tpm_init.pnc_mac_learn_enable);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_fc_conf_set(&tpm_init.port_fc_conf);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_ds_mac_based_trunk_enable_set(tpm_init.ds_mac_based_trunk_enable);
-	IF_ERROR(ret_code);
-
-	/* Set GMAC Logical Functions */
-
-	/* PON_MAC */
-	if (tpm_db_active_wan_get() == TPM_ENUM_PMAC)
-		if ((tpm_init.pon_type == TPM_GPON || tpm_init.pon_type == TPM_EPON) &&
-		    (tpm_init.pon_type != TPM_P2P)) {
-			ret_code = tpm_db_omci_type_set(tpm_init.omci_etype);
-			IF_ERROR(ret_code);
-		}
-
-	/* set GMAC/PMAC functionality */
-	tpm_db_mac_func_set();
-
-#if 0				/*Keep to be added in future version */
-	/* Set Debug Port */
-	if (tpm_init.deb_port_valid == 1) {
-		ret_code = tpm_db_pnc_init_deb_port_set(tpm_init.deb_port);
-		IF_ERROR(ret_code);
-	}
-#endif
-
-	/* Set IGMP Conf */
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_WAN; src_port++) {
-		tpm_db_igmp_set_port_frwd_mode(src_port, tpm_init.igmp_pkt_frwd_mod[src_port]);
-		printk(KERN_INFO "TPM_SRC_PORT: %d, value: %d\n", src_port, tpm_init.igmp_pkt_frwd_mod[src_port]);
-	}
-	tpm_db_igmp_set_cpu_queue(tpm_init.igmp_cpu_queue);
-	tpm_db_igmp_set_snoop_enable(tpm_init.igmp_snoop);
-	/*printk("TPM_SRC_PORT_WAN: %d, TPM_SRC_PORT_UNI_0: %d, TPM_SRC_PORT_UNI_1: %d, TPM_SRC_PORT_UNI_2: %d, "
-	   "TPM_SRC_PORT_UNI_3: %d, igmp_cpu_queue: %d\n",
-	   tpm_init.igmp_pkt_frwd_mod[4],tpm_init.igmp_pkt_frwd_mod[0],tpm_init.igmp_pkt_frwd_mod[1],
-	   tpm_init.igmp_pkt_frwd_mod[2],tpm_init.igmp_pkt_frwd_mod[3],tpm_init.igmp_cpu_queue); */
-
-	/* Set ethernet Port Config */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_TRUE == tpm_init.eth_port_conf[i].valid) {
-			ret_code = tpm_db_eth_port_conf_set(&tpm_init.eth_port_conf[i]);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Set GMAC Port Config */
-	ret_code = tpm_db_gmac_conn_conf_set(tpm_init.gmac_port_conf, TPM_NUM_GMACS);
-	IF_ERROR(ret_code);
-
-	/* Init MH Tx Amber Port Vectors Table */
-	tpm_init_port_vector_tbl();
-
-	/* Set tcont_llid */
-	ret_code = tpm_db_gmac_tcont_llid_set(tpm_init.num_tcont_llid);
-	IF_ERROR(ret_code);
-
-	/* Set GMAC mh_enable */
-	ret_code = tpm_db_gmac_mh_en_conf_set(TPM_ENUM_GMAC_0, tpm_init.gmac0_mh_en);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_mh_en_conf_set(TPM_ENUM_GMAC_1, tpm_init.gmac1_mh_en);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_mh_en_conf_set(TPM_ENUM_PMAC, TPM_TRUE);
-	IF_ERROR(ret_code);
-
-	/* Set GMAC BM pools */
-	for (i = 0; i < sizeof(tpm_init.gmac_bp_bufs) / sizeof(tpm_init_gmac_bufs_t); i++) {
-		if (tpm_init.gmac_bp_bufs[i].valid == TPM_TRUE) {
-			tpm_db_gmac_bm_bufs_conf_set(i,
-						     tpm_init.gmac_bp_bufs[i].large_pkt_buffers,
-						     tpm_init.gmac_bp_bufs[i].small_pkt_buffers);
-		}
-	}
-
-	/* Set GMAC/TCONT Tx Queues */
-
-	/* GMAC0 tx */
-	if (tpm_init.gmac_port_conf[0].conn != TPM_GMAC_CON_DISC) {
-		tpm_db_gmac_tx_val_set(TPM_TX_MOD_GMAC0);
-		tpm_init_tx_mod_set(TPM_TX_MOD_GMAC0);
-
-	}
-	/* GMAC1 tx */
-	if (tpm_init.gmac_port_conf[1].conn != TPM_GMAC_CON_DISC) {
-		tpm_db_gmac_tx_val_set(TPM_TX_MOD_GMAC1);
-		tpm_init_tx_mod_set(TPM_TX_MOD_GMAC1);
-	}
-	/* TCONTs */
-	for (i = TPM_TX_MOD_PMAC_0; i < (TPM_TX_MOD_PMAC_0 + tpm_init.num_tcont_llid); i++) {
-		tpm_db_gmac_tx_val_set(i);
-		tpm_init_tx_mod_set(i);
-	}
-
-	/* Set GMAC Rx Queues */
-
-	/* GMAC0 rx */
-	if (tpm_init.gmac_port_conf[0].conn != TPM_GMAC_CON_DISC) {
-		tpm_db_gmac_rx_val_set(TPM_ENUM_GMAC_0);
-		tpm_init_gmac_rxq_set(TPM_ENUM_GMAC_0);
-	}
-
-	/* GMAC1 rx */
-	if (tpm_init.gmac_port_conf[1].conn != TPM_GMAC_CON_DISC) {
-		tpm_db_gmac_rx_val_set(TPM_ENUM_GMAC_1);
-		tpm_init_gmac_rxq_set(TPM_ENUM_GMAC_1);
-	}
-	/* PMAC Rx */
-	if (    tpm_init.pon_type == TPM_GPON
-	     || tpm_init.pon_type == TPM_EPON
-	     || tpm_init.pon_type == TPM_P2P) {
-		tpm_db_gmac_rx_val_set(TPM_ENUM_PMAC);
-		tpm_init_gmac_rxq_set(TPM_ENUM_PMAC);
-	}
-
-	/* Init PNC Ranges */
-	/* Init ALL PnC Ranges in the DB, even PnC Ranges with highest reset_level */
-	ret_code = tpm_init_pncranges_set(TPM_ENUM_MAX_RESET_LEVEL + 1);
-	IF_ERROR(ret_code);
-
-	/* Init API Ranges */
-	ret_code = tpm_init_api_rng_init_all();
-	IF_ERROR(ret_code);
-
-	tpm_db_mod2_set_udp_checksum_use_init_bm_state(tpm_init.mod_config.udp_checksum_use_init_bm);
-	tpm_db_mod2_set_udp_checksum_state(tpm_init.mod_config.udp_checksum_update);
-
-	for (i = 0; i < tpm_init.mod_chain.chain_num; i++)
-		tpm_db_mod2_set_chain_num(tpm_init.mod_chain.chain_data[i].type, tpm_init.mod_chain.chain_data[i].num);
-
-	/*** Set state of MH modification in PMT for Multicast ***/
-
-	/* For ip_only_filter_mode, multicast will ALWAYS update the MH, and NEVER use the MH_tx_registers
-	   This way it works the same way for both with_virtual_uni and without_virtual_uni */
-	if (tpm_init.mc_setting.filter_mode == TPM_MC_IP_ONLY_FILTER)
-		tpm_db_mod2_set_multicast_mh_state(1);
-	else {
-		/* For mac_ip_combo_filter_mode, MH is not modified.
-		 * The MH_tx_register are set to :
-		 *   - no_uni_translation  - The "broadcast register", to all_uni_ports.
-		 *   - yes_uni_translation - to switch_port of GMAC1.
-		 * For other modes (not supported yet), it will be same as mac_ip_combo_filter_mode
-		 */
-		if (tpm_init.mc_setting.per_uni_vlan_xlat)
-			tpm_db_mod2_set_multicast_mh_state(1);
-		else
-			tpm_db_mod2_set_multicast_mh_state(0);
-	}
-	/* Set system support for adding PPPoE header as part of PMT modification */
-	tpm_db_mod2_set_pppoe_add_mod_state(tpm_init.pppoe_add_enable);
-
-	/* Set modification double_tag according to num_vlan_tags parameter */
-	tpm_db_mod2_set_double_tag_state((tpm_init.num_vlan_tags >= 2));
-
-	/* set mtu config */
-	tpm_db_mtu_set_ipv4_mtu_us(tpm_init.mtu_config.ipv4_mtu_us);
-
-	tpm_db_mtu_set_ipv4_pppoe_mtu_us(tpm_init.mtu_config.ipv4_pppoe_mtu_us);
-
-	tpm_db_mtu_set_ipv6_mtu_us(tpm_init.mtu_config.ipv6_mtu_us);
-
-	tpm_db_mtu_set_ipv6_pppoe_mtu_us(tpm_init.mtu_config.ipv6_pppoe_mtu_us);
-
-	tpm_db_mtu_set_ipv4_mtu_ds(tpm_init.mtu_config.ipv4_mtu_ds);
-
-	tpm_db_mtu_set_ipv6_mtu_ds(tpm_init.mtu_config.ipv6_mtu_ds);
-
-	tpm_db_set_pppoe_add_enable(tpm_init.pppoe_add_enable);
-
-	tpm_db_set_num_vlan_tags(tpm_init.num_vlan_tags);
-
-	tpm_db_set_mtu_enable(tpm_init.mtu_config.mtu_enable);
-
-	tpm_db_set_cpu_rx_queue(tpm_init.cpu_rx_queue);
-
-	tpm_db_set_ttl_illegal_action(tpm_init.ttl_illegal_action);
-
-	tpm_db_set_tcp_flag_check(tpm_init.tcp_flag_check);
-
-	tpm_db_set_mc_filter_mode(tpm_init.mc_setting.filter_mode);
-	/*tpm_db_set_mc_igmp_mode(tpm_init.mc_setting.igmp_mode); */
-	tpm_db_set_mc_per_uni_vlan_xlate(tpm_init.mc_setting.per_uni_vlan_xlat);
-	tpm_db_set_mc_lpbk_enable(TPM_IP_VER_4, (uint8_t)tpm_init.mc_setting.ipv4_mc_support);
-	tpm_db_set_mc_lpbk_enable(TPM_IP_VER_6, (uint8_t)tpm_init.mc_setting.ipv6_mc_support);
-	tpm_db_set_mc_pppoe_enable(tpm_init.mc_setting.mc_pppoe_enable);
-	tpm_db_set_mc_hwf_queue(tpm_init.mc_setting.mc_hwf_queue);
-	tpm_db_set_mc_cpu_queue(tpm_init.mc_setting.mc_cpu_queue);
-
-	tpm_db_set_catch_all_pkt_action(tpm_init.catch_all_pkt_action);
-	tpm_db_set_ety_dsa_enable(tpm_init.ety_dsa_enable);
-
-	/* set split mod config */
-	tpm_db_split_mod_set_enable(tpm_init.split_mod_config.split_mod_enable);
-	tpm_db_split_mod_set_num_vlans(tpm_init.split_mod_config.vlan_num);
-	tpm_db_split_mod_set_num_p_bits(tpm_init.split_mod_config.p_bit_num, tpm_init.split_mod_config.p_bit);
-	tpm_db_split_mod_set_mode(tpm_init.split_mod_config.split_mod_mode);
-
-	/* set function profile */
-	if (tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_LPBK)
-		tpm_db_gmac1_lpbk_en_set(true);
-	else
-		tpm_db_gmac1_lpbk_en_set(false);
-
-	/* set CPU WAN loopback en */
-	tpm_db_cpu_wan_lpbk_en_set(tpm_init.cpu_loopback);
-
-	tpm_db_switch_init_set(tpm_init.switch_init);
-	if (	(tpm_init.eth_cmplx_profile == TPM_PON_WAN_DUAL_MAC_INT_SWITCH)
-	     || (tpm_init.eth_cmplx_profile == TPM_PON_WAN_DUAL_MAC_EXT_SWITCH))
-		tpm_db_ds_load_bal_en_set(true);
-	else
-		tpm_db_ds_load_bal_en_set(false);
-
-
-	/* set switch active WAN en */
-	if (    (tpm_init.eth_cmplx_profile == TPM_PON_G1_WAN_G0_INT_SWITCH)
-	     || (tpm_init.eth_cmplx_profile == TPM_PON_G0_WAN_G1_INT_SWITCH)
-	     || (tpm_init.eth_cmplx_profile == TPM_PON_G1_WAN_G0_SINGLE_PORT)
-	     || (tpm_init.eth_cmplx_profile == TPM_PON_G0_WAN_G1_SINGLE_PORT))
-		tpm_db_switch_active_wan_en_set(true);
-	else
-		tpm_db_switch_active_wan_en_set(false);
-
-	return (TPM_OK);
-}
-
-void tpm_init_locks_init(void)
-{
-	spin_lock_init(&tpmPncLock);
-	spin_lock_init(&tpmModLock);
-	spin_lock_init(&tpmTcamAgingLock);
-}
-
-/* Note : The function assumes that the port numbers in the LSP are identical
- * to the GMAC numbers (port 0 = GMAC0, etc. )*/
-void tpm_init_hwf_set(void)
-{
-	int tx_num, q_num, dest_port, dest_port_txp, owner_rx_port;
-
-	for (tx_num = TPM_TX_MOD_GMAC0; tx_num < TPM_MAX_NUM_TX_PORTS; tx_num++) {
-		dest_port = tpm_tx_mod_hal_attrs[tx_num].hal_port;
-		dest_port_txp = tpm_tx_mod_hal_attrs[tx_num].hal_txp;
-		if (!tpm_init.gmac_tx[tx_num].valid)
-		continue;
-
-		for (q_num = 0; q_num < TPM_MAX_NUM_TX_QUEUE; q_num++) {
-			if (tpm_init.gmac_tx[tx_num].tx_queue[q_num].valid) {
-				/* No HW forwarding for CPU */
-				if (tpm_init.gmac_tx[tx_num].tx_queue[q_num].queue_owner != TPM_Q_OWNER_CPU) {
-					owner_rx_port =
-					    tpm_init.gmac_tx[tx_num].tx_queue[q_num].queue_owner - 1;
-					if (mv_eth_ctrl_txq_hwf_own(dest_port, dest_port_txp, q_num, owner_rx_port)){
-						TPM_OS_ERROR(TPM_INIT_MOD,
-						"mv_eth_ctrl_txq_hwf_own err GMAC = %d TCONT = %d Q = %d HWF: owner_rx %d\n",
-						     dest_port, dest_port_txp, q_num, owner_rx_port);
-					}
-
-					mvNetaHwfTxqEnable(owner_rx_port, dest_port, dest_port_txp, q_num, 1);
-
-					TPM_OS_DEBUG(TPM_INIT_MOD,
-						     "GMAC = %d TCONT = %d Q = %d HWF: owner_rx %d\n",
-						     dest_port, dest_port_txp, q_num, owner_rx_port);
-				}
-				else
-				{
-					if (mv_eth_ctrl_txq_cpu_own(dest_port, dest_port_txp, q_num, 1)){
-						TPM_OS_ERROR(TPM_INIT_MOD,
-						"mv_eth_ctrl_txq_cpu_own err GMAC = %d TCONT = %d Q = %d SWF: owner_rx -1\n",
-						     dest_port, dest_port_txp, q_num);
-					}
-				}
-			} else {
-				if (mv_eth_ctrl_txq_hwf_own(dest_port, dest_port_txp, q_num, -1)){
-						TPM_OS_DEBUG(TPM_INIT_MOD,
-						"mv_eth_ctrl_txq_hwf_own err GMAC = %d TCONT = %d Q = %d HWF: owner_rx -1\n",
-						     dest_port, dest_port_txp, q_num);
-				}
-				mvNetaHwfTxqEnable(0, dest_port, dest_port_txp, q_num, 0);
-				TPM_OS_DEBUG(TPM_INIT_MOD, "GMAC = %d TCONT = %d Q = %d CPU owner\n",
-					     dest_port, dest_port_txp, q_num);
-			}
-		}	/* All queues */
-	}			/* All TX ports */
-}
-
-/* Note : The function assumes that the port numbers in the LSP are
- * identical to the GMAC numbers (port 0 = GMAC0, etc. )*/
-void tpm_init_txq_size_set(void)
-{
-	int tx_num, q_num, dest_port, prev_dest_port = 0xFF, dest_port_txp, status;
-	uint32_t q_valid, q_size;
-
-	for (tx_num = TPM_TX_MOD_GMAC0; tx_num < TPM_MAX_NUM_TX_PORTS; tx_num++) {
-		dest_port = tpm_tx_mod_hal_attrs[tx_num].hal_port;
-		dest_port_txp = tpm_tx_mod_hal_attrs[tx_num].hal_txp;
-
-		if ((dest_port == 0 && tpm_init.gmac_port_conf[0].conn == TPM_GMAC_CON_DISC) ||
-		    (dest_port == 1 && tpm_init.gmac_port_conf[1].conn == TPM_GMAC_CON_DISC)) {
-			continue;
-		}
-
-		if (mv_eth_ctrl_port_started_get(dest_port)) {
-			if (prev_dest_port != dest_port)
-				TPM_OS_WARN(TPM_INIT_MOD,
-					    "port%d already started, tx_queue sizes will not be updated\n", dest_port);
-			prev_dest_port = dest_port;
-			continue;
-		}
-
-		for (q_num = 0; q_num < TPM_MAX_NUM_TX_QUEUE; q_num++) {
-
-			if (TPM_DB_OK != tpm_db_gmac_tx_q_conf_get(tx_num, q_num, &q_valid,
-								   NULL, NULL, NULL, &q_size, NULL)){
-				TPM_OS_WARN(TPM_INIT_MOD,
-					    "Could not get port(%d) tx_queue sizes\n", dest_port);
-				continue;
-			}
-
-			if (!q_valid)
-				q_size = 0;
-
-			status = mv_eth_ctrl_txq_size_set(dest_port, dest_port_txp, q_num, q_size);
-			if (status) {
-				TPM_OS_DEBUG(TPM_INIT_MOD, "mv_eth_ctrl_txq_size_set err, port = %d TCONT = %d Q = %d size = %d\n",
-					     dest_port, dest_port_txp, q_num, q_size);
-			}
-		}		/* All TX queues */
-	}			/* All TX ports */
-}
-
-/* Note : The function assumes that the port numbers in the LSP are
- * identical to the GMAC numbers (port 0 = GMAC0, etc. )*/
-void tpm_init_rxq_size_set(void)
-{
-	tpm_gmacs_enum_t gmac_num;
-	int q_num, status;
-	uint32_t q_valid, q_size, rc;
-
-	for (gmac_num = TPM_ENUM_GMAC_0; gmac_num < TPM_MAX_NUM_GMACS; gmac_num++) {
-		if (!tpm_db_gmac_rx_val_get(gmac_num))
-			continue;
-		/* treat only valid ports */
-		if (!INIT_GMAC_VALID(gmac_num))
-			continue;
-
-		if (mv_eth_ctrl_port_started_get(gmac_num)) {
-			TPM_OS_WARN(TPM_INIT_MOD, "port%d already started, rx_queue sizes will not be updated\n", gmac_num);
-			continue;
-		}
-		for (q_num = 0; q_num < TPM_MAX_NUM_RX_QUEUE; q_num++) {
-			rc = tpm_db_gmac_rx_q_conf_get(gmac_num, q_num, &q_valid, &q_size);
-
-			if (TPM_DB_OK != rc) {
-				TPM_OS_WARN(TPM_INIT_MOD, "tpm_db_gmac_rx_q_conf_get port%d error\n", gmac_num);
-				continue;
-			}
-			if (q_valid)
-				status = mv_eth_ctrl_rxq_size_set(gmac_num, q_num, q_size);
-			else
-				status = mv_eth_ctrl_rxq_size_set(gmac_num, q_num, 0);
-
-			if (status)
-				TPM_OS_DEBUG(TPM_INIT_MOD, "gmac_num = %d  Q = %d size = %d\n", gmac_num, q_num, q_size);
-		}		/* All RX queues */
-	}			/* All GMACs */
-}
-
-int32_t tpm_init_mh_select(tpm_init_mh_src_t ds_mh_set_conf)
-{
-	tpm_gmacs_enum_t gmac_i;
-	tpm_db_gmac_func_t gmac_func;
-
-	/* MH select config */
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-
-		if ((gmac_func == TPM_GMAC_FUNC_LAN_AND_WAN) || (gmac_func == TPM_GMAC_FUNC_WAN)) {
-			switch (ds_mh_set_conf) {
-			case TPM_MH_SRC_RX_CTRL:
-				mvNetaHwfMhSrcSet(gmac_i, MV_NETA_HWF_MH_REG);
-				mvNetaHwfMhSelSet(gmac_i, (uint8_t) NETA_MH_REPLACE_MH_REG(0));
-				/* Keep all TX_MH_registers(1-15) 'Zero' !! */
-				break;
-			case TPM_MH_SRC_PNC_RI:
-				mvNetaHwfMhSrcSet(gmac_i, MV_NETA_HWF_MH_PNC);
-				mvNetaHwfMhSelSet(gmac_i, (uint8_t) NETA_MH_DONT_CHANGE);
-				break;
-			default:
-				TPM_OS_ERROR(TPM_INIT_MOD, " Unknown d/s MH source (%d)\n", ds_mh_set_conf);
-				return (TPM_FAIL);
-			}
-		} else if ((gmac_func == TPM_GMAC_FUNC_LAN_AND_WAN) || (gmac_func == TPM_GMAC_FUNC_LAN) || (gmac_func == TPM_GMAC_FUNC_LAN_UNI)) {
-			mvNetaHwfMhSrcSet(gmac_i, MV_NETA_HWF_MH_REG);
-			mvNetaHwfMhSelSet(gmac_i, (uint8_t) NETA_MH_REPLACE_GPON_HDR);
-		}
-	}
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_tx_queue_sched(void)
-{
-
-	tpm_init_tx_mod_t tx_mod;
-	tpm_db_sched_t sched_method;
-	uint32_t queue_weight = 0;
-	int32_t ret_code = TPM_OK;
-	int i = 0, port = 0, sched_ent = 0;
-	uint32_t q_valid;
-
-	for (tx_mod = TPM_TX_MOD_GMAC0; tx_mod < TPM_MAX_NUM_TX_PORTS; (tx_mod)++) {
-
-		for (i = 0; i < TPM_MAX_NUM_TX_QUEUE; i++) {
-
-			ret_code = tpm_db_gmac_tx_q_conf_get(tx_mod, i, &q_valid, &sched_method,
-							     NULL, NULL, NULL, &queue_weight);
-			if (q_valid == TPM_FALSE)
-				continue;
-
-			if (tx_mod == TPM_TX_MOD_GMAC0) {
-				port = SW_GMAC_0;
-				sched_ent = 0;
-			} else if (tx_mod >= TPM_TX_MOD_PMAC_0) {
-				port = PON_PORT;
-				sched_ent = tx_mod - TPM_TX_MOD_PMAC_0;
-			} else {
-				ret_code = TPM_FAIL;
-				break;
-			}
-
-			switch (sched_method) {
-			case TPM_SCHED_SP:
-				mvNetaTxqFixPrioSet(port, sched_ent, i);
-				break;
-
-			case TPM_SCHED_WRR:
-				mvNetaTxqWrrPrioSet(port, sched_ent, i, queue_weight);
-				break;
-
-			default:
-				printk(KERN_ERR " Unknown scheduling method command \n");
-				return (TPM_NOT_FOUND);
-
-			}
-		}
-	}
-
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_init_gmac_PHY_poll()
-*
-* DESCRIPTION:      Initialize the GMAC PHY polling state accordint to it connect to PHY or not
-*
-* INPUTS:
-*	port -- GMAC port
-*	state -- true: enable PHY polling; false: disable PHY polling
-* OUTPUTS:None
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_gmac_PHY_poll(int port, bool state)
-{
-	unsigned int regData;
-
-	regData = MV_REG_READ(ETH_UNIT_CONTROL_REG(port));
-	if (state)
-		regData |= ETH_PHY_POLLING_ENABLE_MASK;
-	else
-		regData &= (~ETH_PHY_POLLING_ENABLE_MASK);
-
-	MV_REG_WRITE(ETH_UNIT_CONTROL_REG(port), regData);
-
-	return TPM_OK;
-}
-
-int32_t tpm_init_switch(void)
-{
-	uint32_t i;
-	uint32_t sw_port_bmp = 0;
-	unsigned char gq_da[6] = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x01 };
-	tpm_gmacs_enum_t gmac_i;
-	int32_t switch_port;
-
-	/* no need to initialize switch for these profiles */
-	switch (tpm_init.eth_cmplx_profile) {
-	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
-	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
-	case TPM_PON_WAN_G0_SINGLE_PORT:
-	case TPM_PON_WAN_G1_SINGLE_PORT:
-	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
-	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
-	case TPM_PON_WAN_G0_G1_LPBK:
-	case TPM_PON_WAN_G0_G1_DUAL_LAN:
-		return (TPM_OK);
-       default:
-	break;
-	}
-
-	mv_switch_drv_init();
-
-	/* Set 802.1q mode => fallback for all ports */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_FALSE == tpm_init.eth_port_conf[i].valid)
-			continue;
-
-		/* need only switch ports */
-		if (TPM_INTCON_SWITCH != tpm_init.eth_port_conf[i].int_connect)
-			continue;
-
-		if (mv_switch_set_vid_filter_per_port(tpm_init.eth_port_conf[i].switch_port, GT_FALSE))
-			TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_vid_filter_per_port err. sw port %d\n",
-					    tpm_init.eth_port_conf[i].switch_port);
-	}
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		switch_port = -1;
-
-		if (TPM_GMAC_CON_SWITCH_4 == tpm_init.gmac_port_conf[gmac_i].conn)
-			switch_port = TPM_GMAC0_AMBER_PORT_NUM;
-		else if (TPM_GMAC_CON_SWITCH_5 == tpm_init.gmac_port_conf[gmac_i].conn){
-			if (1 == tpm_init.virt_uni_info.enabled || tpm_init.mc_setting.per_uni_vlan_xlat == 1)
-				switch_port = tpm_init.virt_uni_info.switch_port;
-			else
-				switch_port = TPM_GMAC1_AMBER_PORT_NUM;
-		 }
-		 if (switch_port != -1) {
-		 if (mv_switch_set_vid_filter_per_port(switch_port, GT_FALSE))
-				 TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_vid_filter_per_port err. sw port %d\n",
-					    switch_port);
-		}
-	}
-
-	/* Enable BC floods */
-	mv_switch_set_broadcast_flood(GT_TRUE);
-
-	/* Disable unknown MC floods for all UNI ports */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_FALSE == tpm_init.eth_port_conf[i].valid)
-			continue;
-
-		/* need only switch ports */
-		if (TPM_INTCON_SWITCH != tpm_init.eth_port_conf[i].int_connect)
-			continue;
-
-		if (mv_switch_set_unknown_multicast_flood(tpm_init.eth_port_conf[i].switch_port, GT_FALSE))
-			TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_unknown_multicast_flood err. sw port %d\n",
-					    tpm_init.eth_port_conf[i].switch_port);
-	}
-
-	/*set default VLAN ID to 0 */
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_FALSE == tpm_init.eth_port_conf[i].valid)
-			continue;
-
-		/* need only switch ports */
-		if (TPM_INTCON_SWITCH != tpm_init.eth_port_conf[i].int_connect)
-			continue;
-
-		if (mv_switch_set_port_def_vlan(tpm_init.eth_port_conf[i].switch_port, 0))
-			TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_port_def_vlan err. sw port %d\n",
-					    tpm_init.eth_port_conf[i].switch_port);
-	}
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (TPM_FALSE == tpm_init.gmac_port_conf[gmac_i].valid)
-			continue;
-
-		switch_port = -1;
-
-		if (TPM_GMAC_CON_SWITCH_4 == tpm_init.gmac_port_conf[gmac_i].conn)
-			switch_port = TPM_GMAC0_AMBER_PORT_NUM;
-		else if (TPM_GMAC_CON_SWITCH_5 == tpm_init.gmac_port_conf[gmac_i].conn){
-			if (1 == tpm_init.virt_uni_info.enabled)
-				switch_port = tpm_init.virt_uni_info.switch_port;
-			else
-				switch_port = TPM_GMAC1_AMBER_PORT_NUM;
-		}
-
-		if (switch_port != -1) {
-			if (mv_switch_set_port_def_vlan(switch_port, 0))
-				TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_vid_filter_per_port err. sw port %d\n",
-					    switch_port);
-		}
-	}
-
-	switch_port = -1;
-
-	/* Add all ports to the member list of default VID(0) */
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (TPM_FALSE == tpm_init.gmac_port_conf[gmac_i].valid)
-			continue;
-
-		if (TPM_GMAC_CON_SWITCH_5 == tpm_init.gmac_port_conf[gmac_i].conn){
-			if (1 == tpm_init.virt_uni_info.enabled)
-				switch_port = tpm_init.virt_uni_info.switch_port;
-			else
-				switch_port = TPM_GMAC1_AMBER_PORT_NUM;
-
-		 if (mv_switch_port_add_vid(switch_port, 0, TPM_GMAC0_AMBER_PORT_NUM))
-				 TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_set_port_def_vlan err. sw port %d\n",
-					    switch_port);
-		}
-	}
-
-	if (switch_port != -1) {
-		for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-			if (TPM_FALSE == tpm_init.eth_port_conf[i].valid)
-				continue;
-
-			/* need only switch ports */
-			if (TPM_INTCON_SWITCH != tpm_init.eth_port_conf[i].int_connect)
-				continue;
-
-			if (switch_port != -1) {
-				if (mv_switch_port_add_vid(tpm_init.eth_port_conf[i].switch_port, 0, switch_port))
-					TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_port_add_vid err. sw port %d\n",
-						tpm_init.eth_port_conf[i].switch_port);
-			}
-		}
-	}
-
-
-	/* config amber port#5 - same as UNI ports */
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (TPM_FALSE == tpm_init.gmac_port_conf[gmac_i].valid)
-			continue;
-
-		if (TPM_GMAC_CON_SWITCH_4 == tpm_init.gmac_port_conf[gmac_i].conn)
-			sw_port_bmp |= 1 << TPM_GMAC0_AMBER_PORT_NUM;
-		else if (TPM_GMAC_CON_SWITCH_5 == tpm_init.gmac_port_conf[gmac_i].conn)
-			sw_port_bmp |= 1 << TPM_GMAC1_AMBER_PORT_NUM;
-	}
-
-
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (TPM_FALSE == tpm_init.eth_port_conf[i].valid)
-			continue;
-
-		/* need only switch ports */
-		if (TPM_INTCON_SWITCH != tpm_init.eth_port_conf[i].int_connect)
-			continue;
-
-		sw_port_bmp |= 1 << tpm_init.eth_port_conf[i].switch_port;
-	}
-	if (mv_switch_mac_addr_set(gq_da, 0, sw_port_bmp, 1))
-		TPM_OS_WARN(TPM_INIT_MOD, "mv_switch_mac_addr_set err. sw_port_bmp 0X%x\n", sw_port_bmp);
-
-	/* If Switch port MAC no connected to PHY, disable GMAC PHY polling */
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (TPM_FALSE == tpm_init.gmac_port_conf[gmac_i].valid)
-			continue;
-
-		if (TPM_GMAC_CON_SWITCH_4 == tpm_init.gmac_port_conf[gmac_i].conn ||
-		    TPM_GMAC_CON_SWITCH_5 == tpm_init.gmac_port_conf[gmac_i].conn)
-			tpm_init_gmac_PHY_poll(gmac_i, false);
-	}
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_mh_conf_set(uint32_t gmac0_mh_en, uint32_t gmac1_mh_en, tpm_init_gmac_conn_conf_t *gmac_port_conf)
-{
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t amber_port_num, mh_en;
-	/*uint16_t amber_port_cfg_reg; */
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		/* if port in GateWay mode, do not set MH */
-		if (tpm_init_gmac_in_gateway_mode(gmac_i))
-			continue;
-
-		amber_port_num = -1;
-
-		switch (gmac_i) {
-		case TPM_ENUM_GMAC_0:
-			mh_en = gmac0_mh_en;
-			if (TPM_GMAC_CON_SWITCH_4 == gmac_port_conf[gmac_i].conn)
-				amber_port_num = TPM_GMAC0_AMBER_PORT_NUM;
-			break;
-		case TPM_ENUM_GMAC_1:
-			mh_en = gmac1_mh_en;
-			if (TPM_GMAC_CON_SWITCH_5 == gmac_port_conf[gmac_i].conn)
-				amber_port_num = TPM_GMAC1_AMBER_PORT_NUM;
-			break;
-		case TPM_ENUM_PMAC:
-			mh_en = 1;
-			/*no amber port */
-			break;
-		default:
-			TPM_OS_ERROR(TPM_INIT_MOD, " Unknown GMAC (%d)\n", gmac_i);
-			return (TPM_FAIL);
-		}
-
-		/* Configure PP */
-		TPM_OS_DEBUG(TPM_INIT_MOD, "GMAC(%d) mh_en(%d)\n", gmac_i, mh_en);
-		printk("GMAC(%d) mh_en(%d) amber_port_num(%d)\n", gmac_i, mh_en,amber_port_num);
-		if (mh_en == TPM_TRUE)
-		{
-			if (mv_eth_ctrl_flag(gmac_i, MV_ETH_F_MH, 1)){
-				TPM_OS_ERROR(TPM_INIT_MOD, " mv_eth_ctrl_flag err port %d flag %X VAL %X\n",
-					gmac_i, MV_ETH_F_MH, 1);
-				return (TPM_FAIL);
-			}
-		}
-		else
-			if (mv_eth_ctrl_flag(gmac_i, MV_ETH_F_MH, 0)){
-				TPM_OS_ERROR(TPM_INIT_MOD, " mv_eth_ctrl_flag err port %d flag %X VAL %X\n",
-					gmac_i, MV_ETH_F_MH, 0);
-				return (TPM_FAIL);
-		}
-		/* Configure Amber */
-		if (amber_port_num != -1)
-			mv_switch_set_marvell_header_mode(amber_port_num, mh_en);
-	}
-	return (TPM_OK);
-}
-
-int32_t tpm_init_mh_reg_set(tpm_init_mh_src_t ds_mh_set_conf)
-{
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t pp_port_num;
-	uint32_t num_txp = 0, txp_i = 0, tx_reg_i = 0;
-	tpm_db_gmac_func_t gmac_func;
-	uint32_t gmac_mh_en;
-	uint16_t regVal;
-	uint16_t amber_port_vector;
-	uint32_t pnc_vector, uni_vector;
-
-	/* MH Select Tx registers config */
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		if (tpm_db_gmac_func_get(gmac_i, &gmac_func) != TPM_OK) {
-			TPM_OS_ERROR(TPM_INIT_MOD, " tpm_db_gmac_func_get err port %d\n", gmac_i);
-			return (TPM_FAIL);
-		}
-		if (tpm_db_gmac_mh_en_conf_get(gmac_i, &gmac_mh_en) != TPM_OK) {
-			TPM_OS_ERROR(TPM_INIT_MOD, " tpm_db_gmac_mh_en_conf_get err port %d\n", gmac_i);
-			return (TPM_FAIL);
-		}
-		pp_port_num = TPM_GMAC_TO_PP_PORT(gmac_i);
-
-		if (((gmac_func == TPM_GMAC_FUNC_LAN_AND_WAN) || (gmac_func == TPM_GMAC_FUNC_LAN) || (gmac_func == TPM_GMAC_FUNC_LAN_UNI)) &&
-		    gmac_mh_en && (tpm_init.ds_mh_set_conf == TPM_MH_SRC_PNC_RI)) {
-			/* Set MH Tx registers to full table */
-			for (tx_reg_i = 0; tx_reg_i < TPM_TX_MAX_MH_REGS; tx_reg_i++) {
-				regVal = 0;	/* Marvell Header (FID, LearnDisable) fields are both zero */
-				if (tpm_db_port_vector_tbl_info_get(tx_reg_i, &uni_vector,
-								     &amber_port_vector, &pnc_vector) != TPM_OK) {
-						TPM_OS_ERROR(TPM_INIT_MOD, "tpm_db_port_vector_tbl_info_get err tx_reg %d\n",
-								tx_reg_i);
-						return (TPM_FAIL);
-				}
-				regVal = amber_port_vector;
-				if (mvNetaTxMhRegSet(pp_port_num, 0 /*txp */ , tx_reg_i, regVal)) {
-					TPM_OS_ERROR(TPM_INIT_MOD,
-						     "mvNetaTxMhRegSet err pp_port_num %d tx_reg %d regVal 0x%x\n",
-						     pp_port_num, tx_reg_i, regVal);
-					return (TPM_FAIL);
-				}
-			}
-		} else {
-			/* Get GMAC number of tx_modules & default register value */
-			if (gmac_i != TPM_ENUM_PMAC) {
-				num_txp = 1;
-				/* Marvell Header -  FID/LearnDisable fields are zero */
-				/*                   VLANTable field is  (re)set to 'all_other_switch_ports' */
-
-				if (gmac_i == TPM_ENUM_GMAC_0)
-					regVal = 0x7f & (~(1 << TPM_GMAC0_AMBER_PORT_NUM));
-				else
-					regVal = 0x7f & (~(1 << TPM_GMAC1_AMBER_PORT_NUM));
-			} else {
-				if (tpm_db_num_tcont_llid_get(&num_txp) != TPM_OK) {
-					TPM_OS_ERROR(TPM_INIT_MOD,
-						     "tpm_db_num_tcont_llid_get err\n");
-					return (TPM_FAIL);
-				}
-				regVal = 0;
-			}
-
-			/* Set MH_tx registers for all tx_modules */
-			for (txp_i = 0; txp_i < num_txp; txp_i++) {
-				for (tx_reg_i = 0; tx_reg_i < TPM_TX_MAX_MH_REGS; tx_reg_i++)
-					if (mvNetaTxMhRegSet(pp_port_num, txp_i, tx_reg_i, regVal)) {
-						TPM_OS_ERROR(TPM_INIT_MOD,
-						     "mvNetaTxMhRegSet err pp_port_num %d txp %d tx_reg 0x%x, regVal 0x%X\n",
-						     pp_port_num, txp_i, tx_reg_i, regVal);
-						return (TPM_FAIL);
-					 }
-			}
-
-		}
-	}
-
-	return (TPM_OK);
-}
-int32_t tpm_init_get_gmac_queue_rate_limit(void)
-{
-	tpm_db_tx_mod_t tx_mod_i;
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t txp_i = 0, prio = 0;
-	uint32_t size = 0, queue = 0, rate = 0, wrr = 0;
-
-	for (tx_mod_i = 0; tx_mod_i < TPM_MAX_NUM_TX_PORTS; tx_mod_i++) {
-		if (TPM_FALSE == tpm_db_gmac_tx_val_get(tx_mod_i)) {
-			TPM_OS_INFO(TPM_INIT_MOD, "tx_mod_i (%d) is invalid\n", tx_mod_i);
-			continue;
-		}
-
-		if (tx_mod_i < TPM_TX_MOD_PMAC_0) {
-			gmac_i = tx_mod_i;
-		} else {
-			gmac_i = TPM_ENUM_PMAC;
-			txp_i = tx_mod_i - TPM_TX_MOD_PMAC_0;
-		}
-
-		/* get Tx queue bucket size */
-		for (queue = 0; queue < TPM_MAX_NUM_TX_QUEUE; queue++) {
-#ifdef MV_ETH_WRR_NEW
-			size = MV_REG_READ(NETA_TXQ_TOKEN_SIZE_REG(gmac_i, txp_i, queue));
-			rate = MV_REG_READ(NETA_TXQ_REFILL_REG(gmac_i, txp_i, queue));
-			wrr = MV_REG_READ(NETA_TXQ_WRR_ARBITER_REG(gmac_i, txp_i, queue));
-#else /* Old WRR/EJP module */
-			/* token size and rate are in the same reg */
-			rate = MV_REG_READ(ETH_TXQ_TOKEN_CFG_REG(gmac_i, txp_i, queue));
-#endif /* MV_ETH_WRR_NEW */
-			TPM_OS_INFO(TPM_INIT_MOD, "gmac_i (%d), txp_i (%d), queue (%d), size (%d), rate (%d)\n",
-				gmac_i, txp_i, queue, size, rate);
-			tpm_db_set_gmac_q_rate_limit(tx_mod_i, queue, size, rate, wrr);
-		}
-
-		/* get TX bucket and rate */
-#ifdef MV_ETH_WRR_NEW
-		size = MV_REG_READ(NETA_TXP_TOKEN_SIZE_REG(gmac_i, txp_i));
-		rate = MV_REG_READ(NETA_TXP_REFILL_REG(gmac_i, txp_i));
-		prio = MV_REG_READ(NETA_TX_FIXED_PRIO_CFG_REG(gmac_i, txp_i));
-#else /* Old WRR/EJP module */
-		rate = MV_REG_READ(ETH_TXP_TOKEN_RATE_CFG_REG(gmac_i, txp_i));
-		size = MV_REG_READ(ETH_TXP_TOKEN_SIZE_REG(gmac_i, txp_i));
-#endif /* MV_ETH_WRR_NEW */
-		TPM_OS_INFO(TPM_INIT_MOD, "gmac_i (%d), txp_i (%d), queue (%d), size (%d), rate (%d)\n",
-			gmac_i, txp_i, queue, size, rate);
-		tpm_db_set_gmac_rate_limit(tx_mod_i, size, rate, prio);
-	}
-	return (TPM_OK);
-}
-int32_t tpm_init_set_gmac_queue_rate_limit(void)
-{
-	tpm_db_tx_mod_t tx_mod_i;
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t txp_i = 0;
-	uint32_t size = 0, queue = 0, rate = 0;
-	uint32_t wrr = 0, prio = 0, regVal = 0;
-
-	/* keep the compiler quiet */
-	regVal = 0;
-
-	for (tx_mod_i = 0; tx_mod_i < TPM_MAX_NUM_TX_PORTS; tx_mod_i++) {
-		if (TPM_FALSE == tpm_db_gmac_tx_val_get(tx_mod_i))
-			continue;
-
-		if (tx_mod_i < TPM_TX_MOD_PMAC_0) {
-			gmac_i = tx_mod_i;
-		} else {
-			gmac_i = TPM_ENUM_PMAC;
-			txp_i = tx_mod_i - TPM_TX_MOD_PMAC_0;
-		}
-
-		/* set Tx queue bucket size */
-		for (queue = 0; queue < TPM_MAX_NUM_TX_QUEUE; queue++) {
-			tpm_db_get_gmac_q_rate_limit(tx_mod_i, queue, &size, &rate, &wrr);
-			TPM_OS_INFO(TPM_INIT_MOD, "gmac_i (%d), txp_i (%d), queue (%d), size (%d), rate (%d)\n",
-				gmac_i, txp_i, queue, size, rate);
-#ifdef MV_ETH_WRR_NEW
-			MV_REG_WRITE(NETA_TXQ_REFILL_REG(gmac_i, txp_i, queue), rate);
-			MV_REG_WRITE(NETA_TXQ_TOKEN_SIZE_REG(gmac_i, txp_i, queue), size);
-			MV_REG_WRITE(NETA_TXQ_WRR_ARBITER_REG(gmac_i, txp_i, queue), wrr);
-#else /* Old WRR/EJP module */
-			MV_REG_WRITE(ETH_TXQ_TOKEN_CFG_REG(gmac_i, txp_i, queue), rate);
-#endif /* MV_ETH_WRR_NEW */
-		}
-
-		tpm_db_get_gmac_rate_limit(tx_mod_i, &size, &rate, &prio);
-		TPM_OS_INFO(TPM_INIT_MOD, "gmac_i (%d), txp_i (%d), size (%d), rate (%d)\n",
-			gmac_i, txp_i, size, rate);
-		/* set TX bucket and rate */
-#ifdef MV_ETH_WRR_NEW
-		MV_REG_WRITE(NETA_TXP_TOKEN_SIZE_REG(gmac_i, txp_i), size);
-		MV_REG_WRITE(NETA_TXP_REFILL_REG(gmac_i, txp_i), rate);
-		MV_REG_WRITE(NETA_TX_FIXED_PRIO_CFG_REG(gmac_i, txp_i), prio);
-#else /* Old WRR/EJP module */
-		regVal = MV_REG_READ(ETH_TXP_TOKEN_RATE_CFG_REG(gmac_i, txp_i));
-		regVal &= ~ETH_TXP_TOKEN_RATE_ALL_MASK;
-		regVal |= ETH_TXP_TOKEN_RATE_MASK(rate);
-		MV_REG_WRITE(ETH_TXP_TOKEN_RATE_CFG_REG(gmac_i, txp_i), regVal);
-		regVal = MV_REG_READ(ETH_TXP_TOKEN_SIZE_REG(gmac_i, txp_i));
-		regVal &= ~ETH_TXP_TOKEN_SIZE_ALL_MASK;
-		regVal |= ETH_TXP_TOKEN_SIZE_MASK(size);
-		MV_REG_WRITE(ETH_TXP_TOKEN_SIZE_REG(gmac_i, txp_i), regVal);
-#endif /* MV_ETH_WRR_NEW */
-	}
-	return (TPM_OK);
-}
-int32_t tpm_init_reset_gmac_queue_rate_limit(void)
-{
-	static uint32_t first_time = 0;
-	int32_t tpm_ret = 0;
-
-	if (first_time == 0) {
-		/* tpm module start up, do not reset gmac q */
-		TPM_OS_INFO(TPM_INIT_MOD, "tpm module start up, get gmac queue rate limit\n");
-		first_time = 1;
-
-		/* get queue rate limit */
-		tpm_ret = tpm_init_get_gmac_queue_rate_limit();
-		IF_ERROR(tpm_ret);
-
-		return (TPM_OK);
-	}
-
-	TPM_OS_INFO(TPM_INIT_MOD, "tpm mib-reset, reset gmac queue rage limit\n");
-
-	/* set queue rate limit */
-	tpm_ret = tpm_init_set_gmac_queue_rate_limit();
-	IF_ERROR(tpm_ret);
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_mh(tpm_init_mh_src_t ds_mh_set_conf,
-			uint32_t gmac0_mh_en,
-			uint32_t gmac1_mh_en,
-			tpm_init_gmac_conn_conf_t *gmac_port_conf)
-{
-	if (tpm_init_mh_select(ds_mh_set_conf) != TPM_OK) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "tpm_init_mh_select err\n");
-		return (TPM_FAIL);
-	}
-	if (tpm_init_mh_conf_set(gmac0_mh_en, gmac1_mh_en, gmac_port_conf) != TPM_OK) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "tpm_init_mh_conf_set err\n");
-		return (TPM_FAIL);
-	}
-	if (tpm_init_mh_reg_set(ds_mh_set_conf) != TPM_OK) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "tpm_init_mh_reg_set err\n");
-		return (TPM_FAIL);
-	}
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_bm_pool(void)
-{
-	int status;
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t val, large_buf, small_buf;
-
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_bm_bufs_conf_get(gmac_i, &val, &large_buf, &small_buf);
-		if (val) {
-			if ((gmac_i == 0 && tpm_init.gmac_port_conf[0].conn == TPM_GMAC_CON_DISC) ||
-			    (gmac_i == 1 && tpm_init.gmac_port_conf[1].conn == TPM_GMAC_CON_DISC))
-				continue;
-
-			if (mv_eth_ctrl_port_started_get(gmac_i)) {
-				TPM_OS_WARN(TPM_INIT_MOD, "port%d already started, port bm_pools will not be updated\n",
-					    gmac_i);
-				continue;
-			}
-
-#ifdef CONFIG_MV_ETH_BM_CPU
-			status = mv_eth_ctrl_port_buf_num_set(TPM_GMAC_TO_PP_PORT(gmac_i), large_buf, small_buf);
-#else
-			status = mv_eth_bm_config_buf_num_set(TPM_GMAC_TO_PP_PORT(gmac_i), large_buf, small_buf);
-#endif
-			if (status) {
-				TPM_OS_ERROR(TPM_INIT_MOD, "BM Pool error gmac(%d) large_buf(%d), small_buf(%d)\n",
-					     gmac_i, large_buf, small_buf);
-				return (TPM_FAIL);
-			}
-		}
-	}
-	return (TPM_OK);
-}
-
-int32_t tpm_init_ipg(int32_t mod_value)
-{
-	int status;
-	tpm_gmacs_enum_t gmac_i;
-	uint16_t ipg_val, preamble;
-	uint8_t port;
-	tpm_db_gmac_func_t gmac_func;
-	tpm_db_gmac_conn_t gmac_con;
-	MV_BOOL link_is_up;
-	tpm_db_error_t db_ret_code;
-	uint32_t gmac0_mh_en = 0;
-	uint32_t gmac1_mh_en = 0;
-
-	db_ret_code = tpm_db_gmac_mh_en_conf_get(TPM_ENUM_GMAC_0, &gmac0_mh_en);
-	IF_ERROR(db_ret_code);
-	db_ret_code = tpm_db_gmac_mh_en_conf_get(TPM_ENUM_GMAC_1, &gmac1_mh_en);
-	IF_ERROR(db_ret_code);
-
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_conn_get(gmac_i, &gmac_con);
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-
-		if (gmac_func != TPM_GMAC_FUNC_NONE) {
-
-			if ((gmac_i == 0 && gmac0_mh_en != TPM_FALSE && gmac_con == TPM_GMAC_CON_SWITCH_4) ||
-			    (gmac_i == 1 && gmac1_mh_en != TPM_FALSE && (gmac_con == TPM_GMAC_CON_SWITCH_5 ||
-			     tpm_init.eth_cmplx_profile == TPM_PON_WAN_G0_G1_LPBK))) {
-				mvNetaPortDisable(gmac_i);
-				mvNetaHwfEnable(gmac_i, 0);
-				ipg_val = mvNetaPortIpgGet(gmac_i);
-				ipg_val += mod_value;
-				mvNetaPortIpgSet(gmac_i, ipg_val);
-				mvNetaHwfEnable(gmac_i, 1);
-				status = mvNetaPortEnable(gmac_i);
-				if (status != MV_OK) {
-					link_is_up = mvNetaLinkIsUp(gmac_i);
-
-					if (link_is_up)
-						mvNetaPortUp(gmac_i);
-				}
-
-				if ((gmac_con == TPM_GMAC_CON_SWITCH_4) || (gmac_con == TPM_GMAC_CON_SWITCH_5)) {
-					if (gmac_i == 0)
-						port = TPM_GMAC0_AMBER_PORT_NUM;
-					else
-						port = TPM_GMAC1_AMBER_PORT_NUM;
-
-					/* TODO: Need to check if switch is attached to GMAC */
-					status = mv_switch_get_port_preamble(port, &preamble);
-					if (status) {
-						TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get port(%d) preamble_len\n", port);
-						return (TPM_FAIL);
-					}
-					preamble += mod_value;
-					status = mv_switch_set_port_preamble(port, preamble);
-					if (status) {
-						TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set port(%d) preamble_len(%d)\n"
-							     , port, preamble);
-						return (TPM_FAIL);
-					}
-				}
-			}
-		}
-	}
-
-	return (TPM_OK);
-}
-
-int32_t tpm_init_ethertype_dsa_tag(void)
-{
-	uint16_t  reg_tmp = 0;
-	uint8_t   ret;
-	int       cpu_port = 4;
-	int       frame_mode_reg = 4;
-	int       portetype_reg = 0xf;
-	int       switch_dev_num_reg = 0x1c;
-	int       rsvd2cpu2x_reg = 2;
-	int       rsvd2cpu0x_reg = 3;
-	tpm_db_ety_dsa_enable_t ety_dsa_enable;
-
-	tpm_db_get_ety_dsa_enable(&ety_dsa_enable);
-
-	if (TPM_ETY_DSA_DISABLE == ety_dsa_enable)
-		return TPM_OK;
-
-	/*
-	For switch port 4: change the Frame Mode (Port reg offset 0x04) to Ethertype_DSA.
-	For switch port 4: set Port EType register (Port reg offset 0x0F) to 0xDABC.
-	Set zero to MGMT Enables 0x register (Global 2 offset 0x03) and MGMT Enables 2x register (Global 2 offset 0x02).
-	*/
-
-	/* get Frame Mode reg from HW */
-	ret = mv_switch_reg_read(cpu_port, frame_mode_reg, MV_SWITCH_PORT_ACCESS, &reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get cpu port frame mode reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-
-	/* set bits 8, 9 to 11, as Ethertype_DSA */
-	reg_tmp |= (3 << 8);
-	ret = mv_switch_reg_write(cpu_port, frame_mode_reg, MV_SWITCH_PORT_ACCESS, reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set cpu port frame mode reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-
-	/* set PortEType reg to HW */
-	reg_tmp = TPM_ETHERTYPE_DSA_TAG;
-	ret = mv_switch_reg_write(cpu_port, portetype_reg, MV_SWITCH_PORT_ACCESS, reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set cpu port PortEType reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-
-	/* get switch_dev_num value reg from HW */
-	ret = mv_switch_reg_read(0, switch_dev_num_reg, MV_SWITCH_GLOBAL_ACCESS, &reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get switch_dev_num reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-	tpm_db_set_switch_dev_num((reg_tmp & 0x1f));
-
-	/* set PortEType reg to HW */
-	reg_tmp = 0;
-	ret = mv_switch_reg_write(0, rsvd2cpu2x_reg, MV_SWITCH_GLOBAL2_ACCESS, reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set zero to rsvd2cpu2x reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-	ret = mv_switch_reg_write(0, rsvd2cpu0x_reg, MV_SWITCH_GLOBAL2_ACCESS, reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set zero to rsvd2cpu0x reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_init_gmac_loopback()
-*
-* DESCRIPTION:      Initialize the GMAC to loopback mode if necessary, and force
-*		gmac linkup to 1G
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_gmac_loopback(tpm_gmacs_enum_t port, uint8_t enable)
-{
-	uint32_t regVal;
-
-	if (port > TPM_MAX_GMAC) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "GMAC port(%d) is invalid\n", port);
-		return TPM_FAIL;
-	}
-
-	/* Check Port Available or not */
-	if (!tpm_init_check_gmac_init(port)) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "GMAC port(%d) is not available\n", port);
-		return TPM_FAIL;
-	}
-
-	if (mvNetaPortDisable(port)) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to disable GMAC port(%d)\n", port);
-		return (TPM_FAIL);
-	}
-	if (mvNetaHwfEnable(port, 0)) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to disable GMAC port(%d) HWF\n", port);
-		return (TPM_FAIL);
-	}
-
-	if (mvNetaForceLinkModeSet(port, 1, 0)) {/*for link up*/
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set GMAC port(%d) force link\n", port);
-		return (TPM_FAIL);
-	}
-	if (mvNetaSpeedDuplexSet(port, MV_ETH_SPEED_1000, MV_ETH_DUPLEX_FULL)) {/*set 1G*/
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set GMAC port(%d) speed and duplex\n", port);
-		return (TPM_FAIL);
-	}
-
-	if (mvNetaHwfEnable(port, 1)) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to enable GMAC port(%d) HWF\n", port);
-		return (TPM_FAIL);
-	}
-	if (mvNetaPortEnable(port)) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to enable GMAC port(%d)\n", port);
-		return (TPM_FAIL);
-	}
-
-	/* set GMAC_CTRL_2_REG */
-	regVal = MV_REG_READ(NETA_GMAC_CTRL_2_REG(port));
-	regVal &= ~NETA_GMAC_PSC_ENABLE_MASK;
-	MV_REG_WRITE(NETA_GMAC_CTRL_2_REG(port), regVal);
-
-	if (enable)
-		MV_REG_WRITE(NETA_GMAC_CTRL_1_REG(port), 0x31); /* set gmac to loopback mode */
-	else
-		MV_REG_WRITE(NETA_GMAC_CTRL_1_REG(port), 0x11); /* set gmac to no-loopback mode */
-
-	regVal = MV_REG_READ(NETA_GMAC_AN_CTRL_REG(port));
-	regVal |=  NETA_FORCE_LINK_FAIL_MASK;  			/* enable Force Link Pass 	*/
-	regVal |=  NETA_SET_GMII_SPEED_1000_MASK;  		/* set GMII Speed 1000		*/
-	regVal &= ~NETA_ENABLE_SPEED_AUTO_NEG_MASK;  		/* disable AutoNeg speed 	*/
-	regVal |=  NETA_SET_FLOW_CONTROL_MASK;  		/* enable AutoNeg FC		*/
-	regVal |=  NETA_FLOW_CONTROL_ADVERTISE_MASK;  		/* enable advertise FC		*/
-	regVal &= ~NETA_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;  	/* disable AutoNeg FC		*/
-	regVal |=  NETA_SET_FULL_DUPLEX_MASK;			/* enable full duplex mode	*/
-	regVal &= ~NETA_ENABLE_DUPLEX_AUTO_NEG_MASK;		/* disable duplex AutoNeg 	*/
-	MV_REG_WRITE(NETA_GMAC_AN_CTRL_REG(port), regVal);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_init_system_mib_reset()
-*
-* DESCRIPTION:      Initialize the dynamic parts of the system hardware
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_system_mib_reset(tpm_reset_level_enum_t reset_type)
-{
-	tpm_pnc_ranges_t cur_range = TPM_INVALID_RANGE, next_range = 0;
-	tpm_db_pnc_range_t next_range_data;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_db_pnc_range_conf_t range_conf_tcp_flag;
-	uint32_t switch_init;
-	int32_t ret_code, ret_code_tcp_flag;
-	tpm_db_ttl_illegal_action_t ttl_illegal_action;
-	tpm_db_tcp_flag_check_t tcp_flag_check;
-	tpm_gmacs_enum_t gmac_i;
-	tpm_db_gmac_func_t gfunc;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-	uint32_t snoop_enable;
-
-	TPM_OS_DEBUG(TPM_INIT_MOD, "\n");
-
-	ret_code = tpm_db_mod2_setup();
-	IF_ERROR(ret_code);
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gfunc);
-		if (gfunc != TPM_GMAC_FUNC_NONE) {
-			ret_code = tpm_mod2_mac_inv(gmac_i);
-			IF_ERROR(ret_code);
-		}
-
-		ret_code = tpm_mod2_split_mod_init(gmac_i);
-		IF_ERROR(ret_code);
-	}
-
-	/* Init Amber Switch */
-	tpm_db_switch_init_get(&switch_init);
-	if (switch_init)
-		tpm_init_switch();
-	else {
-		if (tpm_db_gmac1_lpbk_en_get()) {
-			/* Init GMAC1 in loopback mod if GMAC loopback is enabled */
-			ret_code = tpm_init_gmac_loopback(TPM_ENUM_GMAC_1, 1);
-			IF_ERROR(ret_code);
-		}
-	}
-	/*Init TX scheduling */
-	ret_code = tpm_init_tx_queue_sched();
-	IF_ERROR(ret_code);
-
-	/* Init Tx queue rate limit */
-	ret_code = tpm_init_reset_gmac_queue_rate_limit();
-	IF_ERROR(ret_code);
-
-	/* Initialize (wipe out) the PNC ranges in PnC HW */
-	tpm_db_pnc_rng_val_get_next(cur_range, &next_range, &next_range_data);
-	TPM_OS_DEBUG(TPM_INIT_MOD, "next_range(%d)\n", next_range);
-	while (next_range != TPM_INVALID_RANGE) {
-		if (reset_type >= next_range_data.pnc_range_conf.min_reset_level) {
-			ret_code = tpm_pncl_range_reset(next_range);
-			IF_ERROR(ret_code);
-		}
-		cur_range = next_range;
-		tpm_db_pnc_rng_val_get_next(cur_range, &next_range, &next_range_data);
-		TPM_OS_DEBUG(TPM_INIT_MOD, "next_range(%d)\n", next_range);
-	}
-	/* Initialize the PNC Hardcoded Ranges */
-	/* @Wilson
-	   New bi-direction range: NUM_VLAN_TAGS three hardcoded rules
-	*/
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_NUM_VLAN_TAGS, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		ret_code = tpm_proc_l2_num_vlan_tags_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_NUM_VLAN_TAGS);
-
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_DS_LOAD_BALANCE, &range_conf);
-	if (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable) {
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_INIT_MOD, "PNC range TPM_PNC_DS_LOAD_BALANCE is not created "
-				"when ds_mac_based_trunk is enabled\n");
-			return ERR_GENERAL;
-		} else if (range_conf.range_size < 3) {
-			TPM_OS_ERROR(TPM_INIT_MOD, "PNC range TPM_PNC_DS_LOAD_BALANCE size should be at least "
-				"3 when ds_mac_based_trunk is enabled\n");
-			return ERR_GENERAL;
-		}
-	} else {
-		if ((ret_code == TPM_DB_OK) && (range_conf.range_size != 0)) {
-			TPM_OS_WARN(TPM_INIT_MOD, "do not perform ds_mac_based_trunk, "
-				"no need to create TPM_PNC_DS_LOAD_BALANCE range\n");
-		}
-	}
-
-	tpm_db_get_ttl_illegal_action(&ttl_illegal_action);
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_TTL, &range_conf);
-	if (TPM_TTL_ZERO_ACTION_NOTHING == ttl_illegal_action) {
-		if (ret_code == TPM_DB_OK) {
-			/* do not check ttl, no need to create ttl range */
-			TPM_OS_WARN(TPM_INIT_MOD, "do not check ttl, no need to create ttl range\n");
-		}
-	} else {
-		if ((ret_code != TPM_DB_OK) || (range_conf.range_size < 4)) {
-			/* check ttl, need to create ttl range */
-			TPM_OS_WARN(TPM_INIT_MOD, "check ttl, need to create ttl range with size of 4\n");
-		} else {
-			ret_code = tpm_proc_ipv4_ttl_init(ttl_illegal_action);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_L4_MC_DS, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		if (range_conf.range_size > 1)
-			/* SIZE too big, it is a waste */
-			TPM_OS_WARN(TPM_INIT_MOD, "TPM_PNC_IPV6_L4_MC_DS SIZE should be 1, too big now, it is a waste\n");
-		ret_code = tpm_proc_ipv6_l4_mc_ds_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_IPV6_L4_MC_DS);
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_MC_SIP, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		if (range_conf.range_size > 8)
-			/* SIZE too big, it is a waste */
-			TPM_OS_WARN(TPM_INIT_MOD, "TPM_PNC_IPV6_MC_SIP SIZE should be 8, too big now, it is a waste\n");
-		if (range_conf.range_size < 8)
-			/* SIZE too small, it might not be enough */
-			TPM_OS_WARN(TPM_INIT_MOD, "TPM_PNC_IPV6_MC_SIP SIZE should be 8, a little bit smaller now\n");
-		ret_code = tpm_proc_ipv6_mc_sip_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_IPV6_L4_MC_DS);
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_HOPL, &range_conf);
-	if (TPM_TTL_ZERO_ACTION_NOTHING == ttl_illegal_action) {
-		if (ret_code == TPM_DB_OK) {
-			/* do not check ttl, no need to create hoplimit range */
-			TPM_OS_WARN(TPM_INIT_MOD, "do not check hoplimit, no need to create hoplimit range\n");
-		}
-	} else {
-		if ((ret_code != TPM_DB_OK) || (range_conf.range_size < 3)) {
-			/* check hoplimit, need to create hoplimit range */
-			TPM_OS_WARN(TPM_INIT_MOD, "check hoplimit, need to create hoplimit range with size of 3\n");
-		} else {
-			ret_code = tpm_proc_ipv6_hoplimit_init(ttl_illegal_action);
-			IF_ERROR(ret_code);
-		}
-	}
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IGMP, &range_conf);
-	tpm_db_igmp_get_snoop_enable(&snoop_enable);
-	if (TPM_TRUE == snoop_enable) {
-		if (ret_code == TPM_DB_OK) {
-			ret_code = tpm_proc_ipv4_igmp_init();
-			IF_ERROR(ret_code);
-		} else {
-			TPM_OS_ERROR(TPM_INIT_MOD, "PNC range(TPM_PNC_IGMP) not initialized with IGMP snoop enabled\n");
-			return ERR_GENERAL;
-		}
-	} else if (ret_code == TPM_DB_OK) {
-		if (range_conf.range_size != 0) {
-			/* igmp snoop is disabled, no need to create TPM_PNC_IGMP range */
-			TPM_OS_WARN(TPM_INIT_MOD, "igmp snoop is disabled, no need to create TPM_PNC_IGMP range\n");
-		}
-	}
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_PROTO, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		ret_code = tpm_proc_ipv4_proto_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_IPV4_PROTO);
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_FRAG, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		ret_code = tpm_proc_ipv4_frag_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_IPV4_FRAG);
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CATCH_ALL, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		ret_code = tpm_proc_catch_all_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_CATCH_ALL);
-
-	tpm_db_get_tcp_flag_check(&tcp_flag_check);
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_TCP_FLAG, &range_conf);
-	ret_code_tcp_flag = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_TCP_FLAG, &range_conf_tcp_flag);
-	if (TPM_TCP_FLAG_NOT_CHECK == tcp_flag_check) {
-		if (ret_code == TPM_DB_OK || ret_code_tcp_flag == TPM_DB_OK) {
-			/* do not check tcp flag, no need to create tcp flag range */
-			TPM_OS_WARN(TPM_INIT_MOD, "do not check tcp flag, no need to create IPv4/6 tcp flag range\n");
-		}
-	} else {
-		if ((ret_code != TPM_DB_OK) || (range_conf.range_size < 3)) {
-			/* check tcp flag, need to create tcp flag range */
-			TPM_OS_WARN(TPM_INIT_MOD, "check tcp flag, need to create IPv4 tcp flag range with size of 3\n");
-		} else if ((ret_code_tcp_flag != TPM_DB_OK) || (range_conf_tcp_flag.range_size < 2)) {
-			/* check tcp flag, need to create tcp flag range */
-			TPM_OS_WARN(TPM_INIT_MOD, "check tcp flag, need to create IPv6 tcp flag range with size of 2\n");
-		} else {
-			ret_code = tpm_proc_tcp_flag_init();
-			IF_ERROR(ret_code);
-		}
-	}
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_VIRT_UNI, &range_conf);
-	if (ret_code == TPM_DB_OK) {
-		ret_code = tpm_proc_virt_uni_init();
-		IF_ERROR(ret_code);
-	} else
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) not initialized\n", TPM_PNC_VIRT_UNI);
-
-	ret_code = tpm_proc_mtu_init();
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_init_ethertype_dsa_tag();
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_fc_engine_init();
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_init_vlan_etype_set()
-*
-* DESCRIPTION:      Set configured VLAN ETYs in the TPM DB and hardware
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_vlan_etype_set(void)
-{
-	int32_t ret_code = TPM_OK;
-	uint32_t etype_sel;
-	int i;
-
-	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
-		if (tpm_init.vlan_etypes[i] != MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-			ret_code = tpm_mod2_tpid_get(tpm_init.vlan_etypes[i], &etype_sel);
-			IF_ERROR(ret_code);
-		}
-
-	}
-
-	return (ret_code);
-}
-
-/*******************************************************************************
-* tpm_pnc_init_temp()
-*
-* DESCRIPTION:      when TPM is responsible to configure the PNC:
-*                   * PNC clean ALL
-*                   * Add entry #0 for HW forwarding enabled
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-void tpm_pnc_init_temp(void)
-{
-	int rc;
-	unsigned int config_pnc_parser_val;
-
-	/* get the config_pnc_parser value */
-	config_pnc_parser_val = mv_eth_ctrl_pnc_get();
-	if (config_pnc_parser_val == 0) {
-		rc = tcam_hw_init();
-		if (rc != TPM_OK)
-			TPM_OS_WARN(TPM_INIT_MOD, " recvd ret_code(%d)\n", rc);
-		pnc_def_entry_init(0, 0);	/* rxq =0 */
-	}
-	return;
-}
-
-/*******************************************************************************
-* tpm_init_system_init()
-*
-* DESCRIPTION:      Initialize the system hardware.
-*                   First all the one-time Inits are performed,
-*                   and then a call to the dynamic sections is performed by calling mib_reset
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_init_system_init(tpm_reset_level_enum_t reset_type)
-{
-	int32_t ret_code;
-	tpm_db_gmac_func_t gfunc;
-	tpm_db_gmac_conn_t gconn = TPM_GMAC_CON_DISC;
-	tpm_gmacs_enum_t gmac_i;
-	uint16_t txp;
-
-	TPM_OS_DEBUG(TPM_INIT_MOD, "\n");
-
-	/* check PON and GMAC state */
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gfunc);
-
-		if (gfunc == TPM_GMAC_FUNC_NONE)
-			continue;
-		if (!tpm_init_check_gmac_init(gmac_i)) {
-			TPM_OS_ERROR(TPM_INIT_MOD, "GMAC port(%d) is not init, system is not fully functional!\n", gmac_i);
-			return TPM_FAIL;
-		}
-	}
-	/* Init Vlan Ethertype Registers */
-	ret_code = tpm_init_vlan_etype_set();
-	IF_ERROR(ret_code);
-
-	/* Init HW Modification table and registers */
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-		if (!INIT_GMAC_VALID(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gfunc);
-		if (gmac_i != TPM_ENUM_PMAC)
-			tpm_db_gmac_conn_get(gmac_i, &gconn);
-
-		if (gfunc != TPM_GMAC_FUNC_NONE &&
-				(gconn != TPM_GMAC_CON_DISC || gmac_i == TPM_ENUM_PMAC)) {
-			/*ret_code = tpm_mod2_inv_all(); */
-			ret_code = tpm_mod2_mac_inv(gmac_i);
-			IF_ERROR(ret_code);
-			if (gmac_i == TPM_ENUM_PMAC) {
-				for (txp = 0; txp < 8; txp++)
-					ret_code = tpm_mod2_registers_init(gmac_i, txp);
-			} else
-				ret_code = tpm_mod2_registers_init(gmac_i, 0);
-
-			IF_ERROR(ret_code);
-		}
-	}
-	/* temporarily = clean the PNC if needed */
-	tpm_pnc_init_temp();
-
-	/* Init hardware forwarding configuration */
-	tpm_init_hwf_set();
-
-	/* Init tx_queue sizes */
-	tpm_init_txq_size_set();
-
-	/* Init rx_queue sizes */
-	tpm_init_rxq_size_set();
-
-	/* Init marvell header configuration */
-	ret_code = tpm_init_mh(tpm_init.ds_mh_set_conf,
-				tpm_init.gmac0_mh_en,
-				tpm_init.gmac1_mh_en,
-				tpm_init.gmac_port_conf);
-	IF_ERROR(ret_code);
-
-	/* Init Buffer Mngmt Pool configuration */
-	tpm_init_bm_pool();
-
-	/* Init IPG */
-	tpm_init_ipg((-TPM_MH_LEN));
-
-	ret_code = tpm_init_system_mib_reset(reset_type);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_module_init()
-*
-* DESCRIPTION:      Initialize the TPM module
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_module_init(void)
-{
-	int32_t ret_code;
-
-	/* Reset DB */
-	ret_code = tpm_db_init();
-	if (ret_code != TPM_DB_OK) {
-		printk(KERN_ERR "Error in Init DB\n");
-		return (TPM_FAIL);
-	}
-
-	ret_code = tpm_mod2_init();
-	if (ret_code != TPM_OK) {
-		printk(KERN_ERR "Error in Init MOD2\n");
-		return (TPM_FAIL);
-	}
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_module_start()
-*
-* DESCRIPTION:      Initialize the TPM module
-*
-* INPUTS:
-
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-int32_t tpm_module_start(tpm_init_t *tpm_init)
-{
-	int32_t ret_code;
-	static uint32_t first_time = 0;
-
-	if (first_time == 0) {
-
-		/* Initialize XML configuration to the init database */
-		tpm_init_config_params_init(tpm_init);
-
-		/* Update database hardcoded configuration */
-		ret_code = tpm_init_config_params_update();
-		if (ret_code != TPM_OK) {
-			printk(KERN_ERR "Error in Init Configuration \n");
-			return (TPM_FAIL);
-		}
-
-		/* Check all Configuration params are consistent */
-		ret_code = tpm_init_info_validate();
-		if (ret_code != TPM_OK) {
-			printk(KERN_ERR "Error in Init Info Validate \n");
-			return (TPM_FAIL);
-		}
-
-		/* Transform raw form Init Info into TPM format and update DB
-		 * Involves internal mapping logic */
-		ret_code = tpm_init_info_set();
-		if (ret_code != TPM_OK) {
-			printk(KERN_ERR "Error in  Init Info Set \n");
-			return (TPM_FAIL);
-		}
-
-		/* Initialize TPM Locks */
-		tpm_init_locks_init();
-
-		/* Initialize System (HW) */
-		/* In HW reset all PnC Ranges, except for those that should never be reset (e.g. PNC_INIT_US for NFS) */
-		ret_code = tpm_init_system_init(TPM_ENUM_RESET_LEVEL1);
-		if (ret_code != TPM_OK) {
-			printk(KERN_ERR "\n= TPM Module - Error in System Init =\n");
-			return (TPM_FAIL);
-		} else {
-			printk(KERN_INFO "\n= TPM Module Init ended successfully =\n");
-			tpm_db_init_done_set();
-		}
-
-	} else
-		TPM_OS_INFO(TPM_INIT_MOD, " skipped\n");
-
-	first_time++;
-
-	return (TPM_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.h
deleted file mode 100644
index 009d272..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_init.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_init.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-#ifndef _TPM_INIT_H_
-#define _TPM_INIT_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#include "boardEnv/mvBoardEnvLib.h"
-
-/************/
-/*  APIs    */
-/************/
-
-int32_t tpm_init_pncranges_set(tpm_reset_level_enum_t reset_type);
-int32_t tpm_init_system_init(tpm_reset_level_enum_t reset_type);
-int32_t tpm_init_system_mib_reset(tpm_reset_level_enum_t reset_type);
-int32_t tpm_init_api_rng_init_all(void);
-int32_t tpm_module_init(void);
-int32_t tpm_module_start(tpm_init_t *tpm_init);
-void tpm_init_params_get(tpm_init_t *tpm_init_params);
-int32_t tpm_init_get_gmac_queue_rate_limit(void);
-int32_t tpm_init_mh(tpm_init_mh_src_t ds_mh_set_conf,
-			uint32_t gmac0_mh_en,
-			uint32_t gmac1_mh_en,
-			tpm_init_gmac_conn_conf_t *gmac_port_conf);
-int32_t tpm_init_ipg(int32_t mod_value);
-int32_t tpm_init_gmac_loopback(tpm_gmacs_enum_t port, uint8_t enable);
-
-#endif /* _TPM_INIT_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_internal_types.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_internal_types.h
deleted file mode 100644
index 7f8344e..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_internal_types.h
+++ /dev/null
@@ -1,622 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_internal_types.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.3
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_INT_TYPES_H_
-#define _TPM_INT_TYPES_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-#define TPM_MAX_NUM_GEM_PORT		(4096)
-
-#define TPM_CHAIN_NUM_UNLIMITED		(0x1000)
-
-/* PNC Target TXP, in exact numbering scheme, do not change !! */
-typedef enum {
-	TPM_INVALID_PNC_TRG = -1,
-	TPM_PNC_TRG_CPU,
-	TPM_PNC_TRG_GMAC0,
-	TPM_PNC_TRG_GMAC1,
-	TPM_PNC_TRG_PMAC0,
-	TPM_PNC_TRG_PMAC1,
-	TPM_PNC_TRG_PMAC2,
-	TPM_PNC_TRG_PMAC3,
-	TPM_PNC_TRG_PMAC4,
-	TPM_PNC_TRG_PMAC5,
-	TPM_PNC_TRG_PMAC6,
-	TPM_PNC_TRG_PMAC7
-} tpm_pnc_trg_t;
-
-typedef enum {
-	TPM_INT_CALL = 0,
-	TPM_EXT_CALL
-} tpm_caller_t;
-
-
-#define TPM_MAX_VID			(4096)	/* legal VLAN ID = 0-4095 */
-#define TPM_MAX_NUM_CTC_PRECEDENCE		(8)
-
-#define PON_PORT			(2)
-#define SW_GMAC_0			(0)
-#define SW_GMAC_1			(1)
-
-
-/* MH configuration - fixed values - will be supported via xml params */
-#define TPM_GMAC0_AMBER_PORT_NUM	4
-#define TPM_GMAC1_AMBER_PORT_NUM	5
-
-/* Hardware GMAC number to HAL Port number conversion, note that the numbers are currently equal */
-#define TPM_GMAC0_PP_PORT_NUM		0
-#define TPM_GMAC1_PP_PORT_NUM		1
-#define TPM_PMAC_PP_PORT_NUM		2
-
-/* retrieve the num of TCONTs and LLIDs from the .config - kernel global params */
-#define TPM_GPON_MAX_NUM_OF_T_CONTS	(CONFIG_MV_PON_TCONTS)
-#define TPM_EPON_MAX_MAC_NUM		(CONFIG_MV_EPON_LLID)
-/* Currently hardcoded, must update if pp_port_numbers will be reshuffled */
-#define TPM_GMAC_TO_PP_PORT(x)		(x)
-
-#define TPM_NUM_MC_VID_BITS		     (2)
-
-#define TPM_NUM_IPV6_SUBFLOW_BITS_P1 (1)
-#define TPM_NUM_IPV6_SUBFLOW_BITS_P2 (2)
-#define TPM_NUM_IPV6_SUBFLOW_BITS    (TPM_NUM_IPV6_SUBFLOW_BITS_P1 + TPM_NUM_IPV6_SUBFLOW_BITS_P2)
-
-#define TPM_NUM_IPV6_MC_SIP_BITS_P1 (1)
-#define TPM_NUM_IPV6_MC_SIP_BITS_P2 (2)
-#define TPM_NUM_IPV6_MC_SIP_BITS    (TPM_NUM_IPV6_MC_SIP_BITS_P1 + TPM_NUM_IPV6_MC_SIP_BITS_P2)
-
-#define ILLEGAL_API(api_type)		((api_type >= TPM_API_TYPE_ILLEGAL) || (api_type < 0))
-
-#define TPM_INTERNAL_OWNER_ID		(0xABBACDDC)
-
-#define TPM_INVALID_QUEUE		(0xFFFF)
-
-typedef enum {
-	TPM_INVALID_SECTION = -1,
-	TPM_PNC_MAC_LEARN_ACL,
-	TPM_DS_LOAD_BALANCE_ACL,
-	TPM_CPU_LOOPBACK_ACL,
-	TPM_L2_PRIM_ACL,
-	TPM_L3_TYPE_ACL,
-	TPM_IPV4_ACL,
-	TPM_IPV4_MC,
-	TPM_IPV6_NH_ACL,
-	TPM_L4_ACL,
-	TPM_IPV6_GEN_ACL,
-	TPM_IPV6_DIP_ACL,
-	TPM_IPV6_MC_ACL,
-	TPM_CNM_MAIN_ACL,
-	TPM_MAX_NUM_API_SECTIONS	/* Equals to number of entries in enum */
-} tpm_api_sections_t;
-
-#define ILLEGAL_API_SEC(api_sec)	((api_sec >= TPM_MAX_NUM_API_SECTIONS) || (api_sec < 0))
-
-typedef enum {
-	TPM_AI_DS_MAC_IP_SES,
-	TPM_AI_US_MAC_IP_SES,
-	TPM_AI_IPV6_DS_SIP_SES,
-	TPM_AI_IPV6_US_SIP_SES,
-	TPM_AI_IPV6_DS_NH_SES,
-	TPM_AI_IPV6_US_NH_SES,
-	TPM_AI_IPV6_DS_5T_SES,
-	TPM_AI_IPV6_US_5T_SES
-} tpm_ai_ses_type_t;
-
-typedef enum {
-	SES_IN,
-	SES_OUT
-} tpm_ai_con_type_t;
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-
-/* Amber related */
-#define  TPM_AMBER_MH_EN_MASK              (0x800)
-/* End Amber related */
-
-/* Following are derivatives of the TPM_PARSE_FLAGs in tpm_types.h */
-#define TPM_PARSE_FLAG_TAG1_MASK	(TPM_PARSE_FLAG_TAG1_TRUE | TPM_PARSE_FLAG_TAG1_FALSE)
-#define TPM_PARSE_FLAG_TAG2_MASK	(TPM_PARSE_FLAG_TAG2_TRUE | TPM_PARSE_FLAG_TAG2_FALSE)
-#define TPM_PARSE_FLAG_MTM_MASK		(TPM_PARSE_FLAG_MTM_TRUE | TPM_PARSE_FLAG_MTM_FALSE)
-#define TPM_PARSE_FLAG_TO_CPU_MASK	(TPM_PARSE_FLAG_TO_CPU_TRUE | TPM_PARSE_FLAG_TO_CPU_FALSE)
-#define TPM_PARSE_FLAG_L4P_MASK		(TPM_PARSE_FLAG_L4_TCP | TPM_PARSE_FLAG_L4_UDP)
-#define TPM_PARSE_FLAG_PPPOE_MASK	(TPM_PARSE_FLAG_PPPOE_TRUE | TPM_PARSE_FLAG_PPPOE_FALSE)
-#define TPM_PARSE_FLAG_PPPOE_ADD_MASK	(TPM_PARSE_FLAG_PPPOE_ADD_TRUE | TPM_PARSE_FLAG_PPPOE_ADD_FALSE)
-#define TPM_PARSE_FLAG_NO_PROTO_MASK	(TPM_PARSE_FLAG_NO_PROTO_TRUE | TPM_PARSE_FLAG_NO_PROTO_FALSE)
-#define TPM_PARSE_FLAG_NO_FRAG_MASK	(TPM_PARSE_FLAG_NO_FRAG_TRUE | TPM_PARSE_FLAG_NO_FRAG_FALSE)
-#define TPM_PARSE_FLAG_MC_VID_MASK	(TPM_PARSE_FLAG_MC_VID_TRUE | TPM_PARSE_FLAG_MC_VID_FALSE)
-#define TPM_PARSE_FLAG_NH2_ITER_MASK	(TPM_PARSE_FLAG_NH2_ITER_TRUE | TPM_PARSE_FLAG_NH2_ITER_FALSE)
-#define TPM_PARSE_FLAG_CNM_IPV4_MASK	(TPM_PARSE_FLAG_CNM_IPV4_TRUE | TPM_PARSE_FLAG_CNM_IPV4_FALSE)
-#define TPM_PARSE_FLAG_SPLIT_MOD_MASK	(TPM_PARSE_FLGA_SPLIT_MOD_TRUE | TPM_PARSE_FLGA_SPLIT_MOD_FALSE)
-
-#define TPM_DS_LOAD_BALNC_PARSE_BM_MASK		\
-		(TPM_L2_PARSE_MAC_DA | TPM_L2_PARSE_MAC_SA | TPM_L2_PARSE_ONE_VLAN_TAG | TPM_L2_PARSE_TWO_VLAN_TAG |\
-		TPM_L2_PARSE_ETYPE | TPM_L2_PARSE_PPPOE_SES | TPM_L2_PARSE_PPP_PROT | TPM_L2_PARSE_GEMPORT)
-#define TPM_L2_PARSE_BM_MASK		\
-		(TPM_L2_PARSE_MAC_DA | TPM_L2_PARSE_MAC_SA | TPM_L2_PARSE_ONE_VLAN_TAG | TPM_L2_PARSE_TWO_VLAN_TAG |\
-		TPM_L2_PARSE_ETYPE | TPM_L2_PARSE_PPPOE_SES | TPM_L2_PARSE_PPP_PROT | TPM_L2_PARSE_GEMPORT)
-#define TPM_L3_PARSE_BM_MASK		(TPM_L2_PARSE_ETYPE | TPM_L2_PARSE_PPPOE_SES | TPM_L2_PARSE_PPP_PROT)
-#define TPM_IPV4_PARSE_BM_MASK		\
-		(TPM_IPv4_PARSE_SIP | TPM_IPv4_PARSE_DIP | TPM_IPv4_PARSE_DSCP | TPM_IPv4_PARSE_PROTO |\
-		TPM_PARSE_L4_SRC|TPM_PARSE_L4_DST)
-#define TPM_IPV6_GEN_BM_MASK		(TPM_IPv6_PARSE_SIP | TPM_IPv6_PARSE_DSCP | TPM_IPv6_PARSE_HOPL)
-#define TPM_IPV6_L4_BM_MASK			(TPM_PARSE_L4_SRC | TPM_PARSE_L4_DST)
-
-/* in PARSE_FLAG_BM - bit#0 and bit#1 - TRUE and FALSE - should not be set simultaneously */
-#define TPM_PARSE_FLAG_CHECK_TRUE_FALSE		(0x0003)
-/* number of pairs of TRUE/FALSE bits present in the  PARSE_FLAG_BM:
-   TAG1 / TAG2 / MTM / TO_CPU / L2                                   */
-#define  TPM_PARSE_FLAG_CHECK_FIELD_NUMBER	(6)
-
-/* Following additional TPM_PARSE_FLAGs  for internal use, they must co-exist (not overlap)
-   with existing TPM_PARSE_FLAGs in types.h */
-#define TPM_PARSE_FLAG_UNI_PORT_PARSE		(0x00000001LL)
-#define TPM_PARSE_FLAG_PPPOE_ADD_TRUE		(0x00000002LL)
-#define TPM_PARSE_FLAG_PPPOE_ADD_FALSE		(0x00000004LL)
-#define TPM_PARSE_FLAG_NO_PROTO_TRUE		(0x00000008LL)
-#define TPM_PARSE_FLAG_NO_PROTO_FALSE		(0x00000010LL)
-#define TPM_PARSE_FLAG_NO_FRAG_TRUE			(0x00000020LL)
-#define TPM_PARSE_FLAG_NO_FRAG_FALSE		(0x00000040LL)
-#define TPM_PARSE_FLAG_MC_VID_TRUE			(0x00000080LL)
-#define TPM_PARSE_FLAG_MC_VID_FALSE			(0x00000100LL)
-#define TPM_PARSE_FLAG_MC_VID_PARSE			(0x00000200LL)
-#define TPM_PARSE_FLAG_NH2_ITER_TRUE		(0x00000400LL)
-#define TPM_PARSE_FLAG_NH2_ITER_FALSE		(0x00000800LL)
-#define TPM_PARSE_FLAG_IPV6_SUBFLOW_PARSE	(0x00001000LL)
-#define TPM_PARSE_FLAG_CNM_IPV4_TRUE        (0x00002000LL)
-#define TPM_PARSE_FLAG_CNM_IPV4_FALSE       (0x00004000LL)
-#define TPM_PARSE_FLGA_SPLIT_MOD_TRUE       (0x00008000LL)
-#define TPM_PARSE_FLGA_SPLIT_MOD_FALSE      (0x00010000LL)
-#define TPM_PARSE_FLAG_IPV4_PRE_KEY_PARSE   (0x00020000LL)
-#define TPM_PARSE_FLAG_CNM_PREC_PARSE       (0x00040000LL)
-#define TPM_PARSE_FLAG_IPV6_MC_SIP_PARSE    (0x00080000LL)
-#define TPM_PARSE_FLAG_DNRT_DS_TRUNK        (0x00100000LL)	/* Set DNRT_DS_TRUNK bit */
-
-/* Following additional TPM_ACTIONs for internal use, they must co-exist (not overlap)
-   with existing TPM_ACTIONs in types.h */
-#define TPM_ACTION_SET_UNI_PORT			(0x00000001LL)	/* Set UNI Port */
-#define TPM_ACTION_SET_TAG1				(0x00000002LL)	/* Set TAG1 */
-#define TPM_ACTION_SET_TAG2				(0x00000004LL)	/* Set TAG2 */
-#define TPM_ACTION_SET_L4P_TOG_UDP		(0x00000008LL)	/* Set L4 proto toggle bit to '1' (=UDP) */
-#define TPM_ACTION_SET_L4P_TOG_TCP		(0x00000010LL)	/* Set L4 proto toggle bit to '0' (=TCP) */
-#define TPM_ACTION_UNSET_DNRT			(0x00000020LL)	/* Unset DNRT bit */
-#define TPM_ACTION_UNSET_MC_VID_VALID	(0x00000040LL)	/* Unset MC_VID valid bit */
-#define TPM_ACTION_SET_PPPOE			(0x00000080LL)	/* Set PPPOE packet */
-#define TPM_ACTION_UNSET_PPPOE			(0x00000100LL)	/* Set not PPPOE packet */
-#define TPM_ACTION_SET_NO_PROTO_CHECK	(0x00000200LL)	/* Set no IPV4 proto check */
-#define TPM_ACTION_SET_NO_FRAG_CHECK	(0x00000400LL)	/* Set no IPV4 fragment check */
-#define TPM_ACTION_SET_ADD_PPPOE		(0x00000800LL)	/* Set PPPOE header is added */
-#define TPM_ACTION_UNSET_UNI_PORT		(0x00001000LL)	/* UnSet UNI Port */
-#define TPM_ACTION_SET_NH2_ITER			(0x00002000LL)	/* Set NH2 iteration */
-#define TPM_ACTION_UNSET_NH2_ITER		(0x00004000LL)	/* Unset NH2 iteration */
-#define TPM_ACTION_SET_IPV6_SUBFLOW     (0x00008000LL)	/* Set IPV6 subflow */
-#define TPM_ACTION_UNSET_IPV6_SUBFLOW   (0x00010000LL)	/* Unset IPV6 subflow */
-#define TPM_ACTION_SET_CNM_IPV4         (0x00020000LL)
-#define TPM_ACTION_UNSET_CNM_IPV4       (0x00040000LL)
-#define TPM_ACTION_SET_SPLIT_MOD        (0x00080000LL)
-#define TPM_ACTION_UNSET_SPLIT_MOD      (0x00100000LL)
-#define TPM_ACTION_SET_IPV4_PRE_KEY     (0x00200000LL)
-#define TPM_ACTION_UNSET_IPV4_PRE_KEY   (0x00400000LL)
-#define TPM_ACTION_SET_CNM_PREC         (0x00800000LL)
-#define TPM_ACTION_UNSET_CNM_PREC       (0x01000000LL)
-#define TPM_ACTION_UNSET_DNRT_DS_TRUNK  (0x02000000LL)	/* Unset DNRT_DS_TRUNK bit */
-
-#define     TPM_MAX_WRR_WEIGHT             (255)
-
-#define      TPM_MH_LEN                    (2)
-#define      TPM_DA_LEN                    (6)
-#define      TPM_SA_LEN                    (6)
-#define      TPM_VLAN_LEN                  (4)
-#define      TPM_ETYPE_LEN                 (2)
-#define      TPM_PPPOE_HDR_LEN             (8)
-#define      TPM_PPPOE_SES_LEN             (2)
-#define      TPM_PPP_PROTO_LEN             (2)
-#define      TPM_IPV4_VER_IHL_LEN          (1)
-#define      TPM_IPV4_DSCP_LEN             (1)
-#define      TPM_IPV4_TOTLEN_LEN           (2)
-#define      TPM_IPV4_IDENT_LEN            (2)
-#define      TPM_IPV4_FLAG_OFF_LEN         (2)
-#define      TPM_IPV4_TTL_LEN              (1)
-#define      TPM_IPV4_PROTO_LEN            (1)
-#define      TPM_IPV4_SIP_LEN              (4)
-#define      TPM_IPV4_DIP_LEN              (4)
-#define      TPM_IPV4_L4_PORT_LEN          (2)
-
-#define      TPM_TCP_DUMMY_LEN             (13)
-#define      TPM_TCP_FLAGS_LEN             (1)
-
-#define      TPM_IPV6_VER_DSCP_LEN         (1)
-#define      TPM_IPV6_DSCP_FLOW_LEN        (1)
-#define      TPM_IPV6_FLOW_LEN             (2)
-#define      TPM_IPV6_PLLEN_LEN			   (2)
-#define      TPM_IPV6_NH_LEN               (1)
-#define      TPM_IPV6_HOPLIM_LEN           (1)
-#define      TPM_IPV6_SIP_LEN			   (16)
-#define      TPM_IPV6_DIP_LEN			   (16)
-#define      TPM_L4_SPORT_LEN              (2)
-#define      TPM_L4_DPORT_LEN              (2)
-#define      TPM_UDP_LEN_LEN               (2)
-#define      TPM_L4_CHECKSUM_LEN           (2)
-#define      TPM_TCP_SEQ_NUM_LEN	       (4)
-#define      TPM_TCP_ACK_NUM_LEN	       (4)
-#define      TPM_TCP_OFFSET_LEN            (1)
-#define      TPM_TCP_FLAGS_LEN             (1)
-#define      TPM_TCP_WIN_LEN               (2)
-#define      TPM_TCP_URGTPTR_LEN           (2)
-
-#define      TPM_VLAN_CFI_OFFSET           (12)
-#define      TPM_VLAN_PBIT_OFFSET          (13)
-#define      TPM_VLAN_VID_OFFSET           (0)
-
-#define      TPM_IPV4_IHL_OFFSET           (0)	/* Offset in the VER_IHL byte */
-#define      TPM_IPV4_IHL_MASK             (0x0F)	/* Mask in the  IHL byte */
-
-#define      TPM_IPV4_VER_OFFSET           (4)	/* Offset in the VER_IHL byte */
-#define      TPM_IPV4_VER_MASK             (0x0F)	/* Mask in the VER byte */
-
-#define      TPM_IPV4_FRAG_OFFSET          (0)	/* Offset in the FLAGS_FRAGMENT 2_byte */
-#define      TPM_IPV4_FRAG_MASK            (0x1FFF)	/* Mask in the FRAGMENT byte */
-
-#define      TPM_IPV4_MF_OFFSET            (13)	/* Offset in the FLAGS_FRAGMENT 2_byte */
-#define      TPM_IPV4_MF_MASK              (0x01)	/* Mask in the  FLAGS byte */
-
-#define      TPM_IPV4_TOT_LEN_MASK         (0xFFFF)
-#define      TPM_IPV4_IDENT_MASK           (0xFFFF)
-#define      TPM_IPV4_TTL_MASK             (0xFF)
-
-#define     MH_UNI_PORT_MASK                (0x000F)
-#define     MH_UNI_PORT_OFFSET              (0)
-#define     MH_GEM_PORT_MASK                (0x0FFF)
-#define     MH_GEM_PORT_OFFSET              (0)
-
-/* Maximum number of pnc ranges a single API can be spanned upon.
- * Max. is currently two, to support IPV6 session DIP + SIP Routing + DSCP API call */
-#define     TPM_MAX_API_MULTI_RANGES        (3)
-
-#define     TPM_MAX_AI_REFS                 (4)
-
-#define     TPM_BM_GMAC_0                   (0x04)
-#define     TPM_BM_GMAC_1                   (0x10)
-#define     TPM_BM_PMAC                     (0x01)
-
-/* Bitmap of the GMACs */
-typedef uint32_t tpm_gmac_bm_t;
-
-/* TODO - add Amber to part of dynamc Init */
-#define TPM_AMBER                           (1)
-
-/* Direction Bitmap*/
-#define TPM_BM_DIR_DS                       (1<<TPM_DIR_DS)
-#define TPM_BM_DIR_US                       (1<<TPM_DIR_US)
-#define TPM_BM_DIR_BIDIR                    (TPM_BM_DIR_DS|TPM_BM_DIR_US)
-
-#define TPM_RESERVED_WINDOW_SIZE_DEFAULT     0
-
-typedef enum {
-	TPM_IP_VER_4,
-	TPM_IP_VER_6,
-	TPM_IP_VER_MAX,
-} tpm_ip_ver_t;
-
-/* TPM flowid update values */
-#define     TPM_FLOW_ID_31_16            (0x02)
-#define     TPM_FLOW_ID_15_00            (0x01)
-
-#define     TPM_TCAM_PKT_WIDTH           (24)
-
-#define     TPM_SWITCH_NUM_PORTS         (6)
-
-#define     TPM_PNC_LU_REG0              (0)
-#define     TPM_PNC_LU_REG1              (1)
-#define     TPM_PNC_LU_REG2              (2)
-#define     TPM_PNC_ETY_REG              (3)
-
-#define     TPM_PNC_CNM_L2_REG           (5)  /* KEEP IT ZERO, DON'T TOUCH IT!! THIS IS FOR CNM L2 LOOKUP. */
-#define     TPM_PNC_IPV6_DIP_REG         (6)
-#define     TPM_PNC_NOSHIFT_UPDATE_REG   (7)
-
-#define     TPM_MAX_NUM_TCONT            (8)
-#define     TPM_MAX_NUM_GIG_MAC          (2)
-#define     TPM_MAX_MOD_RANGES           (1)
-#define     TPM_MOD_TABL_SIZE            (256)
-
-#define     TPM_PNC_SIZE                 (512)
-
-#define     TPM_TX_MAX_MH_REGS           (15)
-
-/* TPM modification (z2) definitions */
-#define     TPM_MOD2_TABL_SIZE              (4095)
-#define     TPM_MOD2_MAC_TRANSLATIONS_NUM   (100)
-#define     TPM_MOD2_IP_TRANSLATIONS_NUM    (200)
-#define     TPM_MAX_MOD2_FLOWS              ((TPM_MOD2_MAC_TRANSLATIONS_NUM) + (TPM_MOD2_IP_TRANSLATIONS_NUM))
-
-#define     TPM_MOD2_DSCP_DATA_MASK         (0x00FC)	/* IPv4 DSCP */
-#define     TPM_MOD2_DSCP_DATA_BIT          (2)
-
-#define     TPM_MOD2_TC_DATA_MASK           (0x0FC0)	/* IPv6 DSCP */
-#define     TPM_MOD2_TC_DATA_BIT            (6)
-
-#define     TPM_PNC_ANY_LUID             (0xFFFF)
-
-#define     TPM_TRUE                     (1)
-#define     TPM_FALSE                    (0)
-
-#define     TPM_OK                       (0)
-#define     TPM_FAIL                     (1)
-#define     TPM_NOT_FOUND                (2)
-
-#define     TPM_MC_MAX_STREAM_NUM        (256)
-#define     TPM_MC_MAX_MAC_NUM           (256)
-#define     TPM_MAX_CPU_LOOPBACK_NUM     (4096)
-#define     TPM_MAX_CPU_LOOPBACK_ENTRY   (64)
-#define     TPM_MC_MAX_LPBK_ENTRIES_NUM  (128)
-
-#define     TPM_MAX_LU_THRESH_VAL         (0x3ffffff)
-#define     TPM_MC_MAX_MVLAN_XITS_NUM    (16)
-
-typedef enum {
-	TPM_MOD_MH_SET,	/* 0 - Update the Marvell Header */
-	TPM_MOD_MAC_DA_SET,	/* 1 - Update the MAC DA Address */
-	TPM_MOD_MAC_SA_SET,	/* 2 - Update the MAC SA Address */
-	TPM_MOD_VLAN_MOD,	/* 3 - Update the VLAN Tags (add/del/update) */
-	TPM_MOD_PPPOE_DEL,	/* 4 - Delete a PPPoE encapsulation */
-	TPM_MOD_PPPOE_ADD,	/* 5 - Add a PPPoE encapsulation */
-	TPM_MOD_DSCP_SET,	/* 6 - Set the DSCP value */
-	TPM_MOD_TTL_DEC,	/* 7 - Decrease the TTL value */
-	TPM_MOD_IPV4_UPDATE,	/* 8 - Update the IPv4 Header */
-	TPM_MOD_IPV4_SRC_SET,	/* 9 - Set the IPV4 Source Address */
-	TPM_MOD_IPV4_DST_SET,	/* 10 - Set the IPV4 Destination Address */
-	TPM_MOD_IPV6_UPDATE,	/* 11 - Update the IPv6 Header */
-	TPM_MOD_HOPLIM_DEC,	/* 12 - Decrease the Hop Limit value */
-	TPM_MOD_IPV6_SRC_SET,	/* 13 - Set the IPV6 Source Address */
-	TPM_MOD_IPV6_DST_SET,	/* 14 - Set the IPV6 Destination Address */
-	TPM_MOD_L4_SRC_SET,	/* 15 - Set the L4 Source Port (UDP or TCP) */
-	TPM_MOD_L4_DST_SET,	/* 16 - Set the L4 Destination Port (UDP or TCP) */
-
-	TPM_MAX_PKT_MOD_FLAGS
-} tpm_pkt_mod_flags_t;
-
-typedef enum {
-	TPM_AREA_TYPE_JUMP = 0,
-	TPM_AREA_TYPE_CHAIN,
-	TPM_AREA_TYPE_MAX,
-} tpm_area_type_t;
-
-typedef enum {
-	TPM_CHAIN_TYPE_NONE = 0,
-	TPM_CHAIN_TYPE_MH,
-	TPM_CHAIN_TYPE_MAC,
-	TPM_CHAIN_TYPE_VLAN,
-	TPM_CHAIN_TYPE_PPPOE,
-	TPM_CHAIN_TYPE_IPV6_PPPOE,
-	TPM_CHAIN_TYPE_L2,
-	TPM_CHAIN_TYPE_IPV4_NAPT,
-	TPM_CHAIN_TYPE_IPV4_MC,
-	TPM_CHAIN_TYPE_ROUTE,
-	TPM_CHAIN_TYPE_IPV6_MC,
-	TPM_CHAIN_TYPE_MAX,
-} tpm_chain_type_t;
-
-/******************* Internal modification flags *****************************/
-typedef enum {
-	TPM_MOD_INT_L4_TCP,	/* Update TCP checksum */
-	TPM_MOD_INT_L4_UDP,	/* Update UDP checksum */
-	TPM_MOD_INT_SPLIT_MOD,	/* First part of split modification */
-	TPM_MOD_INT_UDP_CHECKSUM,	/* Update UDP checksum - user control */
-	TPM_MAX_INT_MOD_FLAGS
-} tpm_pkt_int_mod_flags_t;
-
-/* CNM related */
-
-typedef enum {
-	TPM_CNM_IPV4_PRE_FILTER_KEY_1 = 0,
-	TPM_CNM_IPV4_PRE_FILTER_KEY_2,
-	TPM_CNM_IPV4_PRE_FILTER_KEY_3,
-	TPM_CNM_IPV4_PRE_FILTER_KEY_MAX,
-} tpm_cnm_ipv4_pre_filter_key_id_t;
-
-#define TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK    (1 << TPM_CNM_IPV4_PRE_FILTER_KEY_1)
-#define TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK    (1 << TPM_CNM_IPV4_PRE_FILTER_KEY_2)
-#define TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK    (1 << TPM_CNM_IPV4_PRE_FILTER_KEY_3)
-
-#define TPM_CNM_INVALID_IPV4_PRE_FILTER_KEY_ID    (0xFF)
-
-#define TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_KEY     (4)
-#define TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_PORT    (7)
-
-
-/*************************************************************/
-/*               STRUCTURES                                  */
-/*************************************************************/
-
-/* Structure for mapping tx_mod to HAL port and txp  */
-typedef struct {
-	uint32_t hal_port;
-	uint32_t hal_txp;
-} tpm_tx_mod_hal_map_t;
-
-/* Structure for mapping pnc_range to lookup_id */
-typedef struct {
-	tpm_pnc_ranges_t pnc_range;
-	uint32_t lookup_id;
-	uint32_t last_lookup_range;
-	uint32_t valid;
-} tpm_pnc_range_lookup_map_t;
-
-typedef struct {
-	uint32_t            enum_in;
-	uint8_t str_out[50];
-} tpm_str_map_t;
-
-/*****************************/
-/* PNC  related structures   */
-/*****************************/
-
-/* Structure represents 24byte packet data in TCAM */
-typedef struct {
-	uint8_t pkt_byte[TPM_TCAM_PKT_WIDTH];
-} tpm_pkt_data_t;
-
-/* Structure represents 24byte mask on packet data in TCAM */
-typedef tpm_pkt_data_t tpm_pkt_mask_t;
-
-/* Structure represents complete TCAM key */
-typedef struct {
-	uint32_t lu_id;	/*  TPM_PNC_ANY_LUID , for unmasking LU_ID */
-	tpm_gmac_bm_t port_ids;
-	tpm_pkt_data_t pkt_data;
-	tpm_pkt_mask_t pkt_mask;
-	uint32_t add_info_data;
-	uint32_t add_info_mask;
-} tpm_tcam_all_t;
-
-/* Structure represents complete SRAM entry */
-typedef struct {
-	uint32_t next_lu_id;
-	uint32_t lookup_done;
-	uint32_t pnc_queue;	/* 0xFFFF, don't update queue */
-	uint32_t res_info_15_0_data;
-	uint32_t res_info_15_0_mask;
-	uint32_t res_info_23_16_data;
-	uint32_t res_info_23_16_mask;
-	uint32_t add_info_data;
-	uint32_t add_info_mask;
-	uint32_t flowid_val;
-	uint32_t flowid_updt_mask;
-	uint32_t shift_updt_reg;
-	uint32_t shift_updt_val;
-	uint32_t next_lu_off_reg;
-} tpm_sram_all_t;
-
-/* Structure represents PnC entry, (TCAM, SRAM) without Index */
-typedef struct {
-	tpm_tcam_all_t tcam_entry;
-	tpm_sram_all_t sram_entry;
-} tpm_pnc_all_t;
-
-#define TPM_MOD2_MAX_PATTERN_ENTRIES    (20)
-
-/* Max number of modification pattern sets:
-	1  - jump entry
-	7 - main chains
-*/
-#define TPM_MOD2_MAX_PATTERN_SETS       (8)
-
-/* Structure for fields that may need to be parsed for internal functions (e.g. creating hardcoded pnc entries),
-   these fields are not exposed to the API's */
-typedef struct {
-	uint8_t ipv4_ver;
-	uint8_t ipv4_ver_mask;	/* 0-MASK ,  1-PARSE */
-	uint8_t ipv4_ihl;
-	uint8_t ipv4_ihl_mask;	/* 0-MASK ,  1-PARSE */
-	uint16_t ipv4_totlen;
-	uint16_t ipv4_totlen_mask;	/* 16-bits */
-	uint16_t ipv4_ident;
-	uint16_t ipv4_flags;	/* MF Flag at bit 0 */
-	uint16_t ipv4_flags_mask;	/* 0-MASK ,  1-PARSE */
-	uint8_t ipv4_frag_offset;
-	uint8_t ipv4_frag_offset_mask;	/* 0-MASK ,  1-PARSE */
-	uint8_t ipv4_ttl;
-} tpm_ipv4_add_key_t;
-
-typedef struct {
-	uint8_t ipv6_hopl;
-	uint16_t ipv6_totlen;
-	uint16_t ipv6_totlen_mask;	/* 16-bits */
-} tpm_ipv6_add_key_t;
-
-typedef struct {
-	uint8_t tcp_flags;
-	uint8_t tcp_flags_mask;	/* Bit7-0 - signal each of the TCP flags */
-} tpm_tcp_key_t;
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_INT_TYPES_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.c
deleted file mode 100644
index 7f8b193..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_mempool.c                                              **
-**                                                                           **
-**  DESCRIPTION : This file tpm memory pool manager                          **
-******************************************************************************/
-#include <linux/slab.h>
-#include "tpm_mempool.h"
-
-bool tpm_common_mempool_check_internal(tpm_common_mempool_t *pool,
-				       void *ptr,
-				       tpm_common_mpool_hdr_t *hdr,
-				       tpm_common_mpool_ftr_t *ftr)
-{
-	if (!ptr) {
-		printk(KERN_ERR "illegal ptr NULL");
-		return false;
-	}
-
-	if (!TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)) {
-		printk(KERN_ERR "ptr not aligned %p", ptr);
-		return false;
-	}
-
-	if (hdr->magic != TPM_COMMON_MPOOL_HDR_MAGIC) {
-		printk(KERN_ERR "illegal hdr magic %x for ptr %p", hdr->magic, ptr);
-		return false;
-	}
-
-	if (ftr->magic != TPM_COMMON_MPOOL_FTR_MAGIC) {
-		printk(KERN_ERR "illegal ftr magic %x for ptr %p", ftr->magic, ptr);
-		return false;
-	}
-
-	if (hdr->pool != pool || ftr->pool != pool) {
-		printk(KERN_ERR "inconsistent size hdr->pool: %p ftr->pool: %p for ptr %p", hdr->pool, ftr->pool, ptr);
-		return false;
-	}
-
-	if (!(hdr->flags & TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED)) {
-		printk(KERN_ERR "ptr %p was not allocated", ptr);
-		return false;
-	}
-	return true;
-}
-
-void *tpm_common_mempool_alloc(tpm_common_mempool_t * pool)
-{
-	tpm_common_mpool_hdr_t *hdr;
-
-	if (!pool || !pool->head || pool->number_of_free_entries == 0)
-		return NULL;
-
-	spin_lock_bh(&pool->lock);
-	hdr = pool->head;
-	pool->head = pool->head->next;
-
-	if (!pool->head)
-		pool->tail = NULL;
-
-	hdr->flags = TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED;
-	pool->number_of_free_entries--;
-	spin_unlock_bh(&pool->lock);
-	return ((uint8_t *) hdr + sizeof(tpm_common_mpool_hdr_t));
-}
-
-void tpm_common_mempool_free(tpm_common_mempool_t *pool, void *ptr)
-{
-	tpm_common_mpool_hdr_t *hdr;
-	tpm_common_mpool_ftr_t *ftr;
-
-	if (!pool || !ptr)
-		return;
-
-	if (!TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)) {
-		printk(KERN_ERR "ptr not aligned %p", ptr);
-		return;
-	}
-	spin_lock_bh(&pool->lock);
-	hdr = (tpm_common_mpool_hdr_t *) ((uint8_t *) ptr - sizeof(tpm_common_mpool_hdr_t));
-	ftr = (tpm_common_mpool_ftr_t *) ((uint8_t *) ptr + pool->data_size);
-
-	if (!tpm_common_mempool_check_internal(pool, ptr, hdr, ftr)) {
-		printk(KERN_ERR "invalid ptr %p", ptr);
-		spin_unlock_bh(&pool->lock);
-		return;
-	}
-
-	hdr->flags ^= TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED;
-	hdr->next = NULL;
-
-	if (!pool->head)
-		pool->head = pool->tail = hdr;
-	else {
-		pool->tail->next = hdr;
-		pool->tail = hdr;
-	}
-
-	pool->number_of_free_entries++;
-	spin_unlock_bh(&pool->lock);
-}
-
-tpm_common_mempool_t *tpm_common_mempool_create(uint32_t number_of_entries,
-						uint32_t entry_size,
-						int32_t priority)
-{
-	uint32_t i;
-	uint32_t aligned_entry_size;
-	uint32_t pool_entry_size;
-	tpm_common_mpool_hdr_t *hdr;
-	tpm_common_mpool_hdr_t *next_hdr;
-	tpm_common_mpool_ftr_t *ftr;
-	tpm_common_mempool_t *pool;
-
-	aligned_entry_size = TPM_COMMON_MPOOL_ALIGN4(entry_size);
-	pool_entry_size =
-	    TPM_COMMON_MPOOL_ALIGN4(sizeof(tpm_common_mpool_hdr_t) + aligned_entry_size +
-				    sizeof(tpm_common_mpool_ftr_t));
-	pool = kmalloc((sizeof(tpm_common_mempool_t) + pool_entry_size * number_of_entries), priority);
-
-	if (!pool)
-		return NULL;
-
-	pool->entry_size = entry_size;
-	pool->number_of_entries = number_of_entries;
-	pool->data_size = aligned_entry_size;
-	pool->pool_entry_size = pool_entry_size;
-	pool->number_of_free_entries = number_of_entries;
-	pool->mem = (uint8_t *) (pool + 1);
-	pool->head = (tpm_common_mpool_hdr_t *) pool->mem;
-	spin_lock_init(&pool->lock);
-
-	for (i = 0; i < number_of_entries; i++) {
-		hdr = (tpm_common_mpool_hdr_t *) &pool->mem[pool_entry_size * i];
-		ftr =
-		    (tpm_common_mpool_ftr_t *) ((uint8_t *) hdr + sizeof(tpm_common_mpool_hdr_t) + aligned_entry_size);
-		hdr->magic = TPM_COMMON_MPOOL_HDR_MAGIC;
-		hdr->pool = pool;
-		hdr->flags = 0;
-		ftr->magic = TPM_COMMON_MPOOL_FTR_MAGIC;
-		ftr->pool = pool;
-
-		if (i < (number_of_entries - 1))
-			next_hdr = (tpm_common_mpool_hdr_t *) &pool->mem[pool_entry_size * (i + 1)];
-		else {
-			pool->tail = hdr;
-			next_hdr = NULL;
-		}
-
-		hdr->next = next_hdr;
-	}
-	return pool;
-}
-
-void tpm_common_mempool_destroy(tpm_common_mempool_t *pool)
-{
-	if (!pool)
-		return;
-
-	kfree(pool);
-}
-
-int32_t tpm_common_mempool_get_number_of_free_entries(tpm_common_mempool_t *pool)
-{
-	if (!pool)
-		return -1;
-
-	return (int32_t) pool->number_of_free_entries;
-}
-
-int32_t tpm_common_mempool_get_number_of_entries(tpm_common_mempool_t *pool)
-{
-	if (!pool)
-		return -1;
-
-	return (int32_t) pool->number_of_entries;
-}
-
-int32_t tpm_common_mempool_get_entry_size(tpm_common_mempool_t *pool)
-{
-	if (!pool)
-		return -1;
-
-	return (int32_t) pool->entry_size;
-}
-
-tpm_common_mempool_t *tpm_common_mempool_get(void *ptr)
-{
-	tpm_common_mpool_hdr_t *hdr;
-	tpm_common_mpool_ftr_t *ftr;
-
-	if (!ptr)
-		return NULL;
-
-	if (!TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr))
-		return NULL;
-
-	hdr = (tpm_common_mpool_hdr_t *) ((uint8_t *) ptr - sizeof(tpm_common_mpool_hdr_t));
-
-	if (!hdr)
-		return NULL;
-
-	ftr = (tpm_common_mpool_ftr_t *) ((uint8_t *) ptr + hdr->pool->data_size);
-
-	if (hdr->magic != TPM_COMMON_MPOOL_HDR_MAGIC) {
-		printk(KERN_ERR "illegal hdr magic %x for ptr %p", hdr->magic, ptr);
-		return NULL;
-	}
-	if (ftr->magic != TPM_COMMON_MPOOL_FTR_MAGIC) {
-		printk(KERN_ERR "illegal ftr magic %x for ptr %p", ftr->magic, ptr);
-		return NULL;
-	}
-	if ((!hdr->pool) || (hdr->pool != ftr->pool)) {
-		printk(KERN_ERR "inconsistent size hdr->pool: %p ftr->pool: %p for ptr %p", hdr->pool, ftr->pool, ptr);
-		return false;
-	}
-	return hdr->pool;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.h
deleted file mode 100644
index 2eabf27..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mempool.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_mempool.h                                              **
-**                                                                           **
-**  DESCRIPTION : This file tpm memory pool manager                          **
-******************************************************************************/
-#ifndef _TPM_MEMPOOL_H
-#define _TPM_MEMPOOL_H
-
-#include <linux/spinlock.h>
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct tpm_common_mempool tpm_common_mempool_t;
-typedef struct tpm_common_mpool_hdr {
-	struct tpm_common_mpool_hdr *next;
-	tpm_common_mempool_t *pool;
-	uint32_t flags;
-	uint32_t magic;
-} tpm_common_mpool_hdr_t;
-
-typedef struct {
-	uint32_t magic;
-	tpm_common_mempool_t *pool;
-} tpm_common_mpool_ftr_t;
-
-struct tpm_common_mempool {
-	tpm_common_mpool_hdr_t *head;
-	tpm_common_mpool_hdr_t *tail;
-	uint32_t number_of_free_entries;
-	spinlock_t lock;
-	uint32_t data_size;	/* size of data section in pool entry */
-	uint32_t pool_entry_size;	/* size of pool entry */
-	/* parameters passed on init */
-	uint32_t number_of_entries;
-	uint32_t entry_size;
-	uint8_t *mem;
-};
-
-void *tpm_common_mempool_alloc(tpm_common_mempool_t *pool);
-void tpm_common_mempool_free(tpm_common_mempool_t *pool, void *mem);
-tpm_common_mempool_t *tpm_common_mempool_get(void *mem);
-tpm_common_mempool_t *tpm_common_mempool_create(uint32_t number_of_entries, uint32_t entry_size,
-						int32_t priority);
-void tpm_common_mempool_destroy(tpm_common_mempool_t *pool);
-int32_t tpm_common_mempool_get_number_of_free_entries(tpm_common_mempool_t *pool);
-int32_t tpm_common_mempool_get_number_of_entries(tpm_common_mempool_t *pool);
-int32_t tpm_common_mempool_get_entry_size(tpm_common_mempool_t *pool);
-
-#define TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED	0x00000001
-#define TPM_COMMON_MPOOL_HDR_MAGIC		0xa5a5a508
-#define TPM_COMMON_MPOOL_FTR_MAGIC		0xa5a5a509
-#define TPM_COMMON_MPOOL_ALIGN4(size)		((size)+4) & 0xFFFFFFFC;
-#define TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)	((((uint32_t)(ptr)) & 0x00000003) == 0)
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_MEMPOOL_H */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.c
deleted file mode 100644
index dc1ccce..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.c
+++ /dev/null
@@ -1,1263 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_mtu.c
-*
-*
-*  MODULE : TPM
-*
-*  DESCRIPTION : This file config tpm mtu
-*
-*  MODIFICATION HISTORY:
-*           15Aug11   jinghua - initial version created.
-*
-* FILE REVISION NUMBER:
-*       Revision: 1.12
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_mtu.h"
-#include "tpm_pkt_proc_logic.h"
-
-tpm_mtu_pnc_cfg_t g_tpm_mtu_cfg;
-tpm_mtu_pnc_entries_t g_tpm_mtu_pnc_entry_tmp;
-
-#define IF_ERROR(ret)		\
-	if (ret != TPM_OK) {\
-		TPM_OS_ERROR(TPM_MTU_MOD, " recvd ret_code(%d)\n", ret);\
-		return(ret);\
-	}
-
-uint32_t tpm_mtu_get_pnc_free_index(void)
-{
-	static uint32_t l_rule_idx = 100;
-	return (l_rule_idx++);
-}
-
-int32_t tpm_mtu_del_acl_pnc_entry(uint32_t ethertype, uint32_t pnc_index)
-{
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_id;
-	uint32_t pnc_start, pnc_stop;
-	int32_t int_ret_code;
-	tpm_mtu_pnc_index_t *pnc_index_cfg;
-	int32_t loop;
-
-	/* Get pnc_range_id */
-	if (TPM_MTU_IPV4 == ethertype) {
-		pnc_range_id = TPM_PNC_IPV4_LEN;
-		pnc_index_cfg = &(g_tpm_mtu_cfg.ipv4_mtu_cfg.pncIndex_cfg);
-	} else {
-		/*pnc_range_id = TPM_PNC_IPV6_LEN;
-		pnc_index_cfg = &(g_tpm_mtu_cfg.ipv6_mtu_cfg.pncIndex_cfg);*/
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "there is no length check for IPv6\n");
-		return ERR_GENERAL;
-	}
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(pnc_range_id, &range_data);
-	IF_ERROR(int_ret_code);
-
-	for (loop = 0; loop < pnc_index_cfg->pncNumber; loop++) {
-		if (pnc_index == pnc_index_cfg->pncIndex[loop])
-			break;
-	}
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d), pncIndex(%d)\n", loop, pnc_index);
-
-	/* Pull range from this index untill last used entry in Pnc range */
-	pnc_start = range_data.pnc_range_conf.range_start + loop;
-	pnc_stop = range_data.pnc_range_conf.range_start + pnc_index_cfg->pncNumber - 1;
-
-	int_ret_code = tpm_pncl_entry_delete(pnc_start, pnc_stop);
-	IF_ERROR(int_ret_code);
-
-	/* Increase number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_inc(pnc_range_id);
-	IF_ERROR(int_ret_code);
-
-	/* update the pnc index cfg */
-	if (pnc_index_cfg->pncNumber > 1) {
-		for (; loop < pnc_index_cfg->pncNumber - 1; loop++)
-			pnc_index_cfg->pncIndex[loop] = pnc_index_cfg->pncIndex[loop + 1];
-	}
-
-	pnc_index_cfg->pncNumber--;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_index_cfg->pncNumber : %d, pncIndex: %d\n", pnc_index_cfg->pncNumber,
-		     pnc_index);
-
-	return (TPM_OK);
-}
-
-int32_t tpm_mtu_create_acl_pnc_entry(uint32_t rule_num, uint32_t ethertype,
-				     tpm_pncl_pnc_full_t *pnc_data, uint32_t *pnc_index)
-{
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_id;
-	uint32_t pnc_range_start, api_start, pnc_stop_entry, pnc_entries_number, pnc_entry;
-	int32_t int_ret_code;
-	tpm_mtu_pnc_index_t *pnc_index_cfg;
-	int loop;
-
-	/* Get pnc_range_id */
-	if (TPM_MTU_IPV4 == ethertype) {
-		pnc_range_id = TPM_PNC_IPV4_LEN;
-		pnc_index_cfg = &(g_tpm_mtu_cfg.ipv4_mtu_cfg.pncIndex_cfg);
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "there is no length check for IPv6\n");
-		return ERR_GENERAL;
-		/*pnc_range_id = TPM_PNC_IPV6_LEN;
-		pnc_index_cfg = &(g_tpm_mtu_cfg.ipv6_mtu_cfg.pncIndex_cfg);*/
-	}
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(pnc_range_id, &range_data);
-	IF_ERROR(int_ret_code);
-
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	/* Get number of existing pnc entries */
-	pnc_entries_number = pnc_index_cfg->pncNumber;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d), pnc_entries_number(%d)\n", rule_num, pnc_entries_number);
-
-	/* Call PNC Entry Insert, if this is not the api_section's new last entry */
-	if (rule_num < pnc_entries_number) {
-		pnc_stop_entry = (pnc_range_start + api_start) + (pnc_entries_number - 1);
-		int_ret_code = tpm_pncl_entry_insert(pnc_entry, pnc_stop_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-	} else {		/* Otherwise just set the entry (no insertion) */
-
-		int_ret_code = tpm_pncl_entry_set(pnc_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-	}
-
-	/* Decrease number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(pnc_range_id);
-	IF_ERROR(int_ret_code);
-
-	/* update the pnc index cfg */
-	*pnc_index = tpm_mtu_get_pnc_free_index();
-
-	if (pnc_index_cfg->pncNumber > 0) {
-		for (loop = pnc_index_cfg->pncNumber - 1; loop >= rule_num; loop--) {
-			pnc_index_cfg->pncIndex[loop + 1] = pnc_index_cfg->pncIndex[loop];
-			if (0 == loop)
-				break;
-		}
-
-	}
-
-	pnc_index_cfg->pncIndex[rule_num] = *pnc_index;
-	pnc_index_cfg->pncNumber++;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_index_cfg->pncNumber : %d, pncIndex: %d\n", pnc_index_cfg->pncNumber,
-		     pnc_index_cfg->pncIndex[rule_num]);
-
-	return (TPM_OK);
-}
-
-tpm_error_code_t tpm_mtu_ipv4_default_pnc_entry_insert(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "\n");
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_LEN, &range_data);
-	IF_ERROR(int_ret_code);
-
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_end;
-
-	/*************************************************/
-	/* Basic TCAM/SRAM Config, valid for all entries */
-	/*************************************************/
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-
-	pnc_data.pncl_tcam.lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_LEN, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_IPV4_LEN);
-	IF_ERROR(int_ret_code);
-
-	return (TPM_RC_OK);
-}
-
-#if 0
-tpm_error_code_t tpm_mtu_ipv6_default_pnc_entry_insert(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, ipv6_frag_type_lu, pnc_entry;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data, nextphase_range_data;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&nextphase_range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "\n");
-
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_TCP_FLAG, &nextphase_range_data);
-	IF_ERROR(int_ret_code);
-	ipv6_frag_type_lu = nextphase_range_data.pnc_range_conf.base_lu_id;
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_LEN, &range_data);
-	IF_ERROR(int_ret_code);
-
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_end;
-
-	/*************************************************/
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-
-	pnc_data.pncl_tcam.lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_VER;
-	pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_VER;
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-	pnc_data.pncl_sram.next_lu_id = ipv6_frag_type_lu;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV6_LEN, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	return (TPM_RC_OK);
-
-}
-#endif
-
-void tpm_mtu_printBinary(uint32_t inValue)
-{
-	uint32_t desArray[16] = { 0 };
-	uint32_t i;
-	for (i = 0; i < 16; i++) {
-		if (0 != (inValue & (1 << i)))
-			desArray[i] = 1;
-	}
-
-	for (i = 16; i > 0; i--)
-		printk("%d", desArray[i - 1]);
-
-	return;
-}
-
-uint32_t tpm_mtu_get_binary_length(uint32_t inValue)
-{
-	uint32_t i;
-	for (i = 16; i > 0; i--) {
-		if (0 != (inValue & (1 << (i - 1))))
-			return i;
-	}
-
-	return 0;
-}
-
-void tpm_mtu_add_len_chk_entry(uint32_t pkt_value, uint32_t pkt_mask)
-{
-/*    printf("\npkt_value: ");
-    printBinary(pkt_value);
-    printf(" ,   %d", pkt_value);
-    printf("\npkt_mask : ");
-    printBinary(pkt_mask);
-    printf(" ,   %d", pkt_mask);
-    printf("\n===========================================================");
-*/
-	g_tpm_mtu_pnc_entry_tmp.pktMask[g_tpm_mtu_pnc_entry_tmp.pncEntryNum] = pkt_mask;
-	g_tpm_mtu_pnc_entry_tmp.pktValue[g_tpm_mtu_pnc_entry_tmp.pncEntryNum] = pkt_value;
-	g_tpm_mtu_pnc_entry_tmp.pncEntryNum++;
-
-	return;
-}
-
-void tpm_mtu_caculate_value_mask(uint32_t min, uint32_t max)
-{
-	uint32_t max_tmp, min_tmp;
-	uint32_t max_length = 0, min_length = 0;
-	uint32_t i = 0, tmp_range_max;
-	uint32_t pkt_value, pkt_mask;
-
-	memset(&g_tpm_mtu_pnc_entry_tmp, 0, sizeof(g_tpm_mtu_pnc_entry_tmp));
-
-	if (min > max)
-		return;
-
-	min++;
-	max_length = tpm_mtu_get_binary_length(max);
-	min_length = tpm_mtu_get_binary_length(min);
-
-	/* get the length of the max */
-	max_tmp = max;
-	min_tmp = min;
-
-	for (i = 0; i < max_length; i++) {
-		tmp_range_max = min_tmp | (0xffff >> (15 - i));
-
-		if (max == min_tmp) {
-			pkt_mask = 0xffff;
-
-			pkt_value = min_tmp;
-
-			tpm_mtu_add_len_chk_entry(pkt_value, pkt_mask);
-
-			return;
-		}
-
-		if (max == tmp_range_max) {
-			if (0 != (min_tmp & (1 << i)))
-				pkt_mask = 0xffff << i;
-			else
-				pkt_mask = 0xffff << (i + 1);
-
-			pkt_value = min_tmp & pkt_mask;
-
-			tpm_mtu_add_len_chk_entry(pkt_value, pkt_mask);
-
-			return;
-		}
-
-		if (0 != (min_tmp & (1 << i))) {
-			/*here we get the 1. */
-			if (max > tmp_range_max) {
-				/*here we get the 1 in min_tmp. */
-				pkt_mask = 0xffff << i;
-
-				pkt_value = min_tmp & pkt_mask;
-
-				tpm_mtu_add_len_chk_entry(pkt_value, pkt_mask);
-
-				min_tmp = min_tmp + (1 << i);
-			} else {
-				/*here we get some problem. */
-				break;
-			}
-		} else {
-			if (max > tmp_range_max)
-				continue;
-			else {
-				/*here we get some problem. */
-				break;
-			}
-		}
-	}
-
-	if (i == max_length) {
-		/* here we got nothing left to do */
-		return;
-	}
-
-	/* here is for the thing like this:
-	   min: 10000
-	   max: 10100
-	   in this case, i = 2;
-	 */
-	for (; i > 0; i--) {
-		if (GET_BIT(max, i) == GET_BIT(min_tmp, i))
-			continue;
-
-		pkt_mask = 0xffff << i;
-
-		pkt_value = min_tmp & pkt_mask;
-
-		tpm_mtu_add_len_chk_entry(pkt_value, pkt_mask);
-
-		min_tmp = min_tmp + (1 << i);
-	}
-
-	/* here we set the last one, i = 0
-	   min: 10100
-	   max: 10100
-	   or
-	   min: 10100
-	   max: 10101
-	 */
-	if (GET_BIT(max, i) == GET_BIT(min_tmp, i))
-		pkt_mask = 0xffff;
-	else
-		pkt_mask = 0xffff << 1;
-
-	pkt_value = min_tmp;
-
-	tpm_mtu_add_len_chk_entry(pkt_value, pkt_mask);
-
-	return;
-}
-
-tpm_error_code_t tpm_mtu_ipv4_len_entry_create(uint32_t len_start,
-					       uint32_t len_mask,
-					       bool pppoe_only,
-					       uint32_t direction, uint32_t rule_num, uint32_t *rule_idx)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t cpu_rx_queue;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_MTU_MOD, "\n");
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_LEN, &range_data);
-	IF_ERROR(int_ret_code);
-
-	free_entries = range_data.pnc_range_oper.free_entries;
-
-	if (free_entries < 1) {
-		TPM_OS_WARN(TPM_MTU_MOD, "PNC length range(%d) too small, can not insert anymore \n", TPM_PNC_IPV4_LEN);
-		return TPM_FAIL;
-	}
-
-	/*************************************************/
-	/* Basic TCAM/SRAM Config, valid for all entries */
-	/*************************************************/
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-
-	pnc_data.pncl_tcam.lu_id = range_data.pnc_range_conf.base_lu_id;
-	if (TPM_DOWNSTREAM == direction) {
-		/* Get PMAC(s) */
-		tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	} else {
-		/* Get GMAC(s) */
-		tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &gmac_bm);
-	}
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_TOTLEN;
-
-	/* Only check length for packets that are not already going to CPU */
-	pnc_data.pncl_tcam.add_info_data = (0 << TPM_AI_TO_CPU_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_TO_CPU_MASK;
-
-	/* Only check length for packets that are MTM */
-	pnc_data.pncl_tcam.add_info_data = (1 << TPM_AI_MTM_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_MTM_MASK;
-
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_TXP | TPM_PNCL_SET_LUD;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-	/* Signal the packet is going to CPU */
-	pnc_data.pncl_sram.add_info_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TO_CPU_MASK;
-
-	if (free_entries == 0) {
-		TPM_OS_ERROR(TPM_MTU_MOD, "No free entries\n");
-		return (TPM_FAIL);
-	}
-
-	/* Build Tcam Entry */
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_totlen = len_start;
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_totlen_mask = len_mask;
-
-	if (pppoe_only) {
-		/* YUVAL - this only handles pppoe_add, which is ok as long as L2_hwf does not need to be len_checked */
-		pnc_data.pncl_tcam.add_info_data |= (1 << TPM_AI_PPPOE_ADD_BIT_OFF);
-		pnc_data.pncl_tcam.add_info_mask |= TPM_AI_PPPOE_ADD_MASK;
-
-	}
-
-	/*** Insert the PNC Entry ***/
-	int_ret_code = tpm_mtu_create_acl_pnc_entry(rule_num, TPM_MTU_IPV4, &pnc_data, rule_idx);
-	IF_ERROR(int_ret_code);
-
-	TPM_OS_INFO(TPM_MTU_MOD,
-		    "insert new len chk PNC rule: pktValue(%d), pktMask(%d), pnc_entry(%d), pncIndex(%d),\n", len_start,
-		    len_mask, rule_num, *rule_idx);
-
-	return (TPM_OK);
-}
-
-tpm_error_code_t tpm_mtu_safety_net_entry_create(uint32_t *entry_index, uint32_t direction, uint32_t ethertype)
-{
-	tpm_error_code_t tpm_ret;
-	uint32_t safety_net_entry;
-
-	TPM_OS_INFO(TPM_MTU_MOD, "direction(%d), ethertype(%d), \n", direction, ethertype);
-
-	if (TPM_MTU_IPV4 == ethertype) {
-		safety_net_entry = g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_ds_cfg.pncEntryNum
-		    + g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_pppoe2ipoe_us_cfg.pncEntryNum
-		    + g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_ipoe2max_us_cfg.pncEntryNum;
-
-		tpm_ret = tpm_mtu_ipv4_len_entry_create(g_tpm_mtu_cfg.safety_net_value,
-							g_tpm_mtu_cfg.safety_net_mask,
-							false, direction, safety_net_entry, entry_index);
-	} else
-		tpm_ret = TPM_OK;
-
-	TPM_OS_INFO(TPM_MTU_MOD, "entry_index(%d)\n", *entry_index);
-
-	return tpm_ret;
-}
-
-uint32_t tpm_mtu_update_pnc(tpm_mtu_pnc_entries_t *mtu_cfg,
-			    uint32_t start_pnc_entry,
-			    uint32_t ethertype, uint32_t direction, uint32_t free_pnc_entry_number, bool pppoe_only)
-{
-	uint32_t pnc_entry_num_tmp;
-	uint32_t pnc_entry_num_original;
-	tpm_error_code_t tpm_ret;
-	uint32_t safety_net_entry;
-	tpm_src_port_type_t src_port;
-
-	pnc_entry_num_tmp = 0;
-	pnc_entry_num_original = 0;
-
-	TPM_OS_INFO(TPM_MTU_MOD, "direction(%d), ethertype(%d), start_pnc_entry(%d), free_pnc_entry_number(%d),\n",
-		    direction, ethertype, start_pnc_entry, free_pnc_entry_number);
-
-	if (TPM_MTU_IPV6 == ethertype)
-		return TPM_OK;
-
-	/* insert safety net first */
-	tpm_ret = tpm_mtu_safety_net_entry_create(&safety_net_entry, direction, ethertype);
-	if (TPM_RC_OK != tpm_ret) {
-		TPM_OS_ERROR(TPM_MTU_MOD, "fail to insert safety net pnc entry, number: %d\n", pnc_entry_num_tmp);
-		return TPM_FAIL;
-	}
-
-	if (TPM_DOWNSTREAM == direction)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-
-	while ((free_pnc_entry_number > 0) && (pnc_entry_num_tmp < g_tpm_mtu_pnc_entry_tmp.pncEntryNum)) {
-		/* insert new */
-		tpm_ret = tpm_mtu_ipv4_len_entry_create(g_tpm_mtu_pnc_entry_tmp.pktValue[pnc_entry_num_tmp],
-							g_tpm_mtu_pnc_entry_tmp.pktMask[pnc_entry_num_tmp],
-							pppoe_only,
-							direction,
-							pnc_entry_num_tmp + start_pnc_entry,
-							&g_tpm_mtu_pnc_entry_tmp.pncIndex[pnc_entry_num_tmp]);
-		if (TPM_RC_OK != tpm_ret) {
-			TPM_OS_ERROR(TPM_MTU_MOD, "fail to insert len chk pnc entry, number: %d\n", pnc_entry_num_tmp);
-			return TPM_FAIL;
-		}
-
-		pnc_entry_num_tmp++;
-		free_pnc_entry_number--;
-
-		TPM_OS_INFO(TPM_MTU_MOD, "pnc_entry_inert_num(%d), free_pnc_entry_number(%d)\n",
-			    pnc_entry_num_tmp, free_pnc_entry_number);
-	}
-
-	while (pnc_entry_num_original < mtu_cfg->pncEntryNum) {
-		/* remove old one */
-		tpm_ret = tpm_mtu_del_acl_pnc_entry(ethertype, mtu_cfg->pncIndex[pnc_entry_num_original]);
-		IF_ERROR(tpm_ret);
-
-		TPM_OS_INFO(TPM_MTU_MOD, "remove (%d) PNC entry pncIndex(%d)\n",
-			    pnc_entry_num_original, mtu_cfg->pncIndex[pnc_entry_num_original]);
-
-		pnc_entry_num_original++;
-
-		/* insert new one if there is */
-		if (pnc_entry_num_tmp < g_tpm_mtu_pnc_entry_tmp.pncEntryNum) {
-			tpm_ret = tpm_mtu_ipv4_len_entry_create(g_tpm_mtu_pnc_entry_tmp.pktValue[pnc_entry_num_tmp],
-								g_tpm_mtu_pnc_entry_tmp.pktMask[pnc_entry_num_tmp],
-								pppoe_only,
-								direction,
-								pnc_entry_num_tmp + start_pnc_entry,
-								&g_tpm_mtu_pnc_entry_tmp.pncIndex[pnc_entry_num_tmp]);
-			if (TPM_RC_OK != tpm_ret) {
-				TPM_OS_ERROR(TPM_MTU_MOD, "fail to insert len chk pnc entry, number: %d\n",
-					     pnc_entry_num_tmp);
-				return TPM_FAIL;
-			}
-			TPM_OS_INFO(TPM_MTU_MOD, "pnc_entry_inert_num(%d)\n", pnc_entry_num_tmp);
-		}
-
-		pnc_entry_num_tmp++;
-	}
-
-	/* set the config */
-	memcpy(mtu_cfg, &g_tpm_mtu_pnc_entry_tmp, sizeof(g_tpm_mtu_pnc_entry_tmp));
-
-	/* remove safety net */
-	tpm_ret = tpm_mtu_del_acl_pnc_entry(ethertype, safety_net_entry);
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-}
-
-uint32_t tpm_proc_set_mtu(uint32_t ethertype, uint32_t direction, uint32_t mtu)
-{
-
-/*
-	1. If ipv4_pppoe_mtu has been set,
-
-		if ipv4_pppoe_mtu > ipv4_MTU, return error.
-		else use algorism to get the PNC entries for (ipv4_pppoe_MTU to ipv4_MTU) with pppoe AI bits
-
-	2. Use algorism to get the PNC entries for (ipv4_MTU to tpm_max_pkt_len)
-
-	3. If the PNC entries number for this two sets is bigger than the size of IPv4 len check range,
-		return error and quit;
-
-	4. If any of the two sets of PNC entries for pkt len check have already been set,
-		use the algorism in section 3.4 to update the PNC entries.
-*/
-
-	tpm_mtu_ethtype_pnc_cfg_t *ethtype_pnc_cfg;
-	uint32_t pppoe_mtu;
-	uint32_t pre_mtu;
-	uint32_t new_pnc_entry_num = 0;
-	uint32_t free_entry_number;
-	uint32_t int_ret_code;
-	tpm_mtu_pnc_entries_t *mtu_cfg;
-	tpm_db_mtu_setting_enable_t enable;
-	tpm_db_pppoe_add_enable_t pppoe_add_enable;
-
-	tpm_db_get_mtu_enable(&enable);
-	if (TPM_MTU_CHECK_DISABLED == enable) {
-		TPM_OS_WARN(TPM_MTU_MOD, "mtu check is not enabled!\n");
-		return TPM_OK;
-	}
-
-	tpm_db_get_pppoe_add_enable(&pppoe_add_enable);
-
-	if (TPM_MTU_IPV4 == ethertype) {
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv4_mtu_cfg);
-		tpm_db_mtu_get_ipv4_pppoe_mtu_us(&pppoe_mtu);
-	} else {
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv6_mtu_cfg);
-		tpm_db_mtu_get_ipv6_pppoe_mtu_us(&pppoe_mtu);
-	}
-
-	if ((TPM_UPSTREAM == direction) && (pppoe_mtu >= mtu)) {
-		/* pppoe_mtu is bigger than ipoe_mtu, does not make sense */
-		TPM_OS_WARN(TPM_MTU_MOD, "pppoe_mtu is bigger than ipoe_mtu, does not make sense\n");
-	}
-
-	TPM_OS_DEBUG(TPM_MTU_MOD, "pppoe_mtu: %d, ipoe_mtu: %d\n", pppoe_mtu, mtu);
-
-	/* get PNC entries */
-	tpm_mtu_caculate_value_mask(mtu, g_tpm_mtu_cfg.sys_pkt_len_max);
-
-	new_pnc_entry_num = g_tpm_mtu_pnc_entry_tmp.pncEntryNum;
-
-	if ((TPM_UPSTREAM == direction) && (TPM_PPPOE_ADD_ENABLED == pppoe_add_enable)) {
-		/* pppoe_mtu to ipoe need to be calculate again */
-		tpm_mtu_caculate_value_mask(pppoe_mtu, mtu);
-		new_pnc_entry_num += g_tpm_mtu_pnc_entry_tmp.pncEntryNum;
-		new_pnc_entry_num += ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum;
-	} else {
-		new_pnc_entry_num += ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum;
-		new_pnc_entry_num += ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum;
-	}
-
-	TPM_OS_DEBUG(TPM_MTU_MOD, "new_pnc_entry_num: %d\n", new_pnc_entry_num);
-
-	if ((ethtype_pnc_cfg->rangeSize) < new_pnc_entry_num) {
-		TPM_OS_ERROR(TPM_MTU_MOD,
-			     "the new pnc entry number is bigger than the range size,  range size: %d, new size: %d\n",
-			     (ethtype_pnc_cfg->rangeSize), new_pnc_entry_num);
-
-		return TPM_FAIL;
-	}
-
-	if (TPM_UPSTREAM == direction) {
-		if (TPM_MTU_IPV4 == ethertype)
-			tpm_db_mtu_get_ipv4_mtu_us(&pre_mtu);
-		else
-			tpm_db_mtu_get_ipv6_mtu_us(&pre_mtu);
-
-		mtu_cfg = &ethtype_pnc_cfg->mtu_ipoe2max_us_cfg;
-	} else {
-		if (TPM_MTU_IPV4 == ethertype)
-			tpm_db_mtu_get_ipv4_mtu_ds(&pre_mtu);
-		else
-			tpm_db_mtu_get_ipv6_mtu_ds(&pre_mtu);
-
-		mtu_cfg = &ethtype_pnc_cfg->mtu_ds_cfg;
-	}
-
-	free_entry_number = (ethtype_pnc_cfg->rangeSize) -
-		(ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum + ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum
-		+ ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum);
-
-	if (TPM_DOWNSTREAM == direction) {
-		/* IN DS, ONLY mtu to max would be updated */
-		/* get PNC entries */
-		tpm_mtu_caculate_value_mask(mtu, g_tpm_mtu_cfg.sys_pkt_len_max);
-
-		/* update the PNC entry on HW */
-		int_ret_code = tpm_mtu_update_pnc(mtu_cfg,
-						  ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum +
-						  ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum, ethertype,
-						  direction, free_entry_number, false);
-
-		IF_ERROR(int_ret_code);
-
-		return TPM_OK;
-	}
-
-	/* IN US, both mtu to max and pppoe to mtu need to be updated */
-	if (pre_mtu > mtu) {
-		/* mtu getting smaller, handle mtu to max first */
-		/* get PNC entries */
-		tpm_mtu_caculate_value_mask(mtu, g_tpm_mtu_cfg.sys_pkt_len_max);
-
-		/* update the PNC entry on HW */
-		int_ret_code = tpm_mtu_update_pnc(mtu_cfg, ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum,
-						  ethertype, direction, free_entry_number, false);
-		IF_ERROR(int_ret_code);
-
-		/* handle pppoe to mtu */
-		if (TPM_PPPOE_ADD_DISABLED == pppoe_add_enable) {
-			/* no pppoe_mtu */
-			TPM_OS_DEBUG(TPM_MTU_MOD, "no pppoe_mtu, return\n");
-			return TPM_OK;
-		}
-
-		/* update free entry number */
-		free_entry_number = (ethtype_pnc_cfg->rangeSize) -
-			(ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum + ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum
-			+ ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum);
-
-		/* get PNC entries */
-		tpm_mtu_caculate_value_mask(pppoe_mtu, mtu);
-
-		/* update the PNC entry on HW */
-		int_ret_code =
-		    tpm_mtu_update_pnc(&(ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg), 0, ethertype, direction,
-				       free_entry_number, true);
-
-		IF_ERROR(int_ret_code);
-	} else {
-		/* mtu getting bigger, handle pppoe to mtu first */
-		if (TPM_PPPOE_ADD_ENABLED == pppoe_add_enable) {
-			/* no pppoe_mtu */
-			TPM_OS_DEBUG(TPM_MTU_MOD, " pppoe_mtu ENABLED, handle pppoe to mtu first\n");
-			/* get PNC entries */
-			tpm_mtu_caculate_value_mask(pppoe_mtu, mtu);
-
-			/* update the PNC entry on HW */
-			int_ret_code =
-				tpm_mtu_update_pnc(&(ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg), 0, ethertype, direction,
-						free_entry_number, true);
-
-			IF_ERROR(int_ret_code);
-		}
-
-		/* handle mtu to max */
-
-		/* update free entry number */
-		free_entry_number = (ethtype_pnc_cfg->rangeSize) -
-			(ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum + ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum
-			+ ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum);
-
-		/* get PNC entries */
-		tpm_mtu_caculate_value_mask(mtu, g_tpm_mtu_cfg.sys_pkt_len_max);
-
-		/* update the PNC entry on HW */
-		int_ret_code = tpm_mtu_update_pnc(mtu_cfg, ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum,
-						ethertype, direction, free_entry_number, false);
-
-		IF_ERROR(int_ret_code);
-	}
-
-	return TPM_OK;
-}
-
-uint32_t tpm_proc_set_pppoe_mtu(uint32_t ethertype, uint32_t direction, uint32_t pppoe_mtu)
-{
-	/*
-	   1. if ipv4_ mtu has been set,
-	   if  ipv4_pppoe_mtu > ipv4_mtu, generate a warning.
-	   else use algorism to get the PNC entries for (ipv4_pppoe_max to ipv4_mtu) with pppoe AI bits
-	   else
-	   use algorism to get the PNC entries for (ipv4_pppoe_max  to   tpm_max_pkt_len) with pppoe AI bits.
-
-	   2. if ipv4_mtu has been set, use algorism to get the PNC entries for
-	   (ipv4_mtu to tpm_mtu)
-
-	   3. if the PNC entries number for this two sets is bigger than the size of
-	   IPv4 len check range, return error and quit;
-
-	   4. if any of the two sets of PNC entries for pkt len check
-	   have already been set, , use the algorism in section 3.4 to update the PNC entries
-	 */
-
-	tpm_mtu_ethtype_pnc_cfg_t *ethtype_pnc_cfg;
-	uint32_t mtu_tmp;
-	uint32_t new_pnc_entry_num;
-	uint32_t free_entry_number;
-	tpm_db_mtu_setting_enable_t enable;
-	tpm_db_pppoe_add_enable_t pppoe_add_enable;
-
-	tpm_db_get_mtu_enable(&enable);
-	if (TPM_MTU_CHECK_DISABLED == enable) {
-		TPM_OS_WARN(TPM_MTU_MOD, "mtu check is not enabled!\n");
-		return TPM_OK;
-	}
-
-	tpm_db_get_pppoe_add_enable(&pppoe_add_enable);
-	if (TPM_PPPOE_ADD_DISABLED == pppoe_add_enable) {
-		TPM_OS_WARN(TPM_MTU_MOD, "pppoe mtu check is not enabled!\n");
-		return TPM_OK;
-	}
-
-	if (TPM_DOWNSTREAM == direction) {
-		/* no pppoe mtu in DS */
-		TPM_OS_WARN(TPM_MTU_MOD, " no pppoe mtu in DS\n");
-		return TPM_OK;
-	}
-
-	if (TPM_MTU_IPV4 == ethertype)
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv4_mtu_cfg);
-	else
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv6_mtu_cfg);
-
-	if (TPM_MTU_IPV4 == ethertype) {
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv4_mtu_cfg);
-		tpm_db_mtu_get_ipv4_mtu_us(&mtu_tmp);
-	} else {
-		ethtype_pnc_cfg = &(g_tpm_mtu_cfg.ipv6_mtu_cfg);
-		tpm_db_mtu_get_ipv6_mtu_us(&mtu_tmp);
-	}
-
-	if (MV_TPM_UN_INITIALIZED_INIT_PARAM == mtu_tmp) {
-		/* no ipoe mtu set */
-		mtu_tmp = g_tpm_mtu_cfg.sys_pkt_len_max;
-	}
-
-	if (pppoe_mtu >= mtu_tmp) {
-		/* pppoe_mtu is bigger than ipoe_mtu, does not make sense */
-		TPM_OS_WARN(TPM_MTU_MOD, "pppoe_mtu is bigger than ipoe_mtu, does not make sense\n");
-	}
-
-	TPM_OS_DEBUG(TPM_MTU_MOD, "pppoe_mtu: %d, ipoe_mtu: %d\n", pppoe_mtu, mtu_tmp);
-
-	/* get PNC entries */
-	tpm_mtu_caculate_value_mask(pppoe_mtu, mtu_tmp);
-
-	new_pnc_entry_num = ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum + ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum
-		+ g_tpm_mtu_pnc_entry_tmp.pncEntryNum;
-
-	if ((ethtype_pnc_cfg->rangeSize) < new_pnc_entry_num) {
-		/* the new pnc entry number is bigger than the range size
-		 */
-		TPM_OS_ERROR(TPM_MTU_MOD,
-				"the new pnc entry number is bigger than the range size,  range size: %d, new size: %d\n",
-				(ethtype_pnc_cfg->rangeSize), new_pnc_entry_num);
-
-		return TPM_FAIL;
-	}
-
-	free_entry_number = (ethtype_pnc_cfg->rangeSize) -
-		(ethtype_pnc_cfg->mtu_ipoe2max_us_cfg.pncEntryNum + ethtype_pnc_cfg->mtu_ds_cfg.pncEntryNum
-		+ ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg.pncEntryNum);
-
-	/* update the PNC entry on HW */
-	tpm_mtu_update_pnc(&ethtype_pnc_cfg->mtu_pppoe2ipoe_us_cfg, 0, ethertype, direction, free_entry_number, true);
-
-	if (TPM_MTU_IPV4 == ethertype)
-		tpm_db_mtu_set_ipv4_pppoe_mtu_us(pppoe_mtu);
-	else
-		tpm_db_mtu_set_ipv6_pppoe_mtu_us(pppoe_mtu);
-
-	return TPM_OK;
-}
-
-void tpm_mtu_set_mru(void)
-{
-	uint32_t mru = 1500;
-	tpm_db_pon_type_t pon_type;
-	uint32_t num_vlan_tags;
-	tpm_db_pppoe_add_enable_t pppoe_add_enable;
-	tpm_db_mtu_setting_enable_t mtu_enable;
-	tpm_gmacs_enum_t act_wan= tpm_db_active_wan_get();
-
-	tpm_db_pon_type_get(&pon_type);
-	tpm_db_get_num_vlan_tags(&num_vlan_tags);
-	tpm_db_get_mtu_enable(&mtu_enable);
-
-	tpm_db_get_pppoe_add_enable(&pppoe_add_enable);
-
-	if (TPM_ENUM_PMAC == act_wan){
-	switch (pon_type) {
-		case TPM_P2P:
-			mru = 2048;
-		break;
-
-		case TPM_EPON:
-			mru = 1593;
-			break;
-
-		case TPM_GPON:
-			/* [YuvalC] According to current info, for GPON 2048 bytes.
-		           define it 2032 for now, to be on the safe side. */
-			mru = 2032;
-			break;
-
-		default:
-			TPM_OS_WARN(TPM_MTU_MOD, "act_wan is PMAC but no valid pon_type (%d)\n", pon_type);
-			return;
-	}
-	} else if (TPM_ENUM_GMAC_0 == act_wan || TPM_ENUM_GMAC_1 == act_wan)
-		mru = 2048;
-
-	mru -= ((num_vlan_tags) * 4);
-
-	if (TPM_PPPOE_ADD_ENABLED == pppoe_add_enable && TPM_MTU_CHECK_DISABLED == mtu_enable) {
-		mru -= 8;
-		/*  This mru_reduction is only needed when mtu is disabled,
-		 */
-	}
-
-	tpm_db_set_mru(mru);
-
-}
-
-int32_t tpm_proc_mtu_check_cpu_queue_size(uint32_t queue)
-{
-	tpm_db_gmac_conn_t gmac_con;
-	uint32_t valid;
-	uint32_t queue_size;
-	/*tpm_db_pon_type_t pon_type; */
-
-	/* GMAC0 rx */
-	tpm_db_gmac_conn_get(TPM_ENUM_GMAC_0, &gmac_con);
-	if (TPM_GMAC_CON_DISC != gmac_con) {
-		tpm_db_gmac_rx_q_conf_get(TPM_ENUM_GMAC_0, queue, &valid, &queue_size);
-		if (0 == queue_size) {
-			TPM_OS_WARN(TPM_MTU_MOD, "cpu rx queue size is 0 from GMAC_0!\n");
-			return TPM_FAIL;
-		}
-	}
-
-	/* GMAC1 rx */
-	tpm_db_gmac_conn_get(TPM_ENUM_GMAC_1, &gmac_con);
-	if (TPM_GMAC_CON_DISC != gmac_con) {
-		tpm_db_gmac_rx_q_conf_get(TPM_ENUM_GMAC_1, queue, &valid, &queue_size);
-		if (0 == queue_size) {
-			TPM_OS_WARN(TPM_MTU_MOD, "cpu rx queue size is 0 from GMAC_1!\n");
-			return TPM_FAIL;
-		}
-	}
-
-	/* PMAC Rx */
-#if 0
-	tpm_db_pon_type_get(&pon_type);
-	if (TPM_GPON == pon_type || TPM_EPON == pon_type) {
-		/* do not need to check */
-		return TPM_OK;
-	}
-#endif
-	tpm_db_gmac_conn_get(TPM_ENUM_PMAC, &gmac_con);
-	if (TPM_GMAC_CON_DISC != gmac_con) {
-		tpm_db_gmac_rx_q_conf_get(TPM_ENUM_PMAC, queue, &valid, &queue_size);
-		if (0 == queue_size) {
-			TPM_OS_WARN(TPM_MTU_MOD, "cpu rx queue size is 0 from TPM_ENUM_PMAC!\n");
-			return TPM_FAIL;
-		}
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mtu_init(void)
-{
-	tpm_db_mtu_setting_enable_t enable;
-	tpm_db_pnc_range_conf_t range_conf;
-	int32_t ret_code;
-	int32_t mtu_tmp, cpu_rx_queue;
-
-	TPM_OS_DEBUG(TPM_MTU_MOD, "MTU init started!\n");
-
-	/* Phase I - set MRU */
-	tpm_mtu_set_mru();
-
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-	ret_code = tpm_proc_mtu_check_cpu_queue_size(cpu_rx_queue);
-	if (ret_code != TPM_OK) {
-		TPM_OS_WARN(TPM_MTU_MOD, "check_cpu_queue_size failed\n");
-		return TPM_FAIL;
-	}
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_LEN, &range_conf);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_WARN(TPM_MTU_MOD, " no ipv4 PNC range\n");
-		return TPM_FAIL;
-	}
-	tpm_db_get_mtu_enable(&enable);
-	if (TPM_MTU_CHECK_DISABLED == enable) {
-	/* range size smaller than 2, illegal */
-		if (range_conf.range_size < 2) {
-			TPM_OS_ERROR(TPM_INIT_MOD, "PNC range(%d) too small to be initialized, "
-						   "current size(%d). Min size should be 2 \n",
-				     TPM_PNC_IPV4_LEN, range_conf.range_size);
-			return TPM_FAIL;
-		} else if (range_conf.range_size > 2) {
-			TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) too big, current size(%d). "
-						  "it is a waste with MTU disabled, size should be 2\n",
-				    TPM_PNC_IPV4_LEN, range_conf.range_size);
-		}
-	} else {
-	/* range size smaller than 2, illegal */
-		if (range_conf.range_size <= 2) {
-			TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) too small to be initialized, size(%d) \n",
-				    TPM_PNC_IPV4_LEN, range_conf.range_size);
-			return TPM_FAIL;
-		}
-	}
-
-	/* create default rule for ipv4 packets */
-	tpm_mtu_ipv4_default_pnc_entry_insert();
-
-	/* Phase II - Set MTU entries, only if */
-	if (TPM_MTU_CHECK_DISABLED == enable) {
-		TPM_OS_WARN(TPM_MTU_MOD, "mtu check is not enabled!\n");
-		return TPM_OK;
-	}
-
-	memset(&g_tpm_mtu_cfg, 0, sizeof(g_tpm_mtu_cfg));
-	g_tpm_mtu_cfg.sys_pkt_len_max = 2048;
-
-	/* safety net is from 1536 to 2047 */
-	g_tpm_mtu_cfg.safety_net_value = 0x600;
-	g_tpm_mtu_cfg.safety_net_mask = 0xfe00;
-
-	/*************************************************/
-	/* IPv4 MTU init                                 */
-	/*************************************************/
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_LEN, &range_conf);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_WARN(TPM_MTU_MOD, " no ipv4 PNC range\n");
-		return TPM_FAIL;
-	}
-	/* range size smaller than 2, illegal */
-	if (range_conf.range_size <= 2) {
-		TPM_OS_WARN(TPM_INIT_MOD, "PNC range(%d) too small to be initialized, size(%d) \n", TPM_PNC_IPV4_LEN,
-			    range_conf.range_size);
-		return TPM_FAIL;
-	}
-
-	/* we need to reserve 3 PNC entry for default and safety net     */
-	g_tpm_mtu_cfg.ipv4_mtu_cfg.rangeSize = range_conf.range_size - 3;
-
-	/*************************************************/
-	/* IPv6 MTU init                                 */
-	/*************************************************/
-#if 0
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_LEN, &range_conf);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_WARN(TPM_MTU_MOD, " no ipv6 PNC range\n");
-		return TPM_FAIL;
-	}
-	if (range_conf.range_size <= 2) {
-		TPM_OS_WARN(TPM_MTU_MOD, "PNC range(%d) too small to be initialized, size(%d) \n", TPM_PNC_IPV6_LEN,
-			    range_conf.range_size);
-		return TPM_FAIL;
-	}
-#endif
-	/* we need to reserve 3 PNC entry for default and safety net     */
-	g_tpm_mtu_cfg.ipv6_mtu_cfg.rangeSize = range_conf.range_size - 3;
-
-	/*tpm_mtu_ipv6_default_pnc_entry_insert(); */
-
-	/* set ipv4 US */
-	tpm_db_mtu_get_ipv4_mtu_us(&mtu_tmp);
-	tpm_proc_set_mtu(TPM_MTU_IPV4, TPM_UPSTREAM, mtu_tmp);
-	tpm_db_mtu_get_ipv4_pppoe_mtu_us(&mtu_tmp);
-	tpm_proc_set_pppoe_mtu(TPM_MTU_IPV4, TPM_UPSTREAM, mtu_tmp);
-
-	/* set ipv6 US
-	   tpm_db_mtu_get_ipv6_mtu_us(&mtu_tmp);
-	   tpm_proc_set_mtu(TPM_MTU_IPV6, TPM_UPSTREAM, mtu_tmp);
-	   tpm_db_mtu_get_ipv6_pppoe_mtu_us(&mtu_tmp);
-	   tpm_proc_set_pppoe_mtu(TPM_MTU_IPV6, TPM_UPSTREAM, mtu_tmp);
-	 */
-
-	/* set ipv4 DS */
-	tpm_db_mtu_get_ipv4_mtu_ds(&mtu_tmp);
-	tpm_proc_set_mtu(TPM_MTU_IPV4, TPM_DOWNSTREAM, mtu_tmp);
-
-	/* set ipv6 DS
-	   tpm_db_mtu_get_ipv6_mtu_ds(&mtu_tmp);
-	   tpm_proc_set_mtu(TPM_MTU_IPV6, TPM_DOWNSTREAM, mtu_tmp);
-	 */
-
-	return TPM_OK;
-}
-
-int32_t tpm_mtu_get_pnc_entry_from_index(int32_t index)
-{
-	int32_t loop;
-
-	for (loop = 0; loop < g_tpm_mtu_cfg.ipv4_mtu_cfg.pncIndex_cfg.pncNumber; loop++) {
-		if (index == g_tpm_mtu_cfg.ipv4_mtu_cfg.pncIndex_cfg.pncIndex[loop])
-			return loop;
-	}
-
-	return 0;
-}
-
-void tpm_mtu_print_len_chk_entry(tpm_mtu_pnc_entries_t *mtu_pnc_entries)
-{
-	int32_t entry_number;
-	int32_t loop, int_ret_code;
-	tpm_db_pnc_range_t range_data;
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_LEN, &range_data);
-	if (TPM_OK != int_ret_code) {
-		printk(KERN_WARNING "there is no Len check range\n");
-		return;
-	}
-
-	for (loop = 0; loop < mtu_pnc_entries->pncEntryNum; loop++) {
-		entry_number = tpm_mtu_get_pnc_entry_from_index(mtu_pnc_entries->pncIndex[loop]);
-		entry_number += range_data.pnc_range_conf.range_start;
-		printk("PNC entry number: %d\n", entry_number);
-		printk("length start: %d\n", mtu_pnc_entries->pktValue[loop]);
-		tpm_mtu_printBinary(mtu_pnc_entries->pktValue[loop]);
-		printk("\n");
-		tpm_mtu_printBinary(mtu_pnc_entries->pktMask[loop]);
-		printk("\n");
-	}
-
-}
-
-void tpm_mtu_print_len_chk_range(void)
-{
-	printk("==========================\n");
-	printk(" TPM IPv4 Length Check Range                \n");
-	printk("==========================\n");
-	printk(" Range size                        : %d\n", g_tpm_mtu_cfg.ipv4_mtu_cfg.rangeSize);
-	printk(" Current PNC entry number: %d\n", g_tpm_mtu_cfg.ipv4_mtu_cfg.pncIndex_cfg.pncNumber);
-
-	printk("__________________________\n");
-	printk("US pppoe to ipoe\n");
-	tpm_mtu_print_len_chk_entry(&g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_pppoe2ipoe_us_cfg);
-	printk("__________________________\n");
-	printk("US ipoe to max length \n");
-	tpm_mtu_print_len_chk_entry(&g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_ipoe2max_us_cfg);
-	printk("__________________________\n");
-	printk("DS ipoe to max length \n");
-	tpm_mtu_print_len_chk_entry(&g_tpm_mtu_cfg.ipv4_mtu_cfg.mtu_ds_cfg);
-	printk("__________________________\n");
-
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.h
deleted file mode 100644
index 82c7836..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_mtu.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_mtu.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   jinghua
-*
-* DATE CREATED: 17 Aug 2011
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.2
-*
-*
-*******************************************************************************/
-#ifndef _TPM_MTU_H_
-#define _TPM_MTU_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-
-#define GET_BIT(VALUE, I)		((VALUE) & (1 << (I)))
-
-#define TPM_MTU_MAX_PNC_ENTRY_NUM	25
-
-typedef struct {
-	uint32_t pncEntryNum;
-	uint32_t pktMask[TPM_MTU_MAX_PNC_ENTRY_NUM];
-	uint32_t pktValue[TPM_MTU_MAX_PNC_ENTRY_NUM];
-	uint32_t pncIndex[TPM_MTU_MAX_PNC_ENTRY_NUM];
-} tpm_mtu_pnc_entries_t;
-
-typedef struct {
-	uint32_t pncNumber;
-	uint32_t pncIndex[3 * TPM_MTU_MAX_PNC_ENTRY_NUM];
-} tpm_mtu_pnc_index_t;
-
-typedef struct {
-	uint32_t rangeSize;
-	tpm_mtu_pnc_index_t pncIndex_cfg;
-	tpm_mtu_pnc_entries_t mtu_pppoe2ipoe_us_cfg;
-	tpm_mtu_pnc_entries_t mtu_ipoe2max_us_cfg;
-	tpm_mtu_pnc_entries_t mtu_ds_cfg;
-} tpm_mtu_ethtype_pnc_cfg_t;
-
-typedef struct {
-	uint32_t sys_pkt_len_max;
-	uint32_t safety_net_value;
-	uint32_t safety_net_mask;
-	tpm_mtu_ethtype_pnc_cfg_t ipv4_mtu_cfg;
-	tpm_mtu_ethtype_pnc_cfg_t ipv6_mtu_cfg;
-} tpm_mtu_pnc_cfg_t;
-
-/*************************************************************/
-/*               APIs                                        */
-/*************************************************************/
-
-int32_t tpm_proc_mtu_init(void);
-
-uint32_t tpm_proc_set_pppoe_mtu(uint32_t ethertype, uint32_t direction, uint32_t pppoe_mtu);
-uint32_t tpm_proc_set_mtu(uint32_t ethertype, uint32_t direction, uint32_t mtu);
-void tpm_mtu_print_len_chk_range(void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_PNCL_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.c
deleted file mode 100644
index bc6c47a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.c
+++ /dev/null
@@ -1,17890 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/*******************************************************************************
-* tpm_pkt_proc_logic.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.7
-*
-*
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-/* Local definitions */
-extern MV_STATUS mv_cust_set_tcont_state(uint32_t tcont, bool state);
-
-typedef tpm_error_code_t (*tpm_proc_common_int_del_func_t) (uint32_t, uint32_t);
-
-int32_t tpm_proc_virt_uni_trg_port_validation(tpm_trg_port_type_t trg_port);
-
-
-
-#define IPV6_MOD(mod_bm)		(mod_bm & (TPM_IPV6_UPDATE | TPM_HOPLIM_DEC | TPM_IPV6_DST_SET | TPM_IPV6_SRC_SET))
-#define IPV4_MOD(mod_bm)		(mod_bm & (TPM_IPV4_UPDATE | TPM_TTL_DEC | TPM_IPV4_DST_SET | TPM_IPV4_SRC_SET))
-
-#define L4_CHECK_MOD(mod_bm)		((mod_bm & TPM_IPV4_DST_SET) || (mod_bm & TPM_IPV4_SRC_SET) || \
-						(mod_bm & TPM_L4_DST_SET) || (mod_bm & TPM_L4_SRC_SET))
-
-#define PARSE_FLAG_CHECK(val, bit)  ((val >> bit) & TPM_PARSE_FLAG_CHECK_TRUE_FALSE)
-
-#define IF_ERROR(ret)	\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " recvd ret_code(%d)\n", ret);\
-			return(ret);\
-		}
-#define IF_ERROR_I(ret, i)	\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " recvd ret_code(%d), ind(%d)\n", ret, i);\
-			return(ret);\
-		}
-
-#define MULTI_IP_2_MAC(macAdd, multiIp)		((uint8_t *)(macAdd))[0] = (uint8_t) 0x01;  \
-						((uint8_t *)(macAdd))[1] = (uint8_t) 0x00;  \
-						((uint8_t *)(macAdd))[2] = (uint8_t) 0x5e;  \
-						((uint8_t *)(macAdd))[3] = (uint8_t) multiIp[1];   \
-						((uint8_t *)(macAdd))[4] = (uint8_t) multiIp[2];   \
-						((uint8_t *)(macAdd))[5] = (uint8_t) multiIp[3];
-#define MULTI_IPV6_2_MAC(macAdd, multiIp)	((uint8_t *)(macAdd))[0] = (uint8_t) 0x33;  \
-						((uint8_t *)(macAdd))[1] = (uint8_t) 0x33;  \
-						((uint8_t *)(macAdd))[2] = (uint8_t) multiIp[12];  \
-						((uint8_t *)(macAdd))[3] = (uint8_t) multiIp[13];   \
-						((uint8_t *)(macAdd))[4] = (uint8_t) multiIp[14];   \
-						((uint8_t *)(macAdd))[5] = (uint8_t) multiIp[15];
-
-#define NO_FREE_ENTRIES()	\
-		if (free_entries == 0) {\
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No free entries\n");\
-			return(TPM_FAIL);\
-		}
-
-/* Local variables */
-
-spinlock_t tpm_proc_api_call_lock;
-
-static tpm_cpu_loopback_t gs_cpu_loopback[TPM_MAX_CPU_LOOPBACK_NUM];
-static uint32_t gn_cpu_lpbk_entry_num = 0;
-
-static uint8_t tpm_igmp_gen_query_mac[6] = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x01};
-static uint8_t tpm_mld_gen_query_mac[6] = { 0x33, 0x33, 0x00, 0x00, 0x00, 0x01};
-
-/* Bitmap of PNC port_ids */
-static uint32_t gmac_pnc_bm[3] = { TPM_BM_GMAC_0, TPM_BM_GMAC_1, TPM_BM_PMAC};
-
-tpm_hot_swap_acl_recovery_t tpm_hot_swap_acl_recovery[] = {
-	{TPM_API_MAC_LEARN,        tpm_acl_rcvr_func_mac_learn},
-	{TPM_API_DS_LOAD_BALANCE,  tpm_acl_rcvr_func_ds_load_balance},
-	{TPM_API_CPU_LOOPBACK,     tpm_acl_rcvr_func_cpu_loopback},
-	{TPM_API_L2_PRIM,          tpm_acl_rcvr_func_l2_prim},
-	{TPM_API_L3_TYPE,          tpm_acl_rcvr_func_l3_type},
-	{TPM_API_IPV4,             tpm_acl_rcvr_func_ipv4},
-	{TPM_API_IPV4_MC,          tpm_acl_rcvr_func_ipv4_mc},
-	{TPM_API_IPV6_GEN,         tpm_acl_rcvr_func_ipv6_gen},
-	{TPM_API_IPV6_DIP,         tpm_acl_rcvr_func_ipv6_dip},
-	{TPM_API_IPV6_MC,          tpm_acl_rcvr_func_ipv6_mc},
-	{TPM_API_IPV6_NH,          tpm_acl_rcvr_func_ipv6_nh},
-	{TPM_API_IPV6_L4,          tpm_acl_rcvr_func_ipv6_l4},
-	{TPM_API_CNM,              tpm_acl_rcvr_func_cnm},
-
-};
-
-
-static tpm_api_sup_param_val_t api_sup_param_val[] = {
-	/* tpm_pnc_api_num		Supported parse field bits
-		Supported parse flag bits
-		Forbidden actions */
-	{TPM_ADD_DS_LOAD_BALANCE_RULE,	TPM_DS_LOAD_BALNC_PARSE_BM_MASK,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_TAG2_MASK),
-		(0)},
-	{TPM_ADD_L2_PRIM_ACL_RULE,      TPM_L2_PARSE_BM_MASK,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_TAG2_MASK),
-		(0)},
-	{TPM_ADD_L3_TYPE_ACL_RULE,      TPM_L3_PARSE_BM_MASK,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_TAG2_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV4_ACL_RULE, TPM_IPV4_PARSE_BM_MASK,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_NH_ACL_RULE,      0,
-		(TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_GEN_ACL_RULE, TPM_IPV6_GEN_BM_MASK,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_DIP_ACL_RULE, TPM_IPv6_PARSE_DIP,
-		(TPM_PARSE_FLAG_TAG1_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_L4_PORTS_ACL_RULE, TPM_IPV6_L4_BM_MASK,
-		(TPM_PARSE_FLAG_L4P_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_GEN_5T_RULE, TPM_IPV6_GEN_BM_MASK | TPM_IPV6_L4_BM_MASK,
-		(TPM_PARSE_FLAG_L4P_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_DIP_5T_RULE, TPM_IPv6_PARSE_DIP | TPM_IPV6_GEN_BM_MASK | TPM_IPV6_L4_BM_MASK,
-		(TPM_PARSE_FLAG_L4P_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-	{TPM_ADD_IPV6_L4_PORTS_5T_RULE, TPM_IPV6_L4_BM_MASK,
-		(TPM_PARSE_FLAG_L4P_MASK | TPM_PARSE_FLAG_PPPOE_MASK | TPM_PARSE_FLAG_MTM_MASK | TPM_PARSE_FLAG_TO_CPU_MASK),
-		(TPM_ACTION_MTM | TPM_ACTION_SPEC_MC_VID)},
-};
-
-
-/* Function Declarations */
-int32_t tpm_proc_calc_cnm_rule_num(tpm_src_port_type_t src_port, uint32_t precedence, uint32_t *rule_num);
-
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_triple_key_rule(tpm_src_port_type_t src_port, uint32_t partner_key_bm, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule(tpm_src_port_type_t src_port, uint32_t partner_key_bm, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_single_key_rule(tpm_src_port_type_t src_port, uint32_t partner_key_bm, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_triple_key_rule(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t key_pattern, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t key_pattern, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_single_key_rule(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t key_pattern, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-int32_t tpm_proc_del_cnm_ipv4_pre_filter_rule(uint32_t src_port, uint32_t key_pattern, uint32_t key_idx);
-
-tpm_cnm_ipv4_pre_filter_rule_oper_t gs_cnm_ipv4_pre_filter_rule_oper[TPM_CNM_IPV4_PRE_FILTER_KEY_MAX][TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_KEY] =
-{
-	/* TPM_CNM_IPV4_PRE_FILTER_KEY_1 */
-	{
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-	},
-
-	/* TPM_CNM_IPV4_PRE_FILTER_KEY_2 */
-	{
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-	},
-
-	/* TPM_CNM_IPV4_PRE_FILTER_KEY_3 */
-	{
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_triple_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_1_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_2_MASK|TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-		{
-			TPM_CNM_IPV4_PRE_FILTER_KEY_3_MASK,
-			tpm_proc_check_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_add_cnm_ipv4_pre_filter_single_key_rule,
-			tpm_proc_del_cnm_ipv4_pre_filter_rule,
-		},
-	},
-
-};
-
-uint32_t sg_l2_cnm_prec_ind[TPM_MAX_NUM_CTC_PRECEDENCE] = {0x0, 0x0, 0x0, 0x1, 0x1, 0x3, 0x3, 0x7};
-uint32_t sg_ipv4_cnm_prec_mask[TPM_MAX_NUM_CTC_PRECEDENCE] = {0x0, 0x0, 0x1, 0x1, 0x2, 0x2, 0x4, 0x4};
-
-
-/* Local Functions */
-
-/* Function Declarations */
-tpm_error_code_t tpm_owner_id_check(tpm_api_type_t api_type, uint32_t owner_id);
-int32_t tpm_proc_multicast_reset(void);
-
-uint32_t tpm_proc_bc_check(tpm_l2_acl_key_t *l2_key)
-{
-	uint32_t i;
-
-	for (i = 0; i < 6; i++) {
-		if ((l2_key->mac.mac_da[i] & l2_key->mac.mac_da_mask[i]) != 0xFF)
-			return(TPM_FALSE);
-	}
-
-	return(TPM_TRUE);
-}
-
-
-uint32_t tpm_proc_mc_check(tpm_l2_acl_key_t *l2_key)
-{
-
-	if ((l2_key->mac.mac_da[0] & l2_key->mac.mac_da_mask[0]) & 0x01)
-		return(TPM_TRUE);
-
-	return(TPM_FALSE);
-}
-
-/*******************************************************************************
-* tpm_proc_src_port_gmac_bm_map()
-*
-* DESCRIPTION:    The function correlates a source_port to it's Rx GMAC(s) by means of the GMAC Functionality
-*
-*
-* INPUTS:
-* src_port         - source port in API format
-*
-* OUTPUTS:
-* gmac_bm          - Bitmap of the GMACs relevant to set in TCAM
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_src_port_gmac_bm_map(tpm_src_port_type_t src_port,
-				      tpm_gmac_bm_t *gmac_bm)
-{
-	tpm_gmacs_enum_t gmac_i;
-	tpm_gmac_bm_t l_gmac_bm = 0;
-	tpm_db_gmac_func_t gmac_func;
-	tpm_init_gmac_conn_conf_t gmac_port_conf;
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i <= TPM_MAX_GMAC; gmac_i++) {
-		if (!tpm_db_gmac_valid(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-
-		/* WAN possiblilties */
-		if (FROM_WAN(src_port) && GMAC_IS_WAN(gmac_func))
-			l_gmac_bm |= gmac_pnc_bm[gmac_i];
-
-		/* LAN possiblilties  (Note: can be from both WAN or LAN) */
-
-		/* From UNI_$, include UNI_virt Port */
-		if (FROM_SPEC_UNI(src_port) && GMAC_IS_LAN(gmac_func)) {
-			l_gmac_bm |= gmac_pnc_bm[gmac_i];
-			//break;
-		/* Any remaining LAN option (UNI_ANY or WAN_OR_LAN) */
-		} else if (FROM_LAN(src_port) && (GMAC_IS_UNI_LAN(gmac_func) || GMAC_IS_LAN(gmac_func))) {
-			if (GMAC_IS_UNI_LAN(gmac_func)) {
-				if (tpm_db_gmac_conn_conf_get(gmac_i, &gmac_port_conf)) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "gmac(%d) connection info get fail\n", gmac_i);
-					return(TPM_FAIL);
-				}
-				if (src_port == gmac_port_conf.port_src) {
-					l_gmac_bm |= gmac_pnc_bm[gmac_i];
-					break;
-				} else if (src_port == TPM_SRC_PORT_UNI_ANY) {
-					l_gmac_bm |= gmac_pnc_bm[gmac_i];
-				}
-			} else {
-				l_gmac_bm |= gmac_pnc_bm[gmac_i];
-			}
-		}
-	}
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "gmac_bm(0x%x)\n", l_gmac_bm);
-	*gmac_bm = l_gmac_bm;
-	return(TPM_OK);
-}
-
-void tpm_proc_set_int_structs(tpm_pncl_pnc_full_t *pnc_data, tpm_pncl_offset_t *start_offset,
-			      tpm_rule_entry_t *api_data, tpm_db_pnc_conn_t *pnc_conn,
-			      tpm_db_pnc_range_t *range_data)
-{
-	/* Set Structs to zero */
-	memset(pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(api_data, 0, sizeof(tpm_rule_entry_t));
-	memset(pnc_conn, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	return;
-}
-
-int32_t tpm_proc_create_acl_pnc_entry(tpm_api_sections_t api_section, uint32_t rule_num,
-				      tpm_pncl_pnc_full_t *pnc_data, uint32_t *pnc_entry, uint32_t *api_rng_entries)
-{
-
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_id;
-	uint32_t pnc_range_start, api_start, pnc_stop_entry, l_api_rng_entries;
-	int32_t int_ret_code;
-
-	/* Get pnc_range_id */
-	int_ret_code = tpm_db_api_section_main_pnc_get(api_section, &pnc_range_id);
-	IF_ERROR(int_ret_code);
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(pnc_range_id, &range_data);
-	IF_ERROR(int_ret_code);
-
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Get number of existing api entries */
-	int_ret_code = tpm_db_api_section_num_entries_get(api_section, &l_api_rng_entries);
-	IF_ERROR(int_ret_code);
-
-	/* Calculate absolute PNC entry number to execute */
-	*pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d), l_api_rng_entries(%d)\n", rule_num, l_api_rng_entries);
-
-	/* Call PNC Entry Insert, if this is not the api_section's new last entry */
-	if (rule_num < l_api_rng_entries) {
-		pnc_stop_entry = (pnc_range_start + api_start) + (l_api_rng_entries - 1);
-		int_ret_code = tpm_pncl_entry_insert(*pnc_entry, pnc_stop_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-	} else {		/* Otherwise just set the entry (no insertion) */
-
-		int_ret_code = tpm_pncl_entry_set(*pnc_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-	}
-
-	/* Decrease number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(pnc_range_id);
-	IF_ERROR(int_ret_code);
-
-	*api_rng_entries = l_api_rng_entries;
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_create_table_pnc_entry(tpm_api_sections_t api_section, uint32_t rule_num, uint32_t update_sram,
-					tpm_pncl_pnc_full_t *pnc_data, uint32_t *pnc_entry,
-					uint32_t *api_rng_entries)
-{
-
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_id;
-	uint32_t pnc_range_start, api_start, l_api_rng_entries;
-	int32_t int_ret_code;
-
-	/* Get pnc_range_id */
-	int_ret_code = tpm_db_api_section_main_pnc_get(api_section, &pnc_range_id);
-	IF_ERROR(int_ret_code);
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(pnc_range_id, &range_data);
-	IF_ERROR(int_ret_code);
-
-	/* check the rule_number */
-	if (rule_num > range_data.pnc_range_conf.api_end) {
-		/* rule_number out of range */
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " rule_num(%d) out of range, range api_end(%d)\n",
-			     rule_num, range_data.pnc_range_conf.api_end);
-		return(TPM_FAIL);
-	}
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Get number of existing api entries */
-	int_ret_code = tpm_db_api_section_num_entries_get(api_section, &l_api_rng_entries);
-	IF_ERROR(int_ret_code);
-
-	/* Calculate absolute PNC entry number to execute */
-	*pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d), l_api_rng_entries(%d)\n", rule_num, l_api_rng_entries);
-
-	if (update_sram) {
-		/* Just update sram  */
-		int_ret_code = tpm_pncl_update_sram(*pnc_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-	} else {
-		/* Just set the entry (no insertion) */
-		int_ret_code = tpm_pncl_entry_set(*pnc_entry, pnc_data);
-		IF_ERROR(int_ret_code);
-
-		/* Decrease number of free entries in pnc_range */
-		int_ret_code = tpm_db_pnc_rng_free_ent_dec(pnc_range_id);
-		IF_ERROR(int_ret_code);
-	}
-
-	*api_rng_entries = l_api_rng_entries;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_trg_port_gmac_map()
-*
-* DESCRIPTION:    The function correlates a source_port to it's Rx GMAC(s) by means of the GMAC Functionality
-*
-*
-* INPUTS:
-* trg_port         - source port in API format
-*
-* OUTPUTS:
-* gmac_port        - Target GMAC
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_trg_port_gmac_map(tpm_trg_port_type_t trg_port, tpm_gmacs_enum_t *gmac_port)
-{
-	tpm_gmacs_enum_t gmac_i;
-	tpm_db_gmac_func_t gmac_func;
-	tpm_init_gmac_conn_conf_t gmac_port_conf;
-
-	if (gmac_port == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid pointer-NULL \n");
-		return(ERR_GENERAL);
-	}
-
-	(*gmac_port) = -1;
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i <= TPM_MAX_GMAC; gmac_i++) {
-		if (!tpm_db_gmac_valid(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-		if (tpm_db_gmac_conn_conf_get(gmac_i, &gmac_port_conf)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "gmac(%d) connection info get fail\n", gmac_i);
-			return(TPM_FAIL);
-		}
-		/* TRG WAN */
-		if ((TRG_WAN(trg_port)) && GMAC_IS_WAN(gmac_func)) {
-			(*gmac_port) = gmac_i;
-			break;
-		/* TRG GMAC_UNI, such as MC lpk, dual gmac uni */
-		} else if (TRG_UNI(trg_port) && (GMAC_IS_UNI_LAN(gmac_func) || GMAC_IS_DS_UNI_LAN(gmac_func))) {
-			if ((gmac_port_conf.port_src != TPM_SRC_PORT_ILLEGAL) &&
-			    ((trg_port == (1 << (gmac_port_conf.port_src + TPM_TRG_UNI_OFFSET))) ||
-			     (trg_port == TPM_TRG_PORT_UNI_ANY))) {
-				(*gmac_port) = gmac_i;
-				break;
-			}
-		/* TRG UNI, such as KW2 */
-		} else if (TRG_UNI(trg_port) && GMAC_IS_LAN(gmac_func)) {
-			(*gmac_port) = gmac_i;
-			break;
-		}
-	}
-	return(TPM_OK);
-}
-
-uint32_t tpm_proc_gmac1_phy_src_port(tpm_src_port_type_t src_port)
-{
-	tpm_db_gmac_func_t gmac_func;
-
-	if (src_port == TPM_SRC_PORT_UNI_VIRT) {
-		tpm_db_gmac_func_get(TPM_ENUM_GMAC_1, &gmac_func);
-		if (gmac_func != TPM_GMAC_FUNC_VIRT_UNI)
-			return(TPM_TRUE);
-	}
-
-	return(TPM_FALSE);
-}
-
-/*******************************************************************************
-* tpm_proc_all_gmac_bm()
-*
-* DESCRIPTION:  Gets a TCAMport_bitmap of all active GMACs
-*
-* INPUTS:
-*
-* RETURNS:
-* Returns a bitmap of all the active GMACs
-*
-* COMMENTS:  Perfom only DB integrity checks, not data correctness checks
-*
-*******************************************************************************/
-uint32_t tpm_proc_all_gmac_bm(void)
-{
-	tpm_gmacs_enum_t gmac_i;
-	tpm_gmac_bm_t l_gmac_bm = 0;
-	tpm_db_gmac_func_t gmac_func;
-
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i <= TPM_MAX_GMAC; gmac_i++) {
-		if (!tpm_db_gmac_valid(gmac_i))
-			continue;
-
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-
-		if (gmac_func != TPM_GMAC_FUNC_NONE)
-			l_gmac_bm |= gmac_pnc_bm[gmac_i];
-	}
-	return(l_gmac_bm);
-}
-
-int32_t tpm_proc_delete_mod(tpm_mod_owner_t owner, tpm_gmacs_enum_t gmac_port, uint32_t mod_entry)
-{
-	tpm_gmacs_enum_t  duplicate_gmac;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-	int32_t ret_code;
-
-	ret_code = tpm_mod2_entry_del(owner, gmac_port, mod_entry);
-	IF_ERROR(ret_code);
-
-	/* when ds load balance on G0 and G1 is enabled, need to duplicate DS PMT on G0/1 */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	if (	(TPM_DS_MAC_BASED_TRUNK_DISABLED == ds_mac_based_trunk_enable)
-	     || ((gmac_port != TPM_ENUM_GMAC_0) && (gmac_port != TPM_ENUM_GMAC_1))) {
-		/* if this is US or DS_MAC_BASED_TRUNK is DISABLED, do nothing */
-		return(TPM_OK);
-	}
-
-	if (gmac_port == TPM_ENUM_GMAC_0)
-		duplicate_gmac = TPM_ENUM_GMAC_1;
-	else
-		duplicate_gmac = TPM_ENUM_GMAC_0;
-
-	ret_code = tpm_mod2_entry_del(owner, duplicate_gmac, mod_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_create_mod(tpm_pkt_action_t pkt_act, tpm_trg_port_type_t trg_port, tpm_pkt_mod_t *pkt_mod,
-			    tpm_pkt_mod_bm_t pkt_mod_bm, tpm_pkt_mod_int_bm_t int_mod_bm, uint32_t *mod_entry,
-			    uint32_t *trg_gmac)
-{
-	int32_t ret_code;
-	tpm_gmacs_enum_t  duplicate_gmac;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	if (SET_MOD(pkt_act)) {
-		/* Currently supporting Vlan operation only */
-		/* Get dest. gmac */
-		if (TPM_TRG_LOAD_BAL & trg_port) {
-			/* DS load balance, set trg port to G1 */
-			*trg_gmac = TPM_ENUM_GMAC_1;
-		} else {
-			tpm_proc_trg_port_gmac_map(trg_port, trg_gmac);
-			if (*trg_gmac == -1) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "pkt modification not possible on this target gmac(%d) \n",
-					     *trg_gmac);
-				return(ERR_ACTION_INVALID);
-			}
-		}
-		ret_code = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, *trg_gmac, pkt_mod_bm, int_mod_bm, pkt_mod, mod_entry);
-		IF_ERROR(ret_code);
-
-		/* when ds load balance on G0 and G1 is enabled, need to duplicate DS PMT on G0/1 */
-		tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-		if (    (TPM_DS_MAC_BASED_TRUNK_DISABLED == ds_mac_based_trunk_enable)
-		     || (TRG_WAN(trg_port))) {
-		     /* if this is US or DS_MAC_BASED_TRUNK is DISABLED, do nothing */
-			return(TPM_OK);
-		}
-
-		if (*trg_gmac == TPM_ENUM_GMAC_0)
-			duplicate_gmac = TPM_ENUM_GMAC_1;
-		else if (*trg_gmac == TPM_ENUM_GMAC_1)
-			duplicate_gmac = TPM_ENUM_GMAC_0;
-		else {
-			TPM_OS_INFO(TPM_TPM_LOG_MOD, "target gmac(%d) invalid\n", *trg_gmac);
-			return(TPM_OK);
-		}
-
-		ret_code = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, duplicate_gmac,
-						pkt_mod_bm, int_mod_bm, pkt_mod, mod_entry);
-		IF_ERROR(ret_code);
-	}
-	return(TPM_OK);
-}
-
-void tpm_proc_set_api_moddata(tpm_pkt_action_t pkt_act, uint32_t trg_gmac, tpm_db_mod_conn_t *mod_con,
-			      uint32_t mod_entry)
-{
-	/* Set modification data in API data */
-	if (SET_MOD(pkt_act)) {
-		mod_con->mod_cmd_ind = mod_entry;
-		mod_con->mod_cmd_mac = trg_gmac;
-	} else {
-		mod_con->mod_cmd_ind = 0;
-		mod_con->mod_cmd_mac = TPM_INVALID_GMAC;
-	}
-	return;
-}
-
-int32_t tpm_proc_check_missing_data(tpm_rule_action_t *rule_action,
-				    tpm_pkt_mod_t *pkt_mod,
-				    tpm_pkt_frwd_t *pkt_frwd,
-				    void *parsing_key,
-				    tpm_pkt_action_t pkt_act,
-				    tpm_parse_fields_t parse_rule_bm)
-{
-
-	/* Check keys exist for parse fields */
-	if (rule_action == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "rule_action cannot be NULL\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_mod == NULL) && (SET_MOD(pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Mod requested with NULL pointer\n");
-		return(ERR_MOD_INVALID);
-	}
-
-	if ((pkt_frwd == NULL) && ((SET_TARGET_PORT(pkt_act)) || SET_TARGET_QUEUE(pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target set requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	if ((parsing_key == NULL) && (parse_rule_bm != 0)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parsing requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_check_valid_target(tpm_dir_t dir,
-				    tpm_db_pon_type_t pon_type,
-				    tpm_src_port_type_t src_port,
-				    tpm_trg_port_type_t trg_port,
-				    uint8_t trg_queue,
-				    tpm_pkt_action_t pkt_act,
-				    uint8_t ds_load_bal_valid)
-{
-
-	tpm_init_virt_uni_t virt_uni_info;
-	int32_t ret_code;
-	uint32_t rx_queue_valid, rx_queue_size;
-	tpm_gmac_bm_t gmac_bm;
-	tpm_gmacs_enum_t gmac;
-	uint32_t tx_queue_valid, tx_queue_size;
-	tpm_db_txq_owner_t tx_owner;
-	tpm_db_tx_mod_t tx_port;
-	tpm_gmacs_enum_t act_wan= tpm_db_active_wan_get();
-
-	/* Check Valid Target */
-	if (SET_TARGET_PORT(pkt_act)) {
-		if (TO_PON(dir, trg_port, pon_type, act_wan) ||
-		    TO_ETHWAN(dir, trg_port, act_wan) || TO_CPU(trg_port)) {
-		    /* PON CPU is OK */
-		} else if (TO_LAN(dir, trg_port)){
-			/* check target uni port valid or not */
-			ret_code = tpm_proc_check_dst_uni_port(trg_port);
-			IF_ERROR(ret_code);
-
-			/* check ds load balance trg */
-			if (trg_port & TPM_TRG_LOAD_BAL) {
-				if (!ds_load_bal_valid) {
-					/* TPM_TRG_LOAD_BAL should not be set */
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "TPM_TRG_LOAD_BAL should not be set\n");
-					return(ERR_FRWD_INVALID);
-				}
-				if (!tpm_db_ds_load_bal_en_get()) {
-					/* profile dose not support TPM_TRG_LOAD_BAL */
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "profile dose not support TPM_TRG_LOAD_BAL\n");
-					return(ERR_FRWD_INVALID);
-				}
-			}
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "* dir=%d, trg_port=%d, pon_type=%d *\r\n", dir, trg_port,
-				     pon_type);
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Illegal Target Port\n");
-			return(ERR_FRWD_INVALID);
-		}
-	}
-	/* check valid target when virt uni via GMAC1 feature is enabled */
-	/* not all target port combinations are supported when WiFi via GMAC1 = UNI_4 feature is enabled */
-	ret_code = tpm_db_virt_info_get(&virt_uni_info);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " virt uni recvd ret_code(%d)\n", ret_code);
-		return(ERR_FRWD_INVALID);
-	}
-	if ((virt_uni_info.enabled == 1) && (dir == TPM_DIR_DS) && (SET_TARGET_PORT(pkt_act))) {
-		/* virt uni feature is enabled - validate and recalculate the mh_reg */
-		ret_code = tpm_proc_virt_uni_trg_port_validation(trg_port);
-		if (ret_code != TPM_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "* dir=%d, trg_port=%d, pon_type=%d *\r\n", dir, trg_port,
-				     pon_type);
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Illegal Virt UNI Target Port.\n");
-			return(ERR_FRWD_INVALID);
-		}
-	}
-
-	/* Check Valid Queue */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	/* TODO - Check Queue depending on actual queues in target or in Rx */
-	if (SET_TARGET_QUEUE(pkt_act) && (trg_queue >= TPM_MAX_NUM_TX_QUEUE)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Out of Range\n");
-		return(ERR_FRWD_INVALID);
-	}
-	/* Check Rx queue valid */
-	if (SET_TARGET_PORT(pkt_act) && TO_CPU(trg_port) && SET_TARGET_QUEUE(pkt_act)) {
-		for (gmac = TPM_ENUM_GMAC_0; gmac < TPM_MAX_NUM_GMACS; gmac++) {
-			if (((gmac_bm & TPM_BM_GMAC_0) && (gmac == TPM_ENUM_GMAC_0)) ||
-			    ((gmac_bm & TPM_BM_GMAC_1) && (gmac == TPM_ENUM_GMAC_1)) ||
-			    ((gmac_bm & TPM_BM_PMAC) && (gmac == TPM_ENUM_PMAC))) {
-				/* Get Rx queue info */
-				ret_code = tpm_db_gmac_rx_q_conf_get(gmac, trg_queue, &rx_queue_valid, &rx_queue_size);
-				if (ret_code != TPM_DB_OK) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, " rx queue recvd ret_code(%d)\n", ret_code);
-					return(ERR_FRWD_INVALID);
-				}
-
-				/* Check queue valid state */
-				if (TPM_FALSE == rx_queue_valid) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Invalid\n");
-					return(ERR_FRWD_INVALID);
-				}
-
-				/* Check queue size */
-				if (0 == rx_queue_size) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Size is Zero\n");
-					return(ERR_FRWD_INVALID);
-				}
-			}
-		}
-	}
-
-	/* Check Tx queue valid */
-	if (SET_TARGET_PORT(pkt_act) && (!TO_CPU(trg_port)) && SET_TARGET_QUEUE(pkt_act)) {
-		tpm_proc_trg_port_gmac_map(trg_port, &gmac);
-		for (tx_port = TPM_TX_MOD_GMAC0; tx_port < TPM_MAX_NUM_TX_PORTS; tx_port++) {
-			if (((trg_port & TPM_TRG_TCONT_0) && (act_wan == TPM_ENUM_PMAC) && (tx_port == TPM_TX_MOD_PMAC_0)) ||
-			    ((trg_port & TPM_TRG_TCONT_0) && (act_wan == TPM_ENUM_GMAC_0) && (tx_port == TPM_TX_MOD_GMAC0)) ||
-			    ((trg_port & TPM_TRG_TCONT_0) && (act_wan == TPM_ENUM_GMAC_1) && (tx_port == TPM_TX_MOD_GMAC1)) ||
-			    ((trg_port & TPM_TRG_TCONT_1) && (tx_port == TPM_TX_MOD_PMAC_1)) ||
-			    ((trg_port & TPM_TRG_TCONT_2) && (tx_port == TPM_TX_MOD_PMAC_2)) ||
-			    ((trg_port & TPM_TRG_TCONT_3) && (tx_port == TPM_TX_MOD_PMAC_3)) ||
-			    ((trg_port & TPM_TRG_TCONT_4) && (tx_port == TPM_TX_MOD_PMAC_4)) ||
-			    ((trg_port & TPM_TRG_TCONT_5) && (tx_port == TPM_TX_MOD_PMAC_5)) ||
-			    ((trg_port & TPM_TRG_TCONT_6) && (tx_port == TPM_TX_MOD_PMAC_6)) ||
-			    ((trg_port & TPM_TRG_TCONT_7) && (tx_port == TPM_TX_MOD_PMAC_7)) ||
-			    ((trg_port & (TPM_TRG_UNI_0 |
-					  TPM_TRG_UNI_1 |
-					  TPM_TRG_UNI_2 |
-					  TPM_TRG_UNI_3 |
-					  TPM_TRG_UNI_4 |
-					  TPM_TRG_UNI_5 |
-					  TPM_TRG_UNI_6 |
-					  TPM_TRG_UNI_7 |
-					  TPM_TRG_UNI_VIRT |
-					  TPM_TRG_PORT_UNI_ANY)) && (tx_port == (tpm_db_tx_mod_t)gmac))) {
-				/* Get Tx queue info */
-				ret_code = tpm_db_gmac_tx_q_conf_get(tx_port,
-								     trg_queue,
-								     &tx_queue_valid,
-								     NULL,
-								     &tx_owner,
-								     NULL,
-								     &tx_queue_size,
-								     NULL);
-				if (ret_code != TPM_DB_OK) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, " tx queue recvd ret_code(%d)\n", ret_code);
-					return(ERR_FRWD_INVALID);
-				}
-
-				/* Check queue valid state */
-				if (TPM_FALSE == tx_queue_valid) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Invalid\n");
-					return(ERR_FRWD_INVALID);
-				}
-
-				/* Check queue owner */
-				if (((gmac_bm & TPM_BM_GMAC_0) && (tx_owner != TPM_Q_OWNER_GMAC0)) ||
-				    ((gmac_bm & TPM_BM_GMAC_1) && (tx_owner != TPM_Q_OWNER_GMAC1)) ||
-				    ((gmac_bm & TPM_BM_PMAC) && (tx_owner != TPM_Q_OWNER_PMAC))) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Owner Invalid, gmac_bm: [%d], tx_owner: [%d]\n",
-									gmac_bm, tx_owner);
-					return(ERR_FRWD_INVALID);
-				}
-
-				/* check queue size */
-				if (0 == tx_queue_size) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Size is Zero\n");
-					return(ERR_FRWD_INVALID);
-				}
-			}
-		}
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_check_pkt_action(tpm_pkt_action_t pkt_act,
-				  tpm_trg_port_type_t trg_port,
-				  tpm_pkt_mod_t *pkt_mod,
-				  tpm_pkt_mod_bm_t pkt_mod_bm)
-{
-	if (PKT_DROP(pkt_act)) {
-		if (SET_TARGET_PORT(pkt_act) || SET_TARGET_QUEUE(pkt_act) || SET_MOD(pkt_act) || SET_CPU(pkt_act)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet dropped action, no other packet actions are allowed \n");
-			return(ERR_ACTION_INVALID);
-		}
-	}
-	if (SET_CPU(pkt_act)) {
-		if ((!SET_TARGET_PORT(pkt_act)) || (trg_port != TPM_TRG_PORT_CPU)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,"trg_port %x \n", trg_port);
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				     "For packet TO_CPU action, target port should be set and equal to CPU port.\n");
-			return(ERR_ACTION_INVALID);
-		}
-	}
-
-	if (SET_MOD(pkt_act)) {
-		/* if split mod, do not check trgt port */
-		if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable())
-			&& (pkt_mod_bm == TPM_VLAN_MOD)
-			&& (pkt_mod->vlan_mod.vlan_op == VLANOP_SPLIT_MOD_PBIT)) {
-
-		} else if ((!SET_TARGET_PORT(pkt_act)) || (trg_port == TPM_TRG_PORT_CPU)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				     "For rule SET_MOD action, target port should be set and should not be CPU port. \n");
-			return(ERR_ACTION_INVALID);
-		}
-	}
-
-	return(TPM_OK);
-}
-
-#if 0				/*Phase1 - no longer has below limitation */
-int32_t tpm_proc_pkt_mod_check(tpm_pkt_action_t pkt_act, tpm_pkt_mod_bm_t pkt_mod_bm, tpm_pkt_mod_t *pkt_mod)
-{
-	if (SET_MOD(pkt_act)) {
-		if (pkt_mod_bm != TPM_VLAN_MOD) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Support only VLAN operations \n");
-			return(ERR_MOD_INVALID);
-		}
-		if (pkt_mod->vlan_mod.vlan_op >= VLANOP_ILLEGAL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Illegal VLAN Operation \n");
-			return(ERR_MOD_INVALID);
-		}
-	}
-	return(TPM_OK);
-}
-#endif
-
-/* in PARSE_FLAG_BM - bit#0 and bit#1 - TRUE and FALSE - should not be set simultaneously
-   check pairs of bits in the parse_flags_bm for validation */
-int32_t tpm_proc_check_parse_flag_valid(tpm_parse_flags_t parse_flags_bm)
-{
-	int32_t i;
-
-	for (i = 0; i < TPM_PARSE_FLAG_CHECK_FIELD_NUMBER; i++) {
-		if (PARSE_FLAG_CHECK(parse_flags_bm, i * 2) == TPM_PARSE_FLAG_CHECK_TRUE_FALSE)
-			return(ERR_PARSE_MAP_INVALID);
-	}
-	return(TPM_OK);
-}
-
-/* Get GMAC Lan UNI number and UNI port number */
-/*******************************************************************************
-* tpm_proc_gmaclanuni_uninum_get()
-*
-* DESCRIPTION:    The function Get GMAC Lan UNI number and UNI port number.
-*
-* INPUTS:
-* src_port         - None
-*
-* OUTPUTS:
-* gmac_is_uni_num  - number of GMAC which is LAN UNI
-* max_uni_port_num - number os UNI ports
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_gmaclanuni_uninum_get(uint32_t *gmac_is_uni_num, uint32_t *max_uni_port_num)
-{
-	tpm_db_gmac_func_t gmac_func;
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t temp1 = 0, temp2 = 0;
-
-	/* Cal number of GMAC LAN UNI */
-	for (gmac_i = TPM_ENUM_GMAC_0; gmac_i <= TPM_MAX_GMAC; gmac_i++) {
-		tpm_db_gmac_func_get(gmac_i, &gmac_func);
-		if (GMAC_IS_UNI_LAN(gmac_func))
-			temp1++;
-	}
-	/* Get Max UNI port number */
-	tpm_db_max_uni_port_nr_get(&temp2);
-
-	*gmac_is_uni_num = temp1;
-	*max_uni_port_num = temp2;
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_src_port_check()
-*
-* DESCRIPTION:    The function checks if the requested source port is legit.
-*
-* INPUTS:
-* src_port         - source port in API format
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_src_port_check(tpm_src_port_type_t src_port)
-{
-	tpm_db_pon_type_t pon_type;
-	int32_t ret_code;
-	tpm_db_chip_conn_t dummy_chip_con;
-	tpm_db_int_conn_t dummy_int_conn;
-	uint32_t dummy_switch_port;
-	tpm_init_virt_uni_t virt_uni_info;
-	uint32_t gmac_is_uni_num = 0, max_uni_port_num = 0;
-
-	/* Check Port exists */
-	if (src_port == TPM_SRC_PORT_WAN) {
-		if (TPM_ENUM_PMAC == tpm_db_active_wan_get()){
-		tpm_db_pon_type_get(&pon_type);
-			if (pon_type >= TPM_NONE) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No pon_type defined (0x%x)\n", pon_type);
-				return(TPM_FAIL);
-			}
-		}
-	} else if (FROM_SPEC_UNI(src_port) && (src_port != TPM_SRC_PORT_UNI_VIRT)) {
-		/* Check if port exists */
-		ret_code = tpm_db_eth_port_conf_get(src_port,
-						    &dummy_chip_con,
-						    &dummy_int_conn,
-						    &dummy_switch_port);
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Source UNI Port (%d) is not valid port \n", src_port);
-			return(TPM_FAIL);
-		}
-	} else if (src_port == TPM_SRC_PORT_UNI_ANY) {
-		/* Check UNI_ANY is supported or not */
-		/* Get GMAC LAN_UNI and UNI ports number */
-		tpm_proc_gmaclanuni_uninum_get(&gmac_is_uni_num, &max_uni_port_num);
-		if (gmac_is_uni_num > TPM_SRC_PORT_UNI_1 ||
-		    (gmac_is_uni_num == TPM_SRC_PORT_UNI_1 && max_uni_port_num > TPM_SRC_PORT_UNI_1)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Src port UNI_ANY is not supported\n");
-			return(ERR_SRC_PORT_INVALID);
-		}
-		return(TPM_OK);
-	} else if (src_port == TPM_SRC_PORT_UNI_VIRT) {
-		tpm_db_virt_info_get(&virt_uni_info);
-		if (TPM_VIRT_UNI_DISABLED == virt_uni_info.enabled) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "UNI_VIRT is not enabled\n");
-			return(ERR_SRC_PORT_INVALID);
-		}
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Source UNI Port (%d) out of range \n", src_port);
-		return(TPM_FAIL);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_src_port_dir_map()
-*
-* DESCRIPTION:    The function maps the source port to the packet direction.
-*
-* INPUTS:
-* src_port         - source port in API format
-*
-* OUTPUTS:
-* dir              - Upstream or downstream direction
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_src_port_dir_map(tpm_src_port_type_t src_port, tpm_dir_t *dir)
-{
-	if (src_port == TPM_SRC_PORT_WAN)
-		(*dir) = TPM_DIR_DS;
-	else
-		(*dir) = TPM_DIR_US;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " Source port(%d), direction(%d) \n", src_port, (*dir));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_setstage_done()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* rule_action      -
-* sram_data
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_proc_setstage_done(tpm_rule_action_t *rule_action, tpm_pncl_sram_data_t *sram_data)
-{
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-	return;
-}
-
-/*******************************************************************************
-* tpm_proc_set_mod()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* rule_action      -
-* sram_data
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_proc_set_mod(tpm_rule_action_t *rule_action, tpm_pncl_sram_data_t *sram_data, uint32_t mod_cmd)
-{
-	if (SET_MOD(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_cmd);
-	}
-}
-
-/*******************************************************************************
-* tpm_proc_set_cust_cpu_packet_parse()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* rule_action      -
-* sram_data
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_proc_set_cust_cpu_packet_parse(tpm_rule_action_t *rule_action, tpm_pncl_sram_data_t *sram_data)
-{
-	/* set the RI = TPM_PNCL_SET_RX_SPECIAL for packets with CUSTOMIZE flag */
-	if (SET_CUST(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_RX_SPECIAL;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Customization flag.\n");
-	}
-
-}
-
-/*******************************************************************************
-* tpm_proc_set_trgt()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* rule_action      -
-* sram_data
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_set_trgt_queue(tpm_rule_action_t *rule_action,
-				tpm_pkt_frwd_t *pkt_frwd,
-				tpm_dir_t dir,
-				tpm_db_pon_type_t pon_type,
-				tpm_pncl_sram_data_t *sram_data)
-{
-	uint32_t i;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	if (SET_TARGET_PORT(rule_action->pkt_act)) {
-		tpm_gmacs_enum_t act_wan= tpm_db_active_wan_get();
-
-		/* Add Target Txp to update BM */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-
-		/* Set PNC FlowId Target */
-		if (TO_PON(dir, pkt_frwd->trg_port, pon_type, act_wan)) {
-			for (i = 0; i < 8; i++) {
-				if (pkt_frwd->trg_port == (uint32_t) (TPM_TRG_TCONT_0 << i))
-					break;
-			}
-			sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_PMAC0 + i;
-		} else if (TO_ETHWAN(dir, pkt_frwd->trg_port, act_wan)) {
-			switch (act_wan) {
-			case TPM_ENUM_GMAC_0:
-				sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC0;
-				break;
-			case TPM_ENUM_GMAC_1:
-				sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC1;
-				break;
-			default:
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Set Target, act_wan(%d) invalid",act_wan);
-				return(TPM_FAIL);
-			}
-		} else if (TO_LAN(dir, pkt_frwd->trg_port)) {
-			tpm_pnc_trg_t pnc_target;
-
-			/* when ds load balance on G0 and G1 is enabled, trgt port can only
-			 * be set in the first range TPM_DS_MAC_BASED_TRUNKING.
-			 */
-			tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-			if (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable) {
-				sram_data->sram_updt_bm &= (~TPM_PNCL_SET_TXP);
-			} else if (TPM_TRG_LOAD_BAL & pkt_frwd->trg_port) {
-				/* DS load balance, set trg port to G1 */
-				pnc_target = TPM_PNC_TRG_GMAC1;
-			} else if (tpm_db_to_lan_gmac_get(pkt_frwd->trg_port, &pnc_target) != TPM_DB_OK){
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_db_to_lan_gmac_get failed trg_port 0x%x\n",
-					     pkt_frwd->trg_port);
-				return(TPM_FAIL);
-			}
-			sram_data->flow_id_sub.pnc_target = pnc_target;
-		} else if (TO_CPU(pkt_frwd->trg_port)) {
-			sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Set Target received, no legitimate Target Found \n");
-			return(TPM_FAIL);
-		}
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Target(%d)\n", sram_data->flow_id_sub.pnc_target);
-		/* If target is GPON, set GEM and MH */
-		if (TO_GPON(dir, pkt_frwd->trg_port, pon_type, act_wan)) {
-			sram_data->mh_reg.mh_set = TPM_TRUE;
-			sram_data->mh_reg.mh_reg = 1;
-			sram_data->sram_updt_bm |= TPM_PNCL_SET_GEM;
-			sram_data->flow_id_sub.gem_port = pkt_frwd->gem_port;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set GemPort(%d)\n", pkt_frwd->gem_port);
-		}
-	}
-	if (SET_TARGET_QUEUE(rule_action->pkt_act)) {
-		/* Set Queue */
-		sram_data->pnc_queue = pkt_frwd->trg_queue;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Tx Queue (%x)\n", pkt_frwd->trg_queue);
-	} else {
-		sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "No Tx Queue Updat\n");
-	}
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_api_ent_check()
-*
-* DESCRIPTION:    The function checks if there is a free_entry to add an API entry
-*
-* INPUTS:
-* section          - Section of the API acl/table
-* api_rng_type     - The Type of the API, ACL or Table
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_add_api_ent_check(tpm_api_sections_t section, tpm_range_type_t api_rng_type, uint32_t rule_num)
-{
-	int32_t ret_code, last_valid;
-	uint32_t api_rng_size, num_valid_entries, tbl_start;
-	tpm_pnc_ranges_t prim_pnc_range;
-
-	/* TODO - make the api_rng_type part of the api_rng database configuration */
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " api_sec(%d), api_rng_type(%d) \n", section, api_rng_type);
-
-	/* Check API range exists */
-	ret_code = tpm_db_api_section_get(section, &api_rng_size,
-					  &num_valid_entries, &prim_pnc_range, &last_valid, &tbl_start);
-	IF_ERROR(ret_code);
-
-	/* Check possible to add another entry */
-	if (num_valid_entries > (api_rng_size-1)) {
-		/* If the range mode is table, it is unnecessary to check */
-		if (api_rng_type == TPM_RANGE_TYPE_ACL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " api_sec(%d), has no free entries \n", section);
-			return(TPM_FAIL);
-		}
-	}
-	/* Check last_valid consistency, for acl type range */
-	if (api_rng_type == TPM_RANGE_TYPE_ACL) {
-		if (last_valid != ((int32_t) (num_valid_entries) - (int32_t) (1))) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "DB problem, api_section(%d),num_entries(%d),last_valid(%d)\n",
-				     section, num_valid_entries, last_valid);
-			return(TPM_FAIL);
-		}
-
-		/* make sure in api table there will not be a gap after insert this rule */
-		if (rule_num > num_valid_entries) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "api table there will not be a gap after insert the api,"
-				     "api_section(%d), num_entries(%d),last_valid(%d), rule_num(%d)\n",
-				     section, num_valid_entries, last_valid, rule_num);
-			return(TPM_FAIL);
-		}
-	}
-	return(TPM_OK);
-}
-
-
-int32_t tpm_proc_check_api_busy(tpm_api_type_t api_type, uint32_t rule_num)
-{
-	uint32_t  db_ret_code;
-	int32_t rc_code = TPM_RC_OK;
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t rangConf;
-
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "api_type(%d) rule_num(%d)\n", api_type, rule_num);
-
-
-	/* Get api_section, range_Id, range configuration, to get range type */
-	db_ret_code = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-	IF_ERROR(db_ret_code);
-	db_ret_code = tpm_db_api_section_main_pnc_get(api_section, &range_id);
-	IF_ERROR(db_ret_code);
-	db_ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(db_ret_code);
-
-
-	/* Check API Section Busy */
-	/* In ACL Mode   - concurrency not supported.
-	   In TABLE Mode - concurrency supported, but not on the same entry */
-
-	spin_lock_bh(&tpm_proc_api_call_lock);
-	if ((rangConf.range_type == TPM_RANGE_TYPE_ACL) && ((tpm_db_get_api_busy(api_type))== TPM_TRUE))
-		rc_code = ERR_API_BUSY;
-	else if ((rangConf.range_type == TPM_RANGE_TYPE_TABLE) &&
-		 ((tpm_db_get_api_rule_num_busy(api_type, rule_num)) == TPM_TRUE))
-		rc_code = ERR_API_BUSY;
-	else {
-		db_ret_code = tpm_db_set_api_busy(api_type, rule_num);
-		if (db_ret_code != TPM_DB_OK)
-			rc_code = ERR_API_BUSY; /* Table full */
-	}
-	spin_unlock_bh(&tpm_proc_api_call_lock);
-	return(rc_code);
-}
-
-int32_t tpm_proc_check_all_api_busy(void)
-{
-	uint32_t  db_ret_code;
-	int32_t rc_code = TPM_RC_OK;
-	int32_t rule_num;
-	int32_t rule_num_max;
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_api_type_t api_type;
-
-	for (api_type = TPM_API_MAC_LEARN; api_type < TPM_MAX_API_TYPES; api_type++) {
-
-		/* Get api_section, range_Id, range configuration, to get range type */
-		db_ret_code = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-		IF_ERROR(db_ret_code);
-		db_ret_code = tpm_db_api_section_main_pnc_get(api_section, &range_id);
-		if (TPM_DB_OK != db_ret_code)
-			continue;
-		db_ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-		IF_ERROR(db_ret_code);
-
-		if (rangConf.range_type == TPM_RANGE_TYPE_ACL)
-			rule_num_max = 1;
-		else
-			rule_num_max = TPM_MAX_PARALLEL_API_CALLS;
-
-		for (rule_num = 0; rule_num < rule_num_max; rule_num++) {
-			rc_code = tpm_proc_check_api_busy(api_type, rule_num);
-				IF_ERROR(rc_code);
-		}
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_api_busy_done(tpm_api_type_t api_type, uint32_t rule_num)
-{
-	int32_t rc_code = TPM_RC_OK;
-	uint32_t  db_ret_code;
-
-	spin_lock_bh(&tpm_proc_api_call_lock);
-	db_ret_code = tpm_db_set_api_free(api_type, rule_num);
-	if (db_ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Error releasing api_busy: api_type(%d) rule_num(%d)\n", api_type, rule_num);
-		rc_code = ERR_GENERAL;
-	}
-	spin_unlock_bh(&tpm_proc_api_call_lock);
-	return(rc_code);
-}
-
-int32_t tpm_proc_all_api_busy_done(void)
-{
-	uint32_t  db_ret_code;
-	int32_t rc_code = TPM_RC_OK;
-	int32_t rule_num;
-	int32_t rule_num_max;
-	tpm_api_sections_t api_section;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_api_type_t api_type;
-
-	for (api_type = TPM_API_MAC_LEARN; api_type < TPM_MAX_API_TYPES; api_type++) {
-
-		/* Get api_section, range_Id, range configuration, to get range type */
-		db_ret_code = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-		IF_ERROR(db_ret_code);
-		db_ret_code = tpm_db_api_section_main_pnc_get(api_section, &range_id);
-		if (TPM_DB_OK != db_ret_code)
-			continue;
-		db_ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-		IF_ERROR(db_ret_code);
-
-		if (rangConf.range_type == TPM_RANGE_TYPE_ACL)
-			rule_num_max = 1;
-		else
-			rule_num_max = TPM_MAX_PARALLEL_API_CALLS;
-
-		for (rule_num = 0; rule_num < rule_num_max; rule_num++) {
-			rc_code = tpm_proc_api_busy_done(api_type, rule_num);
-			IF_ERROR(rc_code);
-		}
-	}
-
-	return(TPM_OK);
-}
-
-
-
-int32_t tpm_proc_parse_flag_ai_tcam_build(tpm_ai_vectors_t *ai_fields,
-					  uint32_t parse_flags,
-					  long long parse_int_flags,
-					  uint32_t *ai_data,
-					  uint32_t *ai_mask)
-{
-	uint32_t ai_val;
-	tpm_init_double_tag_t dbl_tag;
-	tpm_src_port_type_t src_port_tmp;
-
-	/* Parsing flags */
-
-	/*BIT_0 */
-	if (parse_flags & TPM_PARSE_FLAG_TAG1_MASK) {
-		ai_val = ((parse_flags & TPM_PARSE_FLAG_TAG1_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_TAG1_BIT_OFF);
-		*ai_mask |= TPM_AI_TAG1_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_NH2_ITER_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_NH2_ITER_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_TAG1_BIT_OFF);
-		*ai_mask |= TPM_AI_TAG1_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_IPV6_SUBFLOW_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv6 ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (((ai_fields->ipv6_subflow) << TPM_AI_IPV6_SUBFLOW_PART1_BIT_OFF) & TPM_AI_IPV6_SUBFLOW_PART1_MASK);
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART1_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_IPV6_MC_SIP_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv6 ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (((ai_fields->ipv6_mc_sip_indx) << TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF) & TPM_AI_IPV6_MC_SIP_PART1_MASK);
-		*ai_mask |= TPM_AI_IPV6_MC_SIP_PART1_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_CNM_IPV4_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_CNM_IPV4_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_CNM_IPV4_BIT_OFF);
-		*ai_mask |= TPM_AI_CNM_IPV4_MASK;
-	}
-
-	/*BIT_1 */
-	if (parse_flags & TPM_PARSE_FLAG_TAG2_MASK) {
-		tpm_db_double_tag_support_get(&dbl_tag);
-		if (TPM_DOUBLE_TAG_ENABLED == dbl_tag) {
-			ai_val = ((parse_flags & TPM_PARSE_FLAG_TAG2_TRUE) ? 1 : 0);
-			*ai_data |= (ai_val << TPM_AI_TAG2_BIT_OFF);
-			*ai_mask |= TPM_AI_TAG2_MASK;
-		} else {
-			ai_val = ((parse_flags & TPM_PARSE_FLAG_TAG1_TRUE) ? 1 : 0);
-			*ai_data |= (ai_val << TPM_AI_TAG1_BIT_OFF);
-			*ai_mask |= TPM_AI_TAG1_MASK;
-		}
-	}
-
-	if (parse_flags & TPM_PARSE_FLAG_PPPOE_MASK) {
-		ai_val = ((parse_flags & TPM_PARSE_FLAG_PPPOE_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_PPPOE_BIT_OFF);
-		*ai_mask |= TPM_AI_PPPOE_MASK;
-	}
-
-	if (parse_flags & TPM_PARSE_FLAG_L4P_MASK) {
-		ai_val = ((parse_flags & TPM_PARSE_FLAG_L4_UDP) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_L4P_BIT_OFF);
-		*ai_mask |= TPM_AI_L4P_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_IPV4_PRE_KEY_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv4 pre-filter key ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (ai_fields->ipv4_pre_key << TPM_AI_CNM_IPV4_PRE_KEY_BIT_OFF);
-		*ai_mask |= (ai_fields->ipv4_pre_key << TPM_AI_CNM_IPV4_PRE_KEY_BIT_OFF);
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_CNM_PREC_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " cnm precedence ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (ai_fields->cnm_prec << TPM_AI_CNM_PREC_BIT_OFF);
-		*ai_mask |= (ai_fields->cnm_prec << TPM_AI_CNM_PREC_BIT_OFF);
-	}
-
-	/*BIT_2 */
-	if (parse_flags & TPM_PARSE_FLAG_MTM_MASK) {
-		ai_val = ((parse_flags & TPM_PARSE_FLAG_MTM_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_MTM_BIT_OFF);
-		*ai_mask |= TPM_AI_MTM_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_IPV6_MC_SIP_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv6 ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (((ai_fields->ipv6_mc_sip_indx >> (TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF + 1))
-			      << TPM_AI_IPV6_MC_SIP_PART2_BIT_OFF) & TPM_AI_IPV6_MC_SIP_PART2_MASK);
-		*ai_mask |= TPM_AI_IPV6_MC_SIP_PART2_MASK;
-	}
-
-	/*BIT_3 */
-	if (parse_flags & TPM_PARSE_FLAG_TO_CPU_MASK) {
-		ai_val = ((parse_flags & TPM_PARSE_FLAG_TO_CPU_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_TO_CPU_BIT_OFF);
-		*ai_mask |= TPM_AI_TO_CPU_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_SPLIT_MOD_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLGA_SPLIT_MOD_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_SPLIT_MOD_BIT_OFF);
-		*ai_mask |= TPM_AI_SPLIT_MOD_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_DNRT_DS_TRUNK) {
-		*ai_data &= ~(TPM_AI_DNRT_DS_TRUNK_MASK);
-		*ai_mask |= TPM_AI_DNRT_DS_TRUNK_MASK;
-	}
-
-	/*BIT_4 */
-	if (parse_int_flags & TPM_PARSE_FLAG_UNI_PORT_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " src_port ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-		if (ai_fields->src_port == TPM_SRC_PORT_UNI_VIRT)
-			src_port_tmp = TPM_SRC_PORT_UNI_7;
-		else
-			src_port_tmp = ai_fields->src_port;
-
-		*ai_data |= ((src_port_tmp - TPM_SRC_PORT_UNI_0) << TPM_AI_UNI_BIT_OFF);
-		*ai_mask |= TPM_AI_UNI_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_PPPOE_ADD_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_PPPOE_ADD_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_PPPOE_ADD_BIT_OFF);
-		*ai_mask |= TPM_AI_PPPOE_ADD_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_MC_VID_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " vid ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= ((ai_fields->mc_vid_entry) << TPM_AI_MC_VID_BIT_OFF);
-		*ai_mask |= TPM_AI_MC_VID_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_IPV6_SUBFLOW_PARSE) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv6 ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (((ai_fields->ipv6_subflow >> TPM_AI_IPV6_SUBFLOW_PART1_BIT_SIZE) << TPM_AI_IPV6_SUBFLOW_PART2_BIT_OFF) & TPM_AI_IPV6_SUBFLOW_PART2_MASK);
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART2_MASK;
-	}
-
-	/*BIT_5 */
-
-	if (parse_int_flags & TPM_PARSE_FLAG_NO_PROTO_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_NO_PROTO_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_NO_PROTO_BIT_OFF);
-		*ai_mask |= TPM_AI_NO_PROTO_MASK;
-	}
-
-	/*BIT_6 */
-
-	if (parse_int_flags & TPM_PARSE_FLAG_NO_FRAG_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_NO_FRAG_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_NO_FRAG_BIT_OFF);
-		*ai_mask |= TPM_AI_NO_FRAG_MASK;
-	}
-
-	if (parse_int_flags & TPM_PARSE_FLAG_MC_VID_MASK) {
-		ai_val = ((parse_int_flags & TPM_PARSE_FLAG_MC_VID_TRUE) ? 1 : 0);
-		*ai_data |= (ai_val << TPM_AI_MC_VID_VALID_BIT_OFF);
-		*ai_mask |= TPM_AI_MC_VID_VALID_MASK;
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_static_ai_sram_build(tpm_ai_vectors_t *ai_fields,
-				      tpm_pkt_action_t pkt_action,
-				      long long int_pkt_action,
-				      uint32_t *ai_data,
-				      uint32_t *ai_mask)
-{
-	tpm_src_port_type_t src_port_tmp;
-
-	/* Important Note: All TPM_ACTION_UNSET_XXX must be done first, because other bits may re-raise them */
-	if (int_pkt_action & TPM_ACTION_UNSET_DNRT) {
-		*ai_data &= ~(TPM_AI_DNRT_MASK);
-		*ai_mask |= TPM_AI_DNRT_MASK;
-	}
-	if (int_pkt_action & TPM_ACTION_UNSET_DNRT_DS_TRUNK) {
-		*ai_data &= ~(TPM_AI_DNRT_DS_TRUNK_MASK);
-		*ai_mask |= TPM_AI_DNRT_DS_TRUNK_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_UNI_PORT) {
-		*ai_data &= ~(TPM_AI_UNI_MASK);
-		*ai_mask |= TPM_AI_UNI_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_IPV6_SUBFLOW) {
-		*ai_data &= ~TPM_AI_IPV6_SUBFLOW_PART1_MASK;
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART1_MASK;
-
-		*ai_data &= ~TPM_AI_IPV6_SUBFLOW_PART2_MASK;
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART2_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_PPPOE) {
-		*ai_data &= ~(TPM_AI_PPPOE_MASK);
-		*ai_mask |= TPM_AI_PPPOE_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_NH2_ITER) {
-		*ai_data &= ~(TPM_AI_NH2_ITER_MASK);
-		*ai_mask |= TPM_AI_NH2_ITER_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_CNM_IPV4) {
-		*ai_data &= ~(TPM_AI_CNM_IPV4_MASK);
-		*ai_mask |= TPM_AI_CNM_IPV4_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_SPLIT_MOD) {
-		*ai_data &= ~(TPM_AI_SPLIT_MOD_MASK);
-		*ai_mask |= TPM_AI_SPLIT_MOD_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_IPV4_PRE_KEY) {
-		*ai_data &= ~TPM_AI_CNM_IPV4_PRE_KEY_MASK;
-		*ai_mask |= TPM_AI_CNM_IPV4_PRE_KEY_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_UNSET_CNM_PREC) {
-		*ai_data &= ~TPM_AI_CNM_PREC_MASK;
-		*ai_mask |= TPM_AI_CNM_PREC_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_TAG1) {
-		*ai_data |= (1 << TPM_AI_TAG1_BIT_OFF);
-		*ai_mask |= TPM_AI_TAG1_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_TAG2) {
-		*ai_data |= (1 << TPM_AI_TAG1_BIT_OFF);
-		*ai_mask |= TPM_AI_TAG2_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_PPPOE) {
-		*ai_data |= (1 << TPM_AI_PPPOE_BIT_OFF);
-		*ai_mask |= TPM_AI_PPPOE_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_L4P_TOG_UDP) {
-		*ai_data |= (1 << TPM_AI_L4P_BIT_OFF);
-		*ai_mask |= TPM_AI_L4P_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_L4P_TOG_TCP) {
-		*ai_data |= (0 << TPM_AI_L4P_BIT_OFF);
-		*ai_mask |= TPM_AI_L4P_MASK;
-	}
-
-	if (pkt_action & TPM_ACTION_MTM) {
-		*ai_data |= (1 << TPM_AI_MTM_BIT_OFF);
-		*ai_mask |= TPM_AI_MTM_MASK;
-	}
-
-	if (pkt_action & TPM_ACTION_TO_CPU) {
-		*ai_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-		*ai_mask |= TPM_AI_TO_CPU_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_ADD_PPPOE) {
-		*ai_data |= (1 << TPM_AI_PPPOE_ADD_BIT_OFF);
-		*ai_mask |= TPM_AI_PPPOE_ADD_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_UNI_PORT) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " uni_ports ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-		if (ai_fields->src_port == TPM_SRC_PORT_UNI_VIRT)
-			src_port_tmp = TPM_SRC_PORT_UNI_7;
-		else
-			src_port_tmp = ai_fields->src_port;
-
-		*ai_data |= ((src_port_tmp - TPM_SRC_PORT_UNI_0) << TPM_AI_UNI_BIT_OFF);
-		*ai_mask |= TPM_AI_UNI_MASK;
-	}
-
-	if (pkt_action & TPM_ACTION_SPEC_MC_VID) {
-		/* Set mc_valid bit */
-		*ai_data |= (1 << TPM_AI_MC_VID_VALID_BIT_OFF);
-		*ai_mask |= TPM_AI_MC_VID_VALID_MASK;
-
-		/* Set mc_vid vector */
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " vid ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-		*ai_data |= ((ai_fields->mc_vid_entry) << TPM_AI_MC_VID_BIT_OFF);
-		*ai_mask |= TPM_AI_MC_VID_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_NO_PROTO_CHECK) {
-		*ai_data |= (1 << TPM_AI_NO_PROTO_BIT_OFF);
-		*ai_mask |= TPM_AI_NO_PROTO_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_NO_FRAG_CHECK) {
-		*ai_data |= (1 << TPM_AI_NO_FRAG_BIT_OFF);
-		*ai_mask |= TPM_AI_NO_FRAG_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_NH2_ITER) {
-		*ai_data |= (1 << TPM_AI_NH2_ITER_BIT_OFF);
-		*ai_mask |= TPM_AI_NH2_ITER_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_IPV6_SUBFLOW) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv6 ai vector cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= (((ai_fields->ipv6_subflow) << TPM_AI_IPV6_SUBFLOW_PART1_BIT_OFF) & TPM_AI_IPV6_SUBFLOW_PART1_MASK);
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART1_MASK;
-
-		*ai_data |= (((ai_fields->ipv6_subflow >> TPM_AI_IPV6_SUBFLOW_PART1_BIT_SIZE) << TPM_AI_IPV6_SUBFLOW_PART2_BIT_OFF) & TPM_AI_IPV6_SUBFLOW_PART2_MASK);
-		*ai_mask |= TPM_AI_IPV6_SUBFLOW_PART2_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_CNM_IPV4) {
-		*ai_data |= (1 << TPM_AI_CNM_IPV4_BIT_OFF);
-		*ai_mask |= TPM_AI_CNM_IPV4_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_SPLIT_MOD) {
-		*ai_data |= (1 << TPM_AI_SPLIT_MOD_BIT_OFF);
-		*ai_mask |= TPM_AI_SPLIT_MOD_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_IPV4_PRE_KEY) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " ipv4 pre filter key pattern cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= ((ai_fields->ipv4_pre_key << TPM_AI_CNM_IPV4_PRE_KEY_BIT_OFF) & TPM_AI_CNM_IPV4_PRE_KEY_MASK);
-		*ai_mask |= TPM_AI_CNM_IPV4_PRE_KEY_MASK;
-	}
-
-	if (int_pkt_action & TPM_ACTION_SET_CNM_PREC) {
-		if (ai_fields == NULL) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " cnm precedence pattern cannot be null pointer\n");
-			return(TPM_FAIL);
-		}
-
-		*ai_data |= ((ai_fields->cnm_prec << TPM_AI_CNM_PREC_BIT_OFF) & TPM_AI_CNM_PREC_MASK);
-		*ai_mask |= TPM_AI_CNM_PREC_MASK;
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_virt_uni_trg_port_validation()
-*
-* DESCRIPTION:
-*   In case feature Virtual UNI_4 is enabled - only following target port are allowed:
-*       TPM_TRG_UNI_0                       (0x0100)
-*       TPM_TRG_UNI_1                       (0x0200)
-*       TPM_TRG_UNI_2                       (0x0400)
-*       TPM_TRG_UNI_3                       (0x0800)
-*       TPM_TRG_PORT_UNI_ANY                (0x4000)
-* INPUTS:
-* tpm_trg_port_type_t     trg_port
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_virt_uni_trg_port_validation(tpm_trg_port_type_t trg_port)
-{
-	/* unset TPM_TRG_LOAD_BAL first, since it can be mixed with UNI port */
-	trg_port &= (~TPM_TRG_LOAD_BAL);
-
-	if ((trg_port == TPM_TRG_UNI_0) ||
-	    (trg_port == TPM_TRG_UNI_1) ||
-	    (trg_port == TPM_TRG_UNI_2) ||
-	    (trg_port == TPM_TRG_UNI_3) ||
-	    (trg_port == TPM_TRG_UNI_4) ||
-	    (trg_port == TPM_TRG_UNI_5) ||
-	    (trg_port == TPM_TRG_UNI_6) ||
-	    (trg_port == TPM_TRG_UNI_7) ||
-	    (trg_port == TPM_TRG_UNI_VIRT) ||
-	    (trg_port == TPM_TRG_PORT_UNI_ANY) ||
-	    (trg_port == TPM_TRG_PORT_CPU) ||
-	    (trg_port == (TPM_TRG_UNI_0 | TPM_TRG_UNI_1 | TPM_TRG_UNI_2 | TPM_TRG_UNI_3 |
-			  TPM_TRG_UNI_4 | TPM_TRG_UNI_5 | TPM_TRG_UNI_6 | TPM_TRG_UNI_7)))
-		return TPM_OK;
-	else
-		return TPM_FAIL;
-}
-
-/*******************************************************************************
-* tpm_proc_set_RI_mh()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* rule_action
-* pkt_frwd
-* dir
-* sram_data
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_set_RI_mh(tpm_rule_action_t *rule_action,
-			   tpm_pkt_frwd_t *pkt_frwd,
-			   tpm_dir_t dir,
-			   tpm_pncl_sram_data_t *sram_data)
-{
-	uint32_t i;
-	int32_t ret_code;
-	tpm_db_mh_src_t ds_mh_src;
-	tpm_init_virt_uni_t virt_uni_info;
-	uint16_t amber_port_vector;
-	uint32_t pnc_vector, uni_vector;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "tpm_proc_set_RI_mh: dir(%d), trg_port(0x%x) \r\n", dir, pkt_frwd->trg_port);
-
-	tpm_db_ds_mh_get_conf_set(&ds_mh_src);
-
-	if ((SET_TARGET_PORT(rule_action->pkt_act)) &&
-	    (TO_LAN(dir, pkt_frwd->trg_port)) && (ds_mh_src == TPM_MH_SRC_PNC_RI)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_MH_RI;
-		sram_data->mh_reg.mh_set = TPM_TRUE;
-
-		/* target port validation -
-		   not all target port combinations are supported when WiFi via GMAC1 = UNI_4 feature is enabled */
-		ret_code = tpm_db_virt_info_get(&virt_uni_info);
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Virt UNI recvd ret_code(%d)\n", ret_code);
-			return(ret_code);
-		}
-		if ((virt_uni_info.enabled == 1) && (dir == TPM_DIR_DS)) {
-			/* Virt UNI feature is enabled - validate and recalculate the mh_reg */
-			ret_code = tpm_proc_virt_uni_trg_port_validation(pkt_frwd->trg_port);
-			if (ret_code != TPM_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Virt UNI trg_port validation failed. (%d)\n", ret_code);
-				return(ret_code);
-			}
-
-			/* get the MH_REG from the DB */
-			ret_code = tpm_db_port_vector_tbl_info_search(pkt_frwd->trg_port, &uni_vector,
-									   &amber_port_vector, &pnc_vector);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-					" Unable to retrieve port vector table from DB. (0x%x)\n", pkt_frwd->trg_port);
-				return(ret_code);
-			}
-			sram_data->mh_reg.mh_reg = pnc_vector;
-		} else {
-			for (i = 0; i < TPM_MAX_NUM_UNI_PORTS; i++) {
-				if ((pkt_frwd->trg_port & (TPM_TRG_UNI_0 << i)) ||
-				    (pkt_frwd->trg_port & TPM_TRG_PORT_UNI_ANY))
-					sram_data->mh_reg.mh_reg |= (TPM_MH_RI_BIT14 << i);
-			}
-
-		}
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_owner_id_check()
-*
-* DESCRIPTION:    The function checks if the owner_id is the valid owner of api_type
-*
-* INPUTS:
-* owner_id         - API Group owner
-* api_type        - API group the owner requests to act upon
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_owner_id_check(tpm_api_type_t api_type, uint32_t owner_id)
-{
-	/* TODO Implement */
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_cpu_loopback_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_cpu_loopback_rule params.
-*
-* INPUTS:
-* owner_id         - See tpm_proc_add_l2_prim_acl_rule
-* rule_num         - See tpm_proc_add_l2_prim_acl_rule
-* pkt_frwd         - See tpm_proc_add_l2_prim_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_cpu_loopback_check(uint32_t owner_id, uint32_t rule_num, tpm_pkt_frwd_t *pkt_frwd)
-{
-	int32_t ret_code;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_CPU_LOOPBACK, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_CPU_LOOPBACK_ACL, TPM_RANGE_TYPE_ACL, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_l2_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_l2_prim_acl_rule params.
-*
-* INPUTS:
-* owner_id         - See tpm_proc_add_l2_prim_acl_rule
-* src_port         - See tpm_proc_add_l2_prim_acl_rule
-* rule_num         - See tpm_proc_add_l2_prim_acl_rule
-* parse_rule_bm    - See tpm_proc_add_l2_prim_acl_rule
-* l2_key           - See tpm_proc_add_l2_prim_acl_rule
-* pkt_frwd         - See tpm_proc_add_l2_prim_acl_rule
-* pkt_mod          - See tpm_proc_add_l2_prim_acl_rule
-* rule_action      - See tpm_proc_add_l2_prim_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_l2_check(uint32_t owner_id,
-				       tpm_src_port_type_t src_port,
-				       uint32_t rule_num,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_l2_acl_key_t *l2_key,
-				       tpm_parse_flags_t parse_flags_bm,
-				       tpm_pkt_frwd_t *pkt_frwd,
-				       tpm_pkt_mod_bm_t pkt_mod_bm,
-				       tpm_pkt_mod_t *pkt_mod,
-				       tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pnc_range_conf_t rangConf;
-	int32_t mc_vlan_free_slot;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Range_Id, rang configuration, to get range type */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_L2_PRIM_ACL, &range_id);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, pkt_mod, pkt_frwd, (void *)l2_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_L2_PRIM_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check Vlan Tag TPID mask */
-	if (parse_rule_bm & (TPM_L2_PARSE_TWO_VLAN_TAG | TPM_L2_PARSE_ONE_VLAN_TAG)) {
-		if ((l2_key->vlan1.tpid_mask != 0) && (l2_key->vlan1.tpid_mask != 0xffff)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid vlan1 tpid mask(0x%x) \n", l2_key->vlan1.tpid_mask);
-			return(ERR_L2_KEY_INVALID);
-		}
-
-		if (parse_rule_bm & TPM_L2_PARSE_ONE_VLAN_TAG) {
-			if ((l2_key->vlan2.tpid_mask != 0) && (l2_key->vlan2.tpid_mask != 0xffff)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid vlan2 tpid mask(0x%x) \n", l2_key->vlan2.tpid_mask);
-				return(ERR_L2_KEY_INVALID);
-			}
-		}
-	}
-
-	/* Cannot do Double Vlan Tag with looking into PPPoE (up to 24Bytes) with MH */
-	if ((parse_rule_bm & TPM_L2_PARSE_TWO_VLAN_TAG) &&
-	    ((parse_rule_bm & TPM_L2_PARSE_PPP_PROT) || (parse_rule_bm & TPM_L2_PARSE_PPPOE_SES))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parse map of Double Vlan Tag + PPPoE not supported\n");
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Cannot do Single or Double Vlan Tag with checking   PPP protocol (up to 24Bytes) with MH */
-	if (((parse_rule_bm & TPM_L2_PARSE_TWO_VLAN_TAG) || (parse_rule_bm & TPM_L2_PARSE_ONE_VLAN_TAG))
-	    && (parse_rule_bm & TPM_L2_PARSE_PPP_PROT)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parse map of Single Vlan Tag + PPPoE proto not supported\n");
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_L2_PRIM_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/*do not allow user to create VLANOP_NOOP l2 PNC with no vlan parse flag.*/
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(TPM_VLAN_MOD == pkt_mod_bm) &&
-		(VLANOP_NOOP == pkt_mod->vlan_mod.vlan_op)) {
-		if (!(parse_flags_bm &
-			(TPM_PARSE_FLAG_TAG1_TRUE |
-			TPM_PARSE_FLAG_TAG2_TRUE |
-			TPM_PARSE_FLAG_TAG1_FALSE |
-			TPM_PARSE_FLAG_TAG2_FALSE))) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x), "
-				"when split mod VLANOP_NOOP it must TAG FLAG be set\n", parse_flags_bm);
-			return(ERR_PARSE_MAP_INVALID);
-		}
-	}
-
-	/* check VLAN OP p_bit mask */
-	if (pkt_mod_bm & TPM_VLAN_MOD) {
-		if (VLANOP_EXT_TAG_INS == pkt_mod->vlan_mod.vlan_op) {
-			if (pkt_mod->vlan_mod.vlan1_out.pbit_mask != 0xff) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid p_bit mask for VLAN Op (0x%x) \n", VLANOP_EXT_TAG_INS);
-				return(ERR_GENERAL);
-		    }
-		}
-		if (VLANOP_INS_2TAG == pkt_mod->vlan_mod.vlan_op) {
-			if (pkt_mod->vlan_mod.vlan1_out.pbit_mask != 0xff ||
-			    pkt_mod->vlan_mod.vlan2_out.pbit_mask != 0xff) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid p_bit mask for VLAN Op (0x%x) \n", VLANOP_INS_2TAG);
-				return(ERR_GENERAL);
-		    }
-		}
-		if (VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid VLAN Op (0x%x), do not support in L2 \n", VLANOP_SPLIT_MOD_PBIT);
-			return(ERR_GENERAL);
-		}
-	}
-
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Packet Modification */
-#if 0
-	tpm_proc_pkt_mod_check(rule_action->pkt_act, pkt_mod_bm, pkt_mod);
-	IF_ERROR(ret_code);
-#endif
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_L2_PRIM, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_L2_PRIM_ACL, rangConf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check parse_rules */
-
-	/* Check gem_port only for GPON DS */
-	if ((parse_rule_bm & TPM_L2_PARSE_GEMPORT) && ((dir != TPM_DIR_DS) || (pon_type != TPM_GPON)))
-		IF_ERROR(ERR_PARSE_MAP_INVALID);
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_L3_TYPE && rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-	/* Check that for l2_hwf rules (not mtm, not to_cpu), if the parsing is not done, the uni_port is specifc.
-	 * Otherwise, rules in following sections cannot rely on the uni_port */
-	if (((rule_action->pkt_act & (TPM_ACTION_TO_CPU | TPM_ACTION_MTM)) == 0) &&
-	    (rule_action->next_phase != STAGE_DONE)) {
-		if (!(FROM_SPEC_UNI(src_port)) && (src_port != TPM_SRC_PORT_WAN)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				     " For L2_HWF rule (not mtm, not to_cpu), specific uni must be specified \n");
-			return(ERR_SRC_PORT_INVALID);
-		}
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-
-	/* Check mc vlan set */
-	if (TPM_ACTION_SPEC_MC_VID & rule_action->pkt_act) {
-		if (src_port != TPM_SRC_PORT_WAN) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Multicast Vlan-ID can only be assigned in downstream \n");
-			return(ERR_ACTION_INVALID);
-		}
-		if (0 == l2_key->vlan1.vid_mask) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " To spec MC vlan, Vlan-ID must be specified \n");
-			return(ERR_ACTION_INVALID);
-		} else if (l2_key->vlan1.vid == 0 || l2_key->vlan1.vid >= 4096) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Invalid multicast Vlan-ID is assigned \n");
-			return(ERR_L2_KEY_INVALID);
-		}
-		mc_vlan_free_slot = tpm_db_mc_vlan_get_pnc_index_free_slot(l2_key->vlan1.vid, rule_num);
-		if (0 == mc_vlan_free_slot) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " No more free slot for l2 rule of this MC vlan\n");
-			return(ERR_GENERAL);
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-/*******************************************************************************
-* tpm_proc_add_ds_load_balance_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_ds_load_balance_acl_rule params.
-*
-* INPUTS:
-* owner_id         - See tpm_proc_add_ds_load_balance_acl_rule
-* rule_num         - See tpm_proc_add_ds_load_balance_acl_rule
-* parse_rule_bm    - See tpm_proc_add_ds_load_balance_acl_rule
-* l2_key           - See tpm_proc_add_ds_load_balance_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ds_load_balance_check(uint32_t owner_id,
-						uint32_t rule_num,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_l2_acl_key_t *l2_key)
-{
-	int32_t ret_code;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pnc_range_conf_t rangConf;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Get Range_Id, rang configuration, to get range type */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_DS_LOAD_BALANCE_ACL, &range_id);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Check necessary pointers are valid */
-	if ((l2_key == NULL) && (parse_rule_bm != 0)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parsing requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-	IF_ERROR(ret_code);
-
-	/* Check parse_rule_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_DS_LOAD_BALANCE_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flag_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_DS_LOAD_BALANCE_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm(0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check Vlan Tag TPID mask */
-	if (parse_rule_bm & (TPM_L2_PARSE_TWO_VLAN_TAG | TPM_L2_PARSE_ONE_VLAN_TAG)) {
-		if ((l2_key->vlan1.tpid_mask != 0) && (l2_key->vlan1.tpid_mask != 0xffff)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid vlan1 tpid mask(0x%x) \n", l2_key->vlan1.tpid_mask);
-			return(ERR_L2_KEY_INVALID);
-		}
-
-		if (parse_rule_bm & TPM_L2_PARSE_ONE_VLAN_TAG) {
-			if ((l2_key->vlan2.tpid_mask != 0) && (l2_key->vlan2.tpid_mask != 0xffff)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid vlan2 tpid mask(0x%x) \n", l2_key->vlan2.tpid_mask);
-				return(ERR_L2_KEY_INVALID);
-			}
-		}
-	}
-
-	/* Cannot do Double Vlan Tag with looking into PPPoE (up to 24Bytes) with MH */
-	if ((parse_rule_bm & TPM_L2_PARSE_TWO_VLAN_TAG) &&
-	    ((parse_rule_bm & TPM_L2_PARSE_PPP_PROT) || (parse_rule_bm & TPM_L2_PARSE_PPPOE_SES))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parse map of Double Vlan Tag + PPPoE not supported\n");
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Cannot do Single or Double Vlan Tag with checking   PPP protocol (up to 24Bytes) with MH */
-	if (((parse_rule_bm & TPM_L2_PARSE_TWO_VLAN_TAG) || (parse_rule_bm & TPM_L2_PARSE_ONE_VLAN_TAG))
-	    && (parse_rule_bm & TPM_L2_PARSE_PPP_PROT)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parse map of Single Vlan Tag + PPPoE proto not supported\n");
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_DS_LOAD_BALANCE, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_DS_LOAD_BALANCE_ACL, rangConf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	return(TPM_RC_OK);
-}
-
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_check(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_db_pnc_range_t range_data;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check 5_tuple feature is disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, pkt_mod, pkt_frwd, (void *)ipv6_gen_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_GEN_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_GEN_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Packet Modification */
-#if 0
-	tpm_proc_pkt_mod_check(rule_action->pkt_act, pkt_mod_bm, pkt_mod);
-	IF_ERROR(ret_code);
-#endif
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_GEN, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_GEN, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV6_GEN_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		if ((rule_num < range_data.pnc_range_conf.api_start) || (rule_num > range_data.pnc_range_conf.api_end))
-			IF_ERROR(ERR_RULE_NUM_INVALID);
-	}
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_IPv6_DIP && rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_GEN_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_check(uint32_t owner_id,
-					     tpm_src_port_type_t src_port,
-					     uint32_t rule_num,
-					     tpm_parse_fields_t parse_rule_bm,
-					     tpm_parse_flags_t parse_flags_bm,
-					     tpm_ipv6_addr_key_t *ipv6_dip_key,
-					     tpm_pkt_frwd_t *pkt_frwd,
-					     tpm_pkt_mod_bm_t pkt_mod_bm,
-					     tpm_pkt_mod_t *pkt_mod,
-					     tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_db_pnc_range_t range_data;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-
-	/* Check 5_tuple feature is disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, pkt_mod, pkt_frwd, (void *)ipv6_dip_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_rule_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_DIP_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_DIP_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Packet Modification */
-#if 0
-	tpm_proc_pkt_mod_check(rule_action->pkt_act, pkt_mod_bm, pkt_mod);
-	IF_ERROR(ret_code);
-#endif
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_DIP, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_DIP, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV6_DIP_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		if ((rule_num < range_data.pnc_range_conf.api_start) || (rule_num > range_data.pnc_range_conf.api_end))
-			IF_ERROR(ERR_RULE_NUM_INVALID);
-	}
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_DIP_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_l4ports_check(uint32_t owner_id,
-						 tpm_src_port_type_t src_port,
-						 uint32_t rule_num,
-						 tpm_parse_fields_t parse_rule_bm,
-						 tpm_parse_flags_t parse_flags_bm,
-						 tpm_l4_ports_key_t *l4_key,
-						 tpm_pkt_frwd_t *pkt_frwd,
-						 tpm_pkt_mod_bm_t pkt_mod_bm,
-						 tpm_pkt_mod_t *pkt_mod,
-						 tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_db_pnc_range_t range_data;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check 5_tuple feature is disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_DISABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, pkt_mod, pkt_frwd, (void *)l4_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_rule_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Packet Modification */
-#if 0
-	tpm_proc_pkt_mod_check(rule_action->pkt_act, pkt_mod_bm, pkt_mod);
-	IF_ERROR(ret_code);
-#endif
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_L4, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_L4, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_L4_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		if ((rule_num < range_data.pnc_range_conf.api_start) || (rule_num > range_data.pnc_range_conf.api_end))
-			IF_ERROR(ERR_RULE_NUM_INVALID);
-	}
-
-	/* Check forwarding rule,  STAGE_DONE */
-	if (rule_action->next_phase != STAGE_IPv6_GEN && rule_action->next_phase != STAGE_DONE
-	    && rule_action->next_phase != STAGE_CTC_CM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	/* Check if next stage CTC CnM  */
-	if ((rule_action->next_phase == STAGE_CTC_CM) && !(parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CnM, packets must be MTM_FALSE\n");
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_nh_check(uint32_t owner_id,
-					    uint32_t rule_num,
-					    tpm_nh_iter_t nh_iter,
-					    tpm_parse_flags_t parse_flags_bm,
-					    uint32_t nh,
-					    tpm_pkt_frwd_t *pkt_frwd,
-					    tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_t range_data;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm = 0;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check keys exist for parse fields */
-	if (rule_action == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "rule_action cannot be NULL\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_frwd == NULL) && ((SET_TARGET_PORT(rule_action->pkt_act)) || SET_TARGET_QUEUE(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target set requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	/* Check Valid Target, ==> only allowed to direct to CPU */
-	if (SET_TARGET_PORT(rule_action->pkt_act)) {
-		if (TO_CPU(pkt_frwd->trg_port)) {
-			/*cont */
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "* trg_port=%d *\r\n", pkt_frwd->trg_port);
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Illegal Target Port\n");
-			return(ERR_FRWD_INVALID);
-		}
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Valid Queue */
-	/* TODO - Check Queue depending on actual queues in target or in Rx */
-	if (SET_TARGET_QUEUE(rule_action->pkt_act) && (pkt_frwd->trg_queue >= TPM_MAX_NUM_TX_QUEUE)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target Queue Out of Range\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_NH, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV6_NH_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		if ((rule_num < range_data.pnc_range_conf.api_start) || (rule_num > range_data.pnc_range_conf.api_end))
-			IF_ERROR(ERR_RULE_NUM_INVALID);
-	}
-
-	/* Check forwarding rule */
-	if (rule_action->next_phase != STAGE_IPV6_L4 &&
-		rule_action->next_phase != STAGE_IPv6_NH &&
-		rule_action->next_phase != STAGE_IPv6_GEN &&
-		rule_action->next_phase != STAGE_CTC_CM &&
-		rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	if (rule_action->next_phase == STAGE_IPV6_L4) {
-		if (nh != IPPROTO_UDP && nh != IPPROTO_TCP) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase is IPV6_L4 while NH(%d) is not UDP or TCP \n", nh);
-			return(ERR_NEXT_PHASE_INVALID);
-		}
-	}
-
-	if (rule_action->next_phase == STAGE_IPv6_NH && nh_iter == NH_ITER_1) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Multiple Ext Hdr is not supported \n");
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check if next stage CTC CnM  */
-	if (rule_action->next_phase == STAGE_CTC_CM) {
-		if (nh == IPPROTO_UDP || nh == IPPROTO_TCP) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next Phase is CTC_CM while NH(%d) is UDP or TCP \n", nh);
-			return(ERR_NEXT_PHASE_INVALID);
-		}
-		if (0 == (parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage is CnM, packets must be MTM_FALSE\n");
-			return(ERR_NEXT_PHASE_INVALID);
-		}
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, &pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_NH_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	/* when ds load balance on G0 and G1 is enabled, no 2 NH rule can be added */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	if (	(TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable)
-	     && (NH_ITER_1 == nh_iter)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "when ds load balance on G0 and G1 is enabled, "
-			"no 2 NH rule can be added\n");
-		return(ERR_FEAT_UNSUPPORT);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_ipv4_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_ipv4_acl_rule params.
-*
-* INPUTS:
-* - See tpm_proc_add_ipv4_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ipv4_check(uint32_t owner_id,
-					 tpm_src_port_type_t src_port,
-					 uint32_t rule_num,
-					 tpm_parse_fields_t parse_rule_bm,
-					 tpm_parse_flags_t parse_flags_bm,
-					 tpm_ipv4_acl_key_t *ipv4_key,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_pkt_mod_t *pkt_mod,
-					 tpm_rule_action_t *rule_action,
-					 tpm_pkt_mod_bm_t pkt_mod_bm)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pnc_range_conf_t rangConf;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id, rang configuration, to get range type */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_IPV4_ACL, &range_id);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, pkt_mod, pkt_frwd, (void *)ipv4_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_TRUE);
-	IF_ERROR(ret_code);
-
-	/* Check Packet Modification */
-#if 0
-	tpm_proc_pkt_mod_check(rule_action->pkt_act, pkt_mod_bm, pkt_mod);
-	IF_ERROR(ret_code);
-#endif
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV4_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV4_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV4, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV4_ACL, rangConf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check forwarding rule, support STAGE_DONE */
-	if (    rule_action->next_phase != STAGE_DONE
-		 && rule_action->next_phase != STAGE_CTC_CM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV4_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	if(rule_action->next_phase == STAGE_CTC_CM) {
-		if(!tpm_ctc_cm_ipv4_rule2cm(parse_flags_bm, rule_action)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, parse flag must be MTM_FALSE, and action can not be TO_CPU\n");
-			return(ERR_NEXT_PHASE_INVALID);
-		}
-		if(FROM_WAN(src_port)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, Src Port can not be WAN\n");
-			return(ERR_SRC_PORT_INVALID);
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_del_l2_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_del_l2_prim_acl_rule params.
-*
-* INPUTS:
-* owner_id         - See tpm_proc_del_l2_prim_acl_rule
-* src_port         - See tpm_proc_del_l2_prim_acl_rule
-* rule_idx         - See tpm_proc_del_l2_prim_acl_rule
-* parse_rule_bm    - See tpm_proc_del_l2_prim_acl_rule
-* l2_key           - See tpm_proc_del_l2_prim_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_l2_check(uint32_t owner_id,
-				       tpm_src_port_type_t src_port,
-				       uint32_t rule_idx,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_l2_acl_key_t *l2_key)
-{
-	int32_t ret_code;
-	uint32_t rule_num;
-	tpm_dir_t dir;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* check that rule_idx or parse_bm or l2_key are valid - for deletion */
-	if ((rule_idx == 0) && ((l2_key == NULL) || (parse_rule_bm == 0)))
-		IF_ERROR(ERR_DELETE_KEY_INVALID);
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_L2_PRIM, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Check valid rule_idx */
-
-	if (rule_idx != 0) {	/* when rule_idx = 0 -> caller indicates to work according to the l2_key */
-
-		ret_code = tpm_db_api_rulenum_get(TPM_L2_PRIM_ACL, rule_idx, &rule_num);
-		if (ret_code != TPM_OK)
-			IF_ERROR(ERR_RULE_IDX_INVALID);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_common_pncl_info_get()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* dir              - Direction of the API acl/table
-* api_rule_num     - Rulenum in the API table
-*
-* OUTPUTS:
-* pnc_entry        - PnC Entry matching this api_table/rule_num
-* lu_id            - LookupId of this PNC Range
-* start_offset     - Logical TCAM start offset of this API Table
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_common_pncl_info_get(tpm_pnc_ranges_t range_id, uint32_t *lu_id, tpm_pncl_offset_t *start_offset)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "range_id(%d)\n", range_id);
-
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	*lu_id = range_conf.base_lu_id;
-	start_offset->range_id = range_id;
-
-	if (    range_id == TPM_PNC_L2_MAIN || range_id == TPM_PNC_MAC_LEARN
-	     || range_id == TPM_PNC_DS_LOAD_BALANCE) {
-		start_offset->offset_base = TPM_PNCL_ZERO_OFFSET;
-		start_offset->offset_sub.subf = TPM_L2_PARSE_MH;
-	} else if (range_id == TPM_PNC_ETH_TYPE) {
-		start_offset->offset_base = TPM_PNCL_L3_OFFSET;
-		start_offset->offset_sub.subf = TPM_L2_PARSE_ETYPE;
-	} else if ((range_id == TPM_PNC_IPV4_MAIN)
-		   || (range_id == TPM_PNC_IPV4_MC_DS)
-		   || (range_id == TPM_PNC_IPV4_PROTO)
-		   || (range_id == TPM_PNC_CNM_IPV4_PRE)
-		   || (range_id == TPM_PNC_IGMP)) {
-		start_offset->offset_base = TPM_PNCL_IPV4_OFFSET;
-		start_offset->offset_sub.subf = TPM_IPv4_PARSE_VER_OR_IHL;
-	} else if (    (range_id == TPM_PNC_IPV6_NH)
-		    || (range_id == TPM_PNC_IPV6_GEN)
-		    || (range_id == TPM_PNC_IPV6_MC_SIP)) {
-		start_offset->offset_base = TPM_PNCL_IPV6_OFFSET;
-		start_offset->offset_sub.subf = TPM_IPv6_PARSE_VER_OR_DSCP;
-	} else if ((range_id == TPM_PNC_IPV6_DIP)
-		   || (range_id == TPM_PNC_IPV6_MC_DS)) {
-		start_offset->offset_base = TPM_PNCL_IPV6_OFFSET;
-		start_offset->offset_sub.subf = TPM_IPv6_PARSE_DIP;
-	} else if (range_id == TPM_PNC_IPV6_L4) {
-		start_offset->offset_base = TPM_PNCL_L4_OFFSET;
-		start_offset->offset_sub.subf = TPM_PARSE_L4_SRC;
-	} else if (range_id == TPM_PNC_CNM_MAIN) {
-		/* Dummy */
-	} else {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "range id not supported %d\n", range_id);
-		return(TPM_FAIL);
-	}
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_pnc_con_del()
-*
-* DESCRIPTION:     Function deletes a pnc connection structure
-*
-* INPUTS:
-* pnc_con          - APIPNC Table  Configuration
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_pnc_con_del(tpm_db_pnc_conn_t *pnc_con)
-{
-	uint32_t i, cur_pnc_range, cur_pnc_index, pnc_start, pnc_stop;
-	int32_t ret_code;
-	tpm_db_pnc_range_t range_data;
-
-	for (i = 0; i < (pnc_con->num_pnc_ranges); i++) {
-		cur_pnc_index = pnc_con->pnc_conn_tbl[i].pnc_index;
-		cur_pnc_range = pnc_con->pnc_conn_tbl[i].pnc_range;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "range(%d), ind(%d) \n", cur_pnc_range, cur_pnc_index);
-
-		ret_code = tpm_db_pnc_rng_get(cur_pnc_range, &range_data);
-		IF_ERROR(ret_code);
-
-		if (range_data.pnc_range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-			pnc_start = cur_pnc_index;
-			/* Pull range from this index untill last used entry in Pnc range */
-			pnc_stop = range_data.pnc_range_conf.range_start +
-				   (range_data.pnc_range_conf.api_end - range_data.pnc_range_oper.free_entries);
-
-			ret_code = tpm_pncl_entry_delete(pnc_start, pnc_stop);
-			IF_ERROR(ret_code);
-		} else {
-			ret_code = tpm_pncl_entry_reset(cur_pnc_index);
-			IF_ERROR(ret_code);
-		}
-		/* Increase number of free entries in pnc_range */
-		ret_code = tpm_db_pnc_rng_free_ent_inc(cur_pnc_range);
-		IF_ERROR(ret_code);
-	}
-	/* Init the pnc_con structure */
-	memset(pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_split_mod_stage1_check()
-*
-* DESCRIPTION:    function to check the mod in L2 observe to split mod or not
-*
-* INPUTS:
-*           pkt_mod_bm
-*           pkt_mod
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           if the mod observe to split mod, return true, or return false
-*
-* COMMENTS:
-*
-*******************************************************************************/
-bool tpm_split_mod_stage1_check(tpm_pkt_mod_bm_t pkt_mod_bm,
-				tpm_pkt_mod_t *pkt_mod,
-				tpm_rule_action_t *rule_action,
-				bool check_vlan_noop)
-{
-	bool temp;
-
-	if (NULL == pkt_mod)
-		return false;
-
-	if (rule_action->pkt_act & TPM_ACTION_SPEC_MC_VID)
-		return false;
-
-	if (!SET_MOD(rule_action->pkt_act))
-		return false;
-
-	if (STAGE_DONE == rule_action->next_phase)
-		return false;
-
-	if (check_vlan_noop) {
-		if(VLANOP_NOOP == pkt_mod->vlan_mod.vlan_op)
-			temp = true;
-		else
-			temp = false;
-	} else {
-		temp = false;
-	}
-
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(TPM_VLAN_MOD == pkt_mod_bm) &&
-		((VLANOP_EXT_TAG_MOD == pkt_mod->vlan_mod.vlan_op) ||
-			(VLANOP_EXT_TAG_INS == pkt_mod->vlan_mod.vlan_op) ||
-			(VLANOP_EXT_TAG_MOD_INS == pkt_mod->vlan_mod.vlan_op) || temp)) {
-
-		/* L2 {VID+p-bit} translation. In GPON mode
-		 * not set the SPLIT_MOD AI bit
-		 */
-		if (TPM_SPLIT_MOD_MODE_CTC == tpm_db_split_mod_get_mode())
-			return true;
-		else if ((VLANOP_EXT_TAG_MOD == pkt_mod->vlan_mod.vlan_op) &&
-			(pkt_mod->vlan_mod.vlan1_out.vid_mask == 0xffff) &&
-			(pkt_mod->vlan_mod.vlan1_out.pbit_mask == 0xff))
-			return false;
-		else
-			return true;
-	} else {
-		return false;
-	}
-
-}
-
-/*******************************************************************************
-* tpm_proc_l2_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-* OUTPUTS:
-* l2_tcam_data      - Logical TCAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_l2_tcam_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_parse_fields_t parse_rule_bm,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-		     src_port, dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* L2 Parsing, according to bm in param */
-	tcam_data->l2_parse_bm = parse_rule_bm;
-
-	/* Build the AI bits according to parse_flags */
-	/* Parse the vlan tag number AI bits */
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field, parse_flags_bm, 0, &(tcam_data->add_info_data),
-					  &(tcam_data->add_info_mask));
-
-	/*Parse MH for specific src_port or for gemport_parse request */
-	if (((FROM_SPEC_UNI(src_port)) && (!tpm_proc_gmac1_phy_src_port(src_port))) ||
-	    (parse_rule_bm & TPM_L2_PARSE_GEMPORT))
-		tcam_data->l2_parse_bm |= TPM_L2_PARSE_MH;
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (l2_key)
-		memcpy(&(tcam_data->pkt_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_L2_MAIN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_l2_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* pon_type          - WAN technology
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-* pkt_frwd          - See xxx
-* rule_action       - See xxx
-*
-* OUTPUTS:
-* l2_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_l2_sram_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_db_pon_type_t pon_type,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_rule_action_t *rule_action,
-			       uint32_t mod_cmd,
-			       tpm_pncl_sram_data_t *sram_data,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_pkt_mod_t *pkt_mod,
-			       tpm_pkt_mod_bm_t pkt_mod_bm)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_ai_vectors_t ai_vector;
-	uint32_t ai_bits;
-	long long int_pkt_act = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Unset DNRT bit (Do not Repeat Tags Phase), the bit is leftover from previous hardcoded Vlan_tags phase */
-	int_pkt_act |= (TPM_ACTION_UNSET_DNRT | TPM_ACTION_UNSET_DNRT_DS_TRUNK);
-
-	/* Set UNI Port */
-	if (FROM_SPEC_UNI(src_port)) {
-		int_pkt_act |= TPM_ACTION_SET_UNI_PORT;
-		ai_vector.src_port = src_port;
-	}
-	/* alloc AI bits if spec mc vlan.
-	 * Set_uni_port and mc_vid cannot happen at same time */
-	else if (rule_action->pkt_act & TPM_ACTION_SPEC_MC_VID) {
-		ret_code = tpm_db_mc_vlan_get_ai_bit_by_vid(l2_key->vlan1.vid, &ai_bits);
-		IF_ERROR(ret_code);
-
-		ai_vector.mc_vid_entry = ai_bits;
-	}
-
-	/* all tag/untag PNC with VLANOP_NOOP will set split mod AI */
-	if (tpm_split_mod_stage1_check(pkt_mod_bm, pkt_mod, rule_action, true)) {
-
-		/* all tag/untag PNC with VLANOP_NOOP will set split mod AI */
-		int_pkt_act |= TPM_ACTION_SET_SPLIT_MOD;
-	}
-
-	/* Set AI Bits */
-	tpm_proc_static_ai_sram_build(&ai_vector, rule_action->pkt_act, int_pkt_act,
-				      &(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Update dummy register (offset automatically=zero) */
-	/* The L3_offset_register was already updated in the TPM_PNC_NUM_VLAN_TAGS range */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-		/* Set L3, L4 to OTHER */
-		sram_data->l3_type = TPM_PNCL_L3_OTHER;
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-	} else if (rule_action->next_phase == STAGE_L3_TYPE) {
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_ETH_TYPE, &range_conf);
-		IF_ERROR(ret_code);
-
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		sram_data->next_lu_off_reg = TPM_PNC_ETY_REG;
-
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Signal specific packet types to CPU */
-	if (tpm_proc_bc_check(l2_key))
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_BC;
-	else if (tpm_proc_mc_check(l2_key))
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_MC;
-	else
-		sram_data->sram_updt_bm	|= TPM_PNCL_SET_UC;
-
-	/* Set Modification */
-	tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ds_load_balance_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* rule_num          - API rule number
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-*
-* OUTPUTS:
-* tcam_data         - Logical TCAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ds_load_balance_tcam_build(uint32_t rule_num,
-				       tpm_l2_acl_key_t *l2_key,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_parse_flags_t parse_flags_bm,
-				       tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	int32_t ret_code;
-	long long parse_int_flags = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) parse_rule_bm(%x)  \n", rule_num, parse_rule_bm);
-
-	/* L2 Parsing, according to bm in param */
-	tcam_data->l2_parse_bm = parse_rule_bm;
-
-	/* do not repeat this section again */
-	parse_int_flags |= TPM_PARSE_FLAG_DNRT_DS_TRUNK;
-
-	tpm_proc_parse_flag_ai_tcam_build(NULL, parse_flags_bm, parse_int_flags,
-				&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/*Parse MH for specific src_port or for gemport_parse request */
-	if (parse_rule_bm & TPM_L2_PARSE_GEMPORT)
-		tcam_data->l2_parse_bm |= TPM_L2_PARSE_MH;
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = TPM_SRC_PORT_WAN;
-	if (l2_key)
-		memcpy(&(tcam_data->pkt_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_DS_LOAD_BALANCE, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ds_load_balance_sram_build()
-*
-* DESCRIPTION:     Function builds a logical SRAM entry from the API data
-*
-* INPUTS:
-* rule_num          - API rule number
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-*
-* OUTPUTS:
-* sram_data         - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ds_load_balance_sram_build(uint32_t rule_num,
-				       tpm_pncl_sram_data_t *sram_data,
-				       tpm_l2_acl_key_t *l2_key,
-				       tpm_ds_load_balance_tgrt_t tgrt_port)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	uint32_t cpu_rx_queue = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) \n", rule_num);
-
-	sram_data->add_info_data |= (1 << TPM_AI_DNRT_DS_TRUNK_BIT_OFF);
-	sram_data->add_info_mask |= TPM_AI_DNRT_DS_TRUNK_MASK;
-
-	/* Update dummy register (offset automatically=zero) */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_L2_MAIN, &range_conf);
-	IF_ERROR(ret_code);
-
-	sram_data->next_lu_id = range_conf.base_lu_id;
-	sram_data->next_lu_off_reg = TPM_PNC_LU_REG0;
-
-	/* For Target set PNC TXP, GemPort */
-	sram_data->sram_updt_bm = TPM_PNCL_SET_TXP;
-	sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	if (TPM_DS_TGRT_G0 == tgrt_port)
-		sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC0;
-	else if (TPM_DS_TGRT_G1 == tgrt_port)
-		sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC1;
-	else {
-		/* Set lookup done and target */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-		sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-		tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-		sram_data->pnc_queue = cpu_rx_queue;
-
-		/* Set L3, L4 to OTHER */
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-		sram_data->l3_type = TPM_PNCL_L3_OTHER;
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-	}
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-* OUTPUTS:
-* tcam_data         - Logical TCAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ipv4_tcam_build(tpm_src_port_type_t src_port,
-				 tpm_dir_t dir,
-				 uint32_t rule_num,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 tpm_parse_fields_t parse_rule_bm,
-				 tpm_parse_flags_t parse_flags_bm,
-				 tpm_rule_action_t *rule_action,
-				 tpm_pkt_mod_t *pkt_mod,
-				 tpm_pkt_mod_bm_t pkt_mod_bm,
-				 tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	uint8_t l4_parse = 0, l4_hdr_update = 0;
-	/*uint8_t l4_hdr_update=0; */
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%d) \n",
-		     src_port, dir, rule_num, parse_rule_bm);
-
-	/* IPV4 Parsing, according to bm in param */
-	tcam_data->ipv4_parse_bm = parse_rule_bm;
-
-	/*Also Check ipv4_ver */
-	tcam_data->ipv4_parse_bm |= TPM_IPv4_PARSE_VER;
-	tcam_data->pkt_key.ipv4_add_key.ipv4_ver = 0x4;
-	tcam_data->pkt_key.ipv4_add_key.ipv4_ver_mask = 1;
-
-	/* If (this rule looks at L4 ports) THEN
-	   packet MUST not be fragmented AND
-	   packet MUST not have options (ihl=0x5). */
-	l4_parse = ((parse_rule_bm & TPM_PARSE_L4_SRC) || (parse_rule_bm & TPM_PARSE_L4_DST));
-
-	/* If (this rule does not look at L4 data,
-	   however it is performing packet modification that effects the L4 checksum) THEN
-	   packet must not be fragmented  */
-	l4_hdr_update = ((SET_MOD(rule_action->pkt_act)) && (L4_CHECK_MOD(pkt_mod_bm)));
-
-	if (l4_parse || l4_hdr_update) {
-		/* Must not be fragmented */
-		tcam_data->ipv4_parse_bm |= (TPM_IPv4_PARSE_FLAG_MF | TPM_IPv4_PARSE_FRAG_OFFSET);
-		tcam_data->pkt_key.ipv4_add_key.ipv4_frag_offset = 0;
-		tcam_data->pkt_key.ipv4_add_key.ipv4_frag_offset_mask = 1;
-		tcam_data->pkt_key.ipv4_add_key.ipv4_flags = 0;
-		tcam_data->pkt_key.ipv4_add_key.ipv4_flags_mask = 1;
-		if (l4_parse) {
-			/* No options */
-			tcam_data->ipv4_parse_bm |= (TPM_IPv4_PARSE_IHL);
-			tcam_data->pkt_key.ipv4_add_key.ipv4_ihl = 0x5;
-			tcam_data->pkt_key.ipv4_add_key.ipv4_ihl_mask = 1;
-		}
-	}
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* set CTC CnM */
-	/*if Ipv4 split, check AI bit, update tcam*/
-	if ((STAGE_CTC_CM == rule_action->next_phase) || ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD))) {
-
-		/*if Ipv4 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	/* Add AI bits (src_port, parse_flag_bits) */
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field,
-					  parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (ipv4_key)
-		memcpy(&(tcam_data->pkt_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV4_MAIN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_dscp_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* rule_num          - API rule number
-* target_queue      - CPU (Rx) or Hwf (Tx) Queue to set to
-* rule_num          - API rule number
-*
-* OUTPUTS:
-* l2_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ipv4_dscp_sram_build(uint32_t rule_num, uint8_t target_queue, tpm_pncl_sram_data_t *sram_data)
-{
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "rule_num(%d) \n", rule_num);
-
-	sram_data->add_info_data = 0;
-	sram_data->add_info_mask = 0;
-	sram_data->mh_reg.mh_set = TPM_FALSE;
-	sram_data->mh_reg.mh_reg = 0;
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-	sram_data->next_offset.offset_base = 0;
-	sram_data->next_offset.offset_sub.ipv4_subf = 0;
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Set Queue */
-	sram_data->pnc_queue = target_queue;
-	/* Set Lookup Done */
-	sram_data->sram_updt_bm = TPM_PNCL_SET_LUD;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "shift_updt_reg(%d), add_in_data(%x) add_in_mask(%x)",
-		     sram_data->shift_updt_reg, sram_data->add_info_data, sram_data->add_info_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* pon_type          - WAN technology
-* l2_key            - layer2 key data
-* ipv4_parse_bm     - Parse rules bitmap
-* pkt_frwd          - See xxx
-* rule_action       - See xxx
-*
-* OUTPUTS:
-* l2_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ipv4_sram_build(tpm_src_port_type_t src_port,
-				 tpm_dir_t dir,
-				 uint32_t rule_num,
-				 tpm_db_pon_type_t pon_type,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 tpm_parse_fields_t ipv4_parse_bm,
-				 tpm_parse_flags_t parse_flags_bm,
-				 tpm_pkt_frwd_t *pkt_frwd,
-				 tpm_rule_action_t *rule_action,
-				 uint32_t mod_cmd,
-				 tpm_pkt_mod_bm_t pkt_mod_bm,
-				 tpm_pkt_mod_t	  *pkt_mod,
-				 tpm_pncl_sram_data_t *sram_data)
-{
-	uint32_t l4_parse = 0;
-	tpm_db_pnc_range_conf_t range_conf;
-	long long int_pkt_act = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Check and set values for STAGE_DONE */
-	if (rule_action->next_phase == STAGE_DONE) {
-		/* DO NOTHING */
-		/* Note: Also for STAGE_DONE,
-		   the packet_len_check and ipv4_pkt_type lookups are performed. */
-	} else if (rule_action->next_phase != STAGE_CTC_CM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set next offset and update register */
-	sram_data->shift_updt_reg = TPM_PNC_LU_REG1;
-	sram_data->next_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	sram_data->next_offset.offset_sub.ipv4_subf = 0xFFFF;	/* For IPV4, this sets the offset to 126 */
-
-	/* If the l4_proto is parsed, then set udp/tcp/other, no need to parse again in later stage */
-	if (ipv4_parse_bm & TPM_IPv4_PARSE_PROTO) {
-		/* Set correct protocol */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_L4;
-
-		if (ipv4_key->ipv4_proto == IPPROTO_UDP)
-			sram_data->l4_type = TPM_PNCL_L4_UDP;
-		else if (ipv4_key->ipv4_proto == IPPROTO_TCP)
-			sram_data->l4_type = TPM_PNCL_L4_TCP;
-		else
-			sram_data->l4_type = TPM_PNCL_L4_OTHER;
-
-		/* No need to check proto in later stage */
-		int_pkt_act |= TPM_ACTION_SET_NO_PROTO_CHECK;
-	}
-
-	/*** Set next lookup configuration ***/
-
-	/* Following applies only to ROUTED/NAPT streams (mac-to-me=1), and not TO_CPU */
-	if ((parse_flags_bm & TPM_PARSE_FLAG_MTM_TRUE) &&
-	    ((parse_flags_bm & TPM_PARSE_FLAG_TO_CPU_TRUE) == 0) && ((rule_action->pkt_act & TPM_ACTION_TO_CPU) == 0)) {
-		/* For TCP NAPT, check the tcp_flags */
-		l4_parse = ((ipv4_parse_bm & TPM_PARSE_L4_SRC) || (ipv4_parse_bm & TPM_PARSE_L4_DST));
-		if (l4_parse && (sram_data->l4_type == TPM_PNCL_L4_TCP)) {
-			sram_data->next_lu_off_reg = TPM_PNC_LU_REG1;
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_TCP_FLAG, &range_conf);
-			IF_ERROR(ret_code);
-		}
-		/* For any other NAPT/ROUTE, check TTL */
-		else {
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_TTL, &range_conf);
-			IF_ERROR(ret_code);
-		}
-	} else if (rule_action->next_phase == STAGE_CTC_CM){
-		/* go to CTC stage */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_IPV4_PRE, &range_conf);
-		IF_ERROR(ret_code);
-
-		/* set IPv4 AI and set L4 type */
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_L4;
-
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG0;
-		/* set action IPv4 */
-		int_pkt_act = TPM_ACTION_SET_CNM_IPV4;
-	} else {  /* All others - Next lu_id = IPV4_PROTO/IPV4_FRAG/IPV4_LEN */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_PROTO, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG0;
-	}
-
-	sram_data->next_lu_id = range_conf.base_lu_id;
-
-	/* If fragmented packets are not allowed (set in tpm_proc_ipv4_tcam_build funct),
-	   no need to do additional parsing stage  */
-	/* TODO: A full check should also check the values of MF, FRAG_OFFSET,
-	   not just check they are part of the parse_rule_bm */
-	if (ipv4_parse_bm & (TPM_IPv4_PARSE_FLAG_MF | TPM_IPv4_PARSE_FRAG_OFFSET)) {
-		sram_data->l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_L3;
-		int_pkt_act |= TPM_ACTION_SET_NO_FRAG_CHECK;
-	}
-
-	if (pkt_mod_bm & TPM_PPPOE_ADD)
-		int_pkt_act |= TPM_ACTION_SET_ADD_PPPOE;
-
-	/* Reset AI bits for uni_ports  */
-	if (rule_action->next_phase != STAGE_CTC_CM)
-		int_pkt_act |= TPM_ACTION_UNSET_UNI_PORT;
-
-	/* Build AI_bits according to pkt_actions bitmap */
-
-	/* Set AI bits */
-	tpm_proc_static_ai_sram_build(NULL,
-				      rule_action->pkt_act, int_pkt_act, &(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Set Modification */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) {
-		/* split mod stage-2 */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-	else {
-		tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-	}
-
-	/* Set Target and Queue */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-		     "next_lu_id(%d), next_lu_off_reg(%d), next_off_base(%d), next_off_subf(%x), shift_updt_reg(%d)\n"
-		     "add_info_data(%x) add_info_mask(%x)\n", sram_data->next_lu_id, sram_data->next_lu_off_reg,
-		     sram_data->next_offset.offset_base, sram_data->next_offset.offset_sub.ipv4_subf,
-		     sram_data->shift_updt_reg, sram_data->add_info_data, sram_data->add_info_mask);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_gen_tcam_build(tpm_src_port_type_t src_port,
-				       tpm_dir_t dir,
-				       uint32_t rule_num,
-				       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_parse_flags_t parse_flags_bm,
-				       tpm_pkt_mod_t *pkt_mod,
-				       tpm_pkt_mod_bm_t pkt_mod_bm,
-				       tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-		     src_port, dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* IPV6 parsing, according to parse_rule */
-	tcam_data->ipv6_parse_bm = parse_rule_bm;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* set CTC CnM */
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	/* Build the AI bits according to parse_flags */
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field,
-					  parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (ipv6_gen_key)
-		memcpy(&(tcam_data->pkt_key.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_GEN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_gen_sram_build(tpm_src_port_type_t src_port,
-				       tpm_dir_t dir,
-				       uint32_t rule_num,
-				       tpm_db_pon_type_t pon_type,
-				       tpm_pkt_frwd_t *pkt_frwd,
-				       tpm_rule_action_t *rule_action,
-				       uint32_t mod_cmd,
-				       tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Set L3 */
-	sram_data->l3_type = TPM_PNCL_L3_IPV6;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_L3;
-
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-
-		/* Update dummy register (offset automatically=zero) */
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	} else if (rule_action->next_phase == STAGE_IPv6_DIP) {
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_DIP, &range_conf);
-		IF_ERROR(ret_code);
-
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		sram_data->next_lu_off_reg = TPM_PNC_IPV6_DIP_REG;
-
-		sram_data->next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-		sram_data->next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_DIP;
-		sram_data->shift_updt_reg = TPM_PNC_IPV6_DIP_REG;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_dip_tcam_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_ipv6_addr_key_t *ipv6_dip_key,
-				     tpm_parse_fields_t parse_rule_bm,
-				     tpm_parse_flags_t parse_flags_bm,
-				     tpm_pkt_mod_t *pkt_mod,
-				     tpm_pkt_mod_bm_t pkt_mod_bm,
-				     tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	int32_t ret_code;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-		     src_port, dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* IPV6 parsing, according to parse_rule */
-	tcam_data->ipv6_parse_bm = parse_rule_bm;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* Build the AI bits according to parse_flags */
-	/* set CTC CnM */
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field,
-					  parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-
-	if (ipv6_dip_key)
-		memcpy(&(tcam_data->pkt_key.ipv6_dip_key), ipv6_dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_DIP, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_dip_sram_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_db_pon_type_t pon_type,
-				     tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_rule_action_t *rule_action,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Update dummy register (offset automatically=zero) */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Next Stage */
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-
-	} else if (rule_action->next_phase == STAGE_IPv6_NH) {
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_NH, &range_conf);
-		IF_ERROR(ret_code);
-
-		/* Next phase offset already exists in REG_0 */
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG0;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_nh_tcam_build(uint32_t rule_num,
-				    tpm_nh_iter_t nh_iter,
-				    uint32_t nh,
-				    tpm_parse_flags_t parse_flags_bm,
-				    tpm_rule_action_t *rule_action,
-				    tpm_pncl_tcam_data_t *tcam_data)
-{
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) \n", rule_num);
-
-	if (nh != TPM_NH_RESERVED)
-		tcam_data->ipv6_parse_bm = TPM_IPv6_PARSE_NH;
-	else
-		tcam_data->ipv6_parse_bm = 0;
-
-	if (nh_iter == NH_ITER_0)
-		parse_int_flags_bm = TPM_PARSE_FLAG_NH2_ITER_FALSE;
-	else
-		parse_int_flags_bm = TPM_PARSE_FLAG_NH2_ITER_TRUE;
-
-	if (STAGE_CTC_CM == rule_action->next_phase) {
-		/*if next stage is CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	/* Insert AI_BITS */
-	tpm_proc_parse_flag_ai_tcam_build(NULL,
-					  parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Rule applies to LAN GMAC and WAN GMAC, use "special purpose" src_port */
-	tcam_data->port_ids = tpm_proc_all_gmac_bm();
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = TPM_SRC_PORT_WAN_OR_LAN;
-	tcam_data->pkt_key.ipv6_key.ipv6_next_header = nh;
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_NH, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-
-	if (nh_iter == NH_ITER_1) {
-		start_offset.offset_base = TPM_PNCL_IPV6_EXT_OFFSET;
-		start_offset.offset_sub.subf = TPM_IPv6_PARSE_NH;
-	}
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_nh_sram_build(uint32_t rule_num,
-					tpm_nh_iter_t nh_iter,
-					uint32_t nh,
-				    tpm_db_pon_type_t pon_type,
-				    tpm_pkt_frwd_t *pkt_frwd,
-				    tpm_rule_action_t *rule_action,
-				    tpm_pncl_sram_data_t *sram_data)
-{
-
-	tpm_db_pnc_range_conf_t range_conf;
-	int32_t ret_code;
-	tpm_dir_t dir;
-	long long int_pkt_act = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) \n", rule_num);
-
-	memset(sram_data, 0, sizeof(tpm_pncl_sram_data_t));
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-	dir = TPM_DIR_DS;	/*dummy_dir for bi_dir function */
-
-	/* Default, don't set MH */
-	sram_data->mh_reg.mh_set = TPM_FALSE;
-
-	/* Set the L4 protocol & the L4 AI bits, if udp or tcp */
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_L4;
-	if (nh == IPPROTO_UDP) {
-		sram_data->l4_type = TPM_PNCL_L4_UDP;
-		int_pkt_act |= TPM_ACTION_SET_L4P_TOG_UDP;
-	} else if (nh == IPPROTO_TCP) {
-		sram_data->l4_type = TPM_PNCL_L4_TCP;
-		int_pkt_act |= TPM_ACTION_SET_L4P_TOG_TCP;
-	} else
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-
-	if (nh_iter == NH_ITER_0) {
-		/* Calculated value, from start of IPV6_HDR untill end of it */
-		sram_data->next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-		sram_data->next_offset.offset_sub.ipv6_subf = 0xffff;	/* End of IPV6 Header */
-	} else {
-		/* Calculated value, from start of IPV6_HDR untill end of it */
-		sram_data->next_offset.offset_base = TPM_PNCL_IPV6_EXT_OFFSET;
-		sram_data->next_offset.offset_sub.ipv6_subf = 0xffff;	/* For IPV6 Ext Header, this sets the offset to 127 */
-	}
-
-	/* Sram update */
-	if (rule_action->next_phase == STAGE_IPV6_L4) {
-		/* Update PNC_REG_1 (L4_OFFSET_REG) with the IPV6_HDR_LEN (40) */
-		sram_data->shift_updt_reg = TPM_PNC_LU_REG1;	/* update L4_OFFSET_REG */
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG1;	/* lookup reg 1 */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_L4, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		int_pkt_act |= TPM_ACTION_UNSET_NH2_ITER;
-	} else if (rule_action->next_phase == STAGE_IPv6_NH) {
-		/* Update PNC_REG_1 (L4_OFFSET_REG) with the IPV6_HDR_LEN (40) */
-		sram_data->shift_updt_reg = TPM_PNC_LU_REG1;	/* update L4_OFFSET_REG */
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG1;	/* lookup reg 1 */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_NH, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		int_pkt_act |= TPM_ACTION_SET_NH2_ITER;
-	} else if (rule_action->next_phase == STAGE_IPv6_GEN) {
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_GEN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		int_pkt_act |= TPM_ACTION_UNSET_NH2_ITER;
-	} else if (rule_action->next_phase == STAGE_CTC_CM) {
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-		sram_data->next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		int_pkt_act |= TPM_ACTION_UNSET_CNM_IPV4 | TPM_ACTION_UNSET_IPV4_PRE_KEY;
-	} else if (rule_action->next_phase == STAGE_DONE)
-		tpm_proc_setstage_done(rule_action, sram_data);
-	else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " next phase not supported (%d)\n", rule_action->next_phase);
-		return(TPM_FAIL);
-	}
-
-	/* Set AI bits */
-	tpm_proc_static_ai_sram_build(NULL,
-				      rule_action->pkt_act, int_pkt_act, &(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_l4ports_tcam_build(tpm_src_port_type_t src_port,
-					 tpm_dir_t dir,
-					 uint32_t rule_num,
-					 tpm_l4_ports_key_t *l4_key,
-					 tpm_parse_fields_t parse_rule_bm,
-					 tpm_parse_flags_t parse_flags_bm,
-					 tpm_rule_action_t *rule_action,
-					 tpm_pkt_mod_t *pkt_mod,
-					 tpm_pkt_mod_bm_t pkt_mod_bm,
-					 tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-		     src_port, dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* L4 ports parsing, according to parse_rule */
-	tcam_data->l4_parse_bm = parse_rule_bm;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* Build the AI bits according to parse_flags */
-	src_port_field.src_port = src_port;
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((STAGE_CTC_CM == rule_action->next_phase) || ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD))) {
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field,
-					  parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-
-	if (l4_key)
-		memcpy(&(tcam_data->pkt_key.l4_ports_key), l4_key, sizeof(tpm_l4_ports_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_L4, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_l4ports_sram_build(tpm_src_port_type_t src_port,
-					 tpm_dir_t dir,
-					 uint32_t rule_num,
-					 tpm_db_pon_type_t pon_type,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_rule_action_t *rule_action,
-					 uint32_t mod_cmd,
-					 tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Update dummy register (offset automatically=zero) */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Next Stage */
-	if (rule_action->next_phase == STAGE_DONE)
-		tpm_proc_setstage_done(rule_action, sram_data);
-	else if (rule_action->next_phase == STAGE_CTC_CM) {
-		/* nothing to Update */
-		sram_data->next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-
-		sram_data->add_info_data &= ~(TPM_AI_CNM_IPV4_MASK | TPM_AI_CNM_IPV4_PRE_KEY_MASK);
-		sram_data->add_info_mask |= (TPM_AI_CNM_IPV4_MASK | TPM_AI_CNM_IPV4_PRE_KEY_MASK);
-	}
-	else if (rule_action->next_phase == STAGE_IPv6_GEN) {
-		/* nothing to Update */
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-		sram_data->next_lu_off_reg = 0; /* lookup reg 1 */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_GEN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	}
-	else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_api_entry_rulenum_inc()
-*
-* DESCRIPTION:    Function increases the rule_number for a range of api_rule_nums
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* dir              - Direction of the API acl/table
-* rule_inc_start   - First entry to increase rule_num
-* rule_inc_end     - Last entry to increase rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_api_entry_rulenum_inc(tpm_api_sections_t api_section, uint32_t rule_inc_start, uint32_t rule_inc_end)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " api_section(%d), rule_dec_start(%d), rule_dec_end(%d)\n",
-		     api_section, rule_inc_start, rule_inc_end);
-
-	/* Increase the pnc_connection of the API's in the range */
-	ret_code = tpm_db_pnc_conn_inc(api_section, rule_inc_start, rule_inc_end);
-	IF_ERROR(ret_code);
-
-	/* Increase the rule_num of the API's in the range */
-	ret_code = tpm_db_api_entry_rulenum_inc(api_section, rule_inc_start, rule_inc_end);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_api_entry_rulenum_dec()
-*
-* DESCRIPTION:    Function decreases the rule_number for a range of api_rule_nums
-*
-* INPUTS:
-* api_section      - Section of the API acl/table
-* dir              - Direction of the API acl/table
-* rule_dec_start   - First entry to decrease rule_num
-* rule_dec_end     - Last entry to decrease rule_num
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_api_entry_rulenum_dec(tpm_api_sections_t api_section, uint32_t rule_dec_start, uint32_t rule_dec_end)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " api_section(%d, rule_dec_start(%d), rule_dec_end(%d)\n",
-		     api_section, rule_dec_start, rule_dec_end);
-
-	/* Decrease the pnc_connection of the API's in the range */
-	ret_code = tpm_db_pnc_conn_dec(api_section, rule_dec_start, rule_dec_end);
-	IF_ERROR(ret_code);
-
-	/* Decrease the rule_num of the API's in the range */
-	ret_code = tpm_db_api_entry_rulenum_dec(api_section, rule_dec_start, rule_dec_end);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_get_cpu_lpbk_entry_num()
-*
-* DESCRIPTION: The API get the entry number from CPU loopback DB
-*
-* INPUTS:
-*         None
-*
-* OUTPUTS:
-*         None
-*
-* RETURNS:
-* CPU loopback entry number.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-uint32_t tpm_proc_get_cpu_lpbk_entry_num(void)
-{
-	return gn_cpu_lpbk_entry_num;
-}
-
-/*******************************************************************************
-* tpm_proc_increase_cpu_lpbk_entry_num()
-*
-* DESCRIPTION: The API get the entry number from CPU loopback DB
-*
-* INPUTS:
-*         None
-*
-* OUTPUTS:
-*         None
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_increase_cpu_lpbk_entry_num(void)
-{
-	gn_cpu_lpbk_entry_num++;
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_decrease_cpu_lpbk_entry_num()
-*
-* DESCRIPTION: The API get the entry number from CPU loopback DB
-*
-* INPUTS:
-*         None
-*
-* OUTPUTS:
-*         None
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_decrease_cpu_lpbk_entry_num(void)
-{
-	if (gn_cpu_lpbk_entry_num > 0)
-		gn_cpu_lpbk_entry_num--;
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_check_cpu_wan_loopback_param()
-*
-* DESCRIPTION: The API check the parameters of CPU loopback
-*
-* INPUTS:
-*           trg_port    - target tcont/LLID bitmap
-*           trg_queue   - target queue, 0-7
-*           gem_port    - target gem port ID
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_check_cpu_wan_loopback_param(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd)
-{
-	tpm_gmacs_enum_t act_wan = tpm_db_active_wan_get();
-	tpm_db_pon_type_t pon_type;
-
-	tpm_db_pon_type_get(&pon_type);
-
-	if (TO_PON(TPM_DIR_US, pkt_frwd->trg_port, pon_type, act_wan) ||
-	    TO_ETHWAN(TPM_DIR_US, pkt_frwd->trg_port, act_wan)) {
-		/*cont */
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "*Illegal Target Port: dir=%d, trg_port=%08x, pon_type=%d *\r\n",
-			     TPM_DIR_US, pkt_frwd->trg_port, pon_type);
-		return(ERR_FRWD_INVALID);
-	}
-
-	if (pkt_frwd->trg_queue >= TPM_MAX_NUM_TX_QUEUE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "trg_queue[%d] is illegal\n", pkt_frwd->trg_queue);
-		return ERR_GENERAL;
-	}
-
-	if (pkt_frwd->gem_port >= TPM_MAX_NUM_GEM_PORT) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "gem_port[%d] is illegal\n", pkt_frwd->gem_port);
-		return ERR_GENERAL;
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_calc_flow_id()
-*
-* DESCRIPTION:    Calculate flow id according to frwd information.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_calc_flow_id(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd, uint16_t *flow_id)
-{
-	uint32_t llid_idx = 0;
-
-	/*GPON mode */
-	if (pkt_frwd->gem_port)
-		*flow_id = pkt_frwd->gem_port;
-	/*EPON mode */
-	else {
-		/* Convert target port bitmap to llid number */
-		for (llid_idx = 0; llid_idx < 8; llid_idx++) {
-			if ((1 << llid_idx) & pkt_frwd->trg_port)
-				break;
-		}
-
-		/* Set default llid index */
-		if (llid_idx >= 8)
-			llid_idx = 0;
-
-		*flow_id = (llid_idx * TPM_MAX_NUM_TX_QUEUE) + pkt_frwd->trg_queue;
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_init_cpu_wan_loopback()
-*
-* DESCRIPTION: The API initialize CPU egress loopback data
-*
-* INPUTS:
-*
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_proc_init_cpu_wan_loopback(void)
-{
-
-	/* PnC and Modification Initialization are handled in global Init procedures,
-	   and not in this function. */
-
-	memset((uint8_t *) &gs_cpu_loopback[0], 0, sizeof(gs_cpu_loopback));
-	gn_cpu_lpbk_entry_num = 0;
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_init_cpu_wan_loopback()
-*
-* DESCRIPTION: The API initialize CPU egress loopback data
-*
-* INPUTS:
-*           flow_id - Flow ID as the index of loopback db
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           The pointer to specific CPU WAN loopback entry
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_cpu_loopback_t *tpm_proc_get_loopback_entry(uint16_t flow_id)
-{
-	if (flow_id >= TPM_MAX_CPU_LOOPBACK_NUM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " flow_id[%d] is illegal\n", flow_id);
-
-		return NULL;
-	}
-
-	return &gs_cpu_loopback[flow_id];
-}
-
-/*******************************************************************************
-* tpm_proc_add_cpu_loopback_rule()
-*
-* DESCRIPTION:    Main function for adding cpu loopback rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_cpu_loopback_rule(uint32_t owner_id,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_pkt_frwd_t *pkt_frwd)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint16_t flow_id = 0;
-	uint32_t pnc_entry = 0;
-	uint32_t mod_entry = 0;
-	uint32_t api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-
-	tpm_pkt_mod_t pkt_mod;
-	tpm_l2_acl_key_t l2_key;
-	tpm_rule_action_t rule_action;
-
-	if (!tpm_db_cpu_wan_lpbk_en_get()){
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "CPU WAN loopback has not been enabled\n");
-		IF_ERROR(ERR_FEAT_UNSUPPORT);
-	}
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d)\n", owner_id, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_cpu_loopback_check(owner_id, rule_num, pkt_frwd);
-	IF_ERROR(ret_code);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_CPU_LOOPBACK_ACL, &range_id);
-
-	/*********** Create Modification Entries **********/
-	memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-	pkt_mod.vlan_mod.vlan_op = VLANOP_EXT_TAG_DEL;
-	ret_code =
-	tpm_proc_create_mod(TPM_ACTION_SET_PKT_MOD, pkt_frwd->trg_port, &pkt_mod, TPM_VLAN_MOD, 0, &mod_entry,
-			    &trg_gmac);
-	IF_ERROR(ret_code);
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	memset(&l2_key, 0, sizeof(tpm_l2_acl_key_t));
-	l2_key.vlan1.tpid = TPM_MOD2_CPU_LOOPBACK_ETY;
-	l2_key.vlan1.tpid_mask = 0xffff;
-	l2_key.vlan1.vid_mask = 0xffff;
-	ret_code = tpm_proc_calc_flow_id(TPM_MOD_OWNER_TPM, pkt_frwd, &flow_id);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-	l2_key.vlan1.vid = flow_id;
-
-	int_ret_code =
-	tpm_proc_l2_tcam_build(TPM_SRC_PORT_UNI_ANY, TPM_DIR_US, rule_num, &l2_key, TPM_L2_PARSE_ONE_VLAN_TAG, 0,
-			       &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	memset(&rule_action, 0, sizeof(tpm_rule_action_t));
-	rule_action.next_phase = STAGE_DONE;
-	rule_action.pkt_act = TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE | TPM_ACTION_SET_PKT_MOD;
-	int_ret_code =
-	tpm_proc_l2_sram_build(TPM_SRC_PORT_UNI_ANY, TPM_DIR_US, rule_num, pon_type, pkt_frwd, &rule_action,
-			       mod_entry, &(pnc_data.pncl_sram), &l2_key, &pkt_mod, 0);
-	IF_ERROR(int_ret_code);
-
-	/*** Insert the PNC Entry ***/
-	tpm_proc_create_acl_pnc_entry(TPM_CPU_LOOPBACK_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-	IF_ERROR(int_ret_code);
-
-	/*********** Update API Range in DB **********/
-
-	/* Set PNC API data */
-	api_data.l2_prim_key.src_port = TPM_SRC_PORT_UNI_ANY;
-	api_data.l2_prim_key.parse_rule_bm = TPM_L2_PARSE_ONE_VLAN_TAG;
-	api_data.l2_prim_key.parse_flags_bm = 0;
-	api_data.l2_prim_key.pkt_mod_bm = TPM_VLAN_MOD;
-	memcpy(&(api_data.l2_prim_key.rule_action), &rule_action, sizeof(tpm_rule_action_t));
-	memcpy(&(api_data.l2_prim_key.l2_key), &l2_key, sizeof(tpm_l2_acl_key_t));
-	memcpy(&(api_data.l2_prim_key.pkt_mod), &pkt_mod, sizeof(tpm_pkt_mod_t));
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.l2_prim_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.l2_prim_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set API modification data */
-	tpm_proc_set_api_moddata(rule_action.pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-	if (rule_num < api_rng_entries) {
-		int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_CPU_LOOPBACK_ACL, rule_num, (api_rng_entries - 1));
-		IF_ERROR(int_ret_code);
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_CPU_LOOPBACK_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_cpu_wan_loopback()
-*
-* DESCRIPTION: The API add CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:   owner_id    - APP owner id  should be used for all API calls.
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-*
-* OUTPUTS:
-*           mod_idx     - Returned by HW modification, to fill Tx description
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_cpu_wan_loopback(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd, uint32_t *mod_idx)
-{
-	int32_t ret_code;
-	tpm_init_cpu_loopback_t cpu_loopback_val;
-	tpm_pkt_mod_t mod_data;
-	uint32_t rule_idx = 0;
-	uint16_t flow_id = 0;
-	tpm_cpu_loopback_t *lpbk_entry = NULL;
-	uint32_t lpbk_num = 0;
-
-	if (!tpm_db_cpu_wan_lpbk_en_get()){
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "CPU WAN loopback has not been enabled\n");
-		IF_ERROR(ERR_FEAT_UNSUPPORT);
-	}
-
-	/* Verify whether input parameters are legal */
-	ret_code = tpm_proc_check_cpu_wan_loopback_param(owner_id, pkt_frwd);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Get flow ID */
-	ret_code = tpm_proc_calc_flow_id(TPM_MOD_OWNER_TPM, pkt_frwd, &flow_id);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Get CPU WAN loopback entry from DB */
-	lpbk_entry = tpm_proc_get_loopback_entry(flow_id);
-	if (lpbk_entry == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return ERR_GENERAL;
-	}
-
-	/* Check whether the target has already been created, this validation is put at the */
-	/* first because of performance consideration.                                      */
-	if (TPM_TRUE == lpbk_entry->in_use) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "CPU loopback: target already exsit, return \r\n");
-		*mod_idx = lpbk_entry->mod_idx;
-		return TPM_RC_OK;
-	}
-
-	/* Get CPU loopback state: disabled / enabled */
-	ret_code = tpm_db_cpu_loopback_get(&cpu_loopback_val);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Do nothing if CPU loopback function is disabled */
-	if (TPM_CPU_LOOPBACK_DISABLED == cpu_loopback_val) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "CPU loopback disabled, return \r\n");
-		return TPM_RC_OK;
-	}
-
-	/* Check whether CPU loopback entry number exceed the Max value */
-	lpbk_num = tpm_proc_get_cpu_lpbk_entry_num();
-	if (lpbk_num >= TPM_MAX_CPU_LOOPBACK_ENTRY) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]:(%d) Exceed MAX entry number\r\n", __func__, __LINE__,
-			     lpbk_num);
-		return ERR_GENERAL;
-	}
-
-	/* Add modification rules to GMAC1, and get mod index */
-	memset((uint8_t *) &mod_data, 0, sizeof(tpm_pkt_mod_t));
-	mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_INS;
-	mod_data.vlan_mod.vlan1_out.tpid = TPM_MOD2_CPU_LOOPBACK_ETY;
-	mod_data.vlan_mod.vlan1_out.tpid_mask = TPM_MOD2_NEW_TPID;
-	mod_data.vlan_mod.vlan1_out.vid = flow_id;
-	mod_data.vlan_mod.vlan1_out.vid_mask = TPM_MOD2_NEW_VID;
-	mod_data.vlan_mod.vlan1_out.cfi = 0;
-	mod_data.vlan_mod.vlan1_out.cfi_mask = TPM_MOD2_NEW_CFI;
-	mod_data.vlan_mod.vlan1_out.pbit = 0;
-	mod_data.vlan_mod.vlan1_out.pbit_mask = TPM_MOD2_NEW_PBIT;
-	ret_code = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, TPM_ENUM_GMAC_1, TPM_VLAN_MOD, 0, &mod_data, mod_idx);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Add PnC rules including modification to GMAC0 and PON MAC */
-	/* Rule number will always be 0 in ACL mode */
-	ret_code = tpm_proc_add_cpu_loopback_rule(TPM_MOD_OWNER_TPM, 0, &rule_idx, pkt_frwd);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Save to DB */
-	lpbk_entry->trg_port = pkt_frwd->trg_port;
-	lpbk_entry->trg_queue = pkt_frwd->trg_queue;
-	lpbk_entry->gem_port = pkt_frwd->gem_port;
-	lpbk_entry->mod_idx = *mod_idx;
-	lpbk_entry->rule_idx = rule_idx;
-	lpbk_entry->in_use = TPM_TRUE;
-
-	tpm_proc_increase_cpu_lpbk_entry_num();
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_del_cpu_wan_loopback()
-*
-* DESCRIPTION: The API delete CPU egress loopback modification and PnC rules for
-*              specific Tcont/queue/gem_port
-*
-* INPUTS:   owner_id    - APP owner id  should be used for all API calls.
-*           pkt_frwd    - packet forwarding info: target tcont/LLID number, 0-7
-*                         target queue, 0-7, target gem port ID
-*
-* OUTPUTS:
-*           NONE
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_cpu_wan_loopback(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd)
-{
-	int32_t ret_code;
-	tpm_init_cpu_loopback_t cpu_loopback_val;
-	uint16_t flow_id = 0;
-	tpm_cpu_loopback_t *lpbk_entry = NULL;
-
-	if (!tpm_db_cpu_wan_lpbk_en_get()){
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "CPU WAN loopback has not been enabled\n");
-		IF_ERROR(ERR_FEAT_UNSUPPORT);
-	}
-
-	/* Verify whether input parameters are legal */
-	ret_code = tpm_proc_check_cpu_wan_loopback_param(owner_id, pkt_frwd);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Get CPU loopback state: disabled / enabled */
-	ret_code = tpm_db_cpu_loopback_get(&cpu_loopback_val);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " recvd ret_code(%d)\r\n", ret_code);
-		return(ret_code);
-	}
-
-	/* Do nothing if CPU loopback function is disabled */
-	if (TPM_CPU_LOOPBACK_DISABLED == cpu_loopback_val) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "CPU loopback disabled, return \r\n");
-		return TPM_RC_OK;
-	}
-
-	/* Get flow ID */
-	ret_code = tpm_proc_calc_flow_id(TPM_MOD_OWNER_TPM, pkt_frwd, &flow_id);
-	if (ret_code != TPM_RC_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return(ret_code);
-	}
-
-	/* Get CPU WAN loopback entry from DB */
-	lpbk_entry = tpm_proc_get_loopback_entry(flow_id);
-	if (lpbk_entry == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "%s[Line(%d)]: recvd ret_code(%d) \r\n", __func__, __LINE__,
-			     ret_code);
-		return ERR_GENERAL;
-	}
-
-	/* Delete related GMAC1 mod and PnC rule if the entry already exsit */
-	if (TPM_TRUE == lpbk_entry->in_use) {
-		/* Delete GMAC1 modification */
-		ret_code = tpm_mod2_entry_del(TPM_MOD_OWNER_TPM, TPM_ENUM_GMAC_1, lpbk_entry->mod_idx);
-		if (ret_code != TPM_RC_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " tpm_mod2_entry_del error, ret_code(%d)\r\n", ret_code);
-			return(ret_code);
-		}
-
-		/* Delete PnC rule and PON MAC modification */
-		ret_code = tpm_proc_del_acl_rule(TPM_CPU_LOOPBACK_ACL, TPM_MOD_OWNER_TPM, lpbk_entry->rule_idx, TPM_FALSE);
-		if (ret_code != TPM_RC_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " tpm_proc_del_acl_rule error, ret_code(%d)\r\n", ret_code);
-			return(ret_code);
-		}
-
-		/* Delete entry from DB */
-		memset(lpbk_entry, 0, sizeof(tpm_cpu_loopback_t));
-		lpbk_entry->in_use = TPM_FALSE;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "loopback entry non-existing, recvd ret_code(%d) \r\n", ret_code);
-		return ERR_GENERAL;
-	}
-
-
-	tpm_proc_decrease_cpu_lpbk_entry_num();
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_add_l2_prim_acl_rule()
-*
-* DESCRIPTION:    Main function for adding L2 API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_l2_prim_acl_rule(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l2_acl_key_t *l2_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, mod_entry_tmp = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0, bi_dir = 0, update_sram_only = 0;
-	tpm_gmacs_enum_t trg_gmac, duplicate_gmac;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_api_lu_conf_t lu_conf;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_l2_check(owner_id, src_port, rule_num, parse_rule_bm,
-					 l2_key, parse_flags_bm, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_L2_PRIM_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Only do it in table mode */
-	if (TPM_RANGE_TYPE_TABLE == rangConf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_L2_PRIM_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d) already exists\n",
-				     owner_id, src_port, rule_num);
-
-			/* TCAM Key and modification info are not changed, only update SRAM */
-			if ((0 == memcmp(l2_key, &api_data.l2_prim_key.l2_key, sizeof(tpm_l2_acl_key_t)))
-			    && (src_port == api_data.l2_prim_key.src_port)
-			    && (parse_rule_bm == api_data.l2_prim_key.parse_rule_bm)
-			    && (parse_flags_bm == api_data.l2_prim_key.parse_flags_bm)
-			    && (SET_MOD(rule_action->pkt_act) == SET_MOD(api_data.l2_prim_key.rule_action.pkt_act))) {
-				/* No modification */
-				if (!SET_MOD(rule_action->pkt_act))
-					update_sram_only = 1;
-				/* There are modification, then check furthur */
-				else if ((pkt_mod_bm == api_data.l2_prim_key.pkt_mod_bm)
-					 && (0 ==
-					     memcmp(pkt_mod, &api_data.l2_prim_key.pkt_mod, sizeof(tpm_pkt_mod_t)))) {
-					update_sram_only = 1;
-					mod_entry = mod_con.mod_cmd_ind;
-					trg_gmac = mod_con.mod_cmd_mac;
-				}
-			}
-
-			/* TCAM Key or modification info is changed */
-			if (!update_sram_only) {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-					     " owner(%d) src_port(%d), rule_num(%d) TCAM key/modification changed\n",
-					     owner_id, src_port, rule_num);
-
-				tpm_proc_del_l2_prim_acl_rule(owner_id, rule_num, TPM_INT_CALL);
-				IF_ERROR(ret_code);
-			}
-		}
-	}
-
-	if (    (!update_sram_only)
-	     && (SET_MOD(rule_action->pkt_act))) {
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* if split mod is enable, add split rule if possible*/
-		if (tpm_split_mod_stage1_check(pkt_mod_bm, pkt_mod, rule_action, false)) {
-			/* split mod stage-1 */
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-1\n");
-			/* get mod index from p-bit value */
-			ret_code = tpm_mod2_split_mod_create_l2_pmts(trg_gmac, pkt_mod, false);
-			if (TPM_RC_OK != ret_code)
-			{
-				TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "failed to add pmt split mod stage-1\n");
-				return(TPM_FAIL);
-			}
-			int_ret_code = tpm_db_mod2_split_mod_get_vlan_index(trg_gmac, pkt_mod, &mod_entry_tmp);
-			if (TPM_DB_OK != int_ret_code) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-1, failed to get pmt entry\n");
-				return ERR_MOD_INVALID;
-			}
-
-			mod_entry = mod_entry_tmp * 16;
-
-			/* VLANOP_EXT_TAG_MOD_INS mod insert VLAN p_bit*/
-			if (VLANOP_EXT_TAG_MOD_INS == pkt_mod->vlan_mod.vlan_op) {
-				if (pkt_mod->vlan_mod.vlan2_out.pbit_mask == 0xff)
-					mod_entry += (pkt_mod->vlan_mod.vlan2_out.pbit + 1);
-			} else {
-				if (pkt_mod->vlan_mod.vlan1_out.pbit_mask == 0xff)
-					mod_entry += (pkt_mod->vlan_mod.vlan1_out.pbit + 1);
-			}
-
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-
-			/* when ds load balance on G0 and G1 is enabled, need to duplicate DS PMT on G0/1 */
-			tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-			if (    (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable)
-			     && (TPM_ENUM_GMAC_0 == trg_gmac || TPM_ENUM_GMAC_1 == trg_gmac)) {
-
-				/* if this is DS and DS_MAC_BASED_TRUNK is ENABLED */
-				if (trg_gmac == TPM_ENUM_GMAC_0)
-					duplicate_gmac = TPM_ENUM_GMAC_1;
-				else
-					duplicate_gmac = TPM_ENUM_GMAC_0;
-
-				ret_code = tpm_mod2_split_mod_create_l2_pmts(duplicate_gmac, pkt_mod, false);
-				if (TPM_RC_OK != ret_code)
-				{
-					TPM_OS_ERROR(TPM_MODZ2_HM_MOD,
-						"failed to add pmt split mod stage-1 for duplicate GMAC\n");
-					tpm_mod2_split_mod_try_pmt_entry_del(TPM_L2_PRIM_ACL, trg_gmac, mod_entry_tmp);
-					return(TPM_FAIL);
-				}
-
-			}
-		} else if((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-							(TPM_VLAN_MOD == pkt_mod_bm) &&
-							(VLANOP_NOOP == pkt_mod->vlan_mod.vlan_op) &&
-							(parse_flags_bm & TPM_PARSE_FLAG_TAG1_FALSE)) {
-			/*In L2 range, all untag PNC with VLANOP_NOOP will set PMT to 16*/
-			mod_entry = 16;
-		} else {
-		    /*********** Create Modification Entries **********/
-			ret_code =
-			tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm,
-					    0 /*int_mod_bm */ ,
-					    &mod_entry, &trg_gmac);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_l2_tcam_build(src_port, dir, rule_num, l2_key, parse_rule_bm,
-					      parse_flags_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_l2_sram_build(src_port, dir, rule_num, pon_type, pkt_frwd, rule_action,
-					      mod_entry, &(pnc_data.pncl_sram), l2_key, pkt_mod, pkt_mod_bm);
-	IF_ERROR(int_ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_L2_PRIM_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-	/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_L2_PRIM_ACL, rule_num, update_sram_only, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	if (!update_sram_only) {
-		/* Set PNC API data */
-		api_data.l2_prim_key.src_port = src_port;
-		api_data.l2_prim_key.parse_rule_bm = parse_rule_bm;
-		api_data.l2_prim_key.parse_flags_bm = parse_flags_bm;
-		api_data.l2_prim_key.pkt_mod_bm = pkt_mod_bm;
-		memcpy(&(api_data.l2_prim_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-		if (l2_key)
-			memcpy(&(api_data.l2_prim_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-
-		if (pkt_frwd != NULL)
-			memcpy(&(api_data.l2_prim_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-		else
-			memset(&(api_data.l2_prim_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-		if (pkt_mod != NULL)
-			memcpy(&(api_data.l2_prim_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-		else
-			memset(&(api_data.l2_prim_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-		/* Set API modification data */
-		tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-		/* Set Pnc Connection data */
-		pnc_conn.num_pnc_ranges = 1;
-		pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-		pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-		if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-			/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-			if (rule_num < api_rng_entries) {
-				int_ret_code =
-				tpm_proc_api_entry_rulenum_inc(TPM_L2_PRIM_ACL, rule_num, (api_rng_entries - 1));
-				IF_ERROR(int_ret_code);
-			}
-		}
-
-		/* Set new API Entry */
-		int_ret_code = tpm_db_api_entry_set(TPM_L2_PRIM_ACL, rule_num, 0 /*bi_dir */ ,
-						    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-		IF_ERROR(int_ret_code);
-
-		/* Return Output */
-		*rule_idx = l_rule_idx;
-
-		/* Set aging counter group nunmber and msk */
-		int_ret_code = tpm_db_pnc_get_lu_conf(TPM_PNC_L2_MAIN, &lu_conf);
-		IF_ERROR(int_ret_code);
-		tpm_tcam_set_lu_mask(pnc_entry, (int32_t) lu_conf.lu_mask);
-		tpm_tcam_set_cntr_group(pnc_entry, (int32_t) lu_conf.cntr_grp);
-
-		/* alloc rule index if spec mc vlan */
-		if ((rule_action->pkt_act & TPM_ACTION_SPEC_MC_VID) && (dir == TPM_DIR_DS)) {
-			ret_code = tpm_db_mc_vlan_set_ai_bit_pnc_index(l2_key->vlan1.vid, l_rule_idx);
-			IF_ERROR(ret_code);
-		}
-	} else {
-		if (pkt_frwd != NULL)
-			memcpy(&(api_data.l2_prim_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-		else
-			memset(&(api_data.l2_prim_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-		int_ret_code = tpm_db_api_entry_invalidate(TPM_L2_PRIM_ACL, rule_num);
-		IF_ERROR(int_ret_code);
-
-		/* Set new API Entry */
-		int_ret_code = tpm_db_api_entry_set(TPM_L2_PRIM_ACL, rule_num, 0 /*bi_dir */ ,
-						    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-		IF_ERROR(int_ret_code);
-
-		/* Return Output */
-		*rule_idx = l_rule_idx;
-	}
-
-	return(TPM_RC_OK);
-}
-
-
-/*******************************************************************************
-* tpm_proc_add_ds_load_balance_acl_rule()
-*
-* DESCRIPTION:    Main function for adding DS load balance API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ds_load_balance_acl_rule(uint32_t owner_id,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l2_acl_key_t *l2_key,
-					       tpm_ds_load_balance_tgrt_t tgrt_port)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	uint32_t bi_dir;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_api_lu_conf_t lu_conf;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d), rule_num(%d)\n", owner_id, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ds_load_balance_check(owner_id, rule_num, parse_rule_bm, parse_flags_bm, l2_key);
-	IF_ERROR(ret_code);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_DS_LOAD_BALANCE_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Only do it in table mode */
-	if (TPM_RANGE_TYPE_TABLE == rangConf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_DS_LOAD_BALANCE_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) , rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ds_load_balance_acl_rule(owner_id, rule_num, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		} else {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) , rule_num(%d) is a new entry\n", owner_id, rule_num);
-		}
-	}
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ds_load_balance_tcam_build(rule_num, l2_key,
-				parse_rule_bm, parse_flags_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ds_load_balance_sram_build(rule_num, &(pnc_data.pncl_sram), l2_key, tgrt_port);
-	IF_ERROR(int_ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_DS_LOAD_BALANCE_ACL, rule_num, &pnc_data,
-					&pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-	/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_DS_LOAD_BALANCE_ACL, rule_num, 0,
-						&pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	/* Set PNC API data */
-	api_data.l2_prim_key.parse_rule_bm = parse_rule_bm;
-	if (l2_key)
-		memcpy(&(api_data.l2_prim_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			int_ret_code =
-			tpm_proc_api_entry_rulenum_inc(TPM_DS_LOAD_BALANCE_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_DS_LOAD_BALANCE_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	/* Set aging counter group nunmber and msk */
-	int_ret_code = tpm_db_pnc_get_lu_conf(TPM_PNC_DS_LOAD_BALANCE, &lu_conf);
-	IF_ERROR(int_ret_code);
-	tpm_tcam_set_lu_mask(pnc_entry, (int32_t) lu_conf.lu_mask);
-	tpm_tcam_set_cntr_group(pnc_entry, (int32_t) lu_conf.cntr_grp);
-
-	return(TPM_RC_OK);
-}
-
-
-/*******************************************************************************
-* tpm_proc_del_ds_load_balance_acl_rule()
-*
-* DESCRIPTION:    Main function for deleting DS load balance API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_ds_load_balance_acl_rule(uint32_t owner_id, uint32_t rule_idx, uint32_t ext_call)
-{
-
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_DS_LOAD_BALANCE_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_pnc_create(tpm_pnc_ranges_t range_id, uint32_t pnc_entry, tpm_pncl_pnc_full_t *pnc_data)
-{
-
-	int32_t int_ret_code;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_pncl_entry_set(pnc_entry, pnc_data);
-	IF_ERROR(int_ret_code);
-
-	/* Decrease number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(range_id);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_l2_num_vlan_tags_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_l2_num_vlan_tags_init(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, l2_lu, pnc_entry, dtag_entries, exp_entry;
-	tpm_db_pnc_range_t range_data;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_init_tpid_opt_t tpid_opt;
-	tpm_init_double_tag_t dbl_tag;
-	uint32_t i;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&tpid_opt, 0, sizeof(tpm_init_tpid_opt_t));
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_NUM_VLAN_TAGS, &range_data);
-	IF_ERROR(int_ret_code);
-	l2_lu = range_data.pnc_range_conf.base_lu_id;
-	free_entries = range_data.pnc_range_oper.free_entries;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "free_ent(%d)\n", free_entries);
-
-	/* Get tag TPID options */
-	int_ret_code = tpm_db_default_tag_tpid_get(&tpid_opt);
-	IF_ERROR(int_ret_code);
-
-	if (tpid_opt.opt_num == 0) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "none vlan tpid option! \n");
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	dtag_entries = 0;
-	for (i = 0; i < tpid_opt.opt_num; i++) {
-		if (tpid_opt.opt[i].v2_tpid != MV_TPM_UN_INITIALIZED_INIT_PARAM)
-			dtag_entries++;
-	}
-
-	if (dtag_entries == tpid_opt.opt_num) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "none single tag tpid option! \n");
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	exp_entry = tpid_opt.opt_num;
-
-	tpm_db_double_tag_support_get(&dbl_tag);
-	if (dbl_tag == TPM_DOUBLE_TAG_DISABLED)
-		exp_entry -= dtag_entries;
-
-	if ((exp_entry+1) > free_entries) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "not enough tag_num rules! (%d/%d)\n", free_entries, tpid_opt.opt_num+1);
-		IF_ERROR(ERR_GENERAL);
-	} else if ((exp_entry+1) < free_entries)
-		TPM_OS_WARN(TPM_TPM_LOG_MOD, "too much tag_num rules, waste. (%d/%d)\n", free_entries, tpid_opt.opt_num+1);
-
-	pnc_entry = range_data.pnc_range_conf.range_start+range_data.pnc_range_conf.api_start;
-	/* Basic TCAM/SRAM Config, valid for all following entries */
-	/* L2 LUID */
-	pnc_data.pncl_tcam.lu_id = range_data.pnc_range_conf.base_lu_id;
-	/* Bi-direction */
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	/* Current Offset */
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-	/* Set parse type for key */
-	pnc_data.pncl_tcam.l3_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	pnc_data.pncl_tcam.tcp_parse_bm = 0;
-	/* Set DO_NOT_REPEAT_TAG AI filter */
-	pnc_data.pncl_tcam.add_info_data = 0 << TPM_AI_DNRT_BIT_OFF;
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_DNRT_MASK;
-	/* Next LUID is still L2 */
-	pnc_data.pncl_sram.next_lu_id = range_data.pnc_range_conf.base_lu_id;
-	/* Using off_reg 1 */
-	pnc_data.pncl_sram.next_lu_off_reg = 1;
-	/* Update off_reg 0 -> ETY */
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_L2_PARSE_ETYPE;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_ETY_REG;
-	/* No queue update */
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	/* No ResultInfo&FlowId update */
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-
-
-	/*************************************/
-	/* CREATE ENTRIES FOR DOUBLE TAGGED **/
-	/*************************************/
-
-	if (dbl_tag == TPM_DOUBLE_TAG_ENABLED) {
-		/* Set L2 key value */
-		pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_TWO_VLAN_TAG;
-
-		/* Set DO_NOT_REPEAT_TAG AI filter */
-		pnc_data.pncl_sram.add_info_data = 1 << TPM_AI_DNRT_BIT_OFF;
-		pnc_data.pncl_sram.add_info_mask = TPM_AI_DNRT_MASK;
-		/* Set DOUBLE_TAG AI filter */
-		pnc_data.pncl_sram.add_info_data |= 1 << TPM_AI_TAG1_BIT_OFF;
-		pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG1_MASK;
-		pnc_data.pncl_sram.add_info_data |= 1 << TPM_AI_TAG2_BIT_OFF;
-		pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG2_MASK;
-
-		/* Set VLAN Result_Info bit */
-		pnc_data.pncl_sram.sram_updt_bm  |= TPM_PNCL_SET_TAGGED;
-
-		for (i = 0; i < tpid_opt.opt_num; i++) {
-			if (tpid_opt.opt[i].v2_tpid != MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-				/* Set TPID of vlan tag */
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid = tpid_opt.opt[i].v1_tpid;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid_mask = 0xffff;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.pbit_mask = 0;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.cfi_mask = 0;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.vid_mask = 0;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.tpid = tpid_opt.opt[i].v2_tpid;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.tpid_mask = 0xffff;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.pbit_mask = 0;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.cfi_mask = 0;
-				pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.vid_mask = 0;
-
-				/* Create Entry in PnC */
-				int_ret_code = tpm_proc_pnc_create(TPM_PNC_NUM_VLAN_TAGS, pnc_entry, &pnc_data);
-				IF_ERROR(int_ret_code);
-				free_entries--;
-				pnc_entry++;
-			}
-		}
-	}
-
-
-	/*************************************/
-	/* CREATE ENTRIES FOR SINGLE TAGGED **/
-	/*************************************/
-
-	/* Set L2 key value */
-	pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_ONE_VLAN_TAG;
-
-	/* Set DO_NOT_REPEAT_TAG AI filter */
-	pnc_data.pncl_sram.add_info_data = 1 << TPM_AI_DNRT_BIT_OFF;
-	pnc_data.pncl_sram.add_info_mask = TPM_AI_DNRT_MASK;
-	/* Set SINGLE_TAG AI filter */
-	pnc_data.pncl_sram.add_info_data &= (~TPM_AI_TAG2_MASK);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG2_MASK;
-	pnc_data.pncl_sram.add_info_data |= 1 << TPM_AI_TAG1_BIT_OFF;
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG1_MASK;
-
-	for (i = 0; i < tpid_opt.opt_num; i++) {
-		if (tpid_opt.opt[i].v2_tpid == MV_TPM_UN_INITIALIZED_INIT_PARAM) {
-			/* Set TPID of vlan tag */
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid = tpid_opt.opt[i].v1_tpid;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid_mask = 0xffff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.pbit_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.cfi_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.vid_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.tpid = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.tpid_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.pbit_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.cfi_mask = 0;
-			pnc_data.pncl_tcam.pkt_key.l2_key.vlan2.vid_mask = 0;
-
-			/* Create Entry in PnC */
-			int_ret_code = tpm_proc_pnc_create(TPM_PNC_NUM_VLAN_TAGS, pnc_entry, &pnc_data);
-			IF_ERROR(int_ret_code);
-			free_entries--;
-			pnc_entry++;
-		}
-	}
-
-	/*************************************/
-	/* CREATE ENTRIES FOR UNTAGGED      **/
-	/*************************************/
-
-	/* Set L2 key value */
-	pnc_data.pncl_tcam.l2_parse_bm = 0;
-
-	/* Set DO_NOT_REPEAT_TAG AI filter */
-	pnc_data.pncl_sram.add_info_data = 1 << TPM_AI_DNRT_BIT_OFF;
-	pnc_data.pncl_sram.add_info_mask = TPM_AI_DNRT_MASK;
-	/* Set ZERO_TAG AI filter */
-	pnc_data.pncl_sram.add_info_data &= (~TPM_AI_TAG2_MASK);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG2_MASK;
-	pnc_data.pncl_sram.add_info_data &= (~TPM_AI_TAG1_MASK);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TAG1_MASK;
-
-	/* Do NOT set VLAN Result_Info bit */
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_NUM_VLAN_TAGS, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_proto_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_ipv4_proto_init(void)
-{
-
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, ipv4_proto_lu, ipv4_frag_lu;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get NExt range IPV4_FRAG lu_id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_FRAG, &range_data);
-	IF_ERROR(int_ret_code);
-	ipv4_frag_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get IPV4_PROTO lu_id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_PROTO, &range_data);
-	IF_ERROR(int_ret_code);
-	ipv4_proto_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-
-	/*************************************/
-	/* CREATE ENTRIES FOR TCP UDP and    */
-	/* other ipv4 proto                ** */
-	/*************************************/
-
-	/* Basic TCAM/SRAM Config, valid for all following entries */
-	pnc_data.pncl_tcam.lu_id = ipv4_proto_lu;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_PROTO;
-
-	pnc_data.pncl_tcam.add_info_data = (0 << TPM_AI_NO_PROTO_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_NO_PROTO_MASK;
-
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	/* Update dummy register (offset automatically=zero) */
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_L4;
-	pnc_data.pncl_sram.next_lu_off_reg = TPM_PNC_LU_REG0;
-	pnc_data.pncl_sram.next_lu_id = ipv4_frag_lu;
-
-	/* Do not repeat this stage again */
-	pnc_data.pncl_sram.add_info_data = (1 << TPM_AI_NO_PROTO_BIT_OFF);
-	pnc_data.pncl_sram.add_info_mask = TPM_AI_NO_PROTO_MASK;
-
-	/***********************************************************/
-	/* Create  TCP, for  packets                               */
-	/***********************************************************/
-
-	NO_FREE_ENTRIES();
-
-	pnc_data.pncl_tcam.pkt_key.ipv4_key.ipv4_proto = IPPROTO_TCP;
-
-	/* Build SRAM Entry */
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_TCP;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_PROTO, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/***********************************/
-	/* Create  UDP                     */
-	/***********************************/
-	NO_FREE_ENTRIES();
-	/* Build Tcam Entry */
-	pnc_data.pncl_tcam.pkt_key.ipv4_key.ipv4_proto = IPPROTO_UDP;
-
-	/* Build SRAM Entry */
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_UDP;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_PROTO, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/**************************************/
-	/* Create Others                      */
-	/**************************************/
-	NO_FREE_ENTRIES();
-	/* Build Tcam Entry */
-
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-
-	/* Build SRAM Entry */
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_PROTO, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_frag_opt_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_ipv4_frag_init(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, ipv4_frag_lu, ipv4_len_lu;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get Next Range IPV4 LEN Lookup */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_LEN, &range_data);
-	IF_ERROR(int_ret_code);
-	ipv4_len_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get Range IPV4 FRAG Lookup */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_FRAG, &range_data);
-	IF_ERROR(int_ret_code);
-	ipv4_frag_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get number of entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "free_ent(%d)\n", free_entries);
-
-	/* Basic TCAM/SRAM Config, valid for all following entries */
-	pnc_data.pncl_tcam.lu_id = ipv4_frag_lu;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-
-	/* frag_offset an MF TCAM keys */
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_flags = 0;
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_flags_mask = 1;
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_frag_offset = 0;
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_frag_offset_mask = 1;
-
-	/* Only look at ai_no_frag=0 */
-	pnc_data.pncl_tcam.add_info_data = (0 << TPM_AI_NO_FRAG_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_NO_FRAG_MASK;
-
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	/* Update dummy register (offset automatically=zero) */
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_lu_off_reg = TPM_PNC_LU_REG0;
-	pnc_data.pncl_sram.next_lu_id = ipv4_len_lu;
-
-	/* Signal the packet is not going through this range again */
-	pnc_data.pncl_sram.add_info_data = (1 << TPM_AI_NO_FRAG_BIT_OFF);
-	pnc_data.pncl_sram.add_info_mask = TPM_AI_NO_FRAG_MASK;
-
-	/* Set fragment information */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_L3;
-
-	/*********************************************/
-	/* Create to CPU Unfragmented packets        */
-	/*********************************************/
-
-	NO_FREE_ENTRIES();
-
-	/*** Build Tcam Entry ***/
-
-	/* Only Unfragmented MF=0, frag_offset=0 */
-	pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_FLAG_MF | TPM_IPv4_PARSE_FRAG_OFFSET;
-
-	/* Only to_cpu packets */
-	pnc_data.pncl_tcam.add_info_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask |= TPM_AI_TO_CPU_MASK;
-
-	/*** Build SRAM Entry ***/
-
-	/* Packet not fragmented */
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-
-	/* LookupDone - it is to CPU */
-	pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_LUD;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_FRAG, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/***********************************************************/
-	/* Create to CPU Frag packets                              */
-	/***********************************************************/
-	NO_FREE_ENTRIES();
-
-	/* Don't check fragmented */
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-
-	/*** Build SRAM Entry ***/
-
-	/* Packet=fragmented */
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_FRAG;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_FRAG, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/**************************************/
-	/* Create Non-CPU Non-Frag,           */
-	/**************************************/
-	NO_FREE_ENTRIES();
-
-	/*** Build Tcam Entry ***/
-
-	/* MF=0, frag_offset=0 */
-	pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_FLAG_MF | TPM_IPv4_PARSE_FRAG_OFFSET;
-
-	/* Don't check CPU/Non-CPU  */
-	pnc_data.pncl_tcam.add_info_mask &= (~TPM_AI_TO_CPU_MASK);
-
-	/*** Build SRAM Entry ***/
-
-	/* Lookup not done, it is not to CPU */
-	pnc_data.pncl_sram.sram_updt_bm &= (~TPM_PNCL_SET_LUD);
-
-	/* Packet=not_fragmented */
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_FRAG, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/***********************************************************/
-	/* Create Non-CPU Frag packets                            */
-	/***********************************************************/
-	NO_FREE_ENTRIES();
-
-	/* Don't check fragmented */
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-
-	/*** Build SRAM Entry ***/
-
-	/* Packet=fragmented */
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_FRAG;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV4_FRAG, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_tcp_flag_pnc_entry_create()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* ip_ver      - IP version, IPV4 or IPV6
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_tcp_flag_pnc_entry_create(tpm_ip_ver_t ip_ver)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, tcp_flag_lu, ttl_lu = 0, pnc_entry;
-	int32_t cpu_rx_queue;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_ranges_t   range_id;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "\n");
-
-	/* Get default CPU Rx queue */
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-
-	if (TPM_IP_VER_4 == ip_ver) {
-		range_id = TPM_PNC_IPV4_TCP_FLAG;
-
-		/* Get Next Range TTL Info, only for IPv4 */
-		int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_TTL, &range_data);
-		if (int_ret_code != TPM_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " To create TCP Flag range, TPM_PNC_TTL range must exist \n");
-			return(int_ret_code);
-		}
-		ttl_lu = range_data.pnc_range_conf.base_lu_id;
-	} else
-		range_id = TPM_PNC_IPV6_TCP_FLAG;
-
-	/* Get TCP_FLAG Range Info */
-	int_ret_code = tpm_db_pnc_rng_get(range_id, &range_data);
-	IF_ERROR(int_ret_code);
-	tcp_flag_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Set common TCAM params */
-	pnc_data.pncl_tcam.lu_id = tcp_flag_lu;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_TCP_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.tcp_subf = TPM_PARSE_L4_SRC;
-
-	/* Set common SRAM params */
-	if (TPM_IP_VER_4 == ip_ver) {
-		pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_TCP_OFFSET;
-		pnc_data.pncl_sram.next_offset.offset_sub.tcp_subf = TPM_PARSE_TCPFLAGS;
-		pnc_data.pncl_sram.next_lu_id = ttl_lu;
-		pnc_data.pncl_sram.next_lu_off_reg = TPM_PNC_LU_REG0;
-	} else {
-		pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD;
-	}
-
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-
-	/********************/
-	/* Create FIN FLAG=1 */
-	/*******************/
-	NO_FREE_ENTRIES();
-
-	/* Build PnC Entry */
-	/* Double check - only check packets that are MTM */
-	pnc_data.pncl_tcam.add_info_data |= (1 << TPM_AI_MTM_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask |= TPM_AI_MTM_MASK;
-	if (TPM_IP_VER_6 == ip_ver) {
-		pnc_data.pncl_tcam.add_info_data &= ~(TPM_AI_L4P_MASK);
-		pnc_data.pncl_tcam.add_info_mask |= TPM_AI_L4P_MASK;
-	}
-
-	pnc_data.pncl_tcam.tcp_parse_bm = TPM_PARSE_TCPFLAGS;
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags = TPM_TCP_FIN;
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags_mask = TPM_TCP_FIN;
-
-	/* Build SRAM Entry */
-	pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_TXP;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-	if (TPM_IP_VER_4 == ip_ver) {
-		/* Signal the packet is going to CPU */
-		pnc_data.pncl_sram.add_info_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-		pnc_data.pncl_sram.add_info_mask |= TPM_AI_TO_CPU_MASK;
-	}
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(range_id, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/********************/
-	/* Create RES FLAG=1 */
-	/********************/
-	NO_FREE_ENTRIES();
-	/* Build PnC Entry (similar to previous entry */
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags = TPM_TCP_RES;
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags_mask = TPM_TCP_RES;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(range_id, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	if (TPM_IP_VER_6 == ip_ver) {
-		/* no default rule for IPv6 */
-		return(TPM_RC_OK);
-	}
-	/***************/
-	/* All Others  */
-	/***************/
-	NO_FREE_ENTRIES();
-
-	/* Build TCAM Entry */
-	pnc_data.pncl_tcam.add_info_data = 0;
-	pnc_data.pncl_tcam.add_info_mask = 0;
-	pnc_data.pncl_tcam.tcp_parse_bm = 0;
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags = 0;
-	pnc_data.pncl_tcam.pkt_key.tcp_key.tcp_flags_mask = 0;
-
-	/* Build SRAM Entry */
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(range_id, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_tcp_flag_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_tcp_flag_init(void)
-{
-	int32_t int_ret_code;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_tcp_flag_pnc_entry_create(TPM_IP_VER_4);
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_proc_tcp_flag_pnc_entry_create(TPM_IP_VER_6);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-
-/*******************************************************************************
-* tpm_proc_virt_uni_init()
-*
-* DESCRIPTION:
-* The function is responsible for adding a new entry in the PNC range of TPM_PNC_VIRT_UNI.
-* The entry is added in case the xml parameters are defining this entry - even though the
-* wifi_virt_uni_enable feature is disabled.
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_virt_uni_init(void)
-{
-
-	int32_t int_ret_code;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_db_pnc_range_t range_data;
-	uint32_t free_entries, pnc_entry;
-	tpm_init_virt_uni_t virt_uni;
-	tpm_db_gmac_func_t g_func;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " WiFi entry \n");
-
-
-	/* TODO: Currently hardcoded to G1 */
-	tpm_db_gmac_func_get(TPM_ENUM_GMAC_1, &g_func);
-
-	if (g_func != TPM_GMAC_FUNC_VIRT_UNI) {
-		return(TPM_OK);
-	}
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_VIRT_UNI, &range_data);
-	IF_ERROR(int_ret_code);
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry =
-	range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start +
-	(range_data.pnc_range_conf.range_size - 1);
-
-	tpm_db_virt_info_get(&virt_uni);
-
-	/* Build PnC Entry */
-	pnc_data.pncl_tcam.lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_tcam.port_ids = gmac_pnc_bm[TPM_ENUM_GMAC_1];
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	if (virt_uni.enabled == 1) {
-		NO_FREE_ENTRIES();
-
-		/* Build SRAM Entry */
-		pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_TXP | TPM_PNCL_SET_LUD;
-		pnc_data.pncl_sram.pnc_queue = 0;	/* hardcoded - send to Q0 to CPU */
-		pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-		/* Create Entry in PnC */
-		int_ret_code = tpm_proc_pnc_create(TPM_PNC_VIRT_UNI, pnc_entry, &pnc_data);
-		IF_ERROR(int_ret_code);
-
-		free_entries--;
-		pnc_entry--;
-
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0) {
-			NO_FREE_ENTRIES();
-
-			pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_MAC_DA;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[0] = 0x01;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[0] = 0xff;
-
-			/* Build SRAM Entry */
-			pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD;
-			pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-			/* Create Entry in PnC */
-			int_ret_code = tpm_proc_pnc_create(TPM_PNC_VIRT_UNI, pnc_entry, &pnc_data);
-			IF_ERROR(int_ret_code);
-
-			free_entries--;
-			pnc_entry--;
-
-			NO_FREE_ENTRIES();
-
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[0] = 0x33;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[0] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[1] = 0x33;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[1] = 0xff;
-
-			/* Create Entry in PnC */
-			int_ret_code = tpm_proc_pnc_create(TPM_PNC_VIRT_UNI, pnc_entry, &pnc_data);
-			IF_ERROR(int_ret_code);
-
-			free_entries--;
-			pnc_entry--;
-
-			NO_FREE_ENTRIES();
-
-			pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_MAC_DA;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[0] = 0x01;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[1] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[2] = 0x5e;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[3] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[4] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[5] = 0x01;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[0] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[1] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[2] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[3] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[4] = 0xff;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da_mask[5] = 0xff;
-
-			/* Build SRAM Entry */
-			pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_TXP | TPM_PNCL_SET_LUD;
-			pnc_data.pncl_sram.pnc_queue = 1;	/* hardcoded - send to Q1 to CPU */
-			pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-			/* Create Entry in PnC */
-			int_ret_code = tpm_proc_pnc_create(TPM_PNC_VIRT_UNI, pnc_entry, &pnc_data);
-			IF_ERROR(int_ret_code);
-
-			free_entries--;
-			pnc_entry--;
-
-			NO_FREE_ENTRIES();
-
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[0] = 0x33;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[1] = 0x33;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[2] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[3] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[4] = 0x00;
-			pnc_data.pncl_tcam.pkt_key.l2_key.mac.mac_da[5] = 0x01;
-
-			/* Create Entry in PnC */
-			int_ret_code = tpm_proc_pnc_create(TPM_PNC_VIRT_UNI, pnc_entry, &pnc_data);
-			IF_ERROR(int_ret_code);
-
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-/*******************************************************************************
-* tpm_proc_ds_load_balance_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_ds_load_balance_init(void)
-{
-	int32_t ret_code;
-	tpm_pnc_all_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data, nextphase_range_data;
-	uint32_t pnc_entry;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pnc_all_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&nextphase_range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get Range data */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_DS_LOAD_BALANCE, &range_data);
-	IF_ERROR(ret_code);
-
-	/* Get Next Range data */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_L2_MAIN, &nextphase_range_data);
-	IF_ERROR(ret_code);
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	pnc_entry = range_data.pnc_range_conf.range_end;
-
-	/* Set common TCAM params */
-	pnc_data.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.tcam_entry.port_ids = TPM_BM_PMAC;
-
-	/* Set common SRAM params */
-	pnc_data.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.sram_entry.next_lu_id = nextphase_range_data.pnc_range_conf.base_lu_id;
-
-	/* do not repeat this section again */
-	pnc_data.tcam_entry.add_info_data = 0;
-	pnc_data.tcam_entry.add_info_mask = TPM_AI_DNRT_DS_TRUNK_MASK;
-
-	/* Packet forwarded to GMAC0 */
-	pnc_data.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-	pnc_data.sram_entry.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_data.sram_entry.flowid_val = (TPM_PNC_TRG_GMAC0 << TPM_TXP_FL_SHIFT);
-
-	pnc_data.sram_entry.add_info_data |= (1 << TPM_AI_DNRT_DS_TRUNK_BIT_OFF);
-	pnc_data.sram_entry.add_info_mask |= TPM_AI_DNRT_DS_TRUNK_MASK;
-
-	/* create default rule to frwd all DS packets to GMAC0 */
-	ret_code = tpm_pnc_set(pnc_entry, 0, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(pnc_entry, &pnc_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_DS_LOAD_BALANCE);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-
-/*******************************************************************************
-* tpm_proc_ipv4_ttl_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_ipv4_ttl_init(uint32_t ttl_illegal_action)
-{
-
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, ttl_lu, ipv4_proto_lu;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data, nextphase_range_data;
-	int32_t cpu_rx_queue;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&nextphase_range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "ttl_illegal_action(%d)\n", ttl_illegal_action);
-
-	/* Get default CPU Rx queue */
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-
-	/* Get TCP_FLAG Range Info */
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_TTL, &range_data);
-	IF_ERROR(int_ret_code);
-	ttl_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get Next Range IPV4_PROTO LU_ID */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_PROTO, &nextphase_range_data);
-	IF_ERROR(int_ret_code);
-	ipv4_proto_lu = nextphase_range_data.pnc_range_conf.base_lu_id;
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start;
-
-	/* Set common TCAM params */
-	pnc_data.pncl_tcam.lu_id = ttl_lu;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_ttl = 0;
-
-	/* Set common SRAM params */
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_lu_id = ipv4_proto_lu;
-
-	/******************/
-	/* Create TTL=0   */
-	/******************/
-	/* Parse the TTL */
-	pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_TTL;
-
-	/* Double check - check only packets that are MTM */
-	pnc_data.pncl_tcam.add_info_data = (1 << TPM_AI_MTM_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_MTM_MASK;
-
-	/* Packet forwarded to CPU */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_TXP;
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-	/* or packet is dropped */
-	if (TPM_TTL_ZERO_ACTION_DROP == ttl_illegal_action)
-		pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD;
-
-	/* Signal the packet is going to CPU */
-	pnc_data.pncl_sram.add_info_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TO_CPU_MASK;
-
-	NO_FREE_ENTRIES();
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_TTL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/******************/
-	/* Create TTL=1   */
-	/******************/
-	NO_FREE_ENTRIES();
-	/* Build PnC Entry, see TTL=0 */
-	pnc_data.pncl_tcam.pkt_key.ipv4_add_key.ipv4_ttl = 1;
-
-	/* Build SRAM Entry, see TTL=0,
-	   but always send to CPU, don't drop */
-	pnc_data.pncl_sram.sram_updt_bm &= (~(TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD));
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_TTL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/********************/
-	/* Create TTL>1     */
-	/********************/
-	/* All packets */
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	/* Don't update anything (next_lu_id same as previous) */
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-	pnc_data.pncl_sram.add_info_data = 0;
-	pnc_data.pncl_sram.add_info_mask = 0;
-
-	NO_FREE_ENTRIES();
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_TTL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_igmp_init()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_ipv4_igmp_init(void)
-{
-	tpm_error_code_t ret_code = TPM_RC_OK;
-	uint32_t mode;
-	uint32_t cpu_queue;
-	tpm_src_port_type_t src_port;
-
-	/*set cpu queue */
-	tpm_db_igmp_get_cpu_queue(&cpu_queue);
-	tpm_set_igmp_cpu_rx_queue(cpu_queue);
-
-	/*set igmp packet forward mode */
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_UNI_7; src_port++) {
-		if (tpm_db_eth_port_switch_port_get(src_port) == TPM_DB_ERR_PORT_NUM)
-		continue;
-
-		tpm_db_igmp_get_port_frwd_mode(src_port, &mode);
-		ret_code = tpm_proc_add_uni_port_igmp_rule(src_port, mode);
-		IF_ERROR(ret_code);
-	}
-
-	tpm_db_igmp_get_port_frwd_mode(TPM_SRC_PORT_WAN, &mode);
-	ret_code = tpm_proc_add_wan_port_igmp_rule(mode);
-	IF_ERROR(ret_code);
-
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_proc_mib_reset()
-*
-* DESCRIPTION:      Performs MIB reset
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_mib_reset(uint32_t owner_id, tpm_reset_level_enum_t reset_level)
-{
-	int32_t int_ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "\n");
-
-	if (reset_level > TPM_ENUM_MAX_RESET_LEVEL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Illegal reset_level (%d) \n", reset_level);
-		return(ERR_GENERAL);
-	}
-	/* Init CPU WAN loopback DB */
-	int_ret_code = tpm_proc_init_cpu_wan_loopback();
-
-	/* Init Multicast DB */
-	int_ret_code = tpm_proc_multicast_reset();
-	IF_ERROR(int_ret_code);
-
-	/* Init PnC Ranges in DB */
-	int_ret_code = tpm_init_pncranges_set(reset_level);
-	IF_ERROR(int_ret_code);
-
-	/* Init API Ranges in DB */
-	int_ret_code = tpm_init_api_rng_init_all();
-	IF_ERROR(int_ret_code);
-
-	/* Init IPV6 5t flows */
-	int_ret_code = tpm_db_init_ipv6_5t_flow_reset();
-	IF_ERROR(int_ret_code);
-
-	/* Init CnM DB */
-	int_ret_code = tpm_db_ctc_cm_db_reset();
-	IF_ERROR(int_ret_code);
-
-	/* Init IPv6 MC SIP db */
-	tpm_db_ipv6_mc_sip_db_reset();
-
-	/* Init Hardware */
-	int_ret_code = tpm_init_system_mib_reset(reset_level);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_int_del_acl_rule(tpm_api_sections_t api_section, uint32_t owner_id, uint32_t rule_idx)
-{
-
-	int32_t ret_code;
-	uint32_t rule_num, dummy_idx, bi_dir, api_rng_entries;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_pnc_ranges_t range_id = 0;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " api_section(%d) owner(%d) rule_idx (%d)", api_section, owner_id, rule_idx);
-
-	/* Get Range_Id */
-	ret_code = tpm_db_api_section_main_pnc_get(api_section, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Get the rule_num */
-	ret_code = tpm_db_api_rulenum_get(api_section, rule_idx, &rule_num);
-	if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-		TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-		return ERR_RULE_IDX_INVALID;
-	}
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-	/*IF_ERROR(ret_code);*/
-
-	ret_code = tpm_db_api_entry_get(api_section, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_api_section_num_entries_get(api_section, &api_rng_entries);
-	IF_ERROR(ret_code);
-
-	/* Delete PNC Entry */
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	/* Release related modification entry  (Important, after deleting PNC Entries) */
-	if (mod_con.mod_cmd_mac != TPM_INVALID_GMAC) {
-		/* handle split mod */
-		ret_code = tpm_mod2_split_mod_try_pmt_entry_del(api_section, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-		if (TPM_OK != ret_code) {
-			/* this is not split mod entry, remove it */
-			ret_code = tpm_proc_delete_mod(TPM_MOD_OWNER_TPM, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-		}
-	}
-	IF_ERROR(ret_code);
-
-	/* Delete API Rule Entry */
-	ret_code = tpm_db_api_entry_invalidate(api_section, rule_num);
-	IF_ERROR(ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-		/* Decrease rule_numbers and PnC entries of the existing API entries that were "pulled up" */
-		ret_code = tpm_proc_api_entry_rulenum_dec(api_section, (rule_num + 1), (api_rng_entries - 1));
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_acl_rule(tpm_api_sections_t api_section, uint32_t owner_id, uint32_t rule_idx, uint32_t busy_check)
-{
-	tpm_error_code_t ret_code, busy_ret_code = TPM_RC_OK;
-	tpm_api_type_t api_type;
-
-	/* Check API_type Busy */
-	if (busy_check) {
-		ret_code = tpm_db_api_type_get_from_api_section(api_section, &api_type);
-		IF_ERROR(ret_code);
-		ret_code = tpm_proc_check_api_busy(api_type, rule_idx);
-		IF_ERROR(ret_code);
-	}
-
-	ret_code = tpm_proc_int_del_acl_rule(api_section, owner_id, rule_idx);
-
-	/* Free API_type */
-	if (busy_check)
-		busy_ret_code = tpm_proc_api_busy_done(api_type, rule_idx);
-
-	IF_ERROR(ret_code);
-	IF_ERROR(busy_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-
-/*******************************************************************************
-* tpm_add_ipv4_acl_rule()
-*
-* DESCRIPTION:      Creates a new IPv4 processing ACL.
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ipv4_acl_rule(uint32_t owner_id,
-					    tpm_src_port_type_t src_port,
-					    uint32_t rule_num,
-					    uint32_t *rule_idx,
-					    tpm_parse_fields_t parse_rule_bm,
-					    tpm_parse_flags_t parse_flags_bm,
-					    tpm_ipv4_acl_key_t *ipv4_key,
-					    tpm_pkt_frwd_t *pkt_frwd,
-					    tpm_pkt_mod_t *pkt_mod,
-					    tpm_pkt_mod_bm_t pkt_mod_bm,
-					    tpm_rule_action_t *rule_action)
-{
-
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code, int_mod_bm;
-	tpm_gmacs_enum_t trg_gmac;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0, bi_dir = 0, update_sram_only = 0;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_api_lu_conf_t lu_conf;
-	tpm_trg_port_type_t trg_port;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv4_check(owner_id, src_port, rule_num, parse_rule_bm, parse_flags_bm,
-					   ipv4_key, pkt_frwd, pkt_mod, rule_action, pkt_mod_bm);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_IPV4_ACL, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Only do it in table mode */
-	if (TPM_RANGE_TYPE_TABLE == rangConf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV4_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d) already exists\n",
-				     owner_id, src_port, rule_num);
-
-			/* TCAM Key and modification info are not changed, only update SRAM */
-			if ((0 == memcmp(ipv4_key, &api_data.ipv4_key.ipv4_key, sizeof(tpm_ipv4_acl_key_t)))
-			    && (src_port == api_data.ipv4_key.src_port)
-			    && (parse_rule_bm == api_data.ipv4_key.parse_rule_bm)
-			    && (parse_flags_bm == api_data.ipv4_key.parse_flags_bm)
-			    && (SET_MOD(rule_action->pkt_act) == SET_MOD(api_data.ipv4_key.rule_action.pkt_act))
-			    && (SET_UDP_CHKSUM_CALC(rule_action->pkt_act) == \
-					SET_UDP_CHKSUM_CALC(api_data.ipv4_key.rule_action.pkt_act))) {
-				/* No modification */
-					if (!SET_MOD(rule_action->pkt_act))
-						update_sram_only = 1;
-				/* There are modification, then check furthur */
-					else if ((pkt_mod_bm == api_data.ipv4_key.pkt_mod_bm)
-						 && (0 == memcmp(pkt_mod, &api_data.ipv4_key.pkt_mod, sizeof(tpm_pkt_mod_t)))) {
-						update_sram_only = 1;
-						mod_entry = mod_con.mod_cmd_ind;
-						trg_gmac = mod_con.mod_cmd_mac;
-					}
-				}
-
-			/* TCAM Key or modification info is changed */
-			if (!update_sram_only) {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-					     " owner(%d) src_port(%d), rule_num(%d) TCAM key/modification changed\n",
-					     owner_id, src_port, rule_num);
-
-				tpm_proc_del_ipv4_acl_rule(owner_id, rule_num, TPM_INT_CALL);
-				IF_ERROR(ret_code);
-			}
-		}
-	}
-
-	if (    (!update_sram_only)
-	     && (SET_MOD(rule_action->pkt_act))) {
-		/* if split mod stage-2 */
-		if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-			VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-			(pkt_mod_bm == TPM_VLAN_MOD)) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-			/* in this case, trgt port should be set in L2 stage, IPv4 only perform pbit mod,
-			   so here src port is used for get DS or US info, which tells the Dst GMAC.
-			 */
-			if (SET_TARGET_PORT(rule_action->pkt_act))
-				trg_port = pkt_frwd->trg_port;
-			else if (FROM_LAN(src_port))
-				trg_port = TPM_TRG_PORT_WAN;
-			else
-				trg_port = TPM_TRG_PORT_UNI_ANY;
-
-			if (tpm_proc_trg_port_gmac_map(trg_port, &trg_gmac)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-				return(ERR_MOD_INVALID);
-			} else if (trg_gmac == TPM_INVALID_GMAC) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-				return(ERR_MOD_INVALID);
-			}
-
-			/* get mod index from p-bit value */
-			int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-			if (TPM_DB_OK != int_ret_code) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-					pkt_mod->vlan_mod.vlan1_out.pbit);
-				return ERR_MOD_INVALID;
-			}
-
-			/* the first PMT is for p-bit AS-IS */
-			mod_entry++;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-		} else {
-			/* Check if UDP or TCP or nothing */
-			int_mod_bm = 0;
-			if (parse_rule_bm & TPM_IPv4_PARSE_PROTO) {
-				if (ipv4_key->ipv4_proto == IPPROTO_TCP)
-					int_mod_bm = TPM_INT_L4_TCP;
-				else if (ipv4_key->ipv4_proto == IPPROTO_UDP) {
-					int_mod_bm = TPM_INT_L4_UDP;
-					/* Set internal_bm according to API Action */
-					if (rule_action->pkt_act & TPM_ACTION_UDP_CHKSUM_CALC)
-						int_mod_bm = TPM_INT_L4_UDP | TPM_INT_UDP_CHECKSUM;
-				}
-			}
-			ret_code =
-			tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, int_mod_bm,
-					    &mod_entry, &trg_gmac);
-			IF_ERROR(ret_code);
-		}
-	}
-
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv4_tcam_build(src_port, dir, rule_num, ipv4_key, parse_rule_bm,
-					parse_flags_bm, rule_action, pkt_mod, pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code =  tpm_proc_ipv4_sram_build(src_port, dir, rule_num, pon_type, ipv4_key,
-						 pnc_data.pncl_tcam.ipv4_parse_bm, parse_flags_bm,
-						 pkt_frwd, rule_action, mod_entry, pkt_mod_bm, pkt_mod, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-		/*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV4_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV4_ACL, rule_num, update_sram_only, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	if (!update_sram_only) {
-		/* Set API data */
-		api_data.ipv4_key.src_port = src_port;
-		api_data.ipv4_key.parse_rule_bm = parse_rule_bm;
-		api_data.ipv4_key.parse_flags_bm = parse_flags_bm;
-		api_data.ipv4_key.pkt_mod_bm = pkt_mod_bm;
-		memcpy(&(api_data.ipv4_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-		if (ipv4_key)
-			memcpy(&(api_data.ipv4_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-
-		if (pkt_frwd != NULL)
-			memcpy(&(api_data.ipv4_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-		else
-			memset(&(api_data.ipv4_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-		if (pkt_mod != NULL)
-			memcpy(&(api_data.ipv4_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-		else
-			memset(&(api_data.ipv4_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-		/* Set modification data */
-		tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-		/* Set Pnc Connection data */
-		pnc_conn.num_pnc_ranges = 1;
-		pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-		pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-		if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-			/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-			if (rule_num < api_rng_entries) {
-				int_ret_code =
-				tpm_proc_api_entry_rulenum_inc(TPM_IPV4_ACL, rule_num, (api_rng_entries - 1));
-				IF_ERROR(int_ret_code);
-			}
-		}
-
-		/* Set new API Entry */
-		int_ret_code = tpm_db_api_entry_set(TPM_IPV4_ACL, rule_num, 0 /*bi_dir */ ,
-						    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-		IF_ERROR(int_ret_code);
-
-		/* Return Output */
-		*rule_idx = l_rule_idx;
-	} else {
-		if (pkt_frwd != NULL)
-			memcpy(&(api_data.ipv4_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-		else
-			memset(&(api_data.ipv4_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-		int_ret_code = tpm_db_api_entry_invalidate(TPM_IPV4_ACL, rule_num);
-		IF_ERROR(int_ret_code);
-
-		/* Set new API Entry */
-		int_ret_code = tpm_db_api_entry_set(TPM_IPV4_ACL, rule_num, 0 /*bi_dir */ ,
-						    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-		IF_ERROR(int_ret_code);
-
-		/* Return Output */
-		*rule_idx = l_rule_idx;
-	}
-
-	/* Set aging counter group nunmber and mask */
-	int_ret_code = tpm_db_pnc_get_lu_conf(TPM_PNC_IPV4_MAIN, &lu_conf);
-	IF_ERROR(int_ret_code);
-	tpm_tcam_set_lu_mask(pnc_conn.pnc_conn_tbl[0].pnc_index, (int32_t) lu_conf.lu_mask);
-	tpm_tcam_set_cntr_group(pnc_conn.pnc_conn_tbl[0].pnc_index, (int32_t) lu_conf.cntr_grp);
-
-	return(TPM_RC_OK);
-
-}
-
-/*******************************************************************************
-* tpm_del_ipv4_acl_rule()
-*
-* DESCRIPTION:      Delete a  IPv4 processing ACL.
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_ipv4_acl_rule(uint32_t owner_id, uint32_t rule_idx, uint32_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV4_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_check_dst_uni_port()
-*
-* DESCRIPTION:    The function checks Dst port params.
-*
-* INPUTS:
-* dest_port_bm     -
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_check_dst_uni_port(tpm_trg_port_type_t dest_port_bm)
-{
-	uint32_t dst_port;
-	tpm_src_port_type_t src_port;
-	tpm_init_virt_uni_t virt_uni_info;
-	uint32_t gmac_is_uni_num, max_uni_port_num;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "dest_port_bm(0x%x)\n", dest_port_bm);
-
-	for (dst_port = TPM_TRG_UNI_0, src_port = TPM_SRC_PORT_UNI_0;
-	     dst_port <= TPM_TRG_UNI_7;
-	     dst_port = (dst_port << 1), src_port += 1) {
-
-		if(0 == (dest_port_bm & dst_port))
-			continue;
-
-		/* if port is valid */
-		if(!tpm_db_eth_port_valid(src_port)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "dest_port(0x%x) is not valid\n", dst_port);
-			return ERR_MC_DST_PORT_INVALID;
-		}
-	}
-
-	/* check vir uni */
-	tpm_db_virt_info_get(&virt_uni_info);
-	if (    (TPM_VIRT_UNI_DISABLED == virt_uni_info.enabled)
-	     && (dest_port_bm & TPM_TRG_UNI_VIRT)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "TPM_TRG_UNI_VIRT is not enabled\n");
-		return ERR_MC_DST_PORT_INVALID;
-	}
-	/* Get GMAC LAN_UNI and UNI ports number */
-	tpm_proc_gmaclanuni_uninum_get(&gmac_is_uni_num, &max_uni_port_num);
-
-	/* check UNI_ANY */
-	if (dest_port_bm & TPM_TRG_PORT_UNI_ANY) {
-		/* Check UNI_ANY is supported or not */
-		if (gmac_is_uni_num > 1 ||
-		    (gmac_is_uni_num == 1 && max_uni_port_num > 1)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "dest_port UNI_ANY is not supported\n");
-			return ERR_MC_DST_PORT_INVALID;
-		}
-	}
-
-	/* Check multi des port  in bm */
-	if (dest_port_bm > TPM_TRG_UNI_1) {
-		if (gmac_is_uni_num > 1) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "dest_port bit map combine is not supported\n");
-			return ERR_MC_DST_PORT_INVALID;
-		}
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_add_ipv4_mc_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_ipv4_mc_stream params.
-*
-* INPUTS:
-* owner_id         - See tpm_proc_add_ipv4_mc_stream
-* stream_num       - See tpm_proc_add_ipv4_mc_stream
-* vid              - See tpm_proc_add_ipv4_mc_stream
-* ipv4_src_add     - See tpm_proc_add_ipv4_mc_stream
-* ipv4_dst_add     - See tpm_proc_add_ipv4_mc_stream
-* ignore_ipv4_src  - See tpm_proc_add_ipv4_mc_stream
-* dest_port_bm     - See tpm_proc_add_ipv4_mc_stream
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ipvx_mc_check(uint32_t owner_id,
-					    uint32_t stream_num,
-					    tpm_mc_igmp_mode_t igmp_mode,
-					    uint8_t mc_stream_pppoe,
-					    uint16_t vid,
-					    uint8_t src_add[16],
-					    uint8_t dst_add[16],
-					    uint8_t ignore_ipvx_src,
-					    uint16_t dest_queue,
-					    tpm_trg_port_type_t dest_port_bm,
-					    tpm_mc_filter_mode_t filter_mode,
-					    tpm_ip_ver_t ip_version)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code, index;
-	tpm_db_pnc_range_t range_data;
-	uint32_t ai_bit;
-	tpm_init_virt_uni_t virt_uni;
-	uint32_t pnc_rng_free_size;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-	tpm_pnc_ranges_t range;
-	tpm_api_sections_t api_section;
-	tpm_api_type_t api_type;
-
-	if (TPM_IP_VER_4 == ip_version) {
-		range = TPM_PNC_IPV4_MC_DS;
-		api_section = TPM_IPV4_MC;
-		api_type = TPM_API_IPV4_MC;
-	} else {
-		range = TPM_PNC_IPV6_MC_DS;
-		api_section = TPM_IPV6_MC_ACL;
-		api_type = TPM_API_IPV6_MC;
-	}
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	ret_code = tpm_owner_id_check(api_type, owner_id);
-	IF_ERROR(ret_code);
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(range, &range_data);
-	IF_ERROR(int_ret_code);
-
-	if (stream_num >= range_data.pnc_range_conf.range_size)
-		IF_ERROR(ERR_MC_STREAM_INVALID);
-
-	ret_code = tpm_proc_check_dst_uni_port(dest_port_bm);
-	IF_ERROR(ret_code);
-
-	/*check virt range size if necessary*/
-	if(filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0 && (dest_port_bm & TPM_TRG_UNI_VIRT) != 0) {
-			ret_code = tpm_db_pnc_rng_free_ent_get(TPM_PNC_VIRT_UNI, &pnc_rng_free_size);
-			IF_ERROR(ret_code);
-			if(pnc_rng_free_size == 0)
-				IF_ERROR(ERR_OUT_OF_RESOURCES);
-		}
-	}
-
-	/* fix bug of adding 1-2-3 instead of 0-1-2 => when 3 is over-writing the hardcoded entry */
-	if ((stream_num < range_data.pnc_range_conf.api_start) || (stream_num > range_data.pnc_range_conf.api_end))
-		IF_ERROR(ERR_MC_STREAM_INVALID);
-
-	tpm_db_api_entry_ind_get(api_section, stream_num, &index);
-	if (-1 != index)
-		IF_ERROR(ERR_MC_STREAM_EXISTS);
-
-	tpm_db_virt_info_get(&virt_uni);
-
-	if (vid == 0xffff) {
-		if (tpm_db_get_mc_filter_mode() == TPM_MC_IP_ONLY_FILTER) {
-			if (virt_uni.enabled) {
-				TPM_OS_WARN(TPM_TPM_LOG_MOD,
-					    " filter mode fall back to MC_COMBINED_MAC_IP_FILTER \r\n");
-			}
-		}
-
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				    "when mc_per_uni_vlan_xlate is enabled, untagged mcast stream is not supported, "
-				    "and MC VID must be specified \r\n");
-			IF_ERROR(ERR_SW_VID_INVALID);
-		}
-	} else {
-		if (tpm_db_mc_vlan_get_ai_bit(vid, &ai_bit) != TPM_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				    "MC VID must be configured first \r\n");
-			IF_ERROR(ERR_SW_VID_INVALID);
-		}
-	}
-
-	if (mc_stream_pppoe) {
-		if (tpm_db_get_mc_pppoe_enable() == 0)
-			IF_ERROR(ERR_FEAT_UNSUPPORT);
-
-		if (igmp_mode == TPM_MC_IGMP_SNOOPING && tpm_db_get_mc_per_uni_vlan_xlate())
-			IF_ERROR(ERR_FEAT_UNSUPPORT);
-	}
-
-	if (TPM_IP_VER_4 == ip_version) {
-		if ((dst_add[0] < 224) || (dst_add[0] > 239))
-			IF_ERROR(ERR_IPV4_MC_DST_IP_INVALID);
-	} else {
-		if (dst_add[0] != 0xff)
-			IF_ERROR(ERR_IPV6_MC_DST_IP_INVALID);
-
-		/* check if there is MC SIP slot */
-		if(0 == ignore_ipvx_src) {
-			if(!tpm_db_ipv6_mc_sip_index_get(src_add)) {
-				/* this is a new MC SIP */
-				if(!tpm_db_ipv6_mc_sip_free_slot_num_get())
-					IF_ERROR(ERR_OUT_OF_RESOURCES);
-			}
-		}
-	}
-
-	if ((dest_queue != TPM_INVALID_QUEUE) && (dest_queue >= TPM_MAX_NUM_RX_QUEUE))
-		IF_ERROR(ERR_MC_DST_QUEUE_INVALID);
-
-	if (dest_port_bm & TPM_TRG_UNI_VIRT) {
-		if (virt_uni.enabled == 0)
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_CPU) {
-		if (dest_port_bm & (~TPM_TRG_PORT_CPU))
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	/* when ds load balance on G0 and G1 is enabled, no Proxy stream is allowed */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	if (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable) {
-		if (    (TPM_IP_VER_4 == ip_version)
-		     && (TPM_MC_IGMP_PROXY == igmp_mode)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "when ds load balance on G0 and G1 is enabled, "
-				"no Proxy stream is allowed\n");
-			return(ERR_FEAT_UNSUPPORT);
-		}
-		if (TPM_IP_VER_6 == ip_version) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "when ds load balance on G0 and G1 is enabled, "
-				"there is no IPv6 MC feature\n");
-			return(ERR_FEAT_UNSUPPORT);
-		}
-	}
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipv4_mc_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* stream_num          - MC stream number
-* ipv4_src_add        - IPv4 source IP address in network order.
-* ipv4_dst_add        - IPv4 destination IP address in network order.
-* ignore_ipv4_src     - when set to 1 - the IP source is not part of the key.
-* tcam_data           - Logical TCAM Structure
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ipv4_mc_tcam_build(tpm_mc_filter_mode_t filter_mode,
-				    uint32_t stream_num,
-				    uint16_t vid,
-				    uint8_t mc_stream_pppoe,
-				    uint8_t ipv4_src_add[4],
-				    uint8_t ipv4_dst_add[4],
-				    uint8_t ignore_ipv4_src,
-				    tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t int_ret_code;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id, ai_bits;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t vid_ai_field;
-	tpm_parse_flags_t parse_flags_bm = 0;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " stream_num(%d), sip(%02x%02x%02x%02x), dip(%02x%02x%02x%02x), ignore_src(%d)\n",
-		     stream_num, ipv4_src_add[0], ipv4_src_add[1], ipv4_src_add[2], ipv4_src_add[3],
-		     ipv4_dst_add[0], ipv4_dst_add[1], ipv4_dst_add[2], ipv4_dst_add[3], ignore_ipv4_src);
-
-	tcam_data->l2_parse_bm = 0;
-	tcam_data->l3_parse_bm = 0;
-	tcam_data->ipv6_parse_bm = 0;
-	tcam_data->add_info_mask = 0;
-	tcam_data->add_info_data = 0;
-	if (ignore_ipv4_src)
-		tcam_data->ipv4_parse_bm = TPM_IPv4_PARSE_DIP;
-	else
-		tcam_data->ipv4_parse_bm = TPM_IPv4_PARSE_DIP | TPM_IPv4_PARSE_SIP;
-
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (vid != 0xFFFF) {
-		int_ret_code = tpm_db_mc_vlan_get_ai_bit(vid, &ai_bits);
-		IF_ERROR(int_ret_code);
-
-		vid_ai_field.mc_vid_entry = ai_bits;
-
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_TRUE;
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_PARSE;
-	} else
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_FALSE;
-
-	if (mc_stream_pppoe)
-		parse_flags_bm |= TPM_PARSE_FLAG_PPPOE_TRUE;
-	else
-		parse_flags_bm |= TPM_PARSE_FLAG_PPPOE_FALSE;
-
-	/* Update the AI bits */
-	tpm_proc_parse_flag_ai_tcam_build(&vid_ai_field, parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data),
-					  &(tcam_data->add_info_mask));
-
-	/* Copy in logical PnC Key */
-	if (!ignore_ipv4_src) {
-		memcpy(tcam_data->pkt_key.ipv4_key.ipv4_src_ip_add, ipv4_src_add, sizeof(ipv4_src_add));
-		memset(tcam_data->pkt_key.ipv4_key.ipv4_src_ip_add_mask, 0xff, 4);
-	}
-	memcpy(tcam_data->pkt_key.ipv4_key.ipv4_dst_ip_add, ipv4_dst_add, sizeof(ipv4_dst_add));
-	memset(tcam_data->pkt_key.ipv4_key.ipv4_dst_ip_add_mask, 0xff, 4);
-
-	/* Get PNC Range information */
-	int_ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV4_MC_DS, &lu_id, &start_offset);
-	IF_ERROR(int_ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&tcam_data->start_offset, &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_ipvx_mc_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* pon_type          - WAN technology
-* l2_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-* pkt_frwd          - See xxx
-* rule_action       - See xxx
-*
-* OUTPUTS:
-* l2_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_ipvx_mc_sram_build(tpm_mc_filter_mode_t filter_mode,
-				    tpm_mc_igmp_mode_t igmp_mode,
-				    uint16_t dest_queue,
-				    tpm_trg_port_type_t target_port,
-				    uint32_t mod_entry,
-				    tpm_pncl_sram_data_t *sram_data,
-				    tpm_ip_ver_t ip_version)
-{
-	tpm_db_mh_src_t ds_mh_src;
-	tpm_init_virt_uni_t virt_uni;
-	tpm_db_pnc_range_conf_t range_conf;
-	int32_t ret_code;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " target_port(%d)\n", target_port);
-
-	/* Update dummy register (offset automatically=zero) */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	if (TPM_IP_VER_4 == ip_version) {
-		sram_data->sram_updt_bm = 0;
-		/*Set next lookup */
-		sram_data->next_lu_off_reg = 0;
-		/* For igmp_proxy, check TTL, for igmp_snooping do not */
-		if (igmp_mode == TPM_MC_IGMP_PROXY) {
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_TTL, &range_conf);
-			IF_ERROR(ret_code);
-		} else {
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_PROTO, &range_conf);
-			IF_ERROR(ret_code);
-		}
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	} else {
-		sram_data->sram_updt_bm = TPM_PNCL_SET_LUD;
-	}
-
-
-	/* Set MH */
-	if (tpm_db_get_mc_per_uni_vlan_xlate() == 0) {
-		tpm_db_ds_mh_get_conf_set(&ds_mh_src);
-
-		if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-			if (TPM_MH_SRC_PNC_RI == ds_mh_src) {
-				sram_data->sram_updt_bm |= TPM_PNCL_SET_MH_RI;
-				sram_data->mh_reg.mh_set = TPM_TRUE;
-
-				tpm_db_virt_info_get(&virt_uni);
-				if (virt_uni.enabled)
-					sram_data->mh_reg.mh_reg = (TPM_MH_RI_BIT16 | TPM_MH_RI_BIT15);
-				else
-					sram_data->mh_reg.mh_reg = (TPM_MH_RI_BIT17 | TPM_MH_RI_BIT16 |
-								    TPM_MH_RI_BIT15 | TPM_MH_RI_BIT14);
-			} else {
-				sram_data->mh_reg.mh_set = TPM_FALSE;
-				sram_data->mh_reg.mh_reg = 0;
-			}
-		} else if (filter_mode == TPM_MC_IP_ONLY_FILTER) {
-			/* Target UNI is set by Modification Entry */
-		}
-	} else {
-		/* Target UNI is set by Modification Entry */
-	}
-
-	/* Set modification command */
-	if (mod_entry != 0) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_entry;
-	}
-
-	if (TPM_IP_VER_4 == ip_version) {
-		/* Reset AI bits for following LU */
-		sram_data->add_info_data = 0;
-		sram_data->add_info_mask = (TPM_AI_MC_VID_MASK | TPM_AI_MC_VID_VALID_MASK);
-		if (TPM_MC_IGMP_PROXY == igmp_mode) {
-		/* set MTM AI since in proxy mode */
-			sram_data->add_info_data |= (1 << TPM_AI_MTM_BIT_OFF);
-			sram_data->add_info_mask |= TPM_AI_MTM_MASK;
-		}
-
-		/* Final Fragment and L4 is detremined in separate stage */
-		sram_data->l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-	}
-
-	/* Set Target Port */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-	sram_data->pnc_queue = dest_queue;
-	if (target_port == TPM_TRG_PORT_CPU) {
-		sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-	} else if (TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable){
-		sram_data->sram_updt_bm &= (~TPM_PNCL_SET_TXP);
-	} else {
-		tpm_pnc_trg_t pnc_target;
-		ret_code = tpm_db_to_lan_gmac_get(target_port, &pnc_target);
-		IF_ERROR(ret_code);
-		sram_data->flow_id_sub.pnc_target = pnc_target;
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_create_ipvx_mc_mod(tpm_mc_filter_mode_t filter_mode,
-				    tpm_mc_igmp_mode_t igmp_mode,
-				    uint8_t mc_stream_pppoe,
-				    uint16_t vid,
-				    uint8_t *group_addr,
-				    uint32_t dest_port_bm,
-				    uint32_t *mod_entry,
-				    tpm_ip_ver_t ip_version)
-{
-	int32_t ret_code;
-	tpm_pkt_mod_bm_t pkt_mod_bm = 0;
-	tpm_pkt_mod_t pkt_mod;
-	uint8_t mc_mac[6];
-	uint32_t lpbk_port_bm = 0, entry_id;
-	tpm_mc_vid_port_cfg_t *mc_vid_cfg = NULL;
-	uint8_t valid;
-	uint32_t mh_en;
-	uint32_t switch_init, trgt_gmac;
-	tpm_pnc_trg_t pnc_target;
-	tpm_gmacs_enum_t gmac;
-	/*struct net_device *dev = NULL;*/
-
-	memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-
-	if (TPM_TRG_PORT_CPU == dest_port_bm) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "target to CPU, no pkt mod is needed\n");
-		*mod_entry = 0;
-		return TPM_OK;
-	}
-
-	/*get MH EN */
-	ret_code = tpm_db_to_lan_gmac_get(dest_port_bm, &pnc_target);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_target_to_gmac(pnc_target, &gmac);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_mh_en_conf_get(gmac, &mh_en);
-	IF_ERROR(ret_code);
-
-	/*get switch init*/
-	ret_code = tpm_db_switch_init_get(&switch_init);
-	IF_ERROR(ret_code);
-
-	if (filter_mode == TPM_MC_IP_ONLY_FILTER && mh_en) {
-		/* TODO: Check virt_port status. If it is not enabled, set target_port via MH_Tx_reg in RI. */
-		pkt_mod_bm |= TPM_MH_SET;
-		pkt_mod.mh_mod = tpm_db_trg_port_switch_port_get(dest_port_bm);
-	}
-
-	if (tpm_db_get_mc_per_uni_vlan_xlate() == 0) {
-		if (vid != 0xffff) {
-			if (tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg) == TPM_OK) {
-				for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-					if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSLATE) {
-						pkt_mod_bm |= TPM_VLAN_MOD;
-
-						pkt_mod.vlan_mod.vlan_op = VLANOP_EXT_TAG_MOD;
-						pkt_mod.vlan_mod.vlan1_out.tpid = 0x8100;
-						pkt_mod.vlan_mod.vlan1_out.pbit = 0;
-						pkt_mod.vlan_mod.vlan1_out.pbit_mask = 0x0;
-						pkt_mod.vlan_mod.vlan1_out.cfi = 0;
-						pkt_mod.vlan_mod.vlan1_out.cfi_mask = 0x0;
-						pkt_mod.vlan_mod.vlan1_out.vid = mc_vid_cfg[entry_id].uni_port_vid;
-						pkt_mod.vlan_mod.vlan1_out.vid_mask = 0xffff;
-						break;
-					} else if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP) {
-						/* Just for MC, no switch */
-						if (switch_init == 0) {
-							pkt_mod_bm |= TPM_VLAN_MOD;
-
-							pkt_mod.vlan_mod.vlan_op = VLANOP_EXT_TAG_DEL;
-							break;
-						}
-					}
-				}
-			} else
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " not found mv_vlan_cfg %d, assume as transparent! \n", vid);
-		}
-	} else if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		pkt_mod_bm |= TPM_MH_SET;
-
-		ret_code = tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg);
-		IF_ERROR(ret_code);
-
-		for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-			if (mc_vid_cfg[entry_id].tpm_src_port != TPM_SRC_PORT_UNI_VIRT) {
-				if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSPARENT ||
-				    mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP) {
-					lpbk_port_bm |=
-					TPM_TRG_UNI_0 << (mc_vid_cfg[entry_id].tpm_src_port - TPM_SRC_PORT_UNI_0);
-				}
-			}
-		}
-		lpbk_port_bm |= TPM_TRG_UNI_VIRT;
-
-		pkt_mod.mh_mod = tpm_db_trg_port_switch_port_get(lpbk_port_bm);
-	}
-
-	if (igmp_mode == TPM_MC_IGMP_PROXY) {
-#if 0
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-		dev = dev_get_by_name("eth0");
-#else
-		dev = dev_get_by_name(&init_net, "eth0");
-#endif
-		if (dev == NULL)
-			IF_ERROR(ERR_GENERAL);
-
-		pkt_mod_bm |= (TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-		pkt_mod.mac_mod.mac_sa[0] = ((uint8_t *) dev->dev_addr)[0];
-		pkt_mod.mac_mod.mac_sa[1] = ((uint8_t *) dev->dev_addr)[1];
-		pkt_mod.mac_mod.mac_sa[2] = ((uint8_t *) dev->dev_addr)[2];
-		pkt_mod.mac_mod.mac_sa[3] = ((uint8_t *) dev->dev_addr)[3];
-		pkt_mod.mac_mod.mac_sa[4] = ((uint8_t *) dev->dev_addr)[4];
-		pkt_mod.mac_mod.mac_sa[5] = ((uint8_t *) dev->dev_addr)[5];
-
-		pkt_mod.mac_mod.mac_sa_mask[0] = 0xff;
-		pkt_mod.mac_mod.mac_sa_mask[1] = 0xff;
-		pkt_mod.mac_mod.mac_sa_mask[2] = 0xff;
-		pkt_mod.mac_mod.mac_sa_mask[3] = 0xff;
-		pkt_mod.mac_mod.mac_sa_mask[4] = 0xff;
-		pkt_mod.mac_mod.mac_sa_mask[5] = 0xff;
-#endif
-
-		if (TPM_IP_VER_4 == ip_version)
-			pkt_mod_bm |= (TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-		else
-			pkt_mod_bm |= (TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-
-		tpm_db_get_mc_igmp_proxy_sa_mac(mc_mac, &valid);
-
-		if (valid) {
-			memcpy(pkt_mod.mac_mod.mac_sa, mc_mac, 6 * sizeof(uint8_t));
-			memset(pkt_mod.mac_mod.mac_sa_mask, 0xff, 6 * sizeof(uint8_t));
-		} else
-			IF_ERROR(ERR_GENERAL);
-
-		if (mc_stream_pppoe) {
-			pkt_mod_bm |= (TPM_MAC_DA_SET | TPM_PPPOE_DEL);
-
-			if (TPM_IP_VER_4 == ip_version) {
-				MULTI_IP_2_MAC(mc_mac, group_addr);
-			} else {
-				MULTI_IPV6_2_MAC(mc_mac, group_addr);
-			}
-			memcpy(pkt_mod.mac_mod.mac_da, mc_mac, 6 * sizeof(uint8_t));
-			memset(pkt_mod.mac_mod.mac_da_mask, 0xff, 6 * sizeof(uint8_t));
-		}
-	}
-
-	if (pkt_mod_bm != 0) {
-		ret_code = tpm_proc_create_mod(TPM_ACTION_SET_PKT_MOD, dest_port_bm, &pkt_mod, pkt_mod_bm,
-			TPM_INT_MC_MOD, mod_entry, &trgt_gmac);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_uni_port_igmp_rule()
-*
-* DESCRIPTION:    Create IGMP rule for UNI port.
-*
-* INPUTS:
-* src_port        - uni port to set
-* state           - how to process IGMP packets
-*
-* OUTPUTS:
-*           NONE
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_uni_port_igmp_rule(tpm_src_port_type_t src_port, tpm_igmp_frwd_mode_t mode)
-{
-	int32_t ret_code;
-	tpm_pncl_pnc_full_t igmp_pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_conf_t range_conf;
-	uint32_t cpu_queue;
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_entry;
-	int32_t lPort = 0;
-	uint32_t is_switch_port = 1;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, " UNI-%d IGMP Forward Mode -- %d.\r\n", src_port, mode);
-
-	memset(&igmp_pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/* build TCAM */
-	igmp_pnc_data.pncl_tcam.l2_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.l3_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_PROTO;
-
-	if (src_port < TPM_SRC_PORT_UNI_0 || src_port > TPM_SRC_PORT_UNI_VIRT) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " invalid src_port %d\n", src_port);
-		return(ERR_SRC_PORT_INVALID);
-	}
-
-	is_switch_port = tpm_db_src_port_on_switch(src_port);
-
-	if (is_switch_port == 1) {
-		lPort = tpm_db_eth_port_switch_port_get(src_port);
-		if (lPort == TPM_DB_ERR_PORT_NUM) {
-			printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __func__, __LINE__, src_port);
-			return ERR_SRC_PORT_INVALID;
-		}
-
-		igmp_pnc_data.pncl_tcam.add_info_data = ((lPort) << TPM_AI_UNI_BIT_OFF);
-		igmp_pnc_data.pncl_tcam.add_info_mask = AI_TO_MASK(TPM_AI_UNI_BIT_OFF, TPM_AI_UNI_BIT_SIZE);
-	}
-
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	igmp_pnc_data.pncl_tcam.port_ids = gmac_bm;
-	igmp_pnc_data.pncl_tcam.pkt_key.ipv4_key.ipv4_proto = IPPROTO_IGMP;
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IGMP, &range_conf);
-	IF_ERROR(ret_code);
-	igmp_pnc_data.pncl_tcam.lu_id = range_conf.base_lu_id;
-	start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER_OR_IHL;
-	memcpy(&igmp_pnc_data.pncl_tcam.start_offset, &start_offset, sizeof(tpm_pncl_offset_t));
-
-	/* build SRAM */
-	igmp_pnc_data.pncl_sram.next_lu_id = 0;
-	igmp_pnc_data.pncl_sram.next_lu_off_reg = 0;
-	igmp_pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	igmp_pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER_OR_IHL;
-	igmp_pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	switch (mode) {
-	case TPM_IGMP_FRWD_MODE_DROP:
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_DISC;
-		break;
-
-	case TPM_IGMP_FRWD_MODE_FORWARD:
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD;
-		igmp_pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		break;
-
-	case TPM_IGMP_FRWD_MODE_SNOOPING:
-		tpm_db_igmp_get_cpu_queue(&cpu_queue);
-		igmp_pnc_data.pncl_sram.pnc_queue = cpu_queue;
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP | TPM_PNCL_SET_IGMP;
-		igmp_pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-		break;
-
-	default:
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " invalid state %d\n", mode);
-		return(ERR_PORT_IGMP_FRWD_MODE_INVALID);
-	}
-
-	igmp_pnc_data.pncl_sram.mh_reg.mh_set = TPM_FALSE;
-	igmp_pnc_data.pncl_sram.mh_reg.mh_reg = 0;
-	igmp_pnc_data.pncl_sram.add_info_data = 0;
-	igmp_pnc_data.pncl_sram.add_info_mask = 0;
-	igmp_pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-	igmp_pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	igmp_pnc_data.pncl_sram.sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-	igmp_pnc_data.pncl_sram.flow_id_sub.gem_port = 0;	/* ? */
-	igmp_pnc_data.pncl_sram.flow_id_sub.mod_cmd = 0;
-
-	/* set PNC entry */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_IGMP, &range_data);
-	IF_ERROR(ret_code);
-	/* since WAN port will use the first entry of this range,
-       UNI port must start with the second one.
-	 */
-	pnc_entry = range_data.pnc_range_conf.range_start + src_port - TPM_SRC_PORT_UNI_0 + 1;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-	if (pnc_entry > range_data.pnc_range_conf.range_end) {
-		TPM_OS_ERROR(TPM_INIT_MOD, " IGMP range is not big enough for PNC entry of src_port %d\n", src_port);
-		return(ERR_RULE_NUM_INVALID);
-	}
-
-	ret_code = tpm_pncl_entry_set(pnc_entry, &igmp_pnc_data);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_wan_port_igmp_rule()
-*
-* DESCRIPTION:    Create IGMP rule for PON port.
-*
-* INPUTS:
-* state           - how to process IGMP packets
-*
-* OUTPUTS:
-*           NONE
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_wan_port_igmp_rule(tpm_igmp_frwd_mode_t mode)
-{
-	int32_t ret_code;
-	tpm_pncl_pnc_full_t igmp_pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_conf_t range_conf;
-	uint32_t cpu_queue;
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_entry;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, " PON IGMP Forward Mode -- %d.\r\n", mode);
-
-	memset(&igmp_pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/* build TCAM */
-	igmp_pnc_data.pncl_tcam.l2_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.l3_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	igmp_pnc_data.pncl_tcam.ipv4_parse_bm = TPM_IPv4_PARSE_PROTO;
-	igmp_pnc_data.pncl_tcam.add_info_mask = 0;
-	igmp_pnc_data.pncl_tcam.add_info_data = 0;
-
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	igmp_pnc_data.pncl_tcam.port_ids = gmac_bm;
-	igmp_pnc_data.pncl_tcam.pkt_key.ipv4_key.ipv4_proto = IPPROTO_IGMP;
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IGMP, &range_conf);
-	IF_ERROR(ret_code);
-	igmp_pnc_data.pncl_tcam.lu_id = range_conf.base_lu_id;
-	start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	start_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER_OR_IHL;
-	memcpy(&igmp_pnc_data.pncl_tcam.start_offset, &start_offset, sizeof(tpm_pncl_offset_t));
-
-	/* build SRAM */
-	igmp_pnc_data.pncl_sram.next_lu_id = 0;
-	igmp_pnc_data.pncl_sram.next_lu_off_reg = 0;
-	igmp_pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	igmp_pnc_data.pncl_sram.next_offset.offset_sub.ipv4_subf = TPM_IPv4_PARSE_VER_OR_IHL;
-	igmp_pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	switch (mode) {
-	case TPM_IGMP_FRWD_MODE_DROP:
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_DISC;
-		break;
-
-	case TPM_IGMP_FRWD_MODE_FORWARD:
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD;
-		igmp_pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		break;
-
-	case TPM_IGMP_FRWD_MODE_SNOOPING:
-		tpm_db_igmp_get_cpu_queue(&cpu_queue);
-		igmp_pnc_data.pncl_sram.pnc_queue = cpu_queue;
-		igmp_pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP | TPM_PNCL_SET_IGMP;
-		igmp_pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-		break;
-
-	default:
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " invalid state %d\n", mode);
-		return(ERR_PORT_IGMP_FRWD_MODE_INVALID);
-	}
-
-	igmp_pnc_data.pncl_sram.mh_reg.mh_set = TPM_FALSE;
-	igmp_pnc_data.pncl_sram.mh_reg.mh_reg = 0;
-	igmp_pnc_data.pncl_sram.add_info_data = 0;
-	igmp_pnc_data.pncl_sram.add_info_mask = 0;
-	igmp_pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_IPV4_NFRAG;
-	igmp_pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	igmp_pnc_data.pncl_sram.sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-	igmp_pnc_data.pncl_sram.flow_id_sub.gem_port = 0;	/* ? */
-	igmp_pnc_data.pncl_sram.flow_id_sub.mod_cmd = 0;
-
-	/* set PNC entry */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_IGMP, &range_data);
-	IF_ERROR(ret_code);
-	pnc_entry = range_data.pnc_range_conf.range_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-	if (pnc_entry > range_data.pnc_range_conf.range_end) {
-		TPM_OS_ERROR(TPM_INIT_MOD, " IGMP range is not big enough for PNC entry of WAN port\n");
-		return(ERR_RULE_NUM_INVALID);
-	}
-
-	ret_code = tpm_pncl_entry_set(pnc_entry, &igmp_pnc_data);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_del_port_igmp_rule()
-*
-* DESCRIPTION:    Create IGMP rule for PON port.
-*
-* INPUTS:
-* src_port        - port rule to delete
-*
-* OUTPUTS:
-*           NONE
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_port_igmp_rule(tpm_src_port_type_t src_port)
-{
-	int32_t ret_code;
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_db_pnc_range_t range_data;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-
-	if (src_port >= TPM_SRC_PORT_UNI_ANY) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " invalid src_port %d\n", src_port);
-		return(ERR_SRC_PORT_INVALID);
-	}
-
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_IGMP, &range_data);
-	IF_ERROR(ret_code);
-
-	pnc_con.num_pnc_ranges = 1;
-	pnc_con.pnc_conn_tbl[0].pnc_range = TPM_PNC_IGMP;
-	pnc_con.pnc_conn_tbl[0].pnc_index = range_data.pnc_range_conf.range_start + src_port;
-
-	/* set PNC entry */
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-int32_t tpm_proc_mc_create_virt_uni_pnc_entry(uint32_t rule_num,
-						uint16_t uni_vid,
-						uint8_t group_addr[16],
-						bool    ipv6_flag)
-{
-	int32_t ret_code;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_l2_acl_key_t l2_key;
-	uint8_t mc_mac[6];
-	uint32_t pnc_entry = 0, pnc_range_start = 0, api_start = 0;
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&l2_key, 0, sizeof(tpm_l2_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_VIRT_UNI, &range_conf);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_conf.range_start;
-	api_start = range_conf.api_start;
-
-	if (rule_num >= (range_conf.range_size - 3)) {
-		/* Excludes three default rules:
-		   1. forward all queries to virt_uni
-		   2. discard all other mc streams
-		   3. forward all unicast to virt_uni */
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-	}
-
-	/* Build tcam data */
-	pnc_data.pncl_tcam.lu_id = range_conf.base_lu_id;
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.subf = TPM_L2_PARSE_MH;
-
-	/* Get GMAC(s) */
-	pnc_data.pncl_tcam.port_ids = gmac_pnc_bm[TPM_ENUM_GMAC_1];
-
-	/* Set L2 filter */
-	pnc_data.pncl_tcam.l2_parse_bm = (TPM_L2_PARSE_MH | TPM_L2_PARSE_MAC_DA);
-
-	pnc_data.pncl_tcam.pkt_key.src_port = TPM_SRC_PORT_UNI_VIRT;
-
-	if (ipv6_flag) {
-		MULTI_IPV6_2_MAC(mc_mac, group_addr);
-	}
-	else {
-		MULTI_IP_2_MAC(mc_mac, group_addr);
-	}
-
-	memcpy(&(l2_key.mac.mac_da), mc_mac, 6 * sizeof(uint8_t));
-	memset(&(l2_key.mac.mac_da_mask), 0xff, 6 * sizeof(uint8_t));
-
-	if (uni_vid != 0xffff) {
-		pnc_data.pncl_tcam.l2_parse_bm |= TPM_L2_PARSE_ONE_VLAN_TAG;
-
-		l2_key.vlan1.tpid = 0x8100;
-		l2_key.vlan1.tpid_mask = 0xffff;
-		l2_key.vlan1.pbit = 0;
-		l2_key.vlan1.pbit_mask = 0;
-		l2_key.vlan1.cfi = 0;
-		l2_key.vlan1.cfi_mask = 0;
-		l2_key.vlan1.vid = uni_vid;
-		l2_key.vlan1.vid_mask = 0xffff;
-	}
-
-	/* Copy L2 key */
-	memcpy(&(pnc_data.pncl_tcam.pkt_key.l2_key), &l2_key, sizeof(tpm_l2_acl_key_t));
-
-	/* Build sram data */
-	pnc_data.pncl_sram.sram_updt_bm |= (TPM_PNCL_SET_TXP | TPM_PNCL_SET_LUD | TPM_PNCL_SET_MC);
-
-	/* No next lookup */
-	pnc_data.pncl_sram.next_lu_id = 0;
-	pnc_data.pncl_sram.next_lu_off_reg = 0;
-
-	/* Update dummy register (offset automatically=zero) */
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Set txp and txq */
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-	pnc_data.pncl_sram.pnc_queue = 1;	/* set default virt_uni mc queue via XML */
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Decrease number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_VIRT_UNI);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_delete_virt_uni_pnc_entry(uint32_t rule_num)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	uint32_t pnc_range_start = 0, api_start = 0, pnc_entry = 0;
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_VIRT_UNI, &range_conf);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_conf.range_start;
-	api_start = range_conf.api_start;
-
-	/* Pull range from this index untill last used entry in Pnc range */
-	pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	/* Delete PNC entry */
-	ret_code = tpm_pncl_entry_delete(pnc_entry, pnc_entry);
-	IF_ERROR(ret_code);
-
-	/* Increase number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_VIRT_UNI);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-tpm_error_code_t tpm_proc_add_ipv4_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						uint32_t stream_num,
-						tpm_mc_igmp_mode_t igmp_mode,
-						uint8_t mc_stream_pppoe,
-						uint16_t vid,
-						uint8_t ipv4_src_add[4],
-						uint8_t ipv4_dst_add[4],
-						uint8_t ignore_ipv4_src,
-						uint16_t dest_queue,
-						uint32_t dest_port_bm)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_mc_stream_entry_t mc_stream;
-	tpm_mc_vid_port_cfg_t *mc_vid_cfg = NULL;
-	tpm_gmacs_enum_t gmac;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, rule_num = 0xffff;
-	uint32_t pnc_range_start = 0, api_start = 0, rule_idx = 0;
-	uint32_t entry_id;
-	uint16_t u4_vid;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	/* In MC_MAC_ONLY_FILTER mode, forward all multicast traffic to internal switch by default rule. */
-	if (filter_mode != TPM_MC_MAC_ONLY_FILTER) {
-		/* Set Structs to zero */
-		tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-		/*********** Create Modification Entries **********/
-		ret_code =
-		tpm_proc_create_ipvx_mc_mod(filter_mode, igmp_mode, mc_stream_pppoe, vid, ipv4_dst_add,
-					    dest_port_bm, &mod_entry, TPM_IP_VER_4);
-		IF_ERROR(ret_code);
-
-		/*********** Create PNC Entries **********/
-		/* Build PnC Entry */
-		ret_code =
-		tpm_proc_ipv4_mc_tcam_build(filter_mode, stream_num, vid, mc_stream_pppoe, ipv4_src_add,
-					    ipv4_dst_add, ignore_ipv4_src, &(pnc_data.pncl_tcam));
-		IF_ERROR(ret_code);
-
-		/* Build SRAM Entry */
-		ret_code =
-		tpm_proc_ipvx_mc_sram_build(filter_mode, igmp_mode, dest_queue,
-					    dest_port_bm, mod_entry,
-					    &(pnc_data.pncl_sram), TPM_IP_VER_4);
-		IF_ERROR(ret_code);
-
-		/*** Calculate PNC Entry ***/
-
-		/* Get PNC Range Start */
-		ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_MC_DS, &range_data);
-		IF_ERROR(ret_code);
-		pnc_range_start = range_data.pnc_range_conf.range_start;
-		api_start = range_data.pnc_range_conf.api_start;
-
-		/* Calculate absolute PNC entry number to execute */
-		pnc_entry = (pnc_range_start + api_start) + stream_num;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " stream_num(%d), pnc_entry(%d)\n", stream_num, pnc_entry);
-
-		ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-		IF_ERROR(ret_code);
-
-		/* Decrease number of free entries in pnc_range */
-		ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_IPV4_MC_DS);
-		IF_ERROR(ret_code);
-
-		/*********** Update API Range in DB **********/
-
-		/* Set API data */
-		memcpy(api_data.ipv4_mc_key.ipv4_src_add, ipv4_src_add, sizeof(ipv4_src_add));
-		memcpy(api_data.ipv4_mc_key.ipv4_dest_add, ipv4_dst_add, sizeof(ipv4_dst_add));
-		api_data.ipv4_mc_key.ignore_ipv4_src = ignore_ipv4_src;
-		api_data.ipv4_mc_key.dest_port_bm = dest_port_bm;
-		api_data.ipv4_mc_key.dest_queue = dest_queue;
-		api_data.ipv4_mc_key.vid = vid;
-		api_data.ipv4_mc_key.igmp_mode = igmp_mode;
-		api_data.ipv4_mc_key.mc_stream_pppoe = mc_stream_pppoe;
-		api_data.ipv4_mc_key.stream_num = stream_num;
-
-		/* Set Pnc Connection data */
-		pnc_conn.num_pnc_ranges = 1;
-		pnc_conn.pnc_conn_tbl[0].pnc_range = TPM_PNC_IPV4_MC_DS;
-		pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-		/* Set Modification Connection data */
-		mod_con.mod_cmd_ind = mod_entry;
-		if (mod_entry) {
-			ret_code = tpm_db_target_to_gmac(pnc_data.pncl_sram.flow_id_sub.pnc_target, &gmac);
-			IF_ERROR(ret_code);
-			mod_con.mod_cmd_mac = gmac;
-		}
-		/* Set new API Entry */
-		ret_code = tpm_db_api_entry_set(TPM_IPV4_MC, stream_num, 0 /*bi_dir */ ,
-						&api_data, &mod_con, &pnc_conn, &rule_idx);
-		IF_ERROR(ret_code);
-
-		if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-			if (tpm_db_get_mc_per_uni_vlan_xlate() != 0 && (dest_port_bm & TPM_TRG_UNI_VIRT) != 0) {
-				ret_code = tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg);
-				IF_ERROR(ret_code);
-
-				for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-					if (mc_vid_cfg[entry_id].tpm_src_port == TPM_SRC_PORT_UNI_VIRT)
-						break;
-				}
-				if (entry_id == TPM_MAX_NUM_UNI_PORTS) {
-					TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-						     " virt_uni is unable to join the group when "
-						     "virt_uni is not the member of multicast vlan \n");
-				} else if (mc_vid_cfg[entry_id].mc_uni_port_mode != TPM_MC_UNI_MODE_EXCLUDE) {
-					if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSPARENT)
-						u4_vid = vid;
-					else if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP)
-						u4_vid = 0xffff;
-					else
-						u4_vid = mc_vid_cfg[entry_id].uni_port_vid;
-
-					ret_code = tpm_db_mc_alloc_virt_uni_entry(&rule_num);
-					IF_ERROR(ret_code);
-
-					ret_code =
-					tpm_proc_mc_create_virt_uni_pnc_entry(rule_num, u4_vid, ipv4_dst_add, false);
-					IF_ERROR(ret_code);
-				}
-			}
-		}
-	}
-
-	/* Set new stream entry */
-	mc_stream.igmp_mode = igmp_mode;
-	mc_stream.mc_stream_pppoe = mc_stream_pppoe;
-	mc_stream.src_valid = ignore_ipv4_src;
-	mc_stream.vid = vid;
-	mc_stream.dest_queue = dest_queue;
-	mc_stream.dest_port_bm = dest_port_bm;
-	mc_stream.u4_entry = rule_num;
-	memcpy(mc_stream.group_addr, ipv4_dst_add, 4 * sizeof(uint8_t));
-	if (!ignore_ipv4_src)
-		memcpy(mc_stream.src_addr, ipv4_src_add, 4 * sizeof(uint8_t));
-
-	ret_code = tpm_db_set_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_update_ipv4_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						   uint32_t stream_num,
-						   tpm_mc_igmp_mode_t igmp_mode,
-						   uint8_t mc_stream_pppoe,
-						   uint16_t vid,
-						   uint8_t ipv4_src_add[4],
-						   uint8_t ipv4_dst_add[4],
-						   uint8_t ignore_ipv4_src,
-						   uint16_t dest_queue,
-						   uint32_t dest_port_bm)
-{
-	tpm_db_pnc_range_t range_data;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_mc_stream_entry_t mc_stream;
-	tpm_mc_vid_port_cfg_t *mc_vid_cfg = NULL;
-
-	int32_t ret_code;
-	uint32_t bi_dir = 0, rule_idx = 0, pnc_entry = 0, mod_entry = 0, rule_num = 0xffff;
-	uint32_t entry_id;
-	uint16_t u4_vid;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	/* Get old API Entry */
-	ret_code = tpm_db_api_entry_get(TPM_IPV4_MC, stream_num, &rule_idx, &bi_dir,
-					&api_data, &mod_con, &pnc_conn);
-	IF_ERROR(ret_code);
-
-	/* Only MC_IP_ONLY_FILTER mode, update the multicast group member ports by mh_mod. */
-	if (filter_mode == TPM_MC_IP_ONLY_FILTER) {
-		/* Get PNC Range Start */
-		ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV4_MC_DS, &range_data);
-		IF_ERROR(ret_code);
-
-		if (stream_num >= range_data.pnc_range_conf.range_size)
-			IF_ERROR(ERR_MC_STREAM_INVALID);
-
-		pnc_entry = pnc_conn.pnc_conn_tbl[0].pnc_index;
-
-		/* Create new Modification Entry */
-		ret_code = tpm_proc_create_ipvx_mc_mod(filter_mode, igmp_mode, mc_stream_pppoe,
-						       vid, ipv4_dst_add, dest_port_bm, &mod_entry, TPM_IP_VER_4);
-		IF_ERROR(ret_code);
-
-		/* Rebuild PnC Entry */
-		ret_code = tpm_proc_ipv4_mc_tcam_build(filter_mode, stream_num, vid, mc_stream_pppoe, ipv4_src_add,
-						       ipv4_dst_add, ignore_ipv4_src, &(pnc_data.pncl_tcam));
-		IF_ERROR(ret_code);
-
-		/* Rebuild SRAM Entry */
-		ret_code =
-		tpm_proc_ipvx_mc_sram_build(filter_mode, igmp_mode, dest_queue,
-					    dest_port_bm, mod_entry,
-					    &(pnc_data.pncl_sram), TPM_IP_VER_4);
-		IF_ERROR(ret_code);
-
-		/* Update only Sram of PNC Entry */
-		ret_code = tpm_pncl_update_sram(pnc_entry, &pnc_data);
-		IF_ERROR(ret_code);
-
-		/* Delete old Modification Entry */
-		if (mod_con.mod_cmd_ind != 0) {
-			ret_code = tpm_proc_delete_mod(TPM_MOD_OWNER_TPM, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-			IF_ERROR(ret_code);
-		}
-		/* Update new Modification Entry */
-		mod_con.mod_cmd_ind = mod_entry;
-	}
-
-	if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0) {
-			ret_code = tpm_db_get_mc_stream_entry(stream_num, &mc_stream);
-			IF_ERROR(ret_code);
-
-			rule_num = mc_stream.u4_entry;
-
-			if ((dest_port_bm & TPM_TRG_UNI_VIRT) != 0 && (mc_stream.dest_port_bm & TPM_TRG_UNI_VIRT) == 0) {
-				ret_code = tpm_db_mc_alloc_virt_uni_entry(&rule_num);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg);
-				IF_ERROR(ret_code);
-
-				for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-					if (mc_vid_cfg[entry_id].tpm_src_port == TPM_SRC_PORT_UNI_VIRT)
-						break;
-				}
-				if (entry_id == TPM_MAX_NUM_UNI_PORTS) {
-					TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-						     " virt_uni is unable to join the group when "
-						     "virt_uni is not the member of multicast vlan \n");
-				} else {
-					if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSPARENT)
-						u4_vid = vid;
-					else if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP)
-						u4_vid = 0xffff;
-					else
-						u4_vid = mc_vid_cfg[entry_id].uni_port_vid;
-
-					ret_code =
-					tpm_proc_mc_create_virt_uni_pnc_entry(rule_num, u4_vid, ipv4_dst_add, false);
-					IF_ERROR(ret_code);
-				}
-			} else if ((dest_port_bm & TPM_TRG_UNI_VIRT) == 0 && (mc_stream.dest_port_bm & TPM_TRG_UNI_VIRT) != 0) {
-				if (rule_num != 0xffff) {
-					ret_code = tpm_proc_mc_delete_virt_uni_pnc_entry(rule_num);
-					IF_ERROR(ret_code);
-					ret_code = tpm_db_mc_free_virt_uni_entry(rule_num);
-					IF_ERROR(ret_code);
-					rule_num = 0xffff;
-				}
-			}
-		}
-	}
-
-	/* Update stream entry */
-	mc_stream.igmp_mode = igmp_mode;
-	mc_stream.mc_stream_pppoe = mc_stream_pppoe;
-	mc_stream.src_valid = ignore_ipv4_src;
-	mc_stream.vid = vid;
-	mc_stream.dest_port_bm = dest_port_bm;
-	mc_stream.u4_entry = rule_num;
-	memcpy(mc_stream.group_addr, ipv4_dst_add, 4 * sizeof(uint8_t));
-	if (ignore_ipv4_src)
-		memcpy(mc_stream.src_addr, ipv4_src_add, 4 * sizeof(uint8_t));
-
-	ret_code = tpm_db_set_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	/* Update API entry */
-	/* Invalidate old API Entry */
-	ret_code = tpm_db_api_entry_invalidate(TPM_IPV4_MC, stream_num);
-	IF_ERROR(ret_code);
-
-	/* Set new API Entry */
-	api_data.ipv4_mc_key.dest_port_bm = dest_port_bm;
-	ret_code = tpm_db_api_entry_set(TPM_IPV4_MC, stream_num, 0 /*bi_dir */ ,
-					&api_data, &mod_con, &pnc_conn, &rule_idx);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_set_ipv4_mc_switch(tpm_mc_filter_mode_t filter_mode,
-					     uint8_t mc_mac[6],
-					     uint32_t old_target,
-					     uint32_t new_target)
-{
-	int32_t ret_code;
-	uint32_t trg_port_bm = 0, diff_target = 0;
-	uint32_t port;
-	uint32_t switch_init = 0;
-
-	/*get switch init*/
-	ret_code = tpm_db_switch_init_get(&switch_init);
-	IF_ERROR(ret_code);
-
-	if (!switch_init) {
-		/* no switch, no ATU operation */
-		TPM_OS_INFO(TPM_TPM_LOG_MOD, "no switch, no ATU operation\n");
-		return TPM_RC_OK;
-	}
-
-	diff_target = old_target ^ new_target;
-	port = TPM_TRG_UNI_0;
-
-	while (port != TPM_TRG_PORT_CPU) {
-		if (diff_target & port) {
-			if (old_target & port) {
-				ret_code = tpm_db_decrease_mc_mac_port_user_num(mc_mac, port);
-				IF_ERROR(ret_code);
-
-				if (tpm_db_get_mc_mac_port_user_num(mc_mac, port) != 0)
-					new_target |= port;
-			} else {
-				ret_code = tpm_db_increase_mc_mac_port_user_num(mc_mac, port);
-				IF_ERROR(ret_code);
-			}
-		}
-
-		port = port << 1;
-	}
-
-	if (new_target != 0)
-		new_target |= TPM_TRG_PORT_CPU;	/* igmp report to CPU */
-
-	switch (filter_mode) {
-	case TPM_MC_COMBINED_IP_MAC_FILTER:
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0 && new_target != 0)
-			new_target |= TPM_TRG_UNI_VIRT;	/* loopback G1 */
-	case TPM_MC_MAC_ONLY_FILTER:
-		trg_port_bm = tpm_db_trg_port_switch_port_get(new_target);
-		break;
-	case TPM_MC_IP_ONLY_FILTER:
-		trg_port_bm = 0x3F;	/* all uni ports + CPU + G1/wifi */
-		break;
-	default:
-		break;
-	}
-
-	if (new_target == 0) {
-		ret_code = tpm_sw_del_static_mac(TPM_MOD_OWNER_TPM, mc_mac);
-		IF_ERROR(ret_code);
-		tpm_db_reset_mc_mac_entry(mc_mac);
-	} else {
-		ret_code = tpm_sw_set_static_mac_w_ports_mask(TPM_MOD_OWNER_TPM, trg_port_bm, mc_mac);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_ipv4_mc_stream()
-*
-* DESCRIPTION:    Main function for adding IPv4 multicast streams.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_ipv4_mc_stream(uint32_t owner_id,
-					     uint32_t stream_num,
-					     tpm_mc_igmp_mode_t igmp_mode,
-					     uint8_t mc_stream_pppoe,
-					     uint16_t vid,
-					     uint8_t ipv4_src_add[4],
-					     uint8_t ipv4_dst_add[4],
-					     uint8_t ignore_ipv4_src,
-					     uint16_t dest_queue,
-					     tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) stream_num(%d), igmp_mode(%d), mc_stream_pppoe(%d), vid(%d) "
-		     "sip(0x%02x%02x%02x%02x), dip(0x%02x%02x%02x%02x), ignore_ipv4_src(%d), dest_port_bm(0x%x)\n",
-		     owner_id, stream_num, igmp_mode, mc_stream_pppoe, vid, ipv4_src_add[0], ipv4_src_add[1],
-		     ipv4_src_add[2], ipv4_src_add[3], ipv4_dst_add[0], ipv4_dst_add[1], ipv4_dst_add[2],
-		     ipv4_dst_add[3], ignore_ipv4_src, dest_port_bm);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_UNI_ANY)
-		dest_port_bm = tpm_db_trg_port_uni_any_bmp_get(true);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipvx_mc_check(owner_id, stream_num, igmp_mode, mc_stream_pppoe, vid,
-					      ipv4_src_add, ipv4_dst_add, ignore_ipv4_src, dest_queue,
-					      dest_port_bm, filter_mode, TPM_IP_VER_4);
-	IF_ERROR(ret_code);
-
-	/* get queue number */
-	if (dest_queue == TPM_INVALID_QUEUE) {
-		if (dest_port_bm & TPM_TRG_PORT_CPU)
-			dest_queue = tpm_db_get_mc_cpu_queue();
-		else
-			dest_queue = tpm_db_get_mc_hwf_queue();
-	}
-	/* Create PNC entry */
-	ret_code = tpm_proc_add_ipv4_mc_pnc_entry(filter_mode, stream_num, igmp_mode, mc_stream_pppoe, vid,
-						  ipv4_src_add, ipv4_dst_add, ignore_ipv4_src, dest_queue, dest_port_bm);
-	IF_ERROR(ret_code);
-
-	/* Set switch port_map for multicast MAC, but don't overwrite 224.0.0.1 (IGMP General Query) MAC */
-	MULTI_IP_2_MAC(mc_mac, ipv4_dst_add);
-	if (memcmp(mc_mac, tpm_igmp_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, 0, dest_port_bm);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_updt_ipv4_mc_stream()
-*
-* DESCRIPTION:    Main function for updating IPv4 multicast streams.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_updt_ipv4_mc_stream(uint32_t owner_id, uint32_t stream_num, tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-	tpm_init_virt_uni_t virt_uni;
-	tpm_db_mc_stream_entry_t mc_stream;
-
-	memset(&virt_uni, 0, sizeof(tpm_init_virt_uni_t));
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) stream_num(%d),dest_port_bm(0x%x)\n",
-		     owner_id, stream_num, dest_port_bm);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	tpm_db_virt_info_get(&virt_uni);
-
-	if (dest_port_bm & TPM_TRG_UNI_VIRT) {
-		if (virt_uni.enabled == 0)
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_CPU) {
-		if (dest_port_bm & (~TPM_TRG_PORT_CPU))
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_UNI_ANY)
-		dest_port_bm = tpm_db_trg_port_uni_any_bmp_get(true);
-
-	ret_code = tpm_proc_check_dst_uni_port(dest_port_bm);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_get_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	if (dest_port_bm == mc_stream.dest_port_bm) {
-		/* nothing changed, return directly */
-		TPM_OS_INFO(TPM_TPM_LOG_MOD, "dest_port_bm does not change, return directly\n");
-		return (TPM_OK);
-	}
-
-	if (((dest_port_bm & TPM_TRG_PORT_CPU) != 0 && (mc_stream.dest_port_bm & TPM_TRG_PORT_CPU) == 0) ||
-	    ((dest_port_bm & TPM_TRG_PORT_CPU) == 0 && (mc_stream.dest_port_bm & TPM_TRG_PORT_CPU) != 0)) {
-		ret_code = tpm_proc_delete_ipvx_mc_pnc_entry(filter_mode, stream_num,
-							mc_stream.dest_port_bm, mc_stream.u4_entry,
-							TPM_IP_VER_4);
-		IF_ERROR(ret_code);
-
-		ret_code = tpm_proc_add_ipv4_mc_pnc_entry(filter_mode, stream_num, mc_stream.igmp_mode,
-							mc_stream.mc_stream_pppoe, mc_stream.vid,
-							mc_stream.src_addr, mc_stream.group_addr,
-							mc_stream.src_valid, mc_stream.dest_queue,
-							dest_port_bm);
-	} else {
-		ret_code = tpm_proc_update_ipv4_mc_pnc_entry(filter_mode, stream_num, mc_stream.igmp_mode,
-							mc_stream.mc_stream_pppoe, mc_stream.vid,
-							mc_stream.src_addr, mc_stream.group_addr,
-							mc_stream.src_valid, mc_stream.dest_queue,
-							dest_port_bm);
-	}
-	IF_ERROR(ret_code);
-
-	/* Set switch port_map for multicast MAC, but don't overwrite 224.0.0.1 (IGMP General Query) MAC */
-	MULTI_IP_2_MAC(mc_mac, mc_stream.group_addr);
-	if (memcmp(mc_mac, tpm_igmp_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, mc_stream.dest_port_bm, dest_port_bm);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_del_ipv4_mc_stream()
-*
-* DESCRIPTION:      Deletes an existing IPv4 MC stream.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* stream_num         - MC stream number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_ipv4_mc_stream(uint32_t owner_id, uint32_t stream_num)
-{
-
-	int32_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-	tpm_db_mc_stream_entry_t mc_stream;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) stream_num(%d)\n", owner_id, stream_num);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	ret_code = tpm_db_get_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	ret_code =
-	tpm_proc_delete_ipvx_mc_pnc_entry(filter_mode, stream_num,
-	                                  mc_stream.dest_port_bm,
-	                                  mc_stream.u4_entry,
-	                                  TPM_IP_VER_4);
-	IF_ERROR(ret_code);
-
-	/* Set switch VID and multicast MAC */
-	MULTI_IP_2_MAC(mc_mac, mc_stream.group_addr);
-	/* Make sure that donot remove the mac 01-00-5e-00-00-01 from Switch which is used by Genery Query */
-	if (memcmp(mc_mac, tpm_igmp_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, mc_stream.dest_port_bm, 0);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************/
-/*     Multicast Loopback      */
-/*******************************/
-
-int32_t tpm_proc_mc_lpbk_xlat_tcam_build(tpm_ip_ver_t ip_ver, uint16_t mvlan, uint16_t in_vid, tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-	uint8_t first_lpbk;
-	tpm_l2_acl_key_t l2_key;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mvlan(%d), in_vid(%d) \n", mvlan, in_vid);
-
-	tcam_data->l2_parse_bm = 0;
-	memset(&l2_key, 0, sizeof(tpm_l2_acl_key_t));
-
-	first_lpbk = 0;
-	if (mvlan == in_vid)
-		first_lpbk = 1;
-
-	/* Get PNC Range information */
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_MULTI_LPBK, &range_conf);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = range_conf.base_lu_id;
-	tcam_data->start_offset.range_id = TPM_PNC_MULTI_LPBK;
-	tcam_data->start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	tcam_data->start_offset.offset_sub.subf = TPM_L2_PARSE_MH;
-
-	/* Get GMAC(s) */
-	tcam_data->port_ids = gmac_pnc_bm[TPM_ENUM_GMAC_1];
-
-	/* Parse MH for src_port filter */
-	tcam_data->l2_parse_bm |= TPM_L2_PARSE_MH;
-	if (first_lpbk)
-		tcam_data->pkt_key.src_port = TPM_SRC_PORT_WAN;
-	else
-		tcam_data->pkt_key.src_port = TPM_SRC_PORT_UNI_VIRT;
-
-	/* Parse MC DA filter */
-	tcam_data->l2_parse_bm |= TPM_L2_PARSE_MAC_DA;
-	if (ip_ver == TPM_IP_VER_4) {
-		l2_key.mac.mac_da[0] = 0x01;
-		l2_key.mac.mac_da[1] = 0x00;
-		l2_key.mac.mac_da[2] = 0x5e;
-		l2_key.mac.mac_da_mask[0] = 0xff;
-		l2_key.mac.mac_da_mask[1] = 0xff;
-		l2_key.mac.mac_da_mask[2] = 0xff;
-	} else {
-		l2_key.mac.mac_da[0] = 0x33;
-		l2_key.mac.mac_da[1] = 0x33;
-		l2_key.mac.mac_da_mask[0] = 0xff;
-		l2_key.mac.mac_da_mask[1] = 0xff;
-	}
-
-	/* Parse VLAN filter */
-	if (first_lpbk) {
-		tcam_data->l2_parse_bm |= TPM_L2_PARSE_ONE_VLAN_TAG;
-		l2_key.vlan1.tpid = 0x8100;
-		l2_key.vlan1.tpid_mask = 0xffff;
-		l2_key.vlan1.pbit = 0;
-		l2_key.vlan1.pbit_mask = 0;
-		l2_key.vlan1.cfi = 0;
-		l2_key.vlan1.cfi_mask = 0;
-		l2_key.vlan1.vid = in_vid;
-		l2_key.vlan1.vid_mask = 0xffff;
-	} else {
-		tcam_data->l2_parse_bm |= TPM_L2_PARSE_TWO_VLAN_TAG;
-
-		l2_key.vlan1.tpid = 0x8100;
-		l2_key.vlan1.tpid_mask = 0xffff;
-		l2_key.vlan1.pbit = 0;
-		l2_key.vlan1.pbit_mask = 0;
-		l2_key.vlan1.cfi = 0;
-		l2_key.vlan1.cfi_mask = 0;
-		l2_key.vlan1.vid = mvlan;
-		l2_key.vlan1.vid_mask = 0xffff;
-
-		l2_key.vlan2.tpid = 0x8100;
-		l2_key.vlan2.tpid_mask = 0xffff;
-		l2_key.vlan2.pbit = 0;
-		l2_key.vlan2.pbit_mask = 0;
-		l2_key.vlan2.cfi = 0;
-		l2_key.vlan2.cfi_mask = 0;
-		l2_key.vlan2.vid = in_vid;
-		l2_key.vlan2.vid_mask = 0xffff;
-	}
-
-	/* Copy in logical PnC Key */
-	memcpy(&(tcam_data->pkt_key.l2_key), &l2_key, sizeof(tpm_l2_acl_key_t));
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_lpbk_xlat_sram_build(uint32_t mod_entry, tpm_pncl_sram_data_t *sram_data)
-{
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " mod_entry(%d) \n", mod_entry);
-
-	/* Set sram_updt bitmap */
-	sram_data->sram_updt_bm |= (TPM_PNCL_SET_TXP | TPM_PNCL_SET_MOD | TPM_PNCL_SET_LUD | TPM_PNCL_SET_MC);
-
-	/* No next lookup */
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-
-	/* Update dummy register (offset automatically=zero) */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Set txp and txq */
-	sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC1;
-	sram_data->pnc_queue = 1;	/* set default mc_lpbk queue via XML */
-
-	/* Set modification command */
-	sram_data->flow_id_sub.mod_cmd = mod_entry;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_create_lpbk_xlate_mod(uint16_t mvlan, uint16_t in_vid, uint16_t out_vid,
-					  tpm_trg_port_type_t port_bm, uint32_t *mod_entry)
-{
-	int32_t ret_code;
-	uint8_t first_lpbk;
-	tpm_pkt_mod_bm_t mod_bm;
-	tpm_pkt_mod_t mod_data;
-
-	memset(&mod_data, 0, sizeof(tpm_pkt_mod_t));
-
-	first_lpbk = 0;
-	if (mvlan == in_vid)
-		first_lpbk = 1;
-
-	/* Set loopback target ports */
-	mod_bm = TPM_MH_SET;
-	mod_data.mh_mod = tpm_db_trg_port_switch_port_get(port_bm | TPM_TRG_UNI_VIRT);
-
-	/* Set vlan modification data */
-	if (port_bm & TPM_TRG_UNI_VIRT) {
-		if (first_lpbk) {
-			if (mvlan == out_vid) {
-				/* uni-4 is transparent port while all the other uni_ports are transparent ports or strip ports. */
-				/* Noop, just do a dummy loopback! */
-			} else if (out_vid == 0xffff) {
-				mod_bm |= TPM_VLAN_MOD;
-				/* uni-4 is strip port and remove outer vlan tag */
-				mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_DEL;
-			} else {
-				mod_bm |= TPM_VLAN_MOD;
-				/* uni-4 is translated port and replace outer vlan tag */
-				mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_MOD;
-				mod_data.vlan_mod.vlan1_out.tpid = 0x8100;
-				mod_data.vlan_mod.vlan1_out.pbit = 0;
-				mod_data.vlan_mod.vlan1_out.pbit_mask = 0x0;
-				mod_data.vlan_mod.vlan1_out.cfi = 0;
-				mod_data.vlan_mod.vlan1_out.cfi_mask = 0x0;
-				mod_data.vlan_mod.vlan1_out.vid = out_vid;
-				mod_data.vlan_mod.vlan1_out.vid_mask = 0xffff;
-			}
-		} else {
-			mod_bm |= TPM_VLAN_MOD;
-
-			if (mvlan == out_vid) {
-				/* uni-4 is transparent port while at least one of the other uni_ports is translated ports. */
-				/* remove inner vlan tag */
-				mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_DEL_INT_MOD;
-				mod_data.vlan_mod.vlan2_out.tpid = 0x8100;
-				mod_data.vlan_mod.vlan2_out.pbit = 0;
-				mod_data.vlan_mod.vlan2_out.pbit_mask = 0x0;
-				mod_data.vlan_mod.vlan2_out.cfi = 0;
-				mod_data.vlan_mod.vlan2_out.cfi_mask = 0x0;
-				mod_data.vlan_mod.vlan2_out.vid = out_vid;
-				mod_data.vlan_mod.vlan2_out.vid_mask = 0xffff;
-			} else if (out_vid == 0xffff) {
-				/* uni-4 is strip port and remove outer and inner vlan tag */
-				mod_data.vlan_mod.vlan_op = VLANOP_DEL_2TAG;
-			} else {
-				/* uni-4 is translated port and remove outer vlan tag, replace inner vlan tag */
-				mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_DEL_INT_MOD;
-				mod_data.vlan_mod.vlan2_out.tpid = 0x8100;
-				mod_data.vlan_mod.vlan2_out.pbit = 0;
-				mod_data.vlan_mod.vlan2_out.pbit_mask = 0x0;
-				mod_data.vlan_mod.vlan2_out.cfi = 0;
-				mod_data.vlan_mod.vlan2_out.cfi_mask = 0x0;
-				mod_data.vlan_mod.vlan2_out.vid = out_vid;
-				mod_data.vlan_mod.vlan2_out.vid_mask = 0xffff;
-			}
-		}
-	} else {
-		if (out_vid == 0xffff || mvlan == out_vid) {
-			TPM_OS_WARN(TPM_PNCL_MOD, "Input vlan equals to output vlan, should be transparent, not translate!\n");
-			return ERR_GENERAL;
-		}
-		mod_bm |= TPM_VLAN_MOD;
-
-		if (first_lpbk) {
-			mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_MOD_INS;
-			mod_data.vlan_mod.vlan1_out.tpid = 0x8100;
-			mod_data.vlan_mod.vlan1_out.pbit = 0;
-			mod_data.vlan_mod.vlan1_out.pbit_mask = 0x0;
-			mod_data.vlan_mod.vlan1_out.cfi = 0;
-			mod_data.vlan_mod.vlan1_out.cfi_mask = 0x0;
-			mod_data.vlan_mod.vlan1_out.vid = mvlan;
-			mod_data.vlan_mod.vlan1_out.vid_mask = 0xffff;
-			mod_data.vlan_mod.vlan2_out.tpid = 0x8100;
-			mod_data.vlan_mod.vlan2_out.pbit = 0;
-			mod_data.vlan_mod.vlan2_out.pbit_mask = 0xff;
-			mod_data.vlan_mod.vlan2_out.cfi = 0;
-			mod_data.vlan_mod.vlan2_out.cfi_mask = 0xff;
-			mod_data.vlan_mod.vlan2_out.vid = out_vid;
-			mod_data.vlan_mod.vlan2_out.vid_mask = 0xffff;
-		} else {
-			mod_data.vlan_mod.vlan_op = VLANOP_INT_TAG_MOD;
-			mod_data.vlan_mod.vlan2_out.tpid = 0x8100;
-			mod_data.vlan_mod.vlan2_out.pbit = 0;
-			mod_data.vlan_mod.vlan2_out.pbit_mask = 0xff;
-			mod_data.vlan_mod.vlan2_out.cfi = 0;
-			mod_data.vlan_mod.vlan2_out.cfi_mask = 0xff;
-			mod_data.vlan_mod.vlan2_out.vid = out_vid;
-			mod_data.vlan_mod.vlan2_out.vid_mask = 0xffff;
-		}
-	}
-
-	/* Create modification entry */
-	ret_code = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, TPM_ENUM_GMAC_1, mod_bm, TPM_INT_MC_MOD, &mod_data, mod_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_lpbk_calc_rule_num(uint32_t *rule_num)
-{
-	int32_t ret_code;
-	uint32_t _rule_num;
-	tpm_db_pnc_range_t range_data;
-
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MULTI_LPBK, &range_data);
-	IF_ERROR(ret_code);
-
-	_rule_num = tpm_db_mc_lpbk_entries_num_get();
-
-	if (_rule_num > range_data.pnc_range_conf.range_size)
-		return TPM_FAIL;
-
-	*rule_num = _rule_num;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_lpbk_create_acl_rule(uint32_t rule_num, tpm_pncl_pnc_full_t *pnc_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_start = 0, pnc_entries_num = 0, api_start = 0, pnc_entry = 0, pnc_stop_entry = 0;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MULTI_LPBK, &range_data);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	/* Get existing PNC entry number */
-	pnc_entries_num = tpm_db_mc_lpbk_entries_num_get();
-
-	/* Call PNC Entry Insert, if this is not the api_section's new last entry */
-	if (rule_num < pnc_entries_num) {
-		pnc_stop_entry = (pnc_range_start + api_start) + (pnc_entries_num - 1);
-		ret_code = tpm_pncl_entry_insert(pnc_entry, pnc_stop_entry, pnc_data);
-		IF_ERROR(ret_code);
-	} else {		/* Otherwise just set the entry (no insertion) */
-
-		ret_code = tpm_pncl_entry_set(pnc_entry, pnc_data);
-		IF_ERROR(ret_code);
-	}
-
-	/* Decrease number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_MULTI_LPBK);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_lpbk_delete_acl_rule(uint32_t rule_num)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_t range_data;
-	uint32_t pnc_range_start = 0, pnc_entries_num = 0, api_start = 0, pnc_start_entry = 0, pnc_stop_entry = 0;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MULTI_LPBK, &range_data);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Get existing PNC entry number */
-	pnc_entries_num = tpm_db_mc_lpbk_entries_num_get();
-
-	/* Pull range from this index untill last used entry in Pnc range */
-	pnc_start_entry = (pnc_range_start + api_start) + rule_num;
-	pnc_stop_entry = (pnc_range_start + api_start) + (pnc_entries_num - 1);
-
-	/* Delete PNC entry */
-	ret_code = tpm_pncl_entry_delete(pnc_start_entry, pnc_stop_entry);
-	IF_ERROR(ret_code);
-
-	/* Increase number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_MULTI_LPBK);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_set_translation_uni_x_first(tpm_ip_ver_t ip_ver, uint16_t mvlan, uint16_t out_vid, tpm_trg_port_type_t port_bm)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0, mod_entry = 0;
-	tpm_pncl_pnc_full_t pnc_data;
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/*********** Create Modification Entries **********/
-	ret_code = tpm_proc_mc_create_lpbk_xlate_mod(mvlan, mvlan, out_vid, port_bm, &mod_entry);
-	IF_ERROR(ret_code);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_tcam_build(ip_ver, mvlan, mvlan, &(pnc_data.pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_sram_build(mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(ret_code);
-
-	/* Calculate ACL Rule Num */
-	ret_code = tpm_proc_mc_lpbk_calc_rule_num(&rule_num);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK ACL Rule */
-	ret_code = tpm_proc_mc_lpbk_create_acl_rule(rule_num, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK Rule DB */
-	ret_code = tpm_db_mc_lpbk_entry_set(ip_ver, mvlan, mvlan, out_vid, rule_num, mod_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_set_translation_uni_x_next(tpm_ip_ver_t ip_ver, uint16_t mvlan, uint16_t in_vid, uint16_t out_vid,
-					       tpm_trg_port_type_t port_bm)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0, mod_entry = 0;
-	tpm_pncl_pnc_full_t pnc_data;
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/*********** Create Modification Entries **********/
-	ret_code = tpm_proc_mc_create_lpbk_xlate_mod(mvlan, in_vid, out_vid, port_bm, &mod_entry);
-	IF_ERROR(ret_code);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_tcam_build(ip_ver, mvlan, in_vid, &(pnc_data.pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_sram_build(mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(ret_code);
-
-	/* Calculate ACL Rule Num */
-	ret_code = tpm_proc_mc_lpbk_calc_rule_num(&rule_num);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK ACL Rule */
-	ret_code = tpm_proc_mc_lpbk_create_acl_rule(rule_num, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK Rule DB */
-	ret_code = tpm_db_mc_lpbk_entry_set(ip_ver, mvlan, in_vid, out_vid, rule_num, mod_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_set_translation_max_uni_first(tpm_ip_ver_t ip_ver, uint16_t mvlan, uint16_t out_vid)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0, mod_entry = 0, port_bm = TPM_TRG_UNI_VIRT;
-	tpm_pncl_pnc_full_t pnc_data;
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/*********** Create Modification Entries **********/
-	ret_code = tpm_proc_mc_create_lpbk_xlate_mod(mvlan, mvlan, out_vid, port_bm, &mod_entry);
-	IF_ERROR(ret_code);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_tcam_build(ip_ver, mvlan, mvlan, &(pnc_data.pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_sram_build(mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(ret_code);
-
-	/* Calculate ACL Rule Num */
-	ret_code = tpm_proc_mc_lpbk_calc_rule_num(&rule_num);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK ACL Rule */
-	ret_code = tpm_proc_mc_lpbk_create_acl_rule(rule_num, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK Rule DB */
-	ret_code = tpm_db_mc_lpbk_entry_set(ip_ver, mvlan, mvlan, out_vid, rule_num, mod_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_set_translation_max_uni_next(tpm_ip_ver_t ip_ver, uint16_t mvlan, uint16_t in_vid, uint16_t out_vid)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0, mod_entry = 0, port_bm = TPM_TRG_UNI_VIRT;
-	tpm_pncl_pnc_full_t pnc_data;
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/*********** Create Modification Entries **********/
-	ret_code = tpm_proc_mc_create_lpbk_xlate_mod(mvlan, in_vid, out_vid, port_bm, &mod_entry);
-	IF_ERROR(ret_code);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_tcam_build(ip_ver, mvlan, in_vid, &(pnc_data.pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_mc_lpbk_xlat_sram_build(mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(ret_code);
-
-	/* Calculate ACL Rule Num */
-	ret_code = tpm_proc_mc_lpbk_calc_rule_num(&rule_num);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK ACL Rule */
-	ret_code = tpm_proc_mc_lpbk_create_acl_rule(rule_num, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Set MULTI_LPBK Rule DB */
-	ret_code = tpm_db_mc_lpbk_entry_set(ip_ver, mvlan, in_vid, out_vid, rule_num, mod_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_reset_translation(uint16_t mvlan)
-{
-	int32_t ret_code;
-	uint32_t xits_num = 0, xit_id, rule_index, rule_num, mod_entry;
-	uint32_t ip_ver;
-	uint8_t lpbk_enable;
-
-	for (ip_ver = TPM_IP_VER_4; ip_ver < TPM_IP_VER_MAX; ip_ver++) {
-		tpm_db_get_mc_lpbk_enable(ip_ver, &lpbk_enable);
-		if (lpbk_enable == TPM_FALSE)
-			continue;
-		ret_code = tpm_db_mc_vlan_xits_num_get(ip_ver, mvlan, &xits_num);
-		if (ret_code == TPM_OK) {
-			for (xit_id = 0; xit_id < xits_num; xit_id++) {
-				ret_code = tpm_db_mc_vlan_xit_entry_get(ip_ver, mvlan, xit_id, &rule_index, &mod_entry);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_db_mc_lpbk_rule_num_get(rule_index, &rule_num);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_proc_mc_lpbk_delete_acl_rule(rule_num);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_db_mc_lpbk_entry_invalidate(rule_num);
-				IF_ERROR(ret_code);
-
-				if (mod_entry != 0) {
-					ret_code = tpm_mod2_entry_del(TPM_MOD_OWNER_TPM, TPM_ENUM_GMAC_1, mod_entry);
-					IF_ERROR(ret_code);
-				}
-			}
-		}
-	}
-	return TPM_OK;
-}
-
-int32_t tpm_proc_mc_refresh_translation(uint16_t mvlan)
-{
-	int32_t ret_code;
-	uint32_t stream_id;
-	tpm_db_mc_stream_entry_t stream_data;
-	tpm_trg_port_type_t dest_port_bm;
-
-	for (stream_id = 0; stream_id < TPM_MC_MAX_STREAM_NUM; stream_id++) {
-		if (tpm_db_get_mc_stream_entry(stream_id, &stream_data) == TPM_OK) {
-			if (stream_data.vid == mvlan) {
-				if (tpm_db_get_mc_per_uni_vlan_xlate() == 0) {
-					ret_code = tpm_proc_del_ipv4_mc_stream(0, stream_id);
-					IF_ERROR(ret_code);
-
-					ret_code = tpm_proc_add_ipv4_mc_stream(0, stream_id, stream_data.igmp_mode,
-									       stream_data.mc_stream_pppoe,
-									       stream_data.vid, stream_data.src_addr,
-									       stream_data.group_addr,
-									       stream_data.src_valid,
-									       stream_data.dest_queue,
-									       stream_data.dest_port_bm);
-					IF_ERROR(ret_code);
-				} else {
-					if (stream_data.u4_entry != 0xffff) {
-						dest_port_bm = (~TPM_TRG_UNI_VIRT) & stream_data.dest_port_bm;
-						ret_code = tpm_proc_updt_ipv4_mc_stream(0, stream_id, dest_port_bm);
-						IF_ERROR(ret_code);
-
-						dest_port_bm |= TPM_TRG_UNI_VIRT;
-						ret_code = tpm_proc_updt_ipv4_mc_stream(0, stream_id, dest_port_bm);
-						IF_ERROR(ret_code);
-					}
-				}
-			}
-		}
-	}
-
-	return TPM_OK;
-}
-
-void tpm_proc_mc_vid_remove_ai_bits(tpm_rule_action_t *rule_action,
-				    tpm_src_port_type_t src_port,
-				    tpm_l2_acl_key_t *l2_key,
-				    tpm_error_code_t ret_code)
-{
-	tpm_dir_t dir = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "\n");
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	if ((TPM_RC_OK == ret_code) || (TPM_DIR_US == dir)) {
-		/* no need to remove mc_vid */
-		return;
-	}
-
-	if (TPM_ACTION_SPEC_MC_VID & rule_action->pkt_act) {
-		ret_code = tpm_db_mc_vlan_reset_mc_vlan(l2_key->vlan1.vid);
-		/* no need to check if this action failed */
-	}
-
-	return;
-}
-
-tpm_error_code_t tpm_proc_add_mc_vid_cfg_vtu(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	tpm_error_code_t ret;
-	uint32_t i;
-	uint32_t uni_xlate_enable;
-	uint32_t switch_init;
-	tpm_init_virt_uni_t    virt_uni_info;
-	tpm_src_port_type_t switch_api_port;
-	tpm_mc_vid_port_cfg_t *vir_uni_cfg = NULL;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-
-	if (tpm_db_switch_init_get(&switch_init))
-		return ERR_GENERAL;
-
-	if (switch_init == 0) {
-		/* do not have switch */
-		TPM_OS_INFO(TPM_PNCL_MOD, "do not have switch, no VTU operation\n");
-		return TPM_RC_OK;
-	}
-
-	uni_xlate_enable = tpm_db_get_mc_per_uni_vlan_xlate();
-	tpm_db_virt_info_get(&virt_uni_info);
-
-
-	for (i = 0; i < TPM_MAX_NUM_UNI_PORTS; i++) {
-		if (TPM_SRC_PORT_UNI_VIRT == mc_vid_uniports_config->mc_vid_port_vids[i].tpm_src_port) {
-			vir_uni_cfg = &(mc_vid_uniports_config->mc_vid_port_vids[i]);
-			continue;
-		}
-		if (TPM_MC_UNI_MODE_EXCLUDE == mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode)
-			continue;
-
-		switch_api_port = mc_vid_uniports_config->mc_vid_port_vids[i].tpm_src_port;
-
-		ret = tpm_sw_port_add_vid(0, switch_api_port, mc_vid);
-		if (TPM_RC_OK != ret) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "add port(%d) into vlan(%d) failed\n", switch_api_port, mc_vid);
-			return ERR_GENERAL;
-		}
-
-		if (uni_xlate_enable) {
-			if (TPM_MC_UNI_MODE_TRANSPARENT == mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode) {
-				/* egress mode set to as-is */
-				ret = tpm_sw_set_port_vid_egress_mode(0, switch_api_port, mc_vid, MEMBER_EGRESS_UNMODIFIED);
-			} else {
-				/* egress mode set to un-tag */
-				ret = tpm_sw_set_port_vid_egress_mode(0, switch_api_port, mc_vid, MEMBER_EGRESS_UNTAGGED);
-			}
-		} else {
-			if (TPM_MC_UNI_MODE_STRIP == mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode) {
-				/* egress mode set to un-tag */
-				ret = tpm_sw_set_port_vid_egress_mode(0, switch_api_port, mc_vid, MEMBER_EGRESS_UNTAGGED);
-			} else {
-				/* egress mode set to as-is */
-				ret = tpm_sw_set_port_vid_egress_mode(0, switch_api_port, mc_vid, MEMBER_EGRESS_UNMODIFIED);
-			}
-		}
-
-		if (TPM_RC_OK != ret) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "set port(%d) egress mode failed\n",
-				     switch_api_port);
-			return ERR_GENERAL;
-		}
-
-	}
-
-	if (TPM_VIRT_UNI_DISABLED == virt_uni_info.enabled) {
-		TPM_OS_INFO(TPM_PNCL_MOD, "virtual uni is disabled, do not need to set VTU of uni_4!\n");
-		return TPM_RC_OK;
-	}
-
-	if (uni_xlate_enable) {
-		ret = tpm_sw_port_add_vid(0, TPM_SRC_PORT_UNI_VIRT, mc_vid);
-		if (TPM_RC_OK != ret) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "add port(%d) into vlan failed\n", TPM_SRC_PORT_UNI_VIRT);
-			return ERR_GENERAL;
-		}
-	} else if (NULL != vir_uni_cfg) {
-		if (TPM_MC_UNI_MODE_EXCLUDE == vir_uni_cfg->mc_uni_port_mode) {
-			/* do not add port into VTU */
-		} else {
-			ret = tpm_sw_port_add_vid(0, TPM_SRC_PORT_UNI_VIRT, mc_vid);
-			if (TPM_RC_OK != ret) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "add port(%d) into vlan failed\n", TPM_SRC_PORT_UNI_VIRT);
-				return ERR_GENERAL;
-			}
-
-			if (TPM_MC_UNI_MODE_STRIP == vir_uni_cfg->mc_uni_port_mode) {
-				/* egress mode set to un-tag */
-				ret = tpm_sw_set_port_vid_egress_mode(0, TPM_SRC_PORT_UNI_VIRT, mc_vid, MEMBER_EGRESS_UNTAGGED);
-			} else if (TPM_MC_UNI_MODE_TRANSPARENT == vir_uni_cfg->mc_uni_port_mode) {
-				/* egress mode set to as-is */
-				ret = tpm_sw_set_port_vid_egress_mode(0, TPM_SRC_PORT_UNI_VIRT, mc_vid, MEMBER_EGRESS_UNMODIFIED);
-			}
-		}
-	}
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_del_mc_vid_cfg_vtu(uint32_t mc_vid)
-{
-	tpm_error_code_t ret;
-	tpm_db_error_t db_ret;
-	uint32_t vtu_vid;
-	uint32_t i;
-	uint32_t uni_xlate_enable;
-	tpm_mc_vid_port_cfg_t *mc_vid_uniports_config = NULL;
-	uint32_t switch_init;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-
-	if (tpm_db_switch_init_get(&switch_init))
-		return ERR_GENERAL;
-
-	if (switch_init == 0) {
-		/* do not have switch */
-		TPM_OS_INFO(TPM_PNCL_MOD, "do not have switch, no VTU operation\n");
-		return TPM_RC_OK;
-	}
-
-	uni_xlate_enable = tpm_db_get_mc_per_uni_vlan_xlate();
-
-	db_ret = tpm_db_get_mc_vid_cfg(mc_vid, &mc_vid_uniports_config);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "get db of vlan(%d) failed\n", mc_vid);
-		return ERR_GENERAL;
-	}
-
-	for (i = 0; i < TPM_MAX_NUM_UNI_PORTS; i++) {
-		if (TPM_SRC_PORT_UNI_VIRT == mc_vid_uniports_config[i].tpm_src_port)
-			continue;
-
-		if (TPM_MC_UNI_MODE_EXCLUDE == mc_vid_uniports_config[i].mc_uni_port_mode)
-			continue;
-
-		if (uni_xlate_enable)
-			vtu_vid = mc_vid;
-		else
-			vtu_vid	= mc_vid_uniports_config[i].uni_port_vid;
-
-		ret = tpm_sw_port_del_vid(0, mc_vid_uniports_config[i].tpm_src_port, vtu_vid);
-		if (TPM_RC_OK != ret) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "del port(%d) into vlan(%d) failed\n",
-				     mc_vid_uniports_config[i].tpm_src_port, vtu_vid);
-			return ERR_GENERAL;
-		}
-	}
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_add_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	uint32_t ret;
-	uint32_t i, in_loop;
-	uint32_t out_vid = 0;
-	uint32_t vtu_vid = mc_vid;
-	uint32_t tranparent_port_num = 0;
-	uint32_t ip_ver;
-	uint8_t lpbk_enable = TPM_FALSE;
-	tpm_mc_vid_t mc_vid_cfg_tmp;
-	tpm_mc_vid_port_cfg_t *vir_uni_cfg = NULL;
-	tpm_init_virt_uni_t virt_uni_info;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-
-	memset(&mc_vid_cfg_tmp, 0, sizeof(mc_vid_cfg_tmp));
-
-	for (i = 0; i < TPM_MAX_NUM_UNI_PORTS; i++) {
-		if (TPM_SRC_PORT_UNI_VIRT == mc_vid_uniports_config->mc_vid_port_vids[i].tpm_src_port) {
-			vir_uni_cfg = &mc_vid_uniports_config->mc_vid_port_vids[i];
-			continue;
-		}
-
-		if (TPM_MC_UNI_MODE_TRANSPARENT == mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode)
-			tranparent_port_num++;
-
-		/* do not care TRANSPARENT and TRIP */
-		if (TPM_MC_UNI_MODE_TRANSLATE != mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode)
-			continue;
-
-		/* here got a translate */
-		for (in_loop = 0; in_loop < mc_vid_cfg_tmp.vid_num; in_loop++) {
-			if (mc_vid_uniports_config->mc_vid_port_vids[i].uni_port_vid ==
-			    mc_vid_cfg_tmp.mc_vid_port[in_loop].mc_vid) {
-				mc_vid_cfg_tmp.mc_vid_port[in_loop].port_bm |=
-				(TPM_TRG_UNI_0 << (mc_vid_uniports_config->mc_vid_port_vids[i].tpm_src_port - TPM_SRC_PORT_UNI_0));
-				break;
-			}
-		}
-
-		if (mc_vid_cfg_tmp.vid_num == in_loop) {
-			mc_vid_cfg_tmp.mc_vid_port[in_loop].port_bm =
-				(TPM_TRG_UNI_0 << (mc_vid_uniports_config->mc_vid_port_vids[i].tpm_src_port - TPM_SRC_PORT_UNI_0));
-			mc_vid_cfg_tmp.mc_vid_port[in_loop].mc_vid =
-				mc_vid_uniports_config->mc_vid_port_vids[i].uni_port_vid;
-			mc_vid_cfg_tmp.vid_num++;
-		}
-	}
-
-	/* validation */
-	if (!tpm_db_get_mc_per_uni_vlan_xlate()) {
-		/* all the ports should have the same xlate, or strip */
-		if (mc_vid_cfg_tmp.vid_num > 1) {
-			TPM_OS_ERROR(TPM_PNCL_MOD,
-				     "with mc_per_uni_vlan_xlate disabled, all the ports should have the same xlate\n");
-			return ERR_GENERAL;
-		}
-
-		/* there should be no transparent and xlate port at the same time */
-		if ((0 != tranparent_port_num) && (0 != mc_vid_cfg_tmp.vid_num)) {
-			TPM_OS_ERROR(TPM_PNCL_MOD,
-				     "with mc_per_uni_vlan_xlate disabled, "\
-				     "there should be no transparent and xlate port at the same time\n");
-			return ERR_GENERAL;
-		}
-
-		if (mc_vid_cfg_tmp.vid_num > 0)
-			vtu_vid = mc_vid_cfg_tmp.mc_vid_port[0].mc_vid;
-
-	}
-
-	ret = tpm_proc_add_mc_vid_cfg_vtu(vtu_vid, mc_vid_uniports_config);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "set VTU failed, ret: %d\n", ret);
-		return ret;
-	}
-
-	/* add to db */
-	ret = tpm_db_set_mc_vid_cfg(mc_vid, mc_vid_uniports_config);
-	if (TPM_DB_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "add mc vid xlate to DB failed, ret: %d\n", ret);
-		return ret;
-	}
-
-	if (!tpm_db_get_mc_per_uni_vlan_xlate()) {
-		/* mc_per_uni_vlan_xlate is disabled, do not add xlate PNC rules */
-		return TPM_RC_OK;
-	}
-
-	/* deal with IPV4 to V6 */
-	for (ip_ver = TPM_IP_VER_4; ip_ver < TPM_IP_VER_MAX; ip_ver++) {
-		tpm_db_get_mc_lpbk_enable(ip_ver, &lpbk_enable);
-		if (lpbk_enable == TPM_FALSE)
-			continue;
-		/* first deal with U0 to U3 */
-		for (i = 0; i < mc_vid_cfg_tmp.vid_num; i++) {
-			if (0 == i) {
-				/* first xlate */
-				ret =
-				tpm_proc_mc_set_translation_uni_x_first(ip_ver, mc_vid, mc_vid_cfg_tmp.mc_vid_port[i].mc_vid,
-									mc_vid_cfg_tmp.mc_vid_port[i].port_bm);
-				if (TPM_RC_OK != ret) {
-					TPM_OS_ERROR(TPM_PNCL_MOD, "add mc vid xlate failed, ret: %d\n", ret);
-					return ret;
-				}
-			} else {
-				ret = tpm_proc_mc_set_translation_uni_x_next(ip_ver, mc_vid, mc_vid_cfg_tmp.mc_vid_port[i - 1].mc_vid,
-									     mc_vid_cfg_tmp.mc_vid_port[i].mc_vid,
-									     mc_vid_cfg_tmp.mc_vid_port[i].port_bm);
-
-				if (TPM_RC_OK != ret) {
-					TPM_OS_ERROR(TPM_PNCL_MOD, "add mc vid xlate failed, ret: %d\n", ret);
-					return ret;
-				}
-			}
-		}
-	}
-
-	/* deal with U4 */
-	tpm_db_virt_info_get(&virt_uni_info);
-	if (   (TPM_VIRT_UNI_DISABLED == virt_uni_info.enabled)
-		|| (NULL == vir_uni_cfg)){
-		/* VIRT_UNI_DISABLED, or nothing to do */
-		return TPM_RC_OK;
-	}
-	if (TPM_MC_UNI_MODE_EXCLUDE == vir_uni_cfg->mc_uni_port_mode) {
-		/* not member, nothing to do */
-		return TPM_RC_OK;
-	} else if (TPM_MC_UNI_MODE_TRANSPARENT == vir_uni_cfg->mc_uni_port_mode)
-		out_vid = mc_vid;
-	else if (TPM_MC_UNI_MODE_STRIP == vir_uni_cfg->mc_uni_port_mode)
-		out_vid = 0xffff;
-	else if (TPM_MC_UNI_MODE_TRANSLATE == vir_uni_cfg->mc_uni_port_mode)
-		out_vid = vir_uni_cfg->uni_port_vid;
-
-	for (ip_ver = TPM_IP_VER_4; ip_ver < TPM_IP_VER_MAX; ip_ver++) {
-		tpm_db_get_mc_lpbk_enable(ip_ver, &lpbk_enable);
-		if (lpbk_enable == TPM_FALSE)
-			continue;
-		if (0 == mc_vid_cfg_tmp.vid_num) {
-			/* U4 is the first xlate */
-			ret = tpm_proc_mc_set_translation_max_uni_first(ip_ver, mc_vid, out_vid);
-			if (TPM_RC_OK != ret) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "add U4 mc vid xlate failed, ret: %d\n", ret);
-				return ret;
-			}
-		} else {
-			ret = tpm_proc_mc_set_translation_max_uni_next(ip_ver, mc_vid, mc_vid_cfg_tmp.mc_vid_port[i - 1].mc_vid, out_vid);
-			if (TPM_RC_OK != ret) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "add U4 mc vid xlate failed, ret: %d\n", ret);
-				return ret;
-			}
-		}
-	}
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_remove_mc_vid_cfg(uint32_t mc_vid)
-{
-	tpm_error_code_t ret;
-	tpm_db_error_t db_ret;
-
-	ret = tpm_proc_mc_reset_translation(mc_vid);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "remove VID failed, ret: %d\n", ret);
-		return ret;
-	}
-
-	ret = tpm_proc_del_mc_vid_cfg_vtu(mc_vid);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "remove VID MTU, ret: %d\n", ret);
-		return ret;
-	}
-
-	db_ret = tpm_db_remove_mc_vid_cfg(mc_vid);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "del mc vid xlate from DB failed, ret: %d\n", db_ret);
-		return ERR_GENERAL;
-	}
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_update_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	tpm_error_code_t ret;
-
-	ret = tpm_proc_remove_mc_vid_cfg(mc_vid);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "remove VID failed, ret: %d\n", ret);
-		return ret;
-	}
-
-	ret = tpm_proc_add_mc_vid_cfg(mc_vid, mc_vid_uniports_config);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "add VID failed, ret: %d\n", ret);
-		return ret;
-	}
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_set_mc_vid_port_vids(uint32_t owner_id,
-					       uint32_t mc_vid,
-					       tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config)
-{
-	uint32_t ret;
-	int32_t db_ret;
-	uint32_t i;
-	bool already_exist;
-	tpm_src_port_type_t src_port;
-	tpm_init_virt_uni_t virt_uni_info;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "mc_vlan(%d)\n", mc_vid);
-
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_UNI_7; src_port++) {
-
-		if (TPM_MC_UNI_MODE_EXCLUDE == mc_vid_uniports_config->mc_vid_port_vids[src_port].mc_uni_port_mode)
-			continue;
-
-		/* if port is valid */
-		if(!tpm_db_eth_port_valid(src_port)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "uni_port(%x) is not valid, should be EXCLUDE mode\n", src_port);
-			return ERR_MC_DST_PORT_INVALID;
-		}
-	}
-
-	/* check vir uni */
-	db_ret = tpm_db_virt_info_get(&virt_uni_info);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "get virt uni cfg failed, ret: %d\n", db_ret);
-		return ERR_GENERAL;
-	}
-	if (    (TPM_VIRT_UNI_DISABLED == virt_uni_info.enabled)
-	     && (TPM_MC_UNI_MODE_EXCLUDE != mc_vid_uniports_config->mc_vid_port_vids[TPM_SRC_PORT_UNI_VIRT].mc_uni_port_mode)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "TPM_TRG_UNI_VIRT is not enabled, should be EXCLUDE mode\n");
-		return ERR_MC_DST_PORT_INVALID;
-	}
-
-	/* if all the ports are TPM_MC_UNI_MODE_EXCLUDE, remove this VID
-	   if this VID already exists, update it.
-	   else add this VID
-	 */
-	already_exist = tpm_db_mc_vid_exist(mc_vid);
-
-	for (i = 0; i < TPM_MAX_NUM_UNI_PORTS; i++) {
-		if (TPM_MC_UNI_MODE_EXCLUDE == mc_vid_uniports_config->mc_vid_port_vids[i].mc_uni_port_mode)
-			continue;
-
-		if (true == already_exist) {
-			/* VID already exists, update it */
-			ret = tpm_proc_update_mc_vid_cfg(mc_vid, mc_vid_uniports_config);
-			if (TPM_RC_OK != ret) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "update VID failed, ret: %d\n", ret);
-				return ERR_GENERAL;
-			}
-		} else {
-			/* VID not exists, add it */
-			ret = tpm_proc_add_mc_vid_cfg(mc_vid, mc_vid_uniports_config);
-			if (TPM_RC_OK != ret) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "add VID failed, ret: %d\n", ret);
-				return ERR_GENERAL;
-			}
-		}
-
-		return TPM_RC_OK;
-	}
-
-	/* all the ports are TPM_MC_UNI_MODE_EXCLUDE, remove this VID */
-	if (false == already_exist) {
-		/* VID not exists, error */
-		TPM_OS_ERROR(TPM_PNCL_MOD, "all the ports are TPM_MC_UNI_MODE_EXCLUDE, VID not exists, error\n");
-		return ERR_GENERAL;
-	}
-
-	ret = tpm_proc_remove_mc_vid_cfg(mc_vid);
-	if (TPM_RC_OK != ret) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "VID not exists, error\n");
-		return ERR_GENERAL;
-	}
-
-	return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_multicast_reset()
-*
-* DESCRIPTION:    Main function for reset multicast configurations and shadows.
-*
-* INPUTS:
-*
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_multicast_reset(void)
-{
-    /* reset multicast configuration database:
-	   1. MC VID AI-bits allocation
-	   2. MC VID per-port config
-	   3. IGMP proxy sa addr */
-	tpm_db_mc_cfg_reset();
-
-    /* reset multicast rules database:
-	   1. MC stream table
-	   2. MC mac table
-	   3. MC lpbk table
-	   4. virt_uni entry table */
-	tpm_db_mc_rule_reset();
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_del_l2_prim_acl_rule()
-*
-* DESCRIPTION:    Main function for deleting L2 API rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_l2_prim_acl_rule(uint32_t owner_id, uint32_t rule_idx, uint32_t ext_call)
-{
-
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_L2_PRIM_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	/* release mc AI bits */
-	tpm_db_mc_vlan_reset_ai_bit(rule_idx);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_get_next_valid_rule()
-*
-* DESCRIPTION:    Main function for getting next rule.
-*
-* INPUTS:
-*           All inputs/outputs are same as API call
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_get_next_valid_rule(uint32_t owner_id,
-					      int32_t current_index,
-					      tpm_api_type_t rule_type,
-					      int32_t *next_index,
-					      uint32_t *rule_idx,
-					      tpm_rule_entry_t *tpm_rule)
-{
-	int32_t int_ret_code;
-	uint32_t bi_dir = 0;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_api_sections_t api_section;
-
-	if (!next_index || !tpm_rule)
-		return ERR_NULL_POINTER;
-
-	tpm_db_api_section_get_from_api_type(rule_type, &api_section);
-
-	int_ret_code = tpm_db_api_entry_val_get_next(api_section, current_index,
-						     next_index, rule_idx, &bi_dir, tpm_rule, &mod_con, &pnc_con);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_omci_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OMCI management protocol.
-*                   The API sets the gemportid, the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* gem_port           - for OMCI Rx frames - the gem port wherefrom the OMCI frames are received.
-* cpu_rx_queue       - for OMCI Rx frames - the CPU rx queue number.
-* tcont_num          - for OMCI Tx frames - the TCONT number where to send the OMCI frames.
-* cpu_tx_queue       - for OMCI Tx frames - the CPU tx queue number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_omci_add_channel(uint32_t owner_id,
-					   tpm_gem_port_key_t gem_port,
-					   uint32_t cpu_rx_queue,
-					   tpm_trg_port_type_t tcont_num,
-					   uint32_t cpu_tx_queue)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t pnc_entry;
-	tpm_db_pnc_range_t range_data;
-	int32_t int_ret_code;
-	tpm_error_code_t ret_code;
-	uint32_t valid, rxq, txq, txp;
-	uint16_t gem;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "owner(%d),gemport(%d),rx_q(%d),tcont(%d),tx_q(%d)\n",
-		     owner_id, gem_port, cpu_rx_queue, tcont_num, cpu_tx_queue);
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	tpm_db_omci_channel_get(&valid, &gem, &rxq, &txq, &txp);
-	if (valid)
-		IF_ERROR(ERR_MNGT_CREATE_DUPLICATE_CHANNEL);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	/* build TCAM */
-	pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_GEMPORT;
-	pnc_data.pncl_tcam.l3_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-	pnc_data.pncl_tcam.add_info_mask = 0;
-	pnc_data.pncl_tcam.add_info_data = 0;
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	pnc_data.pncl_tcam.pkt_key.l2_key.gem_port = gem_port;
-	pnc_data.pncl_tcam.lu_id = 0;
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	/* Build SRAM */
-	pnc_data.pncl_sram.next_lu_id = 0;
-	pnc_data.pncl_sram.next_lu_off_reg = 0;
-	pnc_data.pncl_sram.next_offset.offset_base = 0;
-	pnc_data.pncl_sram.next_offset.offset_sub.l2_subf = 0;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP | TPM_PNCL_SET_RX_SPECIAL;
-	pnc_data.pncl_sram.mh_reg.mh_set = TPM_FALSE;
-	pnc_data.pncl_sram.mh_reg.mh_reg = 0;
-	pnc_data.pncl_sram.add_info_data = 0;
-	pnc_data.pncl_sram.add_info_mask = 0;
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_OTHER;
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-	pnc_data.pncl_sram.flow_id_sub.mod_cmd = 0;
-	pnc_data.pncl_sram.flow_id_sub.gem_port = 0;
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_MNGMT_DS, &range_data);
-	IF_ERROR(int_ret_code);
-	pnc_entry = range_data.pnc_range_conf.range_start;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-	/* Decrease number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_MNGMT_DS);
-	IF_ERROR(int_ret_code);
-	int_ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	{
-		char cmd[64];
-		uint32_t tcontid = 0;
-
-		if (tcont_num == TPM_TRG_TCONT_0)
-			tcontid = 0;
-		else if (tcont_num == TPM_TRG_TCONT_1)
-			tcontid = 1;
-		else if (tcont_num == TPM_TRG_TCONT_2)
-			tcontid = 2;
-		else if (tcont_num == TPM_TRG_TCONT_3)
-			tcontid = 3;
-		else if (tcont_num == TPM_TRG_TCONT_4)
-			tcontid = 4;
-		else if (tcont_num == TPM_TRG_TCONT_5)
-			tcontid = 5;
-		else if (tcont_num == TPM_TRG_TCONT_6)
-			tcontid = 6;
-		else if (tcont_num == TPM_TRG_TCONT_7)
-			tcontid = 7;
-
-		/*sprintf(cmd, "echo %d  > /sys/devices/platform/neta/pon/omci_gp", gem_port); */
-		pnc_mh_omci(gem_port, 0x0FFF, cpu_rx_queue);
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " %s\n", cmd);
-	}
-
-	/* update database */
-	tpm_db_omci_channel_set(gem_port, cpu_rx_queue, cpu_tx_queue, tcont_num);
-
-	return(TPM_RC_OK);
-
-}
-
-/*******************************************************************************
-* tpm_proc_omci_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OMCI management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_omci_del_channel(uint32_t owner_id)
-{
-	int32_t ret_code;
-	tpm_db_pnc_conn_t pnc_con;
-	uint32_t oam_configured, cpu_rx_queue, cpu_tx_queue, llid_num;
-	tpm_db_pnc_range_t range_data;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d)\n", owner_id);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	tpm_db_oam_channel_get(&oam_configured, &cpu_rx_queue, &cpu_tx_queue, &llid_num);
-	if (!oam_configured)
-		IF_ERROR(ERR_MNGT_DEL_CHANNEL_INVALID);
-
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MNGMT_DS, &range_data);
-	IF_ERROR(ret_code);
-
-	pnc_con.num_pnc_ranges = 1;
-	pnc_con.pnc_conn_tbl[0].pnc_range = TPM_PNC_MNGMT_DS;
-	pnc_con.pnc_conn_tbl[0].pnc_index = range_data.pnc_range_conf.range_start;
-
-	/* Delete PNC Entry */
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_db_omci_channel_remove();
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_oam_epon_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the OAM EPON management protocol.
-*                   The API sets the Rx input queue in the CPU, and the
-*                   Tx T-CONT and queue parameters, which are configured in the driver.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* cpu_rx_queue       - for OAM (EPON) Rx frames - the CPU rx queue number.
-* llid_num           - for OAM (EPON)Tx frames - the LLID number where to send the OMCI frames.
-* cpu_tx_queue       - for OAM (EPON) Tx frames - the CPU tx queue number.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_oam_epon_add_channel(uint32_t owner_id, uint32_t cpu_rx_queue, tpm_trg_port_type_t llid_num)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t pnc_entry;
-	tpm_db_pnc_range_t range_data;
-	int32_t int_ret_code;
-	tpm_error_code_t ret_code;
-	uint32_t valid, rxq, txq, txp;
-	uint16_t gem;
-	uint32_t q_size;
-	uint32_t dummy_cpu_tx_queue = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "owner(%d), rx_q(%d),llid(%d),tx_q(%d)\n",
-		     owner_id, cpu_rx_queue, llid_num, dummy_cpu_tx_queue);
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	tpm_db_omci_channel_get(&valid, &gem, &rxq, &txq, &txp);
-	if (valid)
-		IF_ERROR(ERR_MNGT_CREATE_DUPLICATE_CHANNEL);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	/* validate cpu_rx_queue - should be an existing queue of PON MAC - defined previously */
-	tpm_db_gmac_rx_q_conf_get(TPM_ENUM_PMAC, cpu_rx_queue, &valid, &q_size);
-	if (!valid)
-		TPM_OS_WARN(TPM_INIT_MOD, "OAM CPU RX queue is not valid: queue(%d) \n", cpu_rx_queue);
-
-	/* build TCAM */
-	pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_ETYPE;
-	pnc_data.pncl_tcam.l3_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-	pnc_data.pncl_tcam.add_info_mask = 0;
-	pnc_data.pncl_tcam.add_info_data = 0;
-
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	pnc_data.pncl_tcam.pkt_key.l2_key.ether_type = 0x8809;
-	pnc_data.pncl_tcam.lu_id = 0;
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	/* Build SRAM */
-	pnc_data.pncl_sram.next_lu_id = 0;
-	pnc_data.pncl_sram.next_lu_off_reg = 0;
-	pnc_data.pncl_sram.next_offset.offset_base = 0;
-	pnc_data.pncl_sram.next_offset.offset_sub.l2_subf = 0;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP | TPM_PNCL_SET_RX_SPECIAL;
-	pnc_data.pncl_sram.mh_reg.mh_set = TPM_FALSE;
-	pnc_data.pncl_sram.mh_reg.mh_reg = 0;
-	pnc_data.pncl_sram.add_info_data = 0;
-	pnc_data.pncl_sram.add_info_mask = 0;
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_OTHER;
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-	pnc_data.pncl_sram.flow_id_sub.mod_cmd = 0;
-	pnc_data.pncl_sram.flow_id_sub.gem_port = 0;
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_MNGMT_DS, &range_data);
-	IF_ERROR(int_ret_code);
-	pnc_entry = range_data.pnc_range_conf.range_start;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-
-	/* Decrease number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_MNGMT_DS);
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	{
-		uint32_t llid = 0;
-
-		if (llid_num == TPM_TRG_LLID_0)
-			llid = 0;
-		else if (llid_num == TPM_TRG_LLID_1)
-			llid = 1;
-		else if (llid_num == TPM_TRG_LLID_2)
-			llid = 2;
-		else if (llid_num == TPM_TRG_LLID_3)
-			llid = 3;
-		else if (llid_num == TPM_TRG_LLID_4)
-			llid = 4;
-		else if (llid_num == TPM_TRG_LLID_5)
-			llid = 5;
-		else if (llid_num == TPM_TRG_LLID_6)
-			llid = 6;
-		else if (llid_num == TPM_TRG_LLID_7)
-			llid = 7;
-
-		pnc_eoam(cpu_rx_queue);
-	}
-
-	/* update database */
-	tpm_db_oam_channel_set(cpu_rx_queue, dummy_cpu_tx_queue, llid_num);
-
-	return(TPM_RC_OK);
-}
-/*******************************************************************************
-* tpm_proc_loop_detect_del_channel()
-*
-* DESCRIPTION:      remove the communication channel for the loop detection management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_loop_detect_del_channel(uint32_t owner_id)
-{
-	uint32_t pnc_entry;
-	tpm_db_pnc_range_t range_data;
-	tpm_error_code_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "owner(%d)\n", owner_id);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	memset(&range_data, 0, sizeof(range_data));
-	/* Get PNC Range data */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_LOOP_DET_US, &range_data);
-	IF_ERROR(ret_code);
-
-	if (!range_data.valid) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "range TPM_PNC_LOOP_DET_US is not valid\n");
-		return ERR_GENERAL;
-	}
-
-	if (range_data.pnc_range_conf.range_size == range_data.pnc_range_oper.free_entries) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "there is no loopback detect channel yet\n");
-		return ERR_GENERAL;
-	}
-
-	pnc_entry = range_data.pnc_range_conf.range_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "remove pnc_entry(%d)\n", pnc_entry);
-
-	ret_code = tpm_pnc_entry_inv(pnc_entry);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_LOOP_DET_US);
-	IF_ERROR(ret_code);
-
-	/* remove tag PNC rule */
-	pnc_entry++;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "remove pnc_entry(%d)\n", pnc_entry);
-
-	ret_code = tpm_pnc_entry_inv(pnc_entry);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_LOOP_DET_US);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-/*******************************************************************************
-* tpm_proc_loop_detect_add_channel()
-*
-* DESCRIPTION:      Establishes a communication channel for the loop detection management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* ety                    - EtherType of the loop detection Pkt.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_loop_detect_add_channel(uint32_t owner_id, tpm_ether_type_key_t ety)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t pnc_entry;
-	tpm_db_pnc_range_t range_data;
-	int32_t int_ret_code;
-	tpm_error_code_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "owner(%d)\n", owner_id);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/* build TCAM */
-	pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_ETYPE;
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_TAG1_MASK;
-	pnc_data.pncl_tcam.add_info_data = 0;
-
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	pnc_data.pncl_tcam.pkt_key.l2_key.ether_type = ety;
-	pnc_data.pncl_tcam.lu_id = 0;
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	/* Build SRAM */
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.pnc_queue = 0;	/*send to queue 0 by default */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP | TPM_PNCL_SET_RX_SPECIAL;
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_OTHER;
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-	/* Get PNC Range data */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_LOOP_DET_US, &range_data);
-	IF_ERROR(int_ret_code);
-
-	if ((!range_data.valid) || (range_data.pnc_range_conf.range_size < 2)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "range TPM_PNC_LOOP_DET_US is not big enough!\n");
-		return ERR_OUT_OF_RESOURCES;
-	}
-
-	if (range_data.pnc_range_conf.range_size != range_data.pnc_range_oper.free_entries) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "loopback detect channel has already been added\n");
-		return ERR_GENERAL;
-	}
-
-	pnc_entry = range_data.pnc_range_conf.range_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-
-	int_ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_LOOP_DET_US);
-	IF_ERROR(int_ret_code);
-
-	/* add tag PNC rule */
-	pnc_data.pncl_tcam.l2_parse_bm = TPM_L2_PARSE_ONE_VLAN_TAG | TPM_L2_PARSE_ETYPE;
-	pnc_data.pncl_tcam.add_info_data = TPM_AI_TAG1_MASK;
-
-	pnc_entry++;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-
-	int_ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_LOOP_DET_US);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_oam_epon_del_channel()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OAM EPON management protocol.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_oam_epon_del_channel(uint32_t owner_id)
-{
-	int32_t ret_code;
-	tpm_db_pnc_conn_t pnc_con;
-	uint32_t oam_configured, cpu_rx_queue, cpu_tx_queue, llid_num;
-	tpm_db_pnc_range_t range_data;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d)\n", owner_id);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	tpm_db_oam_channel_get(&oam_configured, &cpu_rx_queue, &cpu_tx_queue, &llid_num);
-	if (!oam_configured)
-		IF_ERROR(ERR_MNGT_DEL_CHANNEL_INVALID);
-
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MNGMT_DS, &range_data);
-	IF_ERROR(ret_code);
-
-	pnc_con.num_pnc_ranges = 1;
-	pnc_con.pnc_conn_tbl[0].pnc_range = TPM_PNC_MNGMT_DS;
-	pnc_con.pnc_conn_tbl[0].pnc_index = range_data.pnc_range_conf.range_start;
-
-	/* Delete PNC Entry */
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_db_oam_channel_remove();
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_oam_loopback_add_channel ()
-*
-* DESCRIPTION:      Establishes a communication channel for the OAM loopback.
-*
-*
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_oam_loopback_add_channel(uint32_t owner_id)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t pnc_entry, pnc_stop_entry, api_rng_entries;
-	tpm_db_pnc_range_t range_data;
-	int32_t int_ret_code;
-	tpm_error_code_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "owner(%d)\n", owner_id);
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-
-	/* build TCAM */
-	pnc_data.pncl_tcam.l2_parse_bm = 0;
-	pnc_data.pncl_tcam.l3_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv6_parse_bm = 0;
-	pnc_data.pncl_tcam.ipv4_parse_bm = 0;
-	pnc_data.pncl_tcam.add_info_mask = 0;
-	pnc_data.pncl_tcam.add_info_data = 0;
-
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid = 0;
-	pnc_data.pncl_tcam.pkt_key.l2_key.vlan1.tpid_mask = 0;
-	pnc_data.pncl_tcam.pkt_key.l2_key.ether_type = 0;
-	pnc_data.pncl_tcam.lu_id = 0;
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	/* Build SRAM */
-	pnc_data.pncl_sram.next_lu_id = 0;
-	pnc_data.pncl_sram.next_lu_off_reg = 0;
-	pnc_data.pncl_sram.next_offset.offset_base = 0;
-	pnc_data.pncl_sram.next_offset.offset_sub.l2_subf = 0;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.pnc_queue = 1;	/*send to queue 1 by default */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD | TPM_PNCL_SET_TXP;
-	pnc_data.pncl_sram.mh_reg.mh_set = TPM_FALSE;
-	pnc_data.pncl_sram.mh_reg.mh_reg = 0;
-	pnc_data.pncl_sram.add_info_data = 0;
-	pnc_data.pncl_sram.add_info_mask = 0;
-	pnc_data.pncl_sram.l3_type = TPM_PNCL_L3_OTHER;
-	pnc_data.pncl_sram.l4_type = TPM_PNCL_L4_OTHER;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_PMAC0;
-	pnc_data.pncl_sram.flow_id_sub.mod_cmd = 0;
-	pnc_data.pncl_sram.flow_id_sub.gem_port = 0;
-
-	/* Get PNC Range Start */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_L2_MAIN, &range_data);
-	IF_ERROR(int_ret_code);
-	/*rule 1 is special for OAM loopback. */
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pnc_entry(%d)\n", pnc_entry);
-
-	int_ret_code = tpm_db_api_section_num_entries_get(TPM_L2_PRIM_ACL, &api_rng_entries);
-	IF_ERROR(int_ret_code);
-
-	if (api_rng_entries > 0) {
-		pnc_stop_entry = pnc_entry + api_rng_entries - 1;
-		int_ret_code = tpm_pncl_entry_insert(pnc_entry, pnc_stop_entry, &pnc_data);
-		IF_ERROR(int_ret_code);
-	} else {
-		int_ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-		IF_ERROR(int_ret_code);
-	}
-
-	int_ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_L2_MAIN);
-	IF_ERROR(int_ret_code);
-
-	/*update datebase */
-	tpm_db_oam_loopback_channel_set();
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_oam_loopback_del_channel ()
-*
-* DESCRIPTION:      Deletes an existing communication channel for the OAM loopback.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_oam_loopback_del_channel(uint32_t owner_id)
-{
-
-	int32_t ret_code;
-	tpm_db_pnc_conn_t pnc_con;
-	uint32_t oam_loopback_configured;
-	tpm_db_pnc_range_t range_data;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d)\n", owner_id);
-
-	ret_code = tpm_owner_id_check(TPM_API_MGMT, owner_id);
-	IF_ERROR(ret_code);
-
-	tpm_db_oam_loopback_state_get(&oam_loopback_configured);
-	if (!oam_loopback_configured)
-		IF_ERROR(ERR_MNGT_DEL_CHANNEL_INVALID);
-
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_L2_MAIN, &range_data);
-	IF_ERROR(ret_code);
-
-	pnc_con.num_pnc_ranges = 1;
-	pnc_con.pnc_conn_tbl[0].pnc_range = TPM_PNC_L2_MAIN;
-	pnc_con.pnc_conn_tbl[0].pnc_index = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_db_oam_loopback_channel_remove();
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_l3_check()
-*
-* DESCRIPTION:      The function checks consistency of the tpm_proc_add_l3_type_acl_rule params..
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-* l3_key             - Structure for PPPoE proto or ether type. In order to define a rule for
-*                      any ether type, the ether type value should be set to 0xFFFF
-* action_drop        - If this stage is dropping the packet.
-* next_phase         - Set the next parsing stage for the packet.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_l3_check(uint32_t owner_id,
-				       tpm_src_port_type_t src_port,
-				       uint32_t rule_num,
-				       tpm_parse_fields_t parse_rule_bm,
-				       tpm_parse_flags_t parse_flags_bm,
-				       tpm_l3_type_key_t *l3_key,
-				       tpm_pkt_frwd_t *pkt_frwd,
-				       tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_dir_t dir;
-	tpm_db_pon_type_t pon_type;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm = 0;
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Check Source Port */
-	ret_code = tpm_proc_src_port_check(src_port);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_SRC_PORT_INVALID);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_L3_TYPE_ACL_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_L3_TYPE_ACL_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check necessary pointers are valid */
-	ret_code =
-	tpm_proc_check_missing_data(rule_action, NULL /*pkt_mod */ , pkt_frwd, (void *)l3_key, rule_action->pkt_act,
-				    parse_rule_bm);
-	IF_ERROR(ret_code);
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_L3_TYPE, owner_id);
-	IF_ERROR(ret_code);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_L3_TYPE_ACL, TPM_RANGE_TYPE_ACL, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_IPv4 && rule_action->next_phase != STAGE_IPv6_NH &&
-	    rule_action->next_phase != STAGE_IPv6_GEN && rule_action->next_phase != STAGE_DONE &&
-	    rule_action->next_phase != STAGE_CTC_CM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, &pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_L3_TYPE_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	if (rule_action->next_phase == STAGE_CTC_CM) {
-		if (!tpm_ctc_cm_l3_rule2cm_sram(parse_flags_bm, rule_action)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, parse_flag must be MTM_FALSE or CTC CM is disabled\n");
-			return(ERR_NEXT_PHASE_INVALID);
-		}
-		if (FROM_WAN(src_port)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, Src Port can not be WAN\n");
-			return(ERR_SRC_PORT_INVALID);
-		}
-		if ((parse_rule_bm & TPM_L2_PARSE_ETYPE) &&
-			(l3_key->ether_type_key == 0x0800)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, ETY can not be IPv4\n");
-			return(ERR_ACTION_INVALID);
-		}
-		if ((parse_rule_bm & TPM_L2_PARSE_PPP_PROT) &&
-			(l3_key->pppoe_key.ppp_proto == 0x0021)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CTC_CM, ETY can not be IPv4 (over PPPoE)\n");
-			return(ERR_ACTION_INVALID);
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_l3_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* l3_key            - layer2 key data
-* parse_rule_bm     - Parse rules bitmap
-* parse_flags_bm    - Parse flags in prim ACL rule
-* rule_action       - rule action of this rule
-* OUTPUTS:
-* l3_tcam_data      - Logical TCAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_l3_tcam_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_l3_type_key_t *l3_key,
-			       tpm_parse_fields_t parse_rule_bm,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_rule_action_t *rule_action,
-			       tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) parse_rule_bm(%d) \n",
-		     src_port, dir, rule_num, parse_rule_bm);
-
-	/* L3 Parsing, according to bm in param */
-	tcam_data->l3_parse_bm = parse_rule_bm;
-	/* If PPPoe, fill in pppoe_ses ethertype, incase user forgot */
-	if (parse_rule_bm & (TPM_L2_PARSE_PPPOE_SES | TPM_L2_PARSE_PPP_PROT)) {
-		l3_key->ether_type_key = ETH_P_PPP_SES;
-		tcam_data->l3_parse_bm |= TPM_L2_PARSE_ETYPE;
-	}
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* set CTC CnM */
-	if(tpm_ctc_cm_l3_rule2cm_tcam(parse_flags_bm, l3_key, rule_action)) {
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	/* Parse the AI flag bits */
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field, parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data),
-					  &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (l3_key) {
-		memcpy(&(tcam_data->pkt_key.l3_key.ether_type_key), &l3_key->ether_type_key,
-		       sizeof(tpm_ether_type_key_t));
-		memcpy(&(tcam_data->pkt_key.l3_key.pppoe_key), &l3_key->pppoe_key, sizeof(tpm_pppoe_key_t));
-	}
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_ETH_TYPE, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_l3_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* src_port          - packet source port
-* dir               - Packet direction
-* rule_num          - API rule number
-* pon_type          - WAN technology
-* action_drop       - drop or not
-* parse_flags_bm    - Parse flags in prim ACL
-* next_phase        - next stage
-*
-* OUTPUTS:
-* l3_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_l3_sram_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       uint8_t is_pppoe,
-			       tpm_db_pon_type_t pon_type,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_rule_action_t *rule_action,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_pncl_sram_data_t *sram_data)
-{
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_ai_vectors_t src_port_field;
-	long long int_pkt_act = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), dir(%d), rule_num(%d) \n", src_port, dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Set pppoe_bit */
-	if (is_pppoe == TPM_TRUE) {
-		int_pkt_act |= TPM_ACTION_SET_PPPOE;
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_PPPOE;
-	} else
-		int_pkt_act |= TPM_ACTION_UNSET_PPPOE;
-
-	/* Set AI Bits */
-	src_port_field.src_port = src_port;
-	/* if L3 is IPv6, reset AI NH2_lu */
-	if (STAGE_IPv6_NH == rule_action->next_phase)
-		int_pkt_act |= TPM_ACTION_UNSET_NH2_ITER;
-	else if (STAGE_CTC_CM == rule_action->next_phase)
-		int_pkt_act |= TPM_ACTION_UNSET_CNM_IPV4 | TPM_ACTION_UNSET_IPV4_PRE_KEY;
-
-	tpm_proc_static_ai_sram_build(&src_port_field,
-				      rule_action->pkt_act, int_pkt_act, &(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Default, don't set MH */
-	sram_data->mh_reg.mh_reg = 0;
-
-	/* Update L3_offset_register with etype/pppoe length */
-	sram_data->shift_updt_reg = 0;	/* update reg 0 */
-	sram_data->next_offset.offset_base = TPM_PNCL_L3_OFFSET;
-	sram_data->next_offset.offset_sub.l3_subf = 0xffff;	/* End of Ether_type/pppoe parsing */
-
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-
-		/* Set L3, L4 to OTHER */
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-		sram_data->l3_type = TPM_PNCL_L3_OTHER;
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-	} else if ((rule_action->next_phase == STAGE_IPv4) || (rule_action->next_phase == STAGE_IPv6_NH)) {
-		/* next lookup at reg0 */
-		sram_data->next_lu_off_reg = 0;
-
-		if (rule_action->next_phase == STAGE_IPv6_NH) {
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_NH, &range_conf);
-			IF_ERROR(ret_code);
-			sram_data->l3_type = TPM_PNCL_L3_IPV6;
-			sram_data->sram_updt_bm |= TPM_PNCL_SET_L3;
-		}
-		if (rule_action->next_phase == STAGE_IPv4) {
-			ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_MAIN, &range_conf);
-			IF_ERROR(ret_code);
-			/* Note: l3_type cannot be set, since ipv4_fragmentation is not known yet*/
-		}
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	} else if (rule_action->next_phase == STAGE_CTC_CM) {
-		/* next lookup at reg0 */
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-		sram_data->next_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-		sram_data->next_offset.offset_sub.l2_subf = 0;
-		sram_data->next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-
-		/* Set L3, L4 to OTHER */
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_L3 | TPM_PNCL_SET_L4);
-		sram_data->l3_type = TPM_PNCL_L3_OTHER;
-		sram_data->l4_type = TPM_PNCL_L4_OTHER;
-
-		/* set next loopup id */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " next phase not supported (%d)\n", rule_action->next_phase);
-		return(TPM_FAIL);
-	}
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_l3_type_acl_rule()
-*
-* DESCRIPTION:      Creates a new L3 type (ether type of pppoe proto) processing ACL.
-*                   It is used for operations that are not possible to be performed
-*                   in a single ACL or to ease the primary ACL processing
-*                   (as a helper of the primary L2 ACL).
-*                   The L3 type ACL is optional.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_num           - Entry index to be added in the current ACL
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-* parse_flags_bm     - Bitmap containing the significant flags result of the primary ACL filtering.
-* l3_key             - Structure for PPPoE proto or ether type. In order to define a rule for
-*                      any ether type, the ether type value should be set to 0xFFFF
-* action_drop        - If this stage is dropping the packet.
-* next_phase         - Set the next parsing stage for the packet.
-*
-* OUTPUTS:
-*  rule_idx         - Unique rule identification number, which is used when deleting the rule.
-*                     (this is not the rule_num)
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_l3_type_acl_rule(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l3_type_key_t *l3_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	uint8_t is_pppoe = TPM_FALSE;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_api_lu_conf_t lu_conf;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_l3_check(owner_id, src_port, rule_num, parse_rule_bm,
-					 parse_flags_bm, l3_key, pkt_frwd, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_L3_TYPE_ACL, &range_id);
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_l3_tcam_build(src_port, dir, rule_num, l3_key, parse_rule_bm,
-					      parse_flags_bm, rule_action, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	if (pnc_data.pncl_tcam.pkt_key.l3_key.ether_type_key == ETH_P_PPP_SES)
-		is_pppoe = TPM_TRUE;
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_l3_sram_build(src_port, dir, rule_num, is_pppoe, pon_type, pkt_frwd,
-					      rule_action, parse_flags_bm, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*** Insert the PNC Entry ***/
-	tpm_proc_create_acl_pnc_entry(TPM_L3_TYPE_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-	IF_ERROR(int_ret_code);
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	api_data.l3_type_key.src_port = src_port;
-	api_data.l3_type_key.parse_rule_bm = parse_rule_bm;
-	api_data.l3_type_key.parse_flags_bm = parse_flags_bm;
-	memcpy(&(api_data.l3_type_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (l3_key)
-		memcpy(&(api_data.l3_type_key.l3_key), l3_key, sizeof(tpm_l3_type_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.l3_type_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.l3_type_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Set API modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, TPM_INVALID_GMAC	/*DO NOT SUPPORT L3 MOD!! */ , &mod_con,
-				 mod_entry);
-
-	/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-	if (rule_num < api_rng_entries) {
-		int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_L3_TYPE_ACL, rule_num, (api_rng_entries - 1));
-		IF_ERROR(int_ret_code);
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_L3_TYPE_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Set aging counter group nunmber and msk */
-	int_ret_code = tpm_db_pnc_get_lu_conf(TPM_PNC_ETH_TYPE, &lu_conf);
-	IF_ERROR(int_ret_code);
-	tpm_tcam_set_lu_mask(pnc_entry, (int32_t) lu_conf.lu_mask);
-	tpm_tcam_set_cntr_group(pnc_entry, (int32_t) lu_conf.cntr_grp);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_del_l3_type_acl_rule()
-*
-* DESCRIPTION:      Deletes an existing ethernet type or PPPoE proto access-list entry .
-*                   Any of the existing access-list entries may be deleted. The src_port parameter
-*                   determines if the rule to be deleted belongs to the upstream access-list
-*                   or the downstream access-list. All parameters are compulsory. If the rule number
-*                   does not match the internally stored src_port and parsing key
-*                   (parse_rule_bm and l3_key), the API will return an error.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* src_port           - The packet originating source port. The parameter has a double function:
-*                       . The source port is part of the rules parsing key.
-*                       . The source port determines if the acl entry being
-*                         created is for the upstream acl or the downstream acl.
-*                      In case of an upstream entry, the parameter determines if the packet
-*                      arrives from a specific LAN port or ANY LAN port.
-* rule_idx           - Unique rule idenitifcation number specifying the rule to be deleted.
-* parse_rule_bm      - Bitmap containing the significant flags for parsing fields of the packet.
-* l3_key             - Information to create a parsing key for PPPoE proto or Ethernet type key.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_l3_type_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_L3_TYPE_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_erase_section()
-*
-* DESCRIPTION:      Erases a section per an application group.
-*
-* INPUTS:
-* owner_id           - APP owner id  should be used for all API calls.
-* api_type          - the API group area to be deleted.
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_erase_section(uint32_t owner_id, tpm_api_type_t api_type)
-{
-	tpm_error_code_t ret_code;
-	tpm_api_sections_t api_section;
-	int32_t next_idx = 0, cur_idx = -1;
-	uint32_t rule_idx, rule_num, dummy_idx, bi_dir;
-	tpm_rule_entry_t tpm_rule;
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_db_mod_conn_t mod_con;
-	tpm_rule_entry_t api_data;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) api_type(%d)\n", owner_id, api_type);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(api_type, owner_id);
-	IF_ERROR(ret_code);
-
-	if (ILLEGAL_API(api_type))
-		IF_ERROR(ERR_API_TYPE_INVALID);
-
-	tpm_db_api_section_get_from_api_type(api_type, &api_section);
-
-	while (next_idx != -1) {
-		ret_code = tpm_get_next_valid_rule(owner_id, cur_idx, api_type, &next_idx, &rule_idx, &tpm_rule);
-		IF_ERROR(ret_code);
-		ret_code = tpm_db_api_rulenum_get(api_section, rule_idx, &rule_num);
-		IF_ERROR(ret_code);
-		ret_code =
-		tpm_db_api_entry_get(api_section, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-		IF_ERROR(ret_code);
-
-		/* Delete PNC Entry */
-		ret_code = tpm_proc_pnc_con_del(&pnc_con);
-		IF_ERROR(ret_code);
-		/* Release related modification entry  (Important, after deleting PNC Entries) */
-		if (mod_con.mod_cmd_mac != TPM_INVALID_GMAC)
-			ret_code = tpm_mod2_entry_del(TPM_MOD_OWNER_TPM, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-
-		IF_ERROR(ret_code);
-	}
-	tpm_db_api_section_reset(api_section);
-	IF_ERROR(ret_code);
-
-	return ret_code;
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_nh_acl_rule(uint32_t owner_id,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_nh_iter_t nh_iter,
-					       uint32_t nh,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	uint32_t bi_dir = 0;
-	uint32_t pnc_entry, mod_entry = 0;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d), rule_num(%d)\n", owner_id, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_nh_check(owner_id, rule_num, nh_iter, parse_flags_bm, nh, pkt_frwd, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Simulate DS only (BI_DIR) */
-	dir = TPM_DIR_DS;
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_IPV6_NH_ACL, &range_id);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_nh_tcam_build(rule_num, nh_iter, nh,
-				parse_flags_bm, rule_action, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code =
-	tpm_proc_ipv6_nh_sram_build(rule_num, nh_iter, nh, pon_type, pkt_frwd, rule_action, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(range_id, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV6_NH_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_nh_acl_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV6_NH_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV6_NH_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	api_data.ipv6_nh_key.nh_iter = nh_iter;
-	api_data.ipv6_nh_key.nh = nh;
-	api_data.ipv6_nh_key.parse_rule_bm = TPM_IPv6_PARSE_NH;
-	api_data.ipv6_nh_key.parse_flags_bm = parse_flags_bm;
-	if (rule_action != NULL)
-		memcpy(&(api_data.ipv6_nh_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	else
-		memset(&(api_data.ipv6_nh_key.rule_action), 0, sizeof(tpm_rule_action_t));
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_nh_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_nh_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Set API modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, TPM_INVALID_GMAC	/*DO NOT SUPPORT NH MOD!! */ , &mod_con,
-				 mod_entry);
-
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_IPV6_NH_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_IPV6_NH_ACL, rule_num, 1 /*bi_dir */ ,
-					    &api_data, &mod_con	/*no mod_con */ , &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_nh_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV6_NH_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_acl_rule(uint32_t owner_id,
-						  tpm_src_port_type_t src_port,
-						  uint32_t rule_num,
-						  uint32_t *rule_idx,
-						  tpm_parse_fields_t parse_rule_bm,
-						  tpm_parse_flags_t parse_flags_bm,
-						  tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-						  tpm_pkt_frwd_t *pkt_frwd,
-						  tpm_pkt_mod_t *pkt_mod,
-						  tpm_pkt_mod_bm_t pkt_mod_bm,
-						  tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	uint32_t bi_dir = 0;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_gen_check(owner_id, src_port, rule_num, parse_rule_bm, parse_flags_bm,
-						 ipv6_gen_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_IPV6_GEN_ACL, &range_id);
-
-	/*********** Create Modification Entries **********/
-
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_gen_tcam_build(src_port, dir, rule_num, ipv6_gen_key,
-						      parse_rule_bm, parse_flags_bm, pkt_mod,
-						      pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_gen_sram_build(src_port, dir, rule_num, pon_type, pkt_frwd, rule_action,
-						      mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(range_id, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV6_GEN_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_gen_acl_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV6_GEN_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV6_GEN_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	api_data.ipv6_gen_key.src_port = src_port;
-	api_data.ipv6_gen_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_gen_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_gen_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_gen_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (ipv6_gen_key)
-		memcpy(&(api_data.ipv6_gen_key.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_gen_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_gen_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_gen_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_gen_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_IPV6_GEN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_IPV6_GEN_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_gen_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV6_GEN_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_acl_rule(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_ipv6_addr_key_t *ipv6_dip_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_mod_t *pkt_mod,
-						tpm_pkt_mod_bm_t pkt_mod_bm,
-						tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	uint32_t bi_dir = 0;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_dip_check(owner_id, src_port, rule_num, parse_rule_bm, parse_flags_bm,
-					       ipv6_dip_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_IPV6_DIP_ACL, &range_id);
-
-	/*********** Create Modification Entries **********/
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_dip_tcam_build(src_port, dir, rule_num, ipv6_dip_key,
-						    parse_rule_bm, parse_flags_bm, pkt_mod,
-						    pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_dip_sram_build(src_port, dir, rule_num, pon_type, pkt_frwd, rule_action,
-						    mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(range_id, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV6_DIP_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_dip_acl_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV6_DIP_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV6_DIP_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	api_data.ipv6_dip_key.src_port = src_port;
-	api_data.ipv6_dip_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_dip_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_dip_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_dip_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (ipv6_dip_key)
-		memcpy(&(api_data.ipv6_dip_key.ipv6_dipkey), ipv6_dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_dip_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_dip_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_dip_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_dip_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_IPV6_DIP_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_IPV6_DIP_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_dip_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV6_DIP_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_l4_ports_acl_rule(uint32_t owner_id,
-						     tpm_src_port_type_t src_port,
-						     uint32_t rule_num,
-						     uint32_t *rule_idx,
-						     tpm_parse_fields_t parse_rule_bm,
-						     tpm_parse_flags_t parse_flags_bm,
-						     tpm_l4_ports_key_t *l4_key,
-						     tpm_pkt_frwd_t *pkt_frwd,
-						     tpm_pkt_mod_t *pkt_mod,
-						     tpm_pkt_mod_bm_t pkt_mod_bm,
-						     tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_dir_t dir = 0;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	uint32_t bi_dir = 0;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d)\n", owner_id, src_port, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_l4ports_check(owner_id, src_port, rule_num, parse_rule_bm, parse_flags_bm,
-						   l4_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get direction */
-	tpm_proc_src_port_dir_map(src_port, &dir);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_L4_ACL, &range_id);
-
-	/*********** Create Modification Entries **********/
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		/*int_mod_bm must be modified in Phase2 */
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_l4ports_tcam_build(src_port, dir, rule_num, l4_key,
-							parse_rule_bm, parse_flags_bm, rule_action,
-							pkt_mod, pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_l4ports_sram_build(src_port, dir, rule_num, pon_type, pkt_frwd, rule_action,
-							mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(range_id, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_L4_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_l4_ports_acl_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_L4_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_L4_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	api_data.ipv6_l4_key.src_port = src_port;
-	api_data.ipv6_l4_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_l4_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_l4_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_l4_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (l4_key)
-		memcpy(&(api_data.ipv6_l4_key.l4_key), l4_key, sizeof(tpm_l4_ports_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_l4_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_l4_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_l4_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_l4_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_L4_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_L4_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_l4_ports_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	ret_code = tpm_proc_del_acl_rule(TPM_L4_ACL, owner_id, rule_idx, ext_call);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_catch_all_init(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, cpu_def_rx_queue;
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_db_pnc_range_t range_data;
-	tpm_init_pnc_last_init_t catch_all_pkt_action;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_CATCH_ALL, &range_data);
-	IF_ERROR(int_ret_code);
-
-	/* Get number of entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start + range_data.pnc_range_conf.api_start;
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "free_ent(%d)\n", free_entries);
-
-	tpm_db_get_catch_all_pkt_action(&catch_all_pkt_action);
-
-	/* TCAM  : Any LU_ID, all GMACs */
-	pnc_data.pncl_tcam.lu_id = TPM_PNC_ANY_LUID;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-
-	/* Fictive L2 table */
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	 /*SRAM*/
-	/* LookupDone */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_LUD;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Trap or drop packets */
-	if (TPM_PNC_LAST_ENTRY_INIT_TRAP == catch_all_pkt_action) {
-		/* Get CPU Queue */
-		tpm_db_get_cpu_rx_queue(&cpu_def_rx_queue);
-
-		/* Set Target to CPU */
-		pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_TXP;
-		pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-		/* Set Queue to default CPU Queue */
-		pnc_data.pncl_sram.pnc_queue = cpu_def_rx_queue;
-	} else {
-		/* Discard packet */
-		pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_DISC;
-	}
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_CATCH_ALL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-void tpm_proc_check_ipv6_gen_5t_key(uint32_t parse_bm, tpm_ipv6_gen_acl_key_t *gen_key)
-{
-	if ((parse_bm & TPM_IPv6_PARSE_SIP) == 0) {
-		memset(gen_key->ipv6_src_ip_add, 0, 16 * sizeof(uint8_t));
-		memset(gen_key->ipv6_src_ip_add_mask, 0, 16 * sizeof(uint8_t));
-	}
-
-	if ((parse_bm & TPM_IPv6_PARSE_DSCP) == 0) {
-		gen_key->ipv6_dscp = 0;
-		gen_key->ipv6_dscp_mask = 0;
-	}
-
-	if ((parse_bm & TPM_IPv6_PARSE_HOPL) == 0) {
-		gen_key->hop_limit = 0;
-	}
-}
-
-void tpm_proc_check_ipv6_dip_5t_key(uint32_t parse_bm, tpm_ipv6_addr_key_t *dip_key)
-{
-	if ((parse_bm & TPM_IPv6_PARSE_DIP) == 0) {
-		memset(dip_key->ipv6_ip_add, 0, 16 * sizeof(uint8_t));
-		memset(dip_key->ipv6_ip_add_mask, 0, 16 * sizeof(uint8_t));
-	}
-}
-
-void tpm_proc_check_ipv6_l4_ports_5t_key(uint32_t parse_bm, tpm_l4_ports_key_t *l4_key)
-{
-	if ((parse_bm & TPM_PARSE_L4_SRC) == 0) {
-		l4_key->l4_src_port = 0;
-	}
-
-	if ((parse_bm & TPM_PARSE_L4_DST) == 0) {
-		l4_key->l4_dst_port = 0;
-	}
-}
-
-uint8_t tpm_proc_check_ipv6_5t_flow_a_equal_b(uint32_t parse_bm,
-												uint32_t proto_a,
-												tpm_l4_ports_key_t *l4_key_a,
-												tpm_ipv6_gen_acl_key_t *gen_key_a,
-												tpm_ipv6_addr_key_t *dip_key_a,
-												uint32_t proto_b,
-												tpm_l4_ports_key_t *l4_key_b,
-												tpm_ipv6_gen_acl_key_t *gen_key_b,
-												tpm_ipv6_addr_key_t *dip_key_b)
-{
-	if (parse_bm & TPM_IPv6_PARSE_NH) {
-		if (proto_a != proto_b)
-			return TPM_FALSE;
-	}
-
-	if (parse_bm & TPM_IPV6_L4_BM_MASK) {
-		if (parse_bm & TPM_PARSE_L4_SRC) {
-			if (l4_key_a->l4_src_port != l4_key_b->l4_src_port)
-				return TPM_FALSE;
-		}
-		if (parse_bm & TPM_PARSE_L4_DST) {
-			if (l4_key_a->l4_dst_port != l4_key_b->l4_dst_port)
-				return TPM_FALSE;
-		}
-	}
-
-	if (parse_bm & TPM_IPV6_GEN_BM_MASK) {
-		if (parse_bm & TPM_IPv6_PARSE_SIP) {
-			if (memcmp(gen_key_a->ipv6_src_ip_add, gen_key_b->ipv6_src_ip_add, 16 * sizeof(uint8_t)) ||
-				memcmp(gen_key_a->ipv6_src_ip_add_mask, gen_key_b->ipv6_src_ip_add_mask, 16 * sizeof(uint8_t)))
-				return TPM_FALSE;
-		}
-	}
-
-	if (parse_bm & TPM_IPv6_PARSE_DIP) {
-		if (memcmp(dip_key_a->ipv6_ip_add, dip_key_b->ipv6_ip_add, 16 * sizeof(uint8_t)) ||
-			memcmp(dip_key_a->ipv6_ip_add_mask, dip_key_b->ipv6_ip_add_mask, 16 * sizeof(uint8_t)))
-			return TPM_FALSE;
-	}
-
-	return TPM_TRUE;
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_5t_check(uint32_t owner_id,
-						tpm_dir_t dir,
-						uint32_t rule_num,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_l4_ports_key_t *l4_key,
-						tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_mod_bm_t pkt_mod_bm,
-						tpm_pkt_mod_t *pkt_mod,
-						tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_db_pon_type_t pon_type;
-	uint32_t i, subflow_bm, subflow_id, protocol = 0, _subflow_bm, _protocol, _dir, _is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_l4_ports_key_t _l4_key;
-	tpm_ipv6_gen_acl_key_t _gen_key;
-	tpm_ipv6_addr_key_t _dip_key, dip_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_src_port_type_t src_port;
-
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check 5_tuple feature is enabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_ENABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check necessary pointers are valid */
-
-	if (rule_action == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "rule_action cannot be NULL\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_mod == NULL) && (SET_MOD(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Mod requested with NULL pointer\n");
-		return(ERR_MOD_INVALID);
-	}
-
-	if ((pkt_frwd == NULL) && ((SET_TARGET_PORT(rule_action->pkt_act)) || SET_TARGET_QUEUE(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target set requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	if ((l4_key == NULL) || (ipv6_gen_key == NULL)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parsing requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_GEN_5T_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_GEN_5T_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_GEN, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_GEN, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV6_GEN_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_IPv6_DIP && rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_GEN_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	/* Check 5T-flow keys */
-	tpm_proc_check_ipv6_l4_ports_5t_key(parse_rule_bm, l4_key);
-	tpm_proc_check_ipv6_gen_5t_key(parse_rule_bm, ipv6_gen_key);
-
-	if (parse_rule_bm & TPM_IPV6_L4_BM_MASK) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) == 0)
-			return(ERR_IPV6_KEY_INVALID);
-	}
-
-	subflow_bm = parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if (subflow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			subflow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		subflow_id = tpm_db_find_matched_ipv6_gen_subflow(dir, subflow_bm, protocol, l4_key, ipv6_gen_key);
-		if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-			return ERR_IPV6_5T_RULE_EXISTS;
-
-		if (rule_action->next_phase == STAGE_DONE) {
-			for (i = 0; i < TPM_DB_IPV6_MAX_5T_FLOW_NUM; i++) {
-				memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-				memset(&_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-				memset(&_dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-				ret_code = tpm_db_get_ipv6_5t_flow(i, &_dir, &_subflow_bm, &_is_pppoe, &_protocol, &_l4_key, &_gen_key, &_dip_key);
-				if (ret_code != TPM_DB_OK)
-					continue;
-
-				if ((subflow_bm & _subflow_bm) == subflow_bm) {
-					if (tpm_proc_check_ipv6_5t_flow_a_equal_b(subflow_bm, protocol, l4_key, ipv6_gen_key, &dip_key,
-															_protocol, &_l4_key, &_gen_key, &_dip_key))
-						return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-				} else if ((subflow_bm & _subflow_bm) == _subflow_bm) {
-					if (tpm_proc_check_ipv6_5t_flow_a_equal_b(_subflow_bm, _protocol, &_l4_key, &_gen_key, &_dip_key,
-															protocol, l4_key, ipv6_gen_key, &dip_key))
-						return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-				}
-			}
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_5t_check(uint32_t owner_id,
-						tpm_dir_t dir,
-						uint32_t rule_num,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_l4_ports_key_t *l4_key,
-						tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-						tpm_ipv6_addr_key_t *ipv6_dip_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_mod_bm_t pkt_mod_bm,
-						tpm_pkt_mod_t *pkt_mod,
-						tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_db_pon_type_t pon_type;
-	uint32_t i, flow_bm, flow_id, protocol = 0, is_pppoe, _flow_bm, _protocol, _dir, _is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_l4_ports_key_t _l4_key;
-	tpm_ipv6_gen_acl_key_t _gen_key;
-	tpm_ipv6_addr_key_t _dip_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_src_port_type_t src_port;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Check 5_tuple feature is enabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_ENABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check necessary pointers are valid */
-
-	if (rule_action == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "rule_action cannot be NULL\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_mod == NULL) && (SET_MOD(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Mod requested with NULL pointer\n");
-		return(ERR_MOD_INVALID);
-	}
-
-	if ((pkt_frwd == NULL) && ((SET_TARGET_PORT(rule_action->pkt_act)) || SET_TARGET_QUEUE(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target set requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	if ((l4_key == NULL) || (ipv6_gen_key == NULL) || (ipv6_dip_key == NULL)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parsing requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port,
-				pkt_frwd->trg_queue, rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_DIP_5T_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_DIP_5T_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_DIP, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_DIP, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_IPV6_DIP_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_DONE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_DIP_ACL_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	/* Check 5T-flow keys */
-	tpm_proc_check_ipv6_l4_ports_5t_key(parse_rule_bm, l4_key);
-	tpm_proc_check_ipv6_gen_5t_key(parse_rule_bm, ipv6_gen_key);
-	tpm_proc_check_ipv6_dip_5t_key(parse_rule_bm, ipv6_dip_key);
-
-	if (parse_rule_bm & TPM_IPV6_L4_BM_MASK) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) == 0)
-			return(ERR_IPV6_KEY_INVALID);
-	}
-
-	if (parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK) {
-		flow_bm = parse_rule_bm;
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			flow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-			is_pppoe = TPM_TRUE;
-		else
-			is_pppoe = TPM_FALSE;
-		flow_id = tpm_db_find_matched_ipv6_5t_flow(dir, flow_bm, is_pppoe, protocol, l4_key, ipv6_gen_key, ipv6_dip_key);
-		if (flow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-			return ERR_IPV6_5T_RULE_EXISTS;
-
-		for (i = 0; i < TPM_DB_IPV6_MAX_5T_FLOW_NUM; i++) {
-			memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-			memset(&_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-			memset(&_dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-			ret_code = tpm_db_get_ipv6_5t_flow(i, &_dir, &_flow_bm, &_is_pppoe, &_protocol, &_l4_key, &_gen_key, &_dip_key);
-			if (ret_code != TPM_DB_OK)
-				continue;
-
-			if ((flow_bm & _flow_bm) == flow_bm) {
-				if (tpm_proc_check_ipv6_5t_flow_a_equal_b(flow_bm, protocol, l4_key, ipv6_gen_key, ipv6_dip_key,
-														_protocol, &_l4_key, &_gen_key, &_dip_key))
-					return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-			} else if ((flow_bm & _flow_bm) == _flow_bm) {
-				if (tpm_proc_check_ipv6_5t_flow_a_equal_b(_flow_bm, _protocol, &_l4_key, &_gen_key, &_dip_key,
-														protocol, l4_key, ipv6_gen_key, ipv6_dip_key))
-					return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-			}
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_l4_ports_5t_check(uint32_t owner_id,
-						     tpm_dir_t dir,
-						     uint32_t rule_num,
-						     tpm_parse_fields_t parse_rule_bm,
-						     tpm_parse_flags_t parse_flags_bm,
-						     tpm_l4_ports_key_t *l4_key,
-						     tpm_pkt_frwd_t *pkt_frwd,
-						     tpm_pkt_mod_bm_t pkt_mod_bm,
-						     tpm_pkt_mod_t *pkt_mod,
-						     tpm_rule_action_t *rule_action)
-{
-	int32_t ret_code;
-	tpm_db_pon_type_t pon_type;
-	uint32_t i, subflow_bm, subflow_id, protocol = 0, _subflow_bm, _protocol, _dir, _is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_l4_ports_key_t _l4_key;
-	tpm_ipv6_gen_acl_key_t _gen_key, gen_key;
-	tpm_ipv6_addr_key_t _dip_key, dip_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_src_port_type_t src_port;
-
-	memset(&gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Check TPM was successfully initialized */
-	if (!tpm_db_init_done_get())
-		IF_ERROR(ERR_SW_NOT_INIT);
-
-	/* Get Direction, PON type, Important before other tests */
-	tpm_db_pon_type_get(&pon_type);
-
-
-	/* Check 5_tuple feature is enabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable != TPM_IPV6_5T_ENABLED)
-		return ERR_IPV6_API_ILLEGAL_CALL;
-
-	/* Check necessary pointers are valid */
-
-	if (rule_action == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "rule_action cannot be NULL\n");
-		return(ERR_ACTION_INVALID);
-	}
-
-	if ((pkt_mod == NULL) && (SET_MOD(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Mod requested with NULL pointer\n");
-		return(ERR_MOD_INVALID);
-	}
-
-	if ((pkt_frwd == NULL) && ((SET_TARGET_PORT(rule_action->pkt_act)) || SET_TARGET_QUEUE(rule_action->pkt_act))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target set requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	if (l4_key == NULL) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Parsing requested with NULL pointer\n");
-		return(ERR_FRWD_INVALID);
-	}
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-
-	/* Check Target_port and Queue are valid */
-	ret_code =
-	tpm_proc_check_valid_target(dir, pon_type, src_port, pkt_frwd->trg_port, pkt_frwd->trg_queue,
-				rule_action->pkt_act, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	/* Check parse_bm */
-	if (parse_rule_bm & (~(api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_5T_RULE].sup_parse_fields))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_rule_bm(0x%x) \n", parse_rule_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-
-	/* Check parse_flags_bm */
-	if (parse_flags_bm & (~(api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_5T_RULE].sup_parse_flags))) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid parse_flags_bm (0x%x) \n", parse_flags_bm);
-		return(ERR_PARSE_MAP_INVALID);
-	}
-	/* Check parse_flags_bm - TRUE and FALSE are not set together */
-	ret_code = tpm_proc_check_parse_flag_valid(parse_flags_bm);
-	IF_ERROR(ret_code);
-
-	/* Check owner_id */
-	ret_code = tpm_owner_id_check(TPM_API_IPV6_L4, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-
-	/* Check rule_num, and api_section is active */
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_L4, &range_data);
-
-	ret_code = tpm_proc_add_api_ent_check(TPM_L4_ACL, range_data.pnc_range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-
-	/* Check forwarding rule, currently only support STAGE_DONE */
-	if (rule_action->next_phase != STAGE_IPv6_GEN && rule_action->next_phase != STAGE_DONE
-		&& rule_action->next_phase != STAGE_CTC_CM) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " Next Phase (%d) is not supported \n", rule_action->next_phase);
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check rule action */
-	ret_code = tpm_proc_check_pkt_action(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm);
-	IF_ERROR(ret_code);
-	if (rule_action->pkt_act & api_sup_param_val[TPM_ADD_IPV6_L4_PORTS_5T_RULE].forbidden_actions) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Packet Action (0x%x) includes forbidden action\n", rule_action->pkt_act);
-		return(ERR_ACTION_INVALID);
-	}
-
-	/* Check if next stage CTC CnM  */
-	if ((rule_action->next_phase == STAGE_CTC_CM) && !(parse_flags_bm & TPM_PARSE_FLAG_MTM_FALSE)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "next stage is CnM, packets must be MTM_FALSE\n");
-		return(ERR_NEXT_PHASE_INVALID);
-	}
-
-	/* Check 5T-flow keys */
-	tpm_proc_check_ipv6_l4_ports_5t_key(parse_rule_bm, l4_key);
-
-	if (parse_rule_bm & TPM_IPV6_L4_BM_MASK) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) == 0)
-			return(ERR_IPV6_KEY_INVALID);
-	}
-
-	subflow_bm = parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-	if (subflow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			subflow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		subflow_id = tpm_db_find_matched_ipv6_l4_subflow(dir, subflow_bm, protocol, l4_key);
-		if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID)
-			return ERR_IPV6_5T_RULE_EXISTS;
-
-		if (rule_action->next_phase == STAGE_DONE) {
-			for (i = 0; i < TPM_DB_IPV6_MAX_5T_FLOW_NUM; i++) {
-				memset(&_l4_key, 0, sizeof(tpm_l4_ports_key_t));
-				memset(&_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-				memset(&_dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-				ret_code = tpm_db_get_ipv6_5t_flow(i, &_dir, &_subflow_bm, &_is_pppoe, &_protocol, &_l4_key, &_gen_key, &_dip_key);
-				if (ret_code != TPM_DB_OK)
-					continue;
-
-				if ((subflow_bm & _subflow_bm) == subflow_bm) {
-					if (tpm_proc_check_ipv6_5t_flow_a_equal_b(subflow_bm, protocol, l4_key, &gen_key, &dip_key,
-															_protocol, &_l4_key, &_gen_key, &_dip_key))
-						return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-				} else if ((subflow_bm & _subflow_bm) == _subflow_bm) {
-					if (tpm_proc_check_ipv6_5t_flow_a_equal_b(_subflow_bm, _protocol, &_l4_key, &_gen_key, &_dip_key,
-															protocol, l4_key, &gen_key, &dip_key))
-						return ERR_IPV6_5T_FLOW_PARTIAL_MATCHED;
-				}
-			}
-		}
-	}
-
-	return(TPM_RC_OK);
-}
-
-int32_t tpm_proc_ipv6_gen_5t_tcam_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_l4_ports_key_t *l4_key,
-					tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					tpm_parse_fields_t parse_rule_bm,
-					tpm_parse_flags_t parse_flags_bm,
-					tpm_rule_action_t *rule_action,
-					tpm_pkt_mod_t *pkt_mod,
-					tpm_pkt_mod_bm_t pkt_mod_bm,
-					tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_src_port_type_t src_port;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t subflow_field;
-	int32_t ret_code;
-	uint32_t subflow_bm, subflow_id, protocol = 0;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-			dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* IPV6 parsing, according to parse_rule */
-	tcam_data->ipv6_parse_bm = parse_rule_bm & TPM_IPV6_GEN_BM_MASK;
-
-	/* Build the AI bits according to parse_flags */
-	subflow_bm = parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-	if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-			protocol = IPPROTO_TCP;
-		else {
-			protocol = IPPROTO_UDP;
-			if (dir == TPM_DIR_DS)
-				parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_FALSE;
-		}
-		subflow_bm |= TPM_IPv6_PARSE_NH;
-	}
-	if (subflow_bm != 0) {
-		subflow_id = tpm_db_find_matched_ipv6_l4_subflow(dir, subflow_bm, protocol, l4_key);
-		if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-			return TPM_FAIL;
-		subflow_field.ipv6_subflow = subflow_id + 1;
-		parse_int_flags_bm |= TPM_PARSE_FLAG_IPV6_SUBFLOW_PARSE;
-	}
-	parse_flags_bm &= ~TPM_PARSE_FLAG_L4P_MASK;
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((STAGE_CTC_CM == rule_action->next_phase) || ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD))) {
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-	tpm_proc_parse_flag_ai_tcam_build(&subflow_field, parse_flags_bm, parse_int_flags_bm,
-									&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (ipv6_gen_key)
-		memcpy(&(tcam_data->pkt_key.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_GEN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_dip_5t_tcam_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_l4_ports_key_t *l4_key,
-					tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					tpm_ipv6_addr_key_t *ipv6_dip_key,
-					tpm_parse_fields_t parse_rule_bm,
-					tpm_parse_flags_t parse_flags_bm,
-					tpm_rule_action_t *rule_action,
-					tpm_pkt_mod_t *pkt_mod,
-					tpm_pkt_mod_bm_t pkt_mod_bm,
-					tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_src_port_type_t src_port;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t subflow_field;
-	int32_t ret_code;
-	uint32_t subflow_bm, subflow_id, protocol = 0;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-			dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* IPV6 parsing, according to parse_rule */
-	tcam_data->ipv6_parse_bm = parse_rule_bm & TPM_IPv6_PARSE_DIP;
-
-	/* Build the AI bits according to parse_flags */
-	if ((parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK) ||
-		(parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK)){
-		subflow_bm = parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			parse_flags_bm &= ~TPM_PARSE_FLAG_L4P_MASK;
-			subflow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		subflow_id = tpm_db_find_matched_ipv6_gen_subflow(dir, subflow_bm, protocol, l4_key, ipv6_gen_key);
-		if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-			return TPM_FAIL;
-		subflow_field.ipv6_subflow = subflow_id + 1;
-		parse_int_flags_bm |= TPM_PARSE_FLAG_IPV6_SUBFLOW_PARSE;
-	}
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD)){
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	tpm_proc_parse_flag_ai_tcam_build(&subflow_field, parse_flags_bm, parse_int_flags_bm,
-									&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (ipv6_dip_key)
-		memcpy(&(tcam_data->pkt_key.ipv6_dip_key), ipv6_dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_DIP, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_l4_ports_5t_tcam_build(tpm_dir_t dir,
-					     uint32_t rule_num,
-					     tpm_l4_ports_key_t *l4_key,
-					     tpm_parse_fields_t parse_rule_bm,
-					     tpm_parse_flags_t parse_flags_bm,
-					     tpm_rule_action_t *rule_action,
-					     tpm_pkt_mod_t *pkt_mod,
-					     tpm_pkt_mod_bm_t pkt_mod_bm,
-					     tpm_pncl_tcam_data_t *tcam_data)
-{
-	tpm_src_port_type_t src_port;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	long long parse_int_flags_bm = 0;
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) parse_rule_bm(%x) parse_flag_bm(%x) \n",
-			dir, rule_num, parse_rule_bm, parse_flags_bm);
-
-	/* IPV6 parsing, according to parse_rule */
-	tcam_data->l4_parse_bm = parse_rule_bm;
-
-	if (parse_flags_bm & TPM_PARSE_FLAG_L4_UDP) {
-		if (dir == TPM_DIR_DS)
-			parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_FALSE;
-	}
-	/*if Ipv6 split, check AI bit, update tcam*/
-	if ((STAGE_CTC_CM == rule_action->next_phase) || ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		(VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) &&
-		(0xff == pkt_mod->vlan_mod.vlan1_out.pbit_mask) &&
-		(pkt_mod_bm == TPM_VLAN_MOD))) {
-
-		/*if Ipv6 split or CTC CnM, check AI bit, update tcam*/
-		parse_int_flags_bm |= TPM_PARSE_FLGA_SPLIT_MOD_TRUE;
-	}
-
-	/* Build the AI bits according to parse_flags */
-	tpm_proc_parse_flag_ai_tcam_build(NULL, parse_flags_bm, parse_int_flags_bm,
-					  &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	if (dir == TPM_DIR_DS)
-		src_port = TPM_SRC_PORT_WAN;
-	else
-		src_port = TPM_SRC_PORT_UNI_ANY;
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	tcam_data->pkt_key.src_port = src_port;
-	if (l4_key)
-		memcpy(&(tcam_data->pkt_key.l4_ports_key), l4_key, sizeof(tpm_l4_ports_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_L4, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_gen_5t_sram_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_db_pon_type_t pon_type,
-					uint32_t ipv6_gen_subflow,
-					tpm_pkt_frwd_t *pkt_frwd,
-					tpm_rule_action_t *rule_action,
-					long long int_pkt_act,
-					tpm_pkt_mod_t *pkt_mod,
-					uint32_t mod_cmd,
-					tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_ai_vectors_t subflow_field;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) \n", dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Set AI Bits */
-	subflow_field.ipv6_subflow = ipv6_gen_subflow + 1;
-	tpm_proc_static_ai_sram_build(&subflow_field, rule_action->pkt_act, int_pkt_act,
-								&(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Set L3 */
-	sram_data->l3_type = TPM_PNCL_L3_IPV6;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_L3;
-
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-
-		/* Update dummy register (offset automatically=zero) */
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	} else if (rule_action->next_phase == STAGE_IPv6_DIP) {
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_DIP, &range_conf);
-		IF_ERROR(ret_code);
-
-		sram_data->next_lu_id = range_conf.base_lu_id;
-		sram_data->next_lu_off_reg = TPM_PNC_IPV6_DIP_REG;
-
-		sram_data->next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-		sram_data->next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_DIP;
-		sram_data->shift_updt_reg = TPM_PNC_IPV6_DIP_REG;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) {
-		/* split mod stage-2 */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-	else {
-		tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-	}
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_dip_5t_sram_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_db_pon_type_t pon_type,
-					tpm_pkt_frwd_t *pkt_frwd,
-					tpm_rule_action_t *rule_action,
-					long long int_pkt_act,
-					tpm_pkt_mod_t *pkt_mod,
-					uint32_t mod_cmd,
-					tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) \n", dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Set AI Bits */
-	tpm_proc_static_ai_sram_build(NULL, rule_action->pkt_act, int_pkt_act,
-								&(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Next Stage */
-	if (rule_action->next_phase == STAGE_DONE) {
-		tpm_proc_setstage_done(rule_action, sram_data);
-		sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	} else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) {
-		/* split mod stage-2 */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-	else {
-		tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-	}
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_l4_ports_5t_sram_build(tpm_dir_t dir,
-					     uint32_t rule_num,
-					     tpm_db_pon_type_t pon_type,
-					     uint32_t ipv6_l4_subflow,
-					     tpm_pkt_frwd_t *pkt_frwd,
-					     tpm_rule_action_t *rule_action,
-					     long long int_pkt_act,
-					     tpm_pkt_mod_t *pkt_mod,
-					     uint32_t mod_cmd,
-					     tpm_pncl_sram_data_t *sram_data)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_ai_vectors_t subflow_field;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " dir(%d), rule_num(%d) \n", dir, rule_num);
-
-	/* If packet Drop, nothing else to do */
-	if (PKT_DROP(rule_action->pkt_act)) {
-		sram_data->sram_updt_bm |= (TPM_PNCL_SET_DISC | TPM_PNCL_SET_LUD);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Packet Drop\n");
-		return(TPM_OK);
-	}
-
-	/* Set AI Bits */
-	subflow_field.ipv6_subflow = ipv6_l4_subflow + 1;
-	tpm_proc_static_ai_sram_build(&subflow_field, rule_action->pkt_act, int_pkt_act,
-								&(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	/* Set L3 */
-	sram_data->l3_type = TPM_PNCL_L3_IPV6;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_L3;
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	if (rule_action->next_phase == STAGE_DONE)
-		tpm_proc_setstage_done(rule_action, sram_data);
-	else if (rule_action->next_phase == STAGE_CTC_CM) {
-		/* nothing to Update */
-		sram_data->next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	}
-	else if (rule_action->next_phase == STAGE_IPv6_GEN) {
-		/* nothing to Update */
-		sram_data->next_lu_off_reg = TPM_PNC_LU_REG0; /* lookup reg 0 */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_GEN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id;
-	}
-	else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Next stage not supported\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Modification */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op) {
-		/* split mod stage-2 */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-	else {
-		tpm_proc_set_mod(rule_action, sram_data, mod_cmd);
-	}
-
-	/* For Target set PNC TXP, GemPort */
-	ret_code = tpm_proc_set_trgt_queue(rule_action, pkt_frwd, dir, pon_type, sram_data);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_set_RI_mh(rule_action, pkt_frwd, dir, sram_data);
-	IF_ERROR(ret_code);
-
-	/* Set Customization flag */
-	tpm_proc_set_cust_cpu_packet_parse(rule_action, sram_data);
-
-	return(TPM_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_5t_rule(uint32_t owner_id,
-					       tpm_dir_t src_dir,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l4_ports_key_t *l4_key,
-					       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0, bi_dir = 0, is_pppoe;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-
-	uint32_t subflow_bm, subflow_id, protocol = 0;
-	tpm_ipv6_addr_key_t dip_key;
-	long long int_pkt_act = 0;
-
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_dir(%d), rule_num(%d)\n", owner_id, src_dir, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_gen_5t_check(owner_id, src_dir, rule_num, parse_rule_bm, parse_flags_bm,
-											l4_key, ipv6_gen_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_IPV6_GEN_ACL, &range_id);
-
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_GEN, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV6_GEN_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_gen_5t_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*********** Create Subflow Entries **********/
-	subflow_bm = parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-			protocol = IPPROTO_TCP;
-		else
-			protocol = IPPROTO_UDP;
-		subflow_bm |= TPM_IPv6_PARSE_NH;
-	}
-	subflow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-	if (subflow_bm != 0 && rule_action->next_phase != STAGE_DONE) {
-		int_pkt_act |= TPM_ACTION_SET_IPV6_SUBFLOW;
-
-		subflow_id = tpm_db_get_free_ipv6_gen_subflow(src_dir);
-		if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-			return ERR_IPV6_5T_FLOW_AI_BITS_EXHAUSED;
-	} else {
-		int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-	}
-
-	/*********** Create Modification Entries **********/
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_gen_5t_tcam_build(src_dir, rule_num, l4_key, ipv6_gen_key,
-							parse_rule_bm, parse_flags_bm, rule_action,
-							pkt_mod, pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_gen_5t_sram_build(src_dir, rule_num, pon_type, subflow_id,
-							pkt_frwd, rule_action, int_pkt_act,
-							pkt_mod, mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV6_GEN_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV6_GEN_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	if (src_dir == TPM_DIR_DS)
-		api_data.ipv6_gen_key.src_port = TPM_SRC_PORT_WAN;
-	else
-		api_data.ipv6_gen_key.src_port = TPM_SRC_PORT_UNI_ANY;
-	api_data.ipv6_gen_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_gen_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_gen_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_gen_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (l4_key)
-		memcpy(&(api_data.ipv6_gen_key.l4_key), l4_key, sizeof(tpm_l4_ports_key_t));
-	if (ipv6_gen_key)
-		memcpy(&(api_data.ipv6_gen_key.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_gen_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_gen_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_gen_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_gen_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_IPV6_GEN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_IPV6_GEN_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Set 5T Flow Entry */
-	if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-		int_ret_code = tpm_db_set_ipv6_gen_subflow(src_dir, subflow_id, subflow_bm, protocol, l4_key, ipv6_gen_key);
-		IF_ERROR(int_ret_code);
-	}
-	if (rule_action->next_phase == STAGE_DONE) {
-		if (subflow_bm != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-				is_pppoe = TPM_TRUE;
-			else
-				is_pppoe = TPM_FALSE;
-			int_ret_code = tpm_db_set_ipv6_5t_flow(src_dir, subflow_bm, is_pppoe, protocol, l4_key, ipv6_gen_key, &dip_key);
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_5t_rule(uint32_t owner_id,
-					       tpm_dir_t src_dir,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l4_ports_key_t *l4_key,
-					       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					       tpm_ipv6_addr_key_t *ipv6_dip_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0, bi_dir = 0, is_pppoe;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-
-	uint32_t flow_bm, protocol = 0;
-	long long int_pkt_act = 0;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_dir(%d), rule_num(%d)\n", owner_id, src_dir, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_dip_5t_check(owner_id, src_dir, rule_num, parse_rule_bm, parse_flags_bm,
-										l4_key, ipv6_gen_key, ipv6_dip_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_IPV6_DIP_ACL, &range_id);
-
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_DIP, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_IPV6_DIP_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_dip_5t_rule(owner_id, l_rule_idx, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*********** Create Subflow Entries **********/
-	int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-	flow_bm = parse_rule_bm & (TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK | TPM_IPv6_PARSE_DIP);
-	if (parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			flow_bm |= TPM_IPv6_PARSE_NH;
-		}
-	}
-
-	/*********** Create Modification Entries **********/
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_dip_5t_tcam_build(src_dir, rule_num, l4_key, ipv6_gen_key, ipv6_dip_key,
-							parse_rule_bm, parse_flags_bm, rule_action,
-							pkt_mod, pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_dip_5t_sram_build(src_dir, rule_num, pon_type,
-							pkt_frwd, rule_action, int_pkt_act,
-							pkt_mod, mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_IPV6_DIP_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_IPV6_DIP_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	if (src_dir == TPM_DIR_DS)
-		api_data.ipv6_dip_key.src_port = TPM_SRC_PORT_WAN;
-	else
-		api_data.ipv6_dip_key.src_port = TPM_SRC_PORT_UNI_ANY;
-	api_data.ipv6_dip_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_dip_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_dip_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_dip_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (l4_key)
-		memcpy(&(api_data.ipv6_dip_key.l4_key), l4_key, sizeof(tpm_l4_ports_key_t));
-	if (ipv6_gen_key)
-		memcpy(&(api_data.ipv6_dip_key.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-	if (ipv6_dip_key)
-		memcpy(&(api_data.ipv6_dip_key.ipv6_dipkey), ipv6_dip_key, sizeof(tpm_ipv6_addr_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_dip_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_dip_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_dip_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_dip_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_IPV6_DIP_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_IPV6_DIP_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Set 5T Flow Entry */
-	if (flow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-			is_pppoe = TPM_TRUE;
-		else
-			is_pppoe = TPM_FALSE;
-		int_ret_code = tpm_db_set_ipv6_5t_flow(src_dir, flow_bm, is_pppoe, protocol, l4_key, ipv6_gen_key, ipv6_dip_key);
-		IF_ERROR(int_ret_code);
-	}
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_l4_ports_5t_rule(uint32_t owner_id,
-						    tpm_dir_t src_dir,
-						    uint32_t rule_num,
-						    uint32_t *rule_idx,
-						    tpm_parse_fields_t parse_rule_bm,
-						    tpm_parse_flags_t parse_flags_bm,
-						    tpm_l4_ports_key_t *l4_key,
-						    tpm_pkt_frwd_t *pkt_frwd,
-						    tpm_pkt_mod_t *pkt_mod,
-						    tpm_pkt_mod_bm_t pkt_mod_bm,
-						    tpm_rule_action_t *rule_action)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, api_rng_entries = 0;
-	uint32_t l_rule_idx = 0, bi_dir = 0;
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_pnc_ranges_t range_id = 0;
-	tpm_db_pon_type_t pon_type = 0;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-
-	uint32_t subflow_bm, subflow_id, protocol = 0, is_pppoe;
-	tpm_ipv6_gen_acl_key_t gen_key;
-	tpm_ipv6_addr_key_t dip_key;
-	long long int_pkt_act = 0;
-
-	memset(&gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_dir(%d), rule_num(%d)\n", owner_id, src_dir, rule_num);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipv6_l4_ports_5t_check(owner_id, src_dir, rule_num, parse_rule_bm, parse_flags_bm,
-											l4_key, pkt_frwd, pkt_mod_bm, pkt_mod, rule_action);
-	IF_ERROR(ret_code);
-
-	/* Get pon_type */
-	tpm_db_pon_type_get(&pon_type);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_L4_ACL, &range_id);
-
-
-	/*********** Remove Current Entries **********/
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_L4, &range_data);
-
-	if (TPM_RANGE_TYPE_TABLE == range_data.pnc_range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_L4_ACL, rule_num, &l_rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_num(%d) already exists\n", owner_id, rule_num);
-
-			ret_code = tpm_proc_del_ipv6_l4_ports_5t_rule(owner_id, rule_num, TPM_INT_CALL);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*********** Create Subflow Entries **********/
-	subflow_bm = parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-	if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-			protocol = IPPROTO_TCP;
-		else
-			protocol = IPPROTO_UDP;
-		subflow_bm |= TPM_IPv6_PARSE_NH;
-	}
-	subflow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-	if (rule_action->next_phase == STAGE_CTC_CM) {
-		/* do not touch sub-flow AI, because they are for UNI also */
-		int_pkt_act |= TPM_ACTION_UNSET_CNM_IPV4 | TPM_ACTION_UNSET_IPV4_PRE_KEY;
-	} else if (subflow_bm != 0 && rule_action->next_phase != STAGE_DONE) {
-		int_pkt_act |= TPM_ACTION_SET_IPV6_SUBFLOW;
-
-		subflow_id = tpm_db_get_free_ipv6_l4_subflow(src_dir);
-		if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-			return ERR_IPV6_5T_FLOW_AI_BITS_EXHAUSED;
-	} else {
-		int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-	}
-
-	/*********** Create Modification Entries **********/
-	/* if split mod stage-2 */
-	if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) &&
-		VLANOP_SPLIT_MOD_PBIT == pkt_mod->vlan_mod.vlan_op &&
-		(pkt_mod_bm == TPM_VLAN_MOD)) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod stage-2\n");
-
-		if (tpm_proc_trg_port_gmac_map(pkt_frwd->trg_port, &trg_gmac)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "tpm_proc_trg_port_gmac_map failed \n");
-			return(ERR_MOD_INVALID);
-		} else if (trg_gmac == TPM_INVALID_GMAC) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Target gmac invalid (%d) \n", trg_gmac);
-			return(ERR_MOD_INVALID);
-		}
-
-		/* get mod index from p-bit value */
-		int_ret_code = tpm_db_split_mod_get_index_by_p_bits(pkt_mod->vlan_mod.vlan1_out.pbit, &mod_entry);
-		if (TPM_DB_OK != int_ret_code) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "split mod stage-2, illeagal p-bit value: %d\n",
-				pkt_mod->vlan_mod.vlan1_out.pbit);
-			return ERR_MOD_INVALID;
-		}
-
-		/* the first PMT is for p-bit AS-IS */
-		mod_entry++;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Modification mod_cmd(%d)\n", mod_entry);
-	} else {
-		ret_code =
-		tpm_proc_create_mod(rule_action->pkt_act, pkt_frwd->trg_port, pkt_mod, pkt_mod_bm, 0 /*int_mod_bm */ ,
-				    &mod_entry, &trg_gmac);
-		IF_ERROR(ret_code);
-	}
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_ipv6_l4_ports_5t_tcam_build(src_dir, rule_num, l4_key,
-							parse_rule_bm, parse_flags_bm, rule_action,
-							pkt_mod, pkt_mod_bm, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	/* Build SRAM Entry */
-	int_ret_code = tpm_proc_ipv6_l4_ports_5t_sram_build(src_dir, rule_num, pon_type, subflow_id,
-							pkt_frwd, rule_action, int_pkt_act,
-							pkt_mod, mod_entry, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	/*** Insert the PNC Entry ***/
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-	    /*** Insert the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_acl_pnc_entry(TPM_L4_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code =
-		tpm_proc_create_table_pnc_entry(TPM_L4_ACL, rule_num, TPM_FALSE, &pnc_data, &pnc_entry,
-						&api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	if (src_dir == TPM_DIR_DS)
-		api_data.ipv6_l4_key.src_port = TPM_SRC_PORT_WAN;
-	else
-		api_data.ipv6_l4_key.src_port = TPM_SRC_PORT_UNI_ANY;
-	api_data.ipv6_l4_key.parse_rule_bm = parse_rule_bm;
-	api_data.ipv6_l4_key.parse_flags_bm = parse_flags_bm;
-	api_data.ipv6_l4_key.pkt_mod_bm = pkt_mod_bm;
-
-	memcpy(&(api_data.ipv6_l4_key.rule_action), rule_action, sizeof(tpm_rule_action_t));
-	if (l4_key)
-		memcpy(&(api_data.ipv6_l4_key.l4_key), l4_key, sizeof(tpm_l4_ports_key_t));
-
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.ipv6_l4_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.ipv6_l4_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	if (pkt_mod != NULL)
-		memcpy(&(api_data.ipv6_l4_key.pkt_mod), pkt_mod, sizeof(tpm_pkt_mod_t));
-	else
-		memset(&(api_data.ipv6_l4_key.pkt_mod), 0, sizeof(tpm_pkt_mod_t));
-
-	/* Set modification data */
-	tpm_proc_set_api_moddata(rule_action->pkt_act, trg_gmac, &mod_con, mod_entry);
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-	if (TPM_RANGE_TYPE_ACL == range_data.pnc_range_conf.range_type) {
-		if (rule_num < api_rng_entries) {
-			int_ret_code = tpm_proc_api_entry_rulenum_inc(TPM_L4_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	int_ret_code = tpm_db_api_entry_set(TPM_L4_ACL, rule_num, 0 /*bi_dir */ ,
-					    &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(int_ret_code);
-
-	/* Set 5T Flow Entry */
-	if (subflow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-		int_ret_code = tpm_db_set_ipv6_l4_subflow(src_dir, subflow_id, subflow_bm, protocol, l4_key);
-		IF_ERROR(int_ret_code);
-	}
-	if (rule_action->next_phase == STAGE_DONE) {
-		if (subflow_bm != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-				is_pppoe = TPM_TRUE;
-			else
-				is_pppoe = TPM_FALSE;
-			int_ret_code = tpm_db_set_ipv6_5t_flow(src_dir, subflow_bm, is_pppoe, protocol, l4_key, &gen_key, &dip_key);
-			IF_ERROR(int_ret_code);
-		}
-	}
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	return(TPM_RC_OK);
-}
-
-
-tpm_error_code_t tpm_proc_int_del_5t_rule(tpm_api_type_t api_type, tpm_proc_common_int_del_func_t int_del_func,
-					  uint32_t busy_check, uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code, busy_ret_code = TPM_RC_OK;
-
-	/* Check API_type busy */
-	if (TPM_TRUE == busy_check) {
-		ret_code = tpm_proc_check_api_busy(api_type, rule_idx);
-		IF_ERROR(ret_code);
-	}
-
-	/* Call internal function */
-	ret_code = (*int_del_func)(owner_id, rule_idx);
-
-	/* Free API_type */
-	if (TPM_TRUE == busy_check)
-		busy_ret_code = tpm_proc_api_busy_done(api_type, rule_idx);
-
-	IF_ERROR(ret_code);
-	IF_ERROR(busy_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_int_del_ipv6_gen_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-	uint32_t rule_num, dummy_idx, src_dir, bi_dir, is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-	tpm_db_pnc_conn_t pnc_con;
-
-	uint32_t parse_rule_bm, parse_flags_bm, flow_bm, flow_id, flow_user, protocol = 0;
-	tpm_rule_action_t rule_action;
-	tpm_l4_ports_key_t *l4_key = NULL;
-	tpm_ipv6_gen_acl_key_t *gen_key = NULL;
-	tpm_ipv6_addr_key_t dip_key;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-	memset(&rule_action, 0, sizeof(rule_action));
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_GEN, &range_data);
-
-	/* Get the rule_num */
-	if (range_data.pnc_range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		ret_code = tpm_db_api_rulenum_get(TPM_IPV6_GEN_ACL, rule_idx, &rule_num);
-		if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-			TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-			return ERR_RULE_IDX_INVALID;
-		}
-	} else
-		rule_num = rule_idx;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-
-	ret_code = tpm_db_api_entry_get(TPM_IPV6_GEN_ACL, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_proc_src_port_dir_map(api_data.ipv6_gen_key.src_port, &src_dir);
-
-	parse_rule_bm = api_data.ipv6_gen_key.parse_rule_bm;
-	parse_flags_bm = api_data.ipv6_gen_key.parse_flags_bm;
-	rule_action = api_data.ipv6_gen_key.rule_action;
-
-	l4_key = &api_data.ipv6_gen_key.l4_key;
-	gen_key = &api_data.ipv6_gen_key.ipv6_gen_key;
-
-
-	flow_bm = parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-	if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-			protocol = IPPROTO_TCP;
-		else
-			protocol = IPPROTO_UDP;
-		flow_bm |= TPM_IPv6_PARSE_NH;
-	}
-	if (flow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-			is_pppoe = TPM_TRUE;
-		else
-			is_pppoe = TPM_FALSE;
-		flow_id = tpm_db_find_matched_ipv6_5t_flow(src_dir, flow_bm, is_pppoe, protocol, l4_key, gen_key, &dip_key);
-		if (flow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-			ret_code = tpm_db_del_ipv6_5t_flow(flow_id);
-			IF_ERROR(ret_code);
-		}
-		if (rule_action.next_phase != STAGE_DONE) {
-			flow_id = tpm_db_find_matched_ipv6_gen_subflow(src_dir, flow_bm, protocol, l4_key, gen_key);
-			if (flow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-				IF_ERROR(ERR_GENERAL);
-
-			flow_user = tpm_db_get_ipv6_gen_subflow_user_num(src_dir, flow_id);
-
-			if (flow_user == 0) {
-				ret_code = tpm_db_del_ipv6_gen_subflow(src_dir, flow_id);
-				IF_ERROR(ret_code);
-			} else {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) is used by other ipv6 flows! \n", rule_num);
-				IF_ERROR(ERR_IPV6_5T_RULE_IN_USE);
-			}
-		}
-	}
-	/* Call generic del function without locking, since locking has already been done */
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV6_GEN_ACL, owner_id, rule_idx, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_gen_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d), ext_call(%d)", owner_id, rule_idx, ext_call);
-
-	ret_code = tpm_proc_int_del_5t_rule(TPM_API_IPV6_GEN, &tpm_proc_int_del_ipv6_gen_5t_rule,
-					    ext_call, owner_id, rule_idx);
-	return(ret_code);
-}
-
-
-tpm_error_code_t tpm_proc_int_del_ipv6_dip_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-	uint32_t rule_num, dummy_idx, src_dir, bi_dir, is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = {0, 0};
-	tpm_db_pnc_conn_t pnc_con;
-
-	uint32_t parse_rule_bm, parse_flags_bm, flow_bm, flow_id, protocol = 0;
-	tpm_rule_action_t rule_action;
-	tpm_l4_ports_key_t *l4_key = NULL;
-	tpm_ipv6_gen_acl_key_t *gen_key = NULL;
-	tpm_ipv6_addr_key_t *dip_key = NULL;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-	memset(&rule_action, 0, sizeof(rule_action));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_DIP, &range_data);
-
-	/* Get the rule_num */
-	if (range_data.pnc_range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		ret_code = tpm_db_api_rulenum_get(TPM_IPV6_DIP_ACL, rule_idx, &rule_num);
-		if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-			TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-			return ERR_RULE_IDX_INVALID;
-		}
-	} else
-		rule_num = rule_idx;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-
-	ret_code = tpm_db_api_entry_get(TPM_IPV6_DIP_ACL, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_proc_src_port_dir_map(api_data.ipv6_dip_key.src_port, &src_dir);
-
-	parse_rule_bm = api_data.ipv6_dip_key.parse_rule_bm;
-	parse_flags_bm = api_data.ipv6_dip_key.parse_flags_bm;
-	rule_action = api_data.ipv6_dip_key.rule_action;
-
-	l4_key = &api_data.ipv6_dip_key.l4_key;
-	gen_key = &api_data.ipv6_dip_key.ipv6_gen_key;
-	dip_key = &api_data.ipv6_dip_key.ipv6_dipkey;
-
-
-	flow_bm = parse_rule_bm & (TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK | TPM_IPv6_PARSE_DIP);
-	if (flow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			flow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-			is_pppoe = TPM_TRUE;
-		else
-			is_pppoe = TPM_FALSE;
-		flow_id = tpm_db_find_matched_ipv6_5t_flow(src_dir, flow_bm, is_pppoe, protocol, l4_key, gen_key, dip_key);
-		if (flow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-			ret_code = tpm_db_del_ipv6_5t_flow(flow_id);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Call generic del function without locking, since locking has already been done */
-	ret_code = tpm_proc_del_acl_rule(TPM_IPV6_DIP_ACL, owner_id, rule_idx, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_dip_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d), ext_call(%d)", owner_id, rule_idx, ext_call);
-
-	ret_code = tpm_proc_int_del_5t_rule(TPM_IPV6_DIP_ACL, &tpm_proc_int_del_ipv6_dip_5t_rule,
-					    ext_call, owner_id, rule_idx);
-	return(ret_code);
-}
-
-tpm_error_code_t tpm_proc_int_del_ipv6_l4_ports_5t_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-	uint32_t rule_num, dummy_idx, src_dir, bi_dir, is_pppoe;
-	tpm_db_pnc_range_t range_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-	tpm_db_pnc_conn_t pnc_con;
-
-	uint32_t parse_rule_bm, parse_flags_bm, flow_bm, flow_id, flow_user, protocol = 0;
-	tpm_rule_action_t rule_action;
-	tpm_l4_ports_key_t *l4_key = NULL;
-	tpm_ipv6_gen_acl_key_t gen_key;
-	tpm_ipv6_addr_key_t dip_key;
-
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-	memset(&rule_action, 0, sizeof(rule_action));
-	memset(&gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-	memset(&dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_idx);
-
-	tpm_db_pnc_rng_get(TPM_PNC_IPV6_L4, &range_data);
-
-	/* Get the rule_num */
-	if (range_data.pnc_range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		ret_code = tpm_db_api_rulenum_get(TPM_L4_ACL, rule_idx, &rule_num);
-		if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-			TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-			return ERR_RULE_IDX_INVALID;
-		}
-	} else
-		rule_num = rule_idx;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-
-	ret_code = tpm_db_api_entry_get(TPM_L4_ACL, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	tpm_proc_src_port_dir_map(api_data.ipv6_l4_key.src_port, &src_dir);
-
-	parse_rule_bm = api_data.ipv6_l4_key.parse_rule_bm;
-	parse_flags_bm = api_data.ipv6_l4_key.parse_flags_bm;
-	rule_action = api_data.ipv6_l4_key.rule_action;
-
-	l4_key = &api_data.ipv6_l4_key.l4_key;
-
-
-	flow_bm = parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-	if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-			protocol = IPPROTO_TCP;
-		else
-			protocol = IPPROTO_UDP;
-		flow_bm |= TPM_IPv6_PARSE_NH;
-	}
-	if (flow_bm != 0) {
-		if ((parse_flags_bm & TPM_PARSE_FLAG_PPPOE_TRUE) != 0)
-			is_pppoe = TPM_TRUE;
-		else
-			is_pppoe = TPM_FALSE;
-		flow_id = tpm_db_find_matched_ipv6_5t_flow(src_dir, flow_bm, is_pppoe, protocol, l4_key, &gen_key, &dip_key);
-		if (flow_id != TPM_DB_INVALID_IPV6_FLOW_ID) {
-			ret_code = tpm_db_del_ipv6_5t_flow(flow_id);
-			IF_ERROR(ret_code);
-		}
-		if (rule_action.next_phase != STAGE_DONE) {
-			flow_id = tpm_db_find_matched_ipv6_l4_subflow(src_dir, flow_bm, protocol, l4_key);
-			if (flow_id == TPM_DB_INVALID_IPV6_FLOW_ID)
-				IF_ERROR(ERR_GENERAL);
-
-			flow_user = tpm_db_get_ipv6_l4_subflow_user_num(src_dir, flow_id);
-
-			if (flow_user == 0) {
-				ret_code = tpm_db_del_ipv6_l4_subflow(src_dir, flow_id);
-				IF_ERROR(ret_code);
-			} else {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_num(%d) is used by other ipv6 flows! \n", rule_num);
-				IF_ERROR(ERR_IPV6_5T_RULE_IN_USE);
-			}
-		}
-	}
-
-	/* Call generic del function without locking, since locking has already been done */
-	ret_code = tpm_proc_del_acl_rule(TPM_L4_ACL, owner_id, rule_idx, TPM_FALSE);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_l4_ports_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d), ext_call(%d)", owner_id, rule_idx, ext_call);
-
-	ret_code = tpm_proc_int_del_5t_rule(TPM_L4_ACL, &tpm_proc_int_del_ipv6_l4_ports_5t_rule,
-					    ext_call, owner_id, rule_idx);
-	return(ret_code);
-}
-
-
-int32_t tpm_proc_ipv6_mc_tcam_build(tpm_mc_filter_mode_t filter_mode,
-				    uint32_t stream_num,
-				    uint16_t vid,
-				    uint8_t mc_stream_pppoe,
-				    uint8_t ipv6_dst_add[16],
-				    uint8_t sip_index,
-				    uint8_t ignore_sip,
-				    tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t int_ret_code;
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id, ai_bits;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t vid_ai_field;
-	tpm_parse_flags_t parse_flags_bm = 0;
-	long long parse_int_flags_bm = 0;
-
-	tcam_data->l2_parse_bm = 0;
-	tcam_data->l3_parse_bm = 0;
-	tcam_data->ipv4_parse_bm = 0;
-	tcam_data->add_info_mask = 0;
-	tcam_data->add_info_data = 0;
-	tcam_data->ipv6_parse_bm = TPM_IPv6_PARSE_DIP;
-
-	/* src port */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (vid != 0xFFFF) {
-		int_ret_code = tpm_db_mc_vlan_get_ai_bit(vid, &ai_bits);
-		IF_ERROR(int_ret_code);
-
-		vid_ai_field.mc_vid_entry = ai_bits;
-
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_TRUE;
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_PARSE;
-	} else
-		parse_int_flags_bm |= TPM_PARSE_FLAG_MC_VID_FALSE;
-
-	if (mc_stream_pppoe)
-		parse_flags_bm |= TPM_PARSE_FLAG_PPPOE_TRUE;
-	else
-		parse_flags_bm |= TPM_PARSE_FLAG_PPPOE_FALSE;
-
-	if (!ignore_sip) {
-		parse_int_flags_bm |= TPM_PARSE_FLAG_IPV6_MC_SIP_PARSE;
-		vid_ai_field.ipv6_mc_sip_indx = sip_index;
-	}
-
-	/* Update the AI bits */
-	tpm_proc_parse_flag_ai_tcam_build(&vid_ai_field, parse_flags_bm, parse_int_flags_bm, &(tcam_data->add_info_data),
-					  &(tcam_data->add_info_mask));
-
-	/* Copy in logical PnC Key */
-	memcpy(tcam_data->pkt_key.ipv6_dip_key.ipv6_ip_add, ipv6_dst_add, 16 * sizeof(uint8_t));
-	memset(tcam_data->pkt_key.ipv6_dip_key.ipv6_ip_add_mask, 0xff, 16);
-
-	/* Get PNC Range information */
-	int_ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_MC_DS, &lu_id, &start_offset);
-	IF_ERROR(int_ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&tcam_data->start_offset, &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_ipv6_mc_sip_entry_create(uint32_t sip_index, uint8_t *ipv6_src_add)
-{
-	int32_t int_ret_code;
-	uint32_t pnc_entry, lu_id;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-	tpm_gmac_bm_t gmac_bm;
-	uint8_t ipv6_src_zero[16];
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&ipv6_src_zero, 0, sizeof(ipv6_src_zero));
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	IF_ERROR(int_ret_code);
-	lu_id = range_data.pnc_range_conf.base_lu_id;
-
-	pnc_entry = range_data.pnc_range_conf.range_start + sip_index;
-
-	/* Set common TCAM params */
-	/* Get PNC Range information */
-	int_ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_MC_SIP, &lu_id, &start_offset);
-	IF_ERROR(int_ret_code);
-	pnc_data.pncl_tcam.lu_id = lu_id;
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	memcpy(&(pnc_data.pncl_tcam.start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-	pnc_data.pncl_tcam.ipv6_parse_bm = TPM_IPv6_PARSE_SIP;
-
-	/* Set common SRAM params */
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_DIP;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_IPV6_DIP_REG;
-	pnc_data.pncl_sram.next_lu_off_reg = TPM_PNC_IPV6_DIP_REG; /* lookup reg 6 */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_DS, &range_data);
-	IF_ERROR(int_ret_code);
-	pnc_data.pncl_sram.next_lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	/* Double check - check only packets that are MC */
-	pnc_data.pncl_tcam.add_info_data = (1 << TPM_AI_MC_VID_VALID_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_MC_VID_VALID_MASK;
-
-	if (0 == memcmp(ipv6_src_zero, ipv6_src_add, sizeof(ipv6_src_zero))) {
-		/* this is the default rule */
-		pnc_data.pncl_sram.add_info_data &= ~(TPM_AI_IPV6_MC_SIP_PART1_MASK);
-		pnc_data.pncl_sram.add_info_data &= ~(TPM_AI_IPV6_MC_SIP_PART2_MASK);
-	} else {
-		/* update MC_SIP AI to sip_index */
-		pnc_data.pncl_sram.add_info_data |= ((sip_index << TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF)& TPM_AI_IPV6_MC_SIP_PART1_MASK);
-		pnc_data.pncl_sram.add_info_data |= (((sip_index >> (TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF + 1))
-			<< TPM_AI_IPV6_MC_SIP_PART2_BIT_OFF)& TPM_AI_IPV6_MC_SIP_PART2_MASK);
-		memcpy(pnc_data.pncl_tcam.pkt_key.ipv6_gen_key.ipv6_src_ip_add, ipv6_src_add, 16);
-		memset(pnc_data.pncl_tcam.pkt_key.ipv6_gen_key.ipv6_src_ip_add_mask, 0xff, 16);
-
-		pnc_entry--;
-	}
-
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_IPV6_MC_SIP_PART1_MASK;
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_IPV6_MC_SIP_PART2_MASK;
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV6_MC_SIP, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	return TPM_RC_OK;
-}
-int32_t tpm_proc_ipv6_mc_sip_entry_del(uint32_t sip_index)
-{
-	int32_t int_ret_code;
-	uint32_t pnc_entry;
-	tpm_db_pnc_range_t range_data;
-
-	/* Get Range data */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	IF_ERROR(int_ret_code);
-
-	pnc_entry = range_data.pnc_range_conf.range_start + sip_index - 1;
-
-	/* del Entry in PnC */
-	int_ret_code = tpm_pncl_entry_reset(pnc_entry);
-	IF_ERROR(int_ret_code);
-
-	/* Increase number of free entries in pnc_range */
-	int_ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_IPV6_MC_SIP);
-	IF_ERROR(int_ret_code);
-
-	return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						uint32_t stream_num,
-						tpm_mc_igmp_mode_t igmp_mode,
-						uint8_t mc_stream_pppoe,
-						uint16_t vid,
-						uint8_t ipv6_src_add[16],
-						uint8_t ipv6_dst_add[16],
-						uint8_t ignore_ipv6_src,
-						uint16_t dest_queue,
-						uint32_t dest_port_bm)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_range_t range_data;
-	tpm_db_ipv6_mc_stream_entry_t mc_stream;
-	tpm_mc_vid_port_cfg_t *mc_vid_cfg = NULL;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, rule_num = 0xffff;
-	uint32_t pnc_range_start = 0, api_start = 0, rule_idx = 0;
-	uint32_t entry_id;
-	uint16_t u4_vid;
-	int32_t  sip_index = 0;
-	tpm_gmacs_enum_t gmac;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	/*********** Create Modification Entries **********/
-	ret_code =
-	tpm_proc_create_ipvx_mc_mod(filter_mode, igmp_mode, mc_stream_pppoe, vid, ipv6_dst_add,
-				    dest_port_bm, &mod_entry, TPM_IP_VER_6);
-	IF_ERROR(ret_code);
-
-	/* Handle IPv6 SSM */
-	if (0 == ignore_ipv6_src) {
-		/* get index of this IPv6 MC SIP */
-		sip_index = tpm_db_ipv6_mc_sip_index_get(ipv6_src_add);
-		if (0 == sip_index) {
-			/* this is a new SIP, add into DB */
-			sip_index = tpm_db_ipv6_mc_sip_add(ipv6_src_add);
-
-			/* create PNC entry in range TPM_PNC_IPV6_MC_SIP */
-			ret_code = tpm_proc_ipv6_mc_sip_entry_create(sip_index, ipv6_src_add);
-
-		} else {
-			/* this is a exising SIP, add reference number in DB */
-			ret_code = tpm_db_ipv6_mc_sip_ref_num_inc(sip_index);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code =
-	tpm_proc_ipv6_mc_tcam_build(filter_mode, stream_num, vid, mc_stream_pppoe,
-				    ipv6_dst_add, sip_index, ignore_ipv6_src, &(pnc_data.pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code =
-	tpm_proc_ipvx_mc_sram_build(filter_mode, igmp_mode,
-				    dest_queue, dest_port_bm,
-				    mod_entry, &(pnc_data.pncl_sram),
-				    TPM_IP_VER_6);
-	IF_ERROR(ret_code);
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_DS, &range_data);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_entry = (pnc_range_start + api_start) + stream_num;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " stream_num(%d), pnc_entry(%d)\n", stream_num, pnc_entry);
-
-	ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-	IF_ERROR(ret_code);
-
-	/* Decrease number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_IPV6_MC_DS);
-	IF_ERROR(ret_code);
-
-	/*********** Update API Range in DB **********/
-
-	/* Set API data */
-	memcpy(api_data.ipv6_mc_key.ipv6_dest_add, ipv6_dst_add, 16 * sizeof(uint8_t));
-	memcpy(api_data.ipv6_mc_key.ipv6_src_add, ipv6_src_add, 16 * sizeof(uint8_t));
-	api_data.ipv6_mc_key.dest_port_bm = dest_port_bm;
-	api_data.ipv6_mc_key.dest_queue = dest_queue;
-	api_data.ipv6_mc_key.vid = vid;
-	api_data.ipv6_mc_key.igmp_mode = igmp_mode;
-	api_data.ipv6_mc_key.mc_stream_pppoe = mc_stream_pppoe;
-	api_data.ipv6_mc_key.stream_num = stream_num;
-	api_data.ipv6_mc_key.ignore_ipv6_src = ignore_ipv6_src;
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = TPM_PNC_IPV6_MC_DS;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	/* Set Modification Connection data */
-	mod_con.mod_cmd_ind = mod_entry;
-	if (mod_entry) {
-		ret_code = tpm_db_target_to_gmac(pnc_data.pncl_sram.flow_id_sub.pnc_target, &gmac);
-		IF_ERROR(ret_code);
-		mod_con.mod_cmd_mac = gmac;
-	}
-
-	/* Set new API Entry */
-	ret_code = tpm_db_api_entry_set(TPM_IPV6_MC_ACL, stream_num, 0 /*bi_dir */ ,
-					&api_data, &mod_con, &pnc_conn, &rule_idx);
-	IF_ERROR(ret_code);
-
-	if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0 && (dest_port_bm & TPM_TRG_UNI_VIRT) != 0) {
-			ret_code = tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg);
-			IF_ERROR(ret_code);
-
-			for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-				if (mc_vid_cfg[entry_id].tpm_src_port == TPM_SRC_PORT_UNI_VIRT)
-					break;
-			}
-			if (entry_id == TPM_MAX_NUM_UNI_PORTS) {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-						 " virt_uni is unable to join the group when "
-						 "virt_uni is not the member of multicast vlan \n");
-			} else if (mc_vid_cfg[entry_id].mc_uni_port_mode != TPM_MC_UNI_MODE_EXCLUDE) {
-				if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSPARENT)
-					u4_vid = vid;
-				else if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP)
-					u4_vid = 0xffff;
-				else
-					u4_vid = mc_vid_cfg[entry_id].uni_port_vid;
-
-				ret_code = tpm_db_mc_alloc_virt_uni_entry(&rule_num);
-				IF_ERROR(ret_code);
-
-				ret_code =
-				tpm_proc_mc_create_virt_uni_pnc_entry(rule_num, u4_vid, ipv6_dst_add, true);
-				IF_ERROR(ret_code);
-			}
-		}
-	}
-
-	/* Set new stream entry */
-	mc_stream.igmp_mode = igmp_mode;
-	mc_stream.mc_stream_pppoe = mc_stream_pppoe;
-	mc_stream.vid = vid;
-	mc_stream.dest_queue = dest_queue;
-	mc_stream.dest_port_bm = dest_port_bm;
-	mc_stream.u4_entry = rule_num;
-	mc_stream.ignore_src_addr = ignore_ipv6_src;
-	memcpy(mc_stream.group_addr, ipv6_dst_add, 16 * sizeof(uint8_t));
-	memcpy(mc_stream.src_addr, ipv6_src_add, 16 * sizeof(uint8_t));
-
-	ret_code = tpm_db_set_ipv6_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_add_ipv6_mc_stream(uint32_t owner_id,
-					     uint32_t stream_num,
-					     tpm_mc_igmp_mode_t igmp_mode,
-					     uint8_t mc_stream_pppoe,
-					     uint16_t vid,
-					     uint8_t ipv6_src_add[16],
-					     uint8_t ipv6_dst_add[16],
-					     uint8_t ignore_ipv6_src,
-					     uint16_t dest_queue,
-					     tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-	tpm_init_virt_uni_t virt_uni;
-
-	memset(&virt_uni, 0, sizeof(tpm_init_virt_uni_t));
-
-	/*
-	filter_mode = tpm_db_get_mc_filter_mode();
-	right now we only have TPM_MC_COMBINED_IP_MAC_FILTER mode
-	*/
-	filter_mode = TPM_MC_COMBINED_IP_MAC_FILTER;
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_UNI_ANY)
-		dest_port_bm = tpm_db_trg_port_uni_any_bmp_get(true);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_ipvx_mc_check(owner_id, stream_num, igmp_mode, mc_stream_pppoe, vid,
-						  ipv6_src_add, ipv6_dst_add, ignore_ipv6_src,
-						  dest_queue, dest_port_bm, filter_mode, TPM_IP_VER_6);
-	IF_ERROR(ret_code);
-
-	/* get queue number */
-	if (dest_queue == TPM_INVALID_QUEUE) {
-		if (dest_port_bm & TPM_TRG_PORT_CPU)
-			dest_queue = tpm_db_get_mc_cpu_queue();
-		else
-			dest_queue = tpm_db_get_mc_hwf_queue();
-	}
-	/* Create PNC entry */
-	ret_code = tpm_proc_add_ipv6_mc_pnc_entry(filter_mode, stream_num, igmp_mode, mc_stream_pppoe, vid,
-						  ipv6_src_add, ipv6_dst_add, ignore_ipv6_src,
-						  dest_queue, dest_port_bm);
-	IF_ERROR(ret_code);
-
-	/* Set switch port_map for multicast MAC, but don't overwrite FF02::1 (MLD General Query) MAC */
-	MULTI_IPV6_2_MAC(mc_mac, ipv6_dst_add);
-	if (memcmp(mc_mac, tpm_mld_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, 0, dest_port_bm);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_delete_ipvx_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						   uint32_t stream_num,
-						   uint32_t dest_port_bm,
-						   uint32_t u4_entry,
-						   tpm_ip_ver_t ip_version)
-{
-	tpm_db_pnc_range_t range_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_ipv6_mc_stream_entry_t mc_stream;
-
-	int32_t ret_code;
-	uint32_t bi_dir = 0, rule_idx = 0;
-	uint32_t pnc_range_start = 0, api_start = 0, pnc_entry = 0;
-	uint32_t sip_index = 0;
-	uint8_t	 new_ref_num = 0;
-	tpm_pnc_ranges_t range;
-	tpm_api_sections_t api_section;
-
-	if (TPM_IP_VER_4 == ip_version) {
-		range = TPM_PNC_IPV4_MC_DS;
-		api_section = TPM_IPV4_MC;
-	} else {
-		range = TPM_PNC_IPV6_MC_DS;
-		api_section = TPM_IPV6_MC_ACL;
-	}
-
-	if (filter_mode != TPM_MC_MAC_ONLY_FILTER) {
-		/* Get PNC Range Start */
-		ret_code = tpm_db_pnc_rng_get(range, &range_data);
-		IF_ERROR(ret_code);
-
-		if (stream_num >= range_data.pnc_range_conf.range_size)
-			IF_ERROR(ERR_MC_STREAM_INVALID);
-
-		/* Check parameters */
-		ret_code = tpm_db_api_entry_get(api_section, stream_num, &rule_idx, &bi_dir,
-						&api_data, &mod_con, &pnc_conn);
-		IF_ERROR(ret_code);
-
-		/* Delete PNC Entry */
-#if 0
-		ret_code = tpm_proc_pnc_con_del(&pnc_conn);
-		IF_ERROR(ret_code);
-#endif
-		pnc_range_start = range_data.pnc_range_conf.range_start;
-		api_start = range_data.pnc_range_conf.api_start;
-
-		/* Pull range from this index untill last used entry in Pnc range */
-		pnc_entry = (pnc_range_start + api_start) + stream_num;
-
-		/* Delete PNC entry */
-		ret_code = tpm_pncl_entry_delete(pnc_entry, pnc_entry);
-		IF_ERROR(ret_code);
-
-		/* Increase number of free entries in pnc_range */
-		ret_code = tpm_db_pnc_rng_free_ent_inc(range);
-		IF_ERROR(ret_code);
-
-		if (mod_con.mod_cmd_ind != 0) {
-			ret_code = tpm_proc_delete_mod(TPM_MOD_OWNER_TPM, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-			IF_ERROR(ret_code);
-		}
-
-		/* Delete API Rule Entry */
-		ret_code = tpm_db_api_entry_invalidate(api_section, stream_num);
-		IF_ERROR(ret_code);
-
-
-		if (TPM_IP_VER_6 == ip_version) {
-			/* remove SIP PNC entry */
-			ret_code = tpm_db_get_ipv6_mc_stream_entry(stream_num, &mc_stream);
-			IF_ERROR(ret_code);
-			if (0 == mc_stream.ignore_src_addr) {
-				/* get index of this IPv6 MC SIP */
-				sip_index = tpm_db_ipv6_mc_sip_index_get(mc_stream.src_addr);
-				if (0 == sip_index) {
-					/* SIP is not in DB, error */
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, "get index of IPv6 MC SIP failed!\n");
-					return(ERR_IPV6_MC_SRC_IP_INVALID);
-				}
-
-				/* dec reference number in DB */
-				ret_code = tpm_db_ipv6_mc_sip_ref_num_dec(sip_index, &new_ref_num);
-				IF_ERROR(ret_code);
-
-				/* if new ref num is 0, remove this SIP in PNC */
-				if (new_ref_num == 0) {
-					ret_code = tpm_proc_ipv6_mc_sip_entry_del(sip_index);
-					IF_ERROR(ret_code);
-				}
-			}
-		}
-
-	}
-
-	if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0) {
-			if (u4_entry != 0xffff) {
-				ret_code = tpm_proc_mc_delete_virt_uni_pnc_entry(u4_entry);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_db_mc_free_virt_uni_entry(u4_entry);
-				IF_ERROR(ret_code);
-			}
-		}
-	}
-
-	/* Remove stream entry */
-	if (TPM_IP_VER_4 == ip_version)
-		tpm_db_reset_mc_stream_entry(stream_num);
-	else
-		tpm_db_reset_ipv6_mc_stream_entry(stream_num);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_update_ipv6_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						   uint32_t stream_num,
-						   tpm_mc_igmp_mode_t igmp_mode,
-						   uint8_t mc_stream_pppoe,
-						   uint16_t vid,
-						   uint8_t ipv6_dst_add[16],
-						   uint8_t sip_index,
-						   uint8_t ignore_sip,
-						   uint16_t dest_queue,
-						   uint32_t dest_port_bm)
-{
-	tpm_db_pnc_range_t range_data;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_ipv6_mc_stream_entry_t mc_stream;
-	tpm_mc_vid_port_cfg_t *mc_vid_cfg = NULL;
-
-	int32_t ret_code;
-	uint32_t bi_dir = 0, rule_idx = 0, pnc_entry = 0, mod_entry = 0, rule_num = 0xffff;
-	uint32_t entry_id;
-	uint16_t u4_vid;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_ipv6_mc_stream_entry_t));
-
-	/* Get old API Entry */
-	ret_code = tpm_db_api_entry_get(TPM_IPV6_MC_ACL, stream_num, &rule_idx, &bi_dir,
-					&api_data, &mod_con, &pnc_conn);
-	IF_ERROR(ret_code);
-
-	/* Only MC_IP_ONLY_FILTER mode, update the multicast group member ports by mh_mod. */
-	if (filter_mode == TPM_MC_IP_ONLY_FILTER) {
-		/* Get PNC Range Start */
-		ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_DS, &range_data);
-		IF_ERROR(ret_code);
-
-		if (stream_num >= range_data.pnc_range_conf.range_size)
-			IF_ERROR(ERR_MC_STREAM_INVALID);
-
-		pnc_entry = pnc_conn.pnc_conn_tbl[0].pnc_index;
-
-		/* Create new Modification Entry */
-		ret_code = tpm_proc_create_ipvx_mc_mod(filter_mode, igmp_mode, mc_stream_pppoe,
-						       vid, ipv6_dst_add, dest_port_bm, &mod_entry, TPM_IP_VER_6);
-		IF_ERROR(ret_code);
-
-		/* Rebuild PnC Entry */
-		ret_code = tpm_proc_ipv6_mc_tcam_build(filter_mode, stream_num, vid, mc_stream_pppoe,
-						       ipv6_dst_add, sip_index, ignore_sip, &(pnc_data.pncl_tcam));
-		IF_ERROR(ret_code);
-
-		/* Rebuild SRAM Entry */
-		ret_code =
-		tpm_proc_ipvx_mc_sram_build(filter_mode, igmp_mode, dest_queue,
-					dest_port_bm, mod_entry, &(pnc_data.pncl_sram),
-					TPM_IP_VER_6);
-		IF_ERROR(ret_code);
-
-		/* Update only Sram of PNC Entry */
-		ret_code = tpm_pncl_update_sram(pnc_entry, &pnc_data);
-		IF_ERROR(ret_code);
-
-		/* Delete old Modification Entry */
-		if (mod_con.mod_cmd_ind != 0) {
-			ret_code = tpm_proc_delete_mod(TPM_MOD_OWNER_TPM, mod_con.mod_cmd_mac, mod_con.mod_cmd_ind);
-			IF_ERROR(ret_code);
-		}
-
-		/* Update new Modification Entry */
-		mod_con.mod_cmd_ind = mod_entry;
-	}
-
-	if (filter_mode == TPM_MC_COMBINED_IP_MAC_FILTER) {
-		if (tpm_db_get_mc_per_uni_vlan_xlate() != 0) {
-			ret_code = tpm_db_get_ipv6_mc_stream_entry(stream_num, &mc_stream);
-			IF_ERROR(ret_code);
-
-			rule_num = mc_stream.u4_entry;
-
-			if ((dest_port_bm & TPM_TRG_UNI_VIRT) != 0 && (mc_stream.dest_port_bm & TPM_TRG_UNI_VIRT) == 0) {
-				ret_code = tpm_db_mc_alloc_virt_uni_entry(&rule_num);
-				IF_ERROR(ret_code);
-
-				ret_code = tpm_db_get_mc_vid_cfg(vid, &mc_vid_cfg);
-				IF_ERROR(ret_code);
-
-				for (entry_id = 0; entry_id < TPM_MAX_NUM_UNI_PORTS; entry_id++) {
-					if (mc_vid_cfg[entry_id].tpm_src_port == TPM_SRC_PORT_UNI_VIRT)
-						break;
-				}
-				if (entry_id == TPM_MAX_NUM_UNI_PORTS) {
-					TPM_OS_DEBUG(TPM_TPM_LOG_MOD,
-						     " virt_uni is unable to join the group when "
-						     "virt_uni is not the member of multicast vlan \n");
-				} else {
-					if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_TRANSPARENT)
-						u4_vid = vid;
-					else if (mc_vid_cfg[entry_id].mc_uni_port_mode == TPM_MC_UNI_MODE_STRIP)
-						u4_vid = 0xffff;
-					else
-						u4_vid = mc_vid_cfg[entry_id].uni_port_vid;
-
-					ret_code =
-					tpm_proc_mc_create_virt_uni_pnc_entry(rule_num, u4_vid, ipv6_dst_add, true);
-					IF_ERROR(ret_code);
-				}
-			} else if ((dest_port_bm & TPM_TRG_UNI_VIRT) == 0 && (mc_stream.dest_port_bm & TPM_TRG_UNI_VIRT) != 0) {
-				if (rule_num != 0xffff) {
-					ret_code = tpm_proc_mc_delete_virt_uni_pnc_entry(rule_num);
-					IF_ERROR(ret_code);
-					ret_code = tpm_db_mc_free_virt_uni_entry(rule_num);
-					IF_ERROR(ret_code);
-					rule_num = 0xffff;
-				}
-		}
-		}
-	}
-
-	/* Update stream entry */
-	mc_stream.igmp_mode = igmp_mode;
-	mc_stream.mc_stream_pppoe = mc_stream_pppoe;
-	mc_stream.vid = vid;
-	mc_stream.dest_port_bm = dest_port_bm;
-	mc_stream.u4_entry = rule_num;
-	memcpy(mc_stream.group_addr, ipv6_dst_add, 16 * sizeof(uint8_t));
-
-	ret_code = tpm_db_set_ipv6_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	/* Update API entry */
-	/* Invalidate old API Entry */
-	ret_code = tpm_db_api_entry_invalidate(TPM_IPV6_MC_ACL, stream_num);
-	IF_ERROR(ret_code);
-
-	/* Set new API Entry */
-	api_data.ipv6_mc_key.dest_port_bm = dest_port_bm;
-	ret_code = tpm_db_api_entry_set(TPM_IPV6_MC_ACL, stream_num, 0 /*bi_dir */ ,
-					&api_data, &mod_con, &pnc_conn, &rule_idx);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_updt_ipv6_mc_stream(uint32_t owner_id, uint32_t stream_num, tpm_trg_port_type_t dest_port_bm)
-{
-	tpm_error_code_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-	tpm_init_virt_uni_t virt_uni;
-	tpm_db_ipv6_mc_stream_entry_t mc_stream;
-	uint8_t sip_index = 0;
-
-	memset(&virt_uni, 0, sizeof(tpm_init_virt_uni_t));
-	memset(&mc_stream, 0, sizeof(tpm_db_mc_stream_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) stream_num(%d),dest_port_bm(0x%x)\n",
-		     owner_id, stream_num, dest_port_bm);
-
-	/*
-	filter_mode = tpm_db_get_mc_filter_mode();
-	right now we only have TPM_MC_COMBINED_IP_MAC_FILTER mode
-	*/
-	filter_mode = TPM_MC_COMBINED_IP_MAC_FILTER;
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	tpm_db_virt_info_get(&virt_uni);
-
-	if (dest_port_bm & TPM_TRG_UNI_VIRT) {
-		if (virt_uni.enabled == 0)
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_CPU) {
-		if (dest_port_bm & (~TPM_TRG_PORT_CPU))
-			IF_ERROR(ERR_MC_DST_PORT_INVALID);
-	}
-
-	if (dest_port_bm & TPM_TRG_PORT_UNI_ANY)
-		dest_port_bm = tpm_db_trg_port_uni_any_bmp_get(true);
-
-	ret_code = tpm_proc_check_dst_uni_port(dest_port_bm);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_get_ipv6_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	if (dest_port_bm == mc_stream.dest_port_bm) {
-		/* nothing changed, return directly */
-		TPM_OS_INFO(TPM_TPM_LOG_MOD, "dest_port_bm does not change, return directly\n");
-		return (TPM_OK);
-	}
-
-	/* get sip_index */
-	if (0 == mc_stream.ignore_src_addr) {
-		/* get index of this IPv6 MC SIP */
-		sip_index = tpm_db_ipv6_mc_sip_index_get(mc_stream.src_addr);
-		if (0 == sip_index) {
-			/* SIP is not in DB, error */
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "get index of IPv6 MC SIP failed!\n");
-			return(ERR_IPV6_MC_SRC_IP_INVALID);
-		}
-	}
-
-	if (((dest_port_bm & TPM_TRG_PORT_CPU) != 0 && (mc_stream.dest_port_bm & TPM_TRG_PORT_CPU) == 0) ||
-	    ((dest_port_bm & TPM_TRG_PORT_CPU) == 0 && (mc_stream.dest_port_bm & TPM_TRG_PORT_CPU) != 0)) {
-		ret_code = tpm_proc_delete_ipvx_mc_pnc_entry(filter_mode, stream_num,
-							     mc_stream.dest_port_bm,
-							     mc_stream.u4_entry,
-							     TPM_IP_VER_6);
-		IF_ERROR(ret_code);
-
-		ret_code = tpm_proc_add_ipv6_mc_pnc_entry(filter_mode, stream_num, mc_stream.igmp_mode,
-							  mc_stream.mc_stream_pppoe, mc_stream.vid,
-							  mc_stream.src_addr, mc_stream.group_addr,
-							  mc_stream.ignore_src_addr, mc_stream.dest_queue,
-							  dest_port_bm);
-	} else {
-		ret_code = tpm_proc_update_ipv6_mc_pnc_entry(filter_mode, stream_num, mc_stream.igmp_mode,
-							     mc_stream.mc_stream_pppoe, mc_stream.vid,
-							     mc_stream.group_addr, sip_index, mc_stream.ignore_src_addr,
-							     mc_stream.dest_queue, dest_port_bm);
-	}
-	IF_ERROR(ret_code);
-
-	/* Set switch port_map for multicast MAC, but don't overwrite FF02::1 (MLD General Query) MAC */
-	MULTI_IPV6_2_MAC(mc_mac, mc_stream.group_addr);
-	if (memcmp(mc_mac, tpm_mld_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, mc_stream.dest_port_bm, dest_port_bm);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_del_ipv6_mc_stream(uint32_t owner_id, uint32_t stream_num)
-{
-
-	int32_t ret_code;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_mac[6];
-	tpm_db_ipv6_mc_stream_entry_t mc_stream;
-
-	memset(&mc_stream, 0, sizeof(tpm_db_ipv6_mc_stream_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) stream_num(%d)\n", owner_id, stream_num);
-
-	/*
-	filter_mode = tpm_db_get_mc_filter_mode();
-	right now we only have TPM_MC_COMBINED_IP_MAC_FILTER mode
-	*/
-	filter_mode = TPM_MC_COMBINED_IP_MAC_FILTER;
-	if (filter_mode == TPM_MC_ALL_CPU_FRWD) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " illegal mc_filter_mod (%d)\n", filter_mode);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	ret_code = tpm_db_get_ipv6_mc_stream_entry(stream_num, &mc_stream);
-	IF_ERROR(ret_code);
-
-	ret_code =
-	tpm_proc_delete_ipvx_mc_pnc_entry(filter_mode, stream_num,
-					  mc_stream.dest_port_bm,
-					  mc_stream.u4_entry,
-					  TPM_IP_VER_6);
-	IF_ERROR(ret_code);
-
-	/* Set switch VID and multicast MAC */
-	MULTI_IPV6_2_MAC(mc_mac, mc_stream.group_addr);
-	/* Set switch port_map for multicast MAC, but don't overwrite FF02::1 (MLD General Query) MAC */
-	if (memcmp(mc_mac, tpm_mld_gen_query_mac, 6) != 0) {
-		ret_code = tpm_proc_set_ipv4_mc_switch(filter_mode, mc_mac, mc_stream.dest_port_bm, 0);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_ipv6_hoplimit_init(uint32_t hoplimit_illegal_action)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, hoplimit_lu;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-	int32_t cpu_rx_queue;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "hoplimit_illegal_action(%d)\n", hoplimit_illegal_action);
-
-	/* Get default CPU Rx queue */
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_HOPL, &range_data);
-	IF_ERROR(int_ret_code);
-	hoplimit_lu = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start;
-
-	/* Set common TCAM params */
-	pnc_data.pncl_tcam.lu_id = hoplimit_lu;
-	pnc_data.pncl_tcam.port_ids = tpm_proc_all_gmac_bm();
-	pnc_data.pncl_tcam.start_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_tcam.start_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_VER;
-	pnc_data.pncl_tcam.pkt_key.ipv6_add_key.ipv6_hopl = 0;
-
-	/* Set common SRAM params */
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_VER;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_LUD;
-
-	/***********************/
-	/* Create HopLimit=0   */
-	/***********************/
-	/* Parse the HopLimit  */
-	pnc_data.pncl_tcam.ipv6_parse_bm = TPM_IPv6_PARSE_HOPL;
-
-	/* Double check - check only packets that are MTM */
-	pnc_data.pncl_tcam.add_info_data = (1 << TPM_AI_MTM_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_MTM_MASK;
-
-	/* Packet forwarded to CPU */
-	pnc_data.pncl_sram.sram_updt_bm = TPM_PNCL_SET_TXP;
-	pnc_data.pncl_sram.pnc_queue = cpu_rx_queue;
-	pnc_data.pncl_sram.flow_id_sub.pnc_target = TPM_PNC_TRG_CPU;
-
-	/* or packet is dropped */
-	if (TPM_TTL_ZERO_ACTION_DROP == hoplimit_illegal_action)
-		pnc_data.pncl_sram.sram_updt_bm |= TPM_PNCL_SET_DISC;
-
-	/* Signal the packet is going to CPU */
-	pnc_data.pncl_sram.add_info_data |= (1 << TPM_AI_TO_CPU_BIT_OFF);
-	pnc_data.pncl_sram.add_info_mask |= TPM_AI_TO_CPU_MASK;
-
-	NO_FREE_ENTRIES();
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV6_HOPL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	/***********************/
-	/* Create HopLimit=1   */
-	/***********************/
-	NO_FREE_ENTRIES();
-	/* Build PnC Entry, see HopLimit=0 */
-	pnc_data.pncl_tcam.pkt_key.ipv6_gen_key.hop_limit = 1;
-
-	/* Build SRAM Entry, see HopLimit=0,
-	   but always send to CPU, don't drop */
-	pnc_data.pncl_sram.sram_updt_bm &= (~(TPM_PNCL_SET_DISC));
-
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV6_HOPL, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-	free_entries--;
-	pnc_entry++;
-
-	return(TPM_RC_OK);
-}
-tpm_error_code_t tpm_proc_set_active_wan_check(tpm_gmacs_enum_t active_wan)
-{
-	tpm_gmacs_enum_t active_wan_current;
-	tpm_eth_complex_profile_t profile_id;
-
-	if(!tpm_db_switch_active_wan_en_get()) {
-		TPM_OS_ERROR(TPM_DB_MOD, "current profile does not support switching active wan\n");
-		return ERR_FEAT_UNSUPPORT;
-	}
-
-	active_wan_current = tpm_db_active_wan_get();
-	profile_id = tpm_db_eth_cmplx_profile_get();
-
-	if (active_wan == active_wan_current) {
-		TPM_OS_ERROR(TPM_DB_MOD, "new active wan port should not be the same with current one\n");
-		return ERR_FEAT_UNSUPPORT;
-	}
-
-	if (    ((profile_id == TPM_PON_G1_WAN_G0_INT_SWITCH) || (profile_id == TPM_PON_G1_WAN_G0_SINGLE_PORT))
-	     && ((active_wan == TPM_ENUM_GMAC_1) || (active_wan == TPM_ENUM_PMAC)))
-		;/* OK */
-	else if  (    ((profile_id == TPM_PON_G0_WAN_G1_INT_SWITCH) || (profile_id == TPM_PON_G0_WAN_G1_SINGLE_PORT))
-	           && ((active_wan == TPM_ENUM_GMAC_0) || (active_wan == TPM_ENUM_PMAC)))
-		;/* OK */
-	else {
-		TPM_OS_ERROR(TPM_DB_MOD, "new active wan port is invalid according to current profile id\n");
-		return ERR_FEAT_UNSUPPORT;
-	}
-
-	return TPM_OK;
-}
-tpm_error_code_t tpm_proc_set_active_wan(tpm_gmacs_enum_t active_wan)
-{
-	int32_t db_ret;
-	tpm_error_code_t tpm_ret;
-
-	tpm_ret = tpm_proc_set_active_wan_check(active_wan);
-	if(TPM_OK != tpm_ret) {
-		TPM_OS_ERROR(TPM_DB_MOD, "input active wan is invalid, error code (%d)\n", tpm_ret);
-		return ERR_GENERAL;
-	}
-
-	db_ret = tpm_db_active_wan_set(active_wan);
-	if(TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_DB_MOD, "set current active wan failed(%d)\n", db_ret);
-		return ERR_GENERAL;
-	}
-	/* reset gmac fun */
-	tpm_db_mac_func_set();
-
-	return (TPM_OK);
-}
-
-
-tpm_error_code_t tpm_proc_ipv6_mc_sip_init(void)
-{
-	int32_t int_ret_code;
-	uint32_t sip_index;
-	uint8_t  ipv6_mc[16];
-	tpm_db_pnc_range_t range_data;
-	tpm_pncl_pnc_full_t pnc_data;
-
-	/* Set Structs to zero */
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&ipv6_mc, 0, sizeof(ipv6_mc));
-
-	/* Get Range data */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_MC_SIP, &range_data);
-	IF_ERROR(int_ret_code);
-	pnc_data.pncl_sram.next_lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_sram.sram_updt_bm = 0;
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	sip_index = range_data.pnc_range_conf.range_size - 1;
-
-
-	int_ret_code = tpm_proc_ipv6_mc_sip_entry_create(sip_index, ipv6_mc);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-tpm_error_code_t tpm_proc_ipv6_l4_mc_ds_init(void)
-{
-	int32_t int_ret_code;
-	uint32_t free_entries, pnc_entry, lu_id;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_db_pnc_range_t range_data;
-	tpm_gmac_bm_t gmac_bm;
-
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&start_offset, 0, sizeof(tpm_pncl_offset_t));
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get Range_Id */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_L4_MC_DS, &range_data);
-	IF_ERROR(int_ret_code);
-	lu_id = range_data.pnc_range_conf.base_lu_id;
-
-	/* Get pnc_range tcam_start_entry, and number of free entries */
-	free_entries = range_data.pnc_range_oper.free_entries;
-	pnc_entry = range_data.pnc_range_conf.range_start;
-
-	/* Set common TCAM params */
-	/* Get PNC Range information */
-	int_ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_IPV6_L4, &lu_id, &start_offset);
-	IF_ERROR(int_ret_code);
-	pnc_data.pncl_tcam.lu_id = lu_id;
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &gmac_bm);
-	pnc_data.pncl_tcam.port_ids = gmac_bm;
-	memcpy(&(pnc_data.pncl_tcam.start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	/* Set common SRAM params */
-	pnc_data.pncl_sram.next_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-	pnc_data.pncl_sram.next_offset.offset_sub.ipv6_subf = TPM_IPv6_PARSE_VER;
-	pnc_data.pncl_sram.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	pnc_data.pncl_sram.next_lu_off_reg = TPM_PNC_LU_REG0; /* lookup reg 0 */
-	int_ret_code = tpm_db_pnc_rng_get(TPM_PNC_IPV6_HOPL, &range_data);
-	IF_ERROR(int_ret_code);
-	pnc_data.pncl_sram.next_lu_id = range_data.pnc_range_conf.base_lu_id;
-	pnc_data.pncl_sram.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	/* Double check - check only packets that are MC */
-	pnc_data.pncl_tcam.add_info_data = (1 << TPM_AI_MC_VID_VALID_BIT_OFF);
-	pnc_data.pncl_tcam.add_info_mask = TPM_AI_MC_VID_VALID_MASK;
-
-	NO_FREE_ENTRIES();
-	/* Create Entry in PnC */
-	int_ret_code = tpm_proc_pnc_create(TPM_PNC_IPV6_L4_MC_DS, pnc_entry, &pnc_data);
-	IF_ERROR(int_ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/***************************/
-/**          CNM Functions            **/
-/***************************/
-
-uint8_t tpm_proc_if_ipv4_pre_filter_key_conflict(uint32_t parse_bm_key_a,
-						uint32_t parse_bm_key_b,
-						tpm_ipv4_acl_key_t *key_a,
-						tpm_ipv4_acl_key_t *key_b)
-{
-	uint32_t com_parse_bm = parse_bm_key_a & parse_bm_key_b;
-
-	if (com_parse_bm != 0)
-	{
-		if (com_parse_bm & TPM_IPv4_PARSE_SIP) {
-			if (memcmp(key_a->ipv4_src_ip_add, key_b->ipv4_src_ip_add, 4 * sizeof(uint8_t)) ||
-				memcmp(key_a->ipv4_src_ip_add_mask, key_b->ipv4_src_ip_add_mask, 4 * sizeof(uint8_t)))
-				return TPM_TRUE;
-		}
-		if (com_parse_bm & TPM_IPv4_PARSE_DIP) {
-			if (memcmp(key_a->ipv4_dst_ip_add, key_b->ipv4_dst_ip_add, 4 * sizeof(uint8_t)) ||
-				memcmp(key_a->ipv4_dst_ip_add_mask, key_b->ipv4_dst_ip_add_mask, 4 * sizeof(uint8_t)))
-				return TPM_TRUE;
-		}
-		if (com_parse_bm & TPM_IPv4_PARSE_DSCP) {
-			if ((key_a->ipv4_dscp & key_a->ipv4_dscp_mask) != (key_b->ipv4_dscp & key_b->ipv4_dscp_mask))
-				return TPM_TRUE;
-		}
-		if (com_parse_bm & TPM_IPv4_PARSE_PROTO) {
-			if (key_a->ipv4_proto != key_b->ipv4_proto)
-				return TPM_TRUE;
-		}
-		if (com_parse_bm & TPM_PARSE_L4_SRC) {
-			if (key_a->l4_src_port != key_b->l4_src_port)
-				return TPM_TRUE;
-		}
-		if (com_parse_bm & TPM_PARSE_L4_DST) {
-			if (key_a->l4_dst_port != key_b->l4_dst_port)
-				return TPM_TRUE;
-		}
-	}
-
-	return TPM_FALSE;
-}
-
-uint8_t tpm_proc_if_ipv4_pre_range_is_full(tpm_src_port_type_t src_port,
-					   tpm_parse_fields_t ipv4_parse_rule_bm,
-					   tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t key_idx, num_keys, num_rules = 1, i, j;
-	tpm_db_pnc_range_oper_t range_oper;
-	tpm_parse_fields_t parse_bm[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1] = {0, 0};
-	tpm_ipv4_acl_key_t key[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1];
-	uint8_t is_conflict = TPM_FALSE;
-
-	memset(&range_oper, 0, sizeof(tpm_db_pnc_range_oper_t));
-
-	ret_code = tpm_db_find_ipv4_pre_filter_key(src_port, ipv4_parse_rule_bm, ipv4_key, &key_idx);
-	if (ret_code != TPM_DB_OK) {
-		tpm_db_get_ipv4_pre_filter_key_num(src_port, &num_keys);
-		if (num_keys >= 3)
-			return TPM_TRUE;
-	} else
-		return TPM_FALSE;
-
-	tpm_db_pnc_rng_oper_get(TPM_PNC_CNM_IPV4_PRE, &range_oper);
-	if (range_oper.free_entries == 0)
-		return TPM_TRUE;
-
-	if ((num_keys == 1 && range_oper.free_entries < 2) ||
-		(num_keys == 2 && range_oper.free_entries < 4)) {
-		for (i = j = 0; i < TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM; i++) {
-			ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, i, &parse_bm[j], &key[j]);
-			if (ret_code == TPM_DB_OK)
-				j++;
-		}
-
-		is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(ipv4_parse_rule_bm, parse_bm[0], ipv4_key, &key[0]);
-		if (!is_conflict)
-			num_rules++;
-
-		if (num_keys == 2) {
-			is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(ipv4_parse_rule_bm, parse_bm[1], ipv4_key, &key[1]);
-			if (!is_conflict)
-				num_rules++;
-
-			is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(parse_bm[0], parse_bm[1], &key[0], &key[1]);
-			if (!is_conflict)
-				num_rules++;
-		}
-
-		if (range_oper.free_entries < num_rules)
-			return TPM_TRUE;
-	}
-
-	return TPM_FALSE;
-}
-
-uint8_t tpm_proc_if_cnm_main_range_is_full(tpm_src_port_type_t src_port, uint32_t precedence)
-{
-	int32_t ret_code;
-	uint32_t rule_num;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	memset(&range_conf, 0, sizeof(tpm_db_pnc_range_conf_t));
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-	if (ret_code != TPM_OK)
-		return TPM_TRUE;
-
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_CNM_MAIN_ACL, range_conf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		return TPM_TRUE;
-
-	return TPM_FALSE;
-}
-
-int32_t tpm_proc_merge_ipv4_pre_filter_key_b_to_a(uint32_t *parse_bm_key_a,
-						 uint32_t parse_bm_key_b,
-						 tpm_ipv4_acl_key_t *key_a,
-						 tpm_ipv4_acl_key_t *key_b)
-{
-	uint32_t diff_parse_bm_b_to_a = (~(*parse_bm_key_a)) & parse_bm_key_b;
-
-	if (diff_parse_bm_b_to_a != 0)
-	{
-		if (diff_parse_bm_b_to_a & TPM_IPv4_PARSE_SIP) {
-			memcpy(key_a->ipv4_src_ip_add, key_b->ipv4_src_ip_add, 4 * sizeof(uint8_t));
-			memcpy(key_a->ipv4_src_ip_add_mask, key_b->ipv4_src_ip_add_mask, 4 * sizeof(uint8_t));
-		}
-		if (diff_parse_bm_b_to_a & TPM_IPv4_PARSE_DIP) {
-			memcpy(key_a->ipv4_dst_ip_add, key_b->ipv4_dst_ip_add, 4 * sizeof(uint8_t));
-			memcpy(key_a->ipv4_dst_ip_add_mask, key_b->ipv4_dst_ip_add_mask, 4 * sizeof(uint8_t));
-		}
-		if (diff_parse_bm_b_to_a & TPM_IPv4_PARSE_DSCP) {
-			key_a->ipv4_dscp = key_b->ipv4_dscp;
-			key_a->ipv4_dscp_mask = key_b->ipv4_dscp_mask;
-		}
-		if (diff_parse_bm_b_to_a & TPM_IPv4_PARSE_PROTO)
-			key_a->ipv4_proto = key_b->ipv4_proto;
-		if (diff_parse_bm_b_to_a & TPM_PARSE_L4_SRC)
-			key_a->l4_src_port = key_b->l4_src_port;
-		if (diff_parse_bm_b_to_a & TPM_PARSE_L4_DST)
-			key_a->l4_dst_port = key_b->l4_dst_port;
-
-		*parse_bm_key_a |= diff_parse_bm_b_to_a;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_triple_key_rule(tpm_src_port_type_t src_port,
-							   uint32_t partner_key_bm,
-							   tpm_parse_fields_t ipv4_parse_rule_bm,
-							   tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t num_keys = 0, i, j;
-	tpm_parse_fields_t parse_bm[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1] = {0, 0};
-	tpm_ipv4_acl_key_t key[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1];
-	uint8_t is_conflict = TPM_FALSE;
-
-	memset(key, 0, sizeof(key));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " check src_port(%d), partner_key_bm(0x%x)\n", src_port, partner_key_bm);
-
-	tpm_db_get_ipv4_pre_filter_key_num(src_port, &num_keys);
-	if (num_keys < 2) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " not enough keys(%d) to set triple key rule - SKIP!\n", num_keys);
-		return TPM_FAIL;
-	}
-
-	for (i = 0, j = 0; i < TPM_CNM_IPV4_PRE_FILTER_KEY_MAX; i++) {
-		if ((1 << i) & partner_key_bm) {
-			ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, i, &parse_bm[j], &key[j]);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " fail to get ipv4 pre-filter key(%d)!\n", i);
-				return TPM_FAIL;
-			}
-			j++;
-		}
-	}
-
-	is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(ipv4_parse_rule_bm, parse_bm[0], ipv4_key, &key[0]);
-	if (is_conflict) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " new key conflicts with FIRST existing key!\n");
-		return TPM_FAIL;
-	}
-
-	is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(ipv4_parse_rule_bm, parse_bm[1], ipv4_key, &key[1]);
-	if (is_conflict) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " new key conflicts with SECOND existing key!\n");
-		return TPM_FAIL;
-	}
-
-	is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(parse_bm[0], parse_bm[1], &key[0], &key[1]);
-	if (is_conflict) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " FIRST existing key conflicts with SECOND existing key!\n");
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_double_key_rule(tpm_src_port_type_t src_port,
-							   uint32_t partner_key_bm,
-							   tpm_parse_fields_t ipv4_parse_rule_bm,
-							   tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t num_keys = 0, i;
-	tpm_parse_fields_t parse_bm = 0;
-	tpm_ipv4_acl_key_t key;
-	uint8_t is_conflict = TPM_FALSE;
-
-	memset(&key, 0, sizeof(tpm_ipv4_acl_key_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " check src_port(%d), partner_key_bm(0x%x)\n", src_port, partner_key_bm);
-
-	tpm_db_get_ipv4_pre_filter_key_num(src_port, &num_keys);
-	if (num_keys < 1) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " not enough keys(%d) to set triple key rule - SKIP!\n", num_keys);
-		return TPM_FAIL;
-	}
-
-	for (i = 0; i < TPM_CNM_IPV4_PRE_FILTER_KEY_MAX; i++) {
-		if ((1 << i) & partner_key_bm) {
-			ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, i, &parse_bm, &key);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " fail to get ipv4 pre-filter key(%d)!\n", i);
-				return TPM_FAIL;
-			}
-		}
-	}
-
-	is_conflict = tpm_proc_if_ipv4_pre_filter_key_conflict(ipv4_parse_rule_bm, parse_bm, ipv4_key, &key);
-	if (is_conflict) {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " new key conflicts with existing key!\n");
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_single_key_rule(tpm_src_port_type_t src_port,
-							   uint32_t partner_key_bm,
-							   tpm_parse_fields_t ipv4_parse_rule_bm,
-							   tpm_ipv4_acl_key_t *ipv4_key)
-{
-	return TPM_OK;
-}
-
-int32_t tpm_proc_cnm_ipv4_pre_tcam_build(tpm_src_port_type_t src_port,
-					 tpm_parse_fields_t ipv4_parse_rule_bm,
-					 tpm_ipv4_acl_key_t *ipv4_key,
-					 tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t src_port_field;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), parse_rule_bm(%d) \n",
-		     src_port, ipv4_parse_rule_bm);
-
-	/* IPV4 Parsing, according to bm in param */
-	tcam_data->ipv4_parse_bm = ipv4_parse_rule_bm;
-
-	parse_int_flags_bm |= TPM_PARSE_FLAG_CNM_IPV4_TRUE;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* Parse the AI flag bits */
-	src_port_field.src_port = src_port;
-	tpm_proc_parse_flag_ai_tcam_build(&src_port_field, 0, parse_int_flags_bm,
-									&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (ipv4_key) {
-		memcpy(&(tcam_data->pkt_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-	}
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_CNM_IPV4_PRE, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_cnm_ipv4_pre_sram_build(uint32_t key_pattern, tpm_pncl_sram_data_t *sram_data)
-{
-	tpm_db_pnc_range_conf_t range_conf;
-	long long int_pkt_act = 0;
-	tpm_ai_vectors_t key_field;
-	int32_t ret_code;
-
-	memset(&key_field, 0, sizeof(tpm_ai_vectors_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " key_pattern(0x%x)n", key_pattern);
-
-	/* Set next offset and update register */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	/*** Set next lookup configuration ***/
-
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-	IF_ERROR(ret_code);
-	sram_data->next_lu_id = range_conf.base_lu_id;
-	sram_data->next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-
-	sram_data->next_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	sram_data->next_offset.offset_sub.l2_subf = TPM_L2_PARSE_MH;
-
-	/* Set AI bits for IPV4 Pre-filter key pattern  */
-	int_pkt_act |= TPM_ACTION_SET_IPV4_PRE_KEY;
-
-	key_field.ipv4_pre_key = key_pattern;
-
-	/* Set AI bits */
-	tpm_proc_static_ai_sram_build(&key_field, 0, int_pkt_act, &(sram_data->add_info_data), &(sram_data->add_info_mask));
-
-	return(TPM_OK);
-}
-
-
-int32_t tpm_proc_set_ipv4_pre_filter_pnc_entry(tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       uint32_t key_pattern,
-					       tpm_parse_fields_t ipv4_parse_rule_bm,
-					       tpm_ipv4_acl_key_t *ipv4_key)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, num_valid_rules = 0, pnc_start_entry = 0, pnc_stop_entry = 0;
-	uint32_t pnc_range_start = 0, api_start = 0;
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_cnm_ipv4_pre_tcam_build(src_port, ipv4_parse_rule_bm, ipv4_key, &pnc_data.pncl_tcam);
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_cnm_ipv4_pre_sram_build(key_pattern, &pnc_data.pncl_sram);
-	IF_ERROR(ret_code);
-
-	/*** Calculate PNC Entry ***/
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_CNM_IPV4_PRE, &range_data);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_entry = (pnc_range_start + api_start) + rule_num;
-
-	/* Get valid IPV4 PRE rule number */
-	tpm_db_get_ipv4_pre_rule_num(&num_valid_rules);
-	/* Decrease by 1 for the new rule */
-	num_valid_rules--;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " set pnc_entry(%d), num_valid_rules(%d)\n", pnc_entry, num_valid_rules);
-
-	/* Call PNC Entry Insert, if this is not the api_section's new last entry */
-	if (rule_num < num_valid_rules) {
-		pnc_start_entry = pnc_entry;
-		pnc_stop_entry = (pnc_range_start + api_start) + (num_valid_rules - 1);
-		ret_code = tpm_pncl_entry_insert(pnc_start_entry, pnc_stop_entry, &pnc_data);
-		IF_ERROR(ret_code);
-	} else {
-		/* Otherwise just set the entry (no insertion) */
-		ret_code = tpm_pncl_entry_set(pnc_entry, &pnc_data);
-		IF_ERROR(ret_code);
-	}
-
-	/* Decrease number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_dec(TPM_PNC_CNM_IPV4_PRE);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_unset_ipv4_pre_filter_pnc_entry(uint32_t rule_num)
-{
-	tpm_db_pnc_range_t range_data;
-
-	int32_t ret_code;
-	uint32_t num_valid_rules = 0, pnc_start_entry = 0, pnc_stop_entry = 0;
-	uint32_t pnc_range_start = 0, api_start = 0;
-
-	/* Get PNC Range Start */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_CNM_IPV4_PRE, &range_data);
-	IF_ERROR(ret_code);
-	pnc_range_start = range_data.pnc_range_conf.range_start;
-	api_start = range_data.pnc_range_conf.api_start;
-
-	/* Get valid IPV4 PRE rule number */
-	tpm_db_get_ipv4_pre_rule_num(&num_valid_rules);
-	/* Increased by 1 for the new rule */
-	num_valid_rules++;
-
-	/* Calculate absolute PNC entry number to execute */
-	pnc_start_entry = (pnc_range_start + api_start) + rule_num;
-	pnc_stop_entry = (pnc_range_start + api_start) + (num_valid_rules - 1);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " delete pnc_start_entry(%d), pnc_stop_entry(%d)\n",
-									pnc_start_entry, pnc_stop_entry);
-
-	ret_code = tpm_pncl_entry_delete(pnc_start_entry, pnc_stop_entry);
-	IF_ERROR(ret_code);
-
-	/* Decrease number of free entries in pnc_range */
-	ret_code = tpm_db_pnc_rng_free_ent_inc(TPM_PNC_CNM_IPV4_PRE);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_triple_key_rule(tpm_src_port_type_t src_port,
-							 uint32_t key_idx,
-							 uint32_t key_pattern,
-							 tpm_parse_fields_t ipv4_parse_rule_bm,
-							 tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t partner_key_bm = 0, rule_num = 0, i, j;
-	tpm_parse_fields_t parse_bm[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1] = {0, 0};
-	tpm_ipv4_acl_key_t key[TPM_DB_CNM_MAX_IPV4_PRE_FILTER_KEY_NUM-1];
-	tpm_parse_fields_t merge_parse_bm = 0;
-	tpm_ipv4_acl_key_t merge_key;
-
-	memset(key, 0, sizeof(key));
-	memset(&merge_key, 0, sizeof(tpm_ipv4_acl_key_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " add src_port(%d), key_idx(%d), key_pattern(0x%x)\n", src_port, key_idx, key_pattern);
-
-	partner_key_bm = key_pattern & ~(1 << key_idx);
-
-	for (i = 0, j = 0; i < TPM_CNM_IPV4_PRE_FILTER_KEY_MAX; i++) {
-		if ((1 << i) & partner_key_bm) {
-			ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, i, &parse_bm[j], &key[j]);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to get ipv4 pre-filter key(%d)!\n", i);
-				return TPM_FAIL;
-			}
-			j++;
-		}
-	}
-
-	tpm_proc_merge_ipv4_pre_filter_key_b_to_a(&merge_parse_bm, ipv4_parse_rule_bm, &merge_key, ipv4_key);
-	tpm_proc_merge_ipv4_pre_filter_key_b_to_a(&merge_parse_bm, parse_bm[0], &merge_key, &key[0]);
-	tpm_proc_merge_ipv4_pre_filter_key_b_to_a(&merge_parse_bm, parse_bm[1], &merge_key, &key[1]);
-
-	ret_code = tpm_db_add_ipv4_pre_rule(src_port, (key_pattern << (TPM_CNM_IPV4_PRE_FILTER_KEY_MAX << 1)), &rule_num);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to add ipv4 pre-filter rule!\n");
-		return TPM_FAIL;
-	}
-	ret_code = tpm_proc_set_ipv4_pre_filter_pnc_entry(src_port, rule_num, key_pattern, merge_parse_bm, &merge_key);
-	if (ret_code != TPM_DB_OK) {
-		tpm_db_del_ipv4_pre_rule(src_port, (key_pattern << (TPM_CNM_IPV4_PRE_FILTER_KEY_MAX << 1)), &rule_num);
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to set ipv4 pre-filter pnc_entry(%d)!\n", rule_num);
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_double_key_rule(tpm_src_port_type_t src_port,
-							 uint32_t key_idx,
-							 uint32_t key_pattern,
-							 tpm_parse_fields_t ipv4_parse_rule_bm,
-							 tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t partner_key_bm = 0, rule_num = 0, i;
-	tpm_parse_fields_t parse_bm = 0;
-	tpm_ipv4_acl_key_t key;
-	tpm_parse_fields_t merge_parse_bm = 0;
-	tpm_ipv4_acl_key_t merge_key;
-
-	memset(&key, 0, sizeof(tpm_ipv4_acl_key_t));
-	memset(&merge_key, 0, sizeof(tpm_ipv4_acl_key_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " add src_port(%d), key_idx(%d), key_pattern(0x%x)\n", src_port, key_idx, key_pattern);
-
-	partner_key_bm = key_pattern & ~(1 << key_idx);
-
-	for (i = 0; i < TPM_CNM_IPV4_PRE_FILTER_KEY_MAX; i++) {
-		if ((1 << i) & partner_key_bm) {
-			ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, i, &parse_bm, &key);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to get ipv4 pre-filter key(%d)!\n", i);
-				return TPM_FAIL;
-			}
-		}
-	}
-
-	tpm_proc_merge_ipv4_pre_filter_key_b_to_a(&merge_parse_bm, ipv4_parse_rule_bm, &merge_key, ipv4_key);
-	tpm_proc_merge_ipv4_pre_filter_key_b_to_a(&merge_parse_bm, parse_bm, &merge_key, &key);
-
-	ret_code = tpm_db_add_ipv4_pre_rule(src_port, (key_pattern << TPM_CNM_IPV4_PRE_FILTER_KEY_MAX), &rule_num);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to add ipv4 pre-filter rule!\n");
-		return TPM_FAIL;
-	}
-	ret_code = tpm_proc_set_ipv4_pre_filter_pnc_entry(src_port, rule_num, key_pattern, merge_parse_bm, &merge_key);
-	if (ret_code != TPM_DB_OK) {
-		tpm_db_del_ipv4_pre_rule(src_port, (key_pattern << TPM_CNM_IPV4_PRE_FILTER_KEY_MAX), &rule_num);
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to set ipv4 pre-filter pnc_entry(%d)!\n", rule_num);
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_single_key_rule(tpm_src_port_type_t src_port,
-							 uint32_t key_idx,
-							 uint32_t key_pattern,
-							 tpm_parse_fields_t ipv4_parse_rule_bm,
-							 tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " add src_port(%d), key_idx(%d), key_pattern(0x%x)\n", src_port, key_idx, key_pattern);
-
-	ret_code = tpm_db_add_ipv4_pre_rule(src_port, key_pattern, &rule_num);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to add ipv4 pre-filter rule!\n");
-		return TPM_FAIL;
-	}
-	ret_code = tpm_proc_set_ipv4_pre_filter_pnc_entry(src_port, rule_num, key_pattern, ipv4_parse_rule_bm, ipv4_key);
-	if (ret_code != TPM_DB_OK) {
-		tpm_db_del_ipv4_pre_rule(src_port, key_pattern, &rule_num);
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to set ipv4 pre-filter pnc_entry(%d)!\n", rule_num);
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_del_cnm_ipv4_pre_filter_rule(uint32_t src_port, uint32_t key_pattern, uint32_t key_idx)
-{
-	int32_t ret_code;
-	uint32_t rule_num = 0, num_keys = 0, _key_pattern = 0, i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " del src_port(%d), key_idx(%d), key_pattern(0x%x)\n", src_port, key_idx, key_pattern);
-
-	for (i = 0; i < TPM_CNM_IPV4_PRE_FILTER_KEY_MAX; i++) {
-		if ((1 << i) & key_pattern)
-			num_keys++;
-	}
-
-	if (num_keys == 1)
-		_key_pattern = key_pattern;
-	else
-		_key_pattern = key_pattern << (TPM_CNM_IPV4_PRE_FILTER_KEY_MAX << (num_keys - 2));
-
-	ret_code = tpm_db_del_ipv4_pre_rule(src_port, _key_pattern, &rule_num);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to delete ipv4 pre-filter rule!\n");
-		return TPM_FAIL;
-	}
-	ret_code = tpm_proc_unset_ipv4_pre_filter_pnc_entry(rule_num);
-	if (ret_code != TPM_DB_OK) {
-		tpm_db_add_ipv4_pre_rule(src_port, _key_pattern, &rule_num);
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to unset ipv4 pre-filter pnc_entry(%d)!\n", rule_num);
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_check_cnm_ipv4_pre_filter_key_rule(uint32_t key_idx,
-						    uint32_t rule_type,
-						    tpm_src_port_type_t src_port,
-						    tpm_parse_fields_t ipv4_parse_rule_bm,
-						    tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	tpm_cnm_ipv4_pre_filter_rule_oper_t *rule_oper = &gs_cnm_ipv4_pre_filter_rule_oper[key_idx][rule_type];
-	uint32_t partner_key_bm;
-
-	partner_key_bm = rule_oper->key_pattern & ~(1 << key_idx);
-	ret_code = rule_oper->check_cnm_ipv4_pre_filter(src_port, partner_key_bm, ipv4_parse_rule_bm, ipv4_key);
-
-	return ret_code;
-}
-
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_key_rule(uint32_t key_idx,
-						  uint32_t rule_type,
-						  tpm_src_port_type_t src_port,
-						  tpm_parse_fields_t ipv4_parse_rule_bm,
-						  tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	tpm_cnm_ipv4_pre_filter_rule_oper_t *rule_oper = &gs_cnm_ipv4_pre_filter_rule_oper[key_idx][rule_type];
-
-	ret_code = rule_oper->add_cnm_ipv4_pre_filter(src_port, key_idx, rule_oper->key_pattern,
-						      ipv4_parse_rule_bm, ipv4_key);
-
-	return ret_code;
-}
-
-int32_t tpm_proc_del_cnm_ipv4_pre_filter_key_rule(uint32_t key_idx,
-						  uint32_t rule_type,
-						  tpm_src_port_type_t src_port,
-						  tpm_parse_fields_t ipv4_parse_rule_bm,
-						  tpm_ipv4_acl_key_t *ipv4_key)
-{
-	int32_t ret_code;
-	tpm_cnm_ipv4_pre_filter_rule_oper_t *rule_oper = &gs_cnm_ipv4_pre_filter_rule_oper[key_idx][rule_type];
-
-	ret_code = rule_oper->del_cnm_ipv4_pre_filter(src_port, rule_oper->key_pattern, key_idx);
-
-	return ret_code;
-}
-
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_key(uint32_t owner_id,
-					     tpm_src_port_type_t src_port,
-					     tpm_parse_fields_t ipv4_parse_rule_bm,
-					     tpm_ipv4_acl_key_t *ipv4_key,
-					     uint32_t *key_idx)
-{
-	int32_t ret_code;
-	uint32_t _key_idx, i;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), ipv4_parse_rule_bm(0x%x)\n", src_port, ipv4_parse_rule_bm);
-
-	ret_code = tpm_db_find_ipv4_pre_filter_key(src_port, ipv4_parse_rule_bm, ipv4_key, &_key_idx);
-	if (ret_code != TPM_DB_OK)
-	{
-		ret_code = tpm_db_alloc_ipv4_pre_filter_key(src_port, &_key_idx);
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " no room for new ipv4 pre-filter key!\n");
-			IF_ERROR(ERR_GENERAL);
-		}
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " alloc new key(%d)\n", _key_idx);
-
-
-		for (i = 0; i < TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_KEY; i++) {
-			ret_code = tpm_proc_check_cnm_ipv4_pre_filter_key_rule(_key_idx, i, src_port, ipv4_parse_rule_bm, ipv4_key);
-			if (ret_code == TPM_DB_OK) {
-				ret_code = tpm_proc_add_cnm_ipv4_pre_filter_key_rule(_key_idx, i, src_port, ipv4_parse_rule_bm, ipv4_key);
-				if (ret_code != TPM_DB_OK) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to add src_port(%d) key(%d), rule(%d)!\n",
-								src_port, _key_idx, i);
-					IF_ERROR(ERR_GENERAL);
-				}
-			}
-		}
-
-		ret_code = tpm_db_set_ipv4_pre_filter_key(src_port, _key_idx, ipv4_parse_rule_bm, ipv4_key);
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to set ipv4 pre-filter key(%d) to db!\n", _key_idx);
-			IF_ERROR(ERR_GENERAL);
-		}
-	} else
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " find existing key(%d)\n", _key_idx);
-
-	tpm_db_inc_ipv4_pre_filter_key_user_num(src_port, _key_idx);
-	*key_idx = _key_idx;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_del_cnm_ipv4_pre_filter_key(uint32_t owner_id, tpm_src_port_type_t src_port, uint32_t key_idx)
-{
-	int32_t ret_code;
-	tpm_parse_fields_t ipv4_parse_rule_bm = 0;
-	tpm_ipv4_acl_key_t ipv4_key;
-	uint32_t num_users = 0, i;
-
-	memset(&ipv4_key, 0, sizeof(tpm_ipv4_acl_key_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), key_idx(%d)\n", src_port, key_idx);
-
-	ret_code = tpm_db_get_ipv4_pre_filter_key(src_port, key_idx, &ipv4_parse_rule_bm, &ipv4_key);
-	if (ret_code != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " not find ipv4 pre-filter key(%d)!\n", key_idx);
-		IF_ERROR(ERR_GENERAL);
-	}
-
-	tpm_db_dec_ipv4_pre_filter_key_user_num(src_port, key_idx);
-
-	tpm_db_get_ipv4_pre_filter_key_user_num(src_port, key_idx, &num_users);
-	if (num_users == 0) {
-		for (i = 0; i < TPM_CNM_MAX_IPV4_PRE_FILTER_RULE_PER_KEY; i++) {
-			ret_code = tpm_proc_check_cnm_ipv4_pre_filter_key_rule(key_idx, i, src_port, ipv4_parse_rule_bm, &ipv4_key);
-			if (ret_code == TPM_DB_OK) {
-				ret_code = tpm_proc_del_cnm_ipv4_pre_filter_key_rule(key_idx, i, src_port, ipv4_parse_rule_bm, &ipv4_key);
-				if (ret_code != TPM_DB_OK) {
-					TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to del src_port(%d) key(%d), rule(%d)!\n",
-								src_port, key_idx, i);
-					IF_ERROR(ERR_GENERAL);
-				}
-			}
-		}
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " del ipv4 pre-filter key(%d)\n", key_idx);
-
-		ret_code = tpm_db_del_ipv4_pre_filter_key(src_port, key_idx);
-		if (ret_code != TPM_DB_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " fail to del ipv4 pre-filter key(%d)!\n", key_idx);
-			IF_ERROR(ERR_GENERAL);
-		}
-	}
-
-	return TPM_OK;
-}
-
-
-int32_t tpm_proc_cnm_l2_tcam_build(tpm_src_port_type_t src_port,
-				   tpm_parse_fields_t l2_parse_rule_bm,
-				   tpm_l2_acl_key_t *l2_key,
-				   uint32_t ipv4_key_idx,
-				   tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t ai_vectors;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), parse_rule_bm(%d), ipv4_key_idx(%d) \n",
-		     src_port, l2_parse_rule_bm, ipv4_key_idx);
-
-	/* IPV4 Parsing, according to bm in param */
-	tcam_data->l2_parse_bm = l2_parse_rule_bm;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port)) {
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-		ai_vectors.src_port = src_port;
-	}
-
-	/* Parse the AI flag bits */
-	if (ipv4_key_idx != TPM_CNM_INVALID_IPV4_PRE_FILTER_KEY_ID) {
-		parse_int_flags_bm |= TPM_PARSE_FLAG_IPV4_PRE_KEY_PARSE;
-		ai_vectors.ipv4_pre_key = 1 << ipv4_key_idx;
-	}
-	tpm_proc_parse_flag_ai_tcam_build(&ai_vectors, 0, parse_int_flags_bm,
-									&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (l2_key) {
-		memcpy(&(tcam_data->pkt_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-	}
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_CNM_MAIN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id + TPM_CNM_L2_MAIN_LUID_OFFSET;
-	start_offset.offset_base = TPM_PNCL_ZERO_OFFSET;
-	start_offset.offset_sub.subf = TPM_L2_PARSE_MH;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_cnm_l2_sram_build(uint32_t precedence,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_action_t pkt_act,
-				   uint32_t mod_cmd,
-				   tpm_pncl_sram_data_t *sram_data)
-{
-	tpm_db_pnc_range_conf_t range_conf;
-	long long int_pkt_act = 0;
-	tpm_ai_vectors_t key_field;
-	tpm_db_pon_type_t pon_type;
-	int32_t ret_code;
-
-	memset(&key_field, 0, sizeof(tpm_ai_vectors_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " precedence(%d), pkt_act(%d), mod_cmd(%d) \n", precedence, pkt_act, mod_cmd);
-
-	/* Set next offset and update register */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Update split modification */
-	if (SET_MOD(pkt_act)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-
-	/*** Set next lookup configuration ***/
-	if (precedence == 0) {
-		sram_data->next_lu_id = 0;
-		sram_data->next_lu_off_reg = 0;
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-	} else {
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-		sram_data->next_lu_id = range_conf.base_lu_id + TPM_CNM_ETY_MAIN_LUID_OFFSET;
-		sram_data->next_lu_off_reg = TPM_PNC_ETY_REG;
-
-		sram_data->next_offset.offset_base = TPM_PNCL_L3_OFFSET;
-		sram_data->next_offset.offset_sub.l3_subf = 0xffff;
-
-		/* Set AI bits for CNM precedence  */
-		int_pkt_act |= TPM_ACTION_SET_CNM_PREC;
-
-		key_field.cnm_prec = sg_l2_cnm_prec_ind[precedence];
-
-		/* Set AI bits */
-		tpm_proc_static_ai_sram_build(&key_field, 0, int_pkt_act, &(sram_data->add_info_data), &(sram_data->add_info_mask));
-	}
-
-	if (SET_TARGET_PORT(pkt_act)) {
-		/* Add Target Txp to update BM */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-
-		/* Set PNC FlowId Target */
-		sram_data->flow_id_sub.pnc_target = tpm_proc_cnm_pnc_trg_get(pkt_frwd->trg_port);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Target(%d)\n", sram_data->flow_id_sub.pnc_target);
-
-		/* If target is GPON, set GEM and MH */
-		tpm_db_pon_type_get(&pon_type);
-		if (pon_type == TPM_GPON) {
-			sram_data->mh_reg.mh_set = TPM_TRUE;
-			sram_data->mh_reg.mh_reg = 1;
-			sram_data->sram_updt_bm |= TPM_PNCL_SET_GEM;
-			sram_data->flow_id_sub.gem_port = pkt_frwd->gem_port;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set GemPort(%d)\n", pkt_frwd->gem_port);
-		}
-	}
-
-	if (SET_TARGET_QUEUE(pkt_act)) {
-		/* Set Queue */
-		sram_data->pnc_queue = pkt_frwd->trg_queue;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Tx Queue (%x) \n", pkt_frwd->trg_queue);
-	} else {
-		sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "No Tx Queue Update \n");
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_cnm_ipv6_tcam_build(tpm_src_port_type_t src_port,
-				     uint32_t precedence,
-				     tpm_parse_fields_t ipv6_parse_rule_bm,
-				     tpm_ipv6_acl_key_t *ipv6_key,
-				     tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t ai_vectors;
-	long long parse_int_flags_bm = 0;
-	tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win;
-
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), parse_rule_bm(%d) \n",
-		     src_port, ipv6_parse_rule_bm);
-
-	/* ipv6 Parsing, according to bm in param */
-	tcam_data->ipv6_parse_bm = ipv6_parse_rule_bm;
-
-	parse_int_flags_bm |= TPM_PARSE_FLAG_CNM_PREC_PARSE;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* Parse the AI flag bits */
-	ai_vectors.src_port = src_port;
-	ai_vectors.cnm_prec = sg_ipv4_cnm_prec_mask[precedence];
-	tpm_proc_parse_flag_ai_tcam_build(&ai_vectors, 0, parse_int_flags_bm,
-					  &(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (ipv6_key) {
-		memcpy(&(tcam_data->pkt_key.ipv6_key), ipv6_key, sizeof(tpm_ipv6_acl_key_t));
-	}
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_CNM_MAIN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id + TPM_CNM_IPV6_MAIN_LUID_OFFSET;
-
-	/* start_offset depends on ipv6 CnM parse window */
-	tpm_db_ctc_cm_ipv6_parse_win_get(&ctc_cm_ipv6_parse_win);
-
-	if(TPM_CTC_CM_IPv6_FIRST_24B == ctc_cm_ipv6_parse_win) {
-		start_offset.offset_base = TPM_PNCL_IPV6_OFFSET;
-		start_offset.offset_sub.subf = TPM_IPv6_PARSE_VER;
-		memcpy(&(tcam_data->pkt_key.ipv6_gen_key.ipv6_src_ip_add),
-			ipv6_key->ipv6_src_ip_add, sizeof(ipv6_key->ipv6_src_ip_add));
-		memcpy(&(tcam_data->pkt_key.ipv6_gen_key.ipv6_src_ip_add_mask),
-			ipv6_key->ipv6_src_ip_add_mask, sizeof(ipv6_key->ipv6_src_ip_add_mask));
-		tcam_data->pkt_key.ipv6_gen_key.ipv6_dscp = ipv6_key->ipv6_dscp;
-		tcam_data->pkt_key.ipv6_gen_key.ipv6_dscp_mask = ipv6_key->ipv6_dscp_mask;
-		tcam_data->pkt_key.ipv6_gen_key.hop_limit = ipv6_key->ipv6_hoplimit;
-	} else {
-		start_offset.offset_base = TPM_PNCL_IPV6_DIP_OFFSET;
-		start_offset.offset_sub.subf = TPM_IPv6_PARSE_DIP;
-		memcpy(&(tcam_data->pkt_key.ipv6_dip_key.ipv6_ip_add),
-			ipv6_key->ipv6_dst_ip_add, sizeof(ipv6_key->ipv6_dst_ip_add));
-		memcpy(&(tcam_data->pkt_key.ipv6_dip_key.ipv6_ip_add_mask),
-			ipv6_key->ipv6_dst_ip_add_mask, sizeof(ipv6_key->ipv6_dst_ip_add_mask));
-		tcam_data->pkt_key.l4_ports_key.l4_dst_port = ipv6_key->l4_dst_port;
-		tcam_data->pkt_key.l4_ports_key.l4_src_port = ipv6_key->l4_src_port;
-	}
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_cnm_ipv6_sram_build(tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_pkt_action_t pkt_act,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data)
-{
-	tpm_ai_vectors_t key_field;
-	tpm_db_pon_type_t pon_type;
-
-	memset(&key_field, 0, sizeof(tpm_ai_vectors_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pkt_act(%d), mod_cmd(%d) \n", pkt_act, mod_cmd);
-
-	/* Set next offset and update register */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/*** Set next lookup configuration ***/
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-
-	/* Update split modification */
-	if (SET_MOD(pkt_act)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-
-	if (SET_TARGET_PORT(pkt_act)) {
-		/* Add Target Txp to update BM */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-
-		/* Set PNC FlowId Target */
-		sram_data->flow_id_sub.pnc_target = tpm_proc_cnm_pnc_trg_get(pkt_frwd->trg_port);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Target(%d)\n", sram_data->flow_id_sub.pnc_target);
-
-		/* If target is GPON, set GEM and MH */
-		tpm_db_pon_type_get(&pon_type);
-		if (pon_type == TPM_GPON) {
-			sram_data->mh_reg.mh_set = TPM_TRUE;
-			sram_data->mh_reg.mh_reg = 1;
-			sram_data->sram_updt_bm |= TPM_PNCL_SET_GEM;
-			sram_data->flow_id_sub.gem_port = pkt_frwd->gem_port;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set GemPort(%d)\n", pkt_frwd->gem_port);
-		}
-	}
-
-	if (SET_TARGET_QUEUE(pkt_act)) {
-		/* Set Queue */
-		sram_data->pnc_queue = pkt_frwd->trg_queue;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Tx Queue (%x)\n", pkt_frwd->trg_queue);
-	} else {
-		sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "No Tx Queue Update \n");
-	}
-
-	return(TPM_OK);
-}
-tpm_pnc_trg_t tpm_proc_cnm_pnc_trg_get(tpm_trg_port_type_t trg_port)
-{
-	uint32_t i;
-	tpm_pnc_trg_t pnc_trgt = 0;
-	tpm_gmacs_enum_t   active_wan;
-
-	active_wan = tpm_db_active_wan_get();
-
-	/* Set PNC FlowId Target */
-	if (TPM_ENUM_PMAC == active_wan) {
-		for (i = 0; i < 8; i++) {
-			if (trg_port == (uint32_t)(TPM_TRG_TCONT_0 << i))
-				break;
-		}
-		pnc_trgt = TPM_PNC_TRG_PMAC0 + i;
-	} else if (TPM_ENUM_GMAC_0 == active_wan)
-		pnc_trgt = TPM_PNC_TRG_GMAC0;
-	else if (TPM_ENUM_GMAC_1 == active_wan)
-		pnc_trgt = TPM_PNC_TRG_GMAC1;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Target(%d)\n", pnc_trgt);
-	return pnc_trgt;
-}
-int32_t tpm_proc_cnm_ipv4_tcam_build(tpm_src_port_type_t src_port,
-				     uint32_t precedence,
-				     tpm_parse_fields_t ipv4_parse_rule_bm,
-				     tpm_ipv4_acl_key_t *ipv4_key,
-				     tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-
-	tpm_gmac_bm_t gmac_bm;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_ai_vectors_t ai_vectors;
-	long long parse_int_flags_bm = 0;
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " src_port(%d), parse_rule_bm(%d) \n",
-		     src_port, ipv4_parse_rule_bm);
-
-	/* IPV4 Parsing, according to bm in param */
-	tcam_data->ipv4_parse_bm = ipv4_parse_rule_bm;
-
-	parse_int_flags_bm |= TPM_PARSE_FLAG_CNM_PREC_PARSE | TPM_PARSE_FLAG_CNM_IPV4_TRUE;
-
-	/* Parse the uni_port AI bits */
-	if (FROM_SPEC_UNI(src_port))
-		parse_int_flags_bm |= TPM_PARSE_FLAG_UNI_PORT_PARSE;
-
-	/* Parse the AI flag bits */
-	ai_vectors.src_port = src_port;
-	ai_vectors.cnm_prec = sg_ipv4_cnm_prec_mask[precedence];
-	tpm_proc_parse_flag_ai_tcam_build(&ai_vectors, 0, parse_int_flags_bm,
-									&(tcam_data->add_info_data), &(tcam_data->add_info_mask));
-
-	/* Get GMAC(s) */
-	tpm_proc_src_port_gmac_bm_map(src_port, &gmac_bm);
-	tcam_data->port_ids = gmac_bm;
-
-	if (ipv4_key) {
-		memcpy(&(tcam_data->pkt_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-	}
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_CNM_MAIN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id + TPM_CNM_IPV4_MAIN_LUID_OFFSET;
-	start_offset.offset_base = TPM_PNCL_IPV4_OFFSET;
-	start_offset.offset_sub.subf = TPM_IPv4_PARSE_VER;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_cnm_ipv4_sram_build(tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_pkt_action_t pkt_act,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data)
-{
-	tpm_ai_vectors_t key_field;
-	tpm_db_pon_type_t pon_type;
-
-	memset(&key_field, 0, sizeof(tpm_ai_vectors_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " pkt_act(%d), mod_cmd(%d) \n", pkt_act, mod_cmd);
-
-	/* Set next offset and update register */
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/*** Set next lookup configuration ***/
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-
-	/* Update split modification */
-	if (SET_MOD(pkt_act)) {
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_SPLIT_MOD;
-		sram_data->flow_id_sub.mod_cmd = mod_cmd;
-	}
-
-	if (SET_TARGET_PORT(pkt_act)) {
-		/* Add Target Txp to update BM */
-		sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-
-		sram_data->flow_id_sub.pnc_target = tpm_proc_cnm_pnc_trg_get(pkt_frwd->trg_port);
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Target(%d)\n", sram_data->flow_id_sub.pnc_target);
-
-		/* If target is GPON, set GEM and MH */
-		tpm_db_pon_type_get(&pon_type);
-		if (pon_type == TPM_GPON) {
-			sram_data->mh_reg.mh_set = TPM_TRUE;
-			sram_data->mh_reg.mh_reg = 1;
-			sram_data->sram_updt_bm |= TPM_PNCL_SET_GEM;
-			sram_data->flow_id_sub.gem_port = pkt_frwd->gem_port;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set GemPort(%d)\n", pkt_frwd->gem_port);
-		}
-	}
-
-	if (SET_TARGET_QUEUE(pkt_act)) {
-		/* Set Queue */
-		sram_data->pnc_queue = pkt_frwd->trg_queue;
-
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "Set Tx Queue (%x)\n", pkt_frwd->trg_queue);
-	} else {
-		sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "No Tx Queue Update \n");
-	}
-
-	return(TPM_OK);
-}
-
-int32_t tpm_proc_calc_cnm_rule_num(tpm_src_port_type_t src_port, uint32_t precedence, uint32_t *rule_num)
-{
-	uint32_t num_rules = 0, i;
-
-	for (i = TPM_SRC_PORT_UNI_0; i < src_port; i++)
-		num_rules += tpm_db_ctc_cm_get_num_rules(i);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " total rule num before src_port(%d): %d\n", src_port, num_rules);
-
-	*rule_num = precedence + num_rules;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_calc_cnm_precedence(tpm_src_port_type_t src_port, uint32_t rule_num, uint32_t *precedence)
-{
-	uint32_t i;
-	uint32_t num_rules = 0;
-
-	if (NULL == precedence) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " invalid pointer--precedence!\n");
-		return ERR_GENERAL;
-	}
-
-	for (i = TPM_SRC_PORT_UNI_0; i < src_port; i++)
-		num_rules += tpm_db_ctc_cm_get_num_rules(i);
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " total rule num before src_port(%d): %d\n", src_port, num_rules);
-
-	if (rule_num < num_rules) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " rule num(%d) before src_port(%d) greater than current rule index(%d)!\n", num_rules, src_port, rule_num);
-		return ERR_GENERAL;
-	}
-
-	if ((rule_num - num_rules) >= TPM_MAX_NUM_CTC_PRECEDENCE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " calculated precedence(%d) invalid!\n", rule_num - num_rules);
-		return ERR_CTC_CM_PREC_INVALID;
-	}
-
-	*precedence = rule_num - num_rules;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_l2_cnm_rule(uint32_t owner_id,
-				 tpm_src_port_type_t src_port,
-				 uint32_t precedence,
-				 tpm_parse_fields_t l2_parse_rule_bm,
-				 tpm_l2_acl_key_t *l2_key,
-				 tpm_parse_fields_t ipv4_parse_rule_bm,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 uint32_t ipv4_key_idx,
-				 tpm_pkt_frwd_t *pkt_frwd,
-				 tpm_pkt_action_t pkt_act,
-				 uint32_t pbits,
-				 uint32_t *rule_idx)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_db_mod_conn_t mod_con;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, rule_num = 0, _rule_idx = 0, bi_dir, api_rng_entries;
-
-	memset(&range_conf, 0, sizeof(tpm_db_pnc_range_conf_t));
-	memset(&mod_con, 0, sizeof(tpm_db_mod_conn_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_CNM_MAIN_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Calculate rule num */
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	if (TPM_RANGE_TYPE_TABLE == range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_CNM_MAIN_ACL, rule_num, &_rule_idx, &bi_dir, &api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_DB_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d) already exists\n",
-				     owner_id, src_port, rule_num);
-
-			tpm_proc_del_l2_cnm_rule(owner_id, rule_num);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Get split modification update */
-	if (SET_MOD(pkt_act)) {
-		if (tpm_db_split_mod_get_enable() == TPM_SPLIT_MOD_ENABLED) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod for prec-0 \n");
-
-			/* get mod index from p-bit value */
-			ret_code = tpm_db_split_mod_get_index_by_p_bits(pbits, &mod_entry);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " unsupported p-bit value: %d\n", pbits);
-				return ERR_MOD_INVALID;
-			}
-
-			/* skip first PMT for p-bit AS-IS */
-			mod_entry++;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " updated mod_cmd(%d) \n", mod_entry);
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " split_mod is in-active \n");
-			return ERR_MOD_INVALID;
-		}
-	}
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_cnm_l2_tcam_build(src_port, l2_parse_rule_bm, l2_key, ipv4_key_idx, &pnc_data.pncl_tcam);
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_cnm_l2_sram_build(precedence, pkt_frwd, pkt_act, mod_entry, &pnc_data.pncl_sram);
-	IF_ERROR(ret_code);
-
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-	    /*** Insert the PNC Entry ***/
-		ret_code = tpm_proc_create_acl_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		ret_code = tpm_proc_create_table_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, 0, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	/* Set PNC API data */
-	api_data.cnm_key.src_port = src_port;
-	api_data.cnm_key.l2_parse_rule_bm = l2_parse_rule_bm;
-	api_data.cnm_key.ipv4_parse_rule_bm = ipv4_parse_rule_bm;
-	api_data.cnm_key.pkt_act = pkt_act;
-	api_data.cnm_key.pbits = pbits;
-	if (l2_key)
-		memcpy(&(api_data.cnm_key.l2_key), l2_key, sizeof(tpm_l2_acl_key_t));
-	if (ipv4_key)
-		memcpy(&(api_data.cnm_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.cnm_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.cnm_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			ret_code = tpm_proc_api_entry_rulenum_inc(TPM_CNM_MAIN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	ret_code = tpm_db_api_entry_set(TPM_CNM_MAIN_ACL, rule_num, 0 /*bi_dir */, &api_data, &mod_con, &pnc_conn, &_rule_idx);
-	IF_ERROR(ret_code);
-
-	/* Return Output */
-	*rule_idx = _rule_idx;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_ipv4_cnm_rule(uint32_t owner_id,
-				   tpm_src_port_type_t src_port,
-				   uint32_t precedence,
-				   tpm_parse_fields_t ipv4_parse_rule_bm,
-				   tpm_ipv4_acl_key_t *ipv4_key,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_action_t pkt_act,
-				   uint32_t pbits,
-				   uint32_t *rule_idx)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_db_mod_conn_t mod_con;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, rule_num = 0, _rule_idx = 0, bi_dir, api_rng_entries;
-
-	memset(&range_conf, 0, sizeof(tpm_db_pnc_range_conf_t));
-	memset(&mod_con, 0, sizeof(tpm_db_mod_conn_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_CNM_MAIN_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Calculate rule num */
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	if (TPM_RANGE_TYPE_TABLE == range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_CNM_MAIN_ACL, rule_num, &_rule_idx, &bi_dir, &api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_DB_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d) already exists\n",
-				     owner_id, src_port, rule_num);
-
-			tpm_proc_del_ipv4_cnm_rule(owner_id, rule_num);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Get split modification update */
-	if (SET_MOD(pkt_act)) {
-		if (tpm_db_split_mod_get_enable() == TPM_SPLIT_MOD_ENABLED) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod for prec-0 \n");
-
-			/* get mod index from p-bit value */
-			ret_code = tpm_db_split_mod_get_index_by_p_bits(pbits, &mod_entry);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " unsupported p-bit value: %d\n", pbits);
-				return ERR_MOD_INVALID;
-			}
-
-			/* skip first PMT for p-bit AS-IS */
-			mod_entry++;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " updated mod_cmd(%d) \n", mod_entry);
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " split_mod is in-active \n");
-			return ERR_MOD_INVALID;
-		}
-	}
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_cnm_ipv4_tcam_build(src_port, precedence, ipv4_parse_rule_bm, ipv4_key, &pnc_data.pncl_tcam);
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_cnm_ipv4_sram_build(pkt_frwd, pkt_act, mod_entry, &pnc_data.pncl_sram);
-	IF_ERROR(ret_code);
-
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-	    /*** Insert the PNC Entry ***/
-		ret_code = tpm_proc_create_acl_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		ret_code = tpm_proc_create_table_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, 0, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	/* Set PNC API data */
-	api_data.cnm_key.src_port = src_port;
-	api_data.cnm_key.ipv4_parse_rule_bm = ipv4_parse_rule_bm;
-	api_data.cnm_key.pkt_act = pkt_act;
-	api_data.cnm_key.pbits = pbits;
-	if (ipv4_key)
-		memcpy(&(api_data.cnm_key.ipv4_key), ipv4_key, sizeof(tpm_ipv4_acl_key_t));
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.cnm_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.cnm_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			ret_code = tpm_proc_api_entry_rulenum_inc(TPM_CNM_MAIN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	ret_code = tpm_db_api_entry_set(TPM_CNM_MAIN_ACL, rule_num, 0 /*bi_dir */, &api_data, &mod_con, &pnc_conn, &_rule_idx);
-	IF_ERROR(ret_code);
-
-	/* Return Output */
-	*rule_idx = _rule_idx;
-
-	return TPM_OK;
-}
-
-int32_t tpm_proc_add_ipv6_cnm_rule(uint32_t owner_id,
-				   tpm_src_port_type_t src_port,
-				   uint32_t precedence,
-				   tpm_parse_fields_t ipv6_parse_rule_bm,
-				   tpm_ipv6_acl_key_t *ipv6_key,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_action_t pkt_act,
-				   uint32_t pbits,
-				   uint32_t *rule_idx)
-{
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_pncl_offset_t start_offset;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_db_mod_conn_t mod_con;
-
-	int32_t ret_code;
-	uint32_t pnc_entry = 0, mod_entry = 0, rule_num = 0, _rule_idx = 0, bi_dir, api_rng_entries;
-
-	memset(&range_conf, 0, sizeof(tpm_db_pnc_range_conf_t));
-	memset(&mod_con, 0, sizeof(tpm_db_mod_conn_t));
-
-	/* Set Structs to zero */
-	tpm_proc_set_int_structs(&pnc_data, &start_offset, &api_data, &pnc_conn, &range_data);
-
-	/* Get Range_Id */
-	tpm_db_api_section_main_pnc_get(TPM_CNM_MAIN_ACL, &range_id);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Calculate rule num */
-	tpm_proc_calc_cnm_rule_num(src_port, precedence, &rule_num);
-
-	if (TPM_RANGE_TYPE_TABLE == range_conf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_CNM_MAIN_ACL, rule_num, &_rule_idx, &bi_dir, &api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_DB_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) src_port(%d), rule_num(%d) already exists\n",
-				     owner_id, src_port, rule_num);
-
-			tpm_proc_del_ipv6_cnm_rule(owner_id, rule_num);
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Get split modification update */
-	if (SET_MOD(pkt_act)) {
-		if (tpm_db_split_mod_get_enable() == TPM_SPLIT_MOD_ENABLED) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " split mod for prec-0 \n");
-
-			/* get mod index from p-bit value */
-			ret_code = tpm_db_split_mod_get_index_by_p_bits(pbits, &mod_entry);
-			if (ret_code != TPM_DB_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, " unsupported p-bit value: %d\n", pbits);
-				return ERR_MOD_INVALID;
-			}
-
-			/* skip first PMT for p-bit AS-IS */
-			mod_entry++;
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " updated mod_cmd(%d) \n", mod_entry);
-		} else {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " split_mod is in-active \n");
-			return ERR_MOD_INVALID;
-		}
-	}
-
-	/*********** Create PNC Entries **********/
-	/* Build PnC Entry */
-	ret_code = tpm_proc_cnm_ipv6_tcam_build(src_port, precedence, ipv6_parse_rule_bm, ipv6_key, &pnc_data.pncl_tcam);
-	IF_ERROR(ret_code);
-
-	/* Build SRAM Entry */
-	ret_code = tpm_proc_cnm_ipv6_sram_build(pkt_frwd, pkt_act, mod_entry, &pnc_data.pncl_sram);
-	IF_ERROR(ret_code);
-
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-	    /*** Insert the PNC Entry ***/
-		ret_code = tpm_proc_create_acl_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		ret_code = tpm_proc_create_table_pnc_entry(TPM_CNM_MAIN_ACL, rule_num, 0, &pnc_data, &pnc_entry, &api_rng_entries);
-		IF_ERROR(ret_code);
-	}
-
-	/*********** Update API Range in DB **********/
-	/* Set PNC API data */
-	api_data.cnm_key.src_port = src_port;
-	api_data.cnm_key.ipv6_parse_rule_bm = ipv6_parse_rule_bm;
-	api_data.cnm_key.pkt_act = pkt_act;
-	api_data.cnm_key.pbits = pbits;
-	if (ipv6_key)
-		memcpy(&(api_data.cnm_key.ipv6_key), ipv6_key, sizeof(tpm_ipv6_acl_key_t));
-	if (pkt_frwd != NULL)
-		memcpy(&(api_data.cnm_key.pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	else
-		memset(&(api_data.cnm_key.pkt_frwd), 0, sizeof(tpm_pkt_frwd_t));
-
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (range_conf.range_type == TPM_RANGE_TYPE_ACL) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			ret_code = tpm_proc_api_entry_rulenum_inc(TPM_CNM_MAIN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	ret_code = tpm_db_api_entry_set(TPM_CNM_MAIN_ACL, rule_num, 0 /*bi_dir */, &api_data, &mod_con, &pnc_conn, &_rule_idx);
-	IF_ERROR(ret_code);
-
-	/* Return Output */
-	*rule_idx = _rule_idx;
-
-	return TPM_OK;
-}
-
-
-int32_t tpm_proc_del_cnm_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-	uint32_t rule_num, dummy_idx, bi_dir, api_rng_entries;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con = { 0, 0};
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_db_pnc_range_conf_t rang_conf;
-	tpm_pnc_ranges_t range_id = 0;
-
-	memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " rule_idx (%d)", rule_idx);
-
-	/* Get Range_Id */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_CNM_MAIN_ACL, &range_id);
-	IF_ERROR(ret_code);
-
-	/* Get Range Conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rang_conf);
-	IF_ERROR(ret_code);
-
-	/* Get the rule_num */
-	ret_code = tpm_db_api_rulenum_get(TPM_CNM_MAIN_ACL, rule_idx, &rule_num);
-	if (ret_code == TPM_DB_ERR_REC_NOT_EXIST) {
-		TPM_OS_ERROR(TPM_DB_MOD, " The rule non-exist!\n");
-		return ERR_RULE_IDX_INVALID;
-	}
-	TPM_OS_DEBUG(TPM_TPM_LOG_MOD, "with rule_num(%d)\n", rule_num);
-	/*IF_ERROR(ret_code);*/
-
-	ret_code = tpm_db_api_entry_get(TPM_CNM_MAIN_ACL, rule_num, &dummy_idx, &bi_dir, &api_data, &mod_con, &pnc_con);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_api_section_num_entries_get(TPM_CNM_MAIN_ACL, &api_rng_entries);
-	IF_ERROR(ret_code);
-
-	/* Delete PNC Entry */
-	ret_code = tpm_proc_pnc_con_del(&pnc_con);
-	IF_ERROR(ret_code);
-
-	/* Delete API Rule Entry */
-	ret_code = tpm_db_api_entry_invalidate(TPM_CNM_MAIN_ACL, rule_num);
-	IF_ERROR(ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rang_conf.range_type) {
-		/* Decrease rule_numbers and PnC entries of the existing API entries that were "pulled up" */
-		ret_code = tpm_proc_api_entry_rulenum_dec(TPM_CNM_MAIN_ACL, (rule_num + 1), (api_rng_entries - 1));
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_RC_OK);
-}
-int32_t tpm_proc_del_ipv6_cnm_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-
-	ret_code = tpm_proc_del_cnm_rule(owner_id, rule_idx);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-int32_t tpm_proc_del_l2_cnm_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-
-	ret_code = tpm_proc_del_cnm_rule(owner_id, rule_idx);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-int32_t tpm_proc_del_ipv4_cnm_rule(uint32_t owner_id, uint32_t rule_idx)
-{
-	int32_t ret_code;
-
-	ret_code = tpm_proc_del_cnm_rule(owner_id, rule_idx);
-	IF_ERROR(ret_code);
-
-	return(TPM_RC_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_mac_learn_port_gmac_bm_map()
-*
-* DESCRIPTION:    The function get the MAC learn port by means of the GMAC Functionality
-*                 for Media convert with loopback mode.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* gmac_bm          - Bitmap of the GMACs relevant to set in TCAM
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_mac_learn_port_gmac_bm_map(tpm_gmac_bm_t *gmac_bm)
-{
-	int32_t ret_code = TPM_DB_OK;
-	uint32_t gmac_id;
-	tpm_db_gmac_func_t gfunc;
-	tpm_gmac_bm_t l_gmac_bm = 0;
-
-	/* Find the GMAC used to do MAC learn on MC */
-	for (gmac_id = TPM_ENUM_GMAC_0; gmac_id < TPM_MAX_NUM_GMACS; gmac_id ++) {
-		ret_code = tpm_db_gmac_func_get(gmac_id, &gfunc);
-		if (TPM_DB_OK == ret_code) {
-			if (TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI == gfunc)
-				l_gmac_bm |= gmac_pnc_bm[gmac_id];
-		} else {
-			TPM_OS_ERROR(TPM_DB_MOD, "GMAC%d Func get failed \n", gmac_id);
-			return ret_code;
-		}
-	}
-
-	*gmac_bm = l_gmac_bm;
-
-	return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_mac_learn_tcam_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* rule_num          - API rule number
-* src_mac_addr      - layer2 key data
-* OUTPUTS:
-* l2_tcam_data      - Logical TCAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_mac_learn_tcam_build(uint32_t rule_num,
-				      tpm_l2_acl_key_t *src_mac_addr,
-				      tpm_pncl_tcam_data_t *tcam_data)
-{
-	int32_t ret_code;
-	uint32_t lu_id;
-	tpm_pncl_offset_t start_offset;
-	tpm_gmac_bm_t gmac_bm;
-
-	/* L2 Parsing, according to bm in param */
-	tcam_data->l2_parse_bm = TPM_L2_PARSE_MAC_SA;
-
-	/* Get GMAC(s) */
-	ret_code = tpm_proc_mac_learn_port_gmac_bm_map(&gmac_bm);
-	IF_ERROR(ret_code);
-	tcam_data->port_ids = gmac_bm;
-
-	/* Copy in logical PnC Key */
-	if (src_mac_addr)
-		memcpy(&(tcam_data->pkt_key.l2_key), src_mac_addr, sizeof(tpm_l2_acl_key_t));
-
-	/* Get PNC Range information */
-	ret_code = tpm_proc_common_pncl_info_get(TPM_PNC_MAC_LEARN, &lu_id, &start_offset);
-	IF_ERROR(ret_code);
-	tcam_data->lu_id = lu_id;
-	memcpy(&(tcam_data->start_offset), &start_offset, sizeof(tpm_pncl_offset_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_mac_learn_sram_build()
-*
-* DESCRIPTION:     Function builds a logical TCAM entry from the API data
-*
-* INPUTS:
-* queue             - queue to update
-*
-* OUTPUTS:
-* l2_sram_data      - Logical SRAM Structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_proc_mac_learn_sram_build(uint32_t queue,
-				      tpm_pncl_sram_data_t *sram_data)
-{
-
-	sram_data->next_lu_id = 0;
-	sram_data->next_lu_off_reg = 0;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_LUD;
-	sram_data->shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	if (queue > 7)
-		sram_data->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	else
-		sram_data->pnc_queue = queue;
-	sram_data->flow_id_sub.pnc_target = TPM_PNC_TRG_GMAC1;
-	sram_data->sram_updt_bm |= TPM_PNCL_SET_TXP;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_proc_add_mac_learn_check()
-*
-* DESCRIPTION:    The function checks consistency of the tpm_proc_add_static_mac_rule params.
-*
-* INPUTS:
-* owner_id         -
-* rule_num         - See tpm_proc_add_l2_prim_acl_rule
-* queue            - See tpm_proc_add_l2_prim_acl_rule
-* src_mac_addr     - See tpm_proc_add_l2_prim_acl_rule
-* rule_idx         - See tpm_proc_add_l2_prim_acl_rule
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_mac_learn_check(uint32_t owner_id,
-					      uint32_t rule_num,
-					      uint32_t queue,
-					      tpm_l2_acl_key_t *src_mac_addr,
-					      uint32_t *rule_idx)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t rangConf;
-	uint32_t l_api_rng_entries;
-
-	/* Get Range_Id */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_PNC_MAC_LEARN_ACL, &range_id);
-	IF_ERROR(ret_code);
-	/* Get range conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-	/* Get number of existing api entries */
-	int_ret_code = tpm_db_api_section_num_entries_get(TPM_PNC_MAC_LEARN_ACL, &l_api_rng_entries);
-	IF_ERROR(int_ret_code);
-	/*check if there are free entry*/
-	if (l_api_rng_entries >= (rangConf.api_end - rangConf.api_start + 1)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, " api_sec(%d), has no free entries \n", TPM_PNC_MAC_LEARN_ACL);
-		return(TPM_FAIL);
-	}
-
-	ret_code = tpm_owner_id_check(TPM_API_MAC_LEARN, owner_id);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_OWNER_INVALID);
-	/* Check rule_num, and api_section is active */
-	ret_code = tpm_proc_add_api_ent_check(TPM_PNC_MAC_LEARN_ACL, rangConf.range_type, rule_num);
-	if (ret_code != TPM_OK)
-		IF_ERROR(ERR_RULE_NUM_INVALID);
-	/* Check src_mac_addr */
-	if (NULL != src_mac_addr) {
-		if (!(src_mac_addr->mac.mac_sa_mask[0] ||
-		      src_mac_addr->mac.mac_sa_mask[1] ||
-		      src_mac_addr->mac.mac_sa_mask[2] ||
-		      src_mac_addr->mac.mac_sa_mask[3] ||
-		      src_mac_addr->mac.mac_sa_mask[4] ||
-		      src_mac_addr->mac.mac_sa_mask[5]))
-		      IF_ERROR(ERR_L2_KEY_INVALID);
-	} else {
-		IF_ERROR(ERR_L2_KEY_INVALID);
-	}
-
-	if (queue > 7)
-		TPM_OS_WARN(TPM_TPM_LOG_MOD, " Invalid Queue(0x%x)\n", queue);
-
-	if (NULL == rule_idx)
-		IF_ERROR(ERR_NULL_POINTER);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_add_static_mac_rule()
-*
-* DESCRIPTION:    Main function for adding source MAC address learn API rule.
-*
-* INPUTS:
-* queue             - queue to update on GMAC1
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_mac_learn_rule(uint32_t owner_id,
-					     uint32_t rule_num,
-					     uint32_t queue,
-					     tpm_l2_acl_key_t *src_mac_addr,
-					     uint32_t *rule_idx)
-{
-	tpm_error_code_t ret_code;
-	int32_t int_ret_code;
-	uint32_t pnc_entry = 0, api_rng_entries = 0;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t rangConf;
-	tpm_pncl_pnc_full_t pnc_data;
-	tpm_rule_entry_t api_data;
-	tpm_db_pnc_conn_t pnc_conn;
-	tpm_db_mod_conn_t mod_con;
-	tpm_api_lu_conf_t lu_conf;
-	uint32_t l_rule_idx, bi_dir;
-
-	/* Get Range_Id */
-	ret_code = tpm_db_api_section_main_pnc_get(TPM_PNC_MAC_LEARN_ACL, &range_id);
-	IF_ERROR(ret_code);
-	/* Get range conf */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &rangConf);
-	IF_ERROR(ret_code);
-
-	/* Check parameters */
-	ret_code = tpm_proc_add_mac_learn_check(owner_id, rule_num, queue, src_mac_addr, rule_idx);
-	IF_ERROR(ret_code);
-
-	if (TPM_RANGE_TYPE_TABLE == rangConf.range_type) {
-		/* Try to getting the current entry */
-		ret_code = tpm_db_api_entry_get(TPM_PNC_MAC_LEARN_ACL, rule_num, &l_rule_idx, &bi_dir, &api_data, &mod_con, &pnc_conn);
-		/* if current entry with this rule num is valid */
-		if (TPM_RC_OK == ret_code) {
-			TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d), rule_num(%d) already exists\n", owner_id, rule_num);
-			ret_code = tpm_proc_del_static_mac_rule(owner_id, src_mac_addr);
-			IF_ERROR(ret_code);
-		}
-	}
-	/* Set Structs to zero */
-	memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-	memset(&api_data, 0, sizeof(tpm_rule_entry_t));
-	memset(&pnc_conn, 0, sizeof(tpm_db_pnc_conn_t));
-	memset(&mod_con, 0, sizeof(tpm_db_mod_conn_t));
-
-	/*********** Create PNC Entries **********/
-
-	/* Build PnC Entry */
-	int_ret_code = tpm_proc_mac_learn_tcam_build(rule_num, src_mac_addr, &(pnc_data.pncl_tcam));
-	IF_ERROR(int_ret_code);
-
-	int_ret_code = tpm_proc_mac_learn_sram_build(queue, &(pnc_data.pncl_sram));
-	IF_ERROR(int_ret_code);
-
-	if (TPM_RANGE_TYPE_ACL == rangConf.range_type) {
-		/*** Insert the PNC Entry ***/
-		int_ret_code = tpm_proc_create_acl_pnc_entry(TPM_PNC_MAC_LEARN_ACL,
-							     rule_num,
-							     &pnc_data,
-							     &pnc_entry,
-							     &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	} else {
-		/*** Set the PNC Entry ***/
-		int_ret_code = tpm_proc_create_table_pnc_entry(TPM_PNC_MAC_LEARN_ACL,
-							       rule_num,
-							       0,
-							       &pnc_data,
-							       &pnc_entry,
-							       &api_rng_entries);
-		IF_ERROR(int_ret_code);
-	}
-	/*********** Update API Range in DB **********/
-	/* Set PNC API data */
-	api_data.l2_prim_key.parse_rule_bm = TPM_L2_PARSE_MAC_SA;
-	memcpy(&(api_data.l2_prim_key.l2_key), src_mac_addr, sizeof(tpm_l2_acl_key_t));
-	/* Invalide mod */
-	mod_con.mod_cmd_ind = 0;
-	mod_con.mod_cmd_mac = TPM_INVALID_GMAC;
-	/* Set Pnc Connection data */
-	pnc_conn.num_pnc_ranges = 1;
-	pnc_conn.pnc_conn_tbl[0].pnc_range = range_id;
-	pnc_conn.pnc_conn_tbl[0].pnc_index = pnc_entry;
-
-	if (rangConf.range_type == TPM_RANGE_TYPE_ACL) {
-		/* Increase rule_numbers and PnC entries of the existing API entries that were "moved down" */
-		if (rule_num < api_rng_entries) {
-			ret_code = tpm_proc_api_entry_rulenum_inc(TPM_PNC_MAC_LEARN_ACL, rule_num, (api_rng_entries - 1));
-			IF_ERROR(ret_code);
-		}
-	}
-
-	/* Set new API Entry */
-	ret_code = tpm_db_api_entry_set(TPM_PNC_MAC_LEARN_ACL, rule_num, 0, &api_data, &mod_con, &pnc_conn, &l_rule_idx);
-	IF_ERROR(ret_code);
-
-	/* Return Output */
-	*rule_idx = l_rule_idx;
-
-	/* Set aging counter group nunmber and msk */
-	int_ret_code = tpm_db_pnc_get_lu_conf(range_id, &lu_conf);
-	IF_ERROR(int_ret_code);
-	tpm_tcam_set_lu_mask(pnc_entry, (int32_t) lu_conf.lu_mask);
-	tpm_tcam_set_cntr_group(pnc_entry, (int32_t) lu_conf.cntr_grp);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_find_mac_addr_db()
-*
-* DESCRIPTION:    To find MAC address for mac learn in DB
-*
-* INPUTS:
-* src_mac_addr             - address to search
-*
-* OUTPUTS:
-* addr_exist               - the address exist in DB or not, 0-not, 1-exist
-* rule_num                 - the unique rule index to pnc rule, will be used in pnc del
-* tbl_num                  - the table serial number, unique
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_find_mac_addr_db(tpm_l2_acl_key_t *src_mac_addr, int32_t *addr_exist, uint32_t *rule_num, uint32_t *tbl_num)
-{
-	tpm_error_code_t ret_code;
-	tpm_db_api_entry_t api_ent_mem_area;
-	uint32_t valid_entry_num = 0;
-	uint32_t api_rng_size, tbl_start;
-	int32_t apisec_last_valid_index;
-	int32_t rule_index;
-	tpm_rule_entry_t tpm_rule;
-	tpm_pnc_ranges_t pnc_range;
-
-	/* get API section info */
-	ret_code = tpm_db_api_section_get(TPM_PNC_MAC_LEARN_ACL,
-					  &api_rng_size,
-					  &valid_entry_num,
-					  &pnc_range,
-					  &apisec_last_valid_index,
-					  &tbl_start);
-	IF_ERROR(ret_code);
-	if (valid_entry_num == 0) {
-		*addr_exist = 0;
-		*rule_num = 0;
-		*tbl_num = 0;
-		return TPM_OK;
-	}
-
-	for (rule_index = 0; rule_index < (api_rng_size - 1); rule_index++) {
-		/* clear structure */
-		memset(&tpm_rule, 0, sizeof(tpm_rule_entry_t));
-		memset(&api_ent_mem_area, 0, sizeof(tpm_db_api_entry_t));
-
-		ret_code = tpm_db_api_section_ent_tbl_get(TPM_PNC_MAC_LEARN_ACL, &api_ent_mem_area, rule_index);
-		IF_ERROR(ret_code);
-		/*get tpm_rule*/
-		if (api_ent_mem_area.valid == TPM_DB_VALID) {
-			memcpy(&tpm_rule, &(api_ent_mem_area.api_rule_data), sizeof(tpm_rule_entry_t));
-			if (!memcmp(&tpm_rule.l2_prim_key.l2_key.mac, &(src_mac_addr->mac), sizeof(tpm_mac_key_t))) {
-				*addr_exist = 1;
-				*rule_num = api_ent_mem_area.rule_idx;
-				*tbl_num = api_ent_mem_area.rule_num;
-				return TPM_OK;
-			}
-		}
-	}
-
-	*addr_exist = 0;
-	*rule_num = 0;
-	*tbl_num = 0;
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_add_static_mac_rule()
-*
-* DESCRIPTION:    Main function for adding source MAC address learn API rule.
-*
-* INPUTS:
-* src_mac_addr             - address to learn
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_add_static_mac_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable = TPM_PNC_MAC_LEARN_DISABLED;
-	uint32_t rule_idx;
-	int32_t addr_exist = 0;
-	uint32_t rule_num = 0;
-	uint32_t queue_idx = 1;
-	tpm_gmacs_enum_t gmac_num;
-	uint32_t tbl_num = 0;
-
-	/* check whether mac_learn_enable is enabled or not */
-	ret_code = tpm_db_pnc_mac_learn_enable_get(&pnc_mac_learn_enable);
-	IF_ERROR(ret_code);
-	if (pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_DISABLED) {
-		printk("MAC learn is not enabled\n");
-		return TPM_FAIL;
-	}
-
-	if (src_mac_addr == NULL) {
-		printk("NULL pointer\n");
-		return TPM_FAIL;
-	}
-	/* check whether the MAC exist in system or not */
-	ret_code = tpm_proc_find_mac_addr_db(src_mac_addr, &addr_exist, &rule_num, &tbl_num);
-	IF_ERROR(ret_code);
-	if (addr_exist)
-		return TPM_OK;
-	/* Get Tx queue */
-	if (tpm_db_gmac_lpk_queue_get(&gmac_num, &queue_idx, TPM_GMAC1_QUEUE_DATA_TRAFFIC)) {
-		printk("Loopback Tx queue index get failed\n");
-		return TPM_FAIL;
-	}
-	/* rule num is always 0 */
-	ret_code = tpm_proc_add_mac_learn_rule(TPM_MOD_OWNER_TPM, 0, queue_idx, src_mac_addr, &rule_idx);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_proc_del_static_mac_rule()
-*
-* DESCRIPTION:    Main function for deleting source MAC address learn API rule.
-*
-* INPUTS:
-* owner_id
-* rule_idx
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_del_static_mac_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable = TPM_PNC_MAC_LEARN_DISABLED;
-	int32_t addr_exist = 0;
-	uint32_t rule_num = 0;
-	uint32_t tbl_num = 0;
-
-	/* check whether mac_learn_enable is enabled or not */
-	ret_code = tpm_db_pnc_mac_learn_enable_get(&pnc_mac_learn_enable);
-	IF_ERROR(ret_code);
-	if (pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_DISABLED) {
-		printk("MAC learn is not enabled\n");
-		return TPM_FAIL;
-	}
-
-	/* check whether the MAC exist in system or not */
-	ret_code = tpm_proc_find_mac_addr_db(src_mac_addr, &addr_exist, &rule_num, &tbl_num);
-	IF_ERROR(ret_code);
-	if (addr_exist == 0) {
-		printk("The src mac entry not exist\n");
-		return TPM_FAIL;
-	} else {
-		TPM_OS_DEBUG(TPM_TPM_LOG_MOD, " owner(%d) rule_idx(%d)", owner_id, rule_num);
-
-		ret_code = tpm_proc_del_acl_rule(TPM_PNC_MAC_LEARN_ACL, owner_id, rule_num, TPM_EXT_CALL);
-		IF_ERROR(ret_code);
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_mac_learn_default_rule_act_set()
-*
-* DESCRIPTION:    Function used to set mac learn default rule action dynamiclly.
-*
-* INPUTS:
-* owner_id   - see L2 rule add
-* mac_conf   - default rule conf, 3 options: trap to CPU, drop packet, frwd to GMAC1
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_mac_learn_default_rule_act_set(uint32_t owner_id, tpm_unknown_mac_conf_t mac_conf)
-{
-	tpm_error_code_t ret_code;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_all_t pnc_entry;
-	uint32_t entry_id;
-	uint32_t queue_id;
-	tpm_gmacs_enum_t lpk_gmac;
-	uint32_t switch_init;
-	uint32_t mod_idx = 0;
-	tpm_pkt_mod_t mod_data;
-
-	/* check switch init */
-	ret_code = tpm_db_switch_init_get(&switch_init);
-	IF_ERROR(ret_code);
-	if (switch_init != 0) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Switch is initialized, no need for PnC MAC learn \n");
-		return TPM_FAIL;
-	}
-	/*check MAC learn defaut rule conf*/
-	if (mac_conf < TPM_UNK_MAC_TRAP || mac_conf > TPM_UNK_MAC_CONTINUE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Invalid MAC learn default rule conf(%d) \n", mac_conf);
-		return ERR_UNKNOWN_MAC_CONF_INVALID;
-	}
-
-	/* Set Structs to zero */
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	/* Get default rul entry ID */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MAC_LEARN, &range_data);
-	IF_ERROR(ret_code);
-	entry_id = range_data.pnc_range_conf.range_end;
-
-	/* Get mod_idx */
-	if (TPM_DB_OK != tpm_db_mac_learn_mod_idx_get(&mod_idx)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "MAC learn mod index get failed \n");
-		return TPM_FAIL;
-	}
-
-	/* construct default rule */
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id;
-	/* Set port_id */
-	pnc_entry.tcam_entry.port_ids = TPM_BM_GMAC_0;
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = TPM_TRUE;
-
-	pnc_entry.sram_entry.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-	switch (mac_conf) {
-	case TPM_UNK_MAC_TRAP:
-		if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-							   &queue_id,
-							   TPM_GMAC1_QUEUE_MAC_LEARN_TRAFFIC)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "loopback gmac queue get failed \n");
-			return TPM_FAIL;
-		}
-		/* Alloc PMT for MAC learn if needed */
-		if (mod_idx == 0) {
-			memset((uint8_t *) &mod_data, 0, sizeof(tpm_pkt_mod_t));
-			mod_data.mh_mod = TPM_MOD2_MAC_LEARN_MH;
-			if (tpm_mod2_entry_set(owner_id,
-					       lpk_gmac,
-					       TPM_MH_SET,
-					       0,
-					       &mod_data,
-					       &mod_idx)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "PMT entry for MAC leanrn get failed\n");
-				return TPM_FAIL;
-			}
-			/* store mod_idx in TPM_DB */
-			if (TPM_DB_OK != tpm_db_mac_learn_mod_idx_set(mod_idx)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "Mod index set to tpm db failed \n");
-				return TPM_FAIL;
-			}
-		}
-		/* Frwd to loopback GMAC1 */
-		pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_GMAC1 << TPM_TXP_FL_SHIFT);
-		pnc_entry.sram_entry.pnc_queue = queue_id;
-		/* Set MH */
-		pnc_entry.sram_entry.flowid_val |= mod_idx;
-		pnc_entry.sram_entry.flowid_updt_mask |= TPM_MOD_FL_UPDT_MASK;
-		break;
-	case TPM_UNK_MAC_DROP:
-		/* Drop the packet */
-		pnc_entry.sram_entry.res_info_15_0_data |= (1 << TPM_PNC_RI_DISC_BIT);
-		pnc_entry.sram_entry.res_info_15_0_mask |= (1 << TPM_PNC_RI_DISC_BIT);
-		/* delete MAC learn PMT entry if there is */
-		if (mod_idx) {
-			if (tpm_mod2_entry_del(owner_id, TPM_ENUM_GMAC_1, mod_idx)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "PMT entry del failed\n");
-				return TPM_FAIL;
-			}
-			/* clearn mod index in TPM_DB */
-			if (TPM_DB_OK != tpm_db_mac_learn_mod_idx_set(0)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "MAC learn mod index clear failed \n");
-				return TPM_FAIL;
-			}
-		}
-		break;
-	case TPM_UNK_MAC_CONTINUE:
-		if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-							   &queue_id,
-							   TPM_GMAC1_QUEUE_DATA_TRAFFIC)) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "loopback gmac queue get failed \n");
-			return TPM_FAIL;
-		}
-		/* Frwd to loopback GMAC1 */
-		pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_GMAC1 << TPM_TXP_FL_SHIFT);
-		pnc_entry.sram_entry.pnc_queue = queue_id;
-		/* delete MAC learn PMT entry if there is */
-		if (mod_idx) {
-			if (tpm_mod2_entry_del(owner_id, TPM_ENUM_GMAC_1, mod_idx)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "PMT entry del failed\n");
-				return TPM_FAIL;
-			}
-			/* clearn mod index in TPM_DB */
-			if (TPM_DB_OK != tpm_db_mac_learn_mod_idx_set(0)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "MAC learn mod index clear failed \n");
-				return TPM_FAIL;
-			}
-		}
-		break;
-	default:
-		break;
-	}
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-tpm_error_code_t tpm_acl_rcvr_func_mac_learn(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_static_mac_rule(owner_id, &(api_data->api_rule_data.l2_prim_key.l2_key));
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ds_load_balance(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_ds_load_balance_acl_rule(owner_id, api_data->rule_num, &rule_index_tmp,
-					api_data->api_rule_data.l2_prim_key.parse_rule_bm,
-					api_data->api_rule_data.l2_prim_key.parse_flags_bm,
-					&(api_data->api_rule_data.l2_prim_key.l2_key),
-					api_data->api_rule_data.l2_prim_key.pkt_frwd.trg_port);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_api_entry_update_rule_idx(TPM_DS_LOAD_BALANCE_ACL, rule_index_tmp, api_data->rule_idx);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_cpu_loopback(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_cpu_loopback_rule(owner_id, api_data->rule_num, &rule_index_tmp,
-					&(api_data->api_rule_data.l2_prim_key.pkt_frwd));
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_api_entry_update_rule_idx(TPM_CPU_LOOPBACK_ACL, rule_index_tmp, api_data->rule_idx);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_l2_prim(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_l2_prim_acl_rule(owner_id, api_data->api_rule_data.l2_prim_key.src_port,
-					api_data->rule_num, &rule_index_tmp,
-					api_data->api_rule_data.l2_prim_key.parse_rule_bm,
-					api_data->api_rule_data.l2_prim_key.parse_flags_bm,
-					&(api_data->api_rule_data.l2_prim_key.l2_key),
-					&(api_data->api_rule_data.l2_prim_key.pkt_frwd),
-					&(api_data->api_rule_data.l2_prim_key.pkt_mod),
-					api_data->api_rule_data.l2_prim_key.pkt_mod_bm,
-					&(api_data->api_rule_data.l2_prim_key.rule_action));
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_L2_PRIM_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_l3_type(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_l3_type_acl_rule(owner_id, api_data->api_rule_data.l3_type_key.src_port,
-					api_data->rule_num, &rule_index_tmp,
-					api_data->api_rule_data.l3_type_key.parse_rule_bm,
-					api_data->api_rule_data.l3_type_key.parse_flags_bm,
-					&(api_data->api_rule_data.l3_type_key.l3_key),
-					&(api_data->api_rule_data.l3_type_key.pkt_frwd),
-					&(api_data->api_rule_data.l3_type_key.rule_action));
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_L3_TYPE_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv4(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	ret_code = tpm_proc_add_ipv4_acl_rule(owner_id, api_data->api_rule_data.ipv4_key.src_port,
-					api_data->rule_num, &rule_index_tmp,
-					api_data->api_rule_data.ipv4_key.parse_rule_bm,
-					api_data->api_rule_data.ipv4_key.parse_flags_bm,
-					&(api_data->api_rule_data.ipv4_key.ipv4_key),
-					&(api_data->api_rule_data.ipv4_key.pkt_frwd),
-					&(api_data->api_rule_data.ipv4_key.pkt_mod),
-					api_data->api_rule_data.ipv4_key.pkt_mod_bm,
-					&(api_data->api_rule_data.ipv4_key.rule_action));
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_IPV4_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv4_mc(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	ret_code = tpm_proc_add_ipv4_mc_stream(owner_id,
-					api_data->api_rule_data.ipv4_mc_key.stream_num,
-					api_data->api_rule_data.ipv4_mc_key.igmp_mode,
-					api_data->api_rule_data.ipv4_mc_key.mc_stream_pppoe,
-					api_data->api_rule_data.ipv4_mc_key.vid,
-					api_data->api_rule_data.ipv4_mc_key.ipv4_src_add,
-					api_data->api_rule_data.ipv4_mc_key.ipv4_dest_add,
-					api_data->api_rule_data.ipv4_mc_key.ignore_ipv4_src,
-					api_data->api_rule_data.ipv4_mc_key.dest_queue,
-					api_data->api_rule_data.ipv4_mc_key.dest_port_bm);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_gen(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_dir_t src_dir;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	/* Check 5_tuple feature is enable/disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		ret_code = tpm_proc_add_ipv6_gen_acl_rule(owner_id, api_data->api_rule_data.ipv6_gen_key.src_port,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_gen_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_gen_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_gen_key.ipv6_gen_key),
-						&(api_data->api_rule_data.ipv6_gen_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_gen_key.pkt_mod),
-						api_data->api_rule_data.ipv6_gen_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_gen_key.rule_action));
-	else {
-		/* get direction */
-		if (FROM_LAN(api_data->api_rule_data.ipv6_gen_key.src_port))
-			src_dir = TPM_DIR_US;
-		else
-			src_dir = TPM_DIR_DS;
-		ret_code = tpm_proc_add_ipv6_gen_5t_rule(owner_id, src_dir,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_gen_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_gen_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_gen_key.l4_key),
-						&(api_data->api_rule_data.ipv6_gen_key.ipv6_gen_key),
-						&(api_data->api_rule_data.ipv6_gen_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_gen_key.pkt_mod),
-						api_data->api_rule_data.ipv6_gen_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_gen_key.rule_action));
-	}
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_IPV6_GEN_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_dip(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_dir_t src_dir;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	/* Check 5_tuple feature is enable/disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		ret_code = tpm_proc_add_ipv6_dip_acl_rule(owner_id, api_data->api_rule_data.ipv6_dip_key.src_port,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_dip_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_dip_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_dip_key.ipv6_dipkey),
-						&(api_data->api_rule_data.ipv6_dip_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_dip_key.pkt_mod),
-						api_data->api_rule_data.ipv6_dip_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_dip_key.rule_action));
-	else {
-		/* get direction */
-		if (FROM_LAN(api_data->api_rule_data.ipv6_dip_key.src_port))
-			src_dir = TPM_DIR_US;
-		else
-			src_dir = TPM_DIR_DS;
-		ret_code = tpm_proc_add_ipv6_dip_5t_rule(owner_id, src_dir,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_dip_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_dip_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_dip_key.l4_key),
-						&(api_data->api_rule_data.ipv6_dip_key.ipv6_gen_key),
-						&(api_data->api_rule_data.ipv6_dip_key.ipv6_dipkey),
-						&(api_data->api_rule_data.ipv6_dip_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_dip_key.pkt_mod),
-						api_data->api_rule_data.ipv6_dip_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_dip_key.rule_action));
-	}
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_IPV6_DIP_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_mc(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	ret_code = tpm_proc_add_ipv6_mc_stream(owner_id,
-					api_data->api_rule_data.ipv6_mc_key.stream_num,
-					api_data->api_rule_data.ipv6_mc_key.igmp_mode,
-					api_data->api_rule_data.ipv6_mc_key.mc_stream_pppoe,
-					api_data->api_rule_data.ipv6_mc_key.vid,
-					api_data->api_rule_data.ipv6_mc_key.ipv6_src_add,
-					api_data->api_rule_data.ipv6_mc_key.ipv6_dest_add,
-					api_data->api_rule_data.ipv6_mc_key.ignore_ipv6_src,
-					api_data->api_rule_data.ipv6_mc_key.dest_queue,
-					api_data->api_rule_data.ipv6_mc_key.dest_port_bm);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_nh(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	ret_code = tpm_proc_add_ipv6_nh_acl_rule(owner_id,
-					api_data->rule_num, &rule_index_tmp,
-					api_data->api_rule_data.ipv6_nh_key.parse_flags_bm,
-					api_data->api_rule_data.ipv6_nh_key.nh_iter,
-					api_data->api_rule_data.ipv6_nh_key.nh,
-					&(api_data->api_rule_data.ipv6_nh_key.pkt_frwd),
-					&(api_data->api_rule_data.ipv6_nh_key.rule_action));
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_IPV6_NH_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_l4(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	uint32_t rule_index_tmp;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_dir_t src_dir;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-
-	/* Check 5_tuple feature is enable/disabled */
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED)
-		ret_code = tpm_proc_add_ipv6_l4_ports_acl_rule(owner_id, api_data->api_rule_data.ipv6_l4_key.src_port,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_l4_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_l4_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_l4_key.l4_key),
-						&(api_data->api_rule_data.ipv6_l4_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_l4_key.pkt_mod),
-						api_data->api_rule_data.ipv6_l4_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_l4_key.rule_action));
-	else {
-		/* get direction */
-		if (FROM_LAN(api_data->api_rule_data.ipv6_l4_key.src_port))
-			src_dir = TPM_DIR_US;
-		else
-			src_dir = TPM_DIR_DS;
-		ret_code = tpm_proc_add_ipv6_l4_ports_5t_rule(owner_id, src_dir,
-						api_data->rule_num, &rule_index_tmp,
-						api_data->api_rule_data.ipv6_l4_key.parse_rule_bm,
-						api_data->api_rule_data.ipv6_l4_key.parse_flags_bm,
-						&(api_data->api_rule_data.ipv6_l4_key.l4_key),
-						&(api_data->api_rule_data.ipv6_l4_key.pkt_frwd),
-						&(api_data->api_rule_data.ipv6_l4_key.pkt_mod),
-						api_data->api_rule_data.ipv6_l4_key.pkt_mod_bm,
-						&(api_data->api_rule_data.ipv6_l4_key.rule_action));
-	}
-	IF_ERROR(ret_code);
-
-	if (rule_idx_updt_en) {
-		ret_code = tpm_db_api_entry_update_rule_idx(TPM_L4_ACL, rule_index_tmp, api_data->rule_idx);
-		IF_ERROR(ret_code);
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_acl_rcvr_func_cnm(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en)
-{
-	tpm_error_code_t ret_code;
-	static tpm_src_port_type_t src_port = TPM_SRC_PORT_UNI_0;
-	static uint32_t precedence_base = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "rule_index:[%d]\n", api_data->rule_idx);
-	if (src_port < api_data->api_rule_data.cnm_key.src_port) {
-		src_port = api_data->api_rule_data.cnm_key.src_port;
-		precedence_base = api_data->rule_num;
-	} else if (src_port > api_data->api_rule_data.cnm_key.src_port) {
-		src_port = api_data->api_rule_data.cnm_key.src_port;
-		precedence_base = 0;
-	}
-	ret_code = tpm_ctc_cm_acl_rule_add(owner_id, api_data->api_rule_data.cnm_key.src_port,
-					api_data->rule_num - precedence_base,
-					api_data->api_rule_data.cnm_key.l2_parse_rule_bm,
-					api_data->api_rule_data.cnm_key.ipv4_parse_rule_bm,
-					api_data->api_rule_data.cnm_key.ipv6_parse_rule_bm,
-					&(api_data->api_rule_data.cnm_key.l2_key),
-					&(api_data->api_rule_data.cnm_key.ipv4_key),
-					&(api_data->api_rule_data.cnm_key.ipv6_key),
-					&(api_data->api_rule_data.cnm_key.pkt_frwd),
-					api_data->api_rule_data.cnm_key.pkt_act,
-					api_data->api_rule_data.cnm_key.pbits);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-
-tpm_error_code_t tpm_acl_rcvr_func_get(tpm_api_type_t api_type, tpm_acl_recovery_func *func)
-{
-	uint32_t api_loop;
-	uint32_t api_max;
-
-	api_max = sizeof(tpm_hot_swap_acl_recovery)/sizeof(tpm_hot_swap_acl_recovery_t);
-
-	for (api_loop = 0; api_loop < api_max; api_loop++) {
-
-		if (tpm_hot_swap_acl_recovery[api_loop].api_type == api_type) {
-			*func = tpm_hot_swap_acl_recovery[api_loop].func;
-			return TPM_OK;
-		}
-	}
-	return (TPM_OK);
-}
-#ifdef CONFIG_MV_ETH_WAN_SWAP
-
-tpm_error_code_t tpm_proc_check_hot_swap_profile(uint32_t owner_id,
-							tpm_eth_complex_profile_t profile_id)
-{
-	tpm_error_code_t ret_code;
-	tpm_api_type_t api_type;
-	tpm_eth_complex_profile_t profile_current;
-
-	/* Check owner_id */
-	for (api_type = TPM_API_MAC_LEARN; api_type < TPM_MAX_API_TYPES; api_type++) {
-		ret_code = tpm_owner_id_check(api_type, owner_id);
-		IF_ERROR(ret_code);
-	}
-
-	/* check profile id */
-	profile_current = tpm_db_eth_cmplx_profile_get();
-	if (    TPM_G0_WAN_G1_INT_SWITCH == profile_current
-	     && TPM_G1_WAN_G0_INT_SWITCH == profile_id)
-		/* allowed */
-		;
-	else if (    TPM_G1_WAN_G0_INT_SWITCH == profile_current
-	          && TPM_G0_WAN_G1_INT_SWITCH == profile_id)
-		/* allowed */
-		;
-	else {
-		/* not support */
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "So far only swapping  from TPM_PON_G1_WAN_G0_INT_SWITCH "
-				"to TPM_PON_G0_WAN_G1_INT_SWITCH or vice versa are supported,"
-				"current profile: [%d], new profile: [%d]\n", profile_current, profile_id);
-		return ERR_FEAT_UNSUPPORT;
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_proc_hot_swap_update_acl_rules(uint32_t owner_id)
-{
-	tpm_db_api_entry_t api_data;
-	tpm_api_type_t api_type;
-	tpm_acl_recovery_func func = NULL;
-	tpm_api_sections_t api_section;
-	int32_t db_ret = 0;
-	int32_t next_rule = 0;
-	uint32_t current_rule = 0;
-	uint32_t rule_index = 0;
-	uint32_t rule_index_max = 0;
-	tpm_error_code_t ret_code;
-	uint32_t rule_idx_updt_en = 0;
-	tpm_pnc_ranges_t range_id;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	//tpm_glob_trace = ~0;
-
-	rule_index_max = 1000;
-
-	/* add ACL rules again */
-	for (api_type = TPM_API_MAC_LEARN; api_type < TPM_MAX_API_TYPES; api_type++) {
-
-		/* Get acl recovery func */
-		ret_code = tpm_acl_rcvr_func_get(api_type, &func);
-		IF_ERROR(ret_code);
-
-		/* Get the api_section */
-		ret_code = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-		IF_ERROR(ret_code);
-
-		current_rule = -1;
-
-		TPM_OS_INFO(TPM_DB_MOD, "api_type(%d)\n\n", api_type);
-
-		ret_code = tpm_db_api_entry_bak_get_next(api_section, current_rule, &next_rule);
-		IF_ERROR(ret_code);
-
-		if (-1 == next_rule) {
-			continue;
-		}
-
-		/* Get Range_Id */
-		tpm_db_api_section_main_pnc_get(api_section, &range_id);
-
-		/* Get Range Conf */
-		ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-		IF_ERROR(ret_code);
-
-		if (range_conf.range_type == TPM_RANGE_TYPE_ACL)
-			rule_idx_updt_en = TPM_TRUE;
-		else
-			rule_idx_updt_en = TPM_FALSE;
-
-		while (-1 != next_rule) {
-			/*get api section table entry*/
-			if (tpm_db_api_section_bak_ent_tbl_get(api_section, &api_data, next_rule)) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "get API data failed, api_section:[%d], rule_index:[%d] \n",
-						api_section, rule_index);
-				return TPM_FAIL;
-			}
-
-			if (api_data.valid != TPM_DB_VALID) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD, "API data is not valid, api_section:[%d], rule_index:[%d] \n",
-						api_section, rule_index);
-				return TPM_FAIL;
-			}
-			TPM_OS_INFO(TPM_DB_MOD, "rule_num(%d), rule_idx(%d) \n", api_data.rule_num, api_data.rule_idx);
-
-			ret_code = (*func)(owner_id, &api_data, rule_idx_updt_en);
-			IF_ERROR(ret_code);
-
-			if (rule_index_max < api_data.rule_idx)
-				rule_index_max = api_data.rule_idx;
-
-			ret_code = tpm_db_api_entry_bak_get_next(api_section, api_data.rule_num, &next_rule);
-			IF_ERROR(ret_code);
-		}
-
-		IF_ERROR(ret_code);
-	}
-
-	/* update the max rule index */
-	db_ret = tpm_db_rule_index_set(rule_index_max + 1);
-	if (TPM_DB_OK != db_ret) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "update rule_index failed, before hot swap, max rule_index:[%d]\n", rule_index_max);
-		return TPM_FAIL;
-	}
-	return (TPM_OK);
-}
-tpm_error_code_t tpm_proc_hot_swap_misc_cfg(tpm_eth_complex_profile_t profile_id)
-{
-	tpm_error_code_t ret_code;
-	tpm_init_gmac_conn_conf_t	gmac_port_conf[TPM_NUM_GMACS];
-	tpm_gmacs_enum_t gmac_i;
-	uint32_t gmac0_mh_en = 0;
-	uint32_t gmac1_mh_en = 0;
-	tpm_db_mh_src_t ds_mh_set_conf;
-
-	/* keep current API data */
-	tpm_db_api_data_backup();
-
-	/* do not update switch */
-	tpm_db_switch_init_set(false);
-
-	/* restore normal IPG of GMAC and switch */
-	ret_code = tpm_init_ipg(TPM_MH_LEN);
-	IF_ERROR(ret_code);
-
-	/* set new profile_id */
-	tpm_db_eth_cmplx_profile_set(profile_id);
-
-	/* update active wan and GMAC conf */
-	for (gmac_i = 0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++)
-		tpm_db_gmac_conn_conf_get(gmac_i, &(gmac_port_conf[gmac_i]));
-
-	if (TPM_G0_WAN_G1_INT_SWITCH == profile_id) {
-		tpm_db_active_wan_set(TPM_ENUM_GMAC_0);
-		gmac_port_conf[TPM_ENUM_GMAC_0].conn = TPM_GMAC_CON_RGMII2;
-		gmac_port_conf[TPM_ENUM_GMAC_0].port_src = TPM_SRC_PORT_WAN;
-		gmac_port_conf[TPM_ENUM_GMAC_1].conn = TPM_GMAC_CON_SWITCH_5;
-		gmac_port_conf[TPM_ENUM_GMAC_1].port_src = TPM_SRC_PORT_ILLEGAL;
-		gmac0_mh_en = TPM_FALSE;
-		gmac1_mh_en = TPM_TRUE;
-	} else if (TPM_G1_WAN_G0_INT_SWITCH == profile_id){
-		tpm_db_active_wan_set(TPM_ENUM_GMAC_1);
-		gmac_port_conf[TPM_ENUM_GMAC_0].conn = TPM_GMAC_CON_SWITCH_4;
-		gmac_port_conf[TPM_ENUM_GMAC_0].port_src = TPM_SRC_PORT_ILLEGAL;
-		gmac_port_conf[TPM_ENUM_GMAC_1].conn = TPM_GMAC_CON_GE_PHY;
-		gmac_port_conf[TPM_ENUM_GMAC_1].port_src = TPM_SRC_PORT_WAN;
-		gmac0_mh_en = TPM_TRUE;
-		gmac1_mh_en = TPM_FALSE;
-	}
-
-	/* Set GMAC Port Config */
-	ret_code = tpm_db_gmac_conn_conf_set(gmac_port_conf, TPM_NUM_GMACS);
-	IF_ERROR(ret_code);
-
-	/* update GMAC func */
-	tpm_db_mac_func_set();
-
-	tpm_db_ds_mh_get_conf_set(&ds_mh_set_conf);
-
-	/* update MH conf */
-	ret_code = tpm_init_mh(ds_mh_set_conf, gmac0_mh_en, gmac1_mh_en, gmac_port_conf);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_db_gmac_mh_en_conf_set(TPM_ENUM_GMAC_0, gmac0_mh_en);
-	IF_ERROR(ret_code);
-	ret_code = tpm_db_gmac_mh_en_conf_set(TPM_ENUM_GMAC_1, gmac1_mh_en);
-	IF_ERROR(ret_code);
-
-	/* update rate limitation */
-	ret_code = tpm_init_get_gmac_queue_rate_limit();
-	IF_ERROR(ret_code);
-
-	/* exchange rate limitation between G0/G1 */
-	tpm_init_get_gmac_queue_rate_limit();
-	tpm_db_wan_lan_rate_limit_exchange();
-
-	/* set new IPG of GMAC and switch */
-	ret_code = tpm_init_ipg((-TPM_MH_LEN));
-	IF_ERROR(ret_code);
-
-	/* switch pppoe length reg's value */
-	tpm_mod2_registers_init(TPM_ENUM_GMAC_0, 0);
-	tpm_mod2_registers_init(TPM_ENUM_GMAC_1, 0);
-
-#if 0
-	/* Set GMAC mh_enable */
-	if (mv_eth_ctrl_flag(TPM_ENUM_GMAC_0, MV_ETH_F_MH, gmac0_mh_en)){
-		TPM_OS_ERROR(TPM_INIT_MOD, " set GMAC0 MH en (%d) failed\n", gmac0_mh_en);
-		return (TPM_FAIL);
-	}
-	if (mv_eth_ctrl_flag(TPM_ENUM_GMAC_1, MV_ETH_F_MH, gmac1_mh_en)){
-		TPM_OS_ERROR(TPM_INIT_MOD, " set GMAC1 MH en (%d) failed\n", gmac1_mh_en);
-		return (TPM_FAIL);
-	}
-#endif
-
-	return (TPM_OK);
-}
-
-extern int mv_eth_wan_swap(int wan_mode);
-tpm_error_code_t tpm_proc_hot_swap_lsp(tpm_eth_complex_profile_t profile_id)
-{
-	int lsp_ret = 0;
-
-	if (TPM_G0_WAN_G1_INT_SWITCH == profile_id)
-		lsp_ret = mv_eth_wan_swap(0);
-	else if (TPM_G1_WAN_G0_INT_SWITCH == profile_id)
-		lsp_ret = mv_eth_wan_swap(1);
-
-	if (lsp_ret) {
-		TPM_OS_ERROR(TPM_HWM_MOD, "LSP hot swap failed, return value (%d)\n", lsp_ret);
-		return (TPM_FAIL);
-	}
-	return (TPM_OK);
-}
-
-tpm_error_code_t tpm_proc_hot_swap_profile(uint32_t owner_id,
-				    tpm_eth_complex_profile_t profile_id)
-{
-	tpm_error_code_t ret_code = TPM_OK;
-
-	ret_code = tpm_proc_check_hot_swap_profile(owner_id, profile_id);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_hot_swap_lsp(profile_id);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_proc_hot_swap_misc_cfg(profile_id);
-	IF_ERROR(ret_code);
-
-	/* perform mib-reset */
-	tpm_proc_mib_reset(owner_id, TPM_ENUM_RESET_LEVEL0);
-
-	/* tpm_db recovery */
-	tpm_db_api_data_rcvr();
-
-	ret_code = tpm_proc_hot_swap_update_acl_rules(owner_id);
-	IF_ERROR(ret_code);
-
-	return (TPM_OK);
-}
-#endif /* CONFIG_MV_ETH_WAN_SWAP */
-
-/*******************************************************************************
-* tpm_proc_mac_learn_entry_num_get()
-*
-* DESCRIPTION:    Function used to set mac learn default rule action dynamiclly.
-*
-* INPUTS:
-* none
-*
-* OUTPUTS:
-* entry_num  - current MAC learn entry count in MAC_LEARN range, not including default one
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_mac_learn_entry_num_get(uint32_t *entry_num)
-{
-	tpm_error_code_t ret_code;
-	uint32_t valid_entry_num = 0;
-	uint32_t api_rng_size, tbl_start;
-	int32_t apisec_last_valid_index;
-	tpm_pnc_ranges_t pnc_range;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable = TPM_PNC_MAC_LEARN_DISABLED;
-
-	/* check whether mac_learn_enable is enabled or not */
-	ret_code = tpm_db_pnc_mac_learn_enable_get(&pnc_mac_learn_enable);
-	IF_ERROR(ret_code);
-	if (pnc_mac_learn_enable == TPM_PNC_MAC_LEARN_DISABLED) {
-		printk("MAC learn is not enabled\n");
-		return TPM_FAIL;
-	}
-
-	/* get API section info */
-	ret_code = tpm_db_api_section_get(TPM_PNC_MAC_LEARN_ACL,
-					  &api_rng_size,
-					  &valid_entry_num,
-					  &pnc_range,
-					  &apisec_last_valid_index,
-					  &tbl_start);
-	IF_ERROR(ret_code);
-
-	*entry_num = valid_entry_num;
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_proc_hwf_admin_set()
-*
-* DESCRIPTION:    Function used to enable/disable hwf to certain port.
-*
-* INPUTS:
-*
-* port
-* txp
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_proc_hwf_admin_set(tpm_gmacs_enum_t port, uint8_t txp, uint8_t enable)
-{
-	uint32_t valid, q_num;
-	tpm_db_sched_t sched_method;
-	tpm_db_txq_owner_t queue_owner;
-	uint32_t owner_queue_num;
-	uint32_t queue_size;
-	uint32_t queue_weight;
-	int32_t db_ret;
-	tpm_db_tx_mod_t tx_mod;
-	uint32_t curr_state = 0;
-
-	//TPM_OS_INFO(TPM_PNCL_MOD, "port = %d txp = %d enable = %d\n", port, txp, enable);
-
-	printk("TPM T-Cont API, port(%d), txp(%d) enable(%d)\n", port, txp, enable);
-
-	tx_mod = port + txp;
-
-	if (tx_mod >= TPM_MAX_NUM_TX_PORTS) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "input invalid, port = %d txp = %d\n", port, txp);
-		return ERR_OMCI_TCONT_INVALID;
-	}
-
-	for (q_num = 0; q_num < TPM_MAX_NUM_TX_QUEUE; q_num++) {
-		db_ret = tpm_db_gmac_tx_q_conf_get(tx_mod, q_num, &valid, &sched_method,
-					&queue_owner, &owner_queue_num, &queue_size,
-					&queue_weight);
-		if (!valid)
-		{
-			//TPM_OS_INFO(TPM_PNCL_MOD, "Q-num = %d not valid, continue\n", q_num);
-			continue;
-		}
-
-		/* HWF Traffic */
-		/* =========== */
-		if (queue_owner != TPM_Q_OWNER_CPU)
-		{
-			/* get the hwf en first */
-			curr_state = NETA_HWF_TX_PORT_MASK(port + txp) | NETA_HWF_TXQ_MASK(q_num);
-			MV_REG_WRITE(NETA_HWF_TX_PTR_REG((queue_owner - 1)), curr_state);
-			curr_state = MV_REG_READ(NETA_HWF_TXQ_ENABLE_REG((queue_owner - 1)));
-
-			/* enable/disable hwf */
-			if (enable == true)
-				printk("HWF T-Cont active, port(%d), txp(%d), que(%d)\n", port, txp, q_num);
-
-			mvNetaHwfTxqEnable((queue_owner - 1), port, txp, q_num, enable);
-
-			//TPM_OS_INFO(TPM_PNCL_MOD,"GMAC = %d TCONT = %d Q = %d HWF: owner_rx %d\n", port, txp, q_num, (queue_owner - 1));
-
-			if ((!enable) && (curr_state))
-			{
-				//TPM_OS_INFO(TPM_PNCL_MOD, "Call mv_eth_txq_clean - current state: %d, enable %d\n", curr_state, enable);
-				printk("HWF T-Cont stop/clean, port(%d), txp(%d), que(%d)\n", port, txp, q_num);
-				mv_eth_txq_clean(port, txp, q_num);
-			}
-		}
-		/* SWF Traffic */
-		/* =========== */
-		else
-		{
-			if (!enable)
-			{
-				printk("SWF T-Cont stop/clean, port(%d), txp(%d), que(%d)\n", port, txp, q_num);
-				mv_cust_set_tcont_state(txp, false);
-				mv_eth_txq_clean(port, txp, q_num);
-			}
-			else
-			{
-				printk("SWF T-Cont active, port(%d), txp(%d), que(%d)\n", port, txp, q_num);
-				mv_cust_set_tcont_state(txp, true);
-			}
-		}
-	}
-
-	return TPM_OK;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.h
deleted file mode 100644
index 9f47c12..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pkt_proc_logic.h
+++ /dev/null
@@ -1,936 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_pkt_proc_logic.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.3
-*
-*
-*******************************************************************************/
-#ifndef _TPM_PKT_PROCL_H_
-#define _TPM_PKT_PROCL_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-#define MASK_AI(value)   (0x7f & (value))
-
-#define AI_TO_MASK(off, size)   (((1<<size) - 1) << off)
-
-/* Definitions for statically configured AI bits */
-
-#define      TPM_AI_TAG1_BIT_OFF                (0)
-#define      TPM_AI_TAG1_BIT_SIZE               (1)
-#define      TPM_AI_TAG1_MASK                   (AI_TO_MASK(TPM_AI_TAG1_BIT_OFF, TPM_AI_TAG1_BIT_SIZE))
-
-#define      TPM_AI_NH2_ITER_BIT_OFF            (0)
-#define      TPM_AI_NH2_ITER_BIT_SIZE           (1)
-#define      TPM_AI_NH2_ITER_MASK               (AI_TO_MASK(TPM_AI_NH2_ITER_BIT_OFF, TPM_AI_NH2_ITER_BIT_SIZE))
-
-#define      TPM_AI_L4P_BIT_OFF                 (0)
-#define      TPM_AI_L4P_BIT_SIZE                (1)
-#define      TPM_AI_L4P_MASK                    (AI_TO_MASK(TPM_AI_L4P_BIT_OFF, TPM_AI_L4P_BIT_SIZE))
-
-#define      TPM_AI_IPV6_SUBFLOW_PART1_BIT_OFF  (0)
-#define      TPM_AI_IPV6_SUBFLOW_PART1_BIT_SIZE (TPM_NUM_IPV6_SUBFLOW_BITS_P1)
-#define      TPM_AI_IPV6_SUBFLOW_PART1_MASK     (AI_TO_MASK(TPM_AI_IPV6_SUBFLOW_PART1_BIT_OFF, \
-															TPM_AI_IPV6_SUBFLOW_PART1_BIT_SIZE))
-#define      TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF  (0)
-#define      TPM_AI_IPV6_MC_SIP_PART1_BIT_SIZE (TPM_NUM_IPV6_MC_SIP_BITS_P1)
-#define      TPM_AI_IPV6_MC_SIP_PART1_MASK     (AI_TO_MASK(TPM_AI_IPV6_MC_SIP_PART1_BIT_OFF, \
-							   TPM_AI_IPV6_MC_SIP_PART1_BIT_SIZE))
-
-#define      TPM_AI_CNM_IPV4_BIT_OFF            (0)
-#define      TPM_AI_CNM_IPV4_BIT_SIZE           (1)
-#define      TPM_AI_CNM_IPV4_MASK               (AI_TO_MASK(TPM_AI_CNM_IPV4_BIT_OFF, TPM_AI_CNM_IPV4_BIT_SIZE))
-
-#define      TPM_AI_TAG2_BIT_OFF                (1)
-#define      TPM_AI_TAG2_BIT_SIZE               (1)
-#define      TPM_AI_TAG2_MASK                   (AI_TO_MASK(TPM_AI_TAG2_BIT_OFF, TPM_AI_TAG2_BIT_SIZE))
-
-#define      TPM_AI_PPPOE_BIT_OFF               (1)
-#define      TPM_AI_PPPOE_BIT_SIZE              (1)
-#define      TPM_AI_PPPOE_MASK                  (AI_TO_MASK(TPM_AI_PPPOE_BIT_OFF, TPM_AI_PPPOE_BIT_SIZE))
-
-#define      TPM_AI_CNM_IPV4_PRE_KEY_BIT_OFF    (1)
-#define      TPM_AI_CNM_IPV4_PRE_KEY_BIT_SIZE   (3)
-#define      TPM_AI_CNM_IPV4_PRE_KEY_MASK       (AI_TO_MASK(TPM_AI_CNM_IPV4_PRE_KEY_BIT_OFF, \
-							    TPM_AI_CNM_IPV4_PRE_KEY_BIT_SIZE))
-
-#define      TPM_AI_CNM_PREC_BIT_OFF            (1)
-#define      TPM_AI_CNM_PREC_BIT_SIZE           (3)
-#define      TPM_AI_CNM_PREC_MASK               (AI_TO_MASK(TPM_AI_CNM_PREC_BIT_OFF, TPM_AI_CNM_PREC_BIT_SIZE))
-
-#define      TPM_AI_DNRT_BIT_OFF                (2)
-#define      TPM_AI_DNRT_BIT_SIZE               (1)
-#define      TPM_AI_DNRT_MASK                   (AI_TO_MASK(TPM_AI_DNRT_BIT_OFF, TPM_AI_DNRT_BIT_SIZE))
-
-#define      TPM_AI_DNRT_DS_TRUNK_BIT_OFF       (3)
-#define      TPM_AI_DNRT_DS_TRUNK_BIT_SIZE      (1)
-#define      TPM_AI_DNRT_DS_TRUNK_MASK          (AI_TO_MASK(TPM_AI_DNRT_DS_TRUNK_BIT_OFF, TPM_AI_DNRT_DS_TRUNK_BIT_SIZE))
-
-#define      TPM_AI_MTM_BIT_OFF                 (2)
-#define      TPM_AI_MTM_BIT_SIZE                (1)
-#define      TPM_AI_MTM_MASK                    (AI_TO_MASK(TPM_AI_MTM_BIT_OFF, TPM_AI_MTM_BIT_SIZE))
-
-#define      TPM_AI_IPV6_MC_SIP_PART2_BIT_OFF   (2)
-#define      TPM_AI_IPV6_MC_SIP_PART2_BIT_SIZE  (TPM_NUM_IPV6_MC_SIP_BITS_P2)
-#define      TPM_AI_IPV6_MC_SIP_PART2_MASK      (AI_TO_MASK(TPM_AI_IPV6_MC_SIP_PART2_BIT_OFF, \
-							    TPM_AI_IPV6_MC_SIP_PART2_BIT_SIZE))
-#define      TPM_AI_TO_CPU_BIT_OFF              (3)
-#define      TPM_AI_TO_CPU_BIT_SIZE             (1)
-#define      TPM_AI_TO_CPU_MASK                 (AI_TO_MASK(TPM_AI_TO_CPU_BIT_OFF, TPM_AI_TO_CPU_BIT_SIZE))
-
-#define      TPM_AI_SPLIT_MOD_BIT_OFF           (3)
-#define      TPM_AI_SPLIT_MOD_BIT_SIZE          (1)
-#define      TPM_AI_SPLIT_MOD_MASK              (AI_TO_MASK(TPM_AI_SPLIT_MOD_BIT_OFF, TPM_AI_SPLIT_MOD_BIT_SIZE))
-
-#define      TPM_AI_UNI_BIT_OFF                 (4)
-#define      TPM_AI_UNI_BIT_SIZE                (3)
-#define      TPM_AI_UNI_MASK                    (AI_TO_MASK(TPM_AI_UNI_BIT_OFF, TPM_AI_UNI_BIT_SIZE))
-
-#define      TPM_AI_MC_VID_BIT_OFF              (4)
-#define      TPM_AI_MC_VID_BIT_SIZE             (TPM_NUM_MC_VID_BITS)
-#define      TPM_AI_MC_VID_MASK                 (AI_TO_MASK(TPM_AI_MC_VID_BIT_OFF, TPM_AI_MC_VID_BIT_SIZE))
-
-#define      TPM_AI_PPPOE_ADD_BIT_OFF           (4)
-#define      TPM_AI_PPPOE_ADD_BIT_SIZE          (1)
-#define      TPM_AI_PPPOE_ADD_MASK              (AI_TO_MASK(TPM_AI_PPPOE_ADD_BIT_OFF, TPM_AI_PPPOE_ADD_BIT_SIZE))
-
-#define      TPM_AI_IPV6_SUBFLOW_PART2_BIT_OFF  (4)
-#define      TPM_AI_IPV6_SUBFLOW_PART2_BIT_SIZE (TPM_NUM_IPV6_SUBFLOW_BITS_P2)
-#define      TPM_AI_IPV6_SUBFLOW_PART2_MASK     (AI_TO_MASK(TPM_AI_IPV6_SUBFLOW_PART2_BIT_OFF, \
-															TPM_AI_IPV6_SUBFLOW_PART2_BIT_SIZE))
-
-#define      TPM_AI_NO_PROTO_BIT_OFF            (5)
-#define      TPM_AI_NO_PROTO_BIT_SIZE           (1)
-#define      TPM_AI_NO_PROTO_MASK               (AI_TO_MASK(TPM_AI_NO_PROTO_BIT_OFF, TPM_AI_NO_PROTO_BIT_SIZE))
-
-#define      TPM_AI_NO_FRAG_BIT_OFF             (6)
-#define      TPM_AI_NO_FRAG_BIT_SIZE            (1)
-#define      TPM_AI_NO_FRAG_MASK                (AI_TO_MASK(TPM_AI_NO_FRAG_BIT_OFF, TPM_AI_NO_FRAG_BIT_SIZE))
-
-#define      TPM_AI_MC_VID_VALID_BIT_OFF        (6)
-#define      TPM_AI_MC_VID_VALID_BIT_SIZE       (1)
-#define      TPM_AI_MC_VID_VALID_MASK           (AI_TO_MASK(TPM_AI_MC_VID_VALID_BIT_OFF, TPM_AI_MC_VID_VALID_BIT_SIZE))
-
-/* End of  statically configured AI bits */
-
-#define      TPM_MAX_AS_SES_TBL_SIZE           (128)
-
-#define      TPM_TCP_FIN                       (0x1)
-#define      TPM_TCP_RES                       (0x4)
-
-#define     TPM_NH_RESERVED                    (0xFFFF)
-#define     TPM_ETHERTYPE_DSA_TAG              (0xDABC)
-
-#define PKT_DROP(pkt_act)           (pkt_act & TPM_ACTION_DROP_PK)
-#define SET_TARGET_PORT(pkt_act)    (pkt_act & TPM_ACTION_SET_TARGET_PORT)
-#define SET_TARGET_QUEUE(pkt_act)   (pkt_act & TPM_ACTION_SET_TARGET_QUEUE)
-#define SET_CPU(pkt_act)            (pkt_act & TPM_ACTION_TO_CPU)
-#define SET_MOD(pkt_act)            (pkt_act & TPM_ACTION_SET_PKT_MOD)
-#define SET_CUST(pkt_act)           (pkt_act & TPM_ACTION_CUST_CPU_PKT_PARSE)
-#define SET_UDP_CHKSUM_CALC(pkt_act) (pkt_act & TPM_ACTION_UDP_CHKSUM_CALC)
-
-#define TO_PON(dir, trg, wan, act_wan)		\
-	 (TRG_PON(trg) && (TPM_ENUM_PMAC == act_wan) && (dir == TPM_DIR_US) && \
-	 (wan == TPM_EPON || wan == TPM_GPON || wan == TPM_P2P))
-#define TO_GPON(dir, trg, wan, act_wan)	\
-	(TRG_PON(trg) && (dir == TPM_DIR_US) && (wan == TPM_GPON) && (act_wan == TPM_ENUM_PMAC))
-#define TO_EPON(dir, trg, wan, act_wan)	\
-	(TRG_PON(trg) && (dir == TPM_DIR_US) && (wan == TPM_EPON) && (act_wan == TPM_ENUM_PMAC))
-#define TO_ETHWAN(dir, trg, act_wan)		\
-	((trg == TPM_TRG_PORT_WAN) && (dir == TPM_DIR_US) && ((act_wan == TPM_ENUM_GMAC_0) || (act_wan == TPM_ENUM_GMAC_1)))
-#define TO_LAN(dir, trg)            (TRG_UNI(trg) && (dir == TPM_DIR_DS))
-#define TO_CPU(trg)                 (TRG_CPU(trg))
-
-/* TODO - TPM_TRG_UNI_4 should be from DB, not hardcoded */
-#define TRG_UNI(trg)                (trg & \
-				     (TPM_TRG_UNI_0|TPM_TRG_UNI_1|TPM_TRG_UNI_2|TPM_TRG_UNI_3|TPM_TRG_UNI_4| \
-				      TPM_TRG_UNI_5|TPM_TRG_UNI_6|TPM_TRG_UNI_7|TPM_TRG_UNI_VIRT|TPM_TRG_PORT_UNI_ANY))
-#define TRG_PON(trg)                (trg >= TPM_TRG_TCONT_0 && trg <= TPM_TRG_TCONT_7)
-#define TRG_WAN(trg)                ((trg >= TPM_TRG_TCONT_0 && trg <= TPM_TRG_TCONT_7) || (trg == TPM_TRG_PORT_WAN))
-#define TRG_CPU(trg)                (trg == TPM_TRG_PORT_CPU)
-
-#define FROM_WAN(src)               ((src == TPM_SRC_PORT_WAN) || (src == TPM_SRC_PORT_WAN_OR_LAN))
-#define FROM_SPEC_UNI(src)          (src >= TPM_SRC_PORT_UNI_0 && src <= TPM_SRC_PORT_UNI_VIRT)
-#define FROM_LAN(src)               (src != TPM_SRC_PORT_WAN)
-
-#define GMAC_IS_LAN(gmac_func)          ((gmac_func == TPM_GMAC_FUNC_LAN_AND_WAN) || (gmac_func == TPM_GMAC_FUNC_LAN))
-#define GMAC_IS_WAN(gmac_func)          ((gmac_func == TPM_GMAC_FUNC_LAN_AND_WAN) || (gmac_func == TPM_GMAC_FUNC_WAN))
-#define GMAC_IS_UNI_LAN(gmac_func)      (gmac_func == TPM_GMAC_FUNC_LAN_UNI)
-#define GMAC_IS_UNI_VIRT(gmac_func)     (gmac_func == TPM_GMAC_FUNC_VIRT_UNI)
-#define GMAC_IS_DS_UNI_LAN(gmac_func)   (gmac_func == TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI)
-
-
-#define TPM_CNM_L2_MAIN_LUID_OFFSET      (0)
-#define TPM_CNM_ETY_MAIN_LUID_OFFSET     (1)
-#define TPM_CNM_IPV4_MAIN_LUID_OFFSET    (2)
-#define TPM_CNM_IPV6_MAIN_LUID_OFFSET    (3)
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-typedef enum {
-	TTL_ZERO_DROP,
-	TTL_ZERO_TO_CPU
-} ttl_illegal_action_t;
-
-typedef enum {
-	TPM_ADD_DS_LOAD_BALANCE_RULE,
-	TPM_ADD_L2_PRIM_ACL_RULE,
-	TPM_ADD_L3_TYPE_ACL_RULE,
-	TPM_ADD_IPV4_ACL_RULE,
-	TPM_ADD_IPV6_NH_ACL_RULE,
-	TPM_ADD_IPV6_GEN_ACL_RULE,
-	TPM_ADD_IPV6_DIP_ACL_RULE,
-	TPM_ADD_IPV6_L4_PORTS_ACL_RULE,
-	TPM_ADD_IPV6_GEN_5T_RULE,
-	TPM_ADD_IPV6_DIP_5T_RULE,
-	TPM_ADD_IPV6_L4_PORTS_5T_RULE,
-	TPM_NUM_AI_APIS
-} tpm_pnc_apis;
-
-/*************************************************************/
-/*               STRUCTURES                                  */
-/*************************************************************/
-
-typedef struct {
-	tpm_src_port_type_t src_port;
-	uint32_t mc_vid_entry;
-	uint32_t ipv6_subflow;
-	uint32_t ipv4_pre_key;
-	uint32_t cnm_prec;
-	uint32_t ipv6_mc_sip_indx;
-} tpm_ai_vectors_t;
-
-typedef struct {
-	tpm_pnc_apis api_num;
-	tpm_parse_fields_t sup_parse_fields;
-	tpm_parse_flags_t sup_parse_flags;
-	tpm_pkt_action_t forbidden_actions;
-} tpm_api_sup_param_val_t;
-
-/* Structure for add mc vid */
-typedef struct {
-	uint32_t port_bm;
-	uint32_t mc_vid;
-} tpm_mc_vid_port_t;
-
-typedef struct {
-	uint32_t vid_num;
-	tpm_mc_vid_port_t mc_vid_port[TPM_MAX_NUM_UNI_PORTS];
-} tpm_mc_vid_t;
-
-/* CNM related */
-typedef int32_t (* check_cnm_ipv4_pre_filter_key_fn_t)(tpm_src_port_type_t src_port, uint32_t partner_key_bm, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-typedef int32_t (* add_cnm_ipv4_pre_filter_key_fn_t)(tpm_src_port_type_t src_port, uint32_t key_idx, uint32_t key_pattern, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-typedef int32_t (* del_cnm_ipv4_pre_filter_key_fn_t)(tpm_src_port_type_t src_port, uint32_t key_pattern, uint32_t key_idx);
-
-
-typedef struct {
-	uint32_t key_pattern;
-	check_cnm_ipv4_pre_filter_key_fn_t check_cnm_ipv4_pre_filter;
-	add_cnm_ipv4_pre_filter_key_fn_t add_cnm_ipv4_pre_filter;
-	del_cnm_ipv4_pre_filter_key_fn_t del_cnm_ipv4_pre_filter;
-} tpm_cnm_ipv4_pre_filter_rule_oper_t;
-
-typedef tpm_error_code_t (*tpm_acl_recovery_func)(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-
-typedef struct {
-	tpm_api_type_t api_type;
-	tpm_acl_recovery_func func;
-} tpm_hot_swap_acl_recovery_t;
-
-
-/* API's */
-
-tpm_error_code_t tpm_proc_mib_reset(uint32_t owner_id, tpm_reset_level_enum_t reset_level);
-
-uint32_t tpm_proc_get_cpu_lpbk_entry_num(void);
-
-tpm_error_code_t tpm_proc_increase_cpu_lpbk_entry_num(void);
-
-tpm_error_code_t tpm_proc_decrease_cpu_lpbk_entry_num(void);
-
-tpm_error_code_t tpm_proc_check_cpu_wan_loopback_param(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd);
-
-tpm_error_code_t tpm_proc_calc_flow_id(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd, uint16_t *flow_id);
-
-int32_t tpm_proc_init_cpu_wan_loopback(void);
-
-tpm_cpu_loopback_t *tpm_proc_get_loopback_entry(uint16_t flow_id);
-
-tpm_error_code_t tpm_proc_add_cpu_loopback_rule(uint32_t owner_id,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_pkt_frwd_t *pkt_frwd);
-
-tpm_error_code_t tpm_proc_add_cpu_wan_loopback(uint32_t owner_id,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       uint32_t *mod_idx);
-
-tpm_error_code_t tpm_proc_del_cpu_wan_loopback(uint32_t owner_id, tpm_pkt_frwd_t *pkt_frwd);
-tpm_error_code_t tpm_proc_add_ds_load_balance_acl_rule(uint32_t owner_id,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l2_acl_key_t *l2_key,
-					       tpm_ds_load_balance_tgrt_t tgrt_port);
-tpm_error_code_t tpm_proc_del_ds_load_balance_acl_rule(uint32_t owner_id, uint32_t rule_idx, uint32_t ext_call);
-
-int32_t tpm_proc_l2_tcam_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_parse_fields_t parse_rule_bm,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_l2_sram_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_db_pon_type_t pon_type,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_rule_action_t *rule_action,
-			       uint32_t mod_cmd,
-			       tpm_pncl_sram_data_t *sram_data,
-			       tpm_l2_acl_key_t *l2_key,
-			       tpm_pkt_mod_t *pkt_mod,
-			       tpm_pkt_mod_bm_t pkt_mod_bm);
-
-tpm_error_code_t tpm_proc_add_l2_prim_acl_rule(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l2_acl_key_t *l2_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_add_ipv4_acl_rule(uint32_t owner_id,
-					    tpm_src_port_type_t src_port,
-					    uint32_t rule_num,
-					    uint32_t *rule_idx,
-					    tpm_parse_fields_t parse_rule_bm,
-					    tpm_parse_flags_t parse_flags_bm,
-					    tpm_ipv4_acl_key_t *ipv4_key,
-					    tpm_pkt_frwd_t *pkt_frwd,
-					    tpm_pkt_mod_t *pkt_mod,
-					    tpm_pkt_mod_bm_t pkt_mod_bm,
-					    tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_add_l3_type_acl_rule(uint32_t owner_id,
-					       tpm_src_port_type_t src_port,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l3_type_key_t *l3_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_get_next_valid_rule(uint32_t owner_id,
-					      int32_t current_index,
-					      tpm_api_type_t rule_type,
-					      int32_t *next_index,
-					      uint32_t *rule_idx,
-					      tpm_rule_entry_t *tpm_rule);
-
-tpm_error_code_t tpm_proc_omci_add_channel(uint32_t owner_id,
-					   tpm_gem_port_key_t gem_port,
-					   uint32_t cpu_rx_queue,
-					   tpm_trg_port_type_t tcont_num,
-					   uint32_t cpu_tx_queue);
-
-tpm_error_code_t tpm_proc_omci_del_channel(uint32_t owner_id);
-
-tpm_error_code_t tpm_proc_oam_epon_add_channel(uint32_t owner_id,
-					       uint32_t cpu_rx_queue,
-					       tpm_trg_port_type_t llid_num);
-
-tpm_error_code_t tpm_proc_loop_detect_add_channel(uint32_t owner_id, tpm_ether_type_key_t ety);
-
-tpm_error_code_t tpm_proc_loop_detect_del_channel(uint32_t owner_id);
-
-tpm_error_code_t tpm_proc_oam_loopback_add_channel(uint32_t owner_id);
-
-tpm_error_code_t tpm_proc_oam_loopback_del_channel(uint32_t owner_id);
-
-tpm_error_code_t tpm_proc_oam_epon_del_channel(uint32_t owner_id);
-
-int32_t tpm_proc_l3_tcam_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       tpm_l3_type_key_t *l3_key,
-			       tpm_parse_fields_t parse_rule_bm,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_rule_action_t *rule_action,
-			       tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_l3_sram_build(tpm_src_port_type_t src_port,
-			       tpm_dir_t dir,
-			       uint32_t rule_num,
-			       uint8_t is_pppoe,
-			       tpm_db_pon_type_t pon_type,
-			       tpm_pkt_frwd_t *pkt_frwd,
-			       tpm_rule_action_t *rule_action,
-			       tpm_parse_flags_t parse_flags_bm,
-			       tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_del_l3_type_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-tpm_error_code_t tpm_proc_erase_section(uint32_t owner_id, tpm_api_type_t api_type);
-
-tpm_error_code_t tpm_proc_del_ipv4_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-tpm_error_code_t tpm_proc_add_ipv4_mc_stream(uint32_t owner_id,
-					     uint32_t stream_num,
-					     tpm_mc_igmp_mode_t igmp_mode,
-					     uint8_t mc_stream_pppoe,
-					     uint16_t vid,
-					     uint8_t ipv4_src_add[4],
-					     uint8_t ipv4_dst_add[4],
-					     uint8_t ignore_ipv4_src,
-					     uint16_t dest_queue,
-					     tpm_trg_port_type_t dest_port_bm);
-
-int32_t tpm_proc_ipv4_sram_build(tpm_src_port_type_t src_port,
-				 tpm_dir_t dir,
-				 uint32_t rule_num,
-				 tpm_db_pon_type_t pon_type,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 tpm_parse_fields_t ipv4_parse_bm,
-				 tpm_parse_flags_t parse_flags_bm,
-				 tpm_pkt_frwd_t *pkt_frwd,
-				 tpm_rule_action_t *rule_action,
-				 uint32_t mod_cmd,
-				 tpm_pkt_mod_bm_t pkt_mod_bm,
-				 tpm_pkt_mod_t *pkt_mod,
-				 tpm_pncl_sram_data_t *sram_data);
-
-int32_t tpm_proc_ipv4_tcam_build(tpm_src_port_type_t src_port,
-				 tpm_dir_t dir,
-				 uint32_t rule_num,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 tpm_parse_fields_t parse_rule_bm,
-				 tpm_parse_flags_t parse_flags_bm,
-				 tpm_rule_action_t *rule_action,
-				 tpm_pkt_mod_t *pkt_mod,
-				 tpm_pkt_mod_bm_t pkt_mod_bm,
-				 tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv4_mc_tcam_build(tpm_mc_filter_mode_t filter_mode,
-				    uint32_t stream_num,
-				    uint16_t vid,
-				    uint8_t mc_stream_pppoe,
-				    uint8_t ipv4_src_add[4],
-				    uint8_t ipv4_dst_add[4],
-				    uint8_t ignore_ipv4_src,
-				    tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipvx_mc_sram_build(tpm_mc_filter_mode_t filter_mode,
-				    tpm_mc_igmp_mode_t igmp_mode,
-				    uint16_t dest_queue,
-				    tpm_trg_port_type_t target_port,
-				    uint32_t mod_entry,
-				    tpm_pncl_sram_data_t *sram_data,
-				    tpm_ip_ver_t ip_version);
-
-tpm_error_code_t tpm_proc_updt_ipv4_mc_stream(uint32_t owner_id,
-					      uint32_t stream_num, tpm_trg_port_type_t dest_port_bm);
-
-tpm_error_code_t tpm_proc_del_ipv4_mc_stream(uint32_t owner_id, uint32_t stream_num);
-
-int32_t tpm_proc_ipv6_mc_tcam_build(tpm_mc_filter_mode_t filter_mode,
-				    uint32_t stream_num,
-				    uint16_t vid,
-				    uint8_t mc_stream_pppoe,
-				    uint8_t ipv6_dst_add[16],
-				    uint8_t sip_index,
-				    uint8_t ignore_sip,
-				    tpm_pncl_tcam_data_t *tcam_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_mc_stream(uint32_t owner_id,
-					     uint32_t stream_num,
-					     tpm_mc_igmp_mode_t igmp_mode,
-					     uint8_t mc_stream_pppoe,
-					     uint16_t vid,
-					     uint8_t ipv6_src_add[16],
-					     uint8_t ipv6_dst_add[16],
-					     uint8_t ignore_ipv6_src,
-					     uint16_t dest_queue,
-					     tpm_trg_port_type_t dest_port_bm);
-
-tpm_error_code_t tpm_proc_updt_ipv6_mc_stream(uint32_t owner_id,
-					      uint32_t stream_num, tpm_trg_port_type_t dest_port_bm);
-tpm_error_code_t tpm_proc_del_ipv6_mc_stream(uint32_t owner_id, uint32_t stream_num);
-
-tpm_error_code_t tpm_proc_del_l2_prim_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-int32_t tpm_proc_src_port_gmac_bm_map(tpm_src_port_type_t src_port, tpm_gmac_bm_t *gmac_bm);
-
-tpm_error_code_t tpm_proc_l2_num_vlan_tags_init(void);
-tpm_error_code_t tpm_proc_ipv4_ttl_init(uint32_t ttl_illegal_action);
-tpm_error_code_t tpm_proc_ds_load_balance_init(void);
-
-tpm_error_code_t tpm_proc_tcp_flag_init(void);
-tpm_error_code_t tpm_proc_ipv4_len_init(void);
-tpm_error_code_t tpm_proc_ipv4_igmp_init(void);
-tpm_error_code_t tpm_proc_ipv4_proto_init(void);
-tpm_error_code_t tpm_proc_ipv4_frag_init(void);
-
-tpm_error_code_t tpm_proc_virt_uni_init(void);
-
-tpm_error_code_t tpm_proc_add_uni_port_igmp_rule(tpm_src_port_type_t src_port, tpm_igmp_frwd_mode_t mode);
-tpm_error_code_t tpm_proc_add_wan_port_igmp_rule(tpm_igmp_frwd_mode_t mode);
-tpm_error_code_t tpm_proc_del_port_igmp_rule(tpm_src_port_type_t src_port);
-
-int32_t tpm_proc_ipv6_nh_tcam_build(uint32_t rule_num,
-				    tpm_nh_iter_t nh_iter,
-				    uint32_t nh,
-				    tpm_parse_flags_t parse_flags_bm,
-				    tpm_rule_action_t *rule_action,
-				    tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_nh_sram_build(uint32_t rule_num,
-				    tpm_nh_iter_t nh_iter,
-				    uint32_t nh,
-				    tpm_db_pon_type_t pon_type,
-				    tpm_pkt_frwd_t *pkt_frwd,
-				    tpm_rule_action_t *rule_action,
-				    tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_nh_acl_rule(uint32_t owner_id,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_nh_iter_t nh_iter,
-					       uint32_t nh,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_del_ipv6_nh_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-int32_t tpm_proc_ipv6_gen_tcam_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-				     tpm_parse_fields_t parse_rule_bm,
-				     tpm_parse_flags_t parse_flags_bm,
-				     tpm_pkt_mod_t *pkt_mod,
-				     tpm_pkt_mod_bm_t pkt_mod_bm,
-				     tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_gen_sram_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_db_pon_type_t pon_type,
-				     tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_rule_action_t *rule_action,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_acl_rule(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_mod_t *pkt_mod,
-						tpm_pkt_mod_bm_t pkt_mod_bm,
-						tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_del_ipv6_gen_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-int32_t tpm_proc_ipv6_dip_tcam_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_ipv6_addr_key_t *ipv6_dip_key,
-				     tpm_parse_fields_t parse_rule_bm,
-				     tpm_parse_flags_t parse_flags_bm,
-				     tpm_pkt_mod_t *pkt_mod,
-				     tpm_pkt_mod_bm_t pkt_mod_bm,
-				     tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_dip_sram_build(tpm_src_port_type_t src_port,
-				     tpm_dir_t dir,
-				     uint32_t rule_num,
-				     tpm_db_pon_type_t pon_type,
-				     tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_rule_action_t *rule_action,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_acl_rule(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						uint32_t rule_num,
-						uint32_t *rule_idx,
-						tpm_parse_fields_t parse_rule_bm,
-						tpm_parse_flags_t parse_flags_bm,
-						tpm_ipv6_addr_key_t *ipv6_dip_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_mod_t *pkt_mod,
-						tpm_pkt_mod_bm_t pkt_mod_bm,
-						tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_del_ipv6_dip_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-int32_t tpm_proc_ipv6_l4ports_tcam_build(tpm_src_port_type_t src_port,
-					 tpm_dir_t dir,
-					 uint32_t rule_num,
-					 tpm_l4_ports_key_t *l4_key,
-					 tpm_parse_fields_t parse_rule_bm,
-					 tpm_parse_flags_t parse_flags_bm,
-					 tpm_rule_action_t *rule_action,
-					 tpm_pkt_mod_t *pkt_mod,
-					 tpm_pkt_mod_bm_t pkt_mod_bm,
-					 tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_l4ports_sram_build(tpm_src_port_type_t src_port,
-					 tpm_dir_t dir,
-					 uint32_t rule_num,
-					 tpm_db_pon_type_t pon_type,
-					 tpm_pkt_frwd_t *pkt_frwd,
-					 tpm_rule_action_t *rule_action,
-					 uint32_t mod_cmd,
-					 tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_l4_ports_acl_rule(uint32_t owner_id,
-						     tpm_src_port_type_t src_port,
-						     uint32_t rule_num,
-						     uint32_t *rule_idx,
-						     tpm_parse_fields_t parse_rule_bm,
-						     tpm_parse_flags_t parse_flags_bm,
-						     tpm_l4_ports_key_t *l4_key,
-						     tpm_pkt_frwd_t *pkt_frwd,
-						     tpm_pkt_mod_t *pkt_mod,
-						     tpm_pkt_mod_bm_t pkt_mod_bm,
-						     tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_del_ipv6_l4_ports_acl_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-
-tpm_error_code_t tpm_proc_del_acl_rule(tpm_api_sections_t api_section, uint32_t owner_id, uint32_t rule_idx, uint32_t busy_check);
-
-tpm_error_code_t tpm_proc_pnc_create(tpm_pnc_ranges_t range_id,
-				     uint32_t pnc_entry,
-				     tpm_pncl_pnc_full_t *pnc_data);
-
-uint32_t tpm_proc_all_gmac_bm(void);
-
-void tpm_proc_mc_vid_remove_ai_bits
-(tpm_rule_action_t *rule_action,
- tpm_src_port_type_t src_port, tpm_l2_acl_key_t *l2_key, tpm_error_code_t ret_code);
-
-tpm_error_code_t tpm_proc_add_mc_vid_cfg(uint32_t mc_vid, tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config);
-
-tpm_error_code_t tpm_proc_remove_mc_vid_cfg(uint32_t mc_vid);
-
-tpm_error_code_t tpm_proc_update_mc_vid_cfg(uint32_t mc_vid,
-					    tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config);
-tpm_error_code_t tpm_proc_set_mc_vid_port_vids(uint32_t owner_id,
-					       uint32_t mc_vid,
-					       tpm_mc_vid_port_vid_set_t *mc_vid_uniports_config);
-tpm_error_code_t tpm_proc_delete_ipvx_mc_pnc_entry(tpm_mc_filter_mode_t filter_mode,
-						   uint32_t stream_num,
-						   uint32_t dest_port_bm,
-						   uint32_t u4_entry,
-						   tpm_ip_ver_t ip_version);
-
-tpm_error_code_t tpm_proc_catch_all_init(void);
-
-int32_t tpm_proc_ipv6_gen_5t_tcam_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_l4_ports_key_t *l4_key,
-					tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					tpm_parse_fields_t parse_rule_bm,
-					tpm_parse_flags_t parse_flags_bm,
-					tpm_rule_action_t *rule_action,
-					tpm_pkt_mod_t *pkt_mod,
-					tpm_pkt_mod_bm_t pkt_mod_bm,
-					tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_gen_5t_sram_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_db_pon_type_t pon_type,
-					uint32_t ipv6_gen_subflow,
-					tpm_pkt_frwd_t *pkt_frwd,
-					tpm_rule_action_t *rule_action,
-					long long int_pkt_act,
-					tpm_pkt_mod_t *pkt_mod,
-					uint32_t mod_cmd,
-					tpm_pncl_sram_data_t *sram_data);
-
-int32_t tpm_proc_ipv6_dip_5t_tcam_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_l4_ports_key_t *l4_key,
-					tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					tpm_ipv6_addr_key_t *ipv6_dip_key,
-					tpm_parse_fields_t parse_rule_bm,
-					tpm_parse_flags_t parse_flags_bm,
-					tpm_rule_action_t *rule_action,
-					tpm_pkt_mod_t *pkt_mod,
-					tpm_pkt_mod_bm_t pkt_mod_bm,
-					tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_dip_5t_sram_build(tpm_dir_t dir,
-					uint32_t rule_num,
-					tpm_db_pon_type_t pon_type,
-					tpm_pkt_frwd_t *pkt_frwd,
-					tpm_rule_action_t *rule_action,
-					long long int_pkt_act,
-					tpm_pkt_mod_t *pkt_mod,
-					uint32_t mod_cmd,
-					tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_gen_5t_rule(uint32_t owner_id,
-					       tpm_dir_t src_dir,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l4_ports_key_t *l4_key,
-					       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_add_ipv6_dip_5t_rule(uint32_t owner_id,
-					       tpm_dir_t src_dir,
-					       uint32_t rule_num,
-					       uint32_t *rule_idx,
-					       tpm_parse_fields_t parse_rule_bm,
-					       tpm_parse_flags_t parse_flags_bm,
-					       tpm_l4_ports_key_t *l4_key,
-					       tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-					       tpm_ipv6_addr_key_t *ipv6_dip_key,
-					       tpm_pkt_frwd_t *pkt_frwd,
-					       tpm_pkt_mod_t *pkt_mod,
-					       tpm_pkt_mod_bm_t pkt_mod_bm,
-					       tpm_rule_action_t *rule_action);
-
-int32_t tpm_proc_ipv6_l4_ports_5t_tcam_build(tpm_dir_t dir,
-					     uint32_t rule_num,
-					     tpm_l4_ports_key_t *l4_key,
-					     tpm_parse_fields_t parse_rule_bm,
-					     tpm_parse_flags_t parse_flags_bm,
-					     tpm_rule_action_t *rule_action,
-					     tpm_pkt_mod_t *pkt_mod,
-					     tpm_pkt_mod_bm_t pkt_mod_bm,
-					     tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_ipv6_l4_ports_5t_sram_build(tpm_dir_t dir,
-					     uint32_t rule_num,
-					     tpm_db_pon_type_t pon_type,
-					     uint32_t ipv6_l4_subflow,
-					     tpm_pkt_frwd_t *pkt_frwd,
-					     tpm_rule_action_t *rule_action,
-					     long long int_pkt_act,
-					     tpm_pkt_mod_t *pkt_mod,
-					     uint32_t mod_cmd,
-					     tpm_pncl_sram_data_t *sram_data);
-
-tpm_error_code_t tpm_proc_add_ipv6_l4_ports_5t_rule(uint32_t owner_id,
-						    tpm_dir_t src_dir,
-						    uint32_t rule_num,
-						    uint32_t *rule_idx,
-						    tpm_parse_fields_t parse_rule_bm,
-						    tpm_parse_flags_t parse_flags_bm,
-						    tpm_l4_ports_key_t *l4_key,
-						    tpm_pkt_frwd_t *pkt_frwd,
-						    tpm_pkt_mod_t *pkt_mod,
-						    tpm_pkt_mod_bm_t pkt_mod_bm,
-						    tpm_rule_action_t *rule_action);
-
-tpm_error_code_t tpm_proc_del_ipv6_gen_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-tpm_error_code_t tpm_proc_del_ipv6_dip_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-tpm_error_code_t tpm_proc_del_ipv6_l4_ports_5t_rule(uint32_t owner_id, uint32_t rule_idx, tpm_caller_t ext_call);
-tpm_error_code_t tpm_proc_ipv6_hoplimit_init(uint32_t hoplimit_illegal_action);
-tpm_error_code_t tpm_proc_send_genquery_to_uni(tpm_trg_port_type_t dest_port_bm, uint32_t packet_num);
-tpm_error_code_t tpm_proc_ipv6_l4_mc_ds_init(void);
-tpm_error_code_t tpm_proc_ipv6_mc_sip_init(void);
-
-int32_t tpm_proc_cnm_l2_tcam_build(tpm_src_port_type_t src_port,
-				   tpm_parse_fields_t l2_parse_rule_bm,
-				   tpm_l2_acl_key_t *l2_key,
-				   uint32_t ipv4_key_idx,
-				   tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_cnm_l2_sram_build(uint32_t precedence,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_action_t pkt_act,
-				   uint32_t mod_cmd,
-				   tpm_pncl_sram_data_t *sram_data);
-
-int32_t tpm_proc_cnm_ipv4_tcam_build(tpm_src_port_type_t src_port,
-				     uint32_t precedence,
-				     tpm_parse_fields_t ipv4_parse_rule_bm,
-				     tpm_ipv4_acl_key_t *ipv4_key,
-				     tpm_pncl_tcam_data_t *tcam_data);
-
-int32_t tpm_proc_cnm_ipv4_sram_build(tpm_pkt_frwd_t *pkt_frwd,
-				     tpm_pkt_action_t pkt_act,
-				     uint32_t mod_cmd,
-				     tpm_pncl_sram_data_t *sram_data);
-tpm_pnc_trg_t tpm_proc_cnm_pnc_trg_get(tpm_trg_port_type_t trg_port);
-
-uint8_t tpm_proc_if_ipv4_pre_range_is_full(tpm_src_port_type_t src_port, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key);
-uint8_t tpm_proc_if_cnm_main_range_is_full(tpm_src_port_type_t src_port, uint32_t precedence);
-int32_t tpm_proc_add_cnm_ipv4_pre_filter_key(uint32_t owner_id, tpm_src_port_type_t src_port, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key, uint32_t *key_idx);
-int32_t tpm_proc_del_cnm_ipv4_pre_filter_key(uint32_t owner_id, tpm_src_port_type_t src_port, uint32_t key_idx);
-int32_t tpm_proc_add_l2_cnm_rule(uint32_t owner_id,
-				 tpm_src_port_type_t src_port,
-				 uint32_t precedence,
-				 tpm_parse_fields_t l2_parse_rule_bm,
-				 tpm_l2_acl_key_t *l2_key,
-				 tpm_parse_fields_t ipv4_parse_rule_bm,
-				 tpm_ipv4_acl_key_t *ipv4_key,
-				 uint32_t ipv4_key_idx,
-				 tpm_pkt_frwd_t *pkt_frwd,
-				 tpm_pkt_action_t pkt_act,
-				 uint32_t pbits,
-				 uint32_t *rule_idx);
-int32_t tpm_proc_del_l2_cnm_rule(uint32_t owner_id, uint32_t rule_idx);
-int32_t tpm_proc_add_ipv4_cnm_rule(uint32_t owner_id, tpm_src_port_type_t src_port, uint32_t precedence, tpm_parse_fields_t ipv4_parse_rule_bm, tpm_ipv4_acl_key_t *ipv4_key, tpm_pkt_frwd_t *pkt_frwd, tpm_pkt_action_t pkt_act, uint32_t pbits, uint32_t *rule_idx);
-int32_t tpm_proc_add_ipv6_cnm_rule(uint32_t owner_id,
-				   tpm_src_port_type_t src_port,
-				   uint32_t precedence,
-				   tpm_parse_fields_t ipv6_parse_rule_bm,
-				   tpm_ipv6_acl_key_t *ipv6_key,
-				   tpm_pkt_frwd_t *pkt_frwd,
-				   tpm_pkt_action_t pkt_act,
-				   uint32_t pbits,
-				   uint32_t *rule_idx);
-int32_t tpm_proc_del_ipv4_cnm_rule(uint32_t owner_id, uint32_t rule_idx);
-int32_t tpm_proc_del_ipv6_cnm_rule(uint32_t owner_id, uint32_t rule_idx);
-int32_t tpm_proc_calc_cnm_rule_num(tpm_src_port_type_t src_port, uint32_t precedence, uint32_t *rule_num);
-tpm_error_code_t tpm_proc_find_mac_addr_db(tpm_l2_acl_key_t *src_mac_addr, int32_t *addr_exist, uint32_t *rule_num, uint32_t *tbl_num);
-tpm_error_code_t tpm_proc_add_static_mac_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr);
-tpm_error_code_t tpm_proc_del_static_mac_rule(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr);
-tpm_error_code_t tpm_proc_mac_learn_default_rule_act_set(uint32_t owner_id, tpm_unknown_mac_conf_t mac_conf);
-tpm_error_code_t tpm_proc_mac_learn_entry_num_get(uint32_t *entry_num);
-#ifdef CONFIG_MV_ETH_WAN_SWAP
-tpm_error_code_t tpm_proc_hot_swap_profile(uint32_t owner_id,
-				    tpm_eth_complex_profile_t profile_id);
-#endif /* CONFIG_MV_ETH_WAN_SWAP */
-
-
-int32_t tpm_proc_check_api_busy(tpm_api_type_t api_type, uint32_t rule_num);
-int32_t tpm_proc_api_busy_done(tpm_api_type_t api_type, uint32_t rule_num);
-int32_t tpm_proc_src_port_dir_map(tpm_src_port_type_t src_port, tpm_dir_t *dir);
-int32_t tpm_proc_check_all_api_busy(void);
-int32_t tpm_proc_all_api_busy_done(void);
-
-bool tpm_split_mod_stage1_check(tpm_pkt_mod_bm_t pkt_mod_bm,
-				tpm_pkt_mod_t *pkt_mod,
-				tpm_rule_action_t *rule_action,
-				bool check_vlan_noop);
-int32_t tpm_proc_calc_cnm_precedence(tpm_src_port_type_t src_port, uint32_t rule_num, uint32_t *precedence);
-tpm_error_code_t tpm_proc_hwf_admin_set(tpm_gmacs_enum_t port, uint8_t txp, uint8_t enable);
-
-tpm_error_code_t tpm_proc_check_dst_uni_port(tpm_trg_port_type_t dest_port_bm);
-tpm_error_code_t tpm_proc_set_active_wan(tpm_gmacs_enum_t active_wan);
-
-/* hot swap profile acl recovery func api section */
-tpm_error_code_t tpm_acl_rcvr_func_mac_learn(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ds_load_balance(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_cpu_loopback(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_l2_prim(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_l3_type(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv4(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv4_mc(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_gen(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_dip(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_mc(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_nh(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_ipv6_l4(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-tpm_error_code_t tpm_acl_rcvr_func_cnm(uint32_t owner_id, tpm_db_api_entry_t *api_data, uint32_t rule_idx_updt_en);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_PKT_PROCL_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.c
deleted file mode 100644
index 447de4e..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.c
+++ /dev/null
@@ -1,3637 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_pnc_logic.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.4
-*
-*
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-typedef int32_t(*tpm_parse_func_t) (uint32_t, tpm_pkt_data_t *, tpm_pkt_mask_t *, tpm_pncl_tcam_data_t *);
-
-/* Local Structures */
-
-/* Structure for parsing tables */
-typedef struct {
-	uint32_t mandatory;
-	uint32_t parse_bm;
-	uint32_t field_len;
-	uint32_t shift_len;
-	tpm_parse_func_t parse_func;
-	char field_name[30];
-} tpm_parse_tbl_t;
-
-/* Local definitions */
-
-#define IF_ERROR(ret)		\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_PNCL_MOD, " recvd ret_code(%d)\n", ret);\
-			return(ret);\
-		}
-#define IF_ERROR_I(ret, i)	\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_PNCL_MOD, " recvd ret_code(%d), ind(%d)\n", ret, i);\
-			return(ret);\
-		}
-
-/* Function Declarations */
-
-int32_t tpm_pncl_mh_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_da_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_sa_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_vlan_parse(uint32_t offset, uint32_t sec_vlan_tag, tpm_pkt_data_t *pkt_data,
-			    tpm_pkt_mask_t *pkt_mask, tpm_pncl_tcam_data_t * tcam_in);
-int32_t tpm_pncl_vlan1_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_vlan2_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_etype_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_pppoe_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_l3_etype_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_l3_pppoe_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_ver_ihl_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				    tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_tot_len_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				    tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_ident_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_flag_ttl_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_flag_off_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_dscp_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_proto_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_sip_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_dip_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_l4_src_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv4_l4_dst_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_l4_src_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_l4_dst_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_l4_src_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_l4_dst_port_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_flags_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_ver_dscp_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				     tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_dscp_flow_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				      tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_flow_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_pllen_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_nh_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_hoplim_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_sip_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_dip_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_udp_len_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_l4_checksum_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_seq_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_ack_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_offset_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_ipv6_tcp_flags_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				      tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_win_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_tcp_urgtptr_parse(uint32_t offset, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in);
-
-int32_t tpm_pncl_pkt_data_parse(tpm_pncl_tcam_data_t *tcam_in, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask);
-
-int32_t tpm_pncl_log_offset_get(tpm_pncl_offset_t *logic_offset, uint32_t *parse_tbl_ind);
-int32_t tpm_pncl_shift_calc(tpm_pncl_offset_t *start_offset, tpm_pncl_offset_t *stop_offset,
-			    tpm_pncl_parse_bm_t l2_parse_bm, uint32_t *calc_shift);
-int32_t tpm_pncl_tcam_map(tpm_pncl_tcam_data_t *tcam_in, tpm_tcam_all_t *tcam_out);
-int32_t tpm_pncl_flowid_map(tpm_pncl_flowid_t *flowid_in, tpm_pncl_sram_updt_bm_t sram_bm_in, uint32_t *flowid_val,
-			    uint32_t *flowid_updt_mask);
-int32_t tpm_pncl_res_info_map(tpm_pncl_sram_data_t *sram_in, tpm_sram_all_t *sram_out);
-int32_t tpm_pncl_sram_map(tpm_pncl_sram_data_t *sram_in, tpm_sram_all_t *sram_out, tpm_pncl_tcam_data_t *tcam_in);
-int32_t tpm_pncl_set_ri_bit(tpm_sram_all_t *sram_out, uint32_t ri_bit, uint32_t ri_val);
-int32_t tpm_pncl_set_l4(tpm_pncl_l4_type_t l4_type, tpm_sram_all_t *sram_out);
-int32_t tpm_pncl_set_l3(tpm_pncl_l3_type_t l3_type, tpm_sram_all_t *sram_out);
-
-/* L2 Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT     PARSING FUNCTION     TEXT */
-static tpm_parse_tbl_t pncl_l2_parse_tbl[] = {
-	{TPM_TRUE, TPM_L2_PARSE_MH, TPM_MH_LEN, TPM_MH_LEN, &tpm_pncl_mh_parse, "MH"},
-	{TPM_TRUE, TPM_L2_PARSE_MAC_DA, TPM_DA_LEN, TPM_DA_LEN, &tpm_pncl_da_parse, "DA"},
-	{TPM_TRUE, TPM_L2_PARSE_MAC_SA, TPM_SA_LEN, TPM_SA_LEN, &tpm_pncl_sa_parse, "SA"},
-	{TPM_FALSE, TPM_PNCL_ONE_TWO_VLAN_TAG, TPM_VLAN_LEN, TPM_VLAN_LEN, &tpm_pncl_vlan1_parse, "VLAN1"},
-	{TPM_FALSE, TPM_L2_PARSE_TWO_VLAN_TAG, TPM_VLAN_LEN, TPM_VLAN_LEN, &tpm_pncl_vlan2_parse, "VLAN2"},
-	{TPM_TRUE, TPM_L2_PARSE_ETYPE, TPM_ETYPE_LEN, TPM_ETYPE_LEN, &tpm_pncl_etype_parse, "ETHER_TYPE"},
-	{TPM_FALSE, TPM_L2_PARSE_PPPOE_HDR, TPM_PPPOE_HDR_LEN, TPM_PPPOE_HDR_LEN, &tpm_pncl_pppoe_parse, "PPPOE"}
-};
-
-/* L3 Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT     PARSING FUNCTION     TEXT */
-static tpm_parse_tbl_t pncl_l3_parse_tbl[] = {
-	{TPM_TRUE, TPM_L2_PARSE_ETYPE, TPM_ETYPE_LEN, TPM_ETYPE_LEN, &tpm_pncl_l3_etype_parse, "ETHER_TYPE"},
-	{TPM_FALSE, TPM_L2_PARSE_PPPOE_HDR, TPM_PPPOE_HDR_LEN, TPM_PPPOE_HDR_LEN, &tpm_pncl_l3_pppoe_parse,
-		"PPPOE HDR"},
-};
-
-/* IPv4 Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN            SHIFT TO NEXT     PARSING FUNCTION     TEXT */
-static tpm_parse_tbl_t pncl_ipv4_parse_tbl[] = {
-	{TPM_TRUE, TPM_IPv4_PARSE_VER_OR_IHL, TPM_IPV4_VER_IHL_LEN, TPM_IPV4_VER_IHL_LEN, &tpm_pncl_ipv4_ver_ihl_parse,
-		"IPv4 Ver&IHL"},
-	{TPM_TRUE, TPM_IPv4_PARSE_DSCP, TPM_IPV4_DSCP_LEN, TPM_IPV4_DSCP_LEN, &tpm_pncl_ipv4_dscp_parse, "IPv4 DSCP"},
-	{TPM_TRUE, TPM_IPv4_PARSE_TOTLEN, TPM_IPV4_TOTLEN_LEN, TPM_IPV4_TOTLEN_LEN, &tpm_pncl_ipv4_tot_len_parse,
-		"IPv4 TotalLength"},
-	{TPM_TRUE, TPM_IPv4_PARSE_IDENT, TPM_IPV4_IDENT_LEN, TPM_IPV4_IDENT_LEN, &tpm_pncl_ipv4_ident_parse,
-		"IPv4 Idenitification"},
-	{TPM_TRUE, TPM_IPv4_PARSE_MF_OR_FRAG, TPM_IPV4_FLAG_OFF_LEN, TPM_IPV4_FLAG_OFF_LEN, &tpm_pncl_flag_off_parse,
-		"IPv4 MF Flag and Offset"},
-	{TPM_TRUE, TPM_IPv4_PARSE_TTL, TPM_IPV4_TTL_LEN, TPM_IPV4_TTL_LEN, &tpm_pncl_flag_ttl_parse, "IPv4 TTL"},
-	{TPM_TRUE, TPM_IPv4_PARSE_PROTO, TPM_IPV4_PROTO_LEN, TPM_IPV4_PROTO_LEN + 2, &tpm_pncl_ipv4_proto_parse,
-		"IPv4 PROTO"},
-	{TPM_TRUE, TPM_IPv4_PARSE_SIP, TPM_IPV4_SIP_LEN, TPM_IPV4_SIP_LEN, &tpm_pncl_ipv4_sip_parse, "IPv4 SIP"},
-	{TPM_TRUE, TPM_IPv4_PARSE_DIP, TPM_IPV4_DIP_LEN, TPM_IPV4_DIP_LEN, &tpm_pncl_ipv4_dip_parse, "IPv4 DIP"},
-	{TPM_TRUE, TPM_PARSE_L4_SRC, TPM_IPV4_L4_PORT_LEN, TPM_IPV4_L4_PORT_LEN, &tpm_pncl_ipv4_l4_src_port_parse,
-		"IPV4_L4_SRC"},
-	{TPM_TRUE, TPM_PARSE_L4_DST, TPM_IPV4_L4_PORT_LEN, TPM_IPV4_L4_PORT_LEN, &tpm_pncl_ipv4_l4_dst_port_parse,
-		"IPV4_L4_DST"}
-};
-
-/* IPv6 Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT
-		PARSING FUNCTION     		TEXT */
-static tpm_parse_tbl_t pncl_ipv6_parse_tbl[] = {
-	{TPM_TRUE, TPM_IPv6_PARSE_VER_OR_DSCP, TPM_IPV6_VER_DSCP_LEN, TPM_IPV6_VER_DSCP_LEN,
-		&tpm_pncl_ipv6_ver_dscp_parse,  "IPv6 Ver&DSCP"},
-	{TPM_TRUE, TPM_IPv6_PARSE_DSCP_OR_FLOW, TPM_IPV6_DSCP_FLOW_LEN, TPM_IPV6_DSCP_FLOW_LEN,
-		&tpm_pncl_ipv6_dscp_flow_parse, "IPv6 DSCP&Flow"},
-	{TPM_TRUE, TPM_IPv6_PARSE_FLOW, TPM_IPV6_FLOW_LEN, TPM_IPV6_FLOW_LEN,
-		&tpm_pncl_ipv6_flow_parse,      "IPv6 Flow"},
-	{TPM_TRUE, TPM_IPv6_PARSE_PLLEN, TPM_IPV6_PLLEN_LEN, TPM_IPV6_PLLEN_LEN,
-		&tpm_pncl_ipv6_pllen_parse,     "IPv6 Payload len"},
-	{TPM_TRUE, TPM_IPv6_PARSE_NH, TPM_IPV6_NH_LEN, TPM_IPV6_NH_LEN,
-		&tpm_pncl_ipv6_nh_parse,        "IPv6 Next header"},
-	{TPM_TRUE, TPM_IPv6_PARSE_HOPL, TPM_IPV6_HOPLIM_LEN, TPM_IPV6_HOPLIM_LEN,
-		&tpm_pncl_ipv6_hoplim_parse,    "IPv6 hop limit"},
-	{TPM_TRUE, TPM_IPv6_PARSE_SIP, TPM_IPV6_SIP_LEN, TPM_IPV6_SIP_LEN,
-		&tpm_pncl_ipv6_sip_parse,       "IPv6 SIP"},
-	{TPM_TRUE, TPM_IPv6_PARSE_DIP, TPM_IPV6_DIP_LEN, TPM_IPV6_DIP_LEN,
-		&tpm_pncl_ipv6_dip_parse,       "IPv6 DIP"},
-};
-
-/* IPv6 Ext Hdr Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT
-		PARSING FUNCTION     		TEXT */
-static tpm_parse_tbl_t pncl_ipv6_ext_hdr_parse_tbl[] = {
-	{TPM_TRUE, TPM_IPv6_PARSE_NH, TPM_IPV6_NH_LEN, TPM_IPV6_NH_LEN,
-		&tpm_pncl_ipv6_nh_parse,        "IPv6 Next header"},
-};
-
-static tpm_parse_tbl_t pncl_ipv6_dip_parse_tbl[] = {
-	{TPM_TRUE, TPM_IPv6_PARSE_DIP, TPM_IPV6_DIP_LEN, TPM_IPV6_DIP_LEN,
-		&tpm_pncl_ipv6_dip_parse,       "IPv6 DIP"},
-	{TPM_TRUE, TPM_PARSE_L4_SRC, TPM_L4_SPORT_LEN, TPM_L4_SPORT_LEN,
-		&tpm_pncl_l4_src_port_parse,	"L4 source port"},
-	{TPM_TRUE, TPM_PARSE_L4_DST, TPM_L4_DPORT_LEN, TPM_L4_DPORT_LEN,
-		&tpm_pncl_l4_dst_port_parse,	"L4 dest port"},
-};
-
-/* TCP Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT
-		PARSING FUNCTION     		TEXT */
-static tpm_parse_tbl_t pncl_tcp_parse_tbl[] = {
-	{TPM_TRUE, TPM_PARSE_L4_SRC, TPM_L4_SPORT_LEN, TPM_L4_SPORT_LEN,
-		&tpm_pncl_l4_src_port_parse,    "L4 source port"},
-	{TPM_TRUE, TPM_PARSE_L4_DST, TPM_L4_DPORT_LEN, TPM_L4_DPORT_LEN,
-		&tpm_pncl_l4_dst_port_parse,    "L4 dest port"},
-	{TPM_TRUE, TPM_PARSE_TCPSEQ_NUM, TPM_TCP_SEQ_NUM_LEN, TPM_TCP_SEQ_NUM_LEN,
-		&tpm_pncl_tcp_seq_parse,        "TCP Seq Num"},
-	{TPM_TRUE, TPM_PARSE_TCPACK_NUM, TPM_TCP_ACK_NUM_LEN, TPM_TCP_ACK_NUM_LEN,
-		&tpm_pncl_tcp_ack_parse,        "TCP Ack Num"},
-	{TPM_TRUE, TPM_PARSE_TCPOFFSET, TPM_TCP_OFFSET_LEN, TPM_TCP_OFFSET_LEN,
-		&tpm_pncl_tcp_offset_parse,     "TCP Offset"},
-	{TPM_TRUE, TPM_PARSE_TCPFLAGS, TPM_TCP_FLAGS_LEN, TPM_TCP_FLAGS_LEN,
-		&tpm_pncl_tcp_flags_parse,      "TCP Flags"},
-	{TPM_TRUE, TPM_PARSE_TCPWIN, TPM_TCP_WIN_LEN, TPM_TCP_WIN_LEN,
-		&tpm_pncl_tcp_win_parse,        "TCP Window"},
-	{TPM_TRUE, TPM_PARSE_L4_CHECKSUM, TPM_L4_CHECKSUM_LEN, TPM_L4_CHECKSUM_LEN,
-		&tpm_pncl_l4_checksum_parse,    "L4 checksum"},
-	{TPM_TRUE, TPM_PARSE_TCPURGTPTR, TPM_TCP_URGTPTR_LEN, TPM_TCP_URGTPTR_LEN,
-		&tpm_pncl_tcp_urgtptr_parse,    "TCP Urgent Ptr"},
-};
-
-/* L4 Ports Parsing Table */
-/*    MAND.           PARSE_BM                FIELD_LEN     SHIFT TO NEXT     PARSING FUNCTION     TEXT */
-static tpm_parse_tbl_t pncl_l4_ports_parse_tbl[] = {
-	{TPM_TRUE, TPM_PARSE_L4_SRC, TPM_L4_SPORT_LEN, TPM_L4_SPORT_LEN, &tpm_pncl_l4_src_port_parse, "L4 source port"},
-	{TPM_TRUE, TPM_PARSE_L4_DST, TPM_L4_DPORT_LEN, TPM_L4_DPORT_LEN, &tpm_pncl_l4_dst_port_parse, "L4 dest port"},
-};
-
-/*******************************************************************************
-* tpm_pncl_print_pncl()
-*
-* DESCRIPTION:     The function prints
-*
-* INPUTS:
-* pnc_data            -  PNC entry in logical format
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-*******************************************************************************/
-void tpm_pncl_print_pncl(tpm_pncl_pnc_full_t *pnc_data)
-{
-	tpm_pncl_pkt_key_t *l_pkt_key = &(pnc_data->pncl_tcam.pkt_key);
-
-	/* TODO - Organize printout to Table */
-	printk(KERN_INFO "TCAM Logical:\n");
-	printk("lu_id(%02d), port_ids(%02x), start_offset_base(%02d), start_offset_sub(%x)\n",
-	       pnc_data->pncl_tcam.lu_id,
-	       pnc_data->pncl_tcam.port_ids,
-	       pnc_data->pncl_tcam.start_offset.offset_base, pnc_data->pncl_tcam.start_offset.offset_sub.l2_subf);
-	TPM_OS_DEB_WAIT();
-
-	if (pnc_data->pncl_tcam.add_info_mask != 0)
-		printk("ai_data(%x),  ai_mask(%x)\n",
-		       pnc_data->pncl_tcam.add_info_data, pnc_data->pncl_tcam.add_info_mask);
-
-	printk("l2_bm(0x%x), l3_bm(0x%x), ipv4bm(0x%x), ipv6_bm(0x%x)\n",
-	       pnc_data->pncl_tcam.l2_parse_bm,
-	       pnc_data->pncl_tcam.l3_parse_bm, pnc_data->pncl_tcam.ipv4_parse_bm, pnc_data->pncl_tcam.ipv6_parse_bm);
-
-	TPM_OS_DEB_WAIT();
-
-	printk("src_port(%d), gem_port(%x)\n", l_pkt_key->src_port, l_pkt_key->l2_key.gem_port);
-	printk("L2 ethertype(%04x), pppoe_ses(%d), pppoe_proto(%x)\n",
-	       l_pkt_key->l2_key.ether_type,
-	       l_pkt_key->l2_key.pppoe_hdr.ppp_session, l_pkt_key->l2_key.pppoe_hdr.ppp_proto);
-
-	TPM_OS_DEB_WAIT();
-	printk("L3 ethertype(%04x), pppoe_ses(%d), pppoe_proto(%x)\n",
-	       l_pkt_key->l3_key.ether_type_key,
-	       l_pkt_key->l3_key.pppoe_key.ppp_session, l_pkt_key->l3_key.pppoe_key.ppp_proto);
-
-	TPM_OS_DEB_WAIT();
-	tpm_print_mac_key(&(l_pkt_key->l2_key.mac));
-
-	TPM_OS_DEB_WAIT();
-	printk("\nVLAN 1:\n");
-	tpm_print_vlan_key(&(l_pkt_key->l2_key.vlan1));
-	printk("\nVLAN 2:\n");
-	tpm_print_vlan_key(&(l_pkt_key->l2_key.vlan2));
-	TPM_OS_DEB_WAIT();
-
-	tpm_print_ipv4_key(&(l_pkt_key->ipv4_key), &(l_pkt_key->ipv4_add_key));
-	TPM_OS_DEB_WAIT();
-
-	printk("ipv6 L4 Src Port(%d), pv6 L4 Dst Port(%d)\n",
-	       pnc_data->pncl_tcam.pkt_key.l4_ports_key.l4_src_port, pnc_data->pncl_tcam.pkt_key.l4_ports_key.l4_dst_port);
-
-	printk("\nSRAM\n");
-	printk("next_lu_id(%d), next_lu_off_reg(%d), shift_updt_reg(%d)\n",
-	       pnc_data->pncl_sram.next_lu_id, pnc_data->pncl_sram.next_lu_off_reg, pnc_data->pncl_sram.shift_updt_reg);
-	printk("next_off_base(%d), lx_subf(%X)\n",
-	       pnc_data->pncl_sram.next_offset.offset_base, pnc_data->pncl_sram.next_offset.offset_sub.l2_subf);
-	TPM_OS_DEB_WAIT();
-	printk("sram_updt_bm(0x%x), l3_type(%d), l4_type(%d), mh_reg(%d,%d), pkt_col(%d)\n",
-	       pnc_data->pncl_sram.sram_updt_bm,
-	       pnc_data->pncl_sram.l3_type,
-	       pnc_data->pncl_sram.l4_type,
-	       pnc_data->pncl_sram.mh_reg.mh_set, pnc_data->pncl_sram.mh_reg.mh_reg, pnc_data->pncl_sram.pkt_col);
-
-	TPM_OS_DEB_WAIT();
-	printk("pnc_queue(%d), flow_id_gem(%d), flow_id_mod(%d), flow_id_txp(%d), \n",
-	       pnc_data->pncl_sram.pnc_queue,
-	       pnc_data->pncl_sram.flow_id_sub.gem_port,
-	       pnc_data->pncl_sram.flow_id_sub.mod_cmd, pnc_data->pncl_sram.flow_id_sub.pnc_target);
-
-	TPM_OS_DEB_WAIT();
-	if (pnc_data->pncl_sram.add_info_mask != 0)
-		printk("ai_data(%x),  ai_mask(%x)\n",
-		       pnc_data->pncl_sram.add_info_data, pnc_data->pncl_sram.add_info_mask);
-}
-
-/*******************************************************************************
-* tpm_pncl_mh_parse()
-*
-* DESCRIPTION:     The function creates the TCAM Marvell Header parsing format,
-*                  according to the information that must be parsed (Amber MH, or GPON Header)
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function (should always be zero)
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physicalTCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_mh_parse(uint32_t offset,
-			  tpm_pkt_data_t *pkt_data,
-			  tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in)
-{
-	tpm_db_int_conn_t int_con;
-	uint32_t switch_port;
-	int32_t ret_code;
-	uint16_t mh = 0;
-	tpm_db_pon_type_t pon_type;
-	uint32_t switch_init;
-
-	/* Parse MH, depending on field parse request */
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* US, specific UNI Port */
-	if (FROM_SPEC_UNI(tcam_in->pkt_key.src_port)) {
-		/* Get Amber Switch Port */
-		ret_code = tpm_db_intport_int_con_get(tcam_in->pkt_key.src_port, &int_con, &switch_port);
-		IF_ERROR(ret_code);
-
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "MH set by UNI_Port_%d -> switch_port(%d)\n",
-			     (tcam_in->pkt_key.src_port - TPM_SRC_PORT_UNI_0), switch_port);
-
-		/* Translate switch_port to Marvell Header */
-		if (int_con == TPM_INTCON_SWITCH)
-			mh = (switch_port << MH_UNI_PORT_OFFSET);
-		else {		/* UNI Port, not connected to Switch */
-			mh = 0;
-		}
-
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(mh);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(MH_UNI_PORT_MASK);
-
-	}
-	/* DS, set MH according to Gemport */
-	else if (tcam_in->l2_parse_bm & TPM_L2_PARSE_GEMPORT) {	/* Specific GPON gemport */
-		/* Double-check WAN technology */
-		ret_code = tpm_db_pon_type_get(&pon_type);
-		IF_ERROR(ret_code);
-		if (pon_type != TPM_GPON) {
-			TPM_OS_ERROR(TPM_PNCL_MOD, " MH set requested for non-GPON WAN technology \n");
-			return(TPM_FAIL);
-		}
-		mh = ((tcam_in->pkt_key.l2_key.gem_port) << MH_GEM_PORT_OFFSET);
-
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(mh);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(MH_GEM_PORT_MASK);
-
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "MH from GemPort\n");
-	} else {
-		if (tcam_in->pkt_key.src_port == TPM_SRC_PORT_WAN) {
-			/* it is for multicast per uni vlan feature
-			   in the first loop, pkt goes to G1 from G0 through Switch.
-			 */
-			ret_code = tpm_db_switch_init_get(&switch_init);
-			IF_ERROR(ret_code);
-			if (switch_init) {
-				mh = tpm_db_eth_port_switch_port_get(TPM_SRC_PORT_WAN);
-				if (TPM_DB_ERR_PORT_NUM == mh) {
-					TPM_OS_ERROR(TPM_PNCL_MOD, "tpm_db_eth_port_switch_port_get returned %d\n", mh);
-					return(TPM_FAIL);
-				}
-			} else
-				mh = 0;
-
-			/* Update TCAM Data and Mask */
-			*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(mh);
-			*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(MH_UNI_PORT_MASK);
-		} else {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "Unrecognized MH parsing request received\n");
-			return(TPM_FAIL);
-		}
-	}
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "MH(%02x%02x) MH_mask(%02x%02x) \n",
-		     pkt_data->pkt_byte[offset],
-		     pkt_data->pkt_byte[offset + 1], pkt_mask->pkt_byte[offset], pkt_mask->pkt_byte[offset + 1]);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_da_parse()
-*
-* DESCRIPTION:     The function creates the TCAM MAC DA parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_da_parse(uint32_t offset,
-			  tpm_pkt_data_t *pkt_data,
-			  tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in)
-{
-	uint32_t i;
-	for (i = 0; i < TPM_DA_LEN; i++) {
-		pkt_data->pkt_byte[offset] = tcam_in->pkt_key.l2_key.mac.mac_da[i];
-		pkt_mask->pkt_byte[offset] = tcam_in->pkt_key.l2_key.mac.mac_da_mask[i];
-		offset++;
-	}
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_sa_parse()
-*
-* DESCRIPTION:     The function creates the TCAM MAC SA parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_sa_parse(uint32_t offset,
-			  tpm_pkt_data_t *pkt_data,
-			  tpm_pkt_mask_t *pkt_mask,
-			  tpm_pncl_tcam_data_t *tcam_in)
-{
-	uint32_t i;
-	for (i = 0; i < TPM_DA_LEN; i++) {
-		pkt_data->pkt_byte[offset] = tcam_in->pkt_key.l2_key.mac.mac_sa[i];
-		pkt_mask->pkt_byte[offset] = tcam_in->pkt_key.l2_key.mac.mac_sa_mask[i];
-		offset++;
-	}
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_vlan_parse()
-*
-* DESCRIPTION:     The function creates a TCAM Vlan Tag parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-* sec_vlan_tag     - States if this is second Vlan Tag
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS: Used by tpm_pncl_vlan1_parse, tpm_pncl_vlan2_parse
-*
-*******************************************************************************/
-int32_t tpm_pncl_vlan_parse(uint32_t offset,
-			    uint32_t sec_vlan_tag,
-			    tpm_pkt_data_t *pkt_data,
-			    tpm_pkt_mask_t *pkt_mask,
-			    tpm_pncl_tcam_data_t *tcam_in)
-{
-	tpm_vlan_key_t *vlan_key;
-	uint16_t temp_data;
-	uint16_t temp_mask;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d), sec_vlan_tag(%d)\n", offset, sec_vlan_tag);
-
-	if (sec_vlan_tag == 0)
-		vlan_key = &(tcam_in->pkt_key.l2_key.vlan1);
-	else
-		vlan_key = &(tcam_in->pkt_key.l2_key.vlan2);
-
-	/* Vlan Ethertype */
-#if 0
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(vlan_key->tpid);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-#endif
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(((vlan_key->tpid) & (vlan_key->tpid_mask)));
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons((0xFFFF & (vlan_key->tpid_mask)));
-
-	offset += 2;
-
-	/* VID, pbits, cfi */
-	temp_data = (((vlan_key->cfi) & (vlan_key->cfi_mask)) << TPM_VLAN_CFI_OFFSET) +
-		    (((vlan_key->pbit) & (vlan_key->pbit_mask)) << TPM_VLAN_PBIT_OFFSET) +
-		    (((vlan_key->vid) & (vlan_key->vid_mask)) << TPM_VLAN_VID_OFFSET);
-
-	temp_mask = ((0x01 & vlan_key->cfi_mask) << TPM_VLAN_CFI_OFFSET) +
-		    ((0x07 & vlan_key->pbit_mask) << TPM_VLAN_PBIT_OFFSET) +
-		    ((0x0FFF & vlan_key->vid_mask) << TPM_VLAN_VID_OFFSET);
-
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(temp_data);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(temp_mask);
-
-	return(TPM_OK);
-
-}
-
-/*******************************************************************************
-* tpm_pncl_vlan1_parse()
-*
-* DESCRIPTION:     The function creates a TCAM first Vlan Tag parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_vlan1_parse(uint32_t offset,
-			     tpm_pkt_data_t *pkt_data,
-			     tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-	tpm_pncl_vlan_parse(offset, 0, pkt_data, pkt_mask, tcam_in);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_vlan2_parse()
-*
-* DESCRIPTION:     The function creates a TCAM second Vlan Tag parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_vlan2_parse(uint32_t offset,
-			     tpm_pkt_data_t *pkt_data,
-			     tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in)
-{
-	tpm_pncl_vlan_parse(offset, 1, pkt_data, pkt_mask, tcam_in);
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_etype_parse()
-*
-* DESCRIPTION:     The function creates a TCAM Ethertype parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_etype_parse(uint32_t offset,
-			     tpm_pkt_data_t *pkt_data,
-			     tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.l2_key.ether_type);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_pppoe_parse()
-*
-* DESCRIPTION:     The function creates a TCAM PPPoE header parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_pppoe_parse(uint32_t offset,
-			     tpm_pkt_data_t *pkt_data,
-			     tpm_pkt_mask_t *pkt_mask,
-			     tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	if (tcam_in->l2_parse_bm & TPM_L2_PARSE_PPPOE_SES) {
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset + 2])) =
-		htons(tcam_in->pkt_key.l2_key.pppoe_hdr.ppp_session);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset + 2])) = htons(0xFFFF);
-	}
-	if (tcam_in->l2_parse_bm & TPM_L2_PARSE_PPP_PROT) {
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset + 6])) = htons(tcam_in->pkt_key.l2_key.pppoe_hdr.ppp_proto);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset + 6])) = htons(0xFFFF);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_l3_etype_parse()
-*
-* DESCRIPTION:     The function creates a TCAM L3 Ethertype parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_l3_etype_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.l3_key.ether_type_key);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_l3_pppoe_parse()
-*
-* DESCRIPTION:     The function creates a TCAM PPPoE header parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_l3_pppoe_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	if (tcam_in->l3_parse_bm & TPM_L2_PARSE_PPPOE_SES) {
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset + 2])) =
-		htons(tcam_in->pkt_key.l3_key.pppoe_key.ppp_session);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset + 2])) = htons(0xFFFF);
-	}
-	if (tcam_in->l3_parse_bm & TPM_L2_PARSE_PPP_PROT) {
-		/* Update TCAM Data and Mask */
-		*(uint16_t *) (&(pkt_data->pkt_byte[offset + 6])) = htons(tcam_in->pkt_key.l3_key.pppoe_key.ppp_proto);
-		*(uint16_t *) (&(pkt_mask->pkt_byte[offset + 6])) = htons(0xFFFF);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_ver_ihl_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 version and IHL parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_ver_ihl_parse(uint32_t offset,
-				    tpm_pkt_data_t *pkt_data,
-				    tpm_pkt_mask_t *pkt_mask,
-				    tpm_pncl_tcam_data_t *tcam_in)
-{
-	uint16_t temp_data = 0;
-	uint16_t temp_mask = 0;
-	tpm_ipv4_add_key_t *ipv4_add_key;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	ipv4_add_key = &(tcam_in->pkt_key.ipv4_add_key);
-
-	/* Add IHL if requested */
-	temp_data |=
-	(ipv4_add_key->ipv4_ihl_mask) * ((ipv4_add_key->ipv4_ihl & TPM_IPV4_IHL_MASK) << TPM_IPV4_IHL_OFFSET);
-	temp_mask |= (ipv4_add_key->ipv4_ihl_mask) * (TPM_IPV4_IHL_MASK << TPM_IPV4_IHL_OFFSET);
-
-	/* Add IP Version if requested */
-	temp_data |=
-	(ipv4_add_key->ipv4_ver_mask) * ((ipv4_add_key->ipv4_ver & TPM_IPV4_VER_MASK) << TPM_IPV4_VER_OFFSET);
-	temp_mask |= (ipv4_add_key->ipv4_ver_mask) * (TPM_IPV4_VER_MASK << TPM_IPV4_VER_OFFSET);
-
-	/* Update TCAM Data and Mask */
-	*(uint8_t *) (&(pkt_data->pkt_byte[offset])) = temp_data;
-	*(uint8_t *) (&(pkt_mask->pkt_byte[offset])) = temp_mask;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_tot_len_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 version and IHL parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_tot_len_parse(uint32_t offset,
-				    tpm_pkt_data_t *pkt_data,
-				    tpm_pkt_mask_t *pkt_mask,
-				    tpm_pncl_tcam_data_t *tcam_in)
-{
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv4_add_key.ipv4_totlen);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv4_add_key.ipv4_totlen_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_flag_ttl_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 version and IHL parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_flag_ttl_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint8_t *) (&(pkt_data->pkt_byte[offset])) = tcam_in->pkt_key.ipv4_add_key.ipv4_ttl;
-	*(uint8_t *) (&(pkt_mask->pkt_byte[offset])) = TPM_IPV4_TTL_MASK;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_ident_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 version and IHL parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_ident_parse(uint32_t offset,
-				  tpm_pkt_data_t *pkt_data,
-				  tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in)
-{
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv4_add_key.ipv4_ident);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = TPM_IPV4_IDENT_MASK;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_flag_off_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 version and IHL parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_flag_off_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	uint16_t temp_data = 0;
-	uint16_t temp_mask = 0;
-	tpm_ipv4_add_key_t *ipv4_add_key;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	ipv4_add_key = &(tcam_in->pkt_key.ipv4_add_key);
-
-	/* Add Fragment Offset if requested */
-	temp_data |= ((ipv4_add_key->ipv4_frag_offset_mask) *
-		      ((ipv4_add_key->ipv4_frag_offset) & TPM_IPV4_FRAG_MASK)) << TPM_IPV4_FRAG_OFFSET;
-
-	temp_mask |= ((ipv4_add_key->ipv4_frag_offset_mask) * TPM_IPV4_FRAG_MASK) << TPM_IPV4_FRAG_OFFSET;
-
-	/* Add MH Flag if requested */
-	temp_data |= ((ipv4_add_key->ipv4_flags_mask) *
-		      ((ipv4_add_key->ipv4_flags) & TPM_IPV4_MF_MASK)) << TPM_IPV4_MF_OFFSET;
-
-	temp_mask |= ((ipv4_add_key->ipv4_flags_mask) * TPM_IPV4_MF_MASK) << TPM_IPV4_MF_OFFSET;
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(temp_data);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(temp_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_dscp_parse()
-*
-* DESCRIPTION:     The function creates a TCAM ipv4 DSCP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_dscp_parse(uint32_t offset,
-				 tpm_pkt_data_t *pkt_data,
-				 tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint8_t *) (&(pkt_data->pkt_byte[offset])) = ((tcam_in->pkt_key.ipv4_key.ipv4_dscp) & 0x3F) << 2;
-	*(uint8_t *) (&(pkt_mask->pkt_byte[offset])) = ((tcam_in->pkt_key.ipv4_key.ipv4_dscp_mask) & 0x3F) << 2;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_proto_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 protocol parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_proto_parse(uint32_t offset,
-				  tpm_pkt_data_t *pkt_data,
-				  tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint8_t *) (&(pkt_data->pkt_byte[offset])) = (tcam_in->pkt_key.ipv4_key.ipv4_proto);
-	*(uint8_t *) (&(pkt_mask->pkt_byte[offset])) = (0xFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_sip_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 source IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_sip_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	memcpy(&(pkt_data->pkt_byte[offset]), tcam_in->pkt_key.ipv4_key.ipv4_src_ip_add, 4);
-	memcpy(&(pkt_mask->pkt_byte[offset]), tcam_in->pkt_key.ipv4_key.ipv4_src_ip_add_mask, 4);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_dip_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_dip_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	memcpy(&(pkt_data->pkt_byte[offset]), tcam_in->pkt_key.ipv4_key.ipv4_dst_ip_add, 4);
-	memcpy(&(pkt_mask->pkt_byte[offset]), tcam_in->pkt_key.ipv4_key.ipv4_dst_ip_add_mask, 4);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_l4_src_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_l4_src_port_parse(uint32_t offset,
-					tpm_pkt_data_t *pkt_data,
-					tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv4_key.l4_src_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv4_l4_dst_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv4_l4_dst_port_parse(uint32_t offset,
-					tpm_pkt_data_t *pkt_data,
-					tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv4_key.l4_dst_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_l4_src_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_l4_src_port_parse(uint32_t offset,
-					tpm_pkt_data_t *pkt_data,
-					tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv6_key.l4_src_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_l4_dst_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_l4_dst_port_parse(uint32_t offset,
-					tpm_pkt_data_t *pkt_data,
-					tpm_pkt_mask_t *pkt_mask,
-					tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv6_key.l4_dst_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_l4_src_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_l4_src_port_parse(uint32_t offset,
-				   tpm_pkt_data_t *pkt_data,
-				   tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.l4_ports_key.l4_src_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_l4_dst_port_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_l4_dst_port_parse(uint32_t offset,
-				   tpm_pkt_data_t *pkt_data,
-				   tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.l4_ports_key.l4_dst_port);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(0xFFFF);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_tcp_flags_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv4 destination IP parsing format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_tcp_flags_parse(uint32_t offset,
-				 tpm_pkt_data_t *pkt_data,
-				 tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	pkt_data->pkt_byte[offset] = tcam_in->pkt_key.tcp_key.tcp_flags;
-	pkt_mask->pkt_byte[offset] = tcam_in->pkt_key.tcp_key.tcp_flags_mask;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_ver_dscp_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 Version and DSCP parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_ver_dscp_parse(uint32_t offset,
-				     tpm_pkt_data_t *pkt_data,
-				     tpm_pkt_mask_t *pkt_mask,
-				     tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "ipv6 key, dscp: %d, mask: %d\n",
-		     tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp, tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp_mask);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care version */
-	pkt_data->pkt_byte[offset] |= (tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp & 0x3c) >> 2;
-	pkt_mask->pkt_byte[offset] |= (tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp_mask & 0x3c) >> 2;
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_dscp_flow_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 DSCP and FLOW parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_dscp_flow_parse(uint32_t offset,
-				      tpm_pkt_data_t *pkt_data,
-				      tpm_pkt_mask_t *pkt_mask,
-				      tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "ipv6 key, dscp: %d, mask: %d\n",
-		     tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp, tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp_mask);
-	/* Update TCAM Data and Mask */
-	/* We don't care flow */
-	pkt_data->pkt_byte[offset] |= (tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp & 0x03) << 6;
-	pkt_mask->pkt_byte[offset] |= (tcam_in->pkt_key.ipv6_gen_key.ipv6_dscp_mask & 0x03) << 6;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_flow_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 FLOW parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_flow_parse(uint32_t offset,
-				 tpm_pkt_data_t *pkt_data,
-				 tpm_pkt_mask_t *pkt_mask,
-				 tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care flow */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_IPV6_FLOW_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_IPV6_FLOW_LEN);
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_pllen_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 Payload len parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_pllen_parse(uint32_t offset,
-				  tpm_pkt_data_t *pkt_data,
-				  tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	*(uint16_t *) (&(pkt_data->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv6_add_key.ipv6_totlen);
-	*(uint16_t *) (&(pkt_mask->pkt_byte[offset])) = htons(tcam_in->pkt_key.ipv6_add_key.ipv6_totlen_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_nh_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 Next Header parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_nh_parse(uint32_t offset,
-			       tpm_pkt_data_t *pkt_data,
-			       tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	pkt_data->pkt_byte[offset] = tcam_in->pkt_key.ipv6_key.ipv6_next_header;
-	pkt_mask->pkt_byte[offset] = 0xFF;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_hoplim_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 Hop Limit parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_hoplim_parse(uint32_t offset,
-				   tpm_pkt_data_t *pkt_data,
-				   tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-
-	/*memset(&pkt_data->pkt_byte[offset], 0x0, TPM_IPV6_HOPLIM_LEN);*/
-	/*memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_IPV6_HOPLIM_LEN);*/
-	pkt_data->pkt_byte[offset] = tcam_in->pkt_key.ipv6_gen_key.hop_limit;
-	pkt_mask->pkt_byte[offset] = 0xff;
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_ipv6_sip_parse()
-*
-* DESCRIPTION:     The function creates a TCAM IPv6 SIP parse format.
-*
-* INPUTS:
-* offset           - Offset in PNC TCAM when starting the function
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_ipv6_sip_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	memcpy(&(pkt_data->pkt_byte[offset]), tcam_in->pkt_key.ipv6_gen_key.ipv6_src_ip_add, 16);
-	memcpy(&(pkt_mask->pkt_byte[offset]), tcam_in->pkt_key.ipv6_gen_key.ipv6_src_ip_add_mask, 16);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_ipv6_dip_parse(uint32_t offset,
-				tpm_pkt_data_t *pkt_data,
-				tpm_pkt_mask_t *pkt_mask,
-				tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	memcpy(&(pkt_data->pkt_byte[offset]), tcam_in->pkt_key.ipv6_dip_key.ipv6_ip_add, 16);
-	memcpy(&(pkt_mask->pkt_byte[offset]), tcam_in->pkt_key.ipv6_dip_key.ipv6_ip_add_mask, 16);
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_udp_len_parse(uint32_t offset,
-			       tpm_pkt_data_t *pkt_data,
-			       tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_UDP_LEN_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_UDP_LEN_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_l4_checksum_parse(uint32_t offset,
-				   tpm_pkt_data_t *pkt_data,
-				   tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_L4_CHECKSUM_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_L4_CHECKSUM_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_tcp_seq_parse(uint32_t offset,
-			       tpm_pkt_data_t *pkt_data,
-			       tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_SEQ_NUM_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_SEQ_NUM_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_tcp_ack_parse(uint32_t offset,
-			       tpm_pkt_data_t *pkt_data,
-			       tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_ACK_NUM_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_ACK_NUM_LEN);
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_tcp_offset_parse(uint32_t offset,
-				  tpm_pkt_data_t *pkt_data,
-				  tpm_pkt_mask_t *pkt_mask,
-				  tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_OFFSET_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_OFFSET_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_ipv6_tcp_flags_parse(uint32_t offset,
-				      tpm_pkt_data_t *pkt_data,
-				      tpm_pkt_mask_t *pkt_mask,
-				      tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_FLAGS_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_FLAGS_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_tcp_win_parse(uint32_t offset,
-			       tpm_pkt_data_t *pkt_data,
-			       tpm_pkt_mask_t *pkt_mask,
-			       tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_WIN_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_WIN_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_tcp_urgtptr_parse(uint32_t offset,
-				   tpm_pkt_data_t *pkt_data,
-				   tpm_pkt_mask_t *pkt_mask,
-				   tpm_pncl_tcam_data_t *tcam_in)
-{
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " offset_in(%d)\n", offset);
-
-	/* Update TCAM Data and Mask */
-	/* We don't care */
-	memset(&pkt_data->pkt_byte[offset], 0x0, TPM_TCP_URGTPTR_LEN);
-	memset(&pkt_mask->pkt_byte[offset], 0x0, TPM_TCP_URGTPTR_LEN);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_get_parse_tbl(tpm_pncl_offset_t *logic_offset,
-			       tpm_parse_tbl_t **tbl, uint32_t *tbl_size)
-{
-	if (logic_offset->offset_base == TPM_PNCL_ZERO_OFFSET) {
-		*tbl = pncl_l2_parse_tbl;
-		*tbl_size = sizeof(pncl_l2_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_L3_OFFSET) {
-		*tbl = pncl_l3_parse_tbl;
-		*tbl_size = sizeof(pncl_l3_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_IPV4_OFFSET) {
-		*tbl = pncl_ipv4_parse_tbl;
-		*tbl_size = sizeof(pncl_ipv4_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_IPV6_OFFSET) {
-		*tbl = pncl_ipv6_parse_tbl;
-		*tbl_size = sizeof(pncl_ipv6_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_IPV6_DIP_OFFSET) {
-		*tbl = pncl_ipv6_dip_parse_tbl;
-		*tbl_size = sizeof(pncl_ipv6_dip_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_IPV6_EXT_OFFSET) {
-		*tbl = pncl_ipv6_ext_hdr_parse_tbl;
-		*tbl_size = sizeof(pncl_ipv6_ext_hdr_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_TCP_OFFSET) {
-		*tbl = pncl_tcp_parse_tbl;
-		*tbl_size = sizeof(pncl_tcp_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else if (logic_offset->offset_base == TPM_PNCL_L4_OFFSET) {
-		*tbl = pncl_l4_ports_parse_tbl;
-		*tbl_size = sizeof(pncl_l4_ports_parse_tbl) / sizeof(tpm_parse_tbl_t);
-	} else {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "Unsupported offset_base %d \n", logic_offset->offset_base);
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pncl_log_offset_get()
-*
-* DESCRIPTION:     This function takes a TCAM logical Offset field and logical Offset sub-field,
-*                  (See tpm_pncl_offset_t) and returns the matching entry in the parsing function table
-*                  pncl_l2_parse_tbl.
-* INPUTS:
-* logic_offset     - Pointer to offset bas & offset sub-field
-*
-* OUTPUTS:
-* parse_tbl_ind   - pointer to physical TCAM packet data (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_log_offset_get(tpm_pncl_offset_t *logic_offset, uint32_t *parse_tbl_ind)
-{
-	uint32_t i;
-	int32_t ret_code;
-	tpm_parse_tbl_t *tbl;
-	uint32_t tbl_size;
-
-	/* Reset output */
-	*parse_tbl_ind = 0;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "log_offset_base(%d) , log_offset_sub(%x)\n",
-		     logic_offset->offset_base, logic_offset->offset_sub.subf);
-
-	ret_code = tpm_pncl_get_parse_tbl(logic_offset, &tbl, &tbl_size);
-	IF_ERROR(ret_code);
-
-	for (i = 0; i < tbl_size; i++) {
-		if (tbl[i].parse_bm & logic_offset->offset_sub.subf) {
-			*parse_tbl_ind = i;
-			break;
-		}
-	}
-
-	if (i == tbl_size) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "No start offset sub-field found \n");
-		return(TPM_FAIL);
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_pkt_data_parse()
-*
-* DESCRIPTION: Function translates Logical TCAM structure to physical TCAM packet data and mask
-*
-* INPUTS:
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* pkt_data         - pointer to physical TCAM packet data (24 bytes)
-* pkt_mask         - pointer to physical TCAM packet mask (24 bytes)
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_pkt_data_parse(tpm_pncl_tcam_data_t *tcam_in, tpm_pkt_data_t *pkt_data, tpm_pkt_mask_t *pkt_mask)
-{
-	int32_t ret_code;
-	int32_t white_space;
-	uint32_t start_ind, i;
-	uint32_t tcam_offset = 0, field_len, shift_len, size;
-	tpm_parse_tbl_t *parse_table;
-	tpm_pncl_parse_bm_t parse_bm;
-
-	tpm_pkt_data_t l_pkt_data;
-	tpm_pkt_mask_t l_pkt_mask;
-
-	memset(&l_pkt_data, 0, sizeof(tpm_pkt_data_t));
-	memset(&l_pkt_mask, 0, sizeof(tpm_pkt_mask_t));
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "\n");
-
-	/* Loop over L2 fields, starting from the start_offset sub_field */
-	/* 1 - Find start Offset */
-	ret_code = tpm_pncl_log_offset_get(&(tcam_in->start_offset), &start_ind);
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "start_offset_bm(%x), start_index(%d) \n",
-		     tcam_in->start_offset.offset_sub.subf, start_ind);
-	IF_ERROR(ret_code);
-
-	ret_code = tpm_pncl_get_parse_tbl(&tcam_in->start_offset, &parse_table, &size);
-	IF_ERROR(ret_code);
-
-	if (tcam_in->start_offset.offset_base == TPM_PNCL_ZERO_OFFSET) {
-		parse_bm = tcam_in->l2_parse_bm;
-	} else if (tcam_in->start_offset.offset_base == TPM_PNCL_L3_OFFSET) {
-		parse_bm = tcam_in->l3_parse_bm;
-	} else if (tcam_in->start_offset.offset_base == TPM_PNCL_IPV4_OFFSET) {
-		parse_bm = tcam_in->ipv4_parse_bm;
-	} else if ((tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_OFFSET)
-		   || (tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_EXT_OFFSET)
-		   || (tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_DIP_OFFSET)
-		  ) {
-		parse_bm = tcam_in->ipv6_parse_bm;
-	} else if (tcam_in->start_offset.offset_base == TPM_PNCL_TCP_OFFSET) {
-		parse_bm = tcam_in->tcp_parse_bm;
-	} else if (tcam_in->start_offset.offset_base == TPM_PNCL_L4_OFFSET) {
-		parse_bm = tcam_in->l4_parse_bm;
-	}
-
-	else {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "Invalid base offset %d\n", tcam_in->start_offset.offset_base);
-		return(TPM_FAIL);
-	}
-
-	/* 2 - Perform Parsing Loop */
-	for (i = start_ind; i < size; i++) {
-		field_len = parse_table[i].field_len;
-		shift_len = parse_table[i].shift_len;
-
-		/* 1 - Field must be parsed */
-		if (parse_table[i].parse_bm & parse_bm) {
-			/* Cannot parse pass TCAM length */
-			if ((tcam_offset + field_len) > TPM_TCAM_PKT_WIDTH) {
-				TPM_OS_ERROR(TPM_PNCL_MOD, "TCAM Width passed \n");
-				return(TPM_FAIL);
-			}
-			/* Parse the field, by func */
-			(*(parse_table[i].parse_func)) (tcam_offset, &l_pkt_data, &l_pkt_mask, tcam_in);
-			tcam_offset += field_len;
-
-			/* Must skip untill next field, "skip" means to write masked bytes to TCAM packet data and TCAM mask */
-			white_space = shift_len - field_len;
-			/* TODO : Check shift_len - field_len > 0 */
-
-		} else if (parse_table[i].mandatory)	/* 2 - Must skip entire current field untill next field */
-			white_space = shift_len - 0;
-		else	/* 3 - Field doesn't exist in packet, no parsing or skipping */
-			white_space = 0;
-
-		/* 4 - Perform generic skipping for all three cases above (no skipping for case 3) */
-		if ((tcam_offset + white_space) > TPM_TCAM_PKT_WIDTH)
-			white_space = TPM_TCAM_PKT_WIDTH - tcam_offset;
-
-		memset(&(l_pkt_data.pkt_byte[tcam_offset]), 0, white_space);
-		memset(&(l_pkt_mask.pkt_byte[tcam_offset]), 0, white_space);
-		tcam_offset += white_space;
-	}
-
-	/* Set TCAM Data & Mask */
-	memcpy(pkt_data, &l_pkt_data, TPM_TCAM_PKT_WIDTH);
-	memcpy(pkt_mask, &l_pkt_mask, TPM_TCAM_PKT_WIDTH);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_shift_calc()
-*
-* DESCRIPTION: Function receives a logical start_offset, stop_offset and parsing bitmap,
-*              and calculates the shift_length from start_offset up untill stop_offset
-*              The parse bitmap is important, because it indicates which optional fields exist,
-*              e.g. Vlan Tags, PPPoE etc.
-* INPUTS:
-* start_offset     - Start offset structure
-* stop_offset      - Stop offset structure
-* l2_parse_bm      - Parse bitmap field.
-*
-* OUTPUTS:
-* calc_shift       - Calculated Shift in bytes
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_shift_calc(tpm_pncl_offset_t *start_offset,
-			    tpm_pncl_offset_t *stop_offset,
-			    tpm_pncl_parse_bm_t parse_bm,
-			    uint32_t *calc_shift)
-{
-	uint32_t start_ind, stop_ind, t_calc_shift = 0;
-	uint32_t i;
-	uint32_t ret_code, size;
-	tpm_parse_tbl_t *parse_table;
-	tpm_pncl_parse_bm_t stop_offset_bm;
-
-	if (start_offset->offset_base != stop_offset->offset_base) {
-		TPM_OS_ERROR(TPM_PNCL_MOD, "start base offset %d != stop base offset %d\n",
-			     start_offset->offset_base, stop_offset->offset_base);
-		return(TPM_FAIL);
-	}
-
-	ret_code = tpm_pncl_get_parse_tbl(start_offset, &parse_table, &size);
-	IF_ERROR(ret_code);
-
-	stop_offset_bm = stop_offset->offset_sub.subf;
-
-	/* Get Start Index */
-	ret_code = tpm_pncl_log_offset_get(start_offset, &start_ind);
-	IF_ERROR(ret_code);
-
-	/* Get Stop Index */
-	if (stop_offset_bm == 0)
-		stop_ind = 0;
-	else if (stop_offset_bm == 0xFFFF) {
-		stop_ind = size;
-
-		if (stop_offset->offset_base == TPM_PNCL_IPV4_OFFSET) {
-			*calc_shift = 126;
-			return(TPM_OK);
-		}
-
-		if (stop_offset->offset_base == TPM_PNCL_IPV6_EXT_OFFSET) {
-			*calc_shift = 127;
-			return(TPM_OK);
-		}
-	} else {
-		ret_code = tpm_pncl_log_offset_get(stop_offset, &stop_ind);
-		IF_ERROR(ret_code);
-	}
-	if (stop_ind < start_ind)
-		TPM_OS_DEBUG(TPM_PNCL_MOD, " stop field < start field, shift=0 \n");
-
-	/* Calc Shift until end (not including last!) */
-	for (i = start_ind; i < stop_ind; i++) {
-		/* Shift is added to sum if (field is mandatory) or
-		 * (field is optional, but it was parsed in TCAM, so it exists) */
-		if (parse_table[i].mandatory == TPM_TRUE || ((parse_table[i].parse_bm & parse_bm) > 0))
-			t_calc_shift += parse_table[i].shift_len;
-	}
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " Calculated PNC shift =(%d)\n", t_calc_shift);
-
-	*calc_shift = t_calc_shift;
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_tcam_map()
-*
-* DESCRIPTION:    Function maps a Logical TCAM structure to a pseudo-physical TCAM Entry
-*
-*
-*
-* INPUTS:
-* tcam_in          - Logical TCAM structure
-*
-* OUTPUTS:
-* tcam_out         - Physical TCAM Entry
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_tcam_map(tpm_pncl_tcam_data_t *tcam_in, tpm_tcam_all_t *tcam_out)
-{
-	int32_t ret_code;
-	tpm_tcam_all_t temp_tcam_out;
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "\n");
-
-	/* AI bits are unchanged */
-	temp_tcam_out.add_info_data = tcam_in->add_info_data;
-	temp_tcam_out.add_info_mask = tcam_in->add_info_mask;
-
-	/* Lookup is unchanged */
-	temp_tcam_out.lu_id = tcam_in->lu_id;
-
-	/* Port Id mask is unchanged */
-	temp_tcam_out.port_ids = tcam_in->port_ids;
-
-	/**** Packet Data parsing ****/
-	ret_code = tpm_pncl_pkt_data_parse(tcam_in, &(temp_tcam_out.pkt_data), &(temp_tcam_out.pkt_mask));
-	IF_ERROR(ret_code);
-
-	/* Set Output */
-	memcpy(tcam_out, &temp_tcam_out, sizeof(tpm_tcam_all_t));
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_flowid_map()
-*
-* DESCRIPTION:    Function maps a Logical Flowid and SRAM bitmap to a pseudo-physical FlowId value and update mask
-*
-*
-* INPUTS:
-* flowid_in       - Flowid Data
-* sram_bm_in      - Logical SRAM bitmap
-*
-* OUTPUTS:
-* flowid_val      - Physical SRAM flowid value
-* flowid_updt_mask- pseudo-physical flowid update mask (mapping to physical maps performed in tpm_pnc_mgr)
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_flowid_map(tpm_pncl_flowid_t *flowid_in,
-			    tpm_pncl_sram_updt_bm_t sram_bm_in,
-			    uint32_t *flowid_val, uint32_t *flowid_updt_mask)
-{
-
-	*flowid_val = 0;
-	*flowid_updt_mask = 0;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "\n");
-	if (sram_bm_in & TPM_PNCL_SET_GEM) {
-		*flowid_val |= (flowid_in->gem_port << TPM_GEM_FL_SHIFT);
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "flow_id after gem_addition(%x)\n", *flowid_val);
-		*flowid_updt_mask |= TPM_GEM_FL_UPDT_MASK;
-	}
-	if (sram_bm_in & TPM_PNCL_SET_TXP) {
-		*flowid_val |= (flowid_in->pnc_target << TPM_TXP_FL_SHIFT);
-		*flowid_updt_mask |= TPM_TXP_FL_UPDT_MASK;
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "flow_id after txp_addition(%x)\n", *flowid_val);
-	}
-	if (sram_bm_in & TPM_PNCL_SET_MOD) {
-		*flowid_val |= (flowid_in->mod_cmd << TPM_MOD_FL_SHIFT);
-		*flowid_updt_mask |= TPM_MOD_FL_UPDT_MASK;
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "flow_id after pkt_mod_addition(%x)\n", *flowid_val);
-	}
-	if (sram_bm_in & TPM_PNCL_SET_SPLIT_MOD) {
-		*flowid_val |= (flowid_in->mod_cmd << TPM_MOD_FL_SHIFT);
-		*flowid_updt_mask |= TPM_MOD_FL_SPLIT_MOD_UPDT_MASK;
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "flow_id after pkt_mod_addition(%x)\n", *flowid_val);
-	}
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "flow_id log_mask(%x)\n", *flowid_updt_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_res_info_map()
-*
-* DESCRIPTION:   The function maps info from the SRAM Logical format
-*                into the Result Info bits in the SRAM pseudo-physical format
-*
-* INPUTS:
-* sram_in        - Sram logical structure
-*
-* OUTPUTS:
-* sram_out       - SRAM pseudo-physical structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_res_info_map(tpm_pncl_sram_data_t *sram_in, tpm_sram_all_t *sram_out)
-{
-
-	sram_out->res_info_23_16_data = 0;
-	sram_out->res_info_23_16_mask = 0;
-	sram_out->res_info_15_0_data = 0;
-	sram_out->res_info_15_0_mask = 0;
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_DISC)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_DISC_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_IGMP)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_RX_SPECIAL_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_RX_SPECIAL)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_RX_SPECIAL_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_L3)
-		tpm_pncl_set_l3(sram_in->l3_type, sram_out);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_L4)
-		tpm_pncl_set_l4(sram_in->l4_type, sram_out);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_COL)
-		;/* TODO : Fill in code */
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_BC)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_BC_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_MC)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_MC_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_UC)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_UC_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_MH_RI) {
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "mapping <TPM_PNCL_SET_MH_RI>: mh_set(%d), mh_reg(0x%x)\r\n",
-			     sram_in->mh_reg.mh_set, sram_in->mh_reg.mh_reg);
-		if (sram_in->mh_reg.mh_set) {
-			if (sram_in->mh_reg.mh_reg & TPM_MH_RI_BIT14)
-				tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_MH_BIT_14, 1);
-
-			if (sram_in->mh_reg.mh_reg & TPM_MH_RI_BIT15)
-				tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_MH_BIT_15, 1);
-
-			if (sram_in->mh_reg.mh_reg & TPM_MH_RI_BIT16)
-				tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_MH_BIT_16, 1);
-
-			if (sram_in->mh_reg.mh_reg & TPM_MH_RI_BIT17)
-				tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_MH_BIT_17, 1);
-		}
-	}
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_PPPOE)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_PPPOE_BIT, 1);
-
-	if (sram_in->sram_updt_bm & TPM_PNCL_SET_TAGGED)
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_VLAN_BIT, 1);
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "sram_out: res_info_23_16_data(0x%x) res_info_15_0_data(0x%x)\r\n"
-		     "          res_info_23_16_mask(0x%x) res_info_15_0_mask(0x%x)\r\n",
-		     sram_out->res_info_23_16_data, sram_out->res_info_15_0_data,
-		     sram_out->res_info_23_16_mask, sram_out->res_info_15_0_mask);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_sram_map()
-*
-* DESCRIPTION:   The function maps the Logical SRAM format into a pseudo-physical SRAM format
-*                To perform the mapping, certain TCAM fields are needed as well
-*
-* INPUTS:
-* tcam_in        - Logical TCAM structure
-* sram_in        - SRAM logical structure
-*
-* OUTPUTS:
-* sram_out       - SRAM pseudo-physical structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_sram_map(tpm_pncl_sram_data_t *sram_in, tpm_sram_all_t *sram_out, tpm_pncl_tcam_data_t *tcam_in)
-{
-	uint32_t calc_shift;
-	uint32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "\n");
-
-	/* Next LU */
-	sram_out->next_lu_id = sram_in->next_lu_id;
-	sram_out->next_lu_off_reg = sram_in->next_lu_off_reg;
-	sram_out->lookup_done = (((sram_in->sram_updt_bm & TPM_PNCL_SET_LUD) > 0) ? 1 : 0);
-
-	/* AI */
-	sram_out->add_info_data = sram_in->add_info_data;
-	sram_out->add_info_mask = sram_in->add_info_mask;
-
-	/* Queue */
-	sram_out->pnc_queue = sram_in->pnc_queue;
-
-	/* Shift Reg */
-	sram_out->shift_updt_reg = sram_in->shift_updt_reg;
-
-	/* Calculate Shift Value, if a shift_register must be updated */
-	if ((sram_out->shift_updt_reg != TPM_PNC_NOSHIFT_UPDATE_REG) && (!(sram_in->sram_updt_bm & TPM_PNCL_SET_DISC))) {
-		if (tcam_in->start_offset.offset_base == TPM_PNCL_ZERO_OFFSET) {
-			ret_code =
-			tpm_pncl_shift_calc(&(tcam_in->start_offset), &(sram_in->next_offset), tcam_in->l2_parse_bm,
-					    &calc_shift);
-			IF_ERROR(ret_code);
-		} else if (tcam_in->start_offset.offset_base == TPM_PNCL_L3_OFFSET) {
-			ret_code =
-			tpm_pncl_shift_calc(&(tcam_in->start_offset), &(sram_in->next_offset), tcam_in->l3_parse_bm,
-					    &calc_shift);
-			IF_ERROR(ret_code);
-		} else if (tcam_in->start_offset.offset_base == TPM_PNCL_IPV4_OFFSET) {
-			ret_code =
-			tpm_pncl_shift_calc(&(tcam_in->start_offset), &(sram_in->next_offset),
-					    tcam_in->ipv4_parse_bm, &calc_shift);
-			IF_ERROR(ret_code);
-		} else if ((tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_OFFSET) ||
-					(tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_EXT_OFFSET)/*||
-			(tcam_in->start_offset.offset_base == TPM_PNCL_IPV6_DIP_OFFSET) */) {
-			ret_code =
-			tpm_pncl_shift_calc(&(tcam_in->start_offset), &(sram_in->next_offset),
-					    tcam_in->ipv6_parse_bm, &calc_shift);
-			IF_ERROR(ret_code);
-		} else if (tcam_in->start_offset.offset_base == TPM_PNCL_TCP_OFFSET) {
-			ret_code =
-			tpm_pncl_shift_calc(&(tcam_in->start_offset), &(sram_in->next_offset),
-					    tcam_in->tcp_parse_bm, &calc_shift);
-			IF_ERROR(ret_code);
-		} else {
-			TPM_OS_ERROR(TPM_PNCL_MOD, "invalid offset base %d\n", tcam_in->start_offset.offset_base);
-			IF_ERROR(TPM_FAIL);
-		}
-
-		sram_out->shift_updt_val = calc_shift;
-	} else
-		sram_out->shift_updt_val = 0;
-
-	/* FlowId */
-	tpm_pncl_flowid_map(&(sram_in->flow_id_sub), sram_in->sram_updt_bm, &(sram_out->flowid_val),
-			    &(sram_out->flowid_updt_mask));
-
-	/* Result Info */
-	tpm_pncl_res_info_map(sram_in, sram_out);
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "ai_data(%x) ai_mask(%x) ri_15_0_d(%x) ri_15_0_m(%x) ri_23_16_d(%x) ri_23_16_m(%x)\n"
-		     "flowid_updt_mask(%x) flowid_val(%x) pnc_queue(%x)\n"
-		     "next_lu_reg(%d) next_lu_id(%d) shift_updt_reg(%d), shift_updt_val(%d)\n",
-		     sram_out->add_info_data,
-		     sram_out->add_info_mask,
-		     sram_out->res_info_15_0_data,
-		     sram_out->res_info_15_0_mask,
-		     sram_out->res_info_23_16_data,
-		     sram_out->res_info_23_16_mask,
-		     sram_out->flowid_updt_mask,
-		     sram_out->flowid_val,
-		     sram_out->pnc_queue,
-		     sram_out->next_lu_off_reg,
-		     sram_out->next_lu_id,
-		     sram_out->shift_updt_reg,
-		     sram_out->shift_updt_val);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_set_ri_bit()
-*
-* DESCRIPTION:   The function sets a single Result Info bit in the pseudo-phsical SRAM structure.
-*
-* INPUTS:
-* ri_bit         - Result Info bit number
-* ri_val         - Result Info bit value
-*
-* OUTPUTS:
-* sram_out       - SRAM pseudo-physical structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_set_ri_bit(tpm_sram_all_t *sram_out, uint32_t ri_bit, uint32_t ri_val)
-{
-	/*TODO - check data */
-	if (ri_bit < 16) {
-		sram_out->res_info_15_0_data |= (ri_val << ri_bit);
-		sram_out->res_info_15_0_mask |= (1 << ri_bit);
-	} else {
-		sram_out->res_info_23_16_data |= (ri_val << (ri_bit - 16));
-		sram_out->res_info_23_16_mask |= (1 << (ri_bit - 16));
-	}
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_set_l3()
-*
-* DESCRIPTION:   The function sets a single Result Info bit in the pseudo-phsical SRAM structure.
-*
-* INPUTS:
-* l3_type         - Logical L3_type
-*
-* OUTPUTS:
-* sram_out       - SRAM pseudo-physical structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_set_l3(tpm_pncl_l3_type_t l3_type, tpm_sram_all_t *sram_out)
-{
-	switch (l3_type) {
-	case TPM_PNCL_L3_OTHER:
-		break;
-	case TPM_PNCL_L3_IPV6:
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_L3_OFF_BIT, 1);
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l3_type(%d)\n", l3_type);
-		break;
-	case TPM_PNCL_L3_IPV4_NFRAG:
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l3_type(%d)\n", l3_type);
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_L3_OFF_BIT, 1);
-		tpm_pncl_set_ri_bit(sram_out, (TPM_PNC_RI_L3_OFF_BIT + 1), 1);
-		break;
-	case TPM_PNCL_L3_IPV4_FRAG:
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l3_type(%d)\n", l3_type);
-		tpm_pncl_set_ri_bit(sram_out, (TPM_PNC_RI_L3_OFF_BIT + 1), 1);
-		break;
-	case TPM_PNCL_L3_IPV4_FFRAG:
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l3_type(%d)\n", l3_type);
-		tpm_pncl_set_ri_bit(sram_out, (TPM_PNC_RI_L3_OFF_BIT + 1), 1);
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_L3_FF_BIT, 1);
-		break;
-	default:
-		return(TPM_FAIL);
-	}
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_set_l4()
-*
-* DESCRIPTION:   The function sets a single Result Info bit in the pseudo-phsical SRAM structure.
-*
-* INPUTS:
-* l4_type         - Logical L4_type
-*
-* OUTPUTS:
-* sram_out       - SRAM pseudo-physical structure
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_set_l4(tpm_pncl_l4_type_t l4_type, tpm_sram_all_t *sram_out)
-{
-	switch (l4_type) {
-	case TPM_PNCL_L4_OTHER:
-		tpm_pncl_set_ri_bit(sram_out, (TPM_PNC_RI_L4_OFF_BIT + 1), 1);
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l4_type(%d)\n", l4_type);
-		break;
-	case TPM_PNCL_L4_TCP:
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l4_type(%d)\n", l4_type);
-		break;
-	case TPM_PNCL_L4_UDP:
-		tpm_pncl_set_ri_bit(sram_out, TPM_PNC_RI_L4_OFF_BIT, 1);
-		TPM_OS_DEBUG(TPM_PNCL_MOD, "l4_type(%d)\n", l4_type);
-		break;
-	default:
-		TPM_OS_ERROR(TPM_PNCL_MOD, "l4_type(%d)\n", l4_type);
-		return(TPM_FAIL);
-	}
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_update_sram()
-*
-* DESCRIPTION:   The function sets a PNC Entry.
-*                It maps TCAM/SRAM logical to physical structures and updates HW and PNC Shadow Tables.
-* INPUTS:
-* pnc_entry      - Pnc Entry number (0-511)
-* pnc_data       - PNC pseudo-physical data (TCAM+SRAM)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_update_sram(uint32_t pnc_entry, tpm_pncl_pnc_full_t *pnc_data)
-{
-	tpm_pnc_all_t pnc_out;
-	int32_t ret_code;
-
-	memset(&pnc_out, 0, sizeof(tpm_pnc_all_t));
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "pnc_entry(%d)\n", pnc_entry);
-	TPM_OS_COND_DEBUG(TPM_PNCL_MOD) {
-		tpm_pncl_print_pncl(pnc_data);
-	}
-
-	/* TODO : check pnc_entry value */
-	/* TODO : check pointer */
-
-	/* TCAM Translate */
-	ret_code = tpm_pncl_tcam_map(&(pnc_data->pncl_tcam), &(pnc_out.tcam_entry));
-	IF_ERROR(ret_code);
-
-	/* SRAM  Translate */
-	ret_code = tpm_pncl_sram_map(&(pnc_data->pncl_sram), &(pnc_out.sram_entry), &(pnc_data->pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* TODO: validate */
-
-	/* Call HW */
-	tpm_pnc_set(pnc_entry, 1 /*sram_update */ , &pnc_out);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(pnc_entry, &pnc_out);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_entry_set()
-*
-* DESCRIPTION:   The function sets a PNC Entry.
-*                It maps TCAM/SRAM logical to physical structures and updates HW and PNC Shadow Tables.
-* INPUTS:
-* pnc_entry      - Pnc Entry number (0-511)
-* pnc_data       - PNC pseudo-physical data (TCAM+SRAM)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_entry_set(uint32_t pnc_entry, tpm_pncl_pnc_full_t *pnc_data)
-{
-	tpm_pnc_all_t pnc_out;
-	int32_t ret_code;
-	memset(&pnc_out, 0, sizeof(tpm_pnc_all_t));
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "pnc_entry(%d)\n", pnc_entry);
-	TPM_OS_COND_DEBUG(TPM_PNCL_MOD) {
-		tpm_pncl_print_pncl(pnc_data);
-	}
-
-	/* TODO : check pnc_entry value */
-	/* TODO : check pointer */
-
-	/* TCAM Translate */
-	ret_code = tpm_pncl_tcam_map(&(pnc_data->pncl_tcam), &(pnc_out.tcam_entry));
-	IF_ERROR(ret_code);
-
-	/* SRAM  Translate */
-	ret_code = tpm_pncl_sram_map(&(pnc_data->pncl_sram), &(pnc_out.sram_entry), &(pnc_data->pncl_tcam));
-	IF_ERROR(ret_code);
-
-	/* TODO: validate */
-
-	/* Call HW */
-	tpm_pnc_set(pnc_entry, 0 /*sram_update */ , &pnc_out);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(pnc_entry, &pnc_out);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_entry_insert()
-*
-* DESCRIPTION:   The function inserts a PNC Entry.
-*                It inserts an empty entry into a range and then sets the entry.
-* INPUTS:
-* pnc_ins_entry  - Pnc Entry first entry to "move down", also the entry to set
-* pnc_stop_entry - Pnc last entry to "move"down"
-* pnc_data       - PNC pseudo-physical data (TCAM+SRAM)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_entry_insert(uint32_t pnc_ins_entry, uint32_t pnc_stop_entry, tpm_pncl_pnc_full_t *pnc_data)
-{
-
-	int32_t ret_code;
-
-	/* TODO : check pnc_entry value */
-	/* TODO : check pointer */
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "pnc_ins_entry(%d) pnc_stop_entry(%d)\n", pnc_ins_entry, pnc_stop_entry);
-
-	/* Insert empty entry in HW */
-	tpm_pnc_entry_insert(pnc_ins_entry, pnc_stop_entry);
-
-	/* Update PNC Shadow  */
-	ret_code = tpm_db_pnc_shdw_ent_ins(pnc_ins_entry, pnc_stop_entry);
-	IF_ERROR(ret_code);
-
-	/* Set new PNC entry */
-	ret_code = tpm_pncl_entry_set(pnc_ins_entry, pnc_data);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_entry_reset()
-*
-* DESCRIPTION:   The function resets a PNC Entry.
-*                It updates HW and PNC Shadow Tables.
-* INPUTS:
-* pnc_entry      - Pnc Entry number (0-511)
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_entry_reset(uint32_t pnc_entry)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "pnc_entry(%d)\n", pnc_entry);
-
-	/* TODO : check pnc_entry value */
-
-	/* Call HW */
-	ret_code = tpm_pnc_entry_inv(pnc_entry);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_inv(pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_entry_delete()
-*
-* DESCRIPTION:   The function deletes a PNC Entry. It "pushes up" a range of PNC entries
-*                following the entry to be deleted. It updates HW and PNC Shadow Tables.
-* INPUTS:
-* pnc_del_entry  - Pnc Entry to delete, the following entry is the frist entry to "push Up"
-* pnc_stop_entry - Pnc last entry to "push Up"
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_entry_delete(uint32_t pnc_del_entry, uint32_t pnc_stop_entry)
-{
-	int32_t ret_code;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "pnc_del_entry(%d) pnc_stop_entry(%d)\n", pnc_del_entry, pnc_stop_entry);
-
-	if ((pnc_del_entry > pnc_stop_entry) || (pnc_stop_entry > TPM_PNC_SIZE))
-		TPM_OS_ERROR(TPM_PNCL_MOD, "pnc_del_entry(%d) pnc_stop_entry(%d)\n", pnc_del_entry, pnc_stop_entry);
-
-	/* Call HW */
-	ret_code = tpm_pnc_entry_delete(pnc_del_entry, pnc_stop_entry);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_del(pnc_del_entry, pnc_stop_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_pkt_trap()
-*
-* DESCRIPTION:   The function sets an entry to "CPU trap"
-*                The function purpose is to catch  packets that for unknown reason have not been caught
-*                by previous rules in a lookup_id
-*
-* INPUTS:
-* entry          - Pnc Entry number
-* lu_id          - lu_id to set in TCAM. The function only traps packets with  this lu_id
-* gmac_bm        - gmac bitmap to set in TCAM port_id field. The function only traps packets from GMACs in the bitmap.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_pkt_trap(uint32_t entry, uint32_t lu_id, tpm_gmac_bm_t gmac_bm)
-{
-	uint32_t ret_code;
-
-	tpm_pnc_all_t pnc_entry;
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " pnc_entry(%d) lu_id(%d) gmac_bm(%x)\n", entry, lu_id, gmac_bm);
-
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = 1;
-
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = lu_id;
-
-	/* Set port_ids */
-	pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-	/* Set high FlowId to Pnc Entry, as indication to CPU, which PnC entry performed a trap */
-	pnc_entry.sram_entry.flowid_val = (entry << TPM_PKT_TRAP_FL_SHIFT);
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_PKT_TRAP_UPDT_MASK;
-
-	/* Set Target to CPU */
-	pnc_entry.sram_entry.flowid_val |= (TPM_PNC_TRG_CPU << TPM_TXP_FL_SHIFT);
-	pnc_entry.sram_entry.flowid_updt_mask |= TPM_TXP_FL_UPDT_MASK;
-
-	/* Set Result Info Ind. to CPU */
-	tpm_pncl_set_ri_bit(&(pnc_entry.sram_entry), TPM_PNC_RI_TRAP_BIT, 1);
-
-	/* If debug, then print entry */
-	TPM_OS_COND_DEBUG(TPM_PNCL_MOD) {
-		tpm_pnc_print_sw_entry(&pnc_entry);
-	}
-	/* Write to PNC */
-	tpm_pnc_set(entry, 0, &pnc_entry);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_pkt_drop()
-*
-* DESCRIPTION:   The function sets an entry to drop. It sets only lu_id, port_id in TCAM, empty
-*                and leaves the packet part (24 bytes). The function purpose is to drop packets t
-*                hat for unknown reason have not been caught by previous rules in a lookup_id
-*
-* INPUTS:
-* entry          - Pnc Entry number
-* lu_id          - lookup_id to set in TCAM. The function only drops packets with this lu_id
-* gmac_bm        - gmac bitmap to set in TCAM port_id field. The function only drops packets from GMACs in the bitmap.
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_pkt_drop(uint32_t entry, uint32_t lu_id, tpm_gmac_bm_t gmac_bm)
-{
-	uint32_t ret_code;
-	tpm_pnc_all_t pnc_entry;
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, " pnc_entry(%d) lu_id(%d) gmac_bm(%x)\n", entry, lu_id, gmac_bm);
-
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = lu_id;
-
-	/* Set port_ids */
-	pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = 1;
-
-	/* Set Discard */
-	tpm_pncl_set_ri_bit(&(pnc_entry.sram_entry), TPM_PNC_RI_DISC_BIT, 1);
-
-	/* Write to PNC */
-	tpm_pnc_set(entry, 0, &pnc_entry);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_init_ipv6_last_entry(uint32_t entry, uint32_t lu_id, uint32_t next_lu_id)
-{
-	uint32_t ret_code;
-	tpm_pnc_all_t pnc_entry;
-	tpm_gmac_bm_t l_gmac_bm;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "entry(%d) lu_id(%d), next_lu_id(%d)\n", entry, lu_id, next_lu_id);
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = lu_id;
-
-	/* Set port_ids, both dir */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN, &l_gmac_bm);
-	pnc_entry.tcam_entry.port_ids |= l_gmac_bm;
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &l_gmac_bm);
-	pnc_entry.tcam_entry.port_ids |= l_gmac_bm;
-
-	/* Set LU Done */
-	pnc_entry.sram_entry.next_lu_id = next_lu_id;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry, 0, &pnc_entry);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_ipv6_shift2dip(tpm_sram_all_t *sram_entry)
-{
-	/*TODO  check pointer */
-
-	/* in ipv6, use the 3rd shift offset table for now, need further discussion.
-	 * it is like in excel column "shift update" says "[2] = 24",
-	 * "Nxt LU offset Ind" says " 2 ".
-	 */
-	sram_entry->next_lu_off_reg = 2;
-	sram_entry->shift_updt_reg = 2;
-	sram_entry->shift_updt_val = 24;
-
-	return TPM_OK;
-}
-
-int32_t tpm_pncl_init_ipv4_mc_range(void)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_pnc_all_t pnc_entry;
-	tpm_gmac_bm_t l_gmac_bm;
-	tpm_mc_filter_mode_t filter_mode;
-	uint32_t cpu_rx_queue;
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV4_MC_DS, &range_conf);
-	IF_ERROR(ret_code);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_conf.base_lu_id;
-
-	/* Set port_ids, both dir */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN_OR_LAN, &l_gmac_bm);
-	pnc_entry.tcam_entry.port_ids |= l_gmac_bm;
-
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = 1;
-
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-	if (TPM_MC_ALL_CPU_FRWD == filter_mode)
-		pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_CPU << TPM_TXP_FL_SHIFT);
-	else if (TPM_MC_MAC_ONLY_FILTER == filter_mode) {
-		pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_GMAC0 << TPM_TXP_FL_SHIFT);
-		pnc_entry.sram_entry.pnc_queue = 1;
-
-		tpm_pncl_set_ri_bit(&pnc_entry.sram_entry, TPM_PNC_RI_MH_BIT_14, 1);
-		tpm_pncl_set_ri_bit(&pnc_entry.sram_entry, TPM_PNC_RI_MH_BIT_15, 1);
-		tpm_pncl_set_ri_bit(&pnc_entry.sram_entry, TPM_PNC_RI_MH_BIT_16, 1);
-		tpm_pncl_set_ri_bit(&pnc_entry.sram_entry, TPM_PNC_RI_MH_BIT_17, 1);
-	} else
-		/* Set Discard */
-		tpm_pncl_set_ri_bit(&(pnc_entry.sram_entry), TPM_PNC_RI_DISC_BIT, 1);
-
-	/* the first byte of DIP is 224 to 239, high 3 bits are 1s */
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[16] = 0xE0;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[16] = 0xE0;
-
-	/* Write to PNC */
-	tpm_pnc_set(range_conf.range_end, 0, &pnc_entry);
-
-	/* fix bug for IPv4MC - default last entry in range is DISCARDING all MC
-	   - but num of free entries / api_end - is not decremented */
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_IPV4_MC_DS);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(range_conf.range_end, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pncl_init_ipv4_ranges()
-*
-* DESCRIPTION:  Functions resets a IPv4 PnC range, in HW and in DB.
-*
-*
-* INPUTS:
-* range_id       - range_id number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_init_ipv4_ranges(tpm_pnc_ranges_t range_id)
-{
-	int32_t ret_code = TPM_OK;
-
-	if (range_id == TPM_PNC_IPV4_MC_DS)
-		ret_code = tpm_pncl_init_ipv4_mc_range();
-
-	/* No other cases yet */
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_pncl_init_ipv6_mc_range()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_pncl_init_ipv6_mc_range(void)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_pnc_all_t pnc_entry;
-	tpm_gmac_bm_t l_gmac_bm;
-
-	/*
-		In TPM_PNC_IPV6_MC, add a default PNC entry at the end
-		to discard all the DS un-match IPv6 MC packets
-	*/
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_IPV6_MC_DS, &range_conf);
-	IF_ERROR(ret_code);
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_conf.base_lu_id;
-
-	/* Set port_ids, both dir */
-	tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_WAN_OR_LAN, &l_gmac_bm);
-	pnc_entry.tcam_entry.port_ids |= l_gmac_bm;
-
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = 1;
-
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-
-	tpm_pncl_set_ri_bit(&(pnc_entry.sram_entry), TPM_PNC_RI_DISC_BIT, 1);
-
-	/* the first byte of DIP is 0xff */
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[0] = 0xff;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[0] = 0xff;
-
-	/* Write to PNC */
-	tpm_pnc_set(range_conf.range_end, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_IPV6_MC_DS);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(range_conf.range_end, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pncl_init_ipv6_ranges()
-*
-* DESCRIPTION:  Functions resets a IPv4 PnC range, in HW and in DB.
-*
-*
-* INPUTS:
-* range_id       - range_id number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_init_ipv6_ranges(tpm_pnc_ranges_t range_id)
-{
-	int32_t ret_code = TPM_OK;
-
-	if (range_id == TPM_PNC_IPV6_MC_DS)
-		ret_code = tpm_pncl_init_ipv6_mc_range();
-
-	/* No other cases yet */
-	return ret_code;
-}
-
-
-int32_t tpm_pncl_init_cnm_ipv4_pre_range(void)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_pnc_all_t pnc_entry;
-	uint32_t entry_id;
-	tpm_gmac_bm_t gmac_bm;
-
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	/* Set Structs to zero */
-	memset(&range_conf, 0, sizeof(tpm_db_pnc_range_conf_t));
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	/* default rule:
-	 *	create default PNC rules in CnM_IPv4_Pre, go to CnM_MAIN
-	 */
-	if (ctc_cm_enable != TPM_CTC_CM_DISABLED) {
-		/* Get DB Info, check PnC config */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_IPV4_PRE, &range_conf);
-		IF_ERROR(ret_code);
-
-		entry_id = range_conf.range_end;
-
-		/* Set Lookup Id */
-		pnc_entry.tcam_entry.lu_id = range_conf.base_lu_id;
-
-		/* Set port_ids, both dir */
-		ret_code = tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &gmac_bm);
-		IF_ERROR(ret_code);
-		pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-		/* Get DB Info, check PnC config */
-		ret_code = tpm_db_pnc_rng_conf_get(TPM_PNC_CNM_MAIN, &range_conf);
-		IF_ERROR(ret_code);
-
-		/* Set Next LUID  */
-		pnc_entry.sram_entry.next_lu_id = range_conf.base_lu_id + TPM_CNM_L2_MAIN_LUID_OFFSET;
-		pnc_entry.sram_entry.next_lu_off_reg = TPM_PNC_CNM_L2_REG;
-
-		pnc_entry.sram_entry.add_info_data &= ~TPM_AI_CNM_IPV4_PRE_KEY_MASK;
-		pnc_entry.sram_entry.add_info_mask = TPM_AI_CNM_IPV4_PRE_KEY_MASK;
-
-		pnc_entry.sram_entry.pnc_queue = 0xFFFF;
-		pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-		/* Write to PNC */
-		tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-		ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_IPV4_PRE);
-		IF_ERROR(ret_code);
-
-		/* Write to Shadow */
-		ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-		IF_ERROR(ret_code);
-	}
-
-	return(TPM_OK);
-}
-int32_t tpm_pncl_init_cnm_main_ety_ipv6(uint32_t entry_id, tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_all_t pnc_entry;
-	tpm_gmac_bm_t gmac_bm;
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	/* Set Structs to zero */
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_CNM_MAIN, &range_data);
-	IF_ERROR(ret_code);
-
-	/* Set port_ids, US dir */
-	ret_code = tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &gmac_bm);
-	IF_ERROR(ret_code);
-	pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_ETY_MAIN_LUID_OFFSET;
-
-	/* Set Next LUID  */
-	pnc_entry.sram_entry.next_lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_IPV6_MAIN_LUID_OFFSET;
-
-	pnc_entry.sram_entry.pnc_queue = 0xFFFF;
-
-	/* depends on ipv6 CnM parse window */
-	if(TPM_CTC_CM_IPv6_FIRST_24B == ctc_cm_ipv6_parse_win) {
-		pnc_entry.sram_entry.next_lu_off_reg = TPM_PNC_LU_REG0;
-		pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-	} else {
-		pnc_entry.sram_entry.next_lu_off_reg = TPM_PNC_IPV6_DIP_REG;
-		pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_IPV6_DIP_REG;
-		pnc_entry.sram_entry.shift_updt_val = 26;
-	}
-
-	/* ETY = 0x86dd */
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[0] = 0x86;
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[1] = 0xDD;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[0] = 0xFF;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[1] = 0xFF;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return TPM_OK;
-}
-
-int32_t tpm_pncl_init_cnm_main_range(void)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_all_t pnc_entry;
-	uint32_t free_entry = 0, entry_id;
-	tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win;
-	tpm_gmac_bm_t gmac_bm;
-
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-
-	/* Set Structs to zero */
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-
-	tpm_db_ctc_cm_enable_get(&ctc_cm_enable);
-
-	if (ctc_cm_enable == TPM_CTC_CM_DISABLED)
-		return TPM_OK;
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_CNM_MAIN, &range_data);
-	IF_ERROR(ret_code);
-
-	free_entry = range_data.pnc_range_oper.free_entries;
-	entry_id = range_data.pnc_range_conf.range_end;
-
-	/* default rule #1:
-	 *	create three default PNC rules in CnM_MAIN, CnM_IPv4 DONE
-	 */
-
-	if (free_entry == 0) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No free entries\n");
-		return(TPM_FAIL);
-	}
-
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_IPV4_MAIN_LUID_OFFSET;
-	/* Set port_ids, US dir */
-	ret_code = tpm_proc_src_port_gmac_bm_map(TPM_SRC_PORT_UNI_ANY, &gmac_bm);
-	IF_ERROR(ret_code);
-	pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-	/* Set Next LUID  */
-	pnc_entry.sram_entry.lookup_done = TPM_TRUE;
-
-	pnc_entry.sram_entry.pnc_queue = 0xFFFF;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	free_entry--;
-	entry_id--;
-
-	/* default rule #2:
-	 *	create three default PNC rules in CnM_MAIN, CnM_IPv6 DONE
-	 */
-	if (free_entry == 0) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No free entries\n");
-		return(TPM_FAIL);
-	}
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_IPV6_MAIN_LUID_OFFSET;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	free_entry--;
-	entry_id--;
-
-	/* default rule #3:
-	 *	create default PNC rules in CnM_MAIN, CnM_ETY L2 done
-	 */
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_ETY_MAIN_LUID_OFFSET;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	free_entry--;
-	entry_id--;
-
-	/* default rule #4:
-	 *	create default PNC rules in CnM_MAIN, CnM_ETY IPv4 goto CnM_IPv4
-	 */
-
-	pnc_entry.sram_entry.lookup_done = TPM_FALSE;
-
-	/* Set Next LUID  */
-	pnc_entry.sram_entry.next_lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_IPV4_MAIN_LUID_OFFSET;
-	pnc_entry.sram_entry.next_lu_off_reg = TPM_PNC_LU_REG0;
-
-	pnc_entry.sram_entry.pnc_queue = 0xFFFF;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* ETY = 0x0800 */
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[0] = 0x08;
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[1] = 0x00;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[0] = 0xFF;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[1] = 0xFF;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	free_entry--;
-	entry_id--;
-	/* default rule #5:
-	 *	create default PNC rules in CnM_MAIN, CnM_ETY IPv6 goto CnM_IPv6
-	 */
-	tpm_db_ctc_cm_ipv6_parse_win_get(&ctc_cm_ipv6_parse_win);
-	ret_code = tpm_pncl_init_cnm_main_ety_ipv6(entry_id, ctc_cm_ipv6_parse_win);
-	IF_ERROR(ret_code);
-
-	/* record ipv6_ety_rule_num */
-	tpm_db_ctc_cm_ipv6_ety_rule_num_set(entry_id);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	free_entry--;
-	entry_id--;
-
-	/* default rule #6:
-	 *	create default PNC rules in CnM_MAIN, CnM_l2 go to CnM_ETY
-	 */
-
-	if (free_entry == 0) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No free entries\n");
-		return(TPM_FAIL);
-	}
-
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_L2_MAIN_LUID_OFFSET;
-
-	/* Set port_ids, US dir */
-	pnc_entry.tcam_entry.port_ids = gmac_bm;
-
-	/* Set Next LUID  */
-	pnc_entry.sram_entry.next_lu_id = range_data.pnc_range_conf.base_lu_id + TPM_CNM_ETY_MAIN_LUID_OFFSET;
-	pnc_entry.sram_entry.next_lu_off_reg = TPM_PNC_ETY_REG;
-
-	pnc_entry.sram_entry.add_info_data = TPM_AI_CNM_PREC_MASK;
-	pnc_entry.sram_entry.add_info_mask = TPM_AI_CNM_PREC_MASK;
-
-	pnc_entry.sram_entry.pnc_queue = 0xFFFF;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_CNM_MAIN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-int32_t tpm_pncl_init_cnm_ranges(tpm_pnc_ranges_t range_id)
-{
-	int32_t ret_code = TPM_OK;
-
-	if (range_id == TPM_PNC_CNM_IPV4_PRE)
-		ret_code = tpm_pncl_init_cnm_ipv4_pre_range();
-	else if (range_id == TPM_PNC_CNM_MAIN)
-		ret_code = tpm_pncl_init_cnm_main_range();
-
-	/* No other cases yet */
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_pncl_init_mac_learn_range()
-*
-* DESCRIPTION:  Functions init MAC learn range default rule
-*
-*
-* INPUTS:
-* range_id       - range_id number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_init_mac_learn_range(void)
-{
-	int32_t ret_code = TPM_OK;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_all_t pnc_entry;
-	uint32_t free_entry = 0, entry_id;
-	uint32_t queue_id;
-	tpm_gmacs_enum_t lpk_gmac;
-	int32_t cpu_rx_queue;
-
-	/* Set Structs to zero */
-	memset(&range_data, 0, sizeof(tpm_db_pnc_range_t));
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-
-	/* check gmac1 loopback en */
-	if (!tpm_db_gmac1_lpbk_en_get())
-		return(TPM_OK);
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_get(TPM_PNC_MAC_LEARN, &range_data);
-	IF_ERROR(ret_code);
-
-	free_entry = range_data.pnc_range_oper.free_entries;
-	/* check the free size in the range for default rule*/
-	if (free_entry < 2) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "No enough entries(%d) for MAC learn default rules\n",
-			     free_entry);
-		return(TPM_FAIL);
-	}
-
-	/* construct default rule on GMAC0 forward packet to GMAC1*/
-	entry_id = range_data.pnc_range_conf.range_end;
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id;
-	/* Set port_id */
-	pnc_entry.tcam_entry.port_ids = TPM_BM_GMAC_0;
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = TPM_TRUE;
-
-	pnc_entry.sram_entry.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-
-	/*forward packet to GMAC1 as default*/
-	if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-						   &queue_id,
-						   TPM_GMAC1_QUEUE_DATA_TRAFFIC)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "loopback gmac queue get failed \n");
-		return TPM_FAIL;
-	}
-	/* Set target GMAC1, queue id changed to cpu_rate_limit queue*/
-	pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_GMAC1 << TPM_TXP_FL_SHIFT);
-	pnc_entry.sram_entry.pnc_queue = queue_id;
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_MAC_LEARN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	/*CPU rate limit*/
-	memset(&pnc_entry, 0, sizeof(tpm_pnc_all_t));
-	entry_id = range_data.pnc_range_conf.range_end - 1;
-	/* Set Lookup Id */
-	pnc_entry.tcam_entry.lu_id = range_data.pnc_range_conf.base_lu_id;
-	/* Set port_id */
-	pnc_entry.tcam_entry.port_ids = TPM_BM_GMAC_1;
-	/* check MH, 0xAACC indicates MAC learning packets */
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[0] = TPM_MOD2_MAC_LEARN_MH >> 8;
-	pnc_entry.tcam_entry.pkt_data.pkt_byte[1] = TPM_MOD2_MAC_LEARN_MH & 0xFF;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[0] = 0xFF;
-	pnc_entry.tcam_entry.pkt_mask.pkt_byte[1] = 0xFF;
-	/* Set LU Done */
-	pnc_entry.sram_entry.lookup_done = TPM_TRUE;
-
-	pnc_entry.sram_entry.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-	pnc_entry.sram_entry.shift_updt_reg = TPM_PNC_NOSHIFT_UPDATE_REG;
-
-	pnc_entry.sram_entry.flowid_updt_mask = TPM_TXP_FL_UPDT_MASK;
-
-	/* Get default CPU queue */
-	tpm_db_get_cpu_rx_queue(&cpu_rx_queue);
-	/* Trap to CPU */
-	pnc_entry.sram_entry.flowid_val = (TPM_PNC_TRG_CPU << TPM_TXP_FL_SHIFT);
-	pnc_entry.sram_entry.pnc_queue = cpu_rx_queue;
-	/* Set result info */
-	pnc_entry.sram_entry.res_info_15_0_data |= (1 << TPM_PNC_RI_MAC_LEARN_BIT);
-	pnc_entry.sram_entry.res_info_15_0_mask |= (1 << TPM_PNC_RI_MAC_LEARN_BIT);
-
-	/* Write to PNC */
-	tpm_pnc_set(entry_id, 0, &pnc_entry);
-
-	ret_code = tpm_db_pnc_rng_api_end_dec(TPM_PNC_MAC_LEARN);
-	IF_ERROR(ret_code);
-
-	/* Write to Shadow */
-	ret_code = tpm_db_pnc_shdw_ent_set(entry_id, &pnc_entry);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_pncl_init_mac_learn_ranges()
-*
-* DESCRIPTION:  Functions init MAC learn range
-*
-*
-* INPUTS:
-* range_id       - range_id number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_init_mac_learn_ranges(tpm_pnc_ranges_t range_id)
-{
-	int32_t ret_code = TPM_OK;
-
-	if (range_id == TPM_PNC_MAC_LEARN)
-		ret_code = tpm_pncl_init_mac_learn_range();
-
-	return ret_code;
-}
-
-/*******************************************************************************
-* tpm_pncl_range_reset()
-*
-* DESCRIPTION:  Functions resets a PnC range, in HW and in DB.
-*
-*
-* INPUTS:
-* range_id       - range_id number
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_pncl_range_reset(tpm_pnc_ranges_t range_id)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_conf_t range_conf;
-	uint32_t switch_init;
-
-	TPM_OS_DEBUG(TPM_PNCL_MOD, "range_id(%d)\n", range_id);
-
-	/* Get DB Info, check PnC config */
-	ret_code = tpm_db_pnc_rng_conf_get(range_id, &range_conf);
-	IF_ERROR(ret_code);
-
-	/* Update HW */
-	if (range_conf.range_size > 1)	/* Invalidate all entries, except last */
-		tpm_pnc_range_inv(range_conf.range_start, (range_conf.range_end - 1));
-
-	/* get switch_init */
-	ret_code = tpm_db_switch_init_get(&switch_init);
-	IF_ERROR(ret_code);
-
-	/* Handle Range's last Pnc Entry */
-	if (range_id == TPM_PNC_IPV4_MC_DS) {
-		ret_code = tpm_pncl_init_ipv4_ranges(range_id);
-		IF_ERROR(ret_code);
-	} else if (range_id == TPM_PNC_IPV6_MC_DS) {
-		ret_code = tpm_pncl_init_ipv6_ranges(range_id);
-		IF_ERROR(ret_code);
-	} else if (range_id == TPM_PNC_CNM_IPV4_PRE ||
-			   range_id == TPM_PNC_CNM_MAIN) {
-		ret_code = tpm_pncl_init_cnm_ranges(range_id);
-		IF_ERROR(ret_code);
-	} else if (range_id == TPM_PNC_MAC_LEARN) {
-		ret_code = tpm_pncl_init_mac_learn_ranges(range_id);
-		IF_ERROR(ret_code);
-	} else {
-		if (range_conf.init_last_entry == TPM_PNC_RNG_LAST_INIT_TRAP) {
-			ret_code = tpm_pncl_pkt_trap(range_conf.range_end,
-						     range_conf.base_lu_id, range_conf.last_ent_portid);
-			IF_ERROR(ret_code);
-		} else if (range_conf.init_last_entry == TPM_PNC_RNG_LAST_INIT_DROP) {
-			ret_code = tpm_pncl_pkt_drop(range_conf.range_end,
-						     range_conf.base_lu_id, range_conf.last_ent_portid);
-			IF_ERROR(ret_code);
-		} else
-			tpm_pnc_entry_inv(range_conf.range_end);
-	}
-	/* Update DB */
-	ret_code = tpm_db_pnc_rng_reset(range_id);
-	IF_ERROR(ret_code);
-
-	return(TPM_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.h
deleted file mode 100644
index 271f82f..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_pnc_logic.h
+++ /dev/null
@@ -1,350 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_pnc_logic.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.2
-*
-*******************************************************************************/
-#ifndef _TPM_PNCL_H_
-#define _TPM_PNCL_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-typedef enum {
-	TPM_PNCL_ZERO_OFFSET,	/* Offset 0 */
-	TPM_PNCL_L3_OFFSET,	/* L3 Header offset */
-	TPM_PNCL_IPV4_OFFSET,	/* IPV4 Header offset */
-	TPM_PNCL_IPV6_OFFSET,	/* IPV6 Header offset */
-	TPM_PNCL_IPV6_EXT_OFFSET,	/* IPV6 Ext Header offset */
-	TPM_PNCL_IPV6_DIP_OFFSET,	/* IPV6 DIP offset */
-	TPM_PNCL_TCP_OFFSET,	/* TCP Header offset */
-	TPM_PNCL_L4_OFFSET	/* UDP/TCP Header offset, used for L4 ports only */
-} tpm_pncl_offset_base_t;
-
-typedef enum {
-	TPM_PNCL_L3_OTHER,
-	TPM_PNCL_L3_IPV6,
-	TPM_PNCL_L3_IPV4_FRAG,
-	TPM_PNCL_L3_IPV4_FFRAG,
-	TPM_PNCL_L3_IPV4_NFRAG
-} tpm_pncl_l3_type_t;
-
-typedef enum {
-	TPM_PNCL_L4_OTHER,
-	TPM_PNCL_L4_TCP,
-	TPM_PNCL_L4_UDP,
-	TPM_PNCL_L4_IGMP,
-	TPM_PNCL_L4_ICMP
-} tpm_pncl_l4_type_t;
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-
-#define     TPM_PNCL_NO_QUEUE_UPDATE        0xFFFF
-
-/* SRAM Update sub-fields update mask */
-#define     TPM_PNCL_SET_GEM             0x1
-#define     TPM_PNCL_SET_TXP             0x2
-#define     TPM_PNCL_SET_MOD             0x4
-#define     TPM_PNCL_SET_DISC            0x8
-#define     TPM_PNCL_SET_RX_SPECIAL      0x10
-#define     TPM_PNCL_SET_LUD             0x20
-#define     TPM_PNCL_SET_L3              0x40
-#define     TPM_PNCL_SET_L4              0x80
-#define     TPM_PNCL_SET_COL             0x100
-#define     TPM_PNCL_SET_IGMP            0x200
-#define     TPM_PNCL_SET_MH_RI           0x400
-#define     TPM_PNCL_SET_BC              0x800
-#define     TPM_PNCL_SET_MC              0x1000
-#define     TPM_PNCL_SET_UC              0x2000
-#define     TPM_PNCL_SET_PPPOE           0x4000
-#define     TPM_PNCL_SET_TAGGED          0x8000
-#define     TPM_PNCL_SET_SPLIT_MOD       0x10000
-
-typedef uint32_t tpm_pncl_sram_updt_bm_t;
-
-#define     TPM_MH_RI_BIT14       0x00004000
-#define     TPM_MH_RI_BIT15       0x00008000
-#define     TPM_MH_RI_BIT16       0x00010000
-#define     TPM_MH_RI_BIT17       0x00020000
-#define     TPM_MH_RI_OFFSET      14
-
-/* TPM flowid shift values */
-#define     TPM_GEM_FL_SHIFT            (12)
-#define     TPM_TXP_FL_SHIFT            (24)
-#define     TPM_MOD_FL_SHIFT            (00)
-#define     TPM_PKT_TRAP_FL_SHIFT       (00)
-
-/* TPM flowid update values */
-#define     TPM_FLOW_NIB_0              (0x01)
-#define     TPM_FLOW_NIB_1              (0x02)
-#define     TPM_FLOW_NIB_2              (0x04)
-#define     TPM_FLOW_NIB_3              (0x08)
-#define     TPM_FLOW_NIB_4              (0x10)
-#define     TPM_FLOW_NIB_5              (0x20)
-#define     TPM_FLOW_NIB_6              (0x40)
-#define     TPM_FLOW_NIB_7              (0x80)
-
-#define     TPM_TXP_FL_UPDT_MASK        (TPM_FLOW_NIB_6)
-#define     TPM_GEM_FL_UPDT_MASK        (TPM_FLOW_NIB_5|TPM_FLOW_NIB_4|TPM_FLOW_NIB_3)
-#define     TPM_MOD_FL_UPDT_MASK        (TPM_FLOW_NIB_2|TPM_FLOW_NIB_1|TPM_FLOW_NIB_0)
-#define     TPM_PKT_TRAP_UPDT_MASK      (TPM_FLOW_NIB_3|TPM_FLOW_NIB_2|TPM_FLOW_NIB_1|TPM_FLOW_NIB_0)
-#define     TPM_MOD_FL_SPLIT_MOD_UPDT_MASK        (TPM_FLOW_NIB_0)
-
-/* PNC - Parse fields - bitmap ****************/
-/* These bitmap values are internal, they are complimentary to the values in tpm_types.h
- * must have different values */
-#define                 TPM_L2_PARSE_MH                 (0x8000)
-#define                 TPM_L2_PARSE_PPPOE_CTRL         (0x4000)
-#define                 TPM_L2_PARSE_PPPOE_HDR		(TPM_L2_PARSE_PPPOE_CTRL | \
-								TPM_L2_PARSE_PPPOE_SES | TPM_L2_PARSE_PPP_PROT)
-#define                 TPM_PNCL_ONE_TWO_VLAN_TAG       (TPM_L2_PARSE_ONE_VLAN_TAG|TPM_L2_PARSE_TWO_VLAN_TAG)
-
-/* These bitmap values are internal, they are complimentary to the values in tpm_types.h
- * MUST!! have different values, than the values there */
-#define                 TPM_IPv4_PARSE_VER               (0x8000)	/* parse IPv4 Version */
-#define                 TPM_IPv4_PARSE_IHL               (0x4000)	/* parse IPv4 IHL */
-#define                 TPM_IPv4_PARSE_VER_OR_IHL        (TPM_IPv4_PARSE_VER|TPM_IPv4_PARSE_IHL)
-#define                 TPM_IPv4_PARSE_TOTLEN            (0x2000)	/* parse IPv4 Total Len */
-#define                 TPM_IPv4_PARSE_IDENT             (0x1000)	/* parse IPv4  Identification field */
-#define                 TPM_IPv4_PARSE_FLAG_MF           (0x0800)	/* parse IPv4  MF Flag */
-#define                 TPM_IPv4_PARSE_FRAG_OFFSET       (0x0400)	/* parse IPv4  Offset */
-#define                 TPM_IPv4_PARSE_MF_OR_FRAG        (TPM_IPv4_PARSE_FLAG_MF|TPM_IPv4_PARSE_FRAG_OFFSET)
-#define                 TPM_IPv4_PARSE_TTL               (0x0200)	/* parse IPv4  TTL */
-
-#define                 TPM_TCP_PARSE_DUMMY              (0x8000)
-#define                 TPM_TCP_PARSE_FLAGS              (0x4000)
-
-/* These bitmap values are internal, they are complimentary to the values in tpm_types.h
- * must have different values, than the values there */
-#define                 TPM_IPv6_PARSE_VER               (0x10000)	/* parse IPv6 Version */
-#define                 TPM_IPv6_PARSE_VER_OR_DSCP       (TPM_IPv6_PARSE_VER|TPM_IPv6_PARSE_DSCP)
-#define 				TPM_IPv6_PARSE_FLOW              (0x20000)	/* parse IPv6 Flow Label */
-#define                 TPM_IPv6_PARSE_DSCP_OR_FLOW      (TPM_IPv6_PARSE_DSCP|TPM_IPv6_PARSE_FLOW)
-#define                 TPM_IPv6_PARSE_PLLEN             (0x40000)	/* parse IPv6 Payload Len */
-#define                 TPM_IPv6_PARSE_HOPLIM            (0x80000)	/* parse IPv6  Hop Limit */
-
-#define                 TPM_PARSE_L4_CHECKSUM       (0x10000)	/* parse L4 Checksum */
-
-#define                 TPM_PARSE_UDP_LEN           (0x20000)	/* parse UDP Len */
-
-#define                 TPM_PARSE_TCPSEQ_NUM       (0x020000)	/* parse TCP Seq num */
-#define                 TPM_PARSE_TCPACK_NUM       (0x040000)	/* parse TCP Ack num */
-#define                 TPM_PARSE_TCPOFFSET        (0x080000)	/* parse TCP Offset */
-#define                 TPM_PARSE_TCPFLAGS         (0x100000)	/* parse TCP Flags */
-#define                 TPM_PARSE_TCPWIN           (0x200000)	/* parse TCP window */
-#define                 TPM_PARSE_TCPURGTPTR       (0x400000)	/* parse TCP urgent pointer */
-
-#define                 TPM_IPv6_PARSE_ICMP_TYPE         (0x20000)	/* parse IPv6 ICMP Type */
-#define                 TPM_IPv6_PARSE_ICMP_CODE         (0x40000)	/* parse IPv6 ICMP Code */
-
-typedef uint32_t tpm_pncl_parse_bm_t;
-
-#define                 TPM_PNC_RI_DISC_BIT             (0)
-#define                 TPM_PNC_RI_L4_OFF_BIT           (1)
-#define                 TPM_PNC_RI_L3_OFF_BIT           (3)
-#define                 TPM_PNC_RI_L3_FF_BIT            (5)
-#define                 TPM_PNC_RI_MAC_LEARN_BIT        (9)/*Just for media convert MAC learning*/
-#define                 TPM_PNC_RI_MC_BIT               (10)
-#define                 TPM_PNC_RI_BC_BIT               (11)
-#define                 TPM_PNC_RI_UC_BIT               (12)
-#define                 TPM_PNC_RI_PPPOE_BIT            (13)
-#define                 TPM_PNC_RI_MH_BIT_14            (14)
-#define                 TPM_PNC_RI_MH_BIT_15            (15)
-#define                 TPM_PNC_RI_MH_BIT_16            (16)
-#define                 TPM_PNC_RI_MH_BIT_17            (17)
-/* BIT18 is used by NFP */
-#define                 TPM_PNC_RI_VLAN_BIT             (19)
-#define                 TPM_PNC_RI_RX_SPECIAL_BIT       (20)
-#define                 TPM_PNC_RI_TRAP_BIT             (21) /* Internal to TPM, driver is not aware of this */
-
-typedef struct {
-	uint32_t mh_set;
-	uint32_t mh_reg;
-} tpm_pncl_mh_reg_t;
-
-typedef struct {
-	tpm_src_port_type_t src_port;	/* Specific UNI port in MH/DSA Tag */
-	tpm_l2_acl_key_t l2_key;	/* L2 fields to parse */
-	tpm_l3_type_key_t l3_key;	/* L3 fields to parse */
-	tpm_ipv4_acl_key_t ipv4_key;	/* IPv4 fields to parse */
-	tpm_ipv4_add_key_t ipv4_add_key;	/* Additional IPv4 fields to parse, that are not exposed to the API */
-	tpm_ipv6_acl_key_t ipv6_key;	/* IPv6 fields to parse */
-	tpm_ipv6_add_key_t ipv6_add_key;	/* Additional IPv6 fields to parse, that are not exposed to the API */
-	tpm_tcp_key_t tcp_key;	/* TCP fields to parse */
-	tpm_l4_ports_key_t l4_ports_key;	/* L4 Ports to parse */
-	tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-	tpm_ipv6_addr_key_t ipv6_dip_key;
-} tpm_pncl_pkt_key_t;
-
-/* Structure indicates next logical offset.  There are few type of offset,
- * Either one of the L1/L2/L3 Header Offsets, or a specific sub-field in a header.
- * Specific sub-field
- */
-typedef struct {
-	tpm_pnc_ranges_t range_id;	/* Determine which pnc range it is working on */
-	tpm_pncl_offset_base_t offset_base;	/* Determine if one of L1/L2/L3 Header offset, or specific sub-field offset */
-	union {
-		tpm_pncl_parse_bm_t l2_subf;	/* Specific sub-field to offset to, if empty, start at offset_base */
-		tpm_pncl_parse_bm_t l3_subf;	/* Specific sub-field to offset to, if empty, start at offset_base */
-		tpm_pncl_parse_bm_t ipv4_subf;	/* Specific sub-field to offset to, if empty, start at offset_base */
-		tpm_pncl_parse_bm_t ipv6_subf;	/* Specific sub-field to offset to, if empty, start at offset_base */
-		tpm_pncl_parse_bm_t subf;	/* Easy for coding, we can use it in any case */
-		tpm_pncl_parse_bm_t tcp_subf;	/* Specific sub-field to offset to, if empty, start at offset_base */
-	} offset_sub;
-} tpm_pncl_offset_t;
-
-typedef struct {
-	uint32_t lu_id;
-	tpm_gmac_bm_t port_ids;	/* GMAC(s) relevant to this entry */
-	tpm_pncl_offset_t start_offset;	/* Single bit raised to indicate start of packet */
-	tpm_pncl_pkt_key_t pkt_key;
-	tpm_pncl_parse_bm_t l2_parse_bm;	/* L2 Parsing bitmap for TCAM entry */
-	tpm_pncl_parse_bm_t l3_parse_bm;	/* L2 Parsing bitmap for TCAM entry */
-	tpm_pncl_parse_bm_t ipv4_parse_bm;	/* IPV4 Parsing bitmap for TCAM entry */
-	tpm_pncl_parse_bm_t ipv6_parse_bm;	/* IPV6 Parsing bitmap for TCAM entry */
-	tpm_pncl_parse_bm_t tcp_parse_bm;	/* TCP Parsing bitmap for TCAM entry */
-	tpm_pncl_parse_bm_t l4_parse_bm;	/* UDP/TCP L4 ports Parsing bitmap for TCAM entry */
-	uint32_t add_info_data;
-	uint32_t add_info_mask;
-} tpm_pncl_tcam_data_t;
-
-typedef struct {
-	uint32_t gem_port;
-	uint32_t mod_cmd;
-	tpm_pnc_trg_t pnc_target;
-} tpm_pncl_flowid_t;
-
-typedef struct {
-	/* Next LU */
-	uint32_t next_lu_id;
-	uint32_t next_lu_off_reg;
-
-	/* Next Shift Offset */
-	tpm_pncl_offset_t next_offset;	/* Next Offset Sub-field */
-	uint32_t shift_updt_reg;
-	/* Queue Update */
-	uint32_t pnc_queue;	/* pnc_queue=TPM_PNCL_NO_QUEUE_UPDATE -  don't set queue */
-
-	/* Sram ResultInfo&FlowId update Bitmap */
-	tpm_pncl_sram_updt_bm_t sram_updt_bm;
-	tpm_pncl_mh_reg_t mh_reg;
-	tpm_pncl_l3_type_t l3_type;
-	tpm_pncl_l4_type_t l4_type;
-	uint32_t pkt_col;
-	/* Add Info Update */
-	uint32_t add_info_data;
-	uint32_t add_info_mask;
-	/* flowid values */
-	tpm_pncl_flowid_t flow_id_sub;
-} tpm_pncl_sram_data_t;
-
-typedef struct {
-	tpm_pncl_tcam_data_t pncl_tcam;
-	tpm_pncl_sram_data_t pncl_sram;
-} tpm_pncl_pnc_full_t;
-
-/*************************************************************/
-/*               APIs                                        */
-/*************************************************************/
-
-int32_t tpm_pncl_pkt_trap(uint32_t entry, uint32_t lu_id, tpm_gmac_bm_t gmac_bm);
-int32_t tpm_pncl_pkt_drop(uint32_t entry, uint32_t lu_id, tpm_gmac_bm_t gmac_bm);
-int32_t tpm_pncl_range_reset(tpm_pnc_ranges_t range_id);
-int32_t tpm_pncl_entry_set(uint32_t pnc_entry, tpm_pncl_pnc_full_t *pnc_data);
-int32_t tpm_pncl_entry_insert(uint32_t pnc_ins_entry, uint32_t pnc_stop_entry, tpm_pncl_pnc_full_t *pnc_data);
-int32_t tpm_pncl_update_sram(uint32_t pnc_entry, tpm_pncl_pnc_full_t *pnc_data);
-int32_t tpm_pncl_init_cnm_main_ety_ipv6(uint32_t entry_id, tpm_db_ctc_cm_ipv6_parse_win_t ctc_cm_ipv6_parse_win);
-
-int32_t tpm_pncl_entry_delete(uint32_t pnc_del_entry, uint32_t pnc_stop_entry);
-int32_t tpm_pncl_entry_reset(uint32_t pnc_entry);
-
-int32_t tpm_proc_trg_port_gmac_map(tpm_trg_port_type_t trg_port, tpm_gmacs_enum_t *gmac_port);
-
-int32_t tpm_pncl_tcam_map(tpm_pncl_tcam_data_t *tcam_in, tpm_tcam_all_t *tcam_out);
-
-int32_t tpm_pncl_sram_map(tpm_pncl_sram_data_t *sram_in, tpm_sram_all_t *sram_out, tpm_pncl_tcam_data_t *tcam_in);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _TPM_PNCL_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.c
deleted file mode 100644
index 4b53b54..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.c
+++ /dev/null
@@ -1,2534 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_print.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.3
-*
-*
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_utils.h"
-#include "dbg-trace.h"
-
-/*TODO - currently some printing funtions are directly accessing DB */
-extern tpm_db_t tpm_db;
-
-#define DWORD_LEN       32
-
-/* start offset of api_dump_ipv4_parse_bm, should be bigger than l2_parse_bm
-   right now the biggest l2_parse_bm is TPM_L2_PARSE_GEMPORT with offset 8
- */
-#define API_DUMP_IPV4_PARSE_BM_START       12
-
-/* offset of api_dump_ipv6_parse_bm, should be bigger than ipv4_parse_bm + API_DUMP_IPV4_PARSE_BM_START
-   right now the biggest ipv4_parse_bm is TPM_IPv4_PARSE_PROTO with offset 4
- */
-#define API_DUMP_IPV6_PARSE_BM_START       24
-
-#define TPM_DBVAL_CON(dbval)	((dbval == TPM_DB_VALID) ? TPM_TRUE : TPM_FALSE)
-#define DIR2STR(dir)		((dir == TPM_DIR_DS) ? "DS" : "US")
-#define IF_ERROR(ret)		\
-		if (ret != TPM_DB_OK) {\
-			TPM_OS_ERROR(TPM_CLI_MOD, "%s(%d):  recev'd error code (%d)\n", __func__, __LINE__, ret);\
-			return;\
-		}
-
-db_enum_string_t tpm_db_chip_conn_str[] = {
-	BuildEnumString(TPM_CONN_DISC),
-	BuildEnumString(TPM_CONN_QSGMII),
-	BuildEnumString(TPM_CONN_FE_PHY),
-	BuildEnumString(TPM_CONN_GE_PHY),
-	BuildEnumString(TPM_CONN_RGMII1),
-	BuildEnumString(TPM_CONN_RGMII2),
-};
-
-db_enum_string_t tpm_db_int_conn_str[] = {
-	BuildEnumString(TPM_INTCON_GMAC0),
-	BuildEnumString(TPM_INTCON_GMAC1),
-	BuildEnumString(TPM_INTCON_SWITCH),
-};
-
-db_enum_string_t tpm_db_sched_str[] = {
-	BuildEnumString(TPM_SCHED_SP),
-	BuildEnumString(TPM_SCHED_WRR),
-};
-
-db_enum_string_t tpm_db_txq_owner_str[] = {
-	BuildEnumString(TPM_Q_OWNER_CPU),
-	BuildEnumString(TPM_Q_OWNER_GMAC0),
-	BuildEnumString(TPM_Q_OWNER_GMAC1),
-	BuildEnumString(TPM_Q_OWNER_PMAC),
-};
-
-db_enum_string_t tpm_db_gmac_conn_str[] = {
-	BuildEnumString(TPM_GMAC_CON_DISC),
-	BuildEnumString(TPM_GMAC_CON_QSGMII),
-	BuildEnumString(TPM_GMAC_CON_SWITCH_4),
-	BuildEnumString(TPM_GMAC_CON_SWITCH_5),
-	BuildEnumString(TPM_GMAC_CON_SWITCH_6),
-	BuildEnumString(TPM_GMAC_CON_RGMII1),
-	BuildEnumString(TPM_GMAC_CON_RGMII2),
-	BuildEnumString(TPM_GMAC_CON_GE_PHY),
-};
-
-db_enum_string_t tpm_db_gmac_func_str[] = {
-	BuildEnumString(TPM_GMAC_FUNC_NONE),
-	BuildEnumString(TPM_GMAC_FUNC_LAN),
-	BuildEnumString(TPM_GMAC_FUNC_WAN),
-	BuildEnumString(TPM_GMAC_FUNC_LAN_AND_WAN),
-	BuildEnumString(TPM_GMAC_FUNC_VIRT_UNI),
-	BuildEnumString(TPM_GMAC_FUNC_LAN_UNI),
-	BuildEnumString(TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI),
-};
-
-db_enum_string_t tpm_pnc_ranges_str[] = {
-	BuildEnumString(TPM_PNC_MNGMT_DS),
-	BuildEnumString(TPM_PNC_MAC_LEARN),
-	BuildEnumString(TPM_PNC_CPU_WAN_LPBK_US),
-	BuildEnumString(TPM_PNC_NUM_VLAN_TAGS),
-	BuildEnumString(TPM_PNC_DS_LOAD_BALANCE),
-	BuildEnumString(TPM_PNC_VIRT_UNI),
-	BuildEnumString(TPM_PNC_MULTI_LPBK),
-	BuildEnumString(TPM_PNC_LOOP_DET_US),
-	BuildEnumString(TPM_PNC_L2_MAIN),
-	BuildEnumString(TPM_PNC_ETH_TYPE),
-	BuildEnumString(TPM_PNC_IGMP),
-	BuildEnumString(TPM_PNC_IPV4_MC_DS),
-	BuildEnumString(TPM_PNC_IPV4_MAIN),
-	BuildEnumString(TPM_PNC_IPV4_TCP_FLAG),
-	BuildEnumString(TPM_PNC_TTL),
-	BuildEnumString(TPM_PNC_IPV4_PROTO),
-	BuildEnumString(TPM_PNC_IPV4_FRAG),
-	BuildEnumString(TPM_PNC_IPV4_LEN),
-	BuildEnumString(TPM_PNC_IPV6_HOPL),
-	BuildEnumString(TPM_PNC_IPV6_GEN),
-	BuildEnumString(TPM_PNC_IPV6_MC_SIP),
-	BuildEnumString(TPM_PNC_IPV6_DIP),
-	BuildEnumString(TPM_PNC_IPV6_MC_DS),
-	BuildEnumString(TPM_PNC_IPV6_NH),
-	BuildEnumString(TPM_PNC_IPV6_L4_MC_DS),
-	BuildEnumString(TPM_PNC_IPV6_TCP_FLAG),
-	BuildEnumString(TPM_PNC_IPV6_L4),
-	BuildEnumString(TPM_PNC_CNM_IPV4_PRE),
-	BuildEnumString(TPM_PNC_CNM_MAIN),
-	BuildEnumString(TPM_PNC_CATCH_ALL),
-};
-
-db_enum_string_t tpm_api_range_type_str[] = {
-	BuildEnumString(TPM_RANGE_TYPE_ACL),
-	BuildEnumString(TPM_RANGE_TYPE_TABLE),
-};
-
-db_enum_string_t tpm_db_pnc_last_init_str[] = {
-	BuildEnumString(TPM_PNC_RNG_LAST_INIT_DEF),
-	BuildEnumString(TPM_PNC_RNG_LAST_INIT_DROP),
-	BuildEnumString(TPM_PNC_RNG_LAST_INIT_TRAP),
-};
-
-static tpm_str_map_t api_section_str[] = {
-	{TPM_L2_PRIM_ACL, "TPM_L2_PRIM_ACL"},
-	{TPM_L3_TYPE_ACL, "TPM_L3_TYPE_ACL"},
-	{TPM_IPV4_ACL, "TPM_IPV4_ACL"},
-	{TPM_IPV4_MC, "TPM_IPV4_MC"},
-	{TPM_IPV6_GEN_ACL, "TPM_IPV6_GEN_ACL"},
-	{TPM_IPV6_DIP_ACL, "TPM_IPV6_DIP_ACL"},
-	{TPM_IPV6_NH_ACL, "TPM_IPV6_NH_ACL"},
-	{TPM_L4_ACL, "TPM_L4_ACL"},
-};
-
-static tpm_str_map_t api_type_str[] = {
-	{TPM_API_MGMT, "MNGMT"},
-	{TPM_API_MAC_LEARN,       "MAC_LEARN   "},
-	{TPM_API_DS_LOAD_BALANCE, "DS_LOAD_BAL "},
-	{TPM_API_CPU_LOOPBACK,    "CPU_LOOPBACK"},
-	{TPM_API_L2_PRIM, "L2      "},
-	{TPM_API_L3_TYPE, "L3      "},
-	{TPM_API_IPV4,    "IPV4    "},
-	{TPM_API_IPV4_MC, "IPV4_MC "},
-	{TPM_API_IPV6_GEN, "IPV6_GEN"},
-	{TPM_API_IPV6_DIP, "IPV6_DIP"},
-	{TPM_API_IPV6_MC, "IPV6_MC"},
-	{TPM_API_IPV6_NH, "IPV6_NH "},
-	{TPM_API_IPV6_L4, "L4      "},
-	{TPM_API_CNM,     "CNM     "},
-};
-char *tpm_db_params_illegal_str = "??";
-
-static char buff[1024];
-static unsigned int tpm_age_first[CONFIG_MV_PNC_TCAM_LINES];
-
-/********************************************************************************/
-/*                                Print Utils                                   */
-/********************************************************************************/
-char *db_mac_to_str(uint8_t * addr, char *str)
-{
-	if ((str != NULL) && (addr != NULL)) {
-		str[0] = '\0';
-		sprintf(str, "%02x:%02x:%02x:%02x:%02x:%02x", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
-		return str;
-	}
-
-	return NULL;
-}
-
-char *db_ipv4_to_str(uint8_t * ipaddr, char *str)
-{
-	if ((str != NULL) && (ipaddr != NULL)) {
-		str[0] = '\0';
-		sprintf(str, "%u.%u.%u.%u", ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
-		return str;
-	}
-
-	return NULL;
-}
-
-char *db_ipv6_to_str(uint8_t * ipaddr, char *str)
-{
-	int i, j;
-	uint16_t addr[DB_IPV6_ADDR_LEN / 2];
-
-	if ((str != NULL) && (ipaddr != NULL)) {
-		for (i = 0, j = 0; i < DB_IPV6_ADDR_LEN; j++) {
-			addr[j] = (ipaddr[i] << 8) | ipaddr[i + 1];
-			i += 2;
-		}
-
-		str[0] = '\0';
-		sprintf(str,
-			"%x:%x:%x:%x:%x:%x:%x:%x",
-			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);
-		return str;
-	}
-
-	return NULL;
-}
-
-/*******************************************************************************
-* api_sec_to_str()
-*
-* DESCRIPTION:      Convert api section to string
-*
-* INPUTS:
-* api_section      - API Section to retrieve configuration for
-*
-* RETURNS:
-* On success, return pointer to entry in api_section_str[], on error return NULL.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-static uint8_t *api_sec_to_str(tpm_api_sections_t api_section)
-{
-	uint32_t i;
-
-	for (i = 0; i < (sizeof(api_section_str) / sizeof(tpm_str_map_t)); i++) {
-		if (api_section_str[i].enum_in == api_section)
-			return (&(api_section_str[i].str_out[0]));
-	}
-	return (NULL);
-}
-
-/*******************************************************************************
-* api_type_to_str()
-*
-* DESCRIPTION:      Convert api section to string
-*
-* INPUTS:
-* tpm_api_type_t    - API Type to retrieve configuration for
-*
-* RETURNS:
-* On success, return pointer to entry in api_type_str[], on error return NULL.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-uint8_t *api_type_to_str(tpm_api_type_t api_type)
-{
-	uint32_t i;
-
-	for (i = 0; i < (sizeof(api_type_str) / sizeof(tpm_str_map_t)); i++) {
-		if (api_type_str[i].enum_in == api_type)
-			return (&(api_type_str[i].str_out[0]));
-	}
-	return (tpm_db_params_illegal_str);
-}
-
-/*******************************************************************************
-* pnc_rng_to_str()
-*
-* DESCRIPTION:      Convert Pnc Range  to string
-*
-* INPUTS:
-* api_section      - API Section to retrieve configuration for
-*
-* RETURNS:
-* On success, return pointer to entry in api_section_str[], on error return NULL.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-static uint8_t *pnc_rng_to_str(tpm_pnc_ranges_t range)
-{
-	uint32_t i;
-
-	for (i = 0; i < (sizeof(tpm_pnc_ranges_str) / sizeof(db_enum_string_t)); i++) {
-		if (tpm_pnc_ranges_str[i].enumPar == range)
-			return (&(tpm_pnc_ranges_str[i].enumString[0]));
-	}
-	return (NULL);
-}
-
-/*******************************************************************************
-* tpm_print_mac_key()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* mac_key       - Print mac key
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_mac_key(tpm_mac_key_t *mac_key)
-{
-	char smac_str[DB_MAC_STR_LEN] = { '\0' };
-	char dmac_str[DB_MAC_STR_LEN] = { '\0' };
-
-	printk("=========================================\n");
-	printk("          DA                SA           \n");
-	printk("        DA mask           SA mask        \n");
-	printk("=========================================\n");
-	printk("  %s   %s\n", db_mac_to_str(mac_key->mac_da, dmac_str),
-	       db_mac_to_str(mac_key->mac_sa, smac_str));
-	printk("  %s   %s\n", db_mac_to_str(mac_key->mac_da_mask, dmac_str),
-	       db_mac_to_str(mac_key->mac_sa_mask, smac_str));
-	printk("=========================================\n");
-	return;
-}
-
-/*******************************************************************************
-* tpm_print_cpu_lpbk_entry()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*   None
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_cpu_lpbk_entry(void)
-{
-	uint16_t flow_id;
-	tpm_cpu_loopback_t *lpbk_entry = NULL;
-
-	print_horizontal_line(60);
-	printk("  Index  trg_port  trg_queue  gem_port  rule_idx  mod_idx \n");
-	print_horizontal_line(60);
-
-	for (flow_id = 0; flow_id < TPM_MAX_CPU_LOOPBACK_NUM; flow_id++) {
-		lpbk_entry = tpm_proc_get_loopback_entry(flow_id);
-
-		if ((lpbk_entry != NULL) && (lpbk_entry->in_use == TPM_TRUE)) {
-			printk("  %4.4d   0x%4.4x    %1.1d          %4.4d      %4.4d      %4.4d \n",
-			       flow_id, lpbk_entry->trg_port, lpbk_entry->trg_queue,
-			       lpbk_entry->gem_port, lpbk_entry->rule_idx, lpbk_entry->mod_idx);
-		}
-
-	}
-
-	print_horizontal_line(60);
-}
-
-/*******************************************************************************
-* tpm_print_tcam_lu_entry()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*   None
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_tcam_lu_entry(uint32_t owner_id, uint32_t api_group, uint32_t lu_num, uint32_t lu_reset)
-{
-	uint16_t rule_num;
-	tpm_error_code_t ret_code;
-	uint16_t valid_num;
-	tpm_api_entry_count_t count_array[TPM_MAX_LU_ENTRY_NUM];
-	uint16_t unrelated_num;
-
-	ret_code = tpm_get_pnc_lu_entry(owner_id, api_group, (uint16_t) lu_num, lu_reset, &valid_num,
-					count_array, &unrelated_num);
-
-	if (ret_code != TPM_RC_OK) {
-		printk(KERN_ERR "Failed to call tpm_count_get_pnc_lu_entry, ret_code[%d] \n", ret_code);
-		return;
-	}
-
-	printk("\n");
-	print_horizontal_line(60);
-	printk("  Input owner_id[%d], api_group[%d], lu_num[%d] lu_reset[%d]\n",
-	       owner_id, api_group, lu_num, lu_reset);
-	printk("  output valid_num[%d], unrelated_num[%d]\n", valid_num, unrelated_num);
-	print_horizontal_line(60);
-	printk("  Index    rule_idx    hit_counter \n");
-	print_horizontal_line(60);
-
-	for (rule_num = 0; rule_num < valid_num; rule_num++) {
-		printk("  %4.4d     %4.4d        %6.6d\n",
-		       rule_num, count_array[rule_num].rule_idx, count_array[rule_num].hit_count);
-	}
-
-	print_horizontal_line(60);
-}
-/*******************************************************************************
-* tpm_print_pnc_all_hit_counters()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*   None
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_pnc_all_hit_counters(uint32_t                owner_id,
-				    tpm_api_type_t          api_type,
-				    uint32_t                high_thresh_pkts,
-				    uint8_t                 counters_reset,
-				    uint16_t                valid_counters,
-				    tpm_api_entry_count_t  *count_array)
-{
-	uint16_t              rule_num;
-
-	printk("\n");
-	print_horizontal_line(60);
-	printk("  Input owner_id[%d], api_type[%d], high_thresh_pkts[%d] counters_reset[%d]\n",
-	       owner_id, api_type, high_thresh_pkts, counters_reset);
-	printk("  Output valid_counters[%d]\n", valid_counters);
-	print_horizontal_line(60);
-	printk("  Index    rule_idx    hit_counter \n");
-	print_horizontal_line(60);
-
-	for (rule_num = 0; rule_num < valid_counters; rule_num++) {
-		printk("  %4.4d     %4.4d        %6.6d\n",
-		       rule_num, count_array[rule_num].rule_idx, count_array[rule_num].hit_count);
-	}
-
-	print_horizontal_line(60);
-}
-
-/*******************************************************************************
-* tpm_print_vlan_key()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* vlan_key      - Print CPU WAN loopback entry
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_vlan_key(tpm_vlan_key_t *vlan_key)
-{
-	print_horizontal_line(49);
-	printk("  TPID  VID  VID mask CFI CFI mask PBIT PBIT mask\n");
-	print_horizontal_line(49);
-	printk("  %4.4x  %4.4x  %4d   %4.4x    %1.1x     %1.1x      %2.2x     %2.2x\n",
-	       vlan_key->tpid, vlan_key->tpid_mask, vlan_key->vid, vlan_key->vid_mask,
-	       vlan_key->cfi, vlan_key->cfi_mask, vlan_key->pbit, vlan_key->pbit_mask);
-	print_horizontal_line(49);
-}
-
-/*******************************************************************************
-* tpm_print_ipv4_key()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* ipv4_key      - Print ipv4 key
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_ipv4_key(tpm_ipv4_acl_key_t *ipv4_key, tpm_ipv4_add_key_t *ipv4_add_key)
-{
-	printk("IPV4:\n");
-	printk("=======================================================\n");
-	printk("    DST_IP       SRC_IP     DSCP PROT L4_DST L4_SRC\n");
-	printk("=======================================================\n");
-	printk("  %02x.%02x.%02x.%02x  %02x.%02x.%02x.%02x   %02x   %02x   %02x     %02x\n"
-	       "  %02x.%02x.%02x.%02x  %02x.%02x.%02x.%02x   %02x \n",
-	       ipv4_key->ipv4_dst_ip_add[0], ipv4_key->ipv4_dst_ip_add[1], ipv4_key->ipv4_dst_ip_add[2],
-	       ipv4_key->ipv4_dst_ip_add[3], ipv4_key->ipv4_src_ip_add[0], ipv4_key->ipv4_src_ip_add[1],
-	       ipv4_key->ipv4_src_ip_add[2], ipv4_key->ipv4_src_ip_add[3], ipv4_key->ipv4_dscp, ipv4_key->ipv4_proto,
-	       ipv4_key->l4_dst_port, ipv4_key->l4_src_port, ipv4_key->ipv4_dst_ip_add_mask[0],
-	       ipv4_key->ipv4_dst_ip_add_mask[1], ipv4_key->ipv4_dst_ip_add_mask[2], ipv4_key->ipv4_dst_ip_add_mask[3],
-	       ipv4_key->ipv4_src_ip_add_mask[0], ipv4_key->ipv4_src_ip_add_mask[1], ipv4_key->ipv4_src_ip_add_mask[2],
-	       ipv4_key->ipv4_src_ip_add_mask[3], ipv4_key->ipv4_dscp_mask);
-	if (ipv4_add_key != NULL) {
-		printk("=======================================================\n");
-		printk("    IP_VER  IP_IHL  IP_LEN  IP_FLAG  IP_FRAG IP_TTL \n");
-		printk("=======================================================\n");
-		printk("     %01x        %01x     %04x      %02x      %04x   %02x   \n"
-		       "     %01x        %01x      %01x        %01x        %01x \n",
-		       ipv4_add_key->ipv4_ver, ipv4_add_key->ipv4_ihl, ipv4_add_key->ipv4_totlen,
-		       ipv4_add_key->ipv4_flags, ipv4_add_key->ipv4_frag_offset, ipv4_add_key->ipv4_ttl,
-		       ipv4_add_key->ipv4_ver_mask, ipv4_add_key->ipv4_ihl_mask, ipv4_add_key->ipv4_totlen_mask,
-		       ipv4_add_key->ipv4_flags_mask, ipv4_add_key->ipv4_frag_offset_mask);
-		printk("=======================================================\n");
-	}
-}
-
-/*******************************************************************************
-* tpm_print_l2_key()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* l2_key      - Print l2 key
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_l2_key(tpm_l2_acl_key_t *l2_key)
-{
-	printk("\nL2 KEY:\n");
-
-	tpm_print_mac_key(&(l2_key->mac));
-	TPM_OS_DEB_WAIT();
-	printk("\nVLAN 1:\n");
-	tpm_print_vlan_key(&(l2_key->vlan1));
-	printk("\nVLAN 2:\n");
-	tpm_print_vlan_key(&(l2_key->vlan2));
-	TPM_OS_DEB_WAIT();
-	printk("L2 ethertype(%04x), pppoe_ses(%d), pppoe_proto(%x)\n",
-	       l2_key->ether_type, l2_key->pppoe_hdr.ppp_session, l2_key->pppoe_hdr.ppp_proto);
-	printk("gem_port(%x)\n", l2_key->gem_port);
-	printk("=======================================================\n");
-}
-
-/*******************************************************************************
-* tpm_print_l3_key()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* l3_key      - Print l2 key
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_l3_key(tpm_l3_type_key_t *l3_key)
-{
-	printk("L3 KEY:\n");
-	printk("L3 ethertype(%04x), pppoe_ses(%d), pppoe_proto(%x)\n",
-	       l3_key->ether_type_key, l3_key->pppoe_key.ppp_session, l3_key->pppoe_key.ppp_proto);
-	printk("=======================================================\n");
-}
-
-/*******************************************************************************
-* tpm_print_etherports()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-* vlan_key      - Print vlan key
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_etherports(void)
-{
-	uint32_t i;
-
-	printk("======================================================\n");
-	printk(" TPM ethernet ports:                                  \n");
-	printk("======================================================\n");
-	printk("     ext   switch       chip             internal     \n");
-	printk("                     connection         connection    \n");
-	printk("======================================================\n");
-	for (i = 0; i < TPM_MAX_NUM_ETH_PORTS; i++) {
-		if (tpm_db.eth_ports[i].valid == TPM_DB_VALID) {
-			printk(" %1d   %3d   ", i, tpm_db.eth_ports[i].port_src);
-
-			if (tpm_db.eth_ports[i].int_connect == TPM_INTCON_SWITCH)
-				printk(" %3d    ", tpm_db.eth_ports[i].switch_port);
-			else
-				printk("%8s", " ");
-
-			printk("%15s  %17s \n",
-			       tpm_db_chip_conn_str[tpm_db.eth_ports[i].chip_connect].enumString,
-			       tpm_db_int_conn_str[tpm_db.eth_ports[i].int_connect].enumString);
-		}
-	}
-	printk("======================================================\n");
-	return;
-}
-
-/*******************************************************************************
-* tpm_print_rx_modules()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_rx_modules(void)
-{
-	uint32_t i, j, q_val, q_size;
-
-	printk("============================================================\n");
-	printk(" TPM GMAC RX Queues:                                            \n");
-	printk("============================================================\n");
-	printk(" Queue  size\n");
-	printk("============================================================\n");
-
-	for (i = 0; i < TPM_MAX_NUM_GMACS; i++) {
-		if (tpm_db_gmac_rx_val_get(i)) {
-			printk("GMAC - %d\n", i);
-
-			for (j = 0; j < TPM_MAX_NUM_RX_QUEUE; j++) {
-
-				tpm_db_gmac_rx_q_conf_get(i, j, &q_val, &q_size);
-				if (q_val)
-					printk("q%1d  rxq_size %4d\n", j, q_size);
-			}
-		}
-	}
-	printk("======================================================\n");
-	return;
-}
-
-/*******************************************************************************
-* tpm_print_tx_modules()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-* RETURNS:
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpm_print_tx_modules(void)
-{
-	uint32_t i, j;
-
-	printk("============================================================\n");
-	printk(" TPM TX modules:                                            \n");
-	printk("============================================================\n");
-	printk(" Queue      Sched          Q-owner      owner   size  weight\n");
-	printk("                                        q-num               \n");
-	printk("============================================================\n");
-
-	for (i = 0; i < TPM_MAX_NUM_TX_PORTS; i++) {
-		if (tpm_db.gmac_tx[i].valid == TPM_DB_VALID) {
-			printk("TX Device - %d\n", i);
-
-			for (j = 0; j < TPM_MAX_NUM_TX_QUEUE; j++) {
-				if (tpm_db.gmac_tx[i].tx_queue[j].valid == TPM_DB_VALID) {
-					printk("   %1d   %13s  %17s   %1d     %4d  %5d\n",
-					       j,
-					       tpm_db_sched_str[tpm_db.gmac_tx[i].tx_queue[j].sched_method].enumString,
-					       tpm_db_txq_owner_str[tpm_db.gmac_tx[i].tx_queue[j].queue_owner].
-					       enumString, tpm_db.gmac_tx[i].tx_queue[j].owner_queue_num,
-					       tpm_db.gmac_tx[i].tx_queue[j].queue_size,
-					       tpm_db.gmac_tx[i].tx_queue[j].queue_weight);
-				}
-			}
-
-		}
-	}
-	printk("======================================================\n");
-	return;
-}
-
-void tpm_print_gmac_config(void)
-{
-	printk("=========================================================\n");
-	printk(" TPM GMAC configuration:                                 \n");
-	printk("=========================================================\n");
-	printk("    Num                     Connection                   \n");
-	printk(" tcont/llid         G0                      G1           \n");
-	printk("    %4.4x    %18s  %18s\n",
-	       tpm_db.num_valid_tcont_llid,
-	       tpm_db_gmac_conn_str[tpm_db.gmac_port_conf[0].conn].enumString,
-	       tpm_db_gmac_conn_str[tpm_db.gmac_port_conf[1].conn].enumString);
-	printk("                    mh_en                  mh_en    \n");
-	printk("                      %1d                      %1d\n",
-	       tpm_db.gmac_mh_en[1], tpm_db.gmac_mh_en[0]);
-
-	printk("====================================================\n");
-	return;
-}
-
-void tpm_print_gmac_func(void)
-{
-	printk("=============================================================\n");
-	printk(" TPM GMAC functions:                                         \n");
-	printk("=============================================================\n");
-	printk("        PMAC                 G0                   G1         \n");
-	printk("=============================================================\n");
-	printk(" %18s  %18s  %18s\n",
-	       tpm_db_gmac_func_str[tpm_db.gmac_func[2]].enumString,
-	       tpm_db_gmac_func_str[tpm_db.gmac_func[0]].enumString,
-	       tpm_db_gmac_func_str[tpm_db.gmac_func[1]].enumString);
-	printk("====================================================\n");
-	return;
-}
-
-void tpm_print_bm_buffers(void)
-{
-	uint32_t i, valid, large_pkt_buf, small_pkt_buf;
-
-	printk("=============================================================\n");
-	printk(" Buffer Mngmt Pools:                                         \n");
-	printk("=============================================================\n");
-	printk("        Pool   cfg_val  large_bufs   small_bufs   \n");
-	printk("=============================================================\n");
-	for (i = 0; i < TPM_MAX_NUM_GMACS; i++) {
-		tpm_db_gmac_bm_bufs_conf_get(i, &valid, &large_pkt_buf, &small_pkt_buf);
-		printk("          %d     %d          %d          %d\n",
-		       i, valid, large_pkt_buf, small_pkt_buf);
-	}
-	printk("====================================================\n");
-	return;
-}
-
-void tpm_print_igmp(void)
-{
-#if 0
-	printk("===================\n");
-	printk(" IGMP:             \n");
-	printk("===================\n");
-	printk("Valid  Snoop  CPU-q\n");
-	printk("===================\n");
-	printk(" %3s    %3d    %2d \n",
-	       (tpm_db.igmp_def.valid == TPM_DB_VALID ? "yes" : "no"),
-	       tpm_db.igmp_def.igmp_snoop, tpm_db.igmp_def.igmp_cpu_queue);
-	printk("========================\n");
-	return;
-#endif
-
-	printk("===================\n");
-	printk(" Multicast:   value\n");
-	printk("===================\n");
-	printk("Filter mode        %d\n", tpm_db.igmp_def.filter_mode);
-	printk("Per UNI Vlan Xlate %d\n", tpm_db.igmp_def.per_uni_vlan_xlat);
-	printk("MC PPPoE enable    %d\n", tpm_db.igmp_def.mc_pppoe_enable);
-	printk("MC hwf queue       %d\n", tpm_db.igmp_def.mc_hwf_queue);
-	printk("MC cpu queue       %d\n", tpm_db.igmp_def.mc_cpu_queue);
-	printk("===================\n");
-	return;
-}
-
-void tpm_print_misc(void)
-{
-	char *gmac_name[] = {"GMAC_0","GMAC_1","PMAC"};
-	char *pon_type[] = {"EPON","GPON","P2P","NONE"};
-
-	printk("==========================\n");
-	printk(" TPM misc:          value \n");
-	printk("==========================\n");
-	printk("OMCI ETY            %4.4x\n", tpm_db.init_misc.omci_etype);
-	printk("Debug port          %4d\n", tpm_db.init_misc.pnc_init_debug_port);
-	printk("PON type            %s\n", pon_type[tpm_db.init_misc.pon_type]);
-
-	if ((tpm_db.init_misc.active_wan <= TPM_MAX_GMAC) && (tpm_db.init_misc.active_wan >= TPM_ENUM_GMAC_0))
-		printk("Active WAN          %s\n", gmac_name[tpm_db.init_misc.active_wan]);
-	else
-		printk("Active WAN          N/A");
-	printk("DS MH select source %4d\n", tpm_db.init_misc.ds_mh_set_conf);
-	printk("CFG PNC parse       %4d\n", tpm_db.init_misc.cfg_pnc_parse);
-	printk("CPU loopback        %4d\n", tpm_db.init_misc.cpu_loopback);
-	printk("Double Tag support  %4d\n", tpm_db.init_misc.dbl_tag);
-	printk("IPV6 5T enable      %4d\n", tpm_db.init_misc.ipv6_5t_enable);
-	printk("Virtual UNI-en:%4d uni-src %4d switch port %4d\n",
-	       tpm_db.func_profile.virt_uni_info.enabled,
-	       tpm_db.func_profile.virt_uni_info.uni_port,
-	       tpm_db.func_profile.virt_uni_info.switch_port);
-	printk("===============================\n");
-	printk("TRACE DEBUG info    0x%08x\n", tpm_glob_trace);
-	printk("===============================\n");
-
-	return;
-}
-
-void tpm_print_owners(void)
-{
-
-	printk("\ntpm_print_owners : owners tables NOT USED YET \n");
-
-	return;
-}
-
-void tpm_print_vlan_etype(void)
-{
-	uint32_t i;
-
-	printk("========================\n");
-	printk(" VLAN ETYs:             \n");
-	printk("========================\n");
-	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
-		if (tpm_db.vlan_etype[i].valid == TPM_DB_VALID)
-			printk(" %2d   %4.4x\n", i, tpm_db.vlan_etype[i].tpid_ether_type);
-	}
-
-	return;
-}
-
-void tpm_print_valid_api_sections(void)
-{
-	tpm_api_sections_t cur_section = -1, next_section;
-	int32_t last_valid;
-	int32_t ret_code;
-	uint32_t api_rng_size, num_valid_entries, tbl_start_ind;
-
-	printk("==================================================\n");
-	printk(" Valid API ranges:                         \n");
-	printk("==================================================\n");
-	printk("      Name       Size    Num     Last   Tbl\n");
-	printk("                         entries  valid  Start\n");
-	printk("==================================================\n");
-
-	/* Loop through valid API ranges and print them */
-	ret_code = tpm_db_api_section_val_get_next(cur_section, &next_section,
-						   &api_rng_size, &num_valid_entries, &last_valid, &tbl_start_ind);
-	IF_ERROR(ret_code);
-
-	while (next_section != TPM_INVALID_SECTION) {
-		printk("%15s  %4d    %4d    %4d    %4d\n",
-		       api_sec_to_str(next_section), api_rng_size, num_valid_entries, last_valid, tbl_start_ind);
-
-		cur_section = next_section;
-		ret_code = tpm_db_api_section_val_get_next(cur_section, &next_section,
-							   &api_rng_size, &num_valid_entries, &last_valid,
-							   &tbl_start_ind);
-		IF_ERROR(ret_code);
-	}
-	printk("===========================================\n");
-	return;
-}
-
-void tpm_print_full_api_section(tpm_api_sections_t api_section)
-{
-	uint32_t rule_idx, bi_dir, i;
-	int32_t ret_code;
-	int32_t cur_rule, next_rule, last_valid;
-	uint32_t api_rng_size, num_valid_entries, tbl_start_ind;
-	tpm_pnc_ranges_t prim_pnc_range;
-	tpm_rule_entry_t api_data;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_con;
-
-	/* Print API Range Header */
-	printk("====================================================\n");
-	printk(" Full API range:                          \n");
-	printk("====================================================\n");
-	printk("      Name       Size    Num     Last    Start \n");
-	printk("                         entries  valid     Ind  \n");
-	printk("====================================================\n");
-
-	ret_code =
-	    tpm_db_api_section_get(api_section, &api_rng_size, &num_valid_entries, &prim_pnc_range, &last_valid,
-				   &tbl_start_ind);
-	if (ret_code != TPM_OK) {
-		printk("%15s - invalid \n", api_sec_to_str(api_section));
-		return;
-	}
-
-	printk("%15s %4d    %4d    %4d    %4d\n",
-	       api_sec_to_str(api_section), api_rng_size, num_valid_entries, last_valid, tbl_start_ind);
-
-	cur_rule = -1;
-
-	tpm_db_api_entry_val_get_next(api_section, cur_rule, &next_rule, &rule_idx, &bi_dir,
-				      &api_data, &mod_con, &pnc_con);
-
-	printk("=========================================================\n");
-	printk("  Rule  Rule  Bi-dir  Mod  Mod |  Ranges    PnC    PnC   \n");
-	printk("  num   idx           cmd  bm  |  total    range  index  \n");
-	printk("=========================================================\n");
-
-	while (next_rule != -1) {
-		printk("  %3d  %5d   %3s    %3d  %2d    %4d",
-		       next_rule, rule_idx,
-		       (bi_dir ? "yes" : "no"), mod_con.mod_cmd_ind, mod_con.mod_cmd_mac, pnc_con.num_pnc_ranges);
-
-		for (i = 0; i < pnc_con.num_pnc_ranges; i++) {
-			printk("   %02d     %03d\n",
-			       pnc_con.pnc_conn_tbl[i].pnc_range, pnc_con.pnc_conn_tbl[i].pnc_index);
-		}
-
-		cur_rule = next_rule;
-		tpm_db_api_entry_val_get_next(api_section, cur_rule, &next_rule, &rule_idx, &bi_dir,
-					      &api_data, &mod_con, &pnc_con);
-	}
-	printk("=================================================================\n");
-	return;
-}
-
-void tpm_print_valid_pnc_ranges(void)
-{
-	int32_t ret_code;
-	tpm_db_pnc_range_t range_data;
-	tpm_pnc_ranges_t cur_range, next_range;
-
-	/* Print PNC Range Header */
-	printk("==============================================================================================\n");
-	printk(" Valid PnC ranges:                                                                            \n");
-	printk("==============================================================================================\n");
-	printk(" Range                        LU   Res Size Aging LU      Range         API      RSRV  Free     Num         Last    \n");
-	printk("                                   Lvl      group skip  Start  End   Start  End  entr  entr     rsts        init        \n");
-	printk("==============================================================================================\n");
-
-	cur_range = -1;
-
-	ret_code = tpm_db_pnc_rng_val_get_next(cur_range, &next_range, &range_data);
-	IF_ERROR(ret_code);
-
-	while (next_range != -1) {
-		printk(" %24s    %2d   %2d %4d  %4d  %2d    %4d   %4d  %4d  %4d  %4d  %4d  %s\n",
-		       pnc_rng_to_str(next_range),
-		       range_data.pnc_range_conf.base_lu_id,
-		       range_data.pnc_range_conf.min_reset_level,
-		       range_data.pnc_range_conf.range_size,
-		       range_data.pnc_range_conf.cntr_grp,
-		       range_data.pnc_range_conf.lu_mask,
-		       range_data.pnc_range_conf.range_start,
-		       range_data.pnc_range_conf.range_end,
-		       range_data.pnc_range_conf.api_start,
-		       range_data.pnc_range_conf.api_end,
-		       range_data.pnc_range_oper.free_entries,
-		       range_data.pnc_range_oper.num_resets,
-		       tpm_db_pnc_last_init_str[range_data.pnc_range_conf.init_last_entry].enumString);
-		cur_range = next_range;
-		ret_code = tpm_db_pnc_rng_val_get_next(cur_range, &next_range, &range_data);
-		IF_ERROR(ret_code);
-	}
-	printk("================================================================================\n");
-	return;
-}
-
-void tpm_print_pnc_shadow_range(uint32_t valid_only, uint32_t start, uint32_t end)
-{
-	uint32_t i;
-	uint32_t valid_entry;
-	tpm_pnc_all_t pnc_data;
-
-	printk("======================================================================\n");
-	printk(" Valid PnC shadow range:                                              \n");
-	printk("======================================================================\n");
-
-	if ((end >= (TPM_PNC_SIZE)) || (start > end)) {
-		printk("Invalid params: start(%d) end(%d)\n", start, end);
-		return;
-	}
-
-	for (i = start; i <= end; i++) {
-		tpm_db_pnc_shdw_ent_get(i, &valid_entry, &pnc_data);
-		if ((valid_only == TPM_FALSE) || (valid_entry == TPM_TRUE)) {
-			printk("PNC Shadow Entry (%d)\n", i);
-			tpm_pnc_print_sw_entry(&pnc_data);
-		}
-	}
-	return;
-}
-
-void tpm_print_mh_port_vector_table(void)
-{
-	uint32_t i;
-
-	printk("======================================================================\n");
-	printk(" MH port vector table:                                                \n");
-	printk("======================================================================\n");
-	printk("=  REG#     UNI_VEC                 PNC_VEC               AMBER_VEC  =\n");
-	printk("======================================================================\n");
-
-	for (i = 0; i < TPM_TX_MAX_MH_REGS; i++) {
-		printk("= %02d      0x%05x                0x%08x                 0x%04x   ==\n",
-		       i, tpm_db.tpm_mh_port_vector_tbl[i].uni_vector,
-		       tpm_db.tpm_mh_port_vector_tbl[i].pnc_vector, tpm_db.tpm_mh_port_vector_tbl[i].amber_port_vector);
-	}
-	printk("======================================================================\n");
-	return;
-}
-
-void tpm_print_init_tables(void)
-{
-	tpm_print_etherports();
-	tpm_print_rx_modules();
-	tpm_print_tx_modules();
-	tpm_print_gmac_config();
-	tpm_print_gmac_func();
-	tpm_print_bm_buffers();
-	tpm_print_igmp();
-	tpm_print_misc();
-	tpm_print_owners();
-	tpm_print_vlan_etype();
-	tpm_print_mh_port_vector_table();
-}
-
-void tpm_print_api_dump_head(void)
-{
-	printk("==========================================================================================================================================================\n");
-	printk("=  Section    Rule   Rule   PNC     Src_Port     Parse_BM      Parse_Flag_BM     Next       Pkt_Action          Target_Port         Mod_BM        Mod.   =\n");
-	printk("=             No.    Ind.   Entry                                                Phase                       (Gem_Port)(Queue)                    Entry  =\n");
-	printk("==========================================================================================================================================================\n");
-}
-
-char *tpm_db_src_port_str[] = {
-       "UNI_0",
-	"UNI_1",
-	"UNI_2",
-	"UNI_3",
-	"UNI_4",
-	"UNI_5",
-	"UNI_6",
-	"UNI_7",
-	"UNI_VIRT",
-	"WAN",
-	"UNI_ANY",
-	"PORT_ANY",
-};
-
-char *tpm_db_next_phase_str[] = {
-	"L2",
-	"L3",
-	"IPv4",
-	"IPv6_GEN",
-	"IPv6_DIP",
-	"IPv6_NH",
-	"IPV6_L4",
-	"CTC_CM",
-	"DONE",
-};
-
-tpm_str_map_t tpm_db_none_parse_type_str[] = {
-	{0, ""}
-};
-
-tpm_str_map_t tpm_db_l2_parse_type[] = {
-	{TPM_L2_PARSE_MAC_DA, "DA"},
-	{TPM_L2_PARSE_MAC_SA, "SA"},
-	{TPM_L2_PARSE_ONE_VLAN_TAG, "ONE_TAG"},
-	{TPM_L2_PARSE_TWO_VLAN_TAG, "TWO_TAGS"},
-	{TPM_L2_PARSE_ETYPE, "ETYPE"},
-	{TPM_L2_PARSE_PPPOE_SES, "PPPOE_SES"},
-	{TPM_L2_PARSE_PPP_PROT, "PPP_PROT"},
-	{TPM_L2_PARSE_GEMPORT, "GEMPORT"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_l3_parse_type[] = {
-	{TPM_L2_PARSE_ETYPE, "ETYPE"},
-	{TPM_L2_PARSE_PPPOE_SES, "PPPOE_SES"},
-	{TPM_L2_PARSE_PPP_PROT, "PPP_PROT"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv4_parse_type[] = {
-	{TPM_IPv4_PARSE_SIP,        "IPV4_SRC"},
-	{TPM_IPv4_PARSE_DIP,        "IPV4_DST"},
-	{TPM_IPv4_PARSE_DSCP, "DSCP"},
-	{TPM_IPv4_PARSE_PROTO,      "L4_PROTO"},
-	{TPM_PARSE_L4_SRC, "L4_SRC"},
-	{TPM_PARSE_L4_DST, "L4_DST"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv4_mc_parse_type[] = {
-	{TPM_IPv4_PARSE_SIP, "SIP"},
-	{TPM_IPv4_PARSE_DIP, "DIP"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_gen_parse_type[] = {
-	{TPM_IPv6_PARSE_SIP, "SIP"},
-	{TPM_IPv6_PARSE_DSCP, "DSCP"},
-	{TPM_IPv6_PARSE_HOPL, "HOPL"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_gen_5t_parse_type[] = {
-	{TPM_IPv6_PARSE_SIP, "SIP"},
-	{TPM_PARSE_L4_SRC, "L4_SRC"},
-	{TPM_PARSE_L4_DST, "L4_DST"},
-	{0, ""},
-};
-
-
-tpm_str_map_t tpm_db_ipv6_dip_parse_type[] = {
-	{TPM_IPv6_PARSE_DIP, "DIP"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_dip_5t_parse_type[] = {
-	{TPM_IPv6_PARSE_SIP, "SIP"},
-	{TPM_IPv6_PARSE_DIP, "DIP"},
-	{TPM_PARSE_L4_SRC, "L4_SRC"},
-	{TPM_PARSE_L4_DST, "L4_DST"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_mc_parse_type[] = {
-	{TPM_IPv4_PARSE_DIP, "DIP"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_nh_parse_type[] = {
-	{TPM_IPv6_PARSE_NH, "NH"},
-	{0, ""},
-};
-
-tpm_str_map_t tpm_db_ipv6_l4_parse_type[] = {
-	{TPM_PARSE_L4_SRC, "L4_SRC"},
-	{TPM_PARSE_L4_DST, "L4_DST"},
-	{0, ""},
-};
-tpm_str_map_t tpm_db_ctc_cm_parse_type[] = {
-	{TPM_L2_PARSE_MAC_DA, "DA"},
-	{TPM_L2_PARSE_MAC_SA, "SA"},
-	{TPM_L2_PARSE_ONE_VLAN_TAG, "ONE_TAG"},
-	{TPM_L2_PARSE_TWO_VLAN_TAG, "TWO_TAGS"},
-	{TPM_L2_PARSE_ETYPE, "ETYPE"},
-	{TPM_L2_PARSE_PPPOE_SES, "PPPOE_SES"},
-	{TPM_L2_PARSE_PPP_PROT, "PPP_PROT"},
-
-	{TPM_IPv4_PARSE_SIP << API_DUMP_IPV4_PARSE_BM_START,        "IPV4_SIP"},
-	{TPM_IPv4_PARSE_DIP << API_DUMP_IPV4_PARSE_BM_START,        "IPV4_DIP"},
-	{TPM_IPv4_PARSE_DSCP << API_DUMP_IPV4_PARSE_BM_START,       "IPV4_DSCP"},
-	{TPM_IPv4_PARSE_PROTO << API_DUMP_IPV4_PARSE_BM_START,      "IPV4_PROTO"},
-	{TPM_PARSE_L4_SRC << API_DUMP_IPV4_PARSE_BM_START,          "L4_SRC"},
-	{TPM_PARSE_L4_DST << API_DUMP_IPV4_PARSE_BM_START,          "L4_DST"},
-
-	{TPM_IPv6_PARSE_SIP << API_DUMP_IPV6_PARSE_BM_START,        "IPV6_SIP"},
-	{TPM_IPv6_PARSE_DSCP << API_DUMP_IPV6_PARSE_BM_START,       "IPV6_DSCP"},
-	{TPM_IPv6_PARSE_HOPL << API_DUMP_IPV6_PARSE_BM_START,       "IPV6_HOPL"},
-	{TPM_IPv6_PARSE_DIP << API_DUMP_IPV6_PARSE_BM_START,        "IPV6_DIP"},
-	{TPM_IPv6_PARSE_NH << API_DUMP_IPV6_PARSE_BM_START,         "IPV6_NH"},
-	{TPM_PARSE_L4_SRC << API_DUMP_IPV6_PARSE_BM_START,          "L4_SRC"},
-	{TPM_PARSE_L4_DST << API_DUMP_IPV6_PARSE_BM_START,          "L4_DST"},
-	{0, ""},
-};
-
-tpm_str_map_t *tpm_db_parse_type_str[TPM_MAX_API_TYPES] = {
-	/* TPM_API_MGMT */
-	tpm_db_none_parse_type_str,
-	/* TPM_API_MAC_LEARN */
-	tpm_db_none_parse_type_str,
-	/* TPM_API_DS_LOAD_BALANCE */
-	tpm_db_l2_parse_type,
-	/* TPM_API_CPU_LOOPBACK */
-	tpm_db_none_parse_type_str,
-	/* TPM_API_L2_PRIM */
-	tpm_db_l2_parse_type,
-	/* TPM_API_L3_TYPE */
-	tpm_db_l3_parse_type,
-	/* TPM_API_IPV4 */
-	tpm_db_ipv4_parse_type,
-	/* TPM_API_IPV4_MC */
-	tpm_db_ipv4_mc_parse_type,
-	/* TPM_API_IPV6_NH */
-	tpm_db_ipv6_nh_parse_type,
-	/* TPM_API_IPV6_L4 */
-	tpm_db_ipv6_l4_parse_type,
-	/* TPM_API_IPV6_GEN */
-	tpm_db_ipv6_gen_parse_type,
-	/* TPM_API_IPV6_DIP */
-	tpm_db_ipv6_dip_parse_type,
-	/* TPM_API_IPV6_MC */
-	tpm_db_ipv6_mc_parse_type,
-	/* TPM_API_CTC_CM */
-	tpm_db_ctc_cm_parse_type,
-};
-
-tpm_str_map_t tpm_db_parse_flag_type_str[] = {
-	{TPM_PARSE_FLAG_TAG1_TRUE, "TAG1_TRUE"},
-	{TPM_PARSE_FLAG_TAG1_FALSE, "TAG1_FALSE"},
-	{TPM_PARSE_FLAG_TAG2_TRUE, "TAG2_TRUE"},
-	{TPM_PARSE_FLAG_TAG2_FALSE, "TAG2_FALSE"},
-	{TPM_PARSE_FLAG_MTM_TRUE, "MTM_TRUE"},
-	{TPM_PARSE_FLAG_MTM_FALSE, "MTM_FALSE"},
-	{TPM_PARSE_FLAG_TO_CPU_TRUE, "TO_CPU_TRUE"},
-	{TPM_PARSE_FLAG_TO_CPU_FALSE, "TO_CPU_FALSE"},
-	{TPM_PARSE_FLAG_L4_UDP, "L4_UDP"},
-	{TPM_PARSE_FLAG_L4_TCP, "L4_TCP"},
-	{TPM_PARSE_FLAG_PPPOE_TRUE, "PPPOE_TRUE"},
-	{TPM_PARSE_FLAG_PPPOE_FALSE, "PPPOE_FALSE"},
-};
-
-tpm_str_map_t tpm_db_action_type_str[] = {
-	{TPM_ACTION_DROP_PK, "DROP_PK"},
-	{TPM_ACTION_SET_TARGET_PORT, "SET_TRG_PORT"},
-	{TPM_ACTION_SET_TARGET_QUEUE, "SET_TRG_Q"},
-	{TPM_ACTION_SET_PKT_MOD, "SET_PKT_MOD"},
-	{TPM_ACTION_TO_CPU, "TO_CPU"},
-	{TPM_ACTION_MTM, "MTM"},
-	{TPM_ACTION_CUST_CPU_PKT_PARSE, "CUST_PKT_PARSE"},
-	{TPM_ACTION_SPEC_MC_VID, "SPEC_MC_VID"},
-	{TPM_ACTION_UDP_CHKSUM_CALC, "UDP_CHKSUM_CALC"},
-};
-
-tpm_str_map_t tpm_db_target_type_str[] =
-{
-	{TPM_TRG_PORT_WAN,           "WAN_PORT"},
-	{TPM_TRG_TCONT_0,            "TCONT_0"},
-	{TPM_TRG_TCONT_1,            "TCONT_1"},
-	{TPM_TRG_TCONT_2,            "TCONT_2"},
-	{TPM_TRG_TCONT_3,            "TCONT_3"},
-	{TPM_TRG_TCONT_4,            "TCONT_4"},
-	{TPM_TRG_TCONT_5,            "TCONT_5"},
-	{TPM_TRG_TCONT_6,            "TCONT_6"},
-	{TPM_TRG_TCONT_7,            "TCONT_7"},
-	{TPM_TRG_LLID_0,             "LLID_0"},
-	{TPM_TRG_LLID_1,             "LLID_1"},
-	{TPM_TRG_LLID_2,             "LLID_2"},
-	{TPM_TRG_LLID_3,             "LLID_3"},
-	{TPM_TRG_LLID_4,             "LLID_4"},
-	{TPM_TRG_LLID_5,             "LLID_5"},
-	{TPM_TRG_LLID_6,             "LLID_6"},
-	{TPM_TRG_LLID_7,             "LLID_7"},
-	{TPM_TRG_UNI_0,              "UNI_0"},
-	{TPM_TRG_UNI_1,              "UNI_1"},
-	{TPM_TRG_UNI_2,              "UNI_2"},
-	{TPM_TRG_UNI_3,              "UNI_3"},
-	{TPM_TRG_UNI_4,              "UNI_4"},
-	{TPM_TRG_UNI_5,              "UNI_5"},
-	{TPM_TRG_UNI_6,              "UNI_6"},
-	{TPM_TRG_UNI_7,              "UNI_7"},
-	{TPM_TRG_UNI_VIRT,           "UNI_VIRT"},
-	{TPM_TRG_PORT_CPU,           "CPU"},
-	{TPM_TRG_PORT_UNI_ANY,       "UNI_ANY"},
-	{TPM_TRG_PORT_UNI_CPU_LOOP,  "UNI_CPU_LOOP"}
-};
-tpm_str_map_t tpm_db_mod_type_str[] = {
-	{TPM_MH_SET, "MH_SET"},
-	{TPM_MAC_DA_SET, "DA_SET"},
-	{TPM_MAC_SA_SET, "SA_SET"},
-	{TPM_VLAN_MOD, "VLAN_MOD"},
-	{TPM_PPPOE_DEL, "PPPOE_DEL"},
-	{TPM_PPPOE_ADD, "PPPOE_ADD"},
-	{TPM_DSCP_SET, "DSCP_SET"},
-	{TPM_TTL_DEC, "TTL_DEC"},
-	{TPM_IPV4_UPDATE, "IPV4_UPDATE"},
-	{TPM_IPV4_SRC_SET, "IPV4_SRC_SET"},
-	{TPM_IPV4_DST_SET, "IPV4_DST_SET"},
-	{TPM_IPV6_UPDATE, "IPV6_UPDATE"},
-	{TPM_HOPLIM_DEC, "HOPLIM_DEC"},
-	{TPM_IPV6_SRC_SET, "IPV6_SRC_SET"},
-	{TPM_IPV6_DST_SET, "IPV6_DST_SET"},
-	{TPM_L4_SRC_SET, "L4_SRC_SET"},
-	{TPM_L4_DST_SET, "L4_DST_SET"},
-};
-
-char *tpm_db_mc_uni_mode_str[] = {
-	"EXCLUDE",
-	"TRANSPARENT",
-	"STRIP",
-	"TRANSLATE",
-};
-
-char *db_parse_type_to_str(uint32_t api_type, uint32_t parse_type)
-{
-	uint32_t i;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-
-	if (parse_type == 0)
-		return "";
-
-	if (api_type >= TPM_MAX_API_TYPES)
-		return tpm_db_params_illegal_str;
-
-	tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	if (ipv6_5t_enable == TPM_IPV6_5T_ENABLED) {
-		tpm_db_parse_type_str[TPM_API_IPV6_GEN] = tpm_db_ipv6_gen_5t_parse_type;
-		tpm_db_parse_type_str[TPM_API_IPV6_DIP] = tpm_db_ipv6_dip_5t_parse_type;
-	}
-
-	for (i = 0; tpm_db_parse_type_str[api_type][i].enum_in != 0; i++) {
-		if (tpm_db_parse_type_str[api_type][i].enum_in == parse_type)
-			return (&(tpm_db_parse_type_str[api_type][i].str_out[0]));
-	}
-
-	return tpm_db_params_illegal_str;
-}
-
-char *db_parse_flag_type_to_str(uint32_t parse_flag_type)
-{
-	uint32_t i;
-
-	if (parse_flag_type == 0)
-		return "";
-
-	for (i = 0; i < (sizeof(tpm_db_parse_flag_type_str) / sizeof(tpm_str_map_t)); i++) {
-		if (tpm_db_parse_flag_type_str[i].enum_in == parse_flag_type)
-			return (&(tpm_db_parse_flag_type_str[i].str_out[0]));
-	}
-
-	return tpm_db_params_illegal_str;
-}
-
-char *db_target_type_to_str(uint32_t action_type, tpm_pkt_frwd_t  *pkt_frwd)
-{
-	static char target_str[50];
-	char *port_str = "";
-	char gem_str[10] = "";
-	char q_str[10] = "";
-	uint32_t i;
-	tpm_dir_t            dir;
-	tpm_db_pon_type_t    pon_type;
-	tpm_gmacs_enum_t     act_wan = tpm_db_active_wan_get();
-
-	memset(target_str, 0, sizeof(target_str));
-
-	if (SET_TARGET_PORT(action_type)) {
-		for (i = 0; i < (sizeof(tpm_db_target_type_str)/sizeof(tpm_str_map_t)); i++) {
-			if (tpm_db_target_type_str[i].enum_in == pkt_frwd->trg_port) {
-				port_str = &(tpm_db_target_type_str[i].str_out[0]);
-				break;
-			}
-		}
-
-		dir = TPM_DIR_US;
-	/* Get pon_type */
-		tpm_db_pon_type_get(&pon_type);
-
-		if (TO_GPON(dir, pkt_frwd->trg_port, pon_type, act_wan)) {
-			sprintf(gem_str, "%03d",  pkt_frwd->gem_port);
-		}
-	}
-
-	if (SET_TARGET_QUEUE(action_type))
-		sprintf(q_str, "Q%d",  pkt_frwd->trg_queue);
-
-
-	sprintf(target_str, " %-9s %3s | %2s ", port_str, gem_str, q_str);
-
-	return target_str;
-}
-char *db_action_type_to_str(uint32_t action_type)
-{
-	uint32_t i;
-
-	if (action_type == 0)
-		return "";
-
-	for (i = 0; i < (sizeof(tpm_db_action_type_str) / sizeof(tpm_str_map_t)); i++) {
-		if (tpm_db_action_type_str[i].enum_in == action_type)
-			return (&(tpm_db_action_type_str[i].str_out[0]));
-	}
-
-	return tpm_db_params_illegal_str;
-}
-
-char *db_mod_type_to_str(uint32_t mod_type)
-{
-	uint32_t i;
-
-	if (mod_type == 0)
-		return "";
-
-	for (i = 0; i < (sizeof(tpm_db_mod_type_str) / sizeof(tpm_str_map_t)); i++) {
-		if (tpm_db_mod_type_str[i].enum_in == mod_type)
-			return (&(tpm_db_mod_type_str[i].str_out[0]));
-	}
-
-	return tpm_db_params_illegal_str;
-}
-
-void tpm_print_api_dump_line(uint8_t first_rule,
-			     uint8_t first_line,
-			     uint32_t api_type,
-			     uint32_t rule_num,
-			     uint32_t rule_idx,
-			     uint32_t pnc_entry,
-			     uint32_t src_port,
-			     uint32_t parse_type,
-			     uint32_t parse_flag_type,
-			     uint32_t next_phase,
-			     uint32_t action_type,
-			     uint32_t mod_type,
-			     uint32_t mod_entry,
-			     uint32_t set_port_q,
-			     tpm_pkt_frwd_t *pkt_frwd)
-{
-	char rule_num_str[8] = "";
-	char rule_idx_str[8] = "";
-	char pnc_entry_str[8] = "";
-	char mod_entry_str[8] = "";
-
-	char *empty_str = "";
-
-	char *api_type_str = empty_str;
-	char *src_port_str = empty_str;
-	char *next_phase_str = empty_str;
-
-	char *parse_type_str = empty_str;
-	char *parse_flag_type_str = empty_str;
-	char *action_type_str = empty_str;
-	char *mod_type_str = empty_str;
-	char *target_port_q_str   = empty_str;
-
-	if (first_line) {
-		sprintf(rule_num_str, "%03d", rule_num);
-		sprintf(rule_idx_str, "%03d", rule_idx);
-		sprintf(pnc_entry_str, "%03d", pnc_entry);
-		if (mod_entry != 0)
-			sprintf(mod_entry_str, "%04d", mod_entry);
-
-		if (first_rule) {
-			if (api_type < TPM_MAX_API_TYPES)
-				api_type_str = api_type_to_str(api_type);
-			else
-				api_type_str = tpm_db_params_illegal_str;
-		}
-
-		if (src_port <= TPM_SRC_PORT_WAN_OR_LAN)
-			src_port_str = tpm_db_src_port_str[src_port];
-		else
-			src_port_str = tpm_db_params_illegal_str;
-
-		if (next_phase <= STAGE_DONE)
-			next_phase_str = tpm_db_next_phase_str[next_phase];
-		else
-			next_phase_str = tpm_db_params_illegal_str;
-
-	}
-
-	if (parse_type != 0)
-		parse_type_str = db_parse_type_to_str(api_type, parse_type);
-
-	if (parse_flag_type != 0)
-		parse_flag_type_str = db_parse_flag_type_to_str(parse_flag_type);
-
-	if (action_type != 0) {
-		action_type_str = db_action_type_to_str(action_type);
-	}
-
-	if (set_port_q != 0)
-		target_port_q_str = db_target_type_to_str(set_port_q, pkt_frwd);
-
-	if (mod_type != 0)
-		mod_type_str = db_mod_type_to_str(mod_type);
-
-    printk("=  %8s | %4s | %4s | %5s | %8s | %13s | %13s | %8s | %16s |%20s| %12s | %6s  =\n",
-		api_type_str, rule_num_str, rule_idx_str, pnc_entry_str,
-		src_port_str, parse_type_str, parse_flag_type_str,
-	       next_phase_str, action_type_str, target_port_q_str, mod_type_str, mod_entry_str);
-}
-
-void tpm_print_api_dump_rule(uint8_t first_rule,
-				tpm_api_type_t api_type,
-				uint32_t rule_num,
-				uint32_t rule_idx, uint32_t pnc_entry, uint32_t mod_entry, tpm_rule_entry_t *rule)
-{
-	uint8_t first_line = TPM_TRUE;
-	uint32_t src_port = TPM_SRC_PORT_ILLEGAL;
-	uint32_t next_phase = STAGE_DONE;
-	uint32_t parse_bm = 0;
-	uint32_t parse_flag_bm = 0;
-	uint32_t action_bm = 0;
-	uint32_t mod_bm = 0;
-	uint32_t tgt_port_bm = 0;
-	uint32_t parse_type = 0x1;
-	uint32_t parse_flag_type = 0x1;
-	uint32_t action_type = 0x1;
-	uint32_t mod_type = 0x1;
-	uint32_t tgt_port = 0x1;
-	uint32_t bit_cnt;
-	uint32_t set_port_q = 0;
-	tpm_pkt_frwd_t *pkt_frwd = NULL;
-	tpm_pkt_frwd_t mc_frwd;
-
-	if (rule == NULL)
-		return;
-
-	switch (api_type) {
-	case TPM_API_L2_PRIM:
-		src_port = rule->l2_prim_key.src_port;
-		next_phase = rule->l2_prim_key.rule_action.next_phase;
-		parse_bm = rule->l2_prim_key.parse_rule_bm;
-		parse_flag_bm = rule->l2_prim_key.parse_flags_bm;
-		action_bm = rule->l2_prim_key.rule_action.pkt_act;
-		mod_bm = rule->l2_prim_key.pkt_mod_bm;
-		pkt_frwd = &rule->l2_prim_key.pkt_frwd;
-		break;
-
-	case TPM_API_L3_TYPE:
-		src_port = rule->l3_type_key.src_port;
-		next_phase = rule->l3_type_key.rule_action.next_phase;
-		parse_bm = rule->l3_type_key.parse_rule_bm;
-		parse_flag_bm = rule->l3_type_key.parse_flags_bm;
-		action_bm = rule->l3_type_key.rule_action.pkt_act;
-		pkt_frwd  = &rule->l3_type_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV4:
-		src_port = rule->ipv4_key.src_port;
-		next_phase = rule->ipv4_key.rule_action.next_phase;
-		parse_bm = rule->ipv4_key.parse_rule_bm;
-		parse_flag_bm = rule->ipv4_key.parse_flags_bm;
-		action_bm = rule->ipv4_key.rule_action.pkt_act;
-		mod_bm = rule->ipv4_key.pkt_mod_bm;
-		pkt_frwd = &rule->ipv4_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV4_MC:
-		src_port = TPM_SRC_PORT_WAN;
-		parse_bm = TPM_IPv4_PARSE_DIP;
-		if (rule->ipv4_mc_key.ignore_ipv4_src == 0)
-			parse_bm |= TPM_IPv4_PARSE_SIP;
-		mod_bm = 0;	/* ?? */
-		/*mc_frwd is only used to print target port and target queue for api_dump*/
-		action_bm = TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE;
-		mc_frwd.trg_port = rule->ipv4_mc_key.dest_port_bm;
-		mc_frwd.trg_queue = tpm_db.igmp_def.mc_hwf_queue;
-		pkt_frwd = &mc_frwd;
-		break;
-
-	case TPM_API_IPV6_GEN:
-		src_port = rule->ipv6_gen_key.src_port;
-		next_phase = rule->ipv6_gen_key.rule_action.next_phase;
-		parse_bm = rule->ipv6_gen_key.parse_rule_bm;
-		parse_flag_bm = rule->ipv6_gen_key.parse_flags_bm;
-		action_bm = rule->ipv6_gen_key.rule_action.pkt_act;
-		mod_bm = rule->ipv6_gen_key.pkt_mod_bm;
-		pkt_frwd = &rule->ipv6_gen_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV6_DIP:
-		src_port = rule->ipv6_dip_key.src_port;
-		next_phase = rule->ipv6_dip_key.rule_action.next_phase;
-		parse_bm = rule->ipv6_dip_key.parse_rule_bm;
-		parse_flag_bm = rule->ipv6_dip_key.parse_flags_bm;
-		action_bm = rule->ipv6_dip_key.rule_action.pkt_act;
-		mod_bm = rule->ipv6_dip_key.pkt_mod_bm;
-		pkt_frwd = &rule->ipv6_dip_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV6_NH:
-		src_port = TPM_SRC_PORT_WAN_OR_LAN;
-		next_phase = rule->ipv6_nh_key.rule_action.next_phase;
-		parse_bm = rule->ipv6_nh_key.parse_rule_bm;
-		parse_flag_bm = rule->ipv6_nh_key.parse_flags_bm;
-		action_bm = rule->ipv6_nh_key.rule_action.pkt_act;
-		pkt_frwd = &rule->ipv6_nh_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV6_L4:
-		src_port = rule->ipv6_l4_key.src_port;
-		next_phase = rule->ipv6_l4_key.rule_action.next_phase;
-		parse_bm = rule->ipv6_l4_key.parse_rule_bm;
-		parse_flag_bm = rule->ipv6_l4_key.parse_flags_bm;
-		action_bm = rule->ipv6_l4_key.rule_action.pkt_act;
-		mod_bm = rule->ipv6_l4_key.pkt_mod_bm;
-		pkt_frwd = &rule->ipv6_l4_key.pkt_frwd;
-		break;
-
-	case TPM_API_IPV6_MC:
-		src_port = TPM_SRC_PORT_WAN;
-		parse_bm = TPM_IPv6_PARSE_DIP;
-		mod_bm = 0;	/* ?? */
-		/*mc_frwd is only used to print target port and target queue for api_dump*/
-		action_bm = TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE;
-		mc_frwd.trg_port = rule->ipv6_mc_key.dest_port_bm;
-		mc_frwd.trg_queue = tpm_db.igmp_def.mc_hwf_queue;
-		pkt_frwd = &mc_frwd;
-		break;
-
-	case TPM_API_CNM:
-		src_port = rule->cnm_key.src_port;
-		parse_bm = rule->cnm_key.l2_parse_rule_bm;
-		parse_bm |= (rule->cnm_key.ipv4_parse_rule_bm << API_DUMP_IPV4_PARSE_BM_START);
-		parse_bm |= (rule->cnm_key.ipv6_parse_rule_bm << API_DUMP_IPV6_PARSE_BM_START);
-		action_bm = rule->cnm_key.pkt_act;
-		pkt_frwd = &rule->cnm_key.pkt_frwd;
-		break;
-	default:
-		return;
-	}
-
-	action_bm &= 0xFFFF;	/* DON'T show the internal actions! */
-	tgt_port_bm = pkt_frwd->trg_port;
-
-	set_port_q = action_bm & (TPM_ACTION_SET_TARGET_PORT | TPM_ACTION_SET_TARGET_QUEUE);
-
-	do {
-		if (parse_bm != 0) {
-			for (bit_cnt = 0; (parse_bm & 0x1) == 0; parse_bm = parse_bm >> 1, bit_cnt++)
-				;
-			parse_type = parse_type << bit_cnt;
-		} else
-			parse_type = 0;
-
-		if (parse_flag_bm != 0) {
-			for (bit_cnt = 0; (parse_flag_bm & 0x1) == 0; parse_flag_bm = parse_flag_bm >> 1, bit_cnt++)
-				;
-			parse_flag_type = parse_flag_type << bit_cnt;
-		} else
-			parse_flag_type = 0;
-
-		if (action_bm != 0) {
-			for (bit_cnt = 0; (action_bm & 0x1) == 0; action_bm = action_bm >> 1, bit_cnt++)
-				;
-			action_type = action_type << bit_cnt;
-		} else
-			action_type = 0;
-
-		if (mod_bm != 0) {
-			for (bit_cnt = 0; (mod_bm & 0x1) == 0; mod_bm = mod_bm >> 1, bit_cnt++)
-				;
-			mod_type = mod_type << bit_cnt;
-		} else
-			mod_type = 0;
-
-		if (tgt_port_bm != 0) {
-			for (bit_cnt = 0; (tgt_port_bm & 0x1) == 0; tgt_port_bm = tgt_port_bm >> 1, bit_cnt++)
-				;
-			tgt_port = tgt_port << bit_cnt;
-			pkt_frwd->trg_port = tgt_port;
-		} else
-			pkt_frwd->trg_port = 0;
-
-
-		tpm_print_api_dump_line(first_rule, first_line, api_type, rule_num, rule_idx,
-					pnc_entry, src_port, parse_type, parse_flag_type, next_phase,
-					action_type, mod_type, mod_entry, set_port_q, pkt_frwd);
-
-		first_line = TPM_FALSE;
-		set_port_q &= ~TPM_ACTION_SET_TARGET_QUEUE;
-
-		parse_bm &= ~0x1;
-		parse_flag_bm &= ~0x1;
-		action_bm &= ~0x1;
-		mod_bm &= ~0x1;
-		tgt_port_bm &= ~0x1;
-
-		if ((parse_bm == 0) && (parse_flag_bm == 0) && (action_bm == 0) && (mod_bm == 0) && (tgt_port_bm == 0))
-			break;
-
-	} while (TPM_TRUE);
-
-}
-
-void tpm_print_api_dump(tpm_api_type_t api_type)
-{
-	int8_t first_rule = 1;
-	int32_t current_rule, rcode;
-	int32_t rule_index;
-	int32_t bi_dir;
-	int32_t next_rule;
-	int32_t rule_num;
-	tpm_rule_entry_t tpm_rule;
-	tpm_error_code_t tpm_ret;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_api_sections_t api_section;
-	char *api_type_str = "";
-
-	tpm_print_api_dump_head();
-
-	tpm_db_api_section_get_from_api_type(api_type, &api_section);
-	current_rule = -1;
-
-	tpm_ret = tpm_db_api_entry_val_get_next(api_section, current_rule, &next_rule, &rule_index,
-						&bi_dir, &tpm_rule, &mod_con, &pnc_con);
-
-	if (-1 == next_rule) {
-		if (api_type < TPM_MAX_API_TYPES)
-			api_type_str = api_type_to_str(api_type);
-		else
-			api_type_str = tpm_db_params_illegal_str;
-
-		printk("=  %8s | %4s | %4s | %5s | %8s | %13s | %13s | %8s | %16s |%20s| %12s | %5s   =\n",
-		       api_type_str, "", "", "", "", "", "", "", "", "", "", "");
-	}
-
-	while (-1 != next_rule) {
-		if (first_rule == 0)
-			printk("=           |------+------+-------+----------+---------------+---------------+----------+------------------+--------------------+--------------+---------=\n");
-		/* Get the rule_num */
-		rcode = tpm_db_api_rulenum_get(api_section, rule_index, &rule_num);
-		if (rcode != TPM_DB_OK) {
-			printk("get DB failed: %d\n", rcode);
-			return;
-		}
-
-		tpm_print_api_dump_rule(first_rule, api_type, rule_num, rule_index, pnc_con.pnc_conn_tbl[0].pnc_index,
-					mod_con.mod_cmd_ind, &tpm_rule);
-
-		tpm_ret = tpm_db_api_entry_val_get_next(api_section, next_rule, &next_rule, &rule_index,
-							&bi_dir, &tpm_rule, &mod_con, &pnc_con);
-		first_rule = 0;
-	}
-
-	printk("==========================================================================================================================================================\n");
-	return;
-}
-
-void tpm_print_api_dump_all(void)
-{
-	tpm_api_type_t api_type;
-
-	tpm_api_sections_t api_section;
-	uint32_t api_rng_size;
-	uint32_t num_valid_entries;
-	tpm_pnc_ranges_t prim_pnc_range;
-	int32_t last_valid_entry;
-	uint32_t tbl_start;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	printk("\n");
-	for (api_type = TPM_API_L2_PRIM; api_type < TPM_MAX_API_TYPES; api_type++) {
-		tpm_db_api_section_get_from_api_type(api_type, &api_section);
-		tpm_db_api_section_get(api_section, &api_rng_size, &num_valid_entries,
-					&prim_pnc_range, &last_valid_entry, &tbl_start);
-
-		/* Get Range Conf */
-		tpm_db_pnc_rng_conf_get(prim_pnc_range, &range_conf);
-
-		tpm_print_api_dump(api_type);
-		printk("\n");
-	}
-
-	return;
-}
-
-int tpm_print_sram_next_lookup(struct tcam_entry *te, char *buf)
-{
-	unsigned int word;
-	unsigned int lookup;
-
-	word = LU_DONE_OFFS / DWORD_LEN;
-	lookup = te->sram.word[word] >> (LU_DONE_OFFS % DWORD_LEN);
-	lookup &= 0x1;
-
-	if (lookup)
-		return sprintf(buf, " D");
-
-	word = LU_ID_OFFS / DWORD_LEN;
-	lookup = te->sram.word[word] >> (LU_ID_OFFS % DWORD_LEN);
-	lookup &= LU_MASK;
-
-	return sprintf(buf, " %d", lookup);
-}
-
-int tpm_print_sram_next_lookup_shift(struct tcam_entry *te, char *buf)
-{
-	unsigned int word, value;
-
-	word = NEXT_LU_SHIFT_OFFS / DWORD_LEN;
-	value = te->sram.word[word] >> (NEXT_LU_SHIFT_OFFS % DWORD_LEN);
-	value &= SHIFT_IDX_MASK;
-
-	if (value)
-		return sprintf(buf, " %1d", value);
-
-	return sprintf(buf, " -");
-}
-
-int tpm_print_sram_shift_update(struct tcam_entry *te, char *buf)
-{
-	unsigned int word;
-	unsigned int index;
-	unsigned int value;
-
-	word = SHIFT_VAL_OFFS / DWORD_LEN;
-	value = te->sram.word[word] >> (SHIFT_VAL_OFFS % DWORD_LEN);
-	value &= SHIFT_VAL_MASK;
-
-	word = SHIFT_IDX_OFFS / DWORD_LEN;
-	index = te->sram.word[word] >> (SHIFT_IDX_OFFS % DWORD_LEN);
-	index &= SHIFT_IDX_MASK;
-
-	if (value)
-		return sprintf(buf, " [%2.2d]=%3.3d", index, value);
-
-	return sprintf(buf, " [ 0]= 0");
-}
-
-int tpm_print_sram_rxq(struct tcam_entry *te, char *buf)
-{
-	unsigned int rxq, force;
-
-	rxq = sram_sw_get_rxq(te, &force);
-	if (rxq)
-		return sprintf(buf, " %1.1sQ%1.1d", force ? "f" : " ", rxq);
-
-	return sprintf(buf, " ---");
-}
-
-int tpm_print_sram_ainfo(struct tcam_entry *te, char *buf)
-{
-	unsigned int word, shift, data, mask;
-	int i, off = 0;
-
-	word = AI_VALUE_OFFS / DWORD_LEN;
-	shift = AI_VALUE_OFFS % DWORD_LEN;
-	data = ((te->sram.word[word] >> shift) & AI_MASK);
-	shift = AI_MASK_OFFS % DWORD_LEN;
-	mask = ((te->sram.word[word] >> shift) & AI_MASK);
-
-	if (mask) {
-		for (i = 0; i < AI_BITS; i++) {
-			if (mask & (1 << i))
-				off += sprintf(buf + off, "%d", ((data & (1 << i)) != 0));
-			else
-				off += sprintf(buf + off, "x");
-		}
-	} else
-		off += sprintf(buf + off, "-------");
-
-	return off;
-}
-
-int tpm_print_tcam_ainfo(struct tcam_entry *te, char *buf)
-{
-	int i, data, mask;
-	int off = 0;
-
-	mask = ((te->mask.u.word[AI_WORD] >> AI_OFFS) & AI_MASK);
-	if (mask == 0)
-		off += sprintf(buf + off, "-------");
-	else {
-		data = ((te->data.u.word[AI_WORD] >> AI_OFFS) & AI_MASK);
-		for (i = 0; i < AI_BITS; i++)
-			if (mask & (1 << i))
-				off += sprintf(buf + off, "%d", ((data & (1 << i)) != 0));
-			else
-				off += sprintf(buf + off, "x");
-	}
-
-	return off;
-}
-
-int tpm_print_tcam_port_mask(unsigned int port_mask, char *buf)
-{
-	int off = 0;
-
-	if (port_mask & 1)
-		off += sprintf(buf + off, "--,");
-	else
-		off += sprintf(buf + off, "P ,");
-
-	if (port_mask & 4)
-		off += sprintf(buf + off, "--,");
-	else
-		off += sprintf(buf + off, "G0,");
-
-	if (port_mask & 0x10)
-		off += sprintf(buf + off, "--");
-	else
-		off += sprintf(buf + off, "G1");
-
-	return off;
-}
-
-int tpm_print_sram_rinfo(struct tcam_entry *te, char *buf, unsigned int buf_len)
-{
-	unsigned int word, shift, rinfo_val, rinfo_mask;
-	int off = 0;
-	int i;
-
-	word = RI_VALUE_OFFS / DWORD_LEN;
-	shift = RI_VALUE_OFFS % DWORD_LEN;
-	rinfo_val = ((te->sram.word[word] >> shift) & RI_MASK);
-
-	word = RI_MASK_OFFS / DWORD_LEN;
-	shift = RI_MASK_OFFS % DWORD_LEN;
-	rinfo_mask = ((te->sram.word[word] >> shift) & RI_MASK);
-	word++;
-	rinfo_mask |= (te->sram.word[word] & 0x3FFFF) << 6;
-
-	if (rinfo_val & 1)
-		/* discard */
-		off += sprintf(buf + off, "DIS ");
-
-	/* L4 */
-	if ((rinfo_val & 0x6) == 0x2)
-		/* UDP */
-		off += sprintf(buf + off, "UDP ");
-	else if ((rinfo_val & 0x6) == 0x6)
-		/* other */
-		off += sprintf(buf + off, "L4-OTH ");
-#if 0
-    this code snippet is ifdefed till mask bits are supported in LSP
-    to refrain from flooding with TCP
-	else if ((rinfo_val & 0x6) == 0x0)
-		/* TCP */
-		off += sprintf(buf + off, "TCP ");
-#endif
-
-	/* L3 */
-	if ((rinfo_val & 0x18) == 0x18)
-		/* IPv4 not fragmented */
-		off += sprintf(buf + off, "IPV4_NF ");
-	else if ((rinfo_val & 0x18) == 0x8)
-		/* IPv6 */
-		off += sprintf(buf + off, "IPV6 ");
-	else if ((rinfo_val & 0x18) == 0x10)
-		/* IPv4 fragmented */
-		off += sprintf(buf + off, "IPV4_FR ");
-#if 0
-    this code snippet is ifdefed till mask bits are supported in LSP
-    to refrain from flooding with L3_OTH
-	else if ((rinfo_val & 0x18) == 0x0)
-		/* other */
-		off += sprintf(buf + off, "L3_OTH ");
-#endif
-
-#if 0
-	/* First fragmented */
-	if (rinfo_val & 0x20)
-		off += sprintf(buf + off, "ff ");
-#endif
-
-	/* Filtering method */
-	if (rinfo_val & 0x1c0)
-		off += sprintf(buf + off, "ERR FM-%d ", (rinfo_val & 0x1c0) >> 6);
-
-	/* packet discard decision */
-	if (rinfo_val & 0x200)
-		off += sprintf(buf + off, "COL ");
-
-#if 0
-	/* TX port */
-	if (rinfo_val & 0x3c00)
-		off += sprintf(buf + off, "txp-%d ", (rinfo_val & 0x3c00) >> 10);
-#endif
-
-	/* Marvell Header */
-	if (rinfo_val & 0x3c000)
-		off += sprintf(buf + off, "MH_REG-%d ", (rinfo_val & 0x3c000) >> 14);
-
-#if 0
-	if (rinfo_val & 0x3c0000)
-		off += sprintf(buf + off, "gen-%d ", (rinfo_val & 0x3c0000) >> 14);
-
-	if (rinfo_val & 0xc00000)
-		off += sprintf(buf + off, "prof-%d ", (rinfo_val & 0xc00000) >> 18);
-#endif
-
-	for (i = off; i < buf_len; i++)
-		off += sprintf(buf + off, " ");
-
-	return off;
-}
-
-int tpm_print_tcam(unsigned int print_index, struct tcam_entry *te, char *buf)
-{
-	unsigned int    *p_data = (unsigned int *)&te->data;
-	unsigned int    *p_sram = (unsigned int *)&te->sram;
-	unsigned int    *p_mask = (unsigned int *)&te->mask;
-	unsigned int    value;
-	unsigned int    mask;
-	unsigned int    off = 0;
-	int             i;
-	unsigned int    port_val, port_mask, lookup_val, lookup_mask;
-	unsigned int    bitmap_mask;
-	unsigned int    shift;
-
-	/* hw entry id */
-	if (print_index)
-		off += sprintf(buf + off, "[%4d]\n", te->ctrl.index);
-
-	/* get LU value/mask */
-	tcam_sw_get_lookup(te, &lookup_val, &lookup_mask);
-
-	/* print the LU value */
-	off += sprintf(buf + off, "    %1.1x ", lookup_val);
-
-	/* print the port */
-	tcam_sw_get_port(te, &port_val, &port_mask);
-	off += tpm_print_tcam_port_mask(port_mask, buf + off);
-	off += sprintf(buf+off, "  ");
-
-	/* print tcam data bits */
-	i = 0;
-	while (i < TCAM_LEN - 1) {
-		value = MV_BYTE_SWAP_32BIT(MV_32BIT_LE_FAST(p_data[i]));
-		mask  = MV_BYTE_SWAP_32BIT(MV_32BIT_LE_FAST(p_mask[i]));
-
-		for (shift = 28, bitmap_mask = 0xf0000000; bitmap_mask; shift -= 4) {
-			if (bitmap_mask & mask)
-				off += sprintf(buf + off, "%1.1x", (bitmap_mask & value) >> shift);
-			else
-				off += sprintf(buf + off, "-");
-			bitmap_mask = bitmap_mask >> 4;
-		}
-		off += sprintf(buf + off, " ");
-		i++;
-	}
-
-	/* print sram next LU */
-	off += tpm_print_sram_next_lookup(te, buf + off);
-
-	/* print sram next LU shift */
-	off += tpm_print_sram_next_lookup_shift(te, buf + off);
-
-	/* print sram next shift update */
-	off += tpm_print_sram_shift_update(te, buf + off);
-
-	/* print sram next RX queue */
-	off += tpm_print_sram_rxq(te, buf + off);
-
-	/* print entry name */
-	if (!strncmp("empty", te->ctrl.text, 5))
-		off += sprintf(buf + off, "                 ");
-	else
-		off += sprintf(buf + off, " %-16s", te->ctrl.text);
-	off += sprintf(buf+off, " ");
-
-	/* print sram aditional info (AI) */
-	off += tpm_print_sram_ainfo(te, buf + off);
-
-	/* print sram flow ID value */
-	off += sprintf(buf + off, " %8.8x", p_sram[0]);
-
-	off += sprintf(buf + off, "\n");
-
-	/* print the LU mask */
-	off += sprintf(buf + off, "    %1.1x ", lookup_mask);
-
-	/* print tcam aditional info (AI) */
-	off += tpm_print_tcam_ainfo(te, buf + off);
-	off += sprintf(buf + off, "   ");
-
-	/* print the tcam mask bits */
-	i = 0;
-	while (i < TCAM_LEN - 1) {
-		mask  = MV_BYTE_SWAP_32BIT(MV_32BIT_LE_FAST(p_mask[i]));
-
-		for (shift = 28, bitmap_mask = 0xf0000000; bitmap_mask; shift -= 4) {
-			if (bitmap_mask & mask)
-				off += sprintf(buf + off, "%1.1x", (bitmap_mask & mask) >> shift);
-			else
-				off += sprintf(buf + off, "-");
-			bitmap_mask = bitmap_mask >> 4;
-		}
-		off += sprintf(buf + off, " ");
-		i++;
-	}
-	off += sprintf(buf + off, " ");
-
-	/* print sram result info */
-	off += tpm_print_sram_rinfo(te, buf + off, 42);
-
-	/* print sram flow ID mask */
-	value = p_sram[1];
-	for (bitmap_mask = 0x80; bitmap_mask; shift--) {
-		if (bitmap_mask & value)
-			off += sprintf(buf + off, "f");
-		else
-			off += sprintf(buf + off, "0");
-		bitmap_mask = bitmap_mask >> 1;
-	}
-
-	off += sprintf(buf + off, "\n");
-
-	return off;
-}
-
-void tpm_print_pnc_field_desc(void)
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    printk("    ------------------------------ T C A M -------------------------  --------------- S R A M ----------------------------\n");
-    printk("    +--- LU ID                                            Shift Update ---+    Entry name ---+    modL [3:0]   GEM [23:12]\n");
-    printk("    | +--- Port/s                                  Next LU Shift reg ---+ |                  |    modM [7:4]   txp [27:24]\n");
-    printk("    | |        +--- words value                             Next LU --+ | |  RxQ -+   +------+    modH [9:8]    +-- FlowID\n");
-    printk("    | |        |                                                      | | |       |   |                +--AI    |\n");
-    printk("    . [.,..,.] [......0 .......1 .......2 .......3 .......4 ......5]  . . [.....] [.] [..............] [.....]  [........]\n");
-    printk("    . [.....]  [......0 .......1 .......2 .......3 .......4 ......5]  [.......................................] [........]\n");
-    printk("    | |                                                            |  |                                        |\n");
-    printk("    | +--- AI                                                      |  |                         FlowID mask ---+\n");
-    printk("    +--- LU ID mask                                  words mask ---+  +--- SRAM RI\n");
-#endif
-}
-
-int tpm_print_pnc(void)
-{
-	int i;
-	struct tcam_entry te;
-
-	memset(buff, 0, sizeof(buff));
-	tpm_print_pnc_field_desc();
-	for (i = 0; i < CONFIG_MV_PNC_TCAM_LINES; i++) {
-		tcam_sw_clear(&te);
-		tcam_hw_read(&te, i);
-		if (te.ctrl.flags & TCAM_F_INV)
-			continue;
-		tpm_print_tcam(1, &te, buff);
-		printk(buff);
-	}
-
-	return 0;
-}
-unsigned int tpm_tcam_hw_hits_hist_print(unsigned int   seq,
-					 unsigned int   shift,
-					 unsigned int   last_val,
-					 unsigned int   new_val,
-					 unsigned int   print_pnc)
-{
-	unsigned int off = 0;
-	unsigned int pnc_new_entry  = (new_val >> shift) & 0x3FF;
-	unsigned int pnc_last_entry = (last_val >> shift) & 0x3FF;
-
-	memset(buff, 0, sizeof(buff));
-
-	off += sprintf(buff + off, "%d - %3.3d", seq, pnc_new_entry);
-	if (pnc_new_entry != 0) {
-		if (pnc_new_entry == pnc_last_entry)
-			off += sprintf(buff + off, " *\n");
-		else
-			off += sprintf(buff + off, "\n");
-
-		if (print_pnc) {
-			struct tcam_entry te;
-
-			tcam_sw_clear(&te);
-			tcam_hw_read(&te, pnc_new_entry);
-			if (!(te.ctrl.flags & TCAM_F_INV))
-				off += tpm_print_tcam(0, &te, buff + off);
-		}
-		if (pnc_new_entry == pnc_last_entry) {
-			printk(buff);
-			return 0;
-		}
-	}
-	off += sprintf(buff + off, "\n");
-	printk(buff);
-
-	return 0;
-}
-
-
-void tpm_tcam_hw_record(int port)
-{
-	MV_REG_WRITE(MV_PNC_HIT_SEQ0_REG, (port << 1) | 1);
-}
-
-
-int tpm_tcam_hw_hits(unsigned int print_pnc)
-{
-	unsigned int            new_val;
-	static unsigned int     last_read[3] = {0, 0, 0};
-
-	printk("seq hit recurring\n");
-	printk("--- --- ---------\n");
-
-	new_val = MV_REG_READ(MV_PNC_HIT_SEQ0_REG);
-	tpm_tcam_hw_hits_hist_print(0, 10, last_read[0], new_val, print_pnc);
-	tpm_tcam_hw_hits_hist_print(1, 20, last_read[0], new_val, print_pnc);
-	last_read[0] = new_val;
-
-	new_val = MV_REG_READ(MV_PNC_HIT_SEQ1_REG);
-	tpm_tcam_hw_hits_hist_print(2,  0, last_read[1], new_val, print_pnc);
-	tpm_tcam_hw_hits_hist_print(3, 10, last_read[1], new_val, print_pnc);
-	tpm_tcam_hw_hits_hist_print(4, 20, last_read[1], new_val, print_pnc);
-	last_read[1] = new_val;
-
-	new_val = MV_REG_READ(MV_PNC_HIT_SEQ2_REG);
-	tpm_tcam_hw_hits_hist_print(5,  0, last_read[2], new_val, print_pnc);
-	tpm_tcam_hw_hits_hist_print(6, 10, last_read[2], new_val, print_pnc);
-	tpm_tcam_hw_hits_hist_print(7, 20, last_read[2], new_val, print_pnc);
-	last_read[2] = new_val;
-
-	return 0;
-}
-
-int tpm_age_pnc_dump(void)
-{
-	unsigned int        tid, reg_val;
-	struct tcam_entry   te;
-	unsigned int        off;
-
-	memset(buff, 0, sizeof(buff));
-
-	for (tid = 0; tid < CONFIG_MV_PNC_TCAM_LINES; tid++) {
-		reg_val = mvPncAgingCntrRead(tid);
-
-		if (!(reg_val & PNC_AGING_CNTR_MASK))
-			continue;
-
-		off = 0;
-		off += sprintf(buff + off, "[%4d]: gr=%d - %10u", tid,
-			       ((reg_val & PNC_AGING_GROUP_ALL_MASK) >> PNC_AGING_GROUP_OFFS),
-			       ((reg_val & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS));
-
-		if (reg_val & PNC_AGING_READ_LU_LOG_MASK)
-			off += sprintf(buff + off, ", LU_READ");
-
-		if (reg_val & PNC_AGING_READ_MU_LOG_MASK)
-			off += sprintf(buff + off, ", MU_READ");
-
-		if (reg_val & PNC_AGING_SKIP_LU_SCAN_MASK)
-			off += sprintf(buff + off, ", LU_SKIP");
-
-		if (reg_val & PNC_AGING_SKIP_MU_SCAN_MASK)
-			off += sprintf(buff + off, ", MU_SKIP");
-
-		off += sprintf(buff + off, "\n");
-		printk(buff);
-
-		tcam_sw_clear(&te);
-		tcam_hw_read(&te, tid);
-
-		if (!(te.ctrl.flags & TCAM_F_INV)) {
-			tpm_print_tcam(0, &te, buff);
-			printk(buff);
-		}
-	}
-
-	return 0;
-}
-
-int tpm_age_pnc_dump_live(void)
-{
-	unsigned int        tid, reg_val;
-	unsigned int        off;
-	struct tcam_entry   te;
-
-	memset(buff, 0, sizeof(buff));
-
-	for (tid = 0; tid < CONFIG_MV_PNC_TCAM_LINES; tid++)
-		tpm_age_first[tid] = mvPncAgingCntrRead(tid);
-
-	msleep(1000);
-
-	for (tid = 0; tid < CONFIG_MV_PNC_TCAM_LINES; tid++) {
-		reg_val = mvPncAgingCntrRead(tid);
-
-		if (!(reg_val & PNC_AGING_CNTR_MASK))
-			continue;
-
-		if (tpm_age_first[tid] == reg_val)
-			continue;
-
-		off = 0;
-		off += sprintf(buff + off, "[%4d]: gr=%d - %10u", tid,
-			       ((reg_val & PNC_AGING_GROUP_ALL_MASK) >> PNC_AGING_GROUP_OFFS),
-			       ((reg_val & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS));
-
-		if (reg_val & PNC_AGING_READ_LU_LOG_MASK)
-			off += sprintf(buff + off, ", LU_READ");
-
-		if (reg_val & PNC_AGING_READ_MU_LOG_MASK)
-			off += sprintf(buff + off, ", MU_READ");
-
-		if (reg_val & PNC_AGING_SKIP_LU_SCAN_MASK)
-			off += sprintf(buff + off, ", LU_SKIP");
-
-		if (reg_val & PNC_AGING_SKIP_MU_SCAN_MASK)
-			off += sprintf(buff + off, ", MU_SKIP");
-
-		off += sprintf(buff + off, "\n");
-		printk(buff);
-
-		tcam_sw_clear(&te);
-		tcam_hw_read(&te, tid);
-
-		if (!(te.ctrl.flags & TCAM_F_INV)) {
-			tpm_print_tcam(0, &te, buff);
-			printk(buff);
-		}
-	}
-	return 0;
-}
-
-void tpm_print_mc_vlan_cfg_head(void)
-{
-	print_horizontal_line(65);
-	printk("=    MC VLAN      MC AI       Port        Mode      UNI MC VLAN =\n");
-	print_horizontal_line(65);
-}
-
-void tpm_print_mc_vlan_cfg(tpm_mc_vid_cfg_t *mc_vid_cfg)
-{
-	int32_t src_port;
-	char *src_port_str = "";
-	char *mc_mode_str  = "";
-
-	for (src_port = 0; src_port < TPM_MAX_NUM_UNI_PORTS; src_port++) {
-		src_port_str = tpm_db_src_port_str[mc_vid_cfg->mc_vid_port_vids[src_port].tpm_src_port];
-		mc_mode_str  = tpm_db_mc_uni_mode_str[mc_vid_cfg->mc_vid_port_vids[src_port].mc_uni_port_mode];
-		printk("=  %11s | %8s |   %4s  |  %11s |", "", "", src_port_str, mc_mode_str);
-
-		if (TPM_MC_UNI_MODE_TRANSLATE == mc_vid_cfg->mc_vid_port_vids[src_port].mc_uni_port_mode)
-			printk("  %4d %4s=\n", mc_vid_cfg->mc_vid_port_vids[src_port].uni_port_vid, "");
-		else
-			printk("%11s=\n", "");
-	}
-	return;
-}
-
-void tpm_print_mc_vlan_cfg_all(void)
-{
-	uint32_t i, rcode;
-	uint32_t ai_bit;
-	uint32_t first_rule = 1;
-
-	tpm_print_mc_vlan_cfg_head();
-	for (i = 0; i < TPM_MC_VID_NUM_MAX; i++) {
-		if (true == tpm_db.mc_vid_port_cfg[i].valid) {
-			if (!first_rule)
-				printk("=--------------|----------|----------|--------------|-----------=\n");
-
-			rcode = tpm_db_mc_vlan_get_ai_bit(tpm_db.mc_vid_port_cfg[i].mc_vid, &ai_bit);
-			if (rcode != TPM_DB_OK) {
-				printk("get DB failed: %d\n", rcode);
-				return;
-			}
-			printk("=     %4d     |    %2x    |%10s|%14s|%11s=\n",
-				tpm_db.mc_vid_port_cfg[i].mc_vid, ai_bit, "", "", "");
-
-			tpm_print_mc_vlan_cfg(&tpm_db.mc_vid_port_cfg[i]);
-			first_rule = 0;
-		}
-	}
-	print_horizontal_line(65);
-
-	return;
-}
-
-void tpm_print_section_free_szie(tpm_api_type_t api_type)
-{
-	int32_t section_free_szie = 0;
-	tpm_error_code_t rcode;
-
-	rcode = tpm_get_section_free_size(api_type, &section_free_szie);
-	if (rcode == TPM_OK)
-		printk("Section free size: %4d\n", section_free_szie);
-
-	return;
-}
-
-void tpm_print_gpon_omci_channel(void)
-{
-	uint32_t is_valid;
-	tpm_gem_port_key_t gem_port = 0;
-	uint32_t cpu_rx_queue;
-	uint32_t cpu_tx_queue = 0;
-	tpm_trg_port_type_t tcont_num;
-	tpm_error_code_t rcode;
-
-	rcode = tpm_omci_get_channel(&is_valid, &gem_port, &cpu_rx_queue, &tcont_num, &cpu_tx_queue);
-	if (rcode == TPM_OK)
-		printk("Valid = %d GEM = %d CPU_RX queue = %d CPU_TX queue = %d Tcont = 0x%4.4x\n",
-		is_valid, gem_port, cpu_rx_queue, cpu_tx_queue, tcont_num);
-
-	return;
-}
-
-void tpm_print_epon_oam_channel(void)
-{
-	uint32_t is_valid;
-	uint32_t cpu_rx_queue;
-	tpm_trg_port_type_t llid_num;
-	tpm_error_code_t rcode;
-
-	rcode = tpm_oam_epon_get_channel(&is_valid, &cpu_rx_queue, &llid_num);
-	if (rcode == TPM_OK)
-		printk("Valid = %d RX queue = %d LLID = 0x%4.4x\n", is_valid, cpu_rx_queue, llid_num);
-
-	return;
-}
-
-void tpm_print_busy_apis(void)
-{
-	tpm_api_type_t i;
-	uint32_t temp_api_busy_rulenums[TPM_MAX_PARALLEL_API_CALLS];
-	uint32_t num_busy, j;
-
-	for (i=0;i<TPM_MAX_API_TYPES;i++) {
-		memset(&temp_api_busy_rulenums[0], 0, sizeof(temp_api_busy_rulenums));
-		tpm_db_get_api_all_busy(i, &num_busy, &temp_api_busy_rulenums[0]);
-		if (num_busy > 0) {
-			printk("%s:\t",api_type_to_str(i));
-			for (j=0;j<num_busy;j++) {
-				printk("%d\t",temp_api_busy_rulenums[j]);
-			}
-			printk("\n");
-		}
-	}
-}
-
-void tpm_print_fc(unsigned int print_only)
-{
-	tpm_fc_info_t   *p_fc_inf = NULL;
-
-	if (print_only == 0) {
-		printk(KERN_INFO "Resetting Flow Control engine statistics\n");
-		tpm_fc_clear_stat();
-	} else if (print_only != 1) {
-		printk(KERN_INFO "UNEXPECTED PARAMETER (%d)\n", print_only);
-		return;
-	}
-
-	tpm_fc_get_info(&p_fc_inf);
-	if (p_fc_inf == NULL) {
-		printk(KERN_INFO "UNEXPECTED ERROR\n");
-		return;
-	}
-
-	//TRC_OUTPUT(0,1);
-
-	printk(KERN_INFO "---------------------------------------------------------------------------------\n");
-	printk(KERN_INFO "FC is %s\n", (tpm_fc_is_running() == MV_TRUE) ? "ENABLED" : "DISABLED");
-	printk(KERN_INFO "The Flow Control engine settings:\n");
-	printk(KERN_INFO "\t Threshold: High = %ld, Low = %ld\n",
-	       (long)p_fc_inf->cfg.thresh_high,
-	       (long)p_fc_inf->cfg.thresh_low);
-	printk(KERN_INFO "\t Port %d, Target port = %d, TX port = %d, TX Queue = %d\n",
-	       p_fc_inf->cfg.port,
-	       p_fc_inf->cfg.tgt_port,
-	       p_fc_inf->cfg.tx_port,
-	       p_fc_inf->cfg.tx_queue);
-	printk(KERN_INFO "\t Queue status is checked every %lld ns\n", ktime_to_ns(p_fc_inf->cfg.hrt_hit_time));
-
-#ifdef TPM_FC_DEBUG
-	printk(KERN_INFO "\n");
-	printk(KERN_INFO "Latched statistics for oneshot counter configured to %d hits\n", p_fc_inf->cfg.oneshot_count);
-	printk(KERN_INFO "\t Total timer hits = %ld, Total late hits = %ld, timer wraprarounds = %ld \n",
-		   (long)p_fc_inf->oneshot_stat.hrt_hits_num,
-		   (long)p_fc_inf->oneshot_stat.hrt_lost_num,
-		   (long)p_fc_inf->oneshot_stat.hrt_wraparound);
-	printk(KERN_INFO "\t Highest \"late than expected\" period = %lld ns\n", p_fc_inf->oneshot_stat.hrt_lost_max_ns);
-	printk(KERN_INFO "\t Number of late hits of \"higher than expected\" period distribution in %%:\n");
-	printk(KERN_INFO "\t >200%%    - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_200_up);
-	printk(KERN_INFO "\t 150-200%% - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_150_200);
-	printk(KERN_INFO "\t 100-150%% - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_100_150);
-	printk(KERN_INFO "\t 50-100%%  - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_50_100);
-	printk(KERN_INFO "\t 25-50%%   - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_25_50);
-	printk(KERN_INFO "\t <25%%     - %lld\n", p_fc_inf->oneshot_stat.hrt_lost_25_less);
-	printk(KERN_INFO "\n");
-
-	printk(KERN_INFO "Full statistics since start/reset\n");
-	printk(KERN_INFO "\t Total timer hits = %ld, Total late hits = %ld, timer wraprarounds = %ld \n",
-	       (long)p_fc_inf->stat.hrt_hits_num,
-	       (long)p_fc_inf->stat.hrt_lost_num,
-	       (long)p_fc_inf->stat.hrt_wraparound);
-	printk(KERN_INFO "\t Highest \"late than expected\" period = %lld ns\n", p_fc_inf->stat.hrt_lost_max_ns);
-	printk(KERN_INFO "\t Number of late hits of \"higher than expected\" period distribution in %%:\n");
-	printk(KERN_INFO "\t >200%%    - %lld\n", p_fc_inf->stat.hrt_lost_200_up);
-	printk(KERN_INFO "\t 150-200%% - %lld\n", p_fc_inf->stat.hrt_lost_150_200);
-	printk(KERN_INFO "\t 100-150%% - %lld\n", p_fc_inf->stat.hrt_lost_100_150);
-	printk(KERN_INFO "\t 50-100%%  - %lld\n", p_fc_inf->stat.hrt_lost_50_100);
-	printk(KERN_INFO "\t 25-50%%   - %lld\n", p_fc_inf->stat.hrt_lost_25_50);
-	printk(KERN_INFO "\t <25%%     - %lld\n", p_fc_inf->stat.hrt_lost_25_less);
-	printk(KERN_INFO "---------------------------------------------------------------------------------\n");
-#endif
-}
-
-void tpm_print_mac_learn_entry_count(void)
-{
-	uint32_t entry_count = 0;
-	tpm_error_code_t rcode;
-
-	rcode = tpm_mac_learn_entry_num_get(&entry_count);
-	if (rcode == TPM_OK)
-		printk("MAC learn entry count: %d\n", entry_count);
-
-	return;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.h
deleted file mode 100644
index 9e7deca..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_print.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_print.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_PRINT_H_
-#define _TPM_PRINT_H_
-
-/********************************************************************************/
-/*                                Print Utils                                   */
-/********************************************************************************/
-#define DB_MAC_STR_LEN      25
-#define DB_IPV4_STR_LEN     17
-#define DB_IPV6_STR_LEN     40
-#define DB_IPV6_ADDR_LEN    16
-#define PRINT_PNC_ENTRY         1
-#define DONT_PRINT_PNC_ENTRY    0
-
-#define BuildEnumString(param) { param, #param"\0" }
-
-typedef struct {
-	int enumPar;
-	char enumString[128];
-} db_enum_string_t;
-
-char *db_mac_to_str(uint8_t *addr, char *str);
-char *db_ipv4_to_str(uint8_t *ipaddr, char *str);
-char *db_ipv6_to_str(uint8_t *ipaddr, char *str);
-
-/* TODO - following functions should use db functions, instead of accessing DB directly */
-void tpm_print_etherports(void);
-void tpm_print_tx_modules(void);
-void tpm_print_rx_modules(void);
-void tpm_print_gmac_config(void);
-void tpm_print_gmac_func(void);
-void tpm_print_igmp(void);
-void tpm_print_misc(void);
-void tpm_print_owners(void);
-void tpm_print_vlan_etype(void);
-void tpm_print_mac_key(tpm_mac_key_t *mac_key);
-void tpm_print_cpu_lpbk_entry(void);
-void tpm_print_tcam_lu_entry(uint32_t owner_id, uint32_t api_group, uint32_t lu_num, uint32_t lu_reset);
-void tpm_print_pnc_all_hit_counters(uint32_t owner_id, tpm_api_type_t api_type, uint32_t high_thresh_pkts,
-				    uint8_t counters_reset, uint16_t valid_counters,
-				    tpm_api_entry_count_t *count_array);
-
-void tpm_print_vlan_key(tpm_vlan_key_t *vlan_key);
-void tpm_print_ipv4_key(tpm_ipv4_acl_key_t *ipv4_key, tpm_ipv4_add_key_t *ipv4_add_key);
-void tpm_print_l2_key(tpm_l2_acl_key_t *l2_key);
-void tpm_print_l3_key(tpm_l3_type_key_t *l3_key);
-
-void tpm_print_valid_api_sections(void);
-void tpm_print_full_api_section(tpm_api_sections_t api_section);
-void tpm_print_pnc_shadow_range(uint32_t valid_only, uint32_t start, uint32_t end);
-void tpm_print_valid_pnc_ranges(void);
-void tpm_print_init_tables(void);
-void tpm_print_api_dump_all(void);
-int tpm_print_pnc(void);
-int  tpm_tcam_hw_hits(unsigned int print_pnc);
-void tpm_tcam_hw_record(int port);
-int  tpm_age_pnc_dump(void);
-int  tpm_age_pnc_dump_live(void);
-void tpm_print_pnc_field_desc(void);
-void tpm_print_mc_vlan_cfg_all(void);
-void tpm_print_section_free_szie(tpm_api_type_t api_type);
-void tpm_print_gpon_omci_channel(void);
-void tpm_print_epon_oam_channel(void);
-void tpm_print_busy_apis(void);
-void tpm_print_fc(unsigned int print_only);
-void tpm_init_eth_cmplx_setup_error_print(uint32_t hwEthCmplx, bool sysfs_call);
-void tpm_print_mac_learn_entry_count(void);
-uint8_t *api_type_to_str(tpm_api_type_t api_type);
-
-
-#endif /* _TPM_PRINT_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_setup.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_setup.c
deleted file mode 100644
index 6e2b416..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_setup.c
+++ /dev/null
@@ -1,932 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*
-#include <stdio.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdbool.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-
-#include "globals.h"
-#include "errorCode.h"
-#include "OsGlueLayer.h"
-*/
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_types.h"
-#include "tpm_internal_types.h"
-#include "tpm_mng_if.h"
-#include "tpm_xml_params.h"
-
-tpm_init_t tpm_setup;
-int tpmDrvFd;
-/*GL_SEMAPHORE_ID tpmApiSemId;*/
-extern int32_t tpm_module_start(tpm_init_t *tpm_init);
-extern char *g_pstr_xml_cfg_file;
-
-int32_t tpm_init_pon_type_get_para(void)
-{
-
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_pon_type_param(&(tpm_setup.pon_type));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.pon_type = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_omci_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_omci_etype_param(&(tpm_setup.omci_etype));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.omci_etype = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-#if 0
-int32_t tpm_init_debport_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_debug_port_params(&(tpm_setup.deb_port_valid), &(tpm_setup.deb_port));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	return rc;
-}
-#endif
-
-/* jinghua add for MTU setting */
-int32_t tpm_init_mtu_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_ipv4_mtu_us(&(tpm_setup.mtu_config.ipv4_mtu_us));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv4_mtu_us = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv4_pppoe_mtu_us(&(tpm_setup.mtu_config.ipv4_pppoe_mtu_us));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv4_pppoe_mtu_us = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv6_mtu_us(&(tpm_setup.mtu_config.ipv6_mtu_us));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv6_mtu_us = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv6_pppoe_mtu_us(&(tpm_setup.mtu_config.ipv6_pppoe_mtu_us));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv6_pppoe_mtu_us = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv6_mtu_ds(&(tpm_setup.mtu_config.ipv6_mtu_ds));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv6_mtu_ds = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv4_mtu_ds(&(tpm_setup.mtu_config.ipv4_mtu_ds));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.ipv4_mtu_ds = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_pppoe_add_enable(&(tpm_setup.pppoe_add_enable));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.pppoe_add_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_num_vlan_tags(&(tpm_setup.num_vlan_tags));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.num_vlan_tags = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_mtu_enable(&(tpm_setup.mtu_config.mtu_enable));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mtu_config.mtu_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_cpu_rx_queue(&(tpm_setup.cpu_rx_queue));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.cpu_rx_queue = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ttl_illegal_action(&(tpm_setup.ttl_illegal_action));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ttl_illegal_action = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_tcp_flag_check(&(tpm_setup.tcp_flag_check));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.tcp_flag_check = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_igmp_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-	tpm_src_port_type_t src_port;
-	uint32_t mode;
-
-	app_rc = get_igmp_snoop_params_enable(&(tpm_setup.igmp_snoop));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.igmp_snoop = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_igmp_snoop_params_cpu_queue(&(tpm_setup.igmp_cpu_queue));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.igmp_cpu_queue = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	for (src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_WAN; src_port++) {
-		app_rc = get_igmp_snoop_params_port_frwd_mode(&mode, src_port);
-		if (app_rc == TPM_FAIL)
-			rc = TPM_FAIL;
-		else if (app_rc == TPM_NOT_FOUND)
-			tpm_setup.igmp_pkt_frwd_mod[src_port] = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		else
-			tpm_setup.igmp_pkt_frwd_mod[src_port] = mode;
-	}
-
-	return rc;
-}
-
-int32_t tpm_init_mc_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_mc_filter_mode(&(tpm_setup.mc_setting.filter_mode));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mc_setting.filter_mode = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-/*
-	app_rc = get_igmp_mode(&(tpm_setup.mc_setting.igmp_mode));
-	if (app_rc == TPM_FAIL)
-	{
-	   rc = TPM_FAIL;
-	}
-	else if (app_rc == TPM_NOT_FOUND)
-	{
-	   tpm_setup.mc_setting.igmp_mode = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	}
-*/
-	app_rc = get_mc_per_uni_vlan_xlat(&(tpm_setup.mc_setting.per_uni_vlan_xlat));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mc_setting.per_uni_vlan_xlat = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_mc_pppoe_enable(&(tpm_setup.mc_setting.mc_pppoe_enable));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mc_setting.mc_pppoe_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_mc_queue(&(tpm_setup.mc_setting.mc_hwf_queue), &(tpm_setup.mc_setting.mc_cpu_queue));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.mc_setting.mc_hwf_queue = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		tpm_setup.mc_setting.mc_cpu_queue = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	}
-
-	app_rc = get_ipv4_mc_support(&tpm_setup.mc_setting.ipv4_mc_support);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mc_setting.ipv4_mc_support = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_ipv6_mc_support(&tpm_setup.mc_setting.ipv6_mc_support);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.mc_setting.ipv6_mc_support = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_gmac_conn_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_gmac_conn_params(&(tpm_setup.num_tcont_llid));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.num_tcont_llid = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_eth_cmplx_profile_get_para(void)
-{
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_eth_cmplx_profile_params(&(tpm_setup.eth_cmplx_profile));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.eth_cmplx_profile = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_eth_port_conf_get_para(void)
-{
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_eth_port_conf_params(&(tpm_setup.eth_port_conf[0]), TPM_MAX_NUM_ETH_PORTS);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-	{
-		int32_t i;
-		for (i=0; i < TPM_MAX_NUM_ETH_PORTS; i++){
-			tpm_setup.eth_port_conf[i].valid = TPM_FALSE;
-		}
-	}
-	return rc;
-}
-
-int32_t tpm_init_gmac_port_conf_get_para(void)
-{
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_gmac_port_conf_params(&(tpm_setup.gmac_port_conf[0]), TPM_NUM_GMACS);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-	{
-		int32_t i;
-		for (i=0; i < TPM_NUM_GMACS; i++){
-			tpm_setup.gmac_port_conf[i].valid = TPM_FALSE;
-		}
-	}
-
-	return rc;
-}
-
-int32_t tpm_init_active_wan_get_para(void)
-{
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_active_wan_params(&(tpm_setup.active_wan));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.active_wan = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-int32_t tpm_init_ds_mac_based_trunking_get_para(void)
-{
-	int32_t	rc = TPM_OK;
-	int 	app_rc;
-
-	app_rc = get_ds_mac_based_trunking_enable(&(tpm_setup.ds_mac_based_trunk_enable));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ds_mac_based_trunk_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_gmac_mh_en_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_gmac_mh_en_params(&(tpm_setup.gmac0_mh_en), &(tpm_setup.gmac1_mh_en));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.gmac0_mh_en = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		tpm_setup.gmac1_mh_en = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	}
-	return rc;
-}
-
-int32_t tpm_init_gmac_pool_bufs_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_gmac_pool_bufs_params(&(tpm_setup.gmac_bp_bufs[0]), TPM_MAX_NUM_GMACS);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	return rc;
-}
-
-int32_t tpm_init_gmac_rx_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_gmac_rxq_params(&(tpm_setup.gmac_rx[0]), TPM_MAX_NUM_GMACS, TPM_MAX_NUM_RX_QUEUE);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	return rc;
-}
-
-int32_t tpm_init_gmac_tx_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_gmac_tx_params(&(tpm_setup.gmac_tx[0]), TPM_MAX_NUM_TX_PORTS, TPM_MAX_NUM_TX_QUEUE);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	return rc;
-}
-
-int32_t tpm_init_pnc_config_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_pnc_range_params(&(tpm_setup.pnc_range[0]), TPM_MAX_NUM_RANGES);
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	app_rc = get_catch_all_pkt_action(&(tpm_setup.catch_all_pkt_action));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.catch_all_pkt_action = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_ds_mh_config_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_ds_mh_config_params(&(tpm_setup.ds_mh_set_conf));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ds_mh_set_conf = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_validation_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_validation_enabled_config_params(&(tpm_setup.validation_en));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.validation_en = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_vlan_etypes_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_vlan_mod_vlan_tpid_params(&(tpm_setup.vlan_etypes[0]), TPM_NUM_VLAN_ETYPE_REGS);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.vlan_etypes[0] = 0x8100;
-
-	return rc;
-}
-
-int32_t tpm_init_mod_config_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_modification_params(&(tpm_setup.mod_config));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-
-	app_rc = get_chain_config_params(&(tpm_setup.mod_chain));
-	if (app_rc == TPM_FAIL)
-		rc |= TPM_FAIL;
-
-	return rc;
-}
-
-int32_t tpm_init_cfg_pnc_parse_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_cfg_pnc_parse_param(&(tpm_setup.cfg_pnc_parse));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.cfg_pnc_parse = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_cpu_loopback_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_cpu_loopback_param(&(tpm_setup.cpu_loopback));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.cpu_loopback = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_trace_debug_info_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_trace_debug_info_param(&(tpm_setup.trace_debug_info));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.trace_debug_info = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_vitual_uni_info_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_vitual_uni_enable_params(&(tpm_setup.virt_uni_info.enabled));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.virt_uni_info.enabled = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		tpm_setup.virt_uni_info.uni_port = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		tpm_setup.virt_uni_info.switch_port = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	}
-
-	return rc;
-}
-
-int32_t tpm_init_default_tag_tpid_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-#if 0
-	app_rc = get_default_vlan_tpid_params(&(tpm_setup.vlan1_tpid), &(tpm_setup.vlan2_tpid));
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.vlan1_tpid = 0x8100;
-		tpm_setup.vlan2_tpid = 0x8100;
-	}
-#endif
-
-	app_rc = get_default_vlan_tpid_params(&tpm_setup.tpid_opt.opt_num, tpm_setup.tpid_opt.opt);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.tpid_opt.opt_num = 2;
-
-		tpm_setup.tpid_opt.opt[0].v1_tpid = 0x8100;
-		tpm_setup.tpid_opt.opt[0].v2_tpid = 0x8100;
-
-		tpm_setup.tpid_opt.opt[1].v1_tpid = 0x8100;
-		tpm_setup.tpid_opt.opt[1].v2_tpid = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	}
-
-	return rc;
-}
-
-
-int32_t tpm_init_fc_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_fc_def_params(&tpm_setup.port_fc_conf);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND) {
-		tpm_setup.port_fc_conf.enabled 		= 0;
-		tpm_setup.port_fc_conf.port 		= 1;
-		tpm_setup.port_fc_conf.queue_sample_freq = 1000;
-		tpm_setup.port_fc_conf.tgt_port 	= 1;
-		tpm_setup.port_fc_conf.thresh_high 	= 0xffffffff;
-		tpm_setup.port_fc_conf.thresh_low 	= 0xffffffff;
-		tpm_setup.port_fc_conf.tx_port 		= 1;
-	}
-
-	return rc;
-}
-
-
-int32_t tpm_init_ety_dsa_enable_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_ety_dsa_enable(&tpm_setup.ety_dsa_enable);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ety_dsa_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_ipv6_5t_enable_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_ipv6_5t_enable(&tpm_setup.ipv6_5t_enable);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ipv6_5t_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_split_mod_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_split_mod_enable(&tpm_setup.split_mod_config.split_mod_enable);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.split_mod_config.split_mod_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_split_mot_p_bits(&tpm_setup.split_mod_config.p_bit[0], &tpm_setup.split_mod_config.p_bit_num);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.split_mod_config.p_bit_num = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_split_mod_vlan_num(&tpm_setup.split_mod_config.vlan_num);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.split_mod_config.vlan_num = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	app_rc = get_split_mod_mode(&tpm_setup.split_mod_config.split_mod_mode);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.split_mod_config.split_mod_mode = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_ctc_cm_enable_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_ctc_cm_enable(&tpm_setup.ctc_cm_enable);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ctc_cm_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-
-int32_t tpm_init_ctc_cm_ipv6_parse_window_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-	app_rc = get_ctc_cm_ipv6_parse_window(&tpm_setup.ctc_cm_ipv6_parse_window);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.ctc_cm_ipv6_parse_window = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-int32_t tpm_init_pnc_mac_learn_enable_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_pnc_mac_learn_enable(&tpm_setup.pnc_mac_learn_enable);
-
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.pnc_mac_learn_enable = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	return rc;
-}
-int32_t tpm_init_switch_init_get_para(void)
-{
-	int32_t rc = TPM_OK;
-	int app_rc;
-
-	app_rc = get_switch_init_params(&(tpm_setup.switch_init));
-	if (app_rc == TPM_FAIL)
-		rc = TPM_FAIL;
-	else if (app_rc == TPM_NOT_FOUND)
-		tpm_setup.switch_init = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-	return rc;
-}
-
-/*******************************************************************************
-* module_tpmSetup()
-*
-* DESCRIPTION:
-*
-* INPUTS:
-*
-*
-* OUTPUTS:
-*
-*
-* RETURNS:
-*
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t module_tpmSetup(tpm_setup_t *tpm_initp)
-{
-	int32_t rc;
-
-	if (0 != tpm_initp->xml_file_path[0]) {
-		g_pstr_xml_cfg_file = tpm_initp->xml_file_path;
-		printk(KERN_ERR "ERROR: (%s:%d) change to cfg file path: %s \n", __func__, __LINE__,
-		       g_pstr_xml_cfg_file);
-	} else {
-		printk(KERN_ERR "WARNING: using default (%s:%d) cfg file path: %s \n", __func__, __LINE__,
-		       g_pstr_xml_cfg_file);
-	}
-
-	tpm_init_validation_get_para();
-
-	/* Initialized as sem_full
-	if (osSemCreate(&tpmApiSemId, "/TpmApiSem", 1, SEM_Q_FIFO, TRUE) != IAMBA_OK) {
-		printf("module_tpmSetup: Failed to create TPM API semaphore\n\r");
-		return ERROR;
-	}
-	 */
-
-	tpm_init_pon_type_get_para();
-	tpm_init_vlan_etypes_get_para();
-	tpm_init_vitual_uni_info_get_para();
-	tpm_init_default_tag_tpid_get_para();
-	tpm_init_cfg_pnc_parse_get_para();
-	tpm_init_cpu_loopback_get_para();
-	tpm_init_trace_debug_info_get_para();
-	tpm_init_omci_get_para();
-#if 0
-	tpm_init_debport_get_para();
-#endif
-	tpm_init_igmp_get_para();
-	tpm_init_mc_get_para();
-	/* jinghua add for MTU setting */
-	tpm_init_mtu_get_para();
-	tpm_init_fc_get_para();
-	tpm_init_eth_cmplx_profile_get_para();
-	tpm_init_eth_port_conf_get_para();
-	tpm_init_gmac_port_conf_get_para();
-	tpm_init_active_wan_get_para();
-	tpm_init_gmac_conn_get_para();
-	tpm_init_gmac_rx_get_para();
-	tpm_init_gmac_tx_get_para();
-	tpm_init_gmac_mh_en_get_para();
-	tpm_init_gmac_pool_bufs_para();
-	tpm_init_pnc_config_get_para();
-	tpm_init_ds_mh_config_get_para();
-	tpm_init_mod_config_get_para();
-	tpm_init_ety_dsa_enable_get_para();
-	tpm_init_ipv6_5t_enable_get_para();
-	tpm_init_split_mod_get_para();
-	tpm_init_ctc_cm_enable_get_para();
-	tpm_init_ctc_cm_ipv6_parse_window_get_para();
-	tpm_init_pnc_mac_learn_enable_get_para();
-	tpm_init_switch_init_get_para();
-	tpm_init_ds_mac_based_trunking_get_para();
-
-	free_xml_head_ptr();
-
-	rc = tpm_module_start(&tpm_setup);
-	if (rc != TPM_OK)
-		return (rc);
-
-	return (TPM_OK);
-}
-
-#if 0
-/*******************************************************************************
-* getTpmDrvFd()
-*
-* DESCRIPTION:   Get TPM driver file descriptor
-*
-* INPUTS:
-*
-*
-* OUTPUTS:
-*
-*
-* RETURNS:
-*
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int getTpmDrvFd(void)
-{
-	return (tpmDrvFd);
-}
-
-/*******************************************************************************
-* ponKernelExist()
-*
-* DESCRIPTION:   Verify whether the TPM driver exists
-*
-* INPUTS:
-*
-*
-* OUTPUTS:
-*
-*
-* RETURNS:
-*
-*
-* COMMENTS:
-*
-*******************************************************************************/
-void tpmKernelExist(void)
-{
-	FILE *fptr;
-	uint8_t *filename = "/proc/devices";
-	uint8_t line[120];
-	uint8_t *token;
-	uint8_t *search = " \n\r";
-
-	fptr = fopen(filename, "r");
-	if (fptr == 0) {
-		printf("%s: failed to open %s\n", __func__, filename);
-		return;
-	}
-
-	while (1) {
-		if (fgets(line, sizeof(line), fptr) != 0) {
-			token = strtok(line, search);
-			if (token != NULL) {
-				token = strtok(NULL, search);
-				if (token != NULL) {
-					if (strcmp("tpm", token) == 0) {
-						tpmDrvFd = open("/dev/tpm", O_RDWR);
-						if (tpmDrvFd < 0) {
-							printf("Failed to open /dev/tpm\n\r");
-							return;
-						}
-
-						break;
-					}
-				}
-			}
-		}
-	}
-
-	fclose(fptr);
-}
-
-char *get_TPM_sw_version()
-{
-	return (TPM_SW_VERSION);
-}
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs.h
deleted file mode 100644
index 6c8603a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/*******************************************************************************
-* tpm_print.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_SYSFS_H_
-#define _TPM_SYSFS_H_
-
-int tpm_sysfs_print_init(void);
-int tpm_sysfs_trace_init(void);
-
-#endif /* _TPM_SYSFS_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_print.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_print.c
deleted file mode 100644
index de6ab9a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_print.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-static ssize_t tpm_sysfs_print_help(char *buf)
-{
-	int off = 0;
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-	off += sprintf(buf + off,
-		"cat help                                          - show this help\n");
-	off += sprintf(buf + off,
-		"cat etherports                                    - show TPM DB ethernet port configuration\n");
-	off += sprintf(buf + off, "cat rx_modules                                    - show TPM DB  rx configuration \n");
-	off += sprintf(buf + off,
-		"cat tx_modules                                    - show TPM DB tx modules configuration\n");
-	off += sprintf(buf + off, "cat gmac_cfg                                      - show TPM DB GMAC configuration\n");
-	off += sprintf(buf + off,
-		"cat gmac_func                                     - show TPM DB GMAC function configuration \n");
-	off += sprintf(buf + off, "cat igmp_cfg                                      - show TPM DB IGMP configuration \n");
-	off += sprintf(buf + off,
-		"cat misc_cfg                                      - show TPM DB Misc. configuration \n");
-	off += sprintf(buf + off,
-		"cat vlan_etype                                    - show TPM DB VLAN ethertypes configuration \n");
-	off += sprintf(buf + off,
-		"cat valid_api_section                             - show TPM DB API ranges configuration \n");
-	off += sprintf(buf + off,
-		"cat valid_pnc_range                               - show TPM DB PNC Ranges configuration \n");
-	off += sprintf(buf + off,
-		"cat init_tables                                   - show TPM DB Initialization configuration \n");
-	off += sprintf(buf + off,
-		"cat mtu_cfg                                       - show MTU running configuration \n");
-	off += sprintf(buf + off,
-		"cat tcam_hw_hits                                  - show TCAM HW entries hit table\n");
-	off += sprintf(buf + off,
-		"cat show_omci_channel                             - show gpon OMCI channel info\n");
-	off += sprintf(buf + off,
-		"cat show_oam_channel                              - show epon OAM channel info\n");
-	off += sprintf(buf + off,
-		"cat tcam_hw_hits_dump                             "\
-		"- show TCAM HW entries hit table including per hit TCAM/SRAM data\n");
-	off += sprintf(buf+off,
-		"cat api_dump                                      "
-		"- show TPM DB all API types (l2/l3/ipv4/ipv4mc/ipv6 api's)\n");
-	off += sprintf(buf+off,
-		"cat busy_apis                                      "
-		"- debug info. Show TPM API's that are in an active API call. Should always be empty. \n");
-	off += sprintf(buf + off,
-		"cat show_mac_learn_entry_count                     "
-		"- show MAC learn entry count. \n");
-	off += sprintf(buf + off,
-		 "cat show_fc_config                                - show FC engine configuration/statistics\n");
-	off += sprintf(buf + off,
-		 "echo 0 > show_fc_config                           - clear FC engine statistics\n");
-	off += sprintf(buf + off,
-		"echo section                 > api_section        "
-		"- show TPM DB specific API Section full configuration \n");
-	off += sprintf(buf + off,
-		"echo valid_only st end       > pnc_shadow_range   "
-		"- show TPM DB shadow PNC tables (start_entry, end_entry)\n");
-	off += sprintf(buf + off,
-		"echo <port>                  > tcam_hw_hits       "
-		"- start recording for port (GMAC0-%d GMAC1-%d PONMAC-%d)\n", TPM_ENUM_GMAC_0, TPM_ENUM_GMAC_1, TPM_ENUM_PMAC);
-#else
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __func__);
-#endif
-	return off;
-}
-
-static ssize_t tpm_sysfs_print_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int off = 0;
-	const char *name = attr->attr.name;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (!strcmp(name, "help"))
-		off = tpm_sysfs_print_help(buf);
-	else if (!strcmp(name, "etherports"))
-		tpm_print_etherports();
-	else if (!strcmp(name, "rx_modules"))
-		tpm_print_rx_modules();
-	else if (!strcmp(name, "tx_modules"))
-		tpm_print_tx_modules();
-	else if (!strcmp(name, "gmac_cfg"))
-		tpm_print_gmac_config();
-	else if (!strcmp(name, "gmac_func"))
-		tpm_print_gmac_func();
-	else if (!strcmp(name, "igmp_cfg"))
-		tpm_print_igmp();
-	else if (!strcmp(name, "misc_cfg"))
-		tpm_print_misc();
-	else if (!strcmp(name, "vlan_etype"))
-		tpm_print_vlan_etype();
-	else if (!strcmp(name, "valid_api_section"))
-		tpm_print_valid_api_sections();
-	else if (!strcmp(name, "valid_pnc_range"))
-		tpm_print_valid_pnc_ranges();
-	else if (!strcmp(name, "init_tables"))
-		tpm_print_init_tables();
-	else if (!strcmp(name, "mtu_cfg"))
-		tpm_db_show_mtu_cfg();
-	else if (!strcmp(name, "length_check_range"))
-		tpm_mtu_print_len_chk_range();
-	else if (!strcmp(name, "api_dump"))
-		tpm_print_api_dump_all();
-	else if (!strcmp(name, "pnc_dump"))
-	      tpm_print_pnc();
-	else if (!strcmp(name, "tcam_hw_hits"))
-		return tpm_tcam_hw_hits(DONT_PRINT_PNC_ENTRY);
-	else if (!strcmp(name, "tcam_hw_hits_dump"))
-		return tpm_tcam_hw_hits(PRINT_PNC_ENTRY);
-	else if (!strcmp(name, "age_pnc_dump"))
-		return tpm_age_pnc_dump();
-	else if (!strcmp(name, "age_pnc_dump_live"))
-		return tpm_age_pnc_dump_live();
-	else if (!strcmp(name, "age_pnc_dump_hdrs"))
-		tpm_print_pnc_field_desc();
-	else if (!strcmp(name, "age_dump"))
-		mvPncAgingDump(0);
-	else if (!strcmp(name, "age_dump_all"))
-		mvPncAgingDump(1);
-	else if (!strcmp(name, "mc_vlan_dump"))
-		tpm_print_mc_vlan_cfg_all();
-	else if (!strcmp(name, "show_omci_channel"))
-		tpm_print_gpon_omci_channel();
-	else if (!strcmp(name, "show_oam_channel"))
-		tpm_print_epon_oam_channel();
-	else if (!strcmp(name, "busy_apis"))
-		tpm_print_busy_apis();
-	else if (!strcmp(name, "show_mac_learn_entry_count"))
-		tpm_print_mac_learn_entry_count();
-	else if (!strcmp(name, "show_fc_config"))
-		tpm_print_fc(1);
-	else
-		off = tpm_sysfs_print_help(buf);
-
-	return off;
-}
-
-#if 0				/*Keep as placeholder*/
-static ssize_t tpm_sysfs_print_1_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	unsigned int v;
-	unsigned long flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read input */
-	v = 0;
-
-	sscanf(buf, "%x", &v);
-
-	raw_local_irq_save(flags);
-
-	if (!strcmp(name, "place_holder"))
-		XXXXX(v);
-	else
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-
-	raw_local_irq_restore(flags);
-
-	return len;
-}
-#endif
-
-static ssize_t tpm_sysfs_print_2_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	unsigned int p;
-	/*unsigned long flags;*/
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read input */
-	sscanf(buf, "%d", &p);
-
-	/*raw_local_irq_save(flags);*/
-
-	if (!strcmp(name, "api_section"))
-		tpm_print_full_api_section(p);
-	else if (!strcmp(name, "tcam_hw_hits"))
-		tpm_tcam_hw_record(p);
-	else if (!strcmp(name, "show_fc_config"))
-		tpm_print_fc(p);
-	else
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-
-	/*raw_local_irq_restore(flags);*/
-
-	return len;
-}
-
-static ssize_t tpm_sysfs_print_6_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	unsigned int p, v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0;
-	/*unsigned long flags;*/
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read input */
-	sscanf(buf, "%d %d %d %d %x %x", &p, &v1, &v2, &v3, &v4, &v5);
-
-	/*raw_local_irq_save(flags);*/
-
-	if (!strcmp(name, "pnc_shadow_range"))
-		tpm_print_pnc_shadow_range(p, v1, v2);
-	else
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-
-	/*raw_local_irq_restore(flags);*/
-
-	return len;
-}
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static ssize_t tpm_sysfs_mod2_help(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf + off,
-		"cat help_mod2_print                                           - show this help\n");
-	off += sprintf(buf + off,
-		"cat show_jump_cfg                                             - show jump area configuration\n");
-	off += sprintf(buf + off,
-		"echo chain_type                    > show_chain_cfg           - show chain configuration\n");
-	off += sprintf(buf + off,
-		"     chain_type:                   "
-		"[1-mh|2-mac|3-vlan|4-pppoe|5-l2_main|6-ipv4_napt|7-ipv4_mc|8-route]\n");
-	off += sprintf(buf + off,
-		"echo gmac_port                     > show_jump_pmt_entries    - show the pmt entries of gmac port\n");
-	off += sprintf(buf + off, "     gmac_port :                   [0-2]\n");
-	off += sprintf(buf + off,
-		"echo gmac_port chain_type          > show_chain_pmt_entries   - show the pmt entries of gmac port\n");
-	off += sprintf(buf + off, "     gmac_port :                   [0-2]\n");
-	off += sprintf(buf + off,
-		"     chain_type:                   "
-		"[0-all|1-mh|2-mac|3-vlan|4-pppoe|5-l2_main|6-ipv4_napt|7-ipv4_mc|8-route]\n");
-	off += sprintf(buf + off,
-		"echo gmac_port chain_type chain_id > show_chain_db_entry      - show one chain data base entry\n");
-	off += sprintf(buf + off, "     gmac_port :                   [0-2]\n");
-	off += sprintf(buf + off,
-		"     chain_type:                   "
-		"[1-mh|2-mac|3-vlan|4-pppoe|5-l2_main|6-ipv4_napt|7-ipv4_mc|8-route]\n");
-	off += sprintf(buf + off, "     chain_id  :                   chain index\n");
-	off += sprintf(buf + off,
-		"echo gmac_port chain_type          > show_chain_db            "
-		"- show all the chain database entries of one chain type\n");
-	off += sprintf(buf + off, "     gmac_port :                   [0-2]\n");
-	off += sprintf(buf + off,
-		"     chain_type:                   "
-		"[1-mh|2-mac|3-vlan|4-pppoe|5-l2_main|6-ipv4_napt|7-ipv4_mc|8-route]\n");
-	off += sprintf(buf + off,
-		"echo gmac_port                     > show_all_chain           "
-		"- show all the chain database entries\n");
-	off += sprintf(buf + off, "     gmac_port :                   [0-2]\n");
-	off += sprintf(buf + off,
-		"echo api_type                      > show_section_free_size   "
-		"- show specific API Section free size \n");
-	off += sprintf(buf + off,
-		"     api_type:                   "
-		"  [0-mgmt|1-cpu_lpk|2-l2|3-l3|4-ipv4|5-ipv4_mc|6-ipv6_gen|7-ipv6_dip|8-ipv6_nh|9-ipv6_l4]\n");
-
-	return off;
-}
-
-static ssize_t tpm_sysfs_mod2_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int off = 0;
-	const char *name = attr->attr.name;
-
-	if (!strcmp(name, "show_jump_cfg"))
-		tpm_db_mod2_show_jump_cfg_data();
-	else
-		off = tpm_sysfs_mod2_help(buf);
-
-	return off;
-}
-#else
-static ssize_t tpm_sysfs_mod2_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __func__);
-	return 0;
-}
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-static ssize_t tpm_sysfs_mod2_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	uint8_t arg_num;
-	uint32_t v1, v2, v3;
-
-	if (!strcmp(name, "show_chain_cfg")) {
-		arg_num = sscanf(buf, "%d", &v1);
-		if (arg_num == 1)
-			tpm_db_mod2_show_chain_cfg_data(v1);
-	} else if (!strcmp(name, "show_jump_pmt_entries")) {
-		arg_num = sscanf(buf, "%d", &v1);
-		if (arg_num == 1)
-			tpm_db_mod2_show_jump_pmt_entries(v1);
-	} else if (!strcmp(name, "show_chain_pmt_entries")) {
-		arg_num = sscanf(buf, "%d %d", &v1, &v2);
-		if (arg_num == 2)
-			tpm_db_mod2_show_chain_pmt_entries(v1, v2);
-	} else if (!strcmp(name, "show_chain_db_entry")) {
-		arg_num = sscanf(buf, "%d %d %d", &v1, &v2, &v3);
-		if (arg_num == 3)
-			tpm_db_mod2_show_chain_info_entries(v1, v2, v3);
-	} else if (!strcmp(name, "show_chain_db")) {
-		arg_num = sscanf(buf, "%d %d", &v1, &v2);
-		if (arg_num == 2)
-			tpm_db_mod2_show_chain_info_entries(v1, v2, 0xffff);
-	} else if (!strcmp(name, "show_all_chain")) {
-		arg_num = sscanf(buf, "%d", &v1);
-		if (arg_num == 1)
-			tpm_db_mod2_show_all_chain(v1);
-	} else if (!strcmp(name, "show_section_free_size")) {
-		arg_num = sscanf(buf, "%d", &v1);
-		if (arg_num == 1)
-			tpm_print_section_free_szie(v1);
-	}
-
-	return len;
-}
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help, S_IRUSR, tpm_sysfs_print_show, NULL);
-#endif
-static DEVICE_ATTR(etherports, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(rx_modules, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(tx_modules, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(gmac_cfg, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(gmac_func, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(igmp_cfg, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(misc_cfg, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(vlan_etype, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(valid_api_section, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(valid_pnc_range, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(init_tables, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(mtu_cfg, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(api_dump, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(show_omci_channel, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(show_oam_channel, S_IRUSR, tpm_sysfs_print_show, NULL);
-
-
-static DEVICE_ATTR(length_check_range, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(pnc_dump, S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(tcam_hw_hits,           S_IRUSR | S_IWUSR, tpm_sysfs_print_show, tpm_sysfs_print_2_store);
-static DEVICE_ATTR(tcam_hw_hits_dump,      S_IRUSR | S_IWUSR, tpm_sysfs_print_show, tpm_sysfs_print_2_store);
-static DEVICE_ATTR(age_pnc_dump,           S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(age_pnc_dump_live,      S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(age_pnc_dump_hdrs,      S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(age_dump,               S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(age_dump_all,           S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(mc_vlan_dump,           S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(busy_apis,              S_IRUSR, tpm_sysfs_print_show, NULL);
-static DEVICE_ATTR(show_mac_learn_entry_count, S_IRUSR, tpm_sysfs_print_show, NULL);
-
-static DEVICE_ATTR(api_section, S_IWUSR, tpm_sysfs_print_show, tpm_sysfs_print_2_store);
-static DEVICE_ATTR(pnc_shadow_range, S_IWUSR, tpm_sysfs_print_show, tpm_sysfs_print_6_store);
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help_mod2_print, S_IRUSR, tpm_sysfs_mod2_show, NULL);
-#endif
-static DEVICE_ATTR(show_jump_cfg, S_IRUSR, tpm_sysfs_mod2_show, NULL);
-static DEVICE_ATTR(show_chain_cfg, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_jump_pmt_entries, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_chain_pmt_entries, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_chain_db_entry, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_chain_db, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_all_chain, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-static DEVICE_ATTR(show_section_free_size, S_IWUSR, tpm_sysfs_mod2_show, tpm_sysfs_mod2_store);
-
-static DEVICE_ATTR(show_fc_config,          S_IRUSR | S_IWUSR, tpm_sysfs_print_show, tpm_sysfs_print_2_store);
-
-static struct attribute *tpm_print_attrs[] = {
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-	&dev_attr_help.attr,
-#endif
-	&dev_attr_etherports.attr,
-	&dev_attr_rx_modules.attr,
-	&dev_attr_tx_modules.attr,
-	&dev_attr_gmac_cfg.attr,
-	&dev_attr_gmac_func.attr,
-	&dev_attr_igmp_cfg.attr,
-	&dev_attr_misc_cfg.attr,
-	&dev_attr_vlan_etype.attr,
-	&dev_attr_valid_api_section.attr,
-	&dev_attr_valid_pnc_range.attr,
-	&dev_attr_init_tables.attr,
-	&dev_attr_api_section.attr,
-	&dev_attr_pnc_shadow_range.attr,
-	&dev_attr_mtu_cfg.attr,
-	&dev_attr_length_check_range.attr,
-	&dev_attr_api_dump.attr,
-	&dev_attr_pnc_dump.attr,
-	&dev_attr_tcam_hw_hits.attr,
-	&dev_attr_tcam_hw_hits_dump.attr,
-	&dev_attr_age_pnc_dump.attr,
-	&dev_attr_age_pnc_dump_live.attr,
-	&dev_attr_age_pnc_dump_hdrs.attr,
-	&dev_attr_age_dump.attr,
-	&dev_attr_age_dump_all.attr,
-	&dev_attr_mc_vlan_dump.attr,
-	&dev_attr_show_omci_channel.attr,
-	&dev_attr_show_oam_channel.attr,
-	&dev_attr_busy_apis.attr,
-	&dev_attr_show_mac_learn_entry_count.attr,
-	&dev_attr_show_fc_config.attr,
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-	&dev_attr_help_mod2_print.attr,
-#endif
-	&dev_attr_show_jump_cfg.attr,
-	&dev_attr_show_chain_cfg.attr,
-	&dev_attr_show_jump_pmt_entries.attr,
-	&dev_attr_show_chain_pmt_entries.attr,
-	&dev_attr_show_chain_db_entry.attr,
-	&dev_attr_show_chain_db.attr,
-	&dev_attr_show_all_chain.attr,
-	&dev_attr_show_section_free_size.attr,
-
-	NULL
-};
-
-static struct attribute_group tpm_print_group = {
-	.name = "print",
-	.attrs = tpm_print_attrs,
-};
-
-int tpm_sysfs_print_init(void)
-{
-	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-	if (!pd) {
-		platform_device_register_simple("tpm", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find tpm device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	err = sysfs_create_group(&pd->kobj, &tpm_print_group);
-	if (err) {
-		printk(KERN_ERR "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
-	return err;
-}
-
-/*module_init(xxx); */
-
-MODULE_AUTHOR("Yuval Caduri");
-MODULE_DESCRIPTION("sysfs for TPM Print");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_trace.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_trace.c
deleted file mode 100644
index 0933a4f..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_sysfs_trace.c
+++ /dev/null
@@ -1,211 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-static ssize_t tpm_sysfs_trace_help(char *buf)
-{
-	int off = 0;
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-	off += sprintf(buf + off, "cat help                   - show this help\n");
-	off += sprintf(buf + off, "cat trace                  - show TPM Trace configuration\n");
-	off += sprintf(buf + off,
-		"echo level  > trace_level  - "
-		"Set TPM Global Trace level (0-none, 1-debug, 2-info, 3-warn, 4-err, 5-fatal)\n");
-	off += sprintf(buf + off,
-		"echo mod en > trace_module - Trace en/dis TPM module"
-		"(0-db, 1-pnc_logic, 2-init, 5-proc_logic, 6-cli, 7-pnc_hw, 9-mod)\n");
-#else
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __func__);
-#endif
-	return off;
-}
-
-static ssize_t tpm_sysfs_trace_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int off = 0;
-	const char *name = attr->attr.name;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (!strcmp(name, "trace"))
-		off = tpm_trace_status_print();
-	else
-		off = tpm_sysfs_trace_help(buf);
-
-	return off;
-}
-
-static ssize_t tpm_sysfs_trace_1_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	unsigned int v;
-	/*unsigned long flags;*/
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read input */
-	v = 0;
-
-	sscanf(buf, "%x", &v);
-
-	/*raw_local_irq_save(flags);*/
-
-	if (!strcmp(name, "trace_level"))
-		tpm_trace_set(v);
-	else
-		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-
-	/*raw_local_irq_restore(flags);*/
-
-	return len;
-}
-
-static ssize_t tpm_sysfs_trace_2_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	unsigned int p, v;
-	/*unsigned long flags;*/
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	/* Read input */
-	v = 0;
-	sscanf(buf, "%d %x", &p, &v);
-
-	/*raw_local_irq_save(flags);*/
-
-	if (!strcmp(name, "trace_module"))
-		tpm_trace_module_set(p, v);
-	else
-		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-
-	/*raw_local_irq_restore(flags);*/
-
-	return len;
-}
-
-static DEVICE_ATTR(trace_level, S_IWUSR, tpm_sysfs_trace_show, tpm_sysfs_trace_1_store);
-static DEVICE_ATTR(trace_module, S_IWUSR, tpm_sysfs_trace_show, tpm_sysfs_trace_2_store);
-static DEVICE_ATTR(trace, S_IRUSR, tpm_sysfs_trace_show, NULL);
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help, S_IRUSR, tpm_sysfs_trace_show, NULL);
-#endif
-static struct attribute *tpm_trace_attrs[] = {
-	&dev_attr_trace_level.attr,
-	&dev_attr_trace_module.attr,
-	&dev_attr_trace.attr,
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-	&dev_attr_help.attr,
-#endif
-	NULL
-};
-
-static struct attribute_group tpm_trace_group = {
-	.name = "trace",
-	.attrs = tpm_trace_attrs,
-};
-
-int tpm_sysfs_trace_init(void)
-{
-	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-	if (!pd) {
-		platform_device_register_simple("tpm", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find tpm device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	err = sysfs_create_group(&pd->kobj, &tpm_trace_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
-	return err;
-}
-
-/*module_init(xxx); */
-
-MODULE_AUTHOR("Yuval Caduri");
-MODULE_DESCRIPTION("sysfs for TPM Trace");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.c
deleted file mode 100644
index fae5635..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.c
+++ /dev/null
@@ -1,632 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/*******************************************************************************
-* tpm_tm.c
-*
-*
-*  MODULE : TPM
-*
-*  DESCRIPTION : This file config tpm traffic mng
-*
-*  MODIFICATION HISTORY:
-*           15Aug10   Orenbh - initial version created.
-*
-* FILE REVISION NUMBER:
-*       Revision: 1.1.1.1
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-uint32_t tpm_tm_lan_gmac_get(uint32_t *lan_gmac)
-{
-	int32_t  db_ret;
-	tpm_pnc_trg_t pnc_target;
-
-	db_ret = tpm_db_to_lan_gmac_get(TPM_TRG_PORT_UNI_ANY, &pnc_target);
-	if (db_ret != TPM_DB_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-			"can not get GMAC that works as LAN\n\r");
-		return ERR_GENERAL;
-	}
-	if (pnc_target == TPM_PNC_TRG_GMAC0)
-		*lan_gmac = SW_GMAC_0;
-	else if (pnc_target == TPM_PNC_TRG_GMAC1)
-		*lan_gmac = SW_GMAC_1;
-	else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-			"GMAC works as LAN is not valid: (%d)\n\r", pnc_target);
-		return ERR_GENERAL;
-	}
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "GMAC works as LAN is: (%d)\n\r", *lan_gmac);
-
-	return TPM_OK;
-}
-uint32_t tpm_tm_wan_gmac_get(uint32_t *wan_gmac)
-{
-	tpm_gmacs_enum_t wan_gmac_tmp;
-
-	wan_gmac_tmp = tpm_db_active_wan_get();
-
-	if (wan_gmac_tmp == TPM_ENUM_GMAC_0)
-		*wan_gmac = SW_GMAC_0;
-	else if (wan_gmac_tmp == TPM_ENUM_GMAC_1)
-		*wan_gmac = SW_GMAC_1;
-	else if (wan_gmac_tmp == TPM_ENUM_PMAC)
-		*wan_gmac = PON_PORT;
-	else {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-			"GMAC works as WAN is not valid: (%d)\n\r", wan_gmac_tmp);
-		return ERR_GENERAL;
-	}
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "GMAC works as WAN is: (%d)\n\r", *wan_gmac);
-
-	return TPM_OK;
-}
-/*******************************************************************************
-* tpm_tm_set_wan_egr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per WAN queue.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       sched_ent         - entity for setting the scheduling mode: ex:TPM_TRG_PORT_WAN
-*       sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-*       queue_id          - queue number
-*       wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_egr_queue_sched(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN tpm_pp_sched_type_t sched_mode,
-						IN uint8_t queue_id,
-						IN uint16_t wrr_weight)
-{
-	tpm_error_code_t retVal = TPM_RC_OK;
-	uint32_t i = 0;
-	uint32_t num_tcont_llid = 0;
-	uint32_t wan_gmac = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],sched_ent[%d],sched_mode[%d],"
-		"             queue_id[%d], wrr_weight[%d]\n\r",
-		__func__, owner_id, sched_ent, sched_mode, queue_id, wrr_weight);
-
-	if (queue_id >= TPM_MAX_NUM_TX_QUEUE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: Invalid queue number: owner_id[%d],sched_ent[%d],sched_mode[%d],"
-			"                                    queue_id[%d], wrr_weight[%d]\n\r",
-			__func__, owner_id, sched_ent, sched_mode, queue_id, wrr_weight);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	if ((sched_mode == TPM_PP_SCHED_WRR) && (wrr_weight > TPM_MAX_WRR_WEIGHT)) {
-
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: WRR weight is out of rage: owner_id[%d],sched_mode[%d],"
-			"                                   queue_id[%d], wrr_weight[%d]\n\r",
-			__func__, owner_id, sched_mode, queue_id, wrr_weight);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-	retVal = tpm_tm_wan_gmac_get(&wan_gmac);
-	if (retVal != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	tpm_db_num_tcont_llid_get(&num_tcont_llid);
-	for (i = 0; i < num_tcont_llid; i++) {
-		if (sched_ent & 0x1) {
-			switch (sched_mode) {
-			case TPM_PP_SCHED_STRICT:
-				mvNetaTxqFixPrioSet(wan_gmac, i, queue_id);
-				break;
-
-			case TPM_PP_SCHED_WRR:
-				mvNetaTxqWrrPrioSet(wan_gmac, i, queue_id, wrr_weight);
-				break;
-
-			default:
-				printk(KERN_ERR " Unknown TXQ command \n");
-				return ERR_GENERAL;
-			}
-		}
-		sched_ent = sched_ent >> 1;
-		if (sched_ent == 0)
-			break;
-	}
-	if ((sched_ent != 0) && (i == num_tcont_llid - 1))
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "TCONT doesn't not exist\n");
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s:\n\r", __func__);
-
-	return retVal;
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_egr_queue_sched);
-
-/*******************************************************************************
-* tpm_tm_set_wan_sched_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of upstream traffic.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-*       rate_limit_val    - egress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_sched_egr_rate_lim(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size)
-{
-	uint32_t i = 0;
-	uint32_t num_tcont_llid = 0;
-	uint32_t wan_gmac = 0;
-	uint32_t tpm_ret = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],sched_ent[%d],rate_limit_val[%d], bucket_size[%d]\n\r",
-		__func__, owner_id, sched_ent, rate_limit_val, bucket_size);
-
-	tpm_ret = tpm_tm_wan_gmac_get(&wan_gmac);
-	if (tpm_ret != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	tpm_db_num_tcont_llid_get(&num_tcont_llid);
-	for (i = 0; i < num_tcont_llid; i++) {
-		if (sched_ent & 0x1) {
-
-			if (mvNetaTxpBurstSet(wan_gmac, i, bucket_size) != MV_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-					"==ERROE==%s: Invalid bucket size value: "
-					"owner_id[%d],sched_ent[%d] bucket_size[%d]\n\r",
-					__func__, owner_id, i, bucket_size);
-				return ERR_SW_TM_BUCKET_SIZE_INVALID;
-			}
-			mvNetaTxpRateSet(wan_gmac, i, rate_limit_val);
-		}
-		sched_ent = sched_ent >> 1;
-		if (sched_ent == 0)
-			break;
-	}
-	if ((sched_ent != 0) && (i == num_tcont_llid - 1))
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "TCONT doesn't not exist\n");
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_sched_egr_rate_lim);
-
-/*******************************************************************************
-* tpm_tm_set_wan_queue_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the upstream traffic egress rate limit for a specific
-*                   queue of an upstream scheduling entity.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-*       queue_id          - queue number
-*       rate_limit_val    - egress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_queue_egr_rate_lim(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN uint32_t queue_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size)
-{
-	uint32_t i = 0;
-	uint32_t num_tcont_llid = 0;
-	uint32_t wan_gmac = 0;
-	uint32_t tpm_ret = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],sched_ent[%d],queue_id[%d]"
-		"             rate_limit_val[%d], bucket_size[%d] \n\r",
-		__func__, owner_id, sched_ent, queue_id, rate_limit_val, bucket_size);
-
-	tpm_db_num_tcont_llid_get(&num_tcont_llid);
-
-	if (queue_id >= TPM_MAX_NUM_TX_QUEUE) {
-
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: Invalid queue number: owner_id[%d],sched_ent[%d],queue_id[%d]"
-			"                                   rate_limit_val[%d], bucket_size[%d] \n\r",
-			__func__, owner_id, sched_ent, queue_id, rate_limit_val, bucket_size);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	tpm_ret = tpm_tm_wan_gmac_get(&wan_gmac);
-	if (tpm_ret != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	for (i = 0; i < num_tcont_llid; i++) {
-		if (sched_ent & 0x1) {
-
-			if (mvNetaTxqBurstSet(wan_gmac, i, queue_id, bucket_size) != MV_OK) {
-				TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-					"==ERROE==%s: Invalid bucket size value: owner_id[%d], sched_ent[%d], queue_id[%d]"
-					"             rate_limit_val[%d], bucket_size[%d] \n\r", __func__, owner_id,
-					i, queue_id, rate_limit_val, bucket_size);
-				return ERR_SW_TM_BUCKET_SIZE_INVALID;
-			}
-			mvNetaTxqRateSet(wan_gmac, i, queue_id, rate_limit_val);
-		}
-		sched_ent = sched_ent >> 1;
-		if (sched_ent == 0)
-			break;
-	}
-	if ((sched_ent != 0) && (i == num_tcont_llid - 1))
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "TCONT doesn't not exist\n");
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_queue_egr_rate_lim);
-
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per all downstream traffic from the WAN.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-*       queue_id          - queue number
-*       wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_queue_sched(IN uint32_t owner_id,
-						IN tpm_pp_sched_type_t sched_mode,
-						IN uint8_t queue_id,
-						IN uint16_t wrr_weight)
-{
-	uint32_t tmp_tcont = 0;
-	uint32_t lan_gmac = 0;
-	uint32_t tpm_ret = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],sched_mode[%d],"
-		"             queue_id[%d], wrr_weight[%d]\n\r",
-		__func__, owner_id, sched_mode, queue_id, wrr_weight);
-
-	tpm_ret = tpm_tm_lan_gmac_get(&lan_gmac);
-	if (tpm_ret != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	if (queue_id >= TPM_MAX_NUM_TX_QUEUE) {
-
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: Invalid queue number: owner_id[%d],sched_mode[%d],"
-			"                                   queue_id[%d], wrr_weight[%d]\n\r",
-			__func__, owner_id, sched_mode, queue_id, wrr_weight);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	if ((sched_mode == TPM_PP_SCHED_WRR) && (wrr_weight > TPM_MAX_WRR_WEIGHT)) {
-
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: WRR weight is out of rage: owner_id[%d],sched_mode[%d],"
-			"                                   queue_id[%d], wrr_weight[%d]\n\r",
-			__func__, owner_id, sched_mode, queue_id, wrr_weight);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	switch (sched_mode) {
-	case TPM_PP_SCHED_STRICT:
-		mvNetaTxqFixPrioSet(lan_gmac, tmp_tcont, queue_id);
-		break;
-
-	case TPM_PP_SCHED_WRR:
-		mvNetaTxqWrrPrioSet(lan_gmac, tmp_tcont, queue_id, wrr_weight);
-		break;
-
-	default:
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD," Unknown TXQ command \n");
-		return ERR_GENERAL;
-
-	}
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s:\n\r", __func__);
-
-	return TPM_RC_OK;
-
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_ingr_queue_sched);
-
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the rate limit of all downstream traffic from the WAN.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size)
-{
-	uint32_t tmp_tcont = 0;
-	uint32_t lan_gmac = 0;
-	uint32_t tpm_ret = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],rate_limit_val[%d] bucket_size[%d]\n\r",
-		__func__, owner_id, rate_limit_val, bucket_size);
-
-	tpm_ret = tpm_tm_lan_gmac_get(&lan_gmac);
-	if (tpm_ret != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	if (mvNetaTxpBurstSet(lan_gmac, tmp_tcont, bucket_size) != MV_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-			"==ERROE==%s: Invalid bucket size value: owner_id[%d],rate_limit_val[%d] bucket_size[%d]\n\r",
-			__func__, owner_id, rate_limit_val, bucket_size);
-		return ERR_SW_TM_BUCKET_SIZE_INVALID;
-	}
-
-	mvNetaTxpRateSet(lan_gmac, tmp_tcont, rate_limit_val);
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_ingr_rate_lim);
-
-/*******************************************************************************
-* tpm_tm_set_wan_q_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of a specific queue for
-*                   downstream traffic.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       queue_id          - queue number
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_q_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t queue_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size)
-{
-	uint32_t tmp_tcont = 0;
-	uint32_t lan_gmac = 0;
-	uint32_t tpm_ret = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d], queue_id[%d]"
-		"             rate_limit_val[%d], bucket_size[%d] \n\r",
-		__func__, owner_id, queue_id, rate_limit_val, bucket_size);
-
-	if (queue_id >= TPM_MAX_NUM_TX_QUEUE) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: Invalid queue number: owner_id[%d], queue_id[%d]"
-			"                                   rate_limit_val[%d], bucket_size[%d] \n\r",
-			__func__, owner_id, queue_id, rate_limit_val, bucket_size);
-		return ERR_SW_TM_QUEUE_INVALID;
-	}
-
-	tpm_ret = tpm_tm_lan_gmac_get(&lan_gmac);
-	if (tpm_ret != TPM_OK) {
-		return ERR_SRC_PORT_INVALID;
-	}
-
-	if (mvNetaTxqBurstSet(lan_gmac, tmp_tcont, queue_id, bucket_size) != MV_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROE==%s: Invalid bucket size value: owner_id[%d], queue_id[%d]"
-			"              rate_limit_val[%d], bucket_size[%d] \n\r",
-			__func__, owner_id, queue_id, rate_limit_val, bucket_size);
-		return ERR_SW_TM_BUCKET_SIZE_INVALID;
-	}
-
-	mvNetaTxqRateSet(lan_gmac, tmp_tcont, queue_id, rate_limit_val);
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_tm_set_wan_q_ingr_rate_lim);
-
-/*******************************************************************************
-* tpm_tm_set_gmac0_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the ingress rate limit of US for MC only
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_gmac0_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size)
-{
-	uint32_t tmp_tcont = 0;
-	uint32_t queue_id;
-	tpm_gmacs_enum_t lpk_gmac;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD, "==ENTER==%s: owner_id[%d], rate_limit_val[%d], bucket_size[%d] \n\r",
-		__func__, owner_id, rate_limit_val, bucket_size);
-
-	/*Get Tx queue on loopback gmac*/
-	if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-						   &queue_id,
-						   TPM_GMAC1_QUEUE_DATA_TRAFFIC)) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROR==%s: loopback gmac queue get failed \n\r", __func__);
-		return ERR_GENERAL;
-	}
-
-	if (mvNetaTxqBurstSet((int)lpk_gmac, tmp_tcont, queue_id, bucket_size) != MV_OK) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD,  "==ERROR==%s: Invalid bucket size value: owner_id[%d], queue_id[%d]"
-			"              rate_limit_val[%d], bucket_size[%d] \n\r",
-			__func__, owner_id, queue_id, rate_limit_val, bucket_size);
-		return ERR_SW_TM_BUCKET_SIZE_INVALID;
-	}
-
-	mvNetaTxqRateSet(SW_GMAC_1, tmp_tcont, queue_id, rate_limit_val);
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-
-}
-EXPORT_SYMBOL(tpm_tm_set_gmac0_ingr_rate_lim);
-
-/*******************************************************************************
-* tpm_tm_set_tx_port_rate_lim()
-*
-* DESCRIPTION:      Configures the rate limit of tx port wanted.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       port              - port want to do rate limit
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value, if set 0, use the current bucket size
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_tx_port_rate_lim(IN uint32_t owner_id,
-					     IN uint32_t port,
-					     IN uint32_t rate_limit_val,
-					     IN uint32_t bucket_size)
-{
-	uint32_t tmp_tcont = 0;
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==ENTER==%s: owner_id[%d],port[%d],rate_limit_val[%d] bucket_size[%d]\n\r",
-		__func__, owner_id, port, rate_limit_val, bucket_size);
-
-	if (bucket_size) {
-		if (mvNetaTxpBurstSet(port, tmp_tcont, bucket_size) != MV_OK) {
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD,
-				"==ERROE==%s: Invalid bucket size value: owner_id[%d],rate_limit_val[%d] bucket_size[%d]\n\r",
-				__func__, owner_id, rate_limit_val, bucket_size);
-			return ERR_SW_TM_BUCKET_SIZE_INVALID;
-		}
-	}
-
-	mvNetaTxpRateSet(port, tmp_tcont, rate_limit_val);
-
-	TPM_OS_INFO(TPM_TPM_LOG_MOD,  "==EXIT== %s: \n\r", __func__);
-
-	return TPM_RC_OK;
-}
-EXPORT_SYMBOL(tpm_tm_set_tx_port_rate_lim);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.h
deleted file mode 100644
index 6aae62d..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_tm.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_tm.h
-*
-*
-*  MODULE : TPM
-*
-*  DESCRIPTION : This file config tpm
-*
-*  MODIFICATION HISTORY:
-*           15Aug10   Orenbh  - initial version created.
-*
-* FILE REVISION NUMBER:
-*       Revision: 1.1.1.1
-*******************************************************************************/
-
-#ifndef _TPM_TM_H_
-#define _TPM_TM_H_
-
-#define  IN
-#define  OUT
-
-/*******************************************************************************
-* tpm_tm_set_wan_egr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per WAN queue.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the scheduling mode: ex:TPM_TRG_PORT_WAN
-* sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-* queue_id          - queue number
-* wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_egr_queue_sched(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN tpm_pp_sched_type_t sched_mode,
-						IN uint8_t queue_id,
-						IN uint16_t wrr_weight);
-
-/*******************************************************************************
-* tpm_tm_set_wan_sched_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of upstream traffic.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-* rate_limit_val    - egress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_sched_egr_rate_lim(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_wan_queue_egr_rate_lim()
-*
-* DESCRIPTION:      Configures the upstream traffic egress rate limit for a specific
-*                   queue of an upstream scheduling entity.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_ent         - entity for setting the rate limit: ex:TPM_TRG_PORT_WAN
-* queue_id          - queue number
-* rate_limit_val    - egress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_queue_egr_rate_lim(IN uint32_t owner_id,
-						IN tpm_trg_port_type_t sched_ent,
-						IN uint32_t queue_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size);
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_queue_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per all downstream traffic from the WAN.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* sched_mode        - scheduler mode per port: strict(0) / wrr(1)
-* queue_id          - queue number
-* wrr_weight        - weight value when WRR scheduling (1-256)
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_queue_sched(IN uint32_t owner_id,
-						IN tpm_pp_sched_type_t sched_mode,
-						IN uint8_t queue_id,
-						IN uint16_t wrr_weight);
-
-/*******************************************************************************
-* tpm_tm_set_wan_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the rate limit of all downstream traffic from the WAN.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* rate_limit_val    - ingress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_wan_q_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the egress rate limit of a specific queue for
-*                   downstream traffic.
-*
-* INPUTS:
-* owner_id          - APP owner id  should be used for all API calls.
-* queue_id          - queue number
-* rate_limit_val    - ingress rate limit value
-* bucket_size       - bucket size value
-*
-* OUTPUTS:
-*  None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_wan_q_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t queue_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_gmac0_ingr_rate_lim()
-*
-* DESCRIPTION:      Configures the ingress rate limit of US for MC only
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_gmac0_ingr_rate_lim(IN uint32_t owner_id,
-						IN uint32_t rate_limit_val,
-						IN uint32_t bucket_size);
-
-/*******************************************************************************
-* tpm_tm_set_tx_port_rate_lim()
-*
-* DESCRIPTION:      Configures the rate limit of tx port wanted.
-*
-* INPUTS:
-*       owner_id          - APP owner id  should be used for all API calls.
-*       port              - port want to do rate limit
-*       rate_limit_val    - ingress rate limit value
-*       bucket_size       - bucket size value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success, the function returns TPM_RC_OK. On error different types are returned
-*       according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_tm_set_tx_port_rate_lim(IN uint32_t owner_id,
-					     IN uint32_t port,
-					     IN uint32_t rate_limit_val,
-					     IN uint32_t bucket_size);
-
-#endif /* _TPM_TM_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.c
deleted file mode 100644
index 32bbc80..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/*******************************************************************************
-* tpm_trace.c
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-#define _TPM_TRACE_C_
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-/* Global variables */
-uint32_t tpm_glob_trace = TPM_WARN_TRACE_LEVEL | TPM_ALL_MOD;
-/*uint32_t tpm_glob_trace = TPM_DEBUG_TRACE_LEVEL | TPM_ALL_MOD; */
-
-unsigned long print_wait_time;
-
-/*******************************************************************************
-* tpm_trace_enable_module()
-*
-* DESCRIPTION:      Enables tracing for a TPM module
-*
-* INPUTS:
-* module         - Module to enable tracing for (see tpm_trace.h for list)
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-static tpm_error_code_t tpm_trace_enable_module(uint32_t module)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-
-	if (module == TPM_APPL_MAX_MOD)
-		tpm_glob_trace |= TPM_ALL_MOD; /* TPM trace is enabled for all applications */
-	else {
-		switch (module) {
-		case TPM_APPL_DB_MOD:
-			tpm_glob_trace |= TPM_DB_MOD;
-			break;
-
-		case TPM_APPL_PNCL_MOD:
-			tpm_glob_trace |= TPM_PNCL_MOD;
-			break;
-
-		case TPM_APPL_INIT_MOD:
-			tpm_glob_trace |= TPM_INIT_MOD;
-			break;
-
-		case TPM_APPL_HWM_MOD:
-			tpm_glob_trace |= TPM_HWM_MOD;
-			break;
-
-		case TPM_APPL_MODL_MOD:
-			tpm_glob_trace |= TPM_MODL_MOD;
-			break;
-
-		case TPM_APPL_TPM_LOG_MOD:
-			tpm_glob_trace |= TPM_TPM_LOG_MOD;
-			break;
-
-		case TPM_APPL_CLI_MOD:
-			tpm_glob_trace |= TPM_CLI_MOD;
-			break;
-
-		case TPM_APPL_PNC_HM_MOD:
-			tpm_glob_trace |= TPM_PNC_HM_MOD;
-			break;
-
-		case TPM_APPL_MODZ1_HM_MOD:
-			tpm_glob_trace |= TPM_MODZ1_HM_MOD;
-			break;
-
-		case TPM_APPL_MODZ2_HM_MOD:
-			tpm_glob_trace |= TPM_MODZ2_HM_MOD;
-			break;
-
-		default:
-			rc = ERR_GENERAL;
-			printk(KERN_ERR "Invalid application module - %d\n", module);
-			break;
-		}
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* tpm_trace_disable_module()
-*
-* DESCRIPTION:     Disables tracing for a TPM module
-*
-* INPUTS:
-* module         - Module to disable tracing for (see tpm_trace.h for list)
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-static tpm_error_code_t tpm_trace_disable_module(uint32_t module)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-
-	if (module == TPM_APPL_MAX_MOD)
-		tpm_glob_trace &= ~(TPM_ALL_MOD); /* TPM trace is disabled for all applications */
-	else {
-		switch (module) {
-		case TPM_APPL_DB_MOD:
-			tpm_glob_trace &= ~(TPM_DB_MOD);
-			break;
-
-		case TPM_APPL_PNCL_MOD:
-			tpm_glob_trace &= ~(TPM_PNCL_MOD);
-			break;
-
-		case TPM_APPL_INIT_MOD:
-			tpm_glob_trace &= ~(TPM_INIT_MOD);
-			break;
-
-		case TPM_APPL_HWM_MOD:
-			tpm_glob_trace &= ~(TPM_HWM_MOD);
-			break;
-
-		case TPM_APPL_MODL_MOD:
-			tpm_glob_trace &= ~(TPM_MODL_MOD);
-			break;
-
-		case TPM_APPL_TPM_LOG_MOD:
-			tpm_glob_trace &= ~(TPM_TPM_LOG_MOD);
-			break;
-
-		case TPM_APPL_CLI_MOD:
-			tpm_glob_trace &= ~(TPM_CLI_MOD);
-			break;
-
-		case TPM_APPL_PNC_HM_MOD:
-			tpm_glob_trace &= ~(TPM_PNC_HM_MOD);
-			break;
-
-		case TPM_APPL_MODZ1_HM_MOD:
-			tpm_glob_trace &= ~(TPM_MODZ1_HM_MOD);
-			break;
-
-		case TPM_APPL_MODZ2_HM_MOD:
-			tpm_glob_trace &= ~(TPM_MODZ2_HM_MOD);
-			break;
-
-		default:
-			rc = ERR_GENERAL;
-			printk(KERN_ERR "Invalid application module - %d\n", module);
-			break;
-		}
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* tpm_trace_set()
-*
-* DESCRIPTION:     Disables tracing for a TPM module
-*
-* INPUTS:
-*           level  - trace level
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_trace_set(uint32_t level)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-	uint32_t temp_gl_trace;
-
-	if (level >= TPM_APPL_LEVEL_MAX) {
-		printk(KERN_ERR "Invalid level - %d\n", level);
-		rc = ERR_GENERAL;
-	} else {
-		if (level == TPM_APPL_LEVEL_NONE)
-			tpm_glob_trace &= ~(TPM_ALL_TRACE_LEVEL);
-		else {
-			temp_gl_trace = tpm_glob_trace & TPM_ALL_MOD;
-
-			switch (level) {
-			case TPM_APPL_LEVEL_DEBUG:
-				tpm_glob_trace = temp_gl_trace | TPM_DEBUG_TRACE_LEVEL;
-				break;
-
-			case TPM_APPL_LEVEL_INFO:
-				tpm_glob_trace = temp_gl_trace | TPM_INFO_TRACE_LEVEL;
-				break;
-
-			case TPM_APPL_LEVEL_WARN:
-				tpm_glob_trace = temp_gl_trace | TPM_WARN_TRACE_LEVEL;
-				break;
-
-			case TPM_APPL_LEVEL_ERROR:
-				tpm_glob_trace = temp_gl_trace | TPM_ERROR_TRACE_LEVEL;
-				break;
-
-			case TPM_APPL_LEVEL_FATAL:
-				tpm_glob_trace = temp_gl_trace | TPM_FATAL_TRACE_LEVEL;
-				break;
-			}
-		}
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* tpm_trace_module_set()
-*
-* DESCRIPTION:     Set trace module
-*
-* INPUTS:
-* module         - Module to disable tracing for (see tpm_trace.h for list)
-
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns TPM_DB_OK. On error different types are returned
-* according to the case - see tpm_db_err_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_trace_module_set(uint32_t module, uint32_t en_dis)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-
-	if (en_dis)
-		rc = tpm_trace_enable_module(module);
-	else
-		rc = tpm_trace_disable_module(module);
-
-	return rc;
-}
-
-tpm_error_code_t tpm_trace_status_print(void)
-{
-	tpm_error_code_t rc = TPM_RC_OK;
-	uint16_t module;
-
-	module = tpm_glob_trace & TPM_ALL_MOD;
-
-	printk(KERN_WARNING "===================================\n");
-	printk(KERN_WARNING "Trace levels:\n");
-	printk(KERN_WARNING "===================================\n");
-	printk(KERN_WARNING "Fatal errors                     %s\n", (tpm_glob_trace&TPM_FATAL_MASK) ? "+" : "-");
-	printk(KERN_WARNING "Errors                           %s\n", (tpm_glob_trace&TPM_ERROR_MASK) ? "+" : "-");
-	printk(KERN_WARNING "Warnings                         %s\n", (tpm_glob_trace&TPM_WARN_MASK) ? "+" : "-");
-	printk(KERN_WARNING "Information messages             %s\n", (tpm_glob_trace&TPM_INFO_MASK) ? "+" : "-");
-	printk(KERN_WARNING "Debug messages                   %s\n", (tpm_glob_trace&TPM_DEBUG_MASK) ? "+" : "-");
-	printk(KERN_WARNING "===================================\n");
-	printk(KERN_WARNING "Application modules:\n");
-	printk(KERN_WARNING "===================================\n");
-	printk(KERN_WARNING "DB                               %s\n", (module&TPM_DB_MOD) ? "+" : "-");
-	printk(KERN_WARNING "PNCL                             %s\n", (module&TPM_PNCL_MOD) ? "+" : "-");
-	printk(KERN_WARNING "INIT                             %s\n", (module&TPM_INIT_MOD) ? "+" : "-");
-	printk(KERN_WARNING "HWM                              %s\n", (module&TPM_HWM_MOD) ? "+" : "-");
-	printk(KERN_WARNING "MODL                             %s\n", (module&TPM_MODL_MOD) ? "+" : "-");
-	printk(KERN_WARNING "TPM LOG                          %s\n", (module&TPM_TPM_LOG_MOD) ? "+" : "-");
-	printk(KERN_WARNING "CLI                              %s\n", (module&TPM_CLI_MOD) ? "+" : "-");
-	printk(KERN_WARNING "PNC HM                           %s\n", (module&TPM_PNC_HM_MOD) ? "+" : "-");
-	printk(KERN_WARNING "MODZ1 HM                         %s\n", (module&TPM_MODZ1_HM_MOD) ? "+" : "-");
-	printk(KERN_WARNING "MODZ2 HM                         %s\n", (module&TPM_MODZ2_HM_MOD) ? "+" : "-");
-	printk(KERN_WARNING "===================================\n");
-
-	return rc;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.h
deleted file mode 100644
index 4aab384..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_trace.h
+++ /dev/null
@@ -1,220 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/*******************************************************************************
-* tpm_trace.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager - trace definition.
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.1.1.1
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_TRACE_H_
-#define _TPM_TRACE_H_
-
-#include "mvOs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define GLOB_TRACE      tpm_glob_trace
-
-#define TPM_FATAL_MASK  0x80000000	/*Currently, not used */
-#define TPM_ERROR_MASK  0x40000000
-#define TPM_WARN_MASK   0x20000000
-#define TPM_INFO_MASK   0x10000000
-#define TPM_DEBUG_MASK  0x08000000
-
-#define TPM_FATAL_TRACE_LEVEL   0x80000000	/*Currently, not used */
-#define TPM_ERROR_TRACE_LEVEL   0xC0000000
-#define TPM_WARN_TRACE_LEVEL    0xE0000000
-#define TPM_INFO_TRACE_LEVEL    0xF0000000
-#define TPM_DEBUG_TRACE_LEVEL   0xF8000000
-
-#define TPM_ALL_TRACE_LEVEL     0xFFFF0000
-
-
-#define tpm_printf      printk
-
-#define TPM_DB_MOD          (0x00000001)
-#define TPM_PNCL_MOD        (0x00000002)
-#define TPM_INIT_MOD        (0x00000004)
-#define TPM_HWM_MOD         (0x00000008)
-#define TPM_MODL_MOD        (0x00000010)
-#define TPM_TPM_LOG_MOD     (0x00000020)
-#define TPM_CLI_MOD         (0x00000040)
-#define TPM_PNC_HM_MOD      (0x00000080)
-#define TPM_MODZ1_HM_MOD    (0x00000100)
-#define TPM_MODZ2_HM_MOD    (0x00000200)
-#define TPM_MTU_MOD         (0x00000400)
-#define TPM_CTC_CM_MOD      (0x00000800)
-
-#define TPM_ALL_MOD         (0x0000FFFF)
-
-typedef enum tpm_appl_mod {
-	TPM_APPL_DB_MOD,
-	TPM_APPL_PNCL_MOD,
-	TPM_APPL_INIT_MOD,
-	TPM_APPL_HWM_MOD,
-	TPM_APPL_MODL_MOD,
-	TPM_APPL_TPM_LOG_MOD,
-	TPM_APPL_CLI_MOD,
-	TPM_APPL_PNC_HM_MOD,
-	TPM_APPL_MODZ1_HM_MOD,
-	TPM_APPL_MODZ2_HM_MOD,
-
-	/* TPM_APPL_MAX_MOD must be always last */
-	TPM_APPL_MAX_MOD
-} tpm_appl_mod_t;
-
-typedef enum tpm_appl_level {
-	TPM_APPL_LEVEL_NONE,
-	TPM_APPL_LEVEL_DEBUG,
-	TPM_APPL_LEVEL_INFO,
-	TPM_APPL_LEVEL_WARN,
-	TPM_APPL_LEVEL_ERROR,
-	TPM_APPL_LEVEL_FATAL,
-
-	/* TPM_APPL_LEVEL_MAX must be always last */
-	TPM_APPL_LEVEL_MAX
-} tpm_appl_level_t;
-
-#define TPM_OS_COND_DEBUG(module) if ((module & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE))
-
-#ifdef TPM_PRINT_WAIT  /* See types.h */
-#define TPM_OS_DEBUG(module , format , ...) \
-		{
-			if ((module & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) { \
-				tpm_printf("%s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
-				print_wait_time = (jiffies + 2); \
-				while (jiffies < print_wait_time) \
-					schedule(); \
-			} \
-		}
-#else
-#define TPM_OS_DEBUG(module , format , ...) \
-		{ \
-			if ((module & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) \
-				tpm_printf("%s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
-		}
-#endif
-
-#define TPM_OS_INFO(module , format , ...)  \
-		{ \
-			if ((module & GLOB_TRACE) && (TPM_INFO_MASK & GLOB_TRACE))  \
-				tpm_printf("%s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
-		}
-#define TPM_OS_WARN(module , format , ...)  \
-		{ \
-			if ((module & GLOB_TRACE) && (TPM_WARN_MASK & GLOB_TRACE))  \
-				tpm_printf("(warn)  %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
-		}
-#define TPM_OS_ERROR(module , format , ...) \
-		{ \
-			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
-				tpm_printf("(error) %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
-		}
-#define TPM_OS_FATAL(module , format , ...) \
-		tpm_printf("(fatal) %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__);
-
-#ifdef TPM_PRINT_WAIT
-#define TPM_OS_DEB_WAIT() \
-		{\
-			print_wait_time = (jiffies + 2);\
-			while (jiffies < print_wait_time)\
-				schedule();\
-		}
-#else
-#define TPM_OS_DEB_WAIT()
-#endif
-
-#ifndef _TPM_TRACE_C_
-	extern uint32_t tpm_glob_trace;
-
-	extern unsigned long print_wait_time;
-#endif
-
-/* TODO - Change following  to compilation flags */
-#define TPM_KERNEL_DEBUG
-
-	tpm_error_code_t tpm_trace_status_print(void);
-	tpm_error_code_t tpm_trace_set(uint32_t level);
-	tpm_error_code_t tpm_trace_module_set(uint32_t module, uint32_t flag);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_types.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_types.h
deleted file mode 100644
index 4f85779..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_types.h
+++ /dev/null
@@ -1,1566 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_types.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager - types definition.
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               Revision: 1.4
-*
-*
-*******************************************************************************/
-
-#ifndef _TPM_TYPES_H_
-#define _TPM_TYPES_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/******************************************************************************/
-/********************************** Administrative ****************************/
-/******************************************************************************/
-
-/* API group ownership error codes */
-typedef enum tpm_api_ownership_error {
-	API_OWNERSHIP_SUCCESS,
-	API_OWNERID_UNKNOWN,
-	API_TYPE_UNKNOWN,
-	API_OWNED,
-	API_OWNERSHIP_ERROR
-} tpm_api_ownership_error_t;
-
-
-/* Maximum number of parallel running API calls to a certain API */
-#define TPM_MAX_PARALLEL_API_CALLS	(4)
-
-/******************************************************************************/
-/********************************** Packet Processing *************************/
-/******************************************************************************/
-
-/*************************************/
-/* Packet Processor API Types  *******/
-/*************************************/
-typedef enum {
-	TPM_API_MGMT,
-	TPM_API_MAC_LEARN,
-	TPM_API_DS_LOAD_BALANCE,
-	TPM_API_CPU_LOOPBACK,
-	TPM_API_L2_PRIM,
-	TPM_API_L3_TYPE,
-	TPM_API_IPV4,
-	TPM_API_IPV4_MC,
-	TPM_API_IPV6_NH,
-	TPM_API_IPV6_L4,
-	TPM_API_IPV6_GEN,
-	TPM_API_IPV6_DIP,
-	TPM_API_IPV6_MC,
-	TPM_API_CNM,
-	TPM_API_TYPE_ILLEGAL,
-	TPM_MAX_API_TYPES = TPM_API_TYPE_ILLEGAL
-} tpm_api_type_t;
-
-/*************************************/
-/* Parse fields **********************/
-/* tpm_parse_fields_t bitmap **********/
-/*************************************/
-
-#define     TPM_L2_PARSE_MAC_DA             (0x0001)	/* parsing DEST MAC Address */
-#define     TPM_L2_PARSE_MAC_SA             (0x0002)	/* parsing SRC MAC Address */
-#define     TPM_L2_PARSE_ONE_VLAN_TAG       (0x0004)	/* parsing external VLAN tag */
-#define     TPM_L2_PARSE_TWO_VLAN_TAG       (0x0008)	/* parsing external and inner VLAN tag */
-#define     TPM_L2_PARSE_ETYPE              (0x0010)	/* parsing Ether type */
-#define     TPM_L2_PARSE_PPPOE_SES          (0x0020)	/* parsing PPPOE session */
-#define     TPM_L2_PARSE_PPP_PROT           (0x0040)	/* parsing PPP protocol */
-#define     TPM_L2_PARSE_GEMPORT            (0x0080)	/* parsing the GEM port */
-
-#define     TPM_IPv4_PARSE_SIP              (0x0001)	/* parsing IPv4 Source IP address */
-#define     TPM_IPv4_PARSE_DIP              (0x0002)	/* parsing IPv4 Dest IP address */
-#define     TPM_IPv4_PARSE_DSCP             (0x0004)	/* parsing IPv4 DSCP */
-#define     TPM_IPv4_PARSE_PROTO            (0x0008)	/* parsing IPv4 protocol */
-
-#define     TPM_IPv6_PARSE_SIP              (0x0001)	/* parsing IPv6 Source IP address */
-#define     TPM_IPv6_PARSE_DIP              (0x0002)	/* parsing IPv6 Dest IP address */
-#define     TPM_IPv6_PARSE_DSCP             (0x0004)	/* parsing IPv6 DSCP */
-#define     TPM_IPv6_PARSE_NH               (0x0008)	/* parsing IPv6 next hop */
-#define     TPM_IPv6_PARSE_HOPL             (0x0040)	/* parsing IPv6 hop limit */
-/* for CnM IPv6, there is the possibility that parse_bm has IPv6_HOPL, L4_SRC and L4_DST together,
-   so they can not have the same value, that is the reason HOPL is changed from 0x10 to 0x40, since
-   L4_SRC has 0x10 and L4_DST has 0x20
-*/
-
-/* Both for IPV4 and IPV6 */
-#define     TPM_PARSE_L4_SRC                (0x0010)	/* parsing L4 source port */
-#define     TPM_PARSE_L4_DST                (0x0020)	/* parsing L4 destination port */
-
-typedef uint32_t tpm_parse_fields_t;
-
-/*************************************/
-/* Parse flags ***********************/
-/* tpm_parse_flags_t bitmap **********/
-/*************************************/
-#define     TPM_PARSE_FLAG_TAG1_TRUE        (0x00001)
-#define     TPM_PARSE_FLAG_TAG1_FALSE       (0x00002)
-#define     TPM_PARSE_FLAG_TAG1_DC          (0x0)
-#define     TPM_PARSE_FLAG_TAG2_TRUE        (0x00004)
-#define     TPM_PARSE_FLAG_TAG2_FALSE       (0x00008)
-#define     TPM_PARSE_FLAG_TAG2_DC          (0x0)
-#define     TPM_PARSE_FLAG_MTM_TRUE         (0x00010)
-#define     TPM_PARSE_FLAG_MTM_FALSE        (0x00020)
-#define     TPM_PARSE_FLAG_MTM_DC           (0x0)
-#define     TPM_PARSE_FLAG_TO_CPU_TRUE      (0x00040)
-#define     TPM_PARSE_FLAG_TO_CPU_FALSE     (0x00080)
-#define     TPM_PARSE_FLAG_TO_CPU_DC        (0x0)
-#define     TPM_PARSE_FLAG_L4_UDP           (0x00100)
-#define     TPM_PARSE_FLAG_L4_TCP           (0x00200)
-#define     TPM_PARSE_FLAG_L4_DC            (0x0)
-#define     TPM_PARSE_FLAG_PPPOE_TRUE       (0x00400)
-#define     TPM_PARSE_FLAG_PPPOE_FALSE      (0x00800)
-#define     TPM_PARSE_FLAG_PPPOE_DC         (0x0)
-
-typedef uint32_t tpm_parse_flags_t;
-
-/* Source port - used to specify through which port the packet entered the processor  */
-typedef enum {
-	TPM_SRC_PORT_UNI_0,		/* upstream */
-	TPM_SRC_PORT_UNI_1,		/* upstream */
-	TPM_SRC_PORT_UNI_2,		/* upstream */
-	TPM_SRC_PORT_UNI_3,		/* upstream */
-	TPM_SRC_PORT_UNI_4,		/* upstream */
-	TPM_SRC_PORT_UNI_5,		/* upstream */
-	TPM_SRC_PORT_UNI_6,		/* upstream */
-	TPM_SRC_PORT_UNI_7,		/* upstream */
-	TPM_SRC_PORT_UNI_VIRT,		/* upstream */
-	TPM_SRC_PORT_WAN,		/* downstram */
-	TPM_SRC_PORT_UNI_ANY,		/* upstream - all UNI ports */
-	TPM_SRC_PORT_WAN_OR_LAN,	/* Any Port, currently not supported */
-	TPM_SRC_PORT_ILLEGAL = 0xFF
-} tpm_src_port_type_t;
-
-/* Source Port derivatives : */
-#define     TPM_MAX_NUM_UNI_PORTS           (TPM_SRC_PORT_UNI_VIRT - TPM_SRC_PORT_UNI_0 + 1)
-#define     TPM_MAX_NUM_ETH_PORTS           (1/*wan*/+TPM_MAX_NUM_UNI_PORTS)
-#define     TPM_RATE_LIMIT_MIN_VAL          (64)
-
-/***********************************************/
-/* Target port - bitmap ************************/
-/* Used for forwarding decision making *********/
-/* For EPON/GPON - same bitmap for LLID/TCONTs */
-/***********************************************/
-#define	TPM_TRG_PORT_WAN		(0x00000001)	/* upstream */
-
-#define	TPM_TRG_TCONT_0			(0x00000001)	/* upstream */
-#define	TPM_TRG_TCONT_1			(0x00000002)	/* upstream */
-#define	TPM_TRG_TCONT_2			(0x00000004)	/* upstream */
-#define	TPM_TRG_TCONT_3			(0x00000008)	/* upstream */
-#define	TPM_TRG_TCONT_4			(0x00000010)	/* upstream */
-#define	TPM_TRG_TCONT_5			(0x00000020)	/* upstream */
-#define	TPM_TRG_TCONT_6			(0x00000040)	/* upstream */
-#define	TPM_TRG_TCONT_7			(0x00000080)	/* upstream */
-#define	TPM_TRG_LLID_0 			(0x00000001)	/* upstream */
-#define	TPM_TRG_LLID_1 			(0x00000002)	/* upstream */
-#define	TPM_TRG_LLID_2 			(0x00000004)	/* upstream */
-#define	TPM_TRG_LLID_3 			(0x00000008)	/* upstream */
-#define	TPM_TRG_LLID_4 			(0x00000010)	/* upstream */
-#define	TPM_TRG_LLID_5 			(0x00000020)	/* upstream */
-#define	TPM_TRG_LLID_6 			(0x00000040)	/* upstream */
-#define	TPM_TRG_LLID_7			(0x00000080)	/* upstream */
-#define	TPM_TRG_UNI_0			(0x00000100)	/* downstream */
-#define	TPM_TRG_UNI_1			(0x00000200)	/* downstream */
-#define	TPM_TRG_UNI_2			(0x00000400)	/* downstream */
-#define	TPM_TRG_UNI_3			(0x00000800)	/* downstream */
-#define	TPM_TRG_UNI_4			(0x00001000)	/* downstream */
-#define	TPM_TRG_UNI_5			(0x00002000)	/* downstream */
-#define	TPM_TRG_UNI_6			(0x00004000)	/* downstream */
-#define	TPM_TRG_UNI_7			(0x00008000)	/* downstream */
-#define	TPM_TRG_UNI_VIRT		(0x00010000)	/* downstream */
-
-#define	TPM_TRG_PORT_CPU		(0x00020000)	/* upstream / downstream - CPU port */
-#define	TPM_TRG_PORT_UNI_ANY		(0x00040000)	/* downstream - all UNI ports */
-#define	TPM_TRG_PORT_UNI_CPU_LOOP	(0x00080000)	/* downstream - loop to the CPU port */
-
-#define TPM_TRG_LOAD_BAL                (0x80000000)    /* for 2G DS Load-Balancing,
-							   set target_gmac to GMAC1 */
-
-#define	TPM_TRG_PORT_ILLEGAL		(0xFFFFFFFF)	/* illegal port number value */
-#define	TPM_TRG_UNI_OFFSET		8
-#define	TPM_TRG_UNI_MASK		0x1FF
-
-typedef enum {
-	TPM_DS_TGRT_G0,
-	TPM_DS_TGRT_G1,
-	TPM_DS_TGRT_CPU,
-} tpm_ds_load_balance_tgrt_t;
-
-/* target port type - bitmap */
-typedef uint32_t tpm_trg_port_type_t;	/*ex: TPM_TRG_PORT_WAN or TPM_TRG_TCONT_0 */
-/* YUVAL_NOW - add allowed bitmaps here */
-
-/* GPON GEM port id */
-typedef uint16_t tpm_gem_port_key_t;
-
-/* Structure for packet forwarding decision making */
-typedef struct tpm_pkt_frwd {
-	tpm_trg_port_type_t trg_port;	/* Bitmap of the ports where the packet is targeted */
-					/*(ATTENTION - today only single target port in bm */
-	uint8_t trg_queue;		/* Queue id for the target port. */
-	uint8_t dummy;
-	tpm_gem_port_key_t gem_port;	/* GEM port id. */
-} tpm_pkt_frwd_t;
-
-/* Next Parsing Stage options */
-typedef enum tpm_parse_stage {
-	STAGE_L2_PRIM,
-	STAGE_L3_TYPE,
-	STAGE_IPv4,
-	STAGE_IPv6_GEN,
-	STAGE_IPv6_DIP,
-	STAGE_IPv6_NH,
-	STAGE_IPV6_L4,
-	STAGE_CTC_CM,
-	STAGE_DONE
-} tpm_parse_stage_t;
-
-/*************************************/
-/* Classifying flags rules - bitmap **/
-/* tpm_pkt_action_t bitmap **********/
-/*************************************/
-#define     TPM_ACTION_DROP_PK              (0x001)	/* drop packet */
-#define     TPM_ACTION_SET_TARGET_PORT      (0x002)	/* set forwarding dest Tx_port(GPON:+GemPort) */
-#define     TPM_ACTION_SET_TARGET_QUEUE     (0x004)	/* set forwarding dest Tx_queue */
-#define     TPM_ACTION_SET_PKT_MOD          (0x008)	/* set packet modification command */
-#define     TPM_ACTION_TO_CPU               (0x010)	/* packet should be trapped to CPU */
-#define     TPM_ACTION_MTM                  (0x020)	/* packet is MAC-to-ME */
-#define     TPM_ACTION_CUST_CPU_PKT_PARSE   (0x040)	/* packet should be sent to Customization package */
-#define     TPM_ACTION_SPEC_MC_VID          (0x080)	/* Specific multicast VID  */
-#define     TPM_ACTION_UDP_CHKSUM_CALC      (0x100)	/* UDP Checksum should be updated, due to non-zero udp_checksum */
-
-typedef uint32_t tpm_pkt_action_t;	/*ex: TPM_ACTION_DROP_PK */
-
-/*****************/
-/* Packet Action */
-/*****************/
-typedef struct tpm_rule_action {
-	tpm_pkt_action_t pkt_act;
-	tpm_parse_stage_t next_phase;
-} tpm_rule_action_t;
-
-/******************* Packet fields modification command bitmap ***************/
-#define    TPM_MH_SET                       0x00001
-#define    TPM_MAC_DA_SET                   0x00002	/*Update the MAC DA Address */
-#define    TPM_MAC_SA_SET                   0x00004	/*Update the MAC SA Address */
-#define    TPM_VLAN_MOD                     0x00008	/*Update the VLAN Tags (add/del/update) */
-#define    TPM_PPPOE_DEL                    0x00010	/*Delete a PPPoE encapsulation */
-#define    TPM_PPPOE_ADD                    0x00020	/*Add a PPPoE encapsulation */
-#define    TPM_DSCP_SET                     0x00040	/* Set the DSCP value */
-#define    TPM_TTL_DEC                      0x00080	/* Decrease the TTL value */
-#define    TPM_IPV4_UPDATE                  0x00100	/*Update the IPv4 Header */
-#define    TPM_IPV4_SRC_SET                 0x00200	/* Set the IPV4 Source Address */
-#define    TPM_IPV4_DST_SET                 0x00400	/* Set the IPV4 Destination Address */
-#define    TPM_IPV6_UPDATE                  0x00800	/* Update the IPv6 Header */
-#define    TPM_HOPLIM_DEC                   0x01000	/* Decrease the Hop Limit value */
-#define    TPM_IPV6_SRC_SET                 0x02000	/* Set the IPV6 Source Address */
-#define    TPM_IPV6_DST_SET                 0x04000	/* Set the IPV6 Destination Address */
-#define    TPM_L4_SRC_SET                   0x08000	/* Set the L4 Source Port (UDP or TCP) */
-#define    TPM_L4_DST_SET                   0x10000	/* Set the L4 Destination Port (UDP or TCP) */
-
-typedef uint32_t tpm_pkt_mod_bm_t;	/*ex: TPM_MAC_DA_SET | TPM_MAC_SA_SET .... */
-#define    TPM_CHAIN_NUM_UNLIMITED          (0x1000)
-
-/* Add. Modification flags, used only for tpm_mod_entry_set API */
-#define     TPM_INT_L4_TCP        (0x0001)
-#define     TPM_INT_L4_UDP        (0x0002)
-#define     TPM_INT_SPLIT_MOD     (0x0004)
-#define     TPM_INT_UDP_CHECKSUM  (0x0008)
-#define     TPM_INT_MC_MOD        (0x0010)
-
-typedef uint32_t tpm_pkt_mod_int_bm_t;  /*ex: TPM_INT_L4_TCP | TPM_INT_L4_UDP ....*/
-
-/****************************************************************/
-/*          L2/L3 ACL rule related structures                   */
-/****************************************************************/
-
-/* L2 MAC key structure */
-typedef struct tpm_mac_key {
-	uint8_t mac_da[6];
-	uint8_t mac_da_mask[6];
-	uint8_t mac_sa[6];
-	uint8_t mac_sa_mask[6];
-} tpm_mac_key_t;
-
-/* L2 VLAN key structure */
-typedef struct tpm_vlan_key {
-	uint16_t tpid;
-	uint16_t tpid_mask;
-	uint16_t vid;
-	uint16_t vid_mask;
-	uint8_t cfi;
-	uint8_t cfi_mask;
-	uint8_t pbit;
-	uint8_t pbit_mask;
-} tpm_vlan_key_t;
-
-/* Ethernet type - for example 0x0800 */
-typedef uint16_t tpm_ether_type_key_t;
-
-/* PPP key structure */
-typedef struct tpm_pppoe_key {
-	uint16_t ppp_session;
-	uint16_t ppp_proto;
-} tpm_pppoe_key_t;
-
-/* L2 ACL key structure - for creating a new L2 ACL rule */
-typedef struct tpm_l2_acl_key {
-	tpm_mac_key_t mac;
-	tpm_vlan_key_t vlan1;
-	tpm_vlan_key_t vlan2;
-	tpm_pppoe_key_t pppoe_hdr;
-	tpm_ether_type_key_t ether_type;
-	tpm_gem_port_key_t gem_port;
-} tpm_l2_acl_key_t;
-
-/****************************************************************/
-/*          L3 Type - ACL key structure                         */
-/****************************************************************/
-typedef struct tpm_l3_type_key {
-	tpm_ether_type_key_t ether_type_key;
-	uint16_t dummy;
-	tpm_pppoe_key_t pppoe_key;
-} tpm_l3_type_key_t;
-
-/****************************************************************/
-/*          IPv4 - ACL key structure                            */
-/****************************************************************/
-typedef struct tpm_ipv4_acl_key {
-	uint8_t ipv4_dscp;
-	uint8_t ipv4_dscp_mask;
-	uint8_t ipv4_proto;
-	uint8_t dummy;
-	uint8_t ipv4_src_ip_add[4];
-	uint8_t ipv4_src_ip_add_mask[4];
-	uint8_t ipv4_dst_ip_add[4];
-	uint8_t ipv4_dst_ip_add_mask[4];
-	uint16_t l4_src_port;
-	uint16_t l4_dst_port;
-} tpm_ipv4_acl_key_t;
-
-/****************************************************************/
-/*          IPv6 - ACL key structure                            */
-/****************************************************************/
-
-typedef enum tpm_nh_iter {
-	NH_ITER_0,
-	NH_ITER_1,
-} tpm_nh_iter_t;
-
-typedef struct tpm_ipv6_gen_acl_key {
-	uint8_t ipv6_dscp;
-	uint8_t ipv6_dscp_mask;
-	uint8_t hop_limit;
-	uint8_t dummy;
-	uint8_t ipv6_src_ip_add[16];
-	uint8_t ipv6_src_ip_add_mask[16];
-} tpm_ipv6_gen_acl_key_t;
-
-typedef struct tpm_ipv6_acl_key {
-	uint8_t ipv6_dscp;
-	uint8_t ipv6_dscp_mask;
-	uint8_t ipv6_next_header;
-	uint8_t ipv6_hoplimit;
-	uint8_t ipv6_src_ip_add[16];
-	uint8_t ipv6_src_ip_add_mask[16];
-	uint8_t ipv6_dst_ip_add[16];
-	uint8_t ipv6_dst_ip_add_mask[16];
-	uint16_t l4_src_port;
-	uint16_t l4_dst_port;
-} tpm_ipv6_acl_key_t;
-
-typedef struct tpm_ipv6_addr_key {
-	uint8_t ipv6_ip_add[16];
-	uint8_t ipv6_ip_add_mask[16];
-} tpm_ipv6_addr_key_t;
-
-typedef struct tpm_l4_ports_key {
-	uint16_t l4_src_port;
-	uint16_t l4_dst_port;
-} tpm_l4_ports_key_t;
-
-/****************************************************************/
-/*          IPV4 Multicast definitions                          */
-/****************************************************************/
-typedef enum {
-	TPM_MC_ALL_CPU_FRWD,
-	TPM_MC_MAC_ONLY_FILTER,
-	TPM_MC_COMBINED_IP_MAC_FILTER,
-	TPM_MC_IP_ONLY_FILTER,
-	TPM_MC_FILTER_MODE_MAX,
-} tpm_mc_filter_mode_t;
-
-typedef enum {
-	TPM_MC_IGMP_SNOOPING,
-	TPM_MC_IGMP_PROXY,
-	TPM_MC_IGMP_MODE_MAX,
-} tpm_mc_igmp_mode_t;
-
-typedef enum tpm_mc_port_mode {
-	TPM_MC_UNI_MODE_EXCLUDE,
-	TPM_MC_UNI_MODE_TRANSPARENT,
-	TPM_MC_UNI_MODE_STRIP,
-	TPM_MC_UNI_MODE_TRANSLATE
-} tpm_mc_port_mode_t;
-
-typedef struct tpm_mc_vid_port_cfg {
-	tpm_src_port_type_t tpm_src_port;
-	tpm_mc_port_mode_t mc_uni_port_mode;
-	uint32_t uni_port_vid;
-} tpm_mc_vid_port_cfg_t;
-
-typedef struct {
-	tpm_mc_vid_port_cfg_t mc_vid_port_vids[TPM_MAX_NUM_UNI_PORTS];
-} tpm_mc_vid_port_vid_set_t;
-
-/* Port IGMP forward mode */
-typedef enum {
-	TPM_IGMP_FRWD_MODE_DROP,
-	TPM_IGMP_FRWD_MODE_FORWARD,
-	TPM_IGMP_FRWD_MODE_SNOOPING,
-} tpm_igmp_frwd_mode_t;
-
-/****************************************************************/
-/*          Packet modification structures                      */
-/****************************************************************/
-
-/* VLAN modification commands */
-typedef enum tpm_vlan_oper {
-	VLANOP_NOOP,	/* no VLAN operation performed */
-	VLANOP_EXT_TAG_MOD,	/* modify external tag */
-	VLANOP_EXT_TAG_DEL,	/* delete external tag */
-	VLANOP_EXT_TAG_INS,	/* insert(prepend) external tag */
-	VLANOP_EXT_TAG_MOD_INS,	/* modify existing external tag and insert(prepend) new tag */
-	VLANOP_INS_2TAG,	/* insert(prepend) 2 new tags */
-	VLANOP_MOD_2TAG,	/* modify 2 tags */
-	VLANOP_SWAP_TAGS,	/* swap internal and external tags */
-	VLANOP_DEL_2TAG,	/* delete 2 existing tags */
-	VLANOP_INT_TAG_MOD,	/* modify existing internal tag */
-	VLANOP_EXT_TAG_DEL_INT_MOD,	/* delete existing external tag and modify internal tag */
-	VLANOP_SPLIT_MOD_PBIT, /* split mod stage 2, only modify p-bit */
-	VLANOP_ILLEGAL,	/* illegal VLAN operation */
-
-	VLANOP_MAX_NUM
-} tpm_vlan_oper_t;
-
-typedef enum tpm_mod_owner {
-	TPM_MOD_OWNER_TPM,
-	TPM_MOD_OWNER_CPU,
-	TPM_MAX_MOD_OWNERS
-} tpm_mod_owner_t;
-
-typedef struct tpm_vlan_mod {
-	tpm_vlan_oper_t vlan_op;	/* Vlan operation/modification command */
-	tpm_vlan_key_t vlan1_out;	/* structure for outer VLAN key */
-	tpm_vlan_key_t vlan2_out;	/* structure for inner VLAN key. */
-} tpm_vlan_mod_t;
-
-typedef struct tpm_pkt_mod {
-	uint16_t mh_mod;
-	tpm_vlan_mod_t vlan_mod;
-	tpm_mac_key_t mac_mod;
-	tpm_pppoe_key_t pppoe_mod;
-	union {
-		tpm_ipv4_acl_key_t ipv4_mod;
-		tpm_ipv6_acl_key_t ipv6_mod;
-	} l3;
-} tpm_pkt_mod_t;
-
-/****************************************************************/
-/*          CPU loopback related structures                     */
-/****************************************************************/
-
-typedef struct {
-	uint32_t in_use;
-	uint32_t trg_port;
-	uint8_t trg_queue;
-	uint16_t gem_port;
-	uint32_t rule_idx;	/* PnC rule index returned when add PnC rule to GMAC0 and mod to PON MAC for CPU loopback */
-	uint32_t mod_idx;	/* Modification index returned when add mod to GMAC1 for CPU loopback */
-} tpm_cpu_loopback_t;
-
-/****************************************************************/
-/*          PnC aging counter structure & defines               */
-/****************************************************************/
-
-typedef struct {
-	uint32_t rule_idx;
-	uint32_t hit_count;
-} tpm_api_entry_count_t;
-
-typedef struct {
-	uint32_t cntr_grp;
-	uint32_t lu_mask;
-} tpm_api_lu_conf_t;
-
-#define TPM_MAX_LU_ENTRY_NUM  (100)	/* Max. allowed returned LU entries in single API call */
-#define TPM_MAX_MOD_RULE_NUM  (32)	/* YUVAL_NOW - add description here */
-#define TPM_MAX_PNC_COUNTER_NUM  (450)  /* Max allowed returned PNC counter entries in single API call
-					   Root cause for not using 512 is 4K copy_to_user limitation  */
-
-/****************************************************************/
-/*          Generic key structure from PnC - for GetNext entry  */
-/****************************************************************/
-
-typedef struct tpm_rule_l2_prim_key {
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_l2_acl_key_t l2_key;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm;
-	tpm_rule_action_t rule_action;
-} tpm_rule_l2_prim_key_t;
-
-typedef struct tpm_rule_l3_type_key {
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_l3_type_key_t l3_key;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_action_t rule_action;
-} tpm_rule_l3_type_key_t;
-
-typedef struct tpm_rule_ipv4_key {
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_ipv4_acl_key_t ipv4_key;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv4_key_t;
-
-typedef struct tpm_rule_ipv4_mc_key {
-	uint32_t stream_num;
-	tpm_mc_igmp_mode_t igmp_mode;
-	uint8_t mc_stream_pppoe;
-	uint16_t vid;
-	uint8_t ipv4_src_add[4];
-	uint8_t ipv4_dest_add[4];
-	uint8_t ignore_ipv4_src;
-	uint16_t dest_queue;
-	tpm_trg_port_type_t dest_port_bm;
-} tpm_rule_ipv4_mc_key_t;
-
-typedef struct tpm_rule_ipv6_mc_key {
-	uint32_t stream_num;
-	tpm_mc_igmp_mode_t igmp_mode;
-	uint8_t mc_stream_pppoe;
-	uint16_t vid;
-	uint8_t ipv6_src_add[16];
-	uint8_t ipv6_dest_add[16];
-	uint8_t ignore_ipv6_src;
-	uint16_t dest_queue;
-	tpm_trg_port_type_t dest_port_bm;
-} tpm_rule_ipv6_mc_key_t;
-
-typedef struct tpm_rule_ipv6_key {
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_src_port_type_t src_port;
-	tpm_ipv6_acl_key_t ipv6_key;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv6_key_t;
-
-typedef struct tpm_rule_ipv6_gen_key {
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_src_port_type_t src_port;
-	tpm_l4_ports_key_t l4_key;
-	tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv6_gen_key_t;
-
-typedef struct tpm_rule_ipv6_dip_key {
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_src_port_type_t src_port;
-	tpm_l4_ports_key_t l4_key;
-	tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-	tpm_ipv6_addr_key_t ipv6_dipkey;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv6_dip_key_t;
-
-typedef struct tpm_rule_ipv6_l4_key {
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_src_port_type_t src_port;
-	tpm_l4_ports_key_t l4_key;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_pkt_mod_bm_t pkt_mod_bm;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv6_l4_key_t;
-
-typedef struct tpm_rule_ipv6_nh_key {
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_nh_iter_t nh_iter;
-	uint32_t nh;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_action_t rule_action;
-} tpm_rule_ipv6_nh_key_t;
-
-typedef struct tpm_rule_cnm_key {
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t l2_parse_rule_bm;
-	tpm_parse_fields_t ipv4_parse_rule_bm;
-	tpm_parse_fields_t ipv6_parse_rule_bm;
-	tpm_l2_acl_key_t l2_key;
-	tpm_ipv4_acl_key_t ipv4_key;
-	tpm_ipv6_acl_key_t ipv6_key;
-	uint32_t pbits;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_pkt_action_t pkt_act;
-} tpm_rule_cnm_key_t;
-
-typedef union tpm_rule_entry {
-	tpm_rule_l2_prim_key_t l2_prim_key;
-	tpm_rule_l3_type_key_t l3_type_key;
-	tpm_rule_ipv4_key_t ipv4_key;
-	tpm_rule_ipv6_key_t ipv6_key;
-	tpm_rule_ipv4_mc_key_t ipv4_mc_key;
-	tpm_rule_ipv6_gen_key_t ipv6_gen_key;
-	tpm_rule_ipv6_mc_key_t ipv6_mc_key;
-	tpm_rule_ipv6_dip_key_t ipv6_dip_key;
-	tpm_rule_ipv6_nh_key_t ipv6_nh_key;
-	tpm_rule_ipv6_l4_key_t ipv6_l4_key;
-	tpm_rule_cnm_key_t cnm_key;
-} tpm_rule_entry_t;
-
-/*MRU type*/
-typedef enum {
-	TPM_NETA_MTU_GMAC0,
-	TPM_NETA_MTU_GMAC1,
-	TPM_NETA_MTU_PONMAC,
-	TPM_NETA_MTU_SWITCH
-} tpm_mru_type_t;
-
-/******************************************************************************/
-/********************************** Switch defs *******************************/
-/******************************************************************************/
-#define MEMBER_EGRESS_UNMODIFIED	0
-#define NOT_A_MEMBER			1
-#define MEMBER_EGRESS_UNTAGGED		2
-#define MEMBER_EGRESS_TAGGED		3
-
-typedef enum {
-	TPM_FLOOD_UNKNOWN_UNICAST,
-	TPM_FLOOD_UNKNOWN_MULTI_BROAD_CAST,
-} tpm_flood_type_t;
-
-/* switch scheduler type */
-typedef enum tpm_sw_sched_type {
-	TPM_SW_SCHED_WRR_ALL_Q,
-	TPM_SW_SCHED_STRICT_Q3_WRR_Q210,
-	TPM_SW_SCHED_STRICT_Q32_WRR_Q10,
-	TPM_SW_SCHED_STRICT_ALL_Q,
-	TPM_SW_SCHED_ILLEGAL
-} tpm_sw_sched_type_t;
-
-/*
-* typedef: enum tpm_phy_speed_t
-*
-* Description: Enumeration of Phy Speed
-*
-* Enumerations:
-*	TPM_PHY_SPEED_10_MBPS   - 10Mbps
-*	TPM_PHY_SPEED_100_MBPS	- 100Mbps
-*	TPM_PHY_SPEED_1000_MBPS - 1000Mbps
-*/
-typedef enum {
-	TPM_PHY_SPEED_10_MBPS,
-	TPM_PHY_SPEED_100_MBPS,
-	TPM_PHY_SPEED_1000_MBPS
-} tpm_phy_speed_t;
-
-/* switch mirror type */
-
-
-/* Switch mirror type
-typedef struct {
-	uint32_t sport;
-	uint32_t dport;
-	tpm_sw_mirror_type_t mode;
-	bool enable;
-} tpm_sw_mirror_t;*/
-
-/*
- *  typedef: enum tpm_limit_mode_t
- *
- *  Description: Enumeration of the port ingress/egress rate limit counting mode.
- *
- *  Enumerations:
- *      TPM_SW_LIMIT_FRAME -
- *                Count the number of frames
- *      TPM_SW_LIMIT_LAYER1 -
- *                Count all Layer 1 bytes:
- *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
- *      TPM_SW_LIMIT_LAYER2 -
- *                Count all Layer 2 bytes: Frame's DA to CRC
- *      TPM_SW_LIMIT_LAYER3 -
- *                Count all Layer 3 bytes:
- *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
- */
-typedef enum {
-	TPM_SW_LIMIT_FRAME = 0,
-	TPM_SW_LIMIT_LAYER1,
-	TPM_SW_LIMIT_LAYER2,
-	TPM_SW_LIMIT_LAYER3
-} tpm_limit_mode_t;
-
-/*
-* typedef: enum tpm_autoneg_mode_t
-*
-* Description: Enumeration of Autonegotiation mode.
-*Auto for both speed and duplex.
-*Auto for speed only and Full duplex.
-*Auto for speed only and Half duplex. (1000Mbps is not supported)
-*Auto for duplex only and speed 1000Mbps.
-*Auto for duplex only and speed 100Mbps.
-*Auto for duplex only and speed 10Mbps.
-*1000Mbps Full duplex.
-*100Mbps Full duplex.
-*100Mbps Half duplex.
-*10Mbps Full duplex.
-*10Mbps Half duplex.
-*/
-typedef enum {
-	TPM_SPEED_AUTO_DUPLEX_AUTO,
-	TPM_SPEED_1000_DUPLEX_AUTO,
-	TPM_SPEED_100_DUPLEX_AUTO,
-	TPM_SPEED_10_DUPLEX_AUTO,
-	TPM_SPEED_AUTO_DUPLEX_FULL,
-	TPM_SPEED_AUTO_DUPLEX_HALF,
-	TPM_SPEED_1000_DUPLEX_FULL,
-	TPM_SPEED_1000_DUPLEX_HALF,
-	TPM_SPEED_100_DUPLEX_FULL,
-	TPM_SPEED_100_DUPLEX_HALF,
-	TPM_SPEED_10_DUPLEX_FULL,
-	TPM_SPEED_10_DUPLEX_HALF
-} tpm_autoneg_mode_t;
-
-/*
-* typedef: enum tpm_phy_loopback_mode_t
-*
-* Description: Enumeration of Phy loopback mode
-*
-* Enumerations:
-	TPM_PHY_INTERNAL_LOOPBACK: internal loopback mode
-	TPM_PHY_EXTERNAL_LOOPBACK:external loopback mode
-*/
-typedef enum {
-	TPM_PHY_INTERNAL_LOOPBACK,
-	TPM_PHY_EXTERNAL_LOOPBACK
-} tpm_phy_loopback_mode_t;
-
-/*
-* typedef: enum tpm_vlan_member_mode_t
-*
-* Description: Enumeration of VLAN member mode
-*
-*/
-typedef enum {
-	TPM_VLAN_EGRESS_UNMODIFIED,
-	TPM_VLAN_NOT_A_MEMBER,
-	TPM_VLAN_EGRESS_UNTAGGED,
-	TPM_VLAN_EGRESS_TAGGED
-} tpm_vlan_member_mode_t;
-
-/* switch mirror type */
-typedef enum {
-	TPM_SW_MIRROR_INGRESS,
-	TPM_SW_MIRROR_EGRESS
-} tpm_sw_mirror_type_t;
-
-/* Switch mirror type */
-typedef struct {
-	uint32_t sport;
-	uint32_t dport;
-	tpm_sw_mirror_type_t mode;
-	bool enable;
-	uint8_t dummy1;
-	uint16_t dummy2;
-} tpm_sw_mirror_t;
-
-/* Switch trunk type */
-typedef struct {
-	uint32_t trunk_id;
-	uint32_t port_mask;
-	uint32_t mask_num;
-	uint32_t trunk_mask;
-} tpm_sw_trunk_t;
-
-/*  typedef: struct tpm_sw_pirl_customer_t*/
-typedef struct {
-	uint32_t ebsLimit;
-	uint32_t cbsLimit;
-	uint32_t bktIncrement;
-	uint32_t bktRateFactor;
-	bool isValid;
-	uint8_t dummy1;
-	uint16_t dummy2;
-} tpm_sw_pirl_customer_t;
-
-/******************* Scheduler definitions *****************************/
-#define     TPM_PP_SCHED_STRICT             (0x001)	/* strict priority */
-#define     TPM_PP_SCHED_WRR                (0x002)	/* WRR - weighted round robin */
-
-/* Packet Processor - scheduler type - bitmap - ex: TPM_PP_SCHED_STRICT | TPM_PP_SCHED_WRR */
-typedef uint32_t tpm_pp_sched_type_t;
-
-/* Ethernet counters 1 */
-typedef struct {
-	uint32_t fcsErrors;
-	uint32_t excessiveCollisionCounter;
-	uint32_t lateCollisionCounter;
-	uint32_t frameTooLongs;
-	uint32_t bufferOverflowsOnReceive;
-	uint32_t bufferOverflowsOnTransmit;
-	uint32_t singleCollisionFrameCounter;
-	uint32_t multipleCollisionsFrameCounter;
-	uint32_t sqeCounter;
-	uint32_t deferredTransmissionCounter;
-	uint32_t internalMacTransmitErrorCounter;
-	uint32_t carrierSenseErrorCounter;
-	uint32_t alignmentErrorCounter;
-	uint32_t internalMacReceiveErrorCounter;
-
-} tpm_swport_pm_1_t;
-
-/* Ethernet counters 3 */
-typedef struct {
-	uint32_t dropEvents;
-	uint32_t octets;
-	uint32_t packets;
-	uint32_t broadcastPackets;
-	uint32_t multicastPackets;
-	uint32_t undersizePackets;
-	uint32_t fragments;
-	uint32_t jabbers;
-	uint32_t packets_64Octets;
-	uint32_t packets_65_127Octets;
-	uint32_t packets_128_255Octets;
-	uint32_t packets_256_511Octets;
-	uint32_t packets_512_1023Octets;
-	uint32_t packets_1024_1518Octets;
-} tpm_swport_pm_3_t;
-
-/*
-  All counter set 3 is used by 88E6093 and 88E6065
-*/
-typedef struct {
-	uint32_t  dropEvents;
-	uint32_t  InGoodOctetsLo;
-	uint32_t  InGoodOctetsHi;
-	uint32_t  InBadOctets;
-	uint32_t  OutFCSErr;
-	uint32_t  InUnicasts;
-	uint32_t  Deferred;
-	uint32_t  InBroadcasts;
-	uint32_t  InMulticasts;
-	uint32_t  Octets64;
-	uint32_t  Octets127;
-	uint32_t  Octets255;
-	uint32_t  Octets511;
-	uint32_t  Octets1023;
-	uint32_t  OctetsMax;
-	uint32_t  OutOctetsLo;
-	uint32_t  OutOctetsHi;
-	uint32_t  OutUnicasts;
-	uint32_t  Excessive;
-	uint32_t  OutMulticasts;
-	uint32_t  OutBroadcasts;
-	uint32_t  Single;
-	uint32_t  OutPause;
-	uint32_t  InPause;
-	uint32_t  Multiple;
-	uint32_t  Undersize;
-	uint32_t  Fragments;
-	uint32_t  Oversize;
-	uint32_t  Jabber;
-	uint32_t  InMACRcvErr;
-	uint32_t  InFCSErr;
-	uint32_t  Collisions;
-	uint32_t  Late;
-
-} tpm_swport_pm_3_all_t;
-
-/******************************************************************************/
-/********************************** Initialisation defs ***********************/
-/******************************************************************************/
-
-#define MV_TPM_UN_INITIALIZED_INIT_PARAM   (0xFFFF)
-
-/* UpStream and DownStream general convention */
-#define TPM_DOWNSTREAM          (0)
-#define TPM_UPSTREAM            (1)
-
-/* Definitions for array sizes */
-#define     TPM_NUM_GMACS                   (3)
-#define     TPM_MAX_NUM_TX_QUEUE            (8)
-#define     TPM_MAX_NUM_RX_QUEUE            (8)
-#define     TPM_MAX_NUM_PORTS               (10)	/* WAN 1 + UNI 0..7 + 1 VIRT_UNI see  tpm_src_port_type_t */
-#define     TPM_NUM_VLAN_ETYPE_REGS         (4)
-#define     TPM_MAX_MOD_CHAIN_NUM           (16)
-#define     TPM_MAX_TPID_COMB_NUM           (16)
-
-typedef enum {
-	TPM_DIR_DS,
-	TPM_DIR_US,
-	TPM_NUM_DIRECTIONS
-} tpm_dir_t;
-
-typedef enum {
-	TPM_PON_WAN_DUAL_MAC_INT_SWITCH = 1,
-	TPM_PON_WAN_G0_INT_SWITCH,
-	TPM_PON_WAN_G1_LAN_G0_INT_SWITCH,
-	TPM_G0_WAN_G1_INT_SWITCH,
-	TPM_G1_WAN_G0_INT_SWITCH,
-	TPM_PON_G1_WAN_G0_INT_SWITCH,
-	TPM_PON_G0_WAN_G1_INT_SWITCH,
-	TPM_PON_WAN_DUAL_MAC_EXT_SWITCH,
-	TPM_PON_WAN_G1_MNG_EXT_SWITCH,
-	TPM_PON_WAN_G0_SINGLE_PORT,
-	TPM_PON_WAN_G1_SINGLE_PORT,
-	TPM_PON_G1_WAN_G0_SINGLE_PORT,
-	TPM_PON_G0_WAN_G1_SINGLE_PORT,
-	TPM_PON_WAN_G0_G1_LPBK,
-	TPM_PON_WAN_G0_G1_DUAL_LAN
-} tpm_eth_complex_profile_t;
-
-typedef enum {
-	TPM_PNC_LAST_ENTRY_INIT_DROP,	/* Last (default) entry in PnC is hardcoded to DROP */
-	TPM_PNC_LAST_ENTRY_INIT_TRAP	/* Last (default) entry in PnC is hardcoded to TRAP to CPU */
-} tpm_init_pnc_last_init_t;
-
-typedef enum {
-	TPM_SCHED_SP,
-	TPM_SCHED_WRR
-} tpm_init_sched_t;
-
-typedef enum {
-	TPM_PORT_DOWN,
-	TPM_PORT_UP
-} tpm_init_port_admin_t;
-
-typedef enum {
-	TPM_SPEED_10M,
-	TPM_SPEED_100M,
-	TPM_SPEED_1G,
-	TPM_SPEED_AUTO
-} tpm_init_port_speed_t;
-
-typedef enum {
-	TPM_DUP_HALF,
-	TPM_DUP_FULL,
-	TPM_DUP_AUTO
-} tpm_init_port_duplex_t;
-
-typedef enum {
-	TPM_CONN_DISC,
-	TPM_CONN_QSGMII,
-	TPM_CONN_FE_PHY,
-	TPM_CONN_GE_PHY,
-	TPM_CONN_RGMII1,
-	TPM_CONN_RGMII2
-} tpm_init_chip_conn_t;
-
-/* Possible internal ethernet connnection devices for an external ethernet port */
-typedef enum {
-	TPM_INTCON_GMAC0,
-	TPM_INTCON_GMAC1,
-	TPM_INTCON_SWITCH
-} tpm_init_int_conn_t;
-
-/* Possible Physical internal connections for a Packet Processor Ethernet GMAC (GMAC0/GMAC1) */
-typedef enum {
-	TPM_GMAC_CON_DISC,	/* Disconnected */
-	TPM_GMAC_CON_QSGMII,	/* Quad SGMII */
-	TPM_GMAC_CON_SWITCH_4,	/* Amber Switch Port #4 */
-	TPM_GMAC_CON_SWITCH_5,	/* Amber Switch Port #5 */
-	TPM_GMAC_CON_SWITCH_6,	/* Amber Switch Port #6 */
-	TPM_GMAC_CON_RGMII1,
-	TPM_GMAC_CON_RGMII2,
-	TPM_GMAC_CON_GE_PHY	/* Internal Gig PHY */
-} tpm_init_gmac_conn_t;
-
-typedef enum {
-	TPM_Q_OWNER_CPU,
-	TPM_Q_OWNER_GMAC0,
-	TPM_Q_OWNER_GMAC1,
-	TPM_Q_OWNER_PMAC,
-	TPM_Q_OWNER_MAX
-} tpm_init_txq_owner_t;
-
-typedef enum {
-	TPM_EPON,
-	TPM_GPON,
-	TPM_P2P,
-	TPM_NONE
-} tpm_init_pon_type_t;
-
-typedef enum {
-	TPM_ACTIVE_WAN,
-	TPM_STNDBY_WAN
-} tpm_init_wan_mode_t;
-
-typedef enum {
-	TPM_TX_MOD_GMAC0,	/* = TPM_ENUM_GMAC_0 */
-	TPM_TX_MOD_GMAC1,	/*= TPM_ENUM_GMAC_1 */
-	TPM_TX_MOD_PMAC_0,	/* = TPM_ENUM_PMAC */
-	TPM_TX_MOD_PMAC_1,
-	TPM_TX_MOD_PMAC_2,
-	TPM_TX_MOD_PMAC_3,
-	TPM_TX_MOD_PMAC_4,
-	TPM_TX_MOD_PMAC_5,
-	TPM_TX_MOD_PMAC_6,
-	TPM_TX_MOD_PMAC_7,
-	TPM_MAX_NUM_TX_PORTS
-} tpm_init_tx_mod_t;
-
-/* Structure holds the physical connections of all external Ethernet ports */
-typedef struct {
-	uint32_t		valid;
-	tpm_init_gmac_conn_t	conn;
-	tpm_src_port_type_t	port_src;
-} tpm_init_gmac_conn_conf_t;
-
-/* Structure holds the BM Pool Buffers for small packets
- * (contribution to shared pool) and large packets(pool per port) */
-typedef struct {
-	uint32_t valid;
-	uint32_t small_pkt_buffers;	/* Defines number of small packet pool BM buffers */
-	uint32_t large_pkt_buffers;	/* Defines number of large packet pool BM buffers */
-} tpm_init_gmac_bufs_t;
-
-/* Structure holds the physical connections of all external Ethernet ports */
-typedef struct {
-	uint32_t valid;
-	tpm_src_port_type_t port_src;		/* Port number according to Device port numbering scheme	*/
-	tpm_init_chip_conn_t chip_connect;	/* Connection to physical output lines on SoC			*/
-	tpm_init_int_conn_t int_connect;	/* Internal Ethernet device port is connected to		*/
-	uint32_t switch_port;			/* Port of Internal_Switch, the port is connected to		*/
-} tpm_init_eth_port_conf_t;
-
-typedef struct {
-	uint32_t valid;
-	tpm_init_sched_t sched_method;
-	tpm_init_txq_owner_t queue_owner;
-	uint32_t owner_queue_num;
-	uint32_t queue_size;
-	uint32_t queue_weight;
-} tpm_init_gmac_txq_t;
-
-typedef struct {
-	uint32_t valid;
-	uint32_t queue_size;
-} tpm_init_gmac_rxq_t;
-
-/*Structure defines the details of a Packet Processor Tx component  */
-typedef struct {
-	uint32_t valid;	/* Defines if the Tx component is used */
-	tpm_init_gmac_txq_t tx_queue[TPM_MAX_NUM_TX_QUEUE];	/* Config. of each of the 8 Tx queue of this Tx component */
-} tpm_init_gmac_tx_t;
-
-typedef struct {
-	uint32_t valid;	/* Defines if any of the GMAC queues are defined */
-	tpm_init_gmac_rxq_t rx_queue[TPM_MAX_NUM_RX_QUEUE];	/* Config. of each of the 8 Rx queue of this GMAC component */
-} tpm_init_gmac_rx_t;
-
-typedef enum {
-	TPM_INVALID_RANGE = -1,
-	TPM_MIN_RANGE,
-	TPM_PNC_MNGMT_DS = TPM_MIN_RANGE,
-	TPM_PNC_MAC_LEARN,
-	TPM_PNC_CPU_WAN_LPBK_US,
-	TPM_PNC_NUM_VLAN_TAGS,
-	TPM_PNC_DS_LOAD_BALANCE,
-	TPM_PNC_MULTI_LPBK,
-	TPM_PNC_VIRT_UNI,
-	TPM_PNC_LOOP_DET_US,
-	TPM_PNC_L2_MAIN,
-	TPM_PNC_ETH_TYPE,
-	TPM_PNC_IGMP,
-	TPM_PNC_IPV4_MC_DS,
-	TPM_PNC_IPV4_MAIN,
-	TPM_PNC_IPV4_TCP_FLAG,
-	TPM_PNC_TTL,
-	TPM_PNC_IPV4_PROTO,
-	TPM_PNC_IPV4_FRAG,
-	TPM_PNC_IPV4_LEN,
-	TPM_PNC_IPV6_NH,
-	TPM_PNC_IPV6_L4_MC_DS,
-	TPM_PNC_IPV6_TCP_FLAG,
-	TPM_PNC_IPV6_L4,
-	TPM_PNC_IPV6_HOPL,
-	TPM_PNC_IPV6_MC_SIP,
-	TPM_PNC_IPV6_GEN,
-	TPM_PNC_IPV6_MC_DS,
-	TPM_PNC_IPV6_DIP,
-	TPM_PNC_CNM_IPV4_PRE,
-	TPM_PNC_CNM_MAIN,
-	TPM_PNC_CATCH_ALL,
-	TPM_MAX_RANGE = TPM_PNC_CATCH_ALL,
-	TPM_MAX_NUM_RANGES
-} tpm_pnc_ranges_t;
-
-typedef enum {
-	TPM_RANGE_TYPE_ACL,
-	TPM_RANGE_TYPE_TABLE
-} tpm_range_type_t;
-
-typedef enum {
-	TPM_MH_SRC_RX_CTRL = 0,
-	TPM_MH_SRC_PNC_RI,
-} tpm_init_mh_src_t;
-
-typedef enum {
-	TPM_VALID_DISABLED = 0,
-	TPM_VALID_ENABLED
-} tpm_init_tpm_validation_t;
-
-typedef enum {
-	TPM_ENUM_RESET_LEVEL0,
-	TPM_ENUM_RESET_LEVEL1,
-	TPM_ENUM_MAX_RESET_LEVEL = TPM_ENUM_RESET_LEVEL1
-} tpm_reset_level_enum_t;
-
-typedef enum {
-	TPM_IPV6_5T_DISABLED = 0,
-	TPM_IPV6_5T_ENABLED,
-} tpm_init_ipv6_5t_enable_t;
-typedef enum {
-	TPM_DS_MAC_BASED_TRUNK_DISABLED = 0,
-	TPM_DS_MAC_BASED_TRUNK_ENABLED,
-} tpm_init_ds_mac_based_trunk_enable_t;
-
-typedef enum {
-	TPM_CTC_CM_DISABLED = 0,
-	TPM_CTC_CM_ENABLED,
-} tpm_init_ctc_cm_enable_t;
-
-typedef enum {
-	TPM_CTC_CM_IPv6_FIRST_24B = 0,
-	TPM_CTC_CM_IPv6_SECOND_24B,
-} tpm_ctc_cm_ipv6_parse_win_t;
-typedef enum {
-	TPM_SPLIT_MOD_MODE_CTC = 0,
-	TPM_SPLIT_MOD_MODE_TR156,
-} tpm_init_split_mod_mode_t;
-typedef enum {
-	TPM_PNC_MAC_LEARN_DISABLED = 0,
-	TPM_PNC_MAC_LEARN_ENABLED,
-} tpm_init_pnc_mac_learn_enable_t;
-
-typedef enum {
-	TPM_VIRT_UNI_DISABLED = 0,
-	TPM_VIRT_UNI_ENABLED
-} tpm_init_virt_uni_enable_t;
-
-typedef enum {
-	TPM_CFG_PNC_PARSE_DISABLED,
-	TPM_CFG_PNC_PARSE_ENABLED
-} tpm_init_cfg_pnc_parse_t;
-
-typedef enum {
-	TPM_CPU_LOOPBACK_DISABLED,
-	TPM_CPU_LOOPBACK_ENABLED
-} tpm_init_cpu_loopback_t;
-
-typedef enum {
-	TPM_DOUBLE_TAG_DISABLED,
-	TPM_DOUBLE_TAG_ENABLED
-} tpm_init_double_tag_t;
-
-typedef enum {
-	TPM_CFG_MODE_APPL = 0,
-	TPM_CFG_MODE_KERNEL
-} tpm_config_mode_t;
-
-typedef enum {
-	TPM_FLUSH_ATU_ALL = 0,
-	TPM_FLUSH_ATU_DYNAMIC
-} tpm_flush_atu_type_t;
-
-typedef struct {
-	tpm_pnc_ranges_t range_num;
-	tpm_range_type_t range_type;
-	uint32_t range_size;	/* Range's Physical PnC size */
-	uint32_t cntr_grp;
-	uint32_t lu_mask;
-	tpm_reset_level_enum_t min_reset_level;
-	uint32_t valid;
-} tpm_init_pnc_range_t;
-
-typedef struct {
-	uint16_t v1_tpid;
-	uint16_t v2_tpid;
-} tpm_init_tpid_comb_t;
-
-typedef struct {
-	uint32_t opt_num;
-	tpm_init_tpid_comb_t opt[TPM_MAX_TPID_COMB_NUM];
-} tpm_init_tpid_opt_t;
-
-typedef struct {
-	tpm_init_virt_uni_enable_t enabled;
-	tpm_src_port_type_t uni_port;
-	uint32_t switch_port;
-} tpm_init_virt_uni_t;
-
-typedef struct {
-	uint32_t udp_checksum_use_init_bm;
-	uint32_t udp_checksum_update;
-} tpm_init_mod_params_t;
-
-typedef struct {
-	uint16_t opcode;
-	uint16_t data;
-	uint8_t last;
-	uint8_t updt_ipv4;
-	uint8_t updt_tcp;
-	uint8_t dummy;
-} tpm_mod2_entry_t;
-
-typedef struct {
-	uint32_t entry_id;
-	tpm_mod2_entry_t entry_data;
-} tpm_mod_rule_t;
-
-typedef enum {
-	TPM_MTU_CHECK_DISABLED = 0,
-	TPM_MTU_CHECK_ENABLED
-} tpm_init_mtu_setting_enable_t;
-
-typedef enum {
-	TPM_TTL_ZERO_ACTION_NOTHING = 0,
-	TPM_TTL_ZERO_ACTION_DROP,
-	TPM_TTL_ZERO_ACTION_TO_CPU
-} tpm_init_ttl_illegal_action_t;
-
-typedef enum {
-	TPM_TCP_FLAG_NOT_CHECK = 0,
-	TPM_TCP_FLAG_CHECK
-} tpm_init_tcp_flag_check_t;
-
-typedef enum {
-	TPM_ETY_DSA_DISABLE = 0,
-	TPM_ETY_DSA_ENABLE
-} tpm_init_ety_dsa_enable_t;
-
-typedef enum {
-	TPM_PPPOE_ADD_DISABLED = 0,
-	TPM_PPPOE_ADD_ENABLED
-} tpm_init_pppoe_add_enable_t;
-typedef enum {
-	TPM_SPLIT_MOD_DISABLED = 0,
-	TPM_SPLIT_MOD_ENABLED
-} tpm_init_split_mod_enable_t;
-
-typedef enum {
-	TPM_MTU_IPV4,	/* IPV4 */
-	TPM_MTU_IPV6,	/* IPV6 */
-} tpm_mtu_ethertype_t;
-
-typedef enum {
-	TPM_SELF_CHECK_LEVEL0,
-	TPM_SELF_CHECK_LEVEL1,
-	TPM_ENUM_MAX_CHECK_LEVEL = TPM_SELF_CHECK_LEVEL1
-} tpm_self_check_level_enum_t;
-
-typedef enum tpm_unknown_mac_conf {
-	TPM_UNK_MAC_TRAP,/*default rule trap packet to CPU*/
-	TPM_UNK_MAC_DROP,/*default rule drop the packet*/
-	TPM_UNK_MAC_CONTINUE/*default rule frwd packet to GMAC1*/
-} tpm_unknown_mac_conf_t;
-
-typedef struct {
-	tpm_init_mtu_setting_enable_t mtu_enable;
-	uint32_t ipv4_mtu_us;
-	uint32_t ipv4_pppoe_mtu_us;
-	uint32_t ipv6_mtu_us;
-	uint32_t ipv6_pppoe_mtu_us;
-	uint32_t ipv4_mtu_ds;
-	uint32_t ipv6_mtu_ds;
-} tpm_init_mtu_params_t;
-
-typedef struct {
-	uint32_t type;
-	uint32_t num;
-} tpm_init_chain_data_t;
-
-typedef struct {
-	uint32_t chain_num;
-	tpm_init_chain_data_t chain_data[TPM_MAX_MOD_CHAIN_NUM];
-} tpm_init_mod_chain_t;
-
-typedef struct {
-	tpm_mc_filter_mode_t filter_mode;
-	uint32_t per_uni_vlan_xlat;
-	uint32_t mc_pppoe_enable;
-	uint32_t mc_hwf_queue;
-	uint32_t mc_cpu_queue;
-	uint32_t ipv4_mc_support;
-	uint32_t ipv6_mc_support;
-} tpm_init_mc_setting_t;
-
-typedef enum {
-	TPM_INVALID_GMAC = -1,
-	TPM_ENUM_GMAC_0,
-	TPM_ENUM_GMAC_1,
-	TPM_ENUM_PMAC,
-	TPM_MAX_GMAC = TPM_ENUM_PMAC,
-	TPM_MAX_NUM_GMACS
-} tpm_gmacs_enum_t;
-
-
-typedef struct {
-	tpm_init_split_mod_enable_t split_mod_enable;
-	uint8_t p_bit[8];
-	uint32_t p_bit_num;
-	uint32_t vlan_num;
-	tpm_init_split_mod_mode_t split_mod_mode;
-} tpm_init_split_mod_params_t;
-
-typedef struct {
-	uint8_t		enabled;
-	uint8_t		port;
-	uint8_t		tx_port;
-	uint8_t		tx_queue;
-	uint32_t	tgt_port;
-	uint32_t	queue_sample_freq;
-	uint32_t	thresh_high;
-	uint32_t	thresh_low;
-} tpm_init_fc_params_t;
-
-typedef struct {
-	uint32_t omci_etype;
-	tpm_init_pon_type_t pon_type;
-	uint32_t igmp_snoop;
-	uint32_t igmp_cpu_queue;
-	uint32_t igmp_pkt_frwd_mod[TPM_MAX_NUM_ETH_PORTS+1]; /* save space for UNI_ANY */
-	uint32_t num_tcont_llid;
-	tpm_init_gmac_bufs_t gmac_bp_bufs[TPM_NUM_GMACS];
-	uint32_t gmac0_mh_en;
-	uint32_t gmac1_mh_en;
-	tpm_init_fc_params_t		port_fc_conf;
-	tpm_eth_complex_profile_t	eth_cmplx_profile;
-	tpm_init_eth_port_conf_t	eth_port_conf[TPM_MAX_NUM_ETH_PORTS];
-	tpm_init_gmac_conn_conf_t	gmac_port_conf[TPM_NUM_GMACS];
-	uint32_t			active_wan;
-	tpm_init_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	tpm_init_gmac_tx_t gmac_tx[TPM_MAX_NUM_TX_PORTS];
-	tpm_init_gmac_rx_t gmac_rx[TPM_NUM_GMACS];
-	tpm_init_pnc_range_t pnc_range[TPM_MAX_NUM_RANGES];
-	tpm_init_pnc_last_init_t catch_all_pkt_action;
-
-	tpm_init_mh_src_t ds_mh_set_conf;
-	tpm_init_tpm_validation_t validation_en;
-	tpm_init_tpid_opt_t tpid_opt;
-	uint32_t vlan_etypes[TPM_NUM_VLAN_ETYPE_REGS];
-	tpm_init_mod_params_t mod_config;
-	tpm_init_mod_chain_t mod_chain;
-	tpm_init_cfg_pnc_parse_t cfg_pnc_parse;
-	tpm_init_cpu_loopback_t cpu_loopback;
-	uint32_t trace_debug_info;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable;
-	tpm_init_ctc_cm_enable_t ctc_cm_enable;
-	tpm_ctc_cm_ipv6_parse_win_t  ctc_cm_ipv6_parse_window;
-	tpm_init_virt_uni_t virt_uni_info;
-
-#if 0
-	uint16_t vlan1_tpid;
-	uint16_t vlan2_tpid;
-#endif
-
-	tpm_init_mtu_params_t mtu_config;
-	tpm_init_pppoe_add_enable_t pppoe_add_enable;
-	uint32_t num_vlan_tags;
-	uint32_t cpu_rx_queue;
-	tpm_init_ttl_illegal_action_t ttl_illegal_action;
-	tpm_init_tcp_flag_check_t tcp_flag_check;
-	tpm_init_ety_dsa_enable_t ety_dsa_enable;
-
-	tpm_init_mc_setting_t mc_setting;
-	tpm_init_split_mod_params_t split_mod_config;
-	uint32_t switch_init;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable;
-} tpm_init_t;
-
-#define XML_FILE_PATH_LENGTH  (64)
-typedef struct {
-	char xml_file_path[XML_FILE_PATH_LENGTH];
-} tpm_setup_t;
-
-/******************* TPM global ERROR codes  **************************/
-typedef enum tpm_error_code {
-	TPM_RC_OK,	/*Return ok (=0). */
-	ERR_GENERAL,	/*General purpose error. */
-	ERR_OWNER_INVALID,	/*Illegal owner id. */
-	ERR_SRC_PORT_INVALID,	/*Illegal source port. */
-	ERR_RULE_NUM_INVALID,	/*Illegal rule number. */
-	ERR_RULE_IDX_INVALID,	/*Illegal rule idx. */
-	ERR_PARSE_MAP_INVALID,	/*Illegal parse mapping. */
-	ERR_VLAN_OP_INVALID,	/*Illegal VLAN operation. */
-	ERR_L2_KEY_INVALID,	/*Illegal key information for creating the ACL rule. */
-	ERR_FRWD_INVALID,	/*Illegal forwarding decision for packet. */
-	ERR_MOD_INVALID,	/*Illegal modification command on packet. */
-	ERR_ACTION_INVALID,	/*Illegal action on the packet. */
-	ERR_NEXT_PHASE_INVALID,	/*Illegal next phase for  ACL */
-	ERR_RULE_KEY_MISMATCH,	/*Inconsistency between rule_num, src_port, l2_acl_key. */
-	ERR_IPV4_NO_CONT_L4,	/*There is no continuous block with L4 src port and destination port in packet. */
-	ERR_IPV6_ADD_FAIL,	/*Inconsistency in the building of the IPv6 rule. */
-	ERR_MC_STREAM_INVALID,	/*Illegal stream number. */
-	ERR_MC_STREAM_EXISTS,	/*Stream number already exists. */
-	ERR_MC_DST_PORT_INVALID,	/*Destination port bitmap does not match the UNI ports. */
-	ERR_MC_DST_QUEUE_INVALID,	/*Destination queue number invalid. */
-	ERR_IPV4_MC_DST_IP_INVALID,	/*Destination IP address is not in the MC range. */
-	ERR_IPV6_MC_DST_IP_INVALID,	/*Destination IPv6 address is not in the MC range. */
-	ERR_IPV6_MC_SRC_IP_INVALID,	/*SRC IPv6 address is not in the MC_SIP range. */
-	ERR_OMCI_TCONT_INVALID,	/*Illegal TCONT. */
-	ERR_MNGT_TX_Q_INVALID,	/*Illegal management TX queue. */
-	ERR_MNGT_CREATE_DUPLICATE_CHANNEL,	/*Create channel that already exists, */
-	ERR_MNGT_DEL_CHANNEL_INVALID,	/*Delete an unexisting management channel. */
-	ERR_OAM_LLID_INVALID,	/*Illegal LLID. */
-	ERR_CFG_GETNEXT_INDEX_INVALID,	/*Illegal get_next index for retrieving existing configuration. */
-	ERR_CFG_GETNEXT_DIRECTION_INVALID,	/*Illegal direction set (0-upstream, 1-downstream). */
-	ERR_CFG_GET_CHANNEL_INVALID,	/*Get an unexisting management channel. */
-	ERR_SW_MAC_INVALID,	/*Illegal MAC address. */
-	ERR_SW_MAC_STATIC_NOT_FOUND,	/*Delete an unexisting static MAC. */
-	ERR_SW_MAC_PER_PORT_INVALID,	/*Illegal limit of MAC per port (1-265). */
-	ERR_SW_NUM_OF_MAC_PER_PORT_INVALID,	/*Illegal limit of MAC per port (1-265). */
-	ERR_SW_VID_INVALID,	/*Illegal VLAN ID. */
-	ERR_SW_TM_QUEUE_INVALID,	/*Illegal queue id. */
-	ERR_SW_TM_WEIGHT_INVALID,	/*Illegal weight value. */
-	ERR_SW_TM_WRR_MODE_INVALID,	/*Illegal WRR mode. */
-	ERR_API_TYPE_INVALID,	/*Illegal API type */
-	ERR_DIR_INVALID,	/*Illegal direction value */
-	ERR_NULL_POINTER,	/* NULL pointer */
-	ERR_IGMP_NOT_ENABLED,	/* Try to disable IGMP which was not enabled */
-	ERR_OUT_OF_RESOURCES,	/* No more resources of certain type */
-	ERR_AI_SESS_EXISTS,	/* AI Session already exists */
-	ERR_AI_SESS_DELETING,	/* AI Session was deleted in this API call */
-	ERR_SW_TM_BUCKET_SIZE_INVALID,	/*Illegal bucket size. */
-	ERR_SW_TM_RATE_LIMIT_INVALID,	/*Illegal rate limit. */
-	ERR_DELETE_KEY_INVALID,	/* Illegal combination of key / rule_index for delete action */
-	ERR_L3_KEY_INVALID,	/*Illegal key information for creating the ACL rule. */
-	ERR_IPV4_KEY_INVALID,	/*Illegal key information for creating the ACL rule. */
-	ERR_IPV6_KEY_INVALID,	/*Illegal key information for creating the ACL rule. */
-	ERR_PORT_IGMP_FRWD_MODE_INVALID,	/*Illegal IGMP forward mode. */
-	ERR_IPV6_API_ILLEGAL_CALL,  /* Invoke the IPV6 API which is forbidden in current mode */
-	ERR_IPV6_5T_RULE_EXISTS,	/* IPV6 rule already exists */
-	ERR_IPV6_5T_FLOW_PARTIAL_MATCHED,	/* IPV6 5-tuple flow is a subflow of another flow */
-	ERR_IPV6_5T_RULE_IN_USE,	/* Try to delete a rule which is referred by other flows */
-	ERR_IPV6_5T_FLOW_AI_BITS_EXHAUSED, /* No enough AI resource for new subflow */
-	ERR_SW_NOT_INIT,	/* TPM was not successfully intiailized . */
-	ERR_FEAT_UNSUPPORT,	/* TPM feature not supported  . */
-	ERR_API_BUSY,
-	ERR_CTC_CM_DB_ERR,  /* CTC CnM DB Error */
-	ERR_CTC_CM_PREC_INVALID,   /* CTC CnM Precedence invalid */
-	ERR_TPMCHECK_DB_CHAIN_TYPE_MISMATCH,/*DB main chain type check FAIL */
-	ERR_TPMCHECK_HW_CHAIN_TYPE_MISMATCH,/*HW main chain type check FAIL */
-	ERR_TPMCHECK_BOTH_CHAIN_TYPE_MISMATCH,/*HW & DB main chain type check FAIL */
-	ERR_TPMCHECK_DB_MISMATCH,/*tpm check with DB FAIL */
-	ERR_TPMCHECK_HW_MISMATCH,/*tpm check with HW FAIL */
-	ERR_TPMCHECK_PNC_DB_MISMATCH,/*DB PNC check FAIL */
-	ERR_TPMCHECK_PNC_HW_MISMATCH,/*HW PNC check FAIL */
-	ERR_TPMCHECK_PMT_DB_MISMATCH,/*DB PMT check FAIL */
-	ERR_TPMCHECK_PMT_HW_MISMATCH,/*HW PMT check FAIL */
-	ERR_UNKNOWN_MAC_CONF_INVALID,/*Illegal MAC learn default conf*/
-	ERR_PHY_SRC_PORT_CONN_INVALID,/*PHY and source port connection invalid*/
-	ERR_PHY_STATUS_UNKNOWN,/*PHY status info is unknown*/
-} tpm_error_code_t;
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.c
deleted file mode 100644
index ac146dc..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.c
+++ /dev/null
@@ -1,3839 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_types.h"
-#include "tpm_internal_types.h"
-#include "tpm_xml_params.h"
-#include "ezxml.h"
-
-char *g_pstr_xml_cfg_file = US_XML_CFG_FILE;
-static ezxml_t g_p_xmlHead = NULL;
-
-/*******************************************************************************
-*                          Internal functions
-*******************************************************************************/
-static ezxml_t get_xml_head_ptr(char *cfg_file)
-{
-	if (g_p_xmlHead == NULL) {
-		g_p_xmlHead = ezxml_parse_file(cfg_file);
-
-		if (g_p_xmlHead == NULL)
-			printk(KERN_ERR "Failed to open XML configuration file - %s\n", cfg_file);
-	}
-
-	return g_p_xmlHead;
-}
-
-void free_xml_head_ptr(void)
-{
-	if (g_p_xmlHead != NULL) {
-		ezxml_free(g_p_xmlHead);
-		g_p_xmlHead = NULL;
-	}
-}
-
-static uint32_t get_dig_number(const char *arg)
-{
-	uint32_t val = 0;
-
-	if ((arg[1] == 'x') || (arg[1] == 'X'))
-		sscanf(&arg[2], "%x", &val);
-	else
-		val = simple_strtoul(arg, NULL, 10);
-
-	return val;
-}
-
-static int get_int_param(ezxml_t xml, char *name, uint32_t *num)
-{
-	ezxml_t xmlElement;
-
-	xmlElement = ezxml_child(xml, name);
-	if (xmlElement == NULL)
-		return US_RC_NOT_FOUND;
-	else if (xmlElement->txt == NULL) {
-		printk(KERN_ERR "NULL value for %s in XML config. file\n", name);
-		return US_RC_NOT_FOUND;
-	}
-
-	*num = get_dig_number(xmlElement->txt);
-	return US_RC_OK;
-}
-
-static int get_char_param(ezxml_t xml, char *name, uint8_t *str, uint8_t len)
-{
-	ezxml_t xmlElement;
-
-	xmlElement = ezxml_child(xml, name);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file\n", name);
-		return US_RC_NOT_FOUND;
-	} else if (xmlElement->txt == NULL) {
-		printk(KERN_ERR "NULL value for %s in XML config. file\n", name);
-		return US_RC_NOT_FOUND;
-	}
-
-	memcpy(str, xmlElement->txt, len);
-	str[len] = 0;
-	return US_RC_OK;
-}
-
-static int get_debug_port_attrs(ezxml_t xml, uint32_t *num, uint32_t *valid)
-{
-	const char *attr_str;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_ID_ATTR);
-	if (attr_str != NULL) {
-		*num = get_dig_number(attr_str);
-		attr_str = ezxml_attr(xml, US_XML_VALID_ATTR);
-		if (attr_str != NULL) {
-			*valid = get_dig_number(attr_str);
-			rc = US_RC_OK;
-		} else
-			printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_VALID_ATTR);
-	} else
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-
-	return rc;
-}
-
-static int get_rx_queue_attrs(ezxml_t xml, uint32_t gmac, tpm_init_gmac_rx_t *gmac_rx, int max_rx_queues_num)
-{
-	const char *attr_str;
-	int que_id;
-
-	attr_str = ezxml_attr(xml, US_XML_ID_ATTR);
-	if (attr_str == NULL) {
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-		return (US_RC_FAIL);
-	}
-	que_id = get_dig_number(attr_str);
-
-	if (que_id >= max_rx_queues_num) {
-		printk(KERN_ERR "%s: Invalid ID number %s\n", __func__, attr_str);
-		return (US_RC_FAIL);
-	}
-
-	attr_str = ezxml_attr(xml, US_XML_SIZE_ATTR);
-	if (attr_str == NULL) {
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_SIZE_ATTR);
-		return (US_RC_FAIL);
-	}
-
-	gmac_rx[gmac].rx_queue[que_id].queue_size = get_dig_number(attr_str);
-	gmac_rx[gmac].valid = 1;
-	gmac_rx[gmac].rx_queue[que_id].valid = 1;
-
-	return US_RC_OK;
-}
-
-static int get_tx_queue_attrs(ezxml_t xml, uint32_t port, tpm_init_gmac_tx_t *gmac_tx, int max_tx_queues_num)
-{
-	const char *attr_str;
-	int que_id;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_ID_ATTR);
-	if (attr_str != NULL) {
-		que_id = get_dig_number(attr_str);
-
-		if (que_id < max_tx_queues_num) {
-			attr_str = ezxml_attr(xml, US_XML_QUEUE_SHED_ATTR);
-			if (attr_str != NULL) {
-				gmac_tx[port].tx_queue[que_id].sched_method = get_dig_number(attr_str);
-				attr_str = ezxml_attr(xml, US_XML_QUEUE_OWNER_ATTR);
-				if (attr_str != NULL) {
-					gmac_tx[port].tx_queue[que_id].queue_owner = get_dig_number(attr_str);
-					attr_str = ezxml_attr(xml, US_XML_QUEUE_OW_Q_NUM_ATTR);
-					if (attr_str != NULL) {
-						gmac_tx[port].tx_queue[que_id].owner_queue_num =
-							get_dig_number(attr_str);
-						attr_str = ezxml_attr(xml, US_XML_SIZE_ATTR);
-						if (attr_str != NULL) {
-							gmac_tx[port].tx_queue[que_id].queue_size =
-								get_dig_number(attr_str);
-							attr_str = ezxml_attr(xml, US_XML_QUEUE_WEIGHT_ATTR);
-							if (attr_str != NULL) {
-								gmac_tx[port].tx_queue[que_id].queue_weight =
-									get_dig_number(attr_str);
-								gmac_tx[port].valid = 1;
-								gmac_tx[port].tx_queue[que_id].valid = 1;
-								rc = US_RC_OK;
-							} else
-								printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-									US_XML_QUEUE_WEIGHT_ATTR);
-						} else
-							printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-								US_XML_SIZE_ATTR);
-					} else
-						printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-							US_XML_QUEUE_OW_Q_NUM_ATTR);
-				} else
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_QUEUE_OWNER_ATTR);
-			} else
-				printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_QUEUE_SHED_ATTR);
-		} else
-			printk(KERN_ERR "%s: Invalid ID number %s\n", __func__, attr_str);
-	} else
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-
-	return rc;
-}
-
-static int get_pnc_range_attrs(ezxml_t xml, tpm_init_pnc_range_t *pnc_range, int max_pnc_ranges)
-{
-	const char *attr_str;
-	int range_num;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_NUM_ATTR);
-	if (attr_str != NULL) {
-		range_num = get_dig_number(attr_str);
-		if (range_num < max_pnc_ranges) {
-			pnc_range[range_num].range_num = range_num;
-			attr_str = ezxml_attr(xml, US_XML_TYPE_ATTR);
-			if (attr_str != NULL) {
-				pnc_range[range_num].range_type = get_dig_number(attr_str);
-				attr_str = ezxml_attr(xml, US_XML_SIZE_ATTR);
-				if (attr_str != NULL) {
-					pnc_range[range_num].range_size = get_dig_number(attr_str);
-					attr_str = ezxml_attr(xml, US_XML_TPM_CNTR_GRP_ATTR);
-					if (attr_str != NULL) {
-						pnc_range[range_num].cntr_grp = get_dig_number(attr_str);
-						attr_str = ezxml_attr(xml, US_XML_TPM_LU_MASK_ATTR);
-						if (attr_str != NULL) {
-							pnc_range[range_num].lu_mask = get_dig_number(attr_str);
-							attr_str = ezxml_attr(xml, US_XML_TPM_MIN_RES_LVL_ATTR);
-							if (attr_str != NULL) {
-								pnc_range[range_num].min_reset_level =
-									get_dig_number(attr_str);
-								pnc_range[range_num].valid = 1;
-								rc = US_RC_OK;
-							} else
-								printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-									US_XML_TPM_MIN_RES_LVL_ATTR);
-						} else
-							printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-								US_XML_TPM_LU_MASK_ATTR);
-					} else
-						printk(KERN_ERR "%s: Failed to get %s\n", __func__,
-							US_XML_TPM_CNTR_GRP_ATTR);
-				} else
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_SIZE_ATTR);
-			} else
-				printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_TYPE_ATTR);
-		} else
-			printk(KERN_ERR "%s: Invalid Range number %s\n", __func__, attr_str);
-	} else
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_NUM_ATTR);
-
-	return rc;
-}
-
-static int get_mod_chain_attrs(ezxml_t xml, tpm_init_chain_data_t *chain_data)
-{
-	const char *attr_str;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_TPM_CHAIN_TYPE_ATTR);
-	if (attr_str != NULL) {
-		chain_data->type = get_dig_number(attr_str);
-		attr_str = ezxml_attr(xml, US_XML_TPM_CHAIN_NUM_ATTR);
-		if (attr_str != NULL) {
-			chain_data->num = get_dig_number(attr_str);
-			return US_RC_OK;
-		} else
-			printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_TPM_CHAIN_NUM_ATTR);
-	} else
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_TPM_CHAIN_TYPE_ATTR);
-
-	return rc;
-}
-
-static int get_vlan_ety_attrs(ezxml_t xml, uint32_t *etypes, int max_etypes)
-{
-	const char *attr_str;
-	int reg_id;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_ID_ATTR);
-	if (attr_str != NULL) {
-		reg_id = get_dig_number(attr_str);
-		if (reg_id < max_etypes) {
-			attr_str = ezxml_attr(xml, US_XML_TYPE_ATTR);
-			if (attr_str != NULL) {
-				etypes[reg_id] = get_dig_number(attr_str);
-				rc = US_RC_OK;
-			} else
-				printk(KERN_ERR  "%s: Failed to get %s\n", __func__, US_XML_TYPE_ATTR);
-		} else
-			printk(KERN_ERR "%s: Invalid ID number %s\n", __func__, attr_str);
-	} else
-		printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-
-	return rc;
-}
-
-static int get_filter_tpid_attrs(ezxml_t xml, tpm_init_tpid_comb_t *tpid)
-{
-	const char *attr_str;
-	const char *v1_tpid = NULL;
-	const char *v2_tpid = NULL;
-	int rc = US_RC_FAIL;
-
-	attr_str = ezxml_attr(xml, US_XML_TYPE_ATTR);
-	if (attr_str != NULL) {
-		v1_tpid = attr_str;
-		v2_tpid = strstr(attr_str, ",");
-
-		tpid->v1_tpid = get_dig_number(v1_tpid);
-		if (v2_tpid != NULL) {
-			v2_tpid++;
-			tpid->v2_tpid = get_dig_number(v2_tpid);
-		} else
-			tpid->v2_tpid = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-		rc = US_RC_OK;
-	} else
-		printk("%s: Failed to get %s\n", __func__, US_XML_TYPE_ATTR);
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_pon_type_param()
-*
-* DESCRIPTION:      Get WAN type from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  pon_type - EPON, GPON, ETH or P2P
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_pon_type_param(tpm_init_pon_type_t *pon_type)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t local_pon_type;
-
-	if (pon_type == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*pon_type = TPM_NONE;
-
-	xmlHead = ezxml_parse_file(US_XML_CFG_FILE_GLOBAL);
-	if (xmlHead == NULL) {
-		printk(KERN_ERR "Failed to open XML configuration file - %s\n", US_XML_CFG_FILE_GLOBAL);
-		return US_RC_FAIL;
-	}
-
-	xmlElement = ezxml_child(xmlHead, US_XML_WAN_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_WAN_E, US_XML_CFG_FILE_GLOBAL);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_PON_TYPE_E, &local_pon_type);
-
-	if (rc == US_RC_OK) {
-		*pon_type = (tpm_init_pon_type_t) local_pon_type;
-
-#ifdef US_DEBUG_PRINT
-	{
-	char * pon_str[] = {"EPON", "GPON", "P2P", "NONE"};
-		printk("pon_type = %s \n", pon_str[*pon_type]);
-	}
-#endif
-	}
-
-	ezxml_free(xmlHead);
-	return rc;
-}
-
-/*******************************************************************************
-* get_omci_etype_param()
-*
-* DESCRIPTION:      Get OMCI ETY from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  ety - Ethernet type
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_omci_etype_param(uint32_t *ety)
-{
-	int rc;
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-
-	if (ety == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ety = 0;
-
-	xmlHead = ezxml_parse_file(US_XML_CFG_FILE_OMCI);
-	if (xmlHead == NULL) {
-		printk(KERN_ERR "Failed to open XML configuration file - %s\n", US_XML_CFG_FILE_OMCI);
-		return US_RC_FAIL;
-	}
-
-	xmlElement = ezxml_child(xmlHead, US_XML_OMCI_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_OMCI_E, US_XML_CFG_FILE_OMCI);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_OMCI_ETY_E, ety);
-
-	if (rc == US_RC_OK) {
-#ifdef US_DEBUG_PRINT
-		printk("OMCI ETY = 0x%4.4X\n", *ety);
-#endif
-	}
-
-	ezxml_free(xmlHead);
-	return rc;
-}
-
-/*******************************************************************************
-* get_debug_port_params()
-*
-* DESCRIPTION:      Get debug port from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  valid - whether the debug port is valid
-*           num   - debug port number
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_debug_port_params(uint32_t *valid, uint32_t *num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if ((valid == NULL) || (num == NULL)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*valid = 0;
-	*num = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_DEBUG_PORT_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_DEBUG_PORT_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		get_debug_port_attrs(xmlElement, num, valid);
-
-#ifdef US_DEBUG_PRINT
-		printk("DEBUG port = %d valid = %d\n", *num, *valid);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_fc_def_params
-*
-* DESCRIPTION:      Get FC default parameters from XML configuration file
-*
-* INPUTS:
-*
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_fc_def_params(tpm_init_fc_params_t *port_fc_conf)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t u32_value;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_FC_PARAMS_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_FC_PARAMS_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc |= get_int_param(xmlElement, US_XML_ENABLED_E, &u32_value);
-		port_fc_conf->enabled = (uint8_t)u32_value;
-		rc |= get_int_param(xmlElement, US_XML_PORT_E, &u32_value);
-		port_fc_conf->port = (uint8_t)u32_value;
-	rc |= get_int_param(xmlElement, US_XML_TX_PORT_E, &u32_value);
-		port_fc_conf->tx_port = (uint8_t)u32_value;
-		rc |= get_int_param(xmlElement, US_XML_TX_Q_E, &u32_value);
-		port_fc_conf->tx_queue = (uint8_t)u32_value;
-
-		rc |= get_int_param(xmlElement, US_XML_Q_SAMPLE_FREQ_E, &port_fc_conf->queue_sample_freq);
-		rc |= get_int_param(xmlElement, US_XML_THRESH_HIGH_E,	&port_fc_conf->thresh_high);
-		rc |= get_int_param(xmlElement, US_XML_THRESH_LOW_E, 	&port_fc_conf->thresh_low);
-		rc |= get_int_param(xmlElement, US_XML_TGT_PORT_E, 	&port_fc_conf->tgt_port);
-
-#ifdef US_DEBUG_PRINT
-		printk("SW port FC %s\n", (port_fc_conf->enabled) ? "Enabled" : "Disabled");
-		if (port_fc_conf->enabled) {
-		printk(" port %d\n", port_fc_conf->port);
-			printk(" tgt_port %d\n", port_fc_conf->tgt_port);
-			printk(" tx_port %d\n", port_fc_conf->tx_port);
-			printk(" tx_queue %d\n", port_fc_conf->tx_queue);
-			printk(" queue_sample_freq %d\n", port_fc_conf->queue_sample_freq);
-			printk(" thresh_high %d\n", port_fc_conf->thresh_high);
-			printk(" thresh_low %d\n", port_fc_conf->thresh_low);
-		}
-#endif
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_igmp_snoop_params_enable()
-*
-* DESCRIPTION:      Get IGMP snooping parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the IGMP snooping is enabled
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_igmp_snoop_params_enable(uint32_t *enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_IGMP_SNOOP_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_IGMP_SNOOP_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_ENABLED_E, enable);
-
-#ifdef US_DEBUG_PRINT
-		printk("IGMP snooping: enable %d \n", *enable);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ds_mac_based_trunking_enable()
-*
-* DESCRIPTION:      Get DS load balance parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether DS load balance is enabled
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ds_mac_based_trunking_enable(uint32_t *enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_DS_MAC_BASED_TRUNKING_E, enable);
-
-#ifdef US_DEBUG_PRINT
-		printk("ds_mac_based_trunking enable %d \n", *enable);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_igmp_snoop_params_cpu_queue()
-*
-* DESCRIPTION:      Get IGMP snooping parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the IGMP snooping is enabled
-*           que    - queue number
-*           all    - whether all packets should be verified
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_igmp_snoop_params_cpu_queue(uint32_t *que)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (que == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*que = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_IGMP_SNOOP_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_IGMP_SNOOP_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IGMP_CPU_Q_E, que);
-
-#ifdef US_DEBUG_PRINT
-		printk("IGMP snooping:  que %d\n", *que);
-#endif
-	}
-
- /*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_igmp_snoop_params_port_frwd_mode()
-*
-* DESCRIPTION:      Get IGMP snooping parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the IGMP snooping is enabled
-*           que    - queue number
-*           all    - whether all packets should be verified
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_igmp_snoop_params_port_frwd_mode(uint32_t *mode, tpm_src_port_type_t port)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	char *xml_param_str;
-
-	if (mode == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	switch (port) {
-	case TPM_SRC_PORT_WAN:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_WAN;
-		break;
-	case TPM_SRC_PORT_UNI_0:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_0;
-		break;
-	case TPM_SRC_PORT_UNI_1:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_1;
-		break;
-	case TPM_SRC_PORT_UNI_2:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_2;
-		break;
-	case TPM_SRC_PORT_UNI_3:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_3;
-		break;
-	case TPM_SRC_PORT_UNI_4:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_4;
-		break;
-	case TPM_SRC_PORT_UNI_5:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_5;
-		break;
-	case TPM_SRC_PORT_UNI_6:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_6;
-		break;
-	case TPM_SRC_PORT_UNI_7:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_7;
-		break;
-	case TPM_SRC_PORT_UNI_VIRT:
-		xml_param_str = US_XML_IGMP_PKT_FRWD_MODE_UNI_VIRT;
-		break;
-	case TPM_SRC_PORT_UNI_ANY:
-		return US_RC_NOT_FOUND;
-
-	default:
-#ifdef US_DEBUG_PRINT
-			printk(KERN_ERR "illegal input SRC port: %d\n", port);
-#endif
-			return US_RC_FAIL;
-	}
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_IGMP_SNOOP_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_IGMP_SNOOP_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-
-		rc = get_int_param(xmlElement, xml_param_str, mode);
-
-#ifdef US_DEBUG_PRINT
-		printk("igmp_mode port(%d), mode(%d) \n", port, *mode);
-#endif
-	}
-
- /*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_mh_en_params()
-*
-* DESCRIPTION:      Get GMAC Marvell Header enable parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  gmac0_mh_en  - GMAC0 Marvell Header Enable configuration
-*           gmac1_mh_en  - GMAC0 Marvell Header Enable configuration
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_mh_en_params(uint32_t *gmac0_mh_en, uint32_t *gmac1_mh_en)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if ((gmac0_mh_en == NULL) || (gmac1_mh_en == NULL)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*gmac0_mh_en = 0;
-	*gmac1_mh_en = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_GMAC_CONFIG_E, 0, US_XML_GMAC_MH_ENA_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_GMAC_MH_ENA_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_GMAC_0_MH_ENA_E, gmac0_mh_en);
-		rc |= get_int_param(xmlElement, US_XML_GMAC_1_MH_ENA_E, gmac1_mh_en);
-#ifdef US_DEBUG_PRINT
-		printk("======================================\n");
-		printk("        GMAC Marvell Header Enable    \n");
-		printk("======================================\n");
-		printk("gmac0_mh_en %d \n", *gmac0_mh_en);
-		printk("gmac1_mh_en %d \n", *gmac1_mh_en);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_conn_params()
-*
-* DESCRIPTION:      Get GMAC connection parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  num_tcont_llid  - TCONT/LLID number
-*           gmac0_con       - GMAC0 connection type
-*           gmac1_con       - GMAC1 connection type
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_conn_params(uint32_t *num_tcont_llid)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (num_tcont_llid == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*num_tcont_llid = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_GMAC_CONFIG_E, 0, US_XML_GMAC_CONN_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_GMAC_CONN_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_TCONT_LLID_E, num_tcont_llid);
-#ifdef US_DEBUG_PRINT
-		printk("======================================\n");
-		printk("        GMAC connection               \n");
-		printk("======================================\n");
-		printk("num_tcont_llid %d \n", *num_tcont_llid);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_pool_bufs_params()
-*
-* DESCRIPTION:      Get GMAC Buffer Pool parameters from XML configuration file
-*
-* INPUTS:   max_gmacs_num    - MAX GMACs in the system
-*
-* OUTPUTS:  gmac_bufs       - pointer to the gmac_buffer pool data
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_pool_bufs_params(tpm_init_gmac_bufs_t *gmac_bufs, int max_gmacs_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlGmac;
-	const char *xmlStr;
-	int rc = US_RC_OK;
-	uint32_t gmac;
-	uint32_t large_pkt_pool_bufs;
-	uint32_t small_pkt_pool_bufs;
-
-	if (gmac_bufs == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	if (max_gmacs_num == 0) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid max_gmacs_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(gmac_bufs, 0, sizeof(tpm_init_gmac_bufs_t) * max_gmacs_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_GMAC_CONFIG_E, 0, US_XML_GMAC_BM_BUF_E, -1);
-	if (xmlElement == NULL)
-		rc = US_RC_FAIL;
-	else {
-		xmlGmac = ezxml_child(xmlElement, US_XML_GMAC_E);
-		if (xmlGmac) {
-			for (; xmlGmac; xmlGmac = xmlGmac->next) {
-				xmlStr = ezxml_attr(xmlGmac, US_XML_ID_ATTR);
-				if (xmlStr == NULL) {
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-					rc = US_RC_FAIL;
-					break;
-				}
-				gmac = get_dig_number(xmlStr);
-				if (gmac > (max_gmacs_num - 1)) {
-					printk(KERN_ERR "%s: Invalid GMAC id number - %s\n", __func__, xmlStr);
-					rc = US_RC_FAIL;
-					break;
-				}
-
-				xmlStr = ezxml_attr(xmlGmac, US_XML_LARGE_POOL_BUF_ATTR);
-				if (xmlStr == NULL) {
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_LARGE_POOL_BUF_ATTR);
-					rc = US_RC_FAIL;
-					break;
-				}
-				large_pkt_pool_bufs = get_dig_number(xmlStr);
-
-				xmlStr = ezxml_attr(xmlGmac, US_XML_SHORT_POOL_BUF_ATTR);
-				if (xmlStr == NULL) {
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_SHORT_POOL_BUF_ATTR);
-					rc = US_RC_FAIL;
-					break;
-				}
-				small_pkt_pool_bufs = get_dig_number(xmlStr);
-
-				gmac_bufs[gmac].valid = 1;
-				gmac_bufs[gmac].large_pkt_buffers = large_pkt_pool_bufs;
-				gmac_bufs[gmac].small_pkt_buffers = small_pkt_pool_bufs;
-			}
-		}
-#ifdef US_DEBUG_PRINT
-		printk("======================================\n");
-		printk("               GMAC BUFS              \n");
-		printk("======================================\n");
-		for (gmac = 0; gmac < max_gmacs_num; gmac++) {
-			if (gmac_bufs[gmac].valid) {
-				printk("gmac %d  large_bufs %d  small_bufs %d\n",
-				       gmac, gmac_bufs[gmac].large_pkt_buffers, gmac_bufs[gmac].small_pkt_buffers);
-			}
-		}
-		printk("======================================\n");
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-
-/*******************************************************************************
-* get_eth_cmplx_profile_params()
-*
-* DESCRIPTION:      Get GMAC connection parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  num_tcont_llid  - TCONT/LLID number
-*           gmac0_con       - GMAC0 connection type
-*           gmac1_con       - GMAC1 connection type
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_eth_cmplx_profile_params(tpm_eth_complex_profile_t *eth_cmplx_profile)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (eth_cmplx_profile == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*eth_cmplx_profile = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_ETH_CMPLX_CONFIG_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_ETH_CMPLX_CONFIG_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_ETH_PROFILE_E, eth_cmplx_profile);
-#ifdef US_DEBUG_PRINT
-		printk("======================================\n");
-		printk("            ETH COMPLEX               \n");
-		printk("======================================\n");
-		printk("eth_cmplx_profile %d \n", *eth_cmplx_profile);
-#endif
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_port_conf_params()
-*
-* DESCRIPTION:      Get GMAC Buffer Pool parameters from XML configuration file
-*
-* INPUTS:   max_gmacs_num    - MAX GMACs in the system
-*
-* OUTPUTS:  gmac_bufs       - pointer to the gmac_buffer pool data
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_port_conf_params(tpm_init_gmac_conn_conf_t *gmac_port_conf, int max_gmac_port_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlPort;
-	const char *xmlStr;
-	int rc = US_RC_OK;
-	uint32_t port_src;
-	uint32_t port_nr;
-
-	if ((gmac_port_conf == NULL) || (max_gmac_port_num == 0)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: gmac_port_conf=%p max_gmac_port_num=%d\n",
-		       __func__, gmac_port_conf, max_gmac_port_num);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(gmac_port_conf, 0, sizeof(tpm_init_gmac_conn_conf_t) * max_gmac_port_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-
-	xmlElement = ezxml_get(xmlHead, US_XML_ETH_CMPLX_CONFIG_E, 0, US_XML_GMAC_PORTS_E, -1);
-	if (xmlElement == NULL)
-		return US_RC_NOT_FOUND;
-
-	xmlPort = ezxml_child(xmlElement, US_XML_PORT_E);
-	if (xmlPort == NULL)
-		return US_RC_FAIL;
-
-	for (; xmlPort; xmlPort = xmlPort->next) {
-		/* mandatory field */
-		xmlStr = ezxml_attr(xmlPort, US_XML_ID_ATTR);
-		if (xmlStr == NULL) {
-			printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-			rc = US_RC_FAIL;
-			break;
-		}
-		port_nr = get_dig_number(xmlStr);
-		if (port_nr > (max_gmac_port_num - 1)) {
-			printk(KERN_ERR "%s: Invalid PORT id number - %s\n", __func__, xmlStr);
-			rc = US_RC_FAIL;
-			break;
-		}
-
-		/* optional field */
-		port_src = TPM_SRC_PORT_ILLEGAL;
-		xmlStr = ezxml_attr(xmlPort, US_XML_ETH_PORT_SRC_ATTR);
-		if (xmlStr != NULL)
-			port_src = get_dig_number(xmlStr);
-
-		gmac_port_conf[port_nr].valid = 1;
-		gmac_port_conf[port_nr].port_src = port_src;
-	}
-
-#ifdef US_DEBUG_PRINT
-	 printk("======================================\n");
-	 printk("              GMAC PORTS              \n");
-	 printk("======================================\n");
-	 for (port_nr = 0; port_nr < max_gmac_port_num; port_nr++) {
-		if (gmac_port_conf[port_nr].valid) {
-			printk("port %d  port_src %d\n",
-			       port_nr, gmac_port_conf[port_nr].port_src);
-		}
-	 }
-	 printk("======================================\n");
-#endif
-
-	return rc;
-}
-
-
-/*******************************************************************************
-* get_eth_port_conf_params()
-*
-* DESCRIPTION:      Get GMAC Buffer Pool parameters from XML configuration file
-*
-* INPUTS:   max_gmacs_num    - MAX GMACs in the system
-*
-* OUTPUTS:  gmac_bufs       - pointer to the gmac_buffer pool data
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_eth_port_conf_params(tpm_init_eth_port_conf_t *eth_port_bufs, int max_eth_port_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlPort;
-	const char *xmlStr;
-	int rc = US_RC_OK;
-	uint32_t switch_port;
-	uint32_t port_src;
-	uint32_t port_nr;
-
-	if ((eth_port_bufs == NULL) || (max_eth_port_num == 0)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: eth_port_bufs=%p max_eth_port_num=%d\n", __func__, eth_port_bufs, max_eth_port_num);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(eth_port_bufs, 0, sizeof(tpm_init_eth_port_conf_t) * max_eth_port_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_ETH_CMPLX_CONFIG_E, 0, US_XML_ETH_SW_PORT_ATTR, -1);
-	if (xmlElement == NULL)
-		return US_RC_NOT_FOUND;
-
-	xmlPort = ezxml_child(xmlElement, US_XML_PORT_E);
-	if (xmlPort == NULL)
-		return US_RC_FAIL;
-
-	for (port_nr = 0; xmlPort && (port_nr < max_eth_port_num); xmlPort = xmlPort->next, port_nr++) {
-		/* mandatory field */
-		xmlStr = ezxml_attr(xmlPort, US_XML_ID_ATTR);
-		if (xmlStr == NULL) {
-			printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-			rc = US_RC_FAIL;
-			break;
-		}
-		switch_port = get_dig_number(xmlStr);
-		if (switch_port > 6) {
-			printk(KERN_ERR "%s: Invalid PORT id number - %s\n", __func__, xmlStr);
-			rc = US_RC_FAIL;
-			break;
-		}
-
-		/* mandatory field */
-		xmlStr = ezxml_attr(xmlPort, US_XML_ETH_PORT_SRC_ATTR);
-		if (xmlStr == NULL) {
-			printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ETH_PORT_SRC_ATTR);
-			rc = US_RC_FAIL;
-			break;
-		}
-		port_src = get_dig_number(xmlStr);
-
-		eth_port_bufs[port_nr].valid = 1;
-		eth_port_bufs[port_nr].switch_port = switch_port;
-		eth_port_bufs[port_nr].port_src = port_src;
-       }
-#ifdef US_DEBUG_PRINT
-	printk("======================================\n");
-	printk("               ETH PORTS              \n");
-	printk("======================================\n");
-	for (port_nr = 0; port_nr < max_eth_port_num; port_nr++) {
-		if (eth_port_bufs[port_nr].valid) {
-			printk("%d)  src_port %d  switch_port %d\n",
-			       port_nr,
-			       eth_port_bufs[port_nr].port_src,
-			       eth_port_bufs[port_nr].switch_port);
-		}
-	}
-	printk("======================================\n");
-#endif
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_active_wan_params()
-*
-* DESCRIPTION:      Get GMAC connection parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  num_tcont_llid  - TCONT/LLID number
-*           gmac0_con       - GMAC0 connection type
-*           gmac1_con       - GMAC1 connection type
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_active_wan_params(uint32_t *active_wan)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (active_wan == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*active_wan = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_ETH_CMPLX_CONFIG_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_ETH_CMPLX_CONFIG_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_ACTIVE_WAN_E, active_wan);
-#ifdef US_DEBUG_PRINT
-		printk("======================================\n");
-		printk("            ETH COMPLEX               \n");
-		printk("======================================\n");
-		printk("active_wan %d \n", *active_wan);
-#endif
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_rxq_params()
-*
-* DESCRIPTION:
-*
-* INPUTS:   max_gmacs_num    - MAX GMACs in the system
-*           max_rx_queues_num - MAX possible rx_queues per GMAC
-*
-* OUTPUTS:  gmac_rx             - pointer to the gmac rx_queues data
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_rxq_params(tpm_init_gmac_rx_t *gmac_rx, int max_gmacs_num, int max_rx_queues_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	const char *xmlStr;
-	ezxml_t xmlGmac, xmlQue;
-	int rc = US_RC_OK;
-	uint32_t gmac;
-	uint32_t stop_parsing = 0;
-
-	if (gmac_rx == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	if (max_gmacs_num == 0) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid max_gmacs_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-	if (max_rx_queues_num == 0) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid max_tx_queues_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(gmac_rx, 0, sizeof(tpm_init_gmac_rx_t) * max_gmacs_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_GMAC_CONFIG_E, 0, US_XML_GMAC_RXQUEUES_E, -1);
-	if (xmlElement == NULL)
-		rc = US_RC_FAIL;
-	else {
-		xmlGmac = ezxml_child(xmlElement, US_XML_GMAC_E);
-		if (xmlGmac) {
-			for (; (xmlGmac && !stop_parsing); xmlGmac = xmlGmac->next) {
-				xmlStr = ezxml_attr(xmlGmac, US_XML_ID_ATTR);
-				if (xmlStr == NULL) {
-					printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-					rc = US_RC_FAIL;
-					break;
-				}
-				gmac = get_dig_number(xmlStr);
-				if (gmac > (max_gmacs_num - 1)) {
-					printk(KERN_ERR "%s: Invalid GMAC id number - %s\n", __func__, xmlStr);
-					rc = US_RC_FAIL;
-					break;
-				}
-
-				/* Get GMAC rx queue sizes */
-				for (xmlQue = ezxml_child(xmlGmac, US_XML_QUEUE_E); xmlQue; xmlQue = xmlQue->next) {
-					rc = get_rx_queue_attrs(xmlQue, gmac, gmac_rx, max_rx_queues_num);
-
-					if (rc != US_RC_OK) {
-						stop_parsing = 1;
-						break;
-					}
-				}
-
-			}
-		}
-#ifdef US_DEBUG_PRINT
-		{
-
-			uint32_t rxq;
-			printk("======================================\n");
-			printk("               GMAC RXQs              \n");
-			printk("======================================\n");
-			for (gmac = 0; gmac < max_gmacs_num; gmac++) {
-				if (gmac_rx[gmac].valid) {
-					for (rxq = 0; rxq < max_rx_queues_num; rxq++) {
-						if (gmac_rx[gmac].rx_queue[rxq].valid) {
-							printk("gmac %d rxq %d size %d\n",
-							       gmac, rxq, gmac_rx[gmac].rx_queue[rxq].queue_size);
-						}
-					}
-				}
-			}
-			printk("======================================\n");
-		}
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_gmac_tx_params()
-*
-* DESCRIPTION:      Get GMAC TX parameters from XML configuration file
-*
-* INPUTS:   max_tx_ports_num    - MAX TX ports in the system
-*           max_tx_queues_num   - MAX TX queues per port
-*
-* OUTPUTS:  gmac_tx             - pointer to the TX port data
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_gmac_tx_params(tpm_init_gmac_tx_t *gmac_tx, int max_tx_ports_num, int max_tx_queues_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlGmac;
-	ezxml_t xmlQueMap;
-	ezxml_t xmlQue;
-	int rc = US_RC_OK;
-	uint32_t port;
-	const char *xmlStr;
-	uint8_t stop_parsing = 0;
-
-	if (gmac_tx == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	if ((max_tx_ports_num == 0) || (max_tx_queues_num == 0)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid max_int_ports_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(gmac_tx, 0, sizeof(tpm_init_gmac_tx_t) * max_tx_ports_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_PORT_INIT_E, 0, US_XML_TX_MOD_PARAMS_E, -1);
-	if (xmlElement == NULL)
-		rc = US_RC_FAIL;
-	else {
-		for (xmlGmac = ezxml_child(xmlElement, US_XML_TX_MOD_E);
-		     xmlGmac && !stop_parsing; xmlGmac = xmlGmac->next) {
-			xmlStr = ezxml_attr(xmlGmac, US_XML_ID_ATTR);
-			if (xmlStr == NULL) {
-				printk(KERN_ERR "%s: Failed to get %s\n", __func__, US_XML_ID_ATTR);
-				rc = US_RC_FAIL;
-				break;
-			}
-
-			port = get_dig_number(xmlStr);
-			if (port > max_tx_ports_num) {
-				printk(KERN_ERR "%s: Invalid GMAC id number - %s\n", __func__, xmlStr);
-				rc = US_RC_FAIL;
-				break;
-			}
-
-			xmlQueMap = ezxml_child(xmlGmac, US_XML_QUEUE_MAP_E);
-			for (xmlQue = ezxml_child(xmlQueMap, US_XML_QUEUE_E); xmlQue; xmlQue = xmlQue->next) {
-				rc = get_tx_queue_attrs(xmlQue, port, gmac_tx, max_tx_queues_num);
-
-				if (rc != US_RC_OK) {
-					stop_parsing = 1;
-					break;
-				}
-			}
-		}
-
-#ifdef US_DEBUG_PRINT
-		{
-			int que;
-
-			printk("======================================\n");
-			printk("               GMAC TX                \n");
-			printk("======================================\n");
-			for (port = 0; port < max_tx_ports_num; port++) {
-				if (gmac_tx[port].valid) {
-					printk("TX port %d  \n", port);
-					printk("------------\n");
-
-					for (que = 0; que < max_tx_queues_num; que++) {
-						if (gmac_tx[port].tx_queue[que].valid) {
-							printk(KERN_INFO
-								"TX queue %d: valid %d owner %d owner num %d "
-								"size %d weight %d sched %d\n",
-								que, gmac_tx[port].tx_queue[que].valid,
-								gmac_tx[port].tx_queue[que].queue_owner,
-								gmac_tx[port].tx_queue[que].owner_queue_num,
-								gmac_tx[port].tx_queue[que].queue_size,
-								gmac_tx[port].tx_queue[que].queue_weight,
-								gmac_tx[port].tx_queue[que].sched_method);
-						}
-					}
-					/*} */
-				}
-				printk("======================================\n");
-			}
-		}
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_pnc_range_params()
-*
-* DESCRIPTION:      Get PnC ranges parameters from XML configuration file
-*
-* INPUTS:   max_pnc_ranges_num  - MAX PnC ranges in the system
-*
-* OUTPUTS:  pnc_range           - pointer to the internal PnC range table
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_pnc_range_params(tpm_init_pnc_range_t *pnc_range, int max_pnc_ranges_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlRange;
-	int rc = US_RC_OK;
-
-	if (pnc_range == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	if (max_pnc_ranges_num == 0) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid max_pnc_ranges_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(pnc_range, 0, sizeof(tpm_init_pnc_range_t) * max_pnc_ranges_num);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_PNC_E, 0, US_XML_TPM_PNC_RANGE_PARAMS_E, -1);
-	if (xmlElement == NULL)
-		rc = US_RC_FAIL;
-	else {
-		for (xmlRange = ezxml_child(xmlElement, US_XML_TPM_PNC_RANGE_E); xmlRange; xmlRange = xmlRange->next) {
-			rc = get_pnc_range_attrs(xmlRange, pnc_range, max_pnc_ranges_num);
-
-			if (rc != US_RC_OK)
-				break;
-		}
-
-#ifdef US_DEBUG_PRINT
-		{
-			int range;
-
-			printk("======================================\n");
-			printk("              PnC range               \n");
-			printk("======================================\n");
-			for (range = 0; range < max_pnc_ranges_num; range++) {
-				if (pnc_range[range].valid)
-					printk("%d: num %d type %d size %d cntr_grp %d "
-						"lu_mask %d min_res_level %d\n",
-						range,
-						pnc_range[range].range_num,
-						pnc_range[range].range_type,
-						pnc_range[range].range_size,
-						pnc_range[range].cntr_grp,
-						pnc_range[range].lu_mask, pnc_range[range].min_reset_level);
-			}
-			printk("======================================\n");
-		}
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ds_mh_config_params()
-*
-* DESCRIPTION:      Get downstream MH parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  ds_mh_set - from PnC RI or Rx ctrl reg
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ds_mh_config_params(tpm_init_mh_src_t *dsMhConf)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (dsMhConf == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*dsMhConf = TPM_MH_SRC_RX_CTRL;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_DS_MH_SET_E, &val);
-
-	if (rc == US_RC_OK) {
-		*dsMhConf = (tpm_init_mh_src_t) val;
-
-#ifdef US_DEBUG_PRINT
-		printk("dsMhConf = %d\n", *dsMhConf);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_validation_enabled_config_params()
-*
-* DESCRIPTION:      Get validation enable parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  validation_enabled - enable or not TPM validation
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_validation_enabled_config_params(tpm_init_tpm_validation_t *validEn)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (validEn == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*validEn = TPM_VALID_DISABLED;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_VALID_EN_E, &val);
-
-	if (rc == US_RC_OK) {
-		*validEn = (tpm_init_tpm_validation_t) val;
-
-#ifdef US_DEBUG_PRINT
-		printk("validEn = %d\n", *validEn);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_epon_connect_tpm_params()
-*
-* DESCRIPTION:      Get EPON connect TPM APIS parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  connected - disconnect or connected.
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_epon_connect_tpm_params(PON_connect_type_t *connected)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (connected == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*connected = ONU_PON_CONNECT;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_EPON_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_EPON_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_EPON_CONNECT_E, &val);
-
-	if (rc == US_RC_OK) {
-		*connected = (PON_connect_type_t) val;
-
-#ifdef US_DEBUG_PRINT
-		printk("connected = %d\n", *connected);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_epon_oam_rx_q_params()
-*
-* DESCRIPTION:      Get EPON CPU OAM RX Q parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  OAM CPU RX Queue value
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_epon_oam_rx_q_params(uint32_t *oam_cpu_rx_queue)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (oam_cpu_rx_queue == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	/* default queue is 7 - highest queue */
-	*oam_cpu_rx_queue = 7;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_EPON_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_EPON_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_EPON_OAM_RXQ_E, &val);
-
-	if (rc == US_RC_OK) {
-		*oam_cpu_rx_queue = val;
-
-#ifdef US_DEBUG_PRINT
-		printk("oam_cpu_rx_queue = %d\n", *oam_cpu_rx_queue);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_cfg_pnc_parse_param()
-*
-* DESCRIPTION:      Get mode of how to configure the PNC PARSE in LSP
-*
-* INPUTS:
-*
-* OUTPUTS:  cfgPncParse - enabled/disabled
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_cfg_pnc_parse_param(tpm_init_cfg_pnc_parse_t *cfgPncParse)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (cfgPncParse == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*cfgPncParse = TPM_NONE;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else
-		rc = get_int_param(xmlElement, US_XML_CFG_PNC_PARSER, &val);
-
-	if (rc == US_RC_OK) {
-		*cfgPncParse = (tpm_init_cfg_pnc_parse_t) val;
-
-#ifdef US_DEBUG_PRINT
-		printk("cfgPncParse = %d\n", *cfgPncParse);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_cpu_loopback_param()
-*
-* DESCRIPTION:      Get CPU egress loopback state
-*
-* INPUTS:
-*
-* OUTPUTS:  cfgCpuLoopback - enabled/disabled
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_cpu_loopback_param(tpm_init_cpu_loopback_t *cpuLoopback)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (cpuLoopback == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*cpuLoopback = TPM_NONE;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else
-		rc = get_int_param(xmlElement, US_XML_CFG_CPU_LOOPBACK, &val);
-
-	if (rc == US_RC_OK) {
-		*cpuLoopback = (tpm_init_cpu_loopback_t) val;
-
-#ifdef US_DEBUG_PRINT
-		printk("cfgCpuLoopback = %d\n", *cpuLoopback);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_trace_debug_info_param()
-*
-* DESCRIPTION:      Get mode of how to configure the PNC PARSE in LSP
-*
-* INPUTS:
-*
-* OUTPUTS:  cfgPncParse - enabled/disabled
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_trace_debug_info_param(uint32_t *trace_debug_info)
-{
-
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	uint32_t val;
-
-	if (trace_debug_info == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*trace_debug_info = 0x00000000;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else
-		rc = get_int_param(xmlElement, US_XML_TRACE_DEBUG_info, &val);
-
-	if (rc == US_RC_OK) {
-		*trace_debug_info = val;
-
-#ifdef US_DEBUG_PRINT
-		printk("trace_debug_info = 0x%x\n", *trace_debug_info);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_vitual_uni_enable_params()
-*
-* DESCRIPTION:      Get WiFi via GMAC1 feature parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the WiFi via GMAC1 is enabled
-*           port   - port number for WiFi identification
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_vitual_uni_enable_params(uint32_t *enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val1;
-
-	if (enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-
-		printk(KERN_ERR "get_wifi_vitual_uni_enable_params => NULL pointer\n");
-		return US_RC_FAIL;
-	}
-
-	*enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else {
-		rc = get_int_param(xmlElement, US_XML_WIFI_ENABLED, &val1);
-		/* add port parameter to the XML - in the future - meantime default port: UNI_4 = 5 */
-		/*        rc |= get_int_param (xmlElement, US_XML_WIFI_PORT, &val2);*/
-	}
-
-	if (rc == US_RC_OK) {
-		*enable = val1;
-
-#ifdef US_DEBUG_PRINT
-		printk("wifi_vir_uni_enable => en= %d\n", *enable);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-
-}
-
-#if 0
-/*******************************************************************************
-* get_default_vlan_tpid_params()
-*
-* DESCRIPTION:      Get double tag support parameter from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the WiFi via GMAC1 is enabled
-*           port   - port number for WiFi identification
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_default_vlan_tpid_params(uint16_t *v1_tpid, uint16_t *v2_tpid)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val1, val2;
-
-	if ((v1_tpid == NULL) || (v2_tpid == NULL)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-
-		return US_RC_FAIL;
-	}
-
-	*v1_tpid = *v2_tpid = 0x8100;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else {
-		rc |= get_int_param(xmlElement, US_XML_DEF_V1_TPID, &val1);
-		rc |= get_int_param(xmlElement, US_XML_DEF_V2_TPID, &val2);
-	}
-
-	if (rc == US_RC_OK) {
-		*v1_tpid = val1;
-		*v2_tpid = val2;
-
-#ifdef US_DEBUG_PRINT
-		printk(KERN_INFO"get_double_tag_support_params => v1_tpid= 0x%x  v2_tpid= 0x%x\n", *v1_tpid, *v2_tpid);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-
-}
-#endif
-
-/*******************************************************************************
-* get_default_vlan_tpid_params()
-*
-* DESCRIPTION:      Get double tag support parameter from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - whether the WiFi via GMAC1 is enabled
-*           port   - port number for WiFi identification
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_default_vlan_tpid_params(uint32_t *opt_num, tpm_init_tpid_comb_t *opt)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlTpid;
-	int optNum;
-	int rc;
-
-	if ((opt_num == NULL) || (opt == NULL)) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	optNum = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_VLAN_FILTER_TPID_E, -1);
-	if (xmlElement == NULL) {
-		printk("Failed to find %s in XML config. file %s\n", US_XML_TPM_VLAN_FILTER_TPID_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else {
-		for (xmlTpid = ezxml_child(xmlElement, US_XML_TPM_FILTER_TPID_E); \
-			xmlTpid && (optNum < TPM_MAX_TPID_COMB_NUM); \
-			xmlTpid = xmlTpid->next, optNum++) {
-			rc = get_filter_tpid_attrs(xmlTpid, &(opt[optNum]));
-			if (rc != US_RC_OK)
-			break;
-		}
-		*opt_num = optNum;
-	}
-
-	return rc;
-}
-
-/*******************************************************************************
-* get_pon_def_params()
-*
-* DESCRIPTION: Get PON default parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  param[PON_XML_DEF_PAR_SERIAL_NUM]		- serial number
-*           param[PON_XML_DEF_PAR_PASSWORD]			- password
-*           param[PON_XML_DEF_PAR_DIS_SERIAL_NUM]	- whether SN should be disabled
-*           param[PON_XML_DEF_PARAM_CLEAR_GEM]		- whether gem ports should be removed on reset
-*           param[PON_XML_DEF_PARAM_CLEAR_TCONT]	- whether tconts should be removed on reset
-*   		param[PON_XML_DEF_PARAM_SERIAL_NUM_SRC]	- whether serial number should be taken from xml
-*   													or should the digit part be taken from MAC address
-*   		param[PON_XML_DEF_PARAM_XVR_POLARITY]	- tranceiver polarity
-*   		param[PON_XML_DEF_PARAM_DG_POLARITY]	- dying gasp polarity
-*   		param[PON_XML_DEF_PARAM_RESTORE_GEM]	- whether restore or not GEM ports after returning
-*   													from state-7 (EMG STOP)
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_pon_def_params (void  **param)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-	int	paramIdx;
-	unsigned char   *sn = (unsigned char *)param[PON_XML_DEF_PAR_SERIAL_NUM];
-	unsigned char   *pswd = (unsigned char *)param[PON_XML_DEF_PAR_PASSWORD];
-
-	if (param == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: parameters list is a NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	for (paramIdx = PON_XML_DEF_PAR_SERIAL_NUM; paramIdx < PON_XML_DEF_PARAM_MAX; paramIdx++) {
-		if (param[paramIdx] == NULL) {
-#ifdef US_DEBUG_PRINT
-			printk(KERN_ERR "%s: parameter #%d is a NULL pointer\n", __func__, paramIdx);
-#endif
-			return US_RC_FAIL;
-		}
-	}
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_PON_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_PON_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-
-	} else {
-
-		sn[0] = '\0';
-		rc = get_char_param(xmlElement, US_XML_PON_SN_E, sn, US_XML_PON_SN_LEN);
-		pswd[0] = '\0';
-		rc |= get_char_param(xmlElement, US_XML_PON_PASSWD_E, pswd, US_XML_PON_PASSWD_LEN);
-		*(uint32_t *)param[PON_XML_DEF_PAR_DIS_SERIAL_NUM] = 0;
-		rc |= get_int_param(xmlElement, US_XML_PON_DIS_SN_E, (uint32_t *)param[PON_XML_DEF_PAR_DIS_SERIAL_NUM]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_CLEAR_GEM] = 0;
-		rc |= get_int_param (xmlElement, US_XML_PON_GEM_RST_E, (uint32_t *)param[PON_XML_DEF_PARAM_CLEAR_GEM]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_CLEAR_TCONT] = 0;
-		rc |= get_int_param(xmlElement, US_XML_PON_TCONT_RST_E, (uint32_t *)param[PON_XML_DEF_PARAM_CLEAR_TCONT]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_SERIAL_NUM_SRC] = 0;
-		rc |= get_int_param(xmlElement, US_XML_PON_SN_SRC_E, (uint32_t *)param[PON_XML_DEF_PARAM_SERIAL_NUM_SRC]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_XVR_POLARITY] = 0;
-		rc |= get_int_param(xmlElement, US_XML_PON_XVR_POL_E, (uint32_t *)param[PON_XML_DEF_PARAM_XVR_POLARITY]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_DG_POLARITY] = 1;
-		rc |= get_int_param(xmlElement, US_XML_PON_DG_POL_E, (uint32_t *)param[PON_XML_DEF_PARAM_DG_POLARITY]);
-		*(uint32_t *)param[PON_XML_DEF_PARAM_RESTORE_GEM] = 1;
-		rc |= get_int_param(xmlElement, US_XML_PON_GEM_RESTOR_E, (uint32_t *)param[PON_XML_DEF_PARAM_RESTORE_GEM]);
-
-#ifdef US_DEBUG_PRINT
-		printk(KERN_DEBUG "PON default params: SN %s pswd %s dis %d\n", sn, pswd,
-			   *(uint32_t *)param[PON_XML_DEF_PAR_DIS_SERIAL_NUM]);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_epon_def_params()
-*
-* DESCRIPTION: Get EPON default parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  dba_mode      - DBA mode is either 0 for SW or 1 for HW
-*           xvr_pol       - XVR polarity (0 - high, 1 - low)
-*           dg_pol        - Dying Gasp polarity (1 - high, 0 - low)
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_epon_def_params(unsigned long *xvr_pol, unsigned long *dg_pol)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_EPON_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_EPON_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else {
-		*xvr_pol = 0;
-		rc = get_int_param(xmlElement, US_XML_EPON_XVR_POL_E, (uint32_t *) xvr_pol);
-		*dg_pol = 1;
-		rc |= get_int_param(xmlElement, US_XML_EPON_DG_POL_E, (uint32_t *) dg_pol);
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_pon_dg_polarity()
-*
-* DESCRIPTION: Get PON Dying Gasp polarity value from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  dg_pol - Daing Gasp polarity is either 0 for high or 1 for low
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_pon_dg_polarity(unsigned long *dg_pol)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_PON_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_PON_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else {
-		*dg_pol = 1;
-		rc = get_int_param(xmlElement, US_XML_PON_DG_POL_E, (uint32_t *) dg_pol);
-		if (rc == US_RC_NOT_FOUND) {
-			printk(KERN_ERR "Failed to find %s tag in XML config. file \n", US_XML_PON_DG_POL_E);
-			*dg_pol = 1;
-			rc = US_RC_OK;
-		}
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-
-}
-
-/*******************************************************************************
-* get_vlan_etypes_params()
-*
-* DESCRIPTION:      Get VLAN ETY parameters from XML configuration file
-*
-* INPUTS:   vlan_ety_reg_num    - Number of VLAN ETY registers in the system
-*
-* OUTPUTS:  mod_tpid            - pointer to the VLANs ETY table
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_vlan_mod_vlan_tpid_params(uint32_t *mod_vlan_tpid, int mod_vlan_tpid_reg_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlEty;
-	int rc = US_RC_OK, i;
-
-	if (mod_vlan_tpid == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	if (mod_vlan_tpid_reg_num == 0) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: Invalid vlan_ety_reg_num \n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	for (i = 0; i < mod_vlan_tpid_reg_num; i++)
-		mod_vlan_tpid[i] = MV_TPM_UN_INITIALIZED_INIT_PARAM;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_VLAN_TPID_E, -1);
-	if (xmlElement == NULL)
-		rc = US_RC_NOT_FOUND;
-	else {
-		for (xmlEty = ezxml_child(xmlElement, US_XML_TPM_MOD_TPID_E); xmlEty; xmlEty = xmlEty->next) {
-			rc = get_vlan_ety_attrs(xmlEty, mod_vlan_tpid, mod_vlan_tpid_reg_num);
-
-			if (rc != US_RC_OK)
-				break;
-		}
-
-#ifdef US_DEBUG_PRINT
-		{
-			int reg;
-
-			printk("============================\n");
-			printk("  Reg#   VLAN etype   \n");
-			printk("============================\n");
-			for (reg = 0; reg < mod_vlan_tpid_reg_num; reg++)
-				printk("   %d        0x%x\n", reg, mod_vlan_tpid[reg]);
-
-			printk("============================\n");
-		}
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_modification_params()
-*
-* DESCRIPTION: Get TPM modification parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  config  - configuration parameters of Modification table
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_modification_params(tpm_init_mod_params_t *config)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (config == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	config->udp_checksum_use_init_bm = 0;
-	config->udp_checksum_update = 0;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_E, -1);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_MOD_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc |= get_int_param(xmlElement, US_XML_TPM_MOD_UDP_CKS_USE_INIT_E, &config->udp_checksum_use_init_bm);
-		rc |= get_int_param(xmlElement, US_XML_TPM_MOD_UDP_CKS_CALC_E, &config->udp_checksum_update);
-
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_chain_config_params()
-*
-* DESCRIPTION:      Get num_vlan_tags parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  num_vlan_tags - vlan nmuber
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_chain_config_params(tpm_init_mod_chain_t *mod_chain)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	ezxml_t xmlChain;
-	int chainNum;
-	int rc;
-
-	if (mod_chain == NULL)
-		return US_RC_FAIL;
-
-	memset(mod_chain, 0, sizeof(tpm_init_mod_chain_t));
-	chainNum = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_E, 0, US_XML_TPM_MOD_CHAIN_PARAM_E, -1);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TPM_MOD_CHAIN_PARAM_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else {
-		for (xmlChain = ezxml_child(xmlElement, US_XML_TPM_MOD_CHAIN_E);
-		     xmlChain && (chainNum < TPM_MAX_MOD_CHAIN_NUM); xmlChain = xmlChain->next, chainNum++) {
-			rc = get_mod_chain_attrs(xmlChain, &(mod_chain->chain_data[chainNum]));
-
-			if (rc != US_RC_OK)
-				break;
-		}
-
-		mod_chain->chain_num = chainNum;
-	}
-
-	return rc;
-}
-
-/* jinghua add for MTU setting */
-/*******************************************************************************
-* get_mtu_enable()
-*
-* DESCRIPTION:      Get mtu enable parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - mtu enable
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_mtu_enable(tpm_init_mtu_setting_enable_t *enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_MTU_SETTING_ENABLE_E, &val);
-		if (rc == US_RC_OK) {
-			*enable = (tpm_init_mtu_setting_enable_t) val;
-
-#ifdef US_DEBUG_PRINT
-			printk("US_XML_MTU_SETTING_ENABLE_E: enable %d \n", *enable);
-#endif
-		}
-
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv4_mtu_us()
-*
-* DESCRIPTION:      Get ipv4 mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv4 mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv4_mtu_us(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV4_MTU_US_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV4_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv4_pppoe_mtu_us()
-*
-* DESCRIPTION:      Get ipv4 pppoe mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv4 pppoe mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv4_pppoe_mtu_us(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV4_PPPOE_MTU_US_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV4_PPPOE_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv6_mtu_us()
-*
-* DESCRIPTION:      Get ipv6 mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv6 mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv6_mtu_us(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV6_MTU_US_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV6_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv6_pppoe_mtu_us()
-*
-* DESCRIPTION:      Get ipv6 pppoe mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv6 pppoe mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv6_pppoe_mtu_us(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV6_PPPOE_MTU_US_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV6_PPPOE_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv4_mtu_ds()
-*
-* DESCRIPTION:      Get ipv4 mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv4 mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv4_mtu_ds(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV4_MTU_DS_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV4_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_ipv6_mtu_ds()
-*
-* DESCRIPTION:      Get ipv6 mtu parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  mtu - ipv6 mtu
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_ipv6_mtu_ds(uint32_t *mtu)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mtu == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mtu = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MTU_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MTU_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV6_MTU_DS_E, mtu);
-
-#ifdef US_DEBUG_PRINT
-		printk("IPV6_MTU: mtu %d \n", *mtu);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_pppoe_add_enable()
-*
-* DESCRIPTION:      Get get_pppoe_add_enable parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - pppoe_enable
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_pppoe_add_enable(tpm_init_pppoe_add_enable_t *enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_PPPOE_ENABLE_E, &val);
-		if (rc == US_RC_OK) {
-			*enable = (tpm_init_pppoe_add_enable_t) val;
-
-#ifdef US_DEBUG_PRINT
-			printk("PPPOE_ENABLE: enable %d \n", *enable);
-#endif
-		}
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_num_vlan_tags()
-*
-* DESCRIPTION:      Get num_vlan_tags parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  num_vlan_tags - vlan nmuber
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_num_vlan_tags(uint32_t *num_vlan_tags)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (num_vlan_tags == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*num_vlan_tags = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_NUM_VLAN_TAGS_E, num_vlan_tags);
-
-#ifdef US_DEBUG_PRINT
-		printk("num_vlan_tags %d \n", *num_vlan_tags);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_cpu_rx_queue(uint32_t *cpu_rx_queue)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (cpu_rx_queue == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*cpu_rx_queue = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_CPU_RX_QUEUE_E, cpu_rx_queue);
-
-#ifdef US_DEBUG_PRINT
-		printk("cpu_rx_queue %d \n", *cpu_rx_queue);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ttl_illegal_action(uint32_t *ttl_illegal_action)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (ttl_illegal_action == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ttl_illegal_action = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_TTL_ZERO_ACTION_E, ttl_illegal_action);
-
-#ifdef US_DEBUG_PRINT
-		printk("ttl_illegal_action %d \n", *ttl_illegal_action);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_tcp_flag_check(uint32_t *tcp_flag_check)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (tcp_flag_check == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*tcp_flag_check = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_TCP_FLAG_CHECK_E, tcp_flag_check);
-
-#ifdef US_DEBUG_PRINT
-		printk("tcp_flag_check %d \n", *tcp_flag_check);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_mc_filter_mode(tpm_mc_filter_mode_t *mc_filter_mode)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mc_filter_mode == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mc_filter_mode = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_MC_FILTER_MODE_E, mc_filter_mode);
-
-#ifdef US_DEBUG_PRINT
-		printk("mc_filter_mode %d \n", *mc_filter_mode);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_mc_per_uni_vlan_xlat(uint32_t *mc_per_uni_vlan_xlat)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mc_per_uni_vlan_xlat == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mc_per_uni_vlan_xlat = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_MC_PER_UNI_VLAN_XLAT_E, mc_per_uni_vlan_xlat);
-
-#ifdef US_DEBUG_PRINT
-		printk("mc_per_uni_vlan_xlat %d \n", *mc_per_uni_vlan_xlat);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_mc_pppoe_enable(uint32_t *mc_pppoe_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (mc_pppoe_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*mc_pppoe_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_MC_PPPOE_ENABLE_E, mc_pppoe_enable);
-
-#ifdef US_DEBUG_PRINT
-		printk("mc_pppoe_enable %d \n", *mc_pppoe_enable);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_mc_queue(uint32_t *hwf_queue, uint32_t *cpu_queue)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (hwf_queue == NULL || cpu_queue == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*hwf_queue = 0;
-	*cpu_queue = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_MC_HWF_Q_E, hwf_queue);
-
-#ifdef US_DEBUG_PRINT
-		printk("mc_hwf_queue %d \n", *hwf_queue);
-#endif
-
-		if (*hwf_queue >= 8) {
-			printk(KERN_ERR "%s: Invalid mc_hwf_queue %d\n", __func__, *hwf_queue);
-			rc = US_RC_FAIL;
-		}
-
-		rc = get_int_param(xmlElement, US_XML_MC_CPU_Q_E, cpu_queue);
-
-#ifdef US_DEBUG_PRINT
-		printk("mc_cpu_queue %d \n", *cpu_queue);
-#endif
-
-		if (*cpu_queue >= 8) {
-			printk(KERN_ERR "%s: Invalid mc_cpu_queue %d\n", __func__, *cpu_queue);
-			rc = US_RC_FAIL;
-		}
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_catch_all_pkt_action(uint32_t *catch_all_pkt_action)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (catch_all_pkt_action == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*catch_all_pkt_action = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_PNC_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_CATCH_ALL_PKT_ACTION_E, catch_all_pkt_action);
-
-#ifdef US_DEBUG_PRINT
-		printk("catch_all_pkt_action %d \n", *catch_all_pkt_action);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ety_dsa_enable(uint32_t *ety_dsa_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (ety_dsa_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ety_dsa_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TRAFFIC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TRAFFIC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_ETY_DSA_ENABLE_E, ety_dsa_enable);
-
-#ifdef US_DEBUG_PRINT
-		printk("ety_dsa_enable %d \n", *ety_dsa_enable);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ipv6_5t_enable(uint32_t *ipv6_5t_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (ipv6_5t_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ipv6_5t_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV6_5T_ENA_E, ipv6_5t_enable);
-
-#ifdef US_DEBUG_PRINT
-		printk("ipv6_5t_enable %d \n", *ipv6_5t_enable);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ipv4_mc_support(uint32_t *ipv4_mc_support)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (ipv4_mc_support == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ipv4_mc_support = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV4_MC_SUPPORT_E, ipv4_mc_support);
-
-#ifdef US_DEBUG_PRINT
-		printk("ipv4_mc_support %d \n", *ipv4_mc_support);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ipv6_mc_support(uint32_t *ipv6_mc_support)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (ipv6_mc_support == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ipv6_mc_support = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_MC_SETTING_E);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_MC_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_IPV6_MC_SUPPORT_E, ipv6_mc_support);
-
-#ifdef US_DEBUG_PRINT
-		printk("ipv6_mc_support %d \n", *ipv6_mc_support);
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_split_mod_enable()
-*
-* DESCRIPTION:      Get split mod enable parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  enable - split enable
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_split_mod_enable(uint32_t *split_mod_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (split_mod_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*split_mod_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_E, 0, US_XML_SPLIT_MOD_SETTING_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_SPLIT_MOD_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_SPLIT_MOD_ENABLE_E, &val);
-		if (rc == US_RC_OK) {
-			*split_mod_enable = (tpm_init_split_mod_enable_t) val;
-
-#ifdef US_DEBUG_PRINT
-			printk("split_mod_enable %d \n", *split_mod_enable);
-#endif
-		}
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_split_mod_mode(tpm_init_split_mod_mode_t *split_mod_mode)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (split_mod_mode == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*split_mod_mode = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_SPLIT_MOD_MODE_E, &val);
-		if (rc == US_RC_OK) {
-			*split_mod_mode = (tpm_init_split_mod_mode_t)val;
-
-#ifdef US_DEBUG_PRINT
-			printk("split_mod_mode %d \n", *split_mod_mode);
-#endif
-		}
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-static int get_pbit_param(ezxml_t xml, char *name, uint8_t *pbit, uint32_t *pbit_num)
-{
-	ezxml_t xmlElement;
-	char tmp[30];
-	uint8_t len,i,j,k;
-
-	memset(tmp, '\0', 30);
-
-	xmlElement = ezxml_child(xml, name);
-	if (xmlElement == NULL)
-		return US_RC_NOT_FOUND;
-	else if (xmlElement->txt == NULL) {
-		printk(KERN_ERR "NULL value for %s in XML config. file\n", name);
-		return US_RC_NOT_FOUND;
-	}
-	len = strlen(xmlElement->txt);
-	for (i = 0, j = 0, k = 0; i < len;) {
-		while((xmlElement->txt[i] != ',') && (i < len)) {
-			if (xmlElement->txt[i] != ' ') {
-				tmp[k] = xmlElement->txt[i];
-				k++;
-			}
-			i++;
-		}
-		pbit[j] = get_dig_number(tmp);
-		memset(tmp, '\0', 30);
-		j++;
-		i++;
-		k = 0;
-	}
-	/*get valid pbit num*/
-	*pbit_num = j;
-
-	return US_RC_OK;
-}
-
-/*******************************************************************************
-* get_split_mot_p_bits()
-*
-* DESCRIPTION:      Get split mod p_bits supported parameters from XML configuration file
-*
-* INPUTS:
-*
-* OUTPUTS:  p_bits[] - p_bit supported
-*	    p_bit_num - number of valid p_bit
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_split_mot_p_bits(uint8_t *p_bits, uint32_t *p_bit_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint8_t i = 0;
-
-	if (p_bits == NULL || p_bit_num == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	memset(p_bits,0xFF,8);
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_E, 0, US_XML_SPLIT_MOD_SETTING_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_SPLIT_MOD_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_pbit_param(xmlElement, US_XML_SPLIT_MOD_P_BITS_E, &p_bits[0], p_bit_num);
-
-#ifdef US_DEBUG_PRINT
-		printk("split_mod_p_bit: ");
-		for (i = 0; i < 8; i++) {
-			if (p_bits[i] != 0xFF)
-				printk("%d ", p_bits[i]);
-		}
-		printk("\n");
-#endif
-	}
-
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-/*******************************************************************************
-* get_split_mod_vlan_num()
-*
-* DESCRIPTION:      Get vlan number that needs split pbit and vid modification
-*
-* INPUTS:
-*
-* OUTPUTS:  split_vlan_num - vlan nmuber
-*
-* RETURNS:  US_RC_OK, US_RC_FAIL or US_RC_NOT_FOUND
-*
-*******************************************************************************/
-int get_split_mod_vlan_num(uint32_t *split_vlan_num)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-
-	if (split_vlan_num == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*split_vlan_num = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, 0, US_XML_TPM_MOD_E, 0, US_XML_SPLIT_MOD_SETTING_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_SPLIT_MOD_SETTING_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_SPLIT_MOD_VLAN_NUM_E, split_vlan_num);
-
-#ifdef US_DEBUG_PRINT
-		printk("split_vlan_num %d \n", *split_vlan_num);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_ctc_cm_enable(uint32_t *ctc_cm_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (ctc_cm_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ctc_cm_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_CTC_CNM_ENA_E, &val);
-		if (rc == US_RC_OK) {
-			*ctc_cm_enable = (tpm_init_ctc_cm_enable_t)val;
-
-#ifdef US_DEBUG_PRINT
-			printk("ctc_cnm_enable %d \n", *ctc_cm_enable);
-#endif
-		}
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-int get_ctc_cm_ipv6_parse_window(uint32_t *ctc_cm_ipv6_parse_window)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (ctc_cm_ipv6_parse_window == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*ctc_cm_ipv6_parse_window = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_CTC_CNM_IPv6_PARSE_WIN_E, &val);
-		if (rc == US_RC_OK) {
-			*ctc_cm_ipv6_parse_window = val;
-
-#ifdef US_DEBUG_PRINT
-			printk("ipv6_parse_window_t %d \n", *ctc_cm_ipv6_parse_window);
-#endif
-		}
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-
-int get_pnc_mac_learn_enable(uint32_t *pnc_mac_learn_enable)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (pnc_mac_learn_enable == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	*pnc_mac_learn_enable = 0;
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_get(xmlHead, US_XML_TPM_E, -1);
-	if (xmlElement == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n",
-			US_XML_TPM_E, g_pstr_xml_cfg_file);
-#endif
-		rc = US_RC_NOT_FOUND;
-	} else {
-		rc = get_int_param(xmlElement, US_XML_PNC_MAC_LEARN_ENA_E, &val);
-		if (rc == US_RC_OK) {
-			*pnc_mac_learn_enable = (tpm_init_pnc_mac_learn_enable_t)val;
-
-#ifdef US_DEBUG_PRINT
-			printk("pnc_mac_learn_enable %d \n", *pnc_mac_learn_enable);
-#endif
-		}
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
-int get_switch_init_params(uint32_t *switch_init)
-{
-	ezxml_t xmlHead;
-	ezxml_t xmlElement;
-	int rc = US_RC_OK;
-	uint32_t val;
-
-	if (switch_init == NULL) {
-#ifdef US_DEBUG_PRINT
-		printk(KERN_ERR "%s: NULL pointer\n", __func__);
-#endif
-		return US_RC_FAIL;
-	}
-
-	xmlHead = get_xml_head_ptr(g_pstr_xml_cfg_file);
-
-	if (xmlHead == NULL)
-		return US_RC_FAIL;
-
-	xmlElement = ezxml_child(xmlHead, US_XML_TPM_E);
-	if (xmlElement == NULL) {
-		printk(KERN_ERR "Failed to find %s in XML config. file %s\n", US_XML_TPM_E, g_pstr_xml_cfg_file);
-		rc = US_RC_NOT_FOUND;
-	} else
-		rc = get_int_param(xmlElement, US_XML_SWITCH_INIT_E, &val);
-
-	if (rc == US_RC_OK) {
-		*switch_init = val;
-
-#ifdef US_DEBUG_PRINT
-		printk("switch_init = %d\n", *switch_init);
-#endif
-	}
-	/*ezxml_free(xmlHead); */
-	return rc;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.h
deleted file mode 100644
index 88d65ae..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/core/tpm_xml_params.h
+++ /dev/null
@@ -1,380 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-#ifndef _TPM_XML_PARAMS_H_
-#define _TPM_XML_PARAMS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define US_XML_PON_SN_LEN          (8)
-#define US_XML_PON_PASSWD_LEN      (10)
-
-#define US_RC_OK           0
-#define US_RC_FAIL         1
-#define US_RC_NOT_FOUND    2
-
-typedef enum {
-	NONE_SW_APP = 0,
-	EPON_SW_APP,
-	GPON_SW_APP,
-	GBE_SW_APP,
-	P2P_SW_APP,
-
-	MAX_SW_APP
-} us_sw_app_t;
-
-typedef enum {
-	US_DISABLED = 0,
-	US_ENABLED
-} us_enabled_t;
-
-typedef enum {
-	US_OFF = 0,
-	US_ON
-} us_state_t;
-
-typedef enum {
-	ONU_PON_DISCONNECT = 0,
-	ONU_PON_CONNECT
-} PON_connect_type_t;
-
-typedef enum {
-	PON_XML_DEF_PAR_SERIAL_NUM         = 0,
-	PON_XML_DEF_PAR_PASSWORD           = 1,
-	PON_XML_DEF_PAR_DIS_SERIAL_NUM     = 2,
-	PON_XML_DEF_PARAM_CLEAR_GEM        = 3,
-	PON_XML_DEF_PARAM_CLEAR_TCONT      = 4,
-	PON_XML_DEF_PARAM_SERIAL_NUM_SRC   = 5,
-	PON_XML_DEF_PARAM_XVR_POLARITY     = 6,
-	PON_XML_DEF_PARAM_DG_POLARITY      = 7,
-	PON_XML_DEF_PARAM_RESTORE_GEM      = 8,
-	PON_XML_DEF_PARAM_MAX
-
-} PON_XML_DEF_PARAMS;
-
-#define US_RC_OK           0
-#define US_RC_FAIL         1
-#define US_RC_NOT_FOUND    2
-
-#define US_XML_CFG_FILE            "/etc/xml_params/tpm_xml_cfg_file.xml"
-#define US_XML_CFG_FILE_OMCI       "/etc/xml_params/omci_xml_cfg_file.xml"
-#define US_XML_CFG_FILE_PON        "/etc/xml_params/pon_xml_cfg_file.xml"
-#define US_XML_CFG_FILE_GLOBAL     "/etc/xml_params/pon_type_xml_cfg_file.xml"
-
-#define US_DEBUG_PRINT
-
-#define US_XML_PON_E               "PON"
-#define US_XML_PON_TYPE_E          "WAN_type"
-#define US_XML_PON_TYPE_FORCE_E    "WAN_type_force"
-#define US_XML_PON_SN_E            "PON_serial_num"
-#define US_XML_PON_PASSWD_E        "PON_passwd"
-#define US_XML_PON_DIS_SN_E        "PON_dis_sn"
-#define US_XML_PON_GEM_RST_E       "PON_gem_reset"
-#define US_XML_PON_TCONT_RST_E     "PON_tcont_reset"
-#define US_XML_PON_SN_SRC_E        "PON_serial_src"
-#define US_XML_PON_DG_POL_E        "PON_DG_polarity"
-#define US_XML_PON_XVR_POL_E       "PON_XVR_polarity"
-#define US_XML_PON_GEM_RESTOR_E    "PON_gem_restore"
-
-#define US_XML_EPON_E               "EPON"
-#define US_XML_EPON_CONNECT_E       "EPON_connect_tpm"
-#define US_XML_EPON_DG_POL_E        "EPON_DG_polarity"
-#define US_XML_EPON_XVR_POL_E       "EPON_XVR_polarity"
-#define US_XML_EPON_OAM_RXQ_E       "EPON_OAM_RX_queue"
-
-#define US_XML_OMCI_E              "OMCI"
-#define US_XML_OMCI_ETY_E          "OMCI_ETY"
-
-#define US_XML_DS_MAC_BASED_TRUNKING_E        "ds_mac_based_trunking"
-#define US_XML_IGMP_SNOOP_E        "igmp_snoop"
-#define US_XML_IGMP_SNOOP_ALL_E    "snoop_all"
-#define US_XML_ENABLED_E           "enabled"
-#define US_XML_IGMP_CPU_Q_E        "igmp_cpu_rx_queue"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_0           "igmp_frwrd_mode_uni0"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_1           "igmp_frwrd_mode_uni1"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_2           "igmp_frwrd_mode_uni2"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_3           "igmp_frwrd_mode_uni3"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_4           "igmp_frwrd_mode_uni4"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_5           "igmp_frwrd_mode_uni5"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_6           "igmp_frwrd_mode_uni6"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_7           "igmp_frwrd_mode_uni7"
-#define US_XML_IGMP_PKT_FRWD_MODE_UNI_VIRT        "igmp_frwrd_mode_uni_virt"
-#define US_XML_IGMP_PKT_FRWD_MODE_WAN             "igmp_frwrd_mode_wan"
-
-#define US_XML_PORT_INIT_E         "port_init"
-#define US_XML_DEBUG_PORT_E        "debug_port"
-#define US_XML_INT_PORT_E          "int_port"
-
-#define US_XML_ETH_PORT_PARAMS_E   "Ethernet_parameters"
-#define US_XML_ETH_PORT_E          "Ethernet"
-#define US_XML_ETH_CHIP_CONN_ATTR  "chip_connect"
-#define US_XML_ETH_INT_CONN_ATTR   "int_connect"
-#define US_XML_ETH_SW_PORT_ATTR    "switch_ports"
-#define US_XML_GMAC_PORTS_E        "gmac_ports"
-#define US_XML_ETH_ADMIN_ATTR      "admin_state"
-#define US_XML_ETH_SPEED_ATTR      "speed"
-#define US_XML_ETH_DUPLEX_ATTR     "duplex"
-#define US_XML_ETH_PORT_SRC_ATTR   "src_port"
-#define US_XML_ETH_PORT_CHIPCON_ATTR "chip_conn"
-#define US_XML_ETH_GMAC_CONN_ATTR  "conn"
-#define US_XML_ETH_PORT_INTCON_ATTR "intr_conn"
-#define US_XML_ETH_CMPLX_CONFIG_E  "eth_complex_config"
-#define US_XML_WAN_E		    "WAN"
-#define US_XML_ACTIVE_WAN_E        "active_wan"
-#define US_XML_VIRTUAL_UNI_E       "virtual_uni"
-
-#define US_XML_ETH_PROFILE_E       "profile"
-
-#define US_XML_GMAC_CONFIG_E       "gmac_config"
-#define US_XML_GMAC_CONN_E         "pon_config"
-#define US_XML_TCONT_LLID_E        "num_tcont_llid"
-#define US_XML_GMAC_MH_ENA_E       "gmac_mh_en"
-#define US_XML_GMAC_0_MH_ENA_E     "gmac0_mh_en"
-#define US_XML_GMAC_1_MH_ENA_E     "gmac1_mh_en"
-
-#define US_XML_GMAC_BM_BUF_E       "gmac_bm_buffers"
-#define US_XML_LARGE_POOL_BUF_ATTR "large_pkt_pool_bufs"
-#define US_XML_SHORT_POOL_BUF_ATTR "small_pkt_pool_bufs"
-
-#define US_XML_GMAC_RXQUEUES_E     "gmac_rx_queues"
-
-#define US_XML_TX_MOD_PARAMS_E     "tx_module_parameters"
-#define US_XML_TX_MOD_E            "tx_mod"
-#define US_XML_QUEUE_MAP_E         "queue_map"
-#define US_XML_QUEUE_E             "queue"
-#define US_XML_QUEUE_SHED_ATTR     "sched_method"
-#define US_XML_QUEUE_OWNER_ATTR    "owner"
-#define US_XML_QUEUE_OW_Q_NUM_ATTR "owner_q_num"
-#define US_XML_QUEUE_WEIGHT_ATTR   "weight"
-
-#define US_XML_FC_PARAMS_E         "flow_control"
-#define US_XML_Q_SAMPLE_FREQ_E     "queue_sample_freq"
-#define US_XML_THRESH_HIGH_E       "thresh_high"
-#define US_XML_THRESH_LOW_E        "thresh_low"
-#define US_XML_TGT_PORT_E          "tgt_port"
-#define US_XML_TX_PORT_E           "tx_port"
-#define US_XML_TX_Q_E              "tx_queue"
-
-
-#define US_XML_TPM_E               "TPM"
-#define US_XML_DS_MH_SET_E         "ds_mh_set"
-#define US_XML_VALID_EN_E          "validation_enable"
-#define US_XML_CFG_PNC_PARSER      "pnc_config"
-#define US_XML_CFG_CPU_LOOPBACK    "cpu_wan_egr_loopback"
-#define US_XML_TRACE_DEBUG_info    "trace_debug_info"
-#define US_XML_IPV6_5T_ENA_E       "ipv6_5t_enable"
-#define US_XML_CTC_CNM_ENA_E       "ctc_cnm_enable"
-#define US_XML_WIFI_ENABLED        "gmac1_virt_uni"
-#define US_XML_IPV4_MC_SUPPORT_E   "ipv4_mc_support"
-#define US_XML_IPV6_MC_SUPPORT_E   "ipv6_mc_support"
-#define US_XML_CTC_CNM_IPv6_PARSE_WIN_E       "ctc_cnm_ipv6_parsing_window"
-#define US_XML_PNC_MAC_LEARN_ENA_E "pnc_mac_learn_enable"
-#define US_XML_SWITCH_INIT_E       "switch_init"
-
-/*#define US_XML_WIFI_PORT           "Vitual_UNI_GMAC1_port"*/
-
-#if 0
-#define US_XML_DEF_V1_TPID         "vlan1_tpid"
-#define US_XML_DEF_V2_TPID         "vlan2_tpid"
-#endif
-#define US_XML_TPM_VLAN_FILTER_TPID_E     "vlan_filter_tpid"
-#define US_XML_TPM_FILTER_TPID_E          "filter_tpid"
-
-
-#define US_XML_TPM_PNC_E                  "PnC"
-#define US_XML_TPM_PNC_RANGE_PARAMS_E     "range_parameters"
-#define US_XML_TPM_PNC_RANGE_E            "range"
-#define US_XML_TPM_CNTR_GRP_ATTR          "cntr_grp"
-#define US_XML_TPM_LU_MASK_ATTR           "lu_mask"
-#define US_XML_TPM_MIN_RES_LVL_ATTR       "min_reset_level"
-#define US_XML_TPM_MOD_VLAN_TPID_E        "vlan_mod_tpid"
-#define US_XML_TPM_MOD_TPID_E             "mod_tpid"
-#define US_XML_TPM_MOD_E                  "modification"
-#define US_XML_TPM_MOD_UDP_CKS_USE_INIT_E "udp_checksum_use_init"
-#define US_XML_TPM_MOD_UDP_CKS_CALC_E     "udp_checksum_calc"
-#define US_XML_SPLIT_MOD_SETTING_E        "split_mod"
-#define US_XML_SPLIT_MOD_ENABLE_E         "enable"
-#define US_XML_SPLIT_MOD_P_BITS_E         "p_bits"
-#define US_XML_SPLIT_MOD_VLAN_NUM_E       "vlan_num"
-#define US_XML_SPLIT_MOD_MODE_E           "split_mod_mode"
-
-
-#define US_XML_TPM_MOD_CHAIN_PARAM_E     "chain_parameters"
-#define US_XML_TPM_MOD_CHAIN_E           "chain"
-#define US_XML_TPM_CHAIN_ID_ATTR         "id"
-#define US_XML_TPM_CHAIN_TYPE_ATTR       "type"
-#define US_XML_TPM_CHAIN_NUM_ATTR        "num"
-
-#define US_XML_ID_ATTR             "id"
-#define US_XML_GMAC_E              "gmac"
-#define US_XML_PORT_E              "port"
-#define US_XML_SIZE_ATTR           "size"
-#define US_XML_NUM_ATTR            "num"
-#define US_XML_TYPE_ATTR           "type"
-#define US_XML_VALID_ATTR          "valid"
-
-
-#define US_XML_MTU_SETTING_E          "mtu_setting"
-
-#define US_XML_MTU_SETTING_ENABLE_E   "mtu_setting_enabled"
-#define US_XML_IPV4_MTU_US_E          "ipv4_mtu_us"
-#define US_XML_IPV4_PPPOE_MTU_US_E    "ipv4_pppoe_mtu_us"
-#define US_XML_IPV6_MTU_US_E          "ipv6_mtu_us"
-#define US_XML_IPV6_PPPOE_MTU_US_E    "ipv6_pppoe_mtu_us"
-#define US_XML_IPV4_MTU_DS_E          "ipv4_mtu_ds"
-#define US_XML_IPV6_MTU_DS_E          "ipv6_mtu_ds"
-
-#define US_XML_TRAFFIC_SETTING_E      "traffic_setting"
-#define US_XML_PPPOE_ENABLE_E         "pppoe_add_enable"
-#define US_XML_NUM_VLAN_TAGS_E        "num_vlan_tags"
-#define US_XML_CPU_RX_QUEUE_E         "cpu_trap_rx_queue"
-#define US_XML_TTL_ZERO_ACTION_E      "ttl_illegal_action"
-#define US_XML_TCP_FLAG_CHECK_E       "tcp_flag_check"
-#define US_XML_ETY_DSA_ENABLE_E       "ety_dsa_enable"
-
-
-#define US_XML_MC_SETTING_E                  "multicast"
-#define US_XML_MC_FILTER_MODE_E              "mc_filter_mode"
-#define US_XML_MC_PER_UNI_VLAN_XLAT_E        "mc_per_uni_vlan_xlat"
-#define US_XML_MC_PPPOE_ENABLE_E             "mc_pppoe_enable"
-#define US_XML_MC_HWF_Q_E                    "mc_hwf_queue"
-#define US_XML_MC_CPU_Q_E                    "mc_cpu_queue"
-#define US_XML_CATCH_ALL_PKT_ACTION_E        "catch_all_pkt_action"
-
-/*******************************************************************************
-*                             Configuration functions
-*******************************************************************************/
-int get_pon_type_param(tpm_init_pon_type_t *pon_type);
-int get_omci_etype_param(uint32_t *ety);
-int get_debug_port_params(uint32_t *valid, uint32_t *num);
-int get_igmp_snoop_params_enable(uint32_t *enable);
-int get_ds_mac_based_trunking_enable(uint32_t *enable);
-int get_igmp_snoop_params_cpu_queue(uint32_t *que);
-int get_igmp_snoop_params_port_frwd_mode(uint32_t *mode, tpm_src_port_type_t port);
-int get_gmac_conn_params(uint32_t *num_tcont_llid);
-int get_gmac_mh_en_params(uint32_t *gmac0_mh_en, uint32_t *gmac1_mh_en);
-int get_eth_cmplx_profile_params(tpm_eth_complex_profile_t *eth_cmplx_profile);
-int get_gmac_port_conf_params(tpm_init_gmac_conn_conf_t *gmac_port_conf_bufs, int max_gmac_port_num);
-int get_eth_port_conf_params(tpm_init_eth_port_conf_t *eth_port_bufs, int max_eth_port_num);
-int get_active_wan_params(uint32_t *active_wan);
-
-int get_gmac_pool_bufs_params(tpm_init_gmac_bufs_t *gmac_bufs, int max_gmacs_num);
-int get_trace_debug_info_param(uint32_t *trace_debug_info);
-int get_validation_enabled_config_params(tpm_init_tpm_validation_t *validEn);
-int get_vitual_uni_enable_params(uint32_t *enable);
-#if 0
-int get_default_vlan_tpid_params(uint16_t *v1_tpid, uint16_t *v2_tpid);
-#endif
-int get_default_vlan_tpid_params(uint32_t *opt_num, tpm_init_tpid_comb_t *opt);
-int get_fc_def_params(tpm_init_fc_params_t *port_fc_conf);
-int get_gmac_rxq_params(tpm_init_gmac_rx_t *gmac_rx, int max_gmacs_num, int max_rx_queues_num);
-int get_gmac_tx_params(tpm_init_gmac_tx_t *gmac_tx, int max_tx_ports_num, int max_tx_queues_num);
-int get_pnc_range_params(tpm_init_pnc_range_t *pnc_range, int max_pnc_ranges_num);
-int get_ds_mh_config_params(tpm_init_mh_src_t *dsMhConf);
-int get_vlan_mod_vlan_tpid_params(uint32_t *mod_vlan_tpid, int mod_vlan_tpid_reg_num);
-int get_modification_params(tpm_init_mod_params_t *config);
-int get_chain_config_params(tpm_init_mod_chain_t *mod_chain);
-int get_cfg_pnc_parse_param(tpm_init_cfg_pnc_parse_t *cfgPncParse);
-int get_cpu_loopback_param(tpm_init_cpu_loopback_t *cpuLoopback);
-
-void free_xml_head_ptr(void);
-
-/* jinghua add for MTU setting */
-
-int get_ipv4_mtu_us(uint32_t *mtu);
-int get_ipv4_pppoe_mtu_us(uint32_t *mtu);
-int get_ipv6_mtu_us(uint32_t *mtu);
-int get_ipv6_pppoe_mtu_us(uint32_t *mtu);
-int get_ipv4_mtu_ds(uint32_t *mtu);
-int get_ipv6_mtu_ds(uint32_t *mtu);
-int get_pppoe_add_enable(tpm_init_pppoe_add_enable_t *enable);
-int get_num_vlan_tags(uint32_t *num_vlan_tags);
-int get_mtu_enable(tpm_init_mtu_setting_enable_t *enable);
-int get_cpu_rx_queue(uint32_t *cpu_rx_queue);
-int get_ttl_illegal_action(uint32_t *ttl_illegal_action);
-int get_tcp_flag_check(uint32_t *tcp_flag_check);
-
-int get_mc_filter_mode(tpm_mc_filter_mode_t *mc_filter_mode);
-int get_mc_per_uni_vlan_xlat(uint32_t *mc_per_uni_vlan_xlat);
-int get_mc_pppoe_enable(uint32_t *mc_pppoe_enable);
-int get_mc_queue(uint32_t *hwf_queue, uint32_t *cpu_queue);
-int get_catch_all_pkt_action(uint32_t *catch_all_pkt_action);
-int get_ety_dsa_enable(uint32_t *ety_dsa_enable);
-int get_ipv6_5t_enable(uint32_t *ipv6_5t_enable);
-int get_ipv4_mc_support(uint32_t *ipv4_mc_support);
-int get_ipv6_mc_support(uint32_t *ipv6_mc_support);
-int get_split_mod_enable(uint32_t *split_mod_enable);
-int get_split_mot_p_bits(uint8_t *p_bits, uint32_t *p_bit_num);
-int get_split_mod_vlan_num(uint32_t *split_vlan_num);
-int get_split_mod_mode(tpm_init_split_mod_mode_t *split_mod_mode);
-int get_ctc_cm_enable(uint32_t *ctc_cm_enable);
-int get_ctc_cm_ipv6_parse_window(uint32_t *ctc_cm_ipv6_parse_window);
-int get_pnc_mac_learn_enable(uint32_t *pnc_mac_learn_enable);
-int get_switch_init_params(uint32_t *switch_init);
-
-#ifdef __cplusplus
-}
-#endif
-#endif				/* _PARAMS_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_bring_up.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_bring_up.c
deleted file mode 100644
index c357dfd..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_bring_up.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_bring_up.c                                             **
-**                                                                           **
-**  DESCRIPTION : This file implements TPM BringUp handling                  **
-*******************************************************************************
-*                                                                             *
-*  MODIFICATION HISTORY:                                                      *
-*                                                                             *
-*   11Aug10  Yuval Caduri   created                                         *
-* =========================================================================== *
-******************************************************************************/
-
-/* Include Files
-------------------------------------------------------------------------------*/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-/* Local Constant
-------------------------------------------------------------------------------*/
-
-/* Global Variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Local Variables
-------------------------------------------------------------------------------*/
-
-/* Export Functions
-------------------------------------------------------------------------------*/
-
-/* Local Functions
-------------------------------------------------------------------------------*/
-
-static int __init mv_tpm_module_init(void)
-{
-  tpm_module_init();
-
-  /* create mng interface */
-  tpm_module_mng_if_create();
-
-  /* create user interface */
-  tpm_module_usr_if_create();
-
-  printk(KERN_INFO "= TPM Module Init ended successfully =\n");
-
-  return(0);
-}
-
-static void __exit mv_tpm_module_exit(void)
-{
-  printk(KERN_INFO "= TPM Module Exit =\n");
-
-  /* release allocated memory */
-  /*  - TODO - */
-
-  /* release rtos resources */
-  /*  - TODO - */
-
-  /* release mng interface */
-  tpm_module_mng_if_release();
-}
-
-module_init(mv_tpm_module_init);
-module_exit(mv_tpm_module_exit);
-
-MODULE_AUTHOR("Yuval Caduri");
-MODULE_DESCRIPTION("TPM Driver for Marvell MV65xxx");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.c
deleted file mode 100644
index f5ddf89..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.c
+++ /dev/null
@@ -1,3843 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_mng_if.c                                               **
-**                                                                           **
-**  DESCRIPTION : This file implements ONU TPM Management Interface          **
-*******************************************************************************
-*                                                                             *
-*  MODIFICATION HISTORY:                                                      *
-*                                                                             *
-*   11Aug10  Oren Ben Hayun   created                                         *
-* =========================================================================== *
-******************************************************************************/
-
-/* Include Files
-------------------------------------------------------------------------------*/
-#include <linux/thread_info.h>
-#include <linux/version.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_mempool.h"
-
-
-
-
-/* Local Structures
-------------------------------------------------------------------------------*/
-/* Mempools used by ioctl, 3 size: Small, Medium Large and Huge */
-typedef struct
-{
-    tpm_common_mempool_t *mpool_s;
-    tpm_common_mempool_t *mpool_m;
-    tpm_common_mempool_t *mpool_l;
-    tpm_common_mempool_t *mpool_h;
-} tpm_ioctl_mpools_t;
-
-#define MPOOL_S_MAX_BUFF_SIZE   300
-#define MPOOL_M_MAX_BUFF_SIZE  1024
-#define MPOOL_L_MAX_BUFF_SIZE  2048
-#define MPOOL_H_MAX_BUFF_SIZE  4096
-
-/* TPM Char Device Structure */
-/* ========================= */
-typedef struct
-{
-  tpm_ioctl_admin_t           tpm_ioctl_admin;
-  tpm_ioctl_add_acl_rule_t    tpm_ioctl_add_acl_rule;
-  tpm_ioctl_del_acl_rule_t    tpm_ioctl_del_acl_rule;
-  tpm_ioctl_ctrl_acl_rule_t   tpm_ioctl_ctrl_acl_rule;
-  tpm_ioctl_mc_rule_t         tpm_ioctl_mc_rule;
-  tpm_ioctl_mng_ch_t          tpm_ioctl_mng_ch;
-  tpm_ioctl_sw_mac_security_t tpm_ioctl_sw_mac_security;
-  tpm_ioctl_sw_vlan_filter_t  tpm_ioctl_sw_vlan_filter;
-  tpm_ioctl_sw_tm_t           tpm_ioctl_sw_tm;
-  tpm_ioctl_tm_tm_t           tpm_ioctl_tm_tm;
-  tpm_ioctl_igmp_t            tpm_ioctl_igmp;
-  tpm_ioctl_mib_reset_t       tpm_ioctl_mib_reset;
-  tpm_ioctl_set_active_wan_t  tpm_ioctl_set_active_wan;
-  tpm_ioctl_swport_pm_3_t     apm_ioctl_pm_ethernet_3;
-  tpm_ioctl_rx_igmp_t         tpm_ioctl_rx_igmp;
-  tpm_ioctl_tx_igmp_t         tpm_ioctl_tx_igmp;
-  tpm_ioctl_cpu_lpbk_t        tpm_ioctl_cpu_lpbk;
-  tpm_ioctl_age_count_t       tpm_ioctl_age_count;
-  tpm_ioctl_mc_vid_t          tpm_ioctl_mc_vid;
-  struct cdev  cdev;
-}tpm_module_cdev_t;
-
-
-
-/* Local Constant
-------------------------------------------------------------------------------*/
-
-/* Global Variables
-------------------------------------------------------------------------------*/
-extern GT_QD_DEV *qd_dev;
-extern int32_t module_tpmSetup(tpm_setup_t *tpm_initp);
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-struct semaphore    tpm_sfs_2_ioctl_sem;
-tpm_ioctl_mng_t     tpm_sfs_2_ioctl_command;
-#endif
-
-/* Local Variables
-------------------------------------------------------------------------------*/
-static int        deviceOpen = 0;
-tpm_module_cdev_t tpm_dev;
-static tpm_ioctl_mpools_t  tpm_ioctl_mpools= {0,0,0,0};
-
-/* udev class's */
-struct class  *tpm_udev_class;
-struct device *tpm_udev_dev;
-
-/* Export Functions
-------------------------------------------------------------------------------*/
-
-/* Local Functions
-------------------------------------------------------------------------------*/
-
-/*******************************************************************************
-**
-**  mv_tpm_cdev_ioctl
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function execute IO commands
-**
-**  PARAMETERS:  struct file *filp
-**               unsigned int cmd
-**               unsigned long arg
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-long mv_tpm_cdev_ioctl(struct file *filp, unsigned int cmd,
-                      unsigned long arg)
-{
-
-  tpm_init_t                    *tpm_initp      = NULL;
-  void                          *mpool_s_buff   = NULL;
-  void                          *mpool_m_buff   = NULL;
-  void                          *mpool_l_buff   = NULL;
-  void                          *mpool_h_buff   = NULL;
-  tpm_ioctl_mib_reset_t         tpm_mib_reset_param;
-  GT_STATUS                     rc = GT_OK;
-  tpm_error_code_t              rcode;
-  int                           ret = -EINVAL;
-
-
-  //onuTpmIrqLock();
-
-  /* Init Struct created by malloc, due to kernel_stack_size limit reached */
-  /* TODO: Seperate init_api's into seperate ioctl */
-
-  switch(cmd)
-  {
-      /* =========================== */
-      /* ====== Init Section ======= */
-      /* =========================== */
-      case MV_TPM_IOCTL_INIT_SECTION:
-          tpm_initp = (tpm_init_t *) kmalloc(sizeof(tpm_init_t), GFP_USER);
-          if (tpm_initp == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) kmalloc failed\n", __FUNCTION__, __LINE__);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-
-          if(copy_from_user(tpm_initp, (tpm_init_t*)arg, sizeof(tpm_init_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          rcode = tpm_module_start(tpm_initp);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-
-      case MV_TPM_IOCTL_SETUP_SECTION:
-      {
-          tpm_setup_t *tpm_setup = (tpm_setup_t *)tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_setup == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_setup;
-
-          if(copy_from_user(tpm_setup, (tpm_setup_t*)arg, sizeof(tpm_setup_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          rcode = module_tpmSetup(tpm_setup);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-          ret=0;
-          break;
-      }
-
-      /* =========================== */
-      /* ====== Admin Section ====== */
-      /* =========================== */
-      case MV_TPM_IOCTL_ADMIN_SECTION:
-      {
-          tpm_ioctl_admin_t *tpm_admin = (tpm_ioctl_admin_t *)tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_admin == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_admin;
-
-          if(copy_from_user(tpm_admin, (tpm_ioctl_admin_t*)arg, sizeof(tpm_ioctl_admin_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_admin->amdin_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_CRT_OWNER =============== */
-              case MV_TPM_IOCTL_CRT_OWNER:
-
-                  rcode = tpm_create_ownerid(&(tpm_admin->owner_id));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_admin_t*)arg, tpm_admin, sizeof(tpm_ioctl_admin_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-
-              /* ====== MV_TPM_IOCTL_REQ_API_G_OWNER ========= */
-              case MV_TPM_IOCTL_REQ_API_G_OWNER:
-
-                  tpm_admin->api_ownership_error = tpm_request_api_ownership(tpm_admin->owner_id,
-                                                                             tpm_admin->api_type);
-
-                  if(copy_to_user((tpm_ioctl_admin_t*)arg, tpm_admin, sizeof(tpm_ioctl_admin_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-
-              /* ====== MV_TPM_IOCTL_GET_API_G_OWNER ========= */
-              case MV_TPM_IOCTL_GET_API_G_OWNER:
-
-                  tpm_admin->api_ownership_error = tpm_request_api_ownership(tpm_admin->owner_id,
-                                                                             tpm_admin->api_type);
-
-                  if(copy_to_user((tpm_ioctl_admin_t*)arg, tpm_admin, sizeof(tpm_ioctl_admin_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_SECTION ========= */
-              case MV_TPM_IOCTL_DEL_SECTION:
-
-                  rcode = tpm_erase_section(tpm_admin->owner_id,
-                                            tpm_admin->api_type);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_GET_SECTION_SIZE ========= */
-              case MV_TPM_IOCTL_GET_SECTION_SIZE:
-
-                  rcode = tpm_get_section_free_size(tpm_admin->api_type,
-                                                    &(tpm_admin->section_size));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_admin_t*)arg, tpm_admin, sizeof(tpm_ioctl_admin_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== ACL Rule Add Section ====== */
-      /* ================================== */
-      case MV_TPM_IOCTL_ADD_ACL_SECTION:
-      {
-          tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = (tpm_ioctl_add_acl_rule_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-
-          if (tpm_add_acl_rule == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_add_acl_rule;
-          if(copy_from_user(tpm_add_acl_rule, (tpm_ioctl_add_acl_rule_t*)arg, sizeof(tpm_ioctl_add_acl_rule_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_add_acl_rule->add_acl_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_ADD_L2_ACL_RULE ========= */
-              case MV_TPM_IOCTL_ADD_L2_ACL_RULE:
-
-                  rcode = tpm_add_l2_rule( tpm_add_acl_rule->owner_id,
-                                           tpm_add_acl_rule->src_port,
-                                           tpm_add_acl_rule->rule_num,
-                                          &(tpm_add_acl_rule->rule_idx),
-                                           tpm_add_acl_rule->parse_rule_bm,
-                                           tpm_add_acl_rule->l2_acl_rule.parse_flags_bm,
-                                          &(tpm_add_acl_rule->l2_acl_rule.l2_key),
-                                          &(tpm_add_acl_rule->l2_acl_rule.pkt_frwd),
-                                          &(tpm_add_acl_rule->l2_acl_rule.pkt_mod),
-                                           tpm_add_acl_rule->l2_acl_rule.pkt_mod_bm,
-                                          &(tpm_add_acl_rule->l2_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_MAC_LEARN_ACL_RULE ========= */
-              case MV_TPM_IOCTL_ADD_MAC_LEARN_ACL_RULE:
-                  rcode = tpm_add_mac_learn_rule(tpm_add_acl_rule->owner_id,
-                                                 &(tpm_add_acl_rule->l2_acl_rule.l2_key));
-                  if(rcode != TPM_OK)
-                      goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                      printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                      goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SET_MAC_LEARN_DEFAULT_ACTION ========= */
-              case MV_TPM_IOCTL_SET_MAC_LEARN_DEFAULT_ACTION:
-                  rcode = tpm_mac_learn_default_rule_act_set(tpm_add_acl_rule->owner_id,
-                                                             tpm_add_acl_rule->l2_acl_rule.mac_conf);
-                  if(rcode != TPM_OK)
-                      goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                      printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                      goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_L3_ACL_RULE ========= */
-              case MV_TPM_IOCTL_ADD_L3_ACL_RULE:
-
-                  rcode = tpm_add_l3_type_rule(  tpm_add_acl_rule->owner_id,
-                                                 tpm_add_acl_rule->src_port,
-                                                 tpm_add_acl_rule->rule_num,
-                                                &(tpm_add_acl_rule->rule_idx),
-                                                 tpm_add_acl_rule->parse_rule_bm,
-                                                 tpm_add_acl_rule->l3_acl_rule.parse_flags_bm,
-                                                &(tpm_add_acl_rule->l3_acl_rule.l3_key),
-                                                &(tpm_add_acl_rule->l3_acl_rule.pkt_frwd),
-                                                &(tpm_add_acl_rule->l3_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_IPv4_ACL_RULE ========= */
-              case MV_TPM_IOCTL_ADD_IPv4_ACL_RULE:
-
-                  rcode = tpm_add_ipv4_rule(  tpm_add_acl_rule->owner_id,
-                                              tpm_add_acl_rule->src_port,
-                                              tpm_add_acl_rule->rule_num,
-                                             &(tpm_add_acl_rule->rule_idx),
-                                              tpm_add_acl_rule->parse_rule_bm,
-                                              tpm_add_acl_rule->ipv4_acl_rule.parse_flags_bm,
-                                             &(tpm_add_acl_rule->ipv4_acl_rule.ipv4_key),
-                                             &(tpm_add_acl_rule->ipv4_acl_rule.pkt_frwd),
-                                             &(tpm_add_acl_rule->ipv4_acl_rule.pkt_mod),
-                                              tpm_add_acl_rule->ipv4_acl_rule.pkt_mod_bm,
-                                             &(tpm_add_acl_rule->ipv4_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_IPv6_ACL_RULE ========= */
-              case MV_TPM_IOCTL_ADD_IPV6_GEN_ACL_RULE:
-
-                  rcode = tpm_add_ipv6_gen_rule(  tpm_add_acl_rule->owner_id,
-                                                    tpm_add_acl_rule->src_port,
-                                                    tpm_add_acl_rule->rule_num,
-                                                  &(tpm_add_acl_rule->rule_idx),
-                                                    tpm_add_acl_rule->parse_rule_bm,
-                                                    tpm_add_acl_rule->ipv6_gen_acl_rule.parse_flags_bm,
-                                                  &(tpm_add_acl_rule->ipv6_gen_acl_rule.ipv6_gen_key),
-                                                  &(tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_frwd),
-                                                  &(tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_mod),
-                                                    tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_mod_bm,
-                                                  &(tpm_add_acl_rule->ipv6_gen_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_ADD_IPV6_NH_ACL_RULE:
-
-                  rcode = tpm_add_ipv6_nh_rule(  tpm_add_acl_rule->owner_id,
-                                                 tpm_add_acl_rule->rule_num,
-                                               &(tpm_add_acl_rule->rule_idx),
-                                                 tpm_add_acl_rule->parse_rule_bm,
-                                                 tpm_add_acl_rule->ipv6_nh_acl_rule.nh_iter,
-                                                 tpm_add_acl_rule->ipv6_nh_acl_rule.nh,
-                                               &(tpm_add_acl_rule->ipv6_nh_acl_rule.pkt_frwd),
-                                               &(tpm_add_acl_rule->ipv6_nh_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_ADD_IPV6_DIP_ACL_RULE:
-
-                  rcode = tpm_add_ipv6_dip_rule(  tpm_add_acl_rule->owner_id,
-                                                  tpm_add_acl_rule->src_port,
-                                                  tpm_add_acl_rule->rule_num,
-                                                &(tpm_add_acl_rule->rule_idx),
-                                                  tpm_add_acl_rule->parse_rule_bm,
-                                                  tpm_add_acl_rule->ipv6_dip_acl_rule.parse_flags_bm,
-                                                &(tpm_add_acl_rule->ipv6_dip_acl_rule.ipv6_dip_key),
-                                                &(tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_frwd),
-                                                &(tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_mod),
-                                                  tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_mod_bm,
-                                                &(tpm_add_acl_rule->ipv6_dip_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_ACL_RULE:
-
-                  rcode = tpm_add_ipv6_l4_ports_rule(  tpm_add_acl_rule->owner_id,
-                                                       tpm_add_acl_rule->src_port,
-                                                       tpm_add_acl_rule->rule_num,
-                                                     &(tpm_add_acl_rule->rule_idx),
-                                                       tpm_add_acl_rule->parse_rule_bm,
-                                                       tpm_add_acl_rule->ipv6_l4_ports_acl_rule.parse_flags_bm,
-                                                     &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.l4_key),
-                                                     &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_frwd),
-                                                     &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod),
-                                                       tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod_bm,
-                                                     &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_IPv6_5T_RULE ========= */
-              case MV_TPM_IOCTL_ADD_IPV6_GEN_5T_RULE:
-
-                  rcode = tpm_add_ipv6_gen_5t_rule( tpm_add_acl_rule->owner_id,
-                                                    tpm_add_acl_rule->src_dir,
-                                                    tpm_add_acl_rule->rule_num,
-                                                  &(tpm_add_acl_rule->rule_idx),
-                                                    tpm_add_acl_rule->parse_rule_bm,
-                                                    tpm_add_acl_rule->ipv6_gen_5t_rule.parse_flags_bm,
-                                                  &(tpm_add_acl_rule->ipv6_gen_5t_rule.l4_key),
-                                                  &(tpm_add_acl_rule->ipv6_gen_5t_rule.ipv6_gen_key),
-                                                  &(tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_frwd),
-                                                  &(tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_mod),
-                                                    tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_mod_bm,
-                                                  &(tpm_add_acl_rule->ipv6_gen_5t_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_ADD_IPV6_DIP_5T_RULE:
-
-                  rcode = tpm_add_ipv6_dip_5t_rule( tpm_add_acl_rule->owner_id,
-                                                    tpm_add_acl_rule->src_dir,
-                                                    tpm_add_acl_rule->rule_num,
-                                                  &(tpm_add_acl_rule->rule_idx),
-                                                    tpm_add_acl_rule->parse_rule_bm,
-                                                    tpm_add_acl_rule->ipv6_dip_5t_rule.parse_flags_bm,
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.l4_key),
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.ipv6_gen_key),
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.ipv6_dip_key),
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_frwd),
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_mod),
-                                                    tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_mod_bm,
-                                                  &(tpm_add_acl_rule->ipv6_dip_5t_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_5T_RULE:
-
-                  rcode = tpm_add_ipv6_l4_ports_5t_rule(  tpm_add_acl_rule->owner_id,
-                                                          tpm_add_acl_rule->src_dir,
-                                                          tpm_add_acl_rule->rule_num,
-                                                        &(tpm_add_acl_rule->rule_idx),
-                                                          tpm_add_acl_rule->parse_rule_bm,
-                                                          tpm_add_acl_rule->ipv6_l4_ports_acl_rule.parse_flags_bm,
-                                                        &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.l4_key),
-                                                        &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_frwd),
-                                                        &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod),
-                                                          tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod_bm,
-                                                        &(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.rule_action));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-         /* ====== MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE ========= */
-         case MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE:
-              rcode = tpm_add_ctc_cm_acl_rule(tpm_add_acl_rule->owner_id,
-                    tpm_add_acl_rule->src_port,
-                    tpm_add_acl_rule->ctc_cm_acl_rule.precedence,
-                    tpm_add_acl_rule->ctc_cm_acl_rule.l2_parse_rule_bm,
-                    tpm_add_acl_rule->ctc_cm_acl_rule.ipv4_parse_rule_bm,
-                    &tpm_add_acl_rule->ctc_cm_acl_rule.l2_key,
-                    &tpm_add_acl_rule->ctc_cm_acl_rule.ipv4_key,
-                    &tpm_add_acl_rule->ctc_cm_acl_rule.pkt_frwd,
-                    tpm_add_acl_rule->ctc_cm_acl_rule.pkt_act,
-                    tpm_add_acl_rule->ctc_cm_acl_rule.p_bits);
-        if (rcode != TPM_OK)
-           goto ioctlErr;
-
-        if (copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t))) {
-           printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-         goto ioctlErr;
-        }
-        ret = 0;
-              break;
-         /* ====== MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE ========= */
-         case MV_TPM_IOCTL_ADD_CTC_CM_IPV6_ACL_RULE:
-             rcode = tpm_add_ctc_cm_ipv6_acl_rule(tpm_add_acl_rule->owner_id,
-                tpm_add_acl_rule->src_port,
-                tpm_add_acl_rule->ctc_cm_acl_rule.precedence,
-                tpm_add_acl_rule->ctc_cm_acl_rule.ipv6_parse_rule_bm,
-                &tpm_add_acl_rule->ctc_cm_acl_rule.ipv6_key,
-                &tpm_add_acl_rule->ctc_cm_acl_rule.pkt_frwd,
-                tpm_add_acl_rule->ctc_cm_acl_rule.pkt_act,
-                tpm_add_acl_rule->ctc_cm_acl_rule.p_bits);
-              if (rcode != TPM_OK)
-               goto ioctlErr;
-
-                   if (copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t))) {
-                 printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                 goto ioctlErr;
-              }
-              ret = 0;
-              break;
-              /* ====== MV_TPM_IOCTL_ADD_DS_LOAD_BALANCE_RULE ========= */
-         case MV_TPM_IOCTL_ADD_DS_LOAD_BALANCE_RULE:
-             rcode = tpm_add_ds_load_balance_rule(tpm_add_acl_rule->owner_id,
-                tpm_add_acl_rule->rule_num,
-                &tpm_add_acl_rule->rule_idx,
-                tpm_add_acl_rule->parse_rule_bm,
-                tpm_add_acl_rule->ds_load_balance_acl_rule.parse_flags_bm,
-                &tpm_add_acl_rule->ds_load_balance_acl_rule.l2_key,
-                tpm_add_acl_rule->ds_load_balance_acl_rule.tgrt);
-              if (rcode != TPM_OK)
-               goto ioctlErr;
-
-                   if (copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t))) {
-                 printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                 goto ioctlErr;
-              }
-              ret = 0;
-              break;
-
-              /* ====== MV_TPM_IOCTL_SET_MOD_RULE ========= */
-              case MV_TPM_IOCTL_SET_MOD_RULE:
-
-                  rcode = tpm_mod_entry_set (  tpm_add_acl_rule->mod_rule.trg_port,
-                                               tpm_add_acl_rule->mod_rule.mod_bm,
-                                               tpm_add_acl_rule->mod_rule.int_bm,
-                                               &(tpm_add_acl_rule->mod_rule.mod_data),
-                                               &(tpm_add_acl_rule->rule_idx) );
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_add_acl_rule_t*)arg, tpm_add_acl_rule, sizeof(tpm_ioctl_add_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== ACL Rule Del Section ====== */
-      /* ================================== */
-      case MV_TPM_IOCTL_DEL_ACL_SECTION:
-      {
-          tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = (tpm_ioctl_del_acl_rule_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_del_acl_rule == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_del_acl_rule;
-
-          if(copy_from_user(tpm_del_acl_rule, (tpm_ioctl_del_acl_rule_t*)arg, sizeof(tpm_ioctl_del_acl_rule_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_del_acl_rule->del_acl_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_DEL_L2_ACL_RULE ========= */
-              case MV_TPM_IOCTL_DEL_L2_ACL_RULE:
-
-                  rcode = tpm_del_l2_rule(  tpm_del_acl_rule->owner_id,
-                                            tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_DS_LOAD_BALANCE_RULE ========= */
-              case MV_TPM_IOCTL_DEL_DS_LOAD_BALANCE_RULE:
-
-                  rcode = tpm_del_ds_load_balance_rule(  tpm_del_acl_rule->owner_id,
-                                            tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-        /* ====== MV_TPM_IOCTL_DEL_MAC_LEARN_ACL_RULE ========= */
-        case MV_TPM_IOCTL_DEL_MAC_LEARN_ACL_RULE:
-            rcode = tpm_del_mac_learn_rule(tpm_del_acl_rule->owner_id,
-                       &tpm_del_acl_rule->l2_key);
-            if(rcode != TPM_OK)
-         goto ioctlErr;
-
-            if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-            {
-         printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-         goto ioctlErr;
-            }
-
-            ret = 0;
-            break;
-
-              /* ====== MV_TPM_IOCTL_DEL_L3_ACL_RULE ========= */
-              case MV_TPM_IOCTL_DEL_L3_ACL_RULE:
-
-                  rcode = tpm_del_l3_type_rule(  tpm_del_acl_rule->owner_id,
-                                                 tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_IPv4_ACL_RULE ========= */
-              case MV_TPM_IOCTL_DEL_IPv4_ACL_RULE:
-
-                  rcode = tpm_del_ipv4_rule(  tpm_del_acl_rule->owner_id,
-                                              tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_IPv6_ACL_RULE ========= */
-              case MV_TPM_IOCTL_DEL_IPV6_GEN_ACL_RULE:
-
-                  rcode = tpm_del_ipv6_gen_rule(  tpm_del_acl_rule->owner_id,
-                                                    tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_IPV6_NH_ACL_RULE:
-
-                  rcode = tpm_del_ipv6_nh_rule(  tpm_del_acl_rule->owner_id,
-                                                 tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_IPV6_DIP_ACL_RULE:
-
-                  rcode = tpm_del_ipv6_dip_rule(  tpm_del_acl_rule->owner_id,
-                                                  tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_IPV6_L4_PORTS_ACL_RULE:
-
-                  rcode = tpm_del_ipv6_l4_ports_rule(  tpm_del_acl_rule->owner_id,
-                                                       tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_IPv6_5T_RULE ========= */
-              case MV_TPM_IOCTL_DEL_IPV6_GEN_5T_RULE:
-
-                  rcode = tpm_del_ipv6_gen_5t_rule(  tpm_del_acl_rule->owner_id,
-                                                     tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_IPV6_DIP_5T_RULE:
-
-                  rcode = tpm_del_ipv6_dip_5t_rule(  tpm_del_acl_rule->owner_id,
-                                                     tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_IPV6_L4_PORTS_5T_RULE:
-
-                  rcode = tpm_del_ipv6_l4_ports_5t_rule(  tpm_del_acl_rule->owner_id,
-                                                          tpm_del_acl_rule->rule_idx);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-          /* ====== MV_TPM_IOCTL_DEL_CTC_CM_ACL_RULE ========= */
-          case MV_TPM_IOCTL_DEL_CTC_CM_ACL_RULE:
-
-         rcode = tpm_del_ctc_cm_acl_rule(tpm_del_acl_rule->owner_id,
-                  tpm_del_acl_rule->src_port,
-                  tpm_del_acl_rule->precedence);
-
-         if (rcode != TPM_OK)
-            goto ioctlErr;
-
-         if (copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t))) {
-         printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-         goto ioctlErr;
-         }
-
-         ret = 0;
-         break;
-
-              /* ====== MV_TPM_IOCTL_DEL_MOD_RULE ========= */
-              case MV_TPM_IOCTL_DEL_MOD_RULE:
-
-                  rcode = tpm_mod_entry_del ( tpm_del_acl_rule->trg_port,
-                                              tpm_del_acl_rule->rule_idx );
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-             /* ====== MV_TPM_IOCTL_INV_MOD_RULES ========= */
-             case MV_TPM_IOCTL_INV_MOD_RULES:
-
-                 rcode = tpm_mod_mac_inv ( tpm_del_acl_rule->trg_port );
-                 if(rcode != TPM_OK)
-                   goto ioctlErr;
-
-                 if(copy_to_user((tpm_ioctl_del_acl_rule_t*)arg, tpm_del_acl_rule, sizeof(tpm_ioctl_del_acl_rule_t)))
-                 {
-                   printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                   goto ioctlErr;
-                 }
-
-                 ret = 0;
-                 break;
-
-               default:
-                 printk(KERN_ERR "ERROR: (%s:%d) invalid cmd(%d)\n", __FUNCTION__, __LINE__, tpm_del_acl_rule->del_acl_cmd);
-                 ret = -EINVAL;
-             }
-             break;
-      }
-
-      /* ================================== */
-      /* ====== ACL Rule Ctrl Section ===== */
-      /* ================================== */
-      case MV_TPM_IOCTL_CTRL_ACL_SECTION:
-      {
-          tpm_ioctl_ctrl_acl_rule_t *tpm_ctrl_acl_rule = (tpm_ioctl_ctrl_acl_rule_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ctrl_acl_rule == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ctrl_acl_rule;
-
-          if(copy_from_user(tpm_ctrl_acl_rule, (tpm_ioctl_ctrl_acl_rule_t*)arg, sizeof(tpm_ioctl_ctrl_acl_rule_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_ctrl_acl_rule->ctrl_acl_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_GET_NEXT_VALID_RULE ========= */
-              case MV_TPM_IOCTL_GET_NEXT_VALID_RULE:
-
-                  rcode = tpm_get_next_valid_rule(  tpm_ctrl_acl_rule->owner_id,
-                                                    tpm_ctrl_acl_rule->current_index,
-                                                    tpm_ctrl_acl_rule->rule_type,
-                                                  &(tpm_ctrl_acl_rule->next_index),
-                                                  &(tpm_ctrl_acl_rule->rule_idx),
-                                                  &(tpm_ctrl_acl_rule->tpm_rule));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_ctrl_acl_rule_t*)arg, tpm_ctrl_acl_rule, sizeof(tpm_ioctl_ctrl_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-               /* ====== MV_TPM_IOCTL_GET_MAC_LEARN_ENTRY_NUM ========= */
-               case MV_TPM_IOCTL_GET_MAC_LEARN_ENTRY_NUM:
-                  rcode = tpm_mac_learn_entry_num_get(&(tpm_ctrl_acl_rule->entry_count));
-                  if (rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_ctrl_acl_rule_t*)arg, tpm_ctrl_acl_rule, sizeof(tpm_ioctl_ctrl_acl_rule_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Mod Rule GET Section  ===== */
-      /* ================================== */
-      case MV_TPM_IOCTL_GET_MOD_SECTION:
-      {
-          tpm_ioctl_get_mod_rule_t *tpm_get_mod_rule = (tpm_ioctl_get_mod_rule_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_m);
-          if (tpm_get_mod_rule == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_m);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_m_buff = tpm_get_mod_rule;
-
-          if(copy_from_user(tpm_get_mod_rule, (tpm_ioctl_get_mod_rule_t*)arg, sizeof(tpm_ioctl_get_mod_rule_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_get_mod_rule->get_mod_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_GET_MOD_RULE ========= */
-              case MV_TPM_IOCTL_GET_MOD_RULE:
-
-                  rcode = tpm_mod_entry_get (tpm_get_mod_rule->trg_port,
-                                             tpm_get_mod_rule->rule_idx,
-                                            &(tpm_get_mod_rule->valid_num),
-                                            &(tpm_get_mod_rule->pnc_ref),
-                                             tpm_get_mod_rule->rule);
-
-                  if(copy_to_user((tpm_ioctl_get_mod_rule_t*)arg, tpm_get_mod_rule, sizeof(tpm_ioctl_get_mod_rule_t)))
-                  {
-                      printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                      goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              default:
-                  ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ===== MC Stream Rule Section ===== */
-      /* ================================== */
-      case MV_TPM_IOCTL_MC_STREAM_SECTION:
-      {
-          tpm_ioctl_mc_rule_t *tpm_mc_rule = (tpm_ioctl_mc_rule_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_mc_rule == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_mc_rule;
-
-          if(copy_from_user(tpm_mc_rule, (tpm_ioctl_mc_rule_t*)arg, sizeof(tpm_ioctl_mc_rule_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_mc_rule->mc_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_ADD_IPv4_MC_STREAM ========= */
-              case MV_TPM_IOCTL_ADD_IPv4_MC_STREAM:
-
-
-                  rcode = tpm_add_ipv4_mc_stream(  tpm_mc_rule->owner_id,
-                                                   tpm_mc_rule->stream_num,
-                                                   tpm_mc_rule->igmp_mode,
-                                                   tpm_mc_rule->mc_stream_pppoe,
-                                                   tpm_mc_rule->vid,
-                                                 &(tpm_mc_rule->ipv4_mc.ipv4_src_add[0]),
-                                                 &(tpm_mc_rule->ipv4_mc.ipv4_dst_add[0]),
-                                                   tpm_mc_rule->ipv4_mc.ignore_ipv4_src,
-                                                   tpm_mc_rule->dest_port_bm);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-              /* ====== MV_TPM_IOCTL_ADD_IPv4_MC_STREAM_SET_QUEUE ========= */
-              case MV_TPM_IOCTL_ADD_IPv4_MC_STREAM_SET_QUEUE:
-
-
-                  rcode = tpm_add_ipv4_mc_stream_set_queue(  tpm_mc_rule->owner_id,
-                                                   tpm_mc_rule->stream_num,
-                                                   tpm_mc_rule->igmp_mode,
-                                                   tpm_mc_rule->mc_stream_pppoe,
-                                                   tpm_mc_rule->vid,
-                                                 &(tpm_mc_rule->ipv4_mc.ipv4_src_add[0]),
-                                                 &(tpm_mc_rule->ipv4_mc.ipv4_dst_add[0]),
-                                                   tpm_mc_rule->ipv4_mc.ignore_ipv4_src,
-                                                   tpm_mc_rule->dest_queue,
-                                                   tpm_mc_rule->dest_port_bm);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_MOD_IPv4_MC_STREAM ========= */
-              case MV_TPM_IOCTL_MOD_IPv4_MC_STREAM:
-
-                  rcode = tpm_updt_ipv4_mc_stream(tpm_mc_rule->owner_id,
-                                                  tpm_mc_rule->stream_num,
-                                                  tpm_mc_rule->dest_port_bm);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_IPv4_MC_STREAM ========= */
-              case MV_TPM_IOCTL_DEL_IPv4_MC_STREAM:
-
-                  rcode = tpm_del_ipv4_mc_stream(tpm_mc_rule->owner_id,
-                                                 tpm_mc_rule->stream_num);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-         /* ====== MV_TPM_IOCTL_ADD_IPv6_MC_STREAM ========= */
-         case MV_TPM_IOCTL_ADD_IPv6_MC_STREAM:
-
-            rcode = tpm_add_ipv6_mc_stream(  tpm_mc_rule->owner_id,
-                         tpm_mc_rule->stream_num,
-                         tpm_mc_rule->igmp_mode,
-                         tpm_mc_rule->mc_stream_pppoe,
-                         tpm_mc_rule->vid,
-                         &(tpm_mc_rule->ipv6_mc.ipv6_src_add[0]),
-                         &(tpm_mc_rule->ipv6_mc.ipv6_dst_add[0]),
-                         tpm_mc_rule->ipv6_mc.ignore_ipv6_src,
-                         tpm_mc_rule->dest_port_bm);
-            if(rcode != TPM_OK)
-             goto ioctlErr;
-
-            ret = 0;
-            break;
-
-         /* ====== MV_TPM_IOCTL_ADD_IPv6_MC_STREAM_SET_QUEUE ========= */
-         case MV_TPM_IOCTL_ADD_IPv6_MC_STREAM_SET_QUEUE:
-
-            rcode = tpm_add_ipv6_mc_stream_set_queue(tpm_mc_rule->owner_id,
-                         tpm_mc_rule->stream_num,
-                         tpm_mc_rule->igmp_mode,
-                         tpm_mc_rule->mc_stream_pppoe,
-                         tpm_mc_rule->vid,
-                         &(tpm_mc_rule->ipv6_mc.ipv6_src_add[0]),
-                         &(tpm_mc_rule->ipv6_mc.ipv6_dst_add[0]),
-                         tpm_mc_rule->ipv6_mc.ignore_ipv6_src,
-                         tpm_mc_rule->dest_queue,
-                         tpm_mc_rule->dest_port_bm);
-            if(rcode != TPM_OK)
-             goto ioctlErr;
-
-            ret = 0;
-            break;
-
-         /* ====== MV_TPM_IOCTL_MOD_IPv6_MC_STREAM ========= */
-         case MV_TPM_IOCTL_MOD_IPv6_MC_STREAM:
-
-            rcode = tpm_updt_ipv6_mc_stream(tpm_mc_rule->owner_id,
-                                    tpm_mc_rule->stream_num,
-                                    tpm_mc_rule->dest_port_bm);
-            if(rcode != TPM_OK)
-             goto ioctlErr;
-
-            ret = 0;
-            break;
-
-         /* ====== MV_TPM_IOCTL_DEL_IPv6_MC_STREAM ========= */
-         case MV_TPM_IOCTL_DEL_IPv6_MC_STREAM:
-
-            rcode = tpm_del_ipv6_mc_stream(tpm_mc_rule->owner_id,
-                                   tpm_mc_rule->stream_num);
-            if(rcode != TPM_OK)
-             goto ioctlErr;
-
-            ret = 0;
-            break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Mng Rule Section ========== */
-      /* ================================== */
-  case MV_TPM_IOCTL_MNG_SECTION:
-  {
-      tpm_ioctl_mng_ch_t *tpm_mng_ch = (tpm_ioctl_mng_ch_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_mng_ch == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_mng_ch;
-
-          if(copy_from_user(tpm_mng_ch, (tpm_ioctl_mng_ch_t*)arg, sizeof(tpm_ioctl_mng_ch_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_mng_ch->mng_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_ADD_OMCI_CHNL ========= */
-              case MV_TPM_IOCTL_ADD_OMCI_CHNL:
-
-                  rcode = tpm_omci_add_channel(tpm_mng_ch->tpm_ioctl_omci_ch.owner_id,
-                                               tpm_mng_ch->tpm_ioctl_omci_ch.gem_port,
-                                               tpm_mng_ch->tpm_ioctl_omci_ch.cpu_rx_queue,
-                                               tpm_mng_ch->tpm_ioctl_omci_ch.tcont_num,
-                                               tpm_mng_ch->tpm_ioctl_omci_ch.cpu_tx_queue);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_OMCI_CHNL ========= */
-              case MV_TPM_IOCTL_DEL_OMCI_CHNL:
-
-                  rcode = tpm_omci_del_channel(tpm_mng_ch->tpm_ioctl_omci_ch.owner_id);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_GET_OMCI_CHNL ========= */
-              case MV_TPM_IOCTL_GET_OMCI_CHNL:
-
-                  rcode = tpm_omci_get_channel(&(tpm_mng_ch->tpm_ioctl_omci_ch.is_valid),
-                                               &(tpm_mng_ch->tpm_ioctl_omci_ch.gem_port),
-                                               &(tpm_mng_ch->tpm_ioctl_omci_ch.cpu_rx_queue),
-                                               &(tpm_mng_ch->tpm_ioctl_omci_ch.tcont_num),
-                                               &(tpm_mng_ch->tpm_ioctl_omci_ch.cpu_tx_queue));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_mng_ch_t*)arg, tpm_mng_ch, sizeof(tpm_ioctl_mng_ch_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_OAM_CHNL ========= */
-              case MV_TPM_IOCTL_ADD_OAM_CHNL:
-
-                  rcode = tpm_oam_epon_add_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id,
-                                                   tpm_mng_ch->tpm_ioctl_oam_ch.cpu_rx_queue,
-                                                   tpm_mng_ch->tpm_ioctl_oam_ch.llid_num);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_LOOP_DETECT_CHNL ========= */
-              case MV_TPM_IOCTL_ADD_LOOP_DETECT_CHNL:
-
-                  rcode = tpm_loop_detect_add_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id,
-                          tpm_mng_ch->loopback_detect_ety);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_LOOP_DETECT_CHNL ========= */
-              case MV_TPM_IOCTL_DEL_LOOP_DETECT_CHNL:
-
-                  rcode = tpm_loop_detect_del_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_OAM_CHNL ========= */
-              case MV_TPM_IOCTL_DEL_OAM_CHNL:
-
-                  rcode = tpm_oam_epon_del_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_GET_OAM_CHNL ========= */
-              case MV_TPM_IOCTL_GET_OAM_CHNL:
-
-                  rcode = tpm_oam_epon_get_channel(&(tpm_mng_ch->tpm_ioctl_oam_ch.is_valid),
-                                                   &(tpm_mng_ch->tpm_ioctl_oam_ch.cpu_rx_queue),
-                                                   &(tpm_mng_ch->tpm_ioctl_oam_ch.llid_num));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_mng_ch_t*)arg, tpm_mng_ch, sizeof(tpm_ioctl_mng_ch_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_ADD_LOOP_DETECT_CHNL ========= */
-              case MV_TPM_IOCTL_ADD_OAM_LOOPBACK_CHNL:
-
-                  rcode = tpm_oam_loopback_add_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_DEL_OAM_LOOPBACK_CHNL:
-
-                  rcode = tpm_oam_loopback_del_channel(tpm_mng_ch->tpm_ioctl_oam_ch.owner_id);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-        }
-
-      /* ================================== */
-      /* ====== Switch Security Section === */
-      /* ================================== */
-      case MV_TPM_IOCTL_SW_SECURITY_SECTION:
-      {
-          tpm_ioctl_sw_mac_security_t *tpm_sw_mac_security = (tpm_ioctl_sw_mac_security_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_sw_mac_security == NULL)
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-              ret = -ENOMEM;
-              goto ioctlErr;
-          }
-          mpool_s_buff = tpm_sw_mac_security;
-
-          if(copy_from_user(tpm_sw_mac_security, (tpm_ioctl_sw_mac_security_t*)arg, sizeof(tpm_ioctl_sw_mac_security_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_sw_mac_security->sw_security_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_SW_ADD_STATIC_MAC ========= */
-              case MV_TPM_IOCTL_SW_ADD_STATIC_MAC:
-                  rcode = tpm_sw_add_static_mac(  tpm_sw_mac_security->owner_id,
-                                                  tpm_sw_mac_security->port,
-                                                &(tpm_sw_mac_security->static_mac[0]));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_DEL_STATIC_MAC ========= */
-              case MV_TPM_IOCTL_SW_DEL_STATIC_MAC:
-                  rcode = tpm_sw_del_static_mac(  tpm_sw_mac_security->owner_id,
-                                                &(tpm_sw_mac_security->static_mac[0]));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_PORT_MAC_LIMIT ========= */
-              case MV_TPM_IOCTL_SW_SET_PORT_MAC_LIMIT:
-                  rcode = tpm_sw_set_port_max_macs(tpm_sw_mac_security->owner_id,
-                                                   tpm_sw_mac_security->port,
-                                                   tpm_sw_mac_security->mac_per_port);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_MAC_AGE_TIME ========= */
-              case MV_TPM_IOCTL_SW_SET_MAC_AGE_TIME:
-                  rcode = tpm_sw_set_mac_age_time(tpm_sw_mac_security->owner_id,
-                                                  tpm_sw_mac_security->mac_age_time);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_MAC_AGE_TIME ========= */
-              case MV_TPM_IOCTL_SW_GET_MAC_AGE_TIME:
-                  rcode = tpm_sw_get_mac_age_time(tpm_sw_mac_security->owner_id,
-                                                 &(tpm_sw_mac_security->mac_age_time));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_MAC_LEARN ========= */
-              case MV_TPM_IOCTL_SW_SET_MAC_LEARN:
-                  rcode = tpm_sw_set_mac_learn(tpm_sw_mac_security->owner_id,
-                                               tpm_sw_mac_security->port,
-                                               tpm_sw_mac_security->enable_mac_learn);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_MAC_LEARN ========= */
-              case MV_TPM_IOCTL_SW_GET_MAC_LEARN:
-                  rcode = tpm_sw_get_mac_learn(  tpm_sw_mac_security->owner_id,
-                                                 tpm_sw_mac_security->port,
-                                               &(tpm_sw_mac_security->enable_mac_learn));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SET_MTU_SIZE ========= */
-              case MV_TPM_IOCTL_SET_MTU_SIZE:
-                  rcode = tpm_set_mtu_size(tpm_sw_mac_security->owner_id,
-                                           tpm_sw_mac_security->mtu_type,
-                                           tpm_sw_mac_security->mtu_size);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_GET_MTU_SIZE ========= */
-              case MV_TPM_IOCTL_GET_MTU_SIZE:
-                  rcode = tpm_get_mtu_size(  tpm_sw_mac_security->owner_id,
-                                             tpm_sw_mac_security->mtu_type,
-                                           &(tpm_sw_mac_security->mtu_size));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_PORT_FLOOD ========= */
-              case MV_TPM_IOCTL_SW_SET_PORT_FLOOD:
-                  rcode = tpm_sw_set_port_flooding(tpm_sw_mac_security->owner_id,
-                                                   tpm_sw_mac_security->port,
-                                                   tpm_sw_mac_security->flood_mode,
-                                                   tpm_sw_mac_security->allow_flood);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_PORT_FLOOD ========= */
-              case MV_TPM_IOCTL_SW_GET_PORT_FLOOD:
-                  rcode = tpm_sw_get_port_flooding(  tpm_sw_mac_security->owner_id,
-                                                     tpm_sw_mac_security->port,
-                                                     tpm_sw_mac_security->flood_mode,
-                                                   &(tpm_sw_mac_security->allow_flood));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_CLEAR_DYNAMIC_MAC ========= */
-              case MV_TPM_IOCTL_SW_CLEAR_DYNAMIC_MAC:
-                  rcode = tpm_sw_clear_dynamic_mac(tpm_sw_mac_security->owner_id);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_MIRROR ========= */
-              case MV_TPM_IOCTL_SW_SET_MIRROR:
-                  rcode = tpm_sw_set_port_mirror(tpm_sw_mac_security->owner_id,
-                                                 tpm_sw_mac_security->port_mirror.sport,
-                                                 tpm_sw_mac_security->port_mirror.dport,
-                                                 tpm_sw_mac_security->port_mirror.mode,
-                                                 tpm_sw_mac_security->port_mirror.enable);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-              /* ====== MV_TPM_IOCTL_SW_SET_TRUNK_PORT ========= */
-              case MV_TPM_IOCTL_SW_SET_TRUNK_PORT:
-                  rcode = tpm_sw_set_trunk_ports(tpm_sw_mac_security->owner_id,
-                   tpm_sw_mac_security->trunk.trunk_id,
-                   tpm_sw_mac_security->trunk.trunk_mask);
-
-         if(rcode != TPM_OK)
-             goto ioctlErr;
-         ret = 0;
-         break;
-              /* ====== MV_TPM_IOCTL_SW_SET_TRUNK_MASK ========= */
-              case MV_TPM_IOCTL_SW_SET_TRUNK_MASK:
-              rcode = tpm_sw_set_trunk_mask(tpm_sw_mac_security->owner_id,
-                                            tpm_sw_mac_security->trunk.mask_num,
-                                            tpm_sw_mac_security->trunk.trunk_mask);
-
-              if(rcode != TPM_OK)
-                  goto ioctlErr;
-              ret = 0;
-              break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_MIRROR ========= */
-              case MV_TPM_IOCTL_SW_GET_MIRROR:
-                  rcode = tpm_sw_get_port_mirror(  tpm_sw_mac_security->owner_id,
-                                                   tpm_sw_mac_security->port_mirror.sport,
-                                                   tpm_sw_mac_security->port_mirror.dport,
-                                                   tpm_sw_mac_security->port_mirror.mode,
-                                                 &(tpm_sw_mac_security->port_mirror.enable));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_ISOLATE_PORT_VECTOR ========= */
-              case MV_TPM_IOCTL_SW_SET_ISOLATE_PORT_VECTOR:
-                  rcode = tpm_sw_set_isolate_eth_port_vector(tpm_sw_mac_security->owner_id,
-                                                             tpm_sw_mac_security->port,
-                                                             tpm_sw_mac_security->port_vector);
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-             /* ====== MV_TPM_IOCTL_SW_GET_ISOLATE_PORT_VECTOR ========= */
-              case MV_TPM_IOCTL_SW_GET_ISOLATE_PORT_VECTOR:
-                  rcode = tpm_sw_get_isolate_eth_port_vector(  tpm_sw_mac_security->owner_id,
-                                                               tpm_sw_mac_security->port,
-                                                             &(tpm_sw_mac_security->port_vector));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_mac_security_t*)arg, tpm_sw_mac_security, sizeof(tpm_ioctl_sw_mac_security_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Switch Vlan Section ======= */
-      /* ================================== */
-      case MV_TPM_IOCTL_SW_VLAN_SECTION:
-      {
-        tpm_ioctl_sw_vlan_filter_t *tpm_sw_vlan_filter = (tpm_ioctl_sw_vlan_filter_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-        if (tpm_sw_vlan_filter == NULL)
-        {
-          printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-          ret = -ENOMEM;
-          goto ioctlErr;
-        }
-        mpool_s_buff = tpm_sw_vlan_filter;
-
-        if(copy_from_user(tpm_sw_vlan_filter, (tpm_ioctl_sw_vlan_filter_t*)arg, sizeof(tpm_ioctl_sw_vlan_filter_t)))
-        {
-          printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-          goto ioctlErr;
-        }
-
-         switch (tpm_sw_vlan_filter->sw_vlan_cmd)
-        {
-          /* ====== MV_TPM_IOCTL_SW_SET_PORT_TAGGED ========= */
-          case MV_TPM_IOCTL_SW_SET_PORT_TAGGED:
-            rcode = tpm_sw_set_port_tagged(tpm_sw_vlan_filter->owner_id,
-                                           tpm_sw_vlan_filter->port,
-                                           tpm_sw_vlan_filter->allow_tagged);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_SET_PORT_UNTAGGED ========= */
-          case MV_TPM_IOCTL_SW_SET_PORT_UNTAGGED:
-            rcode = tpm_sw_set_port_untagged(tpm_sw_vlan_filter->owner_id,
-                                             tpm_sw_vlan_filter->port,
-                                             tpm_sw_vlan_filter->allow_untagged);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_ADD_VID ========= */
-          case MV_TPM_IOCTL_SW_PORT_ADD_VID:
-            rcode = tpm_sw_port_add_vid(tpm_sw_vlan_filter->owner_id,
-                                        tpm_sw_vlan_filter->port,
-                                        tpm_sw_vlan_filter->vid);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_DEL_VID ========= */
-          case MV_TPM_IOCTL_SW_PORT_DEL_VID:
-            rcode = tpm_sw_port_del_vid(tpm_sw_vlan_filter->owner_id,
-                                        tpm_sw_vlan_filter->port,
-                                        tpm_sw_vlan_filter->vid);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_CLEAR_VID ========= */
-          case MV_TPM_IOCTL_SW_PORT_CLEAR_VID:
-            rcode = tpm_sw_clear_vid_per_port(tpm_sw_vlan_filter->owner_id,
-                                              tpm_sw_vlan_filter->port);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_ADD_ALL_VID ========= */
-          case MV_TPM_IOCTL_SW_PORT_ADD_ALL_VID:
-            rcode = tpm_sw_add_all_vid_per_port(tpm_sw_vlan_filter->owner_id,
-                                                tpm_sw_vlan_filter->port);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_ADD_VID_GROUP ========= */
-          case MV_TPM_IOCTL_SW_ADD_VID_GROUP:
-            rcode = tpm_sw_port_add_vid_group(tpm_sw_vlan_filter->owner_id,
-                                              tpm_sw_vlan_filter->port,
-                                              (uint8_t)tpm_sw_vlan_filter->egress_mode,
-                                              tpm_sw_vlan_filter->min_vid,
-                                              tpm_sw_vlan_filter->max_vid);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_DEL_VID_GROUP ========= */
-          case MV_TPM_IOCTL_SW_DEL_VID_GROUP:
-            rcode = tpm_sw_port_del_vid_group(tpm_sw_vlan_filter->owner_id,
-                                              tpm_sw_vlan_filter->port,
-                                              tpm_sw_vlan_filter->min_vid,
-                                              tpm_sw_vlan_filter->max_vid);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_SER_VID_FILTER ========= */
-          case MV_TPM_IOCTL_SW_PORT_SER_VID_FILTER:
-            rcode = tpm_sw_port_set_vid_filter(tpm_sw_vlan_filter->owner_id,
-                                                tpm_sw_vlan_filter->port,
-                                                tpm_sw_vlan_filter->vid_filter);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_VLAN_EGRESS_MODE ========= */
-          case MV_TPM_IOCTL_SW_PORT_VLAN_EGRESS_MODE:
-            rcode = tpm_sw_set_port_vid_egress_mode(tpm_sw_vlan_filter->owner_id,
-                                                    tpm_sw_vlan_filter->port,
-                                                    tpm_sw_vlan_filter->vid,
-                                                    tpm_sw_vlan_filter->egress_mode);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_VLAN ========= */
-          case MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_VLAN:
-            rcode = tpm_sw_set_port_def_vlan(tpm_sw_vlan_filter->owner_id,
-                                             tpm_sw_vlan_filter->port,
-                                             tpm_sw_vlan_filter->vid);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_VLAN ========= */
-          case MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_VLAN:
-            rcode = tpm_sw_get_port_def_vlan(tpm_sw_vlan_filter->owner_id,
-                                             tpm_sw_vlan_filter->port,
-                                             &(tpm_sw_vlan_filter->vid));
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-
-            if(copy_to_user((tpm_ioctl_sw_vlan_filter_t*)arg, tpm_sw_vlan_filter, sizeof(tpm_ioctl_sw_vlan_filter_t)))
-            {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-            }
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_PRIORITY ========= */
-          case MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_PRIORITY:
-            rcode = tpm_sw_set_port_def_pri(tpm_sw_vlan_filter->owner_id,
-                                            tpm_sw_vlan_filter->port,
-                                            tpm_sw_vlan_filter->pri);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_PRIORITY ========= */
-          case MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_PRIORITY:
-            rcode = tpm_sw_get_port_def_pri(tpm_sw_vlan_filter->owner_id,
-                                            tpm_sw_vlan_filter->port,
-                                            &(tpm_sw_vlan_filter->pri));
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-
-            if(copy_to_user((tpm_ioctl_sw_vlan_filter_t*)arg, tpm_sw_vlan_filter, sizeof(tpm_ioctl_sw_vlan_filter_t)))
-            {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-            }
-            ret = 0;
-            break;
-
-          /* ====== MV_TPM_IOCTL_SW_PORT_ADD_VID_SET_EGRESS_MODE ========= */
-          case MV_TPM_IOCTL_SW_PORT_ADD_VID_SET_EGRESS_MODE:
-            rcode = tpm_sw_port_add_vid_set_egrs_mode(tpm_sw_vlan_filter->owner_id,
-                                                      tpm_sw_vlan_filter->port,
-                                                      tpm_sw_vlan_filter->vid,
-                                                      tpm_sw_vlan_filter->egress_mode);
-            if(rcode != TPM_OK)
-              goto ioctlErr;
-            ret = 0;
-            break;
-
-          default:
-            ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Switch TM Section ========= */
-      /* ================================== */
-      case MV_TPM_IOCTL_SW_TM_SECTION:
-      {
-          tpm_ioctl_sw_tm_t *tpm_sw_tm = (tpm_ioctl_sw_tm_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_sw_tm == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_sw_tm;
-
-          if(copy_from_user(tpm_sw_tm, (tpm_ioctl_sw_tm_t*)arg, sizeof(tpm_ioctl_sw_tm_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_sw_tm->sw_tm_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_SW_SET_UNI_SCHED ========= */
-              case MV_TPM_IOCTL_SW_SET_UNI_SCHED:
-                  rcode = tpm_sw_set_uni_sched(tpm_sw_tm->owner_id,
-                                               tpm_sw_tm->uni_port,
-                                               tpm_sw_tm->sw_sched_mode);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_UNI_QUE_WEIGHT ========= */
-              case MV_TPM_IOCTL_SW_UNI_QUE_WEIGHT:
-                  rcode = tpm_sw_set_uni_q_weight(tpm_sw_tm->owner_id,
-                                                  tpm_sw_tm->queue_id,
-                                                  tpm_sw_tm->weight);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_UNI_INGR_POLICE_RATE ========= */
-              case MV_TPM_IOCTL_SW_SET_UNI_INGR_POLICE_RATE:
-                  rcode = tpm_sw_set_uni_ingr_police_rate(tpm_sw_tm->owner_id,
-                                                          tpm_sw_tm->uni_port,
-                                                          tpm_sw_tm->limit_mode,
-                                                          tpm_sw_tm->cir,
-                                                          tpm_sw_tm->cbs,
-                                                          tpm_sw_tm->ebs);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_UNI_INGR_POLICE_RATE ========= */
-              case MV_TPM_IOCTL_SW_GET_UNI_INGR_POLICE_RATE:
-
-                  rcode = tpm_sw_get_uni_ingr_police_rate(  tpm_sw_tm->owner_id,
-                                                            tpm_sw_tm->uni_port,
-                                                          &(tpm_sw_tm->limit_mode),
-                                                          &(tpm_sw_tm->cir),
-                                                          &(tpm_sw_tm->cbs),
-                                                          &(tpm_sw_tm->ebs));
-
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_tm_t*)arg, tpm_sw_tm, sizeof(tpm_ioctl_sw_tm_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_UNI_TC_INGR_POLICE_RATE ========= */
-              case MV_TPM_IOCTL_SW_UNI_TC_INGR_POLICE_RATE:
-                  rcode = tpm_sw_set_uni_tc_ingr_police_rate(tpm_sw_tm->owner_id,
-                                                             tpm_sw_tm->uni_port,
-                                                             tpm_sw_tm->tc,
-                                                             tpm_sw_tm->cir,
-                                                             tpm_sw_tm->cbs);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_SET_UNI_EGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_SW_SET_UNI_EGR_RATE_LIMIT:
-                  rcode = tpm_sw_set_uni_egr_rate_limit(tpm_sw_tm->owner_id,
-                                                        tpm_sw_tm->uni_port,
-                                                        tpm_sw_tm->limit_mode,
-                                                        tpm_sw_tm->rate_limit_val);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_GET_UNI_EGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_SW_GET_UNI_EGR_RATE_LIMIT:
-                  rcode = tpm_sw_get_uni_egr_rate_limit(  tpm_sw_tm->owner_id,
-                                                          tpm_sw_tm->uni_port,
-                                                        &(tpm_sw_tm->limit_mode),
-                                                        &(tpm_sw_tm->rate_limit_val));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_sw_tm_t*)arg, tpm_sw_tm, sizeof(tpm_ioctl_sw_tm_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Switch PHY Section ========= */
-      /* ================================== */
-      case MV_TPM_IOCTL_SW_PHY_SECTION:
-      {
-          tpm_ioctl_sw_phy_t *tpm_sw_phy = (tpm_ioctl_sw_phy_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_sw_phy == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_sw_phy;
-
-          if(copy_from_user(tpm_sw_phy, (tpm_ioctl_sw_phy_t*)arg, sizeof(tpm_ioctl_sw_phy_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_sw_phy->sw_phy_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_AUTONEG_MODE ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_AUTONEG_MODE:
-                  rcode = tpm_phy_set_port_autoneg_mode(tpm_sw_phy->owner_id,
-                                                        tpm_sw_phy->port,
-                                                        tpm_sw_phy->port_autoneg_state,
-                                                        tpm_sw_phy->port_autoneg_mode);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_AUTONEG_MODE ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_AUTONEG_MODE:
-                  rcode = tpm_phy_get_port_autoneg_mode(  tpm_sw_phy->owner_id,
-                                                          tpm_sw_phy->port,
-                                                        &(tpm_sw_phy->port_autoneg_state),
-                                                        &(tpm_sw_phy->port_autoneg_mode));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_RESTART_AUTONEG ========= */
-              case MV_TPM_IOCTL_SW_PHY_RESTART_AUTONEG:
-                  rcode = tpm_phy_restart_port_autoneg(tpm_sw_phy->owner_id,
-                                                       tpm_sw_phy->port);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_PORT_STATE ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_PORT_STATE:
-                  rcode = tpm_phy_set_port_admin_state(tpm_sw_phy->owner_id,
-                                                       tpm_sw_phy->port,
-                                                       tpm_sw_phy->phy_port_state);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_STATE ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_STATE:
-                  rcode = tpm_phy_get_port_admin_state(  tpm_sw_phy->owner_id,
-                                                         tpm_sw_phy->port,
-                                                       &(tpm_sw_phy->phy_port_state));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_LINK_STATUS ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_LINK_STATUS:
-                  rcode = tpm_phy_get_port_link_status(  tpm_sw_phy->owner_id,
-                                                         tpm_sw_phy->port,
-                                                       &(tpm_sw_phy->port_link_status));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_DUPLEX_STATUS ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_DUPLEX_STATUS:
-                  rcode = tpm_phy_get_port_duplex_status(  tpm_sw_phy->owner_id,
-                                                           tpm_sw_phy->port,
-                                                         &(tpm_sw_phy->port_duplex_enable));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_SPEED_MODE ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_SPEED_MODE:
-                  rcode = tpm_phy_get_port_speed_mode(  tpm_sw_phy->owner_id,
-                                                        tpm_sw_phy->port,
-                                                      &(tpm_sw_phy->port_speed));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_PORT_FLOW_CONTROL ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_PORT_FLOW_CONTROL:
-                  rcode = tpm_phy_set_port_flow_control_support(tpm_sw_phy->owner_id,
-                                                                tpm_sw_phy->port,
-                                                                tpm_sw_phy->port_pause_state);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_FLOW_CONTROL ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_FLOW_CONTROL:
-                  rcode = tpm_phy_get_port_flow_control_support(  tpm_sw_phy->owner_id,
-                                                                  tpm_sw_phy->port,
-                                                                &(tpm_sw_phy->port_pause_state));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_FC_STATE ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_FC_STATE:
-                  rcode = tpm_phy_get_port_flow_control_state(  tpm_sw_phy->owner_id,
-                                                                tpm_sw_phy->port,
-                                                              &(tpm_sw_phy->port_pause_state));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_PORT_SPEED ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_PORT_SPEED:
-                  rcode = tpm_phy_set_port_speed(tpm_sw_phy->owner_id,
-                                                 tpm_sw_phy->port,
-                                                 tpm_sw_phy->port_speed);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_SPEED ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_SPEED:
-                  rcode = tpm_phy_get_port_speed(  tpm_sw_phy->owner_id,
-                                                   tpm_sw_phy->port,
-                                                 &(tpm_sw_phy->port_speed));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_PORT_LOOPBACK ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_PORT_LOOPBACK:
-                  rcode = tpm_phy_set_port_loopback(tpm_sw_phy->owner_id,
-                                                    tpm_sw_phy->port,
-                                                    tpm_sw_phy->port_loopback_mode,
-                                                    tpm_sw_phy->port_loopback_state);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_LOOPBACK ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_LOOPBACK:
-                  rcode = tpm_phy_get_port_loopback(  tpm_sw_phy->owner_id,
-                                                      tpm_sw_phy->port,
-                                                      tpm_sw_phy->port_loopback_mode,
-                                                    &(tpm_sw_phy->port_loopback_state));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_SET_PORT_DUPLEX_MODE ========= */
-              case MV_TPM_IOCTL_SW_PHY_SET_PORT_DUPLEX_MODE:
-                  rcode = tpm_phy_set_port_duplex_mode(tpm_sw_phy->owner_id,
-                                                       tpm_sw_phy->port,
-                                                       tpm_sw_phy->port_duplex_enable);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_GET_PORT_DUPLEX_MODE ========= */
-              case MV_TPM_IOCTL_SW_PHY_GET_PORT_DUPLEX_MODE:
-                  rcode = tpm_phy_get_port_duplex_mode(  tpm_sw_phy->owner_id,
-                                                         tpm_sw_phy->port,
-                                                       &(tpm_sw_phy->port_duplex_enable));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SW_PHY_CONVERT_PORT_INDEX ========= */
-              case MV_TPM_IOCTL_SW_PHY_CONVERT_PORT_INDEX:
-                  rcode = tpm_phy_convert_port_index( tpm_sw_phy->owner_id,
-                                                      tpm_sw_phy->switch_port_id,
-                                                     &(tpm_sw_phy->extern_port_id));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_UNI_2_SW_PORT ========= */
-              case MV_TPM_IOCTL_UNI_2_SW_PORT:
-                  rcode = tpm_xlate_uni_2_switch_port(  tpm_sw_phy->owner_id,
-                                                        tpm_sw_phy->extern_port_id,
-                                                        &(tpm_sw_phy->switch_port_id));
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-             default:
-               ret = -EINVAL;
-          }
-          if (ret == 0 && (tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_AUTONEG_MODE ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_LINK_STATUS   ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_FLOW_CONTROL    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_SPEED    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_LOOPBACK ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_DUPLEX_MODE    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_LINK_STATUS    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_DUPLEX_STATUS    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_SPEED_MODE    ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_STATE||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_GET_PORT_FC_STATE ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_SW_PHY_CONVERT_PORT_INDEX ||
-                           tpm_sw_phy->sw_phy_cmd == MV_TPM_IOCTL_UNI_2_SW_PORT))
-          {
-              if(copy_to_user((tpm_ioctl_sw_phy_t*)arg, tpm_sw_phy, sizeof(tpm_ioctl_sw_phy_t)))
-              {
-                printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                goto ioctlErr;
-              }
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ===== Packet Processor Section === */
-      /* ================================== */
-      case MV_TPM_IOCTL_PP_TM_SECTION:
-      {
-          tpm_ioctl_tm_tm_t *tpm_tm_tm = (tpm_ioctl_tm_tm_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_tm_tm == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_tm_tm;
-
-          if(copy_from_user(tpm_tm_tm, (tpm_ioctl_tm_tm_t*)arg, sizeof(tpm_ioctl_tm_tm_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_tm_tm->pp_tm_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_EGR_QUE_SCHED ========= */
-              case MV_TPM_IOCTL_TM_SET_WAN_EGR_QUE_SCHED:
-
-                  rcode = tpm_tm_set_wan_egr_queue_sched(tpm_tm_tm->owner_id,
-                                                         tpm_tm_tm->sched_ent,
-                                                         tpm_tm_tm->pp_sched_mode,
-                                                         tpm_tm_tm->queue_id,
-                                                         tpm_tm_tm->wrr_weight);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_SCHED_EGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_TM_SET_WAN_SCHED_EGR_RATE_LIMIT:
-
-                  rcode = tpm_tm_set_wan_sched_egr_rate_lim(tpm_tm_tm->owner_id,
-                                                            tpm_tm_tm->sched_ent,
-                                                            tpm_tm_tm->rate_limit_val,
-                                                            tpm_tm_tm->bucket_size);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_QUE_EGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_TM_SET_WAN_QUE_EGR_RATE_LIMIT:
-
-                  rcode = tpm_tm_set_wan_queue_egr_rate_lim(tpm_tm_tm->owner_id,
-                                                            tpm_tm_tm->sched_ent,
-                                                            tpm_tm_tm->queue_id,
-                                                            tpm_tm_tm->rate_limit_val,
-                                                            tpm_tm_tm->bucket_size);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_INGR_QUE_SCHED  =========*/
-              case MV_TPM_IOCTL_TM_SET_WAN_INGR_QUE_SCHED:
-
-                rcode = tpm_tm_set_wan_ingr_queue_sched(tpm_tm_tm->owner_id,
-                                                        tpm_tm_tm->pp_sched_mode,
-                                                        tpm_tm_tm->queue_id,
-                                                        tpm_tm_tm->wrr_weight);
-                if(rcode != TPM_OK)
-                  goto ioctlErr;
-
-                ret = 0;
-                break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_INGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_TM_SET_WAN_INGR_RATE_LIMIT:
-
-                  rcode = tpm_tm_set_wan_ingr_rate_lim(tpm_tm_tm->owner_id,
-                                                       tpm_tm_tm->rate_limit_val,
-                                                       tpm_tm_tm->bucket_size);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_WAN_QUE_INGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_TM_SET_WAN_QUE_INGR_RATE_LIMIT:
-
-                  rcode = tpm_tm_set_wan_q_ingr_rate_lim(tpm_tm_tm->owner_id,
-                                                         tpm_tm_tm->queue_id,
-                                                         tpm_tm_tm->rate_limit_val,
-                                                         tpm_tm_tm->bucket_size);
-                  if(rcode != TPM_OK)
-                    goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TM_SET_GMAC0_INGR_RATE_LIMIT ========= */
-              case MV_TPM_IOCTL_TM_SET_GMAC0_INGR_RATE_LIMIT:
-
-                  rcode = tpm_tm_set_gmac0_ingr_rate_lim(tpm_tm_tm->owner_id,
-                                                         tpm_tm_tm->rate_limit_val,
-                                                         tpm_tm_tm->bucket_size);
-                  if(rcode != TPM_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== IGMP Section ============== */
-      /* ================================== */
-      case MV_TPM_IOCTL_IGMP_SECTION:
-      {
-          tpm_ioctl_igmp_t *tpm_igmp = (tpm_ioctl_igmp_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_igmp == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_igmp;
-
-          if(copy_from_user(tpm_igmp, (tpm_ioctl_igmp_t*)arg, sizeof(tpm_ioctl_igmp_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_igmp->igmp_cmd)
-          {
-              case MV_TPM_IOCTL_IGMP_SET_PORT_FRWD_MODE:
-                  rcode = tpm_set_port_igmp_frwd_mode(tpm_igmp->src_port, tpm_igmp->frwd_mode);
-                  if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_IGMP_GET_PORT_FRWD_MODE:
-                  rcode = tpm_get_port_igmp_frwd_mode(tpm_igmp->src_port, &(tpm_igmp->frwd_mode));
-                  if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  if(copy_to_user((tpm_ioctl_igmp_t*)arg, tpm_igmp, sizeof(tpm_ioctl_igmp_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_IGMP_SET_CPU_RX_Q:
-                  rcode = tpm_set_igmp_cpu_rx_queue(tpm_igmp->cpu_queue);
-                  if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_IGMP_GET_CPU_RX_Q:
-                  rcode = tpm_get_igmp_cpu_rx_queue(&(tpm_igmp->cpu_queue));
-                  if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  if(copy_to_user((tpm_ioctl_igmp_t*)arg, tpm_igmp, sizeof(tpm_ioctl_igmp_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_SET_IGMP_PROXY_SA_MAC:
-                  rcode = tpm_set_igmp_proxy_sa_mac(tpm_igmp->sa_mac);
-              if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  ret = 0;
-                  break;
-
-              case MV_TPM_IOCTL_GET_IGMP_PROXY_SA_MAC:
-                  rcode = tpm_get_igmp_proxy_sa_mac(tpm_igmp->sa_mac);
-              if(rcode != TPM_OK)
-                     goto ioctlErr;
-                  if(copy_to_user((tpm_ioctl_igmp_t*)arg, tpm_igmp, sizeof(tpm_ioctl_igmp_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Print Section ============= */
-      /* ================================== */
-      case MV_TPM_IOCTL_PRINT_SECTION:
-      {
-          tpm_ioctl_print_t *tpm_print = (tpm_ioctl_print_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_print == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_print;
-
-          if(copy_from_user(tpm_print, (tpm_ioctl_print_t*)arg, sizeof(tpm_ioctl_print_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_print->print_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_PRINT_ETHER_PORTS ========= */
-              case MV_TPM_IOCTL_PRINT_ETHER_PORTS:
-
-                  tpm_print_etherports();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_TX_MODULES ========= */
-              case MV_TPM_IOCTL_PRINT_TX_MODULES:
-
-                  tpm_print_tx_modules();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_RX_MODULES ========= */
-              case MV_TPM_IOCTL_PRINT_RX_MODULES:
-
-                  tpm_print_rx_modules();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_GMAC_CONFIG ========= */
-              case MV_TPM_IOCTL_PRINT_GMAC_CONFIG:
-
-                  tpm_print_gmac_config();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_GMAC_FUNC ========= */
-              case MV_TPM_IOCTL_PRINT_GMAC_FUNC:
-
-                  tpm_print_gmac_func();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_IGMP ========= */
-              case MV_TPM_IOCTL_PRINT_IGMP:
-
-                  tpm_print_igmp();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_MISC ========= */
-              case MV_TPM_IOCTL_PRINT_MISC:
-
-                  tpm_print_misc();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_OWNERS ========= */
-              case MV_TPM_IOCTL_PRINT_OWNERS:
-
-                  tpm_print_owners();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_VLAN_TYPE ========= */
-              case MV_TPM_IOCTL_PRINT_VLAN_TYPE:
-
-                  tpm_print_vlan_etype();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_VALID_API_SECTIONS ========= */
-              case MV_TPM_IOCTL_PRINT_VALID_API_SECTIONS:
-
-                  tpm_print_valid_api_sections();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_FULL_API_SECTIONS ========= */
-              case MV_TPM_IOCTL_PRINT_FULL_API_SECTIONS:
-
-                  tpm_print_full_api_section(tpm_print->api_section);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_PNC_SHADOW_RANGE ========= */
-              case MV_TPM_IOCTL_PRINT_PNC_SHADOW_RANGE:
-
-                  tpm_print_pnc_shadow_range(tpm_print->valid,
-                                             tpm_print->start,
-                                             tpm_print->end);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_VALID_PNC_RANGES ========= */
-              case MV_TPM_IOCTL_PRINT_VALID_PNC_RANGES:
-
-                  tpm_print_valid_pnc_ranges();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_INIT_TABLES ========= */
-              case MV_TPM_IOCTL_PRINT_INIT_TABLES:
-
-                  tpm_print_init_tables();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_MOD2_JUMP_ALL ========= */
-              case MV_TPM_IOCTL_PRINT_MOD2_JUMP_ALL:
-                  tpm_mod2_print_jump_all(tpm_print->gmac);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_MOD2_MAIN_ALL ========= */
-              case MV_TPM_IOCTL_PRINT_MOD2_MAIN_ALL:
-                  tpm_mod2_print_main_all(tpm_print->gmac);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_MOD2_CFG ========= */
-              case MV_TPM_IOCTL_PRINT_MOD2_CFG:
-                  tpm_mod2_print_config(tpm_print->gmac);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_PRINT_MOD2_RULE ========= */
-              case MV_TPM_IOCTL_PRINT_MOD2_RULE:
-                  tpm_mod2_print_rule(tpm_print->gmac,
-                                      tpm_print->entry);
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================== */
-      /* ====== Trace Section ============= */
-      /* ================================== */
-      case MV_TPM_IOCTL_TRACE_SECTION:
-      {
-          tpm_ioctl_trace_t *tpm_trace = (tpm_ioctl_trace_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_trace == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_trace;
-
-          if(copy_from_user(tpm_trace, (tpm_ioctl_trace_t*)arg, sizeof(tpm_ioctl_trace_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_trace->trace_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_TRACE_STATUS ========= */
-              case MV_TPM_IOCTL_TRACE_STATUS:
-
-                  tpm_trace_status_print();
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TRACE_SET ========= */
-              case MV_TPM_IOCTL_TRACE_SET:
-
-                  tpm_trace_set(tpm_trace->level);
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_TRACE_MODULE_SET ========= */
-              case MV_TPM_IOCTL_TRACE_MODULE_SET:
-
-                  tpm_trace_module_set(tpm_trace->module,
-                                       tpm_trace->flag);
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ================================ */
-      /* ====== MIB Reset Section ======= */
-      /* ================================ */
-      case MV_TPM_IOCTL_RESET_SECTION:
-
-          if(copy_from_user(&tpm_mib_reset_param, (tpm_ioctl_mib_reset_t*)arg, sizeof(tpm_ioctl_mib_reset_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          rcode = tpm_mib_reset(tpm_mib_reset_param.owner_id, tpm_mib_reset_param.reset_level);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-
-      /* ================================ */
-      /* ====== SET active wan Section == */
-      /* ================================ */
-      case MV_TPM_IOCTL_SET_ACTIVE_WAN_SECTION:
-      {
-          tpm_ioctl_set_active_wan_t   set_active_wan;
-          if(copy_from_user(&set_active_wan, (tpm_ioctl_set_active_wan_t*)arg, sizeof(tpm_ioctl_set_active_wan_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          rcode = tpm_set_active_wan(set_active_wan.owner_id, set_active_wan.active_wan);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-      }
-      /* ================================ */
-      /* ====== SET GMAC LPBK Section                    == */
-      /* ================================ */
-      case MV_TPM_IOCTL_SET_GMAC_LPBK_SECTION:
-      {
-          tpm_ioctl_set_gmac_loopback_t   set_gmac_lpbk;
-          if(copy_from_user(&set_gmac_lpbk, (tpm_ioctl_set_gmac_loopback_t*)arg, sizeof(tpm_ioctl_set_gmac_loopback_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          rcode = tpm_set_gmac_loopback(set_gmac_lpbk.owner_id, set_gmac_lpbk.gmac, set_gmac_lpbk.enable);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-      }
-      /* ================================ */
-      /* ====== hot swap profile Section == */
-      /* ================================ */
-      case MV_TPM_IOCTL_HOT_SWAP_PROFILE_SECTION:
-      {
-          tpm_ioctl_hot_swap_profile_t  swap_profile;
-          if(copy_from_user(&swap_profile, (tpm_ioctl_hot_swap_profile_t*)arg, sizeof(tpm_ioctl_hot_swap_profile_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          rcode = tpm_hot_swap_profile(swap_profile.owner_id, swap_profile.profile_id);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-      }
-      /* ================================ */
-      /* ====== set hwf admin Section == */
-      /* ================================ */
-      case MV_TPM_IOCTL_SET_PORT_HWF_ADMIN_SECTION:
-      {
-          tpm_ioctl_set_port_hwf_admin_t  set_port_hwf_admin;
-          if(copy_from_user(&set_port_hwf_admin, (tpm_ioctl_set_port_hwf_admin_t*)arg, sizeof(tpm_ioctl_set_port_hwf_admin_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          rcode = tpm_proc_hwf_admin_set(set_port_hwf_admin.port, set_port_hwf_admin.txp, set_port_hwf_admin.enable);
-          if(rcode != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-      }
-      /* ================================ */
-      /* ====== ALARM  Section ======= */
-      /* ================================ */
-      case MV_TPM_IOCTL_ALARM_SECTION:
-      {
-          tpm_ioctl_alarm_t *tpm_alarm = (tpm_ioctl_alarm_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_alarm == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_alarm;
-
-          if(copy_from_user(tpm_alarm, (tpm_ioctl_alarm_t*)arg, sizeof(tpm_ioctl_alarm_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          switch (tpm_alarm->alarm_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_ALARM_GET_ETH_PORT ========= */
-              case MV_TPM_IOCTL_ALARM_GET_ETH_PORT:
-
-                  rcode = tpm_alarm_get_eth_port(tpm_alarm->owner_id, &tpm_alarm->alarm_type, &tpm_alarm->port_bitmap[0][0]);
-                  if(rcode != TPM_OK)
-                     goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_alarm_t*)arg, tpm_alarm, sizeof(tpm_ioctl_alarm_t)))
-                  {
-                    printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                    goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              default:
-                ret = -EINVAL;
-          }
-
-          ret=0;
-          break;
-      }
-
-      /* ================================= */
-      /* ====== TPM PM clear Section   ======= */
-      /* ================================= */
-      case MV_TPM_IOCTL_COUNTER_CLEAR_SECTION:
-      {
-          tpm_ioctl_swport_pm_3_t *tpm_ioctl_swport_pm_3 = (tpm_ioctl_swport_pm_3_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ioctl_swport_pm_3 == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ioctl_swport_pm_3;
-
-          if(copy_from_user(tpm_ioctl_swport_pm_3, (tpm_ioctl_swport_pm_3_t *)arg, sizeof(tpm_ioctl_swport_pm_3_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          rc = tpm_sw_clear_port_counter(tpm_ioctl_swport_pm_3->owner_id, tpm_ioctl_swport_pm_3->port);
-          if (rc != TPM_OK)
-            goto ioctlErr;
-
-          ret=0;
-          break;
-      }
-
-      /* ====================================== */
-      /* ====== TPM Data Path Section   ======= */
-      /* ====================================== */
-
-      case MV_TPM_IOCTL_RX_IGMP:
-      {
-          tpm_ioctl_rx_igmp_t *tpm_ioctl_rx_igmp = (tpm_ioctl_rx_igmp_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_l);
-          if (tpm_ioctl_rx_igmp == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_l);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_l_buff = tpm_ioctl_rx_igmp;
-
-          tpm_ioctl_rx_igmp->owner_id = ((tpm_ioctl_rx_igmp_t*)arg)->owner_id;
-
-          rcode = tpm_rx_igmp_frame(  tpm_ioctl_rx_igmp->owner_id,
-                                    &(tpm_ioctl_rx_igmp->src_llid),
-                                    &(tpm_ioctl_rx_igmp->src_port),
-                                      tpm_ioctl_rx_igmp->buf,
-                                    &(tpm_ioctl_rx_igmp->len));
-          if (rcode != TPM_RC_OK)
-            goto ioctlErr;
-
-          ret = 0;
-
-          if(copy_to_user((tpm_ioctl_rx_igmp_t*)arg, tpm_ioctl_rx_igmp, sizeof(tpm_ioctl_rx_igmp_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          break;
-      }
-
-     case MV_TPM_IOCTL_TX_IGMP:
-     {
-         tpm_ioctl_tx_igmp_t *tpm_ioctl_tx_igmp = (tpm_ioctl_tx_igmp_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_l);
-         if (tpm_ioctl_tx_igmp == NULL)
-         {
-           printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_m);
-           ret = -ENOMEM;
-            goto ioctlErr;
-         }
-         mpool_l_buff = tpm_ioctl_tx_igmp;
-
-        if(copy_from_user(tpm_ioctl_tx_igmp, (tpm_ioctl_tx_igmp_t *)arg, sizeof(tpm_ioctl_tx_igmp_t)))
-        {
-          printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-          goto ioctlErr;
-        }
-        rcode = tpm_tx_igmp_frame(tpm_ioctl_tx_igmp->owner_id,
-                                    tpm_ioctl_tx_igmp->tgt_port,
-                                    tpm_ioctl_tx_igmp->tgt_queue,
-                                    tpm_ioctl_tx_igmp->gem_port,
-                                    tpm_ioctl_tx_igmp->buf,
-                                    tpm_ioctl_tx_igmp->len);
-        if (rcode != TPM_RC_OK)
-          goto ioctlErr;
-
-        ret = 0;
-
-        break;
-      }
-
-      /* ================================= */
-      /* ====== APM PM 1 Section   ======= */
-      /* ================================= */
-      case MV_APM_IOCTL_PM_1_SWPORT_SECTION:
-      {
-          tpm_ioctl_swport_pm_1_t *tpm_ioctl_swport_pm_1 = (tpm_ioctl_swport_pm_1_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ioctl_swport_pm_1 == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ioctl_swport_pm_1;
-
-          if(copy_from_user(tpm_ioctl_swport_pm_1, (tpm_ioctl_swport_pm_1_t *)arg, sizeof(tpm_ioctl_swport_pm_1_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          rcode = tpm_sw_pm_1_read(  tpm_ioctl_swport_pm_1->owner_id,
-                                     tpm_ioctl_swport_pm_1->port,
-                                   &(tpm_ioctl_swport_pm_1->tpm_swport_pm_1));
-          if(rcode != TPM_OK)
-             goto ioctlErr;
-
-          if(copy_to_user((tpm_ioctl_swport_pm_1_t *)arg, tpm_ioctl_swport_pm_1, sizeof(tpm_ioctl_swport_pm_1_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          ret=0;
-          break;
-      }
-
-      /* ================================= */
-      /* ====== APM PM 3 Section   ======= */
-      /* ================================= */
-      case MV_APM_IOCTL_PM_3_SWPORT_SECTION:
-      {
-          tpm_ioctl_swport_pm_3_t *tpm_ioctl_swport_pm_3 = (tpm_ioctl_swport_pm_3_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ioctl_swport_pm_3 == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ioctl_swport_pm_3;
-
-          if(copy_from_user(tpm_ioctl_swport_pm_3, (tpm_ioctl_swport_pm_3_t *)arg, sizeof(tpm_ioctl_swport_pm_3_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          rcode = tpm_sw_pm_3_read(  tpm_ioctl_swport_pm_3->owner_id,
-                                     tpm_ioctl_swport_pm_3->port,
-                                   &(tpm_ioctl_swport_pm_3->tpm_swport_pm_3));
-          if(rcode != TPM_OK)
-             goto ioctlErr;
-
-
-          if(copy_to_user((tpm_ioctl_swport_pm_3_t *)arg, tpm_ioctl_swport_pm_3, sizeof(tpm_ioctl_swport_pm_3_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          ret=0;
-          break;
-      }
-
-  /* ====================================== */
-  /* ====== CPU WAN loopback Section  ===== */
-  /* ====================================== */
-      case MV_TPM_IOCTL_CPU_LPBK_SECTION:
-      {
-          tpm_ioctl_cpu_lpbk_t *tpm_ioctl_cpu_lpbk = (tpm_ioctl_cpu_lpbk_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ioctl_cpu_lpbk == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ioctl_cpu_lpbk;
-
-          if(copy_from_user(tpm_ioctl_cpu_lpbk, (tpm_ioctl_cpu_lpbk_t*)arg, sizeof(tpm_ioctl_cpu_lpbk_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_ioctl_cpu_lpbk->cpu_lpbk_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_ADD_CPU_WAN_LPBK ========= */
-              case MV_TPM_IOCTL_ADD_CPU_WAN_LPBK:
-
-                  rcode = tpm_add_cpu_wan_loopback (  tpm_ioctl_cpu_lpbk->owner_id,
-                                                    &(tpm_ioctl_cpu_lpbk->pkt_frwd),
-                                                    &(tpm_ioctl_cpu_lpbk->mod_idx));
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  if(copy_to_user((tpm_ioctl_cpu_lpbk_t*)arg, tpm_ioctl_cpu_lpbk, sizeof(tpm_ioctl_cpu_lpbk_t)))
-                  {
-                      printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                      goto ioctlErr;
-                  }
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_DEL_CPU_WAN_LPBK ========= */
-              case MV_TPM_IOCTL_DEL_CPU_WAN_LPBK:
-
-                  rcode = tpm_del_cpu_wan_loopback (  tpm_ioctl_cpu_lpbk->owner_id,
-                                                    &(tpm_ioctl_cpu_lpbk->pkt_frwd));
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              default:
-                  ret = -EINVAL;
-          }
-          break;
-      }
-
-      /* ======================================= */
-      /* ====== CPU Aging counter Section  ===== */
-      /* ======================================= */
-      case MV_TPM_IOCTL_AGE_COUNT_SECTION:
-      {
-          uint32_t  age_count_cmd;
-
-          /* AGE_COUNT_SECTION uses two structure types, first identify the type */
-          if(copy_from_user(&age_count_cmd, (uint32_t*)arg, sizeof(uint32_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          /* HIT_COUNTERS uses huge buffer pool */
-          if (age_count_cmd == MV_TPM_IOCTL_GET_ALL_HIT_COUNTERS)
-          {
-            tpm_ioctl_pnc_hit_cnt_t *tpm_ioctl_pnc_hit_cnt =
-                (tpm_ioctl_pnc_hit_cnt_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_h);
-            if (tpm_ioctl_pnc_hit_cnt == NULL)
-            {
-                printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n",
-                        __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_h);
-                ret = -ENOMEM;
-                goto ioctlErr;
-            }
-            mpool_h_buff = tpm_ioctl_pnc_hit_cnt;
-
-            /* copy the data from user space */
-            if(copy_from_user(tpm_ioctl_pnc_hit_cnt, (tpm_ioctl_pnc_hit_cnt_t*)arg, sizeof(tpm_ioctl_pnc_hit_cnt_t)))
-            {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-            }
-
-            rcode = tpm_get_pnc_all_hit_counters (tpm_ioctl_pnc_hit_cnt->owner_id,
-                                                  tpm_ioctl_pnc_hit_cnt->api_type,
-                                                  tpm_ioctl_pnc_hit_cnt->high_thresh_pkts,
-                                                  tpm_ioctl_pnc_hit_cnt->counter_reset,
-                                                 &(tpm_ioctl_pnc_hit_cnt->valid_counters),
-                                                 &(tpm_ioctl_pnc_hit_cnt->count_array[0]));
-
-            if (rcode != TPM_RC_OK)
-                goto ioctlErr;
-
-            ret = 0;
-
-            /* copy back the returned data to user space */
-            if(copy_to_user((tpm_ioctl_pnc_hit_cnt_t*)arg, tpm_ioctl_pnc_hit_cnt, sizeof(tpm_ioctl_pnc_hit_cnt_t)))
-            {
-                printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-                goto ioctlErr;
-            }
-          } /* MV_TPM_IOCTL_GET_ALL_HIT_COUNTERS */
-          else
-          {
-            tpm_ioctl_age_count_t *tpm_ioctl_age_count =
-                (tpm_ioctl_age_count_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_m);
-            if (tpm_ioctl_age_count == NULL)
-            {
-                printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n",
-                        __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_m);
-                ret = -ENOMEM;
-                goto ioctlErr;
-            }
-            mpool_m_buff = tpm_ioctl_age_count;
-
-          if(copy_from_user(tpm_ioctl_age_count, (tpm_ioctl_age_count_t*)arg, sizeof(tpm_ioctl_age_count_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-
-          switch (tpm_ioctl_age_count->age_count_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_GET_LU_ENTRIES ========= */
-              case MV_TPM_IOCTL_GET_LU_ENTRIES:
-
-                  rcode = tpm_get_pnc_lu_entry (tpm_ioctl_age_count->owner_id,
-                                                tpm_ioctl_age_count->api_type,
-                                                tpm_ioctl_age_count->lu_num,
-                                                tpm_ioctl_age_count->lu_reset,
-                                                &(tpm_ioctl_age_count->valid_num),
-                                                &(tpm_ioctl_age_count->count_array[0]),
-                                                &(tpm_ioctl_age_count->unrelated_num));
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SET_LU_COUNT_MASK ========= */
-              case MV_TPM_IOCTL_SET_LU_COUNT_MASK:
-
-                  rcode = tpm_set_pnc_counter_mask (tpm_ioctl_age_count->owner_id,
-                                                    tpm_ioctl_age_count->api_type,
-                                                    tpm_ioctl_age_count->rule_idx,
-                                                    tpm_ioctl_age_count->lu_rule_mask);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_GET_HIT_COUNT ========= */
-              case MV_TPM_IOCTL_GET_HIT_COUNT:
-
-                  rcode = tpm_get_pnc_hit_count (tpm_ioctl_age_count->owner_id,
-                                                 tpm_ioctl_age_count->api_type,
-                                                 tpm_ioctl_age_count->rule_idx,
-                                                 tpm_ioctl_age_count->hit_reset,
-                                                 &(tpm_ioctl_age_count->hit_count));
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SET_LU_THESHOLD ========= */
-              case MV_TPM_IOCTL_SET_LU_THESHOLD:
-
-                  rcode = tpm_set_pnc_lu_threshold (tpm_ioctl_age_count->owner_id,
-                                                    tpm_ioctl_age_count->api_type,
-                                                    tpm_ioctl_age_count->lu_thresh_pkts);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_RESET_COUNT_GROUP ========= */
-              case MV_TPM_IOCTL_RESET_COUNT_GROUP:
-
-                  rcode = tpm_reset_pnc_age_group (tpm_ioctl_age_count->owner_id,
-                                                   tpm_ioctl_age_count->api_type);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              default:
-                  ret = -EINVAL;
-          }
-
-          if (ret == 0 &&
-              (tpm_ioctl_age_count->age_count_cmd == MV_TPM_IOCTL_GET_LU_ENTRIES ||
-               tpm_ioctl_age_count->age_count_cmd == MV_TPM_IOCTL_GET_HIT_COUNT))
-          {
-            if(copy_to_user((tpm_ioctl_age_count_t*)arg, tpm_ioctl_age_count, sizeof(tpm_ioctl_age_count_t)))
-            {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-            }
-          }
-        }
-        break;
-      } /* MV_TPM_IOCTL_AGE_COUNT_SECTION */
-
-      /* ======================================= */
-      /* ====== MC VLAN Section  ===== */
-      /* ======================================= */
-      case MV_TPM_IOCTL_MC_VLAN_SECTION:
-      {
-          tpm_ioctl_mc_vid_t *tpm_ioctl_mc_vid = (tpm_ioctl_mc_vid_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-          if (tpm_ioctl_mc_vid == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_s_buff = tpm_ioctl_mc_vid;
-
-          if(copy_from_user(tpm_ioctl_mc_vid, (tpm_ioctl_mc_vid_t*)arg, sizeof(tpm_ioctl_mc_vid_t)))
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-          }
-
-          switch (tpm_ioctl_mc_vid->mc_vid_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_SET_MC_VID_PORT_VIDS ========= */
-              case MV_TPM_IOCTL_SET_MC_VID_PORT_VIDS:
-
-                  rcode = tpm_set_mc_vid_port_vids(  tpm_ioctl_mc_vid->owner_id,
-                                                     tpm_ioctl_mc_vid->mc_vid,
-                                                   &(tpm_ioctl_mc_vid->port_vid_set));
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              default:
-                  ret = -EINVAL;
-          }
-
-          break;
-      }
-
-      /* ======================================= */
-      /* ====== MC VLAN Section  ===== */
-      /* ======================================= */
-      case MV_TPM_IOCTL_MTU_SECTION:
-      {
-          tpm_ioctl_mtu_t *tpm_ioctl_mtu = (tpm_ioctl_mtu_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_m);
-          if (tpm_ioctl_mtu == NULL)
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_m);
-            ret = -ENOMEM;
-            goto ioctlErr;
-          }
-          mpool_m_buff = tpm_ioctl_mtu;
-
-          if(copy_from_user(tpm_ioctl_mtu, (tpm_ioctl_mtu_t*)arg, sizeof(tpm_ioctl_mtu_t)))
-          {
-              printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-              goto ioctlErr;
-          }
-
-          switch (tpm_ioctl_mtu->mtu_setting_cmd)
-          {
-              /* ====== MV_TPM_IOCTL_SET_MTU_ADMIN ========= */
-              case MV_TPM_IOCTL_SET_MTU_ADMIN:
-
-                  rcode = tpm_db_set_mtu_enable(  tpm_ioctl_mtu->enable);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-              /* ====== MV_TPM_IOCTL_SET_MTU ========= */
-              case MV_TPM_IOCTL_SET_MTU:
-
-                  rcode = tpm_proc_set_mtu(tpm_ioctl_mtu->ethertype,
-                                           tpm_ioctl_mtu->direction,
-                                           tpm_ioctl_mtu->mtu);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-
-              /* ====== MV_TPM_IOCTL_SET_PPPOE_MTU ========= */
-              case MV_TPM_IOCTL_SET_PPPOE_MTU:
-
-                  rcode = tpm_proc_set_pppoe_mtu(tpm_ioctl_mtu->ethertype,
-                                                 tpm_ioctl_mtu->direction,
-                                                 tpm_ioctl_mtu->pppoe_mtu);
-
-                  if (rcode != TPM_RC_OK)
-                      goto ioctlErr;
-
-                  ret = 0;
-                  break;
-              default:
-                  ret = -EINVAL;
-          }
-
-          break;
-      }
-
-  /* ====== TPM SELF CHECK Section  ===== */
-  case MV_TPM_IOCTL_TPM_CHECK_SECTION:
-  {
-   tpm_ioctl_tpm_check_t *tpm_ioctl_tpm_check = (tpm_ioctl_tpm_check_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-   if (NULL == tpm_ioctl_tpm_check) {
-      printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-      ret = -ENOMEM;
-      goto ioctlErr;
-   }
-   mpool_s_buff = tpm_ioctl_tpm_check;
-     if(copy_from_user(tpm_ioctl_tpm_check, (tpm_ioctl_tpm_check_t*)arg, sizeof(tpm_ioctl_tpm_check_t)))
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-        }
-        rcode = tpm_rule_self_check(tpm_ioctl_tpm_check->owner_id, tpm_ioctl_tpm_check->check_level);
-        if(rcode != TPM_OK)
-          goto ioctlErr;
-
-        ret=0;
-        break;
-  }
-
-  case MV_TPM_IOCTL_FLUSH_ATU_SECTION:
-  {
-   tpm_ioctl_flush_atu_t *tpm_ioctl_flush_atu = (tpm_ioctl_flush_atu_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-   if (NULL == tpm_ioctl_flush_atu) {
-      printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-      ret = -ENOMEM;
-      goto ioctlErr;
-   }
-   mpool_s_buff = tpm_ioctl_flush_atu;
-   if (copy_from_user(tpm_ioctl_flush_atu, (tpm_ioctl_flush_atu_t*)arg, sizeof(tpm_ioctl_flush_atu_t))) {
-      printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-      goto ioctlErr;
-   }
-   rcode = tpm_flush_atu(tpm_ioctl_flush_atu->owner_id, tpm_ioctl_flush_atu->flush_type, tpm_ioctl_flush_atu->db_num);
-   if (rcode != TPM_OK)
-          goto ioctlErr;
-
-        ret = 0;
-   break;
-  }
-
-  case MV_TPM_IOCTL_FLUSH_VTU_SECTION:
-  {
-   tpm_ioctl_flush_vtu_t *tpm_ioctl_flush_vtu = (tpm_ioctl_flush_vtu_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-   if (NULL == tpm_ioctl_flush_vtu) {
-      printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-      ret = -ENOMEM;
-      goto ioctlErr;
-   }
-   mpool_s_buff = tpm_ioctl_flush_vtu;
-   if (copy_from_user(tpm_ioctl_flush_vtu, (tpm_ioctl_flush_vtu_t*)arg, sizeof(tpm_ioctl_flush_vtu_t))) {
-      printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-      goto ioctlErr;
-   }
-   rcode = tpm_flush_vtu(tpm_ioctl_flush_vtu->owner_id);
-   if (rcode != TPM_OK)
-          goto ioctlErr;
-
-        ret = 0;
-   break;
-  }
-
-  case MV_TPM_IOCTL_SET_IPV6_CM_PARSE_WIN_SECTION:
-  {
-      tpm_ioctl_ipv6_parse_window_t *ipv6_parse_window = (tpm_ioctl_ipv6_parse_window_t *) tpm_common_mempool_alloc(tpm_ioctl_mpools.mpool_s);
-      if (NULL == ipv6_parse_window) {
-          printk(KERN_ERR "ERROR: (%s:%d) tpm_common_mempool_alloc(%p) failed\n", __FUNCTION__, __LINE__, tpm_ioctl_mpools.mpool_s);
-          ret = -ENOMEM;
-          goto ioctlErr;
-      }
-      mpool_s_buff = ipv6_parse_window;
-      if (copy_from_user(ipv6_parse_window, (tpm_ioctl_ipv6_parse_window_t*)arg, sizeof(tpm_ioctl_ipv6_parse_window_t))) {
-          printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-          goto ioctlErr;
-      }
-      rcode = tpm_ctc_cm_set_ipv6_parse_window(ipv6_parse_window->owner_id, ipv6_parse_window->ipv6_parse_window);
-      if (rcode != TPM_OK)
-          goto ioctlErr;
-
-      ret = 0;
-      break;
-  }
-
-  default:
-        ret = -EINVAL;
-  }
-
-ioctlErr:
-    if (mpool_s_buff != NULL)
-        tpm_common_mempool_free(tpm_ioctl_mpools.mpool_s, mpool_s_buff);
-    else if (mpool_m_buff != NULL)
-        tpm_common_mempool_free(tpm_ioctl_mpools.mpool_m, mpool_m_buff);
-    else if (mpool_l_buff != NULL)
-        tpm_common_mempool_free(tpm_ioctl_mpools.mpool_l, mpool_l_buff);
-    else if (mpool_h_buff != NULL)
-        tpm_common_mempool_free(tpm_ioctl_mpools.mpool_h, mpool_h_buff);
-    else if (tpm_initp != NULL)
-        kfree(tpm_initp);
-
-    return(ret);
-}
-
-/*******************************************************************************
-**
-**  mv_tpm_cdev_open
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function opens the TPM Char device
-**
-**  PARAMETERS:  struct inode *inode
-**               struct file *filp
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-int mv_tpm_cdev_open(struct inode *inode, struct file *filp)
-{
-  tpm_module_cdev_t *dev;
-
-  //if (deviceOpen)
-  //  return(-EBUSY);
-
-  deviceOpen++;
-  try_module_get(THIS_MODULE);
-
-  /* find the device structure */
-  dev = container_of(inode->i_cdev, tpm_module_cdev_t, cdev);
-  filp->private_data = dev;
-
-  return(0);
-}
-
-/*******************************************************************************
-**
-**  mv_tpm_cdev_release
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function releases the TPM Char device
-**
-**  PARAMETERS:  struct inode *inode
-**               struct file *filp
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-int mv_tpm_cdev_release(struct inode *inode, struct file *filp)
-{
-  deviceOpen--;
-  module_put(THIS_MODULE);
-
-  return(0);
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-/*******************************************************************************
-**  mv_tpm_cdev_read
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function waites for data to be written to tpm_sfs_2_ioctl_command
-**               and copies it to user space to be used by IOCTLed
-**
-**  PARAMETERS:  struct file *file- file descriptor
-**               char __user *buf-  user buffer
-**               size_t count-      user buffer byte size
-**
-**  OUTPUTS:    loff_t *ppos-      position in file
-**
-**  RETURNS:    number of bytes read
-**
-*******************************************************************************/
-static ssize_t mv_tpm_cdev_read(struct file *file, char __user *buf,
-                                size_t count, loff_t *ppos)
-{
-    int val;
-
-    val = down_interruptible(&tpm_sfs_2_ioctl_sem);
-    if (val != 0)
-    {
-        return val;
-    }
-
-    if(copy_to_user(buf, &tpm_sfs_2_ioctl_command, sizeof(tpm_ioctl_mng_t)))
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __FUNCTION__, __LINE__);
-        return -EFAULT;
-    }
-
-    return sizeof(tpm_ioctl_mng_t);
-}
-#endif
-
-/*******************************************************************************
-**  TPM device operations
-*******************************************************************************/
-struct file_operations tpmCdevFops =
-{
-  .owner   = THIS_MODULE,
-  .open    = mv_tpm_cdev_open,
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-  .read    = mv_tpm_cdev_read,
-#endif
-  .release = mv_tpm_cdev_release,
-  .unlocked_ioctl   = mv_tpm_cdev_ioctl
-};
-
-/*******************************************************************************
-**  tpm_init_ioctl_mempools
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function allocates 3 memory pools for IOCTL operations
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     TPM_OK or TPM_FAIL
-**
-*******************************************************************************/
-static int32_t tpm_init_ioctl_mempools(void)
-{
-    if (tpm_ioctl_mpools.mpool_s == NULL){
-        uint32_t i;
-        uint32_t max_val= 0;
-        uint32_t struct_size[]= {
-            sizeof(tpm_setup_t),                sizeof(tpm_ioctl_admin_t),          sizeof(tpm_ioctl_add_acl_rule_t),
-            sizeof(tpm_ioctl_del_acl_rule_t),   sizeof(tpm_ioctl_ctrl_acl_rule_t),  sizeof(tpm_ioctl_mc_rule_t),
-            sizeof(tpm_ioctl_mng_ch_t),         sizeof(tpm_ioctl_sw_mac_security_t),sizeof(tpm_ioctl_sw_vlan_filter_t),
-            sizeof(tpm_ioctl_sw_tm_t),          sizeof(tpm_ioctl_sw_phy_t),         sizeof(tpm_ioctl_tm_tm_t),
-            sizeof(tpm_ioctl_print_t),          sizeof(tpm_ioctl_trace_t),          sizeof(tpm_ioctl_igmp_t),
-            sizeof(tpm_ioctl_alarm_t),          sizeof(tpm_ioctl_swport_pm_1_t),    sizeof(tpm_ioctl_swport_pm_3_t),
-            sizeof(tpm_ioctl_cpu_lpbk_t),       sizeof(tpm_ioctl_mtu_t),            sizeof(tpm_ioctl_mc_vid_t),
-            0 };
-
-        /* find the max truct size */
-        for (i=0; struct_size[i] != 0; i++){
-            printk(KERN_DEBUG "struct_size[%d] = %d\n", i, struct_size[i]);
-            if (struct_size[i] > max_val)
-                max_val= struct_size[i];
-        }
-
-        /* validate that max_val does not exceed threashold */
-        if (max_val > MPOOL_S_MAX_BUFF_SIZE){
-            printk(KERN_ERR "ERROR: (%s:%d) requested buffer size is too large %d/%d (requested/max_val)\n",
-                   __FUNCTION__, __LINE__, max_val, MPOOL_S_MAX_BUFF_SIZE);
-            return TPM_FAIL;
-        }
-
-        tpm_ioctl_mpools.mpool_s = tpm_common_mempool_create(i, max_val, GFP_USER);
-        if (NULL == tpm_ioctl_mpools.mpool_s){
-            printk(KERN_ERR "ERROR: (%s:%d) failed allocating tpm_ioctl_mpools.mpool_s\n",
-                   __FUNCTION__, __LINE__);
-            return TPM_FAIL;
-        }
-        printk(KERN_INFO "(%s:%d) init tpm_ioctl_mpools.mpool_s, number_of_entries=%d, entry_size=%d pool=0x%p\n",
-               __FUNCTION__, __LINE__, i, max_val, tpm_ioctl_mpools.mpool_s);
-    }
-
-    if (tpm_ioctl_mpools.mpool_m == NULL){
-        uint32_t i;
-        uint32_t max_val= 0;
-        uint32_t struct_size[]= {
-            sizeof(tpm_ioctl_get_mod_rule_t),   sizeof(tpm_ioctl_age_count_t),  0 };
-
-        /* find the max truct size */
-        for (i=0; struct_size[i] != 0; i++){
-            printk(KERN_DEBUG "struct_size[%d] = %d\n", i, struct_size[i]);
-            if (struct_size[i] > max_val)
-                max_val= struct_size[i];
-        }
-
-        /* validate that max_val does not exceed threashold */
-        if (max_val > MPOOL_M_MAX_BUFF_SIZE){
-            printk(KERN_ERR "ERROR: (%s:%d) requested buffer size is too large %d/%d (requested/max_val)\n",
-                   __FUNCTION__, __LINE__, max_val, MPOOL_M_MAX_BUFF_SIZE);
-            return TPM_FAIL;
-        }
-
-        tpm_ioctl_mpools.mpool_m = tpm_common_mempool_create(i, max_val, GFP_USER);
-        if (NULL == tpm_ioctl_mpools.mpool_m){
-            printk(KERN_ERR "ERROR: (%s:%d) failed allocating tpm_ioctl_mpools.mpool_m\n",
-                   __FUNCTION__, __LINE__);
-            return TPM_FAIL;
-        }
-        printk(KERN_INFO "(%s:%d) init tpm_ioctl_mpools.mpool_m, number_of_entries=%d, entry_size=%d pool=0x%p\n",
-               __FUNCTION__, __LINE__, i, max_val, tpm_ioctl_mpools.mpool_m);
-    }
-
-    if (tpm_ioctl_mpools.mpool_l == NULL){
-        uint32_t i;
-        uint32_t max_val= 0;
-        uint32_t struct_size[]= {
-            sizeof(tpm_ioctl_tx_igmp_t),        sizeof(tpm_ioctl_rx_igmp_t),    0 };
-
-        /* find the max truct size */
-        for (i=0; struct_size[i] != 0; i++){
-            printk(KERN_DEBUG "struct_size[%d] = %d\n", i, struct_size[i]);
-            if (struct_size[i] > max_val)
-                max_val= struct_size[i];
-        }
-
-        /* validate that max_val does not exceed threashold */
-        if (max_val > MPOOL_L_MAX_BUFF_SIZE){
-            printk(KERN_ERR "ERROR: (%s:%d) requested buffer size is too large %d/%d (requested/max_val)\n",
-                   __FUNCTION__, __LINE__, max_val, MPOOL_L_MAX_BUFF_SIZE);
-            return TPM_FAIL;
-        }
-
-        tpm_ioctl_mpools.mpool_l = tpm_common_mempool_create(i, max_val, GFP_USER);
-        if (NULL == tpm_ioctl_mpools.mpool_l){
-            printk(KERN_ERR "ERROR: (%s:%d) failed allocating tpm_ioctl_mpools.mpool_l\n",
-                   __FUNCTION__, __LINE__);
-            return TPM_FAIL;
-        }
-        printk(KERN_INFO "(%s:%d) init tpm_ioctl_mpools.mpool_l, number_of_entries=%d, entry_size=%d pool=0x%p\n",
-               __FUNCTION__, __LINE__, i, max_val, tpm_ioctl_mpools.mpool_l);
-    }
-
-    if (tpm_ioctl_mpools.mpool_h == NULL){
-        uint32_t i;
-        uint32_t max_val= 0;
-        uint32_t struct_size[]= {
-            sizeof(tpm_ioctl_pnc_hit_cnt_t),    0 };
-
-        /* find the max truct size */
-        for (i=0; struct_size[i] != 0; i++){
-            printk(KERN_DEBUG "struct_size[%d] = %d\n", i, struct_size[i]);
-            if (struct_size[i] > max_val)
-                max_val= struct_size[i];
-        }
-
-        /* validate that max_val does not exceed threashold */
-        if (max_val > MPOOL_H_MAX_BUFF_SIZE){
-            printk(KERN_ERR "ERROR: (%s:%d) Huge mempool requested buffer size is too large %d/%d (requested/max_val)\n",
-                   __FUNCTION__, __LINE__, max_val, MPOOL_L_MAX_BUFF_SIZE);
-            return TPM_FAIL;
-        }
-
-        tpm_ioctl_mpools.mpool_h = tpm_common_mempool_create(i, max_val, GFP_USER);
-        if (NULL == tpm_ioctl_mpools.mpool_h){
-            printk(KERN_ERR "ERROR: (%s:%d) failed allocating tpm_ioctl_mpools.mpool_h\n",
-                   __FUNCTION__, __LINE__);
-            return TPM_FAIL;
-        }
-        printk(KERN_INFO "(%s:%d) init tpm_ioctl_mpools.mpool_h, number_of_entries=%d, entry_size=%d pool=0x%p\n",
-               __FUNCTION__, __LINE__, i, max_val, tpm_ioctl_mpools.mpool_h);
-    }
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-**
-**  tpm_destroy_ioctl_mempools
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function destroys 3 pool memory for IOCTL operations
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     TPM_OK or TPM_FAIL
-**
-*******************************************************************************/
-static int32_t tpm_destroy_ioctl_mempools(void)
-{
-      if (tpm_ioctl_mpools.mpool_s != NULL){
-        tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_s);
-        tpm_ioctl_mpools.mpool_s = NULL;
-      }
-      if (tpm_ioctl_mpools.mpool_m != NULL){
-        tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_m);
-        tpm_ioctl_mpools.mpool_m = NULL;
-      }
-      if (tpm_ioctl_mpools.mpool_l != NULL){
-        tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_l);
-        tpm_ioctl_mpools.mpool_l = NULL;
-      }
-      if (tpm_ioctl_mpools.mpool_h != NULL){
-        tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_h);
-        tpm_ioctl_mpools.mpool_h = NULL;
-      }
-      return TPM_OK;
-}
-
-/*******************************************************************************
-**
-**  tpm_module_mng_if_create
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function create management interface - char device
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     TPM_OK or TPM_FAIL
-**
-*******************************************************************************/
-int32_t tpm_module_mng_if_create(void)
-{
-  int   rcode;
-  dev_t dev;
-
-  dev   = MKDEV(MV_TPM_MAJOR, 0);
-  rcode = register_chrdev_region(dev, TPM_NUM_DEVICES, TPM_DEV_NAME);
-  if(rcode < 0)
-  {
-    printk(KERN_ERR "ERROR: (%s:%d) Pon Char Device\n", __FUNCTION__, __LINE__);
-    return(TPM_FAIL);
-  }
-  /* initialize ioctl mempools */
-  if (tpm_init_ioctl_mempools() != TPM_OK)
-    return(TPM_FAIL);
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-  /* initialize ioctl debug semaphore, used for signalling between user space and sysfs  */
-  sema_init(&tpm_sfs_2_ioctl_sem, 0);
-#endif
-
-  cdev_init(&tpm_dev.cdev, &tpmCdevFops);
-  tpm_dev.cdev.owner = THIS_MODULE;
-  tpm_dev.cdev.ops   = &tpmCdevFops;
-
-  rcode = cdev_add(&tpm_dev.cdev, dev, 1);
-  if(rcode < 0)
-  {
-    printk(KERN_ERR "ERROR: (%s:%d) Gpon Char Device Add\n", __FUNCTION__, __LINE__);
-
-    cdev_del(&tpm_dev.cdev);
-    unregister_chrdev_region(dev, TPM_NUM_DEVICES);
-
-    return(TPM_FAIL);
-  }
-
-  /* create device for udev */
-  tpm_udev_class = class_create(THIS_MODULE, TPM_DEV_NAME);
-  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-    tpm_udev_dev   = device_create(tpm_udev_class, NULL, dev, TPM_DEV_NAME);
-  #else
-      tpm_udev_dev   = device_create(tpm_udev_class, NULL, dev, NULL, TPM_DEV_NAME);
-  #endif
-  return(TPM_OK);
-}
-
-/*******************************************************************************
-**
-**  tpm_module_mng_if_release
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function release management interface - char device
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     TPM_OK or TPM_FAIL
-**
-*******************************************************************************/
-int32_t tpm_module_mng_if_release(void)
-{
-  dev_t dev = MKDEV(MV_TPM_MAJOR, 0);
-
-  if (tpm_destroy_ioctl_mempools() != TPM_OK)
-    return(TPM_FAIL);
-
-  device_destroy(tpm_udev_class, dev);
-  class_unregister(tpm_udev_class);
-  class_destroy(tpm_udev_class);
-
-  unregister_chrdev_region(dev, TPM_NUM_DEVICES);
-
-  return(MV_OK);
-}
-
-
-EXPORT_SYMBOL(tpm_sw_add_static_mac);
-EXPORT_SYMBOL(tpm_sw_del_static_mac);
-EXPORT_SYMBOL(tpm_sw_set_port_max_macs);
-EXPORT_SYMBOL(tpm_sw_set_mac_age_time);
-EXPORT_SYMBOL(tpm_sw_get_mac_age_time);
-EXPORT_SYMBOL(tpm_sw_set_mac_learn);
-EXPORT_SYMBOL(tpm_sw_get_mac_learn);
-EXPORT_SYMBOL(tpm_set_mtu_size);
-EXPORT_SYMBOL(tpm_get_mtu_size);
-//EXPORT_SYMBOL(tpm_sw_set_port_flooding);
-//EXPORT_SYMBOL(tpm_sw_get_port_flooding);
-EXPORT_SYMBOL(tpm_sw_clear_dynamic_mac);
-EXPORT_SYMBOL(tpm_sw_set_port_mirror);
-EXPORT_SYMBOL(tpm_sw_get_port_mirror);
-EXPORT_SYMBOL(tpm_sw_set_isolate_eth_port_vector);
-EXPORT_SYMBOL(tpm_sw_get_isolate_eth_port_vector);
-EXPORT_SYMBOL(tpm_sw_set_port_tagged);
-EXPORT_SYMBOL(tpm_sw_set_port_untagged);
-EXPORT_SYMBOL(tpm_sw_set_port_def_vlan);
-EXPORT_SYMBOL(tpm_sw_get_port_def_vlan);
-EXPORT_SYMBOL(tpm_sw_set_port_def_pri);
-EXPORT_SYMBOL(tpm_sw_get_port_def_pri);
-EXPORT_SYMBOL(tpm_sw_port_add_vid);
-EXPORT_SYMBOL(tpm_sw_clear_vid_per_port);
-EXPORT_SYMBOL(tpm_sw_add_all_vid_per_port);
-EXPORT_SYMBOL(tpm_sw_port_add_vid_group);
-EXPORT_SYMBOL(tpm_sw_port_del_vid_group);
-EXPORT_SYMBOL(tpm_sw_set_port_vid_egress_mode);
-EXPORT_SYMBOL(tpm_sw_port_del_vid);
-EXPORT_SYMBOL(tpm_sw_port_set_vid_filter);
-EXPORT_SYMBOL(tpm_sw_set_uni_sched);
-EXPORT_SYMBOL(tpm_sw_set_uni_q_weight);
-EXPORT_SYMBOL(tpm_sw_set_uni_ingr_police_rate);
-EXPORT_SYMBOL(tpm_sw_get_uni_ingr_police_rate);
-EXPORT_SYMBOL(tpm_sw_set_uni_tc_ingr_police_rate);
-EXPORT_SYMBOL(tpm_sw_set_uni_egr_rate_limit);
-EXPORT_SYMBOL(tpm_sw_get_uni_egr_rate_limit);
-EXPORT_SYMBOL(tpm_phy_convert_port_index);
-EXPORT_SYMBOL(tpm_phy_set_port_autoneg_mode);
-EXPORT_SYMBOL(tpm_phy_get_port_autoneg_mode);
-EXPORT_SYMBOL(tpm_phy_restart_port_autoneg);
-EXPORT_SYMBOL(tpm_phy_set_port_admin_state);
-EXPORT_SYMBOL(tpm_phy_get_port_admin_state);
-EXPORT_SYMBOL(tpm_phy_set_port_flow_control_support);
-EXPORT_SYMBOL(tpm_phy_get_port_flow_control_support);
-EXPORT_SYMBOL(tpm_phy_get_port_flow_control_state);
-EXPORT_SYMBOL(tpm_phy_get_port_link_status);
-EXPORT_SYMBOL(tpm_phy_get_port_duplex_status);
-EXPORT_SYMBOL(tpm_phy_get_port_speed_mode);
-EXPORT_SYMBOL(tpm_phy_set_port_loopback);
-EXPORT_SYMBOL(tpm_phy_get_port_loopback);
-EXPORT_SYMBOL(tpm_phy_set_port_duplex_mode);
-EXPORT_SYMBOL(tpm_phy_get_port_duplex_mode);
-EXPORT_SYMBOL(tpm_phy_set_port_speed);
-EXPORT_SYMBOL(tpm_phy_get_port_speed);
-EXPORT_SYMBOL(tpm_alarm_get_eth_port);
-EXPORT_SYMBOL(tpm_sw_pm_1_read);
-EXPORT_SYMBOL(tpm_sw_pm_3_read);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.h
deleted file mode 100644
index 9ceffc6..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_mng_if.h
+++ /dev/null
@@ -1,1107 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#ifndef _TPM_MNG_IF_H_
-#define _TPM_MNG_IF_H_
-
-/* Include Files
-------------------------------------------------------------------------------*/
-
-/* Definitions
-------------------------------------------------------------------------------*/
-#define TPM_NUM_DEVICES     (1)
-#define TPM_DEV_NAME        ("tpm")
-#define MV_TPM_IOCTL_MAGIC  ('T')
-
-#define MAX_ETH_PORT_ALARM 10
-#define MAX_FRAME_SIZE     1600
-
-#define MV_TPM_IOCTL_INIT_SECTION          _IOW(MV_TPM_IOCTL_MAGIC,   1, unsigned int)
-#define MV_TPM_IOCTL_ADMIN_SECTION         _IOWR(MV_TPM_IOCTL_MAGIC,  2, unsigned int)
-#define MV_TPM_IOCTL_ADD_ACL_SECTION       _IOW(MV_TPM_IOCTL_MAGIC,   3, unsigned int)
-#define MV_TPM_IOCTL_DEL_ACL_SECTION       _IOW(MV_TPM_IOCTL_MAGIC,   4, unsigned int)
-#define MV_TPM_IOCTL_CTRL_ACL_SECTION      _IOWR(MV_TPM_IOCTL_MAGIC,  5, unsigned int)
-#define MV_TPM_IOCTL_MC_STREAM_SECTION     _IOW(MV_TPM_IOCTL_MAGIC,   6, unsigned int)
-#define MV_TPM_IOCTL_MNG_SECTION           _IOWR(MV_TPM_IOCTL_MAGIC,  7, unsigned int)
-#define MV_TPM_IOCTL_SW_SECURITY_SECTION   _IOW(MV_TPM_IOCTL_MAGIC,   8, unsigned int)
-#define MV_TPM_IOCTL_SW_VLAN_SECTION       _IOW(MV_TPM_IOCTL_MAGIC,   9, unsigned int)
-#define MV_TPM_IOCTL_SW_TM_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  10, unsigned int)
-#define MV_TPM_IOCTL_IGMP_SECTION          _IOW(MV_TPM_IOCTL_MAGIC,  11, unsigned int)
-#define MV_TPM_IOCTL_PP_TM_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  12, unsigned int)
-#define MV_TPM_IOCTL_PRINT_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  13, unsigned int)
-#define MV_TPM_IOCTL_TRACE_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  14, unsigned int)
-#define MV_TPM_IOCTL_SW_PHY_SECTION        _IOW(MV_TPM_IOCTL_MAGIC,  15, unsigned int)
-#define MV_TPM_IOCTL_RESET_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  16, unsigned int)
-#define MV_TPM_IOCTL_ALARM_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  17, unsigned int)
-#define MV_TPM_IOCTL_COUNTER_CLEAR_SECTION _IOW(MV_TPM_IOCTL_MAGIC,  18, unsigned int)
-#define MV_TPM_IOCTL_GET_MOD_SECTION       _IOWR(MV_TPM_IOCTL_MAGIC, 19, unsigned int)
-#define MV_TPM_IOCTL_RX_IGMP               _IOWR(MV_TPM_IOCTL_MAGIC, 20, unsigned int)
-#define MV_TPM_IOCTL_TX_IGMP               _IOW(MV_TPM_IOCTL_MAGIC,  21, unsigned int)
-#define MV_TPM_IOCTL_SETUP_SECTION         _IOW(MV_TPM_IOCTL_MAGIC,  22, unsigned int)
-#define MV_TPM_IOCTL_CPU_LPBK_SECTION      _IOWR(MV_TPM_IOCTL_MAGIC, 23, unsigned int)
-#define MV_TPM_IOCTL_AGE_COUNT_SECTION     _IOWR(MV_TPM_IOCTL_MAGIC, 24, unsigned int)
-#define MV_TPM_IOCTL_MC_VLAN_SECTION       _IOWR(MV_TPM_IOCTL_MAGIC, 25, unsigned int)
-#define MV_TPM_IOCTL_MTU_SECTION           _IOWR(MV_TPM_IOCTL_MAGIC, 26, unsigned int)
-#define MV_TPM_IOCTL_TPM_CHECK_SECTION     _IOW(MV_TPM_IOCTL_MAGIC,  27, unsigned int)
-#define MV_TPM_IOCTL_FLUSH_ATU_SECTION     _IOWR(MV_TPM_IOCTL_MAGIC, 28, unsigned int)
-#define MV_TPM_IOCTL_FLUSH_VTU_SECTION     _IOWR(MV_TPM_IOCTL_MAGIC, 29, unsigned int)
-#define MV_TPM_IOCTL_SET_IPV6_CM_PARSE_WIN_SECTION     _IOWR(MV_TPM_IOCTL_MAGIC, 30, unsigned int)
-#define MV_TPM_IOCTL_SET_ACTIVE_WAN_SECTION            _IOWR(MV_TPM_IOCTL_MAGIC, 31, unsigned int)
-#define MV_TPM_IOCTL_HOT_SWAP_PROFILE_SECTION          _IOWR(MV_TPM_IOCTL_MAGIC, 32, unsigned int)
-#define MV_TPM_IOCTL_SET_GMAC_LPBK_SECTION             _IOWR(MV_TPM_IOCTL_MAGIC, 33, unsigned int)
-#define MV_TPM_IOCTL_SET_PORT_HWF_ADMIN_SECTION        _IOWR(MV_TPM_IOCTL_MAGIC, 34, unsigned int)
-
-
-#define MV_APM_IOCTL_MAGIC  ('A')
-
-#define MV_APM_IOCTL_PM_1_SWPORT_SECTION   _IOWR(MV_APM_IOCTL_MAGIC,  1, unsigned int)
-#define MV_APM_IOCTL_PM_3_SWPORT_SECTION   _IOWR(MV_APM_IOCTL_MAGIC,  2, unsigned int)
-
-
-/* Enums
-------------------------------------------------------------------------------*/
-
-typedef enum tpm_ioctl_cmd_type
-{
-    MV_TPM_IOCTL_INIT =  1,
-    MV_TPM_IOCTL_CRT_OWNER,
-    MV_TPM_IOCTL_REQ_API_G_OWNER,
-    MV_TPM_IOCTL_GET_API_G_OWNER,
-    MV_TPM_IOCTL_DEL_SECTION,
-    MV_TPM_IOCTL_GET_SECTION_SIZE,
-    MV_TPM_IOCTL_ADD_L2_ACL_RULE,
-    MV_TPM_IOCTL_ADD_L3_ACL_RULE,
-    MV_TPM_IOCTL_ADD_IPv4_ACL_RULE,
-    MV_TPM_IOCTL_DEL_L2_ACL_RULE,
-    MV_TPM_IOCTL_DEL_L3_ACL_RULE,
-    MV_TPM_IOCTL_DEL_IPv4_ACL_RULE,
-    MV_TPM_IOCTL_GET_NEXT_VALID_RULE,
-    MV_TPM_IOCTL_ADD_IPv4_MC_STREAM,
-    MV_TPM_IOCTL_MOD_IPv4_MC_STREAM,
-    MV_TPM_IOCTL_DEL_IPv4_MC_STREAM,
-    MV_TPM_IOCTL_ADD_OMCI_CHNL,
-    MV_TPM_IOCTL_DEL_OMCI_CHNL,
-    MV_TPM_IOCTL_GET_OMCI_CHNL,
-    MV_TPM_IOCTL_ADD_OAM_CHNL,
-    MV_TPM_IOCTL_DEL_OAM_CHNL,
-    MV_TPM_IOCTL_GET_OAM_CHNL,
-    MV_TPM_IOCTL_SW_ADD_STATIC_MAC,
-    MV_TPM_IOCTL_SW_DEL_STATIC_MAC,
-    MV_TPM_IOCTL_SW_SET_PORT_MAC_LIMIT,
-    MV_TPM_IOCTL_SW_SET_PORT_FLOOD,
-    MV_TPM_IOCTL_SW_SET_PORT_TAGGED,
-    MV_TPM_IOCTL_SW_SET_PORT_UNTAGGED,
-    MV_TPM_IOCTL_SW_PORT_ADD_VID,
-    MV_TPM_IOCTL_SW_PORT_DEL_VID,
-    MV_TPM_IOCTL_SW_PORT_SER_VID_FILTER,
-    MV_TPM_IOCTL_SW_SET_UNI_SCHED,
-    MV_TPM_IOCTL_SW_UNI_QUE_WEIGHT,
-    MV_TPM_IOCTL_SW_SET_UNI_INGR_POLICE_RATE,
-    MV_TPM_IOCTL_SW_UNI_TC_INGR_POLICE_RATE,
-    MV_TPM_IOCTL_SW_SET_UNI_EGR_RATE_LIMIT,
-    MV_TPM_IOCTL_TM_SET_WAN_EGR_QUE_SCHED,
-    MV_TPM_IOCTL_TM_SET_WAN_INGR_QUE_SCHED,
-    MV_TPM_IOCTL_TM_SET_WAN_SCHED_EGR_RATE_LIMIT,
-    MV_TPM_IOCTL_TM_SET_WAN_QUE_EGR_RATE_LIMIT,
-    MV_TPM_IOCTL_TM_SET_WAN_INGR_RATE_LIMIT,
-    MV_TPM_IOCTL_TM_SET_WAN_QUE_INGR_RATE_LIMIT,
-    MV_TPM_IOCTL_IGMP_SET_PORT_FRWD_MODE,
-    MV_TPM_IOCTL_IGMP_GET_PORT_FRWD_MODE,
-    MV_TPM_IOCTL_PRINT_ETHER_PORTS,
-    MV_TPM_IOCTL_PRINT_TX_MODULES,
-    MV_TPM_IOCTL_PRINT_GMAC_CONFIG,
-    MV_TPM_IOCTL_PRINT_GMAC_FUNC,
-    MV_TPM_IOCTL_PRINT_EXT_PORT_MAP,        /*not used anymore - can be reused*/
-    MV_TPM_IOCTL_PRINT_IGMP,
-    MV_TPM_IOCTL_PRINT_MISC,
-    MV_TPM_IOCTL_PRINT_OWNERS,
-    MV_TPM_IOCTL_PRINT_API_GROUP,           /*not used anymore - can be reused*/
-    MV_TPM_IOCTL_PRINT_VLAN_TYPE,
-    MV_TPM_IOCTL_PRINT_VALID_API_SECTIONS,
-    MV_TPM_IOCTL_PRINT_FULL_API_SECTIONS,
-    MV_TPM_IOCTL_PRINT_MOD_SHADOW_RANGE,    /*not used anymore - can be reused*/
-    MV_TPM_IOCTL_PRINT_PNC_SHADOW_RANGE,
-    MV_TPM_IOCTL_PRINT_VALID_PNC_RANGES,
-    MV_TPM_IOCTL_PRINT_INIT_TABLES,
-
-    MV_TPM_IOCTL_PRINT_MOD2_TMP_PATTERN,
-    MV_TPM_IOCTL_PRINT_MOD2_JUMP_RANGE,     /*not used anymore - can be reused*/
-    MV_TPM_IOCTL_PRINT_MOD2_JUMP_ALL,
-    MV_TPM_IOCTL_PRINT_MOD2_MAIN_RANGE,     /*not used anymore - can be reused*/
-    MV_TPM_IOCTL_PRINT_MOD2_MAIN_ALL,
-    MV_TPM_IOCTL_PRINT_MOD2_CFG,
-    MV_TPM_IOCTL_PRINT_MOD2_RULE,
-
-    MV_TPM_IOCTL_TRACE_STATUS,
-    MV_TPM_IOCTL_TRACE_SET,
-    MV_TPM_IOCTL_TRACE_MODULE_SET,
-
-    MV_TPM_IOCTL_RESERVED_1,
-    MV_TPM_IOCTL_RESERVED_2,
-
-    MV_TPM_IOCTL_SW_PHY_SET_AUTONEG_MODE,
-    MV_TPM_IOCTL_SW_PHY_GET_AUTONEG_MODE,
-    MV_TPM_IOCTL_SW_PHY_RESTART_AUTONEG,
-    MV_TPM_IOCTL_SW_PHY_SET_PORT_STATE,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_STATE,
-    MV_TPM_IOCTL_SW_PHY_GET_LINK_STATUS,
-    MV_TPM_IOCTL_SW_PHY_SET_PORT_FLOW_CONTROL,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_FLOW_CONTROL,
-    MV_TPM_IOCTL_SW_PHY_SET_PORT_SPEED,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_SPEED,
-    MV_TPM_IOCTL_SW_PORT_VLAN_EGRESS_MODE,
-    MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_VLAN,
-    MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_VLAN,
-    MV_TPM_IOCTL_SW_PORT_SET_DEFAULT_PRIORITY,
-    MV_TPM_IOCTL_SW_PORT_GET_DEFAULT_PRIORITY,
-    MV_TPM_IOCTL_SW_PORT_CLEAR_VID,
-    MV_TPM_IOCTL_SW_PHY_SET_PORT_LOOPBACK,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_LOOPBACK,
-
-    MV_TPM_IOCTL_ALARM_GET_ETH_PORT,
-    MV_TPM_IOCTL_SW_PHY_CONVERT_PORT_INDEX,
-    MV_TPM_IOCTL_ADD_LOOP_DETECT_CHNL,
-    MV_TPM_IOCTL_DEL_LOOP_DETECT_CHNL,
-    MV_TPM_IOCTL_ADD_OAM_LOOPBACK_CHNL,
-    MV_TPM_IOCTL_DEL_OAM_LOOPBACK_CHNL,
-    MV_TPM_IOCTL_SW_PHY_SET_PORT_DUPLEX_MODE,
-    MV_TPM_IOCTL_SW_SET_MAC_AGE_TIME,
-    MV_TPM_IOCTL_SW_GET_MAC_AGE_TIME,
-    MV_TPM_IOCTL_SW_SET_MAC_LEARN,
-    MV_TPM_IOCTL_SW_GET_PORT_FLOOD,
-    MV_TPM_IOCTL_UNI_2_SW_PORT,
-
-    MV_TPM_IOCTL_RESERVED_3,
-    MV_TPM_IOCTL_RESERVED_4,
-    MV_TPM_IOCTL_RESERVED_5,
-    MV_TPM_IOCTL_RESERVED_6,
-
-    MV_TPM_IOCTL_SW_PHY_GET_DUPLEX_STATUS,
-    MV_TPM_IOCTL_SW_PHY_GET_SPEED_MODE,
-    MV_TPM_IOCTL_SW_CLEAR_DYNAMIC_MAC,
-    MV_TPM_IOCTL_SW_SET_MIRROR,
-    MV_TPM_IOCTL_SW_GET_MIRROR,
-    MV_TPM_IOCTL_SW_GET_MAC_LEARN,
-    MV_TPM_IOCTL_SW_SET_TRUNK_PORT,
-    MV_TPM_IOCTL_SW_SET_TRUNK_MASK,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_DUPLEX_MODE,
-    MV_TPM_IOCTL_SET_MTU_SIZE,
-    MV_TPM_IOCTL_GET_MTU_SIZE,
-    MV_TPM_IOCTL_GET_PM_COUNTERS,
-    MV_TPM_IOCTL_CLEAR_PM_COUNTERS,
-    MV_TPM_IOCTL_SW_SET_ISOLATE_PORT_VECTOR,
-    MV_TPM_IOCTL_SW_GET_UNI_EGR_RATE_LIMIT,
-    MV_TPM_IOCTL_SW_GET_UNI_INGR_POLICE_RATE,
-
-    MV_TPM_IOCTL_SET_MOD_RULE,
-    MV_TPM_IOCTL_DEL_MOD_RULE,
-    MV_TPM_IOCTL_GET_MOD_RULE,
-    MV_TPM_IOCTL_INV_MOD_RULES,
-
-    MV_TPM_IOCTL_PRINT_RX_MODULES,
-    MV_TPM_IOCTL_SW_PORT_ADD_ALL_VID,
-    MV_TPM_IOCTL_SW_GET_ISOLATE_PORT_VECTOR,
-    MV_TPM_IOCTL_SW_PHY_GET_PORT_FC_STATE,
-    MV_TPM_IOCTL_SW_ADD_VID_GROUP,
-    MV_TPM_IOCTL_SW_DEL_VID_GROUP,
-    MV_TPM_IOCTL_IGMP_SET_CPU_RX_Q,
-    MV_TPM_IOCTL_IGMP_GET_CPU_RX_Q,
-
-    MV_TPM_IOCTL_ADD_CPU_WAN_LPBK,
-    MV_TPM_IOCTL_DEL_CPU_WAN_LPBK,
-
-    MV_TPM_IOCTL_GET_LU_ENTRIES,
-    MV_TPM_IOCTL_GET_ALL_HIT_COUNTERS,
-    MV_TPM_IOCTL_SET_LU_COUNT_MASK,
-    MV_TPM_IOCTL_GET_HIT_COUNT,
-    MV_TPM_IOCTL_SET_LU_THESHOLD,
-    MV_TPM_IOCTL_RESET_COUNT_GROUP,
-
-    MV_TPM_IOCTL_ADD_IPV6_NH_ACL_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_NH_ACL_RULE,
-    MV_TPM_IOCTL_ADD_IPV6_GEN_ACL_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_GEN_ACL_RULE,
-    MV_TPM_IOCTL_ADD_IPV6_DIP_ACL_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_DIP_ACL_RULE,
-    MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_ACL_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_L4_PORTS_ACL_RULE,
-
-    MV_TPM_IOCTL_SET_MC_VID_PORT_VIDS,
-    MV_TPM_IOCTL_SET_MTU_ADMIN,
-    MV_TPM_IOCTL_SET_MTU,
-    MV_TPM_IOCTL_SET_PPPOE_MTU,
-
-    MV_TPM_IOCTL_SET_IGMP_PROXY_SA_MAC,
-    MV_TPM_IOCTL_GET_IGMP_PROXY_SA_MAC,
-    MV_TPM_IOCTL_ADD_IPv6_MC_STREAM,
-    MV_TPM_IOCTL_MOD_IPv6_MC_STREAM,
-    MV_TPM_IOCTL_DEL_IPv6_MC_STREAM,
-
-    MV_TPM_IOCTL_ADD_IPV6_GEN_5T_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_GEN_5T_RULE,
-    MV_TPM_IOCTL_ADD_IPV6_DIP_5T_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_DIP_5T_RULE,
-    MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_5T_RULE,
-    MV_TPM_IOCTL_DEL_IPV6_L4_PORTS_5T_RULE,
-
-    MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE,
-    MV_TPM_IOCTL_DEL_CTC_CM_ACL_RULE,
-    MV_TPM_IOCTL_ADD_CTC_CM_IPV6_ACL_RULE,
-    MV_TPM_IOCTL_SET_CTC_CM_IPV6_PARSE_WIN,
-    MV_TPM_IOCTL_ADD_MAC_LEARN_ACL_RULE,
-    MV_TPM_IOCTL_DEL_MAC_LEARN_ACL_RULE,
-    MV_TPM_IOCTL_SET_MAC_LEARN_DEFAULT_ACTION,
-    MV_TPM_IOCTL_TM_SET_GMAC0_INGR_RATE_LIMIT,
-    MV_TPM_IOCTL_GET_MAC_LEARN_ENTRY_NUM,
-    MV_TPM_IOCTL_ADD_DS_LOAD_BALANCE_RULE,
-    MV_TPM_IOCTL_DEL_DS_LOAD_BALANCE_RULE,
-    MV_TPM_IOCTL_ADD_IPv4_MC_STREAM_SET_QUEUE,
-    MV_TPM_IOCTL_ADD_IPv6_MC_STREAM_SET_QUEUE,
-    MV_TPM_IOCTL_SW_PORT_ADD_VID_SET_EGRESS_MODE,
-
-} tpm_ioctl_cmd_type_t;
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-
-/* Print Section
-** ==============
-** Function list:
-** 1.  tpm_print_etherports
-** 2.  tpm_print_tx_modules
-** 3.  tpm_print_gmac_config
-** 4.  tpm_print_gmac_func
-** 5.  tpm_print_ext_port_map
-** 6.  tpm_print_igmp
-** 7.  tpm_print_misc
-** 8.  tpm_print_owners
-** 9.
-** 10. tpm_print_vlan_etype
-** 11. tpm_print_valid_api_sections
-** 12. tpm_print_full_api_section
-** 13. tpm_print_mod_shadow_range
-** 14. tpm_print_pnc_shadow_range
-** 15. tpm_print_valid_pnc_ranges
-** 16. tpm_print_init_tables
-** 17. tpm_mod2_print_tmp_pattern
-** 18. tpm_mod2_print_jump_range
-** 19. tpm_mod2_print_jump_all
-** 20. tpm_mod2_print_main_range
-** 21. tpm_mod2_print_main_all
-** 22. tpm_mod2_print_config
-*/
-typedef struct
-{
-    uint32_t           print_cmd;
-    tpm_api_sections_t api_section;
-    tpm_gmacs_enum_t   gmac;
-    uint32_t           valid;
-    uint32_t           start;
-    uint32_t           end;
-    uint32_t           dir;
-    uint32_t           entry;
-    uint32_t           num;
-} tpm_ioctl_print_t;
-
-/* Trace Section
-** ==============
-** Function list:
-** 1.  tpm_trace_status_print
-** 2.  tpm_trace_set
-** 3.  tpm_trace_module_set
-*/
-
-typedef struct
-{
-    uint32_t trace_cmd;
-    uint32_t level;
-    uint32_t module;
-    uint32_t flag;
-} tpm_ioctl_trace_t;
-
-/* Admin Section
-** ==============
-** Function list:
-** 1. tpm_create_ownerid
-** 2. tpm_request_api_ownership
-** 3. tpm_get_api_ownership
-** 4. tpm_erase_section
-** 5. tpm_get_section_free_size
-*/
-
-typedef struct
-{
-    uint32_t                  amdin_cmd;
-    uint32_t                  owner_id;
-    tpm_api_type_t            api_type;
-    tpm_api_ownership_error_t api_ownership_error;
-    int32_t                   section_size;
-    uint8_t                   section_dir;
-    uint8_t                   dummy1;
-    uint16_t                  dummy2;
-} tpm_ioctl_admin_t;
-
-/* ACL Rule Add Section
-** ====================
-** Function list:
-** 1. tpm_add_l2_rule
-** 2. tpm_add_l3_type_rule
-** 3. tpm_add_ipv4_rule
-** 4. tpm_add_ipv6_gen_rule
-** 5. tpm_add_ipv6_nh_rule
-** 6. tpm_add_ipv6_dip_rule
-** 7. tpm_add_ipv6_l4_ports_rule
-** 8. tpm_mod_entry_set
-** 9. tpm_add_ipv6_gen_5t_rule
-** 10. tpm_add_ipv6_dip_5t_rule
-** 11. tpm_add_ipv6_l4_ports_5t_rule
-** 12. tpm_add_ctc_cm_acl_rule
-*/
-
-/* L2 */
-typedef struct
-{
-    tpm_l2_acl_key_t   l2_key;
-    tpm_pkt_frwd_t     pkt_frwd;
-    tpm_pkt_mod_t      pkt_mod;
-    tpm_rule_action_t  rule_action;
-    tpm_parse_flags_t  parse_flags_bm;
-    tpm_pkt_mod_bm_t   pkt_mod_bm;
-    tpm_unknown_mac_conf_t mac_conf;/*Just for PnC MAC learn*/
-} l2_acl_rule_t;
-
-/* L3 */
-typedef struct
-{
-    tpm_l3_type_key_t   l3_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_rule_action_t   rule_action;
-    tpm_parse_flags_t   parse_flags_bm;
-} l3_acl_rule_t;
-
-/* IPv4 */
-typedef struct
-{
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_ipv4_acl_key_t  ipv4_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-} ipv4_acl_rule_t;
-
-/* IPv6 */
-typedef struct
-{
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-} ipv6_gen_acl_rule_t;
-
-typedef struct
-{
-	tpm_nh_iter_t            nh_iter;
-    uint32_t                 nh;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_rule_action_t        rule_action;
-} ipv6_nh_acl_rule_t;
-
-typedef struct
-{
-    tpm_parse_flags_t        parse_flags_bm;
-    tpm_ipv6_addr_key_t      ipv6_dip_key;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    tpm_pkt_mod_bm_t         pkt_mod_bm;
-    tpm_rule_action_t        rule_action;
-} ipv6_dip_acl_rule_t;
-
-typedef struct
-{
-    tpm_parse_flags_t        parse_flags_bm;
-    tpm_l4_ports_key_t       l4_key;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    tpm_pkt_mod_bm_t         pkt_mod_bm;
-    tpm_rule_action_t        rule_action;
-} ipv6_l4_ports_acl_rule_t;
-
-/* IPv6 5 tuple */
-typedef struct
-{
-    tpm_parse_flags_t      parse_flags_bm;
-    tpm_l4_ports_key_t     l4_key;
-    tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-    tpm_pkt_frwd_t         pkt_frwd;
-    tpm_pkt_mod_t          pkt_mod;
-    tpm_pkt_mod_bm_t       pkt_mod_bm;
-    tpm_rule_action_t      rule_action;
-} ipv6_gen_5t_rule_t;
-
-typedef struct
-{
-    tpm_parse_flags_t        parse_flags_bm;
-    tpm_l4_ports_key_t       l4_key;
-    tpm_ipv6_gen_acl_key_t   ipv6_gen_key;
-    tpm_ipv6_addr_key_t      ipv6_dip_key;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    tpm_pkt_mod_bm_t         pkt_mod_bm;
-    tpm_rule_action_t        rule_action;
-} ipv6_dip_5t_rule_t;
-
-typedef struct
-{
-    tpm_parse_flags_t        parse_flags_bm;
-    tpm_l4_ports_key_t       l4_key;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    tpm_pkt_mod_bm_t         pkt_mod_bm;
-    tpm_rule_action_t        rule_action;
-} ipv6_l4_ports_5t_rule_t;
-
-/* CTC CnM */
-typedef struct
-{
-    uint32_t           precedence;
-    uint32_t           p_bits;
-    tpm_parse_fields_t l2_parse_rule_bm;
-    tpm_parse_fields_t ipv4_parse_rule_bm;
-    tpm_parse_fields_t ipv6_parse_rule_bm;
-    tpm_l2_acl_key_t   l2_key;
-    tpm_ipv4_acl_key_t ipv4_key;
-    tpm_ipv6_acl_key_t ipv6_key;
-    tpm_pkt_frwd_t     pkt_frwd;
-    tpm_pkt_action_t   pkt_act;
-} ctc_cm_acl_rule_t;
-
-/* DS load balance */
-typedef struct
-{
-    tpm_l2_acl_key_t   l2_key;
-    tpm_parse_flags_t  parse_flags_bm;
-    tpm_ds_load_balance_tgrt_t tgrt;
-} ds_load_balance_acl_rule_t;
-
-/* Pkt modification */
-typedef struct
-{
-    tpm_trg_port_type_t  trg_port;
-    tpm_pkt_mod_bm_t     mod_bm;
-    tpm_pkt_mod_int_bm_t int_bm;
-    tpm_pkt_mod_t        mod_data;
-} pkt_mod_rule_t;
-
-typedef struct
-{
-    uint32_t             add_acl_cmd;
-    uint32_t             owner_id;
-    tpm_src_port_type_t  src_port;
-	tpm_dir_t            src_dir;
-    uint32_t             rule_num;
-    uint32_t             rule_idx;
-    tpm_parse_fields_t   parse_rule_bm;
-
-    union
-    {
-      l2_acl_rule_t            l2_acl_rule;
-      l3_acl_rule_t            l3_acl_rule;
-      ipv4_acl_rule_t          ipv4_acl_rule;
-      ipv6_gen_acl_rule_t      ipv6_gen_acl_rule;
-      ipv6_nh_acl_rule_t       ipv6_nh_acl_rule;
-      ipv6_dip_acl_rule_t      ipv6_dip_acl_rule;
-      ipv6_l4_ports_acl_rule_t ipv6_l4_ports_acl_rule;
-      ipv6_gen_5t_rule_t       ipv6_gen_5t_rule;
-      ipv6_dip_5t_rule_t       ipv6_dip_5t_rule;
-      ipv6_l4_ports_5t_rule_t  ipv6_l4_ports_5t_rule;
-      ctc_cm_acl_rule_t        ctc_cm_acl_rule;
-      pkt_mod_rule_t           mod_rule;
-      ds_load_balance_acl_rule_t ds_load_balance_acl_rule;
-    };
-} tpm_ioctl_add_acl_rule_t;
-
-/* ACL Rule Delete Section
-** =======================
-** Function list:
-** 1. tpm_del_l2_rule
-** 2. tpm_del_l3_type_rule
-** 3. tpm_del_ipv4_rule
-** 4. tpm_del_ipv6_gen_rule
-** 5. tpm_del_ipv6_nh_rule
-** 6. tpm_del_ipv6_dip_rule
-** 7. tpm_del_ipv6_l4_ports_rule
-** 8. tpm_mod_entry_del
-** 9. tpm_mod_mac_inv
-** 10. tpm_del_ipv6_gen_5t_rule
-** 11. tpm_del_ipv6_dip_5t_rule
-** 12. tpm_del_ipv6_l4_ports_5t_rule
-** 13. tpm_del_ctc_cm_acl_rule
-*/
-
-typedef struct
-{
-    uint32_t             del_acl_cmd;
-    uint32_t             owner_id;
-    tpm_src_port_type_t  src_port;
-    tpm_trg_port_type_t  trg_port;
-    uint32_t             rule_idx;
-    uint32_t           	 precedence;
-    tpm_parse_fields_t   parse_rule_bm;
-    tpm_l2_acl_key_t     l2_key;/*for MAC learn*/
-} tpm_ioctl_del_acl_rule_t;
-
-/* Modification Rule Get Section
-** =======================
-** Function list:
-** 1. tpm_mod_entry_get
-*/
-typedef struct
-{
-    uint32_t            get_mod_cmd;
-    tpm_trg_port_type_t trg_port;
-    uint32_t            rule_idx;
-    uint16_t            pnc_ref;
-    uint16_t            valid_num;
-    tpm_mod_rule_t      rule[TPM_MAX_MOD_RULE_NUM];
-} tpm_ioctl_get_mod_rule_t;
-
-/* ACL Ctrl Rule Section
-** =====================
-** Function list:
-** 1. tpm_get_next_valid_rule
-*/
-
-typedef struct
-{
-    uint32_t         ctrl_acl_cmd;
-    uint32_t         owner_id;
-    int32_t          current_index;
-    uint32_t         next_index;
-    uint32_t         rule_idx;
-    tpm_api_type_t   rule_type;
-    uint8_t          direction;
-    uint8_t          dummy1;
-    uint16_t         dummy2;
-    tpm_rule_entry_t tpm_rule;
-    uint32_t         entry_count;
-} tpm_ioctl_ctrl_acl_rule_t;
-
-/* MC Rule Section
-** ===============
-** Function list:
-** 1. tpm_add_ipv4_mc_stream
-** 2. tpm_updt_ipv4_mc_stream
-** 3. tpm_del_ipv4_mc_stream
-** 4. tpm_add_ipv6_mc_stream
-** 5. tpm_updt_ipv6_mc_stream
-** 6. tpm_del_ipv6_mc_stream
-*/
-
-/* IPv4 */
-typedef struct
-{
-    uint8_t  ipv4_src_add[4];
-    uint8_t  ipv4_dst_add[4];
-    uint8_t  ignore_ipv4_src;
-    uint8_t  dummy1;
-    uint16_t dummy2;
-} ipv4_mc_rule_t;
-
-/* IPv6 */
-typedef struct
-{
-    uint32_t vid;
-    uint8_t  ipv6_src_add[16];
-    uint8_t  ipv6_dst_add[16];
-    uint8_t  ignore_ipv6_src;
-    uint8_t  dummy1;
-    uint16_t dummy2;
-} ipv6_mc_rule_t;
-
-typedef struct
-{
-    uint32_t             mc_cmd;
-    uint32_t             owner_id;
-    uint32_t             stream_num;
-    tpm_mc_igmp_mode_t   igmp_mode;
-    uint8_t              mc_stream_pppoe;
-    uint16_t             vid;
-    uint16_t             dest_queue;
-    tpm_trg_port_type_t  dest_port_bm;
-
-    union
-    {
-      ipv4_mc_rule_t  ipv4_mc;
-      ipv6_mc_rule_t  ipv6_mc;
-    };
-} tpm_ioctl_mc_rule_t;
-
-/* Mng Rule Section
-** ================
-** Function list:
-** 1. tpm_omci_add_channel
-** 2. tpm_omci_del_channel
-** 3. tpm_omci_get_channel
-** 4. tpm_oam_epon_add_channel
-** 5. tpm_oam_epon_del_channel
-** 6. tpm_oam_epon_get_channel
-*/
-
-typedef struct
-{
-    uint32_t              owner_id;
-    uint32_t              is_valid;
-    uint32_t              cpu_rx_queue;
-    tpm_trg_port_type_t   tcont_num;
-    uint32_t              cpu_tx_queue;
-    tpm_gem_port_key_t    gem_port;
-    uint16_t              dummy;
-} tpm_ioctl_omci_ch_t;
-
-typedef struct
-{
-    uint32_t              owner_id;
-    uint32_t              is_valid;
-    uint32_t              cpu_rx_queue;
-    tpm_trg_port_type_t   llid_num;
-} tpm_ioctl_oam_ch_t;
-
-typedef struct
-{
-    uint32_t              mng_cmd;
-    tpm_ioctl_omci_ch_t   tpm_ioctl_omci_ch;
-    tpm_ioctl_oam_ch_t    tpm_ioctl_oam_ch;
-    uint32_t              loopback_detect_ety;
-} tpm_ioctl_mng_ch_t;
-
-/* Switch Section
-** ==============
-** Function list:
-** 1. tpm_sw_add_static_mac
-** 2. tpm_sw_del_static_mac
-** 3. tpm_sw_set_port_max_macs
-** 4. tpm_sw_set_port_flooding
-**
-** 5. tpm_sw_set_port_tagged
-** 6. tpm_sw_set_port_untagged
-** 7. tpm_sw_port_add_vid
-** 8. tpm_sw_port_del_vid
-** 9. tpm_sw_port_set_vid_filter
-**
-** 10.tpm_sw_set_uni_sched
-** 11.tpm_sw_set_uni_q_weight
-** 12.tpm_sw_set_uni_ingr_police_rate
-** 13.tpm_sw_set_uni_tc_ingr_police_rate
-** 14.tpm_sw_set_uni_egr_rate_limit
-*/
-
-/* Switch MAC security */
-typedef struct
-{
-    uint32_t              sw_security_cmd;
-    uint32_t              owner_id;
-    tpm_src_port_type_t   port;
-    uint8_t               static_mac[6];
-    uint8_t               mac_per_port;
-    uint8_t               allow_flood;
-    bool                  enable_mac_learn;
-    tpm_flood_type_t      flood_mode;
-    uint32_t              mac_age_time;
-    tpm_sw_mirror_t       port_mirror;
-    tpm_mru_type_t        mtu_type;
-    uint32_t              mtu_size;
-    uint32_t              port_vector;
-    tpm_sw_trunk_t        trunk;
-} tpm_ioctl_sw_mac_security_t;
-
-/* Switch Vlan filtering */
-typedef struct
-{
-    uint32_t              sw_vlan_cmd;
-    uint32_t              owner_id;
-    tpm_src_port_type_t   port;
-    uint16_t              vid;
-    uint8_t               pri;
-    uint8_t               vid_filter;
-    uint8_t               allow_tagged;
-    uint8_t               allow_untagged;
-    uint8_t               egress_mode;
-    uint8_t               dummy;
-    uint16_t              min_vid;
-    uint16_t              max_vid;
-} tpm_ioctl_sw_vlan_filter_t;
-
-/* Switch Traffic management */
-typedef struct
-{
-    uint32_t            sw_tm_cmd;
-    uint32_t            owner_id;
-    tpm_src_port_type_t uni_port;
-    tpm_sw_sched_type_t sw_sched_mode;
-    uint8_t             queue_id;
-    uint8_t             weight;
-    uint16_t            dummy;
-    uint32_t            limit_mode;
-    uint32_t            cir;
-    uint32_t            cbs;
-    uint32_t            ebs;
-    uint32_t            tc;
-    uint32_t            rate_limit_val;
-} tpm_ioctl_sw_tm_t;
-
-/* Switch PHY port management */
-typedef struct
-{
-    uint32_t                sw_phy_cmd;
-    uint32_t                owner_id;
-    tpm_src_port_type_t     port;
-    tpm_phy_speed_t         port_speed;
-    tpm_phy_loopback_mode_t port_loopback_mode;
-    tpm_src_port_type_t     extern_port_id;
-    uint32_t                switch_port_id;
-    tpm_autoneg_mode_t      port_autoneg_mode;
-    bool                    phy_port_state;
-    bool                    port_autoneg_state;
-    bool                    port_link_status;
-    bool                    port_pause_state;
-    bool                    port_duplex_enable;
-    bool                    port_loopback_state;
-    uint16_t                dummy;
-} tpm_ioctl_sw_phy_t;
-
-/* Packet Processor Section
-** ========================
-** Function list:
-** 1. tpm_tm_set_wan_egr_queue_sched
-** 2. tpm_tm_set_wan_sched_egr_rate_lim
-** 3. tpm_tm_set_wan_queue_egr_rate_lim
-** 4. tpm_tm_set_wan_ingr_rate_lim
-** 5. tpm_tm_set_wan_q_ingr_rate_lim
-*/
-
-/* Packet Processor Traffic management */
-typedef struct
-{
-    uint32_t            pp_tm_cmd;
-    uint32_t            owner_id;
-    tpm_trg_port_type_t sched_ent;
-    tpm_trg_port_type_t uni_port;
-    tpm_pp_sched_type_t pp_sched_mode;
-    uint32_t            queue_id;
-    uint32_t            wrr_weight;
-    uint32_t            rate_limit_val;
-    uint32_t            bucket_size;
-} tpm_ioctl_tm_tm_t;
-
-/* IGMP Section
-** =============
-** Function list:
-** 1. tpm_proc_enable_igmp
-** 2. tpm_proc_edisable_igmp
-*/
-
-/* Packet Processor Traffic management */
-typedef struct
-{
-    uint32_t             igmp_cmd;
-    uint32_t             owner_id;
-    tpm_src_port_type_t  src_port;
-    tpm_igmp_frwd_mode_t frwd_mode;
-    uint32_t             cpu_queue;
-    uint8_t              sa_mac[6];
-} tpm_ioctl_igmp_t;
-
-
-/* MIB Reset Section
-** =============
-** Function list:
-** 1. tpm_proc_enable_igmp
-*/
-
-/* MIB reset */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_reset_level_enum_t reset_level;
-} tpm_ioctl_mib_reset_t;
-
-/* set active wan port */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_gmacs_enum_t       active_wan;
-} tpm_ioctl_set_active_wan_t;
-
-/* set gmac loopback */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_gmacs_enum_t       gmac;
-    uint8_t                enable;
-} tpm_ioctl_set_gmac_loopback_t;
-
-/* hot swap profile */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_eth_complex_profile_t       profile_id;
-} tpm_ioctl_hot_swap_profile_t;
-
-/* set port hwf admin */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_gmacs_enum_t       port;
-    uint8_t                txp;
-    uint8_t                enable;
-} tpm_ioctl_set_port_hwf_admin_t;
-
-/* ALARM Section */
-typedef struct
-{
-    uint32_t            alarm_cmd;
-    uint32_t            owner_id;
-    uint32_t            alarm_type;
-    uint8_t             port_bitmap[2][MAX_ETH_PORT_ALARM];
-} tpm_ioctl_alarm_t;
-
-
-/* Management structure for Ethernet counters 1 */
-typedef struct
-{
-  tpm_src_port_type_t  port;
-  uint32_t             owner_id;
-  tpm_swport_pm_1_t    tpm_swport_pm_1;
-
-} tpm_ioctl_swport_pm_1_t;
-
-
-/* Management structure for Ethernet counters 3 */
-typedef struct
-{
-  tpm_src_port_type_t  port;
-  uint32_t             owner_id;
-  tpm_swport_pm_3_all_t tpm_swport_pm_3;
-
-} tpm_ioctl_swport_pm_3_t;
-
-
-typedef struct
-{
-    uint32_t             owner_id;
-    tpm_trg_port_type_t  tgt_port;
-    uint8_t              tgt_queue;
-    uint8_t              dummy;
-    uint16_t             gem_port;
-    uint8_t              buf[MAX_FRAME_SIZE];
-    uint32_t             len;
-} tpm_ioctl_tx_igmp_t;
-
-typedef struct
-{
-    uint32_t             owner_id;
-    uint8_t              dummy[2];
-    uint16_t             src_llid;
-    tpm_src_port_type_t  src_port;
-    uint8_t              buf[MAX_FRAME_SIZE];
-    uint32_t             len;
-} tpm_ioctl_rx_igmp_t;
-
-
-typedef struct
-{
-    uint32_t             cpu_lpbk_cmd;
-    uint32_t             owner_id;
-    tpm_pkt_frwd_t       pkt_frwd;
-    uint32_t             mod_idx;
-} tpm_ioctl_cpu_lpbk_t;
-
-typedef struct
-{
-    uint32_t             owner_id;
-} tpm_ioctl_flush_vtu_t;
-typedef struct
-{
-    uint32_t             owner_id;
-    tpm_flush_atu_type_t flush_type;
-    uint16_t             db_num;
-} tpm_ioctl_flush_atu_t;
-
-typedef struct
-{
-    uint32_t              age_count_cmd;
-    uint32_t              owner_id;
-    tpm_api_type_t        api_type;
-    uint32_t              lu_thresh_pkts;
-    uint32_t              rule_idx;
-    uint32_t              lu_rule_mask;
-    uint32_t              hit_count;
-    uint16_t              lu_num;
-    uint16_t              valid_num;
-    uint16_t              unrelated_num;
-    uint8_t               lu_reset;
-    uint8_t               hit_reset;
-    tpm_api_entry_count_t count_array[TPM_MAX_LU_ENTRY_NUM];
-} tpm_ioctl_age_count_t;
-
-typedef struct
-{
-    uint32_t              age_count_cmd;
-    uint32_t              owner_id;
-    tpm_api_type_t        api_type;
-    uint32_t              high_thresh_pkts;
-    uint16_t              valid_counters;
-    uint8_t               counter_reset;
-    uint8_t               dummy;
-    tpm_api_entry_count_t count_array[TPM_MAX_PNC_COUNTER_NUM];
-} tpm_ioctl_pnc_hit_cnt_t;
-
-typedef struct
-{
-    uint32_t                  mc_vid_cmd;
-    uint32_t                  owner_id;
-    uint32_t                  mc_vid;
-    tpm_mc_vid_port_vid_set_t port_vid_set;
-} tpm_ioctl_mc_vid_t;
-
-typedef struct
-{
-    uint32_t                  mtu_setting_cmd;
-    uint32_t                  mtu;
-    uint32_t                  pppoe_mtu;
-    tpm_mtu_ethertype_t       ethertype;
-    uint32_t                  direction;
-    tpm_init_mtu_setting_enable_t  enable;
-} tpm_ioctl_mtu_t;
-
-/* TPM check */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_self_check_level_enum_t check_level;
-} tpm_ioctl_tpm_check_t;
-
-/* ipv6 parse window */
-typedef struct
-{
-    uint32_t               owner_id;
-    tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window;
-} tpm_ioctl_ipv6_parse_window_t;
-
-/* this union aggregates all ioctl commands supported by SFS_TO_IOCTL mode */
-typedef union  tpm_cmd_data
-{
-    tpm_ioctl_add_acl_rule_t    tpm_add_acl_rule;
-    tpm_ioctl_del_acl_rule_t    tpm_del_acl_rule;
-    tpm_ioctl_ctrl_acl_rule_t   tpm_ctrl_acl_rule;
-    tpm_ioctl_mc_rule_t         tpm_mc_rule;
-    tpm_ioctl_igmp_t            tpm_igmp;
-    tpm_ioctl_cpu_lpbk_t        tpm_ioctl_cpu_lpbk;
-    tpm_ioctl_mib_reset_t       tpm_mib_reset_param;
-    tpm_ioctl_age_count_t       tpm_ioctl_age_count;
-    tpm_ioctl_pnc_hit_cnt_t     tpm_ioctl_pnc_hit_cnt;
-    tpm_ioctl_mtu_t		        tpm_ioctl_mtu_set;
-    tpm_ioctl_sw_mac_security_t	tpm_ioctl_sw_mac_set;
-    tpm_ioctl_tm_tm_t		    tpm_ioctl_tm_tm;
-    tpm_ioctl_mng_ch_t		    tpm_mng_channel;
-    tpm_ioctl_get_mod_rule_t	tpm_ioctl_get_mod;
-    tpm_ioctl_tpm_check_t       tpm_check_param;
-    tpm_ioctl_flush_vtu_t       tpm_ioctl_flush_vtu;
-    tpm_ioctl_flush_atu_t       tpm_ioctl_flush_atu;
-    tpm_ioctl_ipv6_parse_window_t   tpm_ipv6_parse_window;
-    tpm_ioctl_set_active_wan_t      tpm_set_active_wan_param;
-    tpm_ioctl_hot_swap_profile_t    tpm_hot_swap_profile_param;
-    tpm_ioctl_set_port_hwf_admin_t  tpm_set_port_hwf_admin_param;
-} tpm_cmd_data_t;
-
-/* this structure is used for passing sysfs request from kernel to userspace
-   to be ioctl (SFS_TO_IOCTL mode)  */
-typedef struct
-{
-    unsigned int    cmd;            /* the ioctl command            */
-    tpm_cmd_data_t  tpm_cmd_data;   /* the ioctl additional data    */
-} tpm_ioctl_mng_t;
-
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-int32_t tpm_module_mng_if_create(void);
-int32_t tpm_module_mng_if_release(void);
-
-/* Macros
-------------------------------------------------------------------------------*/
-
-#endif /* _TPM_MNG_IF_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.c
deleted file mode 100644
index 8aae89f..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.c
+++ /dev/null
@@ -1,1986 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/*******************************************************************************
-* tpm_self_check.c
-*
-* DESCRIPTION:
-*       API definitions for TPM checks the hw and the db are synchronized or not
-
-*
-* DEPENDENCIES:
-*
-* FILE REVISION NUMBER:
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_utils.h"
-
-#define IF_ERROR(ret)	\
-		if (ret != TPM_OK) {\
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, " recvd ret_code(%d)\n", ret);\
-			return(ret);\
-		}
-
-#define TPM_CHECK_DIV_BY_32(x)   ((x) >> 5)
-#define TPM_CHECK_MOD_32(x)      ((x) & 0x1f)
-
-extern char *opCodeOperationStr[30];
-
-static tpm_mod_pattern_data_t _pattern_data;
-static tpm_db_api_entry_t api_ent_mem_area;
-static tpm_pncl_pnc_full_t pnc_data;
-
-/*******************************************************************************
-* pnc_mismatch_info_show - Show detailed difference between two tpm rule entry
-*
-* INPUT:
-*       tpm_pnc_all_t *entry1
-*       tpm_pnc_all_t *entry2
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*
-* COMMENTS:
-* None
-*******************************************************************************/
-static void pnc_mismatch_info_show(tpm_pnc_all_t *entry1, tpm_pnc_all_t *entry2)
-{
-	if (entry1 == NULL || entry2 == NULL)
-		return;
-
-	printk("======================================================================================\n");
-
-	printk("Tcam mismatch element:  ");
-
-	if (memcmp(&entry1->tcam_entry.lu_id, &entry2->tcam_entry.lu_id, sizeof(uint32_t)))
-		printk("Lookup ID, ");
-	if (memcmp(&entry1->tcam_entry.port_ids, &entry2->tcam_entry.port_ids, sizeof(tpm_gmac_bm_t)))
-		printk("Port ID, ");
-	if (memcmp(&entry1->tcam_entry.add_info_data, &entry2->tcam_entry.add_info_data, sizeof(uint32_t)))
-		printk("AddInfo data, ");
-	if (memcmp(&entry1->tcam_entry.add_info_mask, &entry2->tcam_entry.add_info_mask, sizeof(uint32_t)))
-		printk("AddInfo mask, ");
-	if (memcmp(&entry1->tcam_entry.pkt_data.pkt_byte[0], &entry2->tcam_entry.pkt_data.pkt_byte[0],
-			TPM_TCAM_PKT_WIDTH * sizeof(uint8_t)))
-		printk("Header data");
-
-	printk("\n");
-
-	printk("Sram mismatch element:  ");
-
-	if (memcmp(&entry1->sram_entry.add_info_data, &entry2->sram_entry.add_info_data, sizeof(uint32_t)))
-		printk("Additional Info, ");
-	if (memcmp(&entry1->sram_entry.add_info_mask, &entry2->sram_entry.add_info_mask, sizeof(uint32_t)))
-		printk("Add Info Mask, ");
-	if (memcmp(&entry1->sram_entry.flowid_updt_mask, &entry2->sram_entry.flowid_updt_mask, sizeof(uint32_t)))
-		printk("FlowID_updt_mask, ");
-	if (memcmp(&entry1->sram_entry.flowid_val, &entry2->sram_entry.flowid_val, sizeof(uint32_t)))
-		printk("Flow ID, ");
-	if (memcmp(&entry1->sram_entry.lookup_done, &entry2->sram_entry.lookup_done, sizeof(uint32_t)))
-		printk("Lookup done, ");
-	if (memcmp(&entry1->sram_entry.next_lu_id, &entry2->sram_entry.next_lu_id, sizeof(uint32_t)))
-		printk("Next_lu_id, ");
-	if (memcmp(&entry1->sram_entry.next_lu_off_reg, &entry2->sram_entry.next_lu_off_reg, sizeof(uint32_t)))
-		printk("Next_lu_off_reg, ");
-	if (memcmp(&entry1->sram_entry.pnc_queue, &entry2->sram_entry.pnc_queue, sizeof(uint32_t)))
-		printk("Pnc queue, ");
-	if (memcmp(&entry1->sram_entry.res_info_15_0_data, &entry2->sram_entry.res_info_15_0_data, sizeof(uint32_t)))
-		printk("Res_info_15_0, ");
-	if (memcmp(&entry1->sram_entry.res_info_15_0_mask, &entry2->sram_entry.res_info_15_0_mask, sizeof(uint32_t)))
-		printk("Res_info_15_0 mask, ");
-	if (memcmp(&entry1->sram_entry.res_info_23_16_data, &entry2->sram_entry.res_info_23_16_data, sizeof(uint32_t)))
-		printk("Res_info_23_16, ");
-	if (memcmp(&entry1->sram_entry.res_info_23_16_mask, &entry2->sram_entry.res_info_23_16_mask, sizeof(uint32_t)))
-		printk("Res_info_23_16 mask, ");
-	if (memcmp(&entry1->sram_entry.shift_updt_reg, &entry2->sram_entry.shift_updt_reg, sizeof(uint32_t)))
-		printk("Shift_updt_reg, ");
-	if (memcmp(&entry1->sram_entry.shift_updt_val, &entry2->sram_entry.shift_updt_val, sizeof(uint32_t)))
-		printk("Shift_updt_val, ");
-
-	printk("\n======================================================================================\n\n");
-}
-
-/*******************************************************************************
-* tran_tcam_entry_to_pnc_all_t - translate tcam_entry structure to tpm_pnc_all_t
-*
-* INPUT:
-*	in_tcam: source struct tcam_entry
-*	rule_action: rule action of pnc rule
-*	api_section: pnc rule belong to
-*
-* OUTPUT:
-*	out_pnc: target tpm_pnc_all_t structure
-*
-* RETURN:None
-*******************************************************************************/
-static void tran_tcam_entry_to_pnc_all_t(tpm_pnc_all_t *out_pnc,
-					 struct tcam_entry *in_tcam,
-					 tpm_rule_action_t *rule_action,
-					 tpm_api_sections_t api_section)
-{
-	unsigned int lookup_mask;
-	int tcam_off;
-
-	/*check parameters*/
-	if (out_pnc == NULL || in_tcam == NULL || rule_action == NULL) {
-		printk(KERN_ERR "NULL pointer\n");
-		return;
-	}
-	if (api_section > TPM_CNM_MAIN_ACL || api_section < TPM_CPU_LOOPBACK_ACL) {
-		printk(KERN_ERR "api_section out of range\n");
-		return;
-	}
-	/*get tcam entry*/
-	tcam_sw_get_lookup(in_tcam, &(out_pnc->tcam_entry.lu_id), &lookup_mask);
-	out_pnc->tcam_entry.port_ids = (~(in_tcam->mask.u.word[PORT_WORD] >> PORT_OFFS)) & PORT_MASK;
-	tcam_sw_get_ainfo(in_tcam,
-			&(out_pnc->tcam_entry.add_info_data),
-			&(out_pnc->tcam_entry.add_info_mask));
-	/* Get tcam packet data */
-	for (tcam_off = 0; tcam_off < TPM_TCAM_PKT_WIDTH; tcam_off++) {
-		out_pnc->tcam_entry.pkt_data.pkt_byte[tcam_off] = in_tcam->data.u.byte[tcam_off];
-		out_pnc->tcam_entry.pkt_mask.pkt_byte[tcam_off] = in_tcam->mask.u.byte[tcam_off];
-	}
-	/*Get sram entry*/
-	out_pnc->sram_entry.flowid_val = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(FLOW_VALUE_OFFS)] >>
-							TPM_CHECK_MOD_32(FLOW_VALUE_OFFS)) & FLOW_VALUE_MASK;
-	out_pnc->sram_entry.flowid_updt_mask = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(FLOW_CTRL_OFFS)] >>
-							TPM_CHECK_MOD_32(FLOW_CTRL_OFFS)) & FLOW_CTRL_MASK;
-	out_pnc->sram_entry.res_info_15_0_data = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(RI_VALUE_OFFS)] >>
-							TPM_CHECK_MOD_32(RI_VALUE_OFFS)) & RI_VALUE_15_0_MASK;
-	out_pnc->sram_entry.res_info_23_16_data = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(RI_VALUE_OFFS)] >>
-							(TPM_CHECK_MOD_32(RI_VALUE_OFFS) + 16)) & RI_VALUE_23_16_MASK;
-	out_pnc->sram_entry.res_info_15_0_mask = in_tcam->sram.word[TPM_CHECK_DIV_BY_32(RI_MASK_OFFS)] &
-							RI_VALUE_15_0_MASK;
-	out_pnc->sram_entry.res_info_23_16_mask = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(RI_MASK_OFFS)] >> 16) &
-							RI_VALUE_23_16_MASK;
-	out_pnc->sram_entry.res_info_15_0_data = out_pnc->sram_entry.res_info_15_0_data &
-							out_pnc->sram_entry.res_info_15_0_mask;
-	out_pnc->sram_entry.res_info_23_16_data = out_pnc->sram_entry.res_info_23_16_data &
-							out_pnc->sram_entry.res_info_23_16_mask;
-	out_pnc->sram_entry.shift_updt_val = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(SHIFT_VAL_OFFS)] >>
-							TPM_CHECK_MOD_32(SHIFT_VAL_OFFS)) & SHIFT_VAL_MASK;
-	out_pnc->sram_entry.shift_updt_reg = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(SHIFT_IDX_OFFS)] >>
-							TPM_CHECK_MOD_32(SHIFT_IDX_OFFS)) & SHIFT_IDX_MASK;
-
-	/*update target queue, supposed that API DB is always right, here to avoid error*/
-	if (SET_TARGET_QUEUE(rule_action->pkt_act) ||
-				(api_section == TPM_IPV4_MC) ||
-				(api_section == TPM_IPV6_MC_ACL))
-		out_pnc->sram_entry.pnc_queue = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(RXQ_QUEUE_OFFS)] >>
-							TPM_CHECK_MOD_32(RXQ_QUEUE_OFFS)) & RXQ_MASK;
-	else
-		out_pnc->sram_entry.pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-
-	out_pnc->sram_entry.next_lu_off_reg = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(NEXT_LU_SHIFT_OFFS)] >>
-							TPM_CHECK_MOD_32(NEXT_LU_SHIFT_OFFS)) & NEXT_LU_SHIFT_MASK;
-	out_pnc->sram_entry.lookup_done = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(LU_DONE_OFFS)] >>
-							TPM_CHECK_MOD_32(LU_DONE_OFFS)) & LU_DONE_MASK;
-	out_pnc->sram_entry.add_info_data = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(AI_VALUE_OFFS)] >>
-							TPM_CHECK_MOD_32(AI_VALUE_OFFS)) & AI_MASK;
-	out_pnc->sram_entry.add_info_mask = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(AI_MASK_OFFS)] >>
-							TPM_CHECK_MOD_32(AI_MASK_OFFS)) & AI_MASK;
-	out_pnc->sram_entry.next_lu_id = (in_tcam->sram.word[TPM_CHECK_DIV_BY_32(LU_ID_OFFS)] >>
-							TPM_CHECK_MOD_32(LU_ID_OFFS)) & LU_MASK;
-
-	return;
-}
-
-/*******************************************************************************
-* tpm_check_update_sram - update sram according to some special condition
-*                       - packet drop, flowid_update_mask
-*                       - just to avoid meaningless pnc check error
-* INPUT:
-*	rule_action
-* OUTPUT:
-*	sram_entry
-* RETURN:None
-*******************************************************************************/
-static void tpm_check_update_sram(tpm_sram_all_t *sram_entry, tpm_rule_action_t *rule_action)
-{
-	uint32_t mask = 0;
-	uint32_t loop;
-
-	if (NULL == sram_entry || NULL == rule_action)
-		return;
-
-	/*update flow id*/
-	for (loop = 0; loop < 8; loop++) {
-		if ((1 << loop) & sram_entry->flowid_updt_mask)
-			mask |= (0xF << (4 * loop));
-	}
-	sram_entry->flowid_val = sram_entry->flowid_val & mask;
-
-	/*update pnc queue, if rule action is drop, set pnc queue to 0xFFFF*/
-	if (PKT_DROP(rule_action->pkt_act))
-		sram_entry->pnc_queue = TPM_PNCL_NO_QUEUE_UPDATE;
-}
-
-int32_t tpm_check_main_chain_type(tpm_gmacs_enum_t gmac_port, tpm_pkt_mod_bm_t mod_bm, tpm_pkt_mod_int_bm_t int_mod_bm,
-				  uint16_t jump_idx, tpm_main_chain_check_type_t *result)
-{
-	tpm_chain_type_t main_chain_type, db_main_chain_type, hw_main_chain_type;
-	uint16_t main_chain_entry, main_idx;
-	int32_t ret;
-	uint8_t error_db, error_hw;
-
-	error_db = 0;
-	error_hw = 0;
-	/* Get main chain type from mod_bm */
-	main_chain_type = tpm_mod2_parse_chain_type(mod_bm, int_mod_bm);
-
-	/*Get main chain type from db*/
-	ret = tpm_mod2_main_chain_index_get(gmac_port, jump_idx, &main_chain_entry, TPM_CHECK_MAIN_CHAIN_IDX_DB);
-	if (ret)
-		return TPM_FAIL;
-	ret = tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, main_chain_entry, &db_main_chain_type, &main_idx);
-	if (ret)
-		return TPM_FAIL;
-	if (main_chain_type != db_main_chain_type)
-		error_db++;
-
-	/*Get main chain type from HW*/
-	ret = tpm_mod2_main_chain_index_get(gmac_port, jump_idx, &main_chain_entry, TPM_CHECK_MAIN_CHAIN_IDX_HW);
-	if (ret)
-		return TPM_FAIL;
-	ret = tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, main_chain_entry, &hw_main_chain_type, &main_idx);
-	if (ret)
-		return TPM_FAIL;
-	if (main_chain_type != hw_main_chain_type)
-		error_hw++;
-
-	if (error_db && error_hw)
-		*result = TPMCHECK_BOTH_CHAIN_TYPE_MISMATCH;
-	else if (error_db)
-		*result = TPMCHECK_DB_CHAIN_TYPE_MISMATCH;
-	else if (error_hw)
-		*result = TPMCHECK_HW_CHAIN_TYPE_MISMATCH;
-	else
-		*result = TPMCHECK_CHAIN_TYPE_OK;
-
-	return TPM_OK;
-}
-
-static void tpm_check_pmt_mismatch_show_header(void)
-{
-    printk("======================================================================================\n");
-    printk(" Info_Src  Index    OpCode     Operation   Data  Last  IPv4    L4   \n");
-    printk("                                                      update update \n");
-    printk("======================================================================================\n");
-}
-
-/*******************************************************************************
-* tpm_pmt_check - check PMT entries
-*
-* INPUT:
-*       tpm_gmacs_enum_t gmac_port
-*	tpm_mod_pattern_data_t *pattern_data
-*	tpm_self_check_enable_t check_with, check with DB or HW
-*
-* OUTPUT:
-*	tpm_self_check_result_t *result, record check result
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-static int32_t tpm_pmt_check(tpm_gmacs_enum_t gmac_port, tpm_mod_pattern_data_t *pattern_data,
-			     tpm_error_code_t *result, tpm_self_check_enable_t check_with)
-{
-	uint32_t set_id, line_id;
-	tpm_pattern_entry_t *entry_p = NULL;
-	uint16_t pmt_entry;
-	MV_NETA_PMT pEntry;
-	tpm_mod2_entry_t pattern_jump, pattern_chain;
-	/*error flag*/
-	int8_t modification_data = 0;
-	int8_t mod_command = 0;
-	int8_t up_ipv4_checksum = 0;
-	int8_t up_tcp_udp_checksum = 0;
-	int8_t last = 0;
-	int8_t hw_error_count, sw_error_count;
-
-	if (gmac_port >= TPM_MAX_NUM_GMACS) {
-		printk("Invalid parameter: port %d\n", gmac_port);
-		return TPM_FAIL;
-	}
-
-	if (NULL == pattern_data) {
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-		return TPM_FAIL;
-	}
-
-	hw_error_count = 0;
-	sw_error_count = 0;
-
-	for (set_id = 0; set_id < TPM_MOD2_MAX_PATTERN_SETS; set_id++) {
-		if (pattern_data->pattern_set[set_id].is_valid) {
-			entry_p = &(pattern_data->pattern_set[set_id]);
-			if (set_id == 0)
-				pmt_entry = entry_p->index;
-			else
-				pmt_entry = tpm_db_mod2_convert_chain_to_pmt_entry(entry_p->chain_type, entry_p->index);
-
-			for (line_id = 0; line_id < TPM_MOD2_MAX_PATTERN_ENTRIES && line_id < entry_p->line_num;
-				line_id++) {
-				if (check_with == TPM_CHECK_WITH_HW) {
-					/*read HW PMT table*/
-					if (tpm_mod2_neta_pmt_get(gmac_port, pmt_entry + line_id, &pEntry)) {
-						TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get hw jump data\n");
-						return TPM_FAIL;
-					}
-
-					/*compare HW PMT*/
-					if ((pEntry.word & MV_NETA_PMT_DATA_MASK) != entry_p->line[line_id].data)
-						modification_data = 1;
-					if (((pEntry.word >> MV_NETA_PMT_CMD_OFFS) & (MV_NETA_PMT_CMD_ALL_MASK >>
-							MV_NETA_PMT_CMD_OFFS)) != entry_p->line[line_id].opcode)
-						mod_command = 1;
-					if (((pEntry.word >> MV_NETA_PMT_IP4_CSUM_BIT) & (MV_NETA_PMT_IP4_CSUM_MASK >>
-							MV_NETA_PMT_IP4_CSUM_BIT)) != entry_p->line[line_id].updt_ipv4)
-						up_ipv4_checksum = 1;
-					if (((pEntry.word >> MV_NETA_PMT_L4_CSUM_BIT) & (MV_NETA_PMT_L4_CSUM_MASK >>
-							MV_NETA_PMT_L4_CSUM_BIT)) != entry_p->line[line_id].updt_tcp)
-						up_tcp_udp_checksum = 1;
-					if (((pEntry.word >> MV_NETA_PMT_LAST_BIT) & (MV_NETA_PMT_LAST_MASK >>
-							MV_NETA_PMT_LAST_BIT)) != entry_p->line[line_id].last)
-						last = 1;
-
-					/*show HW error info*/
-					if (modification_data || mod_command || up_ipv4_checksum ||
-						up_tcp_udp_checksum || last) {
-						hw_error_count++;
-						printk("\nPMT Mismatch: [set %d] area_type %d, chain_type %d, "
-							"chain_index %d ,line_num %d\r\n",
-							set_id, entry_p->area_type, entry_p->chain_type,
-							entry_p->index, entry_p->line_num);
-						tpm_check_pmt_mismatch_show_header();
-						printk(" %5s      %03d      0x%2x %15s  0x%4.4x  %1d     "
-							"%1d      %1d\n",
-							"Build",
-							line_id,
-							entry_p->line[line_id].opcode,
-							opCodeOperationStr[entry_p->line[line_id].opcode],
-							entry_p->line[line_id].data, entry_p->line[line_id].last,
-							entry_p->line[line_id].updt_ipv4,
-							entry_p->line[line_id].updt_tcp);
-						printk(" %5s      %03d      0x%2x %15s  0x%4.4x  %1d     "
-							"%1d      %1d\n",
-							"HWPMT",
-							line_id,
-							((pEntry.word >> MV_NETA_PMT_CMD_OFFS) &
-							(MV_NETA_PMT_CMD_ALL_MASK >> MV_NETA_PMT_CMD_OFFS)),
-							opCodeOperationStr[((pEntry.word >> MV_NETA_PMT_CMD_OFFS) &
-							(MV_NETA_PMT_CMD_ALL_MASK >> MV_NETA_PMT_CMD_OFFS))],
-							(pEntry.word & MV_NETA_PMT_DATA_MASK),
-							((pEntry.word >> MV_NETA_PMT_LAST_BIT) &
-							(MV_NETA_PMT_LAST_MASK >> MV_NETA_PMT_LAST_BIT)),
-							((pEntry.word >> MV_NETA_PMT_IP4_CSUM_BIT) &
-							(MV_NETA_PMT_IP4_CSUM_MASK >> MV_NETA_PMT_IP4_CSUM_BIT)),
-							((pEntry.word >> MV_NETA_PMT_L4_CSUM_BIT) &
-							(MV_NETA_PMT_L4_CSUM_MASK >> MV_NETA_PMT_L4_CSUM_BIT)));
-					}
-
-					/*clear error flags*/
-					modification_data = 0;
-					mod_command = 0;
-					up_ipv4_checksum = 0;
-					up_tcp_udp_checksum = 0;
-					last = 0;
-				} else if (check_with == TPM_CHECK_WITH_DB) {
-					/*read PMT db info*/
-					if (set_id == 0) {
-						if (tpm_mod2_db_jump_pattern_data_get(gmac_port, entry_p->index,
-											&pattern_jump)) {
-							TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Get Jump pattern failed\n");
-							return TPM_FAIL;
-						}
-					} else {
-						if (tpm_mod2_db_chain_pattern_data_get(gmac_port, entry_p->chain_type,
-									entry_p->index, line_id, &pattern_chain)) {
-							TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Get Chain pattern failed\n");
-							return TPM_FAIL;
-						}
-					}
-
-					/*compare to db*/
-					if (set_id == 0) {
-						if (pattern_jump.data != entry_p->line[line_id].data)
-							modification_data = 1;
-						if (pattern_jump.opcode != entry_p->line[line_id].opcode)
-							mod_command = 1;
-						if (pattern_jump.updt_ipv4 != entry_p->line[line_id].updt_ipv4)
-							up_ipv4_checksum = 1;
-						if (pattern_jump.updt_tcp != entry_p->line[line_id].updt_tcp)
-							up_tcp_udp_checksum = 1;
-						if (pattern_jump.last != entry_p->line[line_id].last)
-							last = 1;
-					} else {
-						if (pattern_chain.data != entry_p->line[line_id].data)
-							modification_data = 1;
-						if (pattern_chain.opcode != entry_p->line[line_id].opcode)
-							mod_command = 1;
-						if (pattern_chain.updt_ipv4 != entry_p->line[line_id].updt_ipv4)
-							up_ipv4_checksum = 1;
-						if (pattern_chain.updt_tcp != entry_p->line[line_id].updt_tcp)
-							up_tcp_udp_checksum = 1;
-						if (pattern_chain.last != entry_p->line[line_id].last)
-							last = 1;
-					}
-
-					/*show SW error info*/
-					if (modification_data || mod_command || up_ipv4_checksum ||
-									up_tcp_udp_checksum || last) {
-						sw_error_count++;
-						printk("\nPMT Mismatch: [set %d] area_type %d, chain_type %d, "
-							"chain_index %d ,line_num %d\r\n",
-							set_id, entry_p->area_type, entry_p->chain_type,
-							entry_p->index, entry_p->line_num);
-						tpm_check_pmt_mismatch_show_header();
-						printk(" %5s      %03d      0x%2x %15s  0x%4.4x  "
-							"%1d     %1d      %1d\n",
-							"Build",
-							line_id,
-							entry_p->line[line_id].opcode,
-							opCodeOperationStr[entry_p->line[line_id].opcode],
-							entry_p->line[line_id].data, entry_p->line[line_id].last,
-							entry_p->line[line_id].updt_ipv4,
-							entry_p->line[line_id].updt_tcp);
-						if (set_id == 0) {
-							printk(" %5s      %03d      0x%2x %15s  0x%4.4x  "
-								"%1d     %1d      %1d\n",
-								"DB",
-								line_id,
-								pattern_jump.opcode,
-								opCodeOperationStr[pattern_jump.opcode],
-								pattern_jump.data, pattern_jump.last,
-								pattern_jump.updt_ipv4, pattern_jump.updt_tcp);
-						} else {
-
-							printk(" %5s      %03d      0x%2x %15s  0x%4.4x  "
-								"%1d     %1d      %1d\n",
-								"DB",
-								line_id,
-								pattern_chain.opcode,
-								opCodeOperationStr[pattern_chain.opcode],
-								pattern_chain.data, pattern_chain.last,
-								pattern_chain.updt_ipv4, pattern_chain.updt_tcp);
-						}
-					}
-
-					/*clear error flags*/
-					modification_data = 0;
-					mod_command = 0;
-					up_ipv4_checksum = 0;
-					up_tcp_udp_checksum = 0;
-					last = 0;
-				}
-			}
-
-		}
-	}
-
-	/*record check result*/
-	if (hw_error_count)
-		*result = ERR_TPMCHECK_PMT_HW_MISMATCH;
-	else if (sw_error_count)
-		*result = ERR_TPMCHECK_PMT_DB_MISMATCH;
-	else
-		*result = TPM_RC_OK;
-
-	return TPM_OK;
-}
-
-int32_t tpm_check_param_check(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-			      tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-			      tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-			      tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	if (pon_type < TPM_EPON || pon_type > TPM_P2P) {
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "PON type is invalid\n");
-		return TPM_FAIL;
-	}
-
-	if (tpm_rule == NULL ||
-		mod_con == NULL ||
-		api_ent_mem_area == NULL ||
-		pnc_data == NULL ||
-		mod_entry == NULL ||
-		pkt_mod == NULL ||
-		pkt_mod_bm == NULL ||
-		int_mod_bm == NULL ||
-		trg_port == NULL ||
-		rule_action == NULL) {
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Pointer invalid (NULL)\n");
-		return TPM_FAIL;
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_l2 - translate L2 APi data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	trg_port
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_l2(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-			     tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-			     tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-			     tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_l2_acl_key_t l2_key;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->l2_prim_key.src_port;
-	memcpy(&l2_key, &(tpm_rule->l2_prim_key.l2_key), sizeof(tpm_l2_acl_key_t));
-	parse_rule_bm = tpm_rule->l2_prim_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->l2_prim_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->l2_prim_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->l2_prim_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->l2_prim_key.pkt_frwd.trg_port;
-	memcpy(pkt_mod, &(tpm_rule->l2_prim_key.pkt_mod), sizeof(tpm_pkt_mod_t));
-	*pkt_mod_bm = tpm_rule->l2_prim_key.pkt_mod_bm;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_idx;
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-	/*******************generate PnC Rule Start********************/
-	/*generate tcam */
-	tpm_ret = tpm_proc_l2_tcam_build(src_port,
-					 dir,
-					 rule_num,
-					 &l2_key,
-					 parse_rule_bm,
-					 parse_flags_bm,
-					 &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-	/*generate sram*/
-	tpm_ret = tpm_proc_l2_sram_build(src_port,
-					 dir,
-					 rule_num,
-					 pon_type,
-					 &pkt_frwd,
-					 rule_action,
-					 mod_con->mod_cmd_ind,
-					 &(pnc_data->pncl_sram),
-					 &l2_key,
-					 &(tpm_rule->l2_prim_key.pkt_mod),
-					 tpm_rule->l2_prim_key.pkt_mod_bm);
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-
-}
-
-/*******************************************************************************
-* api_data2pnc_data_l3 - translate L3 APi data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_l3(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-			     tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-			     tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-			     tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_l3_type_key_t l3_key;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	uint8_t l3_is_pppoe = TPM_FALSE;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->l3_type_key.src_port;
-	memcpy(&l3_key, &(tpm_rule->l3_type_key.l3_key), sizeof(tpm_l3_type_key_t));
-	parse_rule_bm = tpm_rule->l3_type_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->l3_type_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->l3_type_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->l3_type_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	rule_num = api_ent_mem_area->rule_idx;
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-	/*******************generate PnC Rule Start********************/
-	/*generate tcam */
-	tpm_ret = tpm_proc_l3_tcam_build(src_port,
-					 dir,
-					 rule_num,
-					 &l3_key,
-					 parse_rule_bm,
-					 parse_flags_bm,
-					 rule_action,
-					 &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-	/*generate sram*/
-	if (pnc_data->pncl_tcam.pkt_key.l3_key.ether_type_key == ETH_P_PPP_SES)
-		l3_is_pppoe = TPM_TRUE;
-	tpm_ret = tpm_proc_l3_sram_build(src_port,
-					 dir,
-					 rule_num,
-					 l3_is_pppoe,
-					 pon_type,
-					 &pkt_frwd,
-					 rule_action,
-					 parse_flags_bm,
-					 &(pnc_data->pncl_sram));
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv4 - translate IPV4 ACL API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv4(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-			       tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-			       tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-			       tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_ipv4_acl_key_t ipv4_acl_key;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->ipv4_key.src_port;
-	memcpy(&ipv4_acl_key, &(tpm_rule->ipv4_key.ipv4_key), sizeof(tpm_ipv4_acl_key_t));
-	parse_rule_bm = tpm_rule->ipv4_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->ipv4_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->ipv4_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->ipv4_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->ipv4_key.pkt_frwd.trg_port;
-	memcpy(pkt_mod, &(tpm_rule->ipv4_key.pkt_mod), sizeof(tpm_pkt_mod_t));
-	*pkt_mod_bm = tpm_rule->ipv4_key.pkt_mod_bm;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_idx;
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-	/*******************generate PnC Rule Start********************/
-	/*generate tcam */
-	tpm_ret = tpm_proc_ipv4_tcam_build(src_port,
-					   dir,
-					   rule_num,
-					   &ipv4_acl_key,
-					   parse_rule_bm,
-					   parse_flags_bm,
-					   rule_action,
-					   &(tpm_rule->ipv4_key.pkt_mod),
-					   tpm_rule->ipv4_key.pkt_mod_bm,
-					   &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-
-	/*generate sram*/
-	tpm_ret = tpm_proc_ipv4_sram_build(src_port,
-					   dir,
-					   rule_num,
-					   pon_type,
-					   &ipv4_acl_key,
-					   pnc_data->pncl_tcam.ipv4_parse_bm,
-					   parse_flags_bm,
-					   &pkt_frwd,
-					   rule_action,
-					   mod_con->mod_cmd_ind,
-					   tpm_rule->ipv4_key.pkt_mod_bm,
-					   &(tpm_rule->ipv4_key.pkt_mod),
-					   &(pnc_data->pncl_sram));
-	IF_ERROR(tpm_ret);
-	/*update L4 checksum*/
-	if (parse_rule_bm & TPM_IPv4_PARSE_PROTO) {
-		if (ipv4_acl_key.ipv4_proto == IPPROTO_TCP)
-			*int_mod_bm = TPM_INT_L4_TCP;
-		else if (ipv4_acl_key.ipv4_proto == IPPROTO_UDP) {
-			*int_mod_bm = TPM_INT_L4_UDP;
-			/* Set internal_bm according to API Action */
-			if (rule_action->pkt_act & TPM_ACTION_UDP_CHKSUM_CALC)
-				*int_mod_bm = TPM_INT_L4_UDP | TPM_INT_UDP_CHECKSUM;
-		}
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv4_mc - translate IPV4 MC API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv4_mc(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				  tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				  tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				  tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_db_mc_stream_entry_t mc_stream_entry;
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_stream_pppoe, ignore_ipv4_src, ipv4_src_add[4], ipv4_dst_add[4];
-	uint16_t mc_vid;
-	uint16_t dest_queue;
-	uint32_t stream_num, igmp_mode, dest_port_bm;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	stream_num = api_ent_mem_area->rule_num;
-	tpm_ret = tpm_db_get_mc_stream_entry(stream_num, &mc_stream_entry);
-	IF_ERROR(tpm_ret);
-	mc_stream_pppoe = mc_stream_entry.mc_stream_pppoe;
-	igmp_mode = mc_stream_entry.igmp_mode;
-	dest_port_bm = mc_stream_entry.dest_port_bm;
-	memcpy(ipv4_src_add, tpm_rule->ipv4_mc_key.ipv4_src_add, sizeof(ipv4_src_add));
-	memcpy(ipv4_dst_add, tpm_rule->ipv4_mc_key.ipv4_dest_add, sizeof(ipv4_dst_add));
-	rule_action->pkt_act = 0;
-	mc_vid = tpm_rule->ipv4_mc_key.vid;
-	ignore_ipv4_src = tpm_rule->ipv4_mc_key.ignore_ipv4_src;
-	*mod_entry = mod_con->mod_cmd_ind;
-	dest_queue = tpm_rule->ipv4_mc_key.dest_queue;
-
-	/*******************generate PnC Rule Start********************/
-	/*generate tcam entry*/
-	tpm_ret = tpm_proc_ipv4_mc_tcam_build(filter_mode,
-					      stream_num,
-					      mc_vid,
-					      mc_stream_pppoe,
-					      ipv4_src_add,
-					      ipv4_dst_add,
-					      ignore_ipv4_src,
-					      &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-	/* Build SRAM Entry */
-	tpm_ret = tpm_proc_ipvx_mc_sram_build(filter_mode,
-					      igmp_mode,
-					      dest_queue,
-					      dest_port_bm,
-					      mod_con->mod_cmd_ind,
-					      &(pnc_data->pncl_sram),
-					      TPM_IP_VER_4 );
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv6_gen - translate IPV6 GEN API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv6_gen(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				   tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				   tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				   tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_ipv6_gen_key_t ipv6_gen_acl_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable = TPM_IPV6_5T_DISABLED;
-	long long int_pkt_act = 0;
-	uint32_t subflow_bm, subflow_id, protocol = 0;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->ipv6_gen_key.src_port;
-	memcpy(&ipv6_gen_acl_key, &(tpm_rule->ipv6_gen_key), sizeof(tpm_rule_ipv6_gen_key_t));
-	parse_rule_bm = tpm_rule->ipv6_gen_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->ipv6_gen_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->ipv6_gen_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->ipv6_gen_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->ipv6_gen_key.pkt_frwd.trg_port;
-	memcpy(pkt_mod, &(tpm_rule->ipv6_gen_key.pkt_mod), sizeof(tpm_pkt_mod_t));
-	*pkt_mod_bm = tpm_rule->ipv6_gen_key.pkt_mod_bm;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_idx;
-	/*check ipv6_5t is enable or not*/
-	tpm_ret = tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	IF_ERROR(tpm_ret);
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-
-	/*******************generate PnC Rule Start********************/
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED) {
-		/*generate tcam */
-		tpm_ret = tpm_proc_ipv6_gen_tcam_build(src_port,
-						       dir,
-						       rule_num,
-						       &ipv6_gen_acl_key.ipv6_gen_key,
-						       parse_rule_bm,
-						       parse_flags_bm,
-						       pkt_mod,
-						       *pkt_mod_bm,
-						       &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-		/*generate sram*/
-		tpm_ret = tpm_proc_ipv6_gen_sram_build(src_port,
-						       dir,
-						       rule_num,
-						       pon_type,
-						       &pkt_frwd,
-						       rule_action,
-						       mod_con->mod_cmd_ind,
-						       &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	} else {
-		/*********** Get Subflow Info **********/
-		subflow_bm = parse_rule_bm & TPM_DB_IPV6_GEN_SUBFLOW_PARSE_BM_MASK;
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			subflow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		subflow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-		if (subflow_bm != 0 && rule_action->next_phase != STAGE_DONE) {
-			int_pkt_act |= TPM_ACTION_SET_IPV6_SUBFLOW;
-			subflow_id = tpm_db_find_matched_ipv6_gen_subflow(dir,
-									  subflow_bm,
-									  protocol,
-									  &ipv6_gen_acl_key.l4_key,
-									  &ipv6_gen_acl_key.ipv6_gen_key);
-			if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID) {
-				printk("Subflow_id get Failed\n");
-				return TPM_FAIL;
-			}
-		} else {
-			int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-		}
-		/*generate tcam */
-		tpm_ret = tpm_proc_ipv6_gen_5t_tcam_build(dir,
-							  rule_num,
-							  &ipv6_gen_acl_key.l4_key,
-							  &ipv6_gen_acl_key.ipv6_gen_key,
-							  parse_rule_bm,
-							  parse_flags_bm,
-							  rule_action,
-							  pkt_mod,
-							  *pkt_mod_bm,
-							  &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-		/*generate sram*/
-		tpm_ret = tpm_proc_ipv6_gen_5t_sram_build(dir,
-							  rule_num,
-							  pon_type,
-							  subflow_id,
-							  &pkt_frwd,
-							  rule_action,
-							  int_pkt_act,
-							  pkt_mod,
-							  mod_con->mod_cmd_ind,
-							  &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	}
-
-	return TPM_OK;
-}
-
-
-/*******************************************************************************
-* api_data2pnc_data_ipv6_dip - translate IPV6 DIP API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv6_dip(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				   tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				   tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				   tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_ipv6_gen_key_t ipv6_gen_acl_key;
-	tpm_rule_ipv6_dip_key_t ipv6_dip_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable = TPM_IPV6_5T_DISABLED;
-	long long int_pkt_act = 0;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->ipv6_dip_key.src_port;
-	memcpy(&ipv6_dip_key, &(tpm_rule->ipv6_dip_key), sizeof(tpm_rule_ipv6_dip_key_t));
-	parse_rule_bm = tpm_rule->ipv6_dip_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->ipv6_dip_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->ipv6_dip_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->ipv6_dip_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->ipv6_dip_key.pkt_frwd.trg_port;
-	memcpy(pkt_mod, &(tpm_rule->ipv6_dip_key.pkt_mod), sizeof(tpm_pkt_mod_t));
-	*pkt_mod_bm = tpm_rule->ipv6_dip_key.pkt_mod_bm;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_idx;
-	/*check ipv6_5t is enable or not*/
-	tpm_ret = tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	IF_ERROR(tpm_ret);
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-	/*******************generate PnC Rule Start********************/
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED) {
-		/*generate tcam */
-		tpm_ret = tpm_proc_ipv6_dip_tcam_build(src_port,
-						       dir,
-						       rule_num,
-						       &ipv6_dip_key.ipv6_dipkey,
-						       parse_rule_bm,
-						       parse_flags_bm,
-						       pkt_mod,
-						       *pkt_mod_bm,
-						       &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-		/*generate sram*/
-		tpm_ret = tpm_proc_ipv6_dip_sram_build(src_port,
-						       dir,
-						       rule_num,
-						       pon_type,
-						       &pkt_frwd,
-						       rule_action,
-						       mod_con->mod_cmd_ind,
-						       &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	} else {
-		int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-		/*generate tcam */
-		memcpy(&ipv6_gen_acl_key, &(tpm_rule->ipv6_gen_key), sizeof(tpm_rule_ipv6_gen_key_t));
-		tpm_ret = tpm_proc_ipv6_dip_5t_tcam_build(dir,
-							  rule_num,
-							  &ipv6_dip_key.l4_key,
-							  &ipv6_gen_acl_key.ipv6_gen_key,
-							  &ipv6_dip_key.ipv6_dipkey,
-							  parse_rule_bm,
-							  parse_flags_bm,
-							  rule_action,
-							  pkt_mod,
-							  *pkt_mod_bm,
-							  &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-		/*generate sram*/
-		tpm_ret = tpm_proc_ipv6_dip_5t_sram_build(dir,
-							  rule_num,
-							  pon_type,
-							  &pkt_frwd,
-							  rule_action,
-							  int_pkt_act,
-							  pkt_mod,
-							  mod_con->mod_cmd_ind,
-							  &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv6_mc - translate IPV6 MC API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv6_mc(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				  tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				  tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				  tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_mc_filter_mode_t filter_mode;
-	uint8_t mc_stream_pppoe;
-	uint16_t mc_vid;
-	uint32_t stream_num, igmp_mode, dest_port_bm;
-	tpm_db_ipv6_mc_stream_entry_t ipv6_mc_stream_entry;
-	uint8_t ipv6_dst_add[16];
-	int32_t tpm_ret = 0;
-	uint8_t sip_index = 0;
-	uint16_t dest_queue;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	filter_mode = tpm_db_get_mc_filter_mode();
-	stream_num = api_ent_mem_area->rule_num;
-	tpm_ret = tpm_db_get_ipv6_mc_stream_entry(stream_num, &ipv6_mc_stream_entry);
-	IF_ERROR(tpm_ret);
-	mc_stream_pppoe = ipv6_mc_stream_entry.mc_stream_pppoe;
-	igmp_mode = ipv6_mc_stream_entry.igmp_mode;
-	dest_port_bm = ipv6_mc_stream_entry.dest_port_bm;
-	memcpy(ipv6_dst_add, tpm_rule->ipv6_mc_key.ipv6_dest_add, sizeof(ipv6_dst_add));
-	rule_action->pkt_act = 0;
-	mc_vid = tpm_rule->ipv6_mc_key.vid;
-	*mod_entry = mod_con->mod_cmd_ind;
-	dest_queue = tpm_rule->ipv6_mc_key.dest_queue;
-
-	/* get sip_index */
-	if (0 == ipv6_mc_stream_entry.ignore_src_addr) {
-		/* get index of this IPv6 MC SIP */
-		sip_index = tpm_db_ipv6_mc_sip_index_get(ipv6_mc_stream_entry.src_addr);
-		if (0 == sip_index) {
-			/* SIP is not in DB, error */
-			TPM_OS_ERROR(TPM_TPM_LOG_MOD, "get index of IPv6 MC SIP failed!\n");
-			return(ERR_IPV6_MC_SRC_IP_INVALID);
-		}
-	}
-
-	/*generate tcam entry*/
-	tpm_ret = tpm_proc_ipv6_mc_tcam_build(filter_mode,
-					      stream_num,
-					      mc_vid,
-					      mc_stream_pppoe,
-					      ipv6_dst_add,
-					      sip_index,
-					      ipv6_mc_stream_entry.ignore_src_addr,
-					      &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-	/*generate sram*/
-	tpm_ret = tpm_proc_ipvx_mc_sram_build(filter_mode,
-					      igmp_mode,
-					      dest_queue,
-					      dest_port_bm,
-					      mod_con->mod_cmd_ind,
-					      &(pnc_data->pncl_sram),
-					      TPM_IP_VER_6);
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv6_nh - translate IPV6 NH API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv6_nh(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				  tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				  tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				  tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_ipv6_nh_key_t ipv6_nh_key;
-	tpm_nh_iter_t nh_iter;
-	uint32_t rule_num;
-	uint32_t nh;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	memcpy(&ipv6_nh_key, &(tpm_rule->ipv6_nh_key), sizeof(tpm_rule_ipv6_nh_key_t));
-	parse_rule_bm = ipv6_nh_key.parse_rule_bm;
-	parse_flags_bm = ipv6_nh_key.parse_flags_bm;
-	nh = ipv6_nh_key.nh;
-	nh_iter = ipv6_nh_key.nh_iter;
-	memcpy(&pkt_frwd, &(ipv6_nh_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(ipv6_nh_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	rule_num = api_ent_mem_area->rule_idx;
-
-	/*******************generate PnC Rule Start********************/
-	/*generate tcam */
-	tpm_ret = tpm_proc_ipv6_nh_tcam_build(rule_num,
-					      nh_iter,
-					      nh,
-					      parse_flags_bm,
-					      rule_action,
-					      &(pnc_data->pncl_tcam));
-	IF_ERROR(tpm_ret);
-	/*generate sram*/
-	tpm_ret = tpm_proc_ipv6_nh_sram_build(rule_num,
-					      nh_iter,
-					      nh,
-					      pon_type,
-					      &pkt_frwd,
-					      rule_action,
-					      &(pnc_data->pncl_sram));
-	IF_ERROR(tpm_ret);
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv6_l4 - translate IPV6 L4 API data to PNC data
-*
-* INPUT:
-*       pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv6_l4(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				  tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				  tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				  tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t parse_rule_bm;
-	tpm_parse_flags_t parse_flags_bm;
-	tpm_dir_t dir = 0;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_rule_ipv6_l4_key_t ipv6_l4_key;
-	tpm_init_ipv6_5t_enable_t ipv6_5t_enable = TPM_IPV6_5T_DISABLED;
-	long long int_pkt_act = 0;
-	uint32_t subflow_bm, subflow_id, protocol = 0;
-	uint32_t rule_num;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	src_port = tpm_rule->ipv6_l4_key.src_port;
-	memcpy(&ipv6_l4_key, &(tpm_rule->ipv6_l4_key), sizeof(tpm_rule_ipv6_l4_key_t));
-	parse_rule_bm = tpm_rule->ipv6_l4_key.parse_rule_bm;
-	parse_flags_bm = tpm_rule->ipv6_l4_key.parse_flags_bm;
-	memcpy(&pkt_frwd, &(tpm_rule->ipv6_l4_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(rule_action, &(tpm_rule->ipv6_l4_key.rule_action), sizeof(tpm_rule_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->ipv6_l4_key.pkt_frwd.trg_port;
-	memcpy(pkt_mod, &(tpm_rule->ipv6_l4_key.pkt_mod), sizeof(tpm_pkt_mod_t));
-	*pkt_mod_bm = tpm_rule->ipv6_l4_key.pkt_mod_bm;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_idx;
-
-	/*check ipv6_5t is enable or not*/
-	tpm_ret = tpm_db_ipv6_5t_enable_get(&ipv6_5t_enable);
-	IF_ERROR(tpm_ret);
-
-	/* Get direction */
-	tpm_ret = tpm_proc_src_port_dir_map(src_port, &dir);
-	IF_ERROR(tpm_ret);
-
-	if (ipv6_5t_enable == TPM_IPV6_5T_DISABLED) {
-		/*generate tcam */
-		tpm_ret = tpm_proc_ipv6_l4ports_tcam_build(src_port,
-							   dir,
-							   rule_num,
-							   &ipv6_l4_key.l4_key,
-							   parse_rule_bm,
-							   parse_flags_bm,
-							   rule_action,
-							   pkt_mod,
-							   *pkt_mod_bm,
-							   &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-
-		/*generate sram*/
-		tpm_ret = tpm_proc_ipv6_l4ports_sram_build(src_port,
-							   dir,
-							   rule_num,
-							   pon_type,
-							   &pkt_frwd,
-							   rule_action,
-							   mod_con->mod_cmd_ind,
-							   &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	} else {
-		/*********** Get Subflow Info **********/
-		subflow_bm = parse_rule_bm & TPM_DB_IPV6_L4_SUBFLOW_PARSE_BM_MASK;
-		if ((parse_flags_bm & TPM_PARSE_FLAG_L4P_MASK) != 0) {
-			if ((parse_flags_bm & TPM_PARSE_FLAG_L4_TCP) != 0)
-				protocol = IPPROTO_TCP;
-			else
-				protocol = IPPROTO_UDP;
-			subflow_bm |= TPM_IPv6_PARSE_NH;
-		}
-		subflow_id = TPM_DB_INVALID_IPV6_FLOW_ID;
-		if (subflow_bm != 0 && rule_action->next_phase != STAGE_DONE) {
-			int_pkt_act |= TPM_ACTION_SET_IPV6_SUBFLOW;
-			subflow_id = tpm_db_find_matched_ipv6_l4_subflow(dir,
-									 subflow_bm,
-									 protocol,
-									 &ipv6_l4_key.l4_key);
-			if (subflow_id == TPM_DB_INVALID_IPV6_FLOW_ID) {
-				printk("Subflow_id get Failed\n");
-				return TPM_FAIL;
-			}
-		} else {
-			int_pkt_act |= TPM_ACTION_UNSET_IPV6_SUBFLOW;
-		}
-		/*generate tcam */
-		tpm_ret = tpm_proc_ipv6_l4_ports_5t_tcam_build(dir,
-							       rule_num,
-							       &ipv6_l4_key.l4_key,
-							       parse_rule_bm,
-							       parse_flags_bm,
-							       rule_action,
-							       pkt_mod,
-							       *pkt_mod_bm,
-							       &(pnc_data->pncl_tcam));
-		IF_ERROR(tpm_ret);
-
-		tpm_ret = tpm_proc_ipv6_l4_ports_5t_sram_build(dir,
-							       rule_num,
-							       pon_type,
-							       subflow_id,
-							       &pkt_frwd,
-							       rule_action,
-							       int_pkt_act,
-							       pkt_mod,
-							       mod_con->mod_cmd_ind,
-							       &(pnc_data->pncl_sram));
-		IF_ERROR(tpm_ret);
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* api_data2pnc_data_ipv4_cnm - translate IPV4 CnM API data to PNC data
-*
-* INPUT:
-*	pon_type
-*	tpm_rule
-*	mod_con
-*	api_ent_mem_area
-*
-* OUTPUT:
-*	pnc_data
-*	mod_entry
-*	pkt_mod
-*	pkt_mod_bm
-*	int_mod_bm
-*	rule_action
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t api_data2pnc_data_ipv4_cnm(tpm_db_pon_type_t pon_type, tpm_rule_entry_t *tpm_rule, tpm_db_mod_conn_t *mod_con,
-				   tpm_db_api_entry_t *api_ent_mem_area, tpm_pncl_pnc_full_t *pnc_data, uint32_t *mod_entry,
-				   tpm_pkt_mod_t *pkt_mod, tpm_pkt_mod_bm_t *pkt_mod_bm, tpm_pkt_mod_int_bm_t *int_mod_bm,
-				   tpm_trg_port_type_t *trg_port, tpm_rule_action_t *rule_action)
-{
-	tpm_src_port_type_t src_port;
-	tpm_parse_fields_t l2_parse_rule_bm;
-	tpm_parse_fields_t ipv4_parse_rule_bm;
-	tpm_pkt_frwd_t pkt_frwd;
-	tpm_l2_acl_key_t l2_key;
-	tpm_ipv4_acl_key_t ipv4_key;
-	tpm_pkt_action_t pkt_act;
-	tpm_db_ctc_cm_rule_entry_t cnm_rule;
-	uint32_t jump_idx = 0;
-	uint32_t precedence = 0;
-	uint32_t rule_num, pbits;
-	uint32_t ipv4_pre_key_idx = TPM_CNM_INVALID_IPV4_PRE_FILTER_KEY_ID;
-	int32_t tpm_ret = 0;
-
-	/*params check*/
-	tpm_ret = tpm_check_param_check(pon_type, tpm_rule, mod_con, api_ent_mem_area, pnc_data, mod_entry,
-					pkt_mod, pkt_mod_bm, int_mod_bm, trg_port, rule_action);
-	IF_ERROR(tpm_ret);
-
-	/*get params from API db*/
-	src_port = tpm_rule->cnm_key.src_port;
-	ipv4_parse_rule_bm = tpm_rule->cnm_key.ipv4_parse_rule_bm;
-	pkt_act = tpm_rule->cnm_key.pkt_act;
-	pbits = tpm_rule->cnm_key.pbits;
-	l2_parse_rule_bm = tpm_rule->cnm_key.l2_parse_rule_bm;
-	memcpy(&l2_key, &(tpm_rule->cnm_key.l2_key), sizeof(tpm_l2_acl_key_t));
-	memcpy(&ipv4_key, &(tpm_rule->cnm_key.ipv4_key), sizeof(tpm_ipv4_acl_key_t));
-	memcpy(&pkt_frwd, &(tpm_rule->cnm_key.pkt_frwd), sizeof(tpm_pkt_frwd_t));
-	memcpy(&rule_action->pkt_act, &(tpm_rule->cnm_key.pkt_act), sizeof(tpm_pkt_action_t));
-	*mod_entry = mod_con->mod_cmd_ind;
-	*trg_port = tpm_rule->cnm_key.pkt_frwd.trg_port;
-	*pkt_mod_bm = 0;
-	*int_mod_bm = 0;
-	rule_num = api_ent_mem_area->rule_num;
-
-	/*check whether CnM_MAIN_L2 or CnM_MAIN_IPv4*/
-	/*get rule precedence*/
-	tpm_ret = tpm_proc_calc_cnm_precedence(src_port, rule_num, &precedence);
-	IF_ERROR(tpm_ret);
-	/*get cnm rule*/
-	tpm_ret = tpm_db_ctc_cm_rule_get(src_port, precedence, &cnm_rule);
-	IF_ERROR(tpm_ret);
-	/* Get split modification update */
-	if (SET_MOD(pkt_act)) {
-		if (tpm_db_split_mod_get_enable() == TPM_SPLIT_MOD_ENABLED) {
-			/* get mod index from p-bit value */
-			tpm_ret = tpm_db_split_mod_get_index_by_p_bits(pbits, &jump_idx);
-			IF_ERROR(tpm_ret);
-			/* skip first PMT for p-bit AS-IS */
-			jump_idx++;
-		} else {
-			printk("split mod is not active\n");
-			return TPM_FAIL;
-		}
-	}
-	/*check l2_parse_rule_bm*/
-	if (cnm_rule.l2_parse_rule_bm) {
-		/*is CnM L2*/
-		/*get ipv4 pre key index for comb rule if it is*/
-		tpm_ret = tpm_db_find_ipv4_pre_filter_key(src_port,
-							  cnm_rule.ipv4_parse_rule_bm,
-							  &cnm_rule.ipv4_key,
-							  &ipv4_pre_key_idx);
-		/*rebuild tcam*/
-		tpm_ret = tpm_proc_cnm_l2_tcam_build(src_port,
-						     l2_parse_rule_bm,
-						     &l2_key,
-						     ipv4_pre_key_idx,
-						     &pnc_data->pncl_tcam);
-		IF_ERROR(tpm_ret);
-		/*rebuild sram*/
-		tpm_ret = tpm_proc_cnm_l2_sram_build(precedence,
-						     &pkt_frwd,
-						     pkt_act,
-						     jump_idx,
-						     &pnc_data->pncl_sram);
-		IF_ERROR(tpm_ret);
-	} else if ((cnm_rule.ipv4_parse_rule_bm) && (!cnm_rule.l2_parse_rule_bm)) {
-		/*is CnM IPV4*/
-		/*rebuild tcam*/
-		tpm_ret = tpm_proc_cnm_ipv4_tcam_build(src_port,
-						       precedence,
-						       ipv4_parse_rule_bm,
-						       &ipv4_key,
-						       &pnc_data->pncl_tcam);
-		IF_ERROR(tpm_ret);
-		/*rebuild sram*/
-		tpm_ret = tpm_proc_cnm_ipv4_sram_build(&pkt_frwd,
-						       pkt_act,
-						       jump_idx,
-						       &pnc_data->pncl_sram);
-		IF_ERROR(tpm_ret);
-	} else {
-		/*error*/
-		printk("Invalid CnM parse rule bm!\n");
-		tpm_ret = TPM_FAIL;
-		IF_ERROR(tpm_ret);
-	}
-
-	return TPM_OK;
-}
-
-/*pnc rebuild functions array*/
-static tpm_check_rebuild_pnc_t tpm_check_rebuild_pnc_array[TPM_MAX_NUM_API_SECTIONS] = {
-								tpm_check_param_check,
-								api_data2pnc_data_l2,
-								api_data2pnc_data_l3,
-								api_data2pnc_data_ipv4,
-								api_data2pnc_data_ipv4_mc,
-								api_data2pnc_data_ipv6_gen,
-								api_data2pnc_data_ipv6_dip,
-								api_data2pnc_data_ipv6_mc,
-								api_data2pnc_data_ipv6_nh,
-								api_data2pnc_data_ipv6_l4,
-								api_data2pnc_data_ipv4_cnm};
-
-/*******************************************************************************
-* tpm_pmt_rebuild_and_check()
-*
-* DESCRIPTION: The API is to rebuild mod pattern data and check it with HW PMT and DB.
-*
-* INPUTS:   api_type    - the rule to check belong to
-*           rule_index  - the rule index in rule's API range
-*           trg_port    - targe port
-*           pkt_mod_bm  - set of flags described which fields in the packet
-*                         to be changed
-*           int_mod_bm  - set of internal flags
-*           mod_data    - modification entry data
-*           mod_entry   - start entry number which has been set for this
-*                         modification <j>
-*
-* OUTPUTS:
-*           pmt_hw_error_count - check result for HW
-*           pmt_sw_error_count - check result for SW
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pmt_rebuild_and_check(tpm_api_type_t api_type,
-				  uint32_t rule_index,
-				  tpm_trg_port_type_t trg_port,
-				  tpm_pkt_mod_bm_t pkt_mod_bm,
-				  tpm_pkt_mod_int_bm_t int_mod_bm,
-				  tpm_pkt_mod_t *pkt_mod,
-				  uint32_t *mod_entry,
-				  uint32_t *pmt_hw_error_count,
-				  uint32_t *pmt_sw_error_count)
-{
-	tpm_gmacs_enum_t trg_gmac;
-	tpm_main_chain_check_type_t main_chain_check;
-	tpm_error_code_t pmt_check_result;
-	int32_t tpm_ret = 0;
-
-	tpm_ret = tpm_proc_trg_port_gmac_map(trg_port, &trg_gmac);
-	IF_ERROR(tpm_ret);
-
-	/*check main chain type*/
-	if (tpm_check_main_chain_type(trg_gmac, pkt_mod_bm, int_mod_bm, *mod_entry,
-				      &main_chain_check)) {
-		printk("(Warn) main chain type check failed, API: %s, PnC index %d\n",
-			api_type_to_str(api_type), rule_index);
-	} else if (main_chain_check) {
-		printk("main chain type mismatch, API: %s, PnC index %d\n",
-			api_type_to_str(api_type), rule_index);
-	}
-
-	/*clear structure*/
-	memset(&_pattern_data, 0, sizeof(tpm_mod_pattern_data_t));
-
-	/*build internal mod pattern data*/
-	tpm_ret = tpm_mod2_fill_in_pattern(trg_gmac,
-					   pkt_mod_bm,
-					   int_mod_bm,
-					   pkt_mod,
-					   mod_entry,
-					   &_pattern_data,
-					   TPM_CHECK_MAIN_CHAIN_IDX_DB);
-	IF_ERROR(tpm_ret);
-	/*check with DB*/
-	if (tpm_pmt_check(trg_gmac, &_pattern_data, &pmt_check_result,
-			  TPM_CHECK_WITH_DB)) {
-		printk("SW PMT check error, API type: %s, PnC rule index %d\n",
-			api_type_to_str(api_type), rule_index);
-	} else if (pmt_check_result) {
-		*pmt_sw_error_count = *pmt_sw_error_count + 1;
-		printk("SW PMT mismatch, API type: %s, PnC rule index %d\n",
-			api_type_to_str(api_type), rule_index);
-	}
-	/*clear structure*/
-	memset(&_pattern_data, 0, sizeof(tpm_mod_pattern_data_t));
-
-	/*build internal mod pattern data*/
-	tpm_ret = tpm_mod2_fill_in_pattern(trg_gmac,
-					   pkt_mod_bm,
-					   int_mod_bm,
-					   pkt_mod,
-					   mod_entry,
-					   &_pattern_data,
-					   TPM_CHECK_MAIN_CHAIN_IDX_HW);
-	IF_ERROR(tpm_ret);
-	/*check with HW*/
-	if (tpm_pmt_check(trg_gmac, &_pattern_data, &pmt_check_result,
-			  TPM_CHECK_WITH_HW)) {
-		printk("HW PMT check error, API type: %s, PnC rule index %d\n",
-			api_type_to_str(api_type), rule_index);
-	} else if (pmt_check_result) {
-		*pmt_hw_error_count = *pmt_hw_error_count + 1;
-		printk("HW PMT mismatch, API type: %s, PnC rule index %d\n",
-			api_type_to_str(api_type), rule_index);
-	}
-
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_self_check - Check existed TPM rules and PMT table
-*
-* INPUT:
-*       owner_id
-*	check_level, 0--only check, 1--if there's error in HW table,
-*					it will try to correct it, done later
-*
-* OUTPUT:
-*	None
-*
-* RETURN:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-* It is APIs caller responsibility to maintain the correct number of each rule.
-*******************************************************************************/
-tpm_error_code_t tpm_self_check(uint32_t owner_id, tpm_self_check_level_enum_t check_level)
-{
-	tpm_api_type_t api_type;
-	tpm_pnc_all_t pnc_out;
-	tpm_rule_entry_t tpm_rule;
-	tpm_api_sections_t api_section;
-	tpm_db_mod_conn_t mod_con;
-	tpm_db_pnc_conn_t pnc_con;
-	tpm_pkt_mod_int_bm_t int_mod_bm = 0;
-	tpm_pkt_mod_bm_t pkt_mod_bm = 0;
-	tpm_rule_action_t rule_action;
-	tpm_db_pon_type_t pon_type = 0;
-	struct tcam_entry hw_te;
-	tpm_pnc_all_t read_pnc;
-	tpm_pnc_all_t shadow_pnc;
-	tpm_trg_port_type_t trg_port = 0;
-	tpm_pkt_mod_t pkt_mod;
-	tpm_vlan_key_t *vlan_out = NULL;
-	tpm_db_ctc_cm_enable_t ctc_cm_enable = TPM_CTC_CM_DISABLED;
-	uint8_t p_bits_tpm;
-	uint32_t loop;
-	uint32_t rule_num, rule_index, bi_dir;
-	int32_t apisec_last_valid_index;
-	uint32_t mod_entry = 0;
-	uint32_t valid_entry_num = 0;
-	uint32_t shadow_ent_valid;
-	uint32_t hw_jump_idx, shadow_jump_idx;
-	uint32_t p_bits_nums;
-	/*error statisc*/
-	uint32_t pnc_hw_error_count = 0;
-	uint32_t pnc_sw_error_count = 0;
-	uint32_t pmt_hw_error_count = 0;
-	uint32_t pmt_sw_error_count = 0;
-	uint32_t unnormal_end_count = 0;
-	uint32_t section_valid_entry_count = 0;/*the count of api section with valid entry*/
-
-	int32_t tpm_ret = 0;
-
-	/* Get pon_type */
-	if (tpm_db_pon_type_get(&pon_type))
-		return ERR_GENERAL;
-	/* get ctc cm enable status */
-	if (tpm_db_ctc_cm_enable_get(&ctc_cm_enable))
-		return ERR_GENERAL;
-
-	for (api_type = TPM_API_L2_PRIM; api_type <= TPM_API_CNM; api_type++) {
-		/*check whether CnM is enable or not*/
-		if ((api_type == TPM_API_CNM) && (TPM_CTC_CM_DISABLED == ctc_cm_enable))
-			continue;
-		/* Get the api_section */
-		tpm_ret = tpm_db_api_section_get_from_api_type(api_type, &api_section);
-		if (tpm_ret != TPM_RC_OK) {
-			printk("Get API_SECTION Failed-%s\n", api_type_to_str(api_type));
-			continue;
-		}
-
-		valid_entry_num = 0;
-		if (tpm_db_api_section_num_entries_get(api_section, &valid_entry_num))
-			continue;
-
-		if (valid_entry_num == 0)
-			continue;
-
-		section_valid_entry_count++;
-
-		/*get the last valid rule index in the api_section*/
-		if (tpm_db_api_section_lastentry_get(api_section, &apisec_last_valid_index))
-			continue;
-
-		/* Get the rulenum index */
-		for (rule_index = 0; rule_index <= apisec_last_valid_index; rule_index++) {
-			/*clear structure*/
-			memset(&pnc_data, 0, sizeof(tpm_pncl_pnc_full_t));
-			memset(&pnc_out, 0, sizeof(tpm_pnc_all_t));
-			memset(&hw_te, 0, sizeof(struct tcam_entry));
-			memset(&read_pnc, 0, sizeof(tpm_pnc_all_t));
-			memset(&shadow_pnc, 0, sizeof(tpm_pnc_all_t));
-			memset(&tpm_rule, 0, sizeof(tpm_rule_entry_t));
-			memset(&rule_action, 0, sizeof(tpm_rule_action_t));
-			memset(&mod_con, 0, sizeof(tpm_db_mod_conn_t));
-			memset(&pnc_con, 0, sizeof(tpm_db_pnc_conn_t));
-			memset(&api_ent_mem_area, 0, sizeof(tpm_db_api_entry_t));
-
-			/*get api section table entry*/
-			if (tpm_db_api_section_ent_tbl_get(api_section, &api_ent_mem_area, rule_index))
-				break;
-
-			if (api_ent_mem_area.valid == TPM_DB_VALID) {
-				/*get tpm_rule*/
-				memcpy(&tpm_rule, &(api_ent_mem_area.api_rule_data),
-					sizeof(tpm_rule_entry_t));
-				memcpy(&mod_con, &(api_ent_mem_area.mod_tbl_conn),
-					sizeof(tpm_db_mod_conn_t));
-				memcpy(&pnc_con, &(api_ent_mem_area.pnc_tbl_conn), sizeof(tpm_db_pnc_conn_t));
-				bi_dir = api_ent_mem_area.bi_dir;
-				rule_num = api_ent_mem_area.rule_idx;
-				tpm_ret = tpm_check_rebuild_pnc_array[api_section](pon_type,
-										   &tpm_rule,
-										   &mod_con,
-										   &api_ent_mem_area,
-										   &pnc_data,
-										   &mod_entry,
-										   &pkt_mod,
-										   &pkt_mod_bm,
-										   &int_mod_bm,
-										   &trg_port,
-										   &rule_action);
-				if (tpm_ret) {
-					printk("API type: %s, the %d th PnC Rule Rebuild Failed\n",
-						api_type_to_str(api_type), rule_index);
-					unnormal_end_count++;
-					break;
-				}
-				/* TCAM map to tpm_tcam_all_t of tpm_pnc_all_t */
-				tpm_ret = tpm_pncl_tcam_map(&(pnc_data.pncl_tcam), &(pnc_out.tcam_entry));
-				IF_ERROR(tpm_ret);
-
-				/* SRAM  map to tpm_sram_all_t of tpm_pnc_all_t */
-				tpm_ret = tpm_pncl_sram_map(&(pnc_data.pncl_sram),
-							    &(pnc_out.sram_entry),
-							    &(pnc_data.pncl_tcam));
-				IF_ERROR(tpm_ret);
-
-				/*read Pnc from HW table*/
-				tpm_ret = tcam_hw_read(&hw_te, pnc_con.pnc_conn_tbl[0].pnc_index);
-				IF_ERROR(tpm_ret);
-				/*translate tcam_entry to tpm_pnc_all_t*/
-				tran_tcam_entry_to_pnc_all_t(&read_pnc, &hw_te, &rule_action, api_section);
-
-				/*read PnC from PnC shadow table*/
-				tpm_ret = tpm_db_pnc_shdw_ent_get(pnc_con.pnc_conn_tbl[0].pnc_index,
-								  &shadow_ent_valid,
-								  &shadow_pnc);
-				IF_ERROR(tpm_ret);
-
-				/*check PNC*/
-				tpm_check_update_sram(&pnc_out.sram_entry, &rule_action);
-				tpm_check_update_sram(&shadow_pnc.sram_entry, &rule_action);
-				if (memcmp(&pnc_out, &read_pnc, sizeof(tpm_pnc_all_t))) {
-					printk("HW PNC mismatch, API type: %s, PnC rule index %d\n",
-						api_type_to_str(api_type), rule_index);
-					pnc_mismatch_info_show(&pnc_out, &read_pnc);
-					pnc_hw_error_count++;
-					/*correct the bad tpm rule, TODO done in future*/
-					/*if (check_level == TPM_SELF_CHECK_LEVEL1)*/
-				}
-				if (memcmp(&pnc_out, &shadow_pnc, sizeof(tpm_pnc_all_t))) {
-					printk("SW PNC mismatch, API type: %s, PnC rule index %d\n",
-						api_type_to_str(api_type), rule_index);
-					pnc_mismatch_info_show(&pnc_out, &shadow_pnc);
-					pnc_sw_error_count++;
-				}
-
-				/*******************check PMT if necessary********************/
-				/*check precondition: SET_MOD, jump_entry index is same in API DB, TPM DB and HW*/
-				/*get HW JUPM Index*/
-				hw_jump_idx = read_pnc.sram_entry.flowid_val & 0xFFF;
-				/*get shadow JUPM Index*/
-				shadow_jump_idx = shadow_pnc.sram_entry.flowid_val & 0xFFF;
-				if (SET_MOD(rule_action.pkt_act) &&
-				    (hw_jump_idx == shadow_jump_idx) &&
-				    (hw_jump_idx == mod_entry)) {
-					/*only modify VLAN and VLAN OP is NOOP, do not check*/
-					if (TPM_VLAN_MOD == pkt_mod_bm && VLANOP_NOOP == pkt_mod.vlan_mod.vlan_op)
-						continue;
-					if ((TPM_API_L2_PRIM == api_type) &&
-					    tpm_split_mod_stage1_check(pkt_mod_bm, &pkt_mod, &rule_action, false)) {
-						int_mod_bm = TPM_INT_SPLIT_MOD;
-						p_bits_nums = TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX;
-						/* VLANOP_EXT_TAG_MOD_INS mod insert VLAN p_bit */
-						if (VLANOP_EXT_TAG_MOD_INS == pkt_mod.vlan_mod.vlan_op)
-							vlan_out = &pkt_mod.vlan_mod.vlan2_out;
-						else
-							vlan_out = &pkt_mod.vlan_mod.vlan1_out;
-						/* AS-IS pmt check */
-						vlan_out->pbit_mask = 0;
-						mod_entry = mod_entry / 16;
-						mod_entry *= 16;
-						tpm_ret = tpm_pmt_rebuild_and_check(api_type,
-										    rule_index,
-										    trg_port,
-										    pkt_mod_bm,
-										    int_mod_bm,
-										    &pkt_mod,
-										    &mod_entry,
-										    &pmt_hw_error_count,
-										    &pmt_sw_error_count);
-						IF_ERROR(tpm_ret);
-						/* supported pbits pmt check */
-						vlan_out->pbit_mask = 0xFF;
-						for (loop = 0; loop < p_bits_nums; loop++) {
-							tpm_ret = tpm_db_split_mod_get_p_bits_by_index(loop, &p_bits_tpm);
-							IF_ERROR(tpm_ret);
-							vlan_out->pbit = p_bits_tpm;
-							mod_entry++;
-							tpm_ret = tpm_pmt_rebuild_and_check(api_type,
-											    rule_index,
-											    trg_port,
-											    pkt_mod_bm,
-											    int_mod_bm,
-											    &pkt_mod,
-											    &mod_entry,
-											    &pmt_hw_error_count,
-											    &pmt_sw_error_count);
-							IF_ERROR(tpm_ret);
-						}
-					} else {
-						/* Normal PMT check */
-						tpm_ret = tpm_pmt_rebuild_and_check(api_type,
-										    rule_index,
-										    trg_port,
-										    pkt_mod_bm,
-										    int_mod_bm,
-										    &pkt_mod,
-										    &mod_entry,
-										    &pmt_hw_error_count,
-										    &pmt_sw_error_count);
-						IF_ERROR(tpm_ret);
-					}
-				}
-
-			}
-		}
-	}
-
-	if (section_valid_entry_count) {
-		if (unnormal_end_count) {
-			if ((pnc_hw_error_count == 0) && (pnc_sw_error_count == 0))
-				printk("\nPartly PNC Check, OK\n");
-			if ((pmt_hw_error_count == 0) && (pmt_sw_error_count == 0))
-				printk("Partly PMT Check, OK\n");
-		} else {
-			if ((pnc_hw_error_count == 0) && (pnc_sw_error_count == 0))
-				printk("\nPNC Check, OK\n");
-			if ((pmt_hw_error_count == 0) && (pmt_sw_error_count == 0))
-				printk("PMT Check, OK\n");
-		}
-	} else {
-		printk("(Warn)No Valid Rule exist, Nothing to check\n");
-	}
-
-	return TPM_RC_OK;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.h
deleted file mode 100644
index 22d9134..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_self_check.h
+++ /dev/null
@@ -1 +0,0 @@
-/*******************************************************************************Copyright (C) Marvell International Ltd. and its affiliatesThis software file (the "File") is owned and distributed by MarvellInternational Ltd. and/or its affiliates ("Marvell") under the followingalternative licensing terms.  Once you have made an election to distribute theFile under one of the following license alternatives, please (i) delete thisintroductory statement regarding license alternatives, (ii) delete the twolicense alternatives that you have not elected to use and (iii) preserve theMarvell copyright notice above.********************************************************************************Marvell Commercial License OptionIf you received this File from Marvell and you have entered into a commerciallicense agreement (a "Commercial License") with Marvell, the File is licensedto you under the terms of the applicable Commercial License.********************************************************************************Marvell GPL License OptionIf you received this File from Marvell, you may opt to use, redistribute and/ormodify this File in accordance with the terms and conditions of the GeneralPublic License Version 2, June 1991 (the "GPL License"), a copy of which isavailable along with the File in the license.txt file or by writing to the FreeSoftware Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 oron the worldwide web at http://www.gnu.org/licenses/gpl.txt.THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIEDWARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLYDISCLAIMED.  The GPL License provides additional details about this warrantydisclaimer.********************************************************************************Marvell BSD License OptionIf you received this File from Marvell, you may opt to use, redistribute and/ormodify this File under the following licensing terms.Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met:    *   Redistributions of source code must retain the above copyright notice,	    this list of conditions and the following disclaimer.    *   Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.    *   Neither the name of Marvell nor the names of its contributors may be        used to endorse or promote products derived from this software without        specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FORANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ONANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.******************************************************************************//******************************************************************************* tpm_self_check.h** DESCRIPTION:*               Traffic Processor Manager = TPM** DEPENDENCIES:*               None** CREATED BY:   Evan** DATE CREATED:** FILE REVISION NUMBER:*********************************************************************************/#ifndef _TPM_SELF_CHECK_H_#define _TPM_SELF_CHECK_H_typedef int32_t (*tpm_check_rebuild_pnc_t) (tpm_db_pon_type_t pon_type,					    tpm_rule_entry_t *tpm_rule,					    tpm_db_mod_conn_t *mod_con,					    tpm_db_api_entry_t *api_ent_mem_area,					    tpm_pncl_pnc_full_t *pnc_data,					    uint32_t *mod_entry,					    tpm_pkt_mod_t *pkt_mod,					    tpm_pkt_mod_bm_t *pkt_mod_bm,					    tpm_pkt_mod_int_bm_t *int_mod_bm,					    tpm_trg_port_type_t *trg_port,					    tpm_rule_action_t *rule_action);typedef enum {	TPMCHECK_CHAIN_TYPE_OK,	TPMCHECK_DB_CHAIN_TYPE_MISMATCH,	TPMCHECK_HW_CHAIN_TYPE_MISMATCH,	TPMCHECK_BOTH_CHAIN_TYPE_MISMATCH,} tpm_main_chain_check_type_t;typedef enum {	TPM_CHECK_DISABLE,/*is not TPM check, do normal use*/	TPM_CHECK_MAIN_CHAIN_IDX_DB,/*is tpm check, main chain index from DB*/	TPM_CHECK_MAIN_CHAIN_IDX_HW,/*is tpm check, main chain index from HW*/	TPM_CHECK_WITH_DB,/*is tpm check, and check with DB*/	TPM_CHECK_WITH_HW,/*is tpm check, check with HW*/	TPM_CHECK_ENABLE,} tpm_self_check_enable_t;tpm_error_code_t tpm_self_check(uint32_t owner_id, tpm_self_check_level_enum_t check_level);#endif  /* _TPM_SELF_CHECK_H_*/
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.c
deleted file mode 100644
index a26e9ca..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.c
+++ /dev/null
@@ -1,1770 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_help.h"
-
-
-
-/**********************************************************************/
-/* ===================================================================*/
-/*             TPM SYSFS CFG HELP FUNCTION                            */
-/* ================================================================== */
-
-
-/*******************************************************************************
-**
-**  sfs_tpm_cfg_index
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_cfg_index(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "cat help_tpm_cfg_index                        - show this help\n");
-    off += sprintf(buf+off, "cat help_frwd_rule_cfg                        - show frwd rule help\n");
-    off += sprintf(buf+off, "cat help_igmp_cfg                             - show IGMP configuration help\n");
-    off += sprintf(buf+off, "cat help_ipv4_key_cfg                         - show IPV4 key ACL help\n");
-    off += sprintf(buf+off, "cat help_ipv4_rule_add                        - show add IPV4 rule help\n");
-
-    off += sprintf(buf+off, "cat help_ipv6_dip_key_cfg                     - show IPV6 DIP key ACL help\n");
-    off += sprintf(buf+off, "cat help_ipv6_ctc_cm_key_cfg                  - show IPV6 CTC key ACL help\n");
-    off += sprintf(buf+off, "cat help_ipv6_dip_rule_add                    - show add IPV6 DIP rule help\n");
-    off += sprintf(buf+off, "cat help_ipv6_l4_ports_rule_add               - show add IPV6 L4 ports rule help\n");
-    off += sprintf(buf+off, "cat help_ipv6_nh_rule_add                     - show add IPV6 NH rule help\n");
-    off += sprintf(buf+off, "cat help_ipv6_gen_key_cfg                     - show IPV6 key ACL help\n");
-    off += sprintf(buf+off, "cat help_ipv6_gen_rule_add                    - show add IPV6 rule help\n");
-
-    off += sprintf(buf+off, "cat help_ctc_cm_rule_add                      - show add CTC CnM rule help\n");
-
-    off += sprintf(buf+off, "cat help_key_rule_delete                      - show key delete from DB table (mod/frwd/vlan/l2/l3/ipv4) help\n");
-    off += sprintf(buf+off, "cat help_l2_key_cfg                           - show L2 key ACL help\n");
-    off += sprintf(buf+off, "cat help_l2_rule_add                          - show add L2 rule help\n");
-    off += sprintf(buf+off, "cat help_l3_key_cfg                           - show L3 key ACL help\n");
-    off += sprintf(buf+off, "cat help_l3_rule_add                          - show add L3 rule help\n");
-    off += sprintf(buf+off, "cat help_mc_ipvx_stream_add                   - show add multicast IPV4 stream help\n");
-    off += sprintf(buf+off, "cat help_mib_reset                            - show MIB reset help\n");
-    off += sprintf(buf+off, "cat help_set_active_wan                       - show set active wan help\n");
-    off += sprintf(buf+off, "cat help_mod_rule_cfg                         - show mod rule help\n");
-    off += sprintf(buf+off, "cat help_no_mc_stream_add                     - show delete multicast stream help\n");
-    off += sprintf(buf+off, "cat help_no_oam_omci_channel                  - show delete OAM/OMCI channel help\n");
-    off += sprintf(buf+off, "cat help_no_rule_add                          - show delete L2/L3/IPV4/IPV6_xxx/DSCP IPV4/DSCP IPV6/CTC CnM rule help\n");
-    off += sprintf(buf+off, "cat help_oam_omci_channel                     - show OAM/OMCI channel configuration help\n");
-    off += sprintf(buf+off, "cat help_pkt_mod_add                          - show packet modification add help\n");
-    off += sprintf(buf+off, "cat help_pkt_mod_get_del_purge                - show packet modification display, delete. purge help\n");
-    off += sprintf(buf+off, "cat help_rate_limit                           - show queue rate limit/scheduling, entity rate limit help\n");
-    off += sprintf(buf+off, "cat help_rule_table_display                   - show rule table display help\n");
-    off += sprintf(buf+off, "cat help_vlan_rule_cfg                        - show vlan rule help\n");
-    off += sprintf(buf+off, "cat help_delete_entry_rule_table              - show delete rule entry help\n");
-    off += sprintf(buf+off, "cat help_tpm_self_check                       - show TPM check help\n");
-    off += sprintf(buf+off, "cat help_mac_learn_rule_add                   - show add MAC learn rule help\n");
-    off += sprintf(buf+off, "cat help_mac_learn_def_act_set                - show set action of mac learn default rule help\n");
-
-    off += sprintf(buf+off, "==================================================================================================\n");
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_frwd_rule_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_frwd_rule_cfg(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [rule_name] [port_bitmap] [queue] [gem_port]  > frwd_rule_set    - set a forwarding rule\n");
-	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-	off += sprintf(buf+off, "\tport_bitmap         (hex) see below\n");
-	off += sprintf(buf+off, "\t\tTPM_TRG_PORT_WAN           %#.5X     TPM_TRG_TCONT_0      %#.5X\n",TPM_TRG_PORT_WAN, TPM_TRG_TCONT_0);
-	off += sprintf(buf+off, "\t\tTPM_TRG_TCONT_1            %#.5X     TPM_TRG_TCONT_2      %#.5X\n",TPM_TRG_TCONT_1, TPM_TRG_TCONT_2);
-	off += sprintf(buf+off, "\t\tTPM_TRG_TCONT_3            %#.5X     TPM_TRG_TCONT_4      %#.5X\n",TPM_TRG_TCONT_3, TPM_TRG_TCONT_4);
-	off += sprintf(buf+off, "\t\tTPM_TRG_TCONT_5            %#.5X     TPM_TRG_TCONT_6      %#.5X\n",TPM_TRG_TCONT_5, TPM_TRG_TCONT_6);
-	off += sprintf(buf+off, "\t\tTPM_TRG_TCONT_7            %#.5X     TPM_TRG_LLID_0       %#.5X\n",TPM_TRG_TCONT_7, TPM_TRG_LLID_0);
-	off += sprintf(buf+off, "\t\tTPM_TRG_LLID_1             %#.5X     TPM_TRG_LLID_2       %#.5X\n",TPM_TRG_LLID_1, TPM_TRG_LLID_2);
-	off += sprintf(buf+off, "\t\tTPM_TRG_LLID_3             %#.5X     TPM_TRG_LLID_4       %#.5X\n",TPM_TRG_LLID_3, TPM_TRG_LLID_4);
-	off += sprintf(buf+off, "\t\tTPM_TRG_LLID_5             %#.5X     TPM_TRG_LLID_6       %#.5X\n",TPM_TRG_LLID_5, TPM_TRG_LLID_6);
-	off += sprintf(buf+off, "\t\tTPM_TRG_LLID_7             %#.5X     TPM_TRG_UNI_0        %#.5X\n",TPM_TRG_LLID_7, TPM_TRG_UNI_0);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_1              %#.5X     TPM_TRG_UNI_2        %#.5X\n",TPM_TRG_UNI_1, TPM_TRG_UNI_2);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_3              %#.5X     TPM_TRG_UNI_4        %#.5X\n",TPM_TRG_UNI_3, TPM_TRG_UNI_4);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_5              %#.5X     TPM_TRG_UNI_6        %#.5X\n",TPM_TRG_UNI_5, TPM_TRG_UNI_6);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_7              %#.5X     TPM_TRG_UNI_VIRT     %#.5X\n",TPM_TRG_UNI_7, TPM_TRG_UNI_VIRT);
-	off += sprintf(buf+off, "\t\tTPM_TRG_PORT_CPU           %#.5X     TPM_TRG_PORT_UNI_ANY %#.5X\n",TPM_TRG_PORT_CPU, TPM_TRG_PORT_UNI_ANY);
-	off += sprintf(buf+off, "\t\tTPM_TRG_PORT_UNI_CPU_LOOP  %#.5X     TPM_TRG_LOAD_BAL     %#.5X\n",TPM_TRG_PORT_UNI_CPU_LOOP, TPM_TRG_LOAD_BAL);
-	off += sprintf(buf+off, "\tqueue               (dec)Queue number\n");
-	off += sprintf(buf+off, "\tgem_port            (dec)GEM port\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_vlan_rule_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_vlan_rule_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [rule_name] [tpid] [tpid_mask] [vid] [vid_mask] [cfi] [cfi_mask] [pbit] [pbit_mask] > vlan_rule_set        - set a VLAN rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\ttpid                (hex)TPID VLAN Ethertype\n");
-    off += sprintf(buf+off, "\ttpid_mask            (hex)TPID mask\n");
-    off += sprintf(buf+off, "\tvid                 (dec)VID\n");
-    off += sprintf(buf+off, "\tvid_mask            (hex)VID mask\n");
-    off += sprintf(buf+off, "\tcfi                 (dec)CFI\n");
-    off += sprintf(buf+off, "\tcfi_mask            (hex)CFI mask\n");
-    off += sprintf(buf+off, "\tpbit                (dec)P-bits\n");
-    off += sprintf(buf+off, "\tpbit_mask           (hex)P-bits mask\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_mod_rule_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_mod_rule_cfg(char* buf)
-{
-    int off = 0;
-#if 0
-    off += sprintf(buf+off, "echo [rule_name] [proto]                                    > mod_proto_rule_set   - set protocol part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tprotocol_type       (hex)Protocol\n");
-#endif
-    off += sprintf(buf+off, "echo [rule_name] [mh2b]                                     > mod_mh_rule_set   - set protocol part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\t                     'dbg_entry' is reserved for PMT debugging\n");
-    off += sprintf(buf+off, "\tmh2b                (hex)2 Bytes Marvell Header\n");
-
-    off += sprintf(buf+off, "\necho [rule_name]   [operation] [vlan_rule_1] [vlan_rule_2] > mod_vlan_rule_set    - set VLAN part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tvlan_rule_1         (str)VLAN rule (Use vlan_empty for absent rule)\n");
-    off += sprintf(buf+off, "\tvlan_rule_2         (str)VLAN rule (Use vlan_empty for absent rule)\n");
-    off += sprintf(buf+off, "\toperation           (str)VLAN operation\n");
-    off += sprintf(buf+off, "\t\tnone      ext_tag_mod  ext_tag_del  ext_tag_ins  ext_tag_mod_ins  ins_2tag\n");
-    off += sprintf(buf+off, "\t\tmod_2tag  swap_tags    del_2tags    int_tag_mod  split_mod_pbit   ext_tag_del_int_mod\n");
-#if 0
-    off += sprintf(buf+off, "\necho [rule_name] [dscp] [dscpmask]                         > mod_dscp_rule_set      - set dscp part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tdscp                (dec)DSCP value\n");
-    off += sprintf(buf+off, "\tdscp_mask           (hex)DSCP mask\n");
-#endif
-    off += sprintf(buf+off, "\necho [rule_name] [session] [protocol_type]                 > mod_pppoe_rule_set     - set PPPoE part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tsession             (dec)Session number\n");
-    off += sprintf(buf+off, "\tprotocol_type       (hex)Protocol type\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [src_port] [dst_port]                     > mod_ipv4_port_rule_set - set IPV4 port part of mod rule\n");
-    off += sprintf(buf+off, "echo [rule_name] [src_port] [dst_port]                       > mod_ipv6_port_rule_set - set IPV6 port part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tsrc_port            (dec)Source port\n");
-    off += sprintf(buf+off, "\tdst_port            (dec)Destination port\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [srcip] [srcip_mask] [dstip] [dstip_mask] > mod_ipv6_addr_rule_set - set IPV6 address part of mod rule\n");
-    off += sprintf(buf+off, "echo [rule_name] [srcip] [srcip_mask] [dstip] [dstip_mask] > mod_ipv4_addr_rule_set - set IPV4 address part of mod rule\n");
-    off += sprintf(buf+off, "echo [rule_name] [SA] [SA_mask] [DA] [DA_mask]             > mod_mac_addr_rule_set  - set MAC address part of mod rule\n");
-    off += sprintf(buf+off, "\trule_name            (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tMAC  address/mask    aa:bb:cc:dd:ee:ff  where each part is hexadecimal in range 0..FF\n");
-    off += sprintf(buf+off, "\tIPV4 address/mask    w.x.y.z  where each part is decimal value in range 0..255\n");
-    off += sprintf(buf+off, "\tIPV6 address/mask    aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh  where each part is hexadecimal in range 0..FFFF\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_l2_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_l2_key_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [rule_name] [ether_type]                     > l2_key_ethertype_rule_set  - set ethertype part of L2 ACL key\n");
-    off += sprintf(buf+off, "\trule_name         (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tether_type        (hex)Ethernet type\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [gem_port]                     > l2_key_gemport_rule_set    - set gemport part of L2 ACL key\n");
-    off += sprintf(buf+off, "\trule_name         (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tgem_port          (dec)Ethernet type\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [SA] [SA_mask] [DA] [DA_mask]  > l2_key_mac_addr_rule_set   - set MAC address part of L2 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name         (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tMAC address       aa:bb:cc:dd:ee:ff  where each part is hexadecimal in range 0..FF\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [vlan_rule_1] [vlan_rule_2]    > l2_key_vlan_rule_set       - set VLAN part of L2 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name         (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tvlan_rule_1       (str)VLAN rule name (Use vlan_empty for absent rule)\n");
-    off += sprintf(buf+off, "\tvlan_rule_2       (str)VLAN rule name (Use vlan_empty for absent rule)\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [session] [protocol_type]      > l2_key_pppoe_rule_set      - set PPPoE part of L2 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name         (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tsession           (dec)Session number\n");
-    off += sprintf(buf+off, "\tprotocol_type     (hex)Protocol type\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_l3_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_l3_key_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [rule_name] [ether_type]              > l3_key_ethertype_rule_set  - set ethertype part of L3 ACL key\n");
-    off += sprintf(buf+off, "\trule_name       (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tether_type      (hex)Ethernet type\n");
-
-    off += sprintf(buf+off, "echo [rule name] [session] [protocol_type] > l3_key_pppoe_rule_set      - set PPPoE part of L3 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name       (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tsession         (dec)Session number\n");
-    off += sprintf(buf+off, "\tprotocol_type   (hex)Protocol type\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv4_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv4_key_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [rule_name] [proto]                           > ipv4_key_proto_rule_set - set protocol part of IPV4 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name        (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tproto            (dec)Protocol 0-255\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [dscp] [dscpmask]               > ipv4_key_dscp_rule_set  - set dscp part of IPV4 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name      (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tdscp            (dec)DSCP value 0-63\n");
-    off += sprintf(buf+off, "\tdscp_mask       (hex)DSCP mask  0x0-0xFF\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [src_port] [dst_port]           > ipv4_key_port_rule_set  - set IPV4 port part of IPV4 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name       (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tsrc_port        (dec)Source port\n");
-    off += sprintf(buf+off, "\tdst_port        (dec)Destination port\n");
-
-    off += sprintf(buf+off, "\necho [rule_name] [srcip] [srcip_mask] [dstip] [dstip_mask] > ipv4_key_addr_rule_set  - set IPV4 address part of IPV4 ACL rule\n");
-    off += sprintf(buf+off, "\trule_name       (max 16 chars)Rule name\n");
-    off += sprintf(buf+off, "\tIPV4 address     w.x.y.z  where each part is decimal value in range 0..255\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_mtu_cfg - see
-**
-*******************************************************************************/
-int sfs_help_mtu_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [enable]                                    > enable_mtu  - enable mtu checking\n");
-    off += sprintf(buf+off, "\tenable                      (dec)0 disable, 1 enable\n");
-    off += sprintf(buf+off, "echo [ipv4_or_ipv6] [direction] [mtu_value]      > set_mtu  - set mtu\n");
-    off += sprintf(buf+off, "\tipv4_or_ipv6                (dec)0 for IPv4, 1 for IPv6\n");
-    off += sprintf(buf+off, "\tdirection                   (dec)0 for DS, 1 for US\n");
-    off += sprintf(buf+off, "\tmtu_value                   (dec)mtu value\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [ipv4_or_ipv6] [direction] [pppoe_mtu_value] > set_pppoe_mtu  - set pppoe mtu\n");
-    off += sprintf(buf+off, "\tipv4_or_ipv6                (dec)0 for IPv4, 1 for IPv6\n");
-    off += sprintf(buf+off, "\tdirection                   (dec)0 for DS, 1 for US\n");
-    off += sprintf(buf+off, "\tpppoe_mtu_value             (dec)pppoe mtu value\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_gen_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_gen_key_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [key_name] [DSCP] [DSCP Mask] > ipv6_gen_key_dscp_rule_set  - set dscp key\n");
-    off += sprintf(buf+off, "\tkey_name           (max 16 chars)Key name\n");
-    off += sprintf(buf+off, "\tDSCP               (dec)DSCP\n");
-    off += sprintf(buf+off, "\tDSCP Mask          (hex)DSCP Mask\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [Key_name] [srcip] [srcip_mask] > ipv6_gen_key_sip_rule_set      - set sip key\n");
-    off += sprintf(buf+off, "\tKey_name           (max 16 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 address/mask  aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh  where each part is hexadecimal in range 0..FFFF\n");
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_help_ipv6_dip_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_dip_key_cfg(char* buf)
-{
-    int off = 0;
-    off += sprintf(buf+off, "echo [Key_name] [dip] [dip_mask] > ipv6_dip_key_rule_set      - set dip key\n");
-    off += sprintf(buf+off, "\tKey_name                (max 16 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 dip address        aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh  where each part is hexadecimal in range 0..FFFF\n");
-    off += sprintf(buf+off, "\tIPV6 dip address mask   aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh  where each part is hexadecimal in range 0..FFFF\n");
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_help_ipv6_ctc_cm_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_ctc_cm_key_cfg(char* buf)
-{
-    int off = 0;
-    off += sprintf(buf+off, "echo [ipv6_ctc_Key_name] [ipv6_gen_Key_name] [ipv6_dip_Key_name] [ipv6_l4_Key_name] "
-    "[ipv6_nh] [ipv6_hoplimit] > ipv6_ctc_cm_key_rule_set      - set IPv6 CTC CnM key\n");
-    off += sprintf(buf+off, "\tIPV6 ctc Key name                (max 32 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 gen Key name                (max 32 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 dip Key name                (max 32 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 l4 Key name                 (max 32 chars)Key name\n");
-    off += sprintf(buf+off, "\tIPV6 ipv6 nh                     (dec)Next Header\n");
-    off += sprintf(buf+off, "\tIPV6 ipv6 hoplimit               (dec)Hop Limit\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_l4_key_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_l4_key_cfg(char* buf)
-{
-    int off = 0;
-    off += sprintf(buf+off, "echo [Key_name] [src_port] [dst_port] > ipv6_l4_key_rule_set  - set l4 key\n");
-    off += sprintf(buf+off, "\tKey_name                (max 16 chars)Key name\n");
-    off += sprintf(buf+off, "\tsrc_port                (dec)Source port\n");
-    off += sprintf(buf+off, "\tdst_port                (dec)Destination port\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_rule_table_display - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_rule_table_display(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "\necho [table_name]         > rule_table_display  - display table rules\n");
-    off += sprintf(buf+off, "\ttable_name    (str)frwd/vlan/mod/l2/l3/ipv4/ipv6_dip/ipv6_gen/ipv6_l4\n");
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_key_rule_delete - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_key_rule_delete(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [table_name] [rule_name]   > no_rule_set         - clear rule from table\n");
-    off += sprintf(buf+off, "\ttable_name        (str)frwd/vlan/mod/l2key/l3key/ipv4key/ipv6_dip/ipv6_gen/ipv6_l4\n");
-
-    off += sprintf(buf+off, "\trule_name         (str)Name of entry in table\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ds_load_balance_rule - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ds_load_balance_rule(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [rule_num] [parse_rule_bm] [parse_flags_bm] [key_name] [target] > add_ds_load_balance\n");
-    off += sprintf(buf+off, "Creates a new ds load balance ACL\n");
-
-    off += sprintf(buf+off, "\towner_id        (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trule_num        (dec)Entry number to be added to the current ACL\n");
-    off += sprintf(buf+off, "\tparse_rule_bm   (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_DA		 %#.4X\n", TPM_L2_PARSE_MAC_DA);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_SA		 %#.4X\n", TPM_L2_PARSE_MAC_SA);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ONE_VLAN_TAG	 %#.4X\n", TPM_L2_PARSE_ONE_VLAN_TAG);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_TWO_VLAN_TAG	 %#.4X\n", TPM_L2_PARSE_TWO_VLAN_TAG);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ETYPE		 %#.4X\n", TPM_L2_PARSE_ETYPE);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPPOE_SES 	 %#.4X\n", TPM_L2_PARSE_PPPOE_SES);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPP_PROT		 %#.4X\n", TPM_L2_PARSE_PPP_PROT);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_GEMPORT		 %#.4X\n", TPM_L2_PARSE_GEMPORT);
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG2_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG2_FALSE);
-    off += sprintf(buf+off, "\tkey_name        (str)Name of L2 key data which has been defined by user [or l2_key_empty]\n");
-    off += sprintf(buf+off, "\ttarget          (dec)0 for GMAC0, 1 for GMAC1, 2 for CPU\n");
-
-    off += sprintf(buf+off, "\n\necho [owner_id] [rule_idx] > del_ds_load_balance       - delete a DS load balance ACL\n");
-    off += sprintf(buf+off, "\towner_id	    (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trule_idx	    (dec)Rule Id returned from the create call\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_l2_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_l2_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [key_name] [frwd_name] [mod_name] [pkt_mod_bm] > l2_rule_add\n");
-    off += sprintf(buf+off, "Creates a new primary L2 processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id        (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port        The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num        (dec)Entry number to be added to the current ACL\n");
-    off += sprintf(buf+off, "\tparse_rule_bm   (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_DA             %#.4X\n", TPM_L2_PARSE_MAC_DA);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_SA             %#.4X\n", TPM_L2_PARSE_MAC_SA);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ONE_VLAN_TAG       %#.4X\n", TPM_L2_PARSE_ONE_VLAN_TAG);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_TWO_VLAN_TAG       %#.4X\n", TPM_L2_PARSE_TWO_VLAN_TAG);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ETYPE              %#.4X\n", TPM_L2_PARSE_ETYPE);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPPOE_SES          %#.4X\n", TPM_L2_PARSE_PPPOE_SES);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPP_PROT           %#.4X\n", TPM_L2_PARSE_PPP_PROT);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_GEMPORT            %#.4X\n", TPM_L2_PARSE_GEMPORT);
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG2_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG2_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-    off += sprintf(buf+off, "\taction          (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.4X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.4X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.4X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.4X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.4X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_MTM                  %#.4X\n", TPM_ACTION_MTM);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.4X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SPEC_MC_VID          %#.4X\n", TPM_ACTION_SPEC_MC_VID);
-    off += sprintf(buf+off, "\tnext_phase      (str)Parse stage (l3/done)\n");
-    off += sprintf(buf+off, "\tkey_name        (str)Name of L2 key data which has been defined by user [or l2_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name       (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name        (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-    off += sprintf(buf+off, "\tpkt_mod_bm      (str)Bit map of pkt modification data \n");
-    off += sprintf(buf+off, "\t\tTPM_MAC_DA_SET                  %#.6X\n", TPM_MAC_DA_SET);
-    off += sprintf(buf+off, "\t\tTPM_MAC_SA_SET                  %#.6X\n", TPM_MAC_SA_SET);
-    off += sprintf(buf+off, "\t\tTPM_VLAN_MOD                    %#.6X\n", TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\tTPM_PPPOE_DEL                   %#.6X\n", TPM_PPPOE_DEL);
-    off += sprintf(buf+off, "\t\tTPM_PPPOE_ADD                   %#.6X\n", TPM_PPPOE_ADD);
-    off += sprintf(buf+off, "\t\tTPM_DSCP_SET                    %#.6X\n", TPM_DSCP_SET);
-    off += sprintf(buf+off, "\t\tTPM_TTL_DEC                     %#.6X\n", TPM_TTL_DEC);
-    off += sprintf(buf+off, "\t\tTPM_IPV4_UPDATE                 %#.6X\n", TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\tTPM_IPV4_SRC_SET                %#.6X\n", TPM_IPV4_SRC_SET);
-    off += sprintf(buf+off, "\t\tTPM_IPV4_DST_SET                %#.6X\n", TPM_IPV4_DST_SET);
-    off += sprintf(buf+off, "\t\tTPM_IPV6_UPDATE                 %#.6X\n", TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\tTPM_HOPLIM_DEC                  %#.6X\n", TPM_HOPLIM_DEC);
-    off += sprintf(buf+off, "\t\tTPM_IPV6_SRC_SET                %#.6X\n", TPM_IPV6_SRC_SET);
-    off += sprintf(buf+off, "\t\tTPM_IPV6_DST_SET                %#.6X\n", TPM_IPV6_DST_SET);
-    off += sprintf(buf+off, "\t\tTPM_L4_SRC_SET                  %#.6X\n", TPM_L4_SRC_SET);
-    off += sprintf(buf+off, "\t\tTPM_L4_DST_SET                  %#.6X\n", TPM_L4_DST_SET);
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_l3_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_l3_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [key_name] [frwd_name] > l3_rule_add\n");
-
-    off += sprintf(buf+off, "Creates a new L3 type processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ETYPE              %#.4X\n", TPM_L2_PARSE_ETYPE);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPPOE_SES          %#.4X\n", TPM_L2_PARSE_PPPOE_SES);
-    off += sprintf(buf+off, "\t\tTPM_L2_PARSE_PPP_PROT           %#.4X\n", TPM_L2_PARSE_PPP_PROT);
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG2_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG2_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG2_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.2X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.2X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv4/ipv6_gen/ipv6_nh/ctc_cm/done)\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tkey_name         (str)Name of L3 key data which has been defined by user [or l3_key_empty]\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv4_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv4_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [key_name] [frwd_name] [mod_name] > ipv4_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv4 processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_SIP              %#.4X\n", TPM_IPv4_PARSE_SIP);
-    off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_DIP              %#.4X\n", TPM_IPv4_PARSE_DIP);
-    off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_DSCP             %#.4X\n", TPM_IPv4_PARSE_DSCP);
-    off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_PROTO            %#.4X\n", TPM_IPv4_PARSE_PROTO);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                %#.4X\n", TPM_PARSE_L4_SRC);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                %#.4X\n", TPM_PARSE_L4_DST);
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.4X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.4X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.4X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.4X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.4X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.4X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_UDP_CHKSUM_CALC      %#.4X\n", TPM_ACTION_UDP_CHKSUM_CALC);
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ctc_cm/done)\n");
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\t\tTPM_VLAN_MOD                    %#.4X\n", TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\tThis is the only packet modification supported in this version. \n");
-    off += sprintf(buf+off, "\tkey_name         (str)Name of IPv4 key data which has been defined by user [or ipv4_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_gen_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_gen_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [key_name] [frwd_name] [mod_name] > ipv6_gen_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 gen processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_SIP              %#.4X\n", TPM_IPv6_PARSE_SIP);
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_DSCP             %#.4X\n", TPM_IPv6_PARSE_DSCP);
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_HOPL             %#.4X\n", TPM_IPv6_PARSE_HOPL);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.2X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.2X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv6_dip/done)\n");
-
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\t\tTPM_VLAN_MOD                    %#.4X\n", TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\tThis is the only packet modification supported in this version. \n");
-    off += sprintf(buf+off, "\tkey_name         (str)Name of IPv6 gen key data which has been defined by user [or ipv6_gen_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_nh_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_nh_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [rule_num] [parse_flags_bm] [action] [next_phase] [nh_iter] [nh] [frwd_name] > ipv6_nh_acl_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 NH processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-
-
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.2X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.2X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv6_nh/ipv6_l4/ipv6_gen/ctc_cm/done)\n");
-
-    off += sprintf(buf+off, "\tnh_iter          (dec)0:First Next Header 1:Extension Header\n");
-    off += sprintf(buf+off, "\tnh               (hex)Code of Next Header\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    return(off);
-}
-
-
-/*******************************************************************************
-**
-**  sfs_help_mc_ipvx_stream_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_mc_ipvx_stream_add(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "IPV4: echo [owner_id] [stream] [igmp_mode] [mc_stream_pppoe] [vid] [src_ip] [dst_ip] [ignore] [target_ports] > mc_ipv4_stream_add\n");
-	off += sprintf(buf+off, "Creates a new multicast stream\n");
-
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tstream           (dec)Stream number\n");
-	off += sprintf(buf+off, "\tigmp_mode        (dec)0-snooping/1-proxy\n");
-	off += sprintf(buf+off, "\tmc_pppoe         (str)true/false.\n");
-	off += sprintf(buf+off, "\tvid              (dec)Vlan Id. When Id is 65535, MC packet is untagged or do not need MC VID check\n");
-	off += sprintf(buf+off, "\tsrc_ip           Source IP address\n");
-	off += sprintf(buf+off, "\tdst_ip           Destination IP address\n");
-	off += sprintf(buf+off, "\tignore           (str)true/false. When true, the source IP address is not part of the key\n");
-	off += sprintf(buf+off, "\ttarget_ports     (hex)Bitmap of port targets \n");
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_0               %#.5X\n", TPM_TRG_UNI_0);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_1               %#.5X\n", TPM_TRG_UNI_1);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_2               %#.5X\n", TPM_TRG_UNI_2);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_3               %#.5X\n", TPM_TRG_UNI_3);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_4               %#.5X\n", TPM_TRG_UNI_4);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_5               %#.5X\n", TPM_TRG_UNI_5);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_6               %#.5X\n", TPM_TRG_UNI_6);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_7               %#.5X\n", TPM_TRG_UNI_7);
-	off += sprintf(buf+off, "\t\tTPM_TRG_UNI_VIRT            %#.5X\n", TPM_TRG_UNI_VIRT);
-	off += sprintf(buf+off, "\t\tTPM_TRG_PORT_CPU            %#.5X\n", TPM_TRG_PORT_CPU);
-	off += sprintf(buf+off, "\t\tTPM_TRG_PORT_UNI_ANY        %#.5X\n", TPM_TRG_PORT_UNI_ANY);
-
-	off += sprintf(buf+off, "\n\tIPV4 address: dst_ip 224.x.y.z  - 239.x.y.z.  Source address w.x.y.z. Each part is decimal value in range 0..255.\n");
-	off += sprintf(buf+off, "\n\n");
-	off += sprintf(buf+off, "echo [owner_id] [stream] [target_ports] > mc_ipv4_stream_update\n");
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tstream           (dec)Stream number\n");
-	off += sprintf(buf+off, "\ttarget_ports     (hex)Bitmap of port targets - SEE ABOVE\n");
-
-	off += sprintf(buf+off, "\n\n");
-	off += sprintf(buf+off, "echo [owner_id] [stream] [igmp_mode] [mc_stream_pppoe] [vid] [src_ip] [dst_ip] [ignore] [target_queue] [target_ports] > mc_ipv4_stream_set_queue_add\n");
-	off += sprintf(buf+off, "\tdest_queue       (dec)destination queue number\n");
-	off += sprintf(buf+off, "Creates a new multicast stream with specified dest queue number\n");
-
-	off += sprintf(buf+off, "\nIPV6: echo [owner_id] [stream] [igmp_mode] [mc_stream_pppoe] [vid] [src_ip] [dst_ip] [ignore] [target_ports] > mc_ipv6_stream_add\n");
-	off += sprintf(buf+off, "Creates a new multicast stream, params refer to IPv4 MC stream add interface, except dst_ip.\n");
-	off += sprintf(buf+off, "\tIPV6 address: ff00:aabb:bbcc:ccdd:ddee:eeff:1111:2222. Each part is Hex value in range 0..ffff.\n");
-
-	off += sprintf(buf+off, "\n\n");
-	off += sprintf(buf+off, "echo [owner_id] [stream] [igmp_mode] [mc_stream_pppoe] [vid] [src_ip] [dst_ip] [ignore] [target_queue] [target_ports] > mc_ipv6_stream_set_queue_add\n");
-	off += sprintf(buf+off, "\tdest_queue       (dec)destination queue number\n");
-	off += sprintf(buf+off, "Creates a new multicast stream with specified dest queue number\n");
-
-	off += sprintf(buf+off, "\n\n");
-	off += sprintf(buf+off, "echo [owner_id] [stream] [target_ports] > mc_ipv6_stream_update\n");
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tstream           (dec)Stream number\n");
-	off += sprintf(buf+off, "\ttarget_ports     (hex)Bitmap of port targets - SEE ABOVE\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_igmp_cfg - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_igmp_cfg(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [frwd_mode] > igmp_port_forward_mode_cfg\n");
-    off += sprintf(buf+off, "Configures port forward mode\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)Source port - WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\tfrwd_mode        (str)Forwarding mode - drop/frwd/snoop\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [queue] > igmp_cpu_queue_cfg\n");
-    off += sprintf(buf+off, "Configures CPU queue for IGMP\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tqueue            (dec)CPU queue 0-7\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [sa_mac] > igmp_proxy_sa_mac\n");
-    off += sprintf(buf+off, "Configures the sa_mac for IGMP proxy\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsa_mac           (hex)Mac address in format, aa:bb:cc:dd:ee:ff\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] > mc_vid_key_reset\n");
-    off += sprintf(buf+off, "reset the mc_uni_xlate configuration for all the UNI ports\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [src_port] [mc_uni_xlate_mode] [mc_uni_xlate_vid] > mc_vid_key_set\n");
-    off += sprintf(buf+off, "Configures mc_uni_xlate_mode\n");
-    off += sprintf(buf+off, "\tsrc_port                    (str)Source port - UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT\n");
-    off += sprintf(buf+off, "\tmc_uni_xlate_mode           (dec)uni_xlate_mode\n");
-    off += sprintf(buf+off, "\t\texclude             0\n");
-    off += sprintf(buf+off, "\t\ttransparent         1\n");
-    off += sprintf(buf+off, "\t\tstrip               2\n");
-    off += sprintf(buf+off, "\t\ttranslate           3\n");
-    off += sprintf(buf+off, "\tuni_vid                      (dec)mc uni vid\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [mc_vid] > mc_vid_cfg_set\n");
-    off += sprintf(buf+off, "Configures mc vid, first use mc_vid_key_reset, then mc_vid_key_set to set per uni xlate, at last use mc_vid_cfg_set\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tmc_vid           (dec)mc_vid\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_no_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_no_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_l2                - delete L2 rule from hardware\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_l3                - delete L3 rule from hardware\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_ipv4              - delete IPv4 rule from hardware\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_ipv6_dip_acl      - delete a IPv6 DIP ACL\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_ipv6_gen_acl      - delete a IPv6 gen ACL\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_ipv6_l4_ports_acl - delete a IPv6 L4 ports ACL\n");
-    off += sprintf(buf+off, "echo [owner_id] [rule_idx]            > no_rule_add_ipv6_nh_acl       - delete a IPv6 NH ACL\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
-
-    off += sprintf(buf+off, "\necho [owner_id] [src_port] [precedence]    > no_rule_add_ctc_cm_acl  - delete a CTC cm rule from hardware\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)The packet originating source port (UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT)\n");
-    off += sprintf(buf+off, "\tprecedence       (dec)Precedence - 0..7\n");
-
-    off += sprintf(buf+off, "echo [owner_id] [l2key_name]          > no_rule_add_mac_learn         - delete MAC learn rule from hardware\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tl2key_name       (str)Name of L2 key data which define src MAC addr, empty is not allowed\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_no_mc_stream_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_no_mc_stream_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [stream]   > no_mc_stream_add_ipv4   - delete IPV4 multicast stream from hardware\n");
-    off += sprintf(buf+off, "\towner_id   (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tstream     (dec)Stream Id used in the mc create call\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_oam_omci_channel - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_oam_omci_channel(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [rx_q] [llid]             > oam_channel - create OAM management channel\n");
-    off += sprintf(buf+off, "\towner_id   (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trx_q       (dec)Receive queue\n");
-    off += sprintf(buf+off, "\tllid       (hex)LLID for management\n");
-    off += sprintf(buf+off, "\t\tLLID_0  0x01     LLID_1  0x02    LLID_2  0x04     LLID_3  0x08\n");
-    off += sprintf(buf+off, "\t\tLLID_4  0x10     LLID_5  0x20    LLID_6  0x40     LLID_7  0x80\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [gem_port] [rx_q] [tx_q] [tcont] > omci_channel - create OMCI management channel\n");
-    off += sprintf(buf+off, "\towner_id   (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tgem_port   (dec)OMCI gem port\n");
-    off += sprintf(buf+off, "\trx_q       (dec)Receive queue\n");
-    off += sprintf(buf+off, "\ttx_q       (dec)Transmit queue\n");
-    off += sprintf(buf+off, "\ttcont      (hex)T-CONT for management\n");
-    off += sprintf(buf+off, "\t\tTCONT_0  0x01     TCONT_1  0x02    TCONT_2  0x04     TCONT_3  0x08\n");
-    off += sprintf(buf+off, "\t\tTCONT_4  0x10     TCONT_5  0x20    TCONT_6  0x40     TCONT_7  0x80\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_no_oam_omci_channel - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_no_oam_omci_channel(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] > no_oam_channel   - delete OAM management channel from hardware\n");
-    off += sprintf(buf+off, "echo [owner_id] > no_omci_channel  - delete OMCI management channel from hardware\n");
-    off += sprintf(buf+off, "\towner_id   (dec)Application owner ID\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_setup - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_setup(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [owner_id] [wan_type] [filename] > setup   - tpm setup \n");
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\t[wan_type]       (dec)EPON 0 or GPON 1\n");
-	off += sprintf(buf+off, "\t[filename]       FILENAME/default\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_mib_reset - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_mib_reset(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [reset_level] > mib_reset   - MIB reset\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[reset_level]    (dec)Reset level 0 or 1\n");
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_help_set_active_wan - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_set_active_wan(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [active_wan] > set_active_wan\n");
-    off += sprintf(buf+off, "\t[owner_id]      (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[active_wan]    (dec)GMAC0: 0; GMAC1: 1; PON: 2\n");
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_help_hot_swap_profile - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_hot_swap_profile(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [profile_id] > hot_swap_profile\n");
-    off += sprintf(buf+off, "before hot swap profile, eth0, eth1 and pon0 must be taken down by ifconfig command; and be bring up after\n");
-    off += sprintf(buf+off, "\t[owner_id]      (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[profile_id]    (dec)TPM_G0_WAN_G1_INT_SWITCH: %d; TPM_G1_WAN_G0_INT_SWITCH: %d\n",
-			TPM_G0_WAN_G1_INT_SWITCH, TPM_G1_WAN_G0_INT_SWITCH);
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_help_set_port_hwf_admin - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_set_port_hwf_admin(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [port] [txp] [enable] > set_port_hwf_admin\n");
-    off += sprintf(buf+off, "disable/enable HWF to port\n");
-    off += sprintf(buf+off, "\t[owner_id]      (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[port]          (dec)GMAC0: 0; GMAC1: 1; PON: 2\n");
-    off += sprintf(buf+off, "\t[txp]           (dec)T-CONT or LLID, for GMAC0/1 it should be 0\n");
-    off += sprintf(buf+off, "\t[enable]        (dec)disable: 0; enable: 1\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_erase_section - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_erase_section(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [api_type] > erase_section   - erase spceified API section\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_type]       (dec)the API PnC section to be deleted\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_flush_vtu - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_flush_vtu(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] > flush_vtu   - flush VTU on Switch\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_flush_atu - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_flush_atu(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] > flush_atu   - flush ATU on Switch\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tflush_type       (dec)0-flush all/1-flush dynamic\n");
-    off += sprintf(buf+off, "\tdb_num           (dec)only 0 is valid since there is only one ATU db\n");
-
-    return(off);
-}
-
-
-/*******************************************************************************
-**
-**  sfs_help_cfg_cpu_lpbk - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_cfg_cpu_lpbk(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [trg_port] [trg_queue] [gem port]  > add_cpu_lpbk   - Add CPU WAN loopback\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[trg_port ]       (hex)tcont/llid bitmap, 0x01:tcont0/llid0,..., 0x80: tcont7/llid7\n");
-    off += sprintf(buf+off, "\t[trg_queue]       (dec)Target queue number, 0~7\n");
-    off += sprintf(buf+off, "\t[gem port ]       (dec)GEM port number, 0<gem port<4096, fill 0 in EPON mode\n");
-    off += sprintf(buf+off, "echo [owner_id] [trg_port] [trg_queue] [gem port]  > del_cpu_lpbk   - Del CPU WAN loopback\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[trg_port ]       (hex)tcont/llid bitmap, 0x01:tcont0/llid0,..., 0x80: tcont7/llid7\n");
-    off += sprintf(buf+off, "\t[trg_queue]       (dec)Target queue number, 0~7\n");
-    off += sprintf(buf+off, "\t[gem port ]       (dec)GEM port number, 0<gem port<4096, fill 0 in EPON mode\n");
-    off += sprintf(buf+off, "echo [owner_id]                                    > dump_cpu_lpbk  - Dump all valid loopback entry from DB \n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_cfg_age_count - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_cfg_age_count(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [api_group] [lu_num] [lu_reset]        > get_lu_entry   - Get least used PnC entires\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-    off += sprintf(buf+off, "\t[lu_num   ]       (dec)required LU number queue number, 1~100\n");
-    off += sprintf(buf+off, "\t[lu_reset ]       (dec)Whether need to reset PnC aging counter after read it.1: reset after read, 0: do not reset\n");
-    off += sprintf(buf+off, "echo [owner_id] [api_group] [rule_idx] [lu_rule_mask]  > set_count_mask  - Set least used mask of specific PnC entry\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-    off += sprintf(buf+off, "\t[rule_idx ]       (dec)rule index returned when add L2/L3/L4 PnC rules\n");
-    off += sprintf(buf+off, "\t[lu_rule_mask]    (dec)Whether need to mask least used loopup for specific PnC rule.1: mask, 0: enable\n");
-    off += sprintf(buf+off, "echo [owner_id] [api_group] [rule_idx] [hit_reset]     > get_hit_count   - Get hitted counter for specific PnC rules\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-    off += sprintf(buf+off, "\t[rule_idx ]       (dec)rule index returned when add L2/L3/L4 PnC rules\n");
-    off += sprintf(buf+off, "echo [owner_id] [api_group] [lu_thresh_pkts]           > set_lu_thresh   - Set least used threshold for specific counter group\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-    off += sprintf(buf+off, "\t[lu_thresh_pkts ] (dec)Least used lookup threshold in number of packets, 0~67108863\n");
-    off += sprintf(buf+off, "echo [owner_id] [api_group]                            > reset_age_group - Reset aging counter for all the PnC rules in one couter group\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-
-    off += sprintf(buf+off, "echo [owner_id] [api_group] [high_thresh_pkts] [counters_reset] [valid_counters] > get_all_hit_counters - Get all PnC  entires for the API group lower than threshold\n");
-    off += sprintf(buf+off, "\t[owner_id ]       (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\t[api_group]       (dec)PnC API group, supported TPM API group,l2[%d], L3[%d], L4[%d] \n", TPM_API_L2_PRIM, TPM_API_L3_TYPE, TPM_API_IPV4);
-    off += sprintf(buf+off, "\t[high_thresh_pkts](dec)counter high threshold watermark\n");
-    off += sprintf(buf+off, "\t[counters_reset]  (dec)Whether need to reset PnC aging counter after read it.1: reset after read, 0: do not reset\n");
-    off += sprintf(buf+off, "\t[valid_counters]  (dec)The number of entries to read, returns the actually read counters\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_rate_limit - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_rate_limit(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [direction] [sched_entity] [que] [rate_limit] [bucket_size]  > rate_limit_queue_set -  set queue rate limit\n");
-    off += sprintf(buf+off, "\towner_id        (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tdirection       Upstream or downstream (us/ds)\n");
-    off += sprintf(buf+off, "\tsched_entity    WAN/TCONT_0/TCONT_1/../TCONT_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\tque             (dec)Queue id - 0..7\n");
-    off += sprintf(buf+off, "\trate_limit      (dec)> 64\n");
-    off += sprintf(buf+off, "\tbucket_size     (dec)TBD\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [direction] [sched_entity] [rate_limit] [bucket_size]  > rate_limit_if_set   - set interface rate limit\n");
-    off += sprintf(buf+off, "\towner_id        Application owner ID\n");
-    off += sprintf(buf+off, "\tdirection       Upstream or downstream (us/ds)\n");
-    off += sprintf(buf+off, "\tsched_entity    WAN/TCONT_0/TCONT_1/../TCONT_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\trate_limit      (dec)> 64\n");
-    off += sprintf(buf+off, "\tbucket_size     (dec)TBD\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [direction] [sched_entity] [mode] [que] [wrr_weight] > scheduling_mode_queue_set   - configure queue scheduling mode\n");
-    off += sprintf(buf+off, "\towner_id        Application owner ID\n");
-    off += sprintf(buf+off, "\tdirection       Upstream or downstream (us/ds)\n");
-    off += sprintf(buf+off, "\tsched_entity    WAN/TCONT_0/TCONT_1/../TCONT_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\tmode            Strict or weighted round robin - strict/wrr \n");
-    off += sprintf(buf+off, "\tque             (dec)Queue id - 0..7\n");
-    off += sprintf(buf+off, "\twrr_weight      (dec)Weight for wrr\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [owner_id] [rate_limit] [bucket_size] > gmac0_ingr_rate_limit_set - set ingress rate limit for GMAC0 only when no switch init\n");
-    off += sprintf(buf+off, "\towner_id        (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\trate_limit      (dec)> 64\n");
-    off += sprintf(buf+off, "\tbucket_size     (dec)TBD\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [thresh_high] [thresh_low] [port] [tx_port] [tx_queue] [tgt_port] > "
-					"fc_config_set   - configure CPU port flow control\n");
-    off += sprintf(buf+off, "\tthresh_high     (dec)High threshold (decriptors amount)\n");
-    off += sprintf(buf+off, "\tthresh_low      (dec)Low threshold (decriptors amount)\n");
-    off += sprintf(buf+off, "\tport            (dec)Port to monitor \n");
-    off += sprintf(buf+off, "\ttx_port         (dec)TX port\n");
-    off += sprintf(buf+off, "\ttx_queue        (dec)TX queue\n");
-    off += sprintf(buf+off, "\ttgt_port        (dec)Port to apply FC\n");
-
-    off += sprintf(buf+off, "\n");
-    off += sprintf(buf+off, "echo [us_period] > fc_us_period_set - configure flow control period\n");
-    off += sprintf(buf+off, "\tus_period       (dec)Flow control engine monitoring priod (us)\n");
-    off += sprintf(buf+off, "\n");
-#ifdef TPM_FC_DEBUG
-    off += sprintf(buf+off, "echo [oneshot_hits] > fc_oneshot_set - configure oneshot statistic count\n");
-    off += sprintf(buf+off, "\toneshot_hits    (dec)Flow control engine monitoring oneshot statistics hits count\n");
-    off += sprintf(buf+off, "\t                Setting this value to 0 resets oneshot statistics counters\n");
-    off += sprintf(buf+off, "\n");
-#endif
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_pkt_mod_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_pkt_mod_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo  [trg_port] [mod_bm] [flag] [mod_name] > pkt_mod_eng_entry_add   - add packet modification to mod rule\n");
-    off += sprintf(buf+off, "\ttrg_port   Target port - WAN/TCONT_0/TCONT_1/TCONT_2/TCONT_3/TCONT_4/TCONT_5/TCONT_6/TCONT_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\tmod_bm     (hex)Modification bitmap:\n");
-
-    /* VLAN Operation only */
-    off += sprintf(buf+off, "\t\t0x%05x - VLAN\n", TPM_VLAN_MOD);
-
-    /* IPv4 Napt */
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL | SIP | L4_SRC\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL | DIP | L4_DST\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | SIP | L4_SRC | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | DIP | L4_DST | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE ADD | SIP | L4_SRC | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | DIP | L4_DST | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE ADD | SIP | L4_SRC | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | DIP | L4_DST | TTL\n",
-        TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET);
-
-    /* IPv6 Route */
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE ADD | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE DEL | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE ADD | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-
-    /* IPv4 Route */
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE ADD | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE ADD | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-
-    /* (IPv4) Multicast */
-    off += sprintf(buf+off, "\t\t0x%05x - MH\n", TPM_MH_SET);
-    off += sprintf(buf+off, "\t\t0x%05x - MH | VLAN\n", TPM_MH_SET | TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | MH | SA | TTL\n", TPM_MH_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | MH | SA | VLAN | TTL\n", TPM_MH_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | MH | DA | SA | PPPoE DEL | TTL\n", TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | MH | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | SA | TTL\n", TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | SA | VLAN | TTL\n", TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE);
-
-	/* (IPv6) Multicast */
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | MH | SA | HOPLIM\n", TPM_MH_SET | TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | MH | SA | VLAN | HOPLIM\n", TPM_MH_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | MH | DA | SA | PPPoE DEL | HOPLIM\n", TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | MH | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | SA | HOPLIM\n", TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | SA | VLAN | HOPLIM\n", TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE DEL | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-    off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE);
-
-    off += sprintf(buf+off, "\tflag       (hex)Additional packet data:\n");
-    off += sprintf(buf+off, "\t\t0x%03x - TCP\n", TPM_INT_L4_TCP);
-    off += sprintf(buf+off, "\t\t0x%03x - UDP\n", TPM_INT_L4_UDP);
-    off += sprintf(buf+off, "\t\t0x%03x - Split modification flag\n", TPM_INT_SPLIT_MOD);
-    off += sprintf(buf+off, "\t\t0x%03x - Update UDP checksum\n", TPM_INT_UDP_CHECKSUM);
-    off += sprintf(buf+off, "\t\t0x%03x - Multicast modification\n", TPM_INT_MC_MOD);
-
-    off += sprintf(buf+off, "\tmod_name   Name of pkt modification data which has been defined by user\n");
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_pkt_mod_eng - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_pkt_mod_get_del_purge(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo  [trg_port] [mod_idx]       > pkt_mod_eng_entry_del   - delete packet modification from mod rule\n");
-    off += sprintf(buf+off, "echo  [trg_port] [mod_idx]       > pkt_mod_eng_entry_show  - show packet modification\n");
-    off += sprintf(buf+off, "echo  [trg_port]                 > pkt_mod_eng_purge       - delete all packet modifications for given port\n");
-    off += sprintf(buf+off, "\ttrg_port   Target port - WAN/TCONT_0/TCONT_1/TCONT_2/TCONT_3/TCONT_4/TCONT_5/TCONT_6/TCONT_7/UNI_ANY\n");
-    off += sprintf(buf+off, "\tmod_idx    (dec)Modification entry returned from pkt_mod_eng_entry_add\n");
-
-    return(off);
-}
-
-/* jinghuaxxxxxx */
-/*******************************************************************************
-**
-**  sys_help_ipv6_dip_acl_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sys_help_ipv6_dip_acl_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [key_name] [frwd_name] [mod_name] > ipv6_dip_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_DIP              %#.4X\n", TPM_IPv6_PARSE_DIP);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_TRUE        %#.4X\n", TPM_PARSE_FLAG_TAG1_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TAG1_FALSE       %#.4X\n", TPM_PARSE_FLAG_TAG1_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.2X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.2X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (done)\n");
-
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\t\tTPM_VLAN_MOD                    %#.4X\n", TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\tThis is the only packet modification supported in this version. \n");
-
-    off += sprintf(buf+off, "\tkey_name         (str)Name of IPv6 key data which has been defined by user [or ipv6_dip_key_empty]\n");
-
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-    return(off);
-}
-
-#if 0
- int sys_help_del_ipv6_dip_acl_rule          (char *buf)
-{
-     int off = 0;
-
-     off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_idx] [parse_rule_bm] [l2_key_name]    > no_rule_add_l2   - delete L2 rule from hardware\n");
-     off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_idx] [parse_rule_bm] [l3_key_name]    > no_rule_add_l3   - delete L3 rule from hardware\n");
-     off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_idx] [parse_rule_bm] [ipv4_key_name]  > no_rule_add_ipv4 - delete IPV4 rule from hardware\n");
-     off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_idx] [parse_rule_bm] [ipv6_key_name]  > no_rule_add_ipv6 - delete IPV6 rule from hardware\n");
-     off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-     off += sprintf(buf+off, "\tsrc_port         WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_ANY\n");
-     off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
-     off += sprintf(buf+off, "\tparse_rule_bm    (hex)Parsing fields bitmap used when the rule was created\n");
-     off += sprintf(buf+off, "\tkey_name         The key name used when the rule was created\n");
-     off += sprintf(buf+off, "\necho [owner_id] [rule_idx]  > no_rule_add_dscp_ipv4 - delete DSCP IPV4 rule from hardware\n");
-     off += sprintf(buf+off, "echo [owner_id] [rule_idx]  > no_rule_add_dscp_ipv6 - delete DSCP IPV6 rule from hardware\n");
-     off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-     off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
-
-
-     off += sprintf(buf+off, "rule del ipv6 <owner_id> <src_port> <rule_index> \n");
-     off += sprintf(buf+off, "delete an existing IPv6 processing ACL\n");
-
-     off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-     off += sprintf(buf+off, "\tsrc_port          (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_ANY)\n");
-     off += sprintf(buf+off, "\rule_index         (dec)Entry index was given when adding the ACL\n");
-
-    return(off);
-}
-int sys_help_del_ipv6_l4_ports_acl_rule     (char *buf)
- {
-      int off = 0;
-
-      off += sprintf(buf+off, "rule del ipv6 <owner_id>  <rule_index> \n");
-      off += sprintf(buf+off, "delete an existing IPv6 l4 processing ACL\n");
-
-      off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-      off += sprintf(buf+off, "\tsrc_port          (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_ANY)\n");
-      off += sprintf(buf+off, "\rule_index         (dec)Entry index was given when adding the ACL\n");
-
-     return(off);
- }
-
-#endif
-/*******************************************************************************
-**
-**  sfs_help_pkt_mod_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_l4_ports_rule_add     (char *buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_port] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [l4_src_port] [l4_dst_port] [mod_bm] [frwd_name] [mod_name] > ipv6_l4_ports_acl_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 l4 processing ACL\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_port         (str)The packet originating source port (WAN/UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT/UNI_ANY)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                %#.4X\n", TPM_PARSE_L4_SRC);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                %#.4X\n", TPM_PARSE_L4_DST);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE         %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE        %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_TRUE      %#.4X\n", TPM_PARSE_FLAG_TO_CPU_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_TO_CPU_FALSE     %#.4X\n", TPM_PARSE_FLAG_TO_CPU_FALSE);
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK              %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD          %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_TO_CPU               %#.2X\n", TPM_ACTION_TO_CPU);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_CUST_CPU_PKT_PARSE   %#.2X\n", TPM_ACTION_CUST_CPU_PKT_PARSE);
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv6_gen/ctc_cm/done)\n");
-    off += sprintf(buf+off, "\tl4_src_port      (dec)L4 source port\n");
-    off += sprintf(buf+off, "\tl4_dst_port      (dec)L4 destination port\n");
-
-
-
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\t\tTPM_VLAN_MOD                    %#.4X\n", TPM_VLAN_MOD);
-    off += sprintf(buf+off, "\t\tThis is the only packet modification supported in this version. \n");
-
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-
-    return(off);
- }
-
-/*******************************************************************************
-**
-**  sfs_help_delete_entry_rule_table - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_delete_entry_rule_table(char *buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [rule_name]     > delete_entry_frwd_rule_table                - delete a forwarding rule entry\n");
-    off += sprintf(buf+off, "echo [rule_name]     > delete_entry_mod_rule_table                 - delete a modification rule entry\n");
-    off += sprintf(buf+off, "echo [rule_name]     > delete_entry_vlan_rule_table                - delete a VLAN rule entry\n");
-    off += sprintf(buf+off, "echo [l2key_name]    > delete_entry_l2_rule_table                  - delete a L2 key entry\n");
-    off += sprintf(buf+off, "echo [l3key_name]    > delete_entry_l3_rule_table                  - delete a L3 key entry\n");
-    off += sprintf(buf+off, "echo [ipv4key_name]  > delete_entry_ipv4_rule_table                - delete a ipv4 key entry\n");
-    off += sprintf(buf+off, "echo [ipv6_gen]      > delete_entry_ipv6_gen_rule_table            - delete a ipv6_gen key entry\n");
-    off += sprintf(buf+off, "echo [ipv6_dip]      > delete_entry_ipv6_dip_rule_table            - delete a ipv6_dip key entry\n");
-    off += sprintf(buf+off, "echo [ipv6_l4]       > delete_entry_ipv6_l4_rule_table             - delete a ipv6_l4 key entry\n");
-
-    return(off);
-}
-
-
-int sfs_help_send_genquery_to_uni(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [target_ports]	[pkt_num]  > send_genquery_to_uni\n");
-	off += sprintf(buf+off, "send general query to uni ports\n");
-    off += sprintf(buf+off, "\ttarget_ports                  (hex)Bitmap of port targets \n");
-    off += sprintf(buf+off, "\t\tTPM_TRG_UNI_0               %#.4X\n", TPM_TRG_UNI_0);
-    off += sprintf(buf+off, "\t\tTPM_TRG_UNI_1               %#.4X\n", TPM_TRG_UNI_1);
-    off += sprintf(buf+off, "\t\tTPM_TRG_UNI_2               %#.4X\n", TPM_TRG_UNI_2);
-    off += sprintf(buf+off, "\t\tTPM_TRG_UNI_3               %#.4X\n", TPM_TRG_UNI_3);
-    off += sprintf(buf+off, "\t\tTPM_TRG_UNI_4               %#.4X\n", TPM_TRG_UNI_4);
-    off += sprintf(buf+off, "\t\tTPM_TRG_PORT_UNI_ANY        %#.4X\n", TPM_TRG_PORT_UNI_ANY);
-	off += sprintf(buf+off, "\tpkt_num                       (dec)general query packet number send to each UNI port\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_gen_5t_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_gen_5t_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_dir] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [l4_key_name] [gen_key_name] [frwd_name] [mod_name] > ipv6_gen_5t_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 SIP processing rule of 5-tuple\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_dir          (str)The packet direction (US/DS)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                 %#.4X\n", TPM_PARSE_L4_SRC);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                 %#.4X\n", TPM_PARSE_L4_DST);
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_SIP               %#.4X\n", TPM_IPv6_PARSE_SIP);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_UDP            %#.4X\n", TPM_PARSE_FLAG_L4_UDP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_TCP            %#.4X\n", TPM_PARSE_FLAG_L4_TCP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE          %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE         %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_TRUE        %#.4X\n", TPM_PARSE_FLAG_PPPOE_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_FALSE       %#.4X\n", TPM_PARSE_FLAG_PPPOE_FALSE);
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK               %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT       %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE      %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD           %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv6_dip/done)\n");
-
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\tl4_key_name      (str)Name of IPv6 l4 ports key data which has been defined by user [or ipv6_l4_key_empty]\n");
-    off += sprintf(buf+off, "\tgen_key_name     (str)Name of IPv6 gen key data which has been defined by user [or ipv6_gen_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_dip_5t_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_dip_5t_rule_add(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_dir] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [l4_key_name] [gen_key_name] [dip_key_name] [frwd_name] [mod_name] > ipv6_dip_5t_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 DIP processing rule of 5-tuple\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_dir          (str)The packet direction (US/DS)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                 %#.4X\n", TPM_PARSE_L4_SRC);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                 %#.4X\n", TPM_PARSE_L4_DST);
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_SIP               %#.4X\n", TPM_IPv6_PARSE_SIP);
-    off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_DIP               %#.4X\n", TPM_IPv6_PARSE_DIP);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_UDP            %#.4X\n", TPM_PARSE_FLAG_L4_UDP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_TCP            %#.4X\n", TPM_PARSE_FLAG_L4_TCP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE          %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE         %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_TRUE        %#.4X\n", TPM_PARSE_FLAG_PPPOE_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_FALSE       %#.4X\n", TPM_PARSE_FLAG_PPPOE_FALSE);
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK               %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT       %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE      %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD           %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (done)\n");
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\tl4_key_name      (str)Name of IPv6 key data which has been defined by user [or ipv6_l4_key_empty]\n");
-    off += sprintf(buf+off, "\tgen_key_name     (str)Name of IPv6 key data which has been defined by user [or ipv6_gen_key_empty]\n");
-    off += sprintf(buf+off, "\tdip_key_name     (str)Name of IPv6 key data which has been defined by user [or ipv6_dip_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ipv6_l4_ports_5t_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ipv6_l4_ports_5t_rule_add(char *buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [src_dir] [rule_num] [parse_rule_bm] [parse_flags_bm] [action] [next_phase] [mod_bm] [l4_key_name] [frwd_name] [mod_name] > ipv6_l4_ports_5t_rule_add\n");
-    off += sprintf(buf+off, "Creates a new IPv6 L4 ports processing rule of 5-tuple\n");
-
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tsrc_dir          (str)The packet direction (US/DS)\n");
-    off += sprintf(buf+off, "\trule_num         (dec)Entry number to be added to the current ACL\n");
-
-    off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                 %#.4X\n", TPM_PARSE_L4_SRC);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                 %#.4X\n", TPM_PARSE_L4_DST);
-
-    off += sprintf(buf+off, "\tparse_flags_bm   (hex)Bitmap containing the significant flags result of the primary ACL filtering\n");
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_UDP            %#.4X\n", TPM_PARSE_FLAG_L4_UDP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_L4_TCP            %#.4X\n", TPM_PARSE_FLAG_L4_TCP);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_TRUE          %#.4X\n", TPM_PARSE_FLAG_MTM_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_MTM_FALSE         %#.4X\n", TPM_PARSE_FLAG_MTM_FALSE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_TRUE        %#.4X\n", TPM_PARSE_FLAG_PPPOE_TRUE);
-    off += sprintf(buf+off, "\t\tTPM_PARSE_FLAG_PPPOE_FALSE       %#.4X\n", TPM_PARSE_FLAG_PPPOE_FALSE);
-
-    off += sprintf(buf+off, "\taction           (hex)Action associated with the rule:\n");
-    off += sprintf(buf+off, "\t\tTPM_ACTION_DROP_PK               %#.2X\n", TPM_ACTION_DROP_PK);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT       %#.2X\n", TPM_ACTION_SET_TARGET_PORT);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE      %#.2X\n", TPM_ACTION_SET_TARGET_QUEUE);
-    off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD           %#.2X\n", TPM_ACTION_SET_PKT_MOD);
-
-    off += sprintf(buf+off, "\tnext_phase       (str)Parse stage (ipv6_gen/ctc_cm/done)\n");
-    off += sprintf(buf+off, "\tmod_bm           (hex)Packet fields modification command bitmap:\n");
-    off += sprintf(buf+off, "\tl4_key_name      (str)Name of IPv6 key data which has been defined by user [or ipv6_l4_key_empty]\n");
-    off += sprintf(buf+off, "\tfrwd_name        (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-    off += sprintf(buf+off, "\tmod_name         (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
-
-    return(off);
- }
-
-/*******************************************************************************
-**
-**  sfs_help_ctc_cm_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ctc_cm_rule_add(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [owner_id] [src_port] [precedence] [l2_parse_rule_bm] [ipv4_parse_rule_bm] [action] [l2_key_name] [ipv4_key_name] [frwd_name] [p_bits] > ctc_cm_acl_rule_add\n");
-	off += sprintf(buf+off, "Creates a CTC CnM rule\n");
-
-	off += sprintf(buf+off, "\towner_id           (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tsrc_port           (str)The packet originating source port (UNI_0/UNI_1/UNI_2/UNI_3/UNI_4/UNI_5/UNI_6/UNI_7/UNI_VIRT)\n");
-	off += sprintf(buf+off, "\tprecedence         (dec)Precedence - 0..7\n");
-
-	off += sprintf(buf+off, "\tl2_parse_rule_bm   (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
-	off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_DA             %#.4X\n", TPM_L2_PARSE_MAC_DA);
-	off += sprintf(buf+off, "\t\tTPM_L2_PARSE_MAC_SA             %#.4X\n", TPM_L2_PARSE_MAC_SA);
-	off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ONE_VLAN_TAG       %#.4X\n", TPM_L2_PARSE_ONE_VLAN_TAG);
-	off += sprintf(buf+off, "\t\tTPM_L2_PARSE_ETYPE              %#.4X\n", TPM_L2_PARSE_ETYPE);
-
-	off += sprintf(buf+off, "\tipv4_parse_rule_bm (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-	off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_SIP                 %#.4X\n", TPM_IPv4_PARSE_SIP);
-	off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_DIP                 %#.4X\n", TPM_IPv4_PARSE_DIP);
-	off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_DSCP                %#.4X\n", TPM_IPv4_PARSE_DSCP);
-	off += sprintf(buf+off, "\t\tTPM_IPv4_PARSE_PROTO               %#.4X\n", TPM_IPv4_PARSE_PROTO);
-	off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                   %#.4X\n", TPM_PARSE_L4_SRC);
-	off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                   %#.4X\n", TPM_PARSE_L4_DST);
-
-	off += sprintf(buf+off, "\taction	           (hex)Action associated with the rule:\n");
-	off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_PORT      %#.4X\n", TPM_ACTION_SET_TARGET_PORT);
-	off += sprintf(buf+off, "\t\tTPM_ACTION_SET_TARGET_QUEUE     %#.4X\n", TPM_ACTION_SET_TARGET_QUEUE);
-	off += sprintf(buf+off, "\t\tTPM_ACTION_SET_PKT_MOD	        %#.4X\n", TPM_ACTION_SET_PKT_MOD);
-
-	off += sprintf(buf+off, "\tl2_key_name        (str)Name of L2 key data which has been defined by user [or l2_key_empty]\n");
-	off += sprintf(buf+off, "\tipv4_key_name      (str)Name of IPV4 key data which has been defined by user [or ipv4_key_empty]\n");
-	off += sprintf(buf+off, "\tfrwd_name          (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
-	off += sprintf(buf+off, "\tp_bits             (dec)P_bit  - 0..7\n");
-
-	off += sprintf(buf+off, "\necho [owner_id] [src_port] [precedence] [ipv6_parse_rule_bm] [action] [ipv6_key_name] [frwd_name] [p_bits] > ctc_cm_ipv6_acl_rule_add\n");
-	off += sprintf(buf+off, "Creates a CTC CnM rule\n");
-
-	off += sprintf(buf+off, "\towner_id           (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tparse_rule_bm    (hex)Bitmap containing the significant flags for parsing fields of the packet\n");
-	off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_SIP              %#.4X\n", TPM_IPv6_PARSE_SIP);
-	off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_DIP              %#.4X\n", TPM_IPv6_PARSE_DIP);
-	off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_DSCP             %#.4X\n", TPM_IPv6_PARSE_DSCP);
-	off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_NH               %#.4X\n", TPM_IPv6_PARSE_NH);
-	off += sprintf(buf+off, "\t\tTPM_IPv6_PARSE_HOPL             %#.4X\n", TPM_IPv6_PARSE_HOPL);
-	off += sprintf(buf+off, "\t\tTPM_PARSE_L4_SRC                %#.4X\n", TPM_PARSE_L4_SRC);
-	off += sprintf(buf+off, "\t\tTPM_PARSE_L4_DST                %#.4X\n", TPM_PARSE_L4_DST);
-
-	return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_ctc_cm_set_ipv6_parse_win - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_ctc_cm_set_ipv6_parse_win(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "echo [owner_id] [ipv6_parse_win] > ctc_cm_set_ipv6_parse_win   - set ipv6 parse window\n");
-    off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-    off += sprintf(buf+off, "\tipv6_parse_win   (dec)ipv6 parse window\n");
-    off += sprintf(buf+off, "\t\tTPM_CTC_CM_IPv6_FIRST_24B	 %d\n", TPM_CTC_CM_IPv6_FIRST_24B);
-    off += sprintf(buf+off, "\t\tTPM_CTC_CM_IPv6_SECOND_24B	 %d\n", TPM_CTC_CM_IPv6_SECOND_24B);
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_help_tpm_self_check - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_tpm_self_check(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [owner_id] [check_level] > tpm_self_check   - tpm rules check\n");
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\t[check_level]    (dec)0: check without correct; 1: check with correct\n");
-
-	return(off);
-}
-
-
-/*******************************************************************************
-**
-**  sfs_help_mac_learn_rule_add - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_mac_learn_rule_add(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [owner_id] [l2_key_name] > mac_learn_rule_add\n");
-	off += sprintf(buf+off, "Creates a new L2 MAC learn rule ACL\n");
-	off += sprintf(buf+off, "\towner_id         (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tl2_key_name      (str)Name of L2 key data which define src MAC addr, empty is not allowed \n");
-
-	return(off);
-
-}
-
-/*******************************************************************************
-**
-**  sfs_help_mac_learn_def_act_set - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_help_mac_learn_def_act_set(char* buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [owner_id] [mac_conf] > mac_learn_default_rule_act_set\n");
-	off += sprintf(buf+off, "Set the action of mac learn default rule\n");
-	off += sprintf(buf+off, "\towner_id        (dec)Application owner ID\n");
-	off += sprintf(buf+off, "\tmac_conf        (hex)Action associated with mac learn default rule: \n");
-	off += sprintf(buf+off, "\t\tTPM_UNK_MAC_TRAP,     (trap packet to CPU)     %#.2X\n", TPM_UNK_MAC_TRAP);
-	off += sprintf(buf+off, "\t\tTPM_UNK_MAC_DROP,     (drop the packet)        %#.2X\n", TPM_UNK_MAC_DROP);
-	off += sprintf(buf+off, "\t\tTPM_UNK_MAC_CONTINUE, (frwd packet to GMAC1)   %#.2X\n", TPM_UNK_MAC_CONTINUE);
-
-	return(off);
-
-}
-
-
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.h
deleted file mode 100644
index 15de3bb..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_help.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_usr_tpmsysfs_help.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Zeev
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_TPM_SYSFS_HELP_H_
-#define _TPM_USR_TPM_SYSFS_HELP_H_
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-extern int sfs_tpm_cfg_index                (char *buf);
-extern int sfs_help_frwd_rule_cfg           (char *buf);
-extern int sfs_help_vlan_rule_cfg           (char *buf);
-extern int sfs_help_mod_rule_cfg            (char *buf);
-extern int sfs_help_l2_key_cfg              (char *buf);
-extern int sfs_help_l3_key_cfg              (char *buf);
-extern int sfs_help_ipv4_key_cfg            (char *buf);
-extern int sfs_help_mtu_cfg                 (char *buf);
-extern int sfs_help_ipv6_gen_key_cfg        (char *buf);
-extern int sfs_help_rule_table_display      (char *buf);
-extern int sfs_help_ipv6_dip_key_cfg        (char *buf);
-extern int sfs_help_ipv6_l4_key_cfg         (char *buf);
-extern int sfs_help_ipv6_ctc_cm_key_cfg     (char *buf);
-extern int sfs_help_ds_load_balance_rule    (char* buf);
-extern int sfs_help_key_rule_delete         (char *buf);
-extern int sfs_help_l2_rule_add             (char *buf);
-extern int sfs_help_l3_rule_add             (char *buf);
-extern int sfs_help_ipv4_rule_add           (char *buf);
-extern int sfs_help_ipv6_gen_rule_add       (char *buf);
-extern int sfs_help_ipv6_nh_rule_add        (char *buf);
-extern int sfs_help_mc_ipvx_stream_add      (char *buf);
-extern int sfs_help_igmp_cfg                (char *buf);
-extern int sfs_help_no_rule_add             (char *buf);
-extern int sfs_help_no_mc_stream_add        (char *buf);
-extern int sfs_help_oam_omci_channel        (char *buf);
-extern int sfs_help_no_oam_omci_channel     (char *buf);
-extern int sfs_help_setup                   (char *buf);
-extern int sfs_help_mib_reset               (char *buf);
-extern int sfs_help_set_active_wan          (char *buf);
-extern int sfs_help_hot_swap_profile    (char* buf);
-extern int sfs_help_set_port_hwf_admin(char* buf);
-extern int sfs_help_cfg_cpu_lpbk            (char *buf);
-extern int sfs_help_cfg_age_count           (char *buf);
-extern int sfs_help_rate_limit              (char *buf);
-extern int sfs_help_pkt_mod_add             (char *buf);
-extern int sfs_help_pkt_mod_get_del_purge   (char *buf);
-
-/* jinghuaxxxxxx */
-extern int sys_help_ipv6_dip_acl_rule_add   (char *buf);
-//extern int sys_help_del_ipv6_dip_acl_rule (char *buf);
-extern int sfs_help_ipv6_l4_ports_rule_add  (char *buf);
-
-extern int sfs_help_delete_entry_rule_table (char *buf);
-extern int sfs_help_send_genquery_to_uni    (char *buf);
-
-//extern int sys_help_del_ipv6_l4_ports_acl_rule  (char *buf);
-/* jinghuaxxxxxx */
-
-extern int sfs_help_ipv6_gen_5t_rule_add     (char *buf);
-extern int sfs_help_ipv6_dip_5t_rule_add     (char *buf);
-extern int sfs_help_ipv6_l4_ports_5t_rule_add(char *buf);
-extern int sfs_help_ctc_cm_set_ipv6_parse_win(char *buf);
-
-extern int sfs_help_ctc_cm_rule_add         (char *buf);
-
-extern int sfs_help_erase_section           (char *buf);
-extern int sfs_help_tpm_self_check          (char* buf);
-extern int sfs_help_flush_vtu               (char *buf);
-extern int sfs_help_flush_atu               (char *buf);
-extern int sfs_help_mac_learn_rule_add      (char *buf);
-extern int sfs_help_mac_learn_def_act_set   (char* buf);
-#else
-
-#define  sfs_tpm_cfg_index                NULL
-#define  sfs_help_frwd_rule_cfg           NULL
-#define  sfs_help_vlan_rule_cfg           NULL
-#define  sfs_help_mod_rule_cfg            NULL
-#define  sfs_help_l2_key_cfg              NULL
-#define  sfs_help_l3_key_cfg              NULL
-#define  sfs_help_ipv4_key_cfg            NULL
-#define  sfs_help_mtu_cfg                 NULL
-#define  sfs_help_ipv6_gen_key_cfg        NULL
-#define  sfs_help_rule_table_display      NULL
-#define  sfs_help_ipv6_ctc_cm_key_cfg     NULL
-#define  sfs_help_ipv6_dip_key_cfg        NULL
-#define  sfs_help_ipv6_l4_key_cfg         NULL
-#define  sfs_help_key_rule_delete         NULL
-#define  sfs_help_l2_rule_add             NULL
-#define  sfs_help_l3_rule_add             NULL
-#define  sfs_help_ipv4_rule_add           NULL
-#define  sfs_help_ipv6_gen_rule_add       NULL
-#define  sfs_help_ipv6_nh_rule_add        NULL
-#define  sfs_help_mc_ipvx_stream_add      NULL
-#define  sfs_help_igmp_cfg                NULL
-#define  sfs_help_no_rule_add             NULL
-#define  sfs_help_no_mc_stream_add        NULL
-#define  sfs_help_oam_omci_channel        NULL
-#define  sfs_help_no_oam_omci_channel     NULL
-#define  sfs_help_setup                   NULL
-#define  sfs_help_mib_reset               NULL
-#define  sfs_help_set_active_wan          NULL
-#define  sfs_help_hot_swap_profile        NULL
-#define  sfs_help_set_port_hwf_admin      NULL
-#define  sfs_help_erase_section           NULL
-#define  sfs_help_cfg_cpu_lpbk            NULL
-#define  sfs_help_cfg_age_count           NULL
-#define  sfs_help_rate_limit              NULL
-#define  sfs_help_pkt_mod_add             NULL
-#define  sfs_help_pkt_mod_get_del_purge   NULL
-#define  sys_help_ipv6_dip_acl_rule_add   NULL
-#define  sfs_help_ipv6_l4_ports_rule_add  NULL
-#define  sfs_help_delete_entry_rule_table NULL
-#define  sfs_help_send_genquery_to_uni    NULL
-#define  sfs_help_tpm_self_check          NULL
-
-
-#define  sfs_help_ipv6_gen_5t_rule_add       NULL
-#define  sfs_help_ipv6_dip_5t_rule_add       NULL
-#define  sfs_help_ipv6_l4_ports_5t_rule_add  NULL
-#define  sfs_help_ctc_cm_set_ipv6_parse_win  NULL
-
-#define sfs_help_ctc_cm_rule_add          NULL
-#define sfs_help_flush_vtu           NULL
-#define sfs_help_flush_atu           NULL
-#define sfs_help_mac_learn_rule_add       NULL
-#define sfs_help_mac_learn_def_act_set    NULL
-#define sfs_help_ds_load_balance_rule     NULL
-
-
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-#endif  /* _TPM_USR_TPM_SYSFS_HELP_H_*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.c
deleted file mode 100644
index e2c4467..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.c
+++ /dev/null
@@ -1,7085 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/ctype.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_utils.h"
-#include "tpm_sysfs_help.h"
-#include "tpm_sysfs_hwcall.h"
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-extern struct semaphore    tpm_sfs_2_ioctl_sem;
-extern tpm_ioctl_mng_t     tpm_sfs_2_ioctl_command;
- #define PR_RULE_IDX(rule_idx)  {}
- #define PR_HIT_COUNT(hit_count){}
- #define PR_RESULT              {}
- #define PR_MAC_COUNT           {}
-#else
- #define PR_RULE_IDX(rule_idx)  {printk(KERN_INFO "OK. rule_idx = %d\n", rule_idx);}
- #define PR_HIT_COUNT(hit_count){printk(KERN_INFO "OK. hit_count = %d\n", hit_count);}
- #define PR_RESULT              {printk(KERN_INFO "OK.\n");}
- #define PR_MAC_COUNT(count)    {printk(KERN_INFO "OK. mac_learn_entry_count = %d\n", count);}
-#endif
-
-static tpm_api_entry_count_t count_array[CONFIG_MV_PNC_TCAM_LINES];
-
-static char *l2_key_empty_name   = "l2_key_empty";
-static char *l3_key_empty_name   = "l3_key_empty";
-static char *ipv4_key_empty_name = "ipv4_key_empty";
-static char *ipv6_key_empty_name = "ipv6_key_empty";
-static char *frwd_empty_name     = "frwd_empty";
-static char *mod_empty_name      = "mod_empty";
-char *ipv6_gen_key_empty_name = "ipv6_gen_key_empty";
-char *ipv6_dip_key_empty_name = "ipv6_dip_key_empty";
-char *ipv6_l4_key_empty_name = "ipv6_l4_key_empty";
-
-extern int32_t module_tpmSetup(tpm_setup_t *tpm_initp);
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_l2_rule_bounce(uint32_t                owner_id,
-                                        tpm_src_port_type_t     src_port,
-                                        uint32_t                rule_num,
-                                        uint32_t               *rule_idx,
-                                        tpm_parse_fields_t      parse_rule_bm,
-                                        tpm_parse_flags_t       parse_flags_bm,
-                                        tpm_l2_acl_key_t       *l2_key,
-                                        tpm_pkt_frwd_t         *pkt_frwd,
-                                        tpm_pkt_mod_t          *pkt_mod,
-                                        tpm_pkt_mod_bm_t        pkt_mod_bm,
-                                        tpm_rule_action_t      *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_L2_ACL_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    tpm_add_acl_rule->src_port                      = src_port;
-    tpm_add_acl_rule->rule_num                      = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                 = parse_rule_bm;
-    tpm_add_acl_rule->l2_acl_rule.parse_flags_bm    = parse_flags_bm;
-    tpm_add_acl_rule->l2_acl_rule.pkt_mod_bm        = pkt_mod_bm;
-    memcpy(&(tpm_add_acl_rule->l2_acl_rule.l2_key),         (void*)l2_key,      sizeof(tpm_l2_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->l2_acl_rule.pkt_frwd),       (void*)pkt_frwd,    sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->l2_acl_rule.pkt_mod),        (void*)pkt_mod,     sizeof(tpm_pkt_mod_t));
-    memcpy(&(tpm_add_acl_rule->l2_acl_rule.rule_action),    (void*)rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_l2_rule tpm_add_l2_rule_bounce
-#else
- #define _tpm_add_l2_rule tpm_add_l2_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_rule_add
-*
-* DESCRIPTION:
-*           This function creates a L2 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2ruleadd_owner=0, l2ruleadd_srcport, l2ruleadd_rulenum, l2ruleadd_parserulebm, l2ruleadd_parseflagbm, l2ruleadd_action,  l2ruleadd_nextphase,
-        l2ruleadd_l2keyname, l2ruleadd_frwdname, l2ruleadd_modname, l2ruleadd_pktmodbm, l2ruleadd_max
-    } l2ruleadd_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    char                     srcport_str[20];
-    char                     uc_srcport_str[20];
-    int                      indx;
-    uint32_t                 src_port;
-    uint32_t                 rulenum;
-    uint32_t                 parserulebm;
-    uint32_t                 parseflagbm;
-    uint32_t                 pkt_mod_bm;
-    uint32_t                 action;
-    char                     nextphase_str[20];
-    uint32_t                 nextphase;
-    char                     l2keyname[20];
-    char                     frwdname[20];
-    char                     modname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_frwd_entry_t      *pdbfrwdentry  = 0;
-    tpmcfg_l2_key_entry_t    *pdbl2keyentry = 0;
-    tpmcfg_mod_entry_t       *pdbmodentry = 0;
-    //Used in API call
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_l2_acl_key_t         l2_acl;
-    tpm_pkt_mod_t            pkt_mod;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2ruleadd_max)
-    {
-        parm_error_completion(numparms, l2ruleadd_max, buf, sfs_help_l2_rule_add);
-//        if (numparms == 1 && buf[0] == '?')
-//        {
-//            char helpbuf[3000];
-//            int  helpbuf_len;
-//
-//            helpbuf_len = sfs_help_l2_rule_add(helpbuf);
-//            print_help_buffer(helpbuf, helpbuf_len);
-//        }
-//        else
-//        {
-//            printk(KERN_INFO "Parse problem: expected %d parameters, found %d\n", l2ruleadd_max, numparms);
-//        }
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s %s %s %s 0x%x",  &ownerid, srcport_str, &rulenum, &parserulebm,
-                                       &parseflagbm, &action, nextphase_str, l2keyname, frwdname, modname, &pkt_mod_bm);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], action[0x%x], nextphase_str[%s], l2keyname[%s], frwdname[%s], modname[%s], pkt_mod_bm[0x%x]\n",
-               len, parsedargs, ownerid, srcport_str, rulenum, parserulebm, action, nextphase_str, l2keyname, frwdname, modname, pkt_mod_bm);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else if (((pdbl2keyentry = find_tpm_l2_key_entry_by_name(l2keyname)) == 0) && strcmp(l2keyname, l2_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "L2 key entry [%s] not found\n", l2keyname);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && strcmp(modname, mod_empty_name) != 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbl2keyentry != 0)  memcpy(&l2_acl, &pdbl2keyentry->l2_acl, sizeof(tpm_l2_acl_key_t));
-            else                     memset(&l2_acl, 0,                      sizeof(tpm_l2_acl_key_t));
-
-            if (pdbfrwdentry != 0)   memcpy(&pkt_frwd, &pdbfrwdentry->frwd,  sizeof(tpm_pkt_frwd_t));
-            else                     memset(&pkt_frwd, 0,                    sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)    memcpy(&pkt_mod, &pdbmodentry->mod,     sizeof(tpm_pkt_mod_t));
-            else                     memset(&pkt_mod, 0,                     sizeof(tpm_pkt_mod_t));
-
-            if ((rc = _tpm_add_l2_rule(ownerid,
-                                       src_port,
-                                       rulenum,
-                                       &rule_idx,
-                                       parserulebm,
-                                       parseflagbm,
-                                       &l2_acl,
-                                       &pkt_frwd,
-                                       &pkt_mod,
-                                       pkt_mod_bm,
-                                       &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_l2_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_l3_type_rule_bounce(uint32_t               owner_id,
-                                             tpm_src_port_type_t     src_port,
-                                             uint32_t                rule_num,
-                                             uint32_t               *rule_idx,
-                                             tpm_parse_fields_t      parse_rule_bm,
-                                             tpm_parse_flags_t       parse_flags_bm,
-                                             tpm_l3_type_key_t      *l3_key,
-                                             tpm_pkt_frwd_t         *pkt_frwd,
-                                             tpm_rule_action_t      *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_L3_ACL_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    tpm_add_acl_rule->src_port                      = src_port;
-    tpm_add_acl_rule->rule_num                      = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                 = parse_rule_bm;
-    tpm_add_acl_rule->l3_acl_rule.parse_flags_bm    = parse_flags_bm;
-    memcpy(&(tpm_add_acl_rule->l3_acl_rule.l3_key),         (void*)l3_key,      sizeof(tpm_l3_type_key_t));
-    memcpy(&(tpm_add_acl_rule->l3_acl_rule.pkt_frwd),       (void*)pkt_frwd,    sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->l3_acl_rule.rule_action),    (void*)rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_l3_type_rule tpm_add_l3_type_rule_bounce
-#else
- #define _tpm_add_l3_type_rule tpm_add_l3_type_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l3_rule_add
-*
-* DESCRIPTION:
-*           This function creates a L3 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l3_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l3ruleadd_owner=0, l3ruleadd_srcport, l3ruleadd_rulenum, l3ruleadd_parserulebm, l3ruleadd_parseflagsbm, l3ruleadd_action, l3ruleadd_nextphase,
-        l2ruleadd_frwdname, l3ruleadd_l3keyname, l3ruleadd_max
-    } l3ruleadd_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    char                     srcport_str[20];
-    char                     uc_srcport_str[20];
-    int                      indx;
-    uint32_t                 src_port;
-    uint32_t                 rulenum;
-    uint32_t                 parserulebm;
-    uint32_t                 parseflagbm;
-    uint32_t                 action;
-    char                     nextphase_str[20];
-    uint32_t                 nextphase;
-    char                     frwdname[20];
-    char                     l3keyname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_l3_key_entry_t    *pdbl3keyentry = 0;
-    tpmcfg_frwd_entry_t      *pdbfrwdentry  = 0;
-    // Used in API call
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_l3_type_key_t        l3_acl;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != l3ruleadd_max)
-    {
-        parm_error_completion(numparms, l3ruleadd_max, buf, sfs_help_l3_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s %s %s",
-                            &ownerid, srcport_str, &rulenum, &parserulebm, &parseflagbm, &action, nextphase_str, l3keyname, frwdname);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagbm[0x%x], action[0x%x], nextphase_str[%s], l3keyname[%s], frwdname[%s]\n",
-               len, parsedargs, ownerid, srcport_str, rulenum, parserulebm, parseflagbm, action, nextphase_str, l3keyname, frwdname);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", uc_srcport_str);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbl3keyentry = find_tpm_l3_key_entry_by_name(l3keyname)) == 0) && strcmp(l3keyname, l3_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "L3 key entry [%s] not found\n", l3keyname);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbl3keyentry != 0)  memcpy(&l3_acl, &pdbl3keyentry->l3_acl, sizeof(tpm_l3_type_key_t));
-            else                     memset(&l3_acl, 0,                      sizeof(tpm_l3_type_key_t));
-
-            if (pdbfrwdentry != 0)   memcpy(&pkt_frwd, &pdbfrwdentry->frwd,  sizeof(tpm_pkt_frwd_t));
-            else                     memset(&pkt_frwd, 0,                    sizeof(tpm_pkt_frwd_t));
-
-            if ((rc = _tpm_add_l3_type_rule(ownerid,
-                                            src_port,
-                                            rulenum,
-                                            &rule_idx,
-                                            parserulebm,
-                                            parseflagbm,
-                                            &l3_acl,
-                                            &pkt_frwd,
-                                            &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_l3_type_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv4_rule_bounce(uint32_t                owner_id,
-                                          tpm_src_port_type_t     src_port,
-                                          uint32_t                rule_num,
-                                          uint32_t               *rule_idx,
-                                          tpm_parse_fields_t      parse_rule_bm,
-                                          tpm_parse_flags_t       parse_flags_bm,
-                                          tpm_ipv4_acl_key_t     *ipv4_key,
-                                          tpm_pkt_frwd_t         *pkt_frwd,
-                                          tpm_pkt_mod_t          *pkt_mod,
-                                          tpm_pkt_mod_bm_t        pkt_mod_bm,
-                                          tpm_rule_action_t      *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_IPv4_ACL_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    tpm_add_acl_rule->src_port                      = src_port;
-    tpm_add_acl_rule->rule_num                      = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                 = parse_rule_bm;
-    tpm_add_acl_rule->ipv4_acl_rule.parse_flags_bm  = parse_flags_bm;
-    tpm_add_acl_rule->ipv4_acl_rule.pkt_mod_bm      = pkt_mod_bm;
-    memcpy(&(tpm_add_acl_rule->ipv4_acl_rule.ipv4_key),     (void*)ipv4_key,    sizeof(tpm_ipv4_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->ipv4_acl_rule.pkt_frwd),     (void*)pkt_frwd,    sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ipv4_acl_rule.pkt_mod),      (void*)pkt_mod,     sizeof(tpm_pkt_mod_t));
-    memcpy(&(tpm_add_acl_rule->ipv4_acl_rule.rule_action),  (void*)rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv4_rule tpm_add_ipv4_rule_bounce
-#else
- #define _tpm_add_ipv4_rule tpm_add_ipv4_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv4_rule_add
-*
-* DESCRIPTION:
-*           This function creates a IPV4 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv4_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4ruleadd_owner=0, ipv4ruleadd_srcport,   ipv4ruleadd_rulenum,  ipv4ruleadd_parserulebm, ipv4ruleadd_parseflagsbm,
-        ipv4ruleadd_action,  ipv4ruleadd_nextphase, ipv4ruleadd_frwdname, ipv4ruleadd_ipv4keyname,   ipv4ruleadd_modbm,
-        ipv4ruleadd_modname, ipv4ruleadd_max
-    } ipv4ruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    char                     srcport_str[20];
-    char                     uc_srcport_str[20];
-    int                      indx;
-    uint32_t                 src_port;
-    uint32_t                 rulenum;
-    uint32_t                 parserulebm;
-    uint32_t                 parseflagsbm;
-    uint32_t                 action;
-    uint32_t                 nextphase;
-    char                     nextphase_str[20];
-    uint32_t                 modbm;
-    char                     ipv4keyname[20];
-    char                     frwdname[20];
-    char                     modname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_ipv4_key_entry_t  *pdbipv4keyentry = 0;
-    tpmcfg_frwd_entry_t      *pdbfrwdentry    = 0;
-    tpmcfg_mod_entry_t       *pdbmodentry     = 0;
-    // Used in API call
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    tpm_ipv4_acl_key_t       ipv4_acl;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4ruleadd_max)
-    {
-        parm_error_completion(numparms, ipv4ruleadd_max, buf, sfs_help_ipv4_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s 0x%x %s %s %s", &ownerid, srcport_str, &rulenum, &parserulebm, &parseflagsbm,
-                            &action, nextphase_str, &modbm, ipv4keyname, frwdname, modname);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], modbm[0x%x], ipv4keyname[%s], frwdname[%s], modname[%s]\n",
-//               len, parsedargs, ownerid, srcport_str, rulenum, parserulebm, parseflagsbm, action, nextphase_str, modbm, ipv4keyname, frwdname, modname);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else if (((pdbipv4keyentry = find_tpm_ipv4_key_entry_by_name(ipv4keyname)) == 0) && strcmp(ipv4keyname, ipv4_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "IPV4 key entry [%s] not found\n", ipv4keyname);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && strcmp(modname, mod_empty_name) != 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv4keyentry != 0)  memcpy(&ipv4_acl, &pdbipv4keyentry->ipv4_acl, sizeof(tpm_ipv4_acl_key_t));
-            else                       memset(&ipv4_acl, 0,                          sizeof(tpm_ipv4_acl_key_t));
-
-            if (pdbfrwdentry != 0)     memcpy(&pkt_frwd, &pdbfrwdentry->frwd,        sizeof(tpm_pkt_frwd_t));
-            else                       memset(&pkt_frwd, 0,                          sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)      memcpy(&pkt_mod, &pdbmodentry->mod,           sizeof(tpm_pkt_mod_t));
-            else                       memset(&pkt_mod, 0,                           sizeof(tpm_pkt_mod_t));
-
-            if ((rc = _tpm_add_ipv4_rule(ownerid,
-                                         src_port,
-                                         rulenum,
-                                         &rule_idx,
-                                         parserulebm,
-                                         parseflagsbm,
-                                         &ipv4_acl,
-                                         &pkt_frwd,
-                                         &pkt_mod,
-                                         modbm,
-                                         &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv4_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv4_mc_stream_bounce(uint32_t                 owner_id,
-                                              uint32_t                  stream_num,
-                                              tpm_mc_igmp_mode_t        igmp_mode,
-                                              uint8_t                   mc_stream_pppoe,
-                                              uint16_t                  vid,
-                                              uint8_t                   ipv4_src_add[4],
-                                              uint8_t                   ipv4_dst_add[4],
-                                              uint8_t                   ignore_ipv4_src,
-                                              tpm_trg_port_type_t       dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd             = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd                     = MV_TPM_IOCTL_ADD_IPv4_MC_STREAM;
-    tpm_mc_rule->stream_num                 = stream_num;
-    tpm_mc_rule->igmp_mode                  = igmp_mode;
-    tpm_mc_rule->mc_stream_pppoe            = mc_stream_pppoe;
-    tpm_mc_rule->vid                        = vid;
-    tpm_mc_rule->ipv4_mc.ignore_ipv4_src    = ignore_ipv4_src;
-    tpm_mc_rule->dest_port_bm               = dest_port_bm;
-    memcpy(&(tpm_mc_rule->ipv4_mc.ipv4_src_add[0]), ipv4_src_add, sizeof(uint8_t)*4);
-    memcpy(&(tpm_mc_rule->ipv4_mc.ipv4_dst_add[0]), ipv4_dst_add, sizeof(uint8_t)*4);
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv4_mc_stream tpm_add_ipv4_mc_stream_bounce
-#else
- #define _tpm_add_ipv4_mc_stream tpm_add_ipv4_mc_stream
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv4_stream_add
-*
-* DESCRIPTION:
-*           This function creates a multicast IPV4 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv4_stream_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcipv4add_owner=0, mcipv4add_stream, mcipv4add_mode,   mcipv4add_pppoe,        mcipv4add_vid,
-        mcipv4add_src_ip,  mcipv4add_dst_ip, mcipv4add_ignore, mcipv4add_target_ports, mcipv4add_max
-    } mcipv4add_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream;
-    uint32_t                 mode;
-    char                     mc_pppoe_str[20];
-    uint32_t                 mc_stream_pppoe;
-    uint32_t                 vid;
-    char                     srcip_str[30];
-    char                     dstip_str[30];
-    uint32_t                 temp_srcip[4];
-    uint32_t                 temp_dstip[4];
-    uint8_t                  srcip[4];
-    uint8_t                  dstip[4];
-    char                     ignore_str[20];
-    uint32_t                 ignore;
-    uint32_t                 target_ports;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcipv4add_max)
-    {
-        parm_error_completion(numparms, mcipv4add_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d %s %d %s %s %s 0x%x",
-                            &ownerid, &stream, &mode, mc_pppoe_str, &vid, srcip_str, dstip_str, ignore_str, &target_ports);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d], vid[%d], srcip_str[%s], dstip_str[%s], ignore_str[%s], target_ports[0x%x]\n",
-//               len, parsedargs, ownerid, stream, vid, srcip_str, dstip_str, ignore_str, target_ports);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_bool_value(mc_pppoe_str, &mc_stream_pppoe) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else if (parse_ipv4_address(srcip_str, temp_srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_ip [%s]\n", srcip_str);
-        }
-        else if (parse_ipv4_address(dstip_str, temp_dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dst_ip [%s]\n", dstip_str);
-        }
-        else if (get_bool_value(ignore_str, &ignore) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else
-        {
-            int indx;
-
-            for (indx = 0; indx < sizeof(srcip); indx++)
-            {
-                srcip[indx] = (uint8_t)temp_srcip[indx];
-                dstip[indx] = (uint8_t)temp_dstip[indx];
-            }
-
-            if ((rc = _tpm_add_ipv4_mc_stream(ownerid,
-                                              stream,
-                                              mode,
-                                              (uint8_t)mc_stream_pppoe,
-                                              vid,
-                                              srcip,
-                                              dstip,
-                                              (uint8_t)ignore,
-                                              target_ports)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv4_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv4_mc_stream_set_queue_bounce(
-					      uint32_t                 owner_id,
-                                              uint32_t                  stream_num,
-                                              tpm_mc_igmp_mode_t        igmp_mode,
-                                              uint8_t                   mc_stream_pppoe,
-                                              uint16_t                  vid,
-                                              uint8_t                   ipv4_src_add[4],
-                                              uint8_t                   ipv4_dst_add[4],
-                                              uint8_t                   ignore_ipv4_src,
-                                              uint16_t                  dest_queue,
-                                              tpm_trg_port_type_t       dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd             = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd                     = MV_TPM_IOCTL_ADD_IPv4_MC_STREAM_SET_QUEUE;
-    tpm_mc_rule->stream_num                 = stream_num;
-    tpm_mc_rule->igmp_mode                  = igmp_mode;
-    tpm_mc_rule->mc_stream_pppoe            = mc_stream_pppoe;
-    tpm_mc_rule->vid                        = vid;
-    tpm_mc_rule->ipv4_mc.ignore_ipv4_src    = ignore_ipv4_src;
-    tpm_mc_rule->dest_queue                 = dest_queue;
-    tpm_mc_rule->dest_port_bm               = dest_port_bm;
-    memcpy(&(tpm_mc_rule->ipv4_mc.ipv4_src_add[0]), ipv4_src_add, sizeof(uint8_t)*4);
-    memcpy(&(tpm_mc_rule->ipv4_mc.ipv4_dst_add[0]), ipv4_dst_add, sizeof(uint8_t)*4);
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv4_mc_stream_set_queue tpm_add_ipv4_mc_stream_set_queue_bounce
-#else
- #define _tpm_add_ipv4_mc_stream_set_queue tpm_add_ipv4_mc_stream_set_queue
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv4_stream_set_queue_add
-*
-* DESCRIPTION:
-*           This function creates a multicast IPV4 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv4_stream_set_queue_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcipv4add_owner=0, mcipv4add_stream, mcipv4add_mode,   mcipv4add_pppoe,        mcipv4add_vid,
-        mcipv4add_src_ip,  mcipv4add_dst_ip, mcipv4add_ignore, mcipv4add_target_ports, mcipv4add_target_queue,
-        mcipv4add_max
-    } mcipv4add_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream;
-    uint32_t                 mode;
-    char                     mc_pppoe_str[20];
-    uint32_t                 mc_stream_pppoe;
-    uint32_t                 vid;
-    char                     srcip_str[30];
-    char                     dstip_str[30];
-    uint32_t                 temp_srcip[4];
-    uint32_t                 temp_dstip[4];
-    uint8_t                  srcip[4];
-    uint8_t                  dstip[4];
-    char                     ignore_str[20];
-    uint32_t                 ignore;
-    uint32_t                 target_queue;
-    uint32_t                 target_ports;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcipv4add_max)
-    {
-        parm_error_completion(numparms, mcipv4add_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d %s %d %s %s %s %d 0x%x",
-                            &ownerid, &stream, &mode, mc_pppoe_str, &vid, srcip_str, dstip_str, ignore_str, &target_queue, &target_ports);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d], vid[%d], srcip_str[%s], dstip_str[%s], ignore_str[%s], target_ports[0x%x]\n",
-//               len, parsedargs, ownerid, stream, vid, srcip_str, dstip_str, ignore_str, target_ports);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_bool_value(mc_pppoe_str, &mc_stream_pppoe) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else if (parse_ipv4_address(srcip_str, temp_srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_ip [%s]\n", srcip_str);
-        }
-        else if (parse_ipv4_address(dstip_str, temp_dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dst_ip [%s]\n", dstip_str);
-        }
-        else if (get_bool_value(ignore_str, &ignore) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else
-        {
-            int indx;
-
-            for (indx = 0; indx < sizeof(srcip); indx++)
-            {
-                srcip[indx] = (uint8_t)temp_srcip[indx];
-                dstip[indx] = (uint8_t)temp_dstip[indx];
-            }
-
-            if ((rc = _tpm_add_ipv4_mc_stream_set_queue(ownerid,
-                                              stream,
-                                              mode,
-                                              (uint8_t)mc_stream_pppoe,
-                                              vid,
-                                              srcip,
-                                              dstip,
-                                              (uint8_t)ignore,
-                                              target_queue,
-                                              target_ports)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv4_mc_stream_set_queue failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_mc_stream_set_queue_bounce(uint32_t owner_id,
-						uint32_t stream_num,
-						tpm_mc_igmp_mode_t igmp_mode,
-						uint8_t mc_stream_pppoe,
-						uint16_t vid,
-						uint8_t ipv6_src_add[16],
-						uint8_t ipv6_dst_add[16],
-						uint8_t ignore_ipv6_src,
-						uint16_t dest_queue,
-						tpm_trg_port_type_t dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd             = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd                     = MV_TPM_IOCTL_ADD_IPv6_MC_STREAM_SET_QUEUE;
-    tpm_mc_rule->stream_num                 = stream_num;
-    tpm_mc_rule->igmp_mode                  = igmp_mode;
-    tpm_mc_rule->mc_stream_pppoe            = mc_stream_pppoe;
-    tpm_mc_rule->vid                        = vid;
-    tpm_mc_rule->dest_port_bm               = dest_port_bm;
-    tpm_mc_rule->dest_queue                 = dest_queue;
-    memcpy(&(tpm_mc_rule->ipv6_mc.ipv6_dst_add[0]), ipv6_dst_add, sizeof(uint8_t) * 16);
-    memcpy(&(tpm_mc_rule->ipv6_mc.ipv6_src_add[0]), ipv6_src_add, sizeof(uint8_t) * 16);
-    tpm_mc_rule->ipv6_mc.ignore_ipv6_src = ignore_ipv6_src;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_mc_stream_set_queue tpm_add_ipv6_mc_stream_set_queue_bounce
-#else
- #define _tpm_add_ipv6_mc_stream_set_queue tpm_add_ipv6_mc_stream_set_queue
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv6_stream_add_set_queue
-*
-* DESCRIPTION:
-*           This function creates a multicast ipv6 rule with destination queue
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv6_stream_set_queue_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcipv6add_owner=0, mcipv6add_stream, mcipv6add_mode,   mcipv6add_pppoe,        mcipv6add_vid,
-        mcipv6add_src_ip, mcipv6add_dst_ip, mcipv6add_ignor_src_ip, mcipv6add_target_queue, mcipv6add_target_ports, mcipv6add_max
-    } mcipv6add_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream;
-    uint32_t                 mode;
-    char                     mc_pppoe_str[20];
-    uint32_t                 mc_stream_pppoe;
-    uint32_t                 vid;
-    char                     dstip_str[60];
-    uint32_t                 temp_dstip[16];
-    char                     srcip_str[60];
-    uint32_t                 temp_srcip[16];
-    uint8_t                  dstip[16];
-    uint8_t                  srcip[16];
-    uint32_t                 ignor_srcip;
-    char                     ignore_str[20];
-    uint32_t                 target_ports;
-    uint32_t                 target_queue;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcipv6add_max)
-    {
-        parm_error_completion(numparms, mcipv6add_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d %s %d %s %s %s %d 0x%x",
-                            &ownerid, &stream, &mode, mc_pppoe_str, &vid, srcip_str, dstip_str, ignore_str, &target_queue, &target_ports);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d], vid[%d], srcip_str[%s],  "
-		"dstip_str[%s],  ignor_srcip[%s], target_queue[%d], target_ports[0x%x]\n",
-               len, parsedargs, ownerid, stream, vid, srcip_str, dstip_str, ignore_str, target_queue, target_ports);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_bool_value(mc_pppoe_str, &mc_stream_pppoe) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid mc_pppoe_str[%s]\n", mc_pppoe_str);
-        }
-        else if (parse_ipv6_address(dstip_str, temp_dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dst_ip [%s]\n", dstip_str);
-        }
-        else if (parse_ipv6_address(srcip_str, temp_srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip_str [%s]\n", srcip_str);
-	}
-	else if (get_bool_value(ignore_str, &ignor_srcip) == GT_FALSE)
-	{
-	    printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else
-        {
-            int indx;
-
-            for (indx = 0; indx < sizeof(dstip); indx++)
-            {
-                dstip[indx] = (uint8_t)temp_dstip[indx];
-                srcip[indx] = (uint8_t)temp_srcip[indx];
-            }
-
-            if ((rc = _tpm_add_ipv6_mc_stream_set_queue(ownerid,
-                                              stream,
-                                              mode,
-                                              (uint8_t)mc_stream_pppoe,
-                                              vid,
-                                              srcip,
-                                              dstip,
-                                              ignor_srcip,
-                                              target_queue,
-                                              target_ports)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_mc_stream_set_queue failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_mc_stream_bounce(uint32_t owner_id,
-						uint32_t stream_num,
-						tpm_mc_igmp_mode_t igmp_mode,
-						uint8_t mc_stream_pppoe,
-						uint16_t vid,
-						uint8_t ipv6_src_add[16],
-						uint8_t ipv6_dst_add[16],
-						uint8_t ignore_ipv6_src,
-						tpm_trg_port_type_t dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd             = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd                     = MV_TPM_IOCTL_ADD_IPv6_MC_STREAM;
-    tpm_mc_rule->stream_num                 = stream_num;
-    tpm_mc_rule->igmp_mode                  = igmp_mode;
-    tpm_mc_rule->mc_stream_pppoe            = mc_stream_pppoe;
-    tpm_mc_rule->vid                        = vid;
-    tpm_mc_rule->dest_port_bm               = dest_port_bm;
-    memcpy(&(tpm_mc_rule->ipv6_mc.ipv6_dst_add[0]), ipv6_dst_add, sizeof(uint8_t) * 16);
-    memcpy(&(tpm_mc_rule->ipv6_mc.ipv6_src_add[0]), ipv6_src_add, sizeof(uint8_t) * 16);
-    tpm_mc_rule->ipv6_mc.ignore_ipv6_src = ignore_ipv6_src;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_mc_stream tpm_add_ipv6_mc_stream_bounce
-#else
- #define _tpm_add_ipv6_mc_stream tpm_add_ipv6_mc_stream
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv6_stream_add
-*
-* DESCRIPTION:
-*           This function creates a multicast ipv6 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv6_stream_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcipv6add_owner=0, mcipv6add_stream, mcipv6add_mode,   mcipv6add_pppoe,        mcipv6add_vid,
-        mcipv6add_src_ip, mcipv6add_dst_ip, mcipv6add_ignor_src_ip, mcipv6add_target_ports, mcipv6add_max
-    } mcipv6add_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream;
-    uint32_t                 mode;
-    char                     mc_pppoe_str[20];
-    uint32_t                 mc_stream_pppoe;
-    uint32_t                 vid;
-    char                     dstip_str[60];
-    uint32_t                 temp_dstip[16];
-    char                     srcip_str[60];
-    uint32_t                 temp_srcip[16];
-    uint8_t                  dstip[16];
-    uint8_t                  srcip[16];
-    uint32_t                 ignor_srcip;
-    char                     ignore_str[20];
-    uint32_t                 target_ports;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcipv6add_max)
-    {
-        parm_error_completion(numparms, mcipv6add_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d %s %d %s %s %s 0x%x",
-                            &ownerid, &stream, &mode, mc_pppoe_str, &vid, srcip_str, dstip_str, ignore_str, &target_ports);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d], vid[%d], srcip_str[%s],  "
-		"dstip_str[%s],  ignor_srcip[%s], target_ports[0x%x]\n",
-               len, parsedargs, ownerid, stream, vid, srcip_str, dstip_str, ignore_str, target_ports);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_bool_value(mc_pppoe_str, &mc_stream_pppoe) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid mc_pppoe_str[%s]\n", mc_pppoe_str);
-        }
-        else if (parse_ipv6_address(dstip_str, temp_dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dst_ip [%s]\n", dstip_str);
-        }
-        else if (parse_ipv6_address(srcip_str, temp_srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip_str [%s]\n", srcip_str);
-	}
-	else if (get_bool_value(ignore_str, &ignor_srcip) == GT_FALSE)
-	{
-	    printk(KERN_INFO "Invalid ignore[%s]\n", ignore_str);
-        }
-        else
-        {
-            int indx;
-
-            for (indx = 0; indx < sizeof(dstip); indx++)
-            {
-                dstip[indx] = (uint8_t)temp_dstip[indx];
-                srcip[indx] = (uint8_t)temp_srcip[indx];
-            }
-
-            if ((rc = _tpm_add_ipv6_mc_stream(ownerid,
-                                              stream,
-                                              mode,
-                                              (uint8_t)mc_stream_pppoe,
-                                              vid,
-                                              srcip,
-                                              dstip,
-                                              ignor_srcip,
-                                              target_ports)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_port_igmp_frwd_mode_bounce(tpm_src_port_type_t  src_port,
-                                                    tpm_igmp_frwd_mode_t mode)
-{
-    tpm_ioctl_igmp_t *tpm_igmp = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_igmp;
-
-    tpm_sfs_2_ioctl_command.cmd   = MV_TPM_IOCTL_IGMP_SECTION;
-    tpm_igmp->igmp_cmd          = MV_TPM_IOCTL_IGMP_SET_PORT_FRWD_MODE;
-    tpm_igmp->src_port          = src_port;
-    tpm_igmp->frwd_mode         = mode;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_port_igmp_frwd_mode tpm_set_port_igmp_frwd_mode_bounce
-#else
- #define _tpm_set_port_igmp_frwd_mode tpm_set_port_igmp_frwd_mode
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_igmp_port_forward_mode_cfg
-*
-* DESCRIPTION:
-*           This function creates a multicast IPV4 rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void  sfs_tpm_cfg_set_igmp_port_forward_mode_cfg (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        igmpfrwd_owner=0, igmpfrwd_src_port, igmpfrwd_mode, igmpfrwd_max
-    } igmpfrwd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;          // NOTE: not used in API!!
-    char                     srcport_str[30];
-    char                     uc_srcport_str[30];
-    int                      indx;
-    uint32_t                 src_port;
-    char                     mode_str[30];
-    uint32_t                 mode;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != igmpfrwd_max)
-    {
-        parm_error_completion(numparms, igmpfrwd_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %s", &ownerid, srcport_str, mode_str);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], mode_str[%s]\n",
-//               len, parsedargs, ownerid, srcport_str, mode_str);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_igmp_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port [%s]\n", srcport_str);
-        }
-        else if (get_igmp_mode_value(mode_str, &mode) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid mode [%s]\n", mode_str);
-        }
-        else
-        {
-            if ((rc = _tpm_set_port_igmp_frwd_mode(src_port,
-                                                   mode)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_set_port_igmp_frwd_mode failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_igmp_cpu_rx_queue_bounce(uint32_t  queue)
-{
-    tpm_ioctl_igmp_t *tpm_igmp = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_igmp;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_IGMP_SECTION;
-    tpm_igmp->igmp_cmd          = MV_TPM_IOCTL_IGMP_SET_CPU_RX_Q;
-    tpm_igmp->cpu_queue         = queue;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_igmp_cpu_rx_queue tpm_set_igmp_cpu_rx_queue_bounce
-#else
- #define _tpm_set_igmp_cpu_rx_queue tpm_set_igmp_cpu_rx_queue
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_igmp_cpu_queue_cfg
-*
-* DESCRIPTION:
-*           This function configres the CPU queue for IGMP
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_igmp_cpu_queue_cfg (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        igmpcpuq_owner=0, igmpcpuq_queue, igmpcpuq_max
-    } igmpcpuq_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;             // NOTE: not used in API!!
-    uint32_t                 que;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != igmpcpuq_max)
-    {
-        parm_error_completion(numparms, igmpcpuq_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &que);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], que[%d]\n",
-//               len, parsedargs, ownerid, que);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (que >= TPM_MAX_NUM_RX_QUEUE)  // Hope this a good choice
-        {
-            printk(KERN_INFO "Invalid queue [%d]\n", que);
-        }
-        else
-        {
-            if ((rc = _tpm_set_igmp_cpu_rx_queue(que)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_set_igmp_cpu_rx_queue failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_igmp_proxy_sa_mac_bounce(uint8_t *sa_mac)
-{
-	tpm_ioctl_igmp_t *tpm_igmp_set_sa_mac = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_igmp;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_IGMP_SECTION;
-	tpm_igmp_set_sa_mac->igmp_cmd = MV_TPM_IOCTL_SET_IGMP_PROXY_SA_MAC;
-	memcpy(tpm_igmp_set_sa_mac->sa_mac, (void *)sa_mac, 6);
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_set_igmp_proxy_sa_mac tpm_set_igmp_proxy_sa_mac_bounce
-#else
- #define _tpm_set_igmp_proxy_sa_mac tpm_set_igmp_proxy_sa_mac
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_igmp_proxy_sa_mac
-*
-* DESCRIPTION:
-*           This function configures the sa_mac for IGMP proxy
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_igmp_proxy_sa_mac (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        igmpproxysa_owner=0, igmpproxysa_mac, igmpproxysa_max
-    } igmpproxysa_parm_indx_t;
-
-    // shell line parsing
-    unsigned int             ownerid, i;
-    uint8_t                  mac[6];
-    uint32_t                 temp_mac[6];
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-
-    numparms = count_parameters(buf);
-    if (numparms != igmpproxysa_max)
-    {
-        parm_error_completion(numparms, igmpproxysa_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %02x:%02x:%02x:%02x:%02x:%02x",
-                            &ownerid, &temp_mac[0], &temp_mac[1], &temp_mac[2], &temp_mac[3], &temp_mac[4], &temp_mac[5]);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], sa_mac[%02x:%02x:%02x:%02x:%02x:%02x]\n",
-//               len, parsedargs, ownerid, temp_mac[0], temp_mac[1], temp_mac[2], temp_mac[3], temp_mac[4], temp_mac[5]);
-
-        if (parsedargs != 7)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, 7);
-        }
-        else
-        {
-            for (i=0;i<6;i++)
-            {
-                mac[i] = temp_mac[i];
-            }
-            if ((rc = _tpm_set_igmp_proxy_sa_mac (mac)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_set_igmp_proxy_sa_mac failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_l2_rule_bounce(uint32_t        owner_id,
-                                        uint32_t        rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_L2_ACL_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_l2_rule tpm_del_l2_rule_bounce
-#else
- #define _tpm_del_l2_rule tpm_del_l2_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_l2
-*
-* DESCRIPTION:
-*           This function deletes a L2 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_l2  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noruleaddl2_owner=0,  noruleaddl2_ruleidx,  noruleaddl2_max
-    } noruleaddl2_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noruleaddl2_max)
-    {
-        parm_error_completion(numparms, noruleaddl2_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        //printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-        //       len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_l2_rule(ownerid,
-                                       rule_idx)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_l2_prim_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_l3_type_rule_bounce(uint32_t           owner_id,
-                                             uint32_t           rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_L3_ACL_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_l3_type_rule tpm_del_l3_type_rule_bounce
-#else
- #define _tpm_del_l3_type_rule tpm_del_l3_type_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_l3
-*
-* DESCRIPTION:
-*           This function deletes a L3 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_l3  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noruleaddl3_owner=0,  noruleaddl3_ruleidx,  noruleaddl3_max
-    } noruleaddl3_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noruleaddl3_max)
-    {
-        parm_error_completion(numparms, noruleaddl3_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rule_idx[%d], parserulebm[0x%x], keyname[%s]\n",
-//               len, parsedargs, ownerid, srcport_str, rule_idx, parserulebm, keyname);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_l3_type_rule(ownerid,
-                                            rule_idx)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_l3_type_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv4_rule_bounce(uint32_t          owner_id,
-                                          uint32_t          rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_IPv4_ACL_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv4_rule tpm_del_ipv4_rule_bounce
-#else
- #define _tpm_del_ipv4_rule tpm_del_ipv4_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv4
-*
-* DESCRIPTION:
-*           This function deletes a IPV4 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv4  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noruleaddipv4_owner=0,  noruleaddipv4_ruleidx, noruleaddipv4_max
-    } noruleaddipv4_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noruleaddipv4_max)
-    {
-        parm_error_completion(numparms, noruleaddipv4_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d",
-                            &ownerid, &rule_idx);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rule_idx[%d], parserulebm[0x%x], keyname[%s]\n",
-//               len, parsedargs, ownerid, srcport_str, rule_idx, parserulebm, keyname);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_ipv4_rule(ownerid,
-                                         rule_idx)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_ipv4_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv4_mc_stream_bounce(uint32_t     owner_id,
-                                              uint32_t      stream_num)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd         = MV_TPM_IOCTL_DEL_IPv4_MC_STREAM;
-    tpm_mc_rule->owner_id       = owner_id;
-    tpm_mc_rule->stream_num     = stream_num;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv4_mc_stream tpm_del_ipv4_mc_stream_bounce
-#else
- #define _tpm_del_ipv4_mc_stream tpm_del_ipv4_mc_stream
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_mc_stream_add_ipv4
-*
-* DESCRIPTION:
-*           This function deletes a DSCP IPV6 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_mc_stream_add_ipv4  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        nostreamaddipv4_owner=0, nostreamaddipv4_ruleidx,  nostreamaddipv4_max
-    } nostreamaddipv4_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 stream;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != nostreamaddipv4_max)
-    {
-        parm_error_completion(numparms, nostreamaddipv4_max, buf, sfs_help_no_mc_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &stream);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d]\n", len, parsedargs, ownerid, stream);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if ((rc = _tpm_del_ipv4_mc_stream(ownerid,
-                                               stream)) == TPM_RC_OK)
-        {
-            printk(KERN_INFO "OK\n");
-        }
-        else
-        {
-            printk(KERN_INFO "%s: tpm_del_ipv4_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_mc_stream_bounce(uint32_t     owner_id,
-                                              uint32_t      stream_num)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd         = MV_TPM_IOCTL_DEL_IPv6_MC_STREAM;
-    tpm_mc_rule->owner_id       = owner_id;
-    tpm_mc_rule->stream_num     = stream_num;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_mc_stream tpm_del_ipv6_mc_stream_bounce
-#else
- #define _tpm_del_ipv6_mc_stream tpm_del_ipv6_mc_stream
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_mc_stream_add_ipv6
-*
-* DESCRIPTION:
-*           This function deletes a DSCP IPV6 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_mc_stream_add_ipv6  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        nostreamaddipv6_owner=0, nostreamaddipv6_ruleidx,  nostreamaddipv6_max
-    } nostreamaddipv6_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 stream;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != nostreamaddipv6_max)
-    {
-        parm_error_completion(numparms, nostreamaddipv6_max, buf, sfs_help_no_mc_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &stream);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream[%d]\n", len, parsedargs, ownerid, stream);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if ((rc = _tpm_del_ipv6_mc_stream(ownerid,
-                                               stream)) == TPM_RC_OK)
-        {
-            printk(KERN_INFO "OK\n");
-        }
-        else
-        {
-            printk(KERN_INFO "%s: tpm_del_ipv6_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_proc_set_enable_mtu_bounce(tpm_init_mtu_setting_enable_t enable)
-{
-	tpm_ioctl_mtu_t *tpm_mtu_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_mtu_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MTU_SECTION;
-	tpm_mtu_set->mtu_setting_cmd = MV_TPM_IOCTL_SET_MTU_ADMIN;
-	tpm_mtu_set->enable = enable;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_proc_set_enable_mtu tpm_proc_set_enable_mtu_bounce
-#else
- #define _tpm_proc_set_enable_mtu tpm_db_set_mtu_enable
-#endif
-
-void sfs_tpm_cfg_set_mtu_enable (const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mtu_enable=0, mtu_enable_max
-	} mtu_enable_indx_t;
-	/*shell line parsing*/
-	int enable;
-
-	int parsedargs;
-	int numparms;
-
-	/*used in API call*/
-	tpm_error_code_t rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != mtu_enable_max)
-		parm_error_completion(numparms, mtu_enable_max, buf, sfs_help_setup);
-	else {
-		/*get parameters*/
-		parsedargs = sscanf(buf, "%d", &enable);
-		if (parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else if ((enable != 1) && (enable != 0))
-			printk(KERN_INFO "Invalid enable[%d]\n", enable);
-		else {
-			if ((rc = _tpm_proc_set_enable_mtu(enable)) == TPM_RC_OK)
-				printk(KERN_INFO "OK\n");
-			else
-				printk(KERN_INFO "%s: tpm_proc_set_enable_mtu failed, rc[%d] - %s\n",
-				__FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_proc_set_mtu_bounce(uint32_t ipv4_or_ipv6,
-					uint32_t direction,
-					uint32_t mtu)
-{
-	tpm_ioctl_mtu_t *tpm_mtu_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_mtu_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MTU_SECTION;
-	tpm_mtu_set->mtu_setting_cmd = MV_TPM_IOCTL_SET_MTU;
-	tpm_mtu_set->ethertype = ipv4_or_ipv6;
-	tpm_mtu_set->direction = direction;
-	tpm_mtu_set->mtu = mtu;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_proc_set_mtu tpm_proc_set_mtu_bounce
-#else
- #define _tpm_proc_set_mtu tpm_proc_set_mtu
-#endif
-
-void sfs_tpm_cfg_set_mtu (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mtu_ipv4_or_ipv6=0,  mtu_direction, mtu_value,  mtu_max
-    } mtu_indx_t;
-    // shell line parsing
-    uint32_t                 ipv4_or_ipv6;
-    uint32_t                 direction;
-    uint32_t                 mtu;
-
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-    tpm_setup_t              setup;
-
-    memset(&setup, 0, sizeof(tpm_setup_t));
-
-    numparms = count_parameters(buf);
-    if (numparms != mtu_max)
-    {
-        parm_error_completion(numparms, mtu_max, buf, sfs_help_setup);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d", &ipv4_or_ipv6, &direction, &mtu);
-        printk(KERN_INFO "ipv4_or_ipv6=%d, direction=%d. mtu[%d],\n", ipv4_or_ipv6, direction, mtu);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (ipv4_or_ipv6 >= 2)
-        {
-            printk(KERN_INFO "Invalid ipv4_or_ipv6[%d]\n", ipv4_or_ipv6);
-        }
-        else if (direction >= 2)
-        {
-            printk(KERN_INFO "Invalid direction[%d]\n", direction);
-        }
-        else
-        {
-            if ((rc = _tpm_proc_set_mtu(ipv4_or_ipv6, direction, mtu)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_proc_set_mtu failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_proc_set_pppoe_mtu_bounce(uint32_t ipv4_or_ipv6,
-					uint32_t direction,
-					uint32_t pppoe_mtu)
-{
-	tpm_ioctl_mtu_t *tpm_mtu_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_mtu_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MTU_SECTION;
-	tpm_mtu_set->mtu_setting_cmd = MV_TPM_IOCTL_SET_PPPOE_MTU;
-	tpm_mtu_set->ethertype = ipv4_or_ipv6;
-	tpm_mtu_set->direction = direction;
-	tpm_mtu_set->pppoe_mtu= pppoe_mtu;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_proc_set_pppoe_mtu tpm_proc_set_pppoe_mtu_bounce
-#else
- #define _tpm_proc_set_pppoe_mtu tpm_proc_set_pppoe_mtu
-#endif
-
-
-void sfs_tpm_cfg_set_pppoe_mtu (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        pppoe_mtu_ipv4_or_ipv6=0,  pppoe_mtu_direction, pppoe_mtu_value,  pppoe_mtu_max
-    } pppoe_mtu_indx_t;
-    // shell line parsing
-    uint32_t                 ipv4_or_ipv6;
-    uint32_t                 direction;
-    uint32_t                 pppoe_mtu;
-
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-    tpm_setup_t              setup;
-
-    memset(&setup, 0, sizeof(tpm_setup_t));
-
-    numparms = count_parameters(buf);
-    if (numparms != pppoe_mtu_max)
-    {
-        parm_error_completion(numparms, pppoe_mtu_max, buf, sfs_help_setup);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d", &ipv4_or_ipv6, &direction, &pppoe_mtu);
-        printk(KERN_INFO "ipv4_or_ipv6=%d, direction=%d. pppoe_mtu[%d],\n", ipv4_or_ipv6, direction, pppoe_mtu);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (ipv4_or_ipv6 >= 2)
-        {
-            printk(KERN_INFO "Invalid ipv4_or_ipv6[%d]\n", ipv4_or_ipv6);
-        }
-        else if (direction >= 2)
-        {
-            printk(KERN_INFO "Invalid direction[%d]\n", direction);
-        }
-        else
-        {
-            if ((rc = _tpm_proc_set_pppoe_mtu(ipv4_or_ipv6, direction, pppoe_mtu)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_proc_set_pppoe_mtu failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_gen_rule_bounce(uint32_t            owner_id,
-                                                uint32_t            rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_DEL_IPV6_GEN_ACL_RULE;
-    tpm_del_acl_rule->owner_id                      = owner_id;
-    tpm_del_acl_rule->rule_idx                      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_gen_rule tpm_del_ipv6_gen_rule_bounce
-#else
- #define _tpm_del_ipv6_gen_rule tpm_del_ipv6_gen_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_gen_acl
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW gen ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_gen_acl (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noipv6gen_owner=0, noipv6gen_ruleidx, noipv6gen_max
-    } noipv6genruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6gen_max)
-    {
-        parm_error_completion(numparms, noipv6gen_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-               len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_ipv6_gen_rule(ownerid,
-                                               rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_ipv6_gen_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_gen_rule_bounce(uint32_t                    owner_id,
-                                                tpm_src_port_type_t         src_port,
-                                                uint32_t                    rule_num,
-                                                uint32_t                   *rule_idx,
-                                                tpm_parse_fields_t          parse_rule_bm,
-                                                tpm_parse_flags_t           parse_flags_bm,
-                                                tpm_ipv6_gen_acl_key_t   *ipv6_gen_key,
-                                                tpm_pkt_frwd_t             *pkt_frwd,
-                                                tpm_pkt_mod_t              *pkt_mod,
-                                                tpm_pkt_mod_bm_t            pkt_mod_bm,
-                                                tpm_rule_action_t          *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                             = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                           = MV_TPM_IOCTL_ADD_IPV6_GEN_ACL_RULE;
-    tpm_add_acl_rule->owner_id                              = owner_id;
-    tpm_add_acl_rule->src_port                              = src_port;
-    tpm_add_acl_rule->rule_num                              = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                         = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_gen_acl_rule.parse_flags_bm    = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_mod_bm        = pkt_mod_bm;
-
-    memcpy(&(tpm_add_acl_rule->ipv6_gen_acl_rule.ipv6_gen_key), ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_frwd),       pkt_frwd,       sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_gen_acl_rule.pkt_mod),        pkt_mod,        sizeof(tpm_pkt_mod_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_gen_acl_rule.rule_action),    rule_action,    sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_gen_rule tpm_add_ipv6_gen_rule_bounce
-#else
- #define _tpm_add_ipv6_gen_rule tpm_add_ipv6_gen_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_gen_rule_add
-*
-* DESCRIPTION:
-*           This function create IPv6 general rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_gen_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6ruleadd_owner=0, ipv6ruleadd_srcport,   ipv6ruleadd_rulenum,  ipv6ruleadd_parserulebm,      ipv6ruleadd_parseflagsbm,
-        ipv6ruleadd_action,  ipv6ruleadd_nextphase, ipv6ruleadd_modbm,    ipv6ruleadd_ipv6genkeyname, ipv6ruleadd_frwdname,
-        ipv6ruleadd_modname, ipv6ruleadd_max
-    } ipv4ruleadd_parm_indx_t;
-
-    uint32_t            owner_id;
-    tpm_src_port_type_t src_port;
-    uint32_t            rule_num;
-    uint32_t            rule_idx;
-    tpm_parse_fields_t  parse_rule_bm;
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-
-    tpmcfg_ipv6_gen_key_entry_t *pdbipv6genkeyentry = 0;
-    tpmcfg_frwd_entry_t           *pdbfrwdentry         = 0;
-    tpmcfg_mod_entry_t            *pdbmodentry          = 0;
-
-    tpm_error_code_t    rc;
-    int                 indx;
-    int                 parsedargs;
-    int                 numparms;
-    uint32_t            action;
-    uint32_t            nextphase;
-    char                srcport_str[20];
-    char                uc_srcport_str[20];
-    char                nextphase_str[20];
-    char                ipv6genkeyname[30];
-    char                frwdname[20];
-    char                modname[20];
-
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6ruleadd_max)
-    {
-        parm_error_completion(numparms, ipv6ruleadd_max, buf, sfs_help_ipv6_gen_rule_add);
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x  0x%x %s 0x%x %s %s %s",
-                            &owner_id, srcport_str, &rule_num, &parse_rule_bm, &parse_flags_bm,
-                            &action, nextphase_str, &pkt_mod_bm, ipv6genkeyname, frwdname, modname);
-                printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], modbm[0x%x], ipv6keyname[%s], frwdname[%s], modname[%s]\n",
-                       len, parsedargs, owner_id, srcport_str, rule_num, parse_rule_bm, parse_flags_bm, action, nextphase_str, pkt_mod_bm, ipv6genkeyname, frwdname, modname);
-
-        for (indx = 0; indx < strlen(srcport_str); indx++)
-        {
-            uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        }
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else if (((pdbipv6genkeyentry = find_tpm_ipv6_gen_key_entry_by_name(ipv6genkeyname)) == 0) && \
-                    strcmp(ipv6genkeyname, ipv6_gen_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "IPV4 key entry [%s] not found\n", ipv6genkeyname);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && \
-                    strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && \
-                    strcmp(modname, mod_empty_name) != 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv6genkeyentry != 0)
-                memcpy(&ipv6_gen_key, &pdbipv6genkeyentry->ipv6gen_acl, sizeof(tpm_ipv6_gen_acl_key_t));
-            else
-                memset(&ipv6_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-
-            if (pdbfrwdentry != 0)
-                memcpy(&pkt_frwd, &pdbfrwdentry->frwd, sizeof(tpm_pkt_frwd_t));
-            else
-                memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)
-                memcpy(&pkt_mod, &pdbmodentry->mod, sizeof(tpm_pkt_mod_t));
-            else
-                memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-
-            if (TPM_RC_OK == (rc = _tpm_add_ipv6_gen_rule(owner_id,
-                                                            src_port,
-                                                            rule_num,
-                                                            &rule_idx,
-                                                            parse_rule_bm,
-                                                            parse_flags_bm,
-                                                            &ipv6_gen_key,
-                                                            &pkt_frwd,
-                                                            &pkt_mod,
-                                                            pkt_mod_bm,
-                                                            &rule_action)) )
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_gen_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_oam_epon_add_channel_bounce(uint32_t owner_id,
-						uint32_t cpu_rx_queue,
-						tpm_trg_port_type_t llid_num)
-{
-	tpm_ioctl_mng_ch_t *tpm_oam_epon_chan = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mng_channel;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MNG_SECTION;
-	tpm_oam_epon_chan->mng_cmd = MV_TPM_IOCTL_ADD_OAM_CHNL;
-	tpm_oam_epon_chan->tpm_ioctl_oam_ch.owner_id = owner_id;
-	tpm_oam_epon_chan->tpm_ioctl_oam_ch.cpu_rx_queue = cpu_rx_queue;
-	tpm_oam_epon_chan->tpm_ioctl_oam_ch.llid_num = llid_num;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_oam_epon_add_channel tpm_oam_epon_add_channel_bounce
-#else
- #define _tpm_oam_epon_add_channel tpm_oam_epon_add_channel
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_oam_channel
-*
-* DESCRIPTION:
-*           This function creates OAM channel HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_oam_channel  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        oam_owner=0, oam_rxq,  oam_llid,  oam_max
-    } oam_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rx_q;
-    uint32_t                 llid;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != oam_max)
-    {
-        parm_error_completion(numparms, oam_max, buf, sfs_help_oam_omci_channel);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d 0x%x", &ownerid, &rx_q, &llid);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rxq[%d], llid[0x%x]\n", len, parsedargs, ownerid, rx_q, llid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if ((rc = _tpm_oam_epon_add_channel (ownerid,
-                                                 rx_q,
-                                                 llid)) == TPM_RC_OK)
-        {
-            printk(KERN_INFO "OK\n");
-        }
-        else
-        {
-            printk(KERN_INFO "%s: tpm_oam_epon_add_channel failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_omci_add_channel_bounce(uint32_t owner_id,
-						tpm_gem_port_key_t gem_port,
-						uint32_t cpu_rx_queue,
-						tpm_trg_port_type_t tcont_num,
-						uint32_t cpu_tx_queue)
-{
-	tpm_ioctl_mng_ch_t *tpm_omci_gpon_chan = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mng_channel;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MNG_SECTION;
-	tpm_omci_gpon_chan->mng_cmd = MV_TPM_IOCTL_ADD_OMCI_CHNL;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.owner_id = owner_id;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.gem_port = gem_port;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.cpu_rx_queue = cpu_rx_queue;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.tcont_num = tcont_num;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.cpu_tx_queue = cpu_tx_queue;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_omci_add_channel tpm_omci_add_channel_bounce
-#else
- #define _tpm_omci_add_channel tpm_omci_add_channel
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_omci_channel
-*
-* DESCRIPTION:
-*           This function creates creates an OMCI channel HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_omci_channel  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        omci_owner=0, omci_gemport,  omci_rxq,  omci_txq,  omci_tcont,  omci_max
-    } omci_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 gemport;
-    uint32_t                 rx_q;
-    uint32_t                 tx_q;
-    uint32_t                 tcont;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != omci_max)
-    {
-        parm_error_completion(numparms, omci_max, buf, sfs_help_oam_omci_channel);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d %d 0x%x", &ownerid, &gemport, &rx_q, &tx_q, &tcont);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], gemport[%d], rx_q[%d], tx_q[%d], tcont[0x%x]\n",
-//               len, parsedargs, ownerid, gemport, rx_q, tx_q, tcont);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (gemport >= 255)
-        {
-            printk(KERN_INFO "invalid gemport[%d]\n", gemport);
-        }
-        else
-        {
-            if ((rc = _tpm_omci_add_channel (ownerid,
-                                            (uint16_t)gemport,
-                                            rx_q,
-                                            tcont,
-                                            tx_q)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_omci_add_channel failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_oam_epon_del_channel_bounce(uint32_t owner_id)
-{
-	tpm_ioctl_mng_ch_t *tpm_oam_epon_chan = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mng_channel;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MNG_SECTION;
-	tpm_oam_epon_chan->mng_cmd = MV_TPM_IOCTL_DEL_OAM_CHNL;
-	tpm_oam_epon_chan->tpm_ioctl_oam_ch.owner_id = owner_id;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_oam_epon_del_channel tpm_oam_epon_del_channel_bounce
-#else
- #define _tpm_oam_epon_del_channel tpm_oam_epon_del_channel
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_oam_channel
-*
-* DESCRIPTION:
-*           This function deletes OAM channel HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_oam_channel  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        nooam_owner=0, nooam_max
-    } oam_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-
-    if (numparms == 1 && buf[0] == '?')
-    {
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-        char helpbuf[1000];
-        int  helpbuf_len;
-
-        helpbuf_len = sfs_help_no_oam_omci_channel(helpbuf);
-        print_help_buffer(helpbuf, helpbuf_len);
-#else
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", nooam_max, numparms);
-#endif
-    }
-    else if (numparms != 1)
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", nooam_max, numparms);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d", &ownerid);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d]\n", len, parsedargs, ownerid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if ((rc = _tpm_oam_epon_del_channel (ownerid)) == TPM_RC_OK)
-        {
-            printk(KERN_INFO "OK\n");
-        }
-        else
-        {
-            printk(KERN_INFO "%s: tpm_oam_epon_del_channel failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_omci_del_channel_bounce(uint32_t owner_id)
-{
-	tpm_ioctl_mng_ch_t *tpm_omci_gpon_chan = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mng_channel;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MNG_SECTION;
-	tpm_omci_gpon_chan->mng_cmd = MV_TPM_IOCTL_DEL_OMCI_CHNL;
-	tpm_omci_gpon_chan->tpm_ioctl_omci_ch.owner_id = owner_id;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
- #define _tpm_omci_del_channel tpm_omci_del_channel_bounce
-#else
- #define _tpm_omci_del_channel tpm_omci_del_channel
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_omci_channel
-*
-* DESCRIPTION:
-*           This function creates creates an OMCI channel HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_omci_channel  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noomci_owner=0, noomci_max
-    } noomci__parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-
-    if (numparms == 1 && buf[0] == '?')
-    {
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-        char helpbuf[1000];
-        int  helpbuf_len;
-
-        helpbuf_len = sfs_help_no_oam_omci_channel(helpbuf);
-        print_help_buffer(helpbuf, helpbuf_len);
-#else
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", noomci_max, numparms);
-#endif
-    }
-    else if (numparms != 1)
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", noomci_max, numparms);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d ", &ownerid);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d]\n", len, parsedargs, ownerid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if ((rc = _tpm_omci_del_channel (ownerid)) == TPM_RC_OK)
-        {
-            printk(KERN_INFO "OK\n");
-        }
-        else
-        {
-            printk(KERN_INFO "%s: tpm_omci_del_channel failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_setup
-*
-* DESCRIPTION:
-*           This function initializes tpm module
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_setup  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        /*setup_ponype=0,  */setup_filename=0, setup_max
-    } setup_parm_indx_t;
-    // shell line parsing
-    /*uint32_t                 pon_type;*/
-    char                     filename[XML_FILE_PATH_LENGTH];
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-    tpm_setup_t              setup;
-
-    memset(&setup, 0, sizeof(tpm_setup_t));
-
-    numparms = count_parameters(buf);
-    if (numparms != setup_max)
-    {
-        parm_error_completion(numparms, setup_max, buf, sfs_help_setup);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s", filename);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], level[%d]\n", len, parsedargs, ownerid, level);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        /*else if (pon_type >= TPM_NONE)
-        {
-            printk(KERN_INFO "Invalid pon_type[%d]\n", pon_type);
-        }*/
-        else
-        {
-            /*setup.pon_type = pon_type;*/
-            if (strcmp(filename, "default"))
-            {
-                strcpy(setup.xml_file_path, filename);
-            }
-            if ((rc = module_tpmSetup(&setup)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: module_tpmSetup failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mib_reset_bounce(uint32_t     owner_id,
-                                      uint32_t     level)
-{
-    tpm_ioctl_mib_reset_t *tpm_mib_reset_param = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mib_reset_param;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_RESET_SECTION;
-    tpm_mib_reset_param->owner_id       = owner_id;
-    tpm_mib_reset_param->reset_level    = level;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_mib_reset tpm_mib_reset_bounce
-#else
- #define _tpm_mib_reset tpm_mib_reset
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mib_reset
-*
-* DESCRIPTION:
-*           This function creates does a MIB reset
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mib_reset  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mibreset_owner=0, mibreset_gemport,  mibreset_max
-    } mibreset_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 level;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mibreset_max)
-    {
-        parm_error_completion(numparms, mibreset_max, buf, sfs_help_mib_reset);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &level);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], level[%d]\n", len, parsedargs, ownerid, level);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (level > TPM_ENUM_MAX_RESET_LEVEL)
-        {
-            printk(KERN_INFO "Invalid level[%d]\n", level);
-        }
-        else
-        {
-            if ((rc = _tpm_mib_reset(ownerid,
-                                     level)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_mib_reset failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_active_wan_bounce(uint32_t     owner_id,
-                                           tpm_gmacs_enum_t active_wan)
-{
-    tpm_ioctl_set_active_wan_t *tpm_set_active_wan_param = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_set_active_wan_param;
-
-    tpm_sfs_2_ioctl_command.cmd              = MV_TPM_IOCTL_SET_ACTIVE_WAN_SECTION;
-    tpm_set_active_wan_param->owner_id       = owner_id;
-    tpm_set_active_wan_param->active_wan     = active_wan;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_active_wan tpm_set_active_wan_bounce
-#else
- #define _tpm_set_active_wan tpm_set_active_wan
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_set_active_wan
-*
-* DESCRIPTION:
-*           This function sets active wan port
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_active_wan  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-	activewan_owner=0, activewan_active_wan,  activewan_max
-    } activewan_parm_indx_t;
-    // shell line parsing
-    uint32_t		     ownerid;
-    int 		     parsedargs;
-    int 		     numparms;
-    //Used in API call
-    tpm_error_code_t	     rc;
-    tpm_gmacs_enum_t	     active_wan;
-
-    numparms = count_parameters(buf);
-    if (numparms != activewan_max)
-    {
-	parm_error_completion(numparms, activewan_max, buf, sfs_help_set_active_wan);
-    }
-    else
-    {
-	// Get parameters
-	parsedargs = sscanf(buf, "%d %d", &ownerid, &active_wan);
-//	  printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], active_wan_int[%d]\n",
-//			len, parsedargs, ownerid, active_wan);
-
-	if (parsedargs != numparms)
-	{
-	    printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-	}
-	else if (active_wan >= TPM_MAX_NUM_GMACS)
-	{
-	    printk(KERN_INFO "Invalid active_wan[%d]\n", active_wan);
-	}
-	else
-	{
-	    if ((rc = _tpm_set_active_wan(ownerid,
-					  active_wan)) == TPM_RC_OK)
-	    {
-		printk(KERN_INFO "OK\n");
-	    }
-	    else
-	    {
-		printk(KERN_INFO "%s: tpm_set_active_wan failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-	    }
-	}
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_hot_swap_profile_bounce(uint32_t     owner_id,
-                                           tpm_eth_complex_profile_t profile_id)
-{
-    tpm_ioctl_hot_swap_profile_t *tpm_hot_swap_profile_param = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_hot_swap_profile_param;
-
-    tpm_sfs_2_ioctl_command.cmd              = MV_TPM_IOCTL_HOT_SWAP_PROFILE_SECTION;
-    tpm_hot_swap_profile_param->owner_id       = owner_id;
-    tpm_hot_swap_profile_param->profile_id     = profile_id;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_hot_swap_profile tpm_hot_swap_profile_bounce
-#else
- #define _tpm_hot_swap_profile tpm_hot_swap_profile
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_hot_swap_profile
-*
-* DESCRIPTION:
-*           This function swap profile in run time
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_hot_swap_profile  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-	hotswap_owner=0, hotswap_profile_id,  hotswap_max
-    } hotswap_parm_indx_t;
-    // shell line parsing
-    uint32_t		     ownerid;
-    int 		     parsedargs;
-    int 		     numparms;
-    //Used in API call
-    tpm_error_code_t	     rc;
-    uint32_t	     profile_id;
-
-    numparms = count_parameters(buf);
-    if (numparms != hotswap_max)
-    {
-	parm_error_completion(numparms, hotswap_max, buf, sfs_help_hot_swap_profile);
-    }
-    else
-    {
-	// Get parameters
-	parsedargs = sscanf(buf, "%d %d", &ownerid, &profile_id);
-//	  printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], profile_id_int[%d]\n",
-//			len, parsedargs, ownerid, profile_id);
-
-	if (parsedargs != numparms)
-	{
-	    printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-	}
-	else
-	{
-	    if ((rc = _tpm_hot_swap_profile(ownerid,
-					  profile_id)) == TPM_RC_OK)
-	    {
-		printk(KERN_INFO "OK\n");
-	    }
-	    else
-	    {
-		printk(KERN_INFO "%s: tpm_hot_swap_profile failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-	    }
-	}
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_port_hwf_admin_bounce(uint32_t	   owner_id,
-							  tpm_gmacs_enum_t port,
-							  uint8_t	   txp,
-							  uint8_t	   enable)
-{
-    tpm_ioctl_set_port_hwf_admin_t *tpm_set_port_hwf_admin_param = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_set_port_hwf_admin_param;
-
-    tpm_sfs_2_ioctl_command.cmd              = MV_TPM_IOCTL_SET_PORT_HWF_ADMIN_SECTION;
-    tpm_set_port_hwf_admin_param->owner_id   = owner_id;
-    tpm_set_port_hwf_admin_param->port       = port;
-    tpm_set_port_hwf_admin_param->txp        = txp;
-    tpm_set_port_hwf_admin_param->enable     = enable;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_port_hwf_admin tpm_set_port_hwf_admin_bounce
-#else
- #define _tpm_set_port_hwf_admin tpm_proc_hwf_admin_set
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_set_port_hwf_admin
-*
-* DESCRIPTION:
-*           This function set port hwf enable/disable
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_port_hwf_admin  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-	setporthwfadmin_owner=0, setporthwfadmin_port, setporthwfadmin_txp,
-	setporthwfadmin_enable, setporthwfadmin_max
-    } setporthwfadmin_parm_indx_t;
-    // shell line parsing
-    int 		     parsedargs;
-    int 		     numparms;
-    //Used in API call
-    tpm_error_code_t	   rc;
-    uint32_t               ownerid;
-    tpm_gmacs_enum_t       port;
-    uint32_t               txp;
-    uint32_t               enable;
-
-    numparms = count_parameters(buf);
-    if (numparms != setporthwfadmin_max)
-    {
-	parm_error_completion(numparms, setporthwfadmin_max, buf, sfs_help_set_port_hwf_admin);
-    }
-    else
-    {
-	// Get parameters
-	parsedargs = sscanf(buf, "%d %d %d %d", &ownerid, &port, &txp, &enable);
-//	  printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], port[%d], txp[%d], enable[%d]\n",
-//			len, parsedargs, ownerid, port, txp, enable);
-
-	if (parsedargs != numparms)
-	{
-	    printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-	}
-	else
-	{
-	    if ((rc = _tpm_set_port_hwf_admin(port, txp, enable)) == TPM_RC_OK)
-	    {
-		printk(KERN_INFO "OK\n");
-	    }
-	    else
-	    {
-		printk(KERN_INFO "%s: tpm_set_port_hwf_admin failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-	    }
-	}
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_erase_section
-*
-* DESCRIPTION:
-*           This function erases a section per an application group.
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_erase_section(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		section_owner_id=0, section_api_type, erase_section_max
-	} erase_section_parm_indx_t;
-	/*shell line parsing*/
-	uint32_t                 ownerid;
-	uint32_t                 api_type;
-	int                      parsedargs;
-	int                      numparms;
-	tpm_error_code_t         rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != erase_section_max)
-		parm_error_completion(numparms, erase_section_max, buf, sfs_help_erase_section);
-	else {
-		/*get parameters*/
-		parsedargs = sscanf(buf, "%d %d", &ownerid, &api_type);
-		if(parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else if (api_type > TPM_MAX_API_TYPES)
-			printk(KERN_INFO "Invalid api type[%d]\n", api_type);
-		else {
-			if ((rc = tpm_erase_section(ownerid, api_type)) == TPM_RC_OK)
-				printk(KERN_INFO "OK\n");
-			else
-				printk(KERN_INFO "%s: tpm_erase_section failed, rc[%d] - %s\n",
-				__FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_cpu_wan_loopback_bounce(uint32_t         owner_id,
-                                                 tpm_pkt_frwd_t  *pkt_frwd,
-                                                 uint32_t        *mod_idx)
-{
-    tpm_ioctl_cpu_lpbk_t *tpm_ioctl_cpu_lpbk = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_cpu_lpbk;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_CPU_LPBK_SECTION;
-    tpm_ioctl_cpu_lpbk->cpu_lpbk_cmd    = MV_TPM_IOCTL_ADD_CPU_WAN_LPBK;
-    tpm_ioctl_cpu_lpbk->owner_id        = owner_id;
-    memcpy(&(tpm_ioctl_cpu_lpbk->pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_cpu_wan_loopback tpm_add_cpu_wan_loopback_bounce
-#else
- #define _tpm_add_cpu_wan_loopback tpm_add_cpu_wan_loopback
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_add_cpu_lpbk
-*
-* DESCRIPTION:
-*           This function adds CPU WAN loopback
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_add_cpu_lpbk  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        lpbk_owner=0, lpbk_port, lpbk_que, lpbk_gem, lpbk_max
-    } lpbk_parm_indx_t;
-    uint32_t            ownerid;
-    uint32_t            temp_port;
-    uint32_t            temp_que;
-    uint32_t            temp_gem;
-    int                 parsedargs;
-    int                 numparms;
-    tpm_error_code_t    rc;
-    tpm_pkt_frwd_t      frwd_entry;
-    uint32_t            mod_idx;
-
-    numparms = count_parameters(buf);
-    if (numparms != lpbk_max)
-    {
-        parm_error_completion(numparms, lpbk_max, buf, sfs_help_cfg_cpu_lpbk);
-    }
-    else
-    {
-        /* Get parameters */
-        parsedargs = sscanf(buf, "%d 0x%x %d %d", &ownerid, &temp_port, &temp_que, &temp_gem);
-/*
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%s] temp_port[0x%x],temp_que[%d],temp_gem[%d]\n",
-               len, parsedargs, ownerid, temp_port, temp_que, temp_gem);
-*/
-        if (temp_que > 7)
-        {
-            printk(KERN_INFO "Invalid queue [%d]\n", temp_que);
-        }
-        else if (temp_gem > 4095)
-        {
-            printk(KERN_INFO "Invalid gem port [%d]\n", temp_gem);
-        }
-        else
-        {
-            frwd_entry.trg_port  = (tpm_trg_port_type_t)temp_port;
-            frwd_entry.trg_queue = (uint8_t)temp_que;
-            frwd_entry.gem_port  = (uint16_t)temp_gem;
-
-            rc = _tpm_add_cpu_wan_loopback(TPM_MOD_OWNER_TPM, &frwd_entry, &mod_idx);
-            if(TPM_RC_OK != rc)
-            {
-                printk(KERN_ERR "Failed to call tpm_add_cpu_wan_loopback, ret_code[%d]\n", rc);
-            }
-            else
-            {
-                printk(KERN_ERR "Call tpm_add_cpu_wan_loopback successfully, mod_idx[%d]\n", mod_idx);
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_cpu_wan_loopback_bounce(uint32_t         owner_id,
-                                                 tpm_pkt_frwd_t  *pkt_frwd)
-{
-    tpm_ioctl_cpu_lpbk_t *tpm_ioctl_cpu_lpbk = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_cpu_lpbk;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_CPU_LPBK_SECTION;
-    tpm_ioctl_cpu_lpbk->cpu_lpbk_cmd    = MV_TPM_IOCTL_DEL_CPU_WAN_LPBK;
-    tpm_ioctl_cpu_lpbk->owner_id        = owner_id;
-    memcpy(&(tpm_ioctl_cpu_lpbk->pkt_frwd), pkt_frwd, sizeof(tpm_pkt_frwd_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_cpu_wan_loopback tpm_del_cpu_wan_loopback_bounce
-#else
- #define _tpm_del_cpu_wan_loopback tpm_del_cpu_wan_loopback
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_del_cpu_lpbk
-*
-* DESCRIPTION:
-*           This function delete CPU WAN loopback
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_del_cpu_lpbk  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        lpbk_owner=0, lpbk_port, lpbk_que, lpbk_gem, lpbk_max
-    } lpbk_parm_indx_t;
-    uint32_t            ownerid;
-    uint32_t            temp_port;
-    uint32_t            temp_que;
-    uint32_t            temp_gem;
-    int                 parsedargs;
-    int                 numparms;
-    tpm_error_code_t    rc;
-    tpm_pkt_frwd_t      frwd_entry;
-
-    numparms = count_parameters(buf);
-    if (numparms != lpbk_max)
-    {
-        parm_error_completion(numparms, lpbk_max, buf, sfs_help_cfg_cpu_lpbk);
-    }
-    else
-    {
-        /* Get parameters */
-        parsedargs = sscanf(buf, "%d 0x%x %d %d", &ownerid, &temp_port, &temp_que, &temp_gem);
-/*
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%s] temp_port[0x%x],temp_que[%d],temp_gem[%d]\n",
-               len, parsedargs, ownerid, temp_port, temp_que, temp_gem);
-*/
-        if (temp_que > 7)
-        {
-            printk(KERN_INFO "Invalid queue [%d]\n", temp_que);
-        }
-        else if (temp_gem > 4095)
-        {
-            printk(KERN_INFO "Invalid gem port [%d]\n", temp_gem);
-        }
-        else
-        {
-            frwd_entry.trg_port  = (tpm_trg_port_type_t)temp_port;
-            frwd_entry.trg_queue = (uint8_t)temp_que;
-            frwd_entry.gem_port  = (uint16_t)temp_gem;
-
-            rc = _tpm_del_cpu_wan_loopback(TPM_MOD_OWNER_TPM, &frwd_entry);
-            if(TPM_RC_OK != rc)
-            {
-                printk(KERN_ERR "Failed to call tpm_del_cpu_wan_loopback, ret_code[%d]\n", rc);
-            }
-            else
-            {
-                printk(KERN_ERR "Call tpm_del_cpu_wan_loopback successfully\n");
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_dump_cpu_lpbk
-*
-* DESCRIPTION:
-*           This function dumps all valid CPU WAN loopback entries from DB
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_dump_cpu_lpbk  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        lpbk_owner=0, lpbk_max
-    } lpbk_parm_indx_t;
-    uint32_t            ownerid;
-    int                 parsedargs;
-    int                 numparms;
-
-    numparms = count_parameters(buf);
-    if (numparms != lpbk_max)
-    {
-        parm_error_completion(numparms, lpbk_max, buf, sfs_help_cfg_cpu_lpbk);
-    }
-    else
-    {
-        /* Get parameters */
-        parsedargs = sscanf(buf, "%d", &ownerid);
-        /*
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%s]\n",
-               len, parsedargs, ownerid);
-        */
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            tpm_print_cpu_lpbk_entry();
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_get_lu_entry
-*
-* DESCRIPTION:
-*           This function dumps least used PnC entries
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_get_lu_entry (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_group, age_lu_num, age_lu_reset, age_max
-    } age_parm_indx_t;
-    uint32_t            owner_id;
-    uint32_t            api_group;
-    uint32_t            lu_num;
-    uint32_t            lu_reset;
-    int                 parsed_args_num;
-    int                 param_num;
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d %d %d", &owner_id, &api_group, &lu_num, &lu_reset);
-        /*
-        printk(KERN_INFO "len=%d, parsed_args_num[%d], ownerid[%d], api_group[%d], lu_num[%d], lu_reset[%d]\n",
-               len, parsed_args_num, owner_id, api_group, lu_num, lu_reset);
-        */
-
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            if((lu_num <= 0) || ( lu_num > TPM_MAX_LU_ENTRY_NUM))
-            {
-                printk(KERN_INFO "lu_num[%d] is illegal, allowed lu_num[1~%d]\n", lu_num, TPM_MAX_LU_ENTRY_NUM);
-                return;
-            }
-
-            tpm_print_tcam_lu_entry(owner_id, api_group, lu_num, lu_reset);
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_get_pnc_all_hit_counters_bounce(uint32_t               owner_id,
-                                                    tpm_api_type_t          api_type,
-                                                    uint32_t                high_thresh_pkts,
-                                                    uint8_t                 counters_reset,
-                                                    uint16_t               *valid_counters,
-                                                    tpm_api_entry_count_t  *count_array)
-{
-    tpm_ioctl_pnc_hit_cnt_t *tpm_ioctl_pnc_hit_cnt = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_pnc_hit_cnt;
-
-    tpm_sfs_2_ioctl_command.cmd             = MV_TPM_IOCTL_AGE_COUNT_SECTION;
-    tpm_ioctl_pnc_hit_cnt->age_count_cmd    = MV_TPM_IOCTL_GET_ALL_HIT_COUNTERS;
-    tpm_ioctl_pnc_hit_cnt->owner_id         = owner_id;
-    tpm_ioctl_pnc_hit_cnt->api_type         = api_type;
-    tpm_ioctl_pnc_hit_cnt->high_thresh_pkts = high_thresh_pkts;
-    tpm_ioctl_pnc_hit_cnt->counter_reset    = counters_reset;
-    tpm_ioctl_pnc_hit_cnt->valid_counters   = *valid_counters;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_get_pnc_all_hit_counters tpm_get_pnc_all_hit_counters_bounce
- #define _tpm_print_pnc_all_hit_counters(a,b,c,d,e,f)
-#else
- #define _tpm_get_pnc_all_hit_counters tpm_get_pnc_all_hit_counters
- #define _tpm_print_pnc_all_hit_counters(a,b,c,d,e,f) tpm_print_pnc_all_hit_counters(a,b,c,d,e,f)
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_get_pnc_all_hit_counters
-*
-* DESCRIPTION:
-*           This function prints all pnc hit counters per API type masking out
-*           high counter values according to high_thresh_pkts
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_get_pnc_all_hit_counters (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_type, age_high_thresh_pkts, age_counters_reset, age_valid_counters, age_max
-    } age_parm_indx_t;
-    uint32_t                owner_id;
-    uint32_t                api_type;
-    uint32_t                high_thresh_pkts;
-    uint32_t                counters_reset;
-    uint32_t                valid_counters;
-    int                     parsed_args_num;
-    int                     param_num;
-    tpm_error_code_t        ret_code;
-
-    memset(count_array, 0, sizeof(count_array));
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d %d %d %d", &owner_id, &api_type, &high_thresh_pkts,
-                                 &counters_reset, &valid_counters);
-
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            ret_code = _tpm_get_pnc_all_hit_counters(owner_id,
-                                                     api_type,
-                                                     high_thresh_pkts,
-                                                     counters_reset,
-                                                    (uint16_t*)&valid_counters,
-                                                    &(count_array[0]));
-
-            if (TPM_RC_OK == ret_code)
-            {
-                _tpm_print_pnc_all_hit_counters(owner_id,
-                                                api_type, high_thresh_pkts,
-                                                (uint8_t)counters_reset,
-                                                valid_counters,
-                                                &(count_array[0]));
-            }
-            else
-            {
-                printk(KERN_INFO "%s: _tpm_get_pnc_all_hit_counters failed, rc[%d] - %s\n",
-                       __FUNCTION__, ret_code, get_tpm_err_str(ret_code));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_pnc_counter_mask_bounce(uint32_t           owner_id,
-                                                 tpm_api_type_t     api_type,
-                                                 uint32_t           rule_idx,
-                                                 uint32_t           lu_rule_mask)
-{
-    tpm_ioctl_age_count_t *tpm_ioctl_age_count = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_age_count;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_AGE_COUNT_SECTION;
-    tpm_ioctl_age_count->age_count_cmd  = MV_TPM_IOCTL_SET_LU_COUNT_MASK;
-    tpm_ioctl_age_count->owner_id       = owner_id;
-    tpm_ioctl_age_count->api_type       = api_type;
-    tpm_ioctl_age_count->rule_idx       = rule_idx;
-    tpm_ioctl_age_count->lu_rule_mask   = lu_rule_mask;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_pnc_counter_mask tpm_set_pnc_counter_mask_bounce
-#else
- #define _tpm_set_pnc_counter_mask tpm_set_pnc_counter_mask
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_count_mask
-*
-* DESCRIPTION:
-*           This function sets count mask
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_count_mask (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_group, age_rule_idx, age_lu_rule_mask, age_max
-    } age_parm_indx_t;
-    uint32_t            owner_id;
-    uint32_t            api_group;
-    uint32_t            rule_idx;
-    uint32_t            lu_rule_mask;
-    int                 parsed_args_num;
-    int                 param_num;
-    tpm_error_code_t    ret_code;
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d %d %d", &owner_id, &api_group, &rule_idx, &lu_rule_mask);
-        /*
-        printk(KERN_INFO "len=%d, parsed_args_num[%d], ownerid[%d], api_group[%d], rule_idx[%d], lu_rule_mask[%d]\n",
-               len, parsed_args_num, owner_id, api_group, rule_idx, lu_rule_mask);
-        */
-
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            if ((ret_code = _tpm_set_pnc_counter_mask(owner_id,
-                                                      api_group,
-                                                      rule_idx,
-                                                      lu_rule_mask)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_set_pnc_counter_mask failed, rc[%d] - %s\n", __FUNCTION__,
-                       ret_code, get_tpm_err_str(ret_code));
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_get_pnc_hit_count_bounce(uint32_t             owner_id,
-                                              tpm_api_type_t       api_type,
-                                              uint32_t             rule_idx,
-                                              uint8_t              hit_reset,
-                                              uint32_t            *hit_count)
-{
-    tpm_ioctl_age_count_t *tpm_ioctl_age_count = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_age_count;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_AGE_COUNT_SECTION;
-    tpm_ioctl_age_count->age_count_cmd  = MV_TPM_IOCTL_GET_HIT_COUNT;
-    tpm_ioctl_age_count->owner_id       = owner_id;
-    tpm_ioctl_age_count->api_type       = api_type;
-    tpm_ioctl_age_count->rule_idx       = rule_idx;
-    tpm_ioctl_age_count->hit_reset      = hit_reset;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_get_pnc_hit_count tpm_get_pnc_hit_count_bounce
-#else
- #define _tpm_get_pnc_hit_count tpm_get_pnc_hit_count
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_get_hit_count
-*
-* DESCRIPTION:
-*           This function sets count mask
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_get_hit_count (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_group, age_rule_idx, age_hit_reset, age_max
-    } age_parm_indx_t;
-    uint32_t            owner_id;
-    uint32_t            api_group;
-    uint32_t            rule_idx;
-    int                 parsed_args_num;
-    int                 param_num;
-    uint32_t            hit_count = 0;
-    uint32_t            hit_reset;
-    tpm_error_code_t    ret_code;
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d %d %d", &owner_id, &api_group, &rule_idx, &hit_reset);
-        /*
-        printk(KERN_INFO "len=%d, parsed_args_num[%d], ownerid[%d], range_id[%d], rule_idx[%d]\n",
-               len, parsed_args_num, owner_id, range_id, rule_idx);
-        */
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            if ((ret_code = _tpm_get_pnc_hit_count(owner_id,
-                                                   api_group,
-                                                   rule_idx,
-                                                   (uint8_t)hit_reset,
-                                                   &hit_count)) == TPM_RC_OK)
-                PR_HIT_COUNT(hit_count)
-            else
-                printk(KERN_INFO "%s: tpm_get_pnc_hit_count failed, rc[%d] - %s\n", __FUNCTION__,
-                       ret_code, get_tpm_err_str(ret_code));
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_set_pnc_lu_threshold_bounce(uint32_t             owner_id,
-                                                 tpm_api_type_t       api_type,
-                                                 uint32_t             lu_thresh_pkts)
-{
-    tpm_ioctl_age_count_t *tpm_ioctl_age_count = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_age_count;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_AGE_COUNT_SECTION;
-    tpm_ioctl_age_count->age_count_cmd  = MV_TPM_IOCTL_SET_LU_THESHOLD;
-    tpm_ioctl_age_count->owner_id       = owner_id;
-    tpm_ioctl_age_count->api_type       = api_type;
-    tpm_ioctl_age_count->lu_thresh_pkts = lu_thresh_pkts;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_set_pnc_lu_threshold tpm_set_pnc_lu_threshold_bounce
-#else
- #define _tpm_set_pnc_lu_threshold tpm_set_pnc_lu_threshold
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_lu_thresh
-*
-* DESCRIPTION:
-*           This function sets count mask
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_lu_thresh (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_group, age_lu_thresh_pkts, age_max
-    } age_parm_indx_t;
-    uint32_t            owner_id;
-    uint32_t            api_group;
-    uint32_t            lu_thresh_pkts;
-    int                 parsed_args_num;
-    int                 param_num;
-    tpm_error_code_t    ret_code;
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d %d", &owner_id, &api_group, &lu_thresh_pkts);
-        /*
-        printk(KERN_INFO "len=%d, parsed_args_num[%d], ownerid[%d], api_group[%d], rule_idx[%d]\n",
-               len, parsed_args_num, owner_id, api_group, rule_idx);
-        */
-
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            if ((ret_code = _tpm_set_pnc_lu_threshold(owner_id,
-                                                     api_group,
-                                                     lu_thresh_pkts)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_set_pnc_lu_threshold failed, rc[%d] - %s\n", __FUNCTION__,
-                       ret_code, get_tpm_err_str(ret_code));
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_reset_pnc_age_group_bounce(uint32_t                owner_id,
-                                                tpm_api_type_t          api_type)
-{
-    tpm_ioctl_age_count_t *tpm_ioctl_age_count = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_age_count;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_AGE_COUNT_SECTION;
-    tpm_ioctl_age_count->age_count_cmd  = MV_TPM_IOCTL_RESET_COUNT_GROUP;
-    tpm_ioctl_age_count->owner_id       = owner_id;
-    tpm_ioctl_age_count->api_type       = api_type;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_reset_pnc_age_group tpm_reset_pnc_age_group_bounce
-#else
- #define _tpm_reset_pnc_age_group tpm_reset_pnc_age_group
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_reset_age_group
-*
-* DESCRIPTION:
-*           This function sets count mask
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_reset_age_group (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        age_owner_id=0, age_api_group,  age_max
-    } age_parm_indx_t;
-    uint32_t            owner_id;
-    uint32_t            api_group;
-    int                 parsed_args_num;
-    int                 param_num;
-    tpm_error_code_t    ret_code;
-
-    param_num = count_parameters(buf);
-    if (param_num != age_max)
-    {
-        parm_error_completion(param_num, age_max, buf, sfs_help_cfg_age_count);
-    }
-    else
-    {
-        /* Get parameters */
-        parsed_args_num = sscanf(buf, "%d %d", &owner_id, &api_group);
-        /*
-        printk(KERN_INFO "len=%d, parsed_args_num[%d], ownerid[%d], api_group[%d]\n",
-               len, parsed_args_num, owner_id, api_group);
-        */
-
-        if (parsed_args_num != param_num)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args_num, param_num);
-        }
-        else
-        {
-            if ((ret_code = _tpm_reset_pnc_age_group(owner_id,
-                                                     api_group)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_reset_pnc_age_group failed, rc[%d] - %s\n", __FUNCTION__,
-                       ret_code, get_tpm_err_str(ret_code));
-        }
-    }
-}
-
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_tm_set_wan_q_ingr_rate_lim_bounce(uint32_t owner_id,
-							uint32_t queue_id,
-							uint32_t rate_limit_val,
-							uint32_t bucket_size)
-{
-	tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_QUE_INGR_RATE_LIMIT;
-	tpm_tm_tm_set->owner_id = owner_id;
-	tpm_tm_tm_set->queue_id = queue_id;
-	tpm_tm_tm_set->rate_limit_val = rate_limit_val;
-	tpm_tm_tm_set->bucket_size = bucket_size;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
-
- tpm_error_code_t tpm_tm_set_wan_queue_egr_rate_lim_bounce(uint32_t owner_id,
-							tpm_trg_port_type_t sched_ent,
-							uint32_t queue_id,
-							uint32_t rate_limit_val,
-							uint32_t bucket_size)
- {
-	 tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	 tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	 tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_QUE_EGR_RATE_LIMIT;
-	 tpm_tm_tm_set->owner_id = owner_id;
-	 tpm_tm_tm_set->sched_ent = sched_ent;
-	 tpm_tm_tm_set->queue_id = queue_id;
-	 tpm_tm_tm_set->rate_limit_val = rate_limit_val;
-	 tpm_tm_tm_set->bucket_size = bucket_size;
-
-	 up(&tpm_sfs_2_ioctl_sem);
-
-	 return TPM_RC_OK;
- }
-
- #define _tpm_tm_set_wan_q_ingr_rate_lim tpm_tm_set_wan_q_ingr_rate_lim_bounce
- #define _tpm_tm_set_wan_queue_egr_rate_lim tpm_tm_set_wan_queue_egr_rate_lim_bounce
-#else
- #define _tpm_tm_set_wan_q_ingr_rate_lim tpm_tm_set_wan_q_ingr_rate_lim
- #define _tpm_tm_set_wan_queue_egr_rate_lim tpm_tm_set_wan_queue_egr_rate_lim
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_rate_limit_queue_set
-*
-* DESCRIPTION:
-*           This function sets rate limit on queue
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_rate_limit_queue_set       (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        qratelim_owner=0, qratelim_direction, qratelim_if, qratelim_que, qratelim_rate_limit, qratelim_bucket_size, qratelim_max
-    } qratelim_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    char                     direction_str[20];
-    uint32_t                 direction;
-    char                     entity_str[20];
-    char                     uc_entity_str[20];
-    int                      indx;
-    uint32_t                 entity;
-    uint32_t                 que;
-    uint32_t                 rate_limit;
-    uint32_t                 bucket_size;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != qratelim_max)
-    {
-        parm_error_completion(numparms, qratelim_max, buf, sfs_help_rate_limit);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %s %d %d %d", &ownerid, direction_str, entity_str, &que, &rate_limit, &bucket_size);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], direction_str[%s], entity_str[%s], que[%d], rate_limit[%d], bucket_size[%d]\n",
-//               len, parsedargs, ownerid, direction_str, entity_str, que, rate_limit, bucket_size);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(entity_str); indx++) uc_entity_str[indx] = (char)toupper(entity_str[indx]);
-        uc_entity_str[strlen(entity_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_direction_value(direction_str, &direction) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid direction[%s]\n", direction_str);
-        }
-        else if (get_sched_entity_value(uc_entity_str, &entity) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid sched_entity[%s] %s\n", entity_str, uc_entity_str);
-        }
-        else if ((direction == TPM_UPSTREAM   && que >= TPM_MAX_NUM_TX_QUEUE) ||
-                 (direction == TPM_DOWNSTREAM && que >= TPM_MAX_NUM_RX_QUEUE))
-        {
-            printk(KERN_INFO "Invalid queue[%d]\n", que);
-        }
-        else
-        {
-            if (direction == TPM_DOWNSTREAM)
-            {
-                if ((rc = _tpm_tm_set_wan_q_ingr_rate_lim (ownerid,
-                                                          // entity,
-                                                          que,
-                                                          rate_limit,
-                                                          bucket_size)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_q_ingr_rate_lim failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-            else
-            {
-                if ((rc = _tpm_tm_set_wan_queue_egr_rate_lim (ownerid,
-                                                             entity,
-                                                             que,
-                                                             rate_limit,
-                                                             bucket_size)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_queue_egr_rate_lim failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_tm_set_wan_ingr_queue_sched_bounce(uint32_t owner_id,
-							tpm_pp_sched_type_t sched_mode,
-							uint8_t queue_id,
-							uint16_t wrr_weight)
-{
-	tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_INGR_QUE_SCHED;
-	tpm_tm_tm_set->owner_id = owner_id;
-	tpm_tm_tm_set->pp_sched_mode = sched_mode;
-	tpm_tm_tm_set->queue_id = queue_id;
-	tpm_tm_tm_set->wrr_weight = wrr_weight;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
-
- tpm_error_code_t tpm_tm_set_wan_egr_queue_sched_bounce(uint32_t owner_id,
-							tpm_trg_port_type_t sched_ent,
-							tpm_pp_sched_type_t sched_mode,
-							uint8_t queue_id,
-							uint16_t wrr_weight)
- {
-	 tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	 tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	 tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_EGR_QUE_SCHED;
-	 tpm_tm_tm_set->owner_id = owner_id;
-	 tpm_tm_tm_set->sched_ent = sched_ent;
-	 tpm_tm_tm_set->pp_sched_mode = sched_mode;
-	 tpm_tm_tm_set->queue_id = queue_id;
-	 tpm_tm_tm_set->wrr_weight = wrr_weight;
-
-	 up(&tpm_sfs_2_ioctl_sem);
-
-	 return TPM_RC_OK;
- }
-
- #define _tpm_tm_set_wan_ingr_queue_sched tpm_tm_set_wan_ingr_queue_sched_bounce
- #define _tpm_tm_set_wan_egr_queue_sched tpm_tm_set_wan_egr_queue_sched_bounce
-#else
- #define _tpm_tm_set_wan_ingr_queue_sched tpm_tm_set_wan_ingr_queue_sched
- #define _tpm_tm_set_wan_egr_queue_sched tpm_tm_set_wan_egr_queue_sched
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_scheduling_mode_queue_set
-*
-* DESCRIPTION:
-*           This function configures queue operation mode (per IF, per direction)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_scheduling_mode_queue_set       (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        sched_owner=0, sched_direction, sched_if, sched_que, sched_rate_limit, sched_bucket_size, sched_max
-    } sched_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    char                     direction_str[20];
-    uint32_t                 direction;
-    char                     entity_str[20];
-    char                     uc_entity_str[20];
-    int                      indx;
-    uint32_t                 entity;
-    char                     mode_str[20];
-    uint32_t                 mode;
-    uint32_t                 que;
-    uint32_t                 wrr_weight;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != sched_max)
-    {
-        parm_error_completion(numparms, sched_max, buf, sfs_help_rate_limit);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %s %s %d %d", &ownerid, direction_str, entity_str, mode_str, &que, &wrr_weight);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], direction_str[%s], entity_str[%s], mode[%s], que[%d], wrr_weight[%d]\n",
-//               len, parsedargs, ownerid, direction_str, entity_str, mode_str, que, wrr_weight);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(entity_str); indx++) uc_entity_str[indx] = (char)toupper(entity_str[indx]);
-        uc_entity_str[strlen(entity_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_direction_value(direction_str, &direction) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid direction[%s]\n", direction_str);
-        }
-        else if (get_sched_entity_value(uc_entity_str, &entity) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid sched_entity[%s] %s\n", entity_str, uc_entity_str);
-        }
-        else if (get_scheduling_mode_value(mode_str, &mode) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid mode[%s]\n", mode_str);
-        }
-        else if ((direction == TPM_UPSTREAM   && que >= TPM_MAX_NUM_TX_QUEUE) ||
-                 (direction == TPM_DOWNSTREAM && que >= TPM_MAX_NUM_RX_QUEUE))
-        {
-            printk(KERN_INFO "Invalid queue[%d]\n", que);
-        }
-        else
-        {
-            if (direction == TPM_DOWNSTREAM)
-            {
-                if ((rc = _tpm_tm_set_wan_ingr_queue_sched (ownerid,
-                                                           mode,
-                                                           que,
-                                                           wrr_weight)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_ingr_queue_sched failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-            else
-            {
-                if ((rc = _tpm_tm_set_wan_egr_queue_sched (ownerid,
-                                                          entity,
-                                                          mode,
-                                                          que,
-                                                          wrr_weight)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_egr_queue_sched failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-        }
-    }
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_tm_set_wan_ingr_rate_lim_bounce(uint32_t owner_id,
-							uint32_t rate_limit_val,
-							uint32_t bucket_size)
-{
-	tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_INGR_RATE_LIMIT;
-	tpm_tm_tm_set->owner_id = owner_id;
-	tpm_tm_tm_set->rate_limit_val = rate_limit_val;
-	tpm_tm_tm_set->bucket_size = bucket_size;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
-
- tpm_error_code_t tpm_tm_set_wan_sched_egr_rate_lim_bounce(uint32_t owner_id,
-							tpm_trg_port_type_t sched_ent,
-							uint32_t rate_limit_val,
-							uint32_t bucket_size)
- {
-	 tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	 tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	 tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_WAN_SCHED_EGR_RATE_LIMIT;
-	 tpm_tm_tm_set->owner_id = owner_id;
-	 tpm_tm_tm_set->sched_ent = sched_ent;
-	 tpm_tm_tm_set->rate_limit_val = rate_limit_val;
-	 tpm_tm_tm_set->bucket_size = bucket_size;
-
-	 up(&tpm_sfs_2_ioctl_sem);
-
-	 return TPM_RC_OK;
- }
-
- #define _tpm_tm_set_wan_ingr_rate_lim tpm_tm_set_wan_ingr_rate_lim_bounce
- #define _tpm_tm_set_wan_sched_egr_rate_lim tpm_tm_set_wan_sched_egr_rate_lim_bounce
-#else
- #define _tpm_tm_set_wan_ingr_rate_lim tpm_tm_set_wan_ingr_rate_lim
- #define _tpm_tm_set_wan_sched_egr_rate_lim tpm_tm_set_wan_sched_egr_rate_lim
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_rate_limit_if_set
-*
-* DESCRIPTION:
-*           This function sets rate limit on interface
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_rate_limit_if_set          (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        entratelim_owner=0, entratelim_direction, entratelim_if, entratelim_rate_limit, entratelim_bucket_size, entratelim_max
-    } entratelim_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    char                     direction_str[20];
-    uint32_t                 direction;
-    char                     entity_str[20];
-    char                     uc_entity_str[20];
-    int                      indx;
-    uint32_t                 entity;
-    uint32_t                 rate_limit;
-    uint32_t                 bucket_size;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != entratelim_max)
-    {
-        parm_error_completion(numparms, entratelim_max, buf, sfs_help_rate_limit);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %s %d %d", &ownerid, direction_str, entity_str, &rate_limit, &bucket_size);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], direction_str[%s], entity_str[%s], rate_limit[%d], bucket_size[%d]\n",
-//               len, parsedargs, ownerid, direction_str, entity_str, rate_limit, bucket_size);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(entity_str); indx++) uc_entity_str[indx] = (char)toupper(entity_str[indx]);
-        uc_entity_str[strlen(entity_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_direction_value(direction_str, &direction) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid direction[%s]\n", direction_str);
-        }
-        else if (get_sched_entity_value(uc_entity_str, &entity) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid sched_entity[%s]\n", entity_str);
-        }
-        else
-        {
-            if (direction == TPM_DOWNSTREAM)
-            {
-                if ((rc = _tpm_tm_set_wan_ingr_rate_lim (ownerid,
-                                                        rate_limit,
-                                                        bucket_size)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_ingr_rate_lim failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-            else
-            {
-                if ((rc = _tpm_tm_set_wan_sched_egr_rate_lim (ownerid,
-                                                             entity,
-                                                             rate_limit,
-                                                             bucket_size)) == TPM_RC_OK)
-                {
-                    printk(KERN_INFO "OK\n");
-                }
-                else
-                {
-                    printk(KERN_INFO "%s: tpm_tm_set_wan_sched_egr_rate_lim failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-                }
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_tm_set_gmac0_ingr_rate_lim_bounce(uint32_t owner_id,
-						       uint32_t rate_limit_val,
-						       uint32_t bucket_size)
-{
-	tpm_ioctl_tm_tm_t *tpm_tm_tm_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_tm_tm;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_PP_TM_SECTION;
-	tpm_tm_tm_set->pp_tm_cmd = MV_TPM_IOCTL_TM_SET_GMAC0_INGR_RATE_LIMIT;
-	tpm_tm_tm_set->owner_id = owner_id;
-	tpm_tm_tm_set->rate_limit_val = rate_limit_val;
-	tpm_tm_tm_set->bucket_size = bucket_size;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-}
-
- #define _tpm_tm_set_gmac0_ingr_rate_lim tpm_tm_set_gmac0_ingr_rate_lim_bounce
-#else
- #define _tpm_tm_set_gmac0_ingr_rate_lim tpm_tm_set_gmac0_ingr_rate_lim
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_gmac0_ingr_rate_limit
-*
-* DESCRIPTION:
-*           This function sets rate limit on queue
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_gmac0_ingr_rate_limit(const char *buf, size_t len)
-{
-    typedef enum
-    {
-        qratelim_owner=0, qratelim_rate_limit, qratelim_bucket_size, qratelim_max
-    } qratelim_parm_indx_t;
-    /* shell line parsing */
-    uint32_t                 ownerid;
-    uint32_t                 rate_limit;
-    uint32_t                 bucket_size;
-    int                      parsedargs;
-    int                      numparms;
-    /* Used in API call */
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != qratelim_max) {
-        parm_error_completion(numparms, qratelim_max, buf, sfs_help_rate_limit);
-    } else {
-        /* Get parameters */
-        parsedargs = sscanf(buf, "%d %d %d", &ownerid, &rate_limit, &bucket_size);
-        if (parsedargs != numparms) {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        } else {
-            if ((rc = _tpm_tm_set_gmac0_ingr_rate_lim(ownerid,
-                                                      rate_limit,
-                                                      bucket_size)) == TPM_RC_OK)
-                printk(KERN_INFO "OK\n");
-            else
-                printk(KERN_INFO "%s: tpm_tm_set_gmac0_ingr_rate_lim failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_dip_rule_bounce(uint32_t              owner_id,
-                                              tpm_src_port_type_t   src_port,
-                                              uint32_t              rule_num,
-                                              uint32_t             *rule_idx,
-                                              tpm_parse_fields_t    parse_rule_bm,
-                                              tpm_parse_flags_t     parse_flags_bm,
-                                              tpm_ipv6_addr_key_t  *ipv6_dip_key,
-                                              tpm_pkt_frwd_t       *pkt_frwd,
-                                              tpm_pkt_mod_t        *pkt_mod,
-                                              tpm_pkt_mod_bm_t      pkt_mod_bm,
-                                              tpm_rule_action_t    *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                             = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                           = MV_TPM_IOCTL_ADD_IPV6_DIP_ACL_RULE;
-    tpm_add_acl_rule->owner_id                              = owner_id;
-    tpm_add_acl_rule->src_port                              = src_port;
-    tpm_add_acl_rule->rule_num                              = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                         = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_dip_acl_rule.parse_flags_bm      = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_mod_bm          = pkt_mod_bm;
-
-    memcpy(&(tpm_add_acl_rule->ipv6_dip_acl_rule.ipv6_dip_key), ipv6_dip_key,   sizeof(tpm_ipv6_addr_key_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_frwd),     pkt_frwd,       sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_dip_acl_rule.pkt_mod),      pkt_mod,        sizeof(tpm_pkt_mod_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_dip_acl_rule.rule_action),  rule_action,    sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_dip_rule tpm_add_ipv6_dip_rule_bounce
-#else
- #define _tpm_add_ipv6_dip_rule tpm_add_ipv6_dip_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_dip_acl_rule_add
-*
-* DESCRIPTION:
-*           This function creates a IPV6 DIP rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_dip_acl_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6ruleadd_owner=0, ipv6ruleadd_srcport,   ipv6ruleadd_rulenum,  ipv6ruleadd_parserulebm, ipv6ruleadd_parseflagsbm,
-        ipv6ruleadd_action,  ipv6ruleadd_nextphase, ipv6ruleadd_modbm,    ipv6ruleadd_ipv6dipkeyname, ipv6ruleadd_frwdname,
-        ipv6ruleadd_modname, ipv6dipruleadd_max
-    } ipv6dipruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    char                     srcport_str[20];
-    char                     uc_srcport_str[20];
-    int                      indx;
-    uint32_t                 src_port;
-    unsigned int             rulenum;
-    unsigned int             parserulebm;
-    unsigned int             parseflagsbm;
-    unsigned int             action;
-    unsigned int             nextphase;
-    char                     nextphase_str[20];
-    unsigned int             modbm;
-    char                     ipv6keyname[30];
-    char                     frwdname[20];
-    char                     modname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_ipv6_dip_key_entry_t  *pdbipv6keyentry = 0;
-    tpm_ipv6_addr_key_t    ipv6AddrKey;
-    tpmcfg_frwd_entry_t      *pdbfrwdentry    = 0;
-    tpmcfg_mod_entry_t       *pdbmodentry     = 0;
-    // Used in API call
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    //tpm_ipv6_acl_key_t       ipv6_acl;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6dipruleadd_max)
-    {
-        parm_error_completion(numparms, ipv6dipruleadd_max, buf, sys_help_ipv6_dip_acl_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s 0x%x %s %s %s",
-                            &ownerid, srcport_str, &rulenum, &parserulebm, &parseflagsbm, &action,
-                            nextphase_str, &modbm, ipv6keyname, frwdname, modname);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], modbm[0x%x], ipv6keyname[%s], frwdname[%s], modname[%s]\n",
-               len, parsedargs, ownerid, srcport_str, rulenum, parserulebm, parseflagsbm, action, nextphase_str, modbm, ipv6keyname, frwdname, modname);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else if (((pdbipv6keyentry = find_tpm_ipv6_dip_key_entry_by_name(ipv6keyname)) == 0) && strcmp(ipv6keyname, ipv6_dip_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "IPV6 key entry [%s] not found\n", ipv6keyname);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && strcmp(modname, mod_empty_name) != 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv6keyentry != 0)
-            {
-                memcpy(&(ipv6AddrKey.ipv6_ip_add), &(pdbipv6keyentry->ipv6_addr.ipv6_ip_add), sizeof(pdbipv6keyentry->ipv6_addr.ipv6_ip_add));
-                memcpy(&(ipv6AddrKey.ipv6_ip_add_mask), &(pdbipv6keyentry->ipv6_addr.ipv6_ip_add_mask), sizeof(pdbipv6keyentry->ipv6_addr.ipv6_ip_add_mask));
-            }
-            else                       memset(&ipv6AddrKey, 0,                          sizeof(ipv6AddrKey));
-
-            if (pdbfrwdentry != 0)     memcpy(&pkt_frwd, &pdbfrwdentry->frwd,    sizeof(tpm_pkt_frwd_t));
-            else                       memset(&pkt_frwd, 0,                      sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)      memcpy(&pkt_mod, &pdbmodentry->mod,      sizeof(tpm_pkt_mod_t));
-            else                       memset(&pkt_mod, 0,                      sizeof(tpm_pkt_mod_t));
-
-            if ((rc = _tpm_add_ipv6_dip_rule(ownerid,
-                                             src_port,
-                                             rulenum,
-                                             &rule_idx,
-                                             parserulebm,
-                                             parseflagsbm,
-                                             &ipv6AddrKey,
-                                             &pkt_frwd,
-                                             &pkt_mod,
-                                             modbm,
-                                             &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_dip_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_dip_rule_bounce(uint32_t              owner_id,
-                                              uint32_t              rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_DEL_IPV6_DIP_ACL_RULE;
-    tpm_del_acl_rule->owner_id                      = owner_id;
-    tpm_del_acl_rule->rule_idx                      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_dip_rule tpm_del_ipv6_dip_rule_bounce
-#else
- #define _tpm_del_ipv6_dip_rule tpm_del_ipv6_dip_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_dip
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_dip  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noruleaddipv6_owner=0,  noruleaddipv6_ruleidx, noruleaddipv6_max
-    } noruleaddipv6_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rule_idx;
-//    uint32_t                 parserulebm;
-//    char                     keyname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-//    tpmcfg_ipv6_dip_key_entry_t  *pdbipv6keyentry = 0;
-    //Used in API call
-    //tpm_ipv6_acl_key_t       ipv6_acl;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noruleaddipv6_max)
-    {
-        parm_error_completion(numparms, noruleaddipv6_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        // Zeev
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-//        parsedargs = sscanf(buf, "%d %s %d 0x%x %s",
-//                            &ownerid, srcport_str, &rule_idx, &parserulebm, keyname);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rule_idx[%d], parserulebm[0x%x], keyname[%s]\n",
-//               len, parsedargs, ownerid, srcport_str, rule_idx, parserulebm, keyname);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-//        else if ((pdbipv6keyentry = find_tpm_ipv6_dip_key_entry_by_name(keyname)) == 0)
-//        {
-//            printk(KERN_INFO "key entry [%s] not found\n", keyname);
-//        }
-        else
-        {
-            //memcpy(&ipv6_acl, &pdbipv6keyentry->ipv6_acl, sizeof(tpm_ipv6_acl_key_t));
-
-            if ((rc = _tpm_del_ipv6_dip_rule(ownerid,
-                                             rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_ipv6_dip_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_l4_ports_rule_bounce(uint32_t                owner_id,
-                                                   tpm_src_port_type_t     src_port,
-                                                   uint32_t                rule_num,
-                                                   uint32_t               *rule_idx,
-                                                   tpm_parse_fields_t      parse_rule_bm,
-                                                   tpm_parse_flags_t       parse_flags_bm,
-                                                   tpm_l4_ports_key_t     *l4_key,
-                                                   tpm_pkt_frwd_t         *pkt_frwd,
-                                                   tpm_pkt_mod_t          *pkt_mod,
-                                                   tpm_pkt_mod_bm_t        pkt_mod_bm,
-                                                   tpm_rule_action_t      *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                             = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                           = MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_ACL_RULE;
-    tpm_add_acl_rule->owner_id                              = owner_id;
-    tpm_add_acl_rule->src_port                              = src_port;
-    tpm_add_acl_rule->rule_num                              = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                         = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_l4_ports_acl_rule.parse_flags_bm = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod_bm     = pkt_mod_bm;
-
-    memcpy(&(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.l4_key),      l4_key,         sizeof(tpm_l4_ports_key_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_frwd),    pkt_frwd,       sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.pkt_mod),     pkt_mod,        sizeof(tpm_pkt_mod_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_l4_ports_acl_rule.rule_action), rule_action,    sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_l4_ports_rule tpm_add_ipv6_l4_ports_rule_bounce
-#else
- #define _tpm_add_ipv6_l4_ports_rule tpm_add_ipv6_l4_ports_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_l4_ports_acl_rule_add
-*
-* DESCRIPTION:
-*           This function adds a IPV6 HW L4 ports ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_l4_ports_acl_rule_add (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6l4ports_owner=0, ipv6l4ports_srcport,   ipv6l4ports_rulenum,  ipv6l4ports_parserulebm, ipv6l4ports_parseflagsbm,
-        ipv6l4ports_action,   ipv6l4ports_next_phase, ipv6l4ports_src_port, ipv6l4ports_dst_port,    ipv6l4ports_modbm,
-        ipv6l4ports_frwdname, ipv6l4ports_modname,    ipv6l4ports_max
-    } ipv6l4ports_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    char                     srcport_str[20];
-    char                     uc_srcport_str[20];
-    int                      indx;
-    uint32_t                 src_port;
-    unsigned int             rulenum;
-    unsigned int             parserulebm;
-    unsigned int             parseflagsbm;
-
-    uint32_t                 temp_l4_src_port;
-    uint32_t                 temp_l4_dst_port;
-
-    char                     frwdname[20];
-
-    char                     modname[20];
-    unsigned int             modbm;
-
-    unsigned int             action;
-    unsigned int             nextphase;
-    char                     nextphase_str[20];
-
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_frwd_entry_t      *pdbfrwdentry    = 0;
-    tpmcfg_mod_entry_t       *pdbmodentry     = 0;
-    // Used in API call
-    tpm_l4_ports_key_t       l4_key;
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    tpm_pkt_mod_t            pkt_mod;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6l4ports_max)
-    {
-        parm_error_completion(numparms, ipv6l4ports_max, buf, sfs_help_ipv6_l4_ports_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x  0x%x %s %d %d  0x%x %s %s",
-                            &ownerid, srcport_str, &rulenum, &parserulebm, &parseflagsbm, &action, nextphase_str,
-                            &temp_l4_src_port, &temp_l4_dst_port, &modbm, frwdname, modname);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], l4_src_port[%d], l4_dst_port[%d], modbm[0x%x], frwdname[%s], modname[%s]\n",
-               len, parsedargs, ownerid, srcport_str, rulenum, parserulebm, parseflagsbm, action, nextphase_str, temp_l4_src_port, temp_l4_dst_port, modbm, frwdname, modname);
-
-        // Minimal help for src_port upper/lower case support
-        for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && strcmp(modname, mod_empty_name) != 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            l4_key.l4_dst_port = (uint16_t)temp_l4_dst_port;
-            l4_key.l4_src_port = (uint16_t)temp_l4_src_port;
-
-            if (pdbfrwdentry != 0)     memcpy(&pkt_frwd, &pdbfrwdentry->frwd,    sizeof(tpm_pkt_frwd_t));
-            else                       memset(&pkt_frwd, 0,                      sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)      memcpy(&pkt_mod, &pdbmodentry->mod,      sizeof(tpm_pkt_mod_t));
-            else                       memset(&pkt_mod, 0,                      sizeof(tpm_pkt_mod_t));
-
-            if ((rc = _tpm_add_ipv6_l4_ports_rule(ownerid,
-                                                  src_port,
-                                                  rulenum,
-                                                  &rule_idx,
-                                                  parserulebm,
-                                                  parseflagsbm,
-                                                  &l4_key,
-                                                  &pkt_frwd,
-                                                  &pkt_mod,
-                                                  modbm,
-                                                  &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_l4_ports_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_l4_ports_rule_bounce(uint32_t              owner_id,
-                                                   uint32_t              rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_DEL_IPV6_L4_PORTS_ACL_RULE;
-    tpm_del_acl_rule->owner_id                      = owner_id;
-    tpm_del_acl_rule->rule_idx                      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_l4_ports_rule tpm_del_ipv6_l4_ports_rule_bounce
-#else
- #define _tpm_del_ipv6_l4_ports_rule tpm_del_ipv6_l4_ports_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_acl
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW L4 ports ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_acl (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noipv6l4ports_owner=0, noipv6l4ports_ruleidx, noipv6l4ports_max
-    } noipv6l4portsruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6l4ports_max)
-    {
-        parm_error_completion(numparms, noipv6l4ports_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-               len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_ipv6_l4_ports_rule(ownerid,
-                                                  rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_ipv6_l4_ports_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_nh_rule_bounce(uint32_t           owner_id,
-                                            uint32_t            rule_num,
-                                            uint32_t           *rule_idx,
-                                            tpm_parse_flags_t   parse_flags_bm,
-                                            tpm_nh_iter_t       nh_iter,
-                                            uint32_t            nh,
-                                            tpm_pkt_frwd_t     *pkt_frwd,
-                                            tpm_rule_action_t  *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_IPV6_NH_ACL_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    tpm_add_acl_rule->rule_num                      = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                 = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_nh_acl_rule.nh_iter      = nh_iter;
-    tpm_add_acl_rule->ipv6_nh_acl_rule.nh           = nh;
-    memcpy(&(tpm_add_acl_rule->ipv6_nh_acl_rule.pkt_frwd),      pkt_frwd,       sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ipv6_nh_acl_rule.rule_action),   rule_action,    sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_nh_rule tpm_add_ipv6_nh_rule_bounce
-#else
- #define _tpm_add_ipv6_nh_rule tpm_add_ipv6_nh_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_nh_acl_rule_add
-*
-* DESCRIPTION:
-*           This function adds a IPV6 HW NH (Next Header) ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_nh_acl_rule_add    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6nh_owner=0,   ipv6nh_rulenum,   ipv6nh_parseflagsbm, ipv6nh_action, ipv6nh_nextphase, ipv6nh_nhiter,
-         ipv6nh_nh,       ipv6nh_frwdname,  ipv6nh_max
-    } ipv6nhruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    unsigned int             rulenum;
-    unsigned int             parseflagsbm;
-    unsigned int             nh_iter;
-    unsigned int             nh;
-    unsigned int             action;
-    unsigned int             nextphase;
-    char                     nextphase_str[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    char                     frwdname[20];
-    tpmcfg_frwd_entry_t      *pdbfrwdentry    = 0;
-    // Used in API call
-    tpm_rule_action_t        rule_action;
-    tpm_pkt_frwd_t           pkt_frwd;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6nh_max)
-    {
-        parm_error_completion(numparms, ipv6nh_max, buf, sfs_help_ipv6_nh_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d 0x%x 0x%x %s %d 0x%x %s",
-                            &ownerid, &rulenum, &parseflagsbm, &action, nextphase_str, &nh_iter, &nh, frwdname);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rulenum[%d], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], nh_iter[%d], nh[0x%x], frwdname[%s]\n",
-               len, parsedargs, ownerid, rulenum, parseflagsbm, action, nextphase_str, nh_iter, nh, frwdname);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name) != 0)
-        {
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        }
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        }
-        else
-        {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbfrwdentry != 0)     memcpy(&pkt_frwd, &pdbfrwdentry->frwd,    sizeof(tpm_pkt_frwd_t));
-            else                       memset(&pkt_frwd, 0,                      sizeof(tpm_pkt_frwd_t));
-
-            if ((rc = _tpm_add_ipv6_nh_rule(ownerid,
-                                            rulenum,
-                                            &rule_idx,
-                                            parseflagsbm,
-                                            nh_iter,
-                                            nh,
-                                            &pkt_frwd,
-                                            &rule_action)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ipv6_nh_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_nh_rule_bounce(uint32_t           owner_id,
-                                            uint32_t            rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_DEL_IPV6_NH_ACL_RULE;
-    tpm_del_acl_rule->owner_id                      = owner_id;
-    tpm_del_acl_rule->rule_idx                      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_nh_rule tpm_del_ipv6_nh_rule_bounce
-#else
- #define _tpm_del_ipv6_nh_rule tpm_del_ipv6_nh_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_nh_acl
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW nh_acl rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_nh_acl    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        noipv6nh_owner=0, noipv6nh_ruleidx, noipv6nh_max
-    } noipv6nhruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6nh_max)
-    {
-        parm_error_completion(numparms, noipv6nh_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",len, parsedargs, ownerid, rule_idx);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_del_ipv6_nh_rule(ownerid,
-                                            rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_del_ipv6_nh_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ctc_cm_acl_rule_bounce(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						uint32_t precedence,
-						tpm_parse_fields_t l2_parse_rule_bm,
-						tpm_parse_fields_t ipv4_parse_rule_bm,
-						tpm_l2_acl_key_t *l2_key,
-						tpm_ipv4_acl_key_t *ipv4_key,
-						tpm_pkt_frwd_t *pkt_frwd,
-						tpm_pkt_action_t *pkt_act,
-						uint32_t pbits)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                          = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                        = MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE;
-    tpm_add_acl_rule->owner_id                           = owner_id;
-    tpm_add_acl_rule->src_port                           = src_port;
-    tpm_add_acl_rule->ctc_cm_acl_rule.precedence         = precedence;
-    tpm_add_acl_rule->ctc_cm_acl_rule.l2_parse_rule_bm   = l2_parse_rule_bm;
-    tpm_add_acl_rule->ctc_cm_acl_rule.ipv4_parse_rule_bm = ipv4_parse_rule_bm;
-    tpm_add_acl_rule->ctc_cm_acl_rule.p_bits             = pbits;
-
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.l2_key),        l2_key,       sizeof(tpm_l2_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.ipv4_key),      ipv4_key,     sizeof(tpm_ipv4_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.pkt_frwd),      pkt_frwd,     sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.pkt_act),       pkt_act,      sizeof(tpm_pkt_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ctc_cm_acl_rule tpm_add_ctc_cm_acl_rule_bounce
-#else
- #define _tpm_add_ctc_cm_acl_rule tpm_add_ctc_cm_acl_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ctc_cm_rule_add
-*
-* DESCRIPTION:
-*           This function adds a CnM ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ctc_cm_rule_add (const char *buf, size_t len)
-{
-	typedef enum
-	{
-	    cnmruleadd_owner=0, cnmruleadd_srcport, cnmruleadd_precedence, cnmruleadd_l2parserulebm,
-	    cnmruleadd_ipv4parserulebm, cnmruleadd_action, cnmruleadd_l2keyname, cnmruleadd_ipv4keyname,
-	    cnmruleadd_frwdname, cnmruleadd_pbits, cnmruleadd_max
-	} cnmruleadd_parm_indx_t;
-	/*shell line parsing*/
-	uint32_t             	  owner_id;
-	char                      srcport_str[20];
-	char                      uc_srcport_str[20];
-	int                       indx;
-	tpm_src_port_type_t 	  src_port;
-	uint32_t            	  precedence;
-	tpm_parse_fields_t  	  l2_parse_rule_bm;
-	tpm_parse_fields_t  	  ipv4_parse_rule_bm;
-	char                      l2keyname[20];
-	tpm_l2_acl_key_t   	  l2_key;
-	char                      ipv4keyname[20];
-	tpm_ipv4_acl_key_t 	  ipv4_key;
-	char                      frwdname[20];
-	tpm_pkt_frwd_t     	  pkt_frwd;
-	tpm_pkt_action_t 	  action;
-	uint32_t            	  pbits;
-	int                       parsedargs;
-	int                       numparms;
-	/*DB*/
-	tpmcfg_l2_key_entry_t    *pdbl2keyentry   = NULL;
-	tpmcfg_ipv4_key_entry_t  *pdbipv4keyentry = NULL;
-	tpmcfg_frwd_entry_t      *pdbfrwdentry    = NULL;
-
-	tpm_error_code_t         rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != cnmruleadd_max) {
-	    parm_error_completion(numparms, cnmruleadd_max, buf, sfs_help_ctc_cm_rule_add);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s %s %s %d",  &owner_id, srcport_str, &precedence,
-			&l2_parse_rule_bm, &ipv4_parse_rule_bm, &action, l2keyname, ipv4keyname, frwdname, &pbits);
-
-		for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-		uc_srcport_str[strlen(srcport_str)] = 0;
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE) {
-			printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-		} else if (((pdbl2keyentry = find_tpm_l2_key_entry_by_name(l2keyname)) == 0) && strcmp(l2keyname, l2_key_empty_name) != 0) {
-			printk(KERN_INFO "L2 key entry [%s] not found\n", l2keyname);
-		} else if (((pdbipv4keyentry = find_tpm_ipv4_key_entry_by_name(ipv4keyname)) == 0) && strcmp(ipv4keyname, ipv4_key_empty_name) != 0) {
-			printk(KERN_INFO "IPV4 key entry [%s] not found\n", ipv4keyname);
-		} else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name)!= 0) {
-			printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-		} else {
-			if (pdbl2keyentry != NULL)
-				memcpy(&l2_key, &(pdbl2keyentry->l2_acl), sizeof(tpm_l2_acl_key_t));
-			else
-				memset(&l2_key, 0, sizeof(tpm_l2_acl_key_t));
-
-			if (pdbipv4keyentry != NULL)
-				memcpy(&ipv4_key, &(pdbipv4keyentry->ipv4_acl), sizeof(tpm_ipv4_acl_key_t));
-			else
-				memset(&ipv4_key, 0, sizeof(tpm_ipv4_acl_key_t));
-
-			if (pdbfrwdentry != NULL)
-				memcpy(&pkt_frwd, &(pdbfrwdentry->frwd), sizeof(tpm_pkt_frwd_t));
-			else
-				memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-			if ((rc = _tpm_add_ctc_cm_acl_rule(owner_id,
-						src_port,
-						precedence,
-						l2_parse_rule_bm,
-						ipv4_parse_rule_bm,
-						&l2_key,
-						&ipv4_key,
-						&pkt_frwd,
-						action,
-						pbits)) == TPM_RC_OK)
-				printk(KERN_INFO "OK. precedence = %d\n", precedence);
-			else
-				printk(KERN_INFO "%s: tpm_add_ctc_cm_acl_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-
-		}
-	}
-
-}
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ctc_cm_ipv6_acl_rule_bounce(uint32_t owner_id,
-						     tpm_src_port_type_t src_port,
-						     uint32_t precedence,
-						     tpm_parse_fields_t ipv6_parse_rule_bm,
-						     tpm_ipv4_acl_key_t *ipv6_key,
-						     tpm_pkt_frwd_t *pkt_frwd,
-						     tpm_pkt_action_t *pkt_act,
-						     uint32_t pbits)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                          = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                        = MV_TPM_IOCTL_ADD_CTC_CM_ACL_RULE;
-    tpm_add_acl_rule->owner_id                           = owner_id;
-    tpm_add_acl_rule->src_port                           = src_port;
-    tpm_add_acl_rule->ctc_cm_acl_rule.precedence         = precedence;
-    tpm_add_acl_rule->ctc_cm_acl_rule.ipv6_parse_rule_bm = ipv6_parse_rule_bm;
-    tpm_add_acl_rule->ctc_cm_acl_rule.p_bits             = pbits;
-
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.ipv6_key),      ipv6_key,     sizeof(tpm_ipv6_acl_key_t));
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.pkt_frwd),      pkt_frwd,     sizeof(tpm_pkt_frwd_t));
-    memcpy(&(tpm_add_acl_rule->ctc_cm_acl_rule.pkt_act),       pkt_act,      sizeof(tpm_pkt_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ctc_cm_ipv6_acl_rule tpm_add_ctc_cm_ipv6_acl_rule_bounce
-#else
- #define _tpm_add_ctc_cm_ipv6_acl_rule tpm_add_ctc_cm_ipv6_acl_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ctc_cm_ipv6_rule_add
-*
-* DESCRIPTION:
-*           This function adds a CnM IPv6 ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ctc_cm_ipv6_rule_add (const char *buf, size_t len)
-{
-	typedef enum
-	{
-	    cnmruleadd_owner=0, cnmruleadd_srcport, cnmruleadd_precedence,
-	    cnmruleadd_ipv6parserulebm, cnmruleadd_action, cnmruleadd_ipv6keyname,
-	    cnmruleadd_frwdname, cnmruleadd_pbits, cnmruleipv6add_max
-	} cnmruleadd_parm_indx_t;
-	/*shell line parsing*/
-	uint32_t		  owner_id;
-	char			  srcport_str[20];
-	char			  uc_srcport_str[20];
-	int			  indx;
-	tpm_src_port_type_t	  src_port;
-	uint32_t		  precedence;
-	tpm_parse_fields_t	  ipv6_parse_rule_bm;
-	char			  ipv6keyname[20];
-	tpm_ipv6_acl_key_t	  ipv6_key;
-	char			  frwdname[20];
-	tpm_pkt_frwd_t		  pkt_frwd;
-	tpm_pkt_action_t	  action;
-	uint32_t		  pbits;
-	int			  parsedargs;
-	int			  numparms;
-	/*DB*/
-	tpmcfg_ipv6_key_entry_t  *pdbipv6keyentry = NULL;
-	tpmcfg_frwd_entry_t	 *pdbfrwdentry	  = NULL;
-
-	tpm_error_code_t	 rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != cnmruleipv6add_max) {
-	    parm_error_completion(numparms, cnmruleipv6add_max, buf, sfs_help_ctc_cm_rule_add);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x %s %s %d",  &owner_id, srcport_str, &precedence,
-			&ipv6_parse_rule_bm, &action, ipv6keyname, frwdname, &pbits);
-
-		for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-		uc_srcport_str[strlen(srcport_str)] = 0;
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE) {
-			printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-		} else if (((pdbipv6keyentry = find_tpm_ipv6_key_entry_by_name(ipv6keyname)) == 0) && strcmp(ipv6keyname, ipv6_key_empty_name) != 0) {
-			printk(KERN_INFO "ipv6 key entry [%s] not found\n", ipv6keyname);
-		} else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && strcmp(frwdname, frwd_empty_name)!= 0) {
-			printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-		} else {
-			if (pdbipv6keyentry != NULL)
-				memcpy(&ipv6_key, &(pdbipv6keyentry->ipv6_acl), sizeof(tpm_ipv6_acl_key_t));
-			else
-				memset(&ipv6_key, 0, sizeof(tpm_ipv6_acl_key_t));
-
-			if (pdbfrwdentry != NULL)
-				memcpy(&pkt_frwd, &(pdbfrwdentry->frwd), sizeof(tpm_pkt_frwd_t));
-			else
-				memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-			if ((rc = _tpm_add_ctc_cm_ipv6_acl_rule(owner_id,
-						src_port,
-						precedence,
-						ipv6_parse_rule_bm,
-						&ipv6_key,
-						&pkt_frwd,
-						action,
-						pbits)) == TPM_RC_OK)
-				printk(KERN_INFO "OK. precedence = %d\n", precedence);
-			else
-				printk(KERN_INFO "%s: tpm_add_ctc_cm_acl_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-
-		}
-	}
-
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ctc_cm_acl_rule_bounce(uint32_t owner_id,
-						tpm_src_port_type_t src_port,
-						uint32_t precedence)
-{
-	tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_DEL_ACL_SECTION;
-	tpm_del_acl_rule->del_acl_cmd			= MV_TPM_IOCTL_DEL_CTC_CM_ACL_RULE;
-	tpm_del_acl_rule->owner_id			= owner_id;
-	tpm_del_acl_rule->src_port			= src_port;
-	tpm_del_acl_rule->precedence			= precedence;
-
-	up(&tpm_sfs_2_ioctl_sem);
-
-	return TPM_RC_OK;
-
-}
- #define _tpm_del_ctc_cm_acl_rule tpm_del_ctc_cm_acl_rule_bounce
-#else
- #define _tpm_del_ctc_cm_acl_rule tpm_del_ctc_cm_acl_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ctc_cm_acl
-*
-* DESCRIPTION:
-*           This function deletes a ctc CnM HW acl rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ctc_cm_acl(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		noctccm_owner=0, noctccm_srcport, noctccm_precedence, noctccm_max
-	} noctccmruleadd_parm_indx_t;
-	/*shell line parsing*/
-	uint32_t             	  owner_id;
-	char                      srcport_str[20];
-	char                      uc_srcport_str[20];
-	tpm_src_port_type_t 	  src_port;
-	uint32_t            	  precedence;
-	int                       parsedargs;
-	int                       numparms;
-	int                       indx;
-
-	tpm_error_code_t         rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != noctccm_max) {
-	    parm_error_completion(numparms, noctccm_max, buf, sfs_help_no_rule_add);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %s %d",  &owner_id, srcport_str, &precedence);
-
-		for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-		uc_srcport_str[strlen(srcport_str)] = 0;
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE) {
-			printk(KERN_INFO "Invalid src_port[%s]\n", srcport_str);
-		} else {
-			if ((rc = _tpm_del_ctc_cm_acl_rule(owner_id,
-							src_port,
-							precedence)) == TPM_RC_OK)
-				PR_RESULT
-			else
-		                printk(KERN_INFO "%s: tpm_del_ctc_cm_acl_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_updt_ipv4_mc_stream_bounce(uint32_t            owner_id,
-                                                uint32_t            stream_num,
-                                                tpm_trg_port_type_t dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd         = MV_TPM_IOCTL_MOD_IPv4_MC_STREAM;
-    tpm_mc_rule->stream_num     = stream_num;
-    tpm_mc_rule->dest_port_bm   = dest_port_bm;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_updt_ipv4_mc_stream tpm_updt_ipv4_mc_stream_bounce
-#else
- #define _tpm_updt_ipv4_mc_stream tpm_updt_ipv4_mc_stream
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv4_stream_update
-*
-* DESCRIPTION:
-*           This function updates a IPv4 multicast stream
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv4_stream_update    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4strupdt_owner=0, ipv4strupdt_stream_num, ipv4strupdt_dest_port_bm, ipv4strupdt_max
-    } noipv6nhruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream_num;
-    uint32_t                 dest_port_bm;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4strupdt_max)
-    {
-        parm_error_completion(numparms, ipv4strupdt_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d 0x%x", &ownerid, &stream_num, &dest_port_bm);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream_num[%d], dest_port_bm[0x%x]\n",
-               len, parsedargs, ownerid, stream_num, dest_port_bm);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_updt_ipv4_mc_stream(ownerid,
-                                               stream_num,
-                                               dest_port_bm)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK.\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_updt_ipv4_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_updt_ipv6_mc_stream_bounce(uint32_t            owner_id,
-                                                uint32_t            stream_num,
-                                                tpm_trg_port_type_t dest_port_bm)
-{
-    tpm_ioctl_mc_rule_t *tpm_mc_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_mc_rule;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_MC_STREAM_SECTION;
-    tpm_mc_rule->mc_cmd         = MV_TPM_IOCTL_MOD_IPv6_MC_STREAM;
-    tpm_mc_rule->stream_num     = stream_num;
-    tpm_mc_rule->dest_port_bm   = dest_port_bm;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_updt_ipv6_mc_stream tpm_updt_ipv6_mc_stream_bounce
-#else
- #define _tpm_updt_ipv6_mc_stream tpm_updt_ipv6_mc_stream
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mc_ipv6_stream_update
-*
-* DESCRIPTION:
-*           This function updates a ipv6 multicast stream
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mc_ipv6_stream_update    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6strupdt_owner=0, ipv6strupdt_stream_num, ipv6strupdt_dest_port_bm, ipv6strupdt_max
-    } noipv6nhruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 stream_num;
-    uint32_t                 dest_port_bm;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6strupdt_max)
-    {
-        parm_error_completion(numparms, ipv6strupdt_max, buf, sfs_help_mc_ipvx_stream_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d 0x%x", &ownerid, &stream_num, &dest_port_bm);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], stream_num[%d], dest_port_bm[0x%x]\n",
-               len, parsedargs, ownerid, stream_num, dest_port_bm);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_updt_ipv6_mc_stream(ownerid,
-                                               stream_num,
-                                               dest_port_bm)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK.\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_updt_ipv6_mc_stream failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-void sfs_tpm_cfg_set_mc_vid_key_reset    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcvidkeyreset_owner=0,  mcvidkeyreset_max
-    } mcvidkeyreset_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    int                      parsedargs;
-    int                      numparms;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcvidkeyreset_max)
-    {
-        parm_error_completion(numparms, mcvidkeyreset_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d", &ownerid);
-        printk(KERN_INFO "parsedargs=%d. ownerid[%d]\n", parsedargs, ownerid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            tpm_reset_mc_vid_key ();
-            printk(KERN_INFO "OK.\n");
-        }
-    }
-}
-
-void sfs_tpm_cfg_set_mc_vid_key_set    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcvidkeyset_src_port=0, mcvidkeyset_mc_uni_xlate_mode, mcvidkeyset_mc_uni_xlate_vid, mcvidkeyset_max
-    } mcvidkeyset_parm_indx_t;
-    // shell line parsing
-    char                     srcport_str[30];
-    char                     uc_srcport_str[30];
-    uint32_t                 src_port;
-    uint32_t                 mc_uni_xlate_mode;
-    uint32_t                 mc_uni_xlate_vid;
-    int                      parsedargs;
-    int                      numparms;
-    int                      indx;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcvidkeyset_max)
-    {
-        parm_error_completion(numparms, mcvidkeyset_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d %d", srcport_str, &mc_uni_xlate_mode, &mc_uni_xlate_vid);
-        printk(KERN_INFO "len=%d, parsedargs=%d. src_port[%s], mc_uni_xlate_mode[%d], mc_uni_xlate_vid[%d]\n",
-               len, parsedargs, srcport_str, mc_uni_xlate_mode, mc_uni_xlate_vid);
-
-         for (indx = 0; indx < strlen(srcport_str); indx++) uc_srcport_str[indx] = (char)toupper(srcport_str[indx]);
-        uc_srcport_str[strlen(srcport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_srcport_value(uc_srcport_str, &src_port) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid src_port [%s]\n", srcport_str);
-        }
-        else
-        {
-            if ( GT_TRUE == tpm_set_mc_vid_key (src_port,
-                                               mc_uni_xlate_mode,
-                                               mc_uni_xlate_vid) )
-            {
-                printk(KERN_INFO "OK.\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_set_mc_vid_key failed\n", __FUNCTION__);
-            }
-        }
-    }
-}
-void sfs_tpm_cfg_set_mc_vid_cfg_set    (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mcvidcfgset_owner=0, mcvidcfgset_mc_vid, mcvidcfgset_max
-    } mcvidcfgset_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 mc_vid;
-    int                      parsedargs;
-    int                      numparms;
-
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != mcvidcfgset_max)
-    {
-        parm_error_completion(numparms, mcvidcfgset_max, buf, sfs_help_igmp_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &mc_vid);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], mc_vid[%d]\n",
-               len, parsedargs, ownerid, mc_vid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = tpm_set_mc_vid_cfg (mc_vid)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK.\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_set_mc_vid_cfg failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-void sfs_tpm_cfg_send_genquery_to_uni  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        sendgenquerytouni_target_ports=0, sendgenquerytouni_packet_num, sendgenquerytouni_max
-    } sendgenquerytouni_parm_indx_t;
-    // shell line parsing
-    uint32_t                 packet_num;
-    uint32_t                 target_ports;
-    int                      parsedargs;
-    int                      numparms;
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != sendgenquerytouni_max)
-    {
-        parm_error_completion(numparms, sendgenquerytouni_max, buf, sfs_help_send_genquery_to_uni);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "0x%x %d ", &target_ports, &packet_num);
-        printk(KERN_INFO "len=%d, parsedargs=%d. target_ports[0x%x]. packet_num[%d]\n",
-               len, parsedargs, target_ports, packet_num);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-		rc = tpm_proc_send_genquery_to_uni(target_ports, packet_num);
-            if (TPM_RC_OK == rc)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_send_genquery_to_uni failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_gen_5t_rule_bounce(uint32_t owner_id,
-										tpm_dir_t src_dir,
-										uint32_t rule_num,
-										uint32_t *rule_idx,
-										tpm_parse_fields_t parse_rule_bm,
-										tpm_parse_flags_t parse_flags_bm,
-										tpm_l4_ports_key_t *l4_key,
-										tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-										tpm_pkt_frwd_t *pkt_frwd,
-										tpm_pkt_mod_t *pkt_mod,
-										tpm_pkt_mod_bm_t pkt_mod_bm,
-										tpm_rule_action_t *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd      = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd    = MV_TPM_IOCTL_ADD_IPV6_GEN_5T_RULE;
-    tpm_add_acl_rule->owner_id       = owner_id;
-    tpm_add_acl_rule->src_dir        = src_dir;
-    tpm_add_acl_rule->rule_num       = rule_num;
-    tpm_add_acl_rule->parse_rule_bm  = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_gen_5t_rule.parse_flags_bm = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_mod_bm     = pkt_mod_bm;
-
-	memcpy(&tpm_add_acl_rule->ipv6_gen_5t_rule.l4_key, l4_key, sizeof(tpm_l4_ports_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_gen_5t_rule.ipv6_gen_key, ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_frwd, pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	memcpy(&tpm_add_acl_rule->ipv6_gen_5t_rule.pkt_mod, pkt_mod, sizeof(tpm_pkt_mod_t));
-	memcpy(&tpm_add_acl_rule->ipv6_gen_5t_rule.rule_action, rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_gen_5t_rule tpm_add_ipv6_gen_5t_rule_bounce
-#else
- #define _tpm_add_ipv6_gen_5t_rule tpm_add_ipv6_gen_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_gen_rule_add
-*
-* DESCRIPTION:
-*           This function create IPv6 general rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_gen_5t_rule_add(const char *buf, size_t len)
-{
-    typedef enum {
-        ipv6ruleadd_owner=0, ipv6ruleadd_srcdir,    ipv6ruleadd_rulenum,  ipv6ruleadd_parserulebm,   ipv6ruleadd_parseflagsbm,
-        ipv6ruleadd_action,  ipv6ruleadd_nextphase, ipv6ruleadd_modbm,    ipv6ruleadd_ipv6l4keyname, ipv6ruleadd_ipv6genkeyname,
-        ipv6ruleadd_frwdname,ipv6ruleadd_modname,   ipv6ruleadd_max
-    } ipv4ruleadd_parm_indx_t;
-
-    uint32_t            owner_id;
-    tpm_dir_t           src_dir;
-    uint32_t            rule_num;
-    uint32_t            rule_idx;
-    tpm_parse_fields_t  parse_rule_bm;
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_l4_ports_key_t     l4_key;
-    tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-
-    tpmcfg_ipv6_l4_ports_key_entry_t *pdbipv6l4keyentry  = 0;
-    tpmcfg_ipv6_gen_key_entry_t      *pdbipv6genkeyentry = 0;
-    tpmcfg_frwd_entry_t              *pdbfrwdentry       = 0;
-    tpmcfg_mod_entry_t               *pdbmodentry        = 0;
-
-    tpm_error_code_t    rc;
-    int                 indx;
-    int                 parsedargs;
-    int                 numparms;
-    uint32_t            action;
-    uint32_t            nextphase;
-    char                srcdir_str[20];
-    char                uc_srcdir_str[20];
-    char                nextphase_str[20];
-    char                ipv6l4keyname[30];
-    char                ipv6genkeyname[30];
-    char                frwdname[20];
-    char                modname[20];
-
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6ruleadd_max)
-        parm_error_completion(numparms, ipv6ruleadd_max, buf, sfs_help_ipv6_gen_5t_rule_add);
-    else {
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s 0x%x %s %s %s %s",
-                            &owner_id, srcdir_str, &rule_num, &parse_rule_bm, &parse_flags_bm,
-                            &action, nextphase_str, &pkt_mod_bm, ipv6l4keyname, ipv6genkeyname, frwdname, modname);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], modbm[0x%x], ipv6l4keyname[%s], ipv6genkeyname[%s], frwdname[%s], modname[%s]\n",
-               len, parsedargs, owner_id, srcdir_str, rule_num, parse_rule_bm, parse_flags_bm, action, nextphase_str, pkt_mod_bm, ipv6l4keyname, ipv6genkeyname, frwdname, modname);
-
-        for (indx = 0; indx < strlen(srcdir_str); indx++)
-			uc_srcdir_str[indx] = (char)toupper(srcdir_str[indx]);
-
-        uc_srcdir_str[strlen(srcdir_str)] = 0;
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else if (get_srcdir_value(uc_srcdir_str, &src_dir) == GT_FALSE)
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcdir_str);
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        else if (((pdbipv6l4keyentry = find_tpm_ipv6_l4_ports_key_entry_by_name(ipv6l4keyname)) == 0) && \
-                    strcmp(ipv6l4keyname, ipv6_l4_key_empty_name) != 0)
-            printk(KERN_INFO "L4 ports key entry [%s] not found\n", ipv6genkeyname);
-        else if (((pdbipv6genkeyentry = find_tpm_ipv6_gen_key_entry_by_name(ipv6genkeyname)) == 0) && \
-                    strcmp(ipv6genkeyname, ipv6_gen_key_empty_name) != 0)
-            printk(KERN_INFO "IPV6 gen key entry [%s] not found\n", ipv6genkeyname);
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && \
-                    strcmp(frwdname, frwd_empty_name) != 0)
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && \
-                    strcmp(modname, mod_empty_name) != 0)
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        else {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv6l4keyentry != 0)
-                memcpy(&l4_key, &pdbipv6l4keyentry->l4_ports, sizeof(tpm_l4_ports_key_t));
-            else
-                memset(&l4_key, 0, sizeof(tpm_l4_ports_key_t));
-
-            if (pdbipv6genkeyentry != 0)
-                memcpy(&ipv6_gen_key, &pdbipv6genkeyentry->ipv6gen_acl, sizeof(tpm_ipv6_gen_acl_key_t));
-            else
-                memset(&ipv6_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-
-            if (pdbfrwdentry != 0)
-                memcpy(&pkt_frwd, &pdbfrwdentry->frwd, sizeof(tpm_pkt_frwd_t));
-            else
-                memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)
-                memcpy(&pkt_mod, &pdbmodentry->mod, sizeof(tpm_pkt_mod_t));
-            else
-                memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-
-            if (TPM_RC_OK == (rc = _tpm_add_ipv6_gen_5t_rule(owner_id,
-                                                            src_dir,
-                                                            rule_num,
-                                                            &rule_idx,
-                                                            parse_rule_bm,
-                                                            parse_flags_bm,
-                                                            &l4_key,
-                                                            &ipv6_gen_key,
-                                                            &pkt_frwd,
-                                                            &pkt_mod,
-                                                            pkt_mod_bm,
-                                                            &rule_action)) )
-                PR_RULE_IDX(rule_idx)
-            else
-                printk(KERN_INFO "%s: tpm_add_ipv6_gen_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_gen_5t_rule_bounce(uint32_t        owner_id,
-							 uint32_t        rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_IPV6_GEN_5T_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_gen_5t_rule tpm_del_ipv6_gen_5t_rule_bounce
-#else
- #define _tpm_del_ipv6_gen_5t_rule tpm_del_ipv6_gen_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_gen_5t
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW gen ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_gen_5t(const char *buf, size_t len)
-{
-    typedef enum {
-        noipv6gen_owner=0, noipv6gen_ruleidx, noipv6gen_max
-    } noipv6genruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6gen_max)
-        parm_error_completion(numparms, noipv6gen_max, buf, sfs_help_no_rule_add);
-    else {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-               len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else {
-            if ((rc = _tpm_del_ipv6_gen_5t_rule(ownerid, rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_del_ipv6_gen_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_dip_5t_rule_bounce(uint32_t owner_id,
-												tpm_dir_t src_dir,
-												uint32_t rule_num,
-												uint32_t *rule_idx,
-												tpm_parse_fields_t parse_rule_bm,
-												tpm_parse_flags_t parse_flags_bm,
-												tpm_l4_ports_key_t *l4_key,
-												tpm_ipv6_gen_acl_key_t *ipv6_gen_key,
-												tpm_ipv6_addr_key_t *ipv6_dip_key,
-												tpm_pkt_frwd_t *pkt_frwd,
-												tpm_pkt_mod_t *pkt_mod,
-												tpm_pkt_mod_bm_t pkt_mod_bm,
-												tpm_rule_action_t *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd      = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd    = MV_TPM_IOCTL_ADD_IPV6_DIP_5T_RULE;
-    tpm_add_acl_rule->owner_id       = owner_id;
-    tpm_add_acl_rule->src_dir        = src_dir;
-    tpm_add_acl_rule->rule_num       = rule_num;
-    tpm_add_acl_rule->parse_rule_bm  = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_dip_5t_rule.parse_flags_bm = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_mod_bm     = pkt_mod_bm;
-
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.l4_key, l4_key, sizeof(tpm_l4_ports_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.ipv6_gen_key, ipv6_gen_key, sizeof(tpm_ipv6_gen_acl_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.ipv6_dip_key, ipv6_dip_key, sizeof(tpm_ipv6_addr_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_frwd, pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.pkt_mod, pkt_mod, sizeof(tpm_pkt_mod_t));
-	memcpy(&tpm_add_acl_rule->ipv6_dip_5t_rule.rule_action, rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_dip_5t_rule tpm_add_ipv6_dip_5t_rule_bounce
-#else
- #define _tpm_add_ipv6_dip_5t_rule tpm_add_ipv6_dip_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_dip_5t_rule_add
-*
-* DESCRIPTION:
-*           This function create IPv6 general rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_dip_5t_rule_add(const char *buf, size_t len)
-{
-    typedef enum {
-        ipv6ruleadd_owner=0,        ipv6ruleadd_srcdir,    ipv6ruleadd_rulenum,  ipv6ruleadd_parserulebm,   ipv6ruleadd_parseflagsbm,
-        ipv6ruleadd_action,         ipv6ruleadd_nextphase, ipv6ruleadd_modbm,    ipv6ruleadd_ipv6l4keyname, ipv6ruleadd_ipv6genkeyname,
-        ipv6ruleadd_ipv6dipkeyname, ipv6ruleadd_frwdname,ipv6ruleadd_modname,   ipv6ruleadd_max
-    } ipv4ruleadd_parm_indx_t;
-
-    uint32_t            owner_id;
-    tpm_dir_t           src_dir;
-    uint32_t            rule_num;
-    uint32_t            rule_idx;
-    tpm_parse_fields_t  parse_rule_bm;
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_l4_ports_key_t     l4_key;
-    tpm_ipv6_gen_acl_key_t ipv6_gen_key;
-    tpm_ipv6_addr_key_t    ipv6_dip_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-
-    tpmcfg_ipv6_l4_ports_key_entry_t *pdbipv6l4keyentry  = 0;
-    tpmcfg_ipv6_gen_key_entry_t      *pdbipv6genkeyentry = 0;
-    tpmcfg_ipv6_dip_key_entry_t      *pdbipv6dipkeyentry = 0;
-    tpmcfg_frwd_entry_t              *pdbfrwdentry       = 0;
-    tpmcfg_mod_entry_t               *pdbmodentry        = 0;
-
-    tpm_error_code_t    rc;
-    int                 indx;
-    int                 parsedargs;
-    int                 numparms;
-    uint32_t            action;
-    uint32_t            nextphase;
-    char                srcdir_str[20];
-    char                uc_srcdir_str[20];
-    char                nextphase_str[20];
-    char                ipv6l4keyname[30];
-    char                ipv6genkeyname[30];
-    char                ipv6dipkeyname[30];
-    char                frwdname[20];
-    char                modname[20];
-
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6ruleadd_max)
-        parm_error_completion(numparms, ipv6ruleadd_max, buf, sfs_help_ipv6_dip_5t_rule_add);
-    else {
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s 0x%x %s %s %s %s %s",
-                            &owner_id, srcdir_str, &rule_num, &parse_rule_bm, &parse_flags_bm,
-                            &action, nextphase_str, &pkt_mod_bm, ipv6l4keyname, ipv6genkeyname,
-                            ipv6dipkeyname, frwdname, modname);
-        printk("len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], "\
-			"parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], modbm[0x%x], "\
-			"ipv6l4keyname[%s], ipv6genkeyname[%s], ipv6dipkeyname[%s], frwdname[%s], modname[%s]\n",
-            len, parsedargs, owner_id, srcdir_str, rule_num,
-            parse_rule_bm, parse_flags_bm, action, nextphase_str, pkt_mod_bm,
-            ipv6l4keyname, ipv6genkeyname, ipv6dipkeyname, frwdname, modname);
-
-        for (indx = 0; indx < strlen(srcdir_str); indx++)
-			uc_srcdir_str[indx] = (char)toupper(srcdir_str[indx]);
-
-        uc_srcdir_str[strlen(srcdir_str)] = 0;
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else if (get_srcdir_value(uc_srcdir_str, &src_dir) == GT_FALSE)
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcdir_str);
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        else if (((pdbipv6l4keyentry = find_tpm_ipv6_l4_ports_key_entry_by_name(ipv6l4keyname)) == 0) && \
-                    strcmp(ipv6l4keyname, ipv6_l4_key_empty_name) != 0)
-            printk(KERN_INFO "L4 ports key entry [%s] not found\n", ipv6l4keyname);
-        else if (((pdbipv6genkeyentry = find_tpm_ipv6_gen_key_entry_by_name(ipv6genkeyname)) == 0) && \
-                    strcmp(ipv6genkeyname, ipv6_gen_key_empty_name) != 0)
-            printk(KERN_INFO "IPV6 gen key entry [%s] not found\n", ipv6genkeyname);
-        else if (((pdbipv6dipkeyentry = find_tpm_ipv6_dip_key_entry_by_name(ipv6dipkeyname)) == 0) && \
-                    strcmp(ipv6dipkeyname, ipv6_dip_key_empty_name) != 0)
-            printk(KERN_INFO "IPV6 dip key entry [%s] not found\n", ipv6dipkeyname);
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && \
-                    strcmp(frwdname, frwd_empty_name) != 0)
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && \
-                    strcmp(modname, mod_empty_name) != 0)
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        else {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv6l4keyentry != 0)
-                memcpy(&l4_key, &pdbipv6l4keyentry->l4_ports, sizeof(tpm_l4_ports_key_t));
-            else
-                memset(&l4_key, 0, sizeof(tpm_l4_ports_key_t));
-
-            if (pdbipv6genkeyentry != 0)
-                memcpy(&ipv6_gen_key, &pdbipv6genkeyentry->ipv6gen_acl, sizeof(tpm_ipv6_gen_acl_key_t));
-            else
-                memset(&ipv6_gen_key, 0, sizeof(tpm_ipv6_gen_acl_key_t));
-
-            if (pdbipv6dipkeyentry != 0)
-                memcpy(&ipv6_dip_key, &pdbipv6dipkeyentry->ipv6_addr, sizeof(tpm_ipv6_addr_key_t));
-            else
-                memset(&ipv6_dip_key, 0, sizeof(tpm_ipv6_addr_key_t));
-
-            if (pdbfrwdentry != 0)
-                memcpy(&pkt_frwd, &pdbfrwdentry->frwd, sizeof(tpm_pkt_frwd_t));
-            else
-                memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)
-                memcpy(&pkt_mod, &pdbmodentry->mod, sizeof(tpm_pkt_mod_t));
-            else
-                memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-
-            if (TPM_RC_OK == (rc = _tpm_add_ipv6_dip_5t_rule(owner_id,
-                                                            src_dir,
-                                                            rule_num,
-                                                            &rule_idx,
-                                                            parse_rule_bm,
-                                                            parse_flags_bm,
-                                                            &l4_key,
-                                                            &ipv6_gen_key,
-                                                            &ipv6_dip_key,
-                                                            &pkt_frwd,
-                                                            &pkt_mod,
-                                                            pkt_mod_bm,
-                                                            &rule_action)) )
-                PR_RULE_IDX(rule_idx)
-            else
-                printk(KERN_INFO "%s: tpm_add_ipv6_dip_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_dip_5t_rule_bounce(uint32_t        owner_id,
-							 uint32_t        rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_IPV6_DIP_5T_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_dip_5t_rule tpm_del_ipv6_dip_5t_rule_bounce
-#else
- #define _tpm_del_ipv6_dip_5t_rule tpm_del_ipv6_dip_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_dip_5t
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW gen ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_dip_5t(const char *buf, size_t len)
-{
-    typedef enum {
-        noipv6dip_owner=0, noipv6dip_ruleidx, noipv6dip_max
-    } noipv6dipruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6dip_max)
-        parm_error_completion(numparms, noipv6dip_max, buf, sfs_help_no_rule_add);
-    else {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-               len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else {
-            if ((rc = _tpm_del_ipv6_dip_5t_rule(ownerid, rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_del_ipv6_dip_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ipv6_l4_ports_5t_rule_bounce(uint32_t owner_id,
-													tpm_dir_t src_dir,
-													uint32_t rule_num,
-													uint32_t *rule_idx,
-													tpm_parse_fields_t parse_rule_bm,
-													tpm_parse_flags_t parse_flags_bm,
-													tpm_l4_ports_key_t *l4_key,
-													tpm_pkt_frwd_t *pkt_frwd,
-													tpm_pkt_mod_t *pkt_mod,
-													tpm_pkt_mod_bm_t pkt_mod_bm,
-													tpm_rule_action_t *rule_action)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd      = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd    = MV_TPM_IOCTL_ADD_IPV6_L4_PORTS_5T_RULE;
-    tpm_add_acl_rule->owner_id       = owner_id;
-    tpm_add_acl_rule->src_dir        = src_dir;
-    tpm_add_acl_rule->rule_num       = rule_num;
-    tpm_add_acl_rule->parse_rule_bm  = parse_rule_bm;
-    tpm_add_acl_rule->ipv6_l4_ports_5t_rule.parse_flags_bm = parse_flags_bm;
-    tpm_add_acl_rule->ipv6_l4_ports_5t_rule.pkt_mod_bm     = pkt_mod_bm;
-
-	memcpy(&tpm_add_acl_rule->ipv6_l4_ports_5t_rule.l4_key, l4_key, sizeof(tpm_l4_ports_key_t));
-	memcpy(&tpm_add_acl_rule->ipv6_l4_ports_5t_rule.pkt_frwd, pkt_frwd, sizeof(tpm_pkt_frwd_t));
-	memcpy(&tpm_add_acl_rule->ipv6_l4_ports_5t_rule.pkt_mod, pkt_mod, sizeof(tpm_pkt_mod_t));
-	memcpy(&tpm_add_acl_rule->ipv6_l4_ports_5t_rule.rule_action, rule_action, sizeof(tpm_rule_action_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ipv6_l4_ports_5t_rule tpm_add_ipv6_l4_ports_5t_rule_bounce
-#else
- #define _tpm_add_ipv6_l4_ports_5t_rule tpm_add_ipv6_l4_ports_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_l4_ports_5t_rule_add
-*
-* DESCRIPTION:
-*           This function create IPv6 general rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_l4_ports_5t_rule_add(const char *buf, size_t len)
-{
-    typedef enum {
-        ipv6ruleadd_owner=0, ipv6ruleadd_srcdir,    ipv6ruleadd_rulenum,  ipv6ruleadd_parserulebm,   ipv6ruleadd_parseflagsbm,
-        ipv6ruleadd_action,  ipv6ruleadd_nextphase, ipv6ruleadd_modbm,    ipv6ruleadd_ipv6l4keyname, ipv6ruleadd_frwdname,
-        ipv6ruleadd_modname, ipv6ruleadd_max
-    } ipv4ruleadd_parm_indx_t;
-
-    uint32_t            owner_id;
-    tpm_dir_t           src_dir;
-    uint32_t            rule_num;
-    uint32_t            rule_idx;
-    tpm_parse_fields_t  parse_rule_bm;
-    tpm_parse_flags_t   parse_flags_bm;
-    tpm_l4_ports_key_t  l4_key;
-    tpm_pkt_frwd_t      pkt_frwd;
-    tpm_pkt_mod_t       pkt_mod;
-    tpm_pkt_mod_bm_t    pkt_mod_bm;
-    tpm_rule_action_t   rule_action;
-
-    tpmcfg_ipv6_l4_ports_key_entry_t *pdbipv6l4keyentry  = 0;
-    tpmcfg_frwd_entry_t              *pdbfrwdentry       = 0;
-    tpmcfg_mod_entry_t               *pdbmodentry        = 0;
-
-    tpm_error_code_t    rc;
-    int                 indx;
-    int                 parsedargs;
-    int                 numparms;
-    uint32_t            action;
-    uint32_t            nextphase;
-    char                srcdir_str[20];
-    char                uc_srcdir_str[20];
-    char                nextphase_str[20];
-    char                ipv6l4keyname[30];
-    char                frwdname[20];
-    char                modname[20];
-
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6ruleadd_max)
-        parm_error_completion(numparms, ipv6ruleadd_max, buf, sfs_help_ipv6_l4_ports_5t_rule_add);
-    else {
-        parsedargs = sscanf(buf, "%d %s %d 0x%x 0x%x 0x%x %s 0x%x %s %s %s",
-                            &owner_id, srcdir_str, &rule_num, &parse_rule_bm, &parse_flags_bm,
-                            &action, nextphase_str, &pkt_mod_bm, ipv6l4keyname, frwdname, modname);
-        printk("len=%d, parsedargs=%d. ownerid[%d], srcport_str[%s], rulenum[%d], "\
-			"parserulebm[0x%x], parseflagsbm[0x%x], action[0x%x], nextphase_str[%s], "\
-			"modbm[0x%x], ipv6l4keyname[%s], frwdname[%s], modname[%s]\n",
-            len, parsedargs, owner_id, srcdir_str, rule_num,
-            parse_rule_bm, parse_flags_bm, action, nextphase_str,
-            pkt_mod_bm, ipv6l4keyname, frwdname, modname);
-
-        for (indx = 0; indx < strlen(srcdir_str); indx++)
-			uc_srcdir_str[indx] = (char)toupper(srcdir_str[indx]);
-
-        uc_srcdir_str[strlen(srcdir_str)] = 0;
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else if (get_srcdir_value(uc_srcdir_str, &src_dir) == GT_FALSE)
-            printk(KERN_INFO "Invalid src_port[%s]\n", srcdir_str);
-        else if (get_phase_value(nextphase_str, &nextphase) == GT_FALSE)
-            printk(KERN_INFO "Invalid next_phase[%s]\n", nextphase_str);
-        else if (((pdbipv6l4keyentry = find_tpm_ipv6_l4_ports_key_entry_by_name(ipv6l4keyname)) == 0) && \
-                    strcmp(ipv6l4keyname, ipv6_l4_key_empty_name) != 0)
-            printk(KERN_INFO "L4 ports key entry [%s] not found\n", ipv6l4keyname);
-        else if (((pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname)) == 0) && \
-                    strcmp(frwdname, frwd_empty_name) != 0)
-            printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
-        else if (((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0) && \
-                    strcmp(modname, mod_empty_name) != 0)
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        else {
-            rule_action.next_phase = nextphase;
-            rule_action.pkt_act    = action;
-
-            if (pdbipv6l4keyentry != 0)
-                memcpy(&l4_key, &pdbipv6l4keyentry->l4_ports, sizeof(tpm_l4_ports_key_t));
-            else
-                memset(&l4_key, 0, sizeof(tpm_l4_ports_key_t));
-
-            if (pdbfrwdentry != 0)
-                memcpy(&pkt_frwd, &pdbfrwdentry->frwd, sizeof(tpm_pkt_frwd_t));
-            else
-                memset(&pkt_frwd, 0, sizeof(tpm_pkt_frwd_t));
-
-            if (pdbmodentry != 0)
-                memcpy(&pkt_mod, &pdbmodentry->mod, sizeof(tpm_pkt_mod_t));
-            else
-                memset(&pkt_mod, 0, sizeof(tpm_pkt_mod_t));
-
-            if (TPM_RC_OK == (rc = _tpm_add_ipv6_l4_ports_5t_rule(owner_id,
-	                                                            src_dir,
-	                                                            rule_num,
-	                                                            &rule_idx,
-	                                                            parse_rule_bm,
-	                                                            parse_flags_bm,
-	                                                            &l4_key,
-	                                                            &pkt_frwd,
-	                                                            &pkt_mod,
-	                                                            pkt_mod_bm,
-	                                                            &rule_action)) )
-                PR_RULE_IDX(rule_idx)
-            else
-                printk(KERN_INFO "%s: tpm_add_ipv6_l4_ports_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ipv6_l4_ports_5t_rule_bounce(uint32_t        owner_id,
-							      uint32_t        rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_IPV6_DIP_5T_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ipv6_l4_ports_5t_rule tpm_del_ipv6_l4_ports_5t_rule_bounce
-#else
- #define _tpm_del_ipv6_l4_ports_5t_rule tpm_del_ipv6_l4_ports_5t_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_5t
-*
-* DESCRIPTION:
-*           This function deletes a IPV6 HW gen ACL rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_5t(const char *buf, size_t len)
-{
-    typedef enum {
-        noipv6l4_owner=0, noipv6l4_ruleidx, noipv6l4_max
-    } noipv6l4ruleadd_parm_indx_t;
-    // shell line parsing
-    unsigned int             ownerid;
-    uint32_t                 rule_idx;
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    // Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noipv6l4_max)
-        parm_error_completion(numparms, noipv6l4_max, buf, sfs_help_no_rule_add);
-    else {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-               len, parsedargs, ownerid, rule_idx);
-
-
-        if (parsedargs != numparms)
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        else {
-            if ((rc = _tpm_del_ipv6_l4_ports_5t_rule(ownerid, rule_idx)) == TPM_RC_OK)
-                PR_RESULT
-            else
-                printk(KERN_INFO "%s: tpm_del_ipv6_l4_ports_5t_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-        }
-    }
-}
-
-/*tpm self check*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_rule_self_check_bounce(uint32_t owner_id,uint32_t level)
-{
-    tpm_ioctl_tpm_check_t *tpm_check_param = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_check_param;
-
-    tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_TPM_CHECK_SECTION;
-    tpm_check_param->owner_id = owner_id;
-    tpm_check_param->check_level = level;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_rule_self_check tpm_rule_self_check_bounce
-#else
- #define _tpm_rule_self_check tpm_rule_self_check
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_rule_self_check
-*
-* DESCRIPTION:
-*           This function creates does a tpm rule check
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_rule_self_check (const char *buf, size_t len)
-{
-	typedef enum
-	{
-		tpm_self_check_owner=0, tpm_self_check_level, tpm_self_check_max
-	} tpm_check_parm_indx_t;
-	// shell line parsing
-	uint32_t                 ownerid;
-	uint32_t                 level;
-	int                      parsedargs;
-	int                      numparms;
-	//Used in API call
-	tpm_error_code_t         rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != tpm_self_check_max) {
-		parm_error_completion(numparms, tpm_self_check_max, buf, sfs_help_mib_reset);
-	} else {
-		// Get parameters
-		parsedargs = sscanf(buf, "%d %d", &ownerid, &level);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (level > TPM_ENUM_MAX_CHECK_LEVEL) {
-			printk(KERN_INFO "Invalid level[%d]\n", level);
-		} else {
-			if ((rc = _tpm_rule_self_check(ownerid, level)) != TPM_RC_OK) {
-				printk(KERN_INFO "%s: tpm_rule_self_check failed, rc[%d] - %s\n",
-				       __FUNCTION__, rc, get_tpm_err_str(rc));
-			}
-		}
-	}
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_flush_vtu_bounce(uint32_t     owner_id)
-{
-    tpm_ioctl_flush_vtu_t *tpm_flush_vtu = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_flush_vtu;
-
-    tpm_sfs_2_ioctl_command.cmd   = MV_TPM_IOCTL_FLUSH_VTU_SECTION;
-    tpm_flush_vtu->owner_id       = owner_id;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_flush_vtu tpm_flush_vtu_bounce
-#else
- #define _tpm_flush_vtu tpm_flush_vtu
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_flush_vtu
-*
-* DESCRIPTION:
-*           This function flush vtu of the switch
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_flush_vtu  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        flush_vtu_owner=0,  flush_vtu_max
-    } flush_vtu_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != flush_vtu_max)
-    {
-        parm_error_completion(numparms, flush_vtu_max, buf, sfs_help_flush_vtu);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d", &ownerid);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d]\n", len, parsedargs, ownerid);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else
-        {
-            if ((rc = _tpm_flush_vtu(ownerid)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_flush_vtu failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_flush_atu_bounce(uint32_t owner_id, tpm_flush_atu_type_t flush_type, uint16_t db_num)
-{
-    tpm_ioctl_flush_atu_t *tpm_flush_atu = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_flush_atu;
-
-    tpm_sfs_2_ioctl_command.cmd         = MV_TPM_IOCTL_FLUSH_ATU_SECTION;
-    tpm_flush_atu->owner_id       = owner_id;
-    tpm_flush_atu->flush_type     = flush_type;
-    tpm_flush_atu->db_num         = db_num;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_flush_atu tpm_flush_atu_bounce
-#else
- #define _tpm_flush_atu tpm_flush_atu
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_flush_atu
-*
-* DESCRIPTION:
-*           This function flush atu of the switch
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_flush_atu  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        flush_atu_owner=0, flush_atu_type, flush_atu_dbnum, flush_atu_max
-    } flush_atu_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 flush_type;
-    uint32_t                 db_num;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != flush_atu_max)
-    {
-        parm_error_completion(numparms, flush_atu_max, buf, sfs_help_flush_atu);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d %d", &ownerid, &flush_type, &db_num);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], flush_type[%d], db_num[%d]\n",
-//                          len, parsedargs, ownerid, flush_type, db_num);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (flush_type > TPM_FLUSH_ATU_DYNAMIC)
-        {
-            printk(KERN_INFO "Invalid flush_type[%d]\n", flush_type);
-        }
-        else
-        {
-            if ((rc = _tpm_flush_atu(ownerid, flush_type, db_num)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_flush_atu failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_ctc_cm_set_ipv6_parse_win_bounce(uint32_t owner_id, tpm_ctc_cm_ipv6_parse_win_t ipv6_parse_window)
-{
-    tpm_ioctl_ipv6_parse_window_t *ipv6_parse_window = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ipv6_parse_window;
-
-    tpm_sfs_2_ioctl_command.cmd           = MV_TPM_IOCTL_SET_IPV6_CM_PARSE_WIN_SECTION;
-    ipv6_parse_window->owner_id           = owner_id;
-    ipv6_parse_window->ipv6_parse_window  = ipv6_parse_window;
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_ctc_cm_set_ipv6_parse_win tpm_ctc_cm_set_ipv6_parse_win_bounce
-#else
- #define _tpm_ctc_cm_set_ipv6_parse_win tpm_ctc_cm_set_ipv6_parse_win
-#endif
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_mac_learn_rule_bounce(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_MAC_LEARN_ACL_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    memcpy(&(tpm_add_acl_rule->l2_acl_rule.l2_key), (void*)src_mac_addr, sizeof(tpm_l2_acl_key_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_mac_learn_rule tpm_add_mac_learn_rule_bounce
-#else
- #define _tpm_add_mac_learn_rule tpm_add_mac_learn_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_ctc_cm_set_ipv6_parse_win
-*
-* DESCRIPTION:
-*           This function set_ipv6_parse_win
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_ctc_cm_set_ipv6_parse_win  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ctc_cm_set_ipv6_parse_win_owner=0, ctc_cm_set_ipv6_parse_win, ctc_cm_set_ipv6_parse_win_max
-    } ctc_cm_set_ipv6_parse_win_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 ipv6_parse_win;
-    int                      parsedargs;
-    int                      numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ctc_cm_set_ipv6_parse_win_max)
-    {
-        parm_error_completion(numparms, ctc_cm_set_ipv6_parse_win_max, buf, sfs_help_ctc_cm_set_ipv6_parse_win);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d", &ownerid, &ipv6_parse_win);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], ipv6_parse_win[%d]\n",
-//                          len, parsedargs, ownerid, db_num);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (ipv6_parse_win > TPM_CTC_CM_IPv6_SECOND_24B)
-        {
-            printk(KERN_INFO "Invalid ipv6_parse_win[%d]\n", ipv6_parse_win);
-        }
-        else
-        {
-            if ((rc = _tpm_ctc_cm_set_ipv6_parse_win(ownerid, (tpm_ctc_cm_ipv6_parse_win_t)ipv6_parse_win)) == TPM_RC_OK)
-            {
-                printk(KERN_INFO "OK\n");
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_ctc_cm_set_ipv6_parse_win failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-/*******************************************************************************
-* sfs_tpm_cfg_set_mac_learn_rule_add
-*
-* DESCRIPTION:
-*           This function creates a L2 mac learn rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mac_learn_rule_add(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_learn_add_owner=0, mac_learn_add_l2keyname, mac_learn_add_max
-	} mac_learn_add_parm_indx_t;
-	/* shell line parsing */
-	uint32_t ownerid;
-	char l2keyname[20];
-	int parsedargs;
-	int numparms;
-	/* DB */
-	tpmcfg_l2_key_entry_t *pdbl2keyentry = 0;
-
-	/* Used in API call */
-	tpm_l2_acl_key_t l2_acl;
-	tpm_error_code_t rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != mac_learn_add_max) {
-		parm_error_completion(numparms, mac_learn_add_max, buf, sfs_help_mac_learn_rule_add);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %s", &ownerid, l2keyname);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (((pdbl2keyentry = find_tpm_l2_key_entry_by_name(l2keyname)) == 0)) {
-			printk(KERN_INFO "L2 MAC addr key entry [%s] not found\n", l2keyname);
-			return;
-		} else {
-			memcpy(&l2_acl, &pdbl2keyentry->l2_acl, sizeof(tpm_l2_acl_key_t));
-			if ((rc = _tpm_add_mac_learn_rule(ownerid, &l2_acl)) == TPM_RC_OK)
-				printk("OK\n");
-			else
-				printk(KERN_INFO "%s: tpm_add_mac_learn_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_mac_learn_rule_bounce(uint32_t owner_id, tpm_l2_acl_key_t *src_mac_addr)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_MAC_LEARN_ACL_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    memcpy(&(tpm_del_acl_rule->l2_key), (void*)src_mac_addr, sizeof(tpm_l2_acl_key_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
-#define _tpm_del_mac_learn_rule tpm_del_mac_learn_rule_bounce
-#else
-#define _tpm_del_mac_learn_rule tpm_del_mac_learn_rule
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_mac_learn
-*
-* DESCRIPTION:
-*           This function deletes a L2 mac learn rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_mac_learn(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		noruleadd_maclearn_owner=0, noruleadd_maclearn_l2keyname, noruleadd_maclearn_max
-	} noruleadd_maclearn_parm_indx_t;
-	/* shell line parsing */
-	uint32_t ownerid;
-	int parsedargs;
-	int numparms;
-	char l2keyname[20];
-	tpmcfg_l2_key_entry_t *pdbl2keyentry = 0;
-	/* Used in API call */
-	tpm_l2_acl_key_t l2_acl;
-	tpm_error_code_t rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != noruleadd_maclearn_max) {
-		parm_error_completion(numparms, noruleadd_maclearn_max, buf, sfs_help_no_rule_add);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %s", &ownerid, l2keyname);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else if (((pdbl2keyentry = find_tpm_l2_key_entry_by_name(l2keyname)) == 0)) {
-			printk(KERN_INFO "L2 MAC addr key entry [%s] not found\n", l2keyname);
-			return;
-		} else {
-			memcpy(&l2_acl, &pdbl2keyentry->l2_acl, sizeof(tpm_l2_acl_key_t));
-			if ((rc = _tpm_del_mac_learn_rule(ownerid, &l2_acl)) == TPM_RC_OK)
-				printk(KERN_INFO "OK\n");
-			else
-				printk(KERN_INFO "%s: tpm_del_mac_learn_rule failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mac_learn_default_rule_act_set_bounce(uint32_t owner_id, tpm_unknown_mac_conf_t mac_conf)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd   = MV_TPM_IOCTL_SET_MAC_LEARN_DEFAULT_ACTION;
-    tpm_add_acl_rule->owner_id      = owner_id;
-    tpm_add_acl_rule->l2_acl_rule.mac_conf = mac_conf;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
-#define _tpm_mac_learn_default_rule_act_set tpm_mac_learn_default_rule_act_set_bounce
-#else
-#define _tpm_mac_learn_default_rule_act_set tpm_mac_learn_default_rule_act_set
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mac_learn_default_rule_action
-*
-* DESCRIPTION:
-*           This function set the action for mac learn default rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mac_learn_default_rule_action(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		default_rule_action_owner=0, default_rule_action_act, default_rule_action_max
-	} default_rule_action_parm_indx_t;
-	/* shell line parsing */
-	uint32_t ownerid;
-	int parsedargs;
-	int numparms;
-	tpm_unknown_mac_conf_t mac_conf;
-	/* Used in API call */
-	tpm_error_code_t rc;
-
-	numparms = count_parameters(buf);
-	if (numparms != default_rule_action_max) {
-		parm_error_completion(numparms, default_rule_action_max, buf, sfs_help_mac_learn_def_act_set);
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %x", &ownerid, &mac_conf);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if ((rc = _tpm_mac_learn_default_rule_act_set(ownerid, mac_conf)) == TPM_RC_OK)
-				printk(KERN_INFO "OK\n");
-			else
-				printk(KERN_INFO "%s: tpm_mac_learn_default_rule_act_set failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_fc
-*
-* DESCRIPTION:
-*           This function configures SW flow control
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_fc(const char *buf, size_t len)
-{
-	typedef enum {
-		fc_thresh_high = 0,
-		fc_thresh_low,
-		fc_port,
-		fc_tgt_port,
-		fc_tx_port,
-		fc_tx_queue,
-		fc_max
-	} fc_parm_indx_t;
-	/* shell line parsing */
-	tpm_fc_cfg_t cfg;
-	int parsedargs;
-	int numparms;
-
-	numparms = count_parameters(buf);
-	if (numparms != fc_max)
-		parm_error_completion(numparms, fc_max, buf, sfs_help_rate_limit);
-	else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d %d %d %d %d %d",
-				    &cfg.thresh_high, &cfg.thresh_low,
-				    &cfg.port, &cfg.tx_port, &cfg.tx_queue, &cfg.tgt_port);
-
-		if (parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else {
-			tpm_fc_set_config(&cfg);
-			printk(KERN_INFO "OK\n");
-
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_fc_period
-*
-* DESCRIPTION:
-*           This function configures SW flow control engine minitoring period
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_fc_period(const char *buf, size_t len)
-{
-	typedef enum {
-		fc_period = 0,
-		fc_max
-	} fc_parm_indx_t;
-	/* shell line parsing */
-	uint32_t period;
-	int parsedargs;
-	int numparms;
-	MV_STATUS ret_code;
-
-	numparms = count_parameters(buf);
-	if (numparms != fc_max)
-		parm_error_completion(numparms, fc_max, buf, sfs_help_rate_limit);
-	else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &period);
-
-		if (parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else {
-			ret_code = tpm_fc_set_period(period);
-			if (ret_code != MV_OK)
-				printk(KERN_INFO "%s: tpm_fc_set_period() failed!\n", __func__);
-			else
-				printk(KERN_INFO "OK\n");
-		}
-	}
-}
-
-#ifdef TPM_FC_DEBUG
-/*******************************************************************************
-* sfs_tpm_cfg_set_fc_oneshot
-*
-* DESCRIPTION:
-*   		This function configures SW flow control engine minitoring
-*   		oneshot count for statistics
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_fc_oneshot(const char *buf, size_t len)
-{
-	typedef enum {
-		fc_oneshot = 0,
-		fc_max
-	} fc_parm_indx_t;
-	/* shell line parsing */
-	uint32_t oneshot;
-	int parsedargs;
-	int numparms;
-	MV_STATUS ret_code;
-
-	numparms = count_parameters(buf);
-	if (numparms != fc_max)
-		parm_error_completion(numparms, fc_max, buf, sfs_help_rate_limit);
-	else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &oneshot);
-
-		if (parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else {
-			ret_code = tpm_fc_set_oneshot(oneshot);
-			if (ret_code != MV_OK)
-				printk(KERN_INFO "%s: tpm_fc_set_oneshot() failed!\n", __func__);
-			else
-				printk(KERN_INFO "OK\n");
-		}
-	}
-}
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_fc_enable
-*
-* DESCRIPTION:
-*   		This function configures SW flow control engine minitoring
-*   		oneshot count for statistics
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len     - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_fc_enable(const char *buf, size_t len)
-{
-	typedef enum {
-		_fc_enable = 0,
-		fc_max
-	} fc_parm_indx_t;
-	/* shell line parsing */
-	uint32_t fc_enable;
-	int parsedargs;
-	int numparms;
-	MV_STATUS ret_code;
-
-	numparms = count_parameters(buf);
-	if (numparms != fc_max)
-		parm_error_completion(numparms, fc_max, buf, sfs_help_rate_limit);
-	else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &fc_enable);
-
-		if (parsedargs != numparms)
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		else {
-			ret_code = tpm_fc_enable((fc_enable == 0) ? MV_FALSE : MV_TRUE);
-			if (ret_code != MV_OK)
-				printk(KERN_INFO "%s: tpm_fc_enable() failed!\n", __func__);
-			else
-				printk(KERN_INFO "OK\n");
-		}
-	}
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_add_ds_load_balance_rule_bounce(uint32_t                owner_id,
-                                        uint32_t                rule_num,
-                                        uint32_t               *rule_idx,
-                                        tpm_parse_fields_t      parse_rule_bm,
-					tpm_parse_flags_t	parse_flags_bm,
-                                        tpm_l2_acl_key_t       *l2_key,
-                                        tpm_ds_load_balance_tgrt_t tgrt_port)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_ADD_DS_LOAD_BALANCE_RULE;
-    tpm_add_acl_rule->owner_id                      = owner_id;
-    tpm_add_acl_rule->rule_num                      = rule_num;
-    tpm_add_acl_rule->parse_rule_bm                 = parse_rule_bm;
-    tpm_add_acl_rule->ds_load_balance_acl_rule.parse_flags_bm = parse_flags_bm;
-    tpm_add_acl_rule->ds_load_balance_acl_rule.tgrt = tgrt_port;
-    memcpy(&(tpm_add_acl_rule->ds_load_balance_acl_rule.l2_key),         (void*)l2_key,      sizeof(tpm_l2_acl_key_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_add_ds_load_balance_rule tpm_add_ds_load_balance_rule_bounce
-#else
- #define _tpm_add_ds_load_balance_rule tpm_add_ds_load_balance_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ds_load_balance_rule_add
-*
-* DESCRIPTION:
-*           This function creates a ds_load_balance rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ds_load_balance_rule_add  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ds_load_blnc_ruleadd_owner=0, ds_load_blnc_ruleadd_rulenum,
-	ds_load_blnc_ruleadd_parserulebm, ds_load_blnc_ruleadd_parseflagsbm,
-	ds_load_blnc_ruleadd_l2keyname,
-        ds_load_blnc_ruleadd_trgt, ds_load_blnc_ruleadd_max
-    } ds_load_blnc_ruleadd_parm_indx_t;
-    // shell line parsing
-    uint32_t                 ownerid;
-    uint32_t                 rulenum;
-    uint32_t                 parserulebm;
-    uint32_t                 parseflagsbm;
-    uint32_t                 trgt;
-    char                     l2keyname[20];
-    int                      parsedargs;
-    int                      numparms;
-    // DB
-    tpmcfg_l2_key_entry_t    *pdbl2keyentry = 0;
-    //Used in API call
-    tpm_l2_acl_key_t         l2_acl;
-    uint32_t                 rule_idx;
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != ds_load_blnc_ruleadd_max)
-    {
-        parm_error_completion(numparms, ds_load_blnc_ruleadd_max, buf, sfs_help_ds_load_balance_rule);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%d %d 0x%x 0x%x %s %d",  &ownerid, &rulenum, &parserulebm,
-                                 &parseflagsbm, l2keyname, &trgt);
-        printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rulenum[%d], parserulebm[0x%x], parseflagsbm[0x%x], "
-			"l2keyname[%s], trgt[%d]\n",
-               len, parsedargs, ownerid, rulenum, parserulebm, parseflagsbm, l2keyname, trgt);
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (((pdbl2keyentry = find_tpm_l2_key_entry_by_name(l2keyname)) == 0) && strcmp(l2keyname, l2_key_empty_name) != 0)
-        {
-            printk(KERN_INFO "L2 key entry [%s] not found\n", l2keyname);
-        }
-        else
-        {
-
-            if (pdbl2keyentry != 0)  memcpy(&l2_acl, &pdbl2keyentry->l2_acl, sizeof(tpm_l2_acl_key_t));
-            else                     memset(&l2_acl, 0,                      sizeof(tpm_l2_acl_key_t));
-
-            if ((rc = _tpm_add_ds_load_balance_rule(ownerid,
-                                       rulenum,
-                                       &rule_idx,
-                                       parserulebm,
-                                       parseflagsbm,
-                                       &l2_acl,
-                                       trgt)) == TPM_RC_OK)
-                PR_RULE_IDX(rule_idx)
-            else
-            {
-                printk(KERN_INFO "%s: tpm_add_ds_load_balance_rule failed, rc[%d] - %s\n",
-			__FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_del_ds_load_balance_rule_bounce(uint32_t        owner_id,
-                                        uint32_t        rule_idx)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd   = MV_TPM_IOCTL_DEL_DS_LOAD_BALANCE_RULE;
-    tpm_del_acl_rule->owner_id      = owner_id;
-    tpm_del_acl_rule->rule_idx      = rule_idx;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_del_ds_load_balance_rule tpm_del_ds_load_balance_rule_bounce
-#else
- #define _tpm_del_ds_load_balance_rule tpm_del_ds_load_balance_rule
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_no_rule_add_ds_load_balance
-*
-* DESCRIPTION:
-*           This function deletes a ds_load_balance HW rule (PNC)
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_no_rule_add_ds_load_balance  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-	noruleadd_owner=0,  noruleadd_ruleidx,	noruleadd_max
-    } noruleadd_parm_indx_t;
-    // shell line parsing
-    uint32_t		     ownerid;
-    uint32_t		     rule_idx;
-    int 		     parsedargs;
-    int 		     numparms;
-    //Used in API call
-    tpm_error_code_t	     rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != noruleadd_max)
-    {
-	parm_error_completion(numparms, noruleadd_max, buf, sfs_help_no_rule_add);
-    }
-    else
-    {
-	// Get parameters
-	parsedargs = sscanf(buf, "%d %d", &ownerid, &rule_idx);
-	//printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
-	//	 len, parsedargs, ownerid, rule_idx);
-
-
-	if (parsedargs != numparms)
-	{
-	    printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-	}
-	else
-	{
-	    if ((rc = _tpm_del_ds_load_balance_rule(ownerid, rule_idx)) == TPM_RC_OK)
-	    {
-		printk(KERN_INFO "OK\n");
-	    }
-	    else
-	    {
-		printk(KERN_INFO "%s: tpm_del_ds_load_balance_rule failed, rc[%d] - %s\n",
-			__FUNCTION__, rc, get_tpm_err_str(rc));
-	    }
-	}
-    }
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.h
deleted file mode 100644
index 74037d7..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_hwcall.h
+++ /dev/null
@@ -1,187 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_usr_tpmsysfs_db.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Zeev
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_TPM_SYSFS_HWCALL_H_
-#define _TPM_USR_TPM_SYSFS_HWCALL_H_
-
-extern void sfs_tpm_cfg_set_l2_rule_add                  (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l3_rule_add                  (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv4_rule_add                (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_gen_rule_add            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv4_stream_add           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv4_stream_set_queue_add           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv4_stream_update        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv6_stream_add           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv6_stream_set_queue_add           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_ipv6_stream_update        (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_igmp_port_forward_mode_cfg   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_igmp_cpu_queue_cfg           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_igmp_proxy_sa_mac            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_l2               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_l3               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv4             (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_no_mc_stream_add_ipv6        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_mc_stream_add_ipv4        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_oam_channel                  (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_omci_channel                 (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_oam_channel               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_omci_channel              (const char *buf, size_t len);
-extern void sfs_tpm_cfg_setup                            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mib_reset                    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_active_wan                   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_port_hwf_admin        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_hot_swap_profile            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_add_cpu_lpbk                     (const char *buf, size_t len);
-extern void sfs_tpm_cfg_del_cpu_lpbk                     (const char *buf, size_t len);
-extern void sfs_tpm_cfg_dump_cpu_lpbk                    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_get_lu_entry                     (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_count_mask                   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_get_hit_count                    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_get_pnc_all_hit_counters         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_lu_thresh                    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_reset_age_group                  (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_rate_limit_queue_set         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_scheduling_mode_queue_set    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_rate_limit_if_set            (const char *buf, size_t len);
-
-/* jinghuaxxxxxx */
-extern void sfs_tpm_cfg_set_ipv6_dip_key_rule            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_l4_key_rule             (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_dip_acl_rule_add        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_dip         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_l4_ports_acl_rule_add   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_acl(const char *buf, size_t len);
-/* jinghuaxxxxxx */
-
-extern void sfs_tpm_cfg_set_ipv6_gen_5t_rule_add         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_gen_5t      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_dip_5t_rule_add         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_dip_5t      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_l4_ports_5t_rule_add    (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_5t (const char *buf, size_t len);
-
-// zeev
-extern void sfs_tpm_cfg_set_ipv6_nh_acl_rule_add         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_nh_acl      (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_ctc_cm_rule_add              (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ctc_cm_acl       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ctc_cm_ipv6_rule_add         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_ctc_cm_set_ipv6_parse_win        (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_no_rule_add_ipv6_gen_acl     (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_mtu_enable                   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mtu                          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_pppoe_mtu                    (const char *buf, size_t len);
-
-
-extern void sfs_tpm_cfg_set_mc_vid_key_reset             (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_vid_key_set               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mc_vid_cfg_set               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_send_genquery_to_uni             (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_erase_section                (const char *buf, size_t len);
-extern void sfs_tpm_rule_self_check                      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_flush_atu                        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_flush_vtu                        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mac_learn_rule_add           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_mac_learn        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mac_learn_default_rule_action(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_gmac0_ingr_rate_limit        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ds_load_balance_rule_add     (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_no_rule_add_ds_load_balance  (const char *buf, size_t len);
-
-/* KostaP */
-extern void sfs_tpm_cfg_set_fc(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_fc_period(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_fc_oneshot(const char *buf, size_t len);
-extern void sfs_tpm_cfg_fc_enable(const char *buf, size_t len);
-
-extern char *ipv6_gen_key_empty_name;
-extern char *ipv6_dip_key_empty_name;
-extern char *ipv6_l4_key_empty_name;
-
-#endif  /* _TPM_USR_TPM_SYSFS_HWCALL_H_*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.c
deleted file mode 100644
index dd4a1b3..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.c
+++ /dev/null
@@ -1,3068 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux/ctype.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_utils.h"
-#include "tpm_sysfs_help.h"
-#include "tpm_sysfs_hwcall.h"
-#include "tpm_sysfs_rule_db.h"
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-extern struct semaphore    tpm_sfs_2_ioctl_sem;
-extern tpm_ioctl_mng_t     tpm_sfs_2_ioctl_command;
- #define PR_RULE_IDX(rule_idx)  {}
- #define PR_RESULT              {}
-#else
- #define PR_RULE_IDX(rule_idx)  {printk(KERN_INFO "OK. rule_idx = %d\n", rule_idx);}
- #define PR_RESULT              {printk(KERN_INFO "OK.\n");}
-#endif
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static char helpbuf[1024];
-#endif
-
-const char *vlan_empty_name = "vlan_empty";
-
-/******************************************************************************/
-/* ========================================================================== */
-/*                            TPM SYS FS                                      */
-/* ========================================================================== */
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG FORWARDING FUNCTIONS                                                 */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_frwd_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies forwarding rule
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_frwd_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        frpi_name=0, frpi_port, frpi_que, frpi_gem, frpi_max
-    } frwd_rule_parm_indx_t;
-    unsigned int        temp_port;
-    unsigned int        temp_que;
-    unsigned int        temp_gem;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_frwd_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != frpi_max)
-    {
-        parm_error_completion(numparms, frpi_max, buf, sfs_help_frwd_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s 0x%x %d %d", name, &temp_port, &temp_que,&temp_gem);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_port[0x%x],temp_que[%d],temp_gem[%d]\n",
-//               len, parsedargs, name, temp_port, temp_que, temp_gem);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_que > 255)
-        {
-            printk(KERN_INFO "Invalid queue [%d]\n", temp_que);
-        }
-        else if (temp_gem > 4095)
-        {
-            printk(KERN_INFO "Invalid gem port [%d]\n", temp_gem);
-        }
-        else
-        {
-            if ((pentry = find_tpm_pkt_frwd_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_pkt_frwd_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Packet Forward DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->frwd.trg_port  = (tpm_trg_port_type_t)temp_port;
-                pentry->frwd.trg_queue = (uint8_t)temp_que;
-                pentry->frwd.gem_port  = (uint16_t)temp_gem;
-            }
-        }
-    }
-}
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG VLAN FUNCTIONS                                                       */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_vlan_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies VLAN rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_vlan_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        vrpi_name=0, vrpi_tpid, vrpi_tpid_mask, vrpi_vid, vrpi_vid_mask, vrpi_cfi, vrpi_cfi_mask, vrpi_pbit,
-		vrpi_pbit_mask, vrpi_max
-    } vlan_rule_parm_indx_t;
-    unsigned int        temp_tpid;
-    unsigned int        temp_tpid_mask;
-    unsigned int        temp_vid;
-    unsigned int        temp_vid_mask;
-    unsigned int        temp_cfi;
-    unsigned int        temp_cfi_mask;
-    unsigned int        temp_pbit;
-    unsigned int        temp_pbit_mask;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms = 0;
-    tpmcfg_vlan_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != vrpi_max)
-    {
-        parm_error_completion(numparms, vrpi_max, buf, sfs_help_vlan_rule_cfg);
-//        if (numparms == 1 && buf[0] == '?')
-//        {
-//            int  helpbuf_len;
-//
-//            helpbuf_len = sfs_help_vlan_rule_cfg(helpbuf);
-//            print_help_buffer(helpbuf, helpbuf_len);
-//        }
-//        else
-//        {
-//            printk(KERN_INFO "Parse problem: expected %d parameters, found %d\n", vrpi_max, numparms);
-//        }
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%s 0x%x 0x%x %d 0x%x %d 0x%x %d 0x%x", name, &temp_tpid, &temp_tpid_mask, &temp_vid,
-							&temp_vid_mask, &temp_cfi, &temp_cfi_mask, &temp_pbit, &temp_pbit_mask);
-//        printk(KERN_INFO "len=%d. pardeargs=%d. rulename[%s] temp_tpid[0x%x], temp_tpid_mask[0x%x], vid[%d/0x%x], cfi[%d/0x%x],"
-//						"pbit[%d/0x%x]\n", len, parsedargs, name, temp_tpid, temp_vid, temp_vid_mask,
-//               				 temp_cfi, temp_cfi_mask, temp_pbit, temp_pbit_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_tpid > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid TPID [0x%x]\n", temp_tpid);
-        }
-        else if (temp_tpid_mask > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid TPID mask [0x%x]\n", temp_tpid_mask);
-        }
-        else if (temp_vid > 4095)
-        {
-            printk(KERN_INFO "Invalid VID [%d]\n", temp_vid);
-        }
-        else if (temp_vid_mask > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid VID mask [0x%x]\n", temp_vid_mask);
-        }
-        else if (temp_cfi > 1)
-        {
-            printk(KERN_INFO "Invalid CFI [%d]\n", temp_cfi);
-        }
-        else if (temp_cfi_mask > 0xFF)
-        {
-            printk(KERN_INFO "Invalid CFI mask [0x%x]\n", temp_cfi_mask);
-        }
-        else if (temp_pbit > 7)
-        {
-            printk(KERN_INFO "Invalid pbit [%d]\n", temp_pbit);
-        }
-        else if (temp_pbit_mask > 0xFF)
-        {
-            printk(KERN_INFO "Invalid pbit mask [0x%x]\n", temp_pbit_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_vlan_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_vlan_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "VLAN DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->vlan.tpid      = (uint16_t)temp_tpid;
-                pentry->vlan.tpid_mask = (uint16_t)temp_tpid_mask;
-                pentry->vlan.vid       = (uint16_t)temp_vid;
-                pentry->vlan.vid_mask  = (uint16_t)temp_vid_mask;
-                pentry->vlan.cfi       = (uint8_t) temp_cfi;
-                pentry->vlan.cfi_mask  = (uint8_t) temp_cfi_mask;
-                pentry->vlan.pbit      = (uint8_t) temp_pbit;
-                pentry->vlan.pbit_mask = (uint8_t) temp_pbit_mask;
-            }
-        }
-    }
-}
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG MOD  FUNCTIONS                                                       */
-/* ======================================================================================== */
-#if 0
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_proto_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies protocol part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_proto_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mprpi_name=0, mprpi_protocol, mprpi_max
-    } mod_proto_rule_parm_indx_t;
-    unsigned int        temp_protocol;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mprpi_max)
-    {
-        parm_error_completion(numparms, mprpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d", name, &temp_protocol);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_protocol[0x%x]\n",
-//               len, parsedargs, name, temp_protocol);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_protocol > 255)
-        {
-            printk(KERN_INFO "Invalid protocol [%d]\n", temp_protocol);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_IP_PROTO;
-                pentry->mod.l3.ipv4_mod.ipv4_proto  = (uint8_t)temp_protocol;
-            }
-        }
-    }
-}
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_vlan_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies vlan part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_vlan_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mvrpi_name=0, mvrpi_oper, mvrpi_vlan1, mvrpi_vlan2, mvrpi_max
-    } mod_vlan_rule_parm_indx_t;
-    char                name[100];
-    uint32_t            vlan_op;
-    char                vlan_op_str[30];
-    char                vlan1_name[100];
-    char                vlan2_name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-    tpmcfg_vlan_entry_t *pvlan1entry = 0;
-    tpmcfg_vlan_entry_t *pvlan2entry = 0;
-
-    numparms = count_parameters(buf);
-    if (numparms != mvrpi_max)
-    {
-        parm_error_completion(numparms, mvrpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s", name, vlan_op_str, vlan1_name, vlan2_name);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] vlan_op_str[%s] vlan1_name[%s] vlan2_name[%s]\n",
-//               len, parsedargs, name, vlan_op_str, vlan1_name, vlan2_name);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (get_vlan_op_value(vlan_op_str, &vlan_op) == GT_FALSE)     // TBD-ZG make symbolic
-        {
-            printk(KERN_INFO "Invalid vlan_op[%s]\n", vlan_op_str);
-        }
-        else if (((pvlan1entry = find_tpm_vlan_entry_by_name(vlan1_name)) == 0) && strcmp(vlan1_name, vlan_empty_name) != 0)
-        {
-            printk(KERN_INFO "vlan1 entry [%s] not found\n", vlan1_name);
-        }
-        else if (((pvlan2entry = find_tpm_vlan_entry_by_name(vlan2_name)) == 0) && strcmp(vlan2_name, vlan_empty_name) != 0)
-        {
-            printk(KERN_INFO "vlan2 entry [%s] not found\n", vlan2_name);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_VLAN;
-
-                pentry->mod.vlan_mod.vlan_op = vlan_op;
-
-                if (pvlan1entry != 0)
-                {
-                    memcpy(&pentry->mod.vlan_mod.vlan1_out, &pvlan1entry->vlan, sizeof(pentry->mod.vlan_mod.vlan1_out));
-                }
-                else
-                {
-                    memset(&pentry->mod.vlan_mod.vlan1_out, 0, sizeof(pentry->mod.vlan_mod.vlan1_out));
-                }
-
-                if (pvlan2entry != 0)
-                {
-                    memcpy(&pentry->mod.vlan_mod.vlan2_out, &pvlan2entry->vlan, sizeof(pentry->mod.vlan_mod.vlan2_out));
-                }
-                else
-                {
-                    memset(&pentry->mod.vlan_mod.vlan2_out, 0, sizeof(pentry->mod.vlan_mod.vlan2_out));
-                }
-            }
-        }
-    }
-}
-
-#if 0
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_dscp_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies DSCP part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_dscp_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mdspi_name=0, mdspi_dscp, mdspi_dscpmask, mdspi_max
-    } mod_dscp_rule_parm_indx_t;
-    unsigned int        temp_dscp;
-    unsigned int        temp_dscp_mask;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mdspi_max)
-    {
-        parm_error_completion(numparms, mdspi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_dscp, &temp_dscp_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_dscp[%d] temp_dscp_mask[0x%x]\n",
-//               len, parsedargs, name, temp_dscp, temp_dscp_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_dscp > 63)
-        {
-            printk(KERN_INFO "Invalid dscp [%d]\n", temp_dscp);
-        }
-        else if (temp_dscp_mask > 0xFF)
-        {
-            printk(KERN_INFO "Invalid dscp mask [0x%x]\n", temp_dscp_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_DSCP;
-                pentry->mod.l3.ipv4_mod.ipv4_dscp      = (uint8_t)temp_dscp;
-                pentry->mod.l3.ipv4_mod.ipv4_dscp_mask = (uint8_t)temp_dscp_mask;
-            }
-        }
-    }
-}
-#endif
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_ipv4_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies IPV4 address part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_ipv4_addr_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mipv4addpi_name=0, mipv4addpi_srcip, mipv4addpi_srcipmask, mipv4addpi_dstip, mipv4addpi_dstipmask, mipv4addpi_max
-    } mod_ipv4add_rule_parm_indx_t;
-    char                temp_srcip[30];
-    char                temp_srcip_mask[30];
-    char                temp_dstip[30];
-    char                temp_dstip_mask[30];
-    uint32_t            srcip[4];
-    uint32_t            srcip_mask[4];
-    uint32_t            dstip[4];
-    uint32_t            dstip_mask[4];
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mipv4addpi_max)
-    {
-        parm_error_completion(numparms, mipv4addpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_srcip[%s] temp_srcip_mask[%s] temp_dstip[%s] temp_dstip_mask[%s]\n",
-//               len, parsedargs, name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_ipv4_address(temp_srcip, srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
-        }
-        else if (parse_ipv4_address(temp_srcip_mask, srcip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
-        }
-        else if (parse_ipv4_address(temp_dstip, dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip [%s]\n", temp_dstip);
-        }
-        else if (parse_ipv4_address(temp_dstip_mask, dstip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip mask [%s]\n", temp_dstip_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else if (pentry->flags & MOD_ENTRY_FLAG_IPV6)
-            {
-                printk(KERN_INFO "IPV6 already defined for this entry!\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_IPV4;
-                pentry->mod.l3.ipv4_mod.ipv4_src_ip_add[0] = (uint8_t)srcip[0]; pentry->mod.l3.ipv4_mod.ipv4_src_ip_add[1] = (uint8_t)srcip[1];
-                pentry->mod.l3.ipv4_mod.ipv4_src_ip_add[2] = (uint8_t)srcip[2]; pentry->mod.l3.ipv4_mod.ipv4_src_ip_add[3] = (uint8_t)srcip[3];
-                pentry->mod.l3.ipv4_mod.ipv4_src_ip_add_mask[0] = (uint8_t)srcip_mask[0]; pentry->mod.l3.ipv4_mod.ipv4_src_ip_add_mask[1] = (uint8_t)srcip_mask[1];
-                pentry->mod.l3.ipv4_mod.ipv4_src_ip_add_mask[2] = (uint8_t)srcip_mask[2]; pentry->mod.l3.ipv4_mod.ipv4_src_ip_add_mask[3] = (uint8_t)srcip_mask[3];
-                pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add[0] = (uint8_t)dstip[0]; pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add[1] = (uint8_t)dstip[1];
-                pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add[2] = (uint8_t)dstip[2]; pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add[3] = (uint8_t)dstip[3];
-                pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add_mask[0] = (uint8_t)dstip_mask[0]; pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add_mask[1] = (uint8_t)dstip_mask[1];
-                pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add_mask[2] = (uint8_t)dstip_mask[2]; pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add_mask[3] = (uint8_t)dstip_mask[3];
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_ipv4_port_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies IPV4 port part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_ipv4_port_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mipv4portpi_name=0, mipv4portpi_srcport, mipv4portpi_dstport, mipv4portpi_max
-    } mod_ipv4port_rule_parm_indx_t;
-    unsigned int        temp_src_port;
-    unsigned int        temp_dst_port;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mipv4portpi_max)
-    {
-        parm_error_completion(numparms, mipv4portpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d %d", name, &temp_src_port, &temp_dst_port);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_src_port[%d] temp_dst_port[%d]\n",
-//               len, parsedargs, name, temp_src_port, temp_dst_port);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_src_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid srcport [%d]\n", temp_src_port);
-        }
-        else if (temp_dst_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid dstport [%d]\n", temp_dst_port);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else if (pentry->flags & MOD_ENTRY_FLAG_IPV6)
-            {
-                printk(KERN_INFO "IPV6 already defined for this entry!\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_IPV4;
-                pentry->mod.l3.ipv4_mod.l4_src_port = (uint16_t)temp_src_port;
-                pentry->mod.l3.ipv4_mod.l4_dst_port = (uint16_t)temp_dst_port;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_ipv6_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies IPV6 address part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_ipv6_addr_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mipv6addpi_name=0, mipv6addpi_srcip, mipv6addpi_srcipmask, mipv6addpi_dstip, mipv6addpi_dstipmask, mipv6addpi_max
-    } mod_ipv6add_rule_parm_indx_t;
-    char                     temp_srcip[60];
-    char                     temp_srcip_mask[60];
-    char                     temp_dstip[60];
-    char                     temp_dstip_mask[60];
-    uint32_t                 srcip[16];
-    uint32_t                 srcip_mask[16];
-    uint32_t                 dstip[16];
-    uint32_t                 dstip_mask[16];
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    int                      indx;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mipv6addpi_max)
-    {
-        parm_error_completion(numparms, mipv6addpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_srcip[%s] temp_srcip_mask[%s] temp_dstip[%s] temp_dstip_mask[%s]\n",
-//               len, parsedargs, name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_ipv6_address(temp_srcip, srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
-        }
-        else if (parse_ipv6_address(temp_srcip_mask, srcip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
-        }
-        else if (parse_ipv6_address(temp_dstip, dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip [%s]\n", temp_dstip);
-        }
-        else if (parse_ipv6_address(temp_dstip_mask, dstip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip mask [%s]\n", temp_dstip_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else if (pentry->flags & MOD_ENTRY_FLAG_IPV4)
-            {
-                printk(KERN_INFO "IPV4 already defined for this entry!\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_IPV6;
-                for (indx = 0; indx < 16; indx++)
-                {
-                    pentry->mod.l3.ipv6_mod.ipv6_src_ip_add[indx] = (uint8_t)srcip[indx];
-                    pentry->mod.l3.ipv6_mod.ipv6_src_ip_add_mask[indx] = (uint8_t)srcip_mask[indx];
-                    pentry->mod.l3.ipv6_mod.ipv6_dst_ip_add[indx] = (uint8_t)dstip[indx];
-                    pentry->mod.l3.ipv6_mod.ipv6_dst_ip_add_mask[indx] = (uint8_t)dstip_mask[indx];
-                }
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_ipv6_port_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies IPV6 port part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_ipv6_port_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mipv6portpi_name=0, mipv6portpi_srcport, mipv6portpi_dstport, mipv6portpi_max
-    } mod_ipv6port_rule_parm_indx_t;
-    unsigned int             temp_src_port;
-    unsigned int             temp_dst_port;
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mipv6portpi_max)
-    {
-        parm_error_completion(numparms, mipv6portpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d %d", name, &temp_src_port, &temp_dst_port);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_src_port[%d] temp_dst_port[%d]\n",
-//               len, parsedargs, name, temp_src_port, temp_dst_port);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_src_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid srcport [%d]\n", temp_src_port);
-        }
-        else if (temp_dst_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid dstport [%d]\n", temp_dst_port);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else if (pentry->flags & MOD_ENTRY_FLAG_IPV4)
-            {
-                printk(KERN_INFO "IPV4 already defined for this entry!\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_IPV6;
-                pentry->mod.l3.ipv6_mod.l4_src_port = (uint16_t)temp_src_port;
-                pentry->mod.l3.ipv6_mod.l4_dst_port = (uint16_t)temp_dst_port;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_mac_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies MAC address part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_mac_addr_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mmacpi_name=0, mmacpi_srcip, mmacpi_srcipmask, mmacpi_dstip, mmacpi_dstipmask, mmacpi_max
-    } mod_mac_rule_parm_indx_t;
-    char                temp_sa[30];
-    char                temp_sa_mask[30];
-    char                temp_da[30];
-    char                temp_da_mask[30];
-    uint32_t            sa[6];
-    uint32_t            sa_mask[6];
-    uint32_t            da[6];
-    uint32_t            da_mask[6];
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mmacpi_max)
-    {
-        parm_error_completion(numparms, mmacpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_sa[%s] temp_sa_mask[%s] temp_da[%s] temp_da_mask[%s]\n",
-//               len, parsedargs, name, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_mac_address(temp_sa, sa) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid SA [%s]\n", temp_sa);
-        }
-        else if (parse_mac_address(temp_sa_mask, sa_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid SA mask [%s]\n", temp_sa_mask);
-        }
-        else if (parse_mac_address(temp_da, da) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid DA [%s]\n", temp_da);
-        }
-        else if (parse_mac_address(temp_da_mask, da_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid DA mask [%s]\n", temp_da_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_MAC;
-                pentry->mod.mac_mod.mac_sa[0] = (uint8_t)sa[0]; pentry->mod.mac_mod.mac_sa[1] = (uint8_t)sa[1]; pentry->mod.mac_mod.mac_sa[2] = (uint8_t)sa[2];
-                pentry->mod.mac_mod.mac_sa[3] = (uint8_t)sa[3]; pentry->mod.mac_mod.mac_sa[4] = (uint8_t)sa[4]; pentry->mod.mac_mod.mac_sa[5] = (uint8_t)sa[5];
-
-                pentry->mod.mac_mod.mac_sa_mask[0] = (uint8_t)sa_mask[0]; pentry->mod.mac_mod.mac_sa_mask[1] = (uint8_t)sa_mask[1]; pentry->mod.mac_mod.mac_sa_mask[2] = (uint8_t)sa_mask[2];
-                pentry->mod.mac_mod.mac_sa_mask[3] = (uint8_t)sa_mask[3]; pentry->mod.mac_mod.mac_sa_mask[4] = (uint8_t)sa_mask[4]; pentry->mod.mac_mod.mac_sa_mask[5] = (uint8_t)sa_mask[5];
-
-                pentry->mod.mac_mod.mac_da[0] = (uint8_t)da[0]; pentry->mod.mac_mod.mac_da[1] = (uint8_t)da[1]; pentry->mod.mac_mod.mac_da[2] = (uint8_t)da[2];
-                pentry->mod.mac_mod.mac_da[3] = (uint8_t)da[3]; pentry->mod.mac_mod.mac_da[4] = (uint8_t)da[4]; pentry->mod.mac_mod.mac_da[5] = (uint8_t)da[5];
-
-                pentry->mod.mac_mod.mac_da_mask[0] = (uint8_t)da_mask[0]; pentry->mod.mac_mod.mac_da_mask[1] = (uint8_t)da_mask[1]; pentry->mod.mac_mod.mac_da_mask[2] = (uint8_t)da_mask[2];
-                pentry->mod.mac_mod.mac_da_mask[3] = (uint8_t)da_mask[3]; pentry->mod.mac_mod.mac_da_mask[4] = (uint8_t)da_mask[4]; pentry->mod.mac_mod.mac_da_mask[5] = (uint8_t)da_mask[5];
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_mh_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies marvell header part of modification rule
-*
-* See sfs_tpm_cfg_set_mod_mh_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_mh_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mmacpi_name=0, mmacpi_mh2b, mmacpi_max
-    } mod_mac_rule_parm_indx_t;
-    uint32_t            mh2b = 0;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mmacpi_max)
-    {
-        parm_error_completion(numparms, mmacpi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s 0x%2x", name, &mh2b);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] mh2b[0x%x]\n"
-//               len, parsedargs, name, mh2b);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (mh2b == 0)
-        {
-            printk(KERN_INFO "Invalid mh2b [0x%2x]\n", mh2b);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_MH;
-                pentry->mod.mh_mod = mh2b;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_mod_pppoe_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies PPPoE part of modification rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_mod_pppoe_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        mpppoepi_name=0, mpppoepi_session, mpppoepi_prototype, mpppoepi_max
-    } mod_pppoe_rule_parm_indx_t;
-    unsigned int        temp_session;
-    unsigned int        temp_prototype;
-    char                name[100];
-    int                 parsedargs;
-    int                 numparms;
-    tpmcfg_mod_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != mpppoepi_max)
-    {
-        parm_error_completion(numparms, mpppoepi_max, buf, sfs_help_mod_rule_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_session, &temp_prototype);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_session[%d] temp_prototype[0x%x]\n",
-//               len, parsedargs, name, temp_session, temp_prototype);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_session > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid session [%d]\n", temp_session);
-        }
-        else if (temp_prototype > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid protocol type [0x%x]\n", temp_prototype);
-        }
-        else
-        {
-            if ((pentry = find_tpm_mod_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_mod_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "Mod DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->flags |= MOD_ENTRY_FLAG_PPPOE;
-                pentry->mod.pppoe_mod.ppp_session = (uint16_t)temp_session;
-                pentry->mod.pppoe_mod.ppp_proto   = (uint16_t)temp_prototype;
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mod_entry_set_bounce(tpm_trg_port_type_t   trg_port,
-                                          tpm_pkt_mod_bm_t      mod_bm,
-                                          tpm_pkt_mod_int_bm_t  int_mod_bm,
-                                          tpm_pkt_mod_t        *mod_data,
-                                          uint32_t             *mod_entry)
-{
-    tpm_ioctl_add_acl_rule_t *tpm_add_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_add_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_ADD_ACL_SECTION;
-    tpm_add_acl_rule->add_acl_cmd                   = MV_TPM_IOCTL_SET_MOD_RULE;
-    tpm_add_acl_rule->mod_rule.trg_port             = trg_port;
-    tpm_add_acl_rule->mod_rule.mod_bm               = mod_bm;
-    tpm_add_acl_rule->mod_rule.int_bm               = int_mod_bm;
-    memcpy(&(tpm_add_acl_rule->mod_rule.mod_data), (void*)mod_data, sizeof(tpm_pkt_mod_t));
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_mod_entry_set tpm_mod_entry_set_bounce
-#else
- #define _tpm_mod_entry_set tpm_mod_entry_set
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_pkt_mod_eng_entry_add
-*
-* DESCRIPTION:
-*           This function adds packet modification to specified port
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_pkt_mod_eng_entry_add      (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        pktmodadd_trgport=0, pktmodadd_modbm, pktmodadd_int_modbm, pktmodadd_modname, pktmodadd_max
-    } pktmodadd_parm_indx_t;
-    // shell line parsing
-    char                trgport_str[20];
-    char                uc_trgport_str[20];
-    int                 indx;
-    uint32_t            trgport;
-    uint32_t            mod_bm;
-    uint32_t            int_mod_bm;
-    char                modname[20];
-    tpm_pkt_mod_t       mod_data;
-    uint32_t            mod_entry = 0;
-    int                 parsedargs;
-    int                 numparms;
-    // DB
-    tpmcfg_mod_entry_t  *pdbmodentry = 0;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != pktmodadd_max)
-    {
-        parm_error_completion(numparms, pktmodadd_max, buf, sfs_help_pkt_mod_add);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s 0x%x 0x%x %s", trgport_str, &mod_bm, &int_mod_bm, modname);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. trgport_str[%s], mod_bm[0x%x], flag[0x%x], modname[%s]\n",
-//               len, parsedargs, trgport_str, mod_bm, int_mod_bm, modname);
-
-        // Minimal help for trgport upper/lower case support
-        for (indx = 0; indx < strlen(trgport_str); indx++) uc_trgport_str[indx] = (char)toupper(trgport_str[indx]);
-        uc_trgport_str[strlen(trgport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_sched_entity_value(uc_trgport_str, &trgport) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid trg_port[%s]\n", trgport_str);
-        }
-        else if ((pdbmodentry = find_tpm_mod_entry_by_name(modname)) == 0)
-        {
-            printk(KERN_INFO "mod entry [%s] not found\n", modname);
-        }
-        else
-        {
-            memcpy(&mod_data, &pdbmodentry->mod, sizeof(mod_data));
-
-            if ((rc = _tpm_mod_entry_set(trgport,
-                                         mod_bm,
-                                         int_mod_bm,
-                                         &mod_data,
-                                         &mod_entry)) == TPM_RC_OK)
-            {
-                PR_RULE_IDX(mod_entry)
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_mod_entry_set failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-static char* opCodeOperationStr[30] =
-{
-    "NOOP",
-    "ADD",
-    "CONF_VLAN",
-    "ADD_VLAN",
-    "CONF_DSA1",
-    "CONF_DSA2",
-    "ADD_DSA",
-    "DEL",
-    "REP2",
-    "REP_LSB",
-    "REP_MSB",
-    "REP_VLAN",
-    "DEC_TTL_LSB",
-    "DEC_TTL_MSB",
-    "ADD_CALC_LEN",
-    "REP_LEN",
-    "REP_IP_CHKSUM",
-    "REP_L4_CHKSUM",
-    "SKIP",
-    "JUMP",
-    "JUMP_SKIP2",
-    "JUMP_SUBR",
-    "PPPOE",
-    "STORE",
-    "ADD_IP_CHKSUM",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED"
-};
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mod_entry_get_bounce(tpm_trg_port_type_t trg_port,
-					uint32_t mod_entry,
-					uint16_t *valid_cmds,
-					uint16_t *pnc_ref,
-					tpm_mod_rule_t *rule)
-{
-	tpm_ioctl_get_mod_rule_t *tpm_get_mod_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_get_mod;
-
-	tpm_sfs_2_ioctl_command.cmd   = MV_TPM_IOCTL_GET_MOD_SECTION;
-	tpm_get_mod_rule->get_mod_cmd = MV_TPM_IOCTL_GET_MOD_RULE;
-	tpm_get_mod_rule->trg_port    = trg_port;
-	tpm_get_mod_rule->rule_idx    = mod_entry;
-	//tpm_get_mod_rule->valid_num   = *valid_cmds;
-	//tpm_get_mod_rule->pnc_ref     = *pnc_ref;
-	up(&tpm_sfs_2_ioctl_sem);
-	//pnc_ref = &tpm_get_mod_rule->pnc_ref;//     = pnc_ref;
-	//rule = tpm_get_mod_rule->rule;// = rule;
-	//up(&tpm_sfs_2_ioctl_sem);
-	return TPM_RC_OK;
-}
- #define _tpm_mod_entry_get tpm_mod_entry_get_bounce
-#else
- #define _tpm_mod_entry_get tpm_mod_entry_get
-#endif
-/*******************************************************************************
-* sfs_tpm_cfg_set_pkt_mod_eng_entry_show
-*
-* DESCRIPTION:
-*           This function displays specific packet modification
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_pkt_mod_eng_entry_show     (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        pktmodshow_trgport=0, pktmodshow_modentry, pktmodshow_max
-    } pktmoddel_parm_indx_t;
-    // shell line parsing
-    char                trgport_str[20];
-    char                uc_trgport_str[20];
-    int                 indx;
-    uint32_t            trgport;
-    uint32_t            mod_entry;
-    uint16_t            valid_cmds;
-    uint16_t            pnc_ref;
-    tpm_mod_rule_t      rule[TPM_MAX_MOD_RULE_NUM];
-    int                 parsedargs;
-    int                 numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != pktmodshow_max)
-    {
-        parm_error_completion(numparms, pktmodshow_max, buf, sfs_help_pkt_mod_get_del_purge);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d", trgport_str, &mod_entry);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. trgport_str[%s], mod_entry[%d]\n", len, parsedargs, trgport_str, mod_entry);
-
-        // Minimal help for trgport upper/lower case support
-        for (indx = 0; indx < strlen(trgport_str); indx++) uc_trgport_str[indx] = (char)toupper(trgport_str[indx]);
-        uc_trgport_str[strlen(trgport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_sched_entity_value(uc_trgport_str, &trgport) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid trg_port[%s]\n", trgport_str);
-        }
-        else
-        {
-            if ((rc = _tpm_mod_entry_get(trgport,
-                                         mod_entry,
-                                         &valid_cmds,
-                                         &pnc_ref,
-                                         rule)) == TPM_RC_OK)
-            {
-#ifndef CONFIG_MV_TPM_SFS_2_IOCTL
-                uint16_t         rule_idx;
-
-                printk("==========================================================\n");
-                printk(" Index  OpCode    Operation      Data  Last  IPv4    L4   \n");
-                printk("                                            update update \n");
-                printk("==========================================================\n");
-
-                for (rule_idx = 0; rule_idx < valid_cmds; rule_idx++)
-                {
-                    printk(" %03d      0x%2x  %15s  0x%4.4x  %1d     %1d      %1d\n",
-                           rule[rule_idx].entry_id, rule[rule_idx].entry_data.opcode,
-                           opCodeOperationStr[rule[rule_idx].entry_data.opcode],
-                           rule[rule_idx].entry_data.data, rule[rule_idx].entry_data.last,
-                           rule[rule_idx].entry_data.updt_ipv4, rule[rule_idx].entry_data.updt_tcp);
-                }
-#endif
-            }
-            else
-            {
-                printk(KERN_INFO "%s: tpm_mod_entry_get failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mod_entry_del_bounce(tpm_trg_port_type_t  trg_port,
-                                          uint32_t             mod_entry)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_DEL_MOD_RULE;
-    tpm_del_acl_rule->trg_port                      = trg_port;
-    tpm_del_acl_rule->rule_idx                      = mod_entry;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_mod_entry_del tpm_mod_entry_del_bounce
-#else
- #define _tpm_mod_entry_del tpm_mod_entry_del
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_pkt_mod_eng_entry_del
-*
-* DESCRIPTION:
-*           This function deletes single packet modification from supplied port
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_pkt_mod_eng_entry_del      (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        pktmoddel_trgport=0, pktmoddel_modentry, pktmoddel_max
-    } pktmoddel_parm_indx_t;
-    // shell line parsing
-    char                trgport_str[20];
-    char                uc_trgport_str[20];
-    int                 indx;
-    uint32_t            trgport;
-    uint32_t            mod_entry;
-    int                 parsedargs;
-    int                 numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms != pktmoddel_max)
-    {
-        parm_error_completion(numparms, pktmoddel_max, buf, sfs_help_pkt_mod_get_del_purge);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d", trgport_str, &mod_entry);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. trgport_str[%s], mod_entry[%d]\n", len, parsedargs, trgport_str, mod_entry);
-
-        // Minimal help for trgport upper/lower case support
-        for (indx = 0; indx < strlen(trgport_str); indx++) uc_trgport_str[indx] = (char)toupper(trgport_str[indx]);
-        uc_trgport_str[strlen(trgport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_sched_entity_value(uc_trgport_str, &trgport) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid trg_port[%s]\n", trgport_str);
-        }
-        else
-        {
-            if ((rc = _tpm_mod_entry_del(trgport,
-                                         mod_entry)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_mod_entry_del failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-tpm_error_code_t tpm_mod_mac_inv_bounce(tpm_trg_port_type_t  trg_port)
-{
-    tpm_ioctl_del_acl_rule_t *tpm_del_acl_rule = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_del_acl_rule;
-
-    tpm_sfs_2_ioctl_command.cmd                     = MV_TPM_IOCTL_DEL_ACL_SECTION;
-    tpm_del_acl_rule->del_acl_cmd                   = MV_TPM_IOCTL_INV_MOD_RULES;
-    tpm_del_acl_rule->trg_port                      = trg_port;
-
-    up(&tpm_sfs_2_ioctl_sem);
-
-    return TPM_RC_OK;
-}
- #define _tpm_mod_mac_inv tpm_mod_mac_inv_bounce
-#else
- #define _tpm_mod_mac_inv tpm_mod_mac_inv
-#endif
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_pkt_mod_eng_purge
-*
-* DESCRIPTION:
-*           This function removes all packet modification from supplied port
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_pkt_mod_eng_purge          (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        pktmodadd_trgport, pktmodpurge_max
-    } pktmodpurge_parm_indx_t;
-    // shell line parsing
-    char                trgport_str[20];
-    char                uc_trgport_str[20];
-    int                 indx;
-    uint32_t            trgport;
-    int                 parsedargs;
-    int                 numparms;
-    //Used in API call
-    tpm_error_code_t         rc;
-
-    numparms = count_parameters(buf);
-    if (numparms == 1 && buf[0] == '?')
-    {
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-        int  helpbuf_len;
-
-        helpbuf_len = sfs_help_pkt_mod_get_del_purge(helpbuf);
-        print_help_buffer(helpbuf, helpbuf_len);
-#else
-	printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", pktmodpurge_max, numparms);
-#endif
-    }
-    else if (numparms != 1)
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", pktmodpurge_max, numparms);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s", trgport_str);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. trgport_str[%s]\n", len, parsedargs, trgport_str);
-
-        // Minimal help for trgport upper/lower case support
-        for (indx = 0; indx < strlen(trgport_str); indx++) uc_trgport_str[indx] = (char)toupper(trgport_str[indx]);
-        uc_trgport_str[strlen(trgport_str)] = 0;
-
-        if (parsedargs != numparms)
-        {
-            printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-        }
-        else if (get_sched_entity_value(uc_trgport_str, &trgport) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid trg_port[%s]\n", trgport_str);
-        }
-        else
-        {
-            if ((rc = _tpm_mod_mac_inv(trgport)) == TPM_RC_OK)
-                PR_RESULT
-            else
-            {
-                printk(KERN_INFO "%s: tpm_mod_mac_inv failed, rc[%d] - %s\n", __FUNCTION__, rc, get_tpm_err_str(rc));
-            }
-        }
-    }
-}
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG L2 KEY FUNCTIONS                                                   */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_key_ethertype_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies ethertype part part of L2 ACL key
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_key_ethertype_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2etypi_name=0, l2etypi_ety, l2etypi_max
-    } l2_ety_rule_parm_indx_t;
-    unsigned int          temp_ety;
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l2_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2etypi_max)
-    {
-        parm_error_completion(numparms, l2etypi_max, buf, sfs_help_l2_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s 0x%x", name, &temp_ety);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_ety[0x%x]\n",
-//               len, parsedargs, name, temp_ety);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_ety > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid ethertype [0x%x]\n", temp_ety);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l2_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l2_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L2 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l2_acl.ether_type  = (uint16_t)temp_ety;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_key_gemport_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies gemport part part of L2 ACL key
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_key_gemport_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2gempi_name=0, l2gempi_ety, l2gempi_max
-    } l2_gemport_rule_parm_indx_t;
-    unsigned int          temp_gemport;
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l2_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2gempi_max)
-    {
-        parm_error_completion(numparms, l2gempi_max, buf, sfs_help_l2_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d", name, &temp_gemport);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_gemport[%d]\n",
-//               len, parsedargs, name, temp_gemport);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_gemport > 4095)
-        {
-            printk(KERN_INFO "Invalid gemport [%d]\n", temp_gemport);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l2_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l2_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L2 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l2_acl.gem_port  = (uint16_t)temp_gemport;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_key_mac_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies MAC address part of L2 ACL key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_key_mac_addr_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2macpi_name=0, l2macpi_srcip, l2macpi_srcipmask, l2macpi_dstip, l2macpi_dstipmask, l2macpi_max
-    } l2_mac_rule_parm_indx_t;
-    char                  temp_sa[30];
-    char                  temp_sa_mask[30];
-    char                  temp_da[30];
-    char                  temp_da_mask[30];
-    uint32_t              sa[6];
-    uint32_t              sa_mask[6];
-    uint32_t              da[6];
-    uint32_t              da_mask[6];
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l2_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2macpi_max)
-    {
-        parm_error_completion(numparms, l2macpi_max, buf, sfs_help_l2_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_sa[%s] temp_sa_mask[%s] temp_da[%s] temp_da_mask[%s]\n",
-//               len, parsedargs, name, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_mac_address(temp_sa, sa) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid SA [%s]\n", temp_sa);
-        }
-        else if (parse_mac_address(temp_sa_mask, sa_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid SA mask [%s]\n", temp_sa_mask);
-        }
-        else if (parse_mac_address(temp_da, da) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid DA [%s]\n", temp_da);
-        }
-        else if (parse_mac_address(temp_da_mask, da_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid DA mask [%s]\n", temp_da_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l2_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l2_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L2 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l2_acl.mac.mac_sa[0] = (uint8_t)sa[0]; pentry->l2_acl.mac.mac_sa[1] = (uint8_t)sa[1]; pentry->l2_acl.mac.mac_sa[2] = (uint8_t)sa[2];
-                pentry->l2_acl.mac.mac_sa[3] = (uint8_t)sa[3]; pentry->l2_acl.mac.mac_sa[4] = (uint8_t)sa[4]; pentry->l2_acl.mac.mac_sa[5] = (uint8_t)sa[5];
-
-                pentry->l2_acl.mac.mac_sa_mask[0] = (uint8_t)sa_mask[0]; pentry->l2_acl.mac.mac_sa_mask[1] = (uint8_t)sa_mask[1]; pentry->l2_acl.mac.mac_sa_mask[2] = (uint8_t)sa_mask[2];
-                pentry->l2_acl.mac.mac_sa_mask[3] = (uint8_t)sa_mask[3]; pentry->l2_acl.mac.mac_sa_mask[4] = (uint8_t)sa_mask[4]; pentry->l2_acl.mac.mac_sa_mask[5] = (uint8_t)sa_mask[5];
-
-                pentry->l2_acl.mac.mac_da[0] = (uint8_t)da[0]; pentry->l2_acl.mac.mac_da[1] = (uint8_t)da[1]; pentry->l2_acl.mac.mac_da[2] = (uint8_t)da[2];
-                pentry->l2_acl.mac.mac_da[3] = (uint8_t)da[3]; pentry->l2_acl.mac.mac_da[4] = (uint8_t)da[4]; pentry->l2_acl.mac.mac_da[5] = (uint8_t)da[5];
-
-                pentry->l2_acl.mac.mac_da_mask[0] = (uint8_t)da_mask[0]; pentry->l2_acl.mac.mac_da_mask[1] = (uint8_t)da_mask[1]; pentry->l2_acl.mac.mac_da_mask[2] = (uint8_t)da_mask[2];
-                pentry->l2_acl.mac.mac_da_mask[3] = (uint8_t)da_mask[3]; pentry->l2_acl.mac.mac_da_mask[4] = (uint8_t)da_mask[4]; pentry->l2_acl.mac.mac_da_mask[5] = (uint8_t)da_mask[5];
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_key_pppoe_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies PPPoE part of L2 ACL key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_key_pppoe_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2pppoepi_name=0, l2pppoepi_session, l2pppoepi_prototype, l2pppoepi_max
-    } l2_pppoe_rule_parm_indx_t;
-    unsigned int          temp_session;
-    unsigned int          temp_prototype;
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l2_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2pppoepi_max)
-    {
-        parm_error_completion(numparms, l2pppoepi_max, buf, sfs_help_l2_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_session, &temp_prototype);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_session[%d] temp_prototype[0x%x]\n",
-//               len, parsedargs, name, temp_session, temp_prototype);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_session > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid session [%d]\n", temp_session);
-        }
-        else if (temp_prototype > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid protocol type [0x%x]\n", temp_prototype);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l2_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l2_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L2 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l2_acl.pppoe_hdr.ppp_session = (uint16_t)temp_session;
-                pentry->l2_acl.pppoe_hdr.ppp_proto   = (uint16_t)temp_prototype;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l2_key_vlan_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies vlan part of L2 ACL key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l2_key_vlan_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l2vrpi_name=0, l2vrpi_vlan1, l2vrpi_vlan2, l2vrpi_max
-    } l2_vlan_rule_parm_indx_t;
-    char                  name[100];
-    char                  vlan1_name[100];
-    char                  vlan2_name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l2_key_entry_t *pentry;
-    tpmcfg_vlan_entry_t   *pvlan1entry = 0;
-    tpmcfg_vlan_entry_t   *pvlan2entry = 0;
-
-    numparms = count_parameters(buf);
-    if (numparms != l2vrpi_max)
-    {
-        parm_error_completion(numparms, l2vrpi_max, buf, sfs_help_l2_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s", name, vlan1_name, vlan2_name);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] vlan1_name[%s] vlan2_name[%s]\n",
-//               len, parsedargs, name, vlan1_name, vlan2_name);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (((pvlan1entry = find_tpm_vlan_entry_by_name(vlan1_name)) == 0) && strcmp(vlan1_name, vlan_empty_name) != 0)
-        {
-            printk(KERN_INFO "vlan1 entry [%s] not found\n", vlan1_name);
-        }
-        else if (((pvlan2entry = find_tpm_vlan_entry_by_name(vlan2_name)) == 0) && strcmp(vlan2_name, vlan_empty_name) != 0)
-        {
-            printk(KERN_INFO "vlan2 entry [%s] not found\n", vlan2_name);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l2_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l2_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L2 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-
-                if (pvlan1entry != 0)
-                {
-                    memcpy(&pentry->l2_acl.vlan1, &pvlan1entry->vlan, sizeof(pentry->l2_acl.vlan1));
-                }
-                else
-                {
-                    memset(&pentry->l2_acl.vlan1, 0, sizeof(pentry->l2_acl.vlan1));
-                }
-
-                if (pvlan2entry != 0)
-                {
-                    memcpy(&pentry->l2_acl.vlan2, &pvlan2entry->vlan, sizeof(pentry->l2_acl.vlan2));
-                }
-                else
-                {
-                    memset(&pentry->l2_acl.vlan2, 0, sizeof(pentry->l2_acl.vlan2));
-                }
-            }
-        }
-    }
-}
-
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG L3 KEY FUNCTIONS                                                   */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l3_key_ethertype_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies ethertype part part of L3 ACL key
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l3_key_ethertype_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l3etypi_name=0, l3etypi_ety, l3etypi_max
-    } l3_ety_rule_parm_indx_t;
-    unsigned int          temp_ety;
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l3_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l3etypi_max)
-    {
-        parm_error_completion(numparms, l3etypi_max, buf, sfs_help_l3_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s 0x%x", name, &temp_ety);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_ety[0x%x]\n", len, parsedargs, name, temp_ety);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_ety > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid ethertype [0x%x]\n", temp_ety);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l3_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l3_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L3 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l3_acl.ether_type_key  = (uint16_t)temp_ety;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_l3_key_pppoe_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies PPPoE part of L3 ACL key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_l3_key_pppoe_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        l3pppoepi_name=0, l3pppoepi_session, l3pppoepi_prototype, l3pppoepi_max
-    } l3_pppoe_rule_parm_indx_t;
-    unsigned int          temp_session;
-    unsigned int          temp_prototype;
-    char                  name[100];
-    int                   parsedargs;
-    int                   numparms;
-    tpmcfg_l3_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != l3pppoepi_max)
-    {
-        parm_error_completion(numparms, l3pppoepi_max, buf, sfs_help_l3_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_session, &temp_prototype);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_session[%d] temp_prototype[0x%x]\n",
-//               len, parsedargs, name, temp_session, temp_prototype);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_session > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid session [%d]\n", temp_session);
-        }
-        else if (temp_prototype > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid protocol type [0x%x]\n", temp_prototype);
-        }
-        else
-        {
-            if ((pentry = find_tpm_l3_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_l3_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "L3 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->l3_acl.pppoe_key.ppp_session = (uint16_t)temp_session;
-                pentry->l3_acl.pppoe_key.ppp_proto   = (uint16_t)temp_prototype;
-            }
-        }
-    }
-}
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG IPV4 KEY FUNCTIONS                                                   */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv4_key_addr_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies address part of IPV4 key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv4_key_addr_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4addpi_name=0, ipv4addpi_srcip, ipv4addpi_srcipmask, ipv4addpi_dstip, ipv4addpi_dstipmask, ipv4addpi_max
-    } ipv4_add_rule_parm_indx_t;
-    char                     temp_srcip[30];
-    char                     temp_srcip_mask[30];
-    char                     temp_dstip[30];
-    char                     temp_dstip_mask[30];
-    uint32_t                 srcip[4];
-    uint32_t                 srcip_mask[4];
-    uint32_t                 dstip[4];
-    uint32_t                 dstip_mask[4];
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_ipv4_key_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4addpi_max)
-    {
-        parm_error_completion(numparms, ipv4addpi_max, buf, sfs_help_ipv4_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_srcip[%s] temp_srcip_mask[%s] temp_dstip[%s] temp_dstip_mask[%s]\n",
-//               len, parsedargs, name, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_ipv4_address(temp_srcip, srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
-        }
-        else if (parse_ipv4_address(temp_srcip_mask, srcip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
-        }
-        else if (parse_ipv4_address(temp_dstip, dstip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip [%s]\n", temp_dstip);
-        }
-        else if (parse_ipv4_address(temp_dstip_mask, dstip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid dstip mask [%s]\n", temp_dstip_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv4_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_ipv4_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV4 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->ipv4_acl.ipv4_src_ip_add[0] = (uint8_t)srcip[0]; pentry->ipv4_acl.ipv4_src_ip_add[1] = (uint8_t)srcip[1];
-                pentry->ipv4_acl.ipv4_src_ip_add[2] = (uint8_t)srcip[2]; pentry->ipv4_acl.ipv4_src_ip_add[3] = (uint8_t)srcip[3];
-                pentry->ipv4_acl.ipv4_src_ip_add_mask[0] = (uint8_t)srcip_mask[0]; pentry->ipv4_acl.ipv4_src_ip_add_mask[1] = (uint8_t)srcip_mask[1];
-                pentry->ipv4_acl.ipv4_src_ip_add_mask[2] = (uint8_t)srcip_mask[2]; pentry->ipv4_acl.ipv4_src_ip_add_mask[3] = (uint8_t)srcip_mask[3];
-                pentry->ipv4_acl.ipv4_dst_ip_add[0] = (uint8_t)dstip[0]; pentry->ipv4_acl.ipv4_dst_ip_add[1] = (uint8_t)dstip[1];
-                pentry->ipv4_acl.ipv4_dst_ip_add[2] = (uint8_t)dstip[2]; pentry->ipv4_acl.ipv4_dst_ip_add[3] = (uint8_t)dstip[3];
-                pentry->ipv4_acl.ipv4_dst_ip_add_mask[0] = (uint8_t)dstip_mask[0]; pentry->ipv4_acl.ipv4_dst_ip_add_mask[1] = (uint8_t)dstip_mask[1];
-                pentry->ipv4_acl.ipv4_dst_ip_add_mask[2] = (uint8_t)dstip_mask[2]; pentry->ipv4_acl.ipv4_dst_ip_add_mask[3] = (uint8_t)dstip_mask[3];
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv4_key_port_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies port part of IPV4 key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv4_key_port_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4portpi_name=0, ipv4portpi_srcport, ipv4portpi_dstport, ipv4portpi_max
-    } ipv4port_rule_parm_indx_t;
-    unsigned int             temp_src_port;
-    unsigned int             temp_dst_port;
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_ipv4_key_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4portpi_max)
-    {
-        parm_error_completion(numparms, ipv4portpi_max, buf, sfs_help_ipv4_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d %d", name, &temp_src_port, &temp_dst_port);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_src_port[%d] temp_dst_port[%d]\n",
-//               len, parsedargs, name, temp_src_port, temp_dst_port);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_src_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid srcport [%d]\n", temp_src_port);
-        }
-        else if (temp_dst_port > 0xFFFF)
-        {
-            printk(KERN_INFO "Invalid dstport [%d]\n", temp_dst_port);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv4_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_ipv4_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV4 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->ipv4_acl.l4_src_port = (uint16_t)temp_src_port;
-                pentry->ipv4_acl.l4_dst_port = (uint16_t)temp_dst_port;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv4_key_protocol_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies protocol part of IPV4 ACL rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv4_key_protocol_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4protopi_name=0, ipv4protopi_protocol, ipv4protopi_max
-    } ipv4proto_rule_parm_indx_t;
-    unsigned int             temp_protocol;
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_ipv4_key_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4protopi_max)
-    {
-        parm_error_completion(numparms, ipv4protopi_max, buf, sfs_help_ipv4_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d", name, &temp_protocol);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_protocol[0x%x]\n",
-//               len, parsedargs, name, temp_protocol);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_protocol > 255)
-        {
-            printk(KERN_INFO "Invalid protocol [%d]\n", temp_protocol);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv4_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_ipv4_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV4 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->ipv4_acl.ipv4_proto  = (uint8_t)temp_protocol;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv4_key_dscp_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies DSCP part of IPV4 ACL rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv4_key_dscp_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv4dscppi_name=0, ipv4dscppi_dscp, ipv4dscppi_dscpmask, ipv4dscppi_max
-    } ipv4dscp_rule_parm_indx_t;
-    unsigned int             temp_dscp;
-    unsigned int             temp_dscp_mask;
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_ipv4_key_entry_t  *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv4dscppi_max)
-    {
-        parm_error_completion(numparms, ipv4dscppi_max, buf, sfs_help_ipv4_key_cfg);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_dscp, &temp_dscp_mask);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_dscp[%d] temp_dscp_mask[0x%x]\n",
-//               len, parsedargs, name, temp_dscp, temp_dscp_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_dscp > 63)
-        {
-            printk(KERN_INFO "Invalid dscp [%d]\n", temp_dscp);
-        }
-        else if (temp_dscp_mask > 0xFF)
-        {
-            printk(KERN_INFO "Invalid dscp mask [0x%x]\n", temp_dscp_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv4_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_ipv4_key_entry();
-
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV4 key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->ipv4_acl.ipv4_dscp      = (uint8_t)temp_dscp;
-                pentry->ipv4_acl.ipv4_dscp_mask = (uint8_t)temp_dscp_mask;
-            }
-        }
-    }
-}
-
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG IPV6 KEY FUNCTIONS                                                   */
-/* ======================================================================================== */
-
-
-
-/********************************************************************************************/
-/* =========================================================================================*/
-/*             TPM CFG IPV6 GEN KEY FUNCTIONS                                             */
-/* ======================================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_gen_key_sip_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies source ip address part of IPV6 gen key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_gen_key_sip_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6gen_name=0, ipv6gen_srcip, ipv6gen_srcipmask, ipv6gen_max
-    } ipv6gensip_rule_parm_indx_t;
-    char     temp_srcip[60];
-    char     temp_srcip_mask[60];
-    uint32_t srcip[16];
-    uint32_t srcip_mask[16];
-    char     name[100];
-    int      parsedargs;
-    int      numparms;
-    int      indx;
-    tpmcfg_ipv6_gen_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6gen_max)
-    {
-        parm_error_completion(numparms, ipv6gen_max, buf, sfs_help_ipv6_gen_key_cfg);
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%s %s %s", name, temp_srcip, temp_srcip_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_ipv6_address(temp_srcip, srcip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
-        }
-        else if (parse_ipv6_address(temp_srcip_mask, srcip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv6_gen_key_entry_by_name(name)) == 0)
-            {
-                pentry = find_free_tpm_ipv6_gen_key_entry();
-            }
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV6 gen key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                for (indx = 0; indx < 16; indx++)
-                {
-                    pentry->ipv6gen_acl.ipv6_src_ip_add[indx]      = (uint8_t)srcip[indx];
-                    pentry->ipv6gen_acl.ipv6_src_ip_add_mask[indx] = (uint8_t)srcip_mask[indx];
-                }
-            }
-        }
-    }
-}
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_ctc_cm_key_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies CTC CnM of IPV6 gen key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_ctc_cm_key_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6ctc_name=0, ipv6gen_name, ipv6dip_name, ipv6l4_name, ipv6nh, ipv6hoplimit, ipv6ctc_max
-    } ipv6ctc_rule_parm_indx_t;
-    uint32_t ipv6_nh;
-    uint32_t ipv6_hoplimit;
-    char     ctc_key_name[40];
-    char     gen_key_name[40];
-    char     dip_key_name[40];
-    char     l4_key_name[40];
-    int      parsedargs;
-    int      numparms;
-    int      indx;
-    tpmcfg_ipv6_key_entry_t *pctc_entry;
-    tpmcfg_ipv6_gen_key_entry_t *pgen_entry;
-    tpmcfg_ipv6_dip_key_entry_t *pdip_entry;
-    tpmcfg_ipv6_l4_ports_key_entry_t  *pl4_entry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6ctc_max)
-    {
-        parm_error_completion(numparms, ipv6ctc_max, buf, sfs_help_ipv6_ctc_cm_key_cfg);
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%s %s %s %s %d %d", ctc_key_name, gen_key_name, dip_key_name,
-                            l4_key_name, &ipv6_nh, &ipv6_hoplimit);
-
-        if (strlen(ctc_key_name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", ctc_key_name);
-        }
-        else if (strlen(gen_key_name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", gen_key_name);
-        }
-        else if (strlen(dip_key_name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", dip_key_name);
-        }
-        else if (strlen(l4_key_name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", l4_key_name);
-        }
-        else if (ipv6_nh > 0xff)
-        {
-            printk(KERN_INFO "Invalid ipv6_nh [%d]\n", ipv6_nh);
-        }
-        else if (ipv6_hoplimit > 0xff)
-        {
-            printk(KERN_INFO "Invalid ipv6_hoplimit [%d]\n", ipv6_hoplimit);
-        }
-        else
-        {
-            if (    ((pgen_entry = find_tpm_ipv6_gen_key_entry_by_name(gen_key_name)) == 0)
-                  && (strcmp(gen_key_name, ipv6_gen_key_empty_name) != 0))
-            {
-		printk(KERN_INFO "ipv6 gen key entry [%s] not found\n", gen_key_name);
-		return;
-            }
-            if (    ((pdip_entry = find_tpm_ipv6_dip_key_entry_by_name(dip_key_name)) == 0)
-                  && (strcmp(dip_key_name, ipv6_dip_key_empty_name) != 0))
-            {
-		printk(KERN_INFO "ipv6 dip key entry [%s] not found\n", dip_key_name);
-		return;
-            }
-            if (    ((pl4_entry = find_tpm_ipv6_l4_ports_key_entry_by_name(l4_key_name)) == 0)
-                  && (strcmp(l4_key_name, ipv6_l4_key_empty_name) != 0))
-            {
-		printk(KERN_INFO "ipv6 l4 key entry [%s] not found\n", l4_key_name);
-		return;
-            }
-
-            if ((pctc_entry = find_tpm_ipv6_key_entry_by_name(ctc_key_name)) == 0)
-            {
-                pctc_entry = find_free_tpm_ipv6_key_entry();
-            }
-            if (pctc_entry == 0)
-            {
-                printk(KERN_INFO "IPV6 key DB full\n");
-                return;
-            }
-            else
-            {
-                strcpy(pctc_entry->name, ctc_key_name);
-                for (indx = 0; indx < 16; indx++)
-                {
-                    if (pdip_entry) {
-		        pctc_entry->ipv6_acl.ipv6_dst_ip_add[indx]	= (uint8_t)pdip_entry->ipv6_addr.ipv6_ip_add[indx];
-		        pctc_entry->ipv6_acl.ipv6_dst_ip_add_mask[indx] = (uint8_t)pdip_entry->ipv6_addr.ipv6_ip_add_mask[indx];
-		    }
-                    if (pgen_entry) {
-			pctc_entry->ipv6_acl.ipv6_src_ip_add[indx]      = (uint8_t)pgen_entry->ipv6gen_acl.ipv6_src_ip_add[indx];
-			pctc_entry->ipv6_acl.ipv6_src_ip_add_mask[indx] = (uint8_t)pgen_entry->ipv6gen_acl.ipv6_src_ip_add_mask[indx];
-		    }
-                }
-		if (pgen_entry) {
-		    pctc_entry->ipv6_acl.ipv6_dscp_mask = (uint8_t)pgen_entry->ipv6gen_acl.ipv6_dscp_mask;
-		    pctc_entry->ipv6_acl.ipv6_dscp = (uint8_t)pgen_entry->ipv6gen_acl.ipv6_dscp;
-		}
-		if (pl4_entry) {
-		    pctc_entry->ipv6_acl.l4_src_port = (uint16_t)pl4_entry->l4_ports.l4_src_port;
-		    pctc_entry->ipv6_acl.l4_dst_port = (uint16_t)pl4_entry->l4_ports.l4_dst_port;
-		}
-		pctc_entry->ipv6_acl.ipv6_next_header= (uint8_t)ipv6_nh;
-		pctc_entry->ipv6_acl.ipv6_hoplimit = (uint8_t)ipv6_hoplimit;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_dip_key_dip_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies source ip address part of IPV6 dip key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_dip_key_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6dip_name=0, ipv6dip_ip, ipv6dip_ipmask, ipv6dip_max
-    } ipv6dip_rule_parm_indx_t;
-    char     temp_ip[60];
-    char     temp_ip_mask[60];
-    uint32_t ip[16];
-    uint32_t ip_mask[16];
-    char     name[100];
-    int      parsedargs;
-    int      numparms;
-    int      indx;
-    tpmcfg_ipv6_dip_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6dip_max)
-    {
-        parm_error_completion(numparms, ipv6dip_max, buf, sfs_help_ipv6_dip_key_cfg);
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%s %s %s", name, temp_ip, temp_ip_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (parse_ipv6_address(temp_ip, ip) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ip [%s]\n", temp_ip);
-        }
-        else if (parse_ipv6_address(temp_ip_mask, ip_mask) == GT_FALSE)
-        {
-            printk(KERN_INFO "Invalid ip mask [%s]\n", temp_ip_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv6_dip_key_entry_by_name(name)) == 0)
-            {
-                pentry = find_free_tpm_ipv6_dip_key_entry();
-            }
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV6 dip key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                for (indx = 0; indx < 16; indx++)
-                {
-                    pentry->ipv6_addr.ipv6_ip_add[indx]      = (uint8_t)ip[indx];
-                    pentry->ipv6_addr.ipv6_ip_add_mask[indx] = (uint8_t)ip_mask[indx];
-                }
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_l4_key_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies source ip address part of IPV6 dip key rule
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_l4_key_rule(const char *buf, size_t len)
-{
-    typedef enum {
-        ipv6l4key_name=0, ipv6l4key_srcport, ipv6l4key_dstport, ipv6l4key_max
-    } ipv6l4_key_parm_indx_t;
-    uint32_t src_port, dst_port;
-    char     name[100];
-    int      parsedargs;
-    int      numparms;
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6l4key_max)
-        parm_error_completion(numparms, ipv6l4key_max, buf, sfs_help_ipv6_l4_key_cfg);
-    else {
-        parsedargs = sscanf(buf, "%s %d %d", name, &src_port, &dst_port);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        else {
-            if ((pentry = find_tpm_ipv6_l4_ports_key_entry_by_name(name)) == 0)
-                pentry = find_free_tpm_ipv6_l4_ports_key_entry();
-
-            if (pentry == 0)
-                printk(KERN_INFO "IPV6 L4 ports key DB full\n");
-            else {
-                strcpy(pentry->name, name);
-				pentry->l4_ports.l4_dst_port = dst_port;
-				pentry->l4_ports.l4_src_port = src_port;
-            }
-        }
-    }
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_ipv6_gen_key_dscp_rule
-*
-* DESCRIPTION:
-*           This function adds/modifies DSCP part of IPV6 ACL rule
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_ipv6_gen_key_dscp_rule  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ipv6gendscp_name=0, ipv6gendscp_dscp, ipv6gendscp_dscpmask, ipv6gendscp_max
-    } ipv6gendscp_rule_parm_indx_t;
-    unsigned int             temp_dscp;
-    unsigned int             temp_dscp_mask;
-    char                     name[100];
-    int                      parsedargs;
-    int                      numparms;
-    tpmcfg_ipv6_gen_key_entry_t *pentry;
-
-    numparms = count_parameters(buf);
-    if (numparms != ipv6gendscp_max)
-    {
-        parm_error_completion(numparms, ipv6gendscp_max, buf, sfs_help_ipv6_gen_key_cfg);
-    }
-    else
-    {
-        parsedargs = sscanf(buf, "%s %d 0x%x", name, &temp_dscp, &temp_dscp_mask);
-
-        if (strlen(name) > DB_TPMCFG_MAX_NAME)
-        {
-            printk(KERN_INFO "Name too long [%s]\n", name);
-        }
-        else if (temp_dscp > 63)
-        {
-            printk(KERN_INFO "Invalid dscp [%d]\n", temp_dscp);
-        }
-        else if (temp_dscp_mask > 0xFF)
-        {
-            printk(KERN_INFO "Invalid dscp mask [0x%x]\n", temp_dscp_mask);
-        }
-        else
-        {
-            if ((pentry = find_tpm_ipv6_gen_key_entry_by_name(name)) == 0)
-            {
-                pentry = find_free_tpm_ipv6_gen_key_entry();
-            }
-            if (pentry == 0)
-            {
-                printk(KERN_INFO "IPV6 gen key DB full\n");
-            }
-            else
-            {
-                strcpy(pentry->name, name);
-                pentry->ipv6gen_acl.ipv6_dscp      = (uint8_t)temp_dscp;
-                pentry->ipv6gen_acl.ipv6_dscp_mask = (uint8_t)temp_dscp_mask;
-            }
-        }
-    }
-}
-
-typedef struct
-{
-    char    *table_name;
-    GT_BOOL (*clear_rule)(char *buf);
-    void    (*display_table)(void);
-} table_rule_operation_t;
-
-static table_rule_operation_t table_rule_operation_ara[] =
-{
-    {"frwd",         del_tpm_pkt_frwd_entry_by_name,          show_tpm_pkt_frwd_db},
-    {"vlan",         del_tpm_vlan_entry_by_name,              show_tpm_vlan_db},
-    {"mod",          del_tpm_mod_entry_by_name,               show_tpm_mod_db},
-    {"l2key",        del_tpm_l2_key_entry_by_name,            show_tpm_l2_key_db},
-    {"l3key",        del_tpm_l3_key_entry_by_name,            show_tpm_l3_key_db},
-    {"ipv4key",      del_tpm_ipv4_key_entry_by_name,          show_tpm_ipv4_key_db},
-    // The following "duplicate" entries for alternate access to mdelete entry functionality
-    {"l2",           del_tpm_l2_key_entry_by_name,            show_tpm_l2_key_db},
-    {"l3",           del_tpm_l3_key_entry_by_name,            show_tpm_l3_key_db},
-    {"ipv4",         del_tpm_ipv4_key_entry_by_name,          show_tpm_ipv4_key_db},
-    {"ipv6_dip",     del_tpm_ipv6_dip_key_entry_by_name,      show_tpm_ipv6_dip_key_db},
-    {"ipv6_gen",     del_tpm_ipv6_gen_key_entry_by_name,      show_tpm_ipv6_gen_key_db},
-    {"ipv6_l4",      del_tpm_ipv6_l4_ports_key_entry_by_name, show_tpm_ipv6_l4_ports_key_db},
-    {"ipv6_ctc",     del_tpm_ipv6_key_entry_by_name,          show_tpm_ipv6_key_db},
-};
-static int num_table_operations = sizeof(table_rule_operation_ara)/sizeof(table_rule_operation_ara[0]);
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_key_rule_delete
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_key_rule_delete  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ruleclearpi_table=0, ruleclearpi_rule, ruleclearpi_max
-    } ruleclear_rule_parm_indx_t;
-    char                     table[100];
-    char                     rulename[100];
-    int                      parsedargs;
-    int                      numparms;
-    int                      indx;
-    GT_BOOL                  found = GT_FALSE;
-    GT_BOOL                  rc;
-    table_rule_operation_t   *ptableop;
-
-    numparms = count_parameters(buf);
-    if (numparms != ruleclearpi_max)
-    {
-        parm_error_completion(numparms, ruleclearpi_max, buf, sfs_help_key_rule_delete);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s %s", table, rulename);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. table[%s] rulename[%s]\n",
-//               len, parsedargs, table, rulename);
-
-        for (indx = 0; indx < num_table_operations; indx++)
-        {
-            ptableop = &table_rule_operation_ara[indx];
-            if (!strcmp(table, ptableop->table_name))
-            {
-                found = GT_TRUE;
-                rc = (ptableop->clear_rule)(rulename);
-                break;
-            }
-        }
-
-        if (found == GT_FALSE)
-        {
-            printk("%s: Table %s not found\n", __FUNCTION__, table);
-        }
-        else if (rc == GT_FALSE)
-        {
-            printk("%s: Table %s does not have entry named %s\n", __FUNCTION__, table, rulename);
-        }
-//        else
-//        {
-//            (ptableop->display_table)();
-//        }
-    }
-}
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_rule_table_display
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_rule_table_display  (const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ruledisppi_table=0, ruledisppi_table_max
-    } ruledisp_rule_parm_indx_t;
-    char                     table[100];
-    int                      parsedargs;
-    int                      numparms;
-    int                      indx;
-    GT_BOOL                  found = GT_FALSE;
-    table_rule_operation_t   *ptableop;
-
-    numparms = count_parameters(buf);
-
-    if (numparms == 1 && buf[0] == '?')
-    {
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-        int  helpbuf_len;
-
-        helpbuf_len = sfs_help_rule_table_display(helpbuf);
-        print_help_buffer(helpbuf, helpbuf_len);
-#else
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", ruledisppi_table_max, numparms);
-#endif
-    }
-    else if (numparms != 1)
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", ruledisppi_table_max, numparms);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s", table);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. table[%s]\n", len, parsedargs, table);
-
-        for (indx = 0; indx < num_table_operations; indx++)
-        {
-            ptableop = &table_rule_operation_ara[indx];
-            if (!strcmp(table, ptableop->table_name))
-            {
-                found = GT_TRUE;
-                (ptableop->display_table)();
-                break;
-            }
-        }
-
-        if (found == GT_FALSE)
-        {
-            printk("%s: Table %s not found\n", __FUNCTION__, table);
-        }
-    }
-}
-
-/*******************************************************************************
-* delete_rule_from_table
-*
-* DESCRIPTION:
-*           This function deletes entry in rule table
-*
-*
-*******************************************************************************/
-static void delete_rule_from_table(char *table, const char *buf, size_t len)
-{
-    typedef enum
-    {
-        ruledelpi_rule=0, ruledelpi_max
-    } ruledel_rule_parm_indx_t;
-    char                     rulename[100];
-    int                      parsedargs;
-    int                      numparms;
-    int                      indx;
-    GT_BOOL                  found = GT_FALSE;
-    GT_BOOL                  rc;
-    table_rule_operation_t   *ptableop;
-
-    numparms = count_parameters(buf);
-    if (numparms == 1 && buf[0] == '?')
-    {
-        printk(KERN_INFO "echo [rule_name] > delete_entry_%s_rule_table\n", table);
-    }
-    else if (numparms != 1)
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", ruledelpi_max, numparms);
-    }
-    else
-    {
-        // Get parameters
-        parsedargs = sscanf(buf, "%s", rulename);
-//        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s]\n", len, parsedargs, rulename);
-
-        for (indx = 0; indx < num_table_operations; indx++)
-        {
-            ptableop = &table_rule_operation_ara[indx];
-            if (!strcmp(table, ptableop->table_name))
-            {
-                found = GT_TRUE;
-                rc = (ptableop->clear_rule)(rulename);
-                break;
-            }
-        }
-
-        if (found == GT_FALSE)
-        {
-            printk("%s: Table %s not found\n", __FUNCTION__, table);
-        }
-        else if (rc == GT_FALSE)
-        {
-            printk("%s: Table %s does not have entry named %s\n", __FUNCTION__, table, rulename);
-        }
-    }
-
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_l2_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_l2_rule_table  (const char *buf, size_t len)
-{
-    delete_rule_from_table("l2key", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_l3_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_l3_rule_table  (const char *buf, size_t len)
-{
-    delete_rule_from_table("l3key", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_ipv4_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_ipv4_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("ipv4key", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_ipv6_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_ipv6_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("ipv6key", buf, len);
-}
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_ipv6_dip_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_ipv6_dip_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("ipv6_dip", buf, len);
-}
-
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_ipv6_gen_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_ipv6_gen_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("ipv6_gen", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_ipv6_gen_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_ipv6_l4_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("ipv6_l4", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_frwd_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_frwd_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("frwd", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_vlan_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_vlan_rule_table(const char *buf, size_t len)
-{
-    delete_rule_from_table("vlan", buf, len);
-}
-
-/*******************************************************************************
-* sfs_tpm_cfg_set_delete_entry_mod_rule_table
-*
-* DESCRIPTION:
-*           This function removes named rule from specified table
-*
-* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
-*
-*******************************************************************************/
-void sfs_tpm_cfg_set_delete_entry_mod_rule_table (const char *buf, size_t len)
-{
-    delete_rule_from_table("mod", buf, len);
-}
-
-
-
-
-#if 0
-// The show_tpm_XYZ_key_db() routines must be made more flexible - take char *buf parameter
-// and return number of characters to print.
-// If called from the functions below, the buf argument is passed
-// If called from a store function, the argument wll be zero and the routine uses a local buffer
-// Messy, this way or that - since the file may be too big for sysfs store invocation
-/*******************************************************************************
-**
-**  sfs_show_l2_rule_table
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_show_l2_rule_table   (char *buf)
-{
-    show_tpm_l2_key_db();
-}
-
-/*******************************************************************************
-**
-**  sfs_show_l3_rule_table - see header of sfs_show_l2_rule_table
-**
-*******************************************************************************/
-int sfs_show_l3_rule_table   (char *buf)
-{
-    show_tpm_l3_key_db();
-}
-
-/*******************************************************************************
-**
-**  sfs_show_ipv4_rule_table - see header of sfs_show_l2_rule_table
-**
-*******************************************************************************/
-int sfs_show_ipv4_rule_table (char *buf)
-{
-    show_tpm_ipv4_key_db();
-}
-
-/*******************************************************************************
-**
-**  sfs_show_ipv6_rule_table - see header of sfs_tpm_cfg_index
-**
-*******************************************************************************/
-int sfs_show_ipv6_rule_table (char *buf)
-{
-    show_tpm_ipv6_key_db();
-}
-
-/*******************************************************************************
-**
-**  sfs_show_frwd_rule_table - see header of sfs_show_l2_rule_table
-**
-*******************************************************************************/
-int sfs_show_frwd_rule_table (char *buf)
-{
-    show_tpm_pkt_frwd_db()
-}
-
-/*******************************************************************************
-**
-**  sfs_show_vlan_rule_table - see header of sfs_show_l2_rule_table
-**
-*******************************************************************************/
-int sfs_show_vlan_rule_table (char *buf)
-{
-    show_tpm_vlan_db();
-}
-
-/*******************************************************************************
-**
-**  sfs_show_mod_rule_table - see header of sfs_show_l2_rule_table
-**
-*******************************************************************************/
-int sfs_show_mod_rule_table  (char *buf)
-{
-    show_tpm_mod_db()
-}
-
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.h
deleted file mode 100644
index fce17e9..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_rule_db.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_usr_tpmsysfs_if.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Zeev
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_TPM_SYSFS_RULE_DB_H_
-#define _TPM_USR_TPM_SYSFS_RULE_DB_H_
-
-extern void sfs_tpm_cfg_set_frwd_rule                   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_vlan_rule                   (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_proto_rule              (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_mh_rule                 (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_vlan_rule               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_dscp_rule               (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_ipv4_addr_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_ipv4_port_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_ipv6_addr_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_ipv6_port_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_mac_addr_rule           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_mod_pppoe_rule              (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_pkt_mod_eng_entry_add       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_pkt_mod_eng_entry_show      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_pkt_mod_eng_entry_del       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_pkt_mod_eng_purge           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l2_key_ethertype_rule       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l2_key_gemport_rule         (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l2_key_mac_addr_rule        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l2_key_pppoe_rule           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l2_key_vlan_rule            (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l3_key_ethertype_rule       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_l3_key_pppoe_rule           (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv4_key_addr_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv4_key_port_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv4_key_protocol_rule      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv4_key_dscp_rule          (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_gen_key_sip_rule       (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_ctc_cm_key_rule        (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_ipv6_gen_key_dscp_rule      (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_key_rule_delete             (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_rule_table_display          (const char *buf, size_t len);
-
-extern void sfs_tpm_cfg_set_delete_entry_l2_rule_table  (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_l3_rule_table  (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_ipv4_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_ipv6_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_ipv6_dip_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_ipv6_gen_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_ipv6_l4_rule_table (const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_frwd_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_vlan_rule_table(const char *buf, size_t len);
-extern void sfs_tpm_cfg_set_delete_entry_mod_rule_table (const char *buf, size_t len);
-
-
-
-#if 0
-extern int sfs_show_l2_rule_table                     (char *buf);
-extern int sfs_show_l3_rule_table                     (char *buf);
-extern int sfs_show_ipv4_rule_table                   (char *buf);
-extern int sfs_show_ipv6_rule_table                   (char *buf);
-extern int sfs_show_frwd_rule_table                   (char *buf);
-extern int sfs_show_vlan_rule_table                   (char *buf);
-extern int sfs_show_mod_rule_table                    (char *buf);
-#endif
-
-#endif  /* _sfs_tpm_cfg_setTPM_USR_TPM_SYSFS_RULE_DB_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.c
deleted file mode 100644
index 47fd903..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.c
+++ /dev/null
@@ -1,1315 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_help.h"
-#include "tpm_sysfs_rule_db.h"
-#include "tpm_sysfs_hwcall.h"
-#include "tpm_sysfs_utils.h"
-#include "tpm_sysfs_setup.h"
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
-/* ========================================================================== */
-
-typedef struct
-{
-    char *sysfs_name;
-    void (*sysfs_func)( const char *buf, size_t len);
-} store_sysfs_name_func_t;
-
-static store_sysfs_name_func_t store_sysfs_name_func_ara[] =
-{
-    {"frwd_rule_set",                      sfs_tpm_cfg_set_frwd_rule},
-    {"vlan_rule_set",                      sfs_tpm_cfg_set_vlan_rule},
-    {"mod_mh_rule_set",                    sfs_tpm_cfg_set_mod_mh_rule},
-    {"mod_vlan_rule_set",                  sfs_tpm_cfg_set_mod_vlan_rule},
-    {"mod_ipv4_addr_rule_set",             sfs_tpm_cfg_set_mod_ipv4_addr_rule},
-    {"mod_ipv4_port_rule_set",             sfs_tpm_cfg_set_mod_ipv4_port_rule},
-    {"mod_ipv6_addr_rule_set",             sfs_tpm_cfg_set_mod_ipv6_addr_rule},
-    {"mod_ipv6_port_rule_set",             sfs_tpm_cfg_set_mod_ipv6_port_rule},
-    {"mod_mac_addr_rule_set",              sfs_tpm_cfg_set_mod_mac_addr_rule},
-    {"mod_pppoe_rule_set",                 sfs_tpm_cfg_set_mod_pppoe_rule},
-    {"l2_key_ethertype_rule_set",          sfs_tpm_cfg_set_l2_key_ethertype_rule},
-    {"l2_key_gemport_rule_set",            sfs_tpm_cfg_set_l2_key_gemport_rule},
-    {"l2_key_mac_addr_rule_set",           sfs_tpm_cfg_set_l2_key_mac_addr_rule},
-    {"l2_key_pppoe_rule_set",              sfs_tpm_cfg_set_l2_key_pppoe_rule},
-    {"l2_key_vlan_rule_set",               sfs_tpm_cfg_set_l2_key_vlan_rule},
-    {"l3_key_ethertype_rule_set",          sfs_tpm_cfg_set_l3_key_ethertype_rule},
-    {"l3_key_pppoe_rule_set",              sfs_tpm_cfg_set_l3_key_pppoe_rule},
-    {"ipv4_key_addr_rule_set",             sfs_tpm_cfg_set_ipv4_key_addr_rule},
-    {"ipv4_key_port_rule_set",             sfs_tpm_cfg_set_ipv4_key_port_rule},
-    {"ipv4_key_proto_rule_set",            sfs_tpm_cfg_set_ipv4_key_protocol_rule},
-    {"ipv4_key_dscp_rule_set",             sfs_tpm_cfg_set_ipv4_key_dscp_rule},
-    {"ipv6_ctc_cm_key_rule_set",           sfs_tpm_cfg_set_ipv6_ctc_cm_key_rule},
-    {"ipv6_gen_key_sip_rule_set",          sfs_tpm_cfg_set_ipv6_gen_key_sip_rule},
-    {"ipv6_gen_key_dscp_rule_set",         sfs_tpm_cfg_set_ipv6_gen_key_dscp_rule},
-    {"key_rule_delete",                    sfs_tpm_cfg_set_key_rule_delete},
-    {"rule_table_display",                 sfs_tpm_cfg_set_rule_table_display},
-    {"l2_rule_add",                        sfs_tpm_cfg_set_l2_rule_add},
-    {"l3_rule_add",                        sfs_tpm_cfg_set_l3_rule_add},
-    {"ipv4_rule_add",                      sfs_tpm_cfg_set_ipv4_rule_add},
-    {"ipv6_gen_rule_add",                  sfs_tpm_cfg_set_ipv6_gen_rule_add},
-    {"mc_ipv4_stream_add",                 sfs_tpm_cfg_set_mc_ipv4_stream_add},
-    {"mc_ipv4_stream_set_queue_add",	   sfs_tpm_cfg_set_mc_ipv4_stream_set_queue_add},
-    {"mc_ipv4_stream_update",              sfs_tpm_cfg_set_mc_ipv4_stream_update},
-    {"mc_ipv6_stream_add",		   sfs_tpm_cfg_set_mc_ipv6_stream_add},
-    {"mc_ipv6_stream_set_queue_add",	   sfs_tpm_cfg_set_mc_ipv6_stream_set_queue_add},
-    {"mc_ipv6_stream_update",		   sfs_tpm_cfg_set_mc_ipv6_stream_update},
-    {"igmp_port_forward_mode_cfg",         sfs_tpm_cfg_set_igmp_port_forward_mode_cfg},
-    {"mc_vid_key_reset",                   sfs_tpm_cfg_set_mc_vid_key_reset},
-    {"mc_vid_key_set",                     sfs_tpm_cfg_set_mc_vid_key_set},
-    {"mc_vid_cfg_set",                     sfs_tpm_cfg_set_mc_vid_cfg_set},
-    {"igmp_cpu_queue_cfg",                 sfs_tpm_cfg_set_igmp_cpu_queue_cfg},
-    {"igmp_proxy_sa_mac",                  sfs_tpm_cfg_set_igmp_proxy_sa_mac},
-    {"no_rule_add_l2",                     sfs_tpm_cfg_set_no_rule_add_l2},
-    {"no_rule_add_l3",                     sfs_tpm_cfg_set_no_rule_add_l3},
-    {"no_rule_add_ipv4",                   sfs_tpm_cfg_set_no_rule_add_ipv4},
-	{"no_mc_stream_add_ipv6",			   sfs_tpm_cfg_set_no_mc_stream_add_ipv6},
-    {"no_mc_stream_add_ipv4",              sfs_tpm_cfg_set_no_mc_stream_add_ipv4},
-    {"oam_channel",                        sfs_tpm_cfg_set_oam_channel},
-    {"omci_channel",                       sfs_tpm_cfg_set_omci_channel},
-    {"no_oam_channel",                     sfs_tpm_cfg_set_no_oam_channel},
-    {"no_omci_channel",                    sfs_tpm_cfg_set_no_omci_channel},
-    {"tpm_setup",                          sfs_tpm_cfg_setup},
-    {"mib_reset",                          sfs_tpm_cfg_set_mib_reset},
-    {"set_active_wan",                     sfs_tpm_cfg_set_active_wan},
-    {"hot_swap_profile",		   sfs_tpm_cfg_hot_swap_profile},
-    {"set_port_hwf_admin",		   sfs_tpm_cfg_set_port_hwf_admin},
-    {"erase_section",                      sfs_tpm_cfg_set_erase_section},
-    {"add_cpu_lpbk",                       sfs_tpm_cfg_add_cpu_lpbk},
-    {"del_cpu_lpbk",                       sfs_tpm_cfg_del_cpu_lpbk},
-    {"dump_cpu_lpbk",                      sfs_tpm_cfg_dump_cpu_lpbk},
-    {"get_lu_entry",                       sfs_tpm_cfg_get_lu_entry},
-    {"set_count_mask",                     sfs_tpm_cfg_set_count_mask},
-    {"get_hit_count",                      sfs_tpm_cfg_get_hit_count},
-    {"get_pnc_all_hit_cntrs",              sfs_tpm_cfg_get_pnc_all_hit_counters},
-    {"set_lu_thresh",                      sfs_tpm_cfg_set_lu_thresh},
-    {"reset_age_group",                    sfs_tpm_cfg_reset_age_group},
-    {"rate_limit_queue_set",               sfs_tpm_cfg_set_rate_limit_queue_set},
-    {"scheduling_mode_queue_set",          sfs_tpm_cfg_set_scheduling_mode_queue_set},
-    {"rate_limit_if_set",                  sfs_tpm_cfg_set_rate_limit_if_set},
-    {"pkt_mod_eng_entry_add",              sfs_tpm_cfg_set_pkt_mod_eng_entry_add},
-    {"pkt_mod_eng_entry_show",             sfs_tpm_cfg_set_pkt_mod_eng_entry_show},
-    {"pkt_mod_eng_entry_del",              sfs_tpm_cfg_set_pkt_mod_eng_entry_del},
-    {"pkt_mod_eng_purge",                  sfs_tpm_cfg_set_pkt_mod_eng_purge},
-    {"delete_entry_l2_rule_table",         sfs_tpm_cfg_set_delete_entry_l2_rule_table},
-    {"delete_entry_l3_rule_table",         sfs_tpm_cfg_set_delete_entry_l3_rule_table},
-    {"delete_entry_ipv4_rule_table",       sfs_tpm_cfg_set_delete_entry_ipv4_rule_table},
-    {"delete_entry_ipv6_gen_rule_table",   sfs_tpm_cfg_set_delete_entry_ipv6_gen_rule_table},
-    {"delete_entry_ipv6_dip_rule_table",   sfs_tpm_cfg_set_delete_entry_ipv6_dip_rule_table},
-    {"delete_entry_ipv6_l4_rule_table",    sfs_tpm_cfg_set_delete_entry_ipv6_l4_rule_table},
-    {"delete_entry_frwd_rule_table",       sfs_tpm_cfg_set_delete_entry_frwd_rule_table},
-    {"delete_entry_vlan_rule_table",       sfs_tpm_cfg_set_delete_entry_vlan_rule_table},
-    {"delete_entry_mod_rule_table",        sfs_tpm_cfg_set_delete_entry_mod_rule_table},
-
-    /* jinghuaxxxxxx */
-    {"ipv6_dip_key_rule_set",              sfs_tpm_cfg_set_ipv6_dip_key_rule},
-    {"ipv6_l4_key_rule_set",               sfs_tpm_cfg_set_ipv6_l4_key_rule},
-    {"ipv6_dip_rule_add",                  sfs_tpm_cfg_set_ipv6_dip_acl_rule_add},
-    {"no_rule_add_ipv6_dip_acl",           sfs_tpm_cfg_set_no_rule_add_ipv6_dip},
-    {"ipv6_l4_ports_acl_rule_add",         sfs_tpm_cfg_set_ipv6_l4_ports_acl_rule_add},
-    {"no_rule_add_ipv6_l4_ports_acl",      sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_acl},
-
-    {"ipv6_gen_5t_rule_add",               sfs_tpm_cfg_set_ipv6_gen_5t_rule_add},
-    {"no_rule_add_ipv6_gen_5t",            sfs_tpm_cfg_set_no_rule_add_ipv6_gen_5t},
-    {"ipv6_dip_5t_rule_add",               sfs_tpm_cfg_set_ipv6_dip_5t_rule_add},
-    {"no_rule_add_ipv6_dip_5t",            sfs_tpm_cfg_set_no_rule_add_ipv6_dip_5t},
-    {"ipv6_l4_ports_5t_rule_add",          sfs_tpm_cfg_set_ipv6_l4_ports_5t_rule_add},
-    {"no_rule_add_ipv6_l4_ports_5t",       sfs_tpm_cfg_set_no_rule_add_ipv6_l4_ports_5t},
-    {"add_ds_load_balance",	           sfs_tpm_cfg_set_ds_load_balance_rule_add},
-    {"del_ds_load_balance",		   sfs_tpm_cfg_set_no_rule_add_ds_load_balance},
-
-    // zeev
-    {"ipv6_nh_acl_rule_add",               sfs_tpm_cfg_set_ipv6_nh_acl_rule_add},
-    {"no_rule_add_ipv6_nh_acl",            sfs_tpm_cfg_set_no_rule_add_ipv6_nh_acl},
-    {"no_rule_add_ipv6_gen_acl",           sfs_tpm_cfg_set_no_rule_add_ipv6_gen_acl},
-
-    {"ctc_cm_acl_rule_add",                sfs_tpm_cfg_set_ctc_cm_rule_add},
-    {"ctc_cm_ipv6_acl_rule_add",	   sfs_tpm_cfg_set_ctc_cm_ipv6_rule_add},
-    {"ctc_cm_set_ipv6_parse_win",	   sfs_tpm_cfg_ctc_cm_set_ipv6_parse_win},
-    {"no_rule_add_ctc_cm_acl",             sfs_tpm_cfg_set_no_rule_add_ctc_cm_acl},
-
-    {"enable_mtu",                         sfs_tpm_cfg_set_mtu_enable},
-    {"set_mtu",                            sfs_tpm_cfg_set_mtu},
-    {"set_pppoe_mtu",                      sfs_tpm_cfg_set_pppoe_mtu},
-    {"send_genquery_to_uni",               sfs_tpm_cfg_send_genquery_to_uni},
-    {"flush_atu",                          sfs_tpm_cfg_flush_atu},
-    {"flush_vtu",                          sfs_tpm_cfg_flush_vtu},
-
-    {"tpm_self_check",                     sfs_tpm_rule_self_check},
-    {"mac_learn_rule_add",                 sfs_tpm_cfg_set_mac_learn_rule_add},
-    {"no_rule_add_mac_learn",              sfs_tpm_cfg_set_no_rule_add_mac_learn},
-    {"mac_learn_default_rule_act_set",     sfs_tpm_cfg_set_mac_learn_default_rule_action},
-    {"gmac0_ingr_rate_limit_set",          sfs_tpm_cfg_set_gmac0_ingr_rate_limit},
-
-    /* KostaP */
-    {"fc_config_set",                      sfs_tpm_cfg_set_fc},
-    {"fc_us_period_set",                   sfs_tpm_cfg_set_fc_period},
-#ifdef TPM_FC_DEBUG
-    {"fc_oneshot_set",                     sfs_tpm_cfg_set_fc_oneshot},
-#endif
-    {"fc_enable",                  	    sfs_tpm_cfg_fc_enable}
-};
-static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
-
-static ssize_t tpm_cfg_store(struct device *dev,
-                             struct device_attribute *attr,
-                             const char *buf, size_t len)
-{
-    const char*             name = attr->attr.name;
-/*    unsigned long           flags  = 0;*/
-    store_sysfs_name_func_t *pnamefunc;
-    int                     indx;
-    GT_BOOL                 found = GT_FALSE;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-//     raw_local_irq_save(flags);
-
-    for (indx = 0; indx < num_store_name_funcs; indx++){
-        pnamefunc = &store_sysfs_name_func_ara[indx];
-        if (!strcmp(name, pnamefunc->sysfs_name)) {
-            found = GT_TRUE;
-            (pnamefunc->sysfs_func)(buf, len);
-            break;
-        }
-    }
-
-    if (found == GT_FALSE){
-        printk("%s: operation <%s> not found\n", __FUNCTION__, attr->attr.name);
-    }
-
-//     raw_local_irq_restore(flags);
-
-    return(len);
-}
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM CFG SYS FS ROUTINE SHOW SWITCHER                           */
-/* ========================================================================== */
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-
-typedef struct
-{
-    char *sysfs_name;
-    int (*sysfs_func)( char *buf);
-    } show_sysfs_name_func_t;
-
-static show_sysfs_name_func_t show_sysfs_name_func_ara[] =
-{
-    {"help_tpm_cfg_index",           sfs_tpm_cfg_index},
-    {"help_frwd_rule_cfg",           sfs_help_frwd_rule_cfg},
-    {"help_vlan_rule_cfg",           sfs_help_vlan_rule_cfg},
-    {"help_mod_rule_cfg",            sfs_help_mod_rule_cfg},
-    {"help_l2_key_cfg",              sfs_help_l2_key_cfg},
-    {"help_l3_key_cfg",              sfs_help_l3_key_cfg},
-    {"help_ipv4_key_cfg",            sfs_help_ipv4_key_cfg},
-    {"help_rule_table_display",      sfs_help_rule_table_display},
-    {"help_l2_rule_add",             sfs_help_l2_rule_add},
-    {"help_l3_rule_add",             sfs_help_l3_rule_add},
-    {"help_ipv4_rule_add",           sfs_help_ipv4_rule_add},
-    {"help_ipv6_dip_rule_add",       sys_help_ipv6_dip_acl_rule_add},
-    {"help_ipv6_gen_rule_add",       sfs_help_ipv6_gen_rule_add},
-    {"help_mc_ipvx_stream_add",      sfs_help_mc_ipvx_stream_add},
-    {"help_igmp_cfg",                sfs_help_igmp_cfg},
-    {"help_no_rule_add",             sfs_help_no_rule_add},
-    {"help_key_rule_delete",         sfs_help_key_rule_delete},
-    {"help_no_mc_stream_add",        sfs_help_no_mc_stream_add},
-    {"help_oam_omci_channel",        sfs_help_oam_omci_channel},
-    {"help_no_oam_omci_channel",     sfs_help_no_oam_omci_channel},
-    {"help_tpm_setup",               sfs_help_setup},
-    {"help_mib_reset",               sfs_help_mib_reset},
-    {"help_set_active_wan",          sfs_help_set_active_wan},
-    {"help_hot_swap_profile",	     sfs_help_hot_swap_profile},
-    {"help_set_port_hwf_admin",	     sfs_help_set_port_hwf_admin},
-    {"help_cfg_cpu_lpbk",            sfs_help_cfg_cpu_lpbk},
-    {"help_ds_load_balance_rule",    sfs_help_ds_load_balance_rule},
-    {"help_cfg_age_count",           sfs_help_cfg_age_count},
-    {"help_rate_limit",              sfs_help_rate_limit},
-    {"help_pkt_mod_add",             sfs_help_pkt_mod_add},
-    {"help_pkt_mod_get_del_purge",   sfs_help_pkt_mod_get_del_purge},
-    {"help_ipv6_nh_rule_add",        sfs_help_ipv6_nh_rule_add},
-    {"help_ipv6_l4_ports_rule_add",  sfs_help_ipv6_l4_ports_rule_add},
-    {"help_ipv6_l4_key_cfg",         sfs_help_ipv6_l4_key_cfg},
-    {"help_ipv6_dip_key_cfg",        sfs_help_ipv6_dip_key_cfg},
-    {"help_ipv6_gen_key_cfg",	     sfs_help_ipv6_gen_key_cfg},
-    {"help_ipv6_ctc_cm_key_cfg",     sfs_help_ipv6_ctc_cm_key_cfg},
-    {"help_mtu_cfg",                 sfs_help_mtu_cfg},
-    {"help_delete_entry_rule_table", sfs_help_delete_entry_rule_table},
-    {"help_erase_section",           sfs_help_erase_section},
-    {"help_send_genquery_to_uni",    sfs_help_send_genquery_to_uni},
-    {"help_tpm_self_check",          sfs_help_tpm_self_check},
-    {"help_ipv6_gen_5t_rule_add",      sfs_help_ipv6_gen_5t_rule_add},
-    {"help_ipv6_dip_5t_rule_add",      sfs_help_ipv6_dip_5t_rule_add},
-    {"help_ipv6_l4_ports_5t_rule_add", sfs_help_ipv6_l4_ports_5t_rule_add},
-
-    {"help_ctc_cm_rule_add",           sfs_help_ctc_cm_rule_add},
-    {"help_ctc_cm_set_ipv6_parse_win", sfs_help_ctc_cm_set_ipv6_parse_win},
-
-    {"help_flush_atu",               sfs_help_flush_atu},
-    {"help_flush_vtu",               sfs_help_flush_vtu},
-    {"help_mac_learn_rule_add",      sfs_help_mac_learn_rule_add},
-    {"help_mac_learn_def_act_set",   sfs_help_mac_learn_def_act_set},
-
-};
-static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
-
-
-static ssize_t tpm_cfg_show(struct device *dev,
-                            struct device_attribute *attr,
-                            char *buf)
-{
-    const char*            name = attr->attr.name;
-    show_sysfs_name_func_t *pnamefunc;
-    int                    indx;
-    GT_BOOL                found = GT_FALSE;
-    int                    buflen = 0;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    for (indx = 0; indx < num_show_name_funcs; indx++){
-        pnamefunc = &show_sysfs_name_func_ara[indx];
-        if (!strcmp(name, pnamefunc->sysfs_name)) {
-            found = GT_TRUE;
-            buflen = (pnamefunc->sysfs_func)(buf);
-            break;
-        }
-    }
-    if (found == GT_FALSE){
-        printk("%s: operation <%s> not found\n", __FUNCTION__, attr->attr.name);
-    }
-    return buflen;
-}
-#else
-static ssize_t tpm_cfg_show(struct device *dev,
-                            struct device_attribute *attr,
-                            char *buf)
-{
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __FUNCTION__);
-	return 0;
-}
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-/******************************************************************************/
-/* ========================================================================== */
-/*                            Cfg SW Attributes                               */
-/* ========================================================================== */
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-// help
-static DEVICE_ATTR(help_tpm_cfg_index,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_frwd_rule_cfg,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_vlan_rule_cfg,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mod_rule_cfg,                               S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_l2_key_cfg,                                 S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_l3_key_cfg,                                 S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv4_key_cfg,                               S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_gen_key_cfg,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_dip_key_cfg,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_ctc_cm_key_cfg,                        S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_l4_key_cfg,                            S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_rule_table_display,                         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(help_l2_rule_add,                                S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mac_learn_rule_add,                         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mac_learn_def_act_set,                      S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_l3_rule_add,                                S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv4_rule_add,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_dip_rule_add,                          S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_gen_rule_add,                          S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_nh_rule_add,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_l4_ports_rule_add,                     S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_gen_5t_rule_add,                       S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_dip_5t_rule_add,                       S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ipv6_l4_ports_5t_rule_add,                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ctc_cm_rule_add,                            S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ctc_cm_set_ipv6_parse_win,                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mc_ipvx_stream_add,                         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_igmp_cfg,                                   S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_no_rule_add,                                S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_key_rule_delete,                            S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_no_mc_stream_add,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_oam_omci_channel,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_no_oam_omci_channel,                        S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_tpm_setup,                                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mib_reset,                                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_set_active_wan,                             S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_hot_swap_profile,                           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_set_port_hwf_admin,                         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_cfg_cpu_lpbk,                               S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_ds_load_balance_rule,                       S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_cfg_age_count,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_rate_limit,                                 S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_pkt_mod_add,                                S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_pkt_mod_get_del_purge,                      S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_mtu_cfg,                                    S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_delete_entry_rule_table,                    S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_erase_section,                              S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_send_genquery_to_uni,                       S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_tpm_self_check,                             S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_flush_atu,                                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(help_flush_vtu,                                  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-// rule set
-static DEVICE_ATTR(frwd_rule_set,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(vlan_rule_set,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_mh_rule_set,                                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_vlan_rule_set,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_ipv4_addr_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_ipv4_port_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_ipv6_addr_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_ipv6_port_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_pppoe_rule_set,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mod_mac_addr_rule_set,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(l2_key_ethertype_rule_set,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l2_key_gemport_rule_set,                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l2_key_mac_addr_rule_set,                        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l2_key_pppoe_rule_set,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l2_key_vlan_rule_set,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(l3_key_ethertype_rule_set,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l3_key_pppoe_rule_set,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(ipv4_key_proto_rule_set,                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv4_key_dscp_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv4_key_addr_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv4_key_port_rule_set,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-
-static DEVICE_ATTR(ipv6_gen_key_sip_rule_set,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_ctc_cm_key_rule_set,                        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_gen_key_dscp_rule_set,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_dip_key_rule_set,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_l4_key_rule_set,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(key_rule_delete,                                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(rule_table_display,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_l2_rule_table,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_l3_rule_table,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_ipv4_rule_table,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_ipv6_gen_rule_table,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_ipv6_dip_rule_table,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_ipv6_l4_rule_table,                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_frwd_rule_table,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_vlan_rule_table,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(delete_entry_mod_rule_table,                     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-// Rule add
-static DEVICE_ATTR(l2_rule_add,                                     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mac_learn_rule_add,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mac_learn_default_rule_act_set,                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(l3_rule_add,                                     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv4_rule_add,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_gen_rule_add,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_dip_rule_add,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv4_stream_add,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv4_stream_set_queue_add,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv4_stream_update,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv6_stream_add,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv6_stream_set_queue_add,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_ipv6_stream_update,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_nh_acl_rule_add,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_l4_ports_acl_rule_add,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(ipv6_gen_5t_rule_add,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_dip_5t_rule_add,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ipv6_l4_ports_5t_rule_add,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(ctc_cm_acl_rule_add,                             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ctc_cm_ipv6_acl_rule_add,                        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(ctc_cm_set_ipv6_parse_win,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(igmp_port_forward_mode_cfg,                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(igmp_cpu_queue_cfg,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(igmp_proxy_sa_mac,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_vid_key_reset,                                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_vid_key_set,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mc_vid_cfg_set,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(no_rule_add_l2,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_l3,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv4,                                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_mc_stream_add_ipv4,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_mc_stream_add_ipv6,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_nh_acl,                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_l4_ports_acl,                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_dip_acl,                        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_gen_acl,                        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(no_rule_add_ipv6_gen_5t,                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_dip_5t,                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_ipv6_l4_ports_5t,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(no_rule_add_ctc_cm_acl,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_rule_add_mac_learn,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-
-static DEVICE_ATTR(oam_channel,                                     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(omci_channel,                                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_oam_channel,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(no_omci_channel,                                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(tpm_setup,                                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(mib_reset,                                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_active_wan,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(hot_swap_profile,                                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_port_hwf_admin,                              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(add_cpu_lpbk,                                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(del_cpu_lpbk,                                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(dump_cpu_lpbk,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(get_lu_entry,                                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_count_mask,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(get_hit_count,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(get_pnc_all_hit_cntrs,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_lu_thresh,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(reset_age_group,                                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(rate_limit_queue_set,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(gmac0_ingr_rate_limit_set,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(scheduling_mode_queue_set,                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(rate_limit_if_set,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(pkt_mod_eng_entry_add,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(pkt_mod_eng_entry_show,                          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(pkt_mod_eng_entry_del,                           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(pkt_mod_eng_purge,                               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(enable_mtu,                                      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_mtu,                                         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(set_pppoe_mtu,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(send_genquery_to_uni,                            S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(erase_section,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(tpm_self_check,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(flush_atu,                                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(flush_vtu,                                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(add_ds_load_balance,                             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(del_ds_load_balance,                             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-
-static DEVICE_ATTR(fc_config_set,                                   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(fc_us_period_set,                                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-static DEVICE_ATTR(fc_enable,                                       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-#ifdef TPM_FC_DEBUG
-static DEVICE_ATTR(fc_oneshot_set,                                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
-#endif
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_mngt SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_mngt_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-
-    &dev_attr_help_oam_omci_channel.attr,
-    &dev_attr_help_no_oam_omci_channel.attr,
-#endif
-    &dev_attr_oam_channel.attr,
-    &dev_attr_omci_channel.attr,
-    &dev_attr_no_oam_channel.attr,
-    &dev_attr_no_omci_channel.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_mngt_sw_group =
-{
-    .name = "cfg_mngt",
-    .attrs = tpm_cfg_mngt_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_mod SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_mod_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_mod_rule_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_pkt_mod_add.attr,
-    &dev_attr_help_pkt_mod_get_del_purge.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_mod_mh_rule_set.attr,
-    &dev_attr_mod_vlan_rule_set.attr,
-    &dev_attr_mod_ipv4_addr_rule_set.attr,
-    &dev_attr_mod_ipv4_port_rule_set.attr,
-    &dev_attr_mod_ipv6_addr_rule_set.attr,
-    &dev_attr_mod_ipv6_port_rule_set.attr,
-    &dev_attr_mod_pppoe_rule_set.attr,
-    &dev_attr_mod_mac_addr_rule_set.attr,
-    &dev_attr_pkt_mod_eng_entry_add.attr,
-    &dev_attr_pkt_mod_eng_entry_show.attr,
-    &dev_attr_pkt_mod_eng_entry_del.attr,
-    &dev_attr_pkt_mod_eng_purge.attr,
-
-    &dev_attr_delete_entry_mod_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_mod_sw_group =
-{
-    .name = "cfg_mod",
-    .attrs = tpm_cfg_mod_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_l2 SYS FS STORE ROUTINE SWITCHER                       */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_l2_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_l2_key_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_l2_rule_add.attr,
-    &dev_attr_help_no_rule_add.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-    &dev_attr_help_mac_learn_rule_add.attr,
-    &dev_attr_help_mac_learn_def_act_set.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_l2_key_ethertype_rule_set.attr,
-    &dev_attr_l2_key_gemport_rule_set.attr,
-    &dev_attr_l2_key_mac_addr_rule_set.attr,
-    &dev_attr_l2_key_pppoe_rule_set.attr,
-    &dev_attr_l2_key_vlan_rule_set.attr,
-
-    &dev_attr_delete_entry_l2_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    &dev_attr_l2_rule_add.attr,
-    &dev_attr_no_rule_add_l2.attr,
-
-    &dev_attr_mac_learn_rule_add.attr,
-    &dev_attr_mac_learn_default_rule_act_set.attr,
-    &dev_attr_no_rule_add_mac_learn.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_l2_sw_group =
-{
-    .name = "cfg_l2",
-    .attrs = tpm_cfg_l2_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_l3 SYS FS STORE ROUTINE SWITCHER                       */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_l3_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_l3_key_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_l3_rule_add.attr,
-    &dev_attr_help_no_rule_add.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_l3_key_ethertype_rule_set.attr,
-    &dev_attr_l3_key_pppoe_rule_set.attr,
-
-    &dev_attr_delete_entry_l3_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    &dev_attr_l3_rule_add.attr,
-    &dev_attr_no_rule_add_l3.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_l3_sw_group =
-{
-    .name = "cfg_l3",
-    .attrs = tpm_cfg_l3_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_ipv4 SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_ipv4_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_ipv4_key_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_ipv4_rule_add.attr,
-    &dev_attr_help_no_rule_add.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_ipv4_key_proto_rule_set.attr,
-    &dev_attr_ipv4_key_dscp_rule_set.attr,
-    &dev_attr_ipv4_key_addr_rule_set.attr,
-    &dev_attr_ipv4_key_port_rule_set.attr,
-
-    &dev_attr_delete_entry_ipv4_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    &dev_attr_ipv4_rule_add.attr,
-    &dev_attr_no_rule_add_ipv4.attr,
-
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_ipv4_sw_group =
-{
-    .name = "cfg_ipv4",
-    .attrs = tpm_cfg_ipv4_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_ipv6 SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_ipv6_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_ipv6_gen_key_cfg.attr,
-    &dev_attr_help_ipv6_ctc_cm_key_cfg.attr,
-    &dev_attr_help_ipv6_dip_key_cfg.attr,
-    &dev_attr_help_ipv6_l4_key_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_ipv6_gen_rule_add.attr,
-    &dev_attr_help_ipv6_dip_rule_add.attr,
-    &dev_attr_help_ipv6_nh_rule_add.attr,
-    &dev_attr_help_ipv6_l4_ports_rule_add.attr,
-    &dev_attr_help_ipv6_gen_5t_rule_add.attr,
-    &dev_attr_help_ipv6_dip_5t_rule_add.attr,
-    &dev_attr_help_ipv6_l4_ports_5t_rule_add.attr,
-    &dev_attr_help_no_rule_add.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_ipv6_dip_key_rule_set.attr,
-    &dev_attr_ipv6_l4_key_rule_set.attr,
-    &dev_attr_ipv6_ctc_cm_key_rule_set.attr,
-    &dev_attr_ipv6_gen_key_sip_rule_set.attr,
-    &dev_attr_ipv6_gen_key_dscp_rule_set.attr,
-    &dev_attr_delete_entry_ipv6_gen_rule_table.attr,
-    &dev_attr_delete_entry_ipv6_dip_rule_table.attr,
-    &dev_attr_delete_entry_ipv6_l4_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    &dev_attr_ipv6_gen_rule_add.attr,
-    &dev_attr_ipv6_dip_rule_add.attr,
-    &dev_attr_ipv6_nh_acl_rule_add.attr,
-    &dev_attr_ipv6_l4_ports_acl_rule_add.attr,
-    &dev_attr_no_rule_add_ipv6_nh_acl.attr,
-    &dev_attr_no_rule_add_ipv6_l4_ports_acl.attr,
-    &dev_attr_no_rule_add_ipv6_gen_acl.attr,
-    &dev_attr_no_rule_add_ipv6_dip_acl.attr,
-
-    &dev_attr_ipv6_gen_5t_rule_add.attr,
-    &dev_attr_ipv6_dip_5t_rule_add.attr,
-    &dev_attr_ipv6_l4_ports_5t_rule_add.attr,
-    &dev_attr_no_rule_add_ipv6_gen_5t.attr,
-    &dev_attr_no_rule_add_ipv6_dip_5t.attr,
-    &dev_attr_no_rule_add_ipv6_l4_ports_5t.attr,
-
-    NULL
-};
-
-static struct attribute *tpm_cfg_mtu_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_mtu_cfg.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-    &dev_attr_enable_mtu.attr,
-    &dev_attr_set_mtu.attr,
-    &dev_attr_set_pppoe_mtu.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_ipv6_sw_group =
-{
-    .name = "cfg_ipv6",
-    .attrs = tpm_cfg_ipv6_sw_attrs
-};
-
-static struct attribute_group tpm_cfg_mtu_sw_group =
-{
-    .name = "cfg_mtu",
-    .attrs = tpm_cfg_mtu_sw_attrs
-};
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_frwd SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_frwd_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_frwd_rule_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_frwd_rule_set.attr,
-
-    &dev_attr_delete_entry_frwd_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_frwd_sw_group =
-{
-    .name = "cfg_frwd",
-    .attrs = tpm_cfg_frwd_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_vlan SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_vlan_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_vlan_rule_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-    &dev_attr_help_delete_entry_rule_table.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_vlan_rule_set.attr,
-
-    &dev_attr_delete_entry_vlan_rule_table.attr,
-    &dev_attr_rule_table_display.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_vlan_sw_group =
-{
-    .name = "cfg_vlan",
-    .attrs = tpm_cfg_vlan_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_traffic SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_traffic_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_rate_limit.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_rate_limit_queue_set.attr,
-    &dev_attr_scheduling_mode_queue_set.attr,
-    &dev_attr_rate_limit_if_set.attr,
-    &dev_attr_gmac0_ingr_rate_limit_set.attr,
-    &dev_attr_fc_config_set.attr,
-    &dev_attr_fc_us_period_set.attr,
-    &dev_attr_fc_enable.attr,
-#ifdef TPM_FC_DEBUG
-    &dev_attr_fc_oneshot_set.attr,
-#endif
-
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_traffic_sw_group =
-{
-    .name = "cfg_traffic",
-    .attrs = tpm_cfg_traffic_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_mc SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_mc_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_mc_ipvx_stream_add.attr,
-    &dev_attr_help_igmp_cfg.attr,
-    &dev_attr_help_no_mc_stream_add.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_mc_ipv4_stream_add.attr,
-    &dev_attr_mc_ipv4_stream_set_queue_add.attr,
-    &dev_attr_igmp_port_forward_mode_cfg.attr,
-    &dev_attr_igmp_cpu_queue_cfg.attr,
-    &dev_attr_igmp_proxy_sa_mac.attr,
-    &dev_attr_no_mc_stream_add_ipv4.attr,
-    &dev_attr_mc_ipv4_stream_update.attr,
-
-    &dev_attr_mc_vid_key_reset.attr,
-    &dev_attr_mc_vid_key_set.attr,
-    &dev_attr_mc_vid_cfg_set.attr,
-
-    &dev_attr_mc_ipv6_stream_add.attr,
-    &dev_attr_mc_ipv6_stream_set_queue_add.attr,
-    &dev_attr_no_mc_stream_add_ipv6.attr,
-    &dev_attr_mc_ipv6_stream_update.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_mc_sw_group =
-{
-    .name = "cfg_mc",
-    .attrs = tpm_cfg_mc_sw_attrs
-};
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_misc SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_misc_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_tpm_setup.attr,
-    &dev_attr_help_mib_reset.attr,
-    &dev_attr_help_set_active_wan.attr,
-    &dev_attr_help_hot_swap_profile.attr,
-    &dev_attr_help_set_port_hwf_admin.attr,
-    &dev_attr_help_erase_section.attr,
-    &dev_attr_help_send_genquery_to_uni.attr,
-    &dev_attr_help_tpm_self_check.attr,
-    &dev_attr_help_flush_atu.attr,
-    &dev_attr_help_flush_vtu.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_tpm_setup.attr,
-
-    &dev_attr_send_genquery_to_uni.attr,
-
-    &dev_attr_mib_reset.attr,
-    &dev_attr_set_active_wan.attr,
-    &dev_attr_hot_swap_profile.attr,
-    &dev_attr_set_port_hwf_admin.attr,
-    &dev_attr_erase_section.attr,
-    &dev_attr_tpm_self_check.attr,
-    &dev_attr_flush_vtu.attr,
-    &dev_attr_flush_atu.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_misc_sw_group =
-{
-    .name = "cfg_misc",
-    .attrs = tpm_cfg_misc_sw_attrs
-};
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_cpu_lpbk SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_cpu_lpbk_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_cfg_cpu_lpbk.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-    &dev_attr_add_cpu_lpbk.attr,
-    &dev_attr_del_cpu_lpbk.attr,
-    &dev_attr_dump_cpu_lpbk.attr,
-    NULL
-};
-
-static struct attribute_group tpm_cfg_cpu_lpbk_sw_group =
-{
-    .name = "cfg_cpu_lpbk",
-    .attrs = tpm_cfg_cpu_lpbk_sw_attrs
-};
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_ds_load_balance SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_ds_load_balance_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_ds_load_balance_rule.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-    &dev_attr_add_ds_load_balance.attr,
-    &dev_attr_del_ds_load_balance.attr,
-    NULL
-};
-
-static struct attribute_group tpm_cfg_ds_load_balance_sw_group =
-{
-    .name = "cfg_ds_load_balance",
-    .attrs = tpm_cfg_ds_load_balance_sw_attrs
-};
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_age_count SYS FS STORE ROUTINE SWITCHER                */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_age_count_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_cfg_age_count.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-    &dev_attr_get_lu_entry.attr,
-    &dev_attr_set_count_mask.attr,
-    &dev_attr_get_hit_count.attr,
-    &dev_attr_get_pnc_all_hit_cntrs.attr,
-    &dev_attr_set_lu_thresh.attr,
-    &dev_attr_reset_age_group.attr,
-    NULL
-};
-
-static struct attribute_group tpm_cfg_age_count_sw_group =
-{
-    .name = "cfg_age_count",
-    .attrs = tpm_cfg_age_count_sw_attrs
-};
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg_ctc_cm SYS FS STORE ROUTINE SWITCHER                     */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_ctc_cm_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_ctc_cm_rule_add.attr,
-    &dev_attr_help_ctc_cm_set_ipv6_parse_win.attr,
-    &dev_attr_help_no_rule_add.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-    &dev_attr_ctc_cm_acl_rule_add.attr,
-    &dev_attr_ctc_cm_ipv6_acl_rule_add.attr,
-    &dev_attr_ctc_cm_set_ipv6_parse_win.attr,
-    &dev_attr_no_rule_add_ctc_cm_acl.attr,
-    NULL
-};
-
-static struct attribute_group tpm_cfg_ctc_cm_sw_group =
-{
-    .name = "cfg_ctc_cm",
-    .attrs = tpm_cfg_ctc_cm_sw_attrs
-};
-
-//#if 0
-
-// !!@@##$$%%
-//
-// KEEP THIS - WE MAY GO BACK TO FLAT cfg FOLDER
-//
-// !!@@##$$%%
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg SYS FS STORE ROUTINE SWITCHER                          */
-/* ========================================================================== */
-
-static struct attribute *tpm_cfg_flat_sw_attrs[] =
-{
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_tpm_cfg_index.attr,
-    &dev_attr_help_frwd_rule_cfg.attr,
-    &dev_attr_help_vlan_rule_cfg.attr,
-    &dev_attr_help_mod_rule_cfg.attr,
-    &dev_attr_help_l2_key_cfg.attr,
-    &dev_attr_help_l3_key_cfg.attr,
-    &dev_attr_help_ipv4_key_cfg.attr,
-    &dev_attr_help_ipv6_l4_key_cfg.attr,
-    &dev_attr_help_ipv6_ctc_cm_key_cfg.attr,
-    &dev_attr_help_ipv6_dip_key_cfg.attr,
-    &dev_attr_help_ipv6_gen_key_cfg.attr,
-    &dev_attr_help_rule_table_display.attr,
-
-    &dev_attr_help_l2_rule_add.attr,
-    &dev_attr_help_l3_rule_add.attr,
-    &dev_attr_help_ipv4_rule_add.attr,
-    &dev_attr_help_ipv6_gen_rule_add.attr,
-    &dev_attr_help_ipv6_dip_rule_add.attr,
-    &dev_attr_help_ipv6_nh_rule_add.attr,
-    &dev_attr_help_ipv6_l4_ports_rule_add.attr,
-    &dev_attr_help_mc_ipvx_stream_add.attr,
-    &dev_attr_help_igmp_cfg.attr,
-    &dev_attr_help_no_rule_add.attr,
-    &dev_attr_help_key_rule_delete.attr,
-    &dev_attr_help_no_mc_stream_add.attr,
-    &dev_attr_help_oam_omci_channel.attr,
-    &dev_attr_help_no_oam_omci_channel.attr,
-    &dev_attr_help_tpm_setup.attr,
-    &dev_attr_help_mib_reset.attr,
-    &dev_attr_help_set_active_wan.attr,
-    &dev_attr_help_hot_swap_profile.attr,
-    &dev_attr_help_set_port_hwf_admin.attr,
-    &dev_attr_help_ds_load_balance_rule.attr,
-    &dev_attr_help_cfg_cpu_lpbk.attr,
-    &dev_attr_help_rate_limit.attr,
-    &dev_attr_help_pkt_mod_add.attr,
-    &dev_attr_help_pkt_mod_get_del_purge.attr,
-
-    &dev_attr_help_ipv6_gen_5t_rule_add.attr,
-    &dev_attr_help_ipv6_dip_5t_rule_add.attr,
-    &dev_attr_help_ipv6_l4_ports_5t_rule_add.attr,
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-    &dev_attr_frwd_rule_set.attr,
-
-    &dev_attr_vlan_rule_set.attr,
-    &dev_attr_mod_vlan_rule_set.attr,
-    &dev_attr_mod_ipv4_addr_rule_set.attr,
-    &dev_attr_mod_ipv4_port_rule_set.attr,
-    &dev_attr_mod_ipv6_addr_rule_set.attr,
-    &dev_attr_mod_ipv6_port_rule_set.attr,
-    &dev_attr_mod_pppoe_rule_set.attr,
-    &dev_attr_mod_mac_addr_rule_set.attr,
-
-    &dev_attr_l2_key_ethertype_rule_set.attr,
-    &dev_attr_l2_key_gemport_rule_set.attr,
-    &dev_attr_l2_key_mac_addr_rule_set.attr,
-    &dev_attr_l2_key_pppoe_rule_set.attr,
-    &dev_attr_l2_key_vlan_rule_set.attr,
-
-    &dev_attr_l3_key_ethertype_rule_set.attr,
-    &dev_attr_l3_key_pppoe_rule_set.attr,
-
-    &dev_attr_ipv4_key_proto_rule_set.attr,
-    &dev_attr_ipv4_key_dscp_rule_set.attr,
-    &dev_attr_ipv4_key_addr_rule_set.attr,
-    &dev_attr_ipv4_key_port_rule_set.attr,
-
-    &dev_attr_ipv6_ctc_cm_key_rule_set.attr,
-    &dev_attr_ipv6_gen_key_sip_rule_set.attr,
-    &dev_attr_ipv6_gen_key_dscp_rule_set.attr,
-    &dev_attr_ipv6_dip_key_rule_set.attr,
-    &dev_attr_ipv6_l4_key_rule_set.attr,
-
-    &dev_attr_key_rule_delete.attr,
-    &dev_attr_rule_table_display.attr,
-
-    &dev_attr_l2_rule_add.attr,
-    &dev_attr_l3_rule_add.attr,
-    &dev_attr_ipv4_rule_add.attr,
-    &dev_attr_ipv6_gen_rule_add.attr,
-    &dev_attr_ipv6_dip_rule_add.attr,
-    &dev_attr_mc_ipv4_stream_add.attr,
-    &dev_attr_mc_ipv4_stream_set_queue_add.attr,
-    &dev_attr_mc_ipv4_stream_update.attr,
-    &dev_attr_mc_ipv6_stream_add.attr,
-    &dev_attr_mc_ipv6_stream_set_queue_add.attr,
-    &dev_attr_mc_ipv6_stream_update.attr,
-    &dev_attr_ipv6_nh_acl_rule_add.attr,
-    &dev_attr_ipv6_l4_ports_acl_rule_add.attr,
-
-    &dev_attr_ipv6_gen_5t_rule_add.attr,
-    &dev_attr_ipv6_dip_5t_rule_add.attr,
-    &dev_attr_ipv6_l4_ports_5t_rule_add.attr,
-
-    &dev_attr_igmp_port_forward_mode_cfg.attr,
-    &dev_attr_igmp_cpu_queue_cfg.attr,
-    &dev_attr_igmp_proxy_sa_mac.attr,
-
-    &dev_attr_no_rule_add_l2.attr,
-    &dev_attr_no_rule_add_l3.attr,
-    &dev_attr_no_rule_add_ipv4.attr,
-    &dev_attr_no_rule_add_ipv6_nh_acl.attr,
-    &dev_attr_no_rule_add_ipv6_l4_ports_acl.attr,
-    &dev_attr_no_rule_add_ipv6_gen_acl.attr,
-    &dev_attr_no_mc_stream_add_ipv6.attr,
-    &dev_attr_no_mc_stream_add_ipv4.attr,
-
-    &dev_attr_no_rule_add_ipv6_gen_5t.attr,
-    &dev_attr_no_rule_add_ipv6_dip_5t.attr,
-    &dev_attr_no_rule_add_ipv6_l4_ports_5t.attr,
-
-    &dev_attr_oam_channel.attr,
-    &dev_attr_omci_channel.attr,
-    &dev_attr_no_oam_channel.attr,
-    &dev_attr_no_omci_channel.attr,
-
-    &dev_attr_tpm_setup.attr,
-    &dev_attr_mib_reset.attr,
-    &dev_attr_set_active_wan.attr,
-    &dev_attr_hot_swap_profile.attr,
-    &dev_attr_set_port_hwf_admin.attr,
-
-    &dev_attr_rate_limit_queue_set.attr,
-    &dev_attr_scheduling_mode_queue_set.attr,
-    &dev_attr_rate_limit_if_set.attr,
-    &dev_attr_pkt_mod_eng_entry_add.attr,
-    &dev_attr_pkt_mod_eng_entry_show.attr,
-    &dev_attr_pkt_mod_eng_entry_del.attr,
-    &dev_attr_pkt_mod_eng_purge.attr,
-
-    NULL
-};
-
-static struct attribute_group tpm_cfg_flat_sw_group =
-{
-    .name = "cfg_flat",
-    .attrs = tpm_cfg_flat_sw_attrs
-};
-//#endif
-
-
-
-
-/******************************************************************************/
-/* ========================================================================== */
-/*             TPM cfg SETUP: incl. folder creation + FS population           */
-/* ========================================================================== */
-
-typedef struct
-{
-    char                   *folder_name;
-    struct attribute_group *pattrgroup;
-} attr_group_pair_t;
-
-static attr_group_pair_t attr_group_pair_ara[] =
-{
-    {"cfg_mngt",               &tpm_cfg_mngt_sw_group},
-    {"cfg_mod",                &tpm_cfg_mod_sw_group},
-    {"cfg_frwd",               &tpm_cfg_frwd_sw_group},
-    {"cfg_vlan",               &tpm_cfg_vlan_sw_group},
-    {"cfg_l2",                 &tpm_cfg_l2_sw_group},
-    {"cfg_l3",                 &tpm_cfg_l3_sw_group},
-    {"cfg_ipv4",               &tpm_cfg_ipv4_sw_group},
-    {"cfg_ipv6",               &tpm_cfg_ipv6_sw_group},
-    {"cfg_mc",                 &tpm_cfg_mc_sw_group},
-    {"cfg_traffic",            &tpm_cfg_traffic_sw_group},
-    {"cfg_misc",               &tpm_cfg_misc_sw_group},
-    {"cfg_cpu_lpbk",           &tpm_cfg_cpu_lpbk_sw_group},
-    {"cfg_ds_load_balance",    &tpm_cfg_ds_load_balance_sw_group},
-    {"cfg_age_count",          &tpm_cfg_age_count_sw_group},
-    {"cfg_flat",               &tpm_cfg_flat_sw_group},
-    {"cfg_mtu",                &tpm_cfg_mtu_sw_group},
-    {"cfg_ctc_cm",             &tpm_cfg_ctc_cm_sw_group},
-};
-static int num_attr_group_pairs = sizeof(attr_group_pair_ara)/sizeof(attr_group_pair_ara[0]);
-
-int tpm_sysfs_init(void)
-{
-    int           err;
-    struct device *pd;
-    int           indx;
-
-    tpm_sysfs_rule_db_init();
-
-    pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-    if (!pd) {
-        platform_device_register_simple("tpm", -1, NULL, 0);
-        pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
-    }
-
-    if (!pd) {
-        printk(KERN_ERR"%s: cannot find tpm device\n", __FUNCTION__);
-        pd = &platform_bus;
-    }
-
-    for (indx = 0; indx < num_attr_group_pairs; indx++)
-    {
-        attr_group_pair_t *ppair;
-
-        ppair = &attr_group_pair_ara[indx];
-
-        err = sysfs_create_group(&pd->kobj, ppair->pattrgroup);
-        if (err)
-        {
-            printk(KERN_INFO "sysfs_create_group failed for %s, err = %d\n", ppair->folder_name, err);
-            goto out;
-        }
-    }
-    printk(KERN_INFO "= SW Module SYS FS Init for tpm ended successfully =\n");
-
-out:
-    return err;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.h
deleted file mode 100644
index 96aabe8..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_setup.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_sysfs_setup.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Zeev
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_TPM_SYSFS_SETUP_H_
-#define _TPM_USR_TPM_SYSFS_SETUP_H_
-
-extern int tpm_sysfs_init(void);
-
-
-#endif  /* _TPM_USR_TPM_SYSFS_SETUP_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.c
deleted file mode 100644
index 7bb7384..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.c
+++ /dev/null
@@ -1,1867 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_utils.h"
-
-tpm_mc_vid_port_vid_set_t mc_vid_key;
-
-static char buf[4000];
-
-uint8_t g_gen_query_pkt[] =
-{
-	0x01, 0x00, 0x5E, 0x00, 0x00, 0x01,
-	0x54, 0xE6, 0xFC, 0x63, 0x36, 0x74,
-	0xda, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* reserve for Ethertype DSA tag */
-	0x81, 0x00, 0x00, 0x11,
-	0x08, 0x00, 0x46, 0xEE, 0x00, 0x20,
-	0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
-	0x82, 0x3F, 0xC0, 0xA8, 0x01, 0x01,
-	0xE0, 0x00, 0x00, 0x01, 0x94, 0x04,
-	0x00, 0x00, 0x11, 0x64, 0xEE, 0x9B,
-	0x00, 0x00, 0x00, 0x00, 0x9E, 0xA0,
-	0x01, 0x00, 0x5E, 0x00, 0x00, 0x01,
-	0x00, 0x00, 0x54, 0xE6, 0xFC, 0x63,
-	0x70, 0xF7, 0xDC, 0x59
-};
-
-/********************************************************************************/
-/*                          Miscellaneous                   */
-/********************************************************************************/
-
-/*******************************************************************************
-* print_help_buffer
-*
-* DESCRIPTION:
-*           This function prints help buffer
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void print_help_buffer(char *helpbuf, int len)
-{
-#if 1
-    int  indx;
-    char savech;
-
-    for (indx = 0; indx < len; indx += 1000)
-    {
-        if (indx + 1000 < len)
-        {
-            savech = helpbuf[indx + 1000];
-            helpbuf[indx + 1000] = 0;
-            printk(KERN_INFO "%s", &helpbuf[indx]);
-            helpbuf[indx + 1000] = savech;
-        }
-        else
-        {
-            printk(KERN_INFO "%s", &helpbuf[indx]);
-        }
-    }
-#else
-    printk(KERN_INFO "%s", helpbuf);
-#endif
-}
-
-/*******************************************************************************
-* parm_error_completion
-*
-* DESCRIPTION:
-*           This function prints out help message if buffer holds 1 parameter that
-*           starts '?'; else it prints out incorrect number of parameters message
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void parm_error_completion(int numparms, int reqdparms, const char *buffer, int (*help_text_routine)(char *))
-{
-    if (numparms == 1 && buffer[0] == '?' && help_text_routine != NULL)
-    {
-        int  helpbuf_len;
-	char *helpbuf = buf;
-
-        helpbuf_len = help_text_routine(helpbuf);
-        print_help_buffer(helpbuf, helpbuf_len);
-    }
-    else
-    {
-        printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", reqdparms, numparms);
-    }
-}
-
-/*******************************************************************************
-* count_parameters
-*
-* DESCRIPTION:
-*           This function counts the number of parameters provided
-* INPUTS:
-*       buf	- buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       int
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-int count_parameters (const char *buf)
-{
-    char                bufcopy[513];
-    char                **ap, *argv[20];
-    char                *inputstring = bufcopy;
-    int                 numparms = 0;
-
-    strcpy(bufcopy, buf);
-
-    for (ap = argv; ap < &argv[15] && (*ap = strsep(&inputstring, " \t")) != NULL;)
-    {
-        if (**ap != '\0')
-        {
-            ap++;
-            numparms++;
-        }
-    }
-    return numparms;
-}
-
-/*******************************************************************************
-* print_horizontal_line
-*
-* DESCRIPTION:
-*           This function prints a horizontal line using the "=" sign and places CRLF
-* INPUTS:
-*       char_count  - the horizontal line length
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       int
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void print_horizontal_line(unsigned int char_count)
-{
-    unsigned int cnt;
-    for (cnt = 0; cnt < char_count; cnt++)
-        printk("=");
-    printk("\n");
-}
-
-/********************************************************************************/
-/*                          String-int map lookups                              */
-/********************************************************************************/
-
-
-/*******************************************************************************
-* map_string_to_value
-*
-* DESCRIPTION:
-*           This function maps a string in a given map table to its value
-* INPUTS:
-*       buf	- buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       int
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-static GT_BOOL map_string_to_value (string_enum_pair_db_t *db, char *str, unsigned int *value)
-{
-    int                indx;
-    string_enum_pair_t *pentry;
-
-    for (indx = 0; indx < db->num_entries; indx++)
-    {
-        pentry = &db->string_enum_pair[indx];
-        if (strcmp(str, pentry->str) == 0)
-        {
-            *value = pentry->value;
-            return GT_TRUE;
-        }
-    }
-    return GT_FALSE;
-}
-
-/*******************************************************************************
-* map_value_to_string
-*
-* DESCRIPTION:
-*           This function maps a value to string in a given map table
-* INPUTS:
-*       value	- int enumaeration
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       char *. The matching string or "<unknown>"
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-static char *map_value_to_string (string_enum_pair_db_t *db, int value)
-{
-    int                indx;
-    string_enum_pair_t *pentry;
-    static char *unknown_str = "<unknown>";
-
-    for (indx = 0; indx < db->num_entries; indx++)
-    {
-        pentry = &db->string_enum_pair[indx];
-        if (value == pentry->value)
-        {
-            return pentry->str;
-        }
-    }
-    return unknown_str;
-}
-
-//--------------------------------------------------------------------------
-
-static string_enum_pair_t phase_string_enum_pair_ara[] =
-{
-    {STAGE_L2_PRIM,  "l2"   },
-    {STAGE_L3_TYPE,  "l3"   },
-    {STAGE_IPv4,     "ipv4" },
-    {STAGE_IPv6_GEN,   "ipv6_gen" },
-    {STAGE_IPv6_DIP,   "ipv6_dip" },
-    {STAGE_IPv6_NH,    "ipv6_nh"  },
-	{STAGE_IPV6_L4,    "ipv6_l4"  },
-    {STAGE_CTC_CM,    "ctc_cm"  },
-    {STAGE_DONE,     "done" },
-};
-
-static string_enum_pair_db_t  phase_string_enum_pair_db =
-{
-    phase_string_enum_pair_ara,
-    sizeof(phase_string_enum_pair_ara)/sizeof(phase_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_phase_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&phase_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-
-static string_enum_pair_t srcport_string_enum_pair_ara[] =
-{
-	{TPM_SRC_PORT_UNI_0,    "UNI_0"   },
-	{TPM_SRC_PORT_UNI_1,    "UNI_1"   },
-	{TPM_SRC_PORT_UNI_2,    "UNI_2"   },
-	{TPM_SRC_PORT_UNI_3,    "UNI_3"   },
-	{TPM_SRC_PORT_UNI_4,    "UNI_4"   },
-	{TPM_SRC_PORT_UNI_5,    "UNI_5"   },
-	{TPM_SRC_PORT_UNI_6,    "UNI_6"   },
-	{TPM_SRC_PORT_UNI_7,    "UNI_7"   },
-	{TPM_SRC_PORT_UNI_VIRT, "UNI_VIRT" },
-	{TPM_SRC_PORT_WAN,      "WAN"     },
-	{TPM_SRC_PORT_UNI_ANY,  "UNI_ANY" },
-};
-
-static string_enum_pair_db_t  srcport_string_enum_pair_db =
-{
-    srcport_string_enum_pair_ara,
-    sizeof(srcport_string_enum_pair_ara)/sizeof(srcport_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_srcport_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&srcport_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-
-static string_enum_pair_t srcdir_string_enum_pair_ara[] =
-{
-    {TPM_DIR_DS,            "DS" },
-    {TPM_DIR_US,            "US" },
-};
-
-static string_enum_pair_db_t srcdir_string_enum_pair_db =
-{
-    srcdir_string_enum_pair_ara,
-    sizeof(srcdir_string_enum_pair_ara)/sizeof(srcdir_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_srcdir_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&srcdir_string_enum_pair_db, str, value);
-}
-
-//-----------------------------------------------------------------------------
-
-static string_enum_pair_t bool_string_enum_pair_ara[] =
-{
-    {GT_FALSE,  "false"},
-    {GT_TRUE,   "true" },
-};
-
-static string_enum_pair_db_t  bool_string_enum_pair_db =
-{
-    bool_string_enum_pair_ara,
-    sizeof(bool_string_enum_pair_ara)/sizeof(bool_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_bool_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&bool_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-
-static string_enum_pair_t igmp_mode_string_enum_pair_ara[] =
-{
-    {TPM_IGMP_FRWD_MODE_DROP,       "drop" },
-    {TPM_IGMP_FRWD_MODE_FORWARD,    "frwd" },
-    {TPM_IGMP_FRWD_MODE_SNOOPING,   "snoop"},
-};
-
-static string_enum_pair_db_t  igmp_mode_string_enum_pair_db =
-{
-    igmp_mode_string_enum_pair_ara,
-    sizeof(igmp_mode_string_enum_pair_ara)/sizeof(igmp_mode_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_igmp_mode_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&igmp_mode_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-
-static string_enum_pair_t igmp_srcport_string_enum_pair_ara[] =
-{
-    {TPM_SRC_PORT_WAN,      "WAN"     },
-    {TPM_SRC_PORT_UNI_0,    "UNI_0"   },
-    {TPM_SRC_PORT_UNI_1,    "UNI_1"   },
-    {TPM_SRC_PORT_UNI_2,    "UNI_2"   },
-    {TPM_SRC_PORT_UNI_3,    "UNI_3"   },
-};
-
-static string_enum_pair_db_t  igmp_srcport_string_enum_pair_db =
-{
-    igmp_srcport_string_enum_pair_ara,
-    sizeof(igmp_srcport_string_enum_pair_ara)/sizeof(igmp_srcport_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_igmp_srcport_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&igmp_srcport_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-
-static string_enum_pair_t lx_ipvy_string_enum_pair_ara[] =
-{
-    {TPM_SRC_PORT_WAN,      "l2"     },
-    {TPM_SRC_PORT_UNI_0,    "l3"     },
-    {TPM_SRC_PORT_UNI_1,    "ipv4"   },
-    {TPM_SRC_PORT_UNI_2,    "ipv6"   },
-};
-
-static string_enum_pair_db_t  lx_ipvy_string_enum_pair_db =
-{
-    lx_ipvy_string_enum_pair_ara,
-    sizeof(lx_ipvy_string_enum_pair_ara)/sizeof(lx_ipvy_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_lx_ipvy_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&lx_ipvy_string_enum_pair_db, str, value);
-}
-
-//---------------------------------------------------------------------------
-static string_enum_pair_t direction_string_enum_pair_ara[] =
-{
-    {TPM_DOWNSTREAM,      "ds"  },
-    {TPM_UPSTREAM,        "us"  },
-};
-
-static string_enum_pair_db_t  direction_string_enum_pair_db =
-{
-    direction_string_enum_pair_ara,
-    sizeof(direction_string_enum_pair_ara)/sizeof(direction_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_direction_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&direction_string_enum_pair_db, str, value);
-}
-
-//-----------------------------------------------------------------------------
-static string_enum_pair_t scheduling_mode_string_enum_pair_ara[] =
-{
-    {TPM_PP_SCHED_STRICT,      "strict"  },
-    {TPM_PP_SCHED_WRR,         "wrr"     },
-};
-
-static string_enum_pair_db_t  scheduling_mode_string_enum_pair_db =
-{
-    scheduling_mode_string_enum_pair_ara,
-    sizeof(scheduling_mode_string_enum_pair_ara)/sizeof(scheduling_mode_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_scheduling_mode_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&scheduling_mode_string_enum_pair_db, str, value);
-}
-
-//-----------------------------------------------------------------------------
-static string_enum_pair_t sched_entity_string_enum_pair_ara[] =
-{
-    {TPM_TRG_PORT_WAN,       "WAN"      },
-    {TPM_TRG_TCONT_0,        "TCONT_0"  },
-    {TPM_TRG_TCONT_1,        "TCONT_1"  },
-    {TPM_TRG_TCONT_2,        "TCONT_2"  },
-    {TPM_TRG_TCONT_3,        "TCONT_3"  },
-    {TPM_TRG_TCONT_4,        "TCONT_4"  },
-    {TPM_TRG_TCONT_5,        "TCONT_5"  },
-    {TPM_TRG_TCONT_6,        "TCONT_6"  },
-    {TPM_TRG_TCONT_7,        "TCONT_7"  },
-    {TPM_TRG_PORT_UNI_ANY,   "UNI_ANY"  },
-};
-
-static string_enum_pair_db_t  sched_entity_string_enum_pair_db =
-{
-    sched_entity_string_enum_pair_ara,
-    sizeof(sched_entity_string_enum_pair_ara)/sizeof(sched_entity_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_sched_entity_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&sched_entity_string_enum_pair_db, str, value);
-}
-
-//-----------------------------------------------------------------------------
-static string_enum_pair_t vlan_op_string_enum_pair_ara[] =
-{
-    {0,    "none"                },
-    {1,    "ext_tag_mod"         },
-    {2,    "ext_tag_del"         },
-    {3,    "ext_tag_ins"         },
-    {4,    "ext_tag_mod_ins"     },
-    {5,    "ins_2tag"            },
-    {6,    "mod_2tag"            },
-    {7,    "swap_tags"           },
-    {8,    "del_2tags"           },
-    {9,    "int_tag_mod"         },
-    {10,   "ext_tag_del_int_mod" },
-	{11,   "split_mod_pbit"      },
-};
-
-static string_enum_pair_db_t  vlan_op_string_enum_pair_db =
-{
-    vlan_op_string_enum_pair_ara,
-    sizeof(vlan_op_string_enum_pair_ara)/sizeof(vlan_op_string_enum_pair_ara[0])
-};
-
-GT_BOOL get_vlan_op_value(char *str, unsigned int *value)
-{
-    return map_string_to_value(&vlan_op_string_enum_pair_db, str, value);
-}
-
-char *get_vlan_op_str(int value)
-{
-    return map_value_to_string(&vlan_op_string_enum_pair_db, value);
-}
-
-//-----------------------------------------------------------------------------
-
-static string_enum_pair_t tpm_err_string_enum_pair_ara[] =
-{
-    {TPM_RC_OK,                         "TPM_RC_OK"},
-    {ERR_GENERAL,                       "ERR_GENERAL"},
-    {ERR_OWNER_INVALID,                 "ERR_OWNER_INVALID"},
-    {ERR_SRC_PORT_INVALID,              "ERR_SRC_PORT_INVALID"},
-    {ERR_RULE_NUM_INVALID,              "ERR_RULE_NUM_INVALID"},
-    {ERR_RULE_IDX_INVALID,              "ERR_RULE_IDX_INVALID"},
-    {ERR_PARSE_MAP_INVALID,             "ERR_PARSE_MAP_INVALID"},
-    {ERR_VLAN_OP_INVALID,               "ERR_VLAN_OP_INVALID"},
-    {ERR_L2_KEY_INVALID,                "ERR_L2_KEY_INVALID"},
-    {ERR_FRWD_INVALID,                  "ERR_FRWD_INVALID"},
-    {ERR_MOD_INVALID,                   "ERR_MOD_INVALID"},
-    {ERR_ACTION_INVALID,                "ERR_ACTION_INVALID"},
-    {ERR_NEXT_PHASE_INVALID,            "ERR_NEXT_PHASE_INVALID"},
-    {ERR_RULE_KEY_MISMATCH,             "ERR_RULE_KEY_MISMATCH"},
-    {ERR_IPV4_NO_CONT_L4,               "ERR_IPV4_NO_CONT_L4"},
-    {ERR_IPV6_ADD_FAIL,                 "ERR_IPV6_ADD_FAIL"},
-    {ERR_MC_STREAM_INVALID,             "ERR_MC_STREAM_INVALID"},
-    {ERR_MC_STREAM_EXISTS ,             "ERR_MC_STREAM_EXISTS "},
-    {ERR_MC_DST_PORT_INVALID,           "ERR_MC_DST_PORT_INVALID"},
-    {ERR_MC_DST_QUEUE_INVALID,		"ERR_MC_DST_QUEUE_INVALID"},
-    {ERR_IPV4_MC_DST_IP_INVALID,        "ERR_IPV4_MC_DST_IP_INVALID"},
-    {ERR_IPV6_MC_DST_IP_INVALID,        "ERR_IPV6_MC_DST_IP_INVALID"},
-    {ERR_OMCI_TCONT_INVALID,            "ERR_OMCI_TCONT_INVALID"},
-    {ERR_MNGT_TX_Q_INVALID,             "ERR_MNGT_TX_Q_INVALID"},
-    {ERR_MNGT_CREATE_DUPLICATE_CHANNEL, "ERR_MNGT_CREATE_DUPLICATE_CHANNEL"},
-    {ERR_MNGT_DEL_CHANNEL_INVALID,      "ERR_MNGT_DEL_CHANNEL_INVALID"},
-    {ERR_OAM_LLID_INVALID,              "ERR_OAM_LLID_INVALID"},
-    {ERR_CFG_GETNEXT_INDEX_INVALID,     "ERR_CFG_GETNEXT_INDEX_INVALID"},
-    {ERR_CFG_GETNEXT_DIRECTION_INVALID, "ERR_CFG_GETNEXT_DIRECTION_INVALID"},
-    {ERR_CFG_GET_CHANNEL_INVALID,       "ERR_CFG_GET_CHANNEL_INVALID"},
-    {ERR_SW_MAC_INVALID,                "ERR_SW_MAC_INVALID"},
-    {ERR_SW_MAC_STATIC_NOT_FOUND,       "ERR_SW_MAC_STATIC_NOT_FOUND"},
-    {ERR_SW_MAC_PER_PORT_INVALID,       "ERR_SW_MAC_PER_PORT_INVALID"},
-    {ERR_SW_NUM_OF_MAC_PER_PORT_INVALID,"ERR_SW_NUM_OF_MAC_PER_PORT_INVALID"},
-    {ERR_SW_VID_INVALID,                "ERR_SW_VID_INVALID"},
-    {ERR_SW_TM_QUEUE_INVALID,           "ERR_SW_TM_QUEUE_INVALID"},
-    {ERR_SW_TM_WEIGHT_INVALID,          "ERR_SW_TM_WEIGHT_INVALID"},
-    {ERR_SW_TM_WRR_MODE_INVALID,        "ERR_SW_TM_WRR_MODE_INVALID"},
-    {ERR_API_TYPE_INVALID,              "ERR_API_TYPE_INVALID"},
-    {ERR_DIR_INVALID,                   "ERR_DIR_INVALID"},
-    {ERR_NULL_POINTER,                  "ERR_NULL_POINTER"},
-    {ERR_IGMP_NOT_ENABLED,              "ERR_IGMP_NOT_ENABLED"},
-    {ERR_OUT_OF_RESOURCES,              "ERR_OUT_OF_RESOURCES"},
-    {ERR_AI_SESS_EXISTS,                "ERR_AI_SESS_EXISTS"},
-    {ERR_AI_SESS_DELETING,              "ERR_AI_SESS_DELETING"},
-    {ERR_SW_TM_BUCKET_SIZE_INVALID,     "ERR_SW_TM_BUCKET_SIZE_INVALID"},
-    {ERR_SW_TM_RATE_LIMIT_INVALID,      "ERR_SW_TM_RATE_LIMIT_INVALID"},
-    {ERR_DELETE_KEY_INVALID,            "ERR_DELETE_KEY_INVALID"},
-    {ERR_L3_KEY_INVALID,                "ERR_L3_KEY_INVALID"},
-    {ERR_IPV4_KEY_INVALID,              "ERR_IPV4_KEY_INVALID"},
-    {ERR_IPV6_KEY_INVALID,              "ERR_IPV6_KEY_INVALID"},
-    {ERR_PORT_IGMP_FRWD_MODE_INVALID,   "ERR_PORT_IGMP_FRWD_MODE_INVALID"},
-    {ERR_IPV6_API_ILLEGAL_CALL,         "ERR_IPV6_API_ILLEGAL_CALL"},
-    {ERR_IPV6_5T_RULE_EXISTS,           "ERR_IPV6_5T_RULE_EXISTS"},
-    {ERR_IPV6_5T_FLOW_PARTIAL_MATCHED,  "ERR_IPV6_5T_FLOW_PARTIAL_MATCHED"},
-    {ERR_IPV6_5T_RULE_IN_USE,           "ERR_IPV6_5T_RULE_IN_USE"},
-    {ERR_IPV6_5T_FLOW_AI_BITS_EXHAUSED, "ERR_IPV6_5T_FLOW_AI_BITS_EXHAUSED"},
-    {ERR_SW_NOT_INIT,                   "ERR_SW_NOT_INIT"},
-};
-
-
-static string_enum_pair_db_t  tpm_err_string_enum_pair_db =
-{
-    tpm_err_string_enum_pair_ara,
-    sizeof(tpm_err_string_enum_pair_ara)/sizeof(tpm_err_string_enum_pair_ara[0])
-};
-
-char *get_tpm_err_str(int value)
-{
-    return map_value_to_string(&tpm_err_string_enum_pair_db, value);
-}
-
-
-/*******************************************************************************
-
-* parse_ipv4_address
-*
-* DESCRIPTION:
-*           This function parses IPV4 address
-* INPUTS:
-*       buf	- buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       GT_BOOL
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-GT_BOOL parse_ipv4_address (char *buf, uint32_t *ipv4addr_parts)
-{
-    if (4 == sscanf(buf, "%d.%d.%d.%d", &ipv4addr_parts[0], &ipv4addr_parts[1], &ipv4addr_parts[2], &ipv4addr_parts[3]))
-    {
-        if (ipv4addr_parts[0] <= 255 && ipv4addr_parts[1] <= 255 && ipv4addr_parts[2] <= 255 && ipv4addr_parts[3] <= 255)
-        {
-            return GT_TRUE;
-        }
-    }
-    return GT_FALSE;
-}
-
-/*******************************************************************************
-* parse_ipv6_address
-*
-* DESCRIPTION:
-*           This function parses IPV4 address
-* INPUTS:
-*       buf	- buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       GT_BOOL
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-GT_BOOL parse_ipv6_address (char *buf, uint32_t *ipv6addr_parts)
-{
-    if (8 == sscanf(buf, "%x:%x:%x:%x:%x:%x:%x:%x",
-                    &ipv6addr_parts[0], &ipv6addr_parts[2],  &ipv6addr_parts[4],  &ipv6addr_parts[6],
-                    &ipv6addr_parts[8], &ipv6addr_parts[10], &ipv6addr_parts[12], &ipv6addr_parts[14]));
-    {
-        if (ipv6addr_parts[0] <= 0xFFFF && ipv6addr_parts[2] <= 0xFFFF  && ipv6addr_parts[4] <= 0xFFFF  && ipv6addr_parts[6] <= 0xFFFF &&
-            ipv6addr_parts[8] <= 0xFFFF && ipv6addr_parts[10] <= 0xFFFF && ipv6addr_parts[12] <= 0xFFFF && ipv6addr_parts[14] <= 0xFFFF)
-        {
-            // Note the order
-            ipv6addr_parts[1]  = ipv6addr_parts[0]  & 0xFF;   ipv6addr_parts[0]  = ipv6addr_parts[0]  >> 8;
-            ipv6addr_parts[3]  = ipv6addr_parts[2]  & 0xFF;   ipv6addr_parts[2]  = ipv6addr_parts[2]  >> 8;
-            ipv6addr_parts[5]  = ipv6addr_parts[4]  & 0xFF;   ipv6addr_parts[4]  = ipv6addr_parts[4]  >> 8;
-            ipv6addr_parts[7]  = ipv6addr_parts[6]  & 0xFF;   ipv6addr_parts[6]  = ipv6addr_parts[6]  >> 8;
-            ipv6addr_parts[9]  = ipv6addr_parts[8]  & 0xFF;   ipv6addr_parts[8]  = ipv6addr_parts[8]  >> 8;
-            ipv6addr_parts[11] = ipv6addr_parts[10] & 0xFF;   ipv6addr_parts[10] = ipv6addr_parts[10] >> 8;
-            ipv6addr_parts[13] = ipv6addr_parts[12] & 0xFF;   ipv6addr_parts[12] = ipv6addr_parts[12] >> 8;
-            ipv6addr_parts[15] = ipv6addr_parts[14] & 0xFF;   ipv6addr_parts[14] = ipv6addr_parts[14] >> 8;
-
-            return GT_TRUE;
-        }
-    }
-    return GT_FALSE;
-}
-
-/*******************************************************************************
-* parse_mac_address
-*
-* DESCRIPTION:
-*           This function parses MAC address
-* INPUTS:
-*       buf	- buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       GT_BOOL
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-GT_BOOL parse_mac_address (char *buf, uint32_t *macaddr_parts)
-{
-    if (6 == sscanf(buf, "%x:%x:%x:%x:%x:%x", &macaddr_parts[0], &macaddr_parts[1], &macaddr_parts[2], &macaddr_parts[3],
-                    &macaddr_parts[4], &macaddr_parts[5]))
-    {
-        if (macaddr_parts[0] <= 255 && macaddr_parts[1] <= 255 && macaddr_parts[2] <= 255 && macaddr_parts[3] <= 255 &&
-            macaddr_parts[4] <= 255 && macaddr_parts[5] <= 255)
-        {
-            return GT_TRUE;
-        }
-    }
-    return GT_FALSE;
-}
-
-
-
-/********************************************************************************/
-/*                          Packet Forward rule table and API                   */
-/********************************************************************************/
-
-static tpmcfg_frwd_entry_t  tpm_sysfs_frwd_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_frwd_rule_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_frwd_entry_t),
-    .entryAra           = tpm_sysfs_frwd_table
-};
-
-
-static void init_tpm_pkt_frwd_db(void)
-{
-    tpmcfg_frwd_entry_t *pentry = (tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
-    int                 indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-
-static void format_ipv4_addr(uint8_t *ipaddr, char *str)
-{
-    sprintf(str, "%d.%d.%d.%d", ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
-}
-
-static void format_ipv6_addr(uint8_t *ipaddr, char *str)
-{
-    uint16_t p1 = (ipaddr[0] << 8)  | ipaddr[1];
-    uint16_t p2 = (ipaddr[2] << 8)  | ipaddr[3];
-    uint16_t p3 = (ipaddr[4] << 8)  | ipaddr[5];
-    uint16_t p4 = (ipaddr[6] << 8)  | ipaddr[7];
-    uint16_t p5 = (ipaddr[8] << 8)  | ipaddr[9];
-    uint16_t p6 = (ipaddr[10] << 8) | ipaddr[11];
-    uint16_t p7 = (ipaddr[12] << 8) | ipaddr[13];
-    uint16_t p8 = (ipaddr[14] << 8) | ipaddr[15];
-
-    sprintf(str, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x", p1, p2, p3, p4, p5, p6, p7, p8);
-}
-
-static void format_mac_addr(uint8_t *macaddr, char *str)
-{
-    sprintf(str, "%02x:%02x:%02x:%02x:%02x:%02x", macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
-}
-
-tpmcfg_frwd_entry_t *find_tpm_pkt_frwd_entry_by_name(char *name)
-{
-    tpmcfg_frwd_entry_t *pentry = (tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_frwd_entry_t *find_free_tpm_pkt_frwd_entry   (void)
-{
-    tpmcfg_frwd_entry_t *pentry = (tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_pkt_frwd_entry_by_name  (char *name)
-{
-    tpmcfg_frwd_entry_t *pentry = (tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            memset(&pentry->frwd, 0, sizeof(pentry->frwd));
-            pentry->name[0] = 0;
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_pkt_frwd_db   (void)
-{
-    tpmcfg_frwd_entry_t *pentry = (tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
-    int                 indx;
-
-    printk(KERN_INFO "%16s  target-port  queue gem-port\n", "name");
-    for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            printk(KERN_INFO "%16s  0x%04x      %-3d    %d\n", pentry->name, pentry->frwd.trg_port, pentry->frwd.trg_queue, pentry->frwd.gem_port);
-        }
-    }
-}
-
-
-/********************************************************************************/
-/*                          VLAN rule table and API                             */
-/********************************************************************************/
-
-static tpmcfg_vlan_entry_t  tpm_sysfs_vlan_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_vlan_rule_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_vlan_entry_t),
-    .entryAra           = tpm_sysfs_vlan_table
-};
-
-
-static void init_tpm_vlan_db(void)
-{
-    tpmcfg_vlan_entry_t *pentry = (tpmcfg_vlan_entry_t *)tpm_vlan_rule_db.entryAra;
-    int                 indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_vlan_rule_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_vlan_entry_t *find_tpm_vlan_entry_by_name(char *name)
-{
-    tpmcfg_vlan_entry_t *pentry = (tpmcfg_vlan_entry_t *)tpm_vlan_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_vlan_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_vlan_entry_t *find_free_tpm_vlan_entry   (void)
-{
-    tpmcfg_vlan_entry_t *pentry = (tpmcfg_vlan_entry_t *)tpm_vlan_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_vlan_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_vlan_entry_by_name  (char *name)
-{
-    tpmcfg_vlan_entry_t *pentry = (tpmcfg_vlan_entry_t *)tpm_vlan_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_vlan_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->vlan, 0, sizeof(pentry->vlan));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_vlan_db   (void)
-{
-    tpmcfg_vlan_entry_t *pentry = (tpmcfg_vlan_entry_t *)tpm_vlan_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_vlan_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            printk(KERN_INFO "%s: tpid 0x%x, tpid_mask 0x%x, VID %d/0x%x, CFI %d/0x%x, pbit %d/0x%x\n", pentry->name,
-                   pentry->vlan.tpid, pentry->vlan.tpid_mask, pentry->vlan.vid, pentry->vlan.vid_mask,
-                   pentry->vlan.cfi, pentry->vlan.cfi_mask, pentry->vlan.pbit, pentry->vlan.pbit_mask);
-        }
-    }
-}
-
-/********************************************************************************/
-/*                          Mod (packet modification) rule table and API        */
-/********************************************************************************/
-
-/*
- *  Wilson:
- *   DB_TPMCFG_MAX_ENTRIES are for ACL rules while one entry,
- *   which is named as 'dbg_entry', is reserved for mod_eng debug only.
- *   The 'dbg_entry' is the last entry in 'tpm_sysfs_mod_table'.
- */
-
-static tpmcfg_mod_entry_t  tpm_sysfs_mod_table[DB_TPMCFG_MAX_ENTRIES+1];
-
-static tpm_generic_rule_db_t tpm_mod_rule_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_mod_entry_t),
-    .entryAra           = tpm_sysfs_mod_table
-};
-
-
-static void init_tpm_mod_db(void)
-{
-    tpmcfg_mod_entry_t *pentry = (tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
-    int                 indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-        pentry->flags   = 0;
-    }
-
-    strcpy(pentry->name, "dbg_entry");
-    pentry->flags = 0;
-}
-
-
-
-tpmcfg_mod_entry_t *find_tpm_mod_entry_by_name(char *name)
-{
-    tpmcfg_mod_entry_t *pentry = (tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
-    int                 indx;
-
-    if (strcmp(name, "dbg_entry") == 0)
-        return &(tpm_sysfs_mod_table[DB_TPMCFG_MAX_ENTRIES]);
-
-    for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_mod_entry_t *find_free_tpm_mod_entry   (void)
-{
-    tpmcfg_mod_entry_t *pentry = (tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
-    int                 indx;
-
-    for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_mod_entry_by_name  (char *name)
-{
-    tpmcfg_mod_entry_t *pentry = (tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
-    int                 indx;
-
-    if (strcmp(name, "dbg_entry") == 0)
-    {
-        memset(&pentry->mod, 0, sizeof(pentry->mod));
-        pentry->flags = 0;
-        return GT_TRUE;
-    }
-
-    for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->mod, 0, sizeof(pentry->mod));
-            pentry->flags = 0;
-            return GT_TRUE;
-        }
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_mod_db   (void)
-{
-    tpmcfg_mod_entry_t  *pentry = (tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
-    int                 indx;
-    int                 off = 0;
-    char                d1[60];
-    char                d2[60];
-    char                d1_mask[60];
-    char                d2_mask[60];
-
-    for (indx = 0; indx < tpm_mod_rule_db.max_num_entries+1; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: flags 0x%x\n",
-                           pentry->name, pentry->flags);
-
-            if (pentry->flags & MOD_ENTRY_FLAG_MH)
-            {
-                off += sprintf(buf+off, "\tMH 0x%x\n", pentry->mod.mh_mod);
-            }
-
-            if (pentry->flags & MOD_ENTRY_FLAG_MAC)
-            {
-                format_mac_addr(pentry->mod.mac_mod.mac_sa, d1);
-                format_mac_addr(pentry->mod.mac_mod.mac_sa_mask, d1_mask);
-                format_mac_addr(pentry->mod.mac_mod.mac_da, d2);
-                format_mac_addr(pentry->mod.mac_mod.mac_da_mask, d2_mask);
-
-                off += sprintf(buf+off, "\tMAC SA %s/%s, DA %s/%s\n", d1, d1_mask, d2, d2_mask);
-            }
-
-            if (pentry->flags & MOD_ENTRY_FLAG_VLAN)
-            {
-                off += sprintf(buf+off, "\t%-19s  VLAN_1 - tpid 0x%x, VID %d/0x%x, CFI %d/0x%x, pbit %d/0x%x\n",
-                               get_vlan_op_str(pentry->mod.vlan_mod.vlan_op), pentry->mod.vlan_mod.vlan1_out.tpid,
-                               pentry->mod.vlan_mod.vlan1_out.vid, pentry->mod.vlan_mod.vlan1_out.vid_mask,
-                               pentry->mod.vlan_mod.vlan1_out.cfi, pentry->mod.vlan_mod.vlan1_out.cfi_mask,
-                               pentry->mod.vlan_mod.vlan1_out.pbit, pentry->mod.vlan_mod.vlan1_out.pbit_mask);
-
-                off += sprintf(buf+off, "\t                     VLAN_2 - tpid 0x%x, VID %d/0x%x, CFI %d/0x%x, pbit %d/0x%x\n",
-                               pentry->mod.vlan_mod.vlan2_out.tpid,
-                               pentry->mod.vlan_mod.vlan2_out.vid, pentry->mod.vlan_mod.vlan2_out.vid_mask,
-                               pentry->mod.vlan_mod.vlan2_out.cfi, pentry->mod.vlan_mod.vlan2_out.cfi_mask,
-                               pentry->mod.vlan_mod.vlan2_out.pbit, pentry->mod.vlan_mod.vlan2_out.pbit_mask);
-            }
-            if (pentry->flags & MOD_ENTRY_FLAG_IPV4)
-            {
-                format_ipv4_addr(pentry->mod.l3.ipv4_mod.ipv4_src_ip_add, d1);
-                format_ipv4_addr(pentry->mod.l3.ipv4_mod.ipv4_src_ip_add_mask, d1_mask);
-                format_ipv4_addr(pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add, d2);
-                format_ipv4_addr(pentry->mod.l3.ipv4_mod.ipv4_dst_ip_add_mask, d2_mask);
-
-                off += sprintf(buf+off, "\tIPV4: src_ip_add %s/%s, dst_ip_add %s/%s\n", d1, d1_mask, d2, d2_mask);
-
-                off += sprintf(buf+off, "\tl3.l4_src_port %d, l3.l4_dst_port %d\n",
-                               pentry->mod.l3.ipv4_mod.l4_src_port, pentry->mod.l3.ipv4_mod.l4_dst_port);
-            }
-            else if (pentry->flags & MOD_ENTRY_FLAG_IPV6)
-            {
-                format_ipv6_addr(pentry->mod.l3.ipv6_mod.ipv6_src_ip_add, d1);
-                format_ipv6_addr(pentry->mod.l3.ipv6_mod.ipv6_src_ip_add_mask, d1_mask);
-                format_ipv6_addr(pentry->mod.l3.ipv6_mod.ipv6_dst_ip_add, d2);
-                format_ipv6_addr(pentry->mod.l3.ipv6_mod.ipv6_dst_ip_add_mask, d2_mask);
-
-                off += sprintf(buf+off, "\tIPV6: src_ip_add %s/%s\n\t      dst_ip_add %s/%s\n", d1, d1_mask, d2, d2_mask);
-
-                off += sprintf(buf+off, "\tl4_src_port %d, l4_dst_port %d\n",
-                               pentry->mod.l3.ipv6_mod.l4_src_port, pentry->mod.l3.ipv6_mod.l4_dst_port);
-            }
-
-
-            if (pentry->flags & MOD_ENTRY_FLAG_PPPOE)
-            {
-                off += sprintf(buf+off, "\tPPPoE session %d, protocol type 0x%x\n",
-                               pentry->mod.pppoe_mod.ppp_session, pentry->mod.pppoe_mod.ppp_proto);
-            }
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-/********************************************************************************/
-/*                          L2 ACL table and API                                */
-/********************************************************************************/
-
-static tpmcfg_l2_key_entry_t  tpm_sysfs_l2_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_l2_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_l2_key_entry_t),
-    .entryAra           = tpm_sysfs_l2_key_table
-};
-
-
-static void init_tpm_l2_key_db(void)
-{
-    tpmcfg_l2_key_entry_t *pentry = (tpmcfg_l2_key_entry_t *)tpm_l2_key_db.entryAra;
-    int                   indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_l2_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_l2_key_entry_t *find_tpm_l2_key_entry_by_name(char *name)
-{
-    tpmcfg_l2_key_entry_t *pentry = (tpmcfg_l2_key_entry_t *)tpm_l2_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l2_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_l2_key_entry_t *find_free_tpm_l2_key_entry   (void)
-{
-    tpmcfg_l2_key_entry_t *pentry = (tpmcfg_l2_key_entry_t *)tpm_l2_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l2_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_l2_key_entry_by_name  (char *name)
-{
-    tpmcfg_l2_key_entry_t *pentry = (tpmcfg_l2_key_entry_t *)tpm_l2_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l2_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->l2_acl, 0, sizeof(pentry->l2_acl));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_l2_key_db   (void)
-{
-    tpmcfg_l2_key_entry_t *pentry = (tpmcfg_l2_key_entry_t *)tpm_l2_key_db.entryAra;
-    int                   indx;
-    int                   off = 0;
-    char                  d1[60];
-    char                  d2[60];
-    char                  d1_mask[60];
-    char                  d2_mask[60];
-
-    for (indx = 0; indx < tpm_l2_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            off += sprintf(buf+off, "\tVLAN_1 - tpid 0x%x/0x%x, VID %d/0x%x, CFI %d/0x%x, pbit %d/0x%x\n",
-                           pentry->l2_acl.vlan1.tpid, pentry->l2_acl.vlan1.tpid_mask,
-                           pentry->l2_acl.vlan1.vid,  pentry->l2_acl.vlan1.vid_mask,
-                           pentry->l2_acl.vlan1.cfi,  pentry->l2_acl.vlan1.cfi_mask,
-                           pentry->l2_acl.vlan1.pbit, pentry->l2_acl.vlan1.pbit_mask);
-
-            off += sprintf(buf+off, "\tVLAN_2 - tpid 0x%x/0x%x, VID %d/0x%x, CFI %d/0x%x, pbit %d/0x%x\n",
-                           pentry->l2_acl.vlan2.tpid, pentry->l2_acl.vlan2.tpid_mask,
-                           pentry->l2_acl.vlan2.vid,  pentry->l2_acl.vlan2.vid_mask,
-                           pentry->l2_acl.vlan2.cfi,  pentry->l2_acl.vlan2.cfi_mask,
-                           pentry->l2_acl.vlan2.pbit, pentry->l2_acl.vlan2.pbit_mask);
-
-            off += sprintf(buf+off, "\tethertype 0x%x, gemport %d, PPPoE: session %d, protocol type 0x%x\n",
-                           pentry->l2_acl.ether_type, pentry->l2_acl.gem_port,
-                           pentry->l2_acl.pppoe_hdr.ppp_session, pentry->l2_acl.pppoe_hdr.ppp_proto);
-
-            format_mac_addr(pentry->l2_acl.mac.mac_sa, d1);
-            format_mac_addr(pentry->l2_acl.mac.mac_sa_mask, d1_mask);
-            format_mac_addr(pentry->l2_acl.mac.mac_da, d2);
-            format_mac_addr(pentry->l2_acl.mac.mac_da_mask, d2_mask);
-
-            off += sprintf(buf+off, "\tMAC SA %s/%s, DA %s/%s\n", d1, d1_mask, d2, d2_mask);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-/********************************************************************************/
-/*                          L3 ACL table and API                                */
-/********************************************************************************/
-
-static tpmcfg_l3_key_entry_t  tpm_sysfs_l3_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_l3_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_l3_key_entry_t),
-    .entryAra           = tpm_sysfs_l3_key_table
-};
-
-
-static void init_tpm_l3_key_db(void)
-{
-    tpmcfg_l3_key_entry_t *pentry = (tpmcfg_l3_key_entry_t *)tpm_l3_key_db.entryAra;
-    int                   indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_l3_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_l3_key_entry_t *find_tpm_l3_key_entry_by_name(char *name)
-{
-    tpmcfg_l3_key_entry_t *pentry = (tpmcfg_l3_key_entry_t *)tpm_l3_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l3_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_l3_key_entry_t *find_free_tpm_l3_key_entry   (void)
-{
-    tpmcfg_l3_key_entry_t *pentry = (tpmcfg_l3_key_entry_t *)tpm_l3_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l3_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_l3_key_entry_by_name  (char *name)
-{
-    tpmcfg_l3_key_entry_t *pentry = (tpmcfg_l3_key_entry_t *)tpm_l3_key_db.entryAra;
-    int                   indx;
-
-    for (indx = 0; indx < tpm_l3_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->l3_acl, 0, sizeof(pentry->l3_acl));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_l3_key_db   (void)
-{
-    tpmcfg_l3_key_entry_t *pentry = (tpmcfg_l3_key_entry_t *)tpm_l3_key_db.entryAra;
-    int                   indx;
-    int                   off = 0;
-
-    for (indx = 0; indx < tpm_l3_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            off += sprintf(buf+off, "\tethertype 0x%x, PPPoE: session %d, protocol type 0x%x\n",
-                           pentry->l3_acl.ether_type_key, pentry->l3_acl.pppoe_key.ppp_session, pentry->l3_acl.pppoe_key.ppp_proto);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-/********************************************************************************/
-/*                          IPV4 ACL table and API                              */
-/********************************************************************************/
-
-static tpmcfg_ipv4_key_entry_t  tpm_sysfs_ipv4_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_ipv4_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_ipv4_key_entry_t),
-    .entryAra           = tpm_sysfs_ipv4_key_table
-};
-
-
-static void init_tpm_ipv4_key_db(void)
-{
-    tpmcfg_ipv4_key_entry_t *pentry = (tpmcfg_ipv4_key_entry_t *)tpm_ipv4_key_db.entryAra;
-    int                     indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_ipv4_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_ipv4_key_entry_t *find_tpm_ipv4_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv4_key_entry_t *pentry = (tpmcfg_ipv4_key_entry_t *)tpm_ipv4_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv4_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_ipv4_key_entry_t *find_free_tpm_ipv4_key_entry   (void)
-{
-    tpmcfg_ipv4_key_entry_t *pentry = (tpmcfg_ipv4_key_entry_t *)tpm_ipv4_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv4_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_ipv4_key_entry_by_name  (char *name)
-{
-    tpmcfg_ipv4_key_entry_t *pentry = (tpmcfg_ipv4_key_entry_t *)tpm_ipv4_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv4_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->ipv4_acl, 0, sizeof(pentry->ipv4_acl));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_ipv4_key_db   (void)
-{
-    tpmcfg_ipv4_key_entry_t *pentry = (tpmcfg_ipv4_key_entry_t *)tpm_ipv4_key_db.entryAra;
-    int                     indx;
-    int                     off = 0;
-    char                    d1[60];
-    char                    d2[60];
-    char                    d1_mask[60];
-    char                    d2_mask[60];
-
-    for (indx = 0; indx < tpm_ipv4_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n",
-                           pentry->name);
-
-            off += sprintf(buf+off, "\tdscp %d/0x%x, protocol %d, src_port %d, dst_port %d\n",
-                           pentry->ipv4_acl.ipv4_dscp, pentry->ipv4_acl.ipv4_dscp_mask,
-                           pentry->ipv4_acl.ipv4_proto, pentry->ipv4_acl.l4_src_port, pentry->ipv4_acl.l4_dst_port);
-
-            format_ipv4_addr(pentry->ipv4_acl.ipv4_src_ip_add, d1);
-            format_ipv4_addr(pentry->ipv4_acl.ipv4_src_ip_add_mask, d1_mask);
-            format_ipv4_addr(pentry->ipv4_acl.ipv4_dst_ip_add, d2);
-            format_ipv4_addr(pentry->ipv4_acl.ipv4_dst_ip_add_mask, d2_mask);
-
-            off += sprintf(buf+off, "\tsrc_ip_add %s/%s, dst_ip_add %s/%s\n", d1, d1_mask, d2, d2_mask);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-/********************************************************************************/
-/*                          IPV6 ACL table and API        */
-/********************************************************************************/
-
-static tpmcfg_ipv6_key_entry_t  tpm_sysfs_ipv6_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_ipv6_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_ipv6_key_entry_t),
-    .entryAra           = tpm_sysfs_ipv6_key_table
-};
-
-static void init_tpm_ipv6_key_db(void)
-{
-    tpmcfg_ipv6_key_entry_t *pentry = (tpmcfg_ipv6_key_entry_t *)tpm_ipv6_key_db.entryAra;
-    int                     indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_ipv6_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_ipv6_key_entry_t *find_tpm_ipv6_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_key_entry_t *pentry = (tpmcfg_ipv6_key_entry_t *)tpm_ipv6_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_ipv6_key_entry_t *find_free_tpm_ipv6_key_entry   (void)
-{
-    tpmcfg_ipv6_key_entry_t *pentry = (tpmcfg_ipv6_key_entry_t *)tpm_ipv6_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL        del_tpm_ipv6_key_entry_by_name  (char *name)
-{
-    tpmcfg_ipv6_key_entry_t *pentry = (tpmcfg_ipv6_key_entry_t *)tpm_ipv6_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->ipv6_acl, 0, sizeof(pentry->ipv6_acl));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_ipv6_key_db   (void)
-{
-    tpmcfg_ipv6_key_entry_t *pentry = (tpmcfg_ipv6_key_entry_t *)tpm_ipv6_key_db.entryAra;
-    int                     indx;
-    int                     off = 0;
-    char                    d1[60];
-    char                    d2[60];
-    char                    d1_mask[60];
-    char                    d2_mask[60];
-
-    for (indx = 0; indx < tpm_ipv6_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            off += sprintf(buf+off, "\tdscp %d/0x%x, next_header %d, src_port %d, dst_port %d\n",
-                           pentry->ipv6_acl.ipv6_dscp, pentry->ipv6_acl.ipv6_dscp_mask,
-                           pentry->ipv6_acl.ipv6_next_header, pentry->ipv6_acl.l4_src_port, pentry->ipv6_acl.l4_dst_port);
-
-            format_ipv6_addr(pentry->ipv6_acl.ipv6_src_ip_add, d1);
-            format_ipv6_addr(pentry->ipv6_acl.ipv6_src_ip_add_mask, d1_mask);
-            format_ipv6_addr(pentry->ipv6_acl.ipv6_dst_ip_add, d2);
-            format_ipv6_addr(pentry->ipv6_acl.ipv6_dst_ip_add_mask, d2_mask);
-
-            off += sprintf(buf+off, "\tsrc_ip_add %s/%s, dst_ip_add %s/%s\n", d1, d1_mask, d2, d2_mask);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-
-/********************************************************************************/
-/*                          IPV6 gen ACL table and API        */
-/********************************************************************************/
-
-static tpmcfg_ipv6_key_entry_t tpm_sysfs_ipv6_gen_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_ipv6_gen_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_ipv6_key_entry_t),
-    .entryAra           = tpm_sysfs_ipv6_gen_key_table
-};
-
-
-static void init_tpm_ipv6_gen_key_db(void)
-{
-    tpmcfg_ipv6_gen_key_entry_t *pentry = (tpmcfg_ipv6_gen_key_entry_t *)tpm_ipv6_gen_key_db.entryAra;
-    int                     indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_ipv6_gen_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_ipv6_gen_key_entry_t *find_tpm_ipv6_gen_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_gen_key_entry_t *pentry = (tpmcfg_ipv6_gen_key_entry_t *)tpm_ipv6_gen_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_gen_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_ipv6_gen_key_entry_t *find_free_tpm_ipv6_gen_key_entry(void)
-{
-    tpmcfg_ipv6_gen_key_entry_t *pentry = (tpmcfg_ipv6_gen_key_entry_t *)tpm_ipv6_gen_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_gen_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL del_tpm_ipv6_gen_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_gen_key_entry_t *pentry = (tpmcfg_ipv6_gen_key_entry_t *)tpm_ipv6_gen_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_gen_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->ipv6gen_acl, 0, sizeof(pentry->ipv6gen_acl));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_ipv6_gen_key_db(void)
-{
-    tpmcfg_ipv6_gen_key_entry_t *pentry = (tpmcfg_ipv6_gen_key_entry_t *)tpm_ipv6_gen_key_db.entryAra;
-    int                     indx;
-    int                     off = 0;
-    char                    d1[60];
-    char                    d1_mask[60];
-
-    for (indx = 0; indx < tpm_ipv6_gen_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            off += sprintf(buf+off, "\tdscp %d/0x%x, hop_limit %d\n",
-                           pentry->ipv6gen_acl.ipv6_dscp, pentry->ipv6gen_acl.ipv6_dscp_mask,
-                           pentry->ipv6gen_acl.hop_limit);
-
-            format_ipv6_addr(pentry->ipv6gen_acl.ipv6_src_ip_add, d1);
-            format_ipv6_addr(pentry->ipv6gen_acl.ipv6_src_ip_add_mask, d1_mask);
-
-            off += sprintf(buf+off, "\tsrc_ip_add %s/%s\n", d1, d1_mask);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-static tpmcfg_ipv6_dip_key_entry_t tpm_sysfs_ipv6_dip_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_ipv6_dip_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_ipv6_dip_key_entry_t),
-    .entryAra           = tpm_sysfs_ipv6_dip_key_table
-};
-
-
-static void init_tpm_ipv6_dip_key_db(void)
-{
-    tpmcfg_ipv6_dip_key_entry_t *pentry = (tpmcfg_ipv6_dip_key_entry_t *)tpm_ipv6_dip_key_db.entryAra;
-    int                     indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_ipv6_dip_key_db.max_num_entries; indx++, pentry++)
-    {
-        pentry->name[0] = 0;
-    }
-}
-
-tpmcfg_ipv6_dip_key_entry_t *find_tpm_ipv6_dip_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_dip_key_entry_t *pentry = (tpmcfg_ipv6_dip_key_entry_t *)tpm_ipv6_dip_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_dip_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0) return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_ipv6_dip_key_entry_t *find_free_tpm_ipv6_dip_key_entry(void)
-{
-    tpmcfg_ipv6_dip_key_entry_t *pentry = (tpmcfg_ipv6_dip_key_entry_t *)tpm_ipv6_dip_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_dip_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] == 0) return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL del_tpm_ipv6_dip_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_dip_key_entry_t *pentry = (tpmcfg_ipv6_dip_key_entry_t *)tpm_ipv6_dip_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_dip_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (strcmp(pentry->name, name) == 0)
-        {
-            pentry->name[0] = 0;
-            memset(&pentry->ipv6_addr, 0, sizeof(pentry->ipv6_addr));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_ipv6_dip_key_db(void)
-{
-    tpmcfg_ipv6_dip_key_entry_t *pentry = (tpmcfg_ipv6_dip_key_entry_t *)tpm_ipv6_dip_key_db.entryAra;
-    int                     indx;
-    int                     off = 0;
-    char                    d1[60];
-//    char                    d2[60];
-    char                    d1_mask[60];
-//    char                    d2_mask[60];
-
-    for (indx = 0; indx < tpm_ipv6_dip_key_db.max_num_entries; indx++, pentry++)
-    {
-        if (pentry->name[0] != 0)
-        {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            format_ipv6_addr(pentry->ipv6_addr.ipv6_ip_add, d1);
-            format_ipv6_addr(pentry->ipv6_addr.ipv6_ip_add_mask, d1_mask);
-
-            off += sprintf(buf+off, "\tdst_ip_add %s/%s\n", d1, d1_mask);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-static tpmcfg_ipv6_l4_ports_key_entry_t  tpm_sysfs_ipv6_l4_ports_key_table[DB_TPMCFG_MAX_ENTRIES];
-
-static tpm_generic_rule_db_t tpm_ipv6_l4_ports_key_db =
-{
-    .max_num_entries    = DB_TPMCFG_MAX_ENTRIES,
-    .num_entries        = 0,
-    .size_entry         = sizeof(tpmcfg_ipv6_l4_ports_key_entry_t),
-    .entryAra           = tpm_sysfs_ipv6_l4_ports_key_table
-};
-
-static void init_tpm_ipv6_l4_ports_key_db(void)
-{
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry = (tpmcfg_ipv6_l4_ports_key_entry_t *)tpm_ipv6_l4_ports_key_db.entryAra;
-    int indx;
-
-    printk(KERN_INFO "%s: Clearing DB\n", __FUNCTION__);
-    for (indx = 0; indx < tpm_ipv6_l4_ports_key_db.max_num_entries; indx++, pentry++)
-        pentry->name[0] = 0;
-}
-
-tpmcfg_ipv6_l4_ports_key_entry_t *find_tpm_ipv6_l4_ports_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry = (tpmcfg_ipv6_l4_ports_key_entry_t *)tpm_ipv6_l4_ports_key_db.entryAra;
-    int indx;
-
-    for (indx = 0; indx < tpm_ipv6_l4_ports_key_db.max_num_entries; indx++, pentry++) {
-        if (strcmp(pentry->name, name) == 0)
-			return pentry;
-    }
-    return 0;
-}
-
-tpmcfg_ipv6_l4_ports_key_entry_t *find_free_tpm_ipv6_l4_ports_key_entry(void)
-{
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry = (tpmcfg_ipv6_l4_ports_key_entry_t *)tpm_ipv6_l4_ports_key_db.entryAra;
-    int indx;
-
-    for (indx = 0; indx < tpm_ipv6_l4_ports_key_db.max_num_entries; indx++, pentry++) {
-        if (pentry->name[0] == 0)
-			return pentry;
-    }
-    return 0;
-}
-
-GT_BOOL del_tpm_ipv6_l4_ports_key_entry_by_name(char *name)
-{
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry = (tpmcfg_ipv6_l4_ports_key_entry_t *)tpm_ipv6_l4_ports_key_db.entryAra;
-    int                     indx;
-
-    for (indx = 0; indx < tpm_ipv6_l4_ports_key_db.max_num_entries; indx++, pentry++) {
-        if (strcmp(pentry->name, name) == 0) {
-            pentry->name[0] = 0;
-            memset(&pentry->l4_ports, 0, sizeof(pentry->l4_ports));
-            return GT_TRUE;
-        };
-    }
-    return GT_FALSE;
-}
-
-void show_tpm_ipv6_l4_ports_key_db(void)
-{
-    tpmcfg_ipv6_l4_ports_key_entry_t *pentry = (tpmcfg_ipv6_l4_ports_key_entry_t *)tpm_ipv6_l4_ports_key_db.entryAra;
-    int                     indx;
-    int                     off = 0;
-
-    for (indx = 0; indx < tpm_ipv6_l4_ports_key_db.max_num_entries; indx++, pentry++) {
-        if (pentry->name[0] != 0) {
-            off += sprintf(buf+off, "%s: \n", pentry->name);
-
-            off += sprintf(buf+off, "\tsrc_port %d, dst_port %d\n",
-						pentry->l4_ports.l4_src_port, pentry->l4_ports.l4_dst_port);
-
-            printk(KERN_INFO "%s\n", buf);
-            off = 0;
-        }
-    }
-}
-
-
-void tpm_reset_mc_vid_key(void)
-{
-    tpm_src_port_type_t                 src_port;
-
-    memset(&mc_vid_key, 0, sizeof(mc_vid_key));
-
-    for ( src_port = TPM_SRC_PORT_UNI_0; src_port <= TPM_SRC_PORT_UNI_VIRT; src_port++)
-    {
-        mc_vid_key.mc_vid_port_vids[src_port - TPM_SRC_PORT_UNI_0].tpm_src_port = src_port;
-    }
-
-    return;
-}
-
-GT_BOOL tpm_set_mc_vid_key(
-    uint32_t                 src_port,
-    uint32_t                 mc_uni_xlate_mode,
-    uint32_t                 mc_uni_xlate_vid
-)
-{
-    if (src_port < TPM_SRC_PORT_UNI_0 || src_port > TPM_SRC_PORT_UNI_VIRT)
-    {
-        printk(KERN_INFO "illegal input src port(%d)\n", src_port);
-        return GT_FALSE;
-    }
-
-    mc_vid_key.mc_vid_port_vids[src_port - TPM_SRC_PORT_UNI_0].mc_uni_port_mode = mc_uni_xlate_mode;
-    mc_vid_key.mc_vid_port_vids[src_port - TPM_SRC_PORT_UNI_0].tpm_src_port = src_port;
-    mc_vid_key.mc_vid_port_vids[src_port - TPM_SRC_PORT_UNI_0].uni_port_vid = mc_uni_xlate_vid;
-
-    return GT_TRUE;
-}
-
-tpm_error_code_t tpm_set_mc_vid_cfg(
-    uint32_t                 mc_vid
-)
-{
-    tpm_error_code_t ret;
-
-    ret = tpm_proc_set_mc_vid_port_vids (0, mc_vid, &mc_vid_key);
-    return ret;
-}
-
-// Intialization of database
-void tpm_sysfs_rule_db_init(void)
-{
-    init_tpm_pkt_frwd_db();
-    init_tpm_vlan_db();
-    init_tpm_mod_db();
-    init_tpm_l2_key_db();
-    init_tpm_l3_key_db();
-    init_tpm_ipv4_key_db();
-    init_tpm_ipv6_key_db();
-    init_tpm_ipv6_dip_key_db();
-    init_tpm_ipv6_gen_key_db();
-	init_tpm_ipv6_l4_ports_key_db();
-}
-tpm_error_code_t tpm_proc_send_genquery_to_uni(tpm_trg_port_type_t dest_port_bm, uint32_t packet_num)
-{
-	int32_t switch_dev_num;
-	uint8_t loop;
-	uint8_t loop_in;
-	uint32_t trg_port;
-	uint32_t switch_port_bm;
-	tpm_error_code_t ret_code;
-	tpm_db_ety_dsa_enable_t ety_dsa_enable;
-
-	tpm_db_get_ety_dsa_enable(&ety_dsa_enable);
-	if (TPM_ETY_DSA_DISABLE == ety_dsa_enable) {
-		TPM_OS_ERROR(TPM_TPM_LOG_MOD, "ety_dsa is not enabled!\n");
-		return TPM_OK;
-	}
-	/* fill in the switch dev_num */
-	tpm_db_get_switch_dev_num(&switch_dev_num);
-	switch_dev_num &= 0x1f;
-	g_gen_query_pkt[16] = (0x40 | switch_dev_num);
-
-	switch_port_bm = tpm_db_trg_port_switch_port_get(dest_port_bm);
-	for (loop = 0, trg_port = 1; loop <= 7; loop++, trg_port = trg_port << 1) {
-		if (0 == (trg_port & switch_port_bm))
-			continue;
-
-		g_gen_query_pkt[17] = (loop << 3);
-
-		for (loop_in = 0; loop_in < packet_num; loop_in++) {
-			g_gen_query_pkt[23] = (loop_in + 1);
-			ret_code = tpm_tx_igmp_frame(0, TPM_TRG_PORT_UNI_ANY, 7, 0, g_gen_query_pkt, sizeof(g_gen_query_pkt));
-			if (ret_code != TPM_OK) {\
-				TPM_OS_ERROR(TPM_CLI_MOD, " recvd ret_code(%d)\n", ret_code);\
-				return(ret_code);\
-			}
-		}
-	}
-
-
-	return(TPM_RC_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.h
deleted file mode 100644
index ddf2bcf..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_sysfs_utils.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_usr_tpmsysfs_db.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   Zeev
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_TPM_SYSFS_DB_H_
-#define _TPM_USR_TPM_SYSFS_DB_H_
-
-#define DB_TPMCFG_MAX_NAME         32
-#define DB_TPMCFG_MAX_ENTRIES      512
-
-
-extern void tpm_sysfs_rule_db_init(void);
-
-
-//
-// Miscellaneous
-//
-// Internal rule type classification
-typedef enum
-{
-    rule_type_l2, rule_type_l3, rule_type_ipv4, rule_type_ipv6
-} rule_type_t;
-
-typedef struct
-{
-    int  value;
-    char *str;
-} string_enum_pair_t;
-
-typedef struct
-{
-    string_enum_pair_t *string_enum_pair;
-    int                num_entries;
-} string_enum_pair_db_t;
-extern GT_BOOL get_srcport_value        (char *str, unsigned int *value);
-extern GT_BOOL get_srcdir_value         (char *str, unsigned int *value);
-extern GT_BOOL get_phase_value          (char *str, unsigned int *value);
-extern GT_BOOL get_bool_value           (char *str, unsigned int *value);
-extern GT_BOOL get_igmp_mode_value      (char *str, unsigned int *value);
-extern GT_BOOL get_igmp_srcport_value   (char *str, unsigned int *value);
-extern GT_BOOL get_lx_ipvy_value        (char *str, unsigned int *value);
-extern GT_BOOL get_direction_value      (char *str, unsigned int *value);
-extern GT_BOOL get_scheduling_mode_value(char *str, unsigned int *value);
-extern GT_BOOL get_sched_entity_value   (char *str, unsigned int *value);
-extern GT_BOOL get_vlan_op_value        (char *str, unsigned int *value);
-
-extern char *get_tpm_err_str(int value);
-
-
-extern GT_BOOL parse_ipv4_address (char *buf, uint32_t *ipv4addr_parts);
-extern GT_BOOL parse_ipv6_address (char *buf, uint32_t *ipv6addr_parts);
-extern GT_BOOL parse_mac_address  (char *buf, uint32_t *macaddr_parts);
-
-
-
-extern int  count_parameters     (const char *buf);
-extern void print_horizontal_line(unsigned int char_count);
-extern void print_help_buffer    (char *helpbuf, int len);
-extern void parm_error_completion(int numparms, int reqdparms, const char *buf, int (*help_text_routine)(char *));
-
-
-//
-// Common DB structure for entries
-//
-typedef struct
-{
-    int  max_num_entries;
-    int  num_entries;
-    int  size_entry;
-    void *entryAra;
-} tpm_generic_rule_db_t;
-
-
-// Frwd packet entry and DB API
-typedef struct
-{
-    char                name[DB_TPMCFG_MAX_NAME+1];
-    tpm_pkt_frwd_t      frwd;
-} tpmcfg_frwd_entry_t;
-
-extern tpmcfg_frwd_entry_t *find_tpm_pkt_frwd_entry_by_name(char *name);
-extern tpmcfg_frwd_entry_t *find_free_tpm_pkt_frwd_entry   (void);
-extern GT_BOOL             del_tpm_pkt_frwd_entry_by_name  (char *name);
-extern void                show_tpm_pkt_frwd_db(void);
-
-
-
-// VLAN entry and DB API
-typedef struct
-{
-    char                name[DB_TPMCFG_MAX_NAME+1];
-    tpm_vlan_key_t      vlan;
-} tpmcfg_vlan_entry_t;
-
-extern tpmcfg_vlan_entry_t *find_tpm_vlan_entry_by_name(char *name);
-extern tpmcfg_vlan_entry_t *find_free_tpm_vlan_entry   (void);
-extern GT_BOOL             del_tpm_vlan_entry_by_name  (char *name);
-extern void                show_tpm_vlan_db(void);
-
-
-// Mod (packet modification) entry and DB API
-//
-// Flags to indicate which fields are defined
-#define MOD_ENTRY_FLAG_IPV4        0x1
-#define MOD_ENTRY_FLAG_IPV6        0x2
-#define MOD_ENTRY_FLAG_PPPOE       0x4
-#define MOD_ENTRY_FLAG_MAC         0x8
-#define MOD_ENTRY_FLAG_VLAN        0x10
-#define MOD_ENTRY_FLAG_MH          0x20
-
-typedef struct
-{
-    char                name[DB_TPMCFG_MAX_NAME+1];
-    tpm_pkt_mod_t       mod;
-    uint32_t            flags;
-} tpmcfg_mod_entry_t;
-
-extern tpmcfg_mod_entry_t  *find_tpm_mod_entry_by_name(char *name);
-extern tpmcfg_mod_entry_t  *find_free_tpm_mod_entry   (void);
-extern GT_BOOL             del_tpm_mod_entry_by_name  (char *name);
-extern void                show_tpm_mod_db(void);
-
-// L2 ACL entry and DB API
-typedef struct
-{
-    char                   name[DB_TPMCFG_MAX_NAME+1];
-    tpm_l2_acl_key_t       l2_acl;
-} tpmcfg_l2_key_entry_t;
-
-extern tpmcfg_l2_key_entry_t  *find_tpm_l2_key_entry_by_name(char *name);
-extern tpmcfg_l2_key_entry_t  *find_free_tpm_l2_key_entry  (void);
-extern GT_BOOL                del_tpm_l2_key_entry_by_name  (char *name);
-extern void                   show_tpm_l2_key_db(void);
-
-// L3 ACL entry and DB API
-typedef struct
-{
-    char                   name[DB_TPMCFG_MAX_NAME+1];
-    tpm_l3_type_key_t      l3_acl;
-} tpmcfg_l3_key_entry_t;
-
-extern tpmcfg_l3_key_entry_t  *find_tpm_l3_key_entry_by_name(char *name);
-extern tpmcfg_l3_key_entry_t  *find_free_tpm_l3_key_entry  (void);
-extern GT_BOOL                del_tpm_l3_key_entry_by_name  (char *name);
-extern void                   show_tpm_l3_key_db(void);
-
-// IPV4 ACL entry and DB API
-typedef struct
-{
-    char                   name[DB_TPMCFG_MAX_NAME+1];
-    tpm_ipv4_acl_key_t     ipv4_acl;
-} tpmcfg_ipv4_key_entry_t;
-
-extern tpmcfg_ipv4_key_entry_t  *find_tpm_ipv4_key_entry_by_name(char *name);
-extern tpmcfg_ipv4_key_entry_t  *find_free_tpm_ipv4_key_entry  (void);
-extern GT_BOOL                  del_tpm_ipv4_key_entry_by_name  (char *name);
-extern void                     show_tpm_ipv4_key_db(void);
-
-// IPV6 ACL entry and DB API
-typedef struct
-{
-    char               name[DB_TPMCFG_MAX_NAME+1];
-    tpm_ipv6_acl_key_t ipv6_acl;
-} tpmcfg_ipv6_key_entry_t;
-
-extern tpmcfg_ipv6_key_entry_t  *find_tpm_ipv6_key_entry_by_name(char *name);
-extern tpmcfg_ipv6_key_entry_t  *find_free_tpm_ipv6_key_entry(void);
-extern GT_BOOL                   del_tpm_ipv6_key_entry_by_name(char *name);
-extern void                      show_tpm_ipv6_key_db(void);
-
-// IPV6 gen ACL entry and DB API
-typedef struct
-{
-    char                   name[DB_TPMCFG_MAX_NAME+1];
-    tpm_ipv6_gen_acl_key_t ipv6gen_acl;
-} tpmcfg_ipv6_gen_key_entry_t;
-
-typedef struct
-{
-    char                name[DB_TPMCFG_MAX_NAME+1];
-    tpm_ipv6_addr_key_t ipv6_addr;
-} tpmcfg_ipv6_dip_key_entry_t;
-
-typedef struct
-{
-    char                name[DB_TPMCFG_MAX_NAME+1];
-    tpm_l4_ports_key_t  l4_ports;
-} tpmcfg_ipv6_l4_ports_key_entry_t;
-
-extern tpmcfg_ipv6_gen_key_entry_t       *find_tpm_ipv6_gen_key_entry_by_name(char *name);
-extern tpmcfg_ipv6_gen_key_entry_t       *find_free_tpm_ipv6_gen_key_entry(void);
-extern GT_BOOL                            del_tpm_ipv6_gen_key_entry_by_name(char *name);
-extern void                               show_tpm_ipv6_gen_key_db(void);
-extern tpmcfg_ipv6_dip_key_entry_t       *find_tpm_ipv6_dip_key_entry_by_name(char *name);
-extern tpmcfg_ipv6_dip_key_entry_t       *find_free_tpm_ipv6_dip_key_entry(void);
-extern GT_BOOL                            del_tpm_ipv6_dip_key_entry_by_name(char *name);
-extern void                               show_tpm_ipv6_dip_key_db(void);
-extern tpmcfg_ipv6_l4_ports_key_entry_t  *find_tpm_ipv6_l4_ports_key_entry_by_name(char *name);
-extern tpmcfg_ipv6_l4_ports_key_entry_t  *find_free_tpm_ipv6_l4_ports_key_entry(void);
-extern GT_BOOL                            del_tpm_ipv6_l4_ports_key_entry_by_name(char *name);
-extern void                               show_tpm_ipv6_l4_ports_key_db(void);
-
-
-extern void tpm_reset_mc_vid_key(void);
-
-extern GT_BOOL tpm_set_mc_vid_key(
-    uint32_t                 src_port,
-    uint32_t                 mc_uni_xlate_mode,
-    uint32_t                 mc_uni_xlate_vid
-);
-extern tpm_error_code_t tpm_set_mc_vid_cfg(
-    uint32_t                 mc_vid
-);
-tpm_error_code_t tpm_proc_send_genquery_to_uni(tpm_trg_port_type_t dest_port_bm, uint32_t packet_num);
-
-
-#endif  /* _TPM_USR_TPM_SYSFS_DB_H_*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.c
deleted file mode 100644
index fcd06d0..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.c
+++ /dev/null
@@ -1,4424 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-        this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "tpm_sysfs_setup.h"
-
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-extern struct semaphore    tpm_sfs_2_ioctl_sem;
-extern tpm_ioctl_mng_t     tpm_sfs_2_ioctl_command;
-#endif
-
-const char *sw_qos_init_pri_str[] =
-{
-    "USE_PORTS_DEF",
-    "TAG_PRI_ONLY",
-    "IP_PRI_ONLY",
-    "TAG_AND_IP_PRI",
-    "UNKNOWN"
-};
-
-
-/* ========================================================================== */
-/*                            Debug SW Attributes                                 */
-/* ========================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_sw_set_global_reg
-*
-* DESCRIPTION:
-*       This function set value to the global register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_global_reg
-(
-    IN uint32_t             owner_id,
-    IN uint8_t              regAddr,
-    IN uint16_t             data
-)
-{
-    tpm_sw_set_global_reg(owner_id, regAddr, data);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_global_reg
-*
-* DESCRIPTION:
-*           This function gets value from the global register.
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_global_reg
-(
-    IN  uint32_t             owner_id,
-    IN  uint8_t              regAddr
-)
-{
-    uint16_t             data;
-
-    tpm_sw_get_global_reg(owner_id, regAddr, &data);
-
-    printk(KERN_INFO " regAddr[0x%x] data[0x%x]\n",regAddr,data);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_reg
-*
-* DESCRIPTION:
-*       This function sets value to the port register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_reg
-(
-    IN uint32_t             owner_id,
-    IN uint32_t             lport,
-    IN uint8_t              regAddr,
-    IN uint16_t             data
-)
-{
-    tpm_sw_set_port_reg(owner_id, lport, regAddr, data);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_reg
-*
-* DESCRIPTION:
-*           This function gets value from the port register.
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_reg
-(
-    IN  uint32_t            owner_id,
-    IN  uint8_t             lport,
-    IN  uint8_t             regAddr
-)
-{
-    uint16_t             data;
-
-    tpm_sw_get_port_reg(owner_id, lport,regAddr, &data);
-
-    printk(KERN_INFO " lport[%d] regAddr[0x%x] data[0x%x]\n",lport, regAddr, data);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_cntrs
-*
-* DESCRIPTION:
-*           This function gets all counters of the given port
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_cntrs
-(
-    IN  uint32_t            owner_id,
-    IN  uint8_t             lport
-)
-{
-
-    tpm_sw_print_port_counters(owner_id, lport);
-
-    return;
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_get_fdb
-*
-* DESCRIPTION:
-*           This function gets all counters of the given port
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       db_num      - ATU MAC Address Database number. If multiple address
-*                     databases are not being used, DBNum should be zero.
-*                     If multiple address databases are being used, this value
-*                     should be set to the desired address database number.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_fdb
-(
-    IN  uint32_t            owner_id,
-    IN  uint16_t            db_num
-)
-{
-
-    tpm_sw_get_fdb(owner_id,db_num);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_init
-*
-* DESCRIPTION:
-*           This function init Amber DB
-* INPUTS:
-*       NONE.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       There is a temprorary function.
-*
-*******************************************************************************/
-
-void sfs_tpm_sw_init
-(
-    void
-)
-{
-    tpm_sw_init();
-
-    return;
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_set_debug_trace_flag
-*
-* DESCRIPTION:
-*           This function sets TPM trace flag
-* INPUTS:
-*       NONE.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-
-void sfs_tpm_sw_set_debug_trace_flag
-(
-    IN  uint32_t    enDis
-)
-{
-    tpm_sw_set_debug_trace_flag(enDis);
-
-    return;
-}
-
-
-/*******************************************************************************
-**
-**  sfs_tpm_sw_get_help_show
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_dbg_help_show(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "========================================================================================================================\n");
-    off += sprintf(buf+off, "                                          Debug Switch Commands\n");
-    off += sprintf(buf+off, "                                          Insert all parameters in Decimal\n");
-    off += sprintf(buf+off, "========================================================================================================================\n");
-    off += sprintf(buf+off, "cat help_sw_dbg                                                    - show this help\n");
-    off += sprintf(buf+off, "echo [owner_id] [regAddr] [data]                > set_global_reg   - sets value to the global register\n");
-    off += sprintf(buf+off, "echo [owner_id] [regAddr]                       > get_global_reg   - gets value of the global register\n");
-    off += sprintf(buf+off, "echo [owner_id] [lport 1 -3] [regAddr]  [data]  > set_port_reg     - sets value to the port register\n");
-    off += sprintf(buf+off, "echo [owner_id] [lport 1 -3] [regAddr]          > get_port_reg     - gets value of the port register\n");
-    off += sprintf(buf+off, "echo [owner_id] [lport 1 -3]                    > get_port_cntrs   - gets and clear all RMON counters of the given port\n");
-    off += sprintf(buf+off, "echo [owner_id] [db_num = 0 or other]           > get_fdb          - gets all FDB table.\n");
-    off += sprintf(buf+off, "echo                                            > sw_init          - Init the Amber SW API DB\n");
-    off += sprintf(buf+off, "echo [debug_trace 0 - 1]                        > debug_trace      - Enable/disable TPM switch trace\n");
-    off += sprintf(buf+off, "========================================================================================================================\n");
-
-    return(off);
-}
-
-
-static ssize_t dbg_sw_store(struct device *dev,
-                         struct device_attribute *attr,
-                         const char *buf, size_t len)
-{
-    const char* name = attr->attr.name;
-//     unsigned long flags  = 0;
-    unsigned int  param1 = 0;
-    unsigned int  param2 = 0;
-    unsigned int  param3 = 0;
-    unsigned int  param4 = 0;
-
-    if (!capable(CAP_NET_ADMIN))
-    return -EPERM;
-
-    sscanf(buf, "%d %d %d %d", &param1, &param2,&param3,&param4);
-
-    printk(KERN_INFO "param1[%d],param2[%d],param3[%d],param4[%d]\n",
-          param1,param2,param3,param4);
-
-//     raw_local_irq_save(flags);
-
-    if (!strcmp(name, "set_global_reg"))
-        sfs_tpm_sw_set_global_reg((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "get_global_reg"))
-        sfs_tpm_sw_get_global_reg((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "set_port_reg"))
-        sfs_tpm_sw_set_port_reg((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3,(MV_U8)param4);
-
-    else if (!strcmp(name, "get_port_reg"))
-        sfs_tpm_sw_get_port_reg((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "get_port_cntrs"))
-        sfs_tpm_sw_get_port_cntrs((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_fdb"))
-        sfs_tpm_sw_get_fdb((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "sw_init"))
-        sfs_tpm_sw_init();
-
-    else if (!strcmp(name, "debug_trace"))
-        sfs_tpm_sw_set_debug_trace_flag((MV_U32)param1);
-
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-//     raw_local_irq_restore(flags);
-
-    return(len);
-}
-
-/* ========================================================================== */
-/*                            Info Commands                                   */
-/* ========================================================================== */
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static ssize_t dbg_sw_show(struct device *dev,
-                        struct device_attribute *attr,
-                        char *buf)
-{
-  const char* name = attr->attr.name;
-
-  if (!capable(CAP_NET_ADMIN))
-      return -EPERM;
-
-  if (!strcmp(name, "help_sw_dbg"))
-      return (sfs_tpm_sw_dbg_help_show(buf));
-
-  return 0;
-}
-#else
-static ssize_t dbg_sw_show(struct device *dev,
-                           struct device_attribute *attr,
-                           char *buf)
-{
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __FUNCTION__);
-	return 0;
-}
-#endif
-
-/* ========================================================================== */
-/*                            get SW Attributes                                 */
-/* ========================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_admin
-*
-* DESCRIPTION:
-*       This function return the port administration state, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_admin
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool port_state;
-
-    tpm_phy_get_port_admin_state(owner_id, (tpm_src_port_type_t)lport, &port_state);
-
-    printk(KERN_INFO "The administration state of lport[%d] is [%s]\n", lport, ((true==port_state)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_link_status
-*
-* DESCRIPTION:
-*       This function return the port flow control status, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_link_status
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-	bool link_status;
-
-    tpm_phy_get_port_link_status(owner_id, (tpm_src_port_type_t)lport, &link_status);
-
-    printk(KERN_INFO "The current link status of lport[%d] is [%s]\n", lport, ((true==link_status)? "UP":"DOWN"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_autoneg
-*
-* DESCRIPTION:
-*       This function return the port auto negotiation state and mode.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_autoneg
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool               autoneg_state;
-    tpm_autoneg_mode_t autoneg_mode;
-
-    tpm_phy_get_port_autoneg_mode(owner_id, (tpm_src_port_type_t)lport, &autoneg_state, &autoneg_mode);
-
-    printk(KERN_INFO "The auto negotiation state of lport[%d] is [%s], mode[%d](0:SPEED_AUTO_DUPLEX_AUTO, 1:SPEED_1000_DUPLEX_AUTO, 2:SPEED_100_DUPLEX_AUTO, 3:SPEED_10_DUPLEX_AUTO, 4:SPEED_AUTO_DUPLEX_FULL, 5:SPEED_AUTO_DUPLEX_HALF, 6:SPEED_1000_DUPLEX_FULL, 7:SPEED_1000_DUPLEX_HALF, 8:SPEED_100_DUPLEX_FULL, 9:SPEED_100_DUPLEX_HALF, 10:SPEED_10_DUPLEX_FULL, 11:SPEED_10_DUPLEX_HALF)\n", lport, ((true==autoneg_state)? "enabled":"disabled"), autoneg_mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_duplex_config
-*
-* DESCRIPTION:
-*       This function return the port duplex mode, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_duplex_config
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool duplex_mode;
-
-    tpm_phy_get_port_duplex_mode(owner_id, (tpm_src_port_type_t)lport, &duplex_mode);
-
-    printk(KERN_INFO "The duplex configuration of lport[%d] is [%s]\n", lport, ((true==duplex_mode)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_duplex_status
-*
-* DESCRIPTION:
-*       This function return the port duplex current status, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_duplex_status
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool duplex_status;
-
-    tpm_phy_get_port_duplex_status(owner_id, (tpm_src_port_type_t)lport, &duplex_status);
-
-    printk(KERN_INFO "The duplex status of lport[%d] is [%s]\n", lport, ((true==duplex_status)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_fc_config
-*
-* DESCRIPTION:
-*       This function return the port flow control configuration state, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_fc_config
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool fc_state;
-
-    tpm_phy_get_port_flow_control_support(owner_id, (tpm_src_port_type_t)lport, &fc_state);
-
-    printk(KERN_INFO "The flow control configuration of lport[%d] is [%s]\n", lport, ((true==fc_state)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_fc_status
-*
-* DESCRIPTION:
-*       This function return the port flow control status, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_fc_status
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    bool fc_state;
-
-    tpm_phy_get_port_flow_control_state(owner_id, (tpm_src_port_type_t)lport, &fc_state);
-
-    printk(KERN_INFO "The flow control status of lport[%d] is [%s]\n", lport, ((true==fc_state)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_speed_config
-*
-* DESCRIPTION:
-*       This function return the port speed configuration state, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_speed_config
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    tpm_phy_speed_t speed;
-
-    tpm_phy_get_port_speed(owner_id, (tpm_src_port_type_t)lport, &speed);
-
-    printk(KERN_INFO "The speed configuration of lport[%d] is [%d]('0'-10M, '1'-100M, '2'-1000M)\n", lport, speed);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_speed_status
-*
-* DESCRIPTION:
-*       This function return the port speed status, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_speed_status
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    MV_U32   speed;
-
-    tpm_phy_get_port_speed_mode(owner_id, (tpm_src_port_type_t)lport, &speed);
-
-    printk(KERN_INFO "The speed status of lport[%d] is [%d]('0'-10M, '1'-100M, '2'-1000M, '3'-UNKOWN)\n", lport, speed);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_isolate_vector
-*
-* DESCRIPTION:
-*       This function return the port isolation vector, enabled or isolated.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_isolate_vector
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    MV_U32   vector;
-
-    tpm_sw_get_isolate_eth_port_vector(owner_id, (tpm_src_port_type_t)lport, &vector);
-
-    printk(KERN_INFO "The isolation vector of lport[%d] is [0x%02x]('0'-isolate, '1'-enable, bit0-UNI0, bit1-UNI1...)\n", lport, vector);
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_loopback
-*
-* DESCRIPTION:
-*       This function return the port loopback status, enabled or disabled.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*       mode         - 0:internal loopback, 1:external loopback.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_loopback
-(
-    MV_U32                owner_id,
-    MV_U32                lport,
-    MV_U32                mode
-)
-{
-    tpm_phy_loopback_mode_t loopback_mode;
-    bool                    status;
-
-    if(mode > TPM_PHY_EXTERNAL_LOOPBACK)
-        loopback_mode = TPM_PHY_EXTERNAL_LOOPBACK;
-    else
-        loopback_mode = (tpm_phy_loopback_mode_t)mode;
-
-    tpm_phy_get_port_loopback(owner_id, (tpm_src_port_type_t)lport, loopback_mode, &status);
-
-    printk(KERN_INFO "The [%d]('0'-internal, '1'-external) loopback status of lport[%d] is [%s]\n", loopback_mode, lport, ((true==status)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_mac_age_time
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_mac_age_time
-(
-    IN uint32_t                 owner_id
-)
-{
-    MV_U32      time_out;
-
-    tpm_sw_get_mac_age_time(owner_id, &time_out);
-
-    printk(KERN_INFO "The time out is [%d]\n",time_out);
-
-     return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_max_macs
-*
-* DESCRIPTION:
-*       This function return the limit number of MAC addresses per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_max_macs
-(
-    MV_U32                owner_id,
-    MV_U32                lport
-)
-{
-    uint32_t               limit;
-
-    tpm_sw_get_port_max_macs(owner_id, (tpm_src_port_type_t)lport, &limit);
-
-    printk(KERN_INFO "The limit number of MAC addresses per lport[%d] is [%d]\n",lport,limit);
-
-    return;
-
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_mac_learn
-*
-* DESCRIPTION:
-*       This function return MAC learning state.
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_mac_learn
-(
-    MV_U32      owner_id,
-    MV_U32      lport
-)
-{
-    bool   status;
-
-    tpm_sw_get_mac_learn(owner_id, (tpm_src_port_type_t)lport, &status);
-
-    printk(KERN_INFO "The MAC learning status of lport[%d] is [%s]\n", lport, ((true==status)? "enabled":"disabled"));
-
-    return;
-
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_flooding
-*
-* DESCRIPTION:
-*       This function gets Forward Unknown mode of a switch lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       egress_port     - Egress lport for applying the flood settings.
-
-*
-* OUTPUTS:
-*       mode  - NONE.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_flooding
-(
-    MV_U32           owner_id,
-    MV_U32           lport
-)
-{
-    uint8_t          mode;
-
-    tpm_sw_get_port_flooding(owner_id, (tpm_src_port_type_t)lport, TPM_FLOOD_UNKNOWN_UNICAST, &mode);
-
-    printk(KERN_INFO "The Forward Unknown mode of a switch lport[%d] is [%d]\n",lport,mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_mc_flooding
-*
-* DESCRIPTION:
-*       This function gets Forward Unknown Multicast mode of a switch lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       egress_port     - Egress lport for applying the flood settings.
-
-*
-* OUTPUTS:
-*       mode  - NONE.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_mc_flooding
-(
-    MV_U32           owner_id,
-    MV_U32           lport
-)
-{
-    uint8_t          mode;
-
-    tpm_sw_get_port_flooding (owner_id, (tpm_src_port_type_t)lport, TPM_FLOOD_UNKNOWN_MULTI_BROAD_CAST,&mode);
-
-    printk(KERN_INFO "The Forward Unknown Multicast mode of a switch lport[%d] is [%d]\n",lport,mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_bc_flooding
-*
-* DESCRIPTION:
-*       This function gets Forward Broadcast mode of a switch lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       egress_port     - Egress lport for applying the flood settings.
-
-*
-* OUTPUTS:
-*       mode  - NONE.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_bc_flooding
-(
-    MV_U32           owner_id
-)
-{
-
-    bool  mode;
-
-    tpm_sw_get_broadcast_flood(owner_id, &mode);
-
-    printk(KERN_INFO "The Broadcast flooding is [%s]\n",(mode==true)?"allowed":"forbidden");
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_tagged
-*
-* DESCRIPTION:
-*       The API gets DiscardTagged bit for the given lport
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         -  lport for applying the filtering of tagged packets.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_tagged
-(
-    MV_U32    owner_id,
-    MV_U32    lport
-)
-{
-
-    uint32_t     mode;
-
-    tpm_sw_get_port_tagged(owner_id, (tpm_src_port_type_t)lport, &mode);
-
-    printk(KERN_INFO "The DiscardTagged bit for the given lport[%d] is [%d]\n",lport, mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_untagged
-*
-* DESCRIPTION:
-*       The API  gets DiscardUntagged bit for the given lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         -  lport for applying the filtering of tagged packets.
-
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_untagged
-(
-    MV_U32    owner_id,
-    MV_U32    lport
-)
-{
-
-    uint32_t     mode;
-
-    tpm_sw_get_port_untagged(owner_id, (tpm_src_port_type_t)lport, &mode);
-
-    printk(KERN_INFO "The DiscardUnTagged bit for the given lport[%d] is [%d]\n",lport, mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_def_vlan
-*
-* DESCRIPTION:
-*       The API gets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       lport       - lport for applying the filtering of tagged packets.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_def_vlan
-(
-    MV_U32    owner_id,
-    MV_U32    lport
-)
-{
-    MV_U16    vid;
-    tpm_sw_get_port_def_vlan(owner_id,(tpm_src_port_type_t)lport,&vid);
-    printk(KERN_INFO "The default vlan id of port[%d] is [%d]\n",lport,vid);
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_def_pri
-*
-* DESCRIPTION:
-*       The API gets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       lport       - lport for applying the filtering of tagged packets.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_def_pri
-(
-    MV_U32    owner_id,
-    MV_U32    lport
-)
-{
-    MV_U8     pri;
-
-    tpm_sw_get_port_def_pri(owner_id,(tpm_src_port_type_t)lport,&pri);
-    printk(KERN_INFO "The default priority of port[%d] is [%d]\n",lport,pri);
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_vid
-*
-* DESCRIPTION:
-*       The API look for vid in VTU DB.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       vid     -  lport for adding the vid.
-
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_vid
-(
-    MV_U32    owner_id,
-    MV_U32    vid
-)
-{
-
-  MV_U32 found;
-
-  tpm_sw_port_get_vid(owner_id, (tpm_src_port_type_t)vid ,&found);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_vid_filter
-*
-* DESCRIPTION:
-*        This routine gets protected mode of a switch lport.
-*        When this mode is set to GT_TRUE, frames are allowed to egress lport
-*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*        by the lport's VLANTable if 802.1Q is enabled on the lport. Both must
-*        allow the frame to Egress.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport        -  lport for setting the filtering mode.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*        NONE
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void  sfs_tpm_sw_get_port_vid_filter
-(
-    MV_U32    owner_id,
-    MV_U32    lport
-)
-{
-
-    uint32_t     mode;
-
-    tpm_sw_get_vid_filter_per_port(owner_id, (tpm_src_port_type_t)lport, &mode);
-
-    printk(KERN_INFO "The protected mode of a switch lport[%d] is [%d]\n", lport, mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*        This routine retrieves the port's ingress data limit based on burst size.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       uni_port - uni lport for configuring the ingress policer function.
-
-*
-* OUTPUTS:
-*       NONE.
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_uni_ingr_police_rate
-(
-    MV_U32      owner_id,
-    MV_U32      uni_port
-)
-{
-    MV_U32  count_mode;
-    MV_U32  cir;
-    MV_U32  cbs;
-    MV_U32  ebs;
-
-    tpm_sw_get_uni_ingr_police_rate(owner_id,(tpm_src_port_type_t)uni_port,&count_mode,&cir, &cbs, &ebs);
-
-    printk(KERN_INFO "The uni_port[%d] ingress data limit mode[%d], cir[%d] cbs[%d] ebs[%d]\r\n",
-           uni_port, count_mode, cir, cbs, ebs);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_uni_tc_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures a policer function for a traffic class for an Ethernet UNI lport.
-*       There are 4 globally defined traffic classes in the integrated switch.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       uni_port - uni lport for configuring the ingress policer function.
-*       tc       - traffic class ( a combination of p-bits and DSCP values).
-*
-* OUTPUTS:
-*       NONE.
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_uni_tc_ingr_police_rate
-(
-    MV_U32      owner_id,
-    MV_U32      uni_port
-
-)
-{
-	uint32_t	cir[5];
-	uint32_t	tc[5];
-	uint32_t	cbs[5];
-	uint32_t	i;
-
-	tpm_sw_get_uni_tc_ingr_police_rate(owner_id,(tpm_src_port_type_t)uni_port,tc,cir,cbs);
-
-	printk(KERN_INFO "The uni_port[%d]: \n",uni_port);
-	for(i = 0; i < 5; i ++) {
-		if(tc[i])
-			printk(KERN_INFO "                ingress data limit[%d] for tc[0x%x]\n", cir[i] ,tc[i]);
-	}
-
-	return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API return the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       trg_lport            - uni lport for configuring the egress rate limit.
-
-*
-* OUTPUTS:
-*       NONE.
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_uni_egr_rate_limit
-(
-    MV_U32              owner_id,
-    MV_U32              trg_lport
-)
-{
-    tpm_limit_mode_t  mode;
-    MV_U32            frame_rate_limit_val;
-
-    tpm_sw_get_uni_egr_rate_limit(owner_id,(tpm_src_port_type_t)trg_lport,&mode, &frame_rate_limit_val);
-
-    printk(KERN_INFO "The egress frame rate limit is [%d] mode[%d] for trg_lport[%d]\n",
-           frame_rate_limit_val, mode, trg_lport);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_vlan_ports
-*
-* DESCRIPTION:
-*           This routine gets the port VLAN group port membership list.
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       lport               - logical port
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_vlan_ports
-(
-    IN uint32_t                 owner_id,
-    IN uint32_t                 lport
-)
-{
-   uint32_t             memPorts[TPM_MAX_NUM_PORTS];
-   uint8_t              memPortsLen;
-   uint32_t             i;
-
-   memset(memPorts, 0, sizeof(GT_LPORT)*TPM_MAX_NUM_PORTS);
-
-   tpm_sw_get_port_vlan_ports(owner_id, (tpm_src_port_type_t)lport, memPorts, &memPortsLen);
-
-   for (i = 0; i < memPortsLen; i++)
-   {
-       if (memPorts[i] > 0)
-       {
-           printk("memPorts[%d] = %02d\n\r",i,memPorts[i]);
-       }
-
-   }
-
-     return;
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_get_ingress_limit_mode
-*
-* DESCRIPTION:
-*           This routine gets the port's rate control ingress limit mode.
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       lport               - logical port
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_ingress_limit_mode
-(
-    uint32_t             owner_id,
-    uint32_t             lport
-)
-{
-    GT_RATE_LIMIT_MODE   mode;
-
-
-   tpm_sw_get_ingress_limit_mode(owner_id, (tpm_src_port_type_t)lport, &mode);
-
-   printk("lport [%d] mode[%d]\n\r",lport,mode);
-
-   return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_priority_selection
-*
-* DESCRIPTION:
-*       This function gets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to set init pri.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_priority_selection
-(
-    uint32_t owner_id,
-    uint8_t  lport
-)
-{
-    uint8_t init_pri;
-    bool    tag_if_both;
-
-    tpm_sw_get_priority_selection(owner_id,(tpm_src_port_type_t)lport,&init_pri,&tag_if_both);
-
-    printk("UNI port[%d] init_pri[%s] tag_if_both[%s]\n\r",lport,
-            sw_qos_init_pri_str[init_pri < PRI_SEL_TYPE_MAX ? init_pri : PRI_SEL_TYPE_MAX], (tag_if_both==true)?"TRUE":"FALSE");
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets tag priority mapping.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       tag_pri     - Source tag priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_tag_pri_mapping
-(
-    IN  uint32_t owner_id,
-    IN  uint8_t  tag_pri
-)
-{
-    uint8_t q_pri;
-
-    tpm_sw_get_tag_pri_mapping(owner_id,tag_pri,&q_pri);
-
-    printk("tag_pri[%d] -> q_pri[%d]\n\r",tag_pri,q_pri);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets the queue priority for a dscp value mapping to.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       dscp        - Source dscp value.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_ip_pri_mapping
-(
-    IN  uint32_t owner_id,
-    IN  uint8_t  dscp
-)
-{
-    uint8_t q_pri;
-
-    tpm_sw_get_ip_pri_mapping(owner_id,dscp,&q_pri);
-
-    printk("dscp[%d] -> q_pri[%d]\n\r",dscp,q_pri);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_gmac_mtu
-*
-* DESCRIPTION:
-*       This function gets the MTU of GMAC.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       gmac        - GMAC, '0'-GMAC0, '1'-GMAC1, '02'-PONMAC, '3'-switch.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_gmac_mtu
-(
-    IN  uint32_t  owner_id,
-    IN  uint32_t  gmac
-)
-{
-    tpm_mru_type_t type;
-    uint32_t       mtu;
-
-    if(gmac > TPM_NETA_MTU_SWITCH)
-        type = TPM_NETA_MTU_SWITCH;
-    else
-        type = (tpm_mru_type_t)gmac;
-
-    tpm_get_mtu_size(owner_id, type, &mtu);
-
-    printk("The MTU of GMAC[%d]('0'-GMAC0, '1'-GMAC1, '02'-PONMAC, '3'-switch) is [%d]\n\r", gmac, mtu);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_get_port_mirror
-*
-* DESCRIPTION:
-*       This function gets port mirror state.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - src UNI port(1-4).
-*       dst_port    - dst UNI port(1-4).
-*       mode        - mirror mode, '0'-ingress mirror, '1'-egress mirror.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_get_port_mirror
-(
-    IN  uint32_t  owner_id,
-    IN  uint32_t  src_port,
-    IN  uint32_t  dst_port,
-    IN  uint32_t  mode
-)
-{
-    tpm_sw_mirror_type_t mirror_mode;
-    bool                 mirror_state;
-
-    if(mode > TPM_SW_MIRROR_EGRESS)
-        mirror_mode = TPM_SW_MIRROR_EGRESS;
-    else
-        mirror_mode = (tpm_sw_mirror_type_t)mode;
-
-    tpm_sw_get_port_mirror(owner_id, src_port, dst_port, mirror_mode, &mirror_state);
-
-    printk("The src_port[%d] dst_port[%d] mode[%d]('0'-ingress, '1'-egress) mirror status is [%s]\n\r", src_port, dst_port, mirror_mode, ((true==mirror_state)? "enabled":"disabled"));
-}
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-/*******************************************************************************
-**
-**  sfs_tpm_sw_get_help_show
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_get_help_show(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "========================================================================================================================\n");
-    off += sprintf(buf+off, "                                          Configuration Switch Commands\n");
-    off += sprintf(buf+off, "                                          Insert all parameters in Decimal\n");
-    off += sprintf(buf+off, "========================================================================================================================\n");
-    off += sprintf(buf+off, "cat help_sw_get_info                                                  - show this help\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_admin              - get port administration state\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_link_status        - get port current link status\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_autoneg            - get port auto negotiation state and mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_duplex_config      - get port duplex configuration\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_duplex_status      - get port duplex current status\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_fc_config          - get port flow control configuration\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_fc_status          - get port flow control current status\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_speed_config       - get port speed configuration\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_speed_status       - get port speed current status\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_isolate_vector     - get port isolation vector\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [mode]   > get_port_loopback           - get port loopback status, mode('0'-internal, '1'-external)\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id]                         > get_mac_age_time            - get the MAC aging time\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_max_macs           - get port maximum number of allowed MAC address to be learned\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_mac_learn          - get port MAC learning state, disabled or enabled\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_flooding           - get Forward Unknown mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_mc_flooding        - get Forward Unknown mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id]                         > get_bc_flooding             - get Forward Unknown mode\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_tagged             - get DiscardTagged bits\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_untagged           - get DiscardUntagged bit\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_vid_filter         - get the filtering mod VID\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_def_vlan           - get port default vlan\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_def_pri            - get port default priority\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [vid 0-4095]            > get_port_vid                - get port VID if it exist\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_uni_ingr_police_rate    - get the port's ingress data limit by burst size\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_uni_tc_ingr_police_rate - get the port's ingress data limit for tc\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_uni_egr_rate_limit      - get the port's egress frame rate limit\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_port_vlan_ports         - get the port VLAN group port membership list\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]          > get_init_pri                - get initial priority\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [pri 0-7]               > get_tag_pri_mapping         - get tag pri mapping\n");
-    off += sprintf(buf+off, "echo [owner_id] [dscp 0-63]             > get_ip_pri_mapping          - get ip pri mapping\n");
-    off += sprintf(buf+off, "echo [owner_id] [gmac]                  > get_gmac_mtu                - get GMAC MTU ('0'-GMAC0, '1'-GMAC1, '2'-PMAC, '3'-switch)\n");
-    off += sprintf(buf+off, "echo [owner_id] [sport][dport][mode]    > get_port_mirror             - get port mirro, src port/dst port(uni port 1-4), mode('0'-ingress, '1'-egress)\n");
-    off += sprintf(buf+off, "========================================================================================================================\n");
-
-    return(off);
-}
-#endif
-
-/* ========================================================================== */
-/*                            Info Group                                      */
-/* ========================================================================== */
-/******************************************************************************/
-
-/* ========================================================================== */
-/*                            Info Commands                                   */
-/* ========================================================================== */
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static ssize_t get_sw_show(struct device *dev,
-                        struct device_attribute *attr,
-                        char *buf)
-{
-  const char* name = attr->attr.name;
-
-  if (!capable(CAP_NET_ADMIN))
-      return -EPERM;
-
-  if (!strcmp(name, "help_sw_get_info"))
-      return (sfs_tpm_sw_get_help_show(buf));
-
-  return 0;
-}
-#else
-static ssize_t get_sw_show(struct device *dev,
-                           struct device_attribute *attr,
-                           char *buf)
-{
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __FUNCTION__);
-	return 0;
-}
-#endif
-
-static ssize_t get_sw_store(struct device *dev,
-                             struct device_attribute *attr,
-                             const char *buf, size_t len)
-{
-    const char* name = attr->attr.name;
-//     unsigned long flags;
-    unsigned int  param1 = 0;
-    unsigned int  param2 = 0;
-    unsigned int  param3 = 0;
-    unsigned int  param4 = 0;
-
-    if (!capable(CAP_NET_ADMIN))
-    return -EPERM;
-
-    if (!strcmp(name, "get_port_mirror"))
-    {
-        sscanf(buf, "%d %d %d %d",
-               &param1, &param2, &param3, &param4);
-    }
-    else
-    {
-        sscanf(buf, "%d %d %d", &param1, &param2, &param3);
-    }
-
-    printk(KERN_INFO "param1[%d],param2[%d],param3[%d]\n",param1,param2,param3);
-
-//     raw_local_irq_save(flags);
-
-    if (!strcmp(name, "get_port_admin"))
-        sfs_tpm_sw_get_port_admin((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_link_status"))
-        sfs_tpm_sw_get_port_link_status((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_autoneg"))
-        sfs_tpm_sw_get_port_autoneg((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_duplex_config"))
-        sfs_tpm_sw_get_port_duplex_config((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_duplex_status"))
-        sfs_tpm_sw_get_port_duplex_status((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_fc_config"))
-        sfs_tpm_sw_get_port_fc_config((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_fc_status"))
-        sfs_tpm_sw_get_port_fc_status((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_speed_config"))
-        sfs_tpm_sw_get_port_speed_config((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_speed_status"))
-        sfs_tpm_sw_get_port_speed_status((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_isolate_vector"))
-        sfs_tpm_sw_get_port_isolate_vector((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_loopback"))
-        sfs_tpm_sw_get_port_loopback((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "get_port_max_macs"))
-        sfs_tpm_sw_get_port_max_macs((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_mac_learn"))
-        sfs_tpm_sw_get_port_mac_learn((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_flooding"))
-        sfs_tpm_sw_get_port_flooding((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_mc_flooding"))
-        sfs_tpm_sw_get_port_mc_flooding((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_bc_flooding"))
-        sfs_tpm_sw_get_bc_flooding((MV_U32)param1);
-
-    else if (!strcmp(name, "get_port_tagged"))
-        sfs_tpm_sw_get_port_tagged((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_untagged"))
-      sfs_tpm_sw_get_port_untagged((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_def_vlan"))
-      sfs_tpm_sw_get_port_def_vlan((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_def_pri"))
-        sfs_tpm_sw_get_port_def_pri((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_vid"))
-        sfs_tpm_sw_get_port_vid((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_vid_filter"))
-      sfs_tpm_sw_get_port_vid_filter((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_uni_ingr_police_rate"))
-        sfs_tpm_sw_get_uni_ingr_police_rate((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_uni_tc_ingr_police_rate"))
-        sfs_tpm_sw_get_uni_tc_ingr_police_rate((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_uni_egr_rate_limit"))
-        sfs_tpm_sw_get_uni_egr_rate_limit((MV_U32)param1, (MV_U32)param2);
-
-    else if (!strcmp(name, "get_mac_age_time"))
-        sfs_tpm_sw_get_mac_age_time((MV_U32)param1);
-
-    else if (!strcmp(name, "get_port_vlan_ports"))
-        sfs_tpm_sw_get_port_vlan_ports((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_port_vlan_ports"))
-        sfs_tpm_sw_get_port_vlan_ports((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_ingress_limit_mode"))
-        sfs_tpm_sw_get_ingress_limit_mode((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "get_init_pri"))
-        sfs_tpm_sw_get_priority_selection((MV_U32)param1,(MV_U8)param2);
-
-    else if (!strcmp(name, "get_tag_pri_mapping"))
-        sfs_tpm_sw_get_tag_pri_mapping((MV_U32)param1,(MV_U8)param2);
-
-    else if (!strcmp(name, "get_ip_pri_mapping"))
-        sfs_tpm_sw_get_ip_pri_mapping((MV_U32)param1,(MV_U8)param2);
-
-    else if (!strcmp(name, "get_gmac_mtu"))
-        sfs_tpm_sw_get_gmac_mtu((MV_U32)param1,(MV_U8)param2);
-
-    else if (!strcmp(name, "get_port_mirror"))
-        sfs_tpm_sw_get_port_mirror((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4);
-
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-//     raw_local_irq_restore(flags);
-
-    return(len);
-}
-
-/* ========================================================================== */
-/*                            Set SW Attributes                                 */
-/* ========================================================================== */
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_admin
-*
-* DESCRIPTION:
-*       This function set the port administration state
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       state         - port administration state, 1:enable, 0:disable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_admin
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               state
-)
-{
-    bool admin_state;
-
-    admin_state = ((1 == state) ? true: false);
-    tpm_phy_set_port_admin_state(owner_id, (tpm_src_port_type_t)lport, admin_state);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_autoneg
-*
-* DESCRIPTION:
-*       This function set the port auto negotiation
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       state         - port auto negotiation  state, 1:enable, 0:disable.
-*       mode          - port auto negotiation  mode:
-*                       Auto for both speed and duplex.
-*                       Auto for speed only and Full duplex.
-*                       Auto for speed only and Half duplex. (1000Mbps is not supported)
-*                       Auto for duplex only and speed 1000Mbps.
-*                       Auto for duplex only and speed 100Mbps.
-*                       Auto for duplex only and speed 10Mbps.
-*                       1000Mbps Full duplex.
-*                       100Mbps Full duplex.
-*                       100Mbps Half duplex.
-*                       10Mbps Full duplex.
-*                       10Mbps Half duplex.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_autoneg
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               state,
-    MV_U32               mode
-)
-{
-    bool               autoneg_state;
-    tpm_autoneg_mode_t autoneg_mode;
-
-    autoneg_state = ((1 == state) ? true: false);
-
-    autoneg_mode = ((mode > TPM_SPEED_10_DUPLEX_HALF ) ? TPM_SPEED_10_DUPLEX_HALF: (tpm_autoneg_mode_t)mode);
-    tpm_phy_set_port_autoneg_mode(owner_id, (tpm_src_port_type_t)lport, autoneg_state, autoneg_mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_restart_autoneg
-*
-* DESCRIPTION:
-*       This function restart the port auto negotiation
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_restart_autoneg
-(
-    MV_U32               owner_id,
-    MV_U32               lport
-)
-{
-    tpm_phy_restart_port_autoneg(owner_id, (tpm_src_port_type_t)lport);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_duplex
-*
-* DESCRIPTION:
-*       This function set the port duplex mode
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       mode          - port duplex mode, 1:enable, 0:disable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_duplex
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               mode
-)
-{
-    bool duplex_mode;
-
-    duplex_mode = ((1 == mode) ? true: false);
-    tpm_phy_set_port_duplex_mode(owner_id, (tpm_src_port_type_t)lport, duplex_mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_fc
-*
-* DESCRIPTION:
-*       This function set the port flow control
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       state         - port flow control configuration, 1:enable, 0:disable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_fc
-(
-    MV_U32      owner_id,
-    MV_U32      lport,
-    MV_U32      state
-)
-{
-    bool fc_state;
-
-    fc_state = ((1 == state) ? true: false);
-    tpm_phy_set_port_flow_control_support(owner_id, (tpm_src_port_type_t)lport, fc_state);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_speed
-*
-* DESCRIPTION:
-*       This function set the port speed
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       speed_mode    - speed mode, '0'-10M, '1'-100M, '2'-1000M.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_speed
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               speed_mode
-)
-{
-    tpm_phy_speed_t speed;
-
-    if((tpm_phy_speed_t)speed_mode > TPM_PHY_SPEED_1000_MBPS)
-        speed = (tpm_phy_speed_t)TPM_PHY_SPEED_1000_MBPS;
-    else
-        speed = (tpm_phy_speed_t)speed_mode;
-
-    tpm_phy_set_port_speed(owner_id, (tpm_src_port_type_t)lport, speed);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_isolate_vector
-*
-* DESCRIPTION:
-*       This function set the port isolation vector
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       vector        - '0'-isolate, '1'-enable, bit0-UNI0, bit1-UNI1...
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_isolate_vector
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               vector
-)
-{
-    tpm_sw_set_isolate_eth_port_vector(owner_id, (tpm_src_port_type_t)lport, vector);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_loopback
-*
-* DESCRIPTION:
-*       This function set the port loopback
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       mode          - '0'-internal loopback, '1'-external loopback
-*       state         - '0'-disable, '1'-enable
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_loopback
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               mode,
-    MV_U32               state
-)
-{
-    tpm_phy_loopback_mode_t loopback_mode;
-    bool                    loopback_state;
-
-    if(mode > TPM_PHY_EXTERNAL_LOOPBACK)
-        loopback_mode = TPM_PHY_EXTERNAL_LOOPBACK;
-    else
-        loopback_mode = (tpm_phy_loopback_mode_t)mode;
-
-    loopback_state = ((1 == state) ? true: false);
-
-    tpm_phy_set_port_loopback(owner_id, (tpm_src_port_type_t)lport, loopback_mode, loopback_state);
-
-    return;
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-void tpm_sw_add_static_mac_bounce(uint32_t owner_id,
-				uint32_t lport,
-				uint8_t static_mac[6])
-{
-	tpm_ioctl_sw_mac_security_t *tpm_sw_mac_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_sw_mac_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_SW_SECURITY_SECTION;
-	tpm_sw_mac_set->sw_security_cmd = MV_TPM_IOCTL_SW_ADD_STATIC_MAC;
-	tpm_sw_mac_set->owner_id = owner_id;
-	tpm_sw_mac_set->port = lport;
-	memcpy(tpm_sw_mac_set->static_mac, (void*)static_mac, sizeof(uint8_t)*6);
-
-	up(&tpm_sfs_2_ioctl_sem);
-}
- #define _tpm_sw_add_static_mac tpm_sw_add_static_mac_bounce
-#else
- #define _tpm_sw_add_static_mac tpm_sw_add_static_mac
-#endif
-
-/*******************************************************************************
-* sfs_tpm_sw_add_static_mac
-*
-* DESCRIPTION:
-*       This function creates a static MAC entry in the MAC address table for a
-*       specific lport in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*       static_mac    - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_add_static_mac
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U8                static_mac[6]
-)
-{
-    _tpm_sw_add_static_mac(owner_id,(tpm_src_port_type_t)lport,static_mac);
-
-    return;
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-void tpm_sw_del_static_mac_bounce(uint32_t owner_id,
-				uint8_t static_mac[6])
-{
-	tpm_ioctl_sw_mac_security_t *tpm_sw_mac_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_sw_mac_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_SW_SECURITY_SECTION;
-	tpm_sw_mac_set->sw_security_cmd = MV_TPM_IOCTL_SW_DEL_STATIC_MAC;
-	tpm_sw_mac_set->owner_id = owner_id;
-	memcpy(tpm_sw_mac_set->static_mac, (void*)static_mac, sizeof(uint8_t)*6);
-
-	up(&tpm_sfs_2_ioctl_sem);
-}
- #define _tpm_sw_del_static_mac tpm_sw_del_static_mac_bounce
-#else
- #define _tpm_sw_del_static_mac tpm_sw_del_static_mac
-#endif
-/*******************************************************************************
-* sfs_tpm_sw_del_static_mac
-*
-* DESCRIPTION:
-*       This function removes an existing static MAC entry from the MAC address
-*       table  in the integrated switch.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       static_mac    - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_del_static_mac
-(
-    MV_U32        owner_id,
-    MV_U8         static_mac[6]
-)
-{
-    _tpm_sw_del_static_mac(owner_id,static_mac);
-
-     return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_clear_dynamic_mac
-*
-* DESCRIPTION:
-*       This function removes all dynamic MAC address in the integrated switch.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_clear_dynamic_mac
-(
-    MV_U32        owner_id
-)
-{
-    tpm_sw_clear_dynamic_mac(owner_id);
-
-     return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_add_static_mac
-*
-* DESCRIPTION:
-*       This function creates a static MAC entry in the MAC address table for a
-*       specific lport in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*       static_mac    - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_static_mac_w_mask
-(
-    MV_U32               owner_id,
-    MV_U32               ports_mask,
-    MV_U8                static_mac[6]
-)
-{
-    tpm_sw_set_static_mac_w_ports_mask(owner_id,ports_mask,static_mac);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_mac_age_time
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       time_out            - table size
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_mac_age_time
-(
-    IN uint32_t                 owner_id,
-    IN uint32_t                    time_out
-)
-{
-    tpm_sw_set_mac_age_time(owner_id, time_out);
-
-    return;
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-void tpm_sw_set_port_max_macs_bounce(uint32_t owner_id,
-				uint32_t lport,
-				uint8_t mac_per_port)
-{
-	tpm_ioctl_sw_mac_security_t *tpm_sw_mac_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_sw_mac_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_SW_SECURITY_SECTION;
-	tpm_sw_mac_set->sw_security_cmd = MV_TPM_IOCTL_SW_SET_PORT_MAC_LIMIT;
-	tpm_sw_mac_set->owner_id = owner_id;
-	tpm_sw_mac_set->port = lport;
-	tpm_sw_mac_set->mac_per_port = mac_per_port;
-
-	up(&tpm_sfs_2_ioctl_sem);
-}
- #define _tpm_sw_set_port_max_macs tpm_sw_set_port_max_macs_bounce
-#else
- #define _tpm_sw_set_port_max_macs tpm_sw_set_port_max_macs
-#endif
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_max_macs
-*
-* DESCRIPTION:
-*       This function limits the number of MAC addresses per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       mac_per_port - maximum number of MAC addresses per lport (1-255).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_max_macs
-(
-    MV_U32                  owner_id,
-    MV_U32                  lport,
-    MV_U8                     mac_per_port
-)
-{
-    tpm_sw_set_port_max_macs(owner_id,(tpm_src_port_type_t)lport,mac_per_port);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_mac_learn
-*
-* DESCRIPTION:
-*       This function set MAC learning ability of given lport
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport        - Packet origination.
-*       state        - MAC learning state. 0:disable, 1:enable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_mac_learn
-(
-    MV_U32      owner_id,
-    MV_U32      lport,
-    MV_U8       state
-)
-{
-    bool mac_state;
-
-    mac_state = ((1 == state) ? true: false);
-
-    tpm_sw_set_mac_learn(owner_id, (tpm_src_port_type_t)lport, mac_state);
-
-    return;
-}
-
-/*Evan*/
-#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
-void tpm_sw_set_port_flooding_bounce(uint32_t owner_id,
-					tpm_src_port_type_t src_port,
-					tpm_flood_type_t    flood_mode,
-					uint8_t             allow_flood)
-{
-	tpm_ioctl_sw_mac_security_t *tpm_sw_mac_set = &tpm_sfs_2_ioctl_command.tpm_cmd_data.tpm_ioctl_sw_mac_set;
-
-	tpm_sfs_2_ioctl_command.cmd = MV_TPM_IOCTL_SW_SECURITY_SECTION;
-	tpm_sw_mac_set->sw_security_cmd = MV_TPM_IOCTL_SW_SET_PORT_FLOOD;
-	tpm_sw_mac_set->owner_id = owner_id;
-	tpm_sw_mac_set->port = src_port;
-	tpm_sw_mac_set->flood_mode = flood_mode;
-	tpm_sw_mac_set->allow_flood = allow_flood;
-
-	up(&tpm_sfs_2_ioctl_sem);
-}
- #define _tpm_sw_set_port_flooding tpm_sw_set_port_flooding_bounce
-#else
- #define _tpm_sw_set_port_flooding tpm_sw_set_port_flooding
-#endif
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_flooding
-*
-* DESCRIPTION:
-*       This function control the flooding behavior (unknown Dest MAC address) per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       egress_port     - Egress lport for applying the flood settings.
-*       allow_flood  - permit flooding of unknown DA: set to 1,
-*                      do not permit flooding of uknown DA: set to 0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_flooding
-(
-    MV_U32           owner_id,
-    MV_U32           lport,
-    MV_U32           allow_flood
-)
-{
-    _tpm_sw_set_port_flooding(owner_id,(tpm_src_port_type_t)lport, TPM_FLOOD_UNKNOWN_UNICAST, allow_flood);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_mc_flooding
-*
-* DESCRIPTION:
-*       This function control the flooding behavior (unknown GDA) per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       egress_port     - Egress lport for applying the flood settings.
-*       allow_flood  - permit flooding of unknown multicast: set to 1,
-*                      do not permit flooding of uknown multicast: set to 0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_mc_flooding
-(
-    MV_U32           owner_id,
-    MV_U32           lport,
-    MV_U32           allow_flood
-)
-{
-    tpm_sw_set_port_flooding (owner_id,(tpm_src_port_type_t)lport,TPM_FLOOD_UNKNOWN_MULTI_BROAD_CAST, allow_flood);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_bc_flooding
-*
-* DESCRIPTION:
-*       This function control the flooding behavior (broadcast address) per lport.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       allow_flood  - permit flooding of BC: set to 1,
-*                      do not permit flooding of BC: set to 0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*      None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_bc_flooding
-(
-    MV_U32           owner_id,
-    MV_U32           always_on
-)
-{
-    bool lFloodOn;
-    if(!always_on)
-        lFloodOn = true;
-    else
-        lFloodOn = false;
-    tpm_sw_set_broadcast_flood(owner_id,lFloodOn);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_tagged
-*
-* DESCRIPTION:
-*       The API allows or drops tagged packets on a per lport basis.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         -  lport for applying the filtering of tagged packets.
-*       allow_tagged - set to 1 = allow tagged packets per lport
-*                      set to 0 = drop tagged packets per lport.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_tagged
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U8     allow_tagged
-)
-{
-    tpm_sw_set_port_tagged(owner_id,(tpm_src_port_type_t)lport,allow_tagged);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_untagged
-*
-* DESCRIPTION:
-*       The API allows or drops untagged packets on a per lport basis.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       lport         -  lport for applying the filtering of tagged packets.
-*       allow_untagged - set to 1 = allow tagged packets per lport
-*                      set to 0 = drop tagged packets per lport.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_untagged
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U8     allow_untagged
-)
-{
-    tpm_sw_set_port_untagged(owner_id,(tpm_src_port_type_t)lport,allow_untagged);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_def_vlan
-*
-* DESCRIPTION:
-*       The API sets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       lport       - lport for applying the filtering of tagged packets.
-*       vid        - the port vlan id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_def_vlan
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    vid
-)
-{
-    tpm_sw_set_port_def_vlan(owner_id,(tpm_src_port_type_t)lport,vid);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_def_pri
-*
-* DESCRIPTION:
-*       The API sets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       lport       - lport for applying the filtering of tagged packets.
-*       pri        - the port priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_def_pri
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U8     pri
-)
-{
-    tpm_sw_set_port_def_pri(owner_id,(tpm_src_port_type_t)lport,pri);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_port_add_vid
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of allowed VIDs per lport.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       lport    -  lport for adding the vid.
-*       vid      - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_port_add_vid
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    vid
-)
-{
-    tpm_sw_port_add_vid(owner_id,(tpm_src_port_type_t)lport,vid);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_del_port_vid
-*
-* DESCRIPTION:
-*       The API delete the existed VID from the list of VIDs allowed per lport.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       lport    -  lport for deleting the VID.
-*       vid      - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_del_port_vid
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    vid
-)
-{
-    tpm_sw_port_del_vid(owner_id,(tpm_src_port_type_t)lport,vid);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_port_add_gvid
-*
-* DESCRIPTION:
-*       The API adds a group of VID to the list of allowed VIDs per lport.
-*
-* INPUTS:
-*       owner_id  - APP owner id - should be used for all API calls.
-*       lport     - lport for adding the vid.
-*       egr_mode  - VLAN egress mode.
-*       min_vid   - minimum VID.
-*       max_vid   - maximum VID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_port_add_gvid
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    egr_mode,
-    MV_U16    min_vid,
-    MV_U16    max_vid
-)
-{
-    MV_U16    mode;
-
-    if(egr_mode > MEMBER_EGRESS_TAGGED)
-        mode = MEMBER_EGRESS_UNMODIFIED;
-    else
-        mode = egr_mode;
-
-    tpm_sw_port_add_vid_group(owner_id, (tpm_src_port_type_t)lport, (MV_U8)mode, min_vid, max_vid);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_del_port_gvid
-*
-* DESCRIPTION:
-*       The API delete the existed VID from the list of VIDs allowed per lport.
-*
-* INPUTS:
-*       owner_id  - APP owner id - should be used for all API calls.
-*       lport     - lport for deleting the VID.
-*       min_vid   - minimum VID.
-*       max_vid   - maximum VID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_del_port_gvid
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    min_vid,
-    MV_U16    max_vid
-)
-{
-    tpm_sw_port_del_vid_group(owner_id, (tpm_src_port_type_t)lport, min_vid, max_vid);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_vid_egress_mode
-*
-* DESCRIPTION:
-*       The API sets the egress mode for a member port of a vlan.
-*
-* INPUTS:
-*       owner_id  - APP owner id - should be used for all API calls.
-*       lport     - logic port id to set
-*       vid       - vlan id
-*       eMode     - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_vid_egress_mode
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    vid,
-    MV_U8     eMode
-)
-{
-    tpm_sw_set_port_vid_egress_mode(owner_id,(tpm_src_port_type_t)lport,vid,eMode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_vid_filter_per_port
-*
-* DESCRIPTION:
-*       The API sets the filtering mode of a certain lport.
-*       If the lport is in filtering mode, only the VIDs added by the
-*       tpm_sw_port_add_vid API will be allowed to ingress and egress the lport.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport        -  lport for setting the filtering mode.
-*       vid_filter  - set to 1 - means the lport will DROP all packets which are NOT in
-*                    the allowed VID list (built using API tpm_sw_port_add_vid).
-*                    set to 0 - means that the list of VIDs allowed
-*                    per lport has no significance (the list is not deleted).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void  sfs_tpm_sw_set_vid_filter_per_port
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U8     vid_filter
-)
-{
-    tpm_sw_port_set_vid_filter(owner_id,(tpm_src_port_type_t)lport,vid_filter);
-
-    return;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_q_weight
-*
-* DESCRIPTION:
-*       The API configures the weight of a queue for all
-*       Ethernet UNI ports in the integrated switch.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       weight   - weight value per queue (1-8).queue (value 1-3).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_uni_q_weight
-(
-    MV_U32        owner_id,
-    MV_U8         queue_id,
-    MV_U8         weight
-)
-{
-    tpm_sw_set_uni_q_weight(owner_id,queue_id,weight);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures an ingress policing function for an Ethernet UNI lport.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       uni_port - uni lport for configuring the ingress policer function.
-*       mode     - policing mode.
-*       cir      - commited info rate.
-*       cbs      - commited burst rate
-*       ebs      - extra burst rate
-
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_uni_ingr_police_rate
-(
-    MV_U32      owner_id,
-    MV_U32      uni_port,
-    MV_U32      mode,
-    MV_U32      cir,
-    MV_U32      cbs,
-    MV_U32      ebs
-)
-{
-    MV_U32 count_mode;
-
-    if(mode > GT_PIRL_ELIMIT_LAYER3)
-        count_mode  = GT_PIRL_ELIMIT_LAYER2;
-    else
-        count_mode  = mode;
-
-    tpm_sw_set_uni_ingr_police_rate(owner_id, (tpm_src_port_type_t)uni_port, count_mode, cir, cbs, ebs);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_uni_tc_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures a policer function for a traffic class for an Ethernet UNI lport.
-*       There are 4 globally defined traffic classes in the integrated switch.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       uni_port - uni lport for configuring the ingress policer function.
-*       tc       - traffic class ( a combination of p-bits and DSCP values).
-*       cir      - comited info rate.
-*       cbs      - comited burst rate.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_uni_tc_ingr_police_rate
-(
-    MV_U32      owner_id,
-    MV_U32      uni_port,
-    MV_U32      tc,
-    MV_U32      cir,
-    MV_U32      cbs
-)
-{
-    tpm_sw_set_uni_tc_ingr_police_rate(owner_id,(tpm_src_port_type_t)uni_port,tc,cir,cbs);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       trg_lport            - uni lport for configuring the egress rate limit.
-*       kb_rate_limit_val  - egress rate limit value.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_uni_egr_rate_limit
-(
-    IN uint32_t     owner_id,
-    IN uint32_t     trg_lport,
-    IN uint32_t     set_uni_egr_rate_limit
-)
-{
-    tpm_sw_set_uni_egr_rate_limit(owner_id,(tpm_src_port_type_t)trg_lport,TPM_SW_LIMIT_LAYER2,set_uni_egr_rate_limit);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id            - APP owner id - should be used for all API calls.
-*       size            - table size
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_atu_size
-(
-    IN uint32_t   owner_id,
-    IN uint32_t   size
-)
-{
-    tpm_sw_set_atu_size(owner_id, size);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_vlan_ports
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - logical port number to set.
-*       memPorts    - array of logical ports in the same vlan.
-*       memPortsLen - number of members in memPorts array
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_vlan_ports
-(
-    IN uint32_t             owner_id,
-    IN uint32_t             lport,
-    IN uint32_t             memPorts[],
-    IN uint8_t              memPortsLen
-)
-{
-    tpm_sw_set_port_vlan_ports(owner_id,(tpm_src_port_type_t)lport,memPorts,memPortsLen);
-
-    return;
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_set_ingress_limit_mode
-*
-* DESCRIPTION:
-*      This routine sets the port's rate control ingress limit mode.
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - logical port number to set.
-*       mode         - rate control ingress limit mode.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*      None
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_ingress_limit_mode
-(
-    IN uint32_t                 owner_id,
-    IN uint32_t                 lport,
-    IN GT_RATE_LIMIT_MODE       mode
-)
-{
-    tpm_sw_set_ingress_limit_mode(owner_id,(tpm_src_port_type_t)lport,mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_priority_selection
-*
-* DESCRIPTION:
-*       This function sets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to set init pri.
-*       init_pri    - Initial QPri and FPri selection type.
-*       tag_if_both - Use Tag information for the initial QPri assignment if the frame is both
-*                     tagged and its also IPv4 or IPv6 and if InitialPri uses Tag & IP priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_priority_selection
-(
-    IN uint32_t owner_id,
-    IN uint8_t  lport,
-    IN uint8_t  init_pri,
-    IN GT_BOOL  tag_if_both
-)
-{
-    bool lTag;
-    if(GT_TRUE == tag_if_both)
-        lTag = true;
-    else
-        lTag = false;
-    tpm_sw_set_priority_selection(owner_id,(tpm_src_port_type_t)lport,init_pri,lTag);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a tag priority to a queue priority.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       tag_pri     - Source tag priority number.
-*       q_pri       - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_tag_pri_mapping
-(
-    IN  uint32_t owner_id,
-    IN  uint8_t  tag_pri,
-    IN  uint8_t  q_pri
-)
-{
-    tpm_sw_set_tag_pri_mapping(owner_id,tag_pri,q_pri);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a dscp value to a queue priority.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       dscp        - Source dscp value.
-*       q_pri       - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_ip_pri_mapping
-(
-    IN  uint32_t owner_id,
-    IN  uint8_t  dscp,
-    IN  uint8_t  q_pri
-)
-{
-    tpm_sw_set_ip_pri_mapping(owner_id,dscp,q_pri);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_gmac_mtu
-*
-* DESCRIPTION:
-*       This function set the MTU of GMAC.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       gmac        - GMAC, '0'-GMAC0, '1'-GMAC1, '02'-PONMAC, '3'-switch.
-*       mtu         - MTU size.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_gmac_mtu
-(
-    IN  uint32_t  owner_id,
-    IN  uint32_t  gmac,
-    IN  uint32_t  mtu
-)
-{
-
-    tpm_mru_type_t type;
-    if(gmac > TPM_NETA_MTU_SWITCH)
-        type = TPM_NETA_MTU_SWITCH;
-    else
-        type = (tpm_mru_type_t)gmac;
-
-    tpm_set_mtu_size(owner_id, type, mtu);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_mirror
-*
-* DESCRIPTION:
-*       This function set port mirror.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - src UNI port(1-4).
-*       dst_port    - dst UNI port(1-4).
-*       mode        - mirror mode, '0'-ingress mirror, '1'-egress mirror.
-*       state       - mirror state, '0'-disable, '1'-enable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_mirror
-(
-    IN  uint32_t  owner_id,
-    IN  uint32_t  src_port,
-    IN  uint32_t  dst_port,
-    IN  uint32_t  mode,
-    IN  uint32_t  state
-)
-{
-    tpm_sw_mirror_type_t mirror_mode;
-    bool                 mirror_state;
-
-    if(mode > TPM_SW_MIRROR_EGRESS)
-        mirror_mode = TPM_SW_MIRROR_EGRESS;
-    else
-        mirror_mode = (tpm_sw_mirror_type_t)mode;
-
-    mirror_state = ((1 == state) ? true: false);
-
-    tpm_sw_set_port_mirror(owner_id, src_port, dst_port, mirror_mode, mirror_state);
-}
-
-
-/*******************************************************************************
-* sfs_tpm_sw_set_trunk_ports
-*
-* DESCRIPTION:
-*       This function set port mirror.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       trunk_id    - valid from 0x0 to 0xf
-*       ports_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_trunk_ports
-(
-    IN  uint32_t  owner_id,
-    IN  uint32_t  trunk_id,
-    IN  uint32_t  ports_mask
-)
-{
-    tpm_sw_set_trunk_ports(owner_id, trunk_id, ports_mask);
-}
-/*******************************************************************************
-* sfs_tpm_sw_set_trunk_mask
-*
-* DESCRIPTION:
-*       This function set port mirror.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       mask_num    - trunk mask number, valid from 0 to 7.
-*       trunk_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None.
-*
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_trunk_mask
-(
-    IN	uint32_t  owner_id,
-    IN	uint32_t  mask_num,
-    IN	uint32_t  trunk_mask
-)
-{
-    tpm_sw_set_trunk_mask(owner_id, mask_num, trunk_mask);
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_set_port_speed_duplex
-*
-* DESCRIPTION:
-*       This function set the port speed and duplex together
-*
-* INPUTS:
-*       owner_id      - APP owner id - should be used for all API calls.
-*       lport         - Packet origination.
-*       speed_mode    - speed mode, '0'-10M, '1'-100M, '2'-1000M.
-*       mode          - duplex mode, 1:enable, 0:disable.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_set_port_speed_duplex
-(
-    MV_U32               owner_id,
-    MV_U32               lport,
-    MV_U32               speed_mode,
-    MV_U32               mode
-)
-{
-    tpm_phy_speed_t speed;
-    bool duplex_mode;
-
-    if((tpm_phy_speed_t)speed_mode > TPM_PHY_SPEED_1000_MBPS)
-        speed = (tpm_phy_speed_t)TPM_PHY_SPEED_1000_MBPS;
-    else
-        speed = (tpm_phy_speed_t)speed_mode;
-
-    duplex_mode = ((1 == mode) ? true: false);
-
-    tpm_phy_set_port_speed_duplex_mode(owner_id, (tpm_src_port_type_t)lport, speed, duplex_mode);
-
-    return;
-}
-
-/*******************************************************************************
-* sfs_tpm_sw_port_add_vid_set_egrs_mode
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of allowed VIDs per lport,
-*       and set the port's egress mode.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       lport    -  lport for adding the vid.
-*       vid      - VLAN id.
-*       eMode    - port egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       None
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-void sfs_tpm_sw_port_add_vid_set_egrs_mode
-(
-    MV_U32    owner_id,
-    MV_U32    lport,
-    MV_U16    vid,
-    MV_U8     eMode
-)
-{
-    tpm_sw_port_add_vid_set_egrs_mode(owner_id,(tpm_src_port_type_t)lport,vid,eMode);
-
-    return;
-}
-
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-/*******************************************************************************
-**
-**  sfs_tpm_sw_set_help_show
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_set_help_show_1(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==============================================================================================================================================\n");
-    off += sprintf(buf+off, "                                 Configuration Switch Commands  [DEC]                                                                         \n");
-    off += sprintf(buf+off, "==============================================================================================================================================\n");
-    off += sprintf(buf+off, "cat help_sw_set_cfg_1                                                                                           - show this help\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [state('1'-enable,'0'-disable)]                    > set_port_admin              - set port administration state\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [state('1'-enable,'0'-disable)] [mode('0'~'11')]   > set_port_autoneg            - set port auto negotiation\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d]                                                    > restart_autoneg             - restart port auto negotiation\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [mode('1'-enable,'0'-disable)]                     > set_port_duplex             - set port duplex mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [state('1'-enable,'0'-disable)]                    > set_port_fc                 - set port flow control\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [mode('0'-10M,'1'-100M,'2'-1000M)]                 > set_port_speed              - set port speed mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vector('0'-isolate,'1'-enable, bit0-UNI0...]      > set_port_isolate_vector     - set port isolation vector\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [mode('0'-internal,'1'-external)] [state]          > set_port_loopback           - set port loopback state, enable or disable it. \n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1]          > add_static_mac              - add static mac to port\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] mac[6], mac[5] mac[4] mac[3]  mac[2], mac[1]                      > del_static_mac              - delete static mac\n");
-    off += sprintf(buf+off, "echo [owner_id]                                                                   > clear_dynamic_mac           - clear all dynamic mac\n");
-    off += sprintf(buf+off, "echo [owner_id] [port_mask] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1]             > set_static_mac_w_mask       - set static mac with port vector\n");
-    off += sprintf(buf+off, "echo [owner_id] [time_out(sec)]                                                   > set_mac_age_time            - set the MAC aging time\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [mac_pe_port(0 - 255)]                             > set_port_max_macs           - set the maximum MAC address of given port\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [state('1'-enable,'0'-disable)]                    > set_port_mac_learn          - set port MAC learning state\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [size 0(256) - 5(8192)]                                           > set_atu_size                - set the FDB size \n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [allow_flood ('1'-permit,'0'-not)]                 > set_port_flooding           - permit flooding of unknown DA\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [allow_flood ('1'-permit,'0'-not)]                 > set_port_mc_flooding        - permit flooding of unknown multicast\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [always_on ('1'-permit,'0'-use mc rules)]                         > set_bc_flooding             - permit flooding of broadcast\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [drop_tagged('1'-drop,  '0'-not)]                  > set_port_tagged             - allows or drops tagged packets\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [drop_untagged('1'-drop,'0'-not)]                  > set_port_untagged           - allows or drops untagged packets\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid_filter('1'-Drop,'0'-not)]                     > set_vid_filter_per_port     - set the filtering mod VID\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [speed('0'-10M,'1'-100M,'2'-1000M)] [duplex('1'-enable,'0'-disable)]  > set_port_speed_duplex - set port speed and duplex mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "====================================================================================================================================================\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_tpm_sw_set_help_show_2
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_set_help_show_2(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==============================================================================================================================================\n");
-    off += sprintf(buf+off, "                                 Configuration Switch Commands  [DEC]                                                                         \n");
-    off += sprintf(buf+off, "==============================================================================================================================================\n");
-    off += sprintf(buf+off, "cat help_sw_set_cfg_2                                                                                           - show this help\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid(1-4094)]                                      > set_port_def_vlan           - set port default vid\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [pri(0-7)]                                         > set_port_def_pri            - set port default pri\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid(1-4094)]                                      > add_port_vid                - add a VID to lport\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid(1-4094)]                                      > del_port_vid                - delete the existed VID from given port\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [egr_mode] [min_vid(0-4095)] [max_vid(0-4095)]     > add_port_gvid               - add a group of VID to lport and set egress mode('0'-AS_IS, '2'-RM_TAG, '3'-ADD_TAG)\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [min_vid(0-4095)] [max_vid(0-4095)]                > del_port_gvid               - delete a group of VID from lport\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid(1-4094)] [egr_mode]                           > set_port_vid_egr_mode       - set the egress modee('0'-AS_IS, '2'-RM_TAG, '3'-ADD_TAG)\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [queue_id 1-3]  [weight 1-8]                                      > set_uni_q_weight            - configure the weight of a queues\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] rate [egr_rate_limit_menu]                         > set_uni_egr_rate_limit      - set egress frame rate limit\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] mode[rate_limit_menu] [cir] [cbs] [ebs]            > set_uni_ingr_police_rate    - set ingress policing\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] tc[1-4] cir[rate_limit_menu] cbs[0 ~ 0xFFFF)       > set_uni_tc_ingr_police_rate - set ingress policing\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] mode [rate_limit_menu]                             > set_ingress_limit_mode      - set ingress policing mode\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] Port[6]Port[5]Port[4]Port[3]Port[2]Port[1]len[1-6] > set_port_vlan_ports         - add lport to VLAN group membership\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [init_pri_menu] [tag_if_both 0-1]                  > set_init_pri                - set initial priority\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "echo [owner_id] [pri 0-7] [q 0-3]                                                 > set_tag_pri_mapping         - map tag pri to queue\n");
-    off += sprintf(buf+off, "echo [owner_id] [dscp 0-63] [q 0-3]                                               > set_ip_pri_mapping          - map ip pri to queue\n");
-    off += sprintf(buf+off, "echo [owner_id] [gmac('0'-GMAC0, '1'-GMAC1, '2'-PMAC, '3'-switch)] [mtu]          > set_gmac_mtu                - set GMAC MTU\n");
-    off += sprintf(buf+off, "echo [owner_id] [src port] [dst port] [mode('0'-ingress), '1'-egress] [state]     > set_port_mirror             - set port mirror, src/dst port is UNI port(1-4), state('1'-enable,'0'-disable)\n");
-    off += sprintf(buf+off, "echo [owner_id] [trunk_id] [port mask]                                            > set_trunk_ports             - set trunk ID and port mask\n");
-    off += sprintf(buf+off, "echo [owner_id] [mask num] [trunk mask]                                           > set_trunk_mask              - set trunk mask\n");
-    off += sprintf(buf+off, "echo [owner_id] [UNI port %.1d-%.1d] [vid(1-4094)] [egr_mode]                           > add_port_vid_set_egr_mode   - add a VID to lport and set the egress mode('0'-AS_IS, '2'-RM_TAG, '3'-ADD_TAG)\n", TPM_SRC_PORT_UNI_0, TPM_SRC_PORT_UNI_3);
-    off += sprintf(buf+off, "====================================================================================================================================================\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_tpm_sw_rate_limit_menu
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_rate_limit_menu(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "                                 rate limit menu                                                  \n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "cir allowed values are: 64, 128, 192, 256, 320,,..., 960,1000, 2000..., 100000,110000, 120000,..,200000\n");
-    off += sprintf(buf+off, "mode enumeration values are: '0'-All,'1'-LIMIT_FLOOD,'2'-LIMIT_BRDCST_MLTCST,'3'-LIMIT_BRDCST\n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-
-    return(off);
-}
-/*******************************************************************************
-**
-**  sfs_tpm_sw_egr_rate_limit_menu
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_egr_rate_limit_menu(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "                                egress rate limit menu \n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "rate allowed values are: 0(MAX) 7600,..,7600+n*64,9600, 100000 110000, 120000,..., 1000000\n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-
-    return(off);
-}
-
-/*******************************************************************************
-**
-**  sfs_tpm_sw_init_pri_menu
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function print cfg help
-**
-**  PARAMETERS:  char* buf
-**
-**  OUTPUTS:     char* buf
-**
-**  RETURNS:     message length
-**
-*******************************************************************************/
-int sfs_tpm_sw_init_pri_menu(char* buf)
-{
-    int off = 0;
-
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "                                 initial priority menu           \n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-    off += sprintf(buf+off, "mode enumeration values are: '0'-USE_PORTS_DEF,'1'-TAG_PRI_ONLY,'2'-IP_PRI_ONLY,'3'-IP_AND_TAG_PRI\n");
-    off += sprintf(buf+off, "==================================================================================================\n");
-
-    return(off);
-}
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-/* ========================================================================== */
-/******************************************************************************/
-
-/* ========================================================================== */
-/*                            Cfg Commands                                    */
-/* ========================================================================== */
-/* ========================================================================== */
-/*                            Cfg Commands                                    */
-/* ========================================================================== */
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static ssize_t set_sw_show(struct device *dev,
-                        struct device_attribute *attr,
-                        char *buf)
-{
-    const char* name = attr->attr.name;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    if (!strcmp(name, "help_sw_set_cfg_1"))
-        return (sfs_tpm_sw_set_help_show_1(buf));
-    if (!strcmp(name, "help_sw_set_cfg_2"))
-        return (sfs_tpm_sw_set_help_show_2(buf));
-    else if (!strcmp(name, "rate_limit_menu"))
-        return (sfs_tpm_sw_rate_limit_menu(buf));
-    else if (!strcmp(name, "egr_rate_limit_menu"))
-        return (sfs_tpm_sw_egr_rate_limit_menu(buf));
-    else if (!strcmp(name, "init_pri_menu"))
-        return (sfs_tpm_sw_init_pri_menu(buf));
-
-    return 0;
-}
-#else
-static ssize_t set_sw_show(struct device *dev,
-                           struct device_attribute *attr,
-                           char *buf)
-{
-	printk(KERN_WARNING "%s: sysfs help is not compiled (CONFIG_MV_TPM_SYSFS_HELP)\n", __FUNCTION__);
-    return 0;
-}
-#endif /* CONFIG_MV_TPM_SYSFS_HELP */
-
-
-static ssize_t set_sw_store(struct device *dev,
-                         struct device_attribute *attr,
-                         const char *buf, size_t len)
-{
-    const char* name = attr->attr.name;
-//     unsigned long flags  = 0;
-    int  param1 = 0;
-    int  param2 = 0;
-    int  param3 = 0;
-    int  param4 = 0;
-    int  param5 = 0;
-    int  param6 = 0;
-    int  param7 = 0;
-    int  param8 = 0;
-    int  param9 = 0;
-    MV_U8         static_mac[6] = {0,0,0,0,0,0};
-    MV_U32        memPorts[6];
-
-    if (!capable(CAP_NET_ADMIN))
-    return -EPERM;
-
-    if (!strcmp(name, "add_static_mac"))
-    {
-        sscanf(buf, "%d %d %d %d %d %d %d %d",
-               &param1, &param2,&param3,&param4,
-               &param5, &param6,&param7,&param8);
-
-        static_mac[0] = param3;
-        static_mac[1] = param4;
-        static_mac[2] = param5;
-        static_mac[3] = param6;
-        static_mac[4] = param7;
-        static_mac[5] = param8;
-
-    }
-    else if (!strcmp(name, "del_static_mac"))
-    {
-        sscanf(buf, "%d %d %d %d %d %d %d ",
-               &param1, &param2,&param3,
-               &param4,&param5, &param6,&param7);
-
-        static_mac[0] = param2;
-        static_mac[1] = param3;
-        static_mac[2] = param4;
-        static_mac[3] = param5;
-        static_mac[4] = param6;
-        static_mac[5] = param7;
-    }
-    else if (!strcmp(name, "clear_dynamic_mac"))
-    {
-        sscanf(buf, "%d ",
-               &param1);
-
-    }
-    else if (!strcmp(name, "set_static_mac_w_mask"))
-    {
-        sscanf(buf, "%d %d %d %d %d %d %d %d",
-               &param1, &param2,&param3,&param4,
-               &param5, &param6,&param7,&param8);
-
-        static_mac[0] = param3;
-        static_mac[1] = param4;
-        static_mac[2] = param5;
-        static_mac[3] = param6;
-        static_mac[4] = param7;
-        static_mac[5] = param8;
-
-    }
-    else if (!strcmp(name, "add_port_gvid"))
-    {
-        sscanf(buf, "%d %d %d %d %d",
-               &param1, &param2,&param3,&param4,&param5);
-    }
-    else if (!strcmp(name, "set_port_mirror"))
-    {
-        sscanf(buf, "%d %d %d %d %d",
-               &param1, &param2,&param3,&param4,&param5);
-    }
-    else if (!strcmp(name, "set_uni_ingr_police_rate"))
-    {
-        sscanf(buf, "%d %d %d %d %d %d",
-               &param1, &param2, &param3,
-               &param4, &param5, &param6);
-    }
-    else if (!strcmp(name, "set_uni_tc_ingr_police_rate"))
-    {
-        sscanf(buf, "%d %d %d %d %d ",
-               &param1, &param2,&param3,
-               &param4,&param5);
-    }
-    else if (!strcmp(name, "set_port_vlan_ports"))
-    {
-        sscanf(buf, "%d %d %d %d %d %d %d %d %d",
-               &param1, &param2,&param3,&param4,
-               &param5, &param6,&param7,&param8,&param9);
-
-        memPorts[0] = param3;
-        memPorts[1] = param4;
-        memPorts[2] = param5;
-        memPorts[3] = param6;
-        memPorts[4] = param7;
-        memPorts[5] = param8;
-    }
-    else if (!strcmp(name, "set_init_pri"))
-    {
-        sscanf(buf, "%d %d %d %d",
-               &param1,&param2,&param3,&param4);
-    }
-    else if (!strcmp(name, "set_tag_pri_mapping"))
-    {
-        sscanf(buf, "%d %d %d",
-               &param1,&param2,&param3);
-    }
-    else if (!strcmp(name, "set_ip_pri_mapping"))
-    {
-        sscanf(buf, "%d %d %d",
-               &param1,&param2,&param3);
-    }
-    else
-    {
-        sscanf(buf, "%d %d %d %d",
-               &param1, &param2,&param3,&param4);
-    }
-
-    printk(KERN_INFO "param1[%d],param2[%d],param3[%d],param4[%d],param5[%d],param6[%d],param7[%d],param8[%d] param9[%d] \n",
-          param1,param2,param3,param4,
-          param5,param6,param7,param8,param9);
-    if (param1 < 0 ||
-        param2 < 0 ||
-        param3 < 0 ||
-        param4 < 0 ||
-        param5 < 0 ||
-        param6 < 0 ||
-        param7 < 0 ||
-        param8 < 0 ||
-        param9 < 0) {
-            printk("ERROR %s: illegal negative parameter <%s>\n", __FUNCTION__, attr->attr.name);
-            return (len);
-    }
-
-//     raw_local_irq_save(flags);
-
-    if (!strcmp(name, "set_port_admin"))
-        sfs_tpm_sw_set_port_admin((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_autoneg"))
-        sfs_tpm_sw_set_port_autoneg((MV_U32)param1,(MV_U32)param2, (MV_U32)param3, (MV_U32)param4);
-
-    else if (!strcmp(name, "restart_autoneg"))
-        sfs_tpm_sw_restart_autoneg((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "set_port_duplex"))
-        sfs_tpm_sw_set_port_duplex((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_fc"))
-        sfs_tpm_sw_set_port_fc((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_speed"))
-        sfs_tpm_sw_set_port_speed((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_isolate_vector"))
-        sfs_tpm_sw_set_port_isolate_vector((MV_U32)param1,(MV_U32)param2, (MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_loopback"))
-        sfs_tpm_sw_set_port_loopback((MV_U32)param1,(MV_U32)param2, (MV_U32)param3, (MV_U32)param4);
-
-    else if (!strcmp(name, "add_static_mac"))
-        sfs_tpm_sw_add_static_mac((MV_U32)param1,(MV_U32)param2, static_mac);
-
-    else if (!strcmp(name, "del_static_mac"))
-        sfs_tpm_sw_del_static_mac((MV_U32)param1, static_mac);
-
-    else if (!strcmp(name, "clear_dynamic_mac"))
-        sfs_tpm_sw_clear_dynamic_mac((MV_U32)param1);
-
-    else if (!strcmp(name, "set_static_mac_w_mask"))
-        sfs_tpm_sw_set_static_mac_w_mask((MV_U32)param1,(MV_U32)param2, static_mac);
-
-    else if (!strcmp(name, "set_port_max_macs"))
-        sfs_tpm_sw_set_port_max_macs((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "set_port_mac_learn"))
-        sfs_tpm_sw_set_port_mac_learn((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if
-        (!strcmp(name, "set_atu_size"))
-                sfs_tpm_sw_set_atu_size((MV_U32)param1,(MV_U32)param2);
-    else if
-        (!strcmp(name, "set_mac_age_time"))
-                sfs_tpm_sw_set_mac_age_time((MV_U32)param1,(MV_U32)param2);
-
-    else if (!strcmp(name, "set_port_flooding"))
-        sfs_tpm_sw_set_port_flooding((MV_U32)param1 ,(MV_U32)param2 ,(MV_U32)param3);
-
-    else if (!strcmp(name, "set_port_mc_flooding"))
-        sfs_tpm_sw_set_port_mc_flooding((MV_U32)param1 ,(MV_U32)param2 ,(MV_U32)param3);
-
-    else if (!strcmp(name, "set_bc_flooding"))
-        sfs_tpm_sw_set_bc_flooding((MV_U32)param1 ,(MV_U32)param2);
-
-    else if (!strcmp(name, "set_port_tagged"))
-        sfs_tpm_sw_set_port_tagged((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "set_port_untagged"))
-        sfs_tpm_sw_set_port_untagged((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "set_port_def_vlan"))
-        sfs_tpm_sw_set_port_def_vlan((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3);
-
-    else if (!strcmp(name, "set_port_def_pri"))
-        sfs_tpm_sw_set_port_def_pri((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "add_port_vid"))
-        sfs_tpm_sw_port_add_vid((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3);
-
-    else if (!strcmp(name, "del_port_vid"))
-        sfs_tpm_sw_del_port_vid((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3);
-
-    else if (!strcmp(name, "add_port_gvid"))
-        sfs_tpm_sw_port_add_gvid((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3, (MV_U16)param4, (MV_U16)param5);
-
-    else if (!strcmp(name, "del_port_gvid"))
-        sfs_tpm_sw_del_port_gvid((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3, (MV_U16)param4);
-
-    else if (!strcmp(name, "set_port_vid_egr_mode"))
-        sfs_tpm_sw_set_port_vid_egress_mode((MV_U32)param1 ,(MV_U32)param2 ,(MV_U16)param3 ,(MV_U8)param4);
-
-    else if (!strcmp(name, "set_uni_q_weight"))
-        sfs_tpm_sw_set_uni_q_weight((MV_U32)param1 ,(MV_U32)param2,(MV_U32)param3);
-
-    else if (!strcmp(name, "set_vid_filter_per_port"))
-        sfs_tpm_sw_set_vid_filter_per_port((MV_U32)param1 ,(MV_U32)param2 ,(MV_U8)param3);
-
-    else if (!strcmp(name, "set_uni_egr_rate_limit"))
-        sfs_tpm_sw_set_uni_egr_rate_limit((MV_U32)param1, (MV_U32)param2,
-                                        (MV_U32)param3);
-
-    else if (!strcmp(name, "set_uni_ingr_police_rate"))
-        sfs_tpm_sw_set_uni_ingr_police_rate((MV_U32)param1, (MV_U32)param2,
-                                            (MV_U32)param3, (MV_U32)param4,
-                                            (MV_U32)param5, (MV_U32)param6);
-    else if (!strcmp(name, "set_uni_tc_ingr_police_rate"))
-        sfs_tpm_sw_set_uni_tc_ingr_police_rate((MV_U32)param1, (MV_U32)param2,
-                                           (MV_U32)param3,(MV_U32)param4,
-                                           (MV_U32)param5);
-    else if
-        (!strcmp(name, "set_ingress_limit_mode"))
-                sfs_tpm_sw_set_ingress_limit_mode((MV_U32)param1,(MV_U32)param2,(MV_U32)param3);
-
-    else if
-        (!strcmp(name, "set_port_vlan_ports"))
-                sfs_tpm_sw_set_port_vlan_ports((MV_U32)param1,(MV_U32)param2, memPorts,(MV_U32)param9);
-
-    else if
-        (!strcmp(name, "set_init_pri"))
-                sfs_tpm_sw_set_priority_selection((MV_U32)param1,(MV_U8)param2,(MV_U8)param3,(MV_U8)param4);
-    else if
-        (!strcmp(name, "set_tag_pri_mapping"))
-                sfs_tpm_sw_set_tag_pri_mapping((MV_U32)param1,(MV_U8)param2,(MV_U8)param3);
-    else if
-        (!strcmp(name, "set_ip_pri_mapping"))
-                sfs_tpm_sw_set_ip_pri_mapping((MV_U32)param1,(MV_U8)param2,(MV_U8)param3);
-    else if
-        (!strcmp(name, "set_gmac_mtu"))
-                sfs_tpm_sw_set_gmac_mtu((MV_U32)param1,(MV_U32)param2,(MV_U32)param3);
-
-    else if
-        (!strcmp(name, "set_port_mirror"))
-                sfs_tpm_sw_set_port_mirror((MV_U32)param1,(MV_U32)param2,(MV_U32)param3,(MV_U32)param4,(MV_U32)param5);
-    else if
-        (!strcmp(name, "set_trunk_mask"))
-                sfs_tpm_sw_set_trunk_mask((MV_U32)param1,(MV_U32)param2,(MV_U32)param3);
-    else if
-        (!strcmp(name, "set_trunk_ports"))
-                sfs_tpm_sw_set_trunk_ports((MV_U32)param1,(MV_U32)param2,(MV_U32)param3);
-    else if
-        (!strcmp(name, "set_port_speed_duplex"))
-                sfs_tpm_sw_set_port_speed_duplex((MV_U32)param1,(MV_U32)param2, (MV_U32)param3, (MV_U32)param4);
-    else if
-        (!strcmp(name, "add_port_vid_set_egr_mode"))
-                sfs_tpm_sw_port_add_vid_set_egrs_mode((MV_U32)param1,(MV_U32)param2, (MV_U16)param3, (MV_U8)param4);
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-//     raw_local_irq_restore(flags);
-
-    return(len);
-}
-
-
-/* ========================================================================== */
-/*                            Debug SW Attributes                             */
-/* ========================================================================== */
-static DEVICE_ATTR(set_global_reg,          S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(get_global_reg,          S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(set_port_reg,            S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(get_port_reg,            S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(get_port_cntrs,          S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(get_fdb,                 S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(sw_init,                 S_IWUSR, dbg_sw_show, dbg_sw_store);
-static DEVICE_ATTR(debug_trace,             S_IWUSR, dbg_sw_show, dbg_sw_store);
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help_sw_dbg,             S_IRUSR, dbg_sw_show, dbg_sw_store);
-#endif
-
-
-static struct attribute *dbg_sw_attrs[] =
-{
-    &dev_attr_set_global_reg.attr,
-    &dev_attr_get_global_reg.attr,
-    &dev_attr_set_port_reg.attr,
-    &dev_attr_get_port_reg.attr,
-    &dev_attr_get_port_cntrs.attr,
-    &dev_attr_get_fdb.attr,
-    &dev_attr_sw_init.attr,
-    &dev_attr_debug_trace.attr,
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_sw_dbg.attr,
-#endif
-    NULL
-};
-
-static struct attribute_group dbg_sw_group =
-{
-    .name = "debug",
-    .attrs = dbg_sw_attrs
-};
-
-
-
-/* ========================================================================== */
-/*                            Info SW Attributes                              */
-/* ========================================================================== */
-
-static DEVICE_ATTR(get_port_admin,                  S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_link_status,            S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_autoneg,                S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_duplex_config,          S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_duplex_status,          S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_fc_config,              S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_fc_status,              S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_speed_config,           S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_speed_status,           S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_isolate_vector,         S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_loopback,               S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_mac_age_time,                S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_max_macs,               S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_mac_learn,              S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_flooding,               S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_mc_flooding,            S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_bc_flooding,                 S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_tagged,                 S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_untagged,               S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_def_vlan,               S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_def_pri,                S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_vid,                    S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_vid_filter,             S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_uni_ingr_police_rate,        S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_uni_tc_ingr_police_rate,     S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_uni_egr_rate_limit,          S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_vlan_ports,             S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_ingress_limit_mode,          S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_init_pri,                    S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_tag_pri_mapping,             S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_ip_pri_mapping,              S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_gmac_mtu,                    S_IWUSR, get_sw_show, get_sw_store);
-static DEVICE_ATTR(get_port_mirror,                 S_IWUSR, get_sw_show, get_sw_store);
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help_sw_get_info,                S_IRUSR, get_sw_show, get_sw_store);
-#endif
-
-
-static struct attribute *get_sw_attrs[] =
-{
-    &dev_attr_get_port_admin.attr,
-    &dev_attr_get_port_link_status.attr,
-    &dev_attr_get_port_autoneg.attr,
-    &dev_attr_get_port_duplex_config.attr,
-    &dev_attr_get_port_duplex_status.attr,
-    &dev_attr_get_port_fc_config.attr,
-    &dev_attr_get_port_fc_status.attr,
-    &dev_attr_get_port_speed_config.attr,
-    &dev_attr_get_port_speed_status.attr,
-    &dev_attr_get_port_isolate_vector.attr,
-    &dev_attr_get_port_loopback.attr,
-    &dev_attr_get_mac_age_time.attr,
-    &dev_attr_get_port_max_macs.attr,
-    &dev_attr_get_port_mac_learn.attr,
-    &dev_attr_get_port_flooding.attr,
-    &dev_attr_get_port_mc_flooding.attr,
-    &dev_attr_get_bc_flooding.attr,
-    &dev_attr_get_port_tagged.attr,
-    &dev_attr_get_port_untagged.attr,
-    &dev_attr_get_port_def_vlan.attr,
-    &dev_attr_get_port_def_pri.attr,
-    &dev_attr_get_port_vid.attr,
-    &dev_attr_get_port_vid_filter.attr,
-    &dev_attr_get_uni_ingr_police_rate.attr,
-    &dev_attr_get_uni_tc_ingr_police_rate.attr,
-    &dev_attr_get_uni_egr_rate_limit.attr,
-    &dev_attr_get_port_vlan_ports.attr,
-    &dev_attr_get_ingress_limit_mode.attr,
-    &dev_attr_get_init_pri.attr,
-    &dev_attr_get_tag_pri_mapping.attr,
-    &dev_attr_get_ip_pri_mapping.attr,
-    &dev_attr_get_gmac_mtu.attr,
-    &dev_attr_get_port_mirror.attr,
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_sw_get_info.attr,
-#endif
-    NULL
-};
-
-static struct attribute_group get_sw_group =
-{
-    .name = "info",
-    .attrs = get_sw_attrs
-};
-
-
-/* ========================================================================== */
-/*                            Cfg SW Attributes                               */
-/* ========================================================================== */
-static DEVICE_ATTR(set_port_admin,                  S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_autoneg,                S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(restart_autoneg,                 S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_duplex,                 S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_fc,                     S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_speed,                  S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_isolate_vector,         S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_loopback,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(add_static_mac,                  S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(del_static_mac,                  S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(clear_dynamic_mac,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_static_mac_w_mask,           S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_mac_age_time,                S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_max_macs,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_mac_learn,              S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_flooding,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_mc_flooding,            S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_bc_flooding,                 S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_tagged,                 S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_untagged,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_def_vlan,               S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_def_pri,                S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(add_port_vid,                    S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(del_port_vid,                    S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(add_port_gvid,                   S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(del_port_gvid,                   S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_vid_egr_mode,           S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_vid_filter_per_port,         S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_uni_q_weight,                S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_uni_ingr_police_rate,        S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_uni_tc_ingr_police_rate,     S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_uni_egr_rate_limit,          S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_atu_size,                    S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_vlan_ports,             S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_ingress_limit_mode,          S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_init_pri,                    S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_tag_pri_mapping,             S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_ip_pri_mapping,              S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_gmac_mtu,                    S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_mirror,                 S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_trunk_mask,                  S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_trunk_ports,                 S_IWUSR, set_sw_show, set_sw_store);
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-static DEVICE_ATTR(help_sw_set_cfg_1,               S_IRUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(help_sw_set_cfg_2,               S_IRUSR, set_sw_show, set_sw_store);
-#endif
-static DEVICE_ATTR(rate_limit_menu,                 S_IRUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(egr_rate_limit_menu,             S_IRUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(init_pri_menu,                   S_IRUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(set_port_speed_duplex,           S_IWUSR, set_sw_show, set_sw_store);
-static DEVICE_ATTR(add_port_vid_set_egr_mode,       S_IWUSR, set_sw_show, set_sw_store);
-
-static struct attribute *set_sw_attrs[] = {
-    &dev_attr_set_port_admin.attr,
-    &dev_attr_set_port_autoneg.attr,
-    &dev_attr_restart_autoneg.attr,
-    &dev_attr_set_port_duplex.attr,
-    &dev_attr_set_port_fc.attr,
-    &dev_attr_set_port_speed.attr,
-    &dev_attr_set_port_isolate_vector.attr,
-    &dev_attr_set_port_loopback.attr,
-    &dev_attr_add_static_mac.attr,
-    &dev_attr_del_static_mac.attr,
-    &dev_attr_clear_dynamic_mac.attr,
-    &dev_attr_set_static_mac_w_mask.attr,
-    &dev_attr_set_mac_age_time.attr,
-    &dev_attr_set_port_max_macs.attr,
-    &dev_attr_set_port_mac_learn.attr,
-    &dev_attr_set_port_flooding.attr,
-    &dev_attr_set_port_mc_flooding.attr,
-    &dev_attr_set_bc_flooding.attr,
-    &dev_attr_set_port_tagged.attr,
-    &dev_attr_set_port_untagged.attr,
-    &dev_attr_set_port_def_vlan.attr,
-    &dev_attr_set_port_def_pri.attr,
-    &dev_attr_add_port_vid.attr,
-    &dev_attr_del_port_vid.attr,
-    &dev_attr_add_port_gvid.attr,
-    &dev_attr_del_port_gvid.attr,
-    &dev_attr_set_port_vid_egr_mode.attr,
-    &dev_attr_set_vid_filter_per_port.attr,
-    &dev_attr_set_uni_q_weight.attr,
-    &dev_attr_set_uni_ingr_police_rate.attr,
-    &dev_attr_set_uni_tc_ingr_police_rate.attr,
-    &dev_attr_set_uni_egr_rate_limit.attr,
-    &dev_attr_set_atu_size.attr,
-    &dev_attr_set_port_vlan_ports.attr,
-    &dev_attr_set_ingress_limit_mode.attr,
-    &dev_attr_set_init_pri.attr,
-    &dev_attr_set_tag_pri_mapping.attr,
-    &dev_attr_set_ip_pri_mapping.attr,
-    &dev_attr_set_gmac_mtu.attr,
-    &dev_attr_set_port_mirror.attr,
-    &dev_attr_set_trunk_mask.attr,
-    &dev_attr_set_trunk_ports.attr,
-    &dev_attr_set_port_speed_duplex.attr,
-#ifdef CONFIG_MV_TPM_SYSFS_HELP
-    &dev_attr_help_sw_set_cfg_1.attr,
-    &dev_attr_help_sw_set_cfg_2.attr,
-#endif
-    &dev_attr_rate_limit_menu.attr,
-    &dev_attr_egr_rate_limit_menu.attr,
-    &dev_attr_init_pri_menu.attr,
-    &dev_attr_add_port_vid_set_egr_mode.attr,
-    NULL
-};
-
-static struct attribute_group set_sw_group =
-{
-  .name = "cfg",
-  .attrs = set_sw_attrs
-};
-/******************************************************************************/
-/* ========================================================================== */
-/*                            SW SYS FS                                       */
-/* ========================================================================== */
-/******************************************************************************/
-int sw_sysfs_init(void)
-{
-    int err;
-    struct device *pd;
-
-    pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm_sw");
-    if (!pd)
-    {
-        platform_device_register_simple("tpm_sw", -1, NULL, 0);
-        pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm_sw");
-    }
-
-    if (!pd)
-    {
-        printk(KERN_ERR"%s: cannot find tpm_sw device\n", __FUNCTION__);
-        pd = &platform_bus;
-    }
-
-    err = sysfs_create_group(&pd->kobj, &set_sw_group);
-    if (err)
-    {
-        printk(KERN_INFO "sysfs group failed %d\n", err);
-        goto out;
-    }
-
-    err = sysfs_create_group(&pd->kobj, &get_sw_group);
-    if (err)
-    {
-        printk(KERN_INFO "sysfs group failed %d\n", err);
-        goto out;
-    }
-
-    err = sysfs_create_group(&pd->kobj, &dbg_sw_group);
-    if (err)
-    {
-        printk(KERN_INFO "sysfs group failed %d\n", err);
-        goto out;
-    }
-
-    printk(KERN_INFO "= SW Module SYS FS Init ended successfully =\n");
-
-    out:
-    return err;
-}
-
-/*******************************************************************************
-**
-**  tpm_module_usr_if_create
-**  ____________________________________________________________________________
-**
-**  DESCRIPTION: The function create user interface - sys fs
-**
-**  PARAMETERS:  None
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     MV_OK or MV_ERROR
-**
-*******************************************************************************/
-MV_STATUS tpm_module_usr_if_create(void)
-{
-  if (sw_sysfs_init() != 0)
-    return(MV_ERROR);
-
-  if (tpm_sysfs_init() != 0)
-    return(MV_ERROR);
-
-  if (tpm_sysfs_print_init() != 0)
-    return(MV_ERROR);
-
-  if (tpm_sysfs_trace_init() != 0)
-    return(MV_ERROR);
-#if 0 //See  tpm_sysfs_config_init module for explanation
-  if (tpm_sysfs_config_init() != 0)
-    return(MV_ERROR);
-#endif
-
-  return(MV_OK);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.h
deleted file mode 100644
index b48506c..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/perf/tpm_usr_if.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_usr_if.h
-*
-* DESCRIPTION:
-*               Traffic Processor Manager = TPM
-*
-* DEPENDENCIES:
-*               None
-*
-* CREATED BY:   OctaviaP
-*
-* DATE CREATED:
-*
-* FILE REVISION NUMBER:
-*               $Revision: 1.1.1.1 $
-*
-*
-*******************************************************************************/
-#ifndef _TPM_USR_IF_H_
-#define _TPM_USR_IF_H_
-
-MV_STATUS tpm_module_usr_if_create(void);
-
-#endif  /* _TPM_USR_IF_H_*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.c
deleted file mode 100644
index 0a6f956..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-/******************************************************************************
-* tpm_alarm.c
-*
-*
-*  MODULE : TPM Alarm
-*
-*  DESCRIPTION : This file config tpm alarm
-*
-*  MODIFICATION HISTORY:
-*           12Dec2010   Victor  - initial version created.
-*
-* FILE REVISION NUMBER:
-*       $Revision: 1.8 $
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-extern  uint32_t trace_sw_dbg_flag;
-static uint32_t gportLosPreviousAlarm = 0;
-
-/*******************************************************************************
-* tpm_alarm_get_eth_port
-*
-* DESCRIPTION:
-*       This function gets eth port alarm.
-*
-* INPUTS:
-*       owner_id	 - APP owner id , should be used for all API calls.
-*
-* OUTPUTS:
-*       alarm_type  - eth alarm type
-*		 port_bitmap	- port bitmap
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_alarm_get_eth_port
-(
-	uint32_t owner_id,
-	uint32_t *alarm_type,
-	uint8_t *port_bitmap
-)
-{
-	tpm_error_code_t retVal = TPM_RC_OK;
-	uint32_t i;
-	uint32_t ethPreviousAlarmState;
-	uint32_t ethCurrentAlarmState;
-	uint32_t ethChangedAlarm;
-	uint8_t reportBitmap;
-	uint8_t clearBitmap;
-
-	if (trace_sw_dbg_flag)
-	{
-		printk(KERN_INFO"==ENTER==%s: owner_id[%d]",
-				__FUNCTION__,owner_id);
-	}
-
-	*alarm_type = 0;
-
-	/*Get eth port los alarm*/
-	if(ONU_EPON_ALARM_ETH_DEF_STATE & ONU_EPON_ALARM_ETH_PORT_LOS)
-	{
-		/* get the prvious eth port los alarm status */
-		ethPreviousAlarmState = gportLosPreviousAlarm;
-
-		/* get the current eth port los alarm status */
-		retVal = mv_switch_get_port_los_alarm(&ethCurrentAlarmState);
-		if (retVal != TPM_RC_OK)
-		{
-			printk(KERN_ERR
-			"%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-		}
-
-		/*port alarm exists, report or clear*/
-		if((ethCurrentAlarmState ^ ethPreviousAlarmState) != 0)
-		{
-			if (trace_sw_dbg_flag)
-			{
-				printk(KERN_INFO"%s: owner_id[%d]  ethPreviousAlarmState[%08x] ethCurrentAlarmState[%08x]\r\n",
-						__FUNCTION__,owner_id, ethPreviousAlarmState, ethCurrentAlarmState);
-			}
-
-			/*get changed alarm*/
-			ethChangedAlarm = (ethCurrentAlarmState ^ ethPreviousAlarmState);
-
-			/* check port los alarm*/
-			reportBitmap = 0;
-			clearBitmap = 0;
-			for(i=0; i<TPM_MAX_NUM_ETH_PORTS; i++)
-			{
-				if(ethChangedAlarm & (1 << i))
-				{
-					/*save report port los alarm*/
-					if(ethCurrentAlarmState & (1 << i))
-					{
-						reportBitmap |= (1 << i);
-					}
-					else /*save clear port los alarm*/
-					{
-						clearBitmap |= (1 << i);
-					}
-				}
-			}
-
-			/*if report port los alarm exists*/
-			if(reportBitmap)
-			{
-				*alarm_type |= ONU_EPON_ALARM_ETH_PORT_LOS;
-				port_bitmap[MAX_ETH_PORT_ALARM+ONU_EPON_ALARM_ETH_PORT_LOS-1] = reportBitmap;
-			}
-
-			/*if clear port los alarm exists*/
-			if(clearBitmap)
-			{
-				*alarm_type |= ONU_EPON_ALARM_ETH_PORT_LOS_CLEAR;
-				port_bitmap[ONU_EPON_ALARM_ETH_PORT_LOS-1] = clearBitmap;
-			}
-		}
-
-		/* save current eth port los alarm status */
-		gportLosPreviousAlarm = ethCurrentAlarmState;
-	}
-
-	if (trace_sw_dbg_flag)
-	{
-		printk(KERN_INFO
-			"==EXIT== %s: alarm_type=%08x, port_bitmap[%02x][%02x]\n\r",__FUNCTION__, *alarm_type,port_bitmap[ONU_EPON_ALARM_ETH_PORT_LOS-1],
-			port_bitmap[MAX_ETH_PORT_ALARM+ONU_EPON_ALARM_ETH_PORT_LOS-1] );
-	}
-
-	return retVal;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.h
deleted file mode 100644
index 210fb3b..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_alarm.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* tpm_alarm.h
-*
-*
-*  MODULE : TPM Alarm
-*
-*  DESCRIPTION : This file config tpm alarm
-*
-*  MODIFICATION HISTORY:
-*           12Dec2010   Victor  - initial version created.
-*
-* FILE REVISION NUMBER:
-*       $Revision: 1.3 $
-*******************************************************************************/
-
-#ifndef __INC_TPM_ALARM_CONFIG
-#define __INC_TPM_ALARM_CONFIG
-
-/* Include Files
-------------------------------------------------------------------------------*/
-
-/* Definitions
-------------------------------------------------------------------------------*/
-#define                           IN
-#define                           OUT
-
-#define ONU_EPON_ALARM_ETH_PORT_AUTONEG_FAIL  (0x0001)
-#define ONU_EPON_ALARM_ETH_PORT_LOS   (0x0002)
-#define ONU_EPON_ALARM_ETH_PORT_FAIL  (0x0004)
-#define ONU_EPON_ALARM_ETH_PORT_LOOPBACK  (0x0008)
-#define ONU_EPON_ALARM_ETH_PORT_CONGESTION    (0x0010)
-
-#define ONU_EPON_ALARM_ETH_PORT_AUTONEG_FAIL_CLEAR  (0x0001<<16)
-#define ONU_EPON_ALARM_ETH_PORT_LOS_CLEAR   (0x0002<<16)
-#define ONU_EPON_ALARM_ETH_PORT_FAIL_CLEAR  (0x0004<<16)
-#define ONU_EPON_ALARM_ETH_PORT_LOOPBACK_CLEAR  (0x0008<<16)
-#define ONU_EPON_ALARM_ETH_PORT_CONGESTION_CLEAR    (0x0010<<16)
-
-#define ONU_EPON_ALARM_ETH_DEF_STATE (ONU_EPON_ALARM_ETH_PORT_AUTONEG_FAIL	| \
-                                  ONU_EPON_ALARM_ETH_PORT_LOS			| \
-                                  ONU_EPON_ALARM_ETH_PORT_FAIL			| \
-                                  ONU_EPON_ALARM_ETH_PORT_LOOPBACK		| \
-                                  ONU_EPON_ALARM_ETH_PORT_CONGESTION)
-
-/* Enums
-------------------------------------------------------------------------------*/
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-/* ONU EPON ETH port Alarm table */
-typedef struct
-{
-	uint32_t			 alarm_type;
-	uint8_t				 port_bitmap[MAX_ETH_PORT_ALARM];
-}S_OnuEponEthAlarmTbl;
-
-
-/* Global variables
-------------------------------------------------------------------------------*/
-//S_OnuEponEthAlarmTbl g_onuEponAlarmEth;
-
-/* Global functions
-------------------------------------------------------------------------------*/
- /*******************************************************************************
-* tpm_alarm_get_eth_port
-*
-* DESCRIPTION:
-*       This function gets eth port alarm.
-*
-* INPUTS:
-*       owner_id	 - APP owner id , should be used for all API calls.
-*
-* OUTPUTS:
-*       alarm_type  - eth alarm type
-*		 port_bitmap	- port bitmap
-* RETURNS:
-*       On success -  TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_alarm_get_eth_port
-(
-	uint32_t  owner_id,
-	uint32_t *alarm_type,
-	uint8_t  *port_bitmap
-);
-
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.c
deleted file mode 100644
index 7e76f1d..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.c
+++ /dev/null
@@ -1,5012 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-/* Local variables */
-//spinlock_t tpmModLock;
-
-spinlock_t tpmMod2JumpEntryLock;
-spinlock_t tpmMod2ChainEntryLock;
-spinlock_t tpmMod2PmtHwLock;
-
-
-
-/*******************************************************************************
-                               Global definitions
-*******************************************************************************/
-#define TPM_IPV6_ADDR_LEN    (16)
-
-/* Null MAC address */
-uint8_t null_mac_address[TPM_SA_LEN] = {0,0,0,0,0,0};
-/* Null IPv4 address */
-uint8_t null_ipv4_address[TPM_IPV4_SIP_LEN] = {0,0,0,0};
-/* Null IPv6 address */
-uint8_t null_ipv6_address[TPM_IPV6_ADDR_LEN] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-/* NULL VLAN key */
-tpm_vlan_key_t null_vlan_key = {0,0,0,0,0,0,0};
-
-
-/*******************************************************************************
-                        PROTOTYPES for internal using
-*******************************************************************************/
-int32_t tpm_mod2_process_mh_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_da_set (tpm_gmacs_enum_t      gmac_port,
-                                 uint32_t                bm,
-                                 uint16_t                cmd_idx,
-                                 uint8_t                *skip,
-                                 tpm_pkt_mod_t          *mod_data,
-                                 tpm_mod_pattern_data_t *pattern_data,
-                                 tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_sa_set (tpm_gmacs_enum_t      gmac_port,
-                                 uint32_t                bm,
-                                 uint16_t                cmd_idx,
-                                 uint8_t                *skip,
-                                 tpm_pkt_mod_t          *mod_data,
-                                 tpm_mod_pattern_data_t *pattern_data,
-                                 tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_vlan_mod (tpm_gmacs_enum_t      gmac_port,
-                                   uint32_t                bm,
-                                   uint16_t                cmd_idx,
-                                   uint8_t                *skip,
-                                   tpm_pkt_mod_t          *mod_data,
-                                   tpm_mod_pattern_data_t *pattern_data,
-                                   tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_pppoe_del (tpm_gmacs_enum_t      gmac_port,
-                                    uint32_t                bm,
-                                    uint16_t                cmd_idx,
-                                    uint8_t                *skip,
-                                    tpm_pkt_mod_t          *mod_data,
-                                    tpm_mod_pattern_data_t *pattern_data,
-                                    tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_pppoe_add (tpm_gmacs_enum_t      gmac_port,
-                                    uint32_t                bm,
-                                    uint16_t                cmd_idx,
-                                    uint8_t                *skip,
-                                    tpm_pkt_mod_t          *mod_data,
-                                    tpm_mod_pattern_data_t *pattern_data,
-                                    tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_ipv4_update (tpm_gmacs_enum_t      gmac_port,
-                                      uint32_t                bm,
-                                      uint16_t                cmd_idx,
-                                      uint8_t                *skip,
-                                      tpm_pkt_mod_t          *mod_data,
-                                      tpm_mod_pattern_data_t *pattern_data,
-                                      tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_dscp_set (tpm_gmacs_enum_t      gmac_port,
-                                   uint32_t                bm,
-                                   uint16_t                cmd_idx,
-                                   uint8_t                *skip,
-                                   tpm_pkt_mod_t          *mod_data,
-                                   tpm_mod_pattern_data_t *pattern_data,
-                                   tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_ttl_dec (tpm_gmacs_enum_t      gmac_port,
-                                  uint32_t                bm,
-                                  uint16_t                cmd_idx,
-                                  uint8_t                *skip,
-                                  tpm_pkt_mod_t          *mod_data,
-                                  tpm_mod_pattern_data_t *pattern_data,
-                                  tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_v4_sip_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_v4_dip_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_hoplim_dec (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_l4_src_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_l4_dst_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check);
-int32_t tpm_mod2_process_l4_checksum_set(tpm_gmacs_enum_t      gmac_port,
-                                         uint32_t                bm,
-                                         uint16_t                cmd_idx,
-                                         uint8_t                *skip,
-                                         tpm_pkt_mod_t          *mod_data,
-                                         tpm_mod_pattern_data_t *pattern_data,
-                                         tpm_self_check_enable_t is_tpm_check);
-
-
-
-tpm_mod_flag_bm_entry_t tpm_mod2_jump_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask><process_function>    <opcode>                <mod_data><last><ip4updt><L4updt>*/
-{        0,             0,        0,         NULL,     {{TPM_MOD2_OPCODE_JUMP,          0xFFFF,    0,     0,      0 }}};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_jump_skip2_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask><process_function>    <opcode>                <mod_data><last><ip4updt><L4updt>*/
-{        0,             0,        0,         NULL,     {{TPM_MOD2_OPCODE_JUMP_SKIP2,    0xFFFF,    0,     0,      0 }}};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_jump_subr_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask><process_function>    <opcode>                <mod_data><last><ip4updt><L4updt>*/
-{        0,             0,        0,         NULL,     {{TPM_MOD2_OPCODE_JUMP_SUBR,     0xFFFF,    0,     0,      0 }}};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_skip_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask><process_function>    <opcode>                <mod_data><last><ip4updt><L4updt>*/
-{        0,             0,        0,         NULL,     {{TPM_MOD2_OPCODE_SKIP,          0xFFFF,    0,     0,      0 }}};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_ipv6_tc_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask>            <process_function>*/
-{        2,             4,       TPM_DSCP_SET,    tpm_mod2_process_dscp_set,
-/*         <opcode>                <mod_data><last><ip4updt><L4updt>*/
-    {{TPM_MOD2_OPCODE_REP2,          0x6000,    0,     0,      0 },}
-};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_ipv6_pppoe_pattern =
-/*=============================================================================================*/
-/*  <skip_before><skip_no_parse><mask>            <process_function>*/
-{        2,             4,       TPM_DSCP_SET,    tpm_mod2_process_pppoe_add,
-/*         <opcode>                <mod_data><last><ip4updt><L4updt>*/
-    {{TPM_MOD2_OPCODE_REP2,          0x8864,    0,     0,      0 },
-     {TPM_MOD2_OPCODE_ADD,           0x1100,    0,     0,      0 },
-     {TPM_MOD2_OPCODE_ADD,           0x0000,    0,     0,      0 },
-     {TPM_MOD2_OPCODE_ADD_CALC_LEN,  0x7000,    0,     0,      0 },
-     {TPM_MOD2_OPCODE_ADD,           0x0057,    0,     0,      0 }}
-};
-
-
-tpm_mod_flag_bm_entry_t tpm_mod2_pattern_array[TPM_MAX_PKT_MOD_FLAGS] =
-/*=============================================================================================*/
-{
-    /* TPM_MH_SET            -   Update the Marvell Header*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           0/*skip w/ jump*/, TPM_MH_SET,         tpm_mod2_process_mh_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_MAC_DA_SET     -   Update the MAC DA Address*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           6,        TPM_MAC_DA_SET,     tpm_mod2_process_da_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_MAC_SA_SET     -   Update the MAC SA Address*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           6,        TPM_MAC_SA_SET,     tpm_mod2_process_sa_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_VLAN_MOD       -   Update the VLAN Tags (add/del/update)*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           0,        TPM_VLAN_MOD,       tpm_mod2_process_vlan_mod,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_PPPOE_DEL      -   Delete a PPPoE encapsulation*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           0,        TPM_PPPOE_DEL,      tpm_mod2_process_pppoe_del,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0x0800,    0,     0,      0 },
-         {TPM_MOD2_OPCODE_DEL,           0x0004,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_PPPOE_ADD      -   Add a PPPoE encapsulation*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           0,        TPM_PPPOE_ADD,      tpm_mod2_process_pppoe_add,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_PPPOE,          0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_DSCP_SET       -   Set the DSCP value */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0/* Don't care ety */,           2/* Don't care ety */,        TPM_DSCP_SET,       tpm_mod2_process_dscp_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP_LSB,        0x0300,    0,     1,      0 }},
-    },
-
-    /* TPM_MOD_TTL_DEC        -   Decrease the TTL value */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           8,        TPM_TTL_DEC,        tpm_mod2_process_ttl_dec,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_DEC_TTL_MSB,    0x0300,    0,     1,      0 }},
-    },
-
-    /* TPM_MOD_IPV4_UPDATE    -   Update the IPv4 Header*/
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           2,        TPM_IPV4_UPDATE,    tpm_mod2_process_ipv4_update,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP_IP_CHKSUM,  0x0000,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_IPV4_SRC_SET   -   Set the IPV4 Source Address */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           4,        TPM_IPV4_SRC_SET,   tpm_mod2_process_v4_sip_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     1,      1 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     1,      1 }},
-    },
-
-    /* TPM_MOD_IPV4_DST_SET   -   Set the IPV4 Destination Address */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           4,         TPM_IPV4_DST_SET,   tpm_mod2_process_v4_dip_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     1,      1 },
-         {TPM_MOD2_OPCODE_REP2,          0xFFFF,    0,     1,      1 }},
-    },
-
-    /* TPM_MOD_IPV6_UPDATE    -   Update the IPv6 Header */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           0,         TPM_IPV6_UPDATE,   NULL,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_HOPLIM_DEC     -   Decrease the Hop Limit value */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           6,        TPM_HOPLIM_DEC,     tpm_mod2_process_hoplim_dec,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_DEC_TTL_LSB,    0x0200,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_IPV6_SRC_SET   -   Set the IPV6 Source Address */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,          16,        TPM_IPV6_SRC_SET,   NULL,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_IPV6_DST_SET   -   Set the IPV6 Destination Address */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,          16,        TPM_IPV6_DST_SET,   NULL,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_L4_SRC_SET     -   Set the L4 Source Port (UDP or TCP) */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           2,        TPM_L4_SRC_SET,     tpm_mod2_process_l4_src_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,           0xFFFF,    0,     0,      1 }},
-    },
-
-    /* TPM_MOD_L4_DST_SET     -   Set the L4 Destination Port (UDP or TCP) */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        0,           2,        TPM_L4_DST_SET,     tpm_mod2_process_l4_dst_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP2,           0xFFFF,    0,     0,      1 }},
-    },
-
-};
-
-tpm_mod_flag_bm_entry_t tpm_mod2_int_pattern_array[TPM_MAX_INT_MOD_FLAGS] =
-/*=============================================================================================*/
-{
-    /* TPM_MOD_INT_L4_TCP     -   Update TCP checksum */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {       12,          14,        TPM_INT_L4_TCP,     tpm_mod2_process_l4_checksum_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP_L4_CHKSUM,  0x0000,    0,     0,      0 }},
-    },
-
-    /* TPM_MOD_INT_L4_UDP     -   Update UDP checksum */
-    /*  <skip_before><skip_no_parse><mask>              <process_function>         */
-    {        2,           4,        TPM_INT_L4_UDP,     tpm_mod2_process_l4_checksum_set,
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_REP_L4_CHKSUM,  0x0000,    0,     0,      0 }},
-    },
-};
-
-tpm_mod_vlan_entry_t tpm_mod2_vlan_pattern_array[VLANOP_MAX_NUM] =
-/*=============================================================================================*/
-{
-    /* VLANOP_NOOP                 -        no VLAN operation performed */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},  /* VLAN 1 */
-
-        {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},  /* VLAN 2 */
-    },
-
-    /* VLANOP_EXT_TAG_MOD          -        modify external tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_EXT_TAG_DEL          -        delete external tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_DEL,            0x0002,    0,     0,      0 }},   /* VLAN 1 */
-    },
-
-    /* VLANOP_EXT_TAG_INS          -        insert(prepend) external tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_ADD_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_EXT_TAG_MOD_INS      -        modify existing external tag and insert(prepend) new tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_ADD_VLAN,       0xFFFF,    0,     0,      0 }},
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 2 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_INS_2TAG             -        insert(prepend) 2 new tags */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_ADD_VLAN,       0xFFFF,    0,     0,      0 }},
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 2 */
-        {TPM_MOD2_OPCODE_ADD_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_MOD_2TAG             -        modify 2 tags */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 2 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_SWAP_TAGS            -        swap internal and external tags */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 1 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },    /* VLAN 2 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_DEL_2TAG             -        delete 2 existing tags */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_DEL,            0x0002,    0,     0,      0 }},   /* VLAN 1 */
-
-       {{TPM_MOD2_OPCODE_DEL,            0x0002,    0,     0,      0 }},   /* VLAN 2 */
-    },
-
-    /* VLANOP_INT_TAG_MOD          -        modify existing internal tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_SKIP,           0x0004,    0,     0,      0 }},  /* VLAN 1 */
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },   /* VLAN 2 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_EXT_TAG_DEL_INT_MOD  -        delete existing external tag and modify internal tag */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_DEL,            0x0002,    0,     0,      0 }},  /* VLAN 1 */
-
-       {{TPM_MOD2_OPCODE_CONF_VLAN,      0xFFFF,    0,     0,      0 },   /* VLAN 2 */
-        {TPM_MOD2_OPCODE_REP_VLAN,       0xFFFF,    0,     0,      0 }},
-    },
-
-    /* VLANOP_ILLEGAL              -        illegal VLAN operation */
-    {
-        /*    <opcode>                 <mod_data><last><ip4updt><L4updt>           */
-       {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},  /* VLAN 1 */
-
-       {{TPM_MOD2_OPCODE_NOOP,           0xFFFF,    0,     0,      0 }},  /* VLAN 2 */
-    },
-};
-
-tpm_chain_map_t tpm_mod2_chain_map[] =
-{
-    {TPM_CHAIN_TYPE_L2,         TPM_VLAN_MOD,                                                                                                                       TPM_MOD2_DONT_CARE_INT_BM},
-
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET,                                TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET,                                TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET,                 TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET,                 TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET,                TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET,                TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_L4_SRC_SET, TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_NAPT,  TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_DST_SET | TPM_L4_DST_SET, TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                                 TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                  TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                 TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                 TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                  TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                  TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE,								       TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE,						       TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE,						       TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,						       TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_ADD | TPM_TTL_DEC | TPM_IPV4_UPDATE,				       TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_ROUTE, TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,				       TPM_MOD2_DONT_CARE_INT_BM},
-
-    {TPM_CHAIN_TYPE_MH,         TPM_MH_SET,                                                                                                                         TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_L2,         TPM_MH_SET | TPM_VLAN_MOD,                                                                                                          TPM_MOD2_DONT_CARE_INT_BM},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MH_SET | TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                                                        TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MH_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                                         TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_DA_SET | TPM_MH_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                       TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_DA_SET | TPM_MH_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,                        TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_SA_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                                                                     TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                                                      TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                                    TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV4_MC,    TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_TTL_DEC | TPM_IPV4_UPDATE,                                     TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                                                  TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                                   TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                 TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                  TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MH_SET | TPM_MAC_SA_SET | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                                     TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MH_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                                      TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                                    TPM_INT_MC_MOD},
-    {TPM_CHAIN_TYPE_IPV6_MC,    TPM_MH_SET | TPM_MAC_DA_SET | TPM_MAC_SA_SET | TPM_VLAN_MOD | TPM_PPPOE_DEL | TPM_HOPLIM_DEC | TPM_IPV6_UPDATE,                     TPM_INT_MC_MOD},
-};
-
-#define TPM_CHAIN_MAP_SIZE    (sizeof(tpm_mod2_chain_map)/sizeof(tpm_chain_map_t))
-
-static tpm_mod_pattern_data_t _pattern_data;
-
-/*******************************************************************************
-                               Internal definitions
-*******************************************************************************/
-
-/*******************************************************************************
-                               Internal functions
-*******************************************************************************/
-
-uint16_t tpm_mod2_get_jump_to(tpm_mod2_entry_t *pattern)
-{
-    if (pattern == NULL)
-    {
-        return TPM_MOD2_NULL_ENT_IDX;
-    }
-
-    if ((pattern->opcode == TPM_MOD2_OPCODE_JUMP) ||
-        (pattern->opcode == TPM_MOD2_OPCODE_JUMP_SKIP2) ||
-        (pattern->opcode == TPM_MOD2_OPCODE_JUMP_SUBR))
-    {
-        return pattern->data;
-    }
-
-    return TPM_MOD2_NULL_ENT_IDX;
-}
-
-tpm_pattern_entry_t * tpm_mod2_get_chain_from_pattern_set(tpm_pattern_entry_t *pattern_set, tpm_chain_type_t chain_type, uint16_t chain_idx)
-{
-    uint8_t set_idx, fst_free = TPM_MOD2_MAX_PATTERN_SETS;
-
-    for (set_idx = 1; set_idx < TPM_MOD2_MAX_PATTERN_SETS; set_idx++)
-    {
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            if (pattern_set[set_idx].is_valid == 0)
-            {
-                fst_free = set_idx;
-                break;
-            }
-        }
-        else if (pattern_set[set_idx].is_valid)
-        {
-            if ((TPM_AREA_TYPE_CHAIN == pattern_set[set_idx].area_type) &&
-                (chain_type == pattern_set[set_idx].chain_type) &&
-                (chain_idx ==  pattern_set[set_idx].index))
-            {
-                return &pattern_set[set_idx];
-            }
-        }
-        else if (fst_free == TPM_MOD2_MAX_PATTERN_SETS)
-        {
-            fst_free = set_idx;
-        }
-    }
-
-    if (chain_idx != TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        return NULL;
-    }
-
-    if (fst_free != TPM_MOD2_MAX_PATTERN_SETS)
-    {
-        pattern_set[fst_free].is_valid   = 1;
-        pattern_set[fst_free].area_type  = TPM_AREA_TYPE_CHAIN;
-        pattern_set[fst_free].chain_type = chain_type;
-    }
-
-    return &pattern_set[fst_free];
-}
-
-/*******************************************************************************
-* tpm_mod2_parse_chain_type()
-*
-* DESCRIPTION: The API is mapping mod bitmap into chain type - BM vs chain_type
-*
-* INPUTS:   mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           chain_type
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-tpm_chain_type_t tpm_mod2_parse_chain_type(tpm_pkt_mod_bm_t mod_bm, tpm_pkt_mod_int_bm_t int_mod_bm)
-{
-    uint32_t map_idx;
-
-    for (map_idx = 0; map_idx < TPM_CHAIN_MAP_SIZE; map_idx++) {
-        if (mod_bm == tpm_mod2_chain_map[map_idx].mod_bm) {
-		if (tpm_mod2_chain_map[map_idx].int_mod_bm == TPM_MOD2_DONT_CARE_INT_BM ||
-				int_mod_bm == tpm_mod2_chain_map[map_idx].int_mod_bm) {
-	            return tpm_mod2_chain_map[map_idx].chain_type;
-		}
-        }
-    }
-
-    return TPM_CHAIN_TYPE_NONE;
-}
-
-/*******************************************************************************
-* tpm_mod2_validate_logical_params()
-*
-* DESCRIPTION: The API is validating the params - BM vs mod_data
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           mod_data    - modification entry data
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_validate_logical_params   (tpm_gmacs_enum_t   gmac_port,
-                                               tpm_pkt_mod_bm_t   mod_bm,
-                                               tpm_pkt_mod_int_bm_t int_mod_bm,
-                                               tpm_pkt_mod_t     *mod_data,
-                                               uint32_t          *mod_entry)
-{
-    tpm_chain_type_t chain_type;
-    tpm_mac_key_t   *mac_data = &mod_data->mac_mod;
-    tpm_pppoe_key_t *pppoe_data = &mod_data->pppoe_mod;
-    uint8_t          forbid_dbl_tag_oper = 0;
-
-    if (gmac_port >= TPM_MAX_NUM_GMACS)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: port %d \n", gmac_port);
-        return TPM_FAIL;
-    }
-
-    if (mod_data == NULL ||
-        mod_entry == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    if (mod_bm == 0)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL bitmap\n");
-        return TPM_FAIL;
-    }
-
-    chain_type = tpm_mod2_parse_chain_type(mod_bm, int_mod_bm);
-    if (chain_type == TPM_CHAIN_TYPE_NONE)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: unsupported bitmap 0x%05x\n", mod_bm);
-        return TPM_FAIL;
-    }
-
-    if (chain_type == TPM_CHAIN_TYPE_IPV4_NAPT ||
-        chain_type == TPM_CHAIN_TYPE_IPV4_MC   ||
-        chain_type == TPM_CHAIN_TYPE_ROUTE)
-    {
-        forbid_dbl_tag_oper = 1;
-    }
-
-    /* for every bit set in the BM - check that the mod_data has the values ok - not NULL pointers */
-    if (mod_bm & TPM_MH_SET)
-    {
-        if (!tpm_db_mod2_get_multicast_mh_state())
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: MH disabled\n");
-            return TPM_FAIL;
-        }
-        if (mod_data->mh_mod == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: Zero MH_2B\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_MAC_DA_SET)
-    {
-        if (memcmp(mac_data->mac_da, null_mac_address, TPM_DA_LEN) == 0 ||
-            memcmp(mac_data->mac_da_mask, null_mac_address, TPM_DA_LEN) == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL DST MAC\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_MAC_SA_SET)
-    {
-        if (memcmp(mac_data->mac_sa, null_mac_address, TPM_SA_LEN) == 0 ||
-            memcmp(mac_data->mac_sa_mask, null_mac_address, TPM_SA_LEN) == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL SRC MAC\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_VLAN_MOD)
-    {
-        tpm_vlan_oper_t vlan_oper = mod_data->vlan_mod.vlan_op;
-        tpm_vlan_key_t *v1_out = &mod_data->vlan_mod.vlan1_out, *v2_out = &mod_data->vlan_mod.vlan2_out;
-#if 0
-        /* Currently VLAN modification request cannot include other modifications */
-        if (mod_bm != TPM_VLAN_MOD)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN modification BM (0x%x)\n", mod_bm);
-            return TPM_FAIL;
-        }
-#endif
-        if (vlan_oper >= VLANOP_ILLEGAL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN op. %d \n", vlan_oper);
-            return TPM_FAIL;
-        }
-
-        if (!tpm_db_mod2_get_double_tag_state() || forbid_dbl_tag_oper)
-        {
-            if (vlan_oper == VLANOP_EXT_TAG_MOD_INS ||
-                vlan_oper == VLANOP_INS_2TAG ||
-                vlan_oper == VLANOP_MOD_2TAG ||
-                vlan_oper == VLANOP_SWAP_TAGS ||
-                vlan_oper == VLANOP_DEL_2TAG ||
-                vlan_oper == VLANOP_INT_TAG_MOD ||
-                vlan_oper == VLANOP_EXT_TAG_DEL_INT_MOD)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Unsupport double VLAN Operation: VLAN op. %d \n", vlan_oper);
-                return TPM_FAIL;
-            }
-        }
-
-		switch (vlan_oper) {
-
-		case VLANOP_INS_2TAG:
-			if ((v1_out->tpid == 0) || (v1_out->tpid_mask == 0)) {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: v2 TPID is NULL for add action\n");
-                return TPM_FAIL;
-			}
-		case VLANOP_EXT_TAG_INS:
-			if ((v1_out->tpid == 0) || (v1_out->tpid_mask == 0)) {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: v1 TPID is NULL for add action\n");
-                return TPM_FAIL;
-			}
-			break;
-
-		case VLANOP_EXT_TAG_MOD_INS:
-		case VLANOP_MOD_2TAG:
-		case VLANOP_SWAP_TAGS:
-			if ((v2_out->tpid == 0) && (v2_out->tpid_mask == 0xffff)) {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: v2 TPID is NULL for modify new action\n");
-                return TPM_FAIL;
-			}
-		case VLANOP_EXT_TAG_MOD:
-			if ((v1_out->tpid == 0) && (v1_out->tpid_mask == 0xffff)) {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: v1 TPID is NULL for modify new action\n");
-                return TPM_FAIL;
-			}
-			break;
-
-		case VLANOP_INT_TAG_MOD:
-		case VLANOP_EXT_TAG_DEL_INT_MOD:
-			if ((v2_out->tpid == 0) && (v2_out->tpid_mask == 0xffff)) {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: v2 TPID is NULL for modify new action\n");
-                return TPM_FAIL;
-			}
-			break;
-
-		default:
-			break;
-		}
-
-        if ( v1_out->vid_mask != TPM_MOD2_ORIGINAL_VID &&
-             v1_out->vid_mask != TPM_MOD2_NEW_VID )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN1 mask - %x\n", v1_out->vid_mask);
-            return TPM_FAIL;
-        }
-
-        if ( v2_out->vid_mask != TPM_MOD2_ORIGINAL_VID &&
-             v2_out->vid_mask != TPM_MOD2_NEW_VID )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN2 mask - %x\n", v2_out->vid_mask);
-            return TPM_FAIL;
-        }
-
-        if ( v1_out->cfi_mask != TPM_MOD2_ORIGINAL_CFI &&
-             v1_out->cfi_mask != TPM_MOD2_NEW_CFI )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN1 CFI mask - %x\n", v1_out->cfi_mask);
-            return TPM_FAIL;
-        }
-
-        if ( v2_out->cfi_mask != TPM_MOD2_ORIGINAL_CFI &&
-             v2_out->cfi_mask != TPM_MOD2_NEW_CFI )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN2 CFI mask - %x\n", v2_out->cfi_mask);
-            return TPM_FAIL;
-        }
-
-        if ( v1_out->pbit_mask != TPM_MOD2_ORIGINAL_PBIT &&
-             v1_out->pbit_mask != TPM_MOD2_NEW_PBIT )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN1 PBIT mask - %x\n", v1_out->pbit_mask);
-            return TPM_FAIL;
-        }
-
-        if ( v2_out->pbit_mask != TPM_MOD2_ORIGINAL_PBIT &&
-             v2_out->pbit_mask != TPM_MOD2_NEW_PBIT )
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: VLAN2 PBIT mask - %x\n", v2_out->pbit_mask);
-            return TPM_FAIL;
-        }
-    }
-
-    if ((mod_bm & TPM_PPPOE_DEL || mod_bm & TPM_PPPOE_ADD) &&
-        !tpm_db_mod2_get_pppoe_add_mod_state())
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: PPPoE disabled\n");
-        return TPM_FAIL;
-    }
-
-    if (mod_bm & TPM_PPPOE_DEL &&
-        mod_bm & TPM_PPPOE_ADD)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: BM includes PPPoE add and del flags\n");
-        return TPM_FAIL;
-    }
-
-    if (mod_bm & TPM_PPPOE_ADD)
-    {
-        if (pppoe_data->ppp_proto == 0 ||
-            pppoe_data->ppp_session == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL PPPoE data\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_IPV4_UPDATE)
-    {
-        tpm_ipv4_acl_key_t *ipv4_data = &(mod_data->l3.ipv4_mod);
-        if (mod_bm & TPM_IPV4_DST_SET)
-        {
-            if (memcmp(ipv4_data->ipv4_dst_ip_add, null_ipv4_address, TPM_IPV4_SIP_LEN) == 0 ||
-                memcmp(ipv4_data->ipv4_dst_ip_add_mask, null_ipv4_address, TPM_IPV4_SIP_LEN) == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL DST IPv4 data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_IPV4_SRC_SET)
-        {
-            if (memcmp(ipv4_data->ipv4_src_ip_add, null_ipv4_address, TPM_IPV4_SIP_LEN) == 0 ||
-                memcmp(ipv4_data->ipv4_src_ip_add_mask, null_ipv4_address, TPM_IPV4_SIP_LEN) == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL SRC IPv4 data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_DSCP_SET)
-        {
-            if (ipv4_data->ipv4_dscp == 0 ||
-                ipv4_data->ipv4_dscp_mask == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL IPv4 DSCP data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_L4_DST_SET)
-        {
-            if (ipv4_data->l4_dst_port == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL L4 DST port\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_L4_SRC_SET)
-        {
-            if (ipv4_data->l4_src_port == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL L4 SRC port\n");
-                return TPM_FAIL;
-            }
-        }
-    }
-    else
-    {
-        if (mod_bm & TPM_IPV4_DST_SET ||
-            mod_bm & TPM_IPV4_SRC_SET ||
-            mod_bm & TPM_TTL_DEC)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid flags: TPM_IPV4_UPDATE should be set\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_IPV6_UPDATE)
-    {
-        tpm_ipv6_acl_key_t *ipv6_data = &mod_data->l3.ipv6_mod;
-        if (mod_bm & TPM_IPV6_DST_SET)
-        {
-            if (memcmp(ipv6_data->ipv6_dst_ip_add, null_ipv6_address, TPM_IPV6_ADDR_LEN) == 0 ||
-                memcmp(ipv6_data->ipv6_dst_ip_add_mask, null_ipv6_address, TPM_IPV6_ADDR_LEN) == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL DST IPv6 data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_IPV6_SRC_SET)
-        {
-            if (memcmp(ipv6_data->ipv6_src_ip_add, null_ipv6_address, TPM_IPV6_ADDR_LEN) == 0 ||
-                memcmp(ipv6_data->ipv6_src_ip_add_mask, null_ipv6_address, TPM_IPV6_ADDR_LEN) == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL SRC IPv6 data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_DSCP_SET)
-        {
-            if (ipv6_data->ipv6_dscp == 0 ||
-                ipv6_data->ipv6_dscp_mask == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL IPv6 DSCP data\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_L4_DST_SET)
-        {
-            if (ipv6_data->l4_dst_port == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL L6 DST port\n");
-                return TPM_FAIL;
-            }
-        }
-
-        if (mod_bm & TPM_L4_SRC_SET)
-        {
-            if (ipv6_data->l4_src_port == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL L6 SRC port\n");
-                return TPM_FAIL;
-            }
-        }
-    }
-    else
-    {
-        if (mod_bm & TPM_IPV6_DST_SET ||
-            mod_bm & TPM_IPV6_SRC_SET ||
-            mod_bm & TPM_HOPLIM_DEC)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid flags: TPM_IPV6_UPDATE should be set\n");
-            return TPM_FAIL;
-        }
-    }
-
-    if (mod_bm & TPM_DSCP_SET     &&
-        !(mod_bm & TPM_IPV6_UPDATE) &&
-        !(mod_bm & TPM_IPV4_UPDATE))
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid flags: TPM_IPV4_UPDATE or TPM_IPV6_UPDATE should be set\n");
-        return TPM_FAIL;
-    }
-
-    if (mod_bm & TPM_L4_SRC_SET   ||
-        mod_bm & TPM_L4_DST_SET   ||
-        mod_bm & TPM_IPV6_SRC_SET ||
-        mod_bm & TPM_IPV6_DST_SET ||
-        mod_bm & TPM_IPV4_SRC_SET ||
-        mod_bm & TPM_IPV4_DST_SET)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Internal BM verification (0x%x)\n", int_mod_bm);
-
-        if (int_mod_bm == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL internal modification BM \n");
-            return TPM_FAIL;
-        }
-#if 0
-        else if (int_mod_bm & TPM_INT_2_VLANS)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: TPM_INT_2_VLANS should NOT be set \n");
-            return TPM_FAIL;
-        }
-#endif
-    }
-
-    if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) && (int_mod_bm & TPM_INT_SPLIT_MOD))
-    {
-        if (mod_bm == TPM_VLAN_MOD)
-        {
-            if ((mod_data->vlan_mod.vlan_op != VLANOP_EXT_TAG_MOD) &&
-                (mod_data->vlan_mod.vlan_op != VLANOP_EXT_TAG_INS) &&
-                (mod_data->vlan_mod.vlan_op != VLANOP_EXT_TAG_MOD_INS) &&
-                (mod_data->vlan_mod.vlan_op != VLANOP_NOOP))
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: vlan_op should be one of VLANOP_EXT_TAG_MOD, VLANOP_EXT_TAG_INS and VLANOP_EXT_TAG_MOD_INS. \n");
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: TPM_VLAN_MOD should be set. \n");
-            return TPM_FAIL;
-        }
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_single_command_add()
-*
-*******************************************************************************/
-static int32_t tpm_mod2_single_command_add(tpm_mod_flag_bm_entry_t *cmd_pattern,
-                                           uint16_t                data,
-                                           tpm_pattern_entry_t    *entry_p)
-{
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), &(cmd_pattern->entry), sizeof(tpm_mod2_entry_t));
-        entry_p->line[entry_p->line_num++].data = data;
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added command 0x%x (data=0x%x pattern_line=%d)\n",
-                    cmd_pattern->entry[0].opcode, data, entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_skip_command_add()
-*
-*******************************************************************************/
-static int32_t  tpm_mod2_skip_command_add (uint8_t *skip,
-                                           uint8_t              skip_before,
-                                           tpm_pattern_entry_t *entry_p)
-{
-    if (*skip || skip_before)
-    {
-        /* Add SKIP */
-        if (tpm_mod2_single_command_add(&tpm_mod2_skip_pattern, (*skip + skip_before), entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-
-        *skip = 0;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_skip_to_l3_off_command_add()
-*
-*******************************************************************************/
-static int32_t  tpm_mod2_skip_to_l3_offset_command_add (uint8_t *skip,
-                                           uint8_t              mod_data,
-                                           tpm_pattern_entry_t *entry_p)
-{
-    /* Add SKIP */
-    if (tpm_mod2_single_command_add(&tpm_mod2_skip_pattern,
-                                    ((0x2 << 12)/*add l3_offset*/ | (0x2 << 8)/*sub mod_data*/ | mod_data),
-                                    entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    *skip = 0;
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_fill_in_vlan_data()
-*
-*******************************************************************************/
-uint32_t tpm_mod2_fill_in_vlan_data (tpm_vlan_key_t      *vlan_data)
-{
-    uint32_t tpm_data = 0;
-
-    tpm_data  = (vlan_data->vid << TPM_MOD2_ENTRY_VID_OFFS) & TPM_MOD2_ENTRY_VID_MASK;
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "tpm_data 1: 0x%4.4x (vid 0x%x mask 0x%x)\n",
-                 tpm_data, vlan_data->vid, vlan_data->vid_mask);
-
-    tpm_data |= (vlan_data->cfi << TPM_MOD2_ENTRY_CFI_OFFS) & TPM_MOD2_ENTRY_CFI_MASK;
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "tpm_data 2: 0x%4.4x (cfi 0x%x mask 0x%x)\n",
-                 tpm_data, vlan_data->cfi, vlan_data->cfi_mask);
-
-    tpm_data |= (vlan_data->pbit << TPM_MOD2_ENTRY_PBIT_OFFS) & TPM_MOD2_ENTRY_PBIT_MASK;
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "tpm_data 3: 0x%4.4x (pbit 0x%x mask 0x%x)\n",
-                 tpm_data, vlan_data->pbit, vlan_data->pbit_mask);
-
-    return (tpm_data & TPM_MOD2_ENTRY_MOD_DATA_MASK);
-}
-
-/*******************************************************************************
-* tpm_mod2_process_mh_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_mh_set (tpm_gmacs_enum_t      gmac_port,
-                                 uint32_t                bm,
-                                 uint16_t                cmd_idx,
-                                 uint8_t                *skip,
-                                 tpm_pkt_mod_t          *mod_data,
-                                 tpm_mod_pattern_data_t *pattern_data,
-                                 tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    tmp_pattern[TPM_MOD2_MH_CMD_ENTRIES];
-    uint16_t            chain_idx = TPM_MOD2_INVALID_CHAIN_ID, main_chain_id = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t            jump_to;
-
-    memset(tmp_pattern, 0, sizeof(tmp_pattern));
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    /* Build pattern entries */
-    memcpy(tmp_pattern, tpm_mod2_pattern_array[cmd_idx].entry, sizeof(tmp_pattern));
-    tmp_pattern[0].data = mod_data->mh_mod;
-    tmp_pattern[0].last = 1;
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /* Scan mh db to check if the MH subchain exist or not. */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, TPM_CHAIN_TYPE_MH, TPM_MOD2_MH_CMD_ENTRIES, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        if(is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "TPM check sub chain-%d failed\n", TPM_CHAIN_TYPE_MH);
-            return TPM_FAIL;
-        }
-
-        if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_MH)
-        {
-            chain_idx = pattern_data->main_chain_id;
-        }
-        else
-        {
-            /* Get next free chain index of MH subchain area */
-            chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, TPM_CHAIN_TYPE_MH);
-            if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-            {
-                spin_unlock_bh(&tpmMod2ChainEntryLock);
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the mac subchain \n");
-                return TPM_FAIL;
-            }
-        }
-    }
-    else
-    {
-        if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_MH)
-        {
-            main_chain_id = chain_idx;
-        }
-    }
-    /* Write to mh db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, TPM_CHAIN_TYPE_MH, chain_idx,
-                                        TPM_MOD2_MH_CMD_ENTRIES, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set mh subr chain entry\n");
-            return TPM_FAIL;
-        }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill MH entries in local pattern set */
-    if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_MH)
-    {
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-        if (main_chain_id != TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            tpm_db_mod2_rollback_chain_entry(gmac_port, TPM_CHAIN_TYPE_MH, pattern_data->main_chain_id, false);
-            pattern_data->main_chain_id = main_chain_id;
-        }
-    }
-    else
-    {
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_MH, TPM_MOD2_INVALID_CHAIN_ID);
-    }
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if ((entry_p->line_num + TPM_MOD2_MH_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_MH_CMD_ENTRIES);
-        entry_p->line_num += TPM_MOD2_MH_CMD_ENTRIES;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Update main chain */
-    if (pattern_data->main_chain_type != TPM_CHAIN_TYPE_MH)
-    {
-        /* Convert Chain Index to PMT Index */
-        jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_MH, chain_idx);
-        if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-        {
-            TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-            return TPM_FAIL;
-        }
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    }
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_mod2_process_da_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_da_set (tpm_gmacs_enum_t      gmac_port,
-                                 uint32_t                bm,
-                                 uint16_t                cmd_idx,
-                                 uint8_t                *skip,
-                                 tpm_pkt_mod_t          *mod_data,
-                                 tpm_mod_pattern_data_t *pattern_data,
-                                 tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    tmp_pattern[TPM_MOD2_MAC_CMD_ENTRIES];
-    uint16_t            chain_idx = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t            jump_to;
-    uint8_t             *mac_array = NULL;
-
-    memset(tmp_pattern, 0, sizeof(tmp_pattern));
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    /* Skip to DA field */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Build pattern entries */
-    memcpy(tmp_pattern, tpm_mod2_pattern_array[cmd_idx].entry, sizeof(tmp_pattern));
-
-    mac_array = mod_data->mac_mod.mac_da;
-
-    tmp_pattern[0].data = (mac_array[0] << 8) | mac_array[1];
-    tmp_pattern[1].data = (mac_array[2] << 8) | mac_array[3];
-    tmp_pattern[2].data = (mac_array[4] << 8) | mac_array[5];
-    tmp_pattern[2].last = 1;
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /* Scan mac db to check if the mac subchain exist or not. */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC, TPM_MOD2_MAC_CMD_ENTRIES, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        if(is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "TPM check sub chain-%d failed\n", TPM_CHAIN_TYPE_MAC);
-            return TPM_FAIL;
-        }
-        /* Get next free chain index of mac subchain area */
-        chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC);
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the mac subchain \n");
-            return TPM_FAIL;
-        }
-    }
-    /* Write to mac db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC, chain_idx,
-	                                TPM_MOD2_MAC_CMD_ENTRIES, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set mac subr chain entry\n");
-            return TPM_FAIL;
-        }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill DA entries in local pattern set */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_MAC, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if ((entry_p->line_num + TPM_MOD2_MAC_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_MAC_CMD_ENTRIES);
-        entry_p->line_num += TPM_MOD2_MAC_CMD_ENTRIES;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the mac.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Add jump/jump_subr command in main_chain */
-    /* Convert Chain Index to PMT Index */
-    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_MAC, chain_idx);
-    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        return TPM_FAIL;
-    }
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-    if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_L2)
-    {
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_single_command_add(&tpm_mod2_jump_pattern, jump_to, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_sa_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_sa_set (tpm_gmacs_enum_t      gmac_port,
-                                 uint32_t                bm,
-                                 uint16_t                cmd_idx,
-                                 uint8_t                *skip,
-                                 tpm_pkt_mod_t          *mod_data,
-                                 tpm_mod_pattern_data_t *pattern_data,
-                                 tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    tmp_pattern[TPM_MOD2_MAC_CMD_ENTRIES];
-    uint16_t            chain_idx = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t            jump_to;
-    uint8_t             *mac_array = NULL;
-
-
-    memset(tmp_pattern, 0, sizeof(tmp_pattern));
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    /* Skip to SA field */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Build pattern entries */
-    memcpy(tmp_pattern, tpm_mod2_pattern_array[cmd_idx].entry, sizeof(tmp_pattern));
-
-    mac_array = mod_data->mac_mod.mac_sa;
-
-    tmp_pattern[0].data = (mac_array[0] << 8) | mac_array[1];
-    tmp_pattern[1].data = (mac_array[2] << 8) | mac_array[3];
-    tmp_pattern[2].data = (mac_array[4] << 8) | mac_array[5];
-    tmp_pattern[2].last = 1;
-
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /* Scan mac db to check if the mac subchain exist or not. */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC, TPM_MOD2_MAC_CMD_ENTRIES, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        if(is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "TPM check sub chain-%d failed\n", TPM_CHAIN_TYPE_MAC);
-            return TPM_FAIL;
-        }
-        /* Get next free chain index of mac subchain area */
-        chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC);
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the mac subchain \n");
-            return TPM_FAIL;
-        }
-    }
-    /* Write to mac db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, TPM_CHAIN_TYPE_MAC, chain_idx,
-	                                TPM_MOD2_MAC_CMD_ENTRIES, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set mac subr chain entry\n");
-            return TPM_FAIL;
-        }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill SA entries in local pattern set */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_MAC, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if ((entry_p->line_num + TPM_MOD2_MAC_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_MAC_CMD_ENTRIES);
-        entry_p->line_num += TPM_MOD2_MAC_CMD_ENTRIES;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the mac.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* add jump/jump_subr command in main_chain */
-    /* Convert Chain Index to PMT Index */
-    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_MAC, chain_idx);
-    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        return TPM_FAIL;
-    }
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-    if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_L2)
-    {
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_single_command_add(&tpm_mod2_jump_pattern, jump_to, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    }
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_mod2_configured_vlan_oper_set()
-*
-*******************************************************************************/
-uint16_t tpm_mod2_configured_vlan_oper_set (tpm_gmacs_enum_t      gmac_port,
-                                           tpm_mod2_entry_t       *patt_entry,
-                                           tpm_vlan_key_t         *vlan_data,
-                                           uint16_t               *conf_data,
-                                           tpm_mod_pattern_data_t *pattern_data,
-                                           tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    tmp_pattern[TPM_MOD2_MAX_VLAN_ENTRIES];
-    uint16_t            chain_idx = TPM_MOD2_INVALID_CHAIN_ID;
-
-    memset(tmp_pattern, 0, sizeof(tmp_pattern));
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    /* Build pattern entries */
-    memcpy(tmp_pattern, patt_entry, sizeof(tmp_pattern));
-    if (conf_data)
-    {
-        tmp_pattern[0].data = *conf_data;
-    }
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d: 0x%4.4x, 0x%4.4x\n",
-                 1, tmp_pattern[0].opcode, tmp_pattern[0].data);
-    if (vlan_data)
-    {
-        tmp_pattern[1].data = tpm_mod2_fill_in_vlan_data(vlan_data);
-    }
-    if (conf_data == NULL || patt_entry->opcode == TPM_MOD2_OPCODE_SKIP)
-    {
-        tmp_pattern[0].last = 1;
-    }
-    else
-    {
-        tmp_pattern[1].last = 1;
-    }
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d: 0x%4.4x, 0x%4.4x\n",
-                 1, tmp_pattern[0].opcode, tmp_pattern[0].data);
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d: 0x%4.4x, 0x%4.4x\n",
-                 2, tmp_pattern[1].opcode, tmp_pattern[1].data);
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /* Scan vlan db to check if the vlan subchain exist or not. */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, TPM_CHAIN_TYPE_VLAN, TPM_MOD2_MAX_VLAN_ENTRIES, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        if(is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "sub chain-%d check failed\n",TPM_CHAIN_TYPE_VLAN);
-            return TPM_MOD2_INVALID_CHAIN_ID;
-        }
-        /* Get next free chain index of vlan subchain area */
-        chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, TPM_CHAIN_TYPE_VLAN);
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the vlan subchain \n");
-            return TPM_MOD2_INVALID_CHAIN_ID;
-        }
-    }
-    /* Write to vlan db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, TPM_CHAIN_TYPE_VLAN, chain_idx,
-	                                TPM_MOD2_MAX_VLAN_ENTRIES, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set vlan subr chain entry\n");
-            return TPM_FAIL;
-        }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill VLAN entries in local pattern set */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_VLAN, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if ((entry_p->line_num + TPM_MOD2_MAX_VLAN_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_MAX_VLAN_ENTRIES);
-        entry_p->line_num += TPM_MOD2_MAX_VLAN_ENTRIES;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the vlan.pattern (%d)\n", entry_p->line_num);
-        return TPM_MOD2_INVALID_CHAIN_ID;
-    }
-
-    return chain_idx;
-}
-
-/*******************************************************************************
-* tpm_mod2_config_vlan1_data_get()
-*
-*******************************************************************************/
-int32_t tpm_mod2_config_tpid (uint8_t is_vlan1, uint16_t tpid, uint16_t tpid_mask, uint16_t *conf_data)
-{
-	int32_t     rc;
-	uint32_t    eth_type_sel;
-
-	if (tpid_mask == TPM_MOD2_NEW_TPID) {
-		rc = tpm_mod2_tpid_get(tpid, &eth_type_sel);
-
-		if (rc != TPM_OK) {
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get TPID selector (0x%x)\n", tpid);
-			return rc;
-		}
-	} else {
-		if (is_vlan1 != 0)
-			eth_type_sel = TPM_MOD2_TP_FROM_VLAN_1;
-		else
-			eth_type_sel = TPM_MOD2_TP_FROM_VLAN_2;
-	}
-
-	*conf_data = eth_type_sel;
-	return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_config_vlan1_data_get()
-*
-*******************************************************************************/
-int32_t tpm_mod2_config_vlan1_data_get (tpm_vlan_key_t *vlan_data, uint16_t *cdata)
-{
-    uint16_t conf_data;
-    int32_t  rc;
-
-    *cdata = 0;
-
-    rc = tpm_mod2_config_tpid(1, vlan_data->tpid, vlan_data->tpid_mask, &conf_data);
-
-    if (rc != TPM_OK)
-        return rc;
-
-    if (vlan_data->vid_mask == TPM_MOD2_NEW_VID)
-        conf_data |= TPM_MOD2_VID_NEW;
-    else
-        conf_data |= TPM_MOD2_VID_FROM_VLAN_1;
-
-    if (vlan_data->cfi_mask == TPM_MOD2_NEW_CFI)
-        conf_data |= TPM_MOD2_CFI_NEW;
-    else
-        conf_data |= TPM_MOD2_CFI_FROM_VLAN_1;
-
-    if (vlan_data->pbit_mask == TPM_MOD2_NEW_PBIT)
-        conf_data |= TPM_MOD2_PBIT_NEW;
-    else
-        conf_data |= TPM_MOD2_PBIT_FROM_VLAN_1;
-
-    *cdata = conf_data;
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_config_vlan2_data_get()
-*
-*******************************************************************************/
-int32_t tpm_mod2_config_vlan2_data_get (tpm_vlan_key_t *vlan_data, uint16_t *cdata)
-{
-    uint16_t conf_data;
-    int32_t  rc;
-
-    *cdata = 0;
-
-    rc = tpm_mod2_config_tpid(0, vlan_data->tpid, vlan_data->tpid_mask, &conf_data);
-
-    if (rc != TPM_OK)
-        return rc;
-
-    if (vlan_data->vid_mask == TPM_MOD2_NEW_VID)
-        conf_data |= TPM_MOD2_VID_NEW;
-    else
-        conf_data |= TPM_MOD2_VID_FROM_VLAN_2;
-
-    if (vlan_data->cfi_mask == TPM_MOD2_NEW_CFI)
-        conf_data |= TPM_MOD2_CFI_NEW;
-    else
-        conf_data |= TPM_MOD2_CFI_FROM_VLAN_2;
-
-    if (vlan_data->pbit_mask == TPM_MOD2_NEW_PBIT)
-        conf_data |= TPM_MOD2_PBIT_NEW;
-    else
-        conf_data |= TPM_MOD2_PBIT_FROM_VLAN_2;
-
-    *cdata = conf_data;
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_vlan_mod()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_vlan_mod     (tpm_gmacs_enum_t      gmac_port,
-                                       uint32_t                bm,
-                                       uint16_t                cmd_idx,
-                                       uint8_t                *skip,
-                                       tpm_pkt_mod_t          *mod_data,
-                                       tpm_mod_pattern_data_t *pattern_data,
-                                       tpm_self_check_enable_t is_tpm_check)
-{
-    uint16_t    config_data;
-    uint16_t    v1_chain_id = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t    v2_chain_id = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t    jump_to;
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    /* Skip to VLAN field */
-    if (mod_data->vlan_mod.vlan_op != VLANOP_NOOP)
-    {
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-        {
-            if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-            {
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-            return TPM_FAIL;
-        }
-    } else {
-	return TPM_OK;
-    }
-
-    switch(mod_data->vlan_mod.vlan_op)
-    {
-    case VLANOP_EXT_TAG_MOD:
-    /***********************/
-        /* Add VLAN modification commands for VLAN1 */
-        if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_MOD].vlan1,
-                                                            &(mod_data->vlan_mod.vlan1_out),
-                                                            &config_data, pattern_data, is_tpm_check);
-        }
-        break;
-
-    case VLANOP_EXT_TAG_DEL:
-    /***********************/
-        /* Add VLAN delete command for VLAN1 */
-        v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port, tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_DEL].vlan1,
-                                                        NULL, NULL, pattern_data, is_tpm_check);
-        break;
-
-    case VLANOP_EXT_TAG_INS:
-    /***********************/
-        /* Add VLAN add commands for VLAN1 */
-        if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_INS].vlan1,
-                                                           &(mod_data->vlan_mod.vlan1_out),
-                                                           &config_data, pattern_data, is_tpm_check);
-        }
-        break;
-
-    case VLANOP_EXT_TAG_MOD_INS:
-    /***********************/
-        /* Add VLAN add commands for VLAN1 */
-        if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_MOD_INS].vlan1,
-                                                           &(mod_data->vlan_mod.vlan1_out),
-                                                           &config_data, pattern_data, is_tpm_check);
-
-            /* Add VLAN modification commands for VLAN2 */
-            if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-            {
-                v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                                tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_MOD_INS].vlan2,
-                                                                &(mod_data->vlan_mod.vlan2_out),
-                                                                &config_data, pattern_data, is_tpm_check);
-            }
-            else
-            {
-                return TPM_FAIL;
-            }
-        }
-        break;
-
-    case VLANOP_INS_2TAG:
-    /***********************/
-        /* Add VLAN add commands for VLAN1 */
-        if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_INS_2TAG].vlan1,
-                                                            &(mod_data->vlan_mod.vlan1_out),
-                                                            &config_data, pattern_data, is_tpm_check);
-
-            /* Add VLAN add commands for VLAN2 */
-            if (tpm_mod2_config_vlan2_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-            {
-                v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                                tpm_mod2_vlan_pattern_array[VLANOP_INS_2TAG].vlan2,
-                                                                &(mod_data->vlan_mod.vlan2_out),
-                                                                &config_data, pattern_data, is_tpm_check);
-            }
-            else
-            {
-                return TPM_FAIL;
-            }
-        }
-        break;
-
-    case VLANOP_MOD_2TAG:
-    /***********************/
-        /* Add VLAN modification commands for VLAN1 */
-        if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_MOD_2TAG].vlan1,
-                                                            &(mod_data->vlan_mod.vlan1_out),
-                                                            &config_data, pattern_data, is_tpm_check);
-
-            /* Add VLAN modification commands for VLAN2 */
-            if (tpm_mod2_config_vlan2_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-            {
-                v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                                tpm_mod2_vlan_pattern_array[VLANOP_MOD_2TAG].vlan2,
-                                                                &(mod_data->vlan_mod.vlan2_out),
-                                                                &config_data, pattern_data, is_tpm_check);
-            }
-            else
-            {
-                return TPM_FAIL;
-            }
-        }
-        break;
-
-    case VLANOP_SWAP_TAGS:
-    /***********************/
-        /* Add VLAN modification commands for VLAN1 */
-        if (tpm_mod2_config_vlan2_data_get(&(mod_data->vlan_mod.vlan1_out), &config_data) == TPM_OK)
-        {
-		if (mod_data->vlan_mod.vlan1_out.tpid_mask != TPM_MOD2_NEW_TPID)
-			{
-			config_data &= ~(0x7);
-				config_data |= TPM_MOD2_TP_FROM_VLAN_1;
-			}
-            v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_SWAP_TAGS].vlan1,
-                                                            &(mod_data->vlan_mod.vlan1_out),
-                                                            &config_data, pattern_data, is_tpm_check);
-
-            /* Add VLAN modification commands for VLAN2 */
-            if (tpm_mod2_config_vlan1_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-            {
-			if (mod_data->vlan_mod.vlan2_out.tpid_mask != TPM_MOD2_NEW_TPID)
-				{
-				config_data &= ~(0x7);
-					config_data |= TPM_MOD2_TP_FROM_VLAN_2;
-				}
-                v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                                tpm_mod2_vlan_pattern_array[VLANOP_SWAP_TAGS].vlan2,
-                                                                &(mod_data->vlan_mod.vlan2_out),
-                                                                &config_data, pattern_data, is_tpm_check);
-            }
-            else
-            {
-                return TPM_FAIL;
-            }
-        }
-        break;
-
-    case VLANOP_DEL_2TAG:
-    /***********************/
-        v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port, tpm_mod2_vlan_pattern_array[VLANOP_DEL_2TAG].vlan1,
-                                                        NULL, NULL, pattern_data, is_tpm_check);
-        v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port, tpm_mod2_vlan_pattern_array[VLANOP_DEL_2TAG].vlan2,
-                                                        NULL, NULL, pattern_data, is_tpm_check);
-        break;
-
-    case VLANOP_INT_TAG_MOD:
-    /***********************/
-        /* SKIP to the inner VLAN tag */
-        if (*skip)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "skip is not zero (%d)\n", *skip);
-            return TPM_FAIL;
-        }
-
-        config_data = tpm_mod2_vlan_pattern_array[VLANOP_INT_TAG_MOD].vlan1[0].data;
-        v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port, tpm_mod2_vlan_pattern_array[VLANOP_INT_TAG_MOD].vlan1,
-                                                        NULL, &config_data, pattern_data, is_tpm_check);
-
-        /* Add VLAN modification commands for VLAN2 */
-        if (tpm_mod2_config_vlan2_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-        {
-            v2_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_INT_TAG_MOD].vlan2,
-                                                           &(mod_data->vlan_mod.vlan2_out),
-                                                           &config_data, pattern_data, is_tpm_check);
-        }
-        break;
-
-    case VLANOP_EXT_TAG_DEL_INT_MOD:
-    /***********************/
-        /* Add VLAN delete command for VLAN1 */
-        v1_chain_id = tpm_mod2_configured_vlan_oper_set(gmac_port, &(tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_DEL_INT_MOD].vlan1[0]),
-                                                        NULL, NULL, pattern_data, is_tpm_check);
-
-        /* Add VLAN modification commands for VLAN2 */
-        if (tpm_mod2_config_vlan2_data_get(&(mod_data->vlan_mod.vlan2_out), &config_data) == TPM_OK)
-        {
-            v2_chain_id = tpm_mod2_configured_vlan_oper_set (gmac_port,
-                                                            tpm_mod2_vlan_pattern_array[VLANOP_EXT_TAG_DEL_INT_MOD].vlan2,
-                                                            &(mod_data->vlan_mod.vlan2_out),
-                                                            &config_data, pattern_data, is_tpm_check);
-        }
-        break;
-
-    default:
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Do nothing for %d operation \n", mod_data->vlan_mod.vlan_op);
-        return TPM_OK;
-    }
-
-    if ((v1_chain_id == TPM_MOD2_INVALID_CHAIN_ID && v2_chain_id == TPM_MOD2_INVALID_CHAIN_ID) ||
-        v1_chain_id == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No VLAN chain is added \n");
-        return TPM_FAIL;
-    }
-
-    /* Update main chain */
-    if (v1_chain_id != TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        /* Add jump/jump_subr command in main_chain */
-        /* Convert Chain Index to PMT Index */
-        jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_VLAN, v1_chain_id);
-        if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-        {
-            TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-            return TPM_FAIL;
-        }
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        if (pattern_data->main_chain_type != TPM_CHAIN_TYPE_L2 || v2_chain_id != TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-            {
-                if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-                {
-                    return TPM_FAIL;
-                }
-            }
-            else
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-            {
-                if (tpm_mod2_single_command_add(&tpm_mod2_jump_pattern, jump_to, entry_p) != TPM_OK)
-                {
-                    return TPM_FAIL;
-                }
-            }
-            else
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-                return TPM_FAIL;
-            }
-        }
-    }
-
-    if (v2_chain_id != TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        //tpm_pattern_entry_t *v1_entry, *v2_entry;
-
-        //v1_entry = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_VLAN, v1_chain_id);
-        //v2_entry = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, TPM_CHAIN_TYPE_VLAN, v2_chain_id);
-        //if (v1_entry == NULL || v2_entry == NULL)
-        //{
-        //    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get v1 or v2 pattern set. \n");
-        //    return TPM_FAIL;
-        //}
-
-        //if (v1_entry->line_num == v2_entry->line_num &&
-        //    !memcmp(v1_entry->line, v2_entry->line,
-        //            v1_entry->line_num * sizeof(tpm_mod2_entry_t)))
-        //{
-        //    v2_entry->index = v1_chain_id;
-        //    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_VLAN, v1_chain_id);
-        //    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-        //    {
-        //        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        //        return TPM_FAIL;
-        //    }
-        //}
-        //else
-        //{
-            /* Convert Chain Index to PMT Index */
-            jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(TPM_CHAIN_TYPE_VLAN, v2_chain_id);
-            if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-            {
-                TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-                return TPM_FAIL;
-            }
-        //}
-
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        /* Add jump/jump_subr command in main_chain */
-        if (pattern_data->main_chain_type == TPM_CHAIN_TYPE_L2)
-        {
-            if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-            {
-                if (tpm_mod2_single_command_add(&tpm_mod2_jump_pattern, jump_to, entry_p) != TPM_OK)
-                {
-                    return TPM_FAIL;
-                }
-            }
-            else
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-                return TPM_FAIL;
-            }
-        }
-        else
-        {
-            if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-            {
-                if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-                {
-                    return TPM_FAIL;
-                }
-            }
-            else
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-                return TPM_FAIL;
-            }
-        }
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_pppoe_del()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_pppoe_del (tpm_gmacs_enum_t      gmac_port,
-                                    uint32_t                bm,
-                                    uint16_t                cmd_idx,
-                                    uint8_t                *skip,
-                                    tpm_pkt_mod_t          *mod_data,
-                                    tpm_mod_pattern_data_t *pattern_data,
-                                    tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t     tmp_pattern[TPM_MOD2_PPPOE_DEL_CMD_ENTRIES];
-    uint16_t             chain_idx = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t             jump_to;
-	tpm_chain_type_t     subr_chain = TPM_CHAIN_TYPE_PPPOE;
-
-    memset(tmp_pattern, 0, sizeof(tmp_pattern));
-
-	if (bm & TPM_IPV6_UPDATE)
-		subr_chain = TPM_CHAIN_TYPE_IPV6_PPPOE;
-
-    /* Build pattern entries */
-    memcpy(tmp_pattern, tpm_mod2_pattern_array[cmd_idx].entry,
-           sizeof(tpm_mod2_entry_t)*TPM_MOD2_PPPOE_DEL_CMD_ENTRIES);
-    tmp_pattern[TPM_MOD2_PPPOE_DEL_CMD_ENTRIES-1].last = 1;
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /*update IPV6 in pattern*/
-    if (bm & TPM_IPV6_UPDATE)
-        tmp_pattern[0].data = 0x86dd;
-
-    /* Scan pppoe db to check if the pppoe subchain exist or not.  */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, subr_chain, TPM_MOD2_PPPOE_DEL_CMD_ENTRIES, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-	/*If it is tpm check, subchain check failed, return*/
-        if (is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "TPM check sub chain-%d failed\n", subr_chain);
-            return TPM_FAIL;
-        }
-        /* Get next free chain index of pppoe subchain area */
-        chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, subr_chain);
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the pppoe subchain \n");
-            return TPM_FAIL;
-        }
-    }
-    /* Write to pppoe db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, subr_chain, chain_idx,
-	                                TPM_MOD2_PPPOE_DEL_CMD_ENTRIES, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set pppoe subr chain entry\n");
-	        return TPM_FAIL;
-	    }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill PPPoE DEL entries in local pattern set */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, subr_chain, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if ((entry_p->line_num + TPM_MOD2_PPPOE_DEL_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_PPPOE_DEL_CMD_ENTRIES);
-        entry_p->line_num += TPM_MOD2_PPPOE_DEL_CMD_ENTRIES;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the pppoe.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Add jump/jump_subr command in main_chain */
-    /* Convert Chain Index to PMT Index */
-    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(subr_chain, chain_idx);
-    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        return TPM_FAIL;
-    }
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_pppoe_add()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_pppoe_add (tpm_gmacs_enum_t      gmac_port,
-                                    uint32_t                bm,
-                                    uint16_t                cmd_idx,
-                                    uint8_t                *skip,
-                                    tpm_pkt_mod_t          *mod_data,
-                                    tpm_mod_pattern_data_t *pattern_data,
-                                    tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    ipv4_pattern[TPM_MOD2_PPPOE_ADD_CMD_ENTRIES];
-    tpm_mod2_entry_t    ipv6_pattern[TPM_MOD2_IPV6_PPPOE_ADD_CMD_ENTRIES];
-    uint16_t            chain_idx = TPM_MOD2_INVALID_CHAIN_ID;
-    uint16_t            jump_to;
-	tpm_chain_type_t    subr_chain = TPM_CHAIN_TYPE_PPPOE;
-    tpm_mod2_entry_t    *tmp_pattern = ipv4_pattern;
-	uint32_t            entry_num = TPM_MOD2_PPPOE_ADD_CMD_ENTRIES;
-    uint32_t  gmac_mh_en;
-
-
-    memset(ipv4_pattern, 0, sizeof(ipv4_pattern));
-    memset(ipv6_pattern, 0, sizeof(ipv6_pattern));
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-	if (bm & TPM_IPV6_UPDATE) {
-		subr_chain = TPM_CHAIN_TYPE_IPV6_PPPOE;
-		tmp_pattern = ipv6_pattern;
-		entry_num = TPM_MOD2_IPV6_PPPOE_ADD_CMD_ENTRIES;
-	}
-
-    /* Build pattern entries */
-	if (bm & TPM_IPV6_UPDATE) {
-	    memcpy(tmp_pattern, tpm_mod2_ipv6_pppoe_pattern.entry,
-	           entry_num * sizeof(tpm_mod2_entry_t));
-	    tmp_pattern[2].data = mod_data->pppoe_mod.ppp_session;
-	    tpm_db_gmac_mh_en_conf_get(gmac_port, &gmac_mh_en);
-	    if (!gmac_mh_en)
-	        tmp_pattern[3].data = TPM_MOD2_DEFAULT_PPPOE_LEN_MH_DIS;
-	} else {
-	    memcpy(tmp_pattern, tpm_mod2_pattern_array[cmd_idx].entry,
-	           entry_num * sizeof(tpm_mod2_entry_t));
-	    tmp_pattern[0].data = mod_data->pppoe_mod.ppp_session;
-	}
-    tmp_pattern[entry_num - 1].last = 1;
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    /* Scan pppoe db to check if the pppoe subchain exist or not. */
-    chain_idx = tpm_db_mod2_get_chain_entry(gmac_port, subr_chain, entry_num, tmp_pattern);
-    if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-    {
-        if(is_tpm_check) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "TPM check sub chain-%d failed\n", subr_chain);
-            return TPM_FAIL;
-        }
-        /* Get next free chain index of pppoe subchain area */
-        chain_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, subr_chain);
-        if (chain_idx == TPM_MOD2_INVALID_CHAIN_ID)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the pppoe subchain \n");
-            return TPM_FAIL;
-        }
-    }
-    /* Write to pppoe db */
-    if(!is_tpm_check) {
-        if (tpm_db_mod2_set_chain_entry(gmac_port, subr_chain, chain_idx,
-	                                entry_num, tmp_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set pppoe subr chain entry\n");
-            return TPM_FAIL;
-        }
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    /* Fill PPPoE ADD entries in local pattern set */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, subr_chain, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set. \n");
-        return TPM_FAIL;
-    }
-    entry_p->index = chain_idx;
-
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tmp_pattern,
-               entry_num * sizeof(tpm_mod2_entry_t));
-        entry_p->line_num += entry_num;
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the pppoe.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    /* Add jump/jump_subr command in main_chain */
-    /* Convert Chain Index to PMT Index */
-    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(subr_chain, chain_idx);
-    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        return TPM_FAIL;
-    }
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        if (tpm_mod2_single_command_add(&tpm_mod2_jump_subr_pattern, jump_to, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_ipv4_update()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_ipv4_update (tpm_gmacs_enum_t      gmac_port,
-                                      uint32_t                bm,
-                                      uint16_t                cmd_idx,
-                                      uint8_t                *skip,
-                                      tpm_pkt_mod_t          *mod_data,
-                                      tpm_mod_pattern_data_t *pattern_data,
-                                      tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if ((bm & TPM_DSCP_SET)     ||
-        (bm & TPM_TTL_DEC)      ||
-        (bm & TPM_IPV4_SRC_SET) ||
-        (bm & TPM_IPV4_DST_SET))
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-            return TPM_FAIL;
-
-        /* Copy IP checksum pattern */
-        if (tpm_mod2_single_command_add(&tpm_mod2_pattern_array[cmd_idx], 0, entry_p) != TPM_OK)
-            return TPM_FAIL;
-    }
-    else
-    {
-        *skip = tpm_mod2_pattern_array[cmd_idx].skip_no_parse;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_dscp_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_dscp_set (tpm_gmacs_enum_t      gmac_port,
-                                   uint32_t                bm,
-                                   uint16_t                cmd_idx,
-                                   uint8_t                *skip,
-                                   tpm_pkt_mod_t          *mod_data,
-                                   tpm_mod_pattern_data_t *pattern_data,
-                                   tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    uint16_t    data = 0;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (bm & TPM_IPV4_UPDATE)
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-
-        /* Copy IPv4 DSCP pattern */
-        data = tpm_mod2_pattern_array[cmd_idx].entry[0].data |
-               ((mod_data->l3.ipv4_mod.ipv4_dscp << TPM_MOD2_DSCP_DATA_BIT) & TPM_MOD2_DSCP_DATA_MASK);
-
-        if (tpm_mod2_single_command_add(&tpm_mod2_pattern_array[cmd_idx], data, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-
-        /* Copy IPv6 TC pattern */
-        data = tpm_mod2_ipv6_tc_pattern.entry[0].data |
-               ((mod_data->l3.ipv6_mod.ipv6_dscp << TPM_MOD2_TC_DATA_BIT) & TPM_MOD2_TC_DATA_MASK);
-
-        if (tpm_mod2_single_command_add(&tpm_mod2_ipv6_tc_pattern, data, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_ttl_dec()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_ttl_dec (tpm_gmacs_enum_t      gmac_port,
-                                  uint32_t                bm,
-                                  uint16_t                cmd_idx,
-                                  uint8_t                *skip,
-                                  tpm_pkt_mod_t          *mod_data,
-                                  tpm_mod_pattern_data_t *pattern_data,
-                                  tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-    uint16_t extra_word_skip = 0;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    /* Save skip command by TTL DEC skip_before */
-    if (*skip % 2)
-    {
-        if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-    }
-    else
-    {
-        extra_word_skip = (*skip / 2) << 8;
-        *skip = 0;
-    }
-
-    /* Copy TTL DEC pattern w/o changing data*/
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tpm_mod2_pattern_array[cmd_idx].entry, sizeof(tpm_mod2_entry_t));
-        entry_p->line[entry_p->line_num].data += extra_word_skip;
-        entry_p->line_num++;
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added command 0x%x pattern_line=%d\n",
-                    tpm_mod2_pattern_array[cmd_idx].entry[0].opcode, entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_v4_sip_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_v4_sip_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy IPv4 SIP pattern */
-    if ((entry_p->line_num + TPM_MOD2_IP_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tpm_mod2_pattern_array[cmd_idx].entry,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_IP_CMD_ENTRIES);
-
-        entry_p->line[entry_p->line_num++].data = ((mod_data->l3.ipv4_mod.ipv4_src_ip_add[0] << 8) | mod_data->l3.ipv4_mod.ipv4_src_ip_add[1]);
-        entry_p->line[entry_p->line_num++].data = ((mod_data->l3.ipv4_mod.ipv4_src_ip_add[2] << 8) | mod_data->l3.ipv4_mod.ipv4_src_ip_add[3]);
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_mod2_process_v4_dip_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_v4_dip_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy IPv4 DIP pattern */
-    if ((entry_p->line_num + TPM_MOD2_IP_CMD_ENTRIES) <= TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tpm_mod2_pattern_array[cmd_idx].entry,
-               sizeof(tpm_mod2_entry_t)*TPM_MOD2_IP_CMD_ENTRIES);
-
-        entry_p->line[entry_p->line_num++].data = ((mod_data->l3.ipv4_mod.ipv4_dst_ip_add[0] << 8) | mod_data->l3.ipv4_mod.ipv4_dst_ip_add[1]);
-        entry_p->line[entry_p->line_num++].data = ((mod_data->l3.ipv4_mod.ipv4_dst_ip_add[2] << 8) | mod_data->l3.ipv4_mod.ipv4_dst_ip_add[3]);
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "pattern_line=%d \n", entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_hoplim_dec()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_hoplim_dec (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy Hop limit DEC pattern w/o changing data*/
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tpm_mod2_pattern_array[cmd_idx].entry, sizeof(tpm_mod2_entry_t));
-        entry_p->line_num++;
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added command 0x%x pattern_line=%d\n",
-                    tpm_mod2_pattern_array[cmd_idx].entry[0].opcode, entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_l4_src_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_l4_src_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy L4 SRC pattern */
-    if (tpm_mod2_single_command_add(&tpm_mod2_pattern_array[cmd_idx],
-                                    mod_data->l3.ipv4_mod.l4_src_port, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_mod2_process_l4_dst_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_l4_dst_set (tpm_gmacs_enum_t      gmac_port,
-                                     uint32_t                bm,
-                                     uint16_t                cmd_idx,
-                                     uint8_t                *skip,
-                                     tpm_pkt_mod_t          *mod_data,
-                                     tpm_mod_pattern_data_t *pattern_data,
-                                     tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy L4 DST pattern */
-    if (tpm_mod2_single_command_add(&tpm_mod2_pattern_array[cmd_idx],
-                                    mod_data->l3.ipv4_mod.l4_dst_port, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_l4_checksum_set()
-*
-*******************************************************************************/
-int32_t tpm_mod2_process_l4_checksum_set(tpm_gmacs_enum_t      gmac_port,
-                                         uint32_t                bm,
-                                         uint16_t                cmd_idx,
-                                         uint8_t                *skip,
-                                         tpm_pkt_mod_t          *mod_data,
-                                         tpm_mod_pattern_data_t *pattern_data,
-                                         tpm_self_check_enable_t is_tpm_check)
-{
-    tpm_pattern_entry_t *entry_p = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "gmac(%d), bitmap(%x)\n",gmac_port, bm);
-
-    if (bm & TPM_INT_L4_UDP)
-    {
-        /* If udp_checksum_calc is taken from Init, take init value */
-        if (tpm_db_mod2_get_udp_checksum_init_bm_state())
-        {
-            if (!tpm_db_mod2_get_udp_checksum_state())
-                return TPM_OK;
-        }
-        else if ((bm & TPM_INT_UDP_CHECKSUM) == 0) /* else take from API flag */
-        {
-            return TPM_OK;
-        }
-    }
-
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, pattern_data->main_chain_type, pattern_data->main_chain_id);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-        return TPM_FAIL;
-    }
-
-    if (tpm_mod2_skip_command_add(skip, tpm_mod2_int_pattern_array[cmd_idx].skip_before, entry_p) != TPM_OK)
-    {
-        return TPM_FAIL;
-    }
-
-    /* Copy L4 checksum pattern w/o changing data*/
-    if (entry_p->line_num < TPM_MOD2_MAX_PATTERN_ENTRIES)
-    {
-        memcpy(&(entry_p->line[entry_p->line_num]), tpm_mod2_int_pattern_array[cmd_idx].entry, sizeof(tpm_mod2_entry_t));
-        entry_p->line_num++;
-
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added command 0x%x pattern_line=%d\n",
-                    tpm_mod2_pattern_array[cmd_idx].entry[0].opcode, entry_p->line_num);
-    }
-    else
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the tmp.pattern (%d)\n", entry_p->line_num);
-        return TPM_FAIL;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_process_l4_checksum_set()
-*
-*******************************************************************************/
-static uint8_t  tpm_mod2_skip_get (tpm_pkt_mod_bm_t mod_bm,
-                                   uint16_t         mod_flag_idx)
-{
-    uint8_t skip_val = 0;
-
-    switch(mod_flag_idx)
-    {
-    case TPM_MOD_MAC_DA_SET:     /* 0 - Update the MAC DA Address*/
-    case TPM_MOD_MAC_SA_SET:     /* 1 - Update the MAC SA Address*/
-    case TPM_MOD_VLAN_MOD:       /* 2 - Update the VLAN Tags (add/del/update)*/
-    case TPM_MOD_PPPOE_DEL:      /* 3 - Delete a PPPoE encapsulation*/
-    case TPM_MOD_PPPOE_ADD:      /* 4 - Add a PPPoE encapsulation*/
-        skip_val = tpm_mod2_pattern_array[mod_flag_idx].skip_no_parse;
-        break;
-
-    case TPM_MOD_DSCP_SET:       /* 5 - Set the DSCP value */
-        skip_val = tpm_mod2_pattern_array[mod_flag_idx].skip_no_parse;
-
-        break;
-
-    case TPM_MOD_TTL_DEC:        /* 6 - Decrease the TTL value */
-    case TPM_MOD_IPV4_SRC_SET:   /* 8 - Set the IPV4 Source Address */
-    case TPM_MOD_IPV4_DST_SET:   /* 9 - Set the IPV4 Destination Address */
-        if (mod_bm & TPM_IPV4_UPDATE)
-        {
-            skip_val = tpm_mod2_pattern_array[mod_flag_idx].skip_no_parse;
-        }
-        break;
-
-    case TPM_MOD_HOPLIM_DEC:     /* 11 - Decrease the Hop Limit value */
-    case TPM_MOD_IPV6_SRC_SET:   /* 12 - Set the IPV6 Source Address */
-    case TPM_MOD_IPV6_DST_SET:   /* 13 - Set the IPV6 Destination Address */
-        if (mod_bm & TPM_IPV6_UPDATE)
-        {
-            skip_val = tpm_mod2_pattern_array[mod_flag_idx].skip_no_parse;
-        }
-        break;
-
-    case TPM_MOD_L4_SRC_SET:     /* 14 - Set the L4 Source Port (UDP or TCP) */
-    case TPM_MOD_L4_DST_SET:     /* 15 - Set the L4 Destination Port (UDP or TCP) */
-        if ((mod_bm & TPM_IPV6_UPDATE) ||
-            (mod_bm & TPM_IPV4_UPDATE))
-        {
-            skip_val = tpm_mod2_pattern_array[mod_flag_idx].skip_no_parse;
-        }
-        break;
-
-    case TPM_MOD_IPV4_UPDATE:    /* 7 - Update the IPv4 Header*/
-    case TPM_MOD_IPV6_UPDATE:    /* 10 - Update the IPv6 Header */
-    default:
-        break;
-    }
-
-    return skip_val;
-}
-
-/*******************************************************************************
-* tpm_mod2_parse_get()
-*
-*******************************************************************************/
-static uint8_t  tpm_mod2_l2_parse_len_get (uint16_t         mod_flag_idx,
-                                           uint32_t         mh_en,
-                                           tpm_pkt_mod_t   *mod_data)
-{
-    uint8_t  parse_len = 0;
-
-    if (mod_flag_idx < TPM_MOD_PPPOE_DEL)
-    {
-        if (mod_flag_idx >= TPM_MOD_MH_SET && mh_en)
-        {
-            parse_len += 2; // add mh len
-        }
-
-        if (mod_flag_idx >= TPM_MOD_MAC_DA_SET)
-        {
-            parse_len += 6; // add da len
-        }
-
-        if (mod_flag_idx >= TPM_MOD_MAC_SA_SET)
-        {
-            parse_len += 6; // add sa len
-        }
-
-        if (mod_flag_idx == TPM_MOD_VLAN_MOD)
-        {
-            switch (mod_data->vlan_mod.vlan_op)
-            {
-            case VLANOP_EXT_TAG_MOD:
-            case VLANOP_EXT_TAG_DEL:
-            case VLANOP_EXT_TAG_MOD_INS:
-                parse_len += 4; // one tag is processed.
-                break;
-
-            case VLANOP_INS_2TAG:
-            case VLANOP_MOD_2TAG:
-            case VLANOP_SWAP_TAGS:
-            case VLANOP_DEL_2TAG:
-            case VLANOP_INT_TAG_MOD:
-            case VLANOP_EXT_TAG_DEL_INT_MOD:
-                parse_len += 8; // two tags are processed.
-                break;
-
-            case VLANOP_EXT_TAG_INS:
-            default:
-                break;
-            }
-        }
-    }
-
-    return parse_len;
-}
-
-/*******************************************************************************
-* tpm_mod2_fill_in_pattern()
-*
-* DESCRIPTION: The API sets the temporary pattern which will be written to HW.
-*
-* INPUTS:   mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           int_mod_bm  - set of internal flags
-*           mod_data    - modification entry data
-*	    is_tpm_check -fill pattern for tpm check or not
-*
-* OUTPUTS:
-*           mod_entry   - start entry number which has been set for this
-*                         modification <j>
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_fill_in_pattern   (tpm_gmacs_enum_t     gmac_port,
-                                       tpm_pkt_mod_bm_t        mod_bm,
-                                       tpm_pkt_mod_int_bm_t    int_mod_bm,
-                                       tpm_pkt_mod_t          *mod_data,
-                                       uint32_t               *mod_entry,
-                                       tpm_mod_pattern_data_t *pattern_data,
-                                       tpm_self_check_enable_t is_tpm_check)
-{
-    uint16_t    jump_idx, main_idx, flag_idx, jump_to;
-    uint16_t    last_mod_flag = TPM_MOD_MH_SET;
-    uint8_t     skip = 0;
-    uint8_t     minus_len = 0;
-    uint32_t    mh_en;
-    tpm_chain_type_t     main_chain_type, db_main_chain_type;
-    tpm_pattern_entry_t *entry_p = NULL;
-    uint32_t    i;
-    uint16_t    max_sz;
-    uint16_t    pmt_entry;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-    jump_idx = 0;
-
-    /* Init jump pattern entry */
-    entry_p = &pattern_data->pattern_set[0];
-    entry_p->is_valid   = 1;
-    entry_p->area_type  = TPM_AREA_TYPE_JUMP;
-    entry_p->chain_type = TPM_CHAIN_TYPE_NONE;
-
-    if (TPM_CHECK_DISABLE == is_tpm_check) {
-        /* Get next_free index => jump_idx */
-        spin_lock_bh(&tpmMod2JumpEntryLock);
-        if ((TPM_SPLIT_MOD_ENABLED == tpm_db_split_mod_get_enable()) && (int_mod_bm & TPM_INT_SPLIT_MOD))
-        {
-            TPM_OS_INFO(TPM_MODZ2_HM_MOD, "Need split_mod JUMP entry\n");
-            jump_idx = tpm_db_mod2_get_next_split_mod_free_jump_entry(gmac_port, mod_data);
-        }
-	else {
-            TPM_OS_INFO(TPM_MODZ2_HM_MOD, "Need common JUMP entry\n");
-            jump_idx = tpm_db_mod2_get_next_free_jump_entry(gmac_port);
-	}
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        if (jump_idx == TPM_MOD2_NULL_ENT_IDX)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free JUMP entry\n");
-            return TPM_FAIL;
-        }
-
-        /* Ensure there is no write to index 0 in modification table */
-        if (jump_idx == 0)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Illegal write to index 0 in modification table: (jump_idx=%d)\n", jump_idx);
-            return TPM_FAIL;
-        }
-	entry_p->index = jump_idx;
-        /* Return mod_entry index */
-        *mod_entry = jump_idx;
-    } else {
-        entry_p->index = *mod_entry;
-        jump_idx = *mod_entry;
-        /*get main chain index*/
-        if (tpm_mod2_main_chain_index_get(gmac_port, jump_idx, &pmt_entry,is_tpm_check)) {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain index for tpm check\n");
-            return TPM_FAIL;
-        }
-        /*get chain ID by PMT entry index*/
-        if (tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port,pmt_entry,&db_main_chain_type,&main_idx)) {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Get main chain id failed for tpm check\n");
-            return TPM_FAIL;
-        }
-    }
-
-    /* Get main chain type from mod_bm */
-    main_chain_type = tpm_mod2_parse_chain_type(mod_bm, int_mod_bm);
-    if (TPM_CHECK_DISABLE == is_tpm_check) {
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        /* Get next_free index by chain_type => main_idx */
-        main_idx = tpm_db_mod2_get_next_free_chain_entry(gmac_port, main_chain_type);
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        if (main_idx == TPM_MOD2_INVALID_CHAIN_ID) {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "No free space in the main area (chain_type=%d)\n", main_chain_type);
-            return TPM_FAIL;
-        }
-    }
-
-    /* Get port MH mode */
-    if (tpm_db_gmac_mh_en_conf_get(gmac_port, &mh_en)) {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get port MH mode\n");
-        return TPM_FAIL;
-    }
-
-    /* Set main chain for mod_rules */
-    pattern_data->main_chain_type = main_chain_type;
-    pattern_data->main_chain_id   = main_idx;
-
-    /* Get free pattern entry for main_chain */
-    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, TPM_MOD2_INVALID_CHAIN_ID);
-    if (entry_p == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get free pattern set for main_chain\n");
-        return TPM_FAIL;
-    }
-    entry_p->index = pattern_data->main_chain_id;
-
-    for (flag_idx = 0; flag_idx < TPM_MAX_PKT_MOD_FLAGS; flag_idx++)
-    {
-        if (mod_bm & tpm_mod2_pattern_array[flag_idx].mask)
-        {
-            /* next pattern found */
-            if (tpm_mod2_pattern_array[flag_idx].process_pattern != NULL)
-            {
-                entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, main_idx);
-                if (entry_p == NULL)
-                {
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set\n");
-                    return TPM_FAIL;
-                }
-
-                //if ((last_mod_flag < TPM_MOD_PPPOE_DEL && flag_idx == TPM_MOD_PPPOE_DEL) ||
-                //    (last_mod_flag < TPM_MOD_PPPOE_ADD && flag_idx == TPM_MOD_PPPOE_ADD))
-                //{
-                //    /* skip to L3_offset */
-                //    minus_len = tpm_mod2_l2_parse_len_get(last_mod_flag, mod_data);
-                //    if (tpm_mod2_skip_to_l3_offset_command_add(&skip, (minus_len + 2/*eth_type*/), entry_p) != TPM_OK)
-                //    {
-                //        return TPM_FAIL;
-                //    }
-                //    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added SKIP to ipv4 header\n");
-                //}
-
-                if (last_mod_flag < TPM_MOD_PPPOE_DEL && flag_idx == TPM_MOD_PPPOE_DEL)
-                {
-                    /* skip to L3_offset */
-                    minus_len = tpm_mod2_l2_parse_len_get(last_mod_flag, mh_en, mod_data);
-                    minus_len+= (2/*eth_type*/ + 8/*pppoe_hdr*/);
-                    if (tpm_mod2_skip_to_l3_offset_command_add(&skip, minus_len, entry_p) != TPM_OK)
-                    {
-                        return TPM_FAIL;
-                    }
-                    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added SKIP to ipv4 header\n");
-                }
-                else if (last_mod_flag < TPM_MOD_PPPOE_ADD && flag_idx == TPM_MOD_PPPOE_ADD)
-                {
-                    /* skip to L3_offset */
-                    minus_len = tpm_mod2_l2_parse_len_get(last_mod_flag, mh_en, mod_data);
-                    minus_len+= 2/*eth_type*/;
-                    if (tpm_mod2_skip_to_l3_offset_command_add(&skip, minus_len, entry_p) != TPM_OK)
-                    {
-                        return TPM_FAIL;
-                    }
-                    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added SKIP to ipv4 header\n");
-                }
-
-                if (tpm_mod2_pattern_array[flag_idx].process_pattern(gmac_port, mod_bm, flag_idx, &skip, mod_data, pattern_data, is_tpm_check) != TPM_OK)
-                {
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to add cmd pattern (%d)\n", flag_idx);
-                    return TPM_FAIL;
-                }
-                last_mod_flag = flag_idx;
-                TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added patterns for %d \n", flag_idx);
-            }
-            else
-            {
-                //if ((last_mod_flag < TPM_MOD_PPPOE_ADD && flag_idx == TPM_MOD_PPPOE_ADD) ||
-                //    (last_mod_flag < TPM_MOD_PPPOE_DEL && flag_idx == TPM_MOD_PPPOE_DEL))
-                if (last_mod_flag < TPM_MOD_PPPOE_DEL && flag_idx == TPM_MOD_PPPOE_ADD)
-                {
-                    /* Skip to L3 offset if L3_mod is requested */
-                    if (mod_bm & (TPM_MOD2_IPV4_MOD_MASK | TPM_MOD2_IPV6_MOD_MASK | TPM_MOD2_L4_MOD_MASK))
-                    {
-                        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, main_idx);
-                        if (entry_p == NULL)
-                        {
-                            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-                            return TPM_FAIL;
-                        }
-
-                        /* Skip to L3_offset */
-                        minus_len = tpm_mod2_l2_parse_len_get(last_mod_flag, mh_en, mod_data);
-                        if (tpm_mod2_skip_to_l3_offset_command_add(&skip, minus_len, entry_p) != TPM_OK)
-                        {
-                            return TPM_FAIL;
-                        }
-                        last_mod_flag = TPM_MOD_PPPOE_ADD;
-                        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added SKIP to ipv4 header\n");
-                    }
-                    else
-                    {
-                        /* Finish parsing mod_flag */
-                        break;
-                    }
-                }
-                else
-                {
-                    skip += tpm_mod2_skip_get(mod_bm, flag_idx);
-                }
-            }
-        }
-        else
-        {
-            /* If not match any mod flag before L3 offset, skip the gap between VLAN Tag and L3 header. */
-            if (last_mod_flag < TPM_MOD_PPPOE_DEL && flag_idx == TPM_MOD_PPPOE_ADD)
-            {
-                if (mod_bm & (TPM_MOD2_IPV4_MOD_MASK | TPM_MOD2_IPV6_MOD_MASK | TPM_MOD2_L4_MOD_MASK))
-                {
-                    entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, main_idx);
-                    if (entry_p == NULL)
-                    {
-                        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-                        return TPM_FAIL;
-                    }
-
-                    /* skip to L3_offset */
-                    minus_len = tpm_mod2_l2_parse_len_get(last_mod_flag, mh_en, mod_data);
-                    if (tpm_mod2_skip_to_l3_offset_command_add(&skip, minus_len, entry_p) != TPM_OK)
-                    {
-                        return TPM_FAIL;
-                    }
-                    last_mod_flag = TPM_MOD_PPPOE_ADD;
-                }
-                else
-                {
-                    /* Finish parsing mod_flag */
-                    break;
-                }
-            }
-            else
-            {
-                skip += tpm_mod2_skip_get(mod_bm, flag_idx);
-            }
-        }
-    }
-
-    if (mod_bm & TPM_L4_SRC_SET ||
-        mod_bm & TPM_L4_DST_SET ||
-        mod_bm & TPM_IPV6_SRC_SET ||
-        mod_bm & TPM_IPV6_DST_SET ||
-        mod_bm & TPM_IPV4_SRC_SET ||
-        mod_bm & TPM_IPV4_DST_SET)
-    {
-        /* Update L4 checksum */
-        for (flag_idx = 0; flag_idx < TPM_MAX_INT_MOD_FLAGS; flag_idx++)
-        {
-            if (int_mod_bm & tpm_mod2_int_pattern_array[flag_idx].mask)
-            {
-                if (tpm_mod2_int_pattern_array[flag_idx].process_pattern != NULL)
-                {
-                    if (tpm_mod2_int_pattern_array[flag_idx].process_pattern(gmac_port, int_mod_bm, flag_idx, &skip, mod_data, pattern_data, is_tpm_check) != TPM_OK)
-                    {
-                        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to add cmd pattern (%d)\n", flag_idx);
-                        return TPM_FAIL;
-                    }
-
-                    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added patterns for %d \n", flag_idx);
-                }
-            }
-        }
-    }
-
-    if (main_chain_type != TPM_CHAIN_TYPE_MH)
-    {
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, main_idx);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        /* Set "last" bit to the last modification entry */
-        entry_p->line[entry_p->line_num-1].last = 1;
-        /* Last command should never be jump_subr, replace it with jump */
-        if (entry_p->line[entry_p->line_num-1].opcode == TPM_MOD2_OPCODE_JUMP_SUBR)
-        {
-            entry_p->line[entry_p->line_num-1].opcode = TPM_MOD2_OPCODE_JUMP;
-        }
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Set last bit to pattern_line=%d\n", entry_p->line_num-1);
-
-    /* Write jump entry to db */
-    jump_to = tpm_db_mod2_convert_chain_to_pmt_entry(main_chain_type, pattern_data->main_chain_id);
-    if (jump_to == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-        return TPM_FAIL;
-    }
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "[GMAC-%d] Jump from 0x%04x to chain-%d[%d] 0x%04x\n",
-                 gmac_port, jump_idx, main_chain_type, pattern_data->main_chain_id, jump_to);
-
-    /* Verify whether the Marvell tag has been defined -
-       in this case the first command in the pattern should be JUMP_SKIP2 */
-    /* get the MH - if enabled or not */
-    entry_p = &pattern_data->pattern_set[0];
-    if (mh_en == TPM_FALSE || mod_bm & TPM_MH_SET)
-    {
-        if (tpm_mod2_single_command_add(&tpm_mod2_jump_pattern, jump_to, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added JUMP pattern\n");
-    }
-    else
-    {
-        if (tpm_mod2_single_command_add(&tpm_mod2_jump_skip2_pattern, jump_to, entry_p) != TPM_OK)
-        {
-            return TPM_FAIL;
-        }
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Added JUMP-SKIP2 pattern\n");
-    }
-
-    /*if function for tpm check, return from here*/
-    if (is_tpm_check)
-        return TPM_OK;
-
-    spin_lock_bh(&tpmMod2JumpEntryLock);
-    if (tpm_db_mod2_set_jump_entry(gmac_port, entry_p->index, entry_p->line) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set jump entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2JumpEntryLock);
-
-    if (main_chain_type != TPM_CHAIN_TYPE_MH)
-    {
-        /* Write main chain entry to db */
-        entry_p = tpm_mod2_get_chain_from_pattern_set(pattern_data->pattern_set, main_chain_type, main_idx);
-        if (entry_p == NULL)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Fail to get main pattern set. \n");
-            return TPM_FAIL;
-        }
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_set_chain_entry(gmac_port, main_chain_type, main_idx, entry_p->line_num, entry_p->line) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set main chain entry\n");
-            return TPM_FAIL;
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-    }
-
-    /* Check if number of chain PMT entry exceeds the maximum chain size */
-    for (i=1; i < TPM_MOD2_MAX_PATTERN_SETS; i++)
-    {
-        entry_p = &pattern_data->pattern_set[i];
-
-        if (entry_p->is_valid)
-        {
-            max_sz = tpm_db_mod2_get_chain_max_size(entry_p->chain_type);
-            if (entry_p->line_num > max_sz)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "chain(%d) PMT entry number(%d) exceeds the maximum chain size(%d)\n",
-                             entry_p->chain_type, entry_p->line_num, max_sz);
-                return TPM_FAIL;
-            }
-        }
-    }
-
-    return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_mod2_hw_add_entry()
-*
-* DESCRIPTION: The API writes a complete Modification table entry to HW table
-*
-* INPUTS:   gmac_port   - GMAC port
-*           pattern_set - pattern array with data to be written
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_hw_add_entry   (tpm_gmacs_enum_t       gmac_port,
-                                    tpm_mod_pattern_data_t *pattern_data)
-{
-    uint16_t    line_id, set_id, pmt_id, /*chain_id, */valid_set_num;
-    uint32_t    cfg_pnc_parse_flag = 0;
-    uint8_t     is_exist;
-    tpm_pattern_entry_t *entry_p = NULL;
-    tpm_mod2_entry_t    *line_p  = NULL;
-
-    MV_NETA_PMT entry;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "\n");
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " TPM is NOT configuring the PNC / MOD - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " TPM is configuring the PNC / MOD \n");
-
-    valid_set_num = 0;
-    /* Set sub chain and main chain first */
-    for (set_id = 1; set_id < TPM_MOD2_MAX_PATTERN_SETS; set_id++)
-    {
-        entry_p = &pattern_data->pattern_set[set_id];
-        if (entry_p->is_valid)
-        {
-            TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " Write pattern set %d to HW: chain_type %d, chain_index %d, line_num %d\n",
-                         set_id, entry_p->chain_type, entry_p->index, entry_p->line_num);
-
-            /* Validate pattern data */
-            if (entry_p->line_num == 0)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Empty pattern\n");
-                return TPM_FAIL;
-            }
-
-            /* Convert chain index to PMT entry index */
-            pmt_id = tpm_db_mod2_convert_chain_to_pmt_entry(entry_p->chain_type, entry_p->index);
-            if (pmt_id == TPM_MOD2_NULL_ENT_IDX)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid pmt entry\n");
-                return TPM_FAIL;
-            }
-
-            valid_set_num++;
-
-            /* If chain_type is one of the subchains,
-               check if the entry has already existed in database. */
-            switch (entry_p->chain_type)
-            {
-            case TPM_CHAIN_TYPE_MH:
-            case TPM_CHAIN_TYPE_MAC:
-            case TPM_CHAIN_TYPE_PPPOE:
-			case TPM_CHAIN_TYPE_IPV6_PPPOE:
-            case TPM_CHAIN_TYPE_VLAN:
-                spin_lock_bh(&tpmMod2ChainEntryLock);
-                if (tpm_db_mod2_if_chain_pmt_entries_exist(gmac_port, entry_p->chain_type, entry_p->index, &is_exist) != TPM_OK)
-                {
-                    spin_unlock_bh(&tpmMod2ChainEntryLock);
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get hw entries status\n");
-                    return TPM_FAIL;
-                }
-                if (is_exist)
-                {
-                    spin_unlock_bh(&tpmMod2ChainEntryLock);
-                    continue;
-                }
-                if (tpm_db_mod2_activate_chain_pmt_entry(gmac_port, entry_p->chain_type, entry_p->index) != TPM_OK)
-                {
-                    spin_unlock_bh(&tpmMod2ChainEntryLock);
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to activate hw entries\n");
-                    return TPM_FAIL;
-                }
-                spin_unlock_bh(&tpmMod2ChainEntryLock);
-                break;
-            case TPM_CHAIN_TYPE_L2:
-            case TPM_CHAIN_TYPE_IPV4_NAPT:
-            case TPM_CHAIN_TYPE_IPV4_MC:
-            case TPM_CHAIN_TYPE_ROUTE:
-            case TPM_CHAIN_TYPE_IPV6_MC:
-                spin_lock_bh(&tpmMod2ChainEntryLock);
-                if (tpm_db_mod2_activate_chain_pmt_entry(gmac_port, entry_p->chain_type, entry_p->index) != TPM_OK)
-                {
-                    spin_unlock_bh(&tpmMod2ChainEntryLock);
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to activate hw entries\n");
-                    return TPM_FAIL;
-                }
-                spin_unlock_bh(&tpmMod2ChainEntryLock);
-                break;
-            default:
-                break;
-            }
-
-            for (line_id = 0; line_id < TPM_MOD2_MAX_PATTERN_ENTRIES && line_id < entry_p->line_num; line_id++)
-            {
-                line_p = &entry_p->line[line_id];
-                /* Fill in modData */
-                entry.word = line_p->data & MV_NETA_PMT_DATA_MASK;
-                /* Fill in opCode */
-                entry.word |= ((line_p->opcode << MV_NETA_PMT_CMD_OFFS) & MV_NETA_PMT_CMD_ALL_MASK);
-                /* Fill in L3 checksum flag */
-                entry.word |= ((line_p->updt_ipv4 << MV_NETA_PMT_IP4_CSUM_BIT) & MV_NETA_PMT_IP4_CSUM_MASK);
-                /* Fill in L4 checksum flag */
-                entry.word |= ((line_p->updt_tcp << MV_NETA_PMT_L4_CSUM_BIT) & MV_NETA_PMT_L4_CSUM_MASK);
-                /* Fill in last instruction flag */
-                entry.word |= ((line_p->last << MV_NETA_PMT_LAST_BIT) & MV_NETA_PMT_LAST_MASK);
-
-                spin_lock_bh(&tpmMod2PmtHwLock);
-                mvNetaPmtWrite(gmac_port, pmt_id++, &entry);
-                spin_unlock_bh(&tpmMod2PmtHwLock);
-            }
-        }
-    }
-
-    /* Set jump entry */
-    line_p = &pattern_data->pattern_set[0].line[0];
-    /* Fill in modData */
-    entry.word = line_p->data & MV_NETA_PMT_DATA_MASK;
-    /* Fill in opCode */
-    entry.word |= ((line_p->opcode << MV_NETA_PMT_CMD_OFFS) & MV_NETA_PMT_CMD_ALL_MASK);
-    /* Fill in L3 checksum flag */
-    entry.word |= ((line_p->updt_ipv4 << MV_NETA_PMT_IP4_CSUM_BIT) & MV_NETA_PMT_IP4_CSUM_MASK);
-    /* Fill in L4 checksum flag */
-    entry.word |= ((line_p->updt_tcp << MV_NETA_PMT_L4_CSUM_BIT) & MV_NETA_PMT_L4_CSUM_MASK);
-    /* Fill in last instruction flag */
-    entry.word |= ((line_p->last << MV_NETA_PMT_LAST_BIT) & MV_NETA_PMT_LAST_MASK);
-
-    spin_lock_bh(&tpmMod2PmtHwLock);
-    mvNetaPmtWrite(gmac_port, pattern_data->pattern_set[0].index, &entry);
-    spin_unlock_bh(&tpmMod2PmtHwLock);
-
-    return TPM_OK;
-}
-
-int32_t    tpm_mod2_flush_all   (tpm_gmacs_enum_t       gmac_port,
-                            tpm_mod_pattern_data_t *pattern_data,
-                            uint8_t                 updt_next_free,
-                            uint8_t                 on_failure)
-{
-    uint16_t set_id;
-    tpm_pattern_entry_t *pattern_set = NULL;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    pattern_set = pattern_data->pattern_set;
-
-	if (pattern_set[0].index != 0 && pattern_set[0].index != TPM_MOD2_NULL_ENT_IDX) {
-	    spin_lock_bh(&tpmMod2JumpEntryLock);
-	    if (tpm_db_mod2_flush_jump_area(gmac_port, pattern_set[0].index, updt_next_free, on_failure) != TPM_OK)
-	    {
-	        spin_unlock_bh(&tpmMod2JumpEntryLock);
-	        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush jump area\n");
-	        return TPM_FAIL;
-	    }
-	    spin_unlock_bh(&tpmMod2JumpEntryLock);
-	}
-
-	if (pattern_data->main_chain_type != TPM_CHAIN_TYPE_NONE) {
-	    for (set_id = 1; set_id < TPM_MOD2_MAX_PATTERN_SETS; set_id++)
-	    {
-	        if (pattern_set[set_id].is_valid)
-	        {
-	            spin_lock_bh(&tpmMod2ChainEntryLock);
-	            if (tpm_db_mod2_flush_chain_entry(gmac_port, pattern_set[set_id].chain_type,
-	                                        pattern_set[set_id].index, updt_next_free, on_failure) != TPM_OK)
-	            {
-	                spin_unlock_bh(&tpmMod2ChainEntryLock);
-	                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush jump area\n");
-	                return TPM_FAIL;
-	            }
-	            spin_unlock_bh(&tpmMod2ChainEntryLock);
-	        }
-	    }
-	}
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_hw_add_entry()
-*
-* DESCRIPTION: The API writes NOOP entry to HW Modification table
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_entry   - modification entry number
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_hw_inv_entry   (tpm_gmacs_enum_t    gmac_port,
-                                    uint16_t            mod_entry)
-{
-    MV_NETA_PMT entry;
-    uint32_t    cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " TPM is NOT invalidating the MOD - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " gmac_port = %d mod_entry = %d\n", gmac_port, mod_entry);
-
-    entry.word = 0;
-    /* Fill in opCode */
-    entry.word |= ((TPM_MOD2_OPCODE_NOOP << MV_NETA_PMT_CMD_OFFS) & MV_NETA_PMT_CMD_ALL_MASK);
-    /* Fill in last instruction flag */
-    entry.word |= ((1 << MV_NETA_PMT_LAST_BIT) & MV_NETA_PMT_LAST_MASK);
-
-    spin_lock_bh(&tpmMod2PmtHwLock);
-    mvNetaPmtWrite(gmac_port, mod_entry, &entry);
-    spin_unlock_bh(&tpmMod2PmtHwLock);
-
-    return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_mod2_sw_add_entry()
-*
-* DESCRIPTION: The API writes a complete Modification table entry to Shadow table
-*
-* INPUTS:   gmac_port   - GMAC port
-*
-* OUTPUTS:  None
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_sw_add_entry   (tpm_mod_owner_t     owner,
-                                    tpm_gmacs_enum_t        gmac_port,
-                                    tpm_mod_pattern_data_t *pattern_data)
-{
-    uint16_t             set_id;
-    tpm_pattern_entry_t *entry_p;
-
-    if (pattern_data == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    for (set_id = 0; set_id < TPM_MOD2_MAX_PATTERN_SETS; set_id++)
-    {
-        entry_p = &pattern_data->pattern_set[set_id];
-        if (entry_p->is_valid)
-        {
-            if (entry_p->area_type == TPM_AREA_TYPE_JUMP)
-            {
-                spin_lock_bh(&tpmMod2JumpEntryLock);
-                if (tpm_db_mod2_activate_jump_entry(gmac_port, entry_p->index) != TPM_OK)
-                {
-                    spin_unlock_bh(&tpmMod2JumpEntryLock);
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set jump entry\n");
-                    return TPM_FAIL;
-                }
-                spin_unlock_bh(&tpmMod2JumpEntryLock);
-            }
-            else
-            {
-                spin_lock_bh(&tpmMod2ChainEntryLock);
-                if (tpm_db_mod2_activate_chain_entry(gmac_port, entry_p->chain_type, entry_p->index) != TPM_OK)
-                {
-                    spin_unlock_bh(&tpmMod2ChainEntryLock);
-                    TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to set chain-%d entry\n", entry_p->chain_type);
-                    return TPM_FAIL;
-                }
-                spin_unlock_bh(&tpmMod2ChainEntryLock);
-            }
-        }
-    }
-
-    return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_mod2_print_set_params()
-*
-* DESCRIPTION: Prints set parameters
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           mod_data    - modification entry data
-*
-* OUTPUTS:  None
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void    tpm_mod2_print_set_params   (tpm_gmacs_enum_t   gmac_port,
-                                     tpm_pkt_mod_bm_t   mod_bm,
-                                     tpm_pkt_mod_t      *mod_data)
-{
-    char    mac_str[DB_MAC_STR_LEN] = {'\0'};
-    char    mac_mask_str[DB_MAC_STR_LEN] = {'\0'};
-    char    ipv4_str[DB_IPV4_STR_LEN];
-    char    ipv4_mask_str[DB_IPV4_STR_LEN];
-    char    ipv6_str[DB_IPV6_STR_LEN];
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "port = %d, BM = 0x%x\n", gmac_port, mod_bm);
-    printk("VLAN data: op = %d\n", mod_data->vlan_mod.vlan_op);
-    printk("   VLAN1 tpid=0x%4.4x, vid=%d(%d), cfi=%d(%d), pbit=%d(%d)\n", mod_data->vlan_mod.vlan1_out.tpid,
-           mod_data->vlan_mod.vlan1_out.vid, mod_data->vlan_mod.vlan1_out.vid_mask,
-           mod_data->vlan_mod.vlan1_out.cfi, mod_data->vlan_mod.vlan1_out.cfi_mask,
-           mod_data->vlan_mod.vlan1_out.pbit, mod_data->vlan_mod.vlan1_out.pbit_mask);
-    printk("   VLAN2 tpid=0x%4.4x, vid=%d(%d), cfi=%d(%d), pbit=%d(%d)\n", mod_data->vlan_mod.vlan2_out.tpid,
-           mod_data->vlan_mod.vlan2_out.vid, mod_data->vlan_mod.vlan2_out.vid_mask,
-           mod_data->vlan_mod.vlan2_out.cfi, mod_data->vlan_mod.vlan2_out.cfi_mask,
-           mod_data->vlan_mod.vlan2_out.pbit, mod_data->vlan_mod.vlan2_out.pbit_mask);
-    printk("MH data:   0x%02x\n", mod_data->mh_mod);
-    printk("MAC data:  SRC %s  MASK %s\n",
-           db_mac_to_str(mod_data->mac_mod.mac_sa, mac_str),
-           db_mac_to_str(mod_data->mac_mod.mac_sa_mask, mac_mask_str));
-    printk("           DST %s  MASK %s\n",
-           db_mac_to_str(mod_data->mac_mod.mac_da, mac_str),
-           db_mac_to_str(mod_data->mac_mod.mac_da_mask, mac_mask_str));
-    printk("PPPoE data: session 0x%x  proto 0x%x\n",
-           mod_data->pppoe_mod.ppp_session, mod_data->pppoe_mod.ppp_proto);
-
-    if (mod_bm & TPM_IPV4_UPDATE)
-    {
-        printk("IPv4 data: proto = %d\n", mod_data->l3.ipv4_mod.ipv4_proto);
-        printk("           SRC %s  MASK %s\n",
-               db_ipv4_to_str(mod_data->l3.ipv4_mod.ipv4_src_ip_add, ipv4_str),
-               db_ipv4_to_str(mod_data->l3.ipv4_mod.ipv4_src_ip_add_mask, ipv4_mask_str));
-        printk("           DST %s  MASK %s\n",
-               db_ipv4_to_str(mod_data->l3.ipv4_mod.ipv4_dst_ip_add, ipv4_str),
-               db_ipv4_to_str(mod_data->l3.ipv4_mod.ipv4_dst_ip_add_mask, ipv4_mask_str));
-        printk("           DSCP %d  MASK 0x%x\n",
-               mod_data->l3.ipv4_mod.ipv4_dscp, mod_data->l3.ipv4_mod.ipv4_dscp_mask);
-        printk("L4 data:   SRC port = %d DST port = %d\n",
-               mod_data->l3.ipv4_mod.l4_src_port, mod_data->l3.ipv4_mod.l4_dst_port);
-    }
-
-    if (mod_bm & TPM_IPV6_UPDATE)
-    {
-        printk("IPv6 data: proto = %d\n", mod_data->l3.ipv6_mod.ipv6_next_header);
-        printk("           SRC %s \n",
-               db_ipv4_to_str(mod_data->l3.ipv6_mod.ipv6_src_ip_add, ipv6_str));
-        printk("           MASK %s\n",
-               db_ipv4_to_str(mod_data->l3.ipv6_mod.ipv6_src_ip_add_mask, ipv6_str));
-        printk("           DST %s\n",
-               db_ipv4_to_str(mod_data->l3.ipv6_mod.ipv6_dst_ip_add, ipv6_str));
-        printk("           MASK %s\n",
-               db_ipv4_to_str(mod_data->l3.ipv6_mod.ipv6_dst_ip_add_mask, ipv6_str));
-        printk("           DSCP %d  MASK 0x%x\n",
-               mod_data->l3.ipv6_mod.ipv6_dscp, mod_data->l3.ipv6_mod.ipv6_dscp_mask);
-        printk("L4 data:   SRC port = %d DST port = %d\n",
-               mod_data->l3.ipv6_mod.l4_src_port, mod_data->l3.ipv6_mod.l4_dst_port);
-    }
-}
-
-/*******************************************************************************
-                               Modification table APIs
-*******************************************************************************/
-
-int32_t    tpm_mod2_inlock_entry_set(tpm_mod_owner_t      owner,
-                                     tpm_gmacs_enum_t     gmac_port,
-                                     tpm_pkt_mod_bm_t     mod_bm,
-                                     tpm_pkt_mod_int_bm_t int_mod_bm,
-                                     tpm_pkt_mod_t        *mod_data,
-                                     uint32_t             *mod_entry)
-{
-    int32_t     rc;
-
-    /* PH1 - clear the global pattern for reuse */
-    memset(&_pattern_data, 0, sizeof(tpm_mod_pattern_data_t));
-
-    *mod_entry = TPM_MOD2_NULL_ENT_IDX;
-
-    /* validate logical parameters*/
-    rc = tpm_mod2_validate_logical_params(gmac_port, mod_bm, int_mod_bm, mod_data, mod_entry);
-
-    if (rc != TPM_OK) {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, " -- tpm_mod2_validate_logical_params FAILED. \n");
-        return (TPM_FAIL);
-    }
-
-    /* print debug - all function params */
-    TPM_OS_COND_DEBUG(TPM_MODZ2_HM_MOD)
-    {
-        tpm_mod2_print_set_params (gmac_port, mod_bm, mod_data);
-    }
-    /*if only VLAN mod, and op is NO OP, return from here*/
-    if ((mod_bm & TPM_VLAN_MOD) && ((mod_bm & ~TPM_VLAN_MOD) == 0)) {
-        if(mod_data->vlan_mod.vlan_op == VLANOP_NOOP) {
-            *mod_entry = 0;
-            return (TPM_OK);
-        }
-    }
-
-    /* update the pattern of new modification with real data */
-    rc = tpm_mod2_fill_in_pattern(gmac_port, mod_bm, int_mod_bm, mod_data, mod_entry, &_pattern_data, TPM_CHECK_DISABLE);
-
-    if (rc != TPM_OK) {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, " -- tpm_mod2_fill_in_pattern FAILED. \n");
-        if (tpm_mod2_flush_all(gmac_port, &_pattern_data, 0, 1) != TPM_OK)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush pmt entry status\n");
-            return TPM_FAIL;
-        }
-        return (TPM_FAIL);
-    }
-
-
-    TPM_OS_COND_DEBUG(TPM_MODZ2_HM_MOD)
-    {
-        tpm_mod2_print_tmp_pattern(&_pattern_data);
-    }
-
-    if (*mod_entry != 0)
-    {
-        /* WR entries to the HW table */
-        rc = tpm_mod2_hw_add_entry(gmac_port, &_pattern_data);
-
-        if (rc != TPM_OK) {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, " -- tpm_mod2_hw_add_entry FAILED. \n");
-            if (tpm_mod2_flush_all(gmac_port, &_pattern_data, 0, 1) != TPM_OK)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush pmt entry status\n");
-                return TPM_FAIL;
-            }
-            return (TPM_FAIL);
-        }
-
-
-        /* WR entries to the SW table */
-        rc = tpm_mod2_sw_add_entry(owner, gmac_port, &_pattern_data);
-
-        if (rc != TPM_OK) {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, " -- tpm_mod2_sw_add_entry FAILED. \n");
-            if (tpm_mod2_flush_all(gmac_port, &_pattern_data, 0, 1) != TPM_OK)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush pmt entry status\n");
-                return TPM_FAIL;
-            }
-            return (TPM_FAIL);
-        }
-    }
-
-    if (tpm_mod2_flush_all(gmac_port, &_pattern_data, 0, 0) != TPM_OK)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to flush pmt entry status\n");
-        return TPM_FAIL;
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Modification entry start index = %d\n", *mod_entry);
-
-    return (TPM_OK);
-}
-
-/*******************************************************************************
-* tpm_mod2_entry_set()
-*
-* DESCRIPTION: The API sets a complete Modification table entry
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_bm      - set of flags described which fields in the packet
-*                         to be changed
-*           int_mod_bm  - set of internal flags
-*           mod_data    - modification entry data
-*
-* OUTPUTS:
-*           mod_entry   - start entry number which has been set for this
-*                         modification
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_entry_set   (tpm_mod_owner_t      owner,
-                                 tpm_gmacs_enum_t     gmac_port,
-                                 tpm_pkt_mod_bm_t     mod_bm,
-                                 tpm_pkt_mod_int_bm_t int_mod_bm,
-                                 tpm_pkt_mod_t        *mod_data,
-                                 uint32_t             *mod_entry)
-{
-    int32_t           rc;
-
-    rc = tpm_mod2_inlock_entry_set(owner, gmac_port, mod_bm, int_mod_bm, mod_data, mod_entry);
-
-    return(rc);
-}
-
-
-/*******************************************************************************
-* tpm_mod2_entry_get()
-*
-* DESCRIPTION: The API gets Modification table entry
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*           valid_entries   - number of valid entries in the chunk
-*                             0 - there is no requested data
-*           pnc_ref         - Number of references from Pnc entries to this modification rule
-* RETURNS:
-*           pointer to the tpm_mod2_rule_entries[TPM_MOD2_MAIN_CHAIN_SIZE]
-*           included requested data or NULL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_entry_get   (tpm_gmacs_enum_t   gmac_port,
-                                        uint32_t           mod_entry,
-                                        uint16_t           *entries_num,
-                                        tpm_mod_rule_t     *pnc_entries)
-{
-    uint16_t pmt_entry, main_chain_id, subr_chain_id, entry_num, entry_id, subr_entry_num, subr_entry_id;
-    uint16_t main_entry, subr_entry;
-    uint16_t pattern_num = 0;
-    tpm_mod2_entry_t  pattern_data;
-    tpm_chain_type_t  main_chain_type, subr_chain_type;
-
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Get Mod. entry for port %d with start index = %d\n",
-                 gmac_port, mod_entry);
-
-    if (gmac_port >= TPM_MAX_NUM_GMACS)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: port %d\n", gmac_port);
-        return TPM_FAIL;
-    }
-
-    if (entries_num == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    if (pnc_entries == NULL)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: NULL pointer\n");
-        return TPM_FAIL;
-    }
-
-    *entries_num = 0;
-
-    /* Get jump entry pattern data */
-    spin_lock_bh(&tpmMod2JumpEntryLock);
-    if (tpm_db_mod2_get_jump_entry_pattern_data(gmac_port, mod_entry, &pattern_data) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to delete jump entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2JumpEntryLock);
-
-    if (pattern_num < TPM_MAX_MOD_RULE_NUM)
-    {
-        pnc_entries[pattern_num].entry_id = mod_entry;
-        memcpy(&(pnc_entries[pattern_num].entry_data), &pattern_data, sizeof(tpm_mod2_entry_t));
-        pattern_num++;
-    }
-
-
-    /* Get main chain PMT entry index */
-    pmt_entry = tpm_mod2_get_jump_to(&pattern_data);
-    if (pmt_entry == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        return TPM_FAIL;
-    }
-
-    main_entry = pmt_entry;
-
-    /* Get main chain type and chain index */
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, pmt_entry, &main_chain_type, &main_chain_id) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_get_chain_entry_num(gmac_port, main_chain_type, main_chain_id, &entry_num) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain size\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    for (entry_id = 0; entry_id < entry_num; entry_id++)
-    {
-        /* Get main chain entry pattern data */
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_get_chain_entry_pattern_data(gmac_port, main_chain_type, main_chain_id,
-                                                        entry_id, &pattern_data) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain data\n");
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-        if (pattern_num < TPM_MAX_MOD_RULE_NUM)
-        {
-            pnc_entries[pattern_num].entry_id = main_entry + entry_id;
-            memcpy(&(pnc_entries[pattern_num].entry_data), &pattern_data, sizeof(tpm_mod2_entry_t));
-            pattern_num++;
-        }
-
-        /* Check if calling a subr chain */
-        pmt_entry = tpm_mod2_get_jump_to(&pattern_data);
-        if (pmt_entry == TPM_MOD2_NULL_ENT_IDX)
-        {
-            continue;
-        }
-
-        subr_entry = pmt_entry;
-
-        /* Get subr chain type and chain index */
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, pmt_entry, &subr_chain_type, &subr_chain_id) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_get_chain_entry_num(gmac_port, subr_chain_type, subr_chain_id, &subr_entry_num) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get subr chain size\n");
-            return TPM_FAIL;
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-        for (subr_entry_id = 0; subr_entry_id < subr_entry_num; subr_entry_id++)
-        {
-            /* Get subr chain entry pattern data */
-            spin_lock_bh(&tpmMod2ChainEntryLock);
-            if (tpm_db_mod2_get_chain_entry_pattern_data(gmac_port, subr_chain_type, subr_chain_id,
-                                                            subr_entry_id, &pattern_data) != TPM_OK)
-            {
-                spin_unlock_bh(&tpmMod2ChainEntryLock);
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get subr chain data\n");
-            }
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-            if (pattern_num < TPM_MAX_MOD_RULE_NUM)
-            {
-                pnc_entries[pattern_num].entry_id = subr_entry + subr_entry_id;
-                memcpy(&(pnc_entries[pattern_num].entry_data), &pattern_data, sizeof(tpm_mod2_entry_t));
-                pattern_num++;
-            }
-        }
-    }
-
-    *entries_num = pattern_num;
-
-    return TPM_OK;
-}
-
-
-/*******************************************************************************
-* tpm_mod2_entry_del()
-*
-* DESCRIPTION: The API invalidates a modification entry chunk - given by PNC.
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_mod2_inlock_entry_del(tpm_mod_owner_t      owner,
-                                  tpm_gmacs_enum_t     gmac_port,
-                                  uint32_t             mod_entry)
-{
-    uint16_t pmt_entry, main_chain_id, subr_chain_id, entry_num, entry_id;
-    tpm_mod2_entry_t  pattern_data;
-    tpm_chain_type_t  main_chain_type, subr_chain_type;
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "for gmac_port= (%d) mod_entry (%d)\n", gmac_port, mod_entry);
-    if (gmac_port >= TPM_MAX_NUM_GMACS)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: port %d\n", gmac_port);
-        return TPM_FAIL;
-    }
-
-    memset(&pattern_data, 0, sizeof(tpm_mod2_entry_t));
-
-    /* Invalidate HW entry */
-    tpm_mod2_hw_inv_entry(gmac_port, mod_entry);
-
-    /* Get jump entry pattern data */
-    spin_lock_bh(&tpmMod2JumpEntryLock);
-    if (tpm_db_mod2_get_jump_entry_pattern_data(gmac_port, mod_entry, &pattern_data) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to delete jump entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2JumpEntryLock);
-
-    /* Delete jump entry */
-    spin_lock_bh(&tpmMod2JumpEntryLock);
-    if (tpm_db_mod2_del_jump_entry(gmac_port, mod_entry) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to delete jump entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2JumpEntryLock);
-
-    /* Get main chain PMT entry index */
-    pmt_entry = tpm_mod2_get_jump_to(&pattern_data);
-    if (pmt_entry == TPM_MOD2_NULL_ENT_IDX)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        return TPM_FAIL;
-    }
-    /* Get main chain type and chain index */
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, pmt_entry, &main_chain_type, &main_chain_id) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_get_chain_entry_num(gmac_port, main_chain_type, main_chain_id, &entry_num) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain size\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    for (entry_id = 0; entry_id < entry_num; entry_id++)
-    {
-        /* Get main chain entry pattern data */
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_get_chain_entry_pattern_data(gmac_port, main_chain_type, main_chain_id,
-                                                        entry_id, &pattern_data) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain size\n");
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-        /* Check if calling a subr chain */
-        pmt_entry = tpm_mod2_get_jump_to(&pattern_data);
-        if (pmt_entry == TPM_MOD2_NULL_ENT_IDX)
-        {
-            continue;
-        }
-
-        /* Get subr chain type and chain index */
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_get_chain_id_by_pmt_entry(gmac_port, pmt_entry, &subr_chain_type, &subr_chain_id) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get main chain entry\n");
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-        /* Delete subr chain */
-        spin_lock_bh(&tpmMod2ChainEntryLock);
-        if (tpm_db_mod2_del_chain_entry(gmac_port, subr_chain_type, subr_chain_id) != TPM_OK)
-        {
-            spin_unlock_bh(&tpmMod2ChainEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to delete chain entries\n");
-        }
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-    }
-
-    /* Delete main chain */
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_del_chain_entry(gmac_port, main_chain_type, main_chain_id) != TPM_OK)
-    {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to delete chain entries\n");
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_entry_del()
-*
-* DESCRIPTION: The API invalidates a modification entry chunk - given by PNC.
-*
-* INPUTS:   gmac_port   - GMAC port
-*           mod_entry   - start entry number (in the "jump" area)
-*
-* OUTPUTS:
-*
-* RETURNS:
-*           TPM_OK, TPM_NOT_FOUND or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_mod2_entry_del(tpm_mod_owner_t      owner,
-                           tpm_gmacs_enum_t     gmac_port,
-                           uint32_t             mod_entry)
-{
-    int32_t            rc;
-
-    //if (in_interrupt())
-    //{
-    //    return ERR_IN_INTERRUPT;
-    //}
-
-    /* Lock the Mod */
-    //spin_lock(&tpmModLock);
-
-    rc = tpm_mod2_inlock_entry_del(owner, gmac_port, mod_entry);
-
-    /* Unlock Mod */
-    //spin_lock(&tpmModLock);
-    return (rc);
-}
-
-
-/*******************************************************************************
-* tpm_mod2_mac_inv()
-*
-* DESCRIPTION: The API resets Modification table for a specified port
-*
-* INPUTS:   gmac_port     - GMAC port
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_mac_inv  (tpm_gmacs_enum_t   gmac_port)
-{
-    uint32_t    cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " TPM is NOT invalidating the MOD - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, " gmac_port = %d \n", gmac_port);
-
-    if (gmac_port >= TPM_MAX_NUM_GMACS)
-    {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid parameter: port %d \n", gmac_port);
-        return TPM_FAIL;
-    }
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "gmac port = %d\n", gmac_port);
-
-    /* Invalidate PMT */
-    mvNetaPmtClear(gmac_port);
-
-    return TPM_OK;
-}
-
-
-
-/*******************************************************************************
-* tpm_mod2_registers_init()
-*
-* DESCRIPTION: The API sets init values to the HW registers used by modification
-*
-* INPUTS:   None
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_mod2_registers_init  (tpm_gmacs_enum_t   gmac_port, uint16_t  txp)
-{
-    uint32_t gmac_mh_en;
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "\n");
-
-    /* Init PPPOE registers*/
-    MV_REG_WRITE (NETA_TX_PMT_PPPOE_TYPE_REG(gmac_port, txp), TPM_MOD2_DEFAULT_PPPOE_ETY);
-    MV_REG_WRITE (NETA_TX_PMT_PPPOE_DATA_REG(gmac_port, txp), TPM_MOD2_DEFAULT_PPPOE_DATA);
-    MV_REG_WRITE (NETA_TX_PMT_PPPOE_PROTO_REG(gmac_port, txp), TPM_MOD2_DEFAULT_PPPOE_PROTO);
-
-    if ((TPM_ENUM_GMAC_0 == gmac_port) || (TPM_ENUM_GMAC_1 == gmac_port))
-        tpm_db_gmac_mh_en_conf_get(gmac_port, &gmac_mh_en);
-    else
-        gmac_mh_en = 1;
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "GMAC: (%d), mh_en: (%d)\n", gmac_port, gmac_mh_en);
-
-    if (gmac_mh_en)
-        MV_REG_WRITE (NETA_TX_PMT_PPPOE_LEN_REG(gmac_port, txp), TPM_MOD2_DEFAULT_PPPOE_LEN_MH_EN);
-    else
-        MV_REG_WRITE (NETA_TX_PMT_PPPOE_LEN_REG(gmac_port, txp), TPM_MOD2_DEFAULT_PPPOE_LEN_MH_DIS);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_modz2_tpid_get()
-*
-* DESCRIPTION:     The function receives a tpid, and returns the selector that matches it.
-*                  - If the tpid has a match, it is returned.
-*                  - If there is no match, a new selector  is created in hardware and in DB.
-*                  - If there is no free selector,  an error is returned
-*
-* INPUTS:
-* tpid            - Requested Vlan tpid
-*
-* OUTPUTS:
-* eth_type_sel    - selector that matches the tpid
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_mod2_tpid_get(uint32_t tpid,
-                          uint32_t *eth_type_sel)
-{
-    uint32_t    ret_code;
-    uint32_t    l_etype_sel;
-    int         port, txp;
-
-    /* Check if vlan_ethertype exists */
-    ret_code = tpm_db_mod_etype_sel_get(tpid, &l_etype_sel);
-
-    /*Create new entry for ethertype */
-    if (ret_code != TPM_OK)
-    {
-        TPM_OS_DEBUG(TPM_MODZ2_HM_MOD,  "New tpid(0x%4x)", tpid);
-
-        /* Get free Etype Select */
-        ret_code = tpm_db_mod_etype_sel_free_get(&l_etype_sel);
-        if (ret_code != TPM_OK)
-        {
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Can't create additional Vlan Ethertype, tpid(0x%x)\n", tpid);
-            return(TPM_FAIL);
-        }
-        else
-        {
-            /* Create tpid in HW  */
-            for (port=TPM_ENUM_GMAC_0; port < TPM_MAX_NUM_GMACS; port++)
-            {
-                TPM_OS_DEBUG(TPM_MODZ2_HM_MOD,  " port(%d) sel(%d)\n", port, l_etype_sel);
-
-                if (port != TPM_ENUM_PMAC)
-                {
-                    mvNetaVlanEtySet(port, 0, l_etype_sel, tpid);
-                }
-                else
-                {
-                    for (txp=0; txp < TPM_MAX_NUM_TCONT; txp++)
-                    {
-                        mvNetaVlanEtySet(port, txp, l_etype_sel, tpid);
-                    }
-                }
-            }
-
-            /* Set tpid in db */
-            ret_code = tpm_db_mod_etype_sel_set(tpid, l_etype_sel);
-            if (ret_code != TPM_OK)
-            {
-                TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Can't create additional Vlan Ethertype, tpid(0x%x) l_etype_sel(%d)\n", tpid, l_etype_sel);
-                return(TPM_FAIL);
-            }
-        }
-    }
-
-    *eth_type_sel = l_etype_sel;
-
-    TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "etype_sel(%d)\n", l_etype_sel);
-    return(TPM_OK);
-}
-
-
-int32_t tpm_mod2_init(void)
-{
-    spin_lock_init(&tpmMod2JumpEntryLock);
-    spin_lock_init(&tpmMod2ChainEntryLock);
-    spin_lock_init(&tpmMod2PmtHwLock);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_split_mod_create_l2_pmts()
-*
-* DESCRIPTION:     The function create split mod entries
-*                  - If the tpid has a match, it is returned.
-*                  - If there is no match, a new selector  is created in hardware and in DB.
-*                  - If there is no free selector,  an error is returned
-*
-* INPUTS:
-* port            - target gmac port
-* mod_data        - split mod entries info
-* init_flag       -flag indicate whether it invoked by init or not
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_mod2_split_mod_create_l2_pmts(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data, bool init_flag)
-{
-	uint32_t p_bits_nums;
-	uint32_t loop;
-	uint32_t mod_entry;
-	int32_t db_ret, tpm_ret;
-	uint32_t vlan_index;
-	tpm_vlan_key_t *vlan_out = NULL;
-	tpm_pkt_mod_t mod_data_tmp;
-
-	/*check param*/
-	if (mod_data == NULL) {
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid pointer\n");
-		return(TPM_FAIL);
-	}
-
-	if (TPM_SPLIT_MOD_DISABLED == tpm_db_split_mod_get_enable())
-	{
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "SPLIT_MOD_DISABLED\n");
-		return(TPM_RC_OK);
-	}
-
-	/* find vlan */
-	db_ret = tpm_db_mod2_split_mod_get_vlan_index(port, mod_data, &vlan_index);
-	if (TPM_DB_OK == db_ret)
-	{
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "this vlan already exists\n");
-		/* increase user number of this vlan */
-		tpm_db_mod2_split_mod_increase_vlan_user_num(port, mod_data);
-		return(TPM_OK);
-	}
-
-	db_ret = tpm_db_mod2_split_mod_insert_vlan(port, mod_data);
-	if (TPM_DB_OK != db_ret)
-	{
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "insert_vlan failed\n");
-		return(ERR_GENERAL);
-	}
-
-	p_bits_nums = TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX;
-
-	memcpy(&mod_data_tmp, mod_data, sizeof(tpm_pkt_mod_t));
-	/* VLANOP_EXT_TAG_MOD_INS mod insert VLAN p_bit*/
-	if (VLANOP_EXT_TAG_MOD_INS == mod_data->vlan_mod.vlan_op)
-		vlan_out = &mod_data_tmp.vlan_mod.vlan2_out;
-	else
-		vlan_out = &mod_data_tmp.vlan_mod.vlan1_out;
-
-	if (!init_flag) {
-		vlan_out->pbit_mask = 0;
-		/* add the first pmt to set p-bit AS-IS */
-		tpm_ret = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, port, TPM_VLAN_MOD, TPM_INT_SPLIT_MOD, &mod_data_tmp, &mod_entry);
-		if (TPM_OK != tpm_ret)
-		{
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "set pbit init PMT failed: port %d\n", port);
-			return TPM_FAIL;
-		}
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "add the first pmt to set p-bit AS-IS, mod_entry: %d \n", mod_entry);
-	}
-
-	vlan_out->pbit_mask = 0xff;
-
-	/* build pmt entry for each pbit from 0 to 7 */
-	for (loop = 0; loop < p_bits_nums; loop++) {
-		vlan_out->pbit = loop;
-		tpm_ret = tpm_mod2_entry_set(TPM_MOD_OWNER_TPM, port, TPM_VLAN_MOD, TPM_INT_SPLIT_MOD, &mod_data_tmp, &mod_entry);
-		if (TPM_OK != tpm_ret) {
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "set pbit init PMT failed: port %d, pbit %d \n", port, loop);
-			return TPM_FAIL;
-		}
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "add pmt for p-bit: %d, mod_entry: %d \n", loop, mod_entry);
-	}
-
-	return TPM_OK;
-}
-
-int32_t tpm_mod2_split_mod_init(tpm_gmacs_enum_t port)
-{
-	int32_t	    tpm_ret;
-	tpm_pkt_mod_t mod_data;
-
-	if (TPM_SPLIT_MOD_DISABLED == tpm_db_split_mod_get_enable())
-	{
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "SPLIT_MOD_DISABLED\n");
-		return(TPM_OK);
-	}
-
-	/* add default pmt from 1 to p_bits_nums */
-	memset(&mod_data, 0, sizeof(mod_data));
-	mod_data.vlan_mod.vlan_op = VLANOP_EXT_TAG_MOD;
-	mod_data.vlan_mod.vlan1_out.pbit_mask = 0xff;
-
-	tpm_ret = tpm_mod2_split_mod_create_l2_pmts(port, &mod_data, true);
-	if (TPM_RC_OK != tpm_ret)
-	{
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "failed to add default pmt from 1 to p_bits_nums\n");
-		return(TPM_FAIL);
-	}
-
-	/* add default pmt from untag NOOP to p_bits_nums */
-	memset(&mod_data, 0, sizeof(mod_data));
-	mod_data.vlan_mod.vlan_op = VLANOP_NOOP;
-	//mod_data.vlan_mod.vlan1_out.pbit_mask = 0xff;
-
-	tpm_ret = tpm_mod2_split_mod_create_l2_pmts(port, &mod_data, true);
-	if (TPM_RC_OK != tpm_ret)
-	{
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "failed to add default pmt from 1 to p_bits_nums\n");
-		return(TPM_FAIL);
-	}
-
-	return TPM_OK;
-}
-
-void tpm_mod2_split_mod_entry_del(tpm_gmacs_enum_t     gmac_port,
-                                  uint32_t             mod_entry,
-                                  uint32_t             vlan_index)
-{
-	int32_t  tpm_ret;
-	uint32_t i = 0;
-	uint32_t num_pbits;
-	uint32_t user_num = 0;
-
-	/* decrease user number of this vlan */
-	tpm_ret = tpm_db_mod2_split_mod_decrease_vlan_user_num(gmac_port, vlan_index, &user_num);
-	if (TPM_DB_OK != tpm_ret)
-	{
-		TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "failed to decrease vlan user num, index: %d\n", vlan_index);
-		return;
-	}
-
-	/* still other usr, do not remove */
-	if (user_num != 0)
-	{
-		TPM_OS_INFO(TPM_MODZ2_HM_MOD, "still other usr, do not remove, usr num: %d\n", user_num);
-		return;
-	}
-
-	/* remove all the PMT entry for this VLAN */
-	num_pbits = TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX;
-	for(i = 0; i <= num_pbits; i++) {
-		tpm_ret = tpm_mod2_entry_del(TPM_MOD_OWNER_TPM, gmac_port, (vlan_index * 16 + i));
-		if (TPM_DB_OK != tpm_ret)
-		{
-			TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "failed to del split mod, index: %d\n", (vlan_index * 16 + i));
-			return;
-		}
-	}
-
-	return;
-}
-int32_t tpm_mod2_split_mod_try_pmt_entry_del(tpm_api_sections_t api_section,
-                                  tpm_gmacs_enum_t     gmac_port,
-                                  uint32_t             mod_entry)
-{
-	uint32_t num_vlans;
-	uint32_t vlan_index;
-	tpm_gmacs_enum_t duplicate_gmac;
-	tpm_db_ds_mac_based_trunk_enable_t ds_mac_based_trunk_enable;
-
-	if (!mod_entry) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "mod_entry is zero, PMT do not need to be removed\n");
-		return(TPM_OK);
-	}
-
-	if (TPM_SPLIT_MOD_DISABLED == tpm_db_split_mod_get_enable()) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "SPLIT_MOD_DISABLED, PMT need to be removed\n");
-		return(TPM_FAIL);
-	}
-
-	if (	(    (TPM_IPV4_ACL == api_section)
-		  || (TPM_L4_ACL == api_section)
-		  || (TPM_IPV6_GEN_ACL == api_section)
-		  || (TPM_IPV6_DIP_ACL == api_section))
-	     && (mod_entry <= TPM_DB_SPLIT_MOD_P_BIT_NUM_MAX)) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "IPv4/6 split mod, PMT do not need to be removed\n");
-		return(TPM_OK);
-	}
-
-	if (TPM_L2_PRIM_ACL != api_section) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Not L2 ACL, PMT need to be removed\n");
-		return(TPM_FAIL);
-	}
-
-	if ((mod_entry % 16) > 8) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Not L2 split mod: %d, PMT need to be removed\n", mod_entry);
-		return(TPM_FAIL);
-	}
-
-	vlan_index = mod_entry / 16;
-	num_vlans = tpm_db_split_mod_get_num_vlans();
-	if (vlan_index > num_vlans) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "Not L2 split mod: %d, PMT need to be removed\n", mod_entry);
-		return(TPM_FAIL);
-	}
-
-	if (vlan_index <= 1) {
-		TPM_OS_DEBUG(TPM_MODZ2_HM_MOD, "mod entry: %d, PMT smaller than 32 is reserved, "
-			"can not be removed\n", mod_entry);
-		return(TPM_OK);
-	}
-
-	tpm_mod2_split_mod_entry_del(gmac_port, mod_entry, vlan_index);
-
-	/* when ds load balance on G0 and G1 is enabled, need to duplicate DS PMT on G0/1 */
-	tpm_db_ds_mac_based_trunk_enable_get(&ds_mac_based_trunk_enable);
-	if (	(TPM_DS_MAC_BASED_TRUNK_ENABLED == ds_mac_based_trunk_enable)
-	     && (TPM_ENUM_GMAC_0 == gmac_port || TPM_ENUM_GMAC_1 == gmac_port)) {
-
-		/* if this is DS and DS_MAC_BASED_TRUNK is ENABLED */
-		if (gmac_port == TPM_ENUM_GMAC_0)
-			duplicate_gmac = TPM_ENUM_GMAC_1;
-		else
-			duplicate_gmac = TPM_ENUM_GMAC_0;
-
-		tpm_mod2_split_mod_entry_del(duplicate_gmac, mod_entry, vlan_index);
-	}
-	return TPM_OK;
-}
-
-
-/*******************************************************************************
-                          Modification table print functions
-*******************************************************************************/
-char *opCodeOperationStr[30] =
-{
-    "NOOP",
-    "ADD",
-    "CONF_VLAN",
-    "ADD_VLAN",
-    "CONF_DSA1",
-    "CONF_DSA2",
-    "ADD_DSA",
-    "DEL",
-    "REP2",
-    "REP_LSB",
-    "REP_MSB",
-    "REP_VLAN",
-    "DEC_TTL_LSB",
-    "DEC_TTL_MSB",
-    "ADD_CALC_LEN",
-    "REP_LEN",
-    "REP_IP_CHKSUM",
-    "REP_L4_CHKSUM",
-    "SKIP",
-    "JUMP",
-    "JUMP_SKIP2",
-    "JUMP_SUBR",
-    "PPPOE",
-    "STORE",
-    "ADD_IP_CHKSUM",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED",
-    "RESERVED"
-};
-
-static void tpm_mod2_print_header (void)
-{
-    printk("==========================================================\n");
-    printk(" Index  OpCode    Operation      Data  Last  IPv4    L4   \n");
-    printk("                                            update update \n");
-    printk("==========================================================\n");
-}
-
-int32_t tpm_mod2_print_tmp_pattern (tpm_mod_pattern_data_t *pattern_data)
-{
-    uint32_t set_id, line_id;
-    tpm_pattern_entry_t *entry_p = NULL;
-    uint16_t pmt_entry;
-
-    if (NULL == pattern_data)
-    {
-        return TPM_FAIL;
-    }
-
-    tpm_mod2_print_header();
-
-    for (set_id = 0; set_id < TPM_MOD2_MAX_PATTERN_SETS; set_id++)
-    {
-        if (pattern_data->pattern_set[set_id].is_valid)
-        {
-            entry_p = &(pattern_data->pattern_set[set_id]);
-
-            if (set_id == 0)
-            {
-                pmt_entry = entry_p->index;
-            }
-            else
-            {
-                pmt_entry = tpm_db_mod2_convert_chain_to_pmt_entry(entry_p->chain_type, entry_p->index);
-            }
-
-            printk("[ set %d ] area_type %d, chain_type %d, chain_index %d (pmt_entry 0x%04x), line_num %d \r\n",
-                    set_id, entry_p->area_type, entry_p->chain_type, entry_p->index, pmt_entry, entry_p->line_num);
-            for (line_id = 0; line_id < TPM_MOD2_MAX_PATTERN_ENTRIES && line_id < entry_p->line_num; line_id++)
-            {
-                printk(" %03d      0x%2x  %15s  0x%4.4x  %1d     %1d      %1d\n",
-                       line_id,
-                       entry_p->line[line_id].opcode,
-                       opCodeOperationStr[entry_p->line[line_id].opcode],
-                       entry_p->line[line_id].data, entry_p->line[line_id].last,
-                       entry_p->line[line_id].updt_ipv4, entry_p->line[line_id].updt_tcp);
-            }
-        }
-    }
-    return TPM_OK;
-}
-
-int32_t tpm_mod2_print_rule (tpm_gmacs_enum_t   gmac_port,
-                             uint32_t           mod_entry)
-{
-    tpm_mod_rule_t mod_rule[TPM_MAX_MOD_RULE_NUM];
-    uint16_t       rule_num, rule_idx;
-
-    if (tpm_mod2_entry_get(gmac_port, mod_entry, &rule_num, mod_rule) != TPM_OK)
-    {
-        printk("Modification entry %d is not found\n", mod_entry);
-        return TPM_NOT_FOUND;
-    }
-
-    tpm_mod2_print_header();
-
-    for (rule_idx = 0; rule_idx < rule_num; rule_idx++)
-    {
-        printk(" %03d      0x%2x  %15s  0x%4.4x  %1d     %1d      %1d\n",
-               mod_rule[rule_idx].entry_id, mod_rule[rule_idx].entry_data.opcode,
-               opCodeOperationStr[mod_rule[rule_idx].entry_data.opcode],
-               mod_rule[rule_idx].entry_data.data, mod_rule[rule_idx].entry_data.last,
-               mod_rule[rule_idx].entry_data.updt_ipv4, mod_rule[rule_idx].entry_data.updt_tcp);
-    }
-
-
-    return TPM_OK;
-}
-
-int32_t tpm_mod2_print_jump_all (tpm_gmacs_enum_t   gmac_port)
-{
-    tpm_db_mod2_show_jump_pmt_entries(gmac_port);
-    return TPM_OK;
-}
-
-int32_t tpm_mod2_print_main_all (tpm_gmacs_enum_t   gmac_port)
-{
-    tpm_db_mod2_show_chain_pmt_entries(gmac_port, TPM_CHAIN_TYPE_NONE);
-    return TPM_OK;
-}
-
-int32_t tpm_mod2_print_config (tpm_gmacs_enum_t   gmac_port)
-{
-    uint32_t chain_type;
-
-    tpm_db_mod2_show_jump_cfg_data();
-    for (chain_type = TPM_CHAIN_TYPE_MH; chain_type < TPM_CHAIN_TYPE_MAX; chain_type++)
-    {
-        tpm_db_mod2_show_chain_cfg_data(chain_type);
-    }
-
-    return TPM_OK;
-}
-
-/*tpm check*/
-/*******************************************************************************
-* tpm_mod2_main_chain_index_get - Get main chain index from HW or DB
-*
-* INPUT:
-*       gmac_port - target gmac port
-*	jump_idx - jump entry index
-*	from - get main chain index from DB or HW
-*
-* OUTPUT:
-*	main_entry - main chain index
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t	tpm_mod2_main_chain_index_get(tpm_gmacs_enum_t gmac_port, uint16_t jump_idx,
-				      uint16_t *main_entry, tpm_self_check_enable_t from)
-{
-    int err;
-    tpm_mod2_entry_t db_jump_pattern;
-    MV_NETA_PMT pEntry;
-
-    /*params check*/
-    if (main_entry == NULL) {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "NULL pointer\n");
-        return TPM_FAIL;
-    }
-    if (from != TPM_CHECK_MAIN_CHAIN_IDX_DB && from != TPM_CHECK_MAIN_CHAIN_IDX_HW) {
-        TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Invalid input\n");
-        return TPM_FAIL;
-    }
-
-    if (from == TPM_CHECK_MAIN_CHAIN_IDX_DB) {
-        /*get main chain index from DB*/
-        spin_lock_bh(&tpmMod2JumpEntryLock);
-        if (tpm_db_mod2_get_jump_entry_pattern_data(gmac_port, jump_idx, &db_jump_pattern) != TPM_OK) {
-            spin_unlock_bh(&tpmMod2JumpEntryLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get db jump entry pattern_data\n");
-            return TPM_FAIL;
-        }
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        *main_entry = db_jump_pattern.data;
-    } else if (from == TPM_CHECK_MAIN_CHAIN_IDX_HW) {
-        /*get main chain index from HW*/
-        spin_lock_bh(&tpmMod2PmtHwLock);
-        err = mvNetaPmtRead(gmac_port, jump_idx, &pEntry);
-        if (err) {
-            spin_unlock_bh(&tpmMod2PmtHwLock);
-            TPM_OS_ERROR(TPM_MODZ2_HM_MOD, "Failed to get hw jump data\n");
-            return TPM_FAIL;
-        }
-        spin_unlock_bh(&tpmMod2PmtHwLock);
-        *main_entry = pEntry.word & 0xFFFF;
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_neta_pmt_get - read HW PMT entry from target port
-*
-* INPUT:
-*       gmac_port - target gmac port
-*	idx - entry index
-*
-* OUTPUT:
-*	pEntry - pmt entry wanted
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_mod2_neta_pmt_get(tpm_gmacs_enum_t gmac_port, int idx, MV_NETA_PMT *pEntry)
-{
-    spin_lock_bh(&tpmMod2PmtHwLock);
-    if (mvNetaPmtRead(gmac_port, idx, pEntry)) {
-        spin_unlock_bh(&tpmMod2PmtHwLock);
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2PmtHwLock);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_db_jump_pattern_data_get - read jump entry pattern data from tpm db
-*
-* INPUT:
-*       gmac_port - target gmac port
-*	entry_id - jump entry index
-*
-* OUTPUT:
-*	pattern - pattern data
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_mod2_db_jump_pattern_data_get(tpm_gmacs_enum_t gmac_port, uint16_t entry_id, tpm_mod2_entry_t *pattern)
-{
-    spin_lock_bh(&tpmMod2JumpEntryLock);
-    if (tpm_db_mod2_get_jump_entry_pattern_data(gmac_port, entry_id, pattern) != TPM_OK) {
-        spin_unlock_bh(&tpmMod2JumpEntryLock);
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2JumpEntryLock);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_mod2_db_jump_pattern_data_get - read chain entry pattern data from tpm db
-*
-* INPUT:
-*       gmac_port - target gmac port
-*	chain_type - chain type
-*	chain_id - chain index
-*	pattern_id - pattern index
-*
-* OUTPUT:
-*	pattern - pattern data
-*
-*RETURN:
-*
-*COMMENTS:
-*
-*******************************************************************************/
-int32_t tpm_mod2_db_chain_pattern_data_get(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					   uint16_t chain_id, uint16_t pattern_id, tpm_mod2_entry_t *pattern)
-{
-    spin_lock_bh(&tpmMod2ChainEntryLock);
-    if (tpm_db_mod2_get_chain_entry_pattern_data(gmac_port, chain_type, chain_id, pattern_id, pattern)) {
-        spin_unlock_bh(&tpmMod2ChainEntryLock);
-        return TPM_FAIL;
-    }
-    spin_unlock_bh(&tpmMod2ChainEntryLock);
-
-    return TPM_OK;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.h
deleted file mode 100644
index 672227a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_modz2_mgr.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#ifndef __TPM_MODZ2_H__
-#define __TPM_MODZ2_H__
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "tpm_common.h"
-#include "tpm_db.h"
-#include "tpm_self_check.h"
-
-/*************************************************************/
-/*               TEMP. DEFINITIONS                           */
-/*************************************************************/
-
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-#define TPM_MOD2_OPCODE_NOOP                0x0
-#define TPM_MOD2_OPCODE_ADD                 0x1
-#define TPM_MOD2_OPCODE_CONF_VLAN           0x2
-#define TPM_MOD2_OPCODE_ADD_VLAN            0x3
-#define TPM_MOD2_OPCODE_CONF_DSA1           0x4
-#define TPM_MOD2_OPCODE_CONF_DSA2           0x5
-#define TPM_MOD2_OPCODE_ADD_DSA             0x6
-#define TPM_MOD2_OPCODE_DEL                 0x7
-#define TPM_MOD2_OPCODE_REP2                0x8
-#define TPM_MOD2_OPCODE_REP_LSB             0x9
-#define TPM_MOD2_OPCODE_REP_MSB             0xA
-#define TPM_MOD2_OPCODE_REP_VLAN            0xB
-#define TPM_MOD2_OPCODE_DEC_TTL_LSB         0xC
-#define TPM_MOD2_OPCODE_DEC_TTL_MSB         0xD
-#define TPM_MOD2_OPCODE_ADD_CALC_LEN        0xE
-#define TPM_MOD2_OPCODE_REP_LEN             0xF
-#define TPM_MOD2_OPCODE_REP_IP_CHKSUM       0x10
-#define TPM_MOD2_OPCODE_ADD_IP_CHKSUM       0x18
-#define TPM_MOD2_OPCODE_REP_L4_CHKSUM       0x11
-#define TPM_MOD2_OPCODE_SKIP                0x12
-#define TPM_MOD2_OPCODE_JUMP                0x13
-#define TPM_MOD2_OPCODE_JUMP_SKIP2          0x14
-#define TPM_MOD2_OPCODE_JUMP_SUBR           0x15
-#define TPM_MOD2_OPCODE_PPPOE               0x16
-#define TPM_MOD2_OPCODE_STORE               0x17
-
-
-#define TPM_MOD2_DEFAULT_ETY                (0x8100)
-#define TPM_MOD2_DEFAULT_PPPOE_ETY          (0x8864)
-#define TPM_MOD2_DEFAULT_PPPOE_DATA         (0x1100)
-#define TPM_MOD2_DEFAULT_PPPOE_LEN_MH_EN    (0x7000)
-#define TPM_MOD2_DEFAULT_PPPOE_LEN_MH_DIS   (0x7202)
-#define TPM_MOD2_DEFAULT_PPPOE_PROTO        (0x0021)
-
-/* Self-defined Ethernet type for CPU loopback frames*/
-#define TPM_MOD2_CPU_LOOPBACK_ETY           (0xAABB)
-/* Self-defined Marvell header for MAC learning frames on Media Convert*/
-#define TPM_MOD2_MAC_LEARN_MH               (0xAACC)
-
-/* Max number of modification entries per command */
-#define TPM_MOD2_MAX_CMD_ENTRIES            (5)
-
-#define TPM_MOD2_MH_CMD_ENTRIES             (1)
-#define TPM_MOD2_MAC_CMD_ENTRIES            (3)
-#define TPM_MOD2_IP_CMD_ENTRIES             (2)
-#define TPM_MOD2_PPPOE_DEL_CMD_ENTRIES      (2)
-#define TPM_MOD2_PPPOE_ADD_CMD_ENTRIES      (1)
-#define TPM_MOD2_IPV6_PPPOE_ADD_CMD_ENTRIES (5)
-
-#define TPM_MOD2_MAX_VLAN_ENTRIES           (2)
-#define TPM_MOD2_VLAN_ADD_ENTRIES           (2)
-#define TPM_MOD2_VLAN_DEL_ENTRIES           (1)
-#define TPM_MOD2_VLAN_MOD_ENTRIES           (2)
-#define TPM_MOD2_VLAN_SKIP_ENTRIES          (1)
-
-#define TPM_MOD2_NULL_PATTERN_IDX           (0xFF)
-
-#define TPM_MOD2_NEW_TPID                   (0xFFFF)
-#define TPM_MOD2_NEW_VID                    (0xFFFF)
-#define TPM_MOD2_NEW_CFI                    (0xFF)
-#define TPM_MOD2_NEW_PBIT                   (0xFF)
-
-#define TPM_MOD2_ORIGINAL_VID               (0x0)
-#define TPM_MOD2_ORIGINAL_CFI               (0x0)
-#define TPM_MOD2_ORIGINAL_PBIT              (0x0)
-
-#define TPM_MOD2_ENTRY_VID_OFFS             (0)
-#define TPM_MOD2_ENTRY_VID_BITS             (12)
-#define TPM_MOD2_ENTRY_VID_MASK             (((1 << TPM_MOD2_ENTRY_VID_BITS) - 1) << TPM_MOD2_ENTRY_VID_OFFS)
-
-#define TPM_MOD2_ENTRY_CFI_OFFS             (12)
-#define TPM_MOD2_ENTRY_CFI_BITS             (1)
-#define TPM_MOD2_ENTRY_CFI_MASK             (1 << TPM_MOD2_ENTRY_CFI_OFFS)
-
-#define TPM_MOD2_ENTRY_PBIT_OFFS            (13)
-#define TPM_MOD2_ENTRY_PBIT_BITS            (3)
-#define TPM_MOD2_ENTRY_PBIT_MASK            (((1 << TPM_MOD2_ENTRY_PBIT_BITS) - 1) << TPM_MOD2_ENTRY_PBIT_OFFS)
-
-#define TPM_MOD2_ENTRY_MOD_DATA_MASK        (0x0000FFFF)
-
-#define TPM_MOD2_TP_FROM_REG_0              (0x0000)
-#define TPM_MOD2_TP_FROM_REG_1              (0x0001)
-#define TPM_MOD2_TP_FROM_REG_2              (0x0002)
-#define TPM_MOD2_TP_FROM_REG_3              (0x0003)
-#define TPM_MOD2_TP_FROM_VLAN_1             (0x0004)
-#define TPM_MOD2_TP_FROM_VLAN_2             (0x0005)
-
-#define TPM_MOD2_VID_FROM_VLAN_1            (0x0000)
-#define TPM_MOD2_VID_FROM_VLAN_2            (0x0010)
-#define TPM_MOD2_VID_NEW                    (0x0020)
-
-#define TPM_MOD2_CFI_FROM_VLAN_1            (0x0000)
-#define TPM_MOD2_CFI_FROM_VLAN_2            (0x0040)
-#define TPM_MOD2_CFI_NEW                    (0x0080)
-
-#define TPM_MOD2_PBIT_FROM_VLAN_1           (0x0000)
-#define TPM_MOD2_PBIT_FROM_VLAN_2           (0x0100)
-#define TPM_MOD2_PBIT_NEW                   (0x0200)
-
-
-#define TPM_MOD2_INVALID_CHAIN_ID           (0xFFFF)
-
-#define TPM_MOD2_IPV4_MOD_MASK              (TPM_DSCP_SET | TPM_TTL_DEC | TPM_IPV4_UPDATE | TPM_IPV4_SRC_SET | TPM_IPV4_DST_SET)
-#define TPM_MOD2_IPV6_MOD_MASK              (TPM_IPV6_UPDATE | TPM_HOPLIM_DEC | TPM_IPV6_SRC_SET | TPM_IPV6_DST_SET)
-#define TPM_MOD2_L4_MOD_MASK                (TPM_L4_SRC_SET | TPM_L4_DST_SET)
-
-#define TPM_MOD2_DONT_CARE_INT_BM           (0xFFFFFFFF)
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-
-/*************************************************************/
-/*               STRUCTURES                                  */
-/*************************************************************/
-
-typedef struct
-{
-    tpm_area_type_t     area_type;
-    tpm_chain_type_t    chain_type;
-    uint16_t            index;
-    uint8_t             is_valid;
-    uint8_t             line_num;
-    tpm_mod2_entry_t    line[TPM_MOD2_MAX_PATTERN_ENTRIES];
-} tpm_pattern_entry_t;
-
-typedef struct
-{
-    tpm_chain_type_t    main_chain_type;
-    uint16_t            main_chain_id;
-    tpm_pattern_entry_t pattern_set[TPM_MOD2_MAX_PATTERN_SETS];
-} tpm_mod_pattern_data_t;
-
-typedef int32_t  (*pattern_f)(tpm_gmacs_enum_t      gmac_port,
-                              uint32_t                bm,
-                              uint16_t                cmd_idx,
-                              uint8_t                *skip,
-                              tpm_pkt_mod_t          *mod_data,
-                              tpm_mod_pattern_data_t *pattern_data,
-                              tpm_self_check_enable_t is_tpm_check);
-
-typedef struct
-{
-    uint8_t             skip_before;
-    uint8_t             skip_no_parse;
-    uint32_t            mask;
-    pattern_f           process_pattern;
-    tpm_mod2_entry_t    entry[TPM_MOD2_MAX_CMD_ENTRIES];
-
-} tpm_mod_flag_bm_entry_t;
-
-typedef struct
-{
-    tpm_mod2_entry_t    vlan1[TPM_MOD2_MAX_VLAN_ENTRIES];
-    tpm_mod2_entry_t    vlan2[TPM_MOD2_MAX_VLAN_ENTRIES];
-} tpm_mod_vlan_entry_t;
-
-typedef struct
-{
-    tpm_chain_type_t chain_type;
-    tpm_pkt_mod_bm_t mod_bm;
-	tpm_pkt_mod_int_bm_t int_mod_bm;
-} tpm_chain_map_t;
-
-/*************************************************************/
-/*               PROTOTYPES                                  */
-/*************************************************************/
-int32_t    tpm_mod2_entry_set   (tpm_mod_owner_t    owner,
-                                 tpm_gmacs_enum_t   gmac_port,
-                                 tpm_pkt_mod_bm_t   mod_bm,
-                                 tpm_pkt_mod_int_bm_t int_mod_bm,
-                                 tpm_pkt_mod_t      *mod_data,
-                                 uint32_t           *mod_entry);
-
-int32_t    tpm_mod2_entry_get   (tpm_gmacs_enum_t   gmac_port,
-                                        uint32_t           mod_entry,
-                                        uint16_t           *entries_num,
-                                        tpm_mod_rule_t     *pnc_entries);
-
-int32_t    tpm_mod2_entry_del   (tpm_mod_owner_t    owner,
-                                 tpm_gmacs_enum_t   gmac_port,
-                                 uint32_t           mod_entry);
-
-int32_t    tpm_mod2_hw_inv_entry(tpm_gmacs_enum_t    gmac_port,
-                                 uint16_t            mod_entry);
-
-int32_t    tpm_mod2_mac_inv (tpm_gmacs_enum_t   gmac_port);
-
-int32_t    tpm_mod2_registers_init (tpm_gmacs_enum_t   gmac_port, uint16_t txp);
-
-int32_t    tpm_mod2_tpid_get(uint32_t tpid,
-                             uint32_t *eth_type_sel);
-
-int32_t    tpm_mod2_print_tmp_pattern (tpm_mod_pattern_data_t *pattern_data);
-
-int32_t    tpm_mod2_print_rule (tpm_gmacs_enum_t   gmac_port,
-                                uint32_t           mod_entry);
-
-int32_t    tpm_mod2_print_jump_all (tpm_gmacs_enum_t   gmac_port);
-
-int32_t    tpm_mod2_print_main_all (tpm_gmacs_enum_t   gmac_port);
-
-int32_t    tpm_mod2_print_config (tpm_gmacs_enum_t   gmac_port);
-
-int32_t    tpm_mod2_init(void);
-int32_t tpm_mod2_split_mod_init(tpm_gmacs_enum_t port);
-int32_t tpm_mod2_split_mod_create_l2_pmts(tpm_gmacs_enum_t port, tpm_pkt_mod_t *mod_data, bool init_flag);
-int32_t tpm_mod2_split_mod_try_pmt_entry_del(tpm_api_sections_t api_section,
-                                  tpm_gmacs_enum_t     gmac_port,
-                                  uint32_t             mod_entry);
-
-int32_t    tpm_mod2_fill_in_pattern   (tpm_gmacs_enum_t     gmac_port,
-                                       tpm_pkt_mod_bm_t        mod_bm,
-                                       tpm_pkt_mod_int_bm_t    int_mod_bm,
-                                       tpm_pkt_mod_t          *mod_data,
-                                       uint32_t               *mod_entry,
-                                       tpm_mod_pattern_data_t *pattern_data,
-                                       tpm_self_check_enable_t is_tpm_check);
-tpm_chain_type_t tpm_mod2_parse_chain_type(tpm_pkt_mod_bm_t mod_bm, tpm_pkt_mod_int_bm_t int_mod_bm);
-
-/*for TPM self check*/
-int32_t tpm_mod2_main_chain_index_get(tpm_gmacs_enum_t gmac_port,
-                                      uint16_t jump_idx,
-                                      uint16_t *main_entry,
-                                      tpm_self_check_enable_t from);
-int32_t tpm_mod2_neta_pmt_get(tpm_gmacs_enum_t gmac_port, int idx, MV_NETA_PMT *pEntry);
-int32_t tpm_mod2_db_jump_pattern_data_get(tpm_gmacs_enum_t gmac_port, uint16_t entry_id, tpm_mod2_entry_t *pattern);
-int32_t tpm_mod2_db_chain_pattern_data_get(tpm_gmacs_enum_t gmac_port, tpm_chain_type_t chain_type,
-					   uint16_t chain_id,
-					   uint16_t pattern_id,
-					   tpm_mod2_entry_t *pattern);
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __TPM_MODZ2_H__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.c
deleted file mode 100644
index 48d4b57..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.c
+++ /dev/null
@@ -1,707 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#define TPM_PNC_ERR_ON_OOR(cond) if (cond){TPM_OS_ERROR(TPM_PNC_HM_MOD, "%s(%d): out of range\n",__FUNCTION__,__LINE__); return TPM_FAIL;}
-#define TPM_PNC_ERR_ON_OOM(cond) if (cond){TPM_OS_ERROR(TPM_PNC_HM_MOD, "%s(%d): out of memory\n",__FUNCTION__,__LINE__);return TPM_FAIL;}
-#define DWORD_LEN       32
-
-
-/* Global  Variables */
-spinlock_t tpmPncLock;
-
-
-
-//static    unsigned long     flags;
-//static    unsigned long     r_jiffies, t_jiffies;
-
-
-/*******************************************************************************
-* tpm_pnc_fill_in_entry()
-*
-* DESCRIPTION:  This function moves HW PnC entry in the internal format
-*
-* INPUTS:
-*           tcam_entry  - HW PnC entry
-*
-* OUTPUTS:
-*           pnc_entry   - PnC entry
-*
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_pnc_print_sw_entry (tpm_pnc_all_t   *pnc_entry)
-{
-    int     i;
-
-    printk("*****************************************************************************************\n");
-    printk("TCAM:  LU  Port Add info    Packet\n");
-    printk("=========================================================================================\n");
-    printk("       %2.2d   %2.2d   %2.2x         ",
-           pnc_entry->tcam_entry.lu_id,
-           pnc_entry->tcam_entry.port_ids,
-           pnc_entry->tcam_entry.add_info_data);
-
-    for (i=0; i < TPM_TCAM_PKT_WIDTH; i++) {
-        printk("%2.2x", pnc_entry->tcam_entry.pkt_data.pkt_byte[i]);
-    }
-    printk("\n                 %2.2x         ", pnc_entry->tcam_entry.add_info_mask);
-    for (i=0; i < TPM_TCAM_PKT_WIDTH; i++) {
-        printk("%2.2x", pnc_entry->tcam_entry.pkt_mask.pkt_byte[i]);
-    }
-
-    printk("\n");
-    printk("================================================================================\n");
-    printk("SRAM:  NLU  Add info  LU Done  NLU idx   Q      Shift(val)   RI         FL      \n");
-    printk("================================================================================\n");
-    printk("       %2.2d      %2.2x        %1.1x        %2.2x     %4.4x    %3.3x(%3.3x)    %2.2x%4.4x     %8.8x\n",
-           pnc_entry->sram_entry.next_lu_id,
-           pnc_entry->sram_entry.add_info_data,
-           pnc_entry->sram_entry.lookup_done,
-           pnc_entry->sram_entry.next_lu_off_reg,
-           pnc_entry->sram_entry.pnc_queue,
-           pnc_entry->sram_entry.shift_updt_reg,
-           pnc_entry->sram_entry.shift_updt_val,
-           pnc_entry->sram_entry.res_info_23_16_data,
-           pnc_entry->sram_entry.res_info_15_0_data,
-           pnc_entry->sram_entry.flowid_val);
-    printk("               %2.2x                                            %2.2x%4.4x     %8.8x\n",
-           pnc_entry->sram_entry.add_info_mask,
-           pnc_entry->sram_entry.res_info_23_16_mask,
-           pnc_entry->sram_entry.res_info_15_0_mask,
-           pnc_entry->sram_entry.flowid_updt_mask);
-    printk("*****************************************************************************************\n");
-}
-
-/*******************************************************************************
-* tpm_pnc_fill_in_entry()
-*
-* DESCRIPTION:  This function moves HW PnC entry in the internal format
-*
-* INPUTS:
-*           tcam_entry  - HW PnC entry
-*
-* OUTPUTS:
-*           pnc_entry   - PnC entry
-*
-* RETURNS:
-*           None
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-void tpm_pnc_fill_in_entry(struct tcam_entry  *tcamEntry, tpm_pnc_all_t *pnc_entry)
-{
-    int         i, word, shift;
-    uint32_t    val, mask;
-
-    /* Fill in TCAM data */
-    pnc_entry->tcam_entry.lu_id         = (tcamEntry->data.u.word[LU_WORD]   >> LU_OFFS) & LU_MASK;
-    pnc_entry->tcam_entry.port_ids      = (tcamEntry->data.u.word[PORT_WORD] >> PORT_OFFS) & PORT_MASK;
-    pnc_entry->tcam_entry.add_info_data = (tcamEntry->data.u.word[AI_WORD]   >> AI_OFFS) & AI_MASK;
-    pnc_entry->tcam_entry.add_info_mask = (tcamEntry->mask.u.word[AI_WORD]   >> AI_OFFS) & AI_MASK;
-
-    for (i = 0; i < TPM_TCAM_PKT_WIDTH; i++)
-    {
-        pnc_entry->tcam_entry.pkt_data.pkt_byte[i] = tcamEntry->data.u.byte[i];
-        pnc_entry->tcam_entry.pkt_mask.pkt_byte[i] = tcamEntry->mask.u.byte[i];
-    }
-
-    /* Fill in SRAM data */
-    word                                   = LU_ID_OFFS / DWORD_LEN;
-    shift                                  = LU_ID_OFFS % DWORD_LEN;
-    pnc_entry->sram_entry.next_lu_id       = (tcamEntry->sram.word[word] >> shift) & LU_MASK;
-
-    word                                   = LU_DONE_OFFS / DWORD_LEN;
-    shift                                  = LU_DONE_OFFS % DWORD_LEN;
-    pnc_entry->sram_entry.lookup_done      = (tcamEntry->sram.word[word] >> shift) & 0x1;
-
-    word                                   = RXQ_QUEUE_OFFS / DWORD_LEN;
-    shift                                  = RXQ_QUEUE_OFFS % DWORD_LEN;
-    pnc_entry->sram_entry.pnc_queue        = (tcamEntry->sram.word[word] >> shift) & RXQ_MASK;
-
-    word                                   = NEXT_LU_SHIFT_OFFS / DWORD_LEN;
-    shift                                  = NEXT_LU_SHIFT_OFFS % DWORD_LEN;
-    pnc_entry->sram_entry.next_lu_off_reg  = (tcamEntry->sram.word[word] >> shift) & SHIFT_IDX_MASK;
-
-    word                                   = SHIFT_IDX_OFFS / DWORD_LEN;
-    shift                                  = SHIFT_IDX_OFFS % DWORD_LEN;
-    pnc_entry->sram_entry.shift_updt_reg   = (tcamEntry->sram.word[word] >> shift) & SHIFT_IDX_MASK;
-
-    word                                   = SHIFT_VAL_OFFS/DWORD_LEN;
-    shift                                  = SHIFT_VAL_OFFS%DWORD_LEN;
-    pnc_entry->sram_entry.shift_updt_val   = (tcamEntry->sram.word[word] >> shift) & SHIFT_VAL_MASK;
-
-    word                                   = AI_VALUE_OFFS/DWORD_LEN;
-    shift                                  = AI_VALUE_OFFS%DWORD_LEN;
-    pnc_entry->sram_entry.add_info_data    = (tcamEntry->sram.word[word] >> shift) & AI_MASK;
-
-    word                                   = AI_MASK_OFFS/DWORD_LEN;
-    shift                                  = AI_MASK_OFFS%DWORD_LEN;
-    pnc_entry->sram_entry.add_info_mask    = (tcamEntry->sram.word[word] >> shift) & AI_MASK;
-
-    pnc_entry->sram_entry.flowid_updt_mask = 0;
-
-    if (tcamEntry->sram.word[1] & FLOW_ID_LSW_MASK)
-        pnc_entry->sram_entry.flowid_updt_mask |= FLOW_ID_LSW_MASK;
-
-    if (tcamEntry->sram.word[1] & FLOW_ID_MSW_MASK)
-        pnc_entry->sram_entry.flowid_updt_mask |= FLOW_ID_MSW_MASK;
-
-    pnc_entry->sram_entry.flowid_val = tcamEntry->sram.word[0];
-
-    word  = RI_VALUE_OFFS/DWORD_LEN;
-    shift = RI_VALUE_OFFS%DWORD_LEN;
-    val   = (tcamEntry->sram.word[word] >> shift) & RI_MASK;
-
-    /* RI mask : word 1 - 6 bits (25 - 31)
-                 word 2 - 18 bits (0 - 17) */
-    word  = RI_MASK_OFFS/DWORD_LEN;
-    shift = RI_MASK_OFFS%DWORD_LEN;
-    mask  = (tcamEntry->sram.word[word] >> shift) & RI_MASK;
-    word++;
-    mask |= (tcamEntry->sram.word[word] & 0x3FFFF) << 6;
-
-    pnc_entry->sram_entry.res_info_15_0_data  =  val  & RES_INFO_BITS_16_MASK;
-    pnc_entry->sram_entry.res_info_15_0_mask  =  mask & RES_INFO_BITS_16_MASK;
-    pnc_entry->sram_entry.res_info_23_16_data = (val  & RES_INFO_BITS_8_MASK) >> MAX_RES_INFO_BITS_16;
-    pnc_entry->sram_entry.res_info_23_16_mask = (mask & RES_INFO_BITS_8_MASK) >> MAX_RES_INFO_BITS_16;
-
-}
-
-
-/*******************************************************************************
-* tpm_pnc_hw_entry_inv()
-*
-* DESCRIPTION: This API invalidates a TCAM entry in a range.
-*              It does not change any other entry in the TCAM.
-*
-* INPUTS:   entry   - entry to be invalidated
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPK_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-static inline void tpm_pnc_hw_entry_inv(uint32_t entry)
-{
-    unsigned long     flags;
-
-    /* Lock the PnC */
-    spin_lock_irqsave(&tpmPncLock, flags);
-
-    /* Invalidate entry */
-    tcam_hw_inv(entry);
-
-    /* Unlock PnC */
-    spin_unlock_irqrestore(&tpmPncLock, flags);
-
-    return;
-}
-
-static inline void tpm_pnc_hw_entry_read(struct tcam_entry *te, uint32_t entry)
-{
-    unsigned long     flags;
-
-    /* Lock the PnC */
-    spin_lock_irqsave(&tpmPncLock, flags);
-
-    /* Read entry */
-    tcam_hw_read(te, entry);
-
-    /* Unlock PnC */
-    spin_unlock_irqrestore(&tpmPncLock, flags);
-
-    return;
-}
-
-
-static inline void tpm_pnc_hw_entry_write(struct tcam_entry *te, uint32_t entry)
-{
-    unsigned long     flags;
-
-    /* Lock the PnC */
-    spin_lock_irqsave(&tpmPncLock, flags);
-
-    /* Write entry */
-    tcam_hw_write(te, entry);
-
-    /* Unlock PnC */
-    spin_unlock_irqrestore(&tpmPncLock, flags);
-
-    return;
-}
-
-/*******************************************************************************
-* tpm_pnc_set()
-*
-* DESCRIPTION:  This API provides a generic interface to set a complete PnC
-*               entry (TCAM + SRAM), or just update the SRAM.
-*               If (TCAM and SRAM) are updated, PnC entry is first invalidated
-*               and only then configured.
-*
-* INPUTS:
-*           entry       - entry to be set/updated
-*           sram_update - 0 - set a complete PnC entry
-*                         1 - just SRAM update
-*           pnc_entry   - pointer to the set/updated PnC entry
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t    tpm_pnc_set  (uint32_t      entry,
-                         uint32_t      sram_update,
-                         tpm_pnc_all_t *pnc_entry)
-{
-    struct tcam_entry tcamEntry;
-    uint32_t          sram_res_info_data = 0;
-    int               indx;
-    uint32_t          cfg_pnc_parse_flag = 0;
-
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_PNC_HM_MOD, " TPM is NOT configuring the PNC - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-    TPM_OS_DEBUG( TPM_PNC_HM_MOD, "entry(%d) sram_update(%d)\n",entry, sram_update);
-    TPM_PNC_ERR_ON_OOR(entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOM(pnc_entry == NULL);
-
-    /* sram_update is equal to 0, therefore the PnC entry is set */
-    if (!sram_update)
-    {
-        /* Update TCAM */
-
-        /* Invalidate PnC entry */
-        tpm_pnc_hw_entry_inv(entry);
-
-        /* Clear SW TCAM entry */
-        tcam_sw_clear(&tcamEntry);
-
-        /* Set lookup */
-        if (pnc_entry->tcam_entry.lu_id != TPM_PNC_ANY_LUID)
-        {
-            tcam_sw_set_lookup(&tcamEntry, pnc_entry->tcam_entry.lu_id);
-        }
-
-        /* Set port */
-        tcam_sw_set_port(&tcamEntry, 0, PORT_MASK &(~(pnc_entry->tcam_entry.port_ids)));
-
-        /* Set TCAM add info */
-        tcam_sw_set_ainfo(&tcamEntry, MASK_AI(pnc_entry->tcam_entry.add_info_data),
-                                      MASK_AI(pnc_entry->tcam_entry.add_info_mask));
-
-        /* Set packet data */
-        for (indx = 0; indx < TPM_TCAM_PKT_WIDTH; indx++)
-        {
-            tcam_sw_set_byte(&tcamEntry, indx, pnc_entry->tcam_entry.pkt_data.pkt_byte[indx]);
-            tcam_sw_set_mask(&tcamEntry, indx, pnc_entry->tcam_entry.pkt_mask.pkt_byte[indx]);
-        }
-    }
-
-    /* sram_update is not equal to 0, therefore SRAM of the PnC entry is updated, read PnC entry */
-    else
-    {
-        /* Clear SW TCAM entry */
-        tcam_sw_clear(&tcamEntry);
-
-        /* Read the entry from HW */
-        tpm_pnc_hw_entry_read(&tcamEntry, entry);
-
-		/* Clear old sram entry */
-		sram_sw_clear(&tcamEntry.sram);
-    }
-
-    /* Update SRAM */
-
-    /* Set next lookup ID */
-    sram_sw_set_next_lookup(&tcamEntry, pnc_entry->sram_entry.next_lu_id);
-
-    /* Set add info update */
-    sram_sw_set_ainfo(&tcamEntry, MASK_AI(pnc_entry->sram_entry.add_info_data), MASK_AI(pnc_entry->sram_entry.add_info_mask));
-
-    /* Set lookup done */
-    sram_sw_set_lookup_done(&tcamEntry, pnc_entry->sram_entry.lookup_done);
-
-    /* Set Next lookup offset index */
-    sram_sw_set_next_lookup_shift(&tcamEntry, pnc_entry->sram_entry.next_lu_off_reg);
-
-    /* Set queue */
-    if (pnc_entry->sram_entry.pnc_queue != 0xFFFF)
-    {
-        sram_sw_set_rxq(&tcamEntry, pnc_entry->sram_entry.pnc_queue, 1);
-    }
-
-    /* Set shift update */
-    sram_sw_set_shift_update(&tcamEntry, pnc_entry->sram_entry.shift_updt_reg,
-                                         pnc_entry->sram_entry.shift_updt_val);
-
-    /* Set results info (RI) */
-    sram_res_info_data = ((pnc_entry->sram_entry.res_info_23_16_data << 16) |
-                           pnc_entry->sram_entry.res_info_15_0_data);
-    sram_sw_set_rinfo(&tcamEntry, sram_res_info_data, sram_res_info_data);
-    /* if need to set marvell header, update them all */
-    if (sram_res_info_data & TPM_MH_RI_BIT14 ||
-        sram_res_info_data & TPM_MH_RI_BIT15 ||
-        sram_res_info_data & TPM_MH_RI_BIT16 ||
-        sram_res_info_data & TPM_MH_RI_BIT17)
-        tcamEntry.sram.word[RI_MASK_OFFS / DWORD_LEN] |= (1 << ((TPM_PNC_RI_MH_BIT_14 + RI_MASK_OFFS) % DWORD_LEN)) |
-                                                         (1 << ((TPM_PNC_RI_MH_BIT_15 + RI_MASK_OFFS) % DWORD_LEN)) |
-                                                         (1 << ((TPM_PNC_RI_MH_BIT_16 + RI_MASK_OFFS) % DWORD_LEN)) |
-                                                         (1 << ((TPM_PNC_RI_MH_BIT_17 + RI_MASK_OFFS) % DWORD_LEN));
-
-    /* Set flow id */
-    sram_sw_set_flowid(&tcamEntry, pnc_entry->sram_entry.flowid_val, pnc_entry->sram_entry.flowid_updt_mask);
-
-    /* Write the current entry to HW */
-    tpm_pnc_hw_entry_write(&tcamEntry, entry);
-
-    return TPM_OK;
-}
-
-
-
-
-/*******************************************************************************
-* tpm_pnc_entry_inv()
-*
-* DESCRIPTION: This API invalidates a TCAM entry in a range.
-*              It does not change any other entry in the TCAM.
-*
-* INPUTS:   entry   - entry to be invalidated
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPK_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pnc_entry_inv(uint32_t entry)
-{
-    uint32_t          cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_PNC_HM_MOD, " TPM is NOT invalidating the PNC - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-
-    TPM_OS_DEBUG( TPM_PNC_HM_MOD, "entry(%d)\n",entry);
-    TPM_PNC_ERR_ON_OOR(entry >= TPM_PNC_SIZE);
-
-    /* Invalidate PnC entry */
-    tpm_pnc_hw_entry_inv(entry);
-
-    return TPM_OK;
-}
-
-
-void tpm_pnc_entry_copy(uint32_t read_entry, uint32_t write_entry)
-{
-    struct tcam_entry tcamEntry;
-    uint32_t pnc_cgrp, lu_mask;
-
-    /* Clear SW TCAM entry */
-    tcam_sw_clear(&tcamEntry);
-
-    /* Read entry from HW */
-    tpm_pnc_hw_entry_read(&tcamEntry, read_entry);
-
-    /* Read PNC counter to get group and LU kask*/
-    pnc_cgrp = tpm_tcam_get_cntr_group(read_entry);
-    lu_mask = tpm_tcam_get_lu_mask(read_entry);
-
-    /* Write entry to HW */
-    tpm_pnc_hw_entry_write(&tcamEntry, write_entry);
-
-    /* Write PNC reg for counter group and LU mask */
-    tpm_tcam_set_lu_mask(write_entry, (int32_t) lu_mask);
-    tpm_tcam_set_cntr_group(write_entry, (int32_t) pnc_cgrp);
-}
-
-
-
-/*******************************************************************************
-* tpm_pnc_entry_insert()
-*
-* DESCRIPTION: This API inserts an invalid empty PnC entry.
-*              It 'pushes down' a block of TCAM entries following the inserted entry.
-*
-* INPUTS:      entry        - entry to be inserted
-*              last_entry   - last entry to be moved
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pnc_entry_insert(uint32_t entry,
-                             uint32_t last_entry)
-{
-    int indx;
-    int iterNum;
-    uint32_t   cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_PNC_HM_MOD, " TPM is NOT configuring the PNC - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-
-    TPM_PNC_ERR_ON_OOR(entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(last_entry+1 >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(entry > last_entry);
-
-    iterNum = last_entry - entry + 1;
-
-    for (indx = 0; indx < iterNum; indx++)
-    {
-        tpm_pnc_entry_copy(last_entry-indx, last_entry-indx+1);
-    }
-
-    /* Invalidate inserted entry */
-    tpm_pnc_entry_inv(entry);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pnc_entry_delete()
-*
-* DESCRIPTION: This API deletes a TCAM entry in a range.
-*              It closes the gap, and pushes up subsequent TCAM entries in the range.
-*
-* INPUTS:      entry        - entry to be deleted
-*              last_entry   - last entry to be moved
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pnc_entry_delete(uint32_t entry,
-                             uint32_t last_entry)
-{
-    int indx;
-    int iterNum;
-    uint32_t  cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_PNC_HM_MOD, " TPM is NOT configuring the PNC - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-    TPM_PNC_ERR_ON_OOR(entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(last_entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(entry > last_entry);
-
-    iterNum = last_entry - entry;
-
-    /* Invalidate deleted entry */
-    tpm_pnc_entry_inv(entry);
-
-    for (indx = 0; indx < iterNum; indx++)
-    {
-        tpm_pnc_entry_copy(entry+indx+1, entry+indx);
-    }
-
-    /* Invalidate last moved entry */
-    tpm_pnc_entry_inv(last_entry);
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pnc_range_inv()
-*
-* DESCRIPTION: This API resets a range
-*
-* INPUTS:      entry        - start entry to be deleted
-*              last_entry   - last entry to be deleted
-*
-* OUTPUTS:
-*           None
-*
-* RETURNS:
-*           TPM_OK or TPM_FAIL
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pnc_range_inv(uint32_t entry,
-                          uint32_t last_entry)
-{
-    int indx;
-    uint32_t          cfg_pnc_parse_flag = 0;
-
-	cfg_pnc_parse_flag = mv_eth_ctrl_pnc_get();
-
-    if (cfg_pnc_parse_flag == 1) {
-        TPM_OS_DEBUG(TPM_PNC_HM_MOD, " TPM is NOT configuring the PNC - MV driver is responsible \n");
-        return (TPM_OK);
-    }
-
-    TPM_OS_DEBUG( TPM_PNC_HM_MOD, "entry(%d) last_entry(%d)\n",entry, last_entry);
-    TPM_PNC_ERR_ON_OOR(entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(last_entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOR(entry > last_entry);
-
-    for (indx = entry; indx <= last_entry; indx++)
-    {
-        /* Invalidate entry */
-        tpm_pnc_entry_inv(indx);
-    }
-
-    return TPM_OK;
-}
-
-/*******************************************************************************
-* tpm_pnc_get_next_valid()
-*
-* DESCRIPTION: The API returns the next valid PnC entry
-*
-* INPUTS:   cur_entry   - start valid entry index
-*
-* OUTPUTS:  next_entry  - next valid entry index
-*           pnc_entry   - next valid entry
-*
-* RETURNS:
-*           TPM_OK, TPM_FAIL or TPM_NOT_FOUND
-*
-* COMMENTS:
-*           None
-*
-*******************************************************************************/
-int32_t tpm_pnc_get_next_valid(uint32_t       cur_entry,
-                               int32_t       *next_entry,
-                               tpm_pnc_all_t *pnc_entry)
-{
-    int               indx;
-    struct tcam_entry tcamEntry;
-    int32_t           rc = TPM_NOT_FOUND;
-
-    TPM_PNC_ERR_ON_OOR(cur_entry >= TPM_PNC_SIZE);
-    TPM_PNC_ERR_ON_OOM(next_entry == NULL);
-    TPM_PNC_ERR_ON_OOM(pnc_entry == NULL);
-
-    *next_entry = -1;
-
-    for (indx = (cur_entry + 1); indx < TPM_PNC_SIZE; indx++)
-    {
-        /* Clear SW TCAM entry */
-        tcam_sw_clear(&tcamEntry);
-
-        /* Read entry from HW */
-        tpm_pnc_hw_entry_read(&tcamEntry, indx);
-
-        if (tcamEntry.ctrl.flags & TCAM_F_INV)
-            continue;
-
-        rc = TPM_OK;
-        *next_entry = indx;
-        tpm_pnc_fill_in_entry(&tcamEntry, pnc_entry);
-        break;
-    }
-
-    return rc;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.h
deleted file mode 100644
index 063592e..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_pnc_mgr.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#ifndef __TPM_PNCM_H__
-#define __TPM_PNCM_H__
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*************************************************************/
-/*               TEMP. DEFINITIONS                           */
-/*************************************************************/
-
-/*************************************************************/
-/*               DEFINITIONS                                 */
-/*************************************************************/
-#define MAX_PORT_NUMBER         0x1F
-#define MAX_ADD_INFO_BITS       7  /* Add info field size = 7 bits */
-
-/* Result info field size = 24 bits */
-#define MAX_RES_INFO_BITS_16    16
-#define MAX_RES_INFO_BITS_8     8
-#define RES_INFO_BITS_16_MASK   0x0000FFFF
-#define RES_INFO_BITS_8_MASK    0x00FF0000
-
-
-/* Flow ID */
-#define FLOW_ID_LSW_MASK        0x00000001
-#define FLOW_ID_MSW_MASK        0x00000002
-#define FLOW_ID_MSW_SHIFT       16
-
-/*************************************************************/
-/*               ENUMERATIONS                                */
-/*************************************************************/
-
-/*************************************************************/
-/*               STRUCTURES                                  */
-/*************************************************************/
-
-/*************************************************************/
-/*               PROTOTYPES for internal using               */
-/*************************************************************/
-void tpm_pnc_fill_in_entry(struct tcam_entry *tcamEntry, tpm_pnc_all_t *pnc_entry);
-void tpm_pnc_print_sw_entry(tpm_pnc_all_t *pnc_entry);
-
-/*************************************************************/
-/*               PROTOTYPES                                  */
-/*************************************************************/
-int32_t tpm_pnc_set            (uint32_t entry, uint32_t sram_update, tpm_pnc_all_t *pnc_entry);
-int32_t tpm_pnc_get_next_valid (uint32_t cur_entry, int32_t *next_entry, tpm_pnc_all_t  *pnc_entry);
-int32_t tpm_pnc_entry_insert   (uint32_t entry, uint32_t last_entry);
-int32_t tpm_pnc_entry_delete   (uint32_t entry, uint32_t last_entry);
-int32_t tpm_pnc_entry_inv      (uint32_t entry);
-int32_t tpm_pnc_range_inv      (uint32_t entry, uint32_t last_entry);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __TPM_PNCM_H__*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_rtos.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_rtos.h
deleted file mode 100644
index 6b72fa6..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_rtos.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : tpm_rtos.h                                                 **
-**                                                                           **
-**  DESCRIPTION : This file contains ONU GPON Linux OS resources             **
-*******************************************************************************
-*                                                                             *
-*  MODIFICATION HISTORY:                                                      *
-*                                                                             *
-*   10Aug10  Oren Ben Hayun   created                                         *
-* =========================================================================== *
-******************************************************************************/
-#ifndef _TPM_RTOS_H_
-#define _TPM_RTOS_H_
-
-/* Include Files
-------------------------------------------------------------------------------*/
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/time.h>
-#include <linux/timer.h>
-#include <linux/slab.h>
-#include <linux/byteorder/generic.h>
-#include <linux/random.h>
-#include <linux/delay.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/platform_device.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <linux/ioctl.h>
-#include <linux/in.h>
-#include <linux/capability.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-
-#include "mvTypes.h"
-#include "mvCommon.h"
-#include "mvOs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-
-/* Definitions
-------------------------------------------------------------------------------*/
-
-/* Enums
-------------------------------------------------------------------------------*/
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Macros
-------------------------------------------------------------------------------*/
-
-#endif /* _TPM_RTOS_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.c
deleted file mode 100644
index bf19e92..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.c
+++ /dev/null
@@ -1,8038 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* mv_tpm_sw_config.c
-*
-*
-*  MODULE : TPM Switch
-*
-*  DESCRIPTION : This file config tpm switch
-*
-*  MODIFICATION HISTORY:
-*           28Apr2010   DimaM  - initial version created.
-*
-* FILE REVISION NUMBER:
-*       $Revision: 1.47 $
-*******************************************************************************/
-
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "../../mv_mac_learn/mv_mac_learn_header.h"
-
-uint32_t trace_sw_dbg_flag = 0;
-
-#define IF_ERROR(ret)\
-    if (ret != TPM_DB_OK) {\
-        printk(KERN_ERR "ERROR: (%s) call not allowed, switch not initialized\n", __FUNCTION__);\
-        return(ret);\
-    }
-
-#define SWITCH_INIT_CHECK()\
-    int32_t ret_init_check;\
-    ret_init_check = tpm_sw_init_check();\
-    IF_ERROR(ret_init_check)
-
-/*******************************************************************************
-* tpm_sw_init_check
-*
-* DESCRIPTION:
-*       This function is to check switch is allowed to init or not
-*
-* INPUTS:
-*       NONE
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_init_check(void)
-{
-    uint32_t switch_init;
-    int32_t ret;
-
-    ret = tpm_db_switch_init_get(&switch_init);
-    IF_ERROR(ret);
-    if (!switch_init)
-        return ERR_SW_NOT_INIT;
-
-    return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_phy_access_check
-*
-* DESCRIPTION:
-*       This function check the PHY access path, direct or through switch.
-*
-* INPUTS:
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       phy_ctrl    - the PHY SMI master indication
-*       phy_direct_addr - PHY address if PHY accessed directly
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_access_check(tpm_src_port_type_t src_port,
-                                      tpm_phy_ctrl_t *phy_access_way,
-                                      uint32_t *phy_direct_addr)
-{
-    tpm_init_gmac_conn_conf_t gmac_conn_info;
-    uint32_t i;
-    tpm_db_chip_conn_t chip_con;
-    tpm_db_int_conn_t int_con;
-    uint32_t switch_port;
-
-    /* Para check*/
-    if ((NULL == phy_access_way) || (NULL == phy_direct_addr)) {
-        printk(KERN_ERR "ERROR: Invalid pointer\n");
-        return ERR_GENERAL;
-    }
-
-    /* Check gmac port connection info */
-    for (i = 0; i < TPM_MAX_NUM_GMACS; i++) {
-        if (TPM_DB_OK != tpm_db_gmac_conn_conf_get(i, &gmac_conn_info)) {
-            printk(KERN_ERR "ERROR: (%s:%d) Gmac port(%d) connection info get failed\n", __FUNCTION__, __LINE__, i);
-            return ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-        if (TPM_TRUE == gmac_conn_info.valid && src_port == gmac_conn_info.port_src) {
-            /* PHY access directly */
-            *phy_access_way = PHY_SMI_MASTER_CPU;
-            /*get PHY addr on GMAC*/
-            *phy_direct_addr = mvBoardPhyAddrGet(i);
-
-            if (trace_sw_dbg_flag)
-                printk(KERN_INFO "Port%d PHY access directly, phyaddr %d\n", src_port, *phy_direct_addr);
-
-            return TPM_RC_OK;
-        }
-    }
-
-    /* Check eth port connection info */
-    if (TPM_DB_OK != tpm_db_eth_port_conf_get(src_port, &chip_con, &int_con, &switch_port)) {
-        printk(KERN_ERR "ERROR: (%s:%d) Eth port(%d) connection info get failed\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_PHY_SRC_PORT_CONN_INVALID;
-    }
-    /* Check QSGMII */
-    if (TPM_CONN_QSGMII == chip_con && TPM_INTCON_SWITCH == int_con) {
-        /* Check MPP register, if value of MPP29 and MPP30 are both 4, then access PHY directly */
-        if ((mvBoardMppGet(3) & DB_88F6535_MPP24_31) == DB_88F6535_MPP24_31) {
-            /* PHY access directly */
-            *phy_access_way = PHY_SMI_MASTER_CPU;
-            /*get PHY addr on GMAC*/
-            *phy_direct_addr = (uint32_t)src_port;
-            if (trace_sw_dbg_flag)
-                printk(KERN_INFO "Port%d QSGMII PHY access directly, phyaddr %d\n", src_port, *phy_direct_addr);
-            return TPM_RC_OK;
-        }
-    }
-
-    *phy_access_way = PHY_SMI_MASTER_SWT;
-    if (trace_sw_dbg_flag)
-        printk(KERN_INFO "Port%d PHY access through switch\n", src_port);
-
-    return TPM_RC_OK;
-}
-
-tpm_error_code_t tpm_src_port_mac_map(tpm_src_port_type_t src_port,
-                                      tpm_gmacs_enum_t *gmac)
-{
-    tpm_init_gmac_conn_conf_t gmac_conn_info;
-    uint32_t i;
-
-    /* Check gmac port connection info */
-    for (i = 0; i < TPM_MAX_NUM_GMACS; i++) {
-        if (TPM_DB_OK != tpm_db_gmac_conn_conf_get(i, &gmac_conn_info)) {
-	    printk(KERN_ERR "ERROR: (%s:%d) Gmac port(%d) connection info get failed\n", __FUNCTION__, __LINE__, i);
-	    return ERR_GENERAL;
-        }
-        if (TPM_TRUE == gmac_conn_info.valid && src_port == gmac_conn_info.port_src) {
-            *gmac = i;
-            return TPM_RC_OK;
-        }
-    }
-    if (i == TPM_MAX_NUM_GMACS) {
-        printk(KERN_ERR "ERROR: (%s:%d) src port(%d) map to MAC failed\n", __FUNCTION__, __LINE__, src_port);
-	return ERR_SRC_PORT_INVALID;
-    }
-
-    return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_sw_set_debug_trace_flag
-*
-* DESCRIPTION:
-*       This function sets TPM trace flag.
-*
-* INPUTS:
-*       enDis    - enable or disable
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_debug_trace_flag
-(
-     uint32_t enDis
-)
-{
-    trace_sw_dbg_flag = enDis;
-    return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_sw_add_static_mac
-*
-* DESCRIPTION:
-*       This function creates a static MAC entry in the MAC address table for a
-*       specific UNI port in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id, should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       static_mac  - 6 byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_add_static_mac
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             static_mac[6]
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_gmacs_enum_t gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r \
-               static_mac[%02x:%02x:%02x:%02x:%02x:%02x]\n\r",
-              __FUNCTION__,owner_id,src_port, static_mac[0],static_mac[1],static_mac[2],static_mac[3],static_mac[4],static_mac[5]);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_static_entry_add(&(static_mac[0]));
-	else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) MAC learn not supported\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_add_static_mac(lPort, &(static_mac[0]));
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_del_static_mac
-*
-* DESCRIPTION:
-*       This function removes an existing static MAC entry from the MAC address
-*       table  in the integrated switch.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       static_mac  - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_del_static_mac
-(
-    uint32_t owner_id,
-    uint8_t  static_mac[6]
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                 "==ENTER==%s: owner_id[%d]\n\r, \
-                 static_mac[%02x:%02x:%02x:%02x:%02x:%02x]\n\r",
-                 __FUNCTION__,owner_id,static_mac[0],static_mac[1],static_mac[2],static_mac[3],static_mac[4],static_mac[5]);
-    }
-
-    if (tpm_sw_init_check()) {
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_static_entry_del(&(static_mac[0]));
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) MAC learn not supported\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        retVal = mv_switch_del_static_mac(&(static_mac[0]));
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_static_mac_w_ports_mask
-*
-* DESCRIPTION:
-*       This function creates or destory a static MAC entry in the MAC address
-*       table for several specific ports in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       ports_mask  - Ports mask.
-*       static_mac  - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_static_mac_w_ports_mask
-(
-    uint32_t owner_id,
-    uint32_t ports_mask,
-    uint8_t  static_mac[6]
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-#ifdef CONFIG_MV_MAC_LEARN
-    static uint32_t mask_check = 1;
-#endif
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],ports_mask[0x%x]\n\r"\
-               "static_mac[%02x:%02x:%02x:%02x:%02x:%02x]\n\r",
-               __FUNCTION__,owner_id,
-               ports_mask,
-               static_mac[0],
-               static_mac[1],
-               static_mac[2],
-               static_mac[3],
-               static_mac[4],
-               static_mac[5]);
-    }
-
-    if (tpm_sw_init_check()) {
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-	if (tpm_db_gmac1_lpbk_en_get()) {
-            if (ports_mask & mask_check)
-                retVal = mv_mac_learn_static_entry_add(&(static_mac[0]));
-        } else {
-            printk(KERN_ERR "ERROR: (%s:%d) MAC learn not supported\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        retVal = mv_switch_mac_addr_set(&(static_mac[0]), 0, ports_mask, 1);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_trunk_ports
-*
-* DESCRIPTION:
-*       This function creates trunk ports and trunk id
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       trunk_id    - valid from 0x0 to 0xf
-*       ports_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_trunk_ports
-(
-    uint32_t owner_id,
-    uint32_t trunk_id,
-    uint32_t ports_mask
-)
-{
-    tpm_error_code_t ret;
-    uint16_t  reg_tmp = 0;
-    uint32_t  switch_port = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d], trunk_id[0x%x], ports_mask[0x%x]\n\r",
-               __FUNCTION__, owner_id, trunk_id, ports_mask);
-    }
-
-    if (trunk_id > SW_TRUNK_ID_MAX)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: trunk_id[0x%x] is bigger than [0x%x]\n\r",
-               __FUNCTION__,trunk_id, SW_TRUNK_ID_MAX);
-    }
-
-    for (switch_port = 0; switch_port <= TPM_SWITCH_NUM_PORTS; switch_port++)
-    {
-        if(0 == (ports_mask & (1 << switch_port)))
-        {
-	    continue;
-        }
-
-	/* get trunk reg from HW */
-	ret = mv_switch_reg_read(switch_port, SW_TRUNK_ID_REG, MV_SWITCH_PORT_ACCESS, &reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get trunk reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-
-	/* set bits 8, 9 to 11, as trunk_id */
-	SW_CLEAR_REG_BIT(reg_tmp, SW_TRUNK_ID_BIT_OFF, SW_TRUNK_ID_BIT_LEN);
-	reg_tmp |= (trunk_id << SW_TRUNK_ID_BIT_OFF);
-	/* set bit 14, as trunk bit */
-	reg_tmp |= (1 << SW_TRUNK_BIT_OFF);
-	ret = mv_switch_reg_write(switch_port, SW_TRUNK_ID_REG, MV_SWITCH_PORT_ACCESS, reg_tmp);
-	if (0 != ret) {
-		TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set trunk reg, ret(%d)\n", ret);
-		return (TPM_FAIL);
-	}
-    }
-
-    /* get trunk mapping reg from HW */
-    ret = mv_switch_reg_read(0, SW_TRUNK_MAPPING_REG, MV_SWITCH_GLOBAL2_ACCESS, &reg_tmp);
-    if (0 != ret) {
-	    TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get trunk mapping reg, ret(%d)\n", ret);
-	    return (TPM_FAIL);
-    }
-
-    /* set bits 11 to 14, as trunk_id */
-    SW_CLEAR_REG_BIT(reg_tmp, SW_TRUNK_MAPPING_ID_BIT_OFF, SW_TRUNK_ID_BIT_LEN);
-    reg_tmp |= (trunk_id << SW_TRUNK_MAPPING_ID_BIT_OFF);
-
-    /* set bits 0 to 6, as trunk map */
-    SW_CLEAR_REG_BIT(reg_tmp, SW_TRUNK_MAPPING_BIT_OFF, SW_TRUNK_MAPPING_BIT_LEN);
-    reg_tmp |= (ports_mask << SW_TRUNK_MAPPING_BIT_OFF);
-
-    /* set bits 15, as udpate bit */
-    reg_tmp |= (1 << SW_REG_UPDATE_BIT_OFF);
-
-    ret = mv_switch_reg_write(0, SW_TRUNK_MAPPING_REG, MV_SWITCH_GLOBAL2_ACCESS, reg_tmp);
-    if (0 != ret) {
-	    TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set trunk mapping reg, ret(%d)\n", ret);
-	    return (TPM_FAIL);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return ret;
-}
-
-
-/*******************************************************************************
-* tpm_sw_set_trunk_mask
-*
-* DESCRIPTION:
-*       This function sets trunk mask
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       mask_num    - trunk mask number, valid from 0 to 7.
-*       trunk_mask  - mask for real switch port, not logical port like TPM_SRC_PORT_UNI_0.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_trunk_mask
-(
-    uint32_t owner_id,
-    uint32_t mask_num,
-    uint32_t trunk_mask
-)
-{
-    tpm_error_code_t ret;
-    uint16_t  reg_tmp = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],mask_num[0x%x],trunk_mask[0x%x]\n\r",
-               __FUNCTION__, owner_id, mask_num, trunk_mask);
-    }
-
-    if (mask_num > SW_TRUNK_MASK_NUM_MAX)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: mask_num[0x%x] is bigger than [0x%x]\n\r",
-               __FUNCTION__,mask_num, SW_TRUNK_MASK_NUM_MAX);
-    }
-
-    if (trunk_mask > SW_TRUNK_MASK_MAX)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: trunk_mask[0x%x] is bigger than [0x%x]\n\r",
-               __FUNCTION__,trunk_mask, SW_TRUNK_MASK_MAX);
-    }
-
-    /* get trunk mask reg from HW */
-    ret = mv_switch_reg_read(0, SW_TRUNK_MASK_REG, MV_SWITCH_GLOBAL2_ACCESS, &reg_tmp);
-    if (0 != ret) {
-	    TPM_OS_ERROR(TPM_INIT_MOD, "Fail to get trunk mask reg, ret(%d)\n", ret);
-	    return (TPM_FAIL);
-    }
-
-    /* set bits 11 to 14, as mask_num */
-    SW_CLEAR_REG_BIT(reg_tmp, SW_TRUNK_MASK_NUM_BIT_OFF, SW_TRUNK_MASK_NUM_BIT_LEN);
-    reg_tmp |= (mask_num << SW_TRUNK_MASK_NUM_BIT_OFF);
-
-    /* set bits 0 to 6, as trunk_mask */
-    SW_CLEAR_REG_BIT(reg_tmp, SW_TRUNK_MASK_BIT_OFF, SW_TRUNK_MASK_BIT_LEN);
-    reg_tmp |= (trunk_mask << SW_TRUNK_MASK_BIT_OFF);
-
-    /* set bits 15, as udpate bit */
-    reg_tmp |= (1 << SW_REG_UPDATE_BIT_OFF);
-
-    ret = mv_switch_reg_write(0, SW_TRUNK_MASK_REG, MV_SWITCH_GLOBAL2_ACCESS, reg_tmp);
-    if (0 != ret) {
-	    TPM_OS_ERROR(TPM_INIT_MOD, "Fail to set trunk mask reg, ret(%d)\n", ret);
-	    return (TPM_FAIL);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return ret;
-}
-
-/*******************************************************************************
-* tpm_sw_clear_dynamic_mac
-*
-* DESCRIPTION:
-*       Clear all dynamic MAC.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_dynamic_mac(    uint32_t owner_id)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d]\n\r", __FUNCTION__, owner_id);
-    }
-
-    retVal = mv_switch_clear_dynamic_mac();
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_mirror
-*
-* DESCRIPTION:
-*       Set port mirror.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       sport      - Source port.
-*       dport      - Destination port.
-*       mode       - mirror mode.
-*       enable     - enable/disable mirror.
-*
-* OUTPUTS:
-*       None
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_mirror
-(
-    uint32_t             owner_id,
-    uint32_t             sport,
-    uint32_t             dport,
-    tpm_sw_mirror_type_t mode,
-    bool                 enable
-)
-{
-    tpm_error_code_t retVal;
-    GT_BOOL  state;
-    uint32_t  sw_sport;
-    uint32_t  sw_dport;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] sport[%d] dport[%d] mode[%d] enable[%d]\n\r",
-               __FUNCTION__, owner_id, tpm_db_eth_port_switch_port_get(sport),
-               tpm_db_eth_port_switch_port_get(dport), mode, enable);
-    }
-
-    if(enable == true)
-        state = GT_TRUE;
-    else
-        state = GT_FALSE;
-
-    sw_sport = tpm_db_eth_port_switch_port_get(sport);
-    sw_dport = tpm_db_eth_port_switch_port_get(dport);
-
-    if (TPM_DB_ERR_PORT_NUM == sw_sport || TPM_DB_ERR_PORT_NUM == sw_dport){
-            TPM_OS_ERROR(TPM_INIT_MOD, "invalid port (sw_sport %d, sw_dport %d)\n", sw_sport, sw_dport);
-	     return GT_FAIL;
-    }
-
-    retVal = mv_switch_set_mirror(sw_sport, sw_dport, (GT_MIRROR_MODE)mode, state);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_mirror
-*
-* DESCRIPTION:
-*       Get port mirror status.
-*
-* INPUTS:
-*       owner_id    - APP owner id , should be used for all API calls.
-*       sport       - Source port.
-*       dport       - Destination port.
-*       mode        - mirror mode.
-*
-* OUTPUTS:
-*       enable      - enable/disable mirror.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_mirror
-(
-    uint32_t             owner_id,
-    uint32_t             sport,
-    uint32_t             dport,
-    tpm_sw_mirror_type_t mode,
-    bool                *enable
-)
-{
-    tpm_error_code_t retVal;
-    GT_BOOL  state;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] sport[%d] dport[%d] mode[%d] \n\r",
-               __FUNCTION__, owner_id, tpm_db_eth_port_switch_port_get(sport),
-               tpm_db_eth_port_switch_port_get(dport), mode);
-    }
-
-    retVal = mv_switch_get_mirror(tpm_db_eth_port_switch_port_get(sport),
-                                  tpm_db_eth_port_switch_port_get(dport),
-                                  (GT_MIRROR_MODE)mode, &state);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if(state == GT_FALSE)
-        *enable = false;
-    else
-        *enable = true;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: enable[%d]\n\r",__FUNCTION__, *enable);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_isolate_eth_port_vector()
-*
-* DESCRIPTION:      Isolate port vector.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       port_vector - port vector.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_isolate_eth_port_vector
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t            port_vector
-)
-{
-#define MEM_PORTS_NR  7
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint32_t memPorts[MEM_PORTS_NR] = {1};
-    uint32_t i = 0;
-    uint8_t  memPortsLen = MEM_PORTS_NR;
-    uint32_t sw_port_num;
-
-    SWITCH_INIT_CHECK();
-
-    memset(memPorts, 1, sizeof(memPorts));
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d] port_vector[%d]\n\r",
-               __FUNCTION__, owner_id, src_port, port_vector);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    /*Init port list*/
-    for(i=0; i<MEM_PORTS_NR; i++)
-    {
-        memPorts[i] = i;
-    }
-
-    for (i=TPM_SRC_PORT_UNI_0; i<TPM_MAX_NUM_UNI_PORTS; i++)
-    {
-        sw_port_num = tpm_db_eth_port_switch_port_get(i);
-
-        if (TPM_DB_ERR_PORT_NUM == sw_port_num)
-            continue;
-
-        if (sw_port_num >= MEM_PORTS_NR) {
-            TPM_OS_ERROR(TPM_INIT_MOD, "sw_port_num too big! (%d >= MEM_PORTS_NR) \n", sw_port_num);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        if(port_vector & (1 << i))
-        {
-            memPorts[sw_port_num] = sw_port_num;
-        }
-        else
-        {
-            memPorts[sw_port_num] = 0x80;
-        }
-    }
-
-    /*set VLAN member*/
-    retVal = mv_switch_set_port_vlan_ports(lPort, memPorts, memPortsLen);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-     if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s \n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_isolate_eth_port_vector()
-*
-* DESCRIPTION:      Isolate port vector.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       port_vector - port vector.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_isolate_eth_port_vector
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *port_vector
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint32_t memPorts[7] = {0x80};
-    uint32_t i = 0;
-    uint8_t  memPortsLen = 7;
-    uint32_t sw_port_num;
-    uint32_t vector = 0;
-
-    SWITCH_INIT_CHECK();
-
-    memset(memPorts, 1, sizeof(memPorts));
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d] \n\r",
-               __FUNCTION__, owner_id, src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    /*get VLAN member*/
-    retVal = mv_switch_get_port_vlan_ports(lPort, memPorts, &memPortsLen);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    for(i=TPM_SRC_PORT_UNI_0; i<TPM_MAX_NUM_ETH_PORTS; i++)
-    {
-        sw_port_num = tpm_db_eth_port_switch_port_get(i);
-	 if (TPM_DB_ERR_PORT_NUM == sw_port_num)
-            continue;
-
-        if(memPorts[sw_port_num] == sw_port_num)
-        {
-            vector |= (1 << (i-1));
-        }
-    }
-
-    *port_vector = vector & 0x0000000F;
-
-     if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: port_vector[%d]\n\r",__FUNCTION__, *port_vector);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_set_mtu_size
-*
-* DESCRIPTION:
-*       Set switch MTU size.
-*
-* INPUTS:
-*       owner_id  - APP owner id , should be used for all API calls.
-*       type      - MRU type:GMAC0, GMAC1, PONMAC, switch
-*       mtu       - MTU size.
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_set_mtu_size
-(
-    uint32_t       owner_id,
-    tpm_mru_type_t type,
-    uint32_t       mtu
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    uint32_t switch_init = 0;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],type[%d],mtu[%d]\r\n",
-               __FUNCTION__, owner_id, type, mtu);
-
-    }
-
-    switch(type)
-    {
-        case TPM_NETA_MTU_GMAC0:
-              /*GMAC0 port number: 0*/
-            retVal = mv_eth_set_mtu(0, mtu);
-            break;
-        case TPM_NETA_MTU_GMAC1:
-            /*GMAC1 port number: 1*/
-            retVal = mv_eth_set_mtu(1, mtu);
-            break;
-        case TPM_NETA_MTU_PONMAC:
-            /*PON GMAC port number: 2*/
-            retVal = mv_eth_set_mtu(2, mtu);
-            break;
-        case TPM_NETA_MTU_SWITCH:
-            /*Set switch MTU if exist*/
-            tpm_db_switch_init_get(&switch_init);
-	    if (switch_init)
-                retVal = mv_switch_set_mtu(mtu);
-            break;
-        default:
-            break;
-    }
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_get_mtu_size
-*
-* DESCRIPTION:
-*       Get switch MTU size.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*       type       - MRU type:GMAC0, GMAC1, PONMAC, switch
-*
-* OUTPUTS:
-*       mtu        - MTU size.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-tpm_error_code_t tpm_get_mtu_size
-(
-    uint32_t        owner_id,
-    tpm_mru_type_t  type,
-    uint32_t       *mtu
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-              "==ENTER==%s: owner_id[%d],type[%d],",
-              __FUNCTION__,owner_id, type);
-
-    }
-
-    switch(type)
-    {
-        case TPM_NETA_MTU_GMAC0:
-              /*GMAC0 port number: 0*/
-            retVal = mv_eth_get_mtu(0, mtu);
-            break;
-        case TPM_NETA_MTU_GMAC1:
-            /*GMAC1 port number: 1*/
-            retVal = mv_eth_get_mtu(1, mtu);
-            break;
-        case TPM_NETA_MTU_PONMAC:
-            /*PON GMAC port number: 2*/
-            retVal = mv_eth_get_mtu(2, mtu);
-            break;
-        case TPM_NETA_MTU_SWITCH:
-            /*Get switch MTU if exist*/
-            if (!tpm_sw_init_check())
-                retVal = mv_switch_get_mtu(mtu);
-            else
-                retVal = ERR_GENERAL;
-            break;
-        default:
-            break;
-    }
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:mtu[%d]\n\r",__FUNCTION__, *mtu);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_max_macs
-*
-* DESCRIPTION:
-*       This function limits the number of MAC addresses per src_port.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mac_per_port - maximum number of MAC addresses per port (1-255).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       The following care is needed when enabling this feature:
-*            1) disable learning on the ports
-*            2) flush all non-static addresses in the ATU
-*            3) define the desired limit for the ports
-*            4) re-enable learing on the ports
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_max_macs
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             mac_per_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_gmacs_enum_t gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],mac_per_port[%d]\r\n",
-                __FUNCTION__, owner_id, src_port, mac_per_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-#ifdef CONFIG_MV_MAC_LEARN
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_max_count_set(mac_per_port);
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) MAC learn not supported\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_port_max_macs(lPort, mac_per_port);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_max_macs
-*
-* DESCRIPTION:
-*        Port's auto learning limit. When the limit is non-zero value, the number
-*        of MAC addresses that can be learned on this UNI port are limited to the value
-*        specified in this API. When the learn limit has been reached any frame
-*        that ingresses this UNI port with a source MAC address not already in the
-*        address database that is associated with this UNI port will be discarded.
-*        Normal auto-learning will resume on the UNI port as soon as the number of
-*        active unicast MAC addresses associated to this UNI port is less than the
-*        learn limit.
-*        CPU directed ATU Load, Purge, or Move will not have any effect on the
-*        learn limit.
-*        This feature is disabled when the limit is zero.
-*        The following care is needed when enabling this feature:
-*            1) dsable learning on the ports
-*            2) flush all non-static addresses in the ATU
-*            3) define the desired limit for the ports
-*            4) re-enable learing on the ports
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       limit      - maximum number of MAC addresses per UNI port (1-255).
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_max_macs
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *limit
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_gmacs_enum_t gmac_i;
-    tpm_db_pnc_range_conf_t range_conf;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Check GMAC1 lpk status */
-        if (tpm_db_gmac1_lpbk_en_get()) {
-            if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)) {
-                printk(KERN_ERR "ERROR: (%s:%d) tpm_db_pnc_rng_conf_get failed\n", __FUNCTION__, __LINE__);
-                return ERR_GENERAL;
-            }
-            *limit = range_conf.api_end - range_conf.api_start + 1;
-            if (*limit > MAC_LEARN_FDB_MAX_COUNT)
-                *limit = MAC_LEARN_FDB_MAX_COUNT;
-        } else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) MAC learn not supported\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_max_macs(lPort, limit);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: limit[%d]\n\r",
-                __FUNCTION__,*limit);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_tagged
-*
-* DESCRIPTION:
-*       The API allows or drops tagged packets on a per UNI port basis.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       drop_tagged - set to 1 = drop tagged packets per UNI port
-*                      set to 0 = allow tagged packets per UNI port.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success   - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_tagged
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             drop_tagged
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          mode;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-              "==ENTER==%s: owner_id[%d],src_port[%d],drop_tagged[%d]\r\n",
-              __FUNCTION__,owner_id,src_port,drop_tagged);
-
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    if (drop_tagged == 1)
-    {
-        mode = 1/*GT_TRUE*/;
-    }
-    else
-    {
-        mode = MV_FALSE;
-    }
-
-    retVal = mv_switch_set_port_tagged(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_tagged
-*
-* DESCRIPTION:
-*       This routine gets DiscardTagged bit for the given UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode       - MV_TRUE if DiscardTagged bit is set, MV_FALSE otherwise
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_tagged
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_port_tagged(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:mode[%d]\n\r",__FUNCTION__,*mode);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_untagged
-*
-* DESCRIPTION:
-*       The API allows or drops untagged packets on a per UNI port basis.
-*
-* INPUTS:
-*       owner_id       - APP owner id - should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       drop_untagged - set to 1 = drop untagged packets per UNI port
-*                        set to 0 = alow untagged packets per UNI port.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success     - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_untagged
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             drop_untagged
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          mode;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],drop_untagged[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,drop_untagged);
-    }
-
-    if (drop_untagged == 1)
-    {
-        mode = 1/*GT_TRUE*/;
-    }
-    else
-    {
-        mode = MV_FALSE;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_port_untagged(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_untagged
-*
-* DESCRIPTION:
-*       This routine gets DiscardUntagged bit for the given UNI port.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode        - MV_TRUE if DiscardUntagged bit is set, MV_FALSE otherwise
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_untagged
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_port_untagged(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:mode[%d]\n\r",
-                __FUNCTION__,*mode);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_def_vlan
-*
-* DESCRIPTION:
-*       The API sets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - the port vlan id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_def_vlan
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],vid[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,vid);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    if (vid > 4095)
-    {
-        printk(KERN_ERR
-            "%s:illegal VID[%d]\r\n", __FUNCTION__, vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    retVal = mv_switch_set_port_def_vlan(lPort, vid);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_def_vlan
-*
-* DESCRIPTION:
-*       The API gets port default vlan id.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       vid        - the port vlan id
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_def_vlan
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint16_t            *vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_port_def_vlan(lPort, vid);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:vid[%d]\n\r",
-                __FUNCTION__,*vid);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_def_pri
-*
-* DESCRIPTION:
-*       The API sets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       pri        - the port priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_def_pri
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             pri
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],pri[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,pri);
-    }
-
-    if (pri>7)
-    {
-        printk(KERN_ERR
-           "%s:illegal pri[%d]\r\n", __FUNCTION__, pri);
-        return ERR_GENERAL;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_port_def_pri(lPort, pri);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_def_pri
-*
-* DESCRIPTION:
-*       The API gets port default priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       pri        - the port priority.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_def_pri
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t            *pri
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_port_def_pri(lPort, pri);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:pri[%d]\n\r",
-                __FUNCTION__,*pri);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_add_vid
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of the allowed VIDs per UNI port.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid      - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       see the example sample802_1qSetup().
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],vid[%d]\n",
-                __FUNCTION__,owner_id,src_port,vid);
-    }
-
-    if (vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid VID[%d]\r\n", __FUNCTION__,__LINE__,vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_port_add_vid(lPort, vid, TPM_GMAC0_AMBER_PORT_NUM);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_clear_vid_per_port
-*
-* DESCRIPTION:
-*       The API delete all VID from the list of VIDs allowed per UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_vid_per_port
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint16_t         vid;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    for(vid=1; vid < TPM_MAX_VID-1; vid++)
-    {
-        retVal = mv_switch_del_vid_per_port(lPort, vid);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_add_all_vid_per_port
-*
-* DESCRIPTION:
-*       The API adds all allowed VIDs from 1 to 4095 per UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_add_all_vid_per_port
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint16_t         vid;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    for(vid=1; vid < TPM_MAX_VID-1; vid++)
-    {
-        retVal = mv_switch_port_add_vid(lPort, vid, TPM_GMAC0_AMBER_PORT_NUM);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_del_vid
-*
-* DESCRIPTION:
-*       The API delete and existing VID from the list of VIDs allowed per UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - VLAN id.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_del_vid
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],vid[%d]\r\n",
-                __FUNCTION__, owner_id, src_port, vid);
-    }
-
-    if (vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid VID[%d]\r\n", __FUNCTION__,__LINE__,vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_del_vid_per_port(lPort, vid);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_vid_egress_mode
-*
-* DESCRIPTION:
-*       The API sets the egress mode for a member port of a vlan.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - vlan id
-*       eMode      - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_vid_egress_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid,
-    uint8_t             eMode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],vid[%d],eMode[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,vid,eMode);
-    }
-
-    if (vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid VID[%d]\r\n", __FUNCTION__,__LINE__,vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_port_vid_egress_mode(lPort, vid, eMode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_get_vid
-*
-* DESCRIPTION:
-*       The API return VID to the list of the allowed VIDs per UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       vid        -  searching VID.
-*
-* OUTPUTS:
-*       found      - MV_TRUE, if the appropriate entry exists.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_get_vid
-(
-    uint32_t  owner_id,
-    uint32_t  vid,
-    uint32_t *found
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],vid[%d]\r\n",
-                __FUNCTION__,owner_id,vid);
-    }
-
-    if (vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid VID[%d]\r\n", __FUNCTION__,__LINE__,vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    retVal = mv_switch_port_print_vid(vid, found);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: found[%d]\n\r",__FUNCTION__,*found);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_add_vid_group()
-*
-* DESCRIPTION:      Add a group of VID to the list of the allowed VIDs per port,
-*                    and set the egress mode correspondingly.
-*
-* INPUTS:
-*       owner_id - APP owner id  should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode     - VLAN egress mode.
-*       min_vid  - min VLAN ID.
-*       max_vid  - max VLAN ID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid_group
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             mode,
-    uint16_t            min_vid,
-    uint16_t            max_vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    uint16_t         vid;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d], src_port[%d], mode[%d], min_vid[%d] max_vid[%d]\r\n",
-                __FUNCTION__,owner_id, src_port, mode, min_vid, max_vid);
-    }
-
-    /*check VID*/
-    if (max_vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid max_vid[%d]\r\n", __FUNCTION__,__LINE__,max_vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    if(min_vid > max_vid)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR==  param error: min_vid[%d] > max_vid[%d] \r\n", __FUNCTION__,__LINE__, min_vid, max_vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    for(vid=min_vid; vid<=max_vid; vid++)
-    {
-        /*set the VID*/
-        retVal = tpm_sw_port_add_vid(owner_id, src_port, vid);
-        if(retVal !=TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-            break;
-        }
-
-        /*set VLAN egress mode*/
-        retVal = tpm_sw_set_port_vid_egress_mode(owner_id, src_port, vid, mode);
-        if(retVal !=TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-            break;
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_del_vid_group()
-*
-* DESCRIPTION:      Delete a group of VID to the list of the allowed VIDs per port,
-*                    and set the egress mode correspondingly.
-*
-* INPUTS:
-*       owner_id - APP owner id  should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       min_vid  - min VLAN ID.
-*       max_vid  - max VLAN ID.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_del_vid_group
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            min_vid,
-    uint16_t            max_vid
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    uint16_t         vid;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d], src_port[%d], min_vid[%d] max_vid[%d]\r\n",
-                __FUNCTION__,owner_id, src_port, min_vid, max_vid);
-    }
-
-    /*check VID*/
-    if (max_vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid max_vid[%d]\r\n", __FUNCTION__,__LINE__,max_vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    if(min_vid > max_vid)
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR==  param error: min_vid[%d] > max_vid[%d] \r\n", __FUNCTION__,__LINE__, min_vid, max_vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    for(vid=min_vid; vid<=max_vid; vid++)
-    {
-        /*Delete the VID*/
-        retVal = tpm_sw_port_del_vid(owner_id, src_port, vid);
-        if(retVal !=TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-            break;
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_prv_set_secure_mode
-*
-* DESCRIPTION:
-*       Change a port mode in the SW data base and remove it from all VLANs
-*
-* INPUTS:
-*       owner_id   -  APP owner id - should be used for all API calls.
-*       port       -  secure port number
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_prv_set_secure_mode
-(
-    uint32_t owner_id,
-    uint32_t port
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    retVal = mv_switch_prv_set_secure_mode(port);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_prv_set_fallback_mode
-*
-* DESCRIPTION:
-*       Change a port mode in the SW data base and add it to all VLANs
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       port       - secure port number
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_prv_set_fallback_mode
-(
-    uint32_t owner_id,
-    uint32_t port
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    retVal = mv_switch_prv_set_fallback_mode(port);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_set_vid_filter
-*
-* DESCRIPTION:
-*       The API sets the filtering mode of a certain UNI port.
-*       If the UNI port is in filtering mode, only the VIDs added by the
-*       tpm_sw_port_add_vid API will be allowed to ingress and egress the UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid_filter - set to 1 - means the UNI port will DROP all packets which are NOT in
-*                    the allowed VID list (built using API tpm_sw_port_add_vid).
-*                    set to 0 - means that the list of VIDs allowed
-*                    per UNI port has no significance (the list is not deleted).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_set_vid_filter
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             vid_filter
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                 "==ENTER==%s: owner_id[%d],src_port[%d],vid_filter[%d]\r\n",
-                 __FUNCTION__,owner_id,src_port, vid_filter);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_vid_filter_per_port(lPort, vid_filter);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_vid_filter_per_port
-*
-* DESCRIPTION:
-*        This routine gets protected mode of a UNI port port.
-*        When this mode is set to GT_TRUE, frames are allowed to egress UNI port
-*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*        by the UNI port's VLANTable if 802.1Q is enabled on the UNI port. Both must
-*        allow the frame to Egress.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*         mode - GT_TRUE: header mode enabled
-*                   GT_FALSE otherwise
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_vid_filter_per_port
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint8_t          vid_filter;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                 "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                 __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_vid_filter_per_port(lPort, &vid_filter);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    *mode = (uint32_t)vid_filter;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: mode[%d] \n\r",__FUNCTION__, *mode);
-    }
-
-    return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_sched()
-*
-* DESCRIPTION:      Configures the scheduling mode per Ethernet port.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       sched_mode  - scheduler mode per port
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*DDD
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_sched
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_sw_sched_type_t sched_mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    uint32_t         mode;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],sched_mode[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,sched_mode);
-    }
-
-    switch(sched_mode)
-    {
-        case  TPM_PP_SCHED_STRICT:
-            mode = PORT_SCHED_MODE_SPRI;
-            break;
-
-        case TPM_PP_SCHED_WRR:
-            mode = PORT_SCHED_MODE_WRRB;
-            break;
-
-       default:
-            printk(KERN_INFO "==Error== %s: sched_mode[1 or 2]\n\r",__FUNCTION__);
-            return ERR_GENERAL;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_port_sched_mode(lPort, mode);
-    if (retVal != GT_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_q_weight
-*
-* DESCRIPTION:
-*       The API configures the weight of a queues for all
-*       Ethernet UNI ports in the integrated switch.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       weight   - weight value per queue (1-8).queue (value 1-3).
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.  DDD
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_q_weight
-(
-    uint32_t owner_id,
-    uint8_t  queue_id,
-    uint8_t  weight
-)
-{
-    tpm_error_code_t retVal = GT_OK;
-    tpm_gmacs_enum_t gmac_i;
-    tpm_db_gmac_func_t gmac_func;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],queue_id[%d] weight[%d]\n\r",
-                __FUNCTION__,owner_id,queue_id,weight);
-    }
-
-    if (tpm_sw_init_check()) {
-        for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-            tpm_db_gmac_func_get(gmac_i, &gmac_func);
-            if (TPM_GMAC_FUNC_LAN_UNI == gmac_func ||
-                TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI == gmac_func)
-                retVal |= mvNetaTxqWrrPrioSet(gmac_i, 0, queue_id, weight);
-        }
-    } else {
-        if ((queue_id == 0) ||
-            (queue_id > SW_QOS_NUM_OF_QUEUES))
-        {
-            printk(KERN_INFO
-                   "%s:%d:==ERROR== invalid queue[%d]\r\n", __FUNCTION__,__LINE__,queue_id);
-            return ERR_SW_TM_QUEUE_INVALID;
-        }
-
-        retVal = mv_switch_set_uni_q_weight(queue_id, weight);
-    }
-    if (retVal != GT_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures an ingress policing function for an Ethernet UNI port.
-*
-* INPUTS:
-*       owner_id   - APP owner id, should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       count_mode - count mode:
-*                               TPM_SW_LIMIT_FRAME
-*                               TPM_SW_LIMIT_LAYER1
-*                               TPM_SW_LIMIT_LAYER2
-*                               TPM_SW_LIMIT_LAYER3
-*       cir        - comited info rate.
-*       cbs        - Committed Burst Size limit (expected to be 2kBytes)
-*       ebs        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_ingr_police_rate
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_limit_mode_t    count_mode,
-    uint32_t            cir,
-    uint32_t            cbs,
-    uint32_t            ebs
-)
-{
-    tpm_error_code_t    retVal = TPM_RC_OK;
-    int32_t             lPort  = 0;
-    GT_PIRL2_COUNT_MODE mode;
-    tpm_gmacs_enum_t    gmac_i;
-    tpm_db_gmac_lpk_uni_ingr_rate_limit_t rate_limit;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],count_mode[%d], cir[%d], cbs[%d], ebs[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,count_mode, cir, cbs,ebs);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Check GMAC1 lpk status, if no lpk, no ingress rate for ingress */
-        if (tpm_db_gmac1_lpbk_en_get()) {
-            retVal = tpm_tm_set_gmac0_ingr_rate_lim(owner_id, cir, cbs);
-            if (retVal == TPM_RC_OK) {
-                rate_limit.count_mode = count_mode;
-                rate_limit.cir = cir;
-                rate_limit.cbs = cbs;
-                rate_limit.ebs = ebs;
-                retVal = tpm_db_gmac_lpk_uni_ingr_rate_limit_set(src_port, rate_limit);
-            }
-        } else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) ingr rate limit not support\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-    } else {
-
-        mode = (GT_PIRL2_COUNT_MODE)count_mode;
-
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_uni_ingr_police_rate(lPort, (GT_PIRL2_COUNT_MODE)mode, cir, cbs, ebs);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s \n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_uni_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API gets an ingress policing function for an Ethernet UNI port.
-*
-* INPUTS:
-*       owner_id - APP owner id, should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       count_mode - count mode:
-*                               TPM_SW_LIMIT_FRAME
-*                               TPM_SW_LIMIT_LAYER1
-*                               TPM_SW_LIMIT_LAYER2
-*                               TPM_SW_LIMIT_LAYER3
-*       cir       - comited info rate.
-*       cbs       - Committed Burst Size limit (expected to be 2kBytes)
-*       ebs       - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_ingr_police_rate
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    tpm_limit_mode_t    *count_mode,
-    uint32_t            *cir,
-    uint32_t            *cbs,
-    uint32_t            *ebs
-)
-{
-    tpm_error_code_t    retVal = TPM_RC_OK;
-    int32_t             lPort  = 0;
-    GT_PIRL2_COUNT_MODE mode;
-    tpm_gmacs_enum_t    gmac_i;
-    tpm_db_gmac_lpk_uni_ingr_rate_limit_t rate_limit;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Check GMAC1 lpk status, if no lpk, no ingress rate for ingress */
-        if (tpm_db_gmac1_lpbk_en_get()) {
-            retVal = tpm_db_gmac_lpk_uni_ingr_rate_limit_get(src_port, &rate_limit);
-            if (retVal == TPM_RC_OK) {
-                mode = (GT_PIRL2_COUNT_MODE)rate_limit.count_mode;
-                *cir = rate_limit.cir;
-                *cbs = rate_limit.cbs;
-                *ebs = rate_limit.ebs;
-            }
-        } else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) ingr rate limit not support\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_uni_ingr_police_rate(lPort, &mode, cir, cbs, ebs);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    *count_mode = (tpm_limit_mode_t)mode;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:,count_mode[%d], cir[%d], cbs[%d], ebs[%d]\n\r",
-                __FUNCTION__, *count_mode, *cir, *cbs, *ebs);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_tc_ingr_police_rate
-*
-* DESCRIPTION:
-*       The API Configures a policer function for a traffic class for an Ethernet UNI port.
-*       There are 4 globally defined traffic classes in the integrated switch.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       tc       - traffic class ( a combination of p-bits and DSCP values).
-*       cir      - comited info rate.
-*       cbs      - comited burst rate.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_tc_ingr_police_rate
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t             tc,
-    uint32_t             cir,
-    uint32_t             cbs
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],tc[%d],cir[%d],cbs[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,tc, cir, cbs);
-    }
-
-    if ((tc == 0) || (tc > SW_QOS_NUM_OF_QUEUES))
-    {
-        printk(KERN_INFO
-               "%s:%d:==ERROR== invalid tc[%d]\r\n", __FUNCTION__,__LINE__,tc);
-        return ERR_SW_TM_QUEUE_INVALID;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_uni_tc_ingr_police_rate(lPort, tc, cir, cbs);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_uni_tc_ingr_police_rate
-*
-* DESCRIPTION:
-*       This routine gets the UNI port's ingress data limit for priority 0 or 1 or 2 or 3 frames.
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       src_port - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*
-*       tc       - traffic class ( a combination of p-bits and DSCP values).
-*       cir      - comited info rate.
-*       cbs      - comited burst rate
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_tc_ingr_police_rate
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *tc,
-    uint32_t            *cir,
-    uint32_t            *cbs
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_uni_tc_ingr_police_rate(lPort, tc, cir, cbs);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:tc[0x%x] cir[%d]\n\r",
-               __FUNCTION__,*tc,*cir);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API Configures the egress frame rate limit of an Ethernet UNI port
-* INPUTS:
-*       owner_id             - APP owner id - should be used for all API calls.
-*       src_port             - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode                 - frame/rate limit mode
-*       frame_rate_limit_val - egress rate limit value.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       GT_ERATE_TYPE used kbRate - frame rate valid values are:
-*                                    7600,..., 9600,
-*                                    10000, 20000, 30000, 40000, ..., 100000,
-*                                    110000, 120000, 130000, ..., 1000000.
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_uni_egr_rate_limit
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    tpm_limit_mode_t     mode,
-    uint32_t             frame_rate_limit_val
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_gmacs_enum_t gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d],mode[%d],frame_rate_limit_val[%d]\r\n",
-                __FUNCTION__,owner_id,src_port,mode,frame_rate_limit_val);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Set tx port rate limit on gmac_i */
-        retVal = tpm_tm_set_tx_port_rate_lim(owner_id, gmac_i, frame_rate_limit_val, 0);
-        if (retVal == TPM_RC_OK) {
-            retVal = tpm_db_gmac_uni_egr_rate_limit_set(src_port, frame_rate_limit_val);
-        }
-    } else {
-
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_uni_egr_rate_limit(lPort, (GT_PIRL_ELIMIT_MODE)mode, frame_rate_limit_val);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API return the egress frame rate limit of an Ethernet UNI port
-* INPUTS:
-*       owner_id        - APP owner id - should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode            - frame/rate limit mode
-*       rate_limit_val  - egress rate limit value..
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       GT_ERATE_TYPE used kbRate - frame rate valid values are:
-*                                    7600,..., 9600,
-*                                    10000, 20000, 30000, 40000, ..., 100000,
-*                                    110000, 120000, 130000, ..., 1000000.
-
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_egr_rate_limit
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    tpm_limit_mode_t    *mode,
-    uint32_t            *frame_rate_limit_val
-)
-{
-    tpm_error_code_t    retVal = TPM_RC_OK;
-    int32_t             lPort  = 0;
-    GT_PIRL_ELIMIT_MODE limit_mode;
-    tpm_gmacs_enum_t    gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d],src_port[%d]\r\n",
-                __FUNCTION__,owner_id,src_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Set tx port rate limit on gmac_i */
-        retVal = tpm_db_gmac_uni_egr_rate_limit_get(src_port, frame_rate_limit_val);
-        limit_mode = GT_PIRL_ELIMIT_FRAME;
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_uni_egr_rate_limit(lPort, &limit_mode, frame_rate_limit_val);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-    *mode = (tpm_limit_mode_t)limit_mode;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: mode[%d], frame_rate_limit_val[%d]\n\r",
-                __FUNCTION__, *mode, *frame_rate_limit_val);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_atu_size
-*
-* DESCRIPTION:
-*       This function Sets the Mac address table size.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       size        - Table size
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        The device GT_88E6351 have fixed ATU size 8192.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_atu_size
-(
-    uint32_t owner_id,
-    uint32_t size
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    uint32_t         atu_size;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],size[%d]\n\r",
-               __FUNCTION__,owner_id,size);
-    }
-
-    switch(size)
-    {
-        case 0: atu_size = 0; /*ATU_SIZE_256*/  break;
-        case 1: atu_size = 1; /*ATU_SIZE_512*/  break;
-        case 2: atu_size = 2; /*ATU_SIZE_1024*/ break;
-        case 3: atu_size = 3; /*ATU_SIZE_2048*/ break;
-        case 4: atu_size = 4; /*ATU_SIZE_4096*/ break;
-        case 5:
-            printk(KERN_INFO "8192 entries not supported by driver\n");break;
-
-        default:
-            printk(KERN_INFO "==Error== %s: size[0-4]\n\r",__FUNCTION__);
-            return ERR_GENERAL;
-    }
-
-    /* The driver support only 8192 entry as constant value */
-    printk(" The device GT_88E6351 have fixed ATU size 8192\r\n");
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_mac_age_time
-*
-* DESCRIPTION:
-*       This function Sets the Mac address table size.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       time_out   - Aging Time value
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_mac_age_time
-(
-    uint32_t owner_id,
-    uint32_t time_out
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],time_out[%d]\n\r",
-               __FUNCTION__,owner_id,time_out);
-    }
-
-    if (tpm_sw_init_check()) {
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_expire_time_set(time_out);
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) MAC learn not supported\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        retVal = mv_switch_set_age_time(time_out);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_mac_age_time
-*
-* DESCRIPTION:
-*       This function Sets the Mac address table size.
-*
-* INPUTS:
-*       owner_id   - APP owner id , should be used for all API calls.
-*
-* OUTPUTS:
-*       time_out   - time out value.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_mac_age_time
-(
-     uint32_t  owner_id,
-     uint32_t *time_out
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d]\n\r",
-               __FUNCTION__,owner_id);
-    }
-
-    if (tpm_sw_init_check()) {
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_expire_time_get(time_out);
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) MAC learn not supported\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        retVal = mv_switch_get_age_time(time_out);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:,time_out[%d]\n\r",__FUNCTION__,*time_out);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-*  tpm_sw_set_mac_learn
-*
-* DESCRIPTION:
-*       Enable/disable automatic learning of new source MAC addresses on port
-*       ingress.
-*
-* INPUTS:
-*       owner_id  - APP owner id , should be used for all API calls.
-*       src_port  - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       enable    - GT_TRUE for enable  or GT_FALSE otherwise
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-*
-* GalTis:
-*
-*******************************************************************************/
-tpm_error_code_t  tpm_sw_set_mac_learn
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool                enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_gmacs_enum_t gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d], src_port[%d] enable[%d]\n\r",
-               __FUNCTION__,owner_id, src_port, enable);
-    }
-
-    if(enable == true)
-        state = GT_TRUE;
-    else
-        state = GT_FALSE;
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-#ifdef CONFIG_MV_MAC_LEARN
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_enable_set(state);
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) MAC learn not supported\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_mac_learn(lPort, state);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-*  tpm_sw_get_mac_learn
-*
-* DESCRIPTION:
-*       Enable/disable automatic learning of new source MAC addresses on port
-*       ingress.
-*
-* INPUTS:
-*       owner_id  - APP owner id , should be used for all API calls.
-*       src_port  - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       enable    - GT_TRUE for enable  or GT_FALSE otherwise
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-*
-* GalTis:
-*
-*******************************************************************************/
-tpm_error_code_t  tpm_sw_get_mac_learn
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    bool               *enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_gmacs_enum_t gmac_i;
-    bool             mac_learn_enable = false;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d], src_port[%d] \n\r",
-               __FUNCTION__,owner_id, src_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            retVal = mv_mac_learn_enable_get(&mac_learn_enable);
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) src port(%d) MAC learn not supported\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_GENERAL;
-        }
-        if(mac_learn_enable)
-            state = GT_TRUE;
-        else
-            state = GT_FALSE;
-#endif
-    } else {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_mac_learn(lPort, &state);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if(state == GT_TRUE)
-        *enable = true;
-    else
-        *enable = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:enable[%d]\n\r",__FUNCTION__, *enable);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_vlan_ports
-*
-* DESCRIPTION:
-*       This routine sets the port VLAN group port membership list.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       memPorts    - array of logical ports in the same vlan.
-*       memPortsLen - number of members in memPorts array
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_vlan_ports
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t            memPorts[],
-    uint8_t             memPortsLen
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d] memPorts[%02d %02d %02d %02d %02d %02d] \
-               memPortsLen[%d]\n\r",
-               __FUNCTION__,
-              owner_id,
-              src_port,
-              memPorts[0],
-              memPorts[1],
-              memPorts[2],
-              memPorts[3],
-              memPorts[4],
-              memPorts[5],
-              memPortsLen);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_port_vlan_ports(lPort, memPorts, memPortsLen);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_vlan_ports
-*
-* DESCRIPTION:
-*       This routine gets the port VLAN group port membership list.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       memPorts    - array of logical ports in the same vlan.
-*       memPortsLen - number of members in memPorts array
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_vlan_ports
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t             memPorts[],
-    uint8_t             *memPortsLen
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_port_vlan_ports(lPort, memPorts, memPortsLen);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT==%s: memPorts[%02d %02d %02d %02d %02d %02d] memPortsLen[%d]\n\r",
-               __FUNCTION__,
-               memPorts[0],
-               memPorts[1],
-               memPorts[2],
-               memPorts[3],
-               memPorts[4],
-               memPorts[5],
-               *memPortsLen);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_ingress_limit_mode
-*
-* DESCRIPTION:
-*       This routine sets the port's rate control ingress limit mode.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode       - rate control ingress limit mode.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*    GT_LIMT_ALL = 0,        limit and count all frames
-*    GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
-*    GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
-*    GT_LIMIT_BRDCST         limit and count Broadcast frames
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_ingress_limit_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t            mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],mode[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,mode);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_set_ingress_limit_mode(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_ingress_limit_mode
-*
-* DESCRIPTION:
-*       This routine gets the port's rate control ingress limit mode.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*        mode        - rate control ingress limit mode.
-*
-* RETURNS:
-*       On success   -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*    GT_LIMT_ALL = 0,        limit and count all frames
-*    GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
-*    GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
-*    GT_LIMIT_BRDCST         limit and count Broadcast frames
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_ingress_limit_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_ingress_limit_mode(lPort, mode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: mode[%d]\n\r",__FUNCTION__,*mode);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_priority_selection
-*
-* DESCRIPTION:
-*       This function sets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       init_pri    - Initial QPri and FPri selection type.
-*       tag_if_both - Use Tag information for the initial QPri assignment if the frame is both
-*                     tagged and its also IPv4 or IPv6 and if InitialPri uses Tag & IP priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_priority_selection
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             init_pri,
-    bool                tag_if_both
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          lTag;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d] init_pri[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,init_pri);
-    }
-
-    if (init_pri >= PRI_SEL_TYPE_MAX)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid initial priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    if(true == tag_if_both)
-        lTag = GT_TRUE;
-    else
-        lTag = GT_FALSE;
-
-    retVal = mv_switch_set_priority_selection(lPort,init_pri,lTag);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_priority_selection
-*
-* DESCRIPTION:
-*       This function gets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       init_pri    - Initial QPri and FPri selection type.
-*       tag_if_both - Use Tag information for the initial QPri assignment if the frame is both
-*                     tagged and its also IPv4 or IPv6 and if InitialPri uses Tag & IP priority.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_priority_selection
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint8_t             *init_pri,
-    bool                *tag_if_both
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          lTag;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    if (NULL == init_pri)
-    {
-        printk(KERN_INFO
-               "%s:%d: null pointer\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_get_priority_selection(lPort,init_pri,&lTag);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if(GT_TRUE == lTag)
-       *tag_if_both = true;
-    else
-       *tag_if_both = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: init_pri[%d]\n\r",__FUNCTION__,*init_pri);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a tag priority to a queue priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       tag_pri    - Source tag priority number.
-*       q_pri      - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_tag_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  tag_pri,
-     uint8_t  q_pri
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] tag_pri[%d] q_pri[%d]\n\r",
-               __FUNCTION__,owner_id,tag_pri,q_pri);
-    }
-
-    if (tag_pri > SW_QOS_NUM_OF_TAG_PRI)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid tag priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (q_pri > SW_QOS_NUM_OF_QUEUES)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid queue priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    retVal = mv_switch_set_tag_pri_mapping(tag_pri,q_pri);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets the queue priority for a tag priority mapping to.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       tag_pri    - Source tag priority number.
-*
-* OUTPUTS:
-*       q_pri      - Target queue priority number.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_tag_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  tag_pri,
-     uint8_t *q_pri
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] tag_pri[%d]\n\r",
-               __FUNCTION__,owner_id,tag_pri);
-    }
-
-    if (NULL == q_pri)
-    {
-        printk(KERN_INFO
-               "%s:%d: null pointer\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (tag_pri > SW_QOS_NUM_OF_TAG_PRI)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid tag priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    retVal = mv_switch_get_tag_pri_mapping(tag_pri,q_pri);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: q_pri[%d]\n\r",__FUNCTION__,*q_pri);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a dscp value to a queue priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       dscp       - Source dscp value.
-*       q_pri      - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_ip_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  dscp,
-     uint8_t  q_pri
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] dscp[0x%x] q_pri[%d]\n\r",
-               __FUNCTION__,owner_id,dscp,q_pri);
-    }
-
-    if (dscp > SW_QOS_DSCP_MAX)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid dscp number\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (q_pri > SW_QOS_NUM_OF_QUEUES)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid queue priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    retVal = mv_switch_set_ip_pri_mapping(dscp,q_pri);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets the queue priority for a dscp value mapping to.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       dscp       - Source dscp value.
-*
-* OUTPUTS:
-*       q_pri      - Target queue priority number.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_ip_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  dscp,
-     uint8_t *q_pri
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] dscp[%d]\n\r",
-               __FUNCTION__,owner_id,dscp);
-    }
-
-    if (NULL == q_pri)
-    {
-        printk(KERN_INFO
-               "%s:%d: null pointer\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (dscp > SW_QOS_DSCP_MAX)
-    {
-        printk(KERN_INFO
-               "%s:%d: invalid tag priority\r\n", __FUNCTION__,__LINE__);
-        return ERR_GENERAL;
-    }
-
-    retVal = mv_switch_get_ip_pri_mapping(dscp,q_pri);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: q_pri[%d]\n\r",__FUNCTION__,*q_pri);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_broadcast_flood
-*
-* DESCRIPTION:
-*       This function decides whether the switch always floods the broadcast
-*       frames to all portsr or uses the multicast egress mode (per port).
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       always_on  - always floods the broadcast regardless the multicast egress mode.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_broadcast_flood
-(
-     uint32_t owner_id,
-     bool     always_on
-)
-{
-    tpm_error_code_t retVal;
-    GT_BOOL          lFloodOn;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] always_on[%d]\n\r",
-               __FUNCTION__,owner_id,always_on);
-    }
-
-    if(true == always_on)
-        lFloodOn = GT_TRUE;
-    else
-        lFloodOn = GT_FALSE;
-
-    retVal = mv_switch_set_broadcast_flood(lFloodOn);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-
-/*******************************************************************************
-* tpm_sw_get_broadcast_flood
-*
-* DESCRIPTION:
-*       This function gets the global mode of broadcast flood.
-*
-* INPUTS:
-*       None.
-*
-* OUTPUTS:
-*       always_on  - always floods the broadcast regardless the multicast egress mode.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_broadcast_flood
-(
-    uint32_t owner_id,
-    bool    *always_on
-)
-{
-    tpm_error_code_t retVal;
-    GT_BOOL          lFloodOn;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d]\n\r",
-               __FUNCTION__,owner_id);
-    }
-
-    retVal = mv_switch_get_broadcast_flood(&lFloodOn);
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if(GT_TRUE == lFloodOn)
-        *always_on = true;
-    else
-        *always_on = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: always_on[%d]\n\r",__FUNCTION__,*always_on);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_flooding()
-*
-* DESCRIPTION:      permit or not the flooding per port
-*
-* INPUTS:
-*   owner_id    - APP owner id  should be used for all API calls.
-*   src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*   flood_mode  - flooding mode.
-*   allow_flood - set to 1 = permit flooding of unknown DA.
-*
-* OUTPUTS:
-*   None.
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_flooding
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_flood_type_t    flood_mode,
-    uint8_t             allow_flood
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          enable;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d] flood_mode[%d], allow_flood[%d]\n\r",
-               __FUNCTION__, owner_id, src_port, flood_mode, allow_flood);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    if(allow_flood == 1)
-    {
-        enable = GT_TRUE;
-    }
-    else
-    {
-        enable = GT_FALSE;
-    }
-
-    switch(flood_mode)
-    {
-        case TPM_FLOOD_UNKNOWN_UNICAST:
-            retVal = mv_switch_set_unknown_unicast_flood(lPort, enable);
-            break;
-        case TPM_FLOOD_UNKNOWN_MULTI_BROAD_CAST:
-            retVal = mv_switch_set_unknown_multicast_flood(lPort, enable);
-            break;
-        default:
-            break;
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_flooding()
-*
-* DESCRIPTION:      permit or not the flooding per port
-*
-* INPUTS:
-*   owner_id    - APP owner id  should be used for all API calls.
-*   src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*   flood_mode  - flooding mode
-*
-* OUTPUTS:
-*   allow_flood - set to 1 = permit flooding .
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_flooding
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_flood_type_t    flood_mode,
-    uint8_t            *allow_flood
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          enable;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] src_port[%d] flood_mode[%d]\n\r",
-               __FUNCTION__, owner_id, src_port, flood_mode);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    switch(flood_mode)
-    {
-        case TPM_FLOOD_UNKNOWN_UNICAST:
-            retVal = mv_switch_get_unknown_unicast_flood(lPort, &enable);
-            break;
-        case TPM_FLOOD_UNKNOWN_MULTI_BROAD_CAST:
-            retVal = mv_switch_get_unknown_multicast_flood(lPort, &enable);
-            break;
-        default:
-            break;
-    }
-
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n",__FUNCTION__,__LINE__);
-    }
-
-    if(enable == GT_TRUE)
-    {
-        *allow_flood = 1;
-    }
-    else
-    {
-        *allow_flood = 0;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: allow_flood[%d]\n\r",__FUNCTION__, *allow_flood);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_convert_port_index()
-*
-* DESCRIPTION: convert switch port index to external port index.
-*
-* INPUTS:
-* owner_id       - APP owner id  should be used for all API calls.
-* switch_port    - switch port index
-*
-* OUTPUTS:
-* extern_port    - external port index
-*
-* RETURNS:
-* On success, the function returns TPM_RC_OK. On error different types are returned
-* according to the case - see tpm_error_code_t.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_convert_port_index (uint32_t             owner_id,
-                                             uint32_t             switch_port,
-                                             tpm_src_port_type_t *extern_port)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    tpm_init_gmac_conn_conf_t gmac_conn_info;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] switch_port[%d]\n\r",
-               __FUNCTION__, owner_id, switch_port);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_db_gmac_conn_conf_get((tpm_gmacs_enum_t)switch_port, &gmac_conn_info)) {
-            printk(KERN_ERR "ERROR: (%s:%d) switch_port(%d) invalid\n", __FUNCTION__, __LINE__, switch_port);
-            return ERR_GENERAL;
-        }
-        if (TPM_TRUE == gmac_conn_info.valid)
-            *extern_port = gmac_conn_info.port_src;
-        else
-            *extern_port = TPM_DB_ERR_PORT_NUM;
-    } else {
-        *extern_port = tpm_db_phy_convert_port_index(switch_port);
-    }
-    if (*extern_port == (tpm_src_port_type_t)TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) switch_port(%d) is invalid\n", __FUNCTION__, __LINE__, switch_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: extern_port[%d]\n\r",__FUNCTION__, *extern_port);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_autoneg_mode
-*
-* DESCRIPTION:
-*       The API Configures the auto negotiation state of an Ethernet UNI port.
-* INPUTS:
-*       owner_id       - APP owner id  should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       autoneg_state  - autonegotiation state, enabled or disabled.
-*       autoneg_mode   - enum:
-*                        TPM_SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
-*                        TPM_SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
-*                        TPM_SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
-*                        TPM_SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
-*                        TPM_SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
-*                        TPM_SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
-*                        TPM_SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
-*                        TPM_SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
-*                        TPM_SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
-*                        TPM_SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
-*                        TPM_SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
-*                        TPM_SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_autoneg_mode
-(
-    uint32_t              owner_id,
-    tpm_src_port_type_t   src_port,
-    bool                  autoneg_state,
-    tpm_autoneg_mode_t    autoneg_mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL  state, prev_state;
-    GT_PHY_AUTO_MODE prev_mode;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    uint16_t         lsp_mode = PHY_AUTO_NEGO_MODE_HALF_10 |
-                                PHY_AUTO_NEGO_MODE_FULL_10 |
-                                PHY_AUTO_NEGO_MODE_HALF_100 |
-                                PHY_AUTO_NEGO_MODE_FULL_100;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-              "==ENTER==%s: owner_id[%d],src_port[%d],autoneg_state[%d],autoneg_mode[%d]\n\r",
-              __FUNCTION__, owner_id, src_port, autoneg_state, autoneg_mode);
-    }
-
-    if(true == autoneg_state)
-        state = GT_TRUE;
-    else
-        state = GT_FALSE;
-
-    switch (autoneg_mode) {
-    case TPM_SPEED_AUTO_DUPLEX_AUTO:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_10 |
-                   PHY_AUTO_NEGO_MODE_FULL_10 |
-                   PHY_AUTO_NEGO_MODE_HALF_100 |
-                   PHY_AUTO_NEGO_MODE_FULL_100 |
-                   PHY_AUTO_NEGO_MODE_HALF_1000 |
-                   PHY_AUTO_NEGO_MODE_FULL_1000;
-        break;
-    case TPM_SPEED_1000_DUPLEX_AUTO:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_1000 |
-                   PHY_AUTO_NEGO_MODE_FULL_1000;
-        break;
-    case TPM_SPEED_100_DUPLEX_AUTO:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_100 |
-                   PHY_AUTO_NEGO_MODE_HALF_100;
-        break;
-    case TPM_SPEED_10_DUPLEX_AUTO:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_10 |
-                   PHY_AUTO_NEGO_MODE_HALF_10;
-        break;
-    case TPM_SPEED_AUTO_DUPLEX_FULL:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_10 |
-		   PHY_AUTO_NEGO_MODE_FULL_100 |
-		    PHY_AUTO_NEGO_MODE_FULL_1000;
-        break;
-    case TPM_SPEED_AUTO_DUPLEX_HALF:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_1000 |
-                   PHY_AUTO_NEGO_MODE_HALF_100 |
-                   PHY_AUTO_NEGO_MODE_HALF_10;
-        break;
-    case TPM_SPEED_1000_DUPLEX_FULL:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_1000;
-        break;
-    case TPM_SPEED_1000_DUPLEX_HALF:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_1000;
-        break;
-    case TPM_SPEED_100_DUPLEX_FULL:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_100;
-        break;
-    case TPM_SPEED_100_DUPLEX_HALF:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_100;
-        break;
-    case TPM_SPEED_10_DUPLEX_FULL:
-        lsp_mode = PHY_AUTO_NEGO_MODE_FULL_10;
-        break;
-    case TPM_SPEED_10_DUPLEX_HALF:
-        lsp_mode = PHY_AUTO_NEGO_MODE_HALF_10;
-        break;
-    default:
-        printk(KERN_ERR "ERROR: (%s:%d) invalid autoneg_mode\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyAutoNegoSet(phy_direct_addr, state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-        if (state && (retVal == TPM_RC_OK)) {
-            if (mvEthPhyAdvertiseSet(phy_direct_addr, lsp_mode)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        if (TPM_RC_OK == (retVal = mv_switch_get_port_autoneg_mode(lPort, &prev_state, &prev_mode)))
-        {
-            if (prev_state != state || prev_mode != (GT_PHY_AUTO_MODE)autoneg_mode)
-            {
-                retVal = mv_switch_set_port_autoneg_mode(lPort, state, (GT_PHY_AUTO_MODE)autoneg_mode);
-                if (retVal != TPM_RC_OK)
-                {
-                    printk(KERN_ERR
-                           "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                }
-            }
-        }
-    }
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_autoneg_mode
-*
-* DESCRIPTION:
-*       The API return the the auto negotiation state of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id       - APP owner id  should be used for all API calls.
-*       src_port       - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       autoneg_state  - autonegotiation state, enabled or disabled.
-*       autoneg_mode   - enum:
-*                        TPM_SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
-*                        TPM_SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
-*                        TPM_SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
-*                        TPM_SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
-*                        TPM_SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
-*                        TPM_SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
-*                        TPM_SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
-*                        TPM_SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
-*                        TPM_SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
-*                        TPM_SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
-*                        TPM_SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
-*                        TPM_SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
-
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_autoneg_mode
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    bool                *autoneg_state,
-    tpm_autoneg_mode_t  *autoneg_mode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    GT_PHY_AUTO_MODE mode;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    uint16_t         lsp_mode;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyAutoNegoGet(phy_direct_addr, (int *)&state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-        if (state && (retVal == TPM_RC_OK)) {
-            if (mvEthPhyAdvertiseGet(phy_direct_addr, &lsp_mode)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-            switch (lsp_mode) {
-            case (PHY_AUTO_NEGO_MODE_HALF_10 |
-                  PHY_AUTO_NEGO_MODE_FULL_10 |
-                  PHY_AUTO_NEGO_MODE_HALF_100 |
-                  PHY_AUTO_NEGO_MODE_FULL_100 |
-                  PHY_AUTO_NEGO_MODE_HALF_1000 |
-                  PHY_AUTO_NEGO_MODE_FULL_1000):
-                mode = TPM_SPEED_AUTO_DUPLEX_AUTO;
-                break;
-            case (PHY_AUTO_NEGO_MODE_HALF_1000 |
-                  PHY_AUTO_NEGO_MODE_FULL_1000):
-                mode = TPM_SPEED_1000_DUPLEX_AUTO;
-                break;
-            case (PHY_AUTO_NEGO_MODE_FULL_100 |
-                  PHY_AUTO_NEGO_MODE_HALF_100):
-                mode = TPM_SPEED_100_DUPLEX_AUTO;
-                break;
-            case (PHY_AUTO_NEGO_MODE_FULL_10 |
-                  PHY_AUTO_NEGO_MODE_HALF_10):
-                mode = TPM_SPEED_10_DUPLEX_AUTO;
-                break;
-            case (PHY_AUTO_NEGO_MODE_FULL_10 |
-                  PHY_AUTO_NEGO_MODE_FULL_100 |
-                  PHY_AUTO_NEGO_MODE_FULL_1000):
-                mode = TPM_SPEED_AUTO_DUPLEX_FULL;
-                break;
-            case (PHY_AUTO_NEGO_MODE_HALF_1000 |
-                  PHY_AUTO_NEGO_MODE_HALF_100 |
-                  PHY_AUTO_NEGO_MODE_HALF_10):
-                mode = TPM_SPEED_AUTO_DUPLEX_HALF;
-                break;
-            case PHY_AUTO_NEGO_MODE_FULL_1000:
-                mode = TPM_SPEED_1000_DUPLEX_FULL;
-                break;
-            case PHY_AUTO_NEGO_MODE_HALF_1000:
-                mode = TPM_SPEED_1000_DUPLEX_HALF;
-                break;
-            case PHY_AUTO_NEGO_MODE_FULL_100:
-                mode = TPM_SPEED_100_DUPLEX_FULL;
-                break;
-            case PHY_AUTO_NEGO_MODE_HALF_100:
-                mode = TPM_SPEED_100_DUPLEX_HALF;
-                break;
-            case PHY_AUTO_NEGO_MODE_FULL_10:
-                mode = TPM_SPEED_10_DUPLEX_FULL;
-                break;
-            case PHY_AUTO_NEGO_MODE_HALF_10:
-                mode = TPM_SPEED_10_DUPLEX_HALF;
-                break;
-            default:
-                mode = TPM_SPEED_AUTO_DUPLEX_AUTO;
-                break;
-            }
-        } else {
-            mode = TPM_SPEED_AUTO_DUPLEX_AUTO;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_autoneg_mode(lPort, &state, &mode);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(GT_TRUE == state)
-        *autoneg_state = true;
-    else
-        *autoneg_state = false;
-
-    *autoneg_mode = (tpm_autoneg_mode_t)mode;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: autoneg_state[%d], autoneg_mode[%d]\n\r", __FUNCTION__, *autoneg_state, *autoneg_mode);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_restart_port_autoneg
-*
-* DESCRIPTION:
-*       The API restart the auto negotiation of an Ethernet  UNI port.
-*	If AutoNegotiation is not enabled, it'll enable it.
-*	Loopback and Power Down will be disabled by this routine.
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*        NONE.
-*                                .
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_restart_port_autoneg
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyRestartAN(phy_direct_addr, 0)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_restart_port_autoneg(lPort);
-        if (retVal != TPM_RC_OK)
-        {
-             printk(KERN_ERR
-                    "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_admin_state
-*
-* DESCRIPTION:
-*       The API Configures the PHY port  state of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id        - APP owner id  should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       phy_port_state  - PHY port  state to set.
-*                         0:normal state
-*                         1:power down
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success      -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_admin_state
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool                phy_port_state
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL  state, prev_state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],phy_port_state[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,phy_port_state);
-    }
-
-    if(phy_port_state == true)
-        state = GT_TRUE;
-    else
-        state = GT_FALSE;
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhySetAdminState(phy_direct_addr, (int)state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        if (TPM_RC_OK == (retVal = mv_switch_get_phy_port_state(lPort, &prev_state)))
-        {
-            if (prev_state != state)
-            {
-                retVal = mv_switch_set_phy_port_state(lPort, state);
-                if (retVal != TPM_RC_OK)
-                {
-                    printk(KERN_ERR
-                           "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                }
-            }
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_admin_state
-*
-* DESCRIPTION:
-*       The API return the PHY port  state of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id         - APP owner id  should be used for all API calls.
-*       src_port         - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       phy_port_state   -  0:normal state
-*                           1:power down                                    .
-*
-* RETURNS:
-*       On success       -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_admin_state
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool               *phy_port_state
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyGetAdminState(phy_direct_addr, (int *)&state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_phy_port_state(lPort, &state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(state == GT_TRUE)
-        *phy_port_state = true;
-    else
-        *phy_port_state = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: phy_port_state[%d]\n\r",__FUNCTION__,*phy_port_state);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_link_status
-*
-* DESCRIPTION:
-*       The API return realtime port link status of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_link_status  -  0:port link is ON
-*                            1:port link is DOWN                                    .
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_link_status
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    bool                *port_link_status
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        state = (GT_BOOL)mvEthPhyCheckLink(phy_direct_addr);
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_link_status(lPort, &state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(state == GT_TRUE)
-        *port_link_status = true;
-    else
-        *port_link_status = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==EXIT== %s: port_link_status[%d]\n\r",__FUNCTION__,*port_link_status);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_duplex_status
-*
-* DESCRIPTION:
-*       The API return realtime port duplex status of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_duplex_status  -  0:half deplex mode
-*                              1:full deplex mode                    .
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-* This function is different from tpm_phy_get_port_duplex_mode, it reflects the real duplex status happening
-* in PHY now. If there is a switch, through PPU function, switch can get the duplex info from PHY and
-* store it in switch port register, so duplex info can be got from switch port register. It is a
-* "get_xxx_oper" function. If there is no switch, this info can be read from PHY spec status register,
-* offset 17
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_duplex_status
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    bool                *port_duplex_status
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state, status_valid;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyDuplexOperGet(phy_direct_addr, (int *)&status_valid, (int *)&state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-
-        if (status_valid == GT_FALSE) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY duplex status is not valid on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_STATUS_UNKNOWN;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_duplex_status(lPort, &state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(state == GT_TRUE)
-        *port_duplex_status = true;
-    else
-        *port_duplex_status = false;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: port_duplex_status[%d]\n\r",__FUNCTION__,*port_duplex_status);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_speed_mode
-*
-* DESCRIPTION:
-*       The API return realtime port speed mode of an Ethernet  UNI port.
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       port_duplex_status  -  0:10M
-*                              1:100M
-*                              2:1000M
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-*
-* COMMENTS:
-* This function is different from "tpm_phy_get_port_speed ", it reflects what really happens
-* in PHY. If there is a switch, this function will get the stats info from switch register,
-* because the PPU function will make the switch get the PHY status info and store it in port
-* register. If there is no switch, speed mode info can be got from PHY register spec status
-* register, offset is 17.
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_speed_mode
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *speed
-)
-{
-    tpm_error_code_t   retVal = TPM_RC_OK;
-    int32_t            lPort  = 0;
-    GT_PORT_SPEED_MODE tmpSpeed;
-    tpm_phy_ctrl_t     phy_access_way;
-    uint32_t           phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhySpeedOperGet(phy_direct_addr, (uint32_t *)&tmpSpeed)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-
-        if (tmpSpeed == PORT_SPEED_UNKNOWN) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY speed status is not valid on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_STATUS_UNKNOWN;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_speed_mode(lPort, &tmpSpeed);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    *speed = (uint32_t)tmpSpeed;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: speed[%d]\n\r",__FUNCTION__,*speed);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_flow_control_support
-*
-* DESCRIPTION:
-*       This routine will set the pause bit in Autonegotiation Advertisement
-*        Register. And restart the autonegotiation.
-*
-* INPUTS:
-*       owner_id   - APP owner id  should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       state      - false:port pause is off.
-*                    true:port pause is on.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-* This function reflect flow control configuration info, it only access PHY register,
-* that is data sheet register 4.10 Autonegotiation Advertisement Register.
-*******************************************************************************/
-
-tpm_error_code_t tpm_phy_set_port_flow_control_support
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool                state
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_PHY_PAUSE_MODE pause_state, prev_state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    uint32_t         switch_init;
-    tpm_gmacs_enum_t gmac_port;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],state[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,state);
-    }
-
-    if(state == true)
-        pause_state = GT_PHY_PAUSE;
-    else
-        pause_state = GT_PHY_NO_PAUSE;
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (tpm_db_switch_init_get(&switch_init) != TPM_DB_OK) {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_db_switch_init_get Failed\n", __FUNCTION__, __LINE__);
-            retVal = ERR_GENERAL;
-            return retVal;
-        }
-        /* Only PHY connected to GMAC, need write GMAC register */
-        if (!switch_init) {
-            for (gmac_port = TPM_ENUM_GMAC_0; gmac_port < TPM_MAX_NUM_GMACS; gmac_port++) {
-                if (phy_direct_addr == mvBoardPhyAddrGet(gmac_port))
-                break;
-            }
-            if (gmac_port == TPM_MAX_NUM_GMACS) {
-                printk(KERN_ERR "ERROR: (%s:%d) Can not find gmac port\n", __FUNCTION__, __LINE__);
-                retVal = ERR_GENERAL;
-                return retVal;
-            }
-
-            /* Write Flow Control reg on GMAC port */
-            switch(pause_state) {
-            case GT_PHY_NO_PAUSE:
-                if (mvNetaFlowCtrlSet((int)gmac_port, MV_ETH_FC_DISABLE) != MV_OK) {
-                    printk(KERN_ERR "ERROR: (%s:%d) mvNetaFlowCtrlSet Failed\n", __FUNCTION__, __LINE__);
-                    retVal = ERR_GENERAL;
-                    return retVal;
-                }
-                break;
-            case GT_PHY_PAUSE:
-                if (mvNetaFlowCtrlSet((int)gmac_port, MV_ETH_FC_ENABLE) != MV_OK) {
-                    printk(KERN_ERR "ERROR: (%s:%d) mvNetaFlowCtrlSet Failed\n", __FUNCTION__, __LINE__);
-                    retVal = ERR_GENERAL;
-                    return retVal;
-                }
-                break;
-            default:
-                printk(KERN_ERR "ERROR: (%s:%d)Invalid flow control mode%d\n", __FUNCTION__, __LINE__, pause_state);
-                retVal = ERR_GENERAL;
-                return retVal;
-            }
-        } else {
-            /* Flow control info can not be got from linkpartner through QSGMII auto negitiation, so manual needed */
-            lPort = tpm_db_eth_port_switch_port_get(src_port);
-            if (lPort == TPM_DB_ERR_PORT_NUM)
-            {
-                printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-                return ERR_SRC_PORT_INVALID;
-            }
-            /* Set force FC value */
-            if ((retVal = mv_switch_set_port_forced_fc_value(lPort, state)) != TPM_RC_OK) {
-                printk(KERN_ERR "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                return retVal;
-            }
-            /* Set force FC */
-            if ((retVal = mv_switch_set_port_forced_flow_control(lPort, state)) != TPM_RC_OK) {
-                printk(KERN_ERR "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                return retVal;
-            }
-        }
-        if (mvEthPhyPauseSet(phy_direct_addr, (uint32_t)pause_state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        if (TPM_RC_OK == (retVal = mv_switch_get_port_pause(lPort, &prev_state)))
-        {
-            if (prev_state != pause_state)
-            {
-                retVal = mv_switch_set_port_pause(lPort, pause_state);
-                if (retVal != TPM_RC_OK)
-                {
-                    printk(KERN_ERR
-                           "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                }
-            }
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_flow_control_support
-* DESCRIPTION:
-*       This routine will get the pause bit in Autonegotiation Advertisement
-*        Register.
-*
-* INPUTS:
-*       owner_id   - APP owner id  should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS
-*       state      -  false:port pause is off.
-*                      true:port pause is on.
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-* data sheet register 4.10 Autonegotiation Advertisement Register
-*******************************************************************************/
-
-tpm_error_code_t tpm_phy_get_port_flow_control_support
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool               *state
-)
-{
-    tpm_error_code_t  retVal = TPM_RC_OK;
-    int32_t           lPort  = 0;
-    GT_PHY_PAUSE_MODE pause_state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyPauseAdminGet(phy_direct_addr, (uint32_t *)&pause_state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_pause(lPort, &pause_state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(pause_state == GT_PHY_NO_PAUSE)
-        *state = false;
-    else
-        *state = true;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: flow_control[%d]\n\r",__FUNCTION__,*state);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_flow_control_state
-*
-* DESCRIPTION:
-*     This routine will get the current pause state.
-*        Register.
-*
-* INPUTS:
-*       owner_id   - APP owner id  should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*        state     -
-*                   false: MAC Pause not implemented in the link partner or in MyPause
-*                   true:  MAC Pause is implemented in the link partner and in MyPause
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case, see tpm_error_code_t.
-* COMMENTS:
-* This function is different from function tpm_phy_set_port_flow_control_support(),
-* it reflects the flow control info on MAC of PHY, so this info can only be got from
-* MAC, PHY connected to. If there is a switch, this info can be got from switch port register,
-* if there is no switch connected to PHY, this info can be got from the MAC connected to it,
-* such as GMAC0.
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_flow_control_state
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool               *state
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          fc_state;
-    uint32_t         switch_init;
-    tpm_gmacs_enum_t gmac_port;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    uint32_t         fc_mode;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    /* Check swicth init or not */
-    if (tpm_db_switch_init_get(&switch_init) != TPM_DB_OK) {
-        printk(KERN_ERR "ERROR: (%s:%d) tpm_db_switch_init_get failed\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-    if (switch_init) {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_pause_state(lPort, &fc_state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        if(fc_state == GT_FALSE)
-            *state = false;
-        else
-            *state = true;
-    } else {
-        /* check PHY access way */
-        retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-        if (retVal != TPM_RC_OK) {
-            printk(KERN_ERR
-                   "Port%d PHY access way check failed\n", src_port);
-            return retVal;
-        }
-        for (gmac_port = TPM_ENUM_GMAC_0; gmac_port < TPM_MAX_NUM_GMACS; gmac_port++) {
-            if (phy_direct_addr == mvBoardPhyAddrGet(gmac_port))
-                break;
-        }
-        if (gmac_port == TPM_MAX_NUM_GMACS) {
-            printk(KERN_ERR "ERROR: (%s:%d) Can not find gmac port\n", __FUNCTION__, __LINE__);
-            retVal = ERR_GENERAL;
-            return retVal;
-        }
-
-        /* Get GMAC Flow Control state */
-        if (mvNetaFlowCtrlGet((int)gmac_port, &fc_mode) != MV_OK) {
-            printk(KERN_ERR "ERROR: (%s:%d) Can not find gmac port\n", __FUNCTION__, __LINE__);
-            retVal = ERR_GENERAL;
-            return retVal;
-        }
-
-        if (fc_mode == MV_ETH_FC_DISABLE)
-            *state = false;
-        else
-            *state = true;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: flow_control_state[%d]\n\r",__FUNCTION__,*state);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_loopback
-*
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode        - Internal or external loopback
-*       enable      - If GT_TRUE, enable loopback mode
-*                     If GT_FALSE, disable loopback mode
-*
-* OUTPUTS:
-* None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-* data sheet register 0.14 - Loop_back
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_loopback
-(
-    uint32_t                owner_id,
-    tpm_src_port_type_t     src_port,
-    tpm_phy_loopback_mode_t mode,
-    bool                    enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state, link_forced;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    uint32_t         switch_init;
-    uint32_t         gmac_idx;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],mode[%d], enable[%d]\n\r",
-               __FUNCTION__,owner_id, src_port, mode, (uint32_t)enable);
-    }
-
-    if(enable == true)
-    {
-        state = GT_TRUE;
-    }
-    else
-    {
-        state = GT_FALSE;
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (PHY_INTERNAL_LOOPBACK == (GT_PHY_LOOPBACK_MODE)mode) {
-            if (mvEthPhyLoopbackSet(phy_direct_addr, state)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-            /* Force switch port link up if QSGMII mode with switch */
-            retVal = tpm_db_switch_init_get(&switch_init);
-            if (retVal) {
-                printk(KERN_ERR "ERROR: (%s:%d)switch init get failed\n", __FUNCTION__, __LINE__);
-                return retVal;
-            }
-            if (switch_init) {
-                lPort = tpm_db_eth_port_switch_port_get(src_port);
-                if (lPort == TPM_DB_ERR_PORT_NUM)
-                {
-                    printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-                    return ERR_SRC_PORT_INVALID;
-                }
-                retVal = mv_switch_get_port_forced_link(lPort, &link_forced);
-                if (retVal != TPM_RC_OK)
-                {
-                    printk(KERN_ERR
-                           "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                    return retVal;
-                }
-                if (((state == GT_TRUE) && (link_forced == GT_FALSE)) ||
-                    ((state == GT_FALSE)&& (link_forced == GT_TRUE)))
-                {
-                    retVal = mv_switch_set_port_forced_link(lPort, state);
-                    if (retVal != TPM_RC_OK)
-                    {
-                        printk(KERN_ERR
-                               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                        return retVal;
-                    }
-                    retVal = mv_switch_set_port_link_value(lPort, state);
-                    if (retVal != TPM_RC_OK)
-                    {
-                        printk(KERN_ERR
-                               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                        return retVal;
-                    }
-                }
-            } else {
-                /* get GMAC with Phyaddr */
-                for (gmac_idx = TPM_ENUM_GMAC_0; gmac_idx < TPM_MAX_NUM_GMACS; gmac_idx++) {
-                    if (phy_direct_addr == mvBoardPhyAddrGet(gmac_idx))
-                        break;
-                }
-                if (gmac_idx == TPM_MAX_NUM_GMACS) {
-                    printk(KERN_ERR
-                           "%s:%d: GMAC get with phyaddr invalid\r\n", __FUNCTION__,__LINE__);
-                    retVal = ERR_GENERAL;
-                    return retVal;
-                }
-                /* Force gmac link or disable it */
-                if (mvNetaForceLinkModeSet(gmac_idx, state, 0)) {
-                    printk(KERN_ERR
-                           "%s:%d: GMAC force link set failed\r\n", __FUNCTION__,__LINE__);
-                    retVal = ERR_GENERAL;
-                    return retVal;
-                }
-            }
-        } else if (PHY_EXTERNAL_LOOPBACK == (GT_PHY_LOOPBACK_MODE)mode) {
-            if (mvEthPhyLineLoopbackSet(phy_direct_addr, state)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-        } else {
-            printk(KERN_INFO
-                   "==ENTER==%s: mode[%d] invalid\n\r", __FUNCTION__,mode);
-            retVal = ERR_GENERAL;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        switch((GT_PHY_LOOPBACK_MODE)mode)
-        {
-            case PHY_INTERNAL_LOOPBACK:
-                if (lPort == INT_GE_PHY_SWITCH_PORT)
-                {
-                    retVal = mv_switch_get_port_forced_link(lPort, &link_forced);
-                    if (retVal != TPM_RC_OK)
-                    {
-                        printk(KERN_ERR
-                               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                        break;
-                    }
-                    if (((state == GT_TRUE) && (link_forced == GT_FALSE)) ||
-                        ((state == GT_FALSE)&& (link_forced == GT_TRUE)))
-                    {
-                        retVal = mv_switch_set_port_forced_link(lPort, state);
-                        if (retVal != TPM_RC_OK)
-                        {
-                            printk(KERN_ERR
-                                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                            break;
-                        }
-                        retVal = mv_switch_set_port_link_value(lPort, state);
-                        if (retVal != TPM_RC_OK)
-                        {
-                            printk(KERN_ERR
-                                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-                            break;
-                        }
-                    }
-                }
-                retVal = mv_switch_set_port_loopback(lPort, state);
-                break;
-            case PHY_EXTERNAL_LOOPBACK:
-                retVal = mv_switch_set_port_line_loopback(lPort, state);
-                break;
-            default:
-                break;
-
-        }
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_loopback
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode        - Internal or external loopback
-*
-* OUTPUTS:
-*       enable      - If GT_TRUE,  loopback mode is enabled
-*                     If GT_FALSE,  loopback mode is disabled
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-* data sheet register 0.14 - Loop_back
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_loopback
-(
-    uint32_t                owner_id,
-    tpm_src_port_type_t     src_port,
-    tpm_phy_loopback_mode_t mode,
-    bool                   *enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d], mode[%d]\n\r",
-               __FUNCTION__,owner_id,src_port, mode);
-    }
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (PHY_INTERNAL_LOOPBACK == (GT_PHY_LOOPBACK_MODE)mode) {
-            if (mvEthPhyLoopbackGet(phy_direct_addr, (int *)&state)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-        } else if (PHY_EXTERNAL_LOOPBACK == (GT_PHY_LOOPBACK_MODE)mode) {
-            if (mvEthPhyLineLoopbackGet(phy_direct_addr, (int *)&state)) {
-                printk(KERN_ERR
-                       "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-                retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-            }
-        } else {
-            printk(KERN_INFO
-                   "==ENTER==%s: mode[%d] invalid\n\r", __FUNCTION__,mode);
-            retVal = ERR_GENERAL;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        switch((GT_PHY_LOOPBACK_MODE)mode)
-        {
-            case PHY_INTERNAL_LOOPBACK:
-                retVal = mv_switch_get_port_loopback(lPort, &state);
-                break;
-            case PHY_EXTERNAL_LOOPBACK:
-                retVal = mv_switch_get_port_line_loopback(lPort, &state);
-                break;
-            default:
-                break;
-        }
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if(state == GT_TRUE)
-    {
-        *enable = true;
-    }
-    else
-    {
-        *enable = false;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: enable[%d]\n\r",__FUNCTION__,(uint32_t)*enable);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_duplex_mode
-*
-* DESCRIPTION:
-*        Sets duplex mode for a specific logical port. This function will keep
-*        the speed and loopback mode to the previous value, but disable others,
-*        such as Autonegotiation.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       enable      - Enable/Disable dulpex mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*         data sheet register 0.8 - Duplex Mode
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_duplex_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    bool                enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],enable[%d]\n\r",
-               __FUNCTION__,owner_id,src_port,(uint32_t)enable);
-    }
-
-    if(enable == true)
-    {
-        state = GT_TRUE;
-    }
-    else
-    {
-        state = GT_FALSE;
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyDuplexModeSet(phy_direct_addr, state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_port_duplex_mode(lPort, state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_duplex_mode
-*
-* DESCRIPTION:
-*         Gets duplex mode for a specific logical port.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-
-*
-* OUTPUTS:
-*       enable      - Enable/Disable dulpex mode
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*         This function will get the duplex configuration info just from PHY's control register
-* that is data sheet register 0.8 - Duplex Mode. It is a "get_xxx_admin" function.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_duplex_mode
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    bool                *enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_BOOL          state;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhyDuplexModeAdminGet(phy_direct_addr, (int *)&state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_duplex_mode(lPort, &state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        if (trace_sw_dbg_flag)
-        {
-            printk(KERN_INFO
-                    "==EXIT== %s:enable[%d]\n\r",__FUNCTION__,  *enable);
-        }
-    }
-
-    if(state == GT_TRUE)
-    {
-        *enable = true;
-    }
-    else
-    {
-        *enable = false;
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_speed
-*
-* DESCRIPTION:
-*       This routine will disable auto-negotiation and set the PHY port speed .
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       speed       -    PHY_SPEED_10_MBPS   - 10Mbps
-*                        PHY_SPEED_100_MBPS  - 100Mbps
-*                        PHY_SPEED_1000_MBPS - 1000Mbps.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-*
-*******************************************************************************/
-
-tpm_error_code_t tpm_phy_set_port_speed
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_phy_speed_t     speed
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],speed[%d]\n\r",
-               __FUNCTION__,owner_id,src_port, (uint32_t)speed);
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhySpeedSet(phy_direct_addr, speed)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_port_speed(lPort, (GT_PHY_SPEED)speed);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_get_port_speed
-*
-* DESCRIPTION:
-*       This routine will get current PHY port speed .
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-
-*
-*
-* OUTPUTS:
-*        speed      -    PHY_SPEED_10_MBPS   -10Mbps
-*                        PHY_SPEED_100_MBPS  -100Mbps
-*                        PHY_SPEED_1000_MBPS -1000Mbps.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-* This function get the PHY config information from PHY controlregister, it is a
-* "get_xxx_admin" function, it reflect the configuration to PHY and it only access PHY register.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_get_port_speed
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_phy_speed_t    *speed
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_PHY_SPEED     lSpeed;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id,src_port);
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhySpeedAdminGet(phy_direct_addr, speed)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_speed(lPort, &lSpeed);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        *speed = (tpm_phy_speed_t)lSpeed;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s: speed[%d]\n\r",__FUNCTION__,(uint32_t)*speed);
-    }
-
-    return retVal;
-}
-
-/*------------------------------------------------------------------------------
-                            Debug functions
-------------------------------------------------------------------------------*/
-
-
-/*******************************************************************************
-* tpm_sw_prv_clear_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       None.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_prv_clear_port_counters
-(
-    void
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    tpm_gmacs_enum_t gmac_i;
-    tpm_db_gmac_func_t gfunc;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s:\n\r",__FUNCTION__);
-    }
-
-    if (tpm_sw_init_check()) {
-        for (gmac_i = TPM_ENUM_GMAC_0; gmac_i < TPM_MAX_NUM_GMACS; gmac_i++) {
-            tpm_db_gmac_func_get(gmac_i, &gfunc);
-            if (gfunc == TPM_GMAC_FUNC_LAN_UNI ||
-                gfunc == TPM_GMAC_FUNC_US_MAC_LEARN_DS_LAN_UNI) {
-                MV_NETA_PORT_CTRL *pPortCtrl = mvNetaPortHndlGet(gmac_i);
-                mvNetaMibCountersClear(gmac_i, pPortCtrl->txpNum);
-            }
-        }
-    } else
-        retVal = mv_switch_clear_port_counters();
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_global_reg
-*
-* DESCRIPTION:
-*       This function sets value to the global register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_global_reg
-(
-    uint32_t owner_id,
-    uint8_t  regAddr,
-    uint16_t data
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] regAddr[0x%x] data[0x%x]\n\r",
-               __FUNCTION__,owner_id, regAddr, data);
-    }
-
-    retVal = mv_switch_set_global_reg (regAddr, data);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_global_reg
-*
-* DESCRIPTION:
-*       This function gets value from the global register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-*       data    - The read register's data.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_global_reg
-(
-     uint32_t owner_id,
-     uint8_t  regAddr,
-    uint16_t *data
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d] regAddr[0x%x]\n\r",
-               __FUNCTION__,owner_id, regAddr);
-    }
-
-    retVal = mv_switch_get_global_reg (regAddr, data);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:,data[0x%x]\n\r",__FUNCTION__,*data);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_set_port_reg
-*
-* DESCRIPTION:
-*       This function sets value to the port register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_reg
-(
-     uint32_t owner_id,
-     uint8_t  lport,
-     uint8_t  regAddr,
-     uint16_t data
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d] lport[%d] regAddr[0x%x] data[0x%x]\n\r",
-                __FUNCTION__,lport, owner_id, regAddr, data);
-    }
-
-    retVal = mv_switch_set_port_reg (lport, regAddr, data);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_get_port_reg
-*
-* DESCRIPTION:
-*       This function gets value from the port register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-*       data        - The data to be written.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_reg
-(
-     uint32_t  owner_id,
-     uint8_t   lport,
-     uint8_t   regAddr,
-     uint16_t *data
-)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d] lport[%d] regAddr[0x%x]\n\r",
-                __FUNCTION__,owner_id,lport, regAddr);
-    }
-
-    retVal = mv_switch_get_port_reg (lport, regAddr, data);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:,data[0x%x]\n\r",__FUNCTION__,*data);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_print_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        Clear on read.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_print_port_counters
-(
-     uint32_t owner_id,
-     uint8_t  lport
-)
-{
-    tpm_error_code_t retVal;
-    tpm_gmacs_enum_t gmac_i;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d] lport[%d]\n\r",
-                __FUNCTION__,owner_id,lport);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(lport, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, lport);
-            return ERR_SRC_PORT_INVALID;
-        }
-        retVal = tpm_sw_pm_print_from_gmac(gmac_i);
-    } else
-        retVal = mv_switch_print_port_counters(lport);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        return retVal;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_clear_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       owner_id    - APP owner id , should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_port_counters
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_gmacs_enum_t gmac_i;
-    MV_NETA_PORT_CTRL *pPortCtrl;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s:\n\r",__FUNCTION__);
-    }
-
-    if (tpm_sw_init_check()) {
-        if (tpm_src_port_mac_map(src_port, &gmac_i)) {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) map to mac failed\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-        pPortCtrl = mvNetaPortHndlGet(gmac_i);
-        mvNetaMibCountersClear(gmac_i, pPortCtrl->txpNum);
-    } else {
-
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_clean_port_counters(lPort);
-    }
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_pm_from_gmac
-*
-*
-* INPUTS:
-*       port        - GMAC port.
-* OUTPUTS:
-*       tpm_swport_pm_1 - Holds PM data1
-*       tpm_swport_pm_3 - Holds PM data all
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_from_gmac(int port,
-				     tpm_swport_pm_1_t   *tpm_swport_pm_1,
-				     tpm_swport_pm_3_all_t *tpm_swport_pm_3)
-{
-    uint32_t         regVaLo, regValHi = 0;
-    int32_t          mib = 0;
-
-    /* Check Input */
-    if (tpm_swport_pm_1 == NULL || tpm_swport_pm_3 == NULL) {
-        printk(KERN_ERR "ERROR: (%s:%d) Invalid Input\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-
-    /* Check GMAC Port */
-    if (mvNetaTxpCheck(port, mib)) {
-        printk(KERN_ERR "ERROR: (%s:%d) mvNetaTxpCheck failed\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-    if (!mvNetaPortHndlGet(port)) {
-        printk(KERN_ERR "ERROR: (%s:%d) mvNetaPortHndlGet failed\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-
-    /* Initialize tpm_swport_pm_3 as Zero */
-    memset(tpm_swport_pm_1, 0, sizeof(tpm_swport_pm_1_t));
-    memset(tpm_swport_pm_3, 0, sizeof(tpm_swport_pm_3_all_t));
-
-    /* Read counter */
-    tpm_swport_pm_3->dropEvents = MV_REG_READ(ETH_RX_DISCARD_PKTS_CNTR_REG(port));
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW, &regValHi);
-    tpm_swport_pm_3->InGoodOctetsLo = regVaLo;
-    tpm_swport_pm_3->InGoodOctetsHi = regValHi;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_BAD_OCTETS_RECEIVED, &regValHi);
-    tpm_swport_pm_3->InBadOctets = regVaLo;
-
-    tpm_swport_pm_3->Deferred = MV_REG_READ(ETH_RX_OVERRUN_PKTS_CNTR_REG(port));
-    tpm_swport_pm_1->deferredTransmissionCounter = tpm_swport_pm_3->Deferred;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_BROADCAST_FRAMES_RECEIVED, &regValHi);
-    tpm_swport_pm_3->InBroadcasts = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_MULTICAST_FRAMES_RECEIVED, &regValHi);
-    tpm_swport_pm_3->InMulticasts = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_64_OCTETS, &regValHi);
-    tpm_swport_pm_3->Octets64 = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_65_TO_127_OCTETS, &regValHi);
-    tpm_swport_pm_3->Octets127 = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_128_TO_255_OCTETS, &regValHi);
-    tpm_swport_pm_3->Octets255 = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_256_TO_511_OCTETS, &regValHi);
-    tpm_swport_pm_3->Octets511 = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_512_TO_1023_OCTETS, &regValHi);
-    tpm_swport_pm_3->Octets1023 = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAMES_1024_TO_MAX_OCTETS, &regValHi);
-    tpm_swport_pm_3->OctetsMax = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_GOOD_OCTETS_SENT_LOW, &regValHi);
-    tpm_swport_pm_3->OutOctetsLo = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_GOOD_OCTETS_SENT_HIGH, &regValHi);
-    tpm_swport_pm_3->OutOctetsHi = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_EXCESSIVE_COLLISION, &regValHi);
-    tpm_swport_pm_1->excessiveCollisionCounter = regVaLo;
-    tpm_swport_pm_3->Excessive = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_MULTICAST_FRAMES_SENT, &regValHi);
-    tpm_swport_pm_3->OutMulticasts = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_BROADCAST_FRAMES_SENT, &regValHi);
-    tpm_swport_pm_3->OutBroadcasts = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FC_SENT, &regValHi);
-    tpm_swport_pm_3->OutPause = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_GOOD_FC_RECEIVED, &regValHi);
-    tpm_swport_pm_3->InPause = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_UNDERSIZE_RECEIVED, &regValHi);
-    tpm_swport_pm_3->Undersize = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_FRAGMENTS_RECEIVED, &regValHi);
-    tpm_swport_pm_3->Fragments = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_OVERSIZE_RECEIVED, &regValHi);
-    tpm_swport_pm_1->frameTooLongs = regVaLo;
-    tpm_swport_pm_3->Oversize = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_JABBER_RECEIVED, &regValHi);
-    tpm_swport_pm_3->Jabber = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_MAC_RECEIVE_ERROR, &regValHi);
-    tpm_swport_pm_3->InMACRcvErr = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_BAD_CRC_EVENT, &regValHi);
-    tpm_swport_pm_3->InFCSErr = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_COLLISION, &regValHi);
-    tpm_swport_pm_3->Collisions = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_LATE_COLLISION, &regValHi);
-    tpm_swport_pm_3->Late = regVaLo;
-
-    regVaLo = mvNetaMibCounterRead(port, mib, ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR, &regValHi);
-    tpm_swport_pm_1->internalMacTransmitErrorCounter = regVaLo;
-
-    return TPM_RC_OK;
-}
-
-/*******************************************************************************
-* tpm_sw_pm_print_from_gmac
-*
-*
-* INPUTS:
-*       port        - GMAC port.
-* OUTPUTS:
-*       tpm_swport_pm_1 - Holds PM data1
-*       tpm_swport_pm_3 - Holds PM data all
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_print_from_gmac(int port)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    tpm_swport_pm_3_all_t tpm_swport_pm_3;
-    tpm_swport_pm_1_t     tpm_swport_pm_1;
-    MV_NETA_PORT_CTRL *pPortCtrl = mvNetaPortHndlGet(port);
-
-    retVal = tpm_sw_pm_from_gmac(port, &tpm_swport_pm_1, &tpm_swport_pm_3);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        return retVal;
-    }
-    printk("=======Counters from port[%d]=======\n",port);
-    printk("InGoodOctetsLo  %08d    ", tpm_swport_pm_3.InGoodOctetsLo);
-    printk("InGoodOctetsHi  %08d   \n", tpm_swport_pm_3.InGoodOctetsHi);
-    printk("InBadOctets     %08d    ", tpm_swport_pm_3.InBadOctets);
-    printk("OutFCSErr       %08d   \n", tpm_swport_pm_3.OutFCSErr);
-    printk("InUnicasts      %08d    ", tpm_swport_pm_3.InUnicasts);
-    printk("Deferred        %08d   \n", tpm_swport_pm_3.Deferred);
-    printk("InBroadcasts    %08d    ", tpm_swport_pm_3.InBroadcasts);
-    printk("InMulticasts    %08d   \n", tpm_swport_pm_3.InMulticasts);
-    printk("64Octets        %08d    ", tpm_swport_pm_3.Octets64);
-    printk("127Octets       %08d   \n", tpm_swport_pm_3.Octets127);
-    printk("255Octets       %08d    ", tpm_swport_pm_3.Octets255);
-    printk("511Octets       %08d   \n", tpm_swport_pm_3.Octets511);
-    printk("1023Octets      %08d    ", tpm_swport_pm_3.Octets1023);
-    printk("MaxOctets       %08d   \n", tpm_swport_pm_3.OctetsMax);
-    printk("OutOctetsLo     %08d    ", tpm_swport_pm_3.OutOctetsLo);
-    printk("OutOctetsHi     %08d   \n", tpm_swport_pm_3.OutOctetsHi);
-    printk("OutUnicasts     %08d    ", tpm_swport_pm_3.OutUnicasts);
-    printk("Excessive       %08d   \n", tpm_swport_pm_3.Excessive);
-    printk("OutMulticasts   %08d    ", tpm_swport_pm_3.OutMulticasts);
-    printk("OutBroadcasts   %08d   \n", tpm_swport_pm_3.OutBroadcasts);
-    printk("Single          %08d    ", tpm_swport_pm_3.Single);
-    printk("OutPause        %08d   \n", tpm_swport_pm_3.OutPause);
-    printk("InPause         %08d    ", tpm_swport_pm_3.InPause);
-    printk("Multiple        %08d   \n", tpm_swport_pm_3.Multiple);
-    printk("Undersize       %08d    ", tpm_swport_pm_3.Undersize);
-    printk("Fragments       %08d   \n", tpm_swport_pm_3.Fragments);
-    printk("Oversize        %08d    ", tpm_swport_pm_3.Oversize);
-    printk("Jabber          %08d   \n", tpm_swport_pm_3.Jabber);
-    printk("InMACRcvErr     %08d    ", tpm_swport_pm_3.InMACRcvErr);
-    printk("InFCSErr        %08d   \n", tpm_swport_pm_3.InFCSErr);
-    printk("Collisions      %08d    ", tpm_swport_pm_3.Collisions);
-    printk("Late            %08d   \n", tpm_swport_pm_3.Late);
-
-    /* Flush all counters */
-    mvNetaMibCountersClear(port, pPortCtrl->txpNum);
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_pm_1_read
-*
-*
-* INPUTS:
-*       wner_id         - APP owner id  should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       tpm_swport_pm_3 - Holds PM data
-*
-* OUTPUTS:
-*       PM data is supplied structure.
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_1_read
-(
-     uint32_t             owner_id,
-     tpm_src_port_type_t  src_port,
-     tpm_swport_pm_1_t   *tpm_swport_pm_1
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_STATS_COUNTER_SET3 statsCounterSet;
-    uint32_t         switch_init;
-    tpm_gmacs_enum_t gmac_port;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    tpm_swport_pm_3_all_t tpm_swport_pm_3;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id, src_port);
-    }
-
-    /* Check swicth init or not */
-    if (tpm_db_switch_init_get(&switch_init) != TPM_DB_OK) {
-        printk(KERN_ERR "ERROR: (%s:%d) tpm_db_switch_init_get failed\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (switch_init) {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_counters(lPort, &statsCounterSet);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        tpm_swport_pm_1->fcsErrors                       = statsCounterSet.InFCSErr;
-        tpm_swport_pm_1->excessiveCollisionCounter       = statsCounterSet.Excessive;
-        tpm_swport_pm_1->lateCollisionCounter            = statsCounterSet.Late;
-        tpm_swport_pm_1->frameTooLongs                   = statsCounterSet.Oversize;
-        tpm_swport_pm_1->bufferOverflowsOnReceive        = 0;
-        tpm_swport_pm_1->bufferOverflowsOnTransmit       = 0;
-        tpm_swport_pm_1->singleCollisionFrameCounter     = statsCounterSet.Single;
-        tpm_swport_pm_1->multipleCollisionsFrameCounter  = statsCounterSet.Multiple;
-        tpm_swport_pm_1->sqeCounter                      = 0;
-        tpm_swport_pm_1->deferredTransmissionCounter     = statsCounterSet.Deferred;
-        tpm_swport_pm_1->internalMacTransmitErrorCounter = 0;
-        tpm_swport_pm_1->carrierSenseErrorCounter        = 0;
-        tpm_swport_pm_1->alignmentErrorCounter           = 0;
-        tpm_swport_pm_1->internalMacReceiveErrorCounter  = statsCounterSet.InMACRcvErr;
-    } else {
-        /* check PHY access way */
-        retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-        if (retVal != TPM_RC_OK) {
-            printk(KERN_ERR
-                   "Port%d PHY access way check failed\n", src_port);
-            return retVal;
-        }
-        for (gmac_port = TPM_ENUM_GMAC_0; gmac_port < TPM_MAX_NUM_GMACS; gmac_port++) {
-            if (phy_direct_addr == mvBoardPhyAddrGet(gmac_port))
-                break;
-        }
-        if (gmac_port == TPM_MAX_NUM_GMACS) {
-            printk(KERN_ERR "ERROR: (%s:%d) Can not find gmac port\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-
-        /* Read counter from GMAC */
-        retVal = tpm_sw_pm_from_gmac((int)gmac_port, tpm_swport_pm_1, &tpm_swport_pm_3);
-        if (retVal != TPM_RC_OK) {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_sw_pm_3_from_gmac failed\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_pm_3_read
-*
-*
-* INPUTS:
-*       owner_id        - APP owner id  should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       tpm_swport_pm_3_all_t - Holds PM data
-*
-* OUTPUTS:
-*       PM data is supplied structure.
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_3_read
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_swport_pm_3_all_t *tpm_swport_pm_3
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    GT_STATS_COUNTER_SET3 statsCounterSet;
-    GT_PORT_STAT2         ctr;
-    uint32_t         switch_init;
-    tpm_gmacs_enum_t gmac_port;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    tpm_swport_pm_1_t   tpm_swport_pm_1;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id, src_port);
-    }
-
-    /* Initialize statsCounterSet and ctr as zero */
-    memset(&statsCounterSet, 0, sizeof(GT_STATS_COUNTER_SET3));
-    memset(&ctr, 0, sizeof(GT_PORT_STAT2));
-
-    /* Check swicth init or not */
-    if (tpm_db_switch_init_get(&switch_init) != TPM_DB_OK) {
-        printk(KERN_ERR "ERROR: (%s:%d) tpm_db_switch_init_get failed\n", __FUNCTION__, __LINE__);
-        return ERR_GENERAL;
-    }
-
-    if (switch_init) {
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_get_port_counters(lPort, &statsCounterSet);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function mv_switch_get_port_counters failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        retVal = mv_switch_get_port_drop_counters(lPort, &ctr);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function mv_switch_get_port_drop_counters failed\r\n", __FUNCTION__,__LINE__);
-        }
-
-        tpm_swport_pm_3->dropEvents	  = (ctr.inDiscardHi<<16) + ctr.inDiscardLo;
-        tpm_swport_pm_3->InGoodOctetsLo   = statsCounterSet.InGoodOctetsLo;
-        tpm_swport_pm_3->InGoodOctetsHi   = statsCounterSet.InGoodOctetsHi;
-        tpm_swport_pm_3->InBadOctets	  = statsCounterSet.InBadOctets;
-        tpm_swport_pm_3->OutFCSErr	  = statsCounterSet.OutFCSErr;
-        tpm_swport_pm_3->InUnicasts	  = statsCounterSet.InUnicasts;
-        tpm_swport_pm_3->Deferred	  = statsCounterSet.Deferred;
-        tpm_swport_pm_3->InBroadcasts	  = statsCounterSet.InBroadcasts;
-        tpm_swport_pm_3->InMulticasts	  = statsCounterSet.InMulticasts;
-        tpm_swport_pm_3->Octets64	  = statsCounterSet.Octets64;
-        tpm_swport_pm_3->Octets127	  = statsCounterSet.Octets127;
-        tpm_swport_pm_3->Octets255	  = statsCounterSet.Octets255;
-        tpm_swport_pm_3->Octets511	  = statsCounterSet.Octets511;
-        tpm_swport_pm_3->Octets1023	  = statsCounterSet.Octets1023;
-        tpm_swport_pm_3->OctetsMax	  = statsCounterSet.OctetsMax;
-        tpm_swport_pm_3->OutOctetsLo	  = statsCounterSet.OutOctetsLo;
-        tpm_swport_pm_3->OutOctetsHi	  = statsCounterSet.OutOctetsHi;
-        tpm_swport_pm_3->OutUnicasts	  = statsCounterSet.OutUnicasts;
-        tpm_swport_pm_3->Excessive	  = statsCounterSet.Excessive;
-        tpm_swport_pm_3->OutMulticasts	  = statsCounterSet.OutMulticasts;
-        tpm_swport_pm_3->OutBroadcasts	  = statsCounterSet.OutBroadcasts;
-        tpm_swport_pm_3->Single 	  = statsCounterSet.Single;
-        tpm_swport_pm_3->OutPause	  = statsCounterSet.OutPause;
-        tpm_swport_pm_3->InPause	  = statsCounterSet.InPause;
-        tpm_swport_pm_3->Multiple	  = statsCounterSet.Multiple;
-        tpm_swport_pm_3->Undersize	  = statsCounterSet.Undersize;
-        tpm_swport_pm_3->Fragments	  = statsCounterSet.Fragments;
-        tpm_swport_pm_3->Oversize	  = statsCounterSet.Oversize;
-        tpm_swport_pm_3->Jabber 	  = statsCounterSet.Jabber;
-        tpm_swport_pm_3->InMACRcvErr	  = statsCounterSet.InMACRcvErr;
-        tpm_swport_pm_3->InFCSErr	  = statsCounterSet.InFCSErr;
-        tpm_swport_pm_3->Collisions	  = statsCounterSet.Collisions;
-        tpm_swport_pm_3->Late		  = statsCounterSet.Late;
-    } else {
-        /* check PHY access way */
-        retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-        if (retVal != TPM_RC_OK) {
-            printk(KERN_ERR
-                   "Port%d PHY access way check failed\n", src_port);
-            return retVal;
-        }
-        for (gmac_port = TPM_ENUM_GMAC_0; gmac_port < TPM_MAX_NUM_GMACS; gmac_port++) {
-            if (phy_direct_addr == mvBoardPhyAddrGet(gmac_port))
-                break;
-        }
-        if (gmac_port == TPM_MAX_NUM_GMACS) {
-            printk(KERN_ERR "ERROR: (%s:%d) Can not find gmac port\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-
-        /* Read counter from GMAC */
-        retVal = tpm_sw_pm_from_gmac((int)gmac_port, &tpm_swport_pm_1, tpm_swport_pm_3);
-        if (retVal != TPM_RC_OK) {
-            printk(KERN_ERR "ERROR: (%s:%d) tpm_sw_pm_3_from_gmac failed\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_clear_port_counter
-*
-* DESCRIPTION:
-*       The API clear port pm counter.
-*
-* INPUTS:
-*       owner_id    - APP owner id should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       none.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case  see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-
-tpm_error_code_t tpm_sw_clear_port_counter
-(
-     uint32_t            owner_id,
-     tpm_src_port_type_t src_port
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d]\n\r",
-               __FUNCTION__,owner_id, src_port);
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_clean_port_counters(lPort);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-/*******************************************************************************
-* tpm_sw_get_fdb
-*
-* DESCRIPTION:
-*       This function gets all FDB table.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       db_num      - ATU MAC Address Database number. If multiple address
-*                     databases are not being used, DBNum should be zero.
-*                     If multiple address databases are being used, this value
-*                     should be set to the desired address database number.
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_fdb
-(
-     uint32_t owner_id,
-     uint16_t db_num
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==ENTER==%s: owner_id[%d] db_num[%d]\n\r",
-                __FUNCTION__,owner_id,db_num);
-    }
-
-    if (tpm_sw_init_check()) {
-        /* Check GMAC1 lpk status, if no lpk, no way to add static MAC */
-#ifdef CONFIG_MV_MAC_LEARN
-        if (tpm_db_gmac1_lpbk_en_get())
-            mac_learn_db_valid_print();
-        else {
-            printk(KERN_ERR "ERROR: (%s:%d) MAC learn not supported\n", __FUNCTION__, __LINE__);
-            return ERR_GENERAL;
-        }
-#endif
-    } else {
-        retVal =  mv_switch_print_fdb(db_num);
-    }
-    if ((retVal != TPM_RC_OK) && (retVal != GT_NO_SUCH))
-    {
-        printk(KERN_INFO
-               "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-/*******************************************************************************
-* tpm_sw_flush_vtu
-*
-* DESCRIPTION:
-*       Flush VTU on the Switch
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_flush_vtu(uint32_t owner_id)
-{
-    tpm_error_code_t retVal;
-
-    SWITCH_INIT_CHECK();
-
-    retVal = mv_switch_flush_vtu();
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    return retVal;
-}
-/*******************************************************************************
-* tpm_sw_flush_atu
-*
-* DESCRIPTION:
-*       Flush ATU on the Switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       flush_type  - FLUSH all or FLUSH all dynamic
-*       db_num      - ATU DB Num, only 0 should be used, since there is only one ATU DB right now.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_flush_atu(uint32_t owner_id, tpm_flush_atu_type_t flush_type, uint16_t db_num)
-{
-    tpm_error_code_t retVal;
-    GT_FLUSH_CMD flush_cmd;
-
-    SWITCH_INIT_CHECK();
-
-    if (TPM_FLUSH_ATU_ALL == flush_type)
-        flush_cmd = GT_FLUSH_ALL;
-    else
-        flush_cmd = GT_FLUSH_ALL_UNLOCKED;
-
-    if (0 != db_num)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed, db_num should be 0\r\n", __FUNCTION__,__LINE__);
-    }
-
-    retVal = mv_switch_flush_atu(flush_cmd, db_num);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-              "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_phy_set_port_speed_duplex_mode
-*
-* DESCRIPTION:
-*       This routine will disable auto-negotiation and set the PHY port speed and duplex mode.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       speed       -    PHY_SPEED_10_MBPS   - 10Mbps
-*                        PHY_SPEED_100_MBPS  - 100Mbps
-*                        PHY_SPEED_1000_MBPS - 1000Mbps.
-*       enable      - Enable/Disable full dulpex mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_speed_duplex_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_phy_speed_t     speed,
-    bool                enable
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t          lPort  = 0;
-    tpm_phy_ctrl_t   phy_access_way;
-    uint32_t         phy_direct_addr;
-    GT_BOOL          state;
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],speed[%d]\n\r",
-               __FUNCTION__,owner_id,src_port, (uint32_t)speed);
-    }
-
-    if(enable == true)
-    {
-        state = GT_TRUE;
-    }
-    else
-    {
-        state = GT_FALSE;
-    }
-
-    /* check PHY access way */
-    retVal = tpm_phy_access_check(src_port, &phy_access_way, &phy_direct_addr);
-    if (retVal != TPM_RC_OK) {
-        printk(KERN_ERR
-               "Port%d PHY access way check failed\n", src_port);
-        return retVal;
-    }
-    /* PHY accessed directly, call lsp API */
-    if (PHY_SMI_MASTER_CPU == phy_access_way) {
-        if (mvEthPhySpeedDuplexModeSet(phy_direct_addr, speed, state)) {
-            printk(KERN_ERR
-                   "ERROR: (%s:%d) PHY LSP API call failed on port(%d)\n", __FUNCTION__, __LINE__, src_port);
-            retVal = ERR_PHY_SRC_PORT_CONN_INVALID;
-        }
-    } else {
-        /* PHY accessed through switch, as original do */
-        lPort = tpm_db_eth_port_switch_port_get(src_port);
-        if (lPort == TPM_DB_ERR_PORT_NUM)
-        {
-            printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-            return ERR_SRC_PORT_INVALID;
-        }
-
-        retVal = mv_switch_set_port_speed_duplex_mode(lPort, (GT_PHY_SPEED)speed, state);
-        if (retVal != TPM_RC_OK)
-        {
-            printk(KERN_ERR
-                   "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-        }
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_port_add_vid_set_egrs_mode
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of the allowed VIDs per UNI port,
-*       and sets the egress mode for the port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - vlan id
-*       eMode      - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid_set_egrs_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid,
-    uint8_t             eMode
-)
-{
-    tpm_error_code_t retVal = TPM_RC_OK;
-    int32_t lPort = 0;
-
-    SWITCH_INIT_CHECK();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-               "==ENTER==%s: owner_id[%d],src_port[%d],vid[%d],egress mode[%d]\n",
-               __FUNCTION__,owner_id,src_port,vid,eMode);
-    }
-
-    if (vid >= TPM_MAX_VID)
-    {
-        printk(KERN_INFO
-           "%s:%d:==ERROR== invalid VID[%d]\r\n", __FUNCTION__,__LINE__,vid);
-        return ERR_SW_VID_INVALID;
-    }
-
-    lPort = tpm_db_eth_port_switch_port_get(src_port);
-    if (lPort == TPM_DB_ERR_PORT_NUM)
-    {
-        printk(KERN_ERR "ERROR: (%s:%d) source port(%d) is invalid\n", __FUNCTION__, __LINE__, src_port);
-        return ERR_SRC_PORT_INVALID;
-    }
-
-    retVal = mv_switch_port_add_vid_set_egrs_mode(lPort, vid, TPM_GMAC0_AMBER_PORT_NUM, eMode);
-    if (retVal != TPM_RC_OK)
-    {
-        printk(KERN_ERR
-           "%s:%d: function failed\r\n", __FUNCTION__,__LINE__);
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-            "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return retVal;
-}
-
-/*******************************************************************************
-* tpm_sw_init
-*
-* DESCRIPTION:
-*       This function init all parameters
-*
-* INPUTS:
-*       NONE.
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       NONE
-*
-* COMMENTS:
-*        There is a temprorary function.
-*
-*******************************************************************************/
-void tpm_sw_init
-(
-    void
-)
-{
-    int32_t int_ret;
-    uint32_t switch_init;
-
-    int_ret = tpm_db_switch_init_get(&switch_init);
-    if (int_ret)
-        printk(KERN_INFO "tpm_db_switch_init_get failed\n");
-    if (!switch_init) {
-        printk(KERN_INFO "switch is not allowed to init\n");
-        return;
-    }
-
-    if (trace_sw_dbg_flag)
-    {
-       printk(KERN_INFO
-               "==ENTER==%s:\n\r",__FUNCTION__);
-    }
-
-    mv_switch_drv_init();
-
-    if (trace_sw_dbg_flag)
-    {
-        printk(KERN_INFO
-                "==EXIT== %s\n\r",__FUNCTION__);
-    }
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.h
deleted file mode 100644
index 0f6141c..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/plat/tpm_switch_mgr.h
+++ /dev/null
@@ -1,1175 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-/******************************************************************************
-* mv_tpm_sw_config.h
-*
-*
-*  MODULE : TPM Switch
-*
-*  DESCRIPTION : This file config tpm switch
-*
-*  MODIFICATION HISTORY:
-*           28Apr2010   DimaM  - initial version created.
-*
-* FILE REVISION NUMBER:
-*       $Revision: 1.27 $
-*******************************************************************************/
-
-#ifndef __INC_TPM_SW_CONFIG
-#define __INC_TPM_SW_CONFIG
-
-#define PORT_SCHED_MODE_WRRB     (0)
-#define PORT_SCHED_MODE_SPRI     (1)
-#define PORT_SCHED_MODE_SPRI3    (2)
-#define PORT_SCHED_MODE_SPRI2_3  (3)
-
-#define SW_QOS_NUM_OF_QUEUES     (4)
-
-#define INT_GE_PHY_SWITCH_PORT   (0)
-
-#define SW_TRUNK_ID_MAX          (0xf)
-#define SW_TRUNK_MASK_NUM_MAX    (0x7)
-#define SW_TRUNK_MASK_MAX        (0x7f)
-
-#define SW_TRUNK_ID_REG          (5)
-#define SW_TRUNK_ID_BIT_OFF      (8)
-#define SW_TRUNK_BIT_OFF         (14)
-#define SW_TRUNK_ID_BIT_LEN      (4)
-
-#define SW_TRUNK_MAPPING_REG     (8)
-#define SW_TRUNK_MAPPING_BIT_OFF (0)
-#define SW_TRUNK_MAPPING_BIT_LEN (7)
-#define SW_TRUNK_MAPPING_ID_BIT_OFF     (11)
-#define SW_REG_UPDATE_BIT_OFF    (15)
-
-#define SW_TRUNK_MASK_REG         (7)
-#define SW_TRUNK_MASK_NUM_BIT_OFF (12)
-#define SW_TRUNK_MASK_NUM_BIT_LEN (3)
-#define SW_TRUNK_MASK_BIT_OFF     (0)
-#define SW_TRUNK_MASK_BIT_LEN     (7)
-
-#define SW_CLEAR_REG_BIT(REG, OFF, LEN) (REG) = (~((0xFFFF >> (16 - (LEN))) << OFF) & (REG))
-
-/* enum of PHY access way */
-typedef enum {
-        PHY_SMI_MASTER_CPU,/*Phy directly accessed through LSP function*/
-        PHY_SMI_MASTER_SWT,/*Phy accessed through switch*/
-} tpm_phy_ctrl_t;
-
-/*******************************************************************************
-* tpm_sw_set_static_mac_w_ports_mask
-*
-* DESCRIPTION:
-*       This function creates or destory a static MAC entry in the MAC address
-*       table for several specific ports in the integrated switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       ports_mask  - Ports mask.
-*       static_mac  - 6byte network order MAC source address.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_static_mac_w_ports_mask
-(
-    uint32_t    owner_id,
-    uint32_t    ports_mask,
-    uint8_t     static_mac[6]
-);
-
-/*******************************************************************************
-* tpm_sw_get_port_max_macs
-*
-* DESCRIPTION:
-*        Port's auto learning limit. When the limit is non-zero value, the number
-*        of MAC addresses that can be learned on this lport are limited to the value
-*        specified in this API. When the learn limit has been reached any frame
-*        that ingresses this lport with a source MAC address not already in the
-*        address database that is associated with this lport will be discarded.
-*        Normal auto-learning will resume on the lport as soon as the number of
-*        active unicast MAC addresses associated to this lport is less than the
-*        learn limit.
-*        CPU directed ATU Load, Purge, or Move will not have any effect on the
-*        learn limit.
-*        This feature is disabled when the limit is zero.
-*        The following care is needed when enabling this feature:
-*            1) dsable learning on the ports
-*            2) flush all non-static addresses in the ATU
-*            3) define the desired limit for the ports
-*            4) re-enable learing on the ports
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       limit       - maximum number of MAC addresses per lport (1-255).
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_max_macs
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *limit
-);
-
-
-/*******************************************************************************
-* tpm_sw_port_get_vid
-*
-* DESCRIPTION:
-*       The API return VID to the list of the allowed VIDs per lport.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       vid        -  searching VID.
-*
-* OUTPUTS:
-*       found      - GT_TRUE, if the appropriate entry exists.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_get_vid
-(
-    uint32_t  owner_id,
-    uint32_t  vid,
-    uint32_t *found
-);
-
-
-/*******************************************************************************
-* tpm_sw_get_vid_filter_per_port
-*
-* DESCRIPTION:
-*        This routine gets protected mode of a switch lport.
-*        When this mode is set to GT_TRUE, frames are allowed to egress lport
-*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*        by the lport's VLANTable if 802.1Q is enabled on the lport. Both must
-*        allow the frame to Egress.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode       - GT_TRUE: header mode enabled
-*                    GT_FALSE otherwise
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_vid_filter_per_port
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *mode
-);
-
-/*******************************************************************************
-* tpm_sw_get_uni_tc_ingr_police_rate
-*
-* DESCRIPTION:
-*       This routine gets the lport's ingress data limit for priority 0 or 1 or 2 or 3 frames.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*
-*       tc         - traffic class ( a combination of p-bits and DSCP values).
-*       cir        - comited info rate.
-*       cbs        - comited burst rate
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_tc_ingr_police_rate
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t            *tc,
-    uint32_t            *cir,
-    uint32_t            *cbs
-);
-
-/*******************************************************************************
-* tpm_sw_get_uni_egr_rate_limit
-*
-* DESCRIPTION:
-*       The API return the egress frame rate limit of an Ethernet UNI lport
-* INPUTS:
-*       owner_id        - APP owner id - should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       mode            - frame/rate limit mode
-*       rate_limit_val  - egress rate limit value..
-*
-* RETURNS:
-*       On success      - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       GT_ERATE_TYPE used kbRate - frame rate valid values are:
-*                                    7600,..., 9600,
-*                                    10000, 20000, 30000, 40000, ..., 100000,
-*                                    110000, 120000, 130000, ..., 1000000.
-
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_uni_egr_rate_limit
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    tpm_limit_mode_t    *mode,
-    uint32_t            *frame_rate_limit_val
-);
-
-/*******************************************************************************
-* tpm_sw_set_atu_size
-*
-* DESCRIPTION:
-*       This function Sets the Mac address table size.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       size        - Table size
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        size 0(256) - 5(8192)
-*                256 entries Mac address table.
-*                512 entries Mac address table.
-*                1024 entries Mac address table.
-*                2048 entries Mac address table.
-*                4096 entries Mac address table.
-*                8192 entries Mac address table.
-*******************************************************************************/
-
-tpm_error_code_t tpm_sw_set_atu_size
-(
-    uint32_t    owner_id,
-    uint32_t    size
-);
-
-/*******************************************************************************
-* tpm_sw_set_port_vlan_ports
-*
-* DESCRIPTION:
-*       This routine sets the port VLAN group port membership list.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       memPorts    - array of logical ports in the same vlan.
-*       memPortsLen - number of members in memPorts array
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_vlan_ports
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t            memPorts[],
-    uint8_t             memPortsLen
-);
-
-/*******************************************************************************
-* tpm_sw_get_port_vlan_ports
-*
-* DESCRIPTION:
-*       This routine gets the port VLAN group port membership list.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*       memPorts    - array of logical ports in the same vlan.
-*       memPortsLen - number of members in memPorts array
-*
-* RETURNS:
-*       On success  - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_vlan_ports
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint32_t             memPorts[],
-    uint8_t             *memPortsLen
-);
-
-/*******************************************************************************
-* tpm_sw_set_ingress_limit_mode
-*
-* DESCRIPTION:
-*       This routine sets the port's rate control ingress limit mode.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       mode         - rate control ingress limit mode.
-*
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success   - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*    GT_LIMT_ALL = 0,        limit and count all frames
-*    GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
-*    GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
-*    GT_LIMIT_BRDCST         limit and count Broadcast frames
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_ingress_limit_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t            mode
-);
-
-/*******************************************************************************
-* tpm_sw_get_ingress_limit_mode
-*
-* DESCRIPTION:
-*       This routine gets the port's rate control ingress limit mode.
-*
-* INPUTS:
-*       owner_id     - APP owner id - should be used for all API calls.
-*       src_port     - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-*
-* OUTPUTS:
-*        mode        - rate control ingress limit mode.
-*
-* RETURNS:
-*       On success   -  TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*    GT_LIMT_ALL = 0,        limit and count all frames
-*    GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
-*    GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
-*    GT_LIMIT_BRDCST         limit and count Broadcast frames
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_ingress_limit_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint32_t           *mode
-);
-
-/*******************************************************************************
-* tpm_sw_set_priority_selection
-*
-* DESCRIPTION:
-*       This function sets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       init_pri    - Initial QPri and FPri selection type.
-*       tag_if_both - Use Tag information for the initial QPri assignment if the frame is both
-*                     tagged and its also IPv4 or IPv6 and if InitialPri uses Tag & IP priority.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_priority_selection
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint8_t             init_pri,
-    bool                tag_if_both
-);
-
-/*******************************************************************************
-* tpm_sw_get_priority_selection
-*
-* DESCRIPTION:
-*       This function gets initial QPri and FPri selection.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       init_pri    - Initial QPri and FPri selection type.
-*       tag_if_both - Use Tag information for the initial QPri assignment if the frame is both
-*                     tagged and its also IPv4 or IPv6 and if InitialPri uses Tag & IP priority.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       PRI_SEL_USE_PORTS_DEF  - 0
-*       PRI_SEL_TAG_PRI_ONLY   - 1
-*       PRI_SEL_IP_PRI_ONLY    - 2
-*       PRI_SEL_TAG_AND_IP_PRI - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_priority_selection
-(
-    uint32_t             owner_id,
-    tpm_src_port_type_t  src_port,
-    uint8_t             *init_pri,
-    bool                *tag_if_both
-);
-
-/*******************************************************************************
-* tpm_sw_set_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a tag priority to a queue priority.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       tag_pri     - Source tag priority number.
-*       q_pri       - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_tag_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  tag_pri,
-     uint8_t  q_pri
-);
-
-/*******************************************************************************
-* tpm_sw_get_tag_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets the queue priority for a tag priority mapping to.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       tag_pri    - Source tag priority number.
-*
-* OUTPUTS:
-*       q_pri      - Target queue priority number.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       tag_pri 0-7.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_tag_pri_mapping
-(
-    uint32_t owner_id,
-    uint8_t  tag_pri,
-    uint8_t *q_pri
-);
-
-/*******************************************************************************
-* tpm_sw_set_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function maps a dscp value to a queue priority.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       dscp       - Source dscp value.
-*       q_pri      - Target queue priority number.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_ip_pri_mapping
-(
-     uint32_t owner_id,
-     uint8_t  dscp,
-     uint8_t  q_pri
-);
-
-/*******************************************************************************
-* tpm_sw_get_ip_pri_mapping
-*
-* DESCRIPTION:
-*       This function gets the queue priority for a dscp value mapping to.
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*       dscp       - Source dscp value.
-*
-* OUTPUTS:
-*       q_pri      - Target queue priority number.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       dscp    0-63.
-*       q_pri   0-3.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_ip_pri_mapping
-(
-    uint32_t owner_id,
-    uint8_t  dscp,
-    uint8_t *q_pri
-);
-
-/*******************************************************************************
-* tpm_sw_set_broadcast_flood
-*
-* DESCRIPTION:
-*       This function decides whether the switch always floods the broadcast
-*       frames to all portsr or uses the multicast egress mode (per port).
-*
-* INPUTS:
-*       owner_id - APP owner id - should be used for all API calls.
-*       always_on - always floods the broadcast regardless the multicast egress mode.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_broadcast_flood
-(
-     uint32_t owner_id,
-     bool     always_on
-);
-
-/*******************************************************************************
-* tpm_sw_get_broadcast_flood
-*
-* DESCRIPTION:
-*       This function gets the global mode of broadcast flood.
-*
-* INPUTS:
-*       None.
-*
-* OUTPUTS:
-*       always_on - always floods the broadcast regardless the multicast egress mode.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_broadcast_flood
-(
-     uint32_t owner_id,
-     bool    *always_on
-);
-
-/*------------------------------------------------------------------------------
-                            Debug functions
-------------------------------------------------------------------------------*/
-
-/*******************************************************************************
-* tpm_sw_set_global_reg
-*
-* DESCRIPTION:
-*       This function sets value to the global register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_global_reg
-(
-    uint32_t             owner_id,
-    uint8_t              regAddr,
-    uint16_t             data
-);
-
-/*******************************************************************************
-* tpm_sw_get_global_reg
-*
-* DESCRIPTION:
-*       This function gets value from the global register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-*       data    - The read register's data.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_global_reg
-(
-     uint32_t             owner_id,
-     uint8_t              regAddr,
-    uint16_t             *data
-);
-
-/*******************************************************************************
-* tpm_sw_set_port_reg
-*
-* DESCRIPTION:
-*       This function sets value to the port register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*       data        - The data to be written.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_port_reg
-(
-     uint32_t            owner_id,
-     uint8_t             lport,
-     uint8_t             regAddr,
-     uint16_t            data
-);
-
-/*******************************************************************************
-* tpm_sw_get_port_reg
-*
-* DESCRIPTION:
-*       This function gets value from the port register.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*       regAddr     - The register's address.
-*
-* OUTPUTS:
-*       data        - The data to be written.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_port_reg
-(
-     uint32_t            owner_id,
-     uint8_t             lport,
-     uint8_t             regAddr,
-    uint16_t            *data
-);
-
-/*******************************************************************************
-* tpm_sw_get_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       lport       - Port number to write the register for.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_print_port_counters
-(
-     uint32_t            owner_id,
-     uint8_t             lport
-);
-
-/*******************************************************************************
-* tpm_sw_clear_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       owner_id    - APP owner id , should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_clear_port_counters
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port
-);
-
-/*******************************************************************************
-* tpm_sw_pm_1_read
-*
-*
-* INPUTS:
-*       wner_id         - APP owner id should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       tpm_swport_pm_3 - Holds PM data
-*
-* OUTPUTS:
-*       PM data is supplied structure.
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_1_read
-(
-     uint32_t             owner_id,
-     tpm_src_port_type_t  src_port,
-     tpm_swport_pm_1_t   *tpm_swport_pm_1
-);
-
-/*******************************************************************************
-* tpm_sw_pm_3_read
-*
-*
-* INPUTS:
-*       owner_id        - APP owner id should be used for all API calls.
-*       src_port        - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       tpm_swport_pm_3_all_t - Holds PM data
-*
-* OUTPUTS:
-*       PM data is supplied structure.
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_3_read
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_swport_pm_3_all_t  *tpm_swport_pm_3
-);
-
-/*******************************************************************************
-* tpm_sw_prv_clear_port_counters
-*
-* DESCRIPTION:
-*       This function gets all counters of the given port
-*
-* INPUTS:
-*       owner_id    - APP owner id , should be used for all API calls.
-*       lport       - Port number to write the register for.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case , see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_prv_clear_port_counters
-(
-    void
-);
-
-/*******************************************************************************
-* tpm_sw_get_fdb
-*
-* DESCRIPTION:
-*       This function gets all FDB table.
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       db_num      - ATU MAC Address Database number. If multiple address
-*                     databases are not being used, DBNum should be zero.
-*                     If multiple address databases are being used, this value
-*                     should be set to the desired address database number.
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_get_fdb
-(
-     uint32_t            owner_id,
-     uint16_t            db_num
-);
-/*******************************************************************************
-* tpm_sw_flush_vtu
-*
-* DESCRIPTION:
-*       Flush VTU on the Switch
-*
-* INPUTS:
-*       owner_id   - APP owner id - should be used for all API calls.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_flush_vtu(uint32_t owner_id);
-
-/*******************************************************************************
-* tpm_sw_flush_atu
-*
-* DESCRIPTION:
-*       Flush ATU on the Switch
-*
-* INPUTS:
-*       owner_id    - APP owner id - should be used for all API calls.
-*       flush_type  - FLUSH all or FLUSH all dynamic
-*       db_num      - ATU DB Num, only 0 should be used, since there is only one ATU DB right now.
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_flush_atu(uint32_t owner_id, tpm_flush_atu_type_t flush_type, uint16_t db_num);
-
-/*******************************************************************************
-* tpm_phy_set_port_speed_duplex_mode
-*
-* DESCRIPTION:
-*       This routine will disable auto-negotiation and set the PHY port speed and duplex mode.
-*
-* INPUTS:
-*       owner_id    - APP owner id  should be used for all API calls.
-*       src_port    - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       speed       -    PHY_SPEED_10_MBPS   - 10Mbps
-*                        PHY_SPEED_100_MBPS  - 100Mbps
-*                        PHY_SPEED_1000_MBPS - 1000Mbps.
-*       enable      - Enable/Disable full dulpex mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-* COMMENTS:
-*
-*******************************************************************************/
-tpm_error_code_t tpm_phy_set_port_speed_duplex_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    tpm_phy_speed_t     speed,
-    bool                enable
-);
-
-/*******************************************************************************
-* tpm_sw_port_add_vid_set_egrs_mode
-*
-* DESCRIPTION:
-*       The API adds a VID to the list of the allowed VIDs per UNI port,
-*       and sets the egress mode for the port.
-*
-* INPUTS:
-*       owner_id   - APP owner id should be used for all API calls.
-*       src_port   - Source port in UNI port index, UNI0, UNI1...UNI4.
-*       vid        - vlan id
-*       eMode      - egress mode
-*
-* OUTPUTS:
-*       None.
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case see tpm_error_code_t.
-*
-* COMMENTS:
-*       MEMBER_EGRESS_UNMODIFIED - 0
-*       NOT_A_MEMBER             - 1
-*       MEMBER_EGRESS_UNTAGGED   - 2
-*       MEMBER_EGRESS_TAGGED     - 3
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_port_add_vid_set_egrs_mode
-(
-    uint32_t            owner_id,
-    tpm_src_port_type_t src_port,
-    uint16_t            vid,
-    uint8_t             eMode
-);
-
-/*******************************************************************************
-* tpm_sw_init
-*
-* DESCRIPTION:
-*       This function init all parameters
-*
-* INPUTS:
-*       NONE.
-*
-* OUTPUTS:
-*       NONE.
-*
-* RETURNS:
-*       NONE
-*
-* COMMENTS:
-*        There is a temprorary function.
-*
-*******************************************************************************/
-void tpm_sw_init
-(
-    void
-);
-
-/*******************************************************************************
-* tpm_sw_set_debug_trace_flag
-*
-* DESCRIPTION:
-*       This function sets TPM trace flag.
-*
-* INPUTS:
-*       enDis    - enable or disable
-*
-* OUTPUTS:
-*
-* RETURNS:
-*       On success - TPM_RC_OK.
-*       On error different types are returned according to the case - see tpm_error_code_t.
-*
-* COMMENTS:
-*        NONE.
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_set_debug_trace_flag
-(
-     uint32_t            enDis
-);
-
-/*******************************************************************************
-* tpm_sw_pm_print_from_gmac
-*
-*
-* INPUTS:
-*       port        - GMAC port.
-* OUTPUTS:
-*       tpm_swport_pm_1 - Holds PM data1
-*       tpm_swport_pm_3 - Holds PM data all
-*
-* RETURNS:
-* TPM_RC_OK - on success, else error code
-*
-*******************************************************************************/
-tpm_error_code_t tpm_sw_pm_print_from_gmac(int port);
-
-#endif
-- 
1.7.5.4

