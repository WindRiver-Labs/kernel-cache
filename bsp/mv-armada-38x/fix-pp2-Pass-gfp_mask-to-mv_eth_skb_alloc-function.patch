From a26f4559a77f3023502956f9e42ef44b6afffa8a Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 4 Dec 2013 11:47:39 -0500
Subject: [PATCH 1189/1825] fix: pp2: Pass gfp_mask to mv_eth_skb_alloc
 function

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 71ad2762c3aa068fd904b06b752f15f41ea1bdbf

	- Fix page allocation failure sometimes occurs when mtu changed.
	- Use GFP_ATOMIC for packet allocation called in NAPI
	- Use GFP_KERNEL for multiple packets allocation during interface start

Change-Id: Id0a315e3e407488c9950f0c30f8728ebf69a7aab
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4594
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4640
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index b65805e..c89c82d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -136,7 +136,7 @@ static u32 mv_eth_netdev_fix_features(struct net_device *dev, u32 features);
 static netdev_features_t mv_eth_netdev_fix_features(struct net_device *dev, netdev_features_t features);
 #endif
 
-static struct sk_buff *mv_eth_skb_alloc(struct bm_pool *pool, MV_ULONG *phys_addr);
+static struct sk_buff *mv_eth_skb_alloc(struct bm_pool *pool, MV_ULONG *phys_addr, gfp_t gfp_mask);
 static MV_STATUS mv_eth_pool_create(int pool, int capacity);
 static int mv_eth_pool_add(int pool, int buf_num);
 static int mv_eth_pool_free(int pool, int num);
@@ -1422,7 +1422,7 @@ int mv_eth_skb_recycle(struct sk_buff *skb)
 
 		mv_eth_skb_print(skb);
 */
-		skb = mv_eth_skb_alloc(ppool, &phys_addr);
+		skb = mv_eth_skb_alloc(ppool, &phys_addr,  GFP_ATOMIC);
 		if (!skb) {
 			pr_err("Linux processing - Can't refill\n");
 			return 1;
@@ -1446,11 +1446,11 @@ EXPORT_SYMBOL(mv_eth_skb_recycle);
 
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
-static struct sk_buff *mv_eth_skb_alloc(struct bm_pool *pool, MV_ULONG *phys_addr)
+static struct sk_buff *mv_eth_skb_alloc(struct bm_pool *pool, MV_ULONG *phys_addr, gfp_t gfp_mask)
 {
 	struct sk_buff *skb;
 
-	skb = dev_alloc_skb(pool->pkt_size);
+	skb = __dev_alloc_skb(pool->pkt_size, gfp_mask);
 	if (!skb) {
 		STAT_ERR(pool->stats.skb_alloc_oom++);
 		return NULL;
@@ -1542,7 +1542,7 @@ inline int mv_eth_refill(struct bm_pool *ppool, __u32 bm, int is_recycle)
 		return 0;
 
 	/* No recycle or too many buffers are in use - alloc new skb */
-	skb = mv_eth_skb_alloc(ppool, &phys_addr);
+	skb = mv_eth_skb_alloc(ppool, &phys_addr, GFP_ATOMIC);
 	if (!skb) {
 		pr_err("Linux processing - Can't refill\n");
 		return 1;
@@ -2666,7 +2666,7 @@ static int mv_eth_pool_add(int pool, int buf_num)
 	for (i = 0; i < buf_num; i++) {
 		if (!MV_ETH_BM_POOL_IS_HWF(bm_pool->type)) {
 			/* Allocate skb for pool used for SWF */
-			skb = mv_eth_skb_alloc(bm_pool, &phys_addr);
+			skb = mv_eth_skb_alloc(bm_pool, &phys_addr, GFP_KERNEL);
 			if (!skb)
 				break;
 
-- 
1.7.5.4

