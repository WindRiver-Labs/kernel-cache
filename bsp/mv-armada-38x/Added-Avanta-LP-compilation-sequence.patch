From d64b5ea9f42b81eb6154839d614f7c5a225aeaa4 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Wed, 13 Mar 2013 12:24:44 +0200
Subject: [PATCH 0485/1825] Added Avanta LP compilation sequence :

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit bb32e9bbc4f33e19495eecfe4fb02baf101c804b

- fixed compilation errors with new compiled interfaces (PEX, PPv2.. )
- aligned CPU/DDR/L2/Core Clk functions to read S@R information using mvCtrlCpuDdrL2FreqGet
- fixed mvBoardIdSet with correct write to S@R

Change-Id: I80266b44d976aa3d056ea3198e5da1bd67eef374
Reviewed-on: http://vgitil04.il.marvell.com:8080/1270
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   58 +++-----
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |  128 ----------------
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.h     |   23 ++--
 .../arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c |   35 ++----
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |   82 ++++++++---
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    1 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h       |  152 ++++++++++++++++----
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    1 +
 arch/arm/plat-armada/common/mvDeviceId.h           |    8 +
 9 files changed, 239 insertions(+), 249 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 7722416..a92954a 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -348,14 +348,8 @@ MV_BOARD_SPEC_INIT *mvBoardSpecInitGet(MV_VOID)
 *******************************************************************************/
 MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum)
 {
-	MV_U32 boardId = mvBoardIdGet();
-
-	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
-		mvOsPrintf("mvBoardQuadPhyAddr0Get: Board unknown.\n");
-		return MV_ERROR;
-	}
 #if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
-	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr0;
+	return board->pBoardMacInfo[ethPortNum].boardEthSmiAddr0;
 #else
 	return 0;
 #endif
@@ -452,8 +446,9 @@ MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum)
 *		Note: In order to avoid interference, make sure task context switch
 *		and interrupts will not occure during this function operation
 *
+*		 ----- omriii : is above comment still relevant here ??? -----
+*
 * INPUT:
-*       countNum - Counter number.
 *
 * OUTPUT:
 *       None.
@@ -464,11 +459,21 @@ MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum)
 *******************************************************************************/
 MV_U32 mvBoardTclkGet(MV_VOID)
 {
+	MV_FREQ_MODE freqMode;
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
 	/* FPGA is limited to 25Mhz */
 	return MV_FPGA_CORE_CLK;
 #else
-#error "Code must be added"
+	switch (mvCtrlSatRRead(MV_SATR_CORE_CLK_SELECT)) {
+	case 0:
+		return _166MHz;
+		break;
+	case 1:
+		return _200MHz;
+		break;
+	default:
+		return (MV_U32)MV_ERROR;
+	}
 #endif
 }
 
@@ -490,11 +495,15 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvBoardSysClkGet(MV_VOID)
 {
+	MV_FREQ_MODE freqMode;
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
 	/* FPGA is limited to 25Mhz */
 	return MV_FPGA_SYS_CLK;
 #else
-#error "Code must be added"
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * simple_strtoul(freqMode.ddrFreq, NULL, 16));
+	else
+		return MV_ERROR;
 #endif
 }
 
@@ -674,6 +683,7 @@ MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId)
 	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS_EN, devId);
 }
 
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
 MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum)
 {
 	MV_U32 localBusNum = mvPciLocalBusNumGet(PCI_DEFAULT_IF);
@@ -690,7 +700,7 @@ MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum)
 
 	return MV_FALSE;
 }
-
+#endif
 /*******************************************************************************
 * mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
 *
@@ -975,32 +985,6 @@ MV_U32 mvBoardBootAttrGet(MV_U32 sarBootDeviceValue, MV_U8 attrNum)
 		return MV_ERROR;
 	}
 }
-/*******************************************************************************
-* mvBoardFreqModeGet - Get the selected S@R Frequency mode
-*
-* DESCRIPTION:
-*   read board BOOT configuration and return the selcted S@R Frequency mode
-*
-* INPUT:  freqMode - MV_FREQ_MODE struct to return the freq mode
-*
-* OUTPUT: None,
-*
-* RETURN:
-*       MV_STATUS to indicate a successful read.
-*
-*******************************************************************************/
-MV_STATUS mvBoardFreqModeGet(MV_FREQ_MODE *freqMode)
-{
-	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
-	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_FREQ);
-	if (MV_ERROR !=freqModeSatRValue )
-	{
-		*freqMode = freqTable[freqModeSatRValue];
-		return MV_OK;
-	}
-	else
-		return MV_ERROR;
-}
 
 /*******************************************************************************
 * mvBoardMac0ConfigGet - test board configuration and return the correct MAC0 config
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 0fb2ca7..fce1859 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -420,18 +420,6 @@ typedef struct _boardInfo {
 	MV_BOOL moduleAutoDetect;
 } MV_BOARD_INFO;
 
-typedef enum {
-	MSAR_0_BOOT_NOR_FLASH,
-	MSAR_0_BOOT_NAND_NEW,
-	MSAR_0_BOOT_UART,
-	MSAR_0_BOOT_SPI_FLASH,
-	MSAR_0_BOOT_PEX,
-	MSAR_0_BOOT_SATA,
-	MSAR_0_BOOT_NAND_LEGACY,
-	MSAR_0_BOOT_PROMPT,
-	MSAR_0_BOOT_SPI1_FLASH
-} MV_BOARD_BOOT_SRC;
-
 /* Boot device bus width */
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS          3
 /* Bus width field meaning for NOR/NAND */
@@ -459,121 +447,6 @@ typedef enum {
 #define MSAR_0_SPI0                             0
 #define MSAR_0_SPI1                             1
 
-typedef struct _mvSARBootTable {
-	MV_BOARD_BOOT_SRC bootSrc;
-	MV_U32 attr1;                           /* Device width/Port */
-	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
-	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
-} MV_SAR_BOOT_TABLE;
-
-#define MV_SAR_TABLE_VAL { \
-/*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*03*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*04*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*05*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*06*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*07*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*08*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*09*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*10*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*11*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*12*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 4, 0 }, \
-/*13*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*14*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 0 }, \
-/*15*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 1 }, \
-/*16*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
-/*17*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
-/*18*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT },	\
-/*19*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT },	\
-/*20*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT }, \
-/*21*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT }, \
-/*22*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT },	\
-/*23*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT },	\
-/*24*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT }, \
-/*25*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT }, \
-/*26*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },	\
-/*27*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },	\
-/*28*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT }, \
-/*29*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT }, \
-/*30*/ { 0,           5,            60,          60           }, \
-/*31*/ { 0,           2,            40,          40           }, \
-/*32*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     2                }, \
-/*33*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
-/*34*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
-/*35*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       3                }, \
-/*36*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
-/*37*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
-/*38*/ { 0,           1,            2,            2              }, \
-/*39*/ { 0,           3,            6,            6              }, \
-/*40*/ { 0,           3,            5,            5              }, \
-/*41*/ { 0,           2,            6,            3              }, \
-/*42*/ { 0,           4,            10,          5              }, \
-/*43*/ { 0,           3,            6,            6              }, \
-/*44*/ { 0,           2,            4,            4              }, \
-/*45*/ { 0,           3,            6,            3              }, \
-/*46*/ { 0,           2,            5,            5              }, \
-/*47*/ { MSAR_0_BOOT_PROMPT,         2,            5,            5              }, \
-/*48*/ { MSAR_0_BOOT_UART,               1,            3,            3              }, \
-/*49*/ { MSAR_0_BOOT_SATA,                5,            10,          10           }, \
-/*50*/ { MSAR_0_BOOT_PEX,   3,            8,            4              }, \
-/*51*/ { MSAR_0_BOOT_PEX,   1,            2,            1              }, \
-/*52*/ { 0,           3,            6,            3              }, \
-/*53*/ { 0,           2,            8,            4              }, \
-/*54*/ { 0,           5,            10,          5              }, \
-/*55*/ { 0,           1,            20,          20           }, \
-/*56*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*57*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*58*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*59*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*60*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*61*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*62*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*63*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 40               } \
-}
-
-#define FREQ_MODES_NUM		29
-typedef struct {
-	MV_U8 id;
-	char *cpuFreq;
-	char *ddrFreq;
-	char *l2Freq;
-} MV_FREQ_MODE;
-
-#define MV_SAR_FREQ_MODES {\
-	{0,  "266",  "266", "133" },\
-	{1,  "333",  "167", "167" },\
-	{2,  "333",  "222", "167" },\
-	{3,  "333",  "333", "167" },\
-	{4,  "400",  "200", "200" },\
-	{5,  "400",  "267", "200" },\
-	{6,  "400",  "400", "200" },\
-	{7,  "500",  "250", "250" },\
-	{8,  "500",  "334", "250" },\
-	{9,  "500",  "400", "250" },\
-	{10,  "533", "267", "267" },\
-	{11, "533",  "356", "267" },\
-	{12, "533",  "533", "267" },\
-	{13, "600",  "300", "300" },\
-	{14, "600",  "400", "300" },\
-	{15, "600",  "600", "300" },\
-	{16, "666",  "333", "333" },\
-	{17, "666",  "444", "333" },\
-	{18, "666",  "666", "333" },\
-	{19, "800",  "267", "400" },\
-	{20, "800",  "400", "400" },\
-	{21, "800",  "534", "400" },\
-	{22, "900",  "300", "450" },\
-	{23, "900",  "450", "450" },\
-	{24, "900",  "600", "450" },\
-	{25, "1000", "500", "500" },\
-	{26, "1000", "667", "500" },\
-	{27, "1000", "500", "333" },\
-	{28, "400",  "400", "400" },\
-	{29, "1100", "550", "550" }\
-};
-
 /* For backward compatability with Legacy mode */
 #define mvBoardSwitchConnectedPortGet(port)	(-1)
 #define mvBoardIsSwitchConnected(port)  	(mvBoardSwitchConnectedPortGet(port) != -1)
@@ -636,7 +509,6 @@ MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet(MV_VOID);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_U32 sarBootDeviceValue);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet(MV_U32 sarBootDeviceValue);
 MV_U32 mvBoardBootAttrGet(MV_U32 sarBootDeviceValue, MV_U8 attrNum);
-MV_STATUS mvBoardFreqModeGet(MV_FREQ_MODE *freqMode);
 MV_U8 mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum);
 MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
index 2255a53..1a94e05 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
@@ -79,18 +79,17 @@
 #ifndef MV_ASMLANGUAGE
 /* New board ID numbers */
 
-typedef enum _mvBoardId {
-	DB_6660_ID,
-	RD_6660_ID,
-	DB_6650_ID,
-	RD_6650_ID,
-	MV_BOARD_ID_AVANTA_LP_FPGA,
-	MV_MAX_BOARD_ID
-} MV_BOARD_ID;
-
-#define BOARD_ID_BASE DB_6660_ID
-
-#define MV_INVALID_BOARD_ID             0xFFFFFFFF
+/* boards ID numbers */
+#define BOARD_ID_BASE			0x0
+
+#define DB_6660_ID			(BOARD_ID_BASE)
+#define RD_6660_ID			(DB_6660_ID + 1)
+#define DB_6650_ID			(RD_6660_ID + 1)
+#define RD_6650_ID			(DB_6650_ID + 1)
+#define MV_BOARD_ID_AVANTA_LP_FPGA	(RD_6650_ID + 1)
+#define MV_MAX_BOARD_ID			(MV_BOARD_ID_AVANTA_LP_FPGA + 1)
+#define MV_INVALID_BOARD_ID		0xFFFFFFFF
+
 
 /*******************************************************************************
  * AvantaLP DB-88F6600 board */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
index f3adf50..f8db747 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
@@ -95,15 +95,15 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 MV_U32 mvCpuPclkGet(MV_VOID)
 {
-	MV_U32 idx;
-	MV_U32 cpuClk[] = MV_CPU_CLK_TBL;
+	MV_FREQ_MODE freqMode;
 
 	if (mvBoardIdGet() == MV_BOARD_ID_AVANTA_LP_FPGA)
 		return MV_FPGA_CORE_CLK; /* FPGA is limited to 12.5Mhz */
 
-	idx = MSAR_CPU_CLK_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
-
-	return cpuClk[idx] * 1000000;
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * simple_strtoul(freqMode.cpuFreq, NULL, 16));
+	else
+		return (MV_U32)MV_ERROR;
 }
 
 /*******************************************************************************
@@ -118,26 +118,11 @@ MV_U32 mvCpuPclkGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCpuL2ClkGet(MV_VOID)
 {
-	MV_U32 idx;
-	MV_U32 freqMhz, l2FreqMhz;
-	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
-
-	if (mvBoardIdGet() == MV_BOARD_ID_AVANTA_LP_FPGA)
-		return MV_FPGA_CORE_CLK; /* FPGA is limited to 12.5Mhz */
-
-	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
-
-	if (clockRatioTbl[idx].vco2cpu != 0) {
-		freqMhz = mvCpuPclkGet() / 1000000;	/* CPU freq */
-		freqMhz *= clockRatioTbl[idx].vco2cpu;	/* VCO freq */
-		l2FreqMhz = freqMhz / clockRatioTbl[idx].vco2l2c;
-		/* round up to integer MHz */
-		if (((freqMhz % clockRatioTbl[idx].vco2l2c) * 10 / clockRatioTbl[idx].vco2l2c) >= 5)
-			l2FreqMhz++;
-
-		return l2FreqMhz * 1000000;
-	} else
-		return (MV_U32)-1;
+	MV_FREQ_MODE freqMode;
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * simple_strtoul(freqMode.l2Freq, NULL, 16));
+	else
+		return (MV_U32)MV_ERROR;;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 6925054..1a716c3 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -286,6 +286,33 @@ MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
 }
 
 /*******************************************************************************
+* mvCtrlCpuDdrL2FreqGet - Get the selected S@R Frequency mode
+*
+* DESCRIPTION:
+*   read board BOOT configuration and return the selcted S@R Frequency mode
+*
+* INPUT:  freqMode - MV_FREQ_MODE struct to return the freq mode
+*
+* OUTPUT: None,
+*
+* RETURN:
+*       MV_STATUS to indicate a successful read.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
+{
+	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
+	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_FREQ);
+	if (MV_ERROR !=freqModeSatRValue )
+	{
+		*freqMode = freqTable[freqModeSatRValue];
+		return MV_OK;
+	}
+	else
+		return MV_ERROR;
+}
+
+/*******************************************************************************
 * mvCtrlBoardConfigGet
 *
 * DESCRIPTION: Read Board configuration Field
@@ -329,7 +356,7 @@ void mvCtrlSatrInit(void)
 	int i = 0;
 
 	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
-	memset(&satrOptionsConfig, MV_ERROR, (sizeof(MV_U32)*MV_SATR_READ_MAX_OPTION) );
+	memset(&satrOptionsConfig, 0xff, (sizeof(MV_U32)*MV_SATR_READ_MAX_OPTION) );
 
 	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++)
 		boardOptionsConfig[i] = MV_ERROR;
@@ -365,6 +392,27 @@ void mvCtrlSatrInit(void)
 			boardOptionsConfig[cInfo.configid] = ((tempVal[cInfo.regNum] & (cInfo.mask)) >> cInfo.offset);
 
 }
+/*******************************************************************************
+* mvCtrlDevFamilyIdGet - Get Device ID
+*
+* DESCRIPTION:
+*       This function returns Device ID.
+*
+* INPUT:
+*       ctrlModel.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board Device ID number, '-1' if Device ID is undefined.
+*
+*******************************************************************************/
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
+{
+	/* omriii - check if needed to distinguish between controllers here */
+	return MV_88F66X0;
+}
 
 /*******************************************************************************
 * mvCtrlMppRegGet - return reg address of mpp group
@@ -760,27 +808,19 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 *******************************************************************************/
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
-	MV_U32 devId, reg, reg2;
-	CTRL_ENV_INFO *ci = &ctrlEnvInfo;
-
-	if (ci->ctrlModel != MV_INVALID_DEV_ID)
-		return ci->ctrlModel;
-
-	/* If PEX0 clock is disabled - enable it to read */
-	reg = MV_REG_READ(POWER_MNG_CTRL_REG);
-	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
-		reg2 = ((reg & ~PMC_PEXSTOPCLOCK_MASK(0)) | PMC_PEXSTOPCLOCK_EN(0));
-		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg2);
+/* omriii - replace with a correct read of CTRL ID register, instead of deriving the SOC from the boardID */
+	switch (mvBoardIdGet()) {
+	case DB_6660_ID:
+	case RD_6660_ID:
+		return MV_6660_DEV_ID;
+		break;
+	case DB_6650_ID:
+	case RD_6650_ID:
+		return MV_6650_DEV_ID;
+		break;
+	default:
+		return (MV_U16)MV_ERROR;
 	}
-
-	devId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
-
-	/* Set PEX0 clock to original state */
-	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
-		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg);
-
-	ci->ctrlModel = (MV_U16)((devId >> 16) & 0xFFFF);
-	return ci->ctrlModel;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 8886a8e..5007178 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -231,6 +231,7 @@ typedef struct _boardSerdesConf {
 /* mcspLib.h API list */
 MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField,MV_SATR_TYPE_ID satrReadField, MV_U8 val);
 MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField);
+MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
 void mvCtrlSatrInit(MV_VOID);
 MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
index 098e20f..8e6aa72 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -401,33 +401,133 @@ extern "C" {
 #define MV_CPU_CLK_TBL { 1000, 1066, 1200, 1333, 1500, 1666, 1800, 2000, \
 			 600,  667,  800, 1600, 2133, 2200, 2400, 0 }
 
-/*		cpu	l2c	hclk	ddr	*/
-#define MV_DDR_L2_CLK_RATIO_TBL    { \
-/*00*/ {       1,      1,      4,      2       }, \
-/*01*/ {       1,      2,      2,      2       }, \
-/*02*/ {       2,      2,      6,      3       }, \
-/*03*/ {       2,      2,      3,      3       }, \
-/*04*/ {       1,      2,      3,      3       }, \
-/*05*/ {       1,      2,      4,      2       }, \
-/*06*/ {       1,      1,      2,      2       }, \
-/*07*/ {       2,      3,      6,      6       }, \
-/*08*/ {       2,      3,      5,      5       }, \
-/*09*/ {       1,      2,      6,      3       }, \
-/*10*/ {       2,      4,      10,     5       }, \
-/*11*/ {       1,      3,      6,      6       }, \
-/*12*/ {       1,      2,      4,      4       }, \
-/*13*/ {       1,      3,      6,      3       }, \
-/*14*/ {       1,      2,      5,      5       }, \
-/*15*/ {       2,      2,      5,      5       }, \
-/*16*/ {       1,      1,      3,      3       }, \
-/*17*/ {       2,      5,      10,     10      }, \
-/*18*/ {       1,      3,      8,      4       }, \
-/*19*/ {       1,      1,      2,      1       }, \
-/*20*/ {       2,      3,      6,      3       }, \
-/*21*/ {       1,      2,      8,      4       }, \
-/*22*/ {       2,      5,      10,     5       } \
+
+typedef enum {
+	MSAR_0_BOOT_NOR_FLASH,
+	MSAR_0_BOOT_NAND_NEW,
+	MSAR_0_BOOT_UART,
+	MSAR_0_BOOT_SPI_FLASH,
+	MSAR_0_BOOT_PEX,
+	MSAR_0_BOOT_SATA,
+	MSAR_0_BOOT_NAND_LEGACY,
+	MSAR_0_BOOT_PROMPT,
+	MSAR_0_BOOT_SPI1_FLASH
+} MV_BOARD_BOOT_SRC;
+
+typedef struct _mvSARBootTable {
+	MV_BOARD_BOOT_SRC bootSrc;
+	MV_U32 attr1;                           /* Device width/Port */
+	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
+	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
+} MV_SAR_BOOT_TABLE;
+
+#define MV_SAR_TABLE_VAL { \
+/*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*03*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*04*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*05*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*06*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*07*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*08*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*09*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*10*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*11*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*12*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 4, 0 }, \
+/*13*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*14*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 0 }, \
+/*15*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 1 }, \
+/*16*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*17*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*18*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT },	\
+/*19*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT },	\
+/*20*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT }, \
+/*21*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT }, \
+/*22*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT },	\
+/*23*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT },	\
+/*24*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT }, \
+/*25*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT }, \
+/*26*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },	\
+/*27*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },	\
+/*28*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT }, \
+/*29*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT }, \
+/*30*/ { 0,           5,            60,          60           }, \
+/*31*/ { 0,           2,            40,          40           }, \
+/*32*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     2                }, \
+/*33*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
+/*34*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
+/*35*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       3                }, \
+/*36*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
+/*37*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
+/*38*/ { 0,           1,            2,            2              }, \
+/*39*/ { 0,           3,            6,            6              }, \
+/*40*/ { 0,           3,            5,            5              }, \
+/*41*/ { 0,           2,            6,            3              }, \
+/*42*/ { 0,           4,            10,          5              }, \
+/*43*/ { 0,           3,            6,            6              }, \
+/*44*/ { 0,           2,            4,            4              }, \
+/*45*/ { 0,           3,            6,            3              }, \
+/*46*/ { 0,           2,            5,            5              }, \
+/*47*/ { MSAR_0_BOOT_PROMPT,         2,            5,            5              }, \
+/*48*/ { MSAR_0_BOOT_UART,               1,            3,            3              }, \
+/*49*/ { MSAR_0_BOOT_SATA,                5,            10,          10           }, \
+/*50*/ { MSAR_0_BOOT_PEX,   3,            8,            4              }, \
+/*51*/ { MSAR_0_BOOT_PEX,   1,            2,            1              }, \
+/*52*/ { 0,           3,            6,            3              }, \
+/*53*/ { 0,           2,            8,            4              }, \
+/*54*/ { 0,           5,            10,          5              }, \
+/*55*/ { 0,           1,            20,          20           }, \
+/*56*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*57*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*58*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*59*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*60*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*61*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*62*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*63*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 40               } \
 }
 
+typedef struct {
+	MV_U8 id;
+	char *cpuFreq;
+	char *ddrFreq;
+	char *l2Freq;
+} MV_FREQ_MODE;
+
+#define MV_SAR_FREQ_MODES {\
+	{0,  "266",  "266", "133" },\
+	{1,  "333",  "167", "167" },\
+	{2,  "333",  "222", "167" },\
+	{3,  "333",  "333", "167" },\
+	{4,  "400",  "200", "200" },\
+	{5,  "400",  "267", "200" },\
+	{6,  "400",  "400", "200" },\
+	{7,  "500",  "250", "250" },\
+	{8,  "500",  "334", "250" },\
+	{9,  "500",  "400", "250" },\
+	{10,  "533", "267", "267" },\
+	{11, "533",  "356", "267" },\
+	{12, "533",  "533", "267" },\
+	{13, "600",  "300", "300" },\
+	{14, "600",  "400", "300" },\
+	{15, "600",  "600", "300" },\
+	{16, "666",  "333", "333" },\
+	{17, "666",  "444", "333" },\
+	{18, "666",  "666", "333" },\
+	{19, "800",  "267", "400" },\
+	{20, "800",  "400", "400" },\
+	{21, "800",  "534", "400" },\
+	{22, "900",  "300", "450" },\
+	{23, "900",  "450", "450" },\
+	{24, "900",  "600", "450" },\
+	{25, "1000", "500", "500" },\
+	{26, "1000", "667", "500" },\
+	{27, "1000", "500", "333" },\
+	{28, "400",  "400", "400" },\
+	{29, "1100", "550", "550" }\
+};
+
 /* These macros help units to identify a target Mport Arbiter group */
 #define MV_TARGET_IS_DRAM(target)   \
 	((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
@@ -583,4 +683,4 @@ typedef enum {
 }
 #endif /* __cplusplus */
 
-#endif
\ No newline at end of file
+#endif
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index d5f8fd9..966a206 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -290,6 +290,7 @@ extern "C" {
 #ifndef MV_ASMLANGUAGE
 
 #define TBL_UNUSED      0       /* Used to mark unused entry */
+#define FREQ_MODES_NUM		29
 
 #define MPP_GROUP_0_TYPE { \
 		0x11111111,     /* NAND_V2_BOOT_DEVICE  */ \
diff --git a/arch/arm/plat-armada/common/mvDeviceId.h b/arch/arm/plat-armada/common/mvDeviceId.h
index 3b4e40c..f65a0a8 100644
--- a/arch/arm/plat-armada/common/mvDeviceId.h
+++ b/arch/arm/plat-armada/common/mvDeviceId.h
@@ -349,6 +349,14 @@ extern "C" {
 #define MV_78460_B0_ID         ((MV_78460_DEV_ID << 16) | MV_78XX0_B0_REV)
 #define MV_78460_B0_NAME       "MV78460 B0"
 
+
+/* Avanta LP Family */
+#define MV_88F66X0		0x6600
+#define MV_6660_DEV_ID		0x6660
+#define MV_6650_DEV_ID		0x6650
+#define MV_6610_DEV_ID		0x6610
+
+
 #ifdef __cplusplus
 }
 #endif	/* __cplusplus */
-- 
1.7.5.4

