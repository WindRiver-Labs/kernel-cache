From 964ab2ae915030ff05afdd0cfa9bf8086cb36026 Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Wed, 23 Apr 2014 09:12:48 +0300
Subject: [PATCH 1569/1825] pp3: bm: new unit test function

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 18764ead08d2d8edd96b85c2f1642229a3b5e1af

Change-Id: I2af9fd07f80c7d0beb1a32ce2c0419f33da978f4
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7165
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.h       |    4 +
 drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c |   85 +++++++++++++++++++++
 2 files changed, 89 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
index 9048ed1..d25dc6b 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
@@ -237,6 +237,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_DATA_PTR_MIN				         0
 #define BM_DATA_PTR_MAX				0xFFFFFFFF
 
+
+/* Register status */
+#define BM_STATUS_IS_IDLE			1
+
 #define BM_PID_TO_BANK(_pid)                \
 	((((_pid) >= 0) && ((_pid)   <=  3)) ?	0 :	\
 	((((_pid) >= 8) && ((_pid)%4 ==  0)) ?	1 :	\
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c b/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
index 0f26597..b763a25 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm_sysfs.c
@@ -118,6 +118,7 @@ static ssize_t mv_bm_help(char *b)
 	o += scnprintf(b+o, s-o, "echo p qi > pool_enable                  - Enables BM pool\n");
 	o += scnprintf(b+o, s-o, "echo p ps > gp_pool_pe_size_set          - Set PE pointer size in GP pool\n");
 	o += scnprintf(b+o, s-o, "echo p pp > gp_pool_pair_set             - Configure pool works in pairs\n");
+	o += scnprintf(b+o, s-o, "echo nb p nb pm pp > test                   - Open&init mandatory registers\n");
 	o += scnprintf(b+o, s-o, "echo p nb pm pp    > gp_pool_def_basic_init - Default basic init of gp pools\n");
 	o += scnprintf(b+o, s-o, "echo p nb fl pm pp > gp_pool_def_quick_init - Default quick init of gp pools\n");
 	o += scnprintf(b+o, s-o, "echo p nb ps qi    > pool_fill_level_set    - Conf Fill level of pool in DRAM\n");
@@ -202,6 +203,88 @@ static ssize_t mv_bm_config(struct device *dev,
 		rc = bm_open();
 		if (rc != OK)
 			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "test")) {
+		u32 qm_num_of_buffers;
+		struct mv_a40 qece_base_address, pl_base_address;
+		u32 pool, gp_num_of_buffers, partition_model, pool_pair;
+		struct mv_a40 base_address;
+		u32 completed, fill_level;
+		u32 status = 0;
+		u32 pool_nempty, dpool_ae, dpool_af;
+		pr_info("uni-test is called\n");
+		qm_num_of_buffers = qece_base_address.dma_msb = qece_base_address.virt_msb = pl_base_address.dma_msb = pl_base_address.virt_msb = 0;
+		gp_num_of_buffers = base_address.dma_msb = base_address.virt_msb = 0;
+		pool = partition_model = pool_pair = 0xFFFFFFFF;
+		sscanf(buf, "%d %d %d %d %d", &qm_num_of_buffers, &pool, &gp_num_of_buffers, &partition_model, &pool_pair);
+		if ((qm_num_of_buffers == 0) || (gp_num_of_buffers == 0)) {
+			pr_err("wrong number of buffers. should be larger than 0\n");
+			return -1;
+		}
+		rc = bm_open();
+		if (rc != OK) {
+			pr_err("bm open failed\n");
+			return -1;
+		}
+		rc = bm_attr_all_pools_def_set();
+		if (rc != OK) {
+			pr_err("set all attributes failed\n");
+			return -1;
+		}
+		qece_base_address.virt_lsb = (u32)dma_alloc_coherent(NULL, qm_num_of_buffers*4, &qece_base_address.dma_lsb, GFP_KERNEL);
+		pl_base_address.virt_lsb   = (u32)dma_alloc_coherent(NULL, qm_num_of_buffers*4, &pl_base_address.dma_lsb, GFP_KERNEL);
+		rc = bm_qm_gpm_pools_def_quick_init(qm_num_of_buffers, &qece_base_address, &pl_base_address);
+		if (rc != OK) {
+			pr_err("qm gpm pool quick init failed\n");
+			return -1;
+		}
+		completed = fill_level = 0xFFFFFFFF;
+		rc = bm_pool_quick_init_status_get(0, &completed);
+		rc = bm_pool_fill_level_get(0, &fill_level);
+
+		pr_info("0 - (%x) = %d\n", qece_base_address.virt_lsb, *(u32 *)(qece_base_address.virt_lsb));
+		pr_info("1 - (%x) = %d\n", qece_base_address.virt_lsb+1*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb));
+		pr_info("100 - (%x) = %d\n", qece_base_address.virt_lsb+100*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb+100*sizeof(u32)));
+		pr_info("200 - (%x) = %d\n", qece_base_address.virt_lsb+200*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb+200*sizeof(u32)));
+		pr_info("5000 - (%x) = %d\n", qece_base_address.virt_lsb+5000*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb+5000*sizeof(u32)));
+		pr_info("5103 - (%x) = %d\n", qece_base_address.virt_lsb+5103*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb+5103*sizeof(u32)));
+		pr_info("5104 - (%x) = %d\n", qece_base_address.virt_lsb+5104*sizeof(u32), *(u32 *)(qece_base_address.virt_lsb+5104*sizeof(u32)));
+
+		if (qm_num_of_buffers * 4 != fill_level)
+			pr_info("pool 0 fill level is different than number of buffers\n");
+		pr_info("\t pool 0 completed quick init= %d fill level %d Bytes\n", completed, fill_level);
+		completed = fill_level = 0xFFFFFFFF;
+		rc = bm_pool_quick_init_status_get(1, &completed);
+		rc = bm_pool_fill_level_get(1, &fill_level);
+		if (qm_num_of_buffers * 4 != fill_level)
+			pr_info("pool 0 fill level is different than configured value\n");
+		pr_info("\t pool 1 completed quick init= %d fill level %d Bytes\n", completed, fill_level);
+
+		rc = bm_enable();
+		if (rc != OK) {
+			pr_err("bm unit enable failed\n");
+			return -1;
+		}
+		bm_enable_status_get(&status);
+		pr_info("bm unit status is %d\n", status);
+		base_address.virt_lsb = (u32)dma_alloc_coherent(NULL, gp_num_of_buffers*4, &base_address.dma_lsb, GFP_KERNEL);
+		rc = bm_gp_pool_def_basic_init(pool, gp_num_of_buffers, &base_address, partition_model, pool_pair);
+		if (rc != OK) {
+			pr_err("bm gp pool %d basic init failed\n", pool);
+			return -1;
+		}
+		rc = bm_pool_quick_init_status_get(pool, &completed);
+		rc = bm_pool_fill_level_get(pool, &fill_level);
+		pr_info("\t pool %d completed quick init= %d fill level %d Bytes\n", pool, completed, fill_level);
+
+		bm_idle_status_get(&status);
+		pr_info("bm unit idle status is %s\n", ((status == BM_STATUS_IS_IDLE) ? "IDLE" : "BUSY"));
+		bm_pool_status_get(pool, &pool_nempty, &dpool_ae, &dpool_af);
+		pr_info("pool %d cache nempty %d dram ae %d dram af %d\n", pool, pool_nempty, dpool_ae, dpool_af);
+		bm_pool_status_get(0, &pool_nempty, &dpool_ae, &dpool_af);
+		pr_info("pool %d cache nempty %d dram ae %d dram af %d\n", 0, pool_nempty, dpool_ae, dpool_af);
+		bm_pool_status_get(1, &pool_nempty, &dpool_ae, &dpool_af);
+		pr_info("pool %d cache nempty %d dram ae %d dram af %d\n", 1, pool_nempty, dpool_ae, dpool_af);
+
 	} else if (!strcmp(name, "attr_all_pools_def_set")) {
 		PR_INFO_CALLED
 		rc = bm_attr_all_pools_def_set();
@@ -613,6 +696,7 @@ static ssize_t mv_bm_config(struct device *dev,
 static DEVICE_ATTR(help,                            S_IRUSR, mv_bm_show, NULL);
 static DEVICE_ATTR(status,                          S_IRUSR, mv_bm_show, NULL);
 static DEVICE_ATTR(open,                         S_IWUSR, NULL,       mv_bm_config);
+static DEVICE_ATTR(test,                         S_IWUSR, NULL,       mv_bm_config);
 static DEVICE_ATTR(attr_all_pools_def_set,       S_IWUSR, NULL,       mv_bm_config);
 static DEVICE_ATTR(attr_qm_pool_set,             S_IWUSR, NULL,       mv_bm_config);
 static DEVICE_ATTR(attr_gp_pool_set,             S_IWUSR, NULL,       mv_bm_config);
@@ -658,6 +742,7 @@ static struct attribute *mv_bm_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_status.attr,
 	&dev_attr_open.attr,
+	&dev_attr_test.attr,
 	&dev_attr_attr_all_pools_def_set.attr,
 	&dev_attr_attr_qm_pool_set.attr,
 	&dev_attr_attr_gp_pool_set.attr,
-- 
1.7.5.4

