From cea3decf173d83eb1f916eb1c94ee1658c79a692 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Tue, 11 Feb 2014 11:59:53 +0800
Subject: [PATCH 1405/1825] pon: alp: add PON driver module

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1dedd3d704d76b1df0a1fdfb6dff6635a62e50e0

Signed-off-by: Victor Gu <xigu@marvell.com>

Change-Id: Ide349b4cd7c3978d3a2dbb40c1cebd3d5b24605b
Reviewed-on: http://vgitil04.il.marvell.com:8080/5634
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Makefile                    |    4 +-
 arch/arm/mach-avantalp/config/mvRules.mk           |   23 +-
 arch/arm/plat-armada/Kconfig                       |    2 +
 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig |  123 +
 .../arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile |   50 +
 .../mv_pon/core/epon/eponCustomerApi.c             |  464 ++
 .../mv_pon/core/epon/eponCustomerApi.h             |  411 ++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuAlrm.c  |  242 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.c   | 1878 ++++++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.h   |  184 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.c    | 3008 ++++++++++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.h    |  596 +++
 .../mv_pon/core/epon/eponOnuHeader.h               |  123 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.c  |  924 ++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.h  |  125 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.c   | 1248 +++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.h   |  167 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.c  | 3190 +++++++++++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.h  |  219 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.c    | 1337 ++++++
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.h    |  232 +
 .../mv_drivers_lsp/mv_pon/core/epon/eponOnuStd.h   |  290 ++
 .../mv_pon/core/gpon/gponCustomerApi.c             |  791 ++++
 .../mv_pon/core/gpon/gponCustomerApi.h             |  589 +++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.c | 1027 +++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.h |  119 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.c  |  473 ++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.h  |  193 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.c   | 2727 +++++++++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.h   |  314 ++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.c   |  518 +++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.h   |  128 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.c    | 3974 ++++++++++++++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.h    |  450 ++
 .../mv_pon/core/gpon/gponOnuHeader.h               |  119 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.c  | 1382 ++++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.h  |  125 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.c   |  553 +++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.h   |  182 +
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.c  |  651 +++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.h  |  213 +
 .../mv_pon/core/gpon/gponOnuMngrStateMachine.c     | 3117 +++++++++++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.c    | 1180 +++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.h    |  274 ++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.c  | 1914 ++++++++
 .../mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.h  |  220 +
 .../mv_pon/perf/epon/eponOnuLnxKsMI.c              | 1256 +++++
 .../mv_pon/perf/epon/eponOnuLnxKsMI.h              |  437 ++
 .../mv_pon/perf/epon/eponOnuLnxKsUI.c              | 2887 ++++++++++++
 .../mv_pon/perf/epon/eponOnuLnxKsUI.h              |  119 +
 .../mv_pon/perf/gpon/gponOnuLnxKsMI.c              |  596 +++
 .../mv_pon/perf/gpon/gponOnuLnxKsMI.h              |  330 ++
 .../mv_pon/perf/gpon/gponOnuLnxKsUI.c              | 4820 ++++++++++++++++++++
 .../mv_pon/perf/gpon/gponOnuLnxKsUI.h              |  102 +
 .../mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.c     |  642 +++
 .../mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.h     |  137 +
 .../mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.c |  752 +++
 .../mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.h |  109 +
 .../mv_pon/plat/epon/eponOnuLnxKsOs.c              |  513 +++
 .../mv_pon/plat/epon/eponOnuLnxKsOs.h              |  112 +
 .../mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.c |  643 +++
 .../mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.h |  111 +
 .../mv_pon/plat/gpon/gponOnuLnxKsOs.c              |  526 +++
 .../mv_pon/plat/gpon/gponOnuLnxKsOs.h              |  122 +
 .../mv_drivers_lsp/mv_pon/plat/ponOnuBoard.c       |  915 ++++
 .../mv_drivers_lsp/mv_pon/plat/ponOnuBoard.h       |  187 +
 .../mv_drivers_lsp/mv_pon/plat/ponOnuHeader.h      |  117 +
 .../mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.c     |  937 ++++
 .../mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.h     |  468 ++
 .../mv_drivers_lsp/mv_pon/plat/ponOnuRtos.h        |  101 +
 70 files changed, 53008 insertions(+), 4 deletions(-)
 create mode 100755 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
 create mode 100755 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuAlrm.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuHeader.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuStd.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuHeader.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngrStateMachine.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuHeader.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuRtos.h

diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index adeffe5..b020bb6 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -87,9 +87,12 @@ avantalp-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o $(HAL_IF_DIR)/mvSysN
 avantalp-$(CONFIG_MV_CPU_PERF_CNTRS)    += $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
 avantalp-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
 avantalp-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+avantalp-$(CONFIG_MV_INCLUDE_PON)	+= $(HAL_PON_DIR)/mvPonOnuMac.o $(HAL_PON_DIR)/mvPonOnuRegs.o
 
 obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
 
+obj-$(CONFIG_MV_INCLUDE_PON)		+= $(PLAT_DRIVERS)/mv_pon/
+
 # drivers part
 
 ################################################################################
@@ -107,7 +110,6 @@ obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
 obj-y					+= $(LSP_MUX_DIR)/
 
-
 obj-$(CONFIG_SENSORS_ALP)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
 
diff --git a/arch/arm/mach-avantalp/config/mvRules.mk b/arch/arm/mach-avantalp/config/mvRules.mk
index d3f0c61..5e7d20f 100644
--- a/arch/arm/mach-avantalp/config/mvRules.mk
+++ b/arch/arm/mach-avantalp/config/mvRules.mk
@@ -43,7 +43,19 @@ HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
 HAL_UART_DIR      = $(HAL_DIR)/uart
 
 HAL_PP2_DIR       = $(HAL_DIR)/pp2
+HAL_PP2_PRS_DIR   = $(HAL_PP2_DIR)/prs
 LSP_PP2_DIR       = $(PLAT_DRIVERS)/mv_pp2
+LSP_PP2_DEV_DIR   = $(LSP_PP2_DIR)/net_dev
+
+HAL_PON_DIR       = $(HAL_DIR)/pon
+LSP_EPON_CORE_DIR = $(PLAT_DRIVERS)/mv_pon/core/epon
+LSP_GPON_CORE_DIR = $(PLAT_DRIVERS)/mv_pon/core/gpon
+LSP_EPON_PERF_DIR = $(PLAT_DRIVERS)/mv_pon/perf/epon
+LSP_GPON_PERF_DIR = $(PLAT_DRIVERS)/mv_pon/perf/gpon
+LSP_EPON_PLAT_DIR = $(PLAT_DRIVERS)/mv_pon/plat/epon
+LSP_GPON_PLAT_DIR = $(PLAT_DRIVERS)/mv_pon/plat/gpon
+LSP_PON_PLAT_DIR  = $(PLAT_DRIVERS)/mv_pon/plat
+LSP_PON_PERF_DIR  = $(PLAT_DRIVERS)/mv_pon/perf
 
 HAL_CPU_DIR       = $(HAL_DIR)/cpu
 HAL_SDMMC_DIR     = $(HAL_DIR)/sdmmc
@@ -98,7 +110,8 @@ HAL_IF_DIR        = mv_hal_if
 LSP_PATH_I       = $(srctree)/arch/arm/mach-avantalp
 PLAT_PATH_I      = $(srctree)/arch/arm/plat-armada
 
-HAL_PATH         = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+HAL_PATH         = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR) \
+                   -I$(PLAT_PATH_I)/$(HAL_PON_DIR)
 ALP_FAM_PATH     = -I$(LSP_PATH_I)/$(ALP_FAM_DIR)
 QD_PATH          = -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi \
                    -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
@@ -108,9 +121,13 @@ COMMON_PATH      = -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
 OSSERV_PATH      = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
 LSP_PATH         = -I$(LSP_PATH_I)
 CONFIG_PATH      = -I$(LSP_PATH_I)/$(CONFIG_DIR)
-HAL_IF_PATH	     = -I$(LSP_PATH_I)/$(HAL_IF) -I$(LSP_PATH_I)/$(HAL_PP2_DIR)
+HAL_IF_PATH      = -I$(LSP_PATH_I)/$(HAL_IF) -I$(LSP_PATH_I)/$(HAL_PP2_DIR) -I$(LSP_PATH_I)/$(HAL_PP2_PRS_DIR)
 DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_PP2_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
-		           -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR)
+                   -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR) -I$(PLAT_PATH_I)/$(LSP_PP2_DEV_DIR)\
+                   -I$(PLAT_PATH_I)/$(LSP_EPON_CORE_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_CORE_DIR) \
+                   -I$(PLAT_PATH_I)/$(LSP_EPON_PERF_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PERF_DIR) \
+                   -I$(PLAT_PATH_I)/$(LSP_EPON_PLAT_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PLAT_DIR) \
+                   -I$(PLAT_PATH_I)/$(LSP_PON_PLAT_DIR)  -I$(PLAT_PATH_I)/$(LSP_PON_PERF_DIR)
 
 EXTRA_INCLUDE    = $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH) $(ALP_FAM_PATH) \
                    $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 7474515..3f32e94c 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -595,6 +595,8 @@ source arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
 
 source arch/arm/plat-armada/mv_drivers_lsp/mv_tsu/Kconfig
 
+source arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
+
 config  SCSI_MVSATA
 	tristate "Support for Marvell Sata Adapters"
 	depends on ( MV_INCLUDE_INTEG_SATA && SCSI ) || ( PCI && SCSI )
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
new file mode 100755
index 0000000..66fd9ed
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
@@ -0,0 +1,123 @@
+menu "SoC PON support"
+depends on MV_INCLUDE_PON
+
+config PON_Z1
+	bool "Support for PON Z1 Driver"
+	default n
+	---help---
+      Whether support PON Z1 version
+
+config PON_A0
+	bool "Support for PON A0 Driver"
+	default y
+	---help---
+      Whether support PON A0 version
+
+config PON_FPGA
+	bool "Support for PON Driver for FPGA"
+	default n
+	---help---
+      Whether support PON FPGA version
+
+config  MV_GPON
+	bool "Support for Marvell GPON Driver"
+	depends on MV_INCLUDE_PON
+	default y
+	---help---
+      Whether support GPON driver
+
+config  MV_EPON
+	bool "Support for Marvell EPON Driver"
+	depends on MV_INCLUDE_PON
+	default y
+	---help---
+      Whether support EPON driver
+
+comment "GPON Driver Options"
+depends on MV_GPON
+
+config MV_PON_TCONTS
+	int "GPON maximum T-CONT's number"
+	default 10
+	---help---
+      The maximum T-CONT's number
+
+config  MV_GPON_HW_INTERRUPT
+	bool "Support for GPON HW Interrupt"
+	depends on MV_GPON
+	default y
+	---help---
+      Whether support GPON HW Interrupt
+
+config  MV_GPON_DEBUG_PRINT
+	bool "Support for GPON Debug printing"
+	depends on MV_GPON
+	default y
+	---help---
+      Whether support GPON Debug printing
+
+config  MV_GPON_STATIC_GEM_PORT
+	bool "Support for GPON Static Gem Port"
+	depends on MV_GPON
+	default y
+	---help---
+      Whether support GPON statistic for Gem Port
+
+config  MV_GPON_PERFORMANCE_CHECK
+	bool "Support for GPON Performance Validation"
+	depends on MV_GPON
+	default n
+	---help---
+      Whether support GPON performance validation
+
+comment "EPON Driver Options"
+depends on MV_EPON
+
+config MV_EPON_LLID
+	int "EPON maximum LLID number"
+	default 1
+	---help---
+      EPON maximum LLID number
+
+config  MV_EPON_HW_INTERRUPT
+	bool "Support for EPON HW Interrupt"
+	depends on MV_EPON
+	default y
+	---help---
+      Whether support EPON HW Interrupt
+
+config  MV_EPON_DBA_LOW_RATE_VALUE
+	int "DBA report low rate value (Bytes)"
+	depends on MV_EPON
+	default 2000
+	---help---
+      Default EPON DBA additional report value in unit of bytes
+
+config  MV_EPON_DBA_LOW_RATE_THRESHOLD
+	int "DBA report low rate threshold (msec)"
+	depends on MV_EPON
+	default 20
+	---help---
+      Default EPON DBA additional report threshold in unit of msec
+
+config  MV_EPON_DBA_LOW_RATE_CONST_VALUE
+	int "DBA report low rate const value (Bytes)"
+	depends on MV_EPON
+	default 256
+	---help---
+      Default EPON DBA low rate const value in unit of bytes
+
+config  MV_EPON_DBA_HIGH_RATE_THRESHOLD
+	int "DBA report high rate threshold (msec)"
+	depends on MV_EPON
+	default 8192
+	---help---
+      Default EPON DBA high rate const value in unit of msec
+
+config  MV_EPON_DBA_HIGH_RATE_VALUE
+	int "DBA report high rate value (Bytes)"
+	depends on MV_EPON
+	default 2000
+	---help---
+      Default EPON DBA high rate const value in unit of bytes
+endmenu
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile
new file mode 100755
index 0000000..0e14468
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile
@@ -0,0 +1,50 @@
+#
+# Makefile for the Marvell PON driver
+#
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+###ifdef CONFIG_MV_HAL_RULES_PATH
+###include $(srctree)/include/config/auto.conf
+###include $(srctree)/$(subst ",,$(CONFIG_MV_HAL_RULES_PATH))
+###endif
+
+PON_OBJ += plat/ponOnuBoard.o \
+	plat/ponOnuLnxKsOs.o \
+	perf/ponOnuLnxKsMI.o
+
+GPON_OBJS += core/gpon/gponOnuAlloc.o \
+	core/gpon/gponCustomerApi.o \
+	core/gpon/gponOnuAlrm.o \
+	core/gpon/gponOnuApi.o \
+	core/gpon/gponOnuBer.o \
+	core/gpon/gponOnuDb.o \
+	core/gpon/gponOnuInit.o \
+	core/gpon/gponOnuIsr.o \
+	core/gpon/gponOnuMngr.o \
+	core/gpon/gponOnuMngrStateMachine.o \
+	core/gpon/gponOnuPm.o \
+	core/gpon/gponOnuSrvc.o \
+	perf/gpon/gponOnuLnxKsUI.o \
+	perf/gpon/gponOnuLnxKsMI.o \
+	plat/gpon/gponOnuBoard.o \
+	plat/gpon/gponOnuLnxKsOs.o
+
+EPON_OBJS += core/epon/eponOnuAlrm.o \
+	core/epon/eponCustomerApi.o \
+	core/epon/eponOnuApi.o \
+	core/epon/eponOnuDb.o \
+	core/epon/eponOnuInit.o \
+	core/epon/eponOnuIsr.o \
+	core/epon/eponOnuMngr.o \
+	core/epon/eponOnuPm.o \
+	perf/epon/eponOnuLnxKsUI.o \
+	perf/epon/eponOnuLnxKsMI.o \
+	plat/epon/eponOnuBoard.o \
+	plat/epon/eponOnuLnxKsOs.o
+
+obj-$(CONFIG_MV_INCLUDE_PON) += mv_pon.o
+mv_pon-y := $(PON_OBJ)
+mv_pon-$(CONFIG_MV_GPON) += $(GPON_OBJS)
+mv_pon-$(CONFIG_MV_EPON) += $(EPON_OBJS)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.c
new file mode 100644
index 0000000..00a153e9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.c
@@ -0,0 +1,464 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponCustomerApi.c                                          **
+**                                                                           **
+*******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponCustomerApi.h"
+#include "mvTypes.h"
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include "eponOnuLnxKsMI.h"
+#include "eponOnuPm.h"
+#include "ponOnuLnxKsOs.h"
+#include "eponOnuStd.h"
+#include "eponOnuApi.h"
+#include "eponOnuDb.h"
+#include "eponOnuLnxKsUI.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_mac
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets MAC address for llid port on ONU.
+**
+**  INPUT      : unsigned short llid: LLID. If multiple llid is not supported,
+**                                    this parameter could be ignored.
+**               unsigned char *mac : MAC address assigned for llid port.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_mac(unsigned short llid, unsigned char *mac)
+{
+	int ret = 0;
+
+	ret = mvEponApiMacAddrSet(llid, mac);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mac
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets MAC address of llid port on ONU.
+**
+**  INPUT      : unsigned short llid: LLID. If multiple llid is not supported,
+**                                    this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char *mac : MAC address assigned for llid port.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mac(unsigned short llid, unsigned char *mac)
+{
+	int ret = 0;
+
+	ret = mvEponApiMacAddrGet(llid, mac);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_fec
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the FEC for llid port(both upstream and downstream).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**               unsigned char enable: Enable or disable FEC.
+**                                     0 - Disable FEC.
+**                                     1 - Enable FEC.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_fec(unsigned short llid, unsigned char enable)
+{
+	int ret = 0;
+
+	ret = mvEponApiFecPerLlidSet(llid, enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_fec
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the FEC configuration of llid port
+**               (both upstream and downstream).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char enable: Enable or disable FEC.
+**                                     0 - Disable FEC.
+**                                     1 - Enable FEC.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_fec(unsigned short llid, unsigned char *enable)
+{
+	int ret = 0;
+
+	ret = mvEponApiFecPerLlidGet(llid, enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_ponsend
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets transmit of PON port
+**
+**  INPUT      : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_ponsend(unsigned char enable)
+{
+	int ret = 0;
+
+	if (enable == 0)
+		ret = onuEponApiOpticalTxEnableSet(MV_FALSE);
+	else if (enable == 1)
+		ret = onuEponApiOpticalTxEnableSet(MV_TRUE);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_ponrcv
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets receive of PON port
+**
+**  INPUT      : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable receive.
+**                                     1 - Enable receive.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_ponrcv(unsigned char enable)
+{
+	int ret = 0;
+
+	if (enable == 0)
+		ret = onuEponApiOpticalRxEnableSet(MV_FALSE);
+	else if (enable == 1)
+		ret = onuEponApiOpticalRxEnableSet(MV_TRUE);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_chipver
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the chip ID information.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_CHIP_VER *ver: Chip ID information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_chipver(MRVL_CHIP_VER *ver)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mngstate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets current management state of ONU
+**               (including OAM and MPCP).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char *oamstate : Standard OAM negotiation state.
+**                                         0 - Successful.
+**                                         1 - Not successful.
+**               unsigned char *mpcpstate: MPCP negotiation state.
+**                                         0 - Successful.
+**                                         1 - Not successful.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mngstate(unsigned short llid, unsigned char *oamstate,
+			       unsigned char *mpcpstate)
+{
+	int ret = 0;
+
+	/* The oam state should be maintained by user space,
+	   User space program should get this state by itself.
+	   Do PON driver need to retrieve this information
+	   from user space? */
+
+	/* Get mpcp state from DB */
+	*mpcpstate = onuEponDbOnuStateGet(llid);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_ponstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of PON port.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_PON_STAT *stat: Statistic information of PON port.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_ponstat(MRVL_PON_STAT *stat)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_oamstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets OAM statistic information.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_PON_STAT *stat: OAM statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_oamstat(MRVL_OAM_STAT *stat)
+{
+	int ret = 0;
+
+	/* The oam state should be maintained by user space,
+	   User space program should get this state by itself.
+	   Do PON driver need to retrieve this information
+	   from user space? */
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mpcpstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets MPCP statistic information.
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : MRVL_MPCP_STAT *stat: MPCP statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mpcpstat(unsigned short llid, MRVL_MPCP_STAT *stat)
+{
+	int ret = 0;
+	S_EponIoctlRxPm rxPm;
+	S_EponIoctlTxPm txPm;
+	S_EponIoctlSwPm swPm;
+
+	ret = onuEponApiRxPmGet(&rxPm, MV_TRUE, llid);
+	ret |= onuEponApiTxPmGet(&txPm, MV_TRUE, llid);
+
+	onuEponApiSwPmGet(&swPm, infoEponCntReadClearInd, llid);
+
+	stat->txRegAck     = txPm.ctrlRegAckFramesCnt;
+	stat->txRegRequest = txPm.ctrlRegReqFramesCnt;
+	stat->txReport     = txPm.reportFramesCnt;
+	stat->rxGate       = rxPm.gateFramesCnt;
+	stat->rxRegister   = swPm.swRxCnt[TOTAL_MPCP_REGISTER_ACK_CNT];
+	stat->macCtrlFramesTx = swPm.swTxCnt[TOTAL_MPCP_TX_FRAME_CNT];
+	stat->macCtrlFramesRx = rxPm.ctrlFramesCnt;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_holdover
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets optical link holdover.
+**
+**  INPUT      : unsigned char enable: Enable or disable optical link holdover.
+**                                     0 - Disable optical link holdover.
+**                                     1 - Enable optical link holdover.
+**               unsigned int time   : Holdover time, measured by ms.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_holdover(unsigned char enable, unsigned int time)
+{
+	int ret = 0;
+
+	ret = onuEponApiHoldoverSet(enable, time);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_holdover
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets optical link holdover configuration.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : unsigned char *enable: Enable or disable optical link holdover.
+**                                     0 - Disable optical link holdover.
+**                                     1 - Enable optical link holdover.
+**               unsigned int *time   : Holdover time, measured by ms.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_holdover(unsigned char *enable, unsigned int *time)
+{
+	int ret = 0;
+
+	ret = onuEponApiHoldoverGet(enable, time);
+
+	return ret;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.h
new file mode 100644
index 0000000..a3dca00
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponCustomerApi.h
@@ -0,0 +1,411 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponCustomerApi.h                                          **
+**                                                                           **
+*******************************************************************************/
+#ifndef EPON_CUSTOMER_API_H
+#define EPON_CUSTOMER_API_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct MRVL_CHIP_VER_T {
+	unsigned short vendorid;
+	unsigned short model;
+	unsigned short revision;
+	unsigned int date;
+} MRVL_CHIP_VER;
+
+typedef struct MRVL_PON_STAT_T {
+	unsigned long long rxDrops;             /*The number of downstream packets which have been dropped*/
+	unsigned long long txDrops;             /*The number of upstream packets which have been dropped*/
+	unsigned long long rxOctets;            /*The number of downstream bytes*/
+	unsigned long long txOctets;            /*The number of upstream bytes*/
+	unsigned long long rxPackets;           /*The number of downstream packets*/
+	unsigned long long txPackets;           /*The number of upstream packets*/
+	unsigned long long rxUniPackets;        /*The number of downstream unicast packets*/
+	unsigned long long txUniPackets;        /*The number of upstream unicast packets*/
+	unsigned long long rxBroadcasts;        /*The number of downstream broadcast packets*/
+	unsigned long long txBroadcasts;        /*The number of upstream broadcast packets*/
+	unsigned long long rxMulticasts;        /*The number of downstream multicast packets*/
+	unsigned long long txMulticasts;        /*The number of upstream multicast packets*/
+	unsigned long long rxCRCerrors;         /*The number of downstream packets with CRC error*/
+	unsigned long long txCRCerrors;         /*The number of upstream packets with CRC error*/
+	unsigned long long rxUndersizes;        /*The number of downstream undersize packets */
+	unsigned long long txUndersizes;        /*The number of upstream undersize packets*/
+	unsigned long long rxOversizes;         /*The number of downstream oversize packets*/
+	unsigned long long txOversizes;         /*The number of upstream oversize packets*/
+	unsigned long long rxFragments;         /*The number of downstream fragments*/
+	unsigned long long txFragments;         /*The number of upstream fragments*/
+	unsigned long long rxJabbers;           /*The number of upstream Jabbers*/
+	unsigned long long txJabbers;           /*The number of upstream Jabbers*/
+	unsigned long long rx64s;               /*The number of downstream packets with length of 64 bytes*/
+	unsigned long long tx64s;               /*The number of upstream packets with length of 64 btyes*/
+	unsigned long long rx65to127s;          /*The number of downstream packets with length from 65 to 127 bytes*/
+	unsigned long long tx65to127s;          /*The number of upstream packets with length from 65 to 127 bytes*/
+	unsigned long long rx128to255s;         /*The number of downstream packets with length from 128 to 255 bytes*/
+	unsigned long long tx128to255s;         /*The number of upstream packets with length from 128 to 255 bytes*/
+	unsigned long long rx256to511s;         /*The number of downstream packets with length from 256 to 511 bytes*/
+	unsigned long long tx256to511s;         /*The number of upstream packets with length from 256 to 511 bytes*/
+	unsigned long long rx512to1023s;        /*The number of downstream packets with length from 512 to 1023 bytes*/
+	unsigned long long tx512to1023s;        /*The number of upstream packets with length from 512 to 1023 bytes*/
+	unsigned long long rx1024to1518s;       /*The number of downstream packets with length from 1024 to 1518 bytes*/
+	unsigned long long tx1024to1518s;       /*The number of upstream packets with length from 1024 to 1518 bytes*/
+	unsigned long long rxDiscards;          /*The number of downstream packets which have been discarded*/
+	unsigned long long txDiscards;          /*The number of upstream packets which have been discarded*/
+	unsigned long long rxErrors;            /*The number of downstream error packets*/
+	unsigned long long txErrors;            /*The number of upstream error packets*/
+	unsigned long long fecCorrects;         /*The number of FEC correct packets*/
+	unsigned long long fecUncorrects;       /*The number of FEC uncorrect packets*/
+} MRVL_PON_STAT;
+
+typedef struct MRVL_OAM_STAT_T {
+	unsigned long long unsuptCodesRx;       /* Received unsupported opcode packets counter */
+	unsigned long long orgSpecificTx;       /* Extended OAM */
+	unsigned long long orgSpecifiicRx;
+	unsigned long long informationTx;       /* Standard OAM */
+	unsigned long long informationRx;
+} MRVL_OAM_STAT;
+
+typedef struct MRVL_MPCP_STAT_T {
+	unsigned long long txRegAck;
+	unsigned long long txRegRequest;
+	unsigned long long txReport;
+	unsigned long long rxGate;
+	unsigned long long rxRegister;
+	unsigned long long macCtrlFramesTx;
+	unsigned long long macCtrlFramesRx;
+} MRVL_MPCP_STAT;
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_mac
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets MAC address for llid port on ONU.
+**
+**  INPUT      : unsigned short llid: LLID. If multiple llid is not supported,
+**                                    this parameter could be ignored.
+**               unsigned char *mac : MAC address assigned for llid port.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_mac(unsigned short llid, unsigned char *mac);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mac
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets MAC address of llid port on ONU.
+**
+**  INPUT      : unsigned short llid: LLID. If multiple llid is not supported,
+**                                    this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char *mac : MAC address assigned for llid port.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mac(unsigned short llid, unsigned char *mac);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_fec
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the FEC for llid port(both upstream and downstream).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**               unsigned char enable: Enable or disable FEC.
+**                                     0 - Disable FEC.
+**                                     1 - Enable FEC.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_fec(unsigned short llid, unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_fec
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the FEC configuration of llid port
+**               (both upstream and downstream).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char enable: Enable or disable FEC.
+**                                     0 - Disable FEC.
+**                                     1 - Enable FEC.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_fec(unsigned short llid, unsigned char *enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_ponsend
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets transmit of PON port
+**
+**  INPUT      : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_ponsend(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_ponrcv
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets receive of PON port
+**
+**  INPUT      : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable receive.
+**                                     1 - Enable receive.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_ponrcv(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_chipver
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the chip ID information.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_CHIP_VER *ver: Chip ID information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_chipver(MRVL_CHIP_VER *ver);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mngstate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets current management state of ONU
+**               (including OAM and MPCP).
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : unsigned char *oamstate : Standard OAM negotiation state.
+**                                         0 - Successful.
+**                                         1 - Not successful.
+**               unsigned char *mpcpstate: MPCP negotiation state.
+**                                         0 - Successful.
+**                                         1 - Not successful.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mngstate(unsigned short llid, unsigned char *oamstate,
+			       unsigned char *mpcpstate);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_ponstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of PON port.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_PON_STAT *stat: Statistic information of PON port.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_ponstat(MRVL_PON_STAT *stat);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_oamstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets OAM statistic information.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : MRVL_PON_STAT *stat: OAM statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_oamstat(MRVL_OAM_STAT *stat);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_mpcpstat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets MPCP statistic information.
+**
+**  INPUT      : unsigned short llid : LLID. If multiple llid is not supported,
+**                                     this parameter could be ignored.
+**
+**  OUTPUTS    : MRVL_MPCP_STAT *stat: MPCP statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_mpcpstat(unsigned short llid, MRVL_MPCP_STAT *stat);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_set_holdover
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets optical link holdover.
+**
+**  INPUT      : unsigned char enable: Enable or disable optical link holdover.
+**                                     0 - Disable optical link holdover.
+**                                     1 - Enable optical link holdover.
+**               unsigned int time   : Holdover time, measured by ms.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_set_holdover(unsigned char enable, unsigned int time);
+
+/*******************************************************************************
+**
+**  mrvl_api_epon_get_holdover
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets optical link holdover configuration.
+**
+**  INPUT      : None.
+**
+**  OUTPUTS    : unsigned char *enable: Enable or disable optical link holdover.
+**                                     0 - Disable optical link holdover.
+**                                     1 - Enable optical link holdover.
+**               unsigned int *time   : Holdover time, measured by ms.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_epon_get_holdover(unsigned char *enable, unsigned int *time);
+
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuAlrm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuAlrm.c
new file mode 100644
index 0000000..90f6f91
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuAlrm.c
@@ -0,0 +1,242 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuAlrm.c                                             **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON Alarm and Statistics        **/
+/**                functionality                                             **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuAlrm.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 onuEponPreviousAlarm = 0;
+MV_U32 onuEponCurrentAlarm  = 0;
+MV_U32 onuEponLosAlarm      = 0;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Alarm Section                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponAlarmProcess
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function process the current alarm state and notify screen
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponAlarmProcess(void)
+{
+	MV_U32 onuEponPreviousAlarmState;
+	MV_U32 onuEponCurrentAlarmState;
+	MV_U32 onuEponChangeAlarm;
+
+	/* get the ASIC prvious alarm status */
+	onuEponPreviousAlarmState = onuEponPreviousAlarm;
+
+	/* get the ASIC current alarm status */
+	onuEponCurrentAlarmState = onuEponCurrentAlarm;
+
+	/* Init PON los alarm */
+	onuEponLosAlarm = 0;
+
+	/* alarm changed */
+	if ((onuEponCurrentAlarmState ^ onuEponPreviousAlarmState) != 0) {
+		onuEponChangeAlarm = (onuEponCurrentAlarmState ^ onuEponPreviousAlarmState);
+
+		if ((onuEponChangeAlarm & onuEponCurrentAlarmState) != 0) {
+			if (onuEponChangeAlarm & ONU_EPON_XVR_SD_MASK) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === XVR SD Off ===\n\r", __FILE_DESC__, __LINE__);
+				onuEponLosAlarm |= 0x01;
+			}
+
+			if (onuEponChangeAlarm & ONU_EPON_SERDES_SD_MASK) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === SERDES SD Off ===\n\r", __FILE_DESC__, __LINE__);
+				onuEponLosAlarm |= 0x02;
+			}
+		} else {
+			if (onuEponChangeAlarm & ONU_EPON_XVR_SD_MASK) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === XVR SD On ===\n\r", __FILE_DESC__, __LINE__);
+				onuEponLosAlarm |= 0x01 << 8;
+			}
+
+			if (onuEponChangeAlarm & ONU_EPON_SERDES_SD_MASK) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === SERDES SD On ===\n\r", __FILE_DESC__, __LINE__);
+				onuEponLosAlarm |= 0x02 << 8;
+			}
+		}
+
+		onuEponPreviousAlarm = onuEponCurrentAlarmState;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponAlarmSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu epon alarm
+**
+**  PARAMETERS:  MV_U32  alarm
+**               MV_BOOL status
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponAlarmSet(MV_U32 alarm, MV_BOOL state)
+{
+	if ((alarm & ONU_EPON_ALARM_MASK) == 0) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALARM_MODULE,
+			   "ERROR: (%s:%d) invalid alarm(%d) type\n\r", __FILE_DESC__, __LINE__, alarm);
+		return MV_ERROR;
+	}
+
+	if (state == MV_FALSE)
+		onuEponCurrentAlarm &= ~(alarm);
+	else
+		onuEponCurrentAlarm |=  (alarm);
+
+	onuEponAlarmProcess();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponAlarmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return current alarm status
+**
+**  PARAMETERS:  MV_U32 *alarm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponAlarmGet(MV_U32 *alarm)
+{
+	alarm[0] = ((onuEponCurrentAlarm & ONU_EPON_XVR_SD_MASK)    != 0) ? (1) : (0);
+	alarm[1] = ((onuEponCurrentAlarm & ONU_EPON_SERDES_SD_MASK) != 0) ? (1) : (0);
+}
+
+/*******************************************************************************
+**
+**  onuEponLosAlarmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return current PON los alarm status
+**
+**  PARAMETERS:  MV_U32 *alarm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponLosAlarmGet(MV_U32 *alarm)
+{
+	*alarm = onuEponLosAlarm;
+
+	/* Set PON los alarm to default value */
+	/* onuEponLosAlarm = 0; */
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.c
new file mode 100644
index 0000000..d153f19
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.c
@@ -0,0 +1,1878 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuApi.c                                              **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON API functionality           **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+#include "mv_netdev.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuApi.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_EponPm g_OnuEponOutPm[EPON_MAX_MAC_NUM];
+struct mv_eth_ext_mac_ops epon_mac_ops;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuEponApiStatusNotifyRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register status callback function
+**
+**  PARAMETERS:  STATUSNOTIFYFUNC notifyCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiStatusNotifyRegister(STATUSNOTIFYFUNC notifyCallBack)
+{
+	MV_STATUS status;
+
+	status = onuEponDbStatusNotifySet(notifyCallBack);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) ponOnuApiStatusNotifyRegister", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponStatusNotify
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function notify EPON status to user space
+**
+**  PARAMETERS:  MV_U32 status
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponStatusNotify(MV_U32 status)
+{
+	STATUSNOTIFYFUNC statusFunc = NULL;
+
+	/* Send signal to management layer */
+	statusFunc = onuEponDbStatusNotifyGet();
+	if (statusFunc != NULL)
+		statusFunc(status);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiInformationGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu info
+**
+**  PARAMETERS:  S_IoctlInfo *onuInfo
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiInformationGet(S_EponIoctlInfo *onuInfo, MV_U32 macId)
+{
+	MV_U32 addressLow;
+	MV_U32 addressHigh;
+
+	onuInfo->onuEponState        = onuEponDbOnuStateGet(macId);
+	onuInfo->onuEponPortState    = onuEponDbOnuEponPortStateGet();
+	onuInfo->onuEponCtrlType     = onuEponDbOnuCtrlTypeGet();
+	onuInfo->onuEponSignalDetect = onuEponDbOnuSignalDetectGet();
+	onuInfo->onuEponDsSyncOkPcs  = onuEponDbOnuDsSyncOkPcsGet();
+	onuInfo->onuEponMode         = onuEponDbModeGet();
+	onuInfo->onuEponDbaMode      = onuEponDbOnuDbaModeGet();
+
+	onuEponDbOnuMacAddrGet(&addressLow, &addressHigh, macId);
+	onuInfo->onuEponMacAddr[5] = ((addressLow  >>  0) & 0xFF);
+	onuInfo->onuEponMacAddr[4] = ((addressLow  >>  8) & 0xFF);
+	onuInfo->onuEponMacAddr[3] = ((addressLow  >> 16) & 0xFF);
+	onuInfo->onuEponMacAddr[2] = ((addressLow  >> 24) & 0xFF);
+	onuInfo->onuEponMacAddr[1] = ((addressHigh >>  0) & 0xFF);
+	onuInfo->onuEponMacAddr[0] = ((addressHigh >>  8) & 0xFF);
+
+	onuEponDbOnuBcastAddrGet(&addressLow, &addressHigh);
+	onuInfo->onuEponBcastAddr[5] = ((addressLow  >>  0) & 0xFF);
+	onuInfo->onuEponBcastAddr[4] = ((addressLow  >>  8) & 0xFF);
+	onuInfo->onuEponBcastAddr[3] = ((addressLow  >> 16) & 0xFF);
+	onuInfo->onuEponBcastAddr[2] = ((addressLow  >> 24) & 0xFF);
+	onuInfo->onuEponBcastAddr[1] = ((addressHigh >>  0) & 0xFF);
+	onuInfo->onuEponBcastAddr[0] = ((addressHigh >>  8) & 0xFF);
+
+	onuEponDbPktRxLlidGet(&(onuInfo->onuEponRxLLID), macId);
+	onuEponDbPktTxLlidGet(&(onuInfo->onuEponTxLLID), macId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiLinkStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu link state
+**
+**  PARAMETERS:  MV_U32 *linkState
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiLinkStateGet(MV_U32 *linkState, MV_U32 macId)
+{
+	if (onuEponDbOnuStateGet(macId) == ONU_EPON_03_OPERATION)
+		*linkState = 1;
+	else
+		*linkState = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiFecConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu FEC
+**
+**  PARAMETERS:  MV_U32 rxGenFecEn
+**               MV_U32 txGenFecEn
+**               MV_U32 txMacFecEn[8]
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiFecConfig(MV_U32 rxGenFecEn, MV_U32 txGenFecEn, MV_U32 *txMacFecEn, MV_U32 source)
+{
+	MV_STATUS status;
+	MV_U32 regReqAutoRes;
+	MV_U32 regAckAutoRes;
+	MV_U32 reportAutoRes;
+	MV_U32 rxGenFecEnTemp;
+	MV_U32 txGenFecEnTemp;
+	MV_U32 txMacFecEnTemp;
+	MV_U32 llidIndex;
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuEponApiFecConfig, input rxGenFecEn(%d), txGenFecEn(%d),txMacFecEn(%d,%d,%d,%d,%d,%d,%d,%d)",
+		   __FILE_DESC__, __LINE__, rxGenFecEn, txGenFecEn, txMacFecEn[0], txMacFecEn[1], txMacFecEn[2], txMacFecEn[3],
+		   txMacFecEn[4], txMacFecEn[5], txMacFecEn[6], txMacFecEn[7]);
+
+	onuEponDbOnuCfgGet(&regReqAutoRes, &regAckAutoRes, &reportAutoRes, &rxGenFecEnTemp, &txGenFecEnTemp, &txMacFecEnTemp);
+	rxGenFecEnTemp = rxGenFecEn;
+	txGenFecEnTemp = txGenFecEn;
+	txMacFecEnTemp = ((txMacFecEn[0] & 0x1) << 0) |
+			 ((txMacFecEn[1] & 0x1) << 1) |
+			 ((txMacFecEn[2] & 0x1) << 2) |
+			 ((txMacFecEn[3] & 0x1) << 3) |
+			 ((txMacFecEn[4] & 0x1) << 4) |
+			 ((txMacFecEn[5] & 0x1) << 5) |
+			 ((txMacFecEn[6] & 0x1) << 6) |
+			 ((txMacFecEn[7] & 0x1) << 7);
+
+	if (source == ONU_FEC_CFG_INIT) {
+		onuEponDbOnuCfgSet(regReqAutoRes, regAckAutoRes, reportAutoRes, rxGenFecEnTemp, txGenFecEnTemp, txMacFecEnTemp);
+		onuEponDbOnuRxFecCfgSet(rxGenFecEn);
+	}
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuEponApiFecConfig, config regReqAutoRes(%d), regAckAutoRes(%d), reportAutoRes(%d), rxGenFecEnTemp(%d), txGenFecEnTemp(%d), txMacFecEnTemp(%d)\n",
+		   __FILE_DESC__, __LINE__, regReqAutoRes, regAckAutoRes, reportAutoRes, rxGenFecEnTemp, txGenFecEnTemp, txMacFecEnTemp);
+
+	status = mvOnuEponMacGenOnuConfigSet(rxGenFecEnTemp, txGenFecEnTemp, reportAutoRes, regAckAutoRes, regReqAutoRes, txMacFecEnTemp);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (rxGenFecEn) {
+		status = mvOnuEponMacPcsDelaySet(0x1058);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	} else {
+		status = mvOnuEponMacPcsDelaySet(0x1C58);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+
+	if ((txGenFecEn != 0) || (txMacFecEnTemp != 0)) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, Set FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_ENABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		mv_eth_ctrl_tx_cmd_gem_oem(PPV2_PON_PORT_INDEX, PPV2_PON_FEC_TX_DESC_SET);
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			if (txMacFecEnTemp & (1 << llidIndex)) {
+				status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+
+				status = mvOnuEponMacPPv2DbaPostFecSet(PPV2_DBA_POST_FEC_OVERHEAD);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+			}
+		}
+	} else {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, reset FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_DISABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		mv_eth_ctrl_tx_cmd_gem_oem(PPV2_PON_PORT_INDEX, PPV2_PON_FEC_TX_DESC_CLR);
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+
+			status = mvOnuEponMacPPv2DbaPostFecSet(0);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiFecReConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function re-configure onu FEC
+**
+**  PARAMETERS:  MV_U32 rxGenFecEn
+**               MV_U32 txGenFecEn
+**               MV_U32 txMacFecEn[8]
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiFecReConfig(void)
+{
+	MV_STATUS status;
+	MV_U32 regReqAutoRes;
+	MV_U32 regAckAutoRes;
+	MV_U32 reportAutoRes;
+	MV_U32 rxGenFecEn;
+	MV_U32 txGenFecEn;
+	MV_U32 txMacFecEn;
+	MV_U32 llidIndex;
+
+	onuEponDbOnuCfgGet(&regReqAutoRes, &regAckAutoRes, &reportAutoRes, &rxGenFecEn, &txGenFecEn, &txMacFecEn);
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuEponApiFecReConfig, regReqAutoRes(%d), regAckAutoRes(%d), reportAutoRes(%d), rxGenFecEn(%d), txGenFecEn(%d), txMacFecEn(0x%x)\n",
+		   __FILE_DESC__, __LINE__, regReqAutoRes, regAckAutoRes, reportAutoRes, rxGenFecEn, txGenFecEn, txMacFecEn);
+
+	status = mvOnuEponMacGenOnuConfigSet(rxGenFecEn, txGenFecEn, reportAutoRes, regAckAutoRes, regReqAutoRes, txMacFecEn);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (rxGenFecEn) {
+		status = mvOnuEponMacPcsDelaySet(0x1058);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	} else {
+		status = mvOnuEponMacPcsDelaySet(0x1C58);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+
+	if ((txGenFecEn != 0) || (txMacFecEn != 0)) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, Set FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_ENABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		mv_eth_ctrl_tx_cmd_gem_oem(PPV2_PON_PORT_INDEX, PPV2_PON_FEC_TX_DESC_SET);
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			if (txMacFecEn & (1 << llidIndex)) {
+				status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+
+				status = mvOnuEponMacPPv2DbaPostFecSet(PPV2_DBA_POST_FEC_OVERHEAD);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+			}
+		}
+	} else {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, Reset FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_DISABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		mv_eth_ctrl_tx_cmd_gem_oem(PPV2_PON_PORT_INDEX, PPV2_PON_FEC_TX_DESC_CLR);
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+
+			status = mvOnuEponMacPPv2DbaPostFecSet(0);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiEncryptionConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu Encryption
+**
+**  PARAMETERS:  MV_U32 onuEncryptCfg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiEncryptionConfig(MV_U32 onuEncryptCfg)
+{
+	MV_STATUS status;
+
+	status = mvOnuEponMacRxpEncConfigSet(onuEncryptCfg);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiEncryptionConfig", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiEncryptionKeyConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu Encryption Key
+**
+**  PARAMETERS:  MV_U32 encryptKey
+**               MV_U32 encryptKeyIndex
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiEncryptionKeyConfig(MV_U32 encryptKey, MV_U32 encryptKeyIndex, MV_U32 macId)
+{
+	MV_STATUS status;
+
+	status = mvOnuEponMacRxpEncKeySet(encryptKey, encryptKeyIndex, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiEncryptionKeyConfig", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiRxPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Rx counters
+**
+**  PARAMETERS:  S_EponIoctlRxPm *rxPm
+**               MV_BOOL         clear
+**               MV_U32          macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiRxPmGet(S_EponIoctlRxPm *rxPm,  MV_BOOL clear, MV_U32 macId)
+{
+	MV_STATUS status;
+	S_RxPm inCounters;
+
+	status = onuEponPmRxPmGet(&inCounters, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiRxPmGet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	rxPm->fcsErrorFramesCnt = inCounters.fcsErrorFramesCnt - g_OnuEponOutPm[macId].rx.fcsErrorFramesCnt;
+	rxPm->shortFramesCnt    = inCounters.shortFramesCnt    - g_OnuEponOutPm[macId].rx.shortFramesCnt;
+	rxPm->longFramesCnt     = inCounters.longFramesCnt     - g_OnuEponOutPm[macId].rx.longFramesCnt;
+	rxPm->dataFramesCnt     = inCounters.dataFramesCnt     - g_OnuEponOutPm[macId].rx.dataFramesCnt;
+	rxPm->ctrlFramesCnt     = inCounters.ctrlFramesCnt     - g_OnuEponOutPm[macId].rx.ctrlFramesCnt;
+	rxPm->reportFramesCnt   = inCounters.reportFramesCnt   - g_OnuEponOutPm[macId].rx.reportFramesCnt;
+	rxPm->gateFramesCnt     = inCounters.gateFramesCnt     - g_OnuEponOutPm[macId].rx.gateFramesCnt;
+
+	if (clear == MV_TRUE) {
+		g_OnuEponOutPm[macId].rx.fcsErrorFramesCnt = inCounters.fcsErrorFramesCnt;
+		g_OnuEponOutPm[macId].rx.shortFramesCnt    = inCounters.shortFramesCnt;
+		g_OnuEponOutPm[macId].rx.longFramesCnt     = inCounters.longFramesCnt;
+		g_OnuEponOutPm[macId].rx.dataFramesCnt     = inCounters.dataFramesCnt;
+		g_OnuEponOutPm[macId].rx.ctrlFramesCnt     = inCounters.ctrlFramesCnt;
+		g_OnuEponOutPm[macId].rx.reportFramesCnt   = inCounters.reportFramesCnt;
+		g_OnuEponOutPm[macId].rx.gateFramesCnt     = inCounters.gateFramesCnt;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiTxPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Tx counters
+**
+**  PARAMETERS:  S_EponIoctlTxPm *rxPm
+**               MV_BOOL         clear
+**               MV_U32          macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiTxPmGet(S_EponIoctlTxPm *txPm, MV_BOOL clear, MV_U32 macId)
+{
+	MV_STATUS status;
+	S_EponTxPm inCounters;
+
+	status = onuEponPmTxPmGet(&inCounters, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiTxPmGet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	txPm->ctrlRegReqFramesCnt = inCounters.ctrlRegReqFramesCnt - g_OnuEponOutPm[macId].tx.ctrlRegReqFramesCnt;
+	txPm->ctrlRegAckFramesCnt = inCounters.ctrlRegAckFramesCnt - g_OnuEponOutPm[macId].tx.ctrlRegAckFramesCnt;
+	txPm->reportFramesCnt     = inCounters.reportFramesCnt     - g_OnuEponOutPm[macId].tx.reportFramesCnt;
+	txPm->dataFramesCnt       = inCounters.dataFramesCnt       - g_OnuEponOutPm[macId].tx.dataFramesCnt;
+	txPm->txAllowedBytesCnt   = inCounters.txAllowedBytesCnt   - g_OnuEponOutPm[macId].tx.txAllowedBytesCnt;
+
+	if (clear == MV_TRUE) {
+		g_OnuEponOutPm[macId].tx.ctrlRegReqFramesCnt = inCounters.ctrlRegReqFramesCnt;
+		g_OnuEponOutPm[macId].tx.ctrlRegAckFramesCnt = inCounters.ctrlRegAckFramesCnt;
+		g_OnuEponOutPm[macId].tx.reportFramesCnt     = inCounters.reportFramesCnt;
+		g_OnuEponOutPm[macId].tx.dataFramesCnt       = inCounters.dataFramesCnt;
+		g_OnuEponOutPm[macId].tx.txAllowedBytesCnt   = inCounters.txAllowedBytesCnt;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiSwPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               SW counters
+**
+**  PARAMETERS:  S_EponIoctlSwPm *swPm
+**               MV_BOOL         clear
+**               MV_U32          macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiSwPmGet(S_EponIoctlSwPm *swPm, MV_BOOL clear, MV_U32 macId)
+{
+	MV_STATUS status;
+	S_SwPm inCounters;
+	MV_U32 index;
+
+	status = onuEponPmSwPmGet(&inCounters, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiSwPmGet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	for (index = 0; index < MAX_EPON_RX_SW_CNT; index++)
+		swPm->swRxCnt[index] = inCounters.swRxCnt[index] - g_OnuEponOutPm[macId].sw.swRxCnt[index];
+
+	for (index = 0; index < MAX_EPON_TX_SW_CNT; index++)
+		swPm->swTxCnt[index] = inCounters.swTxCnt[index] - g_OnuEponOutPm[macId].sw.swTxCnt[index];
+
+	if (clear == MV_TRUE) {
+		for (index = 0; index < MAX_EPON_RX_SW_CNT; index++)
+			g_OnuEponOutPm[macId].sw.swRxCnt[index] = inCounters.swRxCnt[index];
+
+		for (index = 0; index < MAX_EPON_TX_SW_CNT; index++)
+			g_OnuEponOutPm[macId].sw.swTxCnt[index] = inCounters.swTxCnt[index];
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiGpmPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Gpm counters
+**
+**  PARAMETERS:  S_EponIoctlGpmPm *rxPm
+**               MV_BOOL          clear
+**               MV_U32           macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiGpmPmGet(S_EponIoctlGpmPm *gpmPm, MV_BOOL clear, MV_U32 macId)
+{
+	MV_STATUS status;
+	S_GpmPm inCounters;
+
+	status = onuEponPmGpmPmGet(&inCounters, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiTxPmGet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	gpmPm->grantValidCnt                 = inCounters.grantValidCnt                 - g_OnuEponOutPm[macId].gpm.grantValidCnt;
+	gpmPm->grantMaxFutureTimeErrorCnt    = inCounters.grantMaxFutureTimeErrorCnt    - g_OnuEponOutPm[macId].gpm.grantMaxFutureTimeErrorCnt;
+	gpmPm->minProcTimeErrorCnt           = inCounters.minProcTimeErrorCnt           - g_OnuEponOutPm[macId].gpm.minProcTimeErrorCnt;
+	gpmPm->lengthErrorCnt                = inCounters.lengthErrorCnt                - g_OnuEponOutPm[macId].gpm.lengthErrorCnt;
+	gpmPm->discoveryAndRegCnt            = inCounters.discoveryAndRegCnt            - g_OnuEponOutPm[macId].gpm.discoveryAndRegCnt;
+	gpmPm->fifoFullErrorCnt              = inCounters.fifoFullErrorCnt              - g_OnuEponOutPm[macId].gpm.fifoFullErrorCnt;
+	gpmPm->opcDiscoveryNotRegBcastCnt    = inCounters.opcDiscoveryNotRegBcastCnt    - g_OnuEponOutPm[macId].gpm.opcDiscoveryNotRegBcastCnt;
+	gpmPm->opcRegisterNotDiscoveryCnt    = inCounters.opcRegisterNotDiscoveryCnt    - g_OnuEponOutPm[macId].gpm.opcRegisterNotDiscoveryCnt;
+	gpmPm->opcDiscoveryNotRegNotBcastCnt = inCounters.opcDiscoveryNotRegNotBcastCnt - g_OnuEponOutPm[macId].gpm.opcDiscoveryNotRegNotBcastCnt;
+	gpmPm->opcDropGrantCnt               = inCounters.opcDropGrantCnt               - g_OnuEponOutPm[macId].gpm.opcDropGrantCnt;
+	gpmPm->opcHiddenGrantCnt             = inCounters.opcHiddenGrantCnt             - g_OnuEponOutPm[macId].gpm.opcHiddenGrantCnt;
+	gpmPm->opcBackToBackCnt              = inCounters.opcBackToBackCnt              - g_OnuEponOutPm[macId].gpm.opcBackToBackCnt;
+
+	if (clear == MV_TRUE) {
+		g_OnuEponOutPm[macId].gpm.grantValidCnt                 = inCounters.grantValidCnt;
+		g_OnuEponOutPm[macId].gpm.grantMaxFutureTimeErrorCnt    = inCounters.grantMaxFutureTimeErrorCnt;
+		g_OnuEponOutPm[macId].gpm.minProcTimeErrorCnt           = inCounters.minProcTimeErrorCnt;
+		g_OnuEponOutPm[macId].gpm.lengthErrorCnt                = inCounters.lengthErrorCnt;
+		g_OnuEponOutPm[macId].gpm.discoveryAndRegCnt            = inCounters.discoveryAndRegCnt;
+		g_OnuEponOutPm[macId].gpm.fifoFullErrorCnt              = inCounters.fifoFullErrorCnt;
+		g_OnuEponOutPm[macId].gpm.opcDiscoveryNotRegBcastCnt    = inCounters.opcDiscoveryNotRegBcastCnt;
+		g_OnuEponOutPm[macId].gpm.opcRegisterNotDiscoveryCnt    = inCounters.opcRegisterNotDiscoveryCnt;
+		g_OnuEponOutPm[macId].gpm.opcDiscoveryNotRegNotBcastCnt = inCounters.opcDiscoveryNotRegNotBcastCnt;
+		g_OnuEponOutPm[macId].gpm.opcDropGrantCnt               = inCounters.opcDropGrantCnt;
+		g_OnuEponOutPm[macId].gpm.opcHiddenGrantCnt             = inCounters.opcHiddenGrantCnt;
+		g_OnuEponOutPm[macId].gpm.opcBackToBackCnt              = inCounters.opcBackToBackCnt;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiTransmitOamFrame
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function transmit OAM frame via FIFO
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *frame
+**               MV_U32              macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponApiTransmitOamFrame(S_OnuEponCtrlBuffer *frame, MV_U32 macId)
+{
+	MV_STATUS status;
+
+	if (onuEponDbOnuStateGet(0) != ONU_EPON_03_OPERATION) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiTransmitOamFrame, ONU not registered", __FILE_DESC__, __LINE__);
+		return MV_OK;
+	}
+
+	status = onuEponOamAllocMsg(frame, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponApiTransmitOamFrame", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiDgCallbackRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Dying Gasp callback function
+**
+**  PARAMETERS:  DYINGGASPFUNC dgCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiDgCallbackRegister(DYINGGASPFUNC dgCallBack)
+{
+	MV_STATUS status;
+
+	status = onuEponDbDgCallbackSet(dgCallBack);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuEponDbDgCallbackSet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiLinkStatusCallbackRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Link Status callback function
+**
+**  PARAMETERS:  LINKSTATUSFUNC linkStatusCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiLinkStatusCallbackRegister(void)
+{
+	struct mv_eth_ext_mac_ops *ptr_pon_mac_ops;
+	struct mv_netdev_notify_ops *ptr_netdev_ops;
+
+	epon_mac_ops.link_status_get = onuEponLinkIsUp;
+	epon_mac_ops.max_pkt_size_set = onuEponMtuCfg;
+	epon_mac_ops.mac_addr_set = onuEponOnuMacTblUpdate;
+	epon_mac_ops.mib_counters_show = NULL;
+	epon_mac_ops.port_disable = mvEponApiAdminDownSet;
+	epon_mac_ops.port_enable = mvEponApiAdminUpSet;
+
+	ptr_pon_mac_ops = &epon_mac_ops;
+
+	mv_eth_ext_mac_ops_register(MV_PON_LOGIC_PORT_GET(), &ptr_pon_mac_ops, &ptr_netdev_ops);
+
+	onuEponDb_s.onuEponGenTbl_s.onuLinkStatusCallback = ptr_netdev_ops->link_notify;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiAdminUpSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enables pon port
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiAdminUpSet(int port_id)
+{
+	MV_STATUS status;
+
+	/* Enable MAC RX */
+	status = mvOnuEponMacOnuRxEnableSet(ONU_RX_EN);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvEponApiAdminUpSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Enable MAC TX */
+	status = mvOnuEponMacOnuTxEnableSet(ONU_TX_EN, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvEponApiAdminUpSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* set onu to port state up */
+	onuEponDbOnuEponPortStateSet(ONU_PON_PORT_UP);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiAdminUpSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function disables pon port
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiAdminDownSet(int port_id)
+{
+	MV_STATUS status;
+
+	/* set onu to port state down */
+	onuEponDbOnuEponPortStateSet(ONU_PON_PORT_DOWN);
+
+	/* Enable MAC RX */
+	status = mvOnuEponMacOnuRxEnableSet(ONU_RX_DIS);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvEponApiAdminDownSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Enable MAC TX */
+	status = mvOnuEponMacOnuTxEnableSet(ONU_TX_DIS, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvEponApiAdminDownSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponLinkIsUp
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Link Status callback function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_BOOL onuEponLinkIsUp(int port_id)
+{
+	MV_U32 mode;
+
+	mode = onuEponDbModeGet();
+
+	if (onuEponForceTxDownStateGet(0) == MV_TRUE)
+		return MV_TRUE;
+
+	if (mode == E_EPON_IOCTL_STD_MODE) {
+		if (onuEponDbOnuStateGet(0) == ONU_EPON_03_OPERATION)
+			return MV_TRUE;
+		else
+			return MV_FALSE;
+	} else { /* P2P */
+		if (onuEponDbOnuSignalDetectGet() == 1) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+				   "DEBUG: (%s:%d) onuPonLinkIsUp, UP\n", __FILE_DESC__, __LINE__);
+			return MV_TRUE;
+		} else {
+			mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+				   "DEBUG: (%s:%d) onuPonLinkIsUp, DOWN\n", __FILE_DESC__, __LINE__);
+			return MV_FALSE;
+		}
+	}
+}
+
+/*******************************************************************************
+**
+**  mvEponApi2kSupportedSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets 2K byte packets supported on MC board
+**
+**  PARAMETERS:  pkt2kSupported - 2K byte enable or disable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApi2kSupportedSet(MV_U32 pkt2kSupported)
+{
+	MV_STATUS status = 0;
+	MV_U32 familyId;
+
+	familyId = mvCtrlModelGet();
+	if (familyId != MV_88F66X0)
+		return MV_OK;
+
+	/* status =  mvOnuEponMacPcsRxEnableSet(EPON_PCS_CONFIG_RX_DISABLE);*/
+	if (pkt2kSupported == 1) { /* 2K packet supported */
+		status |= mvOnuEponMacPcsFrameSizeLimitsSet(EPON_MAC_PCS_FRAME_SIZE_LIMIT_SIZE_2K_SUPP,
+							    EPON_MAC_PCS_FRAME_SIZE_LIMIT_LATENCY_2K_SUPP);
+		status |= mvOnuEponMacRxpDataFifoThresholdSet(EPON_MAC_RXP_DATA_FIFO_THRESHOLD_2K_SUPP);
+	} else if (pkt2kSupported == 0) {
+		status |= mvOnuEponMacPcsFrameSizeLimitsSet(EPON_MAC_PCS_FRAME_SIZE_LIMIT_SIZE_DEF,
+							    EPON_MAC_PCS_FRAME_SIZE_LIMIT_LATENCY_DEF);
+		status |= mvOnuEponMacRxpDataFifoThresholdSet(EPON_MAC_RXP_DATA_FIFO_THRESHOLD_DEF);
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiLosTimeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets time duration to expire for entering holdover
+**
+**  PARAMETERS:  opticalLosTime - time duration when no optical signal detected
+**               macLosTime     - time duration when no GATE MPCPDU received
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiLosTimeConfig(MV_U16 opticalLosTime, MV_U16 macLosTime)
+{
+	MV_STATUS status = MV_OK;
+
+	onuEponDbOnuOpticalLosTimeSet(opticalLosTime);
+	onuEponDbOnuMacLosTimeSet(macLosTime);
+
+	/* If the holdover timer is not active, we add the OpticalLosTimer to the holdover time and save */
+	if (onuPonResourceTbl_s.onuPonHoldoverTimerId.onuPonTimerActive == ONU_PON_TIMER_NOT_ACTIVE) {
+		/* Add the configured OptLosTime to holdover time and save for next holdover */
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonHoldoverTimerId), 0,
+				  onuEponDbOnuHoldoverTimeGet() + onuEponDbOnuOpticalLosTimeGet(), 0);
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiTxPowerCtrlConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function controls the TX power on and off
+**
+**  PARAMETERS:  action - turn on and turn off the TX power, or turn off after
+**                        certain time duration.
+**               time   - time duration to be expired before turning off TX
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiTxPowerCtrlConfig(MV_U16 action, MV_U16 time)
+{
+	MV_STATUS status = MV_OK;
+
+	if (action == E_EPON_IOCTL_ENABLE_TX)
+		onuPonTxPowerOn(MV_TRUE);
+	else if (action == E_EPON_IOCTL_DISABLE_TX)
+		onuPonTxPowerOn(MV_FALSE);
+	else if (action == E_EPON_IOCTL_DISABLE_TX_DELAY)
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponTxControlTimerId), 0, time, 1);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiPowerSavingConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the parameters for power saving mode
+**
+**  PARAMETERS:  earlyWakeup - set the ability of supporting early wake up
+**               maxSleepDuration - time period for keeping power saving mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiPowerSavingConfig(MV_U8 earlyWakeup, MV_U32 maxSleepDuration)
+{
+	MV_STATUS status = MV_OK;
+
+	if ((onuEponDbOnuSleepDurationGet() + onuEponDbOnuWakeupDurationGet())
+	    >= maxSleepDuration) {
+		mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+			   "ERROR: Wrong parameters, sleep(%d) + wakeup(%d) >= maxSleepDuration(%d)\r\n",
+			   onuEponDbOnuSleepDurationGet(), onuEponDbOnuWakeupDurationGet(),
+			   maxSleepDuration);
+
+		return MV_BAD_PARAM;
+	}
+
+	onuEponDbOnuPowerSavingWakeupSet(earlyWakeup);
+	onuEponDbOnuPowerSavingMaxSleepDurationSet(maxSleepDuration);
+
+	if (onuPonResourceTbl_s.onuEponMaxSleepTimerId.onuPonTimerActive == ONU_PON_TIMER_ACTIVE)
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId), 0,
+				  maxSleepDuration, 1);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiSleepModeCtrl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function controls sleep mode
+**
+**  PARAMETERS:  enable - turn off and turn on the TX or RX
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+**  Ref:         Called by mvEponApiSleepCtrlEnable, mvEponApiSleepCtrlDisable,
+**               mvEponApiSleepCtrlCfg, onuEponMaxSleepTimerHndl,
+**               onuEponSleepWakeDurationTimerHndl
+*******************************************************************************/
+MV_STATUS mvEponApiSleepModeCtrl(MV_U32 enable)
+{
+	MV_STATUS status = MV_OK;
+
+	if (onuEponDbOnuSleepModeGet() == E_EPON_SLEEP_MODE_CTRL_TX) {
+		if (enable == MV_TRUE)
+			status |= onuPonTxPowerOn(MV_FALSE);
+		else
+			status |= onuPonTxPowerOn(MV_TRUE);
+	} else if (onuEponDbOnuSleepModeGet() == E_EPON_SLEEP_MODE_CTRL_TX_RX) {
+		if (enable == MV_TRUE) {
+			status |= onuPonTxPowerOn(MV_FALSE);
+			status |= mvOnuEponMacSerdesPuRxWrite(MV_FALSE);
+		} else {
+			status |= onuPonTxPowerOn(MV_TRUE);
+			status |= mvOnuEponMacSerdesPuRxWrite(MV_TRUE);
+		}
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiSleepCtrlDisable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU to leave the power saving mode
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiSleepCtrlDisable()
+{
+	/* Stop max sleep timer */
+	if (onuPonResourceTbl_s.onuEponMaxSleepTimerId.onuPonTimerActive == ONU_PON_TIMER_ACTIVE)
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId));
+
+	/* Stop sleep/wakeup duration timer */
+	if (onuPonResourceTbl_s.onuEponSleepDurationTimerId.onuPonTimerActive == ONU_PON_TIMER_ACTIVE)
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId));
+
+	/* Enable TX/RX power */
+	mvEponApiSleepModeCtrl(MV_FALSE);
+
+	/* Leave the power saving status */
+	onuEponDbOnuSleepWakeupStatusSet(E_EPON_NOT_POWER_SAVING_STATUS);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiSleepCtrlEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU to enter the power saving mode
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiSleepCtrlEnable()
+{
+	/* refresh max sleep timer, no matter it's active or not */
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId), 0,
+			  onuEponDbOnuPowerSavingMaxSleepDurationGet(), 1);
+
+	/* refresh sleep/wakeup duration timer, no matter it's active or not */
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId), 0,
+			  onuEponDbOnuSleepDurationGet(), 1);
+
+	/* if the current status is not sleep, then go to sleep status */
+	if (onuEponDbOnuSleepWakeupStatusGet() != E_EPON_POWER_SAVING_SLEEP_STATUS) {
+		/* Disable TX/RX power */
+		mvEponApiSleepModeCtrl(MV_TRUE);
+
+		/* update status to sleep status */
+		onuEponDbOnuSleepWakeupStatusSet(E_EPON_POWER_SAVING_SLEEP_STATUS);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiSleepCtrlCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the parameters used in the power saving mode
+**
+**  PARAMETERS:  mode - 0: do nothing, 1: turn off Tx, 2: turn off Tx and Rx
+**               sleepDuration - time duration for keeping sleep
+**               wakeupDuration - time duration for being wakeup
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS mvEponApiSleepCtrlCfg(MV_U8 mode, MV_U32 sleepDuration, MV_U32 wakeupDuration)
+{
+	if ((sleepDuration + wakeupDuration) >= onuEponDbOnuPowerSavingMaxSleepDurationGet()) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: Wrong parameters, sleep(%d) + wakeup(%d) >= maxSleepDuration(%d)\r\n",
+			   sleepDuration, sleepDuration,
+			   onuEponDbOnuPowerSavingMaxSleepDurationGet());
+
+		return MV_BAD_PARAM;
+	}
+
+	/* save paraters into DB */
+	onuEponDbOnuSleepModeSet(mode);
+	onuEponDbOnuSleepDurationSet(sleepDuration);
+	onuEponDbOnuWakeupDurationSet(wakeupDuration);
+
+	/* refresh max sleep timer, no matter it's active or not */
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId), 0,
+			  onuEponDbOnuPowerSavingMaxSleepDurationGet(), 1);
+
+	/* refresh sleep/wakeup duration timer, no matter it's active or not */
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId), 0,
+			  onuEponDbOnuSleepDurationGet(), 1);
+
+	/* if the current status is not sleep, then go to sleep status */
+	if (onuEponDbOnuSleepWakeupStatusGet() != E_EPON_POWER_SAVING_SLEEP_STATUS) {
+		/* Disable TX/RX power */
+		mvEponApiSleepModeCtrl(MV_TRUE);
+
+		/* update status to sleep status */
+		onuEponDbOnuSleepWakeupStatusSet(E_EPON_POWER_SAVING_SLEEP_STATUS);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponMtuCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure MTU
+**
+**  PARAMETERS:  MV_U32 maxEthFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMtuCfg(int port_id, MV_U32 maxEthFrame)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiMacAddrSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the MAC address of a specific llid.
+**
+**  INPUTS     : MV_U16 llid: LLID.
+**               MV_U8 *mac : MAC address for LLID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_TRUE or MV_FLASE.
+**
+*******************************************************************************/
+MV_STATUS mvEponApiMacAddrSet(MV_U16 llid, MV_U8 *mac)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 lowAddr;
+	MV_U32 highAddr;
+
+	lowAddr = *(MV_U32 *)(mac + 2);          /* mac[2]+mac[3]+mac[4]+mac[5] */
+	highAddr = (MV_U32)(*(MV_U16 *)mac);     /* mac[0]+mac[1] */
+
+	status = onuEponDbOnuMacAddrSet(lowAddr, highAddr, llid);
+
+	status |= onuEponOnuFixMacAddrSet(llid, mac);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiMacAddrGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the MAC address of a specific llid.
+**
+**  INPUTS     : MV_U16 llid: LLID.
+**
+**  OUTPUTS    : MV_U8 *mac : MAC address for LLID.
+**
+**  RETURNS    : MV_TRUE or MV_FLASE.
+**
+*******************************************************************************/
+MV_STATUS mvEponApiMacAddrGet(MV_U16 llid, MV_U8 *mac)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 lowAddr;
+	MV_U32 highAddr;
+
+	status = onuEponDbOnuMacAddrGet(&lowAddr, &highAddr, llid);
+
+	*(MV_U32 *)(mac + 2) = lowAddr;          /* mac[2]+mac[3]+mac[4]+mac[5] */
+	*(MV_U16 *)mac = (MV_U16)highAddr;       /* mac[0]+mac[1] */
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiFecPerLlidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the FEC enabled or disabled per llid.
+**
+**  INPUTS     : MV_U16 llid : LLID.
+**               MV_U8 enable: Enable or disable FEC.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_TRUE or MV_FLASE.
+**
+*******************************************************************************/
+MV_STATUS mvEponApiFecPerLlidSet(MV_U16 llid, MV_U8 enable)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 regReqAutoRes;
+	MV_U32 regAckAutoRes;
+	MV_U32 reportAutoRes;
+	MV_U32 rxGenFecEnTemp;
+	MV_U32 txGenFecEnTemp;
+	MV_U32 txMacFecEnTemp;
+	MV_U32 txMacFecBase;
+	MV_U32 flag;
+	MV_U32 llidIndex;
+
+	/* Get current FEC related parameters, keep them unchanged if not configured this time */
+	onuEponDbOnuCfgGet(&regReqAutoRes, &regAckAutoRes, &reportAutoRes,
+			   &rxGenFecEnTemp, &txGenFecEnTemp, &txMacFecEnTemp);
+
+	/* Base value is used to shift bit according to llid */
+	txMacFecBase = 0x1;
+	flag = ((enable == 0 ? 0x0 : 0x1) << llid);
+
+	/* Set the fec bit of the given llid, keep the others unchanged */
+	txMacFecEnTemp = ((txMacFecEnTemp & (~(txMacFecBase << llid))) | (flag));
+
+	/* In our system, every llid is for both tx and rx.
+	   If there is at least one tx fec enabled, then the general tx fec should be enabled.
+	   And if one tx fec of a llid is enabled, then the rx fec of this llid should also be enabled,
+	   which leads to enable the general rx fec. */
+	if (txMacFecEnTemp == 0) {
+		rxGenFecEnTemp = 0;
+		txGenFecEnTemp = 0;
+	} else {
+		rxGenFecEnTemp = 1;
+		txGenFecEnTemp = 1;
+	}
+
+	onuEponDbOnuCfgSet(regReqAutoRes, regAckAutoRes, reportAutoRes,
+			   rxGenFecEnTemp, txGenFecEnTemp, txMacFecEnTemp);
+	status = mvOnuEponMacGenOnuConfigSet(rxGenFecEnTemp, txGenFecEnTemp, reportAutoRes,
+					     regAckAutoRes, regReqAutoRes, txMacFecEnTemp);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvEponApiFecPerLlidSet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	onuEponDbOnuRxFecCfgSet(rxGenFecEnTemp);
+	if (rxGenFecEnTemp == 1) {
+		status = mvOnuEponMacPcsDelaySet(0x1058);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) mvEponApiFecPerLlidSet", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	} else {
+		status = mvOnuEponMacPcsDelaySet(0x1C58);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) mvEponApiFecPerLlidSet", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+
+	if ((txGenFecEnTemp != 0) || (txMacFecEnTemp != 0)) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, Set FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_ENABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			if (txMacFecEnTemp & (1 << llidIndex)) {
+				status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+
+				status = mvOnuEponMacPPv2DbaPostFecSet(PPV2_DBA_POST_FEC_OVERHEAD);
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+						   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+					return status;
+				}
+			}
+		}
+	} else {
+		mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+			   "DEBUG: (%s:%d) onuEponApiFecReConfig, Reset FEC configuation for EPON DBA in PPv2\n",
+			   __FILE_DESC__, __LINE__);
+
+		status = mvOnuEponMacPPv2DbaFecStateSet(PPV2_DBA_POST_STATE_DISABLE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++) {
+			status = mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(llidIndex, 0 /*queue*/);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+
+			status = mvOnuEponMacPPv2DbaPostFecSet(0);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) onuEponApiFecReConfig", __FILE_DESC__, __LINE__);
+				return status;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvEponApiFecPerLlidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the FEC enabled or disabled per llid.
+**
+**  INPUTS     : MV_U16 llid : LLID.
+**
+**  OUTPUTS    : MV_U8 *enable: Enable or disable FEC.
+**
+**  RETURNS    : MV_TRUE or MV_FLASE.
+**
+*******************************************************************************/
+MV_STATUS mvEponApiFecPerLlidGet(MV_U16 llid, MV_U8 *enable)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 regReqAutoRes;
+	MV_U32 regAckAutoRes;
+	MV_U32 reportAutoRes;
+	MV_U32 rxGenFecEnTemp;
+	MV_U32 txGenFecEnTemp;
+	MV_U32 txMacFecEnTemp;
+	MV_U32 txMacFecBase;
+
+	onuEponDbOnuCfgGet(&regReqAutoRes, &regAckAutoRes, &reportAutoRes,
+			   &rxGenFecEnTemp, &txGenFecEnTemp, &txMacFecEnTemp);
+
+	txMacFecBase = 0x1;
+	*enable = ((txMacFecEnTemp & (txMacFecBase << llid)) == 0 ? 0 : 1);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiOpticalTxEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU optical TX enabled or disabled.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable optical TX.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuEponApiOpticalTxEnableSet(MV_BOOL enable)
+{
+	MV_STATUS ret = 0;
+
+	ret = onuPonTxPowerOn(enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiOpticalRxEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU optical RX enabled or disabled.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable optical RX.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuEponApiOpticalRxEnableSet(MV_BOOL enable)
+{
+	MV_STATUS ret = 0;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiHoldoverSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets onu Holdover parameters.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable holdover status.
+**               MV_U32 time : Interval duration before holdover.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : None.
+**
+*******************************************************************************/
+MV_STATUS onuEponApiHoldoverSet(MV_U8 enable, MV_U32 time)
+{
+	MV_STATUS status = MV_OK;
+
+	onuEponDbOnuHoldoverStateSet(enable);
+	onuEponDbOnuHoldoverTimeSet(time);
+
+	/* Add the newly configured holdover time with OpticalLosTime */
+	onuEponIsrTimerHoldoverIntervalSet(onuEponDbOnuHoldoverTimeGet() +
+					   onuEponDbOnuOpticalLosTimeGet(), 0);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiHoldoverGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets onu Holdover parameters.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable holdover status.
+**               MV_U32 time : Interval duration before holdover.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : None.
+**
+*******************************************************************************/
+MV_STATUS onuEponApiHoldoverGet(MV_U8 *enable, MV_U32 *time)
+{
+	MV_STATUS status = MV_OK;
+
+	*enable = onuEponDbOnuHoldoverStateGet();
+	*time = onuEponDbOnuHoldoverTimeGet();
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiOmciChannelAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds EOAM channel
+**
+**  PARAMETERS:  MV_U8 rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponApiEoamChannelAdd(MV_U8 rxCpuQueue)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponEoamChannelAdd(rxCpuQueue);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to add EPON OAM channel\n");
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiEoamChannelDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes EOAM channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponApiEoamChannelDel(void)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponEoamChannelDel();
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to delete EPON OAM channel\n");
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiTxLlidMapStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set the LLID mapping state
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponApiTxLlidMapStateSet(MV_BOOL mode)
+{
+	MV_STATUS rcode;
+	MV_BOOL txMode;
+
+	/* Do nothig in case the state is not changed */
+	rcode = onuEponDbHighPriTxStateGet(&txMode);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to get high priority TX state\n");
+	if (txMode == mode) {
+		mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+			   "INFO: (%s:%d) PON high pri TX state is the same, do nothing",
+			   __FILE_DESC__, __LINE__);
+		return MV_OK;
+	}
+
+	/* Set HW for high priority TX of LLID0 */
+	rcode = mvOnuEponMacTxmHighPriBitmapSet(0, MV_BOOL_TO_INT(mode));
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX to HW\n");
+
+	/* Set HW for high priority TX extended report state */
+	rcode = mvOnuEponMacGenUtmExtReportEnSet(MV_BOOL_TO_INT(mode));
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX ext report to HW\n");
+
+	/* Set HW for high priority TX extended report state of LLID0 */
+	rcode = mvOnuEponMacGenUtmExtReportBitmapEnSet(0, MV_BOOL_TO_INT(mode));
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX ext report to HW\n");
+
+	/* update DB */
+	rcode = onuEponDbHighPriTxStateSet(mode);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX to DB\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiTxLlidMapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set the LLID mapping
+**
+**  PARAMETERS:  MV_U32 llid_bm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponApiTxLlidMapSet(MV_U32 llid_bm)
+{
+	MV_BOOL state;
+	MV_U32 idx;
+	MV_STATUS rcode;
+
+	/* checking */
+	rcode = onuEponDbHighPriTxStateGet(&state);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to check new high pri Tx map\n");
+	if (state == MV_FALSE) {
+		mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+			   "INFO: (%s:%d) PON high pri TX state is disabled, do nothing",
+			   __FILE_DESC__, __LINE__);
+		return MV_FAIL;
+	}
+
+	/* set HW for high priority TX map of LLID0 */
+	rcode = mvOnuEponMacTxmHighPriMapSet(0, llid_bm);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX map to HW\n");
+
+	/* set HW for high priority TX report of LLID0 */
+	for (idx = 0; idx < EPON_MAX_MAC_NUM ; idx++) {
+		if ((1 << idx) &  llid_bm) {
+			rcode = mvOnuEponMacGenUtmExtReportMapSet(idx, 0);
+			PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority report map to HW\n");
+		}
+	}
+
+	/* update DB */
+	rcode = onuEponDbHighPriTxMapSet(llid_bm);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX map to DB\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         LLID PM Section                                    */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponApiLlidPmConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures HW so that MIB Counter PM is activated
+**               for a LLID
+**
+**  PARAMETERS:  S_EponIoctlLlidPmConfig *
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiLlidPmConfig(S_EponIoctlLlidPmConfig *eponLlidPmConfig)
+{
+	MV_STATUS rcode = MV_ERROR;
+
+	if (eponLlidPmConfig->llid > EPON_MAX_LLID) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, llid(%d) invalid\n", __FILE_DESC__, __LINE__, eponLlidPmConfig->llid);
+		return MV_BAD_PARAM;
+	}
+
+	if (!(eponLlidPmConfig->direction == LLIDPMDIRECTION_BIDI ||
+	      eponLlidPmConfig->direction == LLIDPMDIRECTION_DS   ||
+	      eponLlidPmConfig->direction == LLIDPMDIRECTION_US)) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, direction(%d) invalid\n", __FILE_DESC__, __LINE__, eponLlidPmConfig->direction);
+		return MV_BAD_PARAM;
+	}
+
+	if (eponLlidPmConfig->command == LLIDPMCMD_START)
+		rcode = onuEponPmLlidPmStart(eponLlidPmConfig->llid, eponLlidPmConfig->direction);
+	else if (eponLlidPmConfig->command == LLIDPMCMD_STOP)
+		rcode = onuEponPmLlidPmStop(eponLlidPmConfig->llid, eponLlidPmConfig->direction);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiLlidPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves MIB Counter PM for LLID
+**
+**  PARAMETERS:  S_EponIoctlLlidtibCounters *
+**
+**  OUTPUTS:     MIB counters copied
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiLlidPmGet(S_EponIoctlLlidMibCounters *llidMibCounters)
+{
+	MV_STATUS rcode = MV_OK;
+
+	if (llidMibCounters->llid > EPON_MAX_LLID) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, llid(%d) invalid\n", __FILE_DESC__, __LINE__, llidMibCounters->llid);
+		return MV_BAD_PARAM;
+	}
+	if (!(llidMibCounters->direction == LLIDPMDIRECTION_BIDI || llidMibCounters->direction == LLIDPMDIRECTION_DS ||
+	      llidMibCounters->direction == LLIDPMDIRECTION_US)) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, direction(%d) invalid\n", __FILE_DESC__, __LINE__, llidMibCounters->direction);
+		return MV_BAD_PARAM;
+	}
+
+	rcode = onuEponPmLlidPmGet(llidMibCounters);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuEponApiLlidPmReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Reset all LLID MIB Counter PM
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponApiLlidPmReset(void)
+{
+	MV_STATUS rcode = MV_OK;
+
+	rcode = onuEponPmLlidPmReset();
+
+	return rcode;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.h
new file mode 100644
index 0000000..a5da55f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuApi.h
@@ -0,0 +1,184 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuApi.h                                              **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON API definitions               **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_API_H
+#define _ONU_EPON_API_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuDb.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define EPON_MAX_LLID            (7)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Structs
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Notify API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiStatusNotifyRegister(STATUSNOTIFYFUNC notifyCallBack);
+MV_STATUS onuEponStatusNotify(MV_U32 status);
+
+/* Information API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiInformationGet(S_EponIoctlInfo *onuInfo, MV_U32 macId);
+MV_STATUS onuEponApiLinkStateGet(MV_U32 *linkState, MV_U32 macId);
+
+/* FEC API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiFecConfig(MV_U32 rxGenFecEn, MV_U32 txGenFecEn, MV_U32 *txMacFecEn, MV_U32 source);
+MV_STATUS onuEponApiFecReConfig(void);
+
+/* Encryption API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiEncryptionConfig(MV_U32 onuEncryptCfg);
+MV_STATUS onuEponApiEncryptionKeyConfig(MV_U32 encryptKey, MV_U32 encryptKeyIndex, MV_U32 macId);
+
+/* PM API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiRxPmGet(S_EponIoctlRxPm *rxPm, MV_BOOL clear, MV_U32 macId);
+MV_STATUS onuEponApiTxPmGet(S_EponIoctlTxPm *txPm, MV_BOOL clear, MV_U32 macId);
+MV_STATUS onuEponApiSwPmGet(S_EponIoctlSwPm *swPm, MV_BOOL clear, MV_U32 macId);
+MV_STATUS onuEponApiGpmPmGet(S_EponIoctlGpmPm *gpmPm, MV_BOOL clear, MV_U32 macId);
+
+/* OAM Frame API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiEoamChannelAdd(MV_U8 rxCpuQueue);
+MV_STATUS onuEponApiEoamChannelDel(void);
+MV_STATUS onuEponApiTxLlidMapStateSet(MV_BOOL mode);
+MV_STATUS onuEponApiTxLlidMapSet(MV_U32 llid_bm);
+MV_STATUS onuEponApiTransmitOamFrame(S_OnuEponCtrlBuffer *frame, MV_U32 macId);
+
+/* Dying Gasp API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiDgCallbackRegister(DYINGGASPFUNC dgCallBack);
+
+/* Link status API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiLinkStatusCallbackRegister(void);
+MV_BOOL   onuEponLinkIsUp(int port_id);
+
+/* Config API */
+MV_STATUS mvEponApiAdminUpSet(int port_id);
+MV_STATUS mvEponApiAdminDownSet(int port_id);
+
+MV_STATUS mvEponApi2kSupportedSet(MV_U32 pkt2kSupported);
+
+MV_STATUS mvEponApiLosTimeConfig(MV_U16 opticalLosTime, MV_U16 macLosTime);
+MV_STATUS mvEponApiTxPowerCtrlConfig(MV_U16 action, MV_U16 time);
+MV_STATUS mvEponApiPowerSavingConfig(MV_U8 earlyWakeup, MV_U32 maxSleepDuration);
+MV_STATUS mvEponApiSleepModeCtrl(MV_U32 enable);
+MV_STATUS mvEponApiSleepCtrlDisable(void);
+MV_STATUS mvEponApiSleepCtrlEnable(void);
+MV_STATUS mvEponApiSleepCtrlCfg(MV_U8 mode, MV_U32 sleepDuration, MV_U32 wakeupDuration);
+MV_STATUS onuEponMtuCfg(int port_id, MV_U32 maxEthFrame);
+
+MV_STATUS mvEponApiMacAddrSet(MV_U16 llid, MV_U8 *mac);
+MV_STATUS mvEponApiMacAddrGet(MV_U16 llid, MV_U8 *mac);
+MV_STATUS mvEponApiFecPerLlidSet(MV_U16 llid, MV_U8 enable);
+MV_STATUS mvEponApiFecPerLlidGet(MV_U16 llid, MV_U8 *enable);
+MV_STATUS onuEponApiOpticalTxEnableSet(MV_BOOL enable);
+MV_STATUS onuEponApiOpticalRxEnableSet(MV_BOOL enable);
+MV_STATUS onuEponApiHoldoverSet(MV_U8 enable, MV_U32 time);
+MV_STATUS onuEponApiHoldoverGet(MV_U8 *enable, MV_U32 *time);
+
+/* LLID MIB Counters PM  API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponApiLlidPmConfig(S_EponIoctlLlidPmConfig *eponLlidPmConfig);
+MV_STATUS onuEponApiLlidPmGet(S_EponIoctlLlidMibCounters *llidMibCounters);
+MV_STATUS onuEponApiLlidPmReset(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_API_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.c
new file mode 100644
index 0000000..205c7b8
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.c
@@ -0,0 +1,3008 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuDb.c                                               **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON database functionality      **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuDb.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+/* ONU GPON Database */
+S_OnuEponDb onuEponDb_s;
+
+#ifdef PON_FPGA
+#define MV_MAC_ADDR_SIZE (6)
+#endif /* PON_FPGA */
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+MV_U32 swRprtMacTimerInterval; /* in 16 nano sec units */
+
+MV_U8 fixMacAddrs[8][6] = { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x82 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x83 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x84 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x85 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x86 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x87 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x88 },
+			    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x89 } };
+
+extern u8 mvMacAddr[MV_ETH_MAX_PORTS][MV_MAC_ADDR_SIZE];
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Initialization Section                             */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponDbInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database to default values
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponDbInit(void)
+{
+	onuEponOnuMacTblInit();
+	onuEponOnuGenTblInit();
+	onuEponDbOnuDatapathTblInit();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbReInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function re-init onu database to default values
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponDbReInit(MV_U32 macId)
+{
+	/* set onu to state 01 */
+	onuEponDbOnuStateSet(ONU_EPON_02_REGISTER_PENDING, macId);
+
+	/* set onu sync time to 0 */
+	onuEponDbOnuSyncTimeSet(0, macId);
+
+	onuEponDbPktTxLlidSet(ONU_DEF_TX_LLID, macId);
+	onuEponDbPktRxLlidSet(ONU_DEF_RX_LLID, macId);
+
+	if (macId == 0)
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_SLOW);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOnuGenTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database MAC table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponOnuMacTblInit(void)
+{
+	MV_U32 macId;
+	MV_U8 macAddrSkeleton[MV_MAC_ADDR_SIZE];
+
+	memcpy(macAddrSkeleton, mvMacAddr[3], MV_MAC_ADDR_SIZE);
+	printk("macAddrSkeleton = %x:%x:%x:%x:%x:%x\n\r",
+	       macAddrSkeleton[0], macAddrSkeleton[1], macAddrSkeleton[2],
+	       macAddrSkeleton[3], macAddrSkeleton[4], macAddrSkeleton[5]);
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		memcpy(fixMacAddrs[macId], macAddrSkeleton, MV_MAC_ADDR_SIZE);
+
+		macAddrSkeleton[5]++;
+		if (macAddrSkeleton[5] == 0x10)
+			macAddrSkeleton[5] = 0;
+
+		printk(KERN_INFO "mac -%d- macAddr = %x:%x:%x:%x:%x:%x\n\r", macId,
+		       fixMacAddrs[macId][0], fixMacAddrs[macId][1], fixMacAddrs[macId][2],
+		       fixMacAddrs[macId][3], fixMacAddrs[macId][4], fixMacAddrs[macId][5]);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOnuMacTblUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates onu database MAC table
+**
+**  PARAMETERS:  port_id
+**               addr - MAC address
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponOnuMacTblUpdate(int port_id, void *addr)
+{
+	MV_U32 macId;
+	MV_U8 macAddrSkeleton[MV_MAC_ADDR_SIZE];
+
+	memcpy(macAddrSkeleton, addr, MV_MAC_ADDR_SIZE);
+	printk("macAddrSkeleton = %x:%x:%x:%x:%x:%x\n\r",
+	       macAddrSkeleton[0], macAddrSkeleton[1], macAddrSkeleton[2],
+	       macAddrSkeleton[3], macAddrSkeleton[4], macAddrSkeleton[5]);
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		memcpy(fixMacAddrs[macId], macAddrSkeleton, MV_MAC_ADDR_SIZE);
+
+		macAddrSkeleton[5]++;
+		if (macAddrSkeleton[5] == 0x10)
+			macAddrSkeleton[5] = 0;
+
+		printk("mac -%d- macAddr = %x:%x:%x:%x:%x:%x\n\r", macId,
+		       fixMacAddrs[macId][0], fixMacAddrs[macId][1], fixMacAddrs[macId][2],
+		       fixMacAddrs[macId][3], fixMacAddrs[macId][4], fixMacAddrs[macId][5]);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOnuGenTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database general table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponOnuGenTblInit(void)
+{
+	MV_U32 macAddrLow;
+	MV_U32 macAddrHigh;
+	MV_U32 macId;
+	MV_U32 queueSet;
+	MV_U32 queueId;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	/* clear onu database general table */
+	memset((&(onuEponDb_s.onuEponGenTbl_s)), 0, sizeof(S_OnuEponGenTbl));
+
+	/* set onu control type to MPCP - 8808 */
+	onuEponDbOnuCtrlTypeSet(ONU_MPCP_CTRL_TYPE);
+
+	/* set onu to port state down */
+	onuEponDbOnuEponPortStateSet(ONU_PON_PORT_DOWN);
+
+	/* set onu broadcast address */
+	onuEponDbOnuBcastAddrSet(ONU_BROADCAST_ADDR_LOW, ONU_BROADCAST_ADDR_HIGH);
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		/* set onu to valid */
+		onuEponDbOnuValidSet(MV_TRUE, macId);
+
+		/* set onu to state 01 */
+		onuEponDbOnuStateSet(ONU_EPON_02_REGISTER_PENDING, macId);
+
+		/* set onu sync time to 0 */
+		onuEponDbOnuSyncTimeSet(0, macId);
+
+		/* set onu mac address */
+		macAddrLow  = ((fixMacAddrs[macId][5] & 0xFF)) |
+			      ((fixMacAddrs[macId][4] & 0xFF) <<  8) |
+			      ((fixMacAddrs[macId][3] & 0xFF) << 16) |
+			      ((fixMacAddrs[macId][2] & 0xFF) << 24);
+		macAddrHigh = ((fixMacAddrs[macId][1] & 0xFF)) |
+			      ((fixMacAddrs[macId][0] & 0xFF) << 8);
+
+		onuEponDbOnuMacAddrSet(macAddrLow, macAddrHigh, macId);
+
+		/* set default LOID authentication state */
+		onuEponDbOnuLoidAuthStateSet(MV_TRUE, macId);
+	}
+
+	/* set led */
+	onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_SLOW);
+
+	/* set holdover */
+	onuEponDbOnuHoldoverStateSet(ONU_HOLDOVER_NOT_ACTIVE);
+	onuEponDbOnuHoldoverTimeSet(ONU_PON_TIMER_HOLDOVER_INTERVAL);
+	onuEponDbOnuOpticalLosTimeSet(0);
+
+	onuEponDbOnuPowerSavingMaxSleepDurationSet(ONU_PON_TIMER_MAX_SLEEP_INTERVAL);
+	onuEponDbOnuPowerSavingWakeupSet(0);
+	onuEponDbOnuSleepModeSet(E_EPON_SLEEP_MODE_CTRL_TX);
+	onuEponDbOnuSleepDurationSet(ONU_PON_TIMER_SLEEP_DURATION);
+	onuEponDbOnuWakeupDurationSet(ONU_PON_TIMER_WAKEUP_DURATION);
+	onuEponDbOnuSleepWakeupStatusSet(E_EPON_NOT_POWER_SAVING_STATUS);
+
+	/* set silence */
+	onuEponDbOnuSilenceStateSet(ONU_SILENCE_NOT_ACTIVE);
+
+	/* DBA params */
+	/* ========== */
+	/* Device == 6601   AND   SW DBA force == disabled   ==> HW DBA */
+	/* Device != 6601   OR    SW DBA force == Enabled    ==> SW DBA */
+
+	/* Device == 6601   AND   SW DBA force == Enabled    ==> SW DBA */
+	/* Device != 6601   AND   SW DBA force == Enabled    ==> SW DBA */
+	/* Device != 6601   AND   SW DBA force == disabled   ==> SW DBA */
+
+	/* SW DBA Configuration */
+	/* Device == 6601   ==> SW GATE Interrupt */
+	/* Device != 6601   ==> SW Timer Interrupt */
+
+	onuEponDbOnuDbaSwForceModeSet(ONU_DBA_SW_FORCE_MODE_DIS);       /* SW DBA force mode disabled */
+	onuEponDbOnuDbaSwGateIntModeSet(ONU_DBA_SW_GATE_INTRRUPT);      /* SW DBA Gate interrupt = default */
+
+	if ((familyId == MV_88F66X0) && (onuEponDbOnuDbaSwForceModeGet() == ONU_DBA_SW_FORCE_MODE_DIS))
+		onuEponDbOnuDbaModeSet(ONU_DBA_HW_RPRT_MODE);
+	else
+		onuEponDbOnuDbaModeSet(ONU_DBA_SW_RPRT_MODE);
+
+	if (familyId == MV_88F66X0)
+		onuEponDbOnuDbaSwGateIntModeSet(ONU_DBA_SW_GATE_INTRRUPT);      /* SW DBA gate Interrupt mode */
+	else {
+		onuEponDbOnuDbaSwGateIntModeSet(ONU_DBA_SW_TIMER);              /* SW DBA timer mode */
+		onuEponDbOnuSwRprtMacTimerIntervalSet(62500);                   /* 1 msec in 16nano units */
+	}
+
+	onuEponDbOnuDbaSwModeQueuesetDirSet(ONU_DBA_SW_RPRT_NORMAL_DIR);
+	onuEponDbOnuDbaSwModeQueueDirSet(ONU_DBA_SW_RPRT_NORMAL_DIR);
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		if (macId == 0)
+			onuEponDbOnuDbaLlidActiveStatusSet(ONU_DBA_ACTIVE_LLID, macId);
+		else
+			onuEponDbOnuDbaLlidActiveStatusSet(ONU_DBA_NON_ACTIVE_LLID, macId);
+
+		onuEponDbOnuDbaHighestReportQueueSet(ONU_DBA_DEF_HIGHEST_QUEUE, macId);
+		onuEponDbOnuDbaNumOfQueuesSet(ONU_DBA_DEF_NUM_OF_QUEUE, macId);
+		onuEponDbOnuDbaNumOfQueuesetSet(ONU_DBA_DEF_NUM_OF_QUEUESET, macId);
+		onuEponDbOnuDbaQueuesBitMapSet(ONU_DBA_DEF_QUEUES_BIT_MAP, macId);
+
+		for (queueSet = 0; queueSet < ONU_DBA_DEF_NUM_OF_QUEUESET; queueSet++) {
+			for (queueId = 0; queueId < ONU_DBA_DEF_NUM_OF_QUEUE; queueId++) {
+				if (queueSet == 0)
+					onuEponDbOnuDbaQueueThresholdSet(ONU_DBA_DEF_QUEUESET_DEF_THRESHOLD,
+									 1, queueId, queueSet, macId);
+				else if (queueSet == 1)
+					onuEponDbOnuDbaQueueThresholdSet(ONU_DBA_DEF_QUEUESET_DEF_THRESHOLD,
+									 1, queueId, queueSet, macId);
+				else if (queueSet == 2)
+					onuEponDbOnuDbaQueueThresholdSet(ONU_DBA_DEF_QUEUESET_DEF_THRESHOLD,
+									 1, queueId, queueSet, macId);
+				else
+					onuEponDbOnuDbaQueueThresholdSet(ONU_DBA_DEF_QUEUESET_DEF_THRESHOLD,
+									 1, queueId, queueSet, macId);
+			}
+		}
+	}
+
+	/* set onu configuration */
+	onuEponDbOnuCfgSet(ONU_REG_REQ_AUTO_RES,
+			   ONU_REG_ACK_AUTO_RES,
+			   ONU_REPORT_AUTO_RES,
+			   ONU_RX_PCS_FEC_DIS,
+			   ONU_TX_PCS_FEC_DIS,
+			   ONU_TX_FEC_DIS);
+
+	onuEponDbOnuRxFecCfgSet(ONU_RX_PCS_FEC_DIS);
+
+	onuEponDbStatusNotifySet(NULL);
+	onuEponDbDgCallbackSet(NULL);
+	onuEponDbModeSet(E_EPON_IOCTL_STD_MODE);
+
+	/* set high priority TX to false by default */
+	onuEponDbHighPriTxStateSet(MV_FALSE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOnuFixMacAddrSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets fixed MAC addresses for LLIDs.
+**
+**  PARAMETERS:  MV_U16 llid: LLID.
+**               MV_U8 *mac : MAC address for LLID.
+**
+**  OUTPUTS:     None.
+**
+**  RETURNS:     MV_OK.
+**
+*******************************************************************************/
+MV_STATUS onuEponOnuFixMacAddrSet(MV_U16 llid, MV_U8 *mac)
+{
+	memcpy(fixMacAddrs[llid], mac, 6);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDatapathTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database data path table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDatapathTblInit(void)
+{
+	MV_U32 macId;
+
+	/* clear onu database data path table */
+	memset((&(onuEponDb_s.onuEponDataPathTbl_s)), 0, sizeof(S_OnuEponDatapathTbl));
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		onuEponDb_s.onuEponDataPathTbl_s.onuEponRxLLID[macId] = ONU_UNUSED_LLID;
+		onuEponDb_s.onuEponDataPathTbl_s.onuEponTxLLID[macId] = ONU_UNUSED_LLID;
+
+		onuEponDbPktTxLlidSet(ONU_DEF_TX_LLID, macId);
+		onuEponDbPktRxLlidSet(ONU_DEF_RX_LLID, macId);
+	}
+
+	onuEponDbPktForwardSet(ONU_SLOW_FRAME_TO_CTRL_QUEUE,
+			       ONU_SLOW_FRAME_TO_RPRT_QUEUE,
+			       ONU_RPRT_FRAME_TO_RPRT_QUEUE,
+			       ONU_RPRT_FRAME_TO_DATA_QUEUE,
+			       ONU_CTRL_FRAME_TO_CTRL_QUEUE,
+			       ONU_CTRL_FRAME_TO_DATA_QUEUE);
+
+	onuEponDbPktFilterPacketSet(ONU_FORWARD_LLID_ALL_PKT,
+				    ONU_FORWARD_LLID_XXXX_MODE_1_PKT,
+				    ONU_FORWARD_LLID_7FFF_MODE_1_PKT,
+				    ONU_FORWARD_LLID_7FFF_MODE_0_PKT,
+				    ONU_DROP_LLID_NNNN_MODE_1_PKT);
+
+	onuEponDbPktFilterErrorSet(ONU_FORWARD_LLID_LEN_ERR_PKT,
+				   ONU_FORWARD_LLID_GMII_ERR_PKT,
+				   ONU_FORWARD_LLID_FCS_ERR_PKT,
+				   ONU_FORWARD_LLID_CRC_ERR_PKT);
+
+	onuEponDbPktSizeSet(ONU_DEF_MIN_PKT_SIZE, ONU_DEF_MAX_PKT_SIZE);
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Interface Section                                  */
+/* ========================================================================== */
+/******************************************************************************/
+
+/********************************************/
+/* ======================================== */
+/*   ONU EPON General Table API Functions   */
+/* ======================================== */
+/********************************************/
+MV_STATUS matchDestAddressToMacId(MV_U8 *destAddr, MV_U32 *macId)
+{
+	MV_U32 addrIndex;
+
+	for (addrIndex = 0; addrIndex < EPON_MAX_MAC_NUM; addrIndex++) {
+		if (memcmp(fixMacAddrs[addrIndex], destAddr, 6) == 0) {
+			*macId = addrIndex;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuValidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu valid in the database
+**
+**  PARAMETERS:  MV_BOOL onuValid
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuValidSet(MV_BOOL onuValid, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponValid[macId] = onuValid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuValidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu valid
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_BOOL onuEponDbOnuValidGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponValid[macId];
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu state in the database
+**
+**  PARAMETERS:  MV_U32 onuState - ONU_EPON_02_REGISTER_PENDING
+**                                 ONU_EPON_03_OPERATION
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuStateSet(MV_U32 onuState, MV_U32 macId)
+{
+	if ((onuState < ONU_EPON_02_REGISTER_PENDING) ||
+	    (onuState > ONU_EPON_03_OPERATION))
+		return MV_ERROR;
+
+	onuEponDb_s.onuEponGenTbl_s.onuEponState[macId] = onuState;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu state
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuStateGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponState[macId];
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSignalDetectSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu signal detect in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSignalDetectSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponSignalDetect = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSignalDetectGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu state signal detect
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSignalDetectGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponSignalDetect;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDsSyncOkPcsSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu ds sync OK PCS in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDsSyncOkPcsSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDsSyncOkPcs = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDsSyncOkPcsGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu ds sync OK PCS
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDsSyncOkPcsGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDsSyncOkPcs;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuEponPortStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu EPON Port state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuEponPortStateSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponPortState = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuEponPortStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return EPON Port state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuEponPortStateGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponPortState;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuCtrlTypeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu ether type in the database
+**
+**  PARAMETERS:  MV_U32 ctrlType
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuCtrlTypeSet(MV_U32 ctrlType)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponCtrlType = ctrlType;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuCtrlTypeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu ether type
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuCtrlTypeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponCtrlType;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSyncTimeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu sync time in the database
+**
+**  PARAMETERS:  MV_U32 syncTime
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSyncTimeSet(MV_U32 syncTime, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponSyncTime[macId] = syncTime;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSyncTimeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu sync time
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu sync time
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSyncTimeGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponSyncTime[macId];
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuMacAddrSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac address in the database
+**
+**  PARAMETERS:  MV_U32 lowAddr
+**               MV_U32 highAddr
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuMacAddrSet(MV_U32 lowAddr, MV_U32 highAddr, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponMacAddr[macId].addressLow  = lowAddr;
+	onuEponDb_s.onuEponGenTbl_s.onuEponMacAddr[macId].addressHigh = highAddr;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuMacAddrGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac address in the database
+**
+**  PARAMETERS:  MV_U32 *lowAddr
+**               MV_U32 *highAddr
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuMacAddrGet(MV_U32 *lowAddr, MV_U32 *highAddr, MV_U32 macId)
+{
+	*lowAddr  = onuEponDb_s.onuEponGenTbl_s.onuEponMacAddr[macId].addressLow;
+	*highAddr = onuEponDb_s.onuEponGenTbl_s.onuEponMacAddr[macId].addressHigh;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuBcastAddrSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac broadcast address in the database
+**
+**  PARAMETERS:  MV_U32 lowAddr
+**               MV_U32 highAddr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuBcastAddrSet(MV_U32 lowAddr, MV_U32 highAddr)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponBcastAddr.addressLow  = lowAddr;
+	onuEponDb_s.onuEponGenTbl_s.onuEponBcastAddr.addressHigh = highAddr;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuMacAddrGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac broadcast address in the database
+**
+**  PARAMETERS:  MV_U32 *lowAddr
+**               MV_U32 *highAddr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuBcastAddrGet(MV_U32 *lowAddr, MV_U32 *highAddr)
+{
+	*lowAddr  = onuEponDb_s.onuEponGenTbl_s.onuEponBcastAddr.addressLow;
+	*highAddr = onuEponDb_s.onuEponGenTbl_s.onuEponBcastAddr.addressHigh;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuCfgAutoSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac auto configuration in the database
+**
+**  PARAMETERS:  MV_U32 regReqAutoRes
+**               MV_U32 regAckAutoRes
+**               MV_U32 reportAutoRes
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuCfgAutoSet(MV_U32 regReqAutoRes,
+				 MV_U32 regAckAutoRes,
+				 MV_U32 reportAutoRes)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegReqAutoRes = regReqAutoRes;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegAckAutoRes = regAckAutoRes;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponReportAutoRes = reportAutoRes;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuCfgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac configuration in the database
+**
+**  PARAMETERS:  MV_U32 regReqAutoRes
+**               MV_U32 regAckAutoRes
+**               MV_U32 reportAutoRes
+**               MV_U32 rxPcsFecEn
+**               MV_U32 txPcsFecEn
+**               MV_U32 txFecEn
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuCfgSet(MV_U32 regReqAutoRes,
+			     MV_U32 regAckAutoRes,
+			     MV_U32 reportAutoRes,
+			     MV_U32 rxPcsFecEn,
+			     MV_U32 txPcsFecEn,
+			     MV_U32 txFecEn)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegReqAutoRes = regReqAutoRes;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegAckAutoRes = regAckAutoRes;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponReportAutoRes = reportAutoRes;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRxPcsFecEn    = rxPcsFecEn;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponTxPcsFecEn    = txPcsFecEn;
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponTxFecEn       = txFecEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuCfgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac configuration in the database
+**
+**  PARAMETERS:  MV_U32 regReqAutoRes
+**               MV_U32 regAckAutoRes
+**               MV_U32 reportAutoRes
+**               MV_U32 rxFec
+**               MV_U32 txFec
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuCfgGet(MV_U32 *regReqAutoRes,
+			     MV_U32 *regAckAutoRes,
+			     MV_U32 *reportAutoRes,
+			     MV_U32 *rxPcsFecEn,
+			     MV_U32 *txPcsFecEn,
+			     MV_U32 *txFecEn)
+{
+	*regReqAutoRes = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegReqAutoRes;
+	*regAckAutoRes = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRegAckAutoRes;
+	*reportAutoRes = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponReportAutoRes;
+	*rxPcsFecEn    = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRxPcsFecEn;
+	*txPcsFecEn    = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponTxPcsFecEn;
+	*txFecEn       = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponTxFecEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuRxFecCfgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac Rx FEC configuration in the database
+**
+**  PARAMETERS:  MV_U32 rxPcsFecEn
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuRxFecCfgSet(MV_U32 rxPcsFecEn)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRxPcsFecEn = rxPcsFecEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuRxFecCfgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac Rx FEC configuration in the database
+**
+**  PARAMETERS:  MV_U32 rxFec
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuRxFecCfgGet(MV_U32 *rxPcsFecEn)
+{
+	*rxPcsFecEn = onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponRxPcsFecEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuTxFecCfgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac Tx FEC configuration in the database
+**
+**  PARAMETERS:  MV_U32 txFec
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuTxFecCfgGet(MV_U32 *txFecEn, MV_U32 macId)
+{
+	*txFecEn = ((onuEponDb_s.onuEponGenTbl_s.onuEponCfg.onuEponTxFecEn >> macId) & 0x1);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu DBA mode
+**
+**  PARAMETERS:  MV_U32 mode - HW(0) SW(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaModeSet(MV_U32 mode)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDbaMode = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu DBA mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode - HW(0) SW(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaModeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDbaMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwForceModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SW DBA force mode
+**
+**  PARAMETERS:  MV_U32 mode - disable(0) enable(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaSwForceModeSet(MV_U32 mode)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwForceMode = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwForceModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SW DBA force mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode - disable(0) enable(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaSwForceModeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwForceMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwGateIntModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SW DBA Interrupt mode
+**
+**  PARAMETERS:  MV_U32 mode - Timer(0), Gate Interrupt(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaSwGateIntModeSet(MV_U32 mode)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwGateIntMode = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwGateIntModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SW DBA Interrupt mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode - Timer(0), Gate Interrupt(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaSwGateIntModeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwGateIntMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwModeQueuesetDirSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SW mode queueset direction
+**
+**  PARAMETERS:  MV_U32 dir - Normal(0) Reverse(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaSwModeQueuesetDirSet(MV_U32 dir)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwQueuesetDir = dir;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwModeQueuesetDirGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SW mode queueset direction
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 dir - Normal(0) Reverse(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaSwModeQueuesetDirGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwQueuesetDir;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwModeQueueDirSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SW mode queues direction
+**
+**  PARAMETERS:  MV_U32 dir - Normal(0) Reverse(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaSwModeQueueDirSet(MV_U32 dir)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwQueueDir = dir;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaSwModeQueueDirGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SW mode queues direction
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 dir - Normal(0) Reverse(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaSwModeQueueDirGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDbaSwQueueDir;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaLlidActiveStatusSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu DBA LLID active status
+**
+**  PARAMETERS:  MV_U32 status - Off(0) On(1)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaLlidActiveStatusSet(MV_U32 status, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].active = status;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaLlidActiveStatusGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu DBA mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 status - Off(0) On(1)
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaLlidActiveStatusGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].active;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaHighestReportQueueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu highest DBA report queue
+**
+**  PARAMETERS:  MV_U32 queueNum
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaHighestReportQueueSet(MV_U32 queueNum, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].highestReportQueue = queueNum;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaHighestReportQueueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu highest DBA report queue
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaHighestReportQueueGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].highestReportQueue;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaQueuesBitMapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu queues bit map per LLID
+**
+**  PARAMETERS:  MV_U32 queuesBitMap
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaQueuesBitMapSet(MV_U32 queuesBitMap, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queuesBitMap = queuesBitMap;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaQueuesBitMapGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu queues bit map per LLID
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu queues bit map
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaQueuesBitMapGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queuesBitMap;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaNumOfQueuesSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu number of queues per LLID
+**
+**  PARAMETERS:  MV_U32 numOfQueues
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaNumOfQueuesSet(MV_U32 numOfQueues, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].numOfQueues = numOfQueues;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaNumOfQueuesGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu number of queues per LLID
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaNumOfQueuesGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].numOfQueues;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaNumOfQueuesetSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu number of queueset per LLID
+**
+**  PARAMETERS:  MV_U32 numOfQueueset
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaNumOfQueuesetSet(MV_U32 numOfQueueset, MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].numOfQueueSets = numOfQueueset;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaNumOfQueuesetGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu number of queueset per LLID
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuDbaNumOfQueuesetGet(MV_U32 macId)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].numOfQueueSets;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaQueueThresholdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu queue threshold per LLID
+**
+**  PARAMETERS:  MV_U32 threshold
+**               MV_U32 state
+**               MV_U32 queueId
+**               MV_U32 queueSet
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaQueueThresholdSet(MV_U32 threshold,
+					   MV_U32 state,
+					   MV_U32 queueId,
+					   MV_U32 queueSet,
+					   MV_U32 macId)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queueThreshold[queueSet][queueId].threshold = threshold;
+	onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queueThreshold[queueSet][queueId].state     = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaQueueThresholdGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu queue threshold per LLID
+**
+**  PARAMETERS:  MV_U32 *threshold
+**               MV_U32 *state
+**               MV_U32 queueId
+**               MV_U32 queueSet
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaQueueThresholdGet(MV_U32 *threshold,
+					   MV_U32 *state,
+					   MV_U32 queueId,
+					   MV_U32 queueSet,
+					   MV_U32 macId)
+{
+	*threshold = onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queueThreshold[queueSet][queueId].threshold;
+	*state     = onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId].queueThreshold[queueSet][queueId].state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuDbaLlidThresholdGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu llid threshold per LLID
+**
+**  PARAMETERS:  S_OnuEponDba *llidDba
+**               MV_U32        macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuDbaLlidThresholdGet(S_OnuEponDba *llidDba, MV_U32 macId)
+{
+	memcpy(llidDba, &(onuEponDb_s.onuEponGenTbl_s.onuEponDba[macId]), sizeof(S_OnuEponDba));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu holdover state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuHoldoverStateSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverState = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu holdover state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuHoldoverStateGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverState;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverTimeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu holdover time in the database
+**
+**  PARAMETERS:  MV_U32 time
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuHoldoverTimeSet(MV_U32 time)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverTime = time;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverTimeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu holdover time
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuHoldoverTimeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverTime;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverExecSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu holdover execute in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuHoldoverExecSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverExecute = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuHoldoverExecGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu holdover execute
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuHoldoverExecGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponHoldoverExecute;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuOpticalLosTimeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets time duration value in database
+**               when no optical signal is detected
+**
+**  PARAMETERS:  losTime - time duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuOpticalLosTimeSet(MV_U16 losTime)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponOpticalLosTime = losTime;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuOpticalLosTimeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns time duration to be used
+**               when no optical signal is detected
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     time duration value
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuOpticalLosTimeGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponOpticalLosTime;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuMacLosTimeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets time duration value in database
+**               when no GATE MPCPDU is received
+**
+**  PARAMETERS:  losTime - time duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuMacLosTimeSet(MV_U16 losTime)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponMacLosTime = losTime;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuMacLosTimeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns time duration to be used
+**               when no GATE MPCPDU is received
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     time duration value
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuMacLosTimeGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponMacLosTime;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuPowerSavingWakeupSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the support for early wakeup
+**               in power saving mode
+**
+**  PARAMETERS:  wakeUpEnable - Enable or disable the early wakeup support
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuPowerSavingWakeupSet(MV_U8 wakeUpEnable)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingWakeup = wakeUpEnable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuPowerSavingWakeupGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the support for early wakeup
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     enable or disable
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuPowerSavingWakeupGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingWakeup;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuPowerSavingMaxSleepDurationSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the max sleep duration
+**               in power saving mode
+**
+**  PARAMETERS:  maxSleepDuration - max sleep duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuPowerSavingMaxSleepDurationSet(MV_U32 maxSleepDuration)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingMaxSleepDuration = maxSleepDuration;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuPowerSavingMaxSleepDurationGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the max sleep duration in power saving mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     max sleep duration
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuPowerSavingMaxSleepDurationGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingMaxSleepDuration;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets control mode for power saving
+**
+**  PARAMETERS:  mode - turn off tx or tx/rx
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSleepModeSet(MV_U8 mode)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponSleepMode = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the sleep mode for power saving mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     sleep mode
+**
+*******************************************************************************/
+E_EponSleepCtrlMode onuEponDbOnuSleepModeGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponSleepMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepDurationSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the periodical sleep duration
+**               for power saving
+**
+**  PARAMETERS:  sleepDuration - periodical sleep duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSleepDurationSet(MV_U32 sleepDuration)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponSleepDuration = sleepDuration;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepDurationGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the periodical sleep duration for power saving
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     max sleep duration
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSleepDurationGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponSleepDuration;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuWakeupDurationSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the periodical wakeup duration
+**               for power saving
+**
+**  PARAMETERS:  wakeupDuration - periodical wakeup duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuWakeupDurationSet(MV_U32 wakeupDuration)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponWakeupDuration = wakeupDuration;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuWakeupDurationGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the periodical wakeup duration for power saving
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     max sleep duration
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuWakeupDurationGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponWakeupDuration;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepWakeupStatusSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets power saving status
+**
+**  PARAMETERS:  status - no power saving/sleep/wakeup
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSleepWakeupStatusSet(MV_U32 status)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingStatus = status;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSleepWakeupStatusGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the power saving status
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     power saving status
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSleepWakeupStatusGet()
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponPowerSavingStatus;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSilenceStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu silence state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSilenceStateSet(MV_U32 state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponSilenceState = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSilenceStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu silence state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSilenceStateGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponSilenceState;
+}
+
+/********************************************/
+/* ======================================== */
+/*   ONU EPON DataPath Table API Functions  */
+/* ======================================== */
+/********************************************/
+
+/*******************************************************************************
+**
+**  onuEponDbPktSizeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu mac RX packet size
+**
+**  PARAMETERS:  MV_U32 minSize
+**               MV_U32 maxSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktSizeSet(MV_U32 minSize, MV_U32 maxSize)
+{
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponRxPktMinSize = minSize;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponRxPktMaxSize = maxSize;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktSizeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu mac RX packet size
+**
+**  PARAMETERS:  MV_U32 *minSize
+**               MV_U32 *maxSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktSizeGet(MV_U32 *minSize, MV_U32 *maxSize)
+{
+	*minSize = onuEponDb_s.onuEponDataPathTbl_s.onuEponRxPktMinSize;
+	*maxSize = onuEponDb_s.onuEponDataPathTbl_s.onuEponRxPktMaxSize;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktFilterPacketSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu filter packet configuration
+**
+**  PARAMETERS:  MV_U32 forwardLlidAll
+**               MV_U32 forwardLlid1XXX
+**               MV_U32 forwardLlid1FFF
+**               MV_U32 forwardLlid0FFF
+**               MV_U32 dropLlid1NNN
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktFilterPacketSet(MV_U32 forwardLlidAll,
+				      MV_U32 forwardLlid1XXX,
+				      MV_U32 forwardLlid1FFF,
+				      MV_U32 forwardLlid0FFF,
+				      MV_U32 dropLlid1NNN)
+{
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlidAll  = forwardLlidAll;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid1XXX = forwardLlid1XXX;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid1FFF = forwardLlid1FFF;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid0FFF = forwardLlid0FFF;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.dropLlid1NNN    = dropLlid1NNN;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktFilterPacketGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu filter packet configuration
+**
+**  PARAMETERS:  MV_U32 *forwardLlidAll
+**               MV_U32 *forwardLlid1XXX
+**               MV_U32 *forwardLlid1FFF
+**               MV_U32 *forwardLlid0FFF
+**               MV_U32 *dropLlid1NNN
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktFilterPacketGet(MV_U32 *forwardLlidAll,
+				      MV_U32 *forwardLlid1XXX,
+				      MV_U32 *forwardLlid1FFF,
+				      MV_U32 *forwardLlid0FFF,
+				      MV_U32 *dropLlid1NNN)
+{
+	*forwardLlidAll  = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlidAll;
+	*forwardLlid1XXX = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid1XXX;
+	*forwardLlid1FFF = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid1FFF;
+	*forwardLlid0FFF = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.forwardLlid0FFF;
+	*dropLlid1NNN    = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.dropLlid1NNN;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktFilterErrorSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu filter error configuration
+**
+**  PARAMETERS:  MV_U32 ignoreLenErr
+**               MV_U32 ignoreGmiiErr
+**               MV_U32 ignoreFcsErr
+**               MV_U32 ignoreLlidCrcErr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktFilterErrorSet(MV_U32 ignoreLenErr,
+				     MV_U32 ignoreGmiiErr,
+				     MV_U32 ignoreFcsErr,
+				     MV_U32 ignoreLlidCrcErr)
+{
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreLenErr     = ignoreLenErr;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreGmiiErr    = ignoreGmiiErr;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreFcsErr     = ignoreFcsErr;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreLlidCrcErr = ignoreLlidCrcErr;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktFilterErrorGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu filter error configuration
+**
+**  PARAMETERS:  MV_U32 *ignoreLenErr
+**               MV_U32 *ignoreGmiiErr
+**               MV_U32 *ignoreFcsErr
+**               MV_U32 *ignoreLlidCrcErr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktFilterErrorGet(MV_U32 *ignoreLenErr,
+				     MV_U32 *ignoreGmiiErr,
+				     MV_U32 *ignoreFcsErr,
+				     MV_U32 *ignoreLlidCrcErr)
+{
+	*ignoreLenErr     = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreLenErr;
+	*ignoreGmiiErr    = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreGmiiErr;
+	*ignoreFcsErr     = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreFcsErr;
+	*ignoreLlidCrcErr = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktFilter.ignoreLlidCrcErr;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktForwardSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu forwarding configuration
+**
+**  PARAMETERS:  MV_U32 slowFrameToCtrlQueue
+**               MV_U32 slowFrameToRprtQueue
+**               MV_U32 rprtFrameToRprtQueue
+**               MV_U32 rprtFrameToDataQueue
+**               MV_U32 ctrlFrameToCtrlQueue
+**               MV_U32 ctrlFrameToDataQueue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktForwardSet(MV_U32 slowFrameToCtrlQueue,
+				 MV_U32 slowFrameToRprtQueue,
+				 MV_U32 rprtFrameToRprtQueue,
+				 MV_U32 rprtFrameToDataQueue,
+				 MV_U32 ctrlFrameToCtrlQueue,
+				 MV_U32 ctrlFrameToDataQueue)
+{
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.slowFrameToCtrlQueue = slowFrameToCtrlQueue;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.slowFrameToRprtQueue = slowFrameToRprtQueue;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.rprtFrameToRprtQueue = rprtFrameToRprtQueue;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.rprtFrameToDataQueue = rprtFrameToDataQueue;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.ctrlFrameToCtrlQueue = ctrlFrameToCtrlQueue;
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.ctrlFrameToDataQueue = ctrlFrameToDataQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktForwardGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu forwarding configuration
+**
+**  PARAMETERS:  MV_U32 *slowFrameToCtrlQueue
+**               MV_U32 *slowFrameToRprtQueue
+**               MV_U32 *rprtFrameToRprtQueue
+**               MV_U32 *rprtFrameToDataQueue
+**               MV_U32 *ctrlFrameToCtrlQueue
+**               MV_U32 *ctrlFrameToDataQueue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktForwardGet(MV_U32 *slowFrameToCtrlQueue,
+				 MV_U32 *slowFrameToRprtQueue,
+				 MV_U32 *rprtFrameToRprtQueue,
+				 MV_U32 *rprtFrameToDataQueue,
+				 MV_U32 *ctrlFrameToCtrlQueue,
+				 MV_U32 *ctrlFrameToDataQueue)
+{
+	*slowFrameToCtrlQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.slowFrameToCtrlQueue;
+	*slowFrameToRprtQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.slowFrameToRprtQueue;
+	*rprtFrameToRprtQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.rprtFrameToRprtQueue;
+	*rprtFrameToDataQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.rprtFrameToDataQueue;
+	*ctrlFrameToCtrlQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.ctrlFrameToCtrlQueue;
+	*ctrlFrameToDataQueue = onuEponDb_s.onuEponDataPathTbl_s.onuEponPktForward.ctrlFrameToDataQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktRxLlidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Rx LLID
+**
+**  PARAMETERS:  MV_U32 llid
+**               MV_U32 index
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktRxLlidSet(MV_U32 llid, MV_U32 index)
+{
+	if (index >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponRxLLID[index] = llid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktRxLlidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Rx LLID
+**
+**  PARAMETERS:  MV_U32 *llid
+**               MV_U32 index
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktRxLlidGet(MV_U32 *llid, MV_U32 index)
+{
+	if (index >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	*llid = onuEponDb_s.onuEponDataPathTbl_s.onuEponRxLLID[index];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktTxLlidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Tx LLID
+**
+**  PARAMETERS:  MV_U32 llid
+**               MV_U32 index
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktTxLlidSet(MV_U32 llid, MV_U32 index)
+{
+	if (index >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	onuEponDb_s.onuEponDataPathTbl_s.onuEponTxLLID[index] = llid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPktTxLlidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Tx LLID
+**
+**  PARAMETERS:  MV_U32 *llid
+**               MV_U32 index
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPktTxLlidGet(MV_U32 *llid, MV_U32 index)
+{
+	if (index >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	*llid = onuEponDb_s.onuEponDataPathTbl_s.onuEponTxLLID[index];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbStatusNotifySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Status Notify Callback in the database
+**
+**  PARAMETERS:  STATUSNOTIFYFUNC statusCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbStatusNotifySet(STATUSNOTIFYFUNC statusCallback)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuStatusCallback = statusCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbStatusNotifyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Status Notify Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Status Notify Callback
+**
+*******************************************************************************/
+STATUSNOTIFYFUNC onuEponDbStatusNotifyGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuStatusCallback;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSwRprtTimerTypeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set SW report MAC timer interval
+**
+**  PARAMETERS:  MV_U32 timer interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuSwRprtMacTimerIntervalSet(MV_U32 timerInterval)
+{
+	swRprtMacTimerInterval = timerInterval;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuSwRprtMacTimerIntervalGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return SW report MAC timer interval
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 timer interval
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuSwRprtMacTimerIntervalGet(void)
+{
+	return swRprtMacTimerInterval;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON mode in the database
+**
+**  PARAMETERS:  MV_U32 mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbModeSet(MV_U32 mode)
+{
+	if (mode >= E_EPON_IOCTL_MAX_MODE_NUM)
+		return MV_ERROR;
+
+	onuEponDb_s.onuEponGenTbl_s.onuEponMode = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns current EPON mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuEponDbModeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPcsCfgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON PCS configuration register value in the database
+**
+**  PARAMETERS:  MV_U32 val
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbP2PForceModeSet(MV_U32 forceMode)
+{
+	if (forceMode >= E_EPON_IOCTL_MAX_MODE_NUM)
+		return MV_ERROR;
+
+	onuEponDb_s.onuEponGenTbl_s.onuEponP2PForceMode = forceMode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbP2PForceModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns current EPON P2P Force mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuEponDbP2PForceModeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponP2PForceMode;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPcsCfgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON PCS configuration register value in the database
+**
+**  PARAMETERS:  MV_U32 val
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbPcsCfgSet(MV_U32 val)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponPcsCfg = val;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbPcsCfgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON PCS configuration register value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuEponDbPcsCfgGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponPcsCfg;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOverheadSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON Overhead register value in the database
+**
+**  PARAMETERS:  MV_U32 val
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOverheadSet(MV_U32 val)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponOverHead = val;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOverheadGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON Overhead register value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuEponDbOverheadGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponOverHead;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbDgCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Dying Gasp Callback in the database
+**
+**  PARAMETERS:  DYINGGASPFUNC dgCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbDgCallbackSet(DYINGGASPFUNC dgCallback)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuDgCallback = dgCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbDgCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Dying Gasp Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Dying Gasp Callback
+**
+*******************************************************************************/
+DYINGGASPFUNC onuEponDbDgCallbackGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuDgCallback;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbLinkStatusCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Link Status Callback in the database
+**
+**  PARAMETERS:  LINKSTATUSFUNC linkStatusCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbLinkStatusCallbackSet(LINKSTATUSFUNC linkStatusCallback)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuLinkStatusCallback = linkStatusCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbLinkStatusCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Link Status Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Link Status Callback
+**
+*******************************************************************************/
+LINKSTATUSFUNC onuEponDbLinkStatusCallbackGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuLinkStatusCallback;
+}
+
+/*******************************************************************************
+**
+**  onuEponHwDbaAdditionalOamBytesSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON HW DBA additional OAM bytes value in the database
+**
+**  PARAMETERS:  S_EponOamDbaByte *dbaOamByte
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponHwDbaAdditionalOamBytesSet(S_EponOamDbaByte *dbaOamByte)
+{
+	memcpy(&onuEponDb_s.onuEponGenTbl_s.dbaOamByte, dbaOamByte, sizeof(S_EponOamDbaByte));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponHwDbaAdditionalOamBytesGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON HW DBA additional OAM bytes value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     S_EponOamDbaByte *dbaOamByte
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponHwDbaAdditionalOamBytesGet(S_EponOamDbaByte *dbaOamByte)
+{
+	memcpy(dbaOamByte, &onuEponDb_s.onuEponGenTbl_s.dbaOamByte, sizeof(S_EponOamDbaByte));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamFifoSizeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON OAM FIFO size
+**
+**  PARAMETERS:  MV_U32 val
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponOamFifoSizeSet(MV_U32 val)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponOamFifoSize = val;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamFifoSizeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON EPON OAM FIFO size value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuEponOamFifoSizeGet(void)
+{
+	return onuEponDb_s.onuEponGenTbl_s.onuEponOamFifoSize;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuLoidAuthStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu LOID authentication state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbOnuLoidAuthStateSet(MV_BOOL state, MV_U32 macId)
+{
+	PON_POS_RANGE_VALIDATE(PON_DB_MODULE, macId, EPON_MAX_MAC_NUM - 1, "Invalid LLID");
+
+	onuEponDb_s.onuEponGenTbl_s.onuEponLoidAuthState[macId] = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbOnuLoidAuthStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu LOID authentication state
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ctrl frame ether type
+**
+*******************************************************************************/
+MV_U32 onuEponDbOnuLoidAuthStateGet(MV_U32 macId)
+{
+	PON_POS_RANGE_VALIDATE(PON_DB_MODULE, macId, EPON_MAX_MAC_NUM - 1, "Invalid LLID");
+
+	return onuEponDb_s.onuEponGenTbl_s.onuEponLoidAuthState[macId];
+}
+
+/*******************************************************************************
+**
+**  onuEponDbEoamChannelSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON OAM channel config
+**
+**  PARAMETERS:  S_OnuEoamChannel *eoamChannel
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbEoamChannelSet(S_OnuEoamChannel *eoamChannel)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.state = eoamChannel->state;
+	if (eoamChannel->state == MV_TRUE) {
+		onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.luid       = eoamChannel->luid;
+		onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.prsTid     = eoamChannel->prsTid;
+	} else {
+		onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.luid       = 0;
+		onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.prsTid     = 0;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbEoamChannelGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the EPON OAM channel config
+**
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     S_OnuEoamChannel *eoamChannel
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbEoamChannelGet(S_OnuEoamChannel *eoamChannel)
+{
+	eoamChannel->state      = onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.state;
+	eoamChannel->cpuRxQueue = onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.cpuRxQueue;
+	eoamChannel->luid       = onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.luid;
+	eoamChannel->prsTid     = onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.prsTid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbEoamRxQueueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON OAM CPU RX queue
+**
+**  PARAMETERS:  MV_U32 eoamRxQueue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbEoamRxQueueSet(MV_U32 eoamRxQueue)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.cpuRxQueue = eoamRxQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbEoamRxQueueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the EPON OAM CPU RX queue
+**
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     S_OnuEoamChannel *eoamChannel
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbEoamRxQueueGet(MV_U32 *eoamRxQueue)
+{
+	*eoamRxQueue = onuEponDb_s.onuEponGenTbl_s.onuEponOamChannel.cpuRxQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbHighPriTxStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON high priority TX state
+**
+**  PARAMETERS:  MV_BOOL state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbHighPriTxStateSet(MV_BOOL state)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponLlidTxMap.state = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbHighPriTxStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the EPON high priority TX state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     MV_BOOL *state
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbHighPriTxStateGet(MV_BOOL *state)
+{
+	*state = onuEponDb_s.onuEponGenTbl_s.onuEponLlidTxMap.state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbHighPriTxMapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON high priority TX map
+**
+**  PARAMETERS:  MV_U32 llid_bm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbHighPriTxMapSet(MV_U32 llid_bm)
+{
+	onuEponDb_s.onuEponGenTbl_s.onuEponLlidTxMap.llid_bm = llid_bm;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbHighPriTxMapGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the EPON high priority TX map
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     MV_U32 *llid_bm
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponDbHighPriTxMapGet(MV_U32 *llid_bm)
+{
+	*llid_bm = onuEponDb_s.onuEponGenTbl_s.onuEponLlidTxMap.llid_bm;
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.h
new file mode 100644
index 0000000..e30a6fd
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuDb.h
@@ -0,0 +1,596 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuDb.h                                               **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON database definitions          **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_DB_H
+#define _ONU_EPON_DB_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuLnxKsMI.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+/******************************************************************************/
+/* ========================================================================== */
+/*                               Database Definitions                         */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* EPON MAC State Definitions */
+#define ONU_EPON_REGISTERED                   (0x01)
+#define ONU_EPON_NOT_REGISTERD                (0x00)
+
+/* EPON State Definitions */
+#define ONU_EPON_02_REGISTER_PENDING          (0x01)
+#define ONU_EPON_03_OPERATION                 (0x02)
+#define ONU_EPON_MAX_NUM_OF_STATE             (4)
+
+/* EPON Event Definitions */
+#define ONU_EPON_REGISTER_MSG_FLAG_ACK        (0x01)
+#define ONU_EPON_REGISTER_MSG_FLAG_DEREG      (0x02)
+#define ONU_EPON_REGISTER_MSG_FLAG_REREG      (0x03)
+#define ONU_EPON_MAX_NUM_OF_EVENT             (8)
+
+/* EPON Configuration Definitions */
+#define ONU_REG_REQ_AUTO_RES                  (0x01)
+#define ONU_REG_REQ_SW_RES                    (0x00)
+#define ONU_REG_ACK_AUTO_RES                  (0x01)
+#define ONU_REG_ACK_SW_RES                    (0x00)
+#define ONU_REPORT_AUTO_RES                   (0x01)
+#define ONU_REPORT_SW_RES                     (0x00)
+#define ONU_RX_PCS_FEC_EN                     (0x01)
+#define ONU_RX_PCS_FEC_DIS                    (0x00)
+#define ONU_TX_PCS_FEC_EN                     (0x01)
+#define ONU_TX_PCS_FEC_DIS                    (0x00)
+#define ONU_TX_FEC_DIS                        (0x00)
+#define ONU_RX_DIS                            (0x00)
+#define ONU_RX_EN                             (0x01)
+#define ONU_TX_DIS                            (0x00)
+#define ONU_TX_EN                             (0x01)
+
+/* EPON Registration Definitions */
+#define ONU_REGISTER                          (0x01)
+#define ONU_REGISTER_ACK                      (0x02)
+#define ONU_REGISTER_REQ                      (0x03)
+
+/* EPON ONU Sync Time Definitions */
+#define ONU_DEF_SYNC_TIME_ADD                 (0x00)
+#define ONU_DEF_SYNC_TIME_DIS_DISCOVER_AUTO   (0x01)
+#define ONU_DEF_SYNC_TIME_DIS_GATE_AUTO       (0x00)
+#define ONU_DEF_SYNC_TIME_FORCE_SW            (0x00)
+#define ONU_DEF_SYNC_TIME                     (0x34)
+
+/* EPON ONU DDM Definitions */
+#define ONU_DEF_DDM_DELAY                     (0x08)
+
+/* EPON Packet Filtering Definitions */
+#define ONU_FORWARD_LLID_ALL_PKT              (0x00)
+#define ONU_FORWARD_LLID_ALL_PKT_FILTER       (0x01)
+#define ONU_FORWARD_LLID_7FFF_MODE_0_PKT      (0x01)
+#define ONU_FORWARD_LLID_7FFF_MODE_1_PKT      (0x01)
+#define ONU_FORWARD_LLID_XXXX_MODE_1_PKT      (0x00)
+#define ONU_DROP_LLID_NNNN_MODE_1_PKT         (0x00)
+
+/* EPON Error Filtering Definitions */
+#define ONU_FORWARD_LLID_CRC_ERR_PKT          (0x00)
+#define ONU_FORWARD_LLID_CRC_ERR_PKT_IGNORE   (0x01)
+#define ONU_FORWARD_LLID_FCS_ERR_PKT          (0x00)
+#define ONU_FORWARD_LLID_GMII_ERR_PKT         (0x00)
+#define ONU_FORWARD_LLID_LEN_ERR_PKT          (0x00)
+
+/* EPON Packet Forwarding Definitions */
+#define ONU_SLOW_FRAME_TO_CTRL_QUEUE          (0x00)
+#define ONU_SLOW_FRAME_TO_RPRT_QUEUE          (0x00)
+#define ONU_RPRT_FRAME_TO_RPRT_QUEUE          (0x00)
+#define ONU_RPRT_FRAME_TO_DATA_QUEUE          (0x00)
+#define ONU_CTRL_FRAME_TO_CTRL_QUEUE          (0x01)
+#define ONU_CTRL_FRAME_TO_DATA_QUEUE          (0x00)
+
+/* EPON Ether Type Definitions */
+#define ONU_MPCP_CTRL_TYPE                    (0x8808)
+#define ONU_OAM_CTRL_TYPE                     (0x8809)
+
+/* EPON MAC Address Definitions */
+#define ONU_BROADCAST_ADDR_LOW                (0xC2000001)
+#define ONU_BROADCAST_ADDR_HIGH               (0x00000180)
+#define ONU_MAC_ADDR_LOW                      (0x09b0302c)
+#define ONU_MAC_ADDR_HIGH                     (0x00000013)
+
+/* EPON LLID Definitions */
+#define ONU_UNUSED_LLID                       (0xFFFF)
+#define ONU_DEF_TX_LLID                       (0x07FF)
+#define ONU_DEF_RX_LLID                       (0x0000)
+#define ONU_LLID_VALUE_MASK                   (0x7FFF)
+#define ONU_LLID_INDEX_MASK                   (0x000F)
+#define ONU_LLID_VALID_MASK                   (0x0001)
+#define ONU_LLID_VALUE_SHIFT                  (0)
+#define ONU_LLID_INDEX_SHIFT                  (15)
+#define ONU_LLID_VALID_SHIFT                  (19)
+
+/* EPON Laser Definitions */
+#define ONU_DEF_LASER_ON_TIME                 (0x10)
+#define ONU_DEF_LASER_OFF_TIME                (0x00)
+#define ONU_DEF_LASER_ON_OFF_TIME             (0x30)
+
+/* EPON TXM Definitions */
+#ifdef PON_Z1
+#define ONU_DEF_TXM_CFG_MODE                  (0x0)
+#define ONU_DEF_TXM_CFG_ALIGNMENT             (0x1)
+#define ONU_DEF_TXM_CFG_PRIORITY              (0x0)
+#else /* Z2,A0 or later */
+#define ONU_DEF_TXM_CFG_TFEC_1                (0x2)
+#define ONU_DEF_TXM_CFG_TFEC_2                (0x2)
+#define ONU_DEF_TXM_CFG_CTRL_FIFO_DIS_FCS_ON  (0x1)
+#define ONU_DEF_TXM_CFG_CTRL_FIFO_DIS_FCS_OFF (0x0)
+#define ONU_DEF_TXM_CFG_MASK_GMII_ON          (0x1)
+#define ONU_DEF_TXM_CFG_MASK_GMII_OFF         (0x0)
+#define ONU_DEF_TXM_CFG_BLOCK_DATA_ON         (0x1)
+#define ONU_DEF_TXM_CFG_BLOCK_DATA_OFF        (0x0)
+#define ONU_DEF_TXM_CFG_IPG_ADD               (0x1)
+#define ONU_DEF_TXM_CFG_IPG_DONT_ADD          (0x0)
+#define ONU_DEF_TXM_CFG_MODE_EPON             (0x00)
+#define ONU_DEF_TXM_CFG_MODE_GE               (0x01)
+#define ONU_DEF_TXM_CFG_MODE_TX_DIS           (0x10)
+#define ONU_DEF_TXM_CFG_ALIGNMENT_ODD         (0x10)
+#define ONU_DEF_TXM_CFG_ALIGNMENT_EVEN        (0x01)
+#define ONU_DEF_TXM_CFG_ALIGNMENT_DONT_CARE   (0x00)
+#define ONU_DEF_TXM_CFG_PRIORITY_CTRL_FIRST   (0x1)
+#define ONU_DEF_TXM_CFG_PRIORITY_RPRT_FIRST   (0x0)
+#define ONU_DEF_TXM_CFG_EPON_OVERHEAD         (0x0E01)
+#define ONU_DEF_TXM_CFG_P2P_OVERHEAD          (0x0E06)
+#endif
+
+/* EPON PCS Definitions */
+#define ONU_DEF_PCS_CFG_RX_EN                 (0x01)
+#define ONU_DEF_PCS_CFG_TX_EN                 (0x10)
+
+/* P2P PCS Definitions */
+#define ONU_P2P_PCS_TX_RX_NEW                 (0x610)
+#define ONU_P2P_PCS_TX_NEW                    (0x611)
+#define ONU_P2P_PCS_TX_RX_OLD                 (0x613)
+
+/* EPON DDM Definitions */
+#define ONU_DEF_DDM_CFG_TX_EN_OR              (0x2)
+#define ONU_DEF_DDM_CFG_POLARITY_HIGH         (0x0)
+#define ONU_DEF_DDM_CFG_POLARITY_LOW          (0x1)
+
+/* EPON Packet Size */
+#define ONU_DEF_MIN_PKT_SIZE                  (64)
+#define ONU_DEF_MAX_PKT_SIZE                  (2040)
+
+/* EPON Holdover State */
+#define ONU_HOLDOVER_NOT_ACTIVE               (0)
+#define ONU_HOLDOVER_ACTIVE                   (1)
+
+/* EPON Silence State */
+#define ONU_SILENCE_NOT_ACTIVE                (0)
+#define ONU_SILENCE_ACTIVE                    (1)
+#define ONU_SILENCE_DISABLED                  (0)
+#define ONU_SILENCE_ENABLED                   (1)
+
+/* EPON DBA */
+#define ONU_DBA_HW_RPRT_MODE                  (0)
+#define ONU_DBA_SW_RPRT_MODE                  (1)
+#define ONU_DBA_SW_FORCE_MODE_DIS             (0)
+#define ONU_DBA_SW_FORCE_MODE_EN              (1)
+#define ONU_DBA_SW_TIMER                      (0)
+#define ONU_DBA_SW_GATE_INTRRUPT              (1)
+#define ONU_DBA_DEF_QUEUES_BIT_MAP            (0xFF)
+#define ONU_DBA_DEF_NUM_OF_QUEUE              (8)
+#define ONU_DBA_DEF_NUM_OF_QUEUESET           (1)
+#define ONU_DBA_MAX_NUM_OF_QUEUE              (8)
+#define ONU_DBA_MAX_NUM_OF_QUEUESET           (4)
+#define ONU_DBA_DEF_QUEUESET_0_THRESHOLD      (0x2000)
+#define ONU_DBA_DEF_QUEUESET_1_THRESHOLD      (0x4000)
+#define ONU_DBA_DEF_QUEUESET_2_THRESHOLD      (0x6000)
+#define ONU_DBA_DEF_QUEUESET_3_THRESHOLD      (0xFFFF)
+#define ONU_DBA_DEF_QUEUESET_DEF_THRESHOLD    (0xFFFF)
+#define ONU_DBA_UPDATE_LLID                   (2)
+#define ONU_DBA_ACTIVE_LLID                   (1)
+#define ONU_DBA_NON_ACTIVE_LLID               (0)
+#define ONU_DBA_SW_RPRT_NORMAL_DIR            (0)
+#define ONU_DBA_SW_RPRT_REVERSE_DIR           (1)
+
+#define ONU_OAM_CTRL_MSG                      (0)
+#define ONU_OAM_RPRT_MSG                      (1)
+#define ONU_OAM_DG_MSG                        (2)
+
+/* EPON FEC */
+#define ONU_FEC_CFG_INIT                      (0)
+#define ONU_FEC_CFG_RE_INIT                   (1)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef void (*EPONFUNCPTR)(MV_U8, MV_U8, MV_U8*);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                               Database Definitions                         */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ONU EPON General Tables */
+typedef struct {
+	MV_U32 onuEponRegReqAutoRes;                            /* Register Request Auto Response */
+	MV_U32 onuEponRegAckAutoRes;                            /* Register Ack Auto Response  */
+	MV_U32 onuEponReportAutoRes;                            /* Report Auto Response  */
+	MV_U32 onuEponRxPcsFecEn;                               /* Rx PCS FEC Enable */
+	MV_U32 onuEponTxPcsFecEn;                               /* Tx PCS FEC Enable */
+	MV_U32 onuEponTxFecEn;                                  /* Tx FEC Enable */
+} S_OnuEponConfig;
+
+typedef struct {
+	MV_U32 addressLow;                                      /* MAC Address Low */
+	MV_U32 addressHigh;                                     /* MAC Address High */
+} S_OnuEponMacAddr;
+
+typedef struct {
+	MV_U8 state;                                            /* Is threshold configuration active for the queue */
+	MV_U16 threshold;                                       /* Queue threshold: range 0 - 65535                */
+} S_OnuEponDbaQueue;
+
+typedef struct {
+	MV_U32 active;
+	MV_U32 highestReportQueue;
+	MV_U32 queuesBitMap;
+	MV_U32 numOfQueues;
+	MV_U32 numOfQueueSets;
+	S_OnuEponDbaQueue queueThreshold[EPON_MAX_QUEUE_SET_NUMBER][EPON_MAX_THRESHOLD_SET_RER_QUEUE];
+} S_OnuEponDba;
+
+typedef struct {
+	MV_U32 reg;
+	MV_U32 shift;
+	MV_U32 shadowIdx;
+} S_OnuEponDbaSwRprtRegMap;
+
+typedef struct {
+	MV_U32 reg;
+	MV_U32 shadow;
+} S_OnuEponDbaShadowRegMap;
+
+typedef enum {
+	E_EPON_SLEEP_MODE_CTRL_NOTHING = 0,
+	E_EPON_SLEEP_MODE_CTRL_TX      = 1,
+	E_EPON_SLEEP_MODE_CTRL_TX_RX   = 2,
+} E_EponSleepCtrlMode;
+
+typedef enum {
+	E_EPON_NOT_POWER_SAVING_STATUS    = 0,
+	E_EPON_POWER_SAVING_SLEEP_STATUS  = 1,
+	E_EPON_POWER_SAVING_WAKEUP_STATUS = 2,
+} E_EponPowerSavingStatus;
+
+typedef struct {
+	MV_BOOL state;
+	MV_U32 cpuRxQueue;
+	MV_U32 luid;
+	MV_U32 prsTid;
+} S_OnuEoamChannel;
+
+typedef struct {
+	MV_BOOL state;          /* Enable or disable this feature */
+	MV_U32 llid_bm;         /* LLID mapping bitmap            */
+} S_OnuLlidTxMap;
+
+typedef struct {
+	MV_U32 onuEponValid[EPON_MAX_MAC_NUM];                  /* ONU Valid for sync */
+	MV_U32 onuEponState[EPON_MAX_MAC_NUM];                  /* ONU State */
+	MV_U32 onuEponSignalDetect;
+	MV_U32 onuEponDsSyncOkPcs;
+	MV_U32 onuEponPortState;
+	MV_U32 onuEponCtrlType;                                 /* ONU Control Type */
+	MV_U32 onuEponSyncTime[EPON_MAX_MAC_NUM];               /* ONU Sync Time */
+	MV_U32 onuEponHoldoverState;
+	MV_U32 onuEponHoldoverTime;
+	MV_U32 onuEponHoldoverExecute;
+	MV_U32 onuEponSilenceState;
+	MV_U32 onuEponDbaMode;                                  /* HW / SW Modes */
+	MV_U32 onuEponDbaSwForceMode;                           /* SW DBA Force Mode */
+	MV_U32 onuEponDbaSwGateIntMode;                         /* SW DBA Timer or Gate Interrupt */
+	MV_U32 onuEponDbaSwQueuesetDir;                         /* SW Report Queueset Direction */
+	MV_U32 onuEponDbaSwQueueDir;                            /* SW Report Queue Direction */
+	S_OnuEponDba onuEponDba[EPON_MAX_MAC_NUM];
+	S_OnuEponConfig onuEponCfg;                             /* ONU Configuration */
+	S_OnuEponMacAddr onuEponMacAddr[EPON_MAX_MAC_NUM];      /* ONU MAC Address */
+	S_OnuEponMacAddr onuEponBcastAddr;                      /* ONU MAC Broadcast Address */
+	STATUSNOTIFYFUNC onuStatusCallback;
+	DYINGGASPFUNC onuDgCallback;
+	LINKSTATUSFUNC onuLinkStatusCallback;
+	MV_U32 onuEponMode;
+	MV_U32 onuEponP2PForceMode;
+	MV_U32 onuEponPcsCfg;
+	MV_U32 onuEponOverHead;
+	MV_U32 onuEponPhyOutput;
+	MV_U32 onuEponOpticalLosTime;
+	MV_U32 onuEponMacLosTime;
+	MV_U32 onuEponPowerSavingWakeup;
+	MV_U32 onuEponPowerSavingMaxSleepDuration;
+	MV_U32 onuEponSleepAction;
+	MV_U32 onuEponSleepMode;
+	MV_U32 onuEponSleepDuration;
+	MV_U32 onuEponWakeupDuration;
+	MV_U32 onuEponPowerSavingStatus;
+	MV_U32 onuEponOamFifoSize;
+	MV_BOOL onuEponLoidAuthState[EPON_MAX_MAC_NUM];
+	S_EponOamDbaByte dbaOamByte;
+	S_OnuEoamChannel onuEponOamChannel;
+	S_OnuLlidTxMap onuEponLlidTxMap;
+} S_OnuEponGenTbl;
+
+/* ONU EPON Data Path tables */
+typedef struct {
+	MV_U32 slowFrameToCtrlQueue;
+	MV_U32 slowFrameToRprtQueue;
+	MV_U32 rprtFrameToRprtQueue;
+	MV_U32 rprtFrameToDataQueue;
+	MV_U32 ctrlFrameToCtrlQueue;
+	MV_U32 ctrlFrameToDataQueue;
+} S_OnuEponRxPktForward;
+
+typedef struct {
+	MV_U32 dropLlid1NNN;
+	MV_U32 forwardLlidAll;
+	MV_U32 forwardLlid1XXX;
+	MV_U32 forwardLlid1FFF;
+	MV_U32 forwardLlid0FFF;
+	MV_U32 ignoreLenErr;
+	MV_U32 ignoreGmiiErr;
+	MV_U32 ignoreFcsErr;
+	MV_U32 ignoreLlidCrcErr;
+} S_OnuEponRxPktFilter;
+
+typedef struct {
+	MV_U32 onuEponRxPktMinSize;                             /* ONU Rx Packet Min Size */
+	MV_U32 onuEponRxPktMaxSize;                             /* ONU Rx Packet Max Size */
+	S_OnuEponRxPktForward onuEponPktForward;                /* ONU Rx Packet Forward */
+	S_OnuEponRxPktFilter onuEponPktFilter;                  /* ONU Rx Packet Filter */
+	MV_U32 onuEponRxLLID[EPON_MAX_MAC_NUM];                 /* ONU Rx Packet Rx LLID Array */
+	MV_U32 onuEponTxLLID[EPON_MAX_MAC_NUM];                 /* ONU Rx Packet Tx LLID Array */
+} S_OnuEponDatapathTbl;
+
+/* ONU EPON DataBase */
+typedef struct {
+	S_OnuEponGenTbl onuEponGenTbl_s;
+	S_OnuEponDatapathTbl onuEponDataPathTbl_s;
+} S_OnuEponDb;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+/* ONU EPON Database */
+extern S_OnuEponDb onuEponDb_s;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* ONU EPON database init function */
+MV_STATUS onuEponDbInit(void);
+MV_STATUS onuEponDbReInit(MV_U32 macId);
+MV_STATUS onuEponOnuMacTblInit(void);
+MV_STATUS onuEponOnuGenTblInit(void);
+MV_STATUS onuEponDbOnuDatapathTblInit(void);
+
+/* ONU EPON general table API functions */
+MV_STATUS onuEponDbOnuValidSet(MV_BOOL onuValid, MV_U32 macId);
+MV_BOOL   onuEponDbOnuValidGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuStateSet(MV_U32 onuState, MV_U32 macId);
+MV_U32    onuEponDbOnuStateGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuSignalDetectSet(MV_U32 onuState);
+MV_U32    onuEponDbOnuSignalDetectGet(void);
+MV_STATUS onuEponDbOnuDsSyncOkPcsSet(MV_U32 onuState);
+MV_U32    onuEponDbOnuDsSyncOkPcsGet(void);
+MV_STATUS onuEponDbOnuEponPortStateSet(MV_U32 state);
+MV_U32    onuEponDbOnuEponPortStateGet(void);
+MV_STATUS onuEponDbOnuCtrlTypeSet(MV_U32 ctrlType);
+MV_U32    onuEponDbOnuCtrlTypeGet(void);
+MV_STATUS onuEponDbOnuSyncTimeSet(MV_U32 syncTime, MV_U32 macId);
+MV_U32    onuEponDbOnuSyncTimeGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuMacAddrSet(MV_U32 lowAddr, MV_U32 highAddr, MV_U32 macId);
+MV_STATUS onuEponDbOnuMacAddrGet(MV_U32 *lowAddr, MV_U32 *highAddr, MV_U32 macId);
+MV_STATUS onuEponDbOnuBcastAddrSet(MV_U32 lowAddr, MV_U32 highAddr);
+MV_STATUS onuEponDbOnuBcastAddrGet(MV_U32 *lowAddr, MV_U32 *highAddr);
+MV_STATUS onuEponDbOnuCfgSet(MV_U32 regReqAutoRes, MV_U32 regAckAutoRes, MV_U32 reportAutoRes,
+			     MV_U32 rxPcsFecEn, MV_U32 txPcsFecEn, MV_U32 txFecEn);
+MV_STATUS onuEponDbOnuCfgGet(MV_U32 *regReqAutoRes, MV_U32 *regAckAutoRes, MV_U32 *reportAutoRes,
+			     MV_U32 *rxPcsFecEn, MV_U32 *txPcsFecEn, MV_U32 *txFecEn);
+MV_STATUS onuEponDbOnuCfgAutoSet(MV_U32 regReqAutoRes, MV_U32 regAckAutoRes, MV_U32 reportAutoRes);
+MV_STATUS onuEponDbOnuRxFecCfgSet(MV_U32 rxPcsFecEn);
+MV_STATUS onuEponDbOnuRxFecCfgGet(MV_U32 *rxPcsFecEn);
+MV_STATUS onuEponDbOnuTxFecCfgGet(MV_U32 *txFecEn, MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaHighestReportQueueSet(MV_U32 queueNum, MV_U32 macId);
+MV_U32    onuEponDbOnuDbaHighestReportQueueGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaQueuesBitMapSet(MV_U32 queuesBitMap, MV_U32 macId);
+MV_U32    onuEponDbOnuDbaQueuesBitMapGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaNumOfQueuesSet(MV_U32 numOfQueues, MV_U32 macId);
+MV_U32    onuEponDbOnuDbaNumOfQueuesGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaNumOfQueuesetSet(MV_U32 numOfQueueset, MV_U32 macId);
+MV_U32    onuEponDbOnuDbaNumOfQueuesetGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaQueueThresholdSet(MV_U32 threshold, MV_U32 state, MV_U32 queueId,
+					   MV_U32 queueSet, MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaQueueThresholdGet(MV_U32 *threshold, MV_U32 *state, MV_U32 queueId,
+					   MV_U32 queueSet, MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaLlidThresholdGet(S_OnuEponDba *llidDba, MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaLlidActiveStatusSet(MV_U32 status, MV_U32 macId);
+MV_U32    onuEponDbOnuDbaLlidActiveStatusGet(MV_U32 macId);
+MV_STATUS onuEponDbOnuDbaModeSet(MV_U32 mode);
+MV_U32    onuEponDbOnuDbaModeGet(void);
+MV_STATUS onuEponDbOnuDbaSwForceModeSet(MV_U32 mode);
+MV_U32    onuEponDbOnuDbaSwForceModeGet(void);
+MV_STATUS onuEponDbOnuDbaSwGateIntModeSet(MV_U32 mode);
+MV_U32    onuEponDbOnuDbaSwGateIntModeGet(void);
+MV_STATUS onuEponDbOnuDbaSwModeQueuesetDirSet(MV_U32 dir);
+MV_U32    onuEponDbOnuDbaSwModeQueuesetDirGet(void);
+MV_STATUS onuEponDbOnuDbaSwModeQueueDirSet(MV_U32 dir);
+MV_U32    onuEponDbOnuDbaSwModeQueueDirGet(void);
+MV_STATUS onuEponDbOnuHoldoverStateSet(MV_U32 state);
+MV_U32    onuEponDbOnuHoldoverStateGet(void);
+MV_STATUS onuEponDbOnuHoldoverTimeSet(MV_U32 time);
+MV_U32    onuEponDbOnuHoldoverTimeGet(void);
+MV_STATUS onuEponDbOnuHoldoverExecSet(MV_U32 state);
+MV_U32    onuEponDbOnuHoldoverExecGet(void);
+MV_STATUS onuEponDbOnuOpticalLosTimeSet(MV_U16 losTime);
+MV_U32    onuEponDbOnuOpticalLosTimeGet(void);
+MV_STATUS onuEponDbOnuMacLosTimeSet(MV_U16 losTime);
+MV_U32    onuEponDbOnuMacLosTimeGet(void);
+MV_STATUS onuEponDbOnuPowerSavingWakeupSet(MV_U8 wakeUpEnable);
+MV_U32    onuEponDbOnuPowerSavingWakeupGet(void);
+MV_STATUS onuEponDbOnuPowerSavingMaxSleepDurationSet(MV_U32 maxSleepDuration);
+MV_U32    onuEponDbOnuPowerSavingMaxSleepDurationGet(void);
+MV_STATUS onuEponDbOnuSleepActionSet(MV_U8 action);
+MV_U32    onuEponDbOnuSleepActionGet(void);
+MV_STATUS onuEponDbOnuSleepModeSet(MV_U8 mode);
+MV_U32    onuEponDbOnuSleepModeGet(void);
+MV_STATUS onuEponDbOnuSleepDurationSet(MV_U32 sleepDuration);
+MV_U32    onuEponDbOnuSleepDurationGet(void);
+MV_STATUS onuEponDbOnuWakeupDurationSet(MV_U32 wakeupDuration);
+MV_U32    onuEponDbOnuWakeupDurationGet(void);
+MV_STATUS onuEponDbOnuSleepWakeupStatusSet(MV_U32 status);
+MV_U32    onuEponDbOnuSleepWakeupStatusGet(void);
+MV_STATUS onuEponDbOnuSilenceStateSet(MV_U32 state);
+MV_U32    onuEponDbOnuSilenceStateGet(void);
+MV_STATUS onuEponDbOnuSwRprtMacTimerIntervalSet(MV_U32 timerInterval);
+MV_U32    onuEponDbOnuSwRprtMacTimerIntervalGet(void);
+
+/* ONU EPON Data Path table API functions */
+MV_STATUS onuEponDbPktSizeSet(MV_U32 minSize, MV_U32 maxSize);
+MV_STATUS onuEponDbPktSizeGet(MV_U32 *minSize, MV_U32 *maxSize);
+MV_STATUS onuEponDbPktFilterPacketSet(MV_U32 forwardLlidAll, MV_U32 forwardLlid1XXX,
+				      MV_U32 forwardLlid1FFF, MV_U32 forwardLlid0FFF, MV_U32 dropLlid1NNN);
+MV_STATUS onuEponDbPktFilterPacketGet(MV_U32 *forwardLlidAll, MV_U32 *forwardLlid1XXX,
+				      MV_U32 *forwardLlid1FFF, MV_U32 *forwardLlid0FFF, MV_U32 *dropLlid1NNN);
+MV_STATUS onuEponDbPktFilterErrorSet(MV_U32 ignoreLenErr, MV_U32 ignoreGmiiErr,
+				     MV_U32 ignoreFcsErr, MV_U32 ignoreLlidCrcErr);
+MV_STATUS onuEponDbPktFilterErrorGet(MV_U32 *ignoreLenErr, MV_U32 *ignoreGmiiErr,
+				     MV_U32 *ignoreFcsErr, MV_U32 *ignoreLlidCrcErr);
+MV_STATUS onuEponDbPktForwardSet(MV_U32 slowFrameToCtrlQueue, MV_U32 slowFrameToRprtQueue,
+				 MV_U32 rprtFrameToRprtQueue, MV_U32 rprtFrameToDataQueue,
+				 MV_U32 ctrlFrameToCtrlQueue, MV_U32 ctrlFrameToDataQueue);
+MV_STATUS onuEponDbPktForwardGet(MV_U32 *slowFrameToCtrlQueue, MV_U32 *slowFrameToRprtQueue,
+				 MV_U32 *rprtFrameToRprtQueue, MV_U32 *rprtFrameToDataQueue,
+				 MV_U32 *ctrlFrameToCtrlQueue, MV_U32 *ctrlFrameToDataQueue);
+MV_STATUS onuEponDbPktRxLlidSet(MV_U32 llid, MV_U32 index);
+MV_STATUS onuEponDbPktRxLlidGet(MV_U32 *llid, MV_U32 index);
+MV_STATUS onuEponDbPktTxLlidSet(MV_U32 llid, MV_U32 index);
+MV_STATUS onuEponDbPktTxLlidGet(MV_U32 *llid, MV_U32 index);
+
+MV_STATUS        onuEponDbStatusNotifySet(STATUSNOTIFYFUNC statusCallback);
+STATUSNOTIFYFUNC onuEponDbStatusNotifyGet(void);
+
+MV_STATUS        onuEponDbDgCallbackSet(DYINGGASPFUNC dgCallback);
+DYINGGASPFUNC    onuEponDbDgCallbackGet(void);
+
+MV_STATUS        onuEponDbLinkStatusCallbackSet(LINKSTATUSFUNC linkStatusCallback);
+LINKSTATUSFUNC   onuEponDbLinkStatusCallbackGet(void);
+
+MV_STATUS matchDestAddressToMacId(MV_U8 *destAddr, MV_U32 *macId);
+MV_STATUS onuEponOnuFixMacAddrSet(MV_U16 llid, MV_U8 *mac);
+MV_STATUS onuEponOnuMacTblUpdate(int port_id, void *addr);
+
+MV_STATUS   onuEponDbModeSet(MV_U32 mode);
+MV_U32      onuEponDbModeGet(void);
+MV_STATUS   onuEponDbP2PForceModeSet(MV_U32 mode);
+MV_U32      onuEponDbP2PForceModeGet(void);
+MV_STATUS   onuEponDbPcsCfgSet(MV_U32 val);
+MV_U32      onuEponDbPcsCfgGet(void);
+MV_STATUS   onuEponDbOverheadSet(MV_U32 val);
+MV_U32      onuEponDbOverheadGet(void);
+
+MV_STATUS onuEponDbEoamChannelSet(S_OnuEoamChannel *eoamChannel);
+MV_STATUS onuEponDbEoamChannelGet(S_OnuEoamChannel *eoamChannel);
+MV_STATUS onuEponDbEoamRxQueueSet(MV_U32 eoamRxQueue);
+MV_STATUS onuEponDbEoamRxQueueGet(MV_U32 *eoamRxQueue);
+MV_STATUS onuEponDbHighPriTxStateSet(MV_BOOL state);
+MV_STATUS onuEponDbHighPriTxStateGet(MV_BOOL *state);
+MV_STATUS onuEponDbHighPriTxMapSet(MV_U32 llid_bm);
+MV_STATUS onuEponDbHighPriTxMapGet(MV_U32 *llid_bm);
+
+MV_STATUS onuEponHwDbaAdditionalOamBytesSet(S_EponOamDbaByte *dbaOamByte);
+MV_STATUS onuEponHwDbaAdditionalOamBytesGet(S_EponOamDbaByte *dbaOamByte);
+MV_STATUS onuEponOamFifoSizeSet(MV_U32 val);
+MV_U32    onuEponOamFifoSizeGet(void);
+MV_STATUS onuEponDbOnuLoidAuthStateSet(MV_BOOL state, MV_U32 macId);
+MV_U32    onuEponDbOnuLoidAuthStateGet(MV_U32 macId);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_DB_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuHeader.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuHeader.h
new file mode 100644
index 0000000..d858c46
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuHeader.h
@@ -0,0 +1,123 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuHeader.h                                           **/
+/**                                                                          **/
+/**  DESCRIPTION : This file pon module header files                         **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*                                                                            *
+******************************************************************************/
+
+#ifndef _ONU_EPON_HEADER_H
+#define _ONU_EPON_HEADER_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuRtos.h"
+#include "mvPonOnuDefines.h"
+#include "mvPonOnuRegs.h"
+#include "mvPonOnuMac.h"
+#include "eponOnuBoard.h"
+#include "eponOnuLnxKsOs.h"
+#include "eponOnuLnxKsMI.h"
+#include "eponOnuLnxKsUI.h"
+#include "eponOnuStd.h"
+#include "eponOnuInit.h"
+#include "eponOnuIsr.h"
+#include "eponOnuApi.h"
+#include "eponOnuDb.h"
+#include "eponOnuPm.h"
+#include "eponOnuMngr.h"
+#include "eponOnuStd.h"
+#include "ponOnuBoard.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_HEADER_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.c
new file mode 100644
index 0000000..3d6cc49
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.c
@@ -0,0 +1,924 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuInit.c                                             **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON init sequence definitions     **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuInit.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuEponPreSetup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu pre-setup init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**               MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponPreSetup(void)
+{
+	MV_STATUS rcode = MV_OK;
+
+	/* init PON spin lock */
+	spin_lock_init(&onuPonIrqLock);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuEponSetup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu setup init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**               MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponSetup(void)
+{
+	MV_STATUS rcode;
+
+	/* init onu base address */
+	rcode = onuEponGlbAddrInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init onu base address\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	ponXvrFunc = EponXvrSDPolarityHighStatus;
+	/* init onu database */
+	rcode = onuEponDbInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init onu database\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* init onu Asic */
+	rcode = onuEponAsicInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init asic\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* init onu event handling */
+	rcode = onuPonEventInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init PON event handling\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponAsicLedsInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu leds
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponAsicLedsInit(void)
+{
+	onuPonLedInit();
+
+	onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_OFF);
+	onuPonLedHandler(ONU_PON_SYS_LED, ACTIVE_LED_ON);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponAsicInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu EPON MAC configuration
+**
+**  PARAMETERS:  MV_BOOL initTime - init indication flag, true = init sequence
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponAsicInit(void)
+{
+	MV_STATUS status;
+	MV_U32 macAddrHigh;
+	MV_U32 macAddrLow;
+
+#ifndef PON_Z1
+	MV_U32 pcsConfig;
+#endif  /* PON_Z1 */
+	MV_U32 macId;
+	MV_U32 familyId = MV_88F66X0;    /*mvCtrlModelGet();*/
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	if (mvBoardIdGet() == RD_6660_ID) {
+		status = onuEponMppInit();
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) onuEponMppInit\n", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+#endif
+#endif  /* PON_FPGA */
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	status = onuEponSerdesInit();
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponSerdesInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+#endif
+#endif  /*PON_FPGA */
+
+	onuEponAsicLedsInit();
+
+	/* Setup TX power ON/OFF GPP and turn TX power OFF */
+	status = onuPonTxPowerControlInit();
+	if (status == MV_OK)
+		status = onuPonTxPowerOn(MV_FALSE);
+
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Unable to configure TX POWER GPP\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Disable MAC */
+	status = mvOnuEponMacOnuEnableSet(ONU_RX_DIS, ONU_TX_DIS);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuStateSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* MAC State */
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = mvOnuEponMacOnuStateSet(ONU_EPON_NOT_REGISTERD, macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacOnuStateSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	/* Broadcast Address */
+	status = mvOnuEponMacGenBcastAddrSet(ONU_BROADCAST_ADDR_HIGH, ONU_BROADCAST_ADDR_LOW);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenBcastAddrSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Unicast Address */
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		onuEponDbOnuMacAddrGet(&macAddrLow, &macAddrHigh, macId);
+
+		status = mvOnuEponMacGenUcastAddrSet(macAddrHigh, macAddrLow, macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacGenUcastAddrSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	/* Sync Time */
+	status = mvOnuEponMacGenSyncTimeSet(ONU_DEF_SYNC_TIME,
+					    ONU_DEF_SYNC_TIME_ADD,
+					    ONU_DEF_SYNC_TIME_FORCE_SW,
+					    ONU_DEF_SYNC_TIME_DIS_GATE_AUTO,
+					    ONU_DEF_SYNC_TIME_DIS_DISCOVER_AUTO);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenSyncTimeSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacDdmDelaySet(ONU_DEF_DDM_DELAY);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvAsicReg_EPON_DDM_1814_CONFIG\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacRxpPacketForwardSet(ONU_CTRL_FRAME_TO_DATA_QUEUE,
+						 ONU_CTRL_FRAME_TO_CTRL_QUEUE,
+						 ONU_RPRT_FRAME_TO_DATA_QUEUE,
+						 ONU_RPRT_FRAME_TO_RPRT_QUEUE,
+						 ONU_SLOW_FRAME_TO_RPRT_QUEUE,
+						 ONU_SLOW_FRAME_TO_CTRL_QUEUE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpPacketForwardSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacOnuRegAutoUpdateStateSet(1);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuAutoUpdateStateSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* ONU_REPORT_AUTO_RES is always ON */
+	/* In case of SW Report via Control FIFO, the HW will send empty report - keep alive */
+	status = mvOnuEponMacGenOnuConfigSet(ONU_RX_PCS_FEC_DIS,
+					     ONU_TX_PCS_FEC_DIS,
+					     ONU_REPORT_AUTO_RES,
+					     ONU_REG_ACK_AUTO_RES,
+					     ONU_REG_REQ_AUTO_RES,
+					     ONU_TX_FEC_DIS);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenOnuConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacRxpPacketFilterSet(ONU_FORWARD_LLID_CRC_ERR_PKT,
+						ONU_FORWARD_LLID_FCS_ERR_PKT,
+						ONU_FORWARD_LLID_GMII_ERR_PKT,
+						ONU_FORWARD_LLID_LEN_ERR_PKT,
+						ONU_FORWARD_LLID_ALL_PKT,
+						ONU_FORWARD_LLID_7FFF_MODE_0_PKT,
+						ONU_FORWARD_LLID_7FFF_MODE_1_PKT,
+						ONU_FORWARD_LLID_XXXX_MODE_1_PKT,
+						ONU_DROP_LLID_NNNN_MODE_1_PKT);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpPacketFilterSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacGenLaserParamSet(ONU_DEF_LASER_ON_OFF_TIME,
+					      ONU_DEF_LASER_ON_TIME,
+					      ONU_DEF_LASER_OFF_TIME);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenLaserParamSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = mvOnuEponMacTxmLlidSet(ONU_DEF_TX_LLID, macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacTxmLlidSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		status = mvOnuEponMacRxpLlidDataSet(ONU_DEF_RX_LLID, macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacRxpLlidDataSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+#ifdef PON_Z1
+	status = mvOnuEponMacTxmConfigSet(ONU_DEF_TXM_CFG_MODE,
+					  ONU_DEF_TXM_CFG_ALIGNMENT,
+					  ONU_DEF_TXM_CFG_PRIORITY);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+#else   /* Z2,A0 or later */
+
+	status = mvOnuEponMacTxmOverheadSet(0x0E01);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmOverheadSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacTxmConfigSet(ONU_DEF_TXM_CFG_TFEC_1,
+					  ONU_DEF_TXM_CFG_TFEC_2,
+					  ONU_DEF_TXM_CFG_CTRL_FIFO_DIS_FCS_OFF,
+					  ONU_DEF_TXM_CFG_MASK_GMII_OFF,
+					  ONU_DEF_TXM_CFG_BLOCK_DATA_OFF,
+					  ONU_DEF_TXM_CFG_IPG_ADD,
+					  ONU_DEF_TXM_CFG_MODE_EPON,
+					  ONU_DEF_TXM_CFG_ALIGNMENT_EVEN,
+					  ONU_DEF_TXM_CFG_PRIORITY_CTRL_FIRST);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	pcsConfig = (ONU_DEF_PCS_CFG_RX_EN | ONU_DEF_PCS_CFG_TX_EN);
+	status = mvOnuEponMacPcsConfigSet(pcsConfig);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacPcsConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	if (familyId == MV_88F66X0) {
+		/* DDM TX Polarity */
+		status = mvOnuEponMacDdmTxPolaritySet(EPON_DDM_TX_EN_MASK_DEFAULT,
+						      EPON_DDM_TX_TX_POL_DEFAULT,
+						      EPON_DDM_TX_SERDES_POL_DEFAULT,
+						      EPON_DDM_TX_XVR_POL_DEFAULT,
+						      EPON_DDM_TX_BURST_ENA_DEFAULT);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacDdmTxPolaritySet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	} /* familyId == MV_88F66X0*/
+
+	status = mvOnuEponMacGpmDiscoveryGrantLengthSet(0x26,  /* grantLength */
+							0x06,   /* addOffsetForCalc */
+							0x32);  /* grantLengthMultiTq */
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGpmDiscoveryGrantLengthSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacGenTimestampConfig(0x0,    /* gpmAddSyncTimeToTimestamp */
+						0x760,  /* gpmAimestampOffset */
+						0x1,    /* txmAddSyncTimeToTimestamp */
+						0x0,    /* txmUseTimestampImage */
+						0x77B); /* txmTimestampOffset) */
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenTimestampConfig\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* ==================================== */
+	/* ==         DBA REPORT MODE        == */
+	/* ==================================== */
+	if ((familyId != MV_88F66X0) || (onuEponDbOnuDbaSwForceModeGet() == ONU_DBA_SW_FORCE_MODE_EN)) {
+		/* ==================================== */
+		/* ==         SW REPORT MODE         == */
+		/* ==================================== */
+		for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			status  = mvOnuEponMacTxmCppReportConfig(0xFF,  /* Queueset2 not supported - set to 0xFF (queueReportQ2) */
+								 0x1,   /* Queueset2 not supported - set to 0x1, Software (reportBitmapQ2) */
+								 0xFF,  /* Queueset1 supported - set to 0, means all 8 queues are active (queueReport) */
+								 0x1,   /* Number of queueSet - support for 1 queueset */
+								 0x1,   /* Queueset1 supported - set to 0x1, Software (reportBitmap) */
+								 macId);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+					   "ERROR: (%s:%d) mvOnuEponMacTxmCppReportConfig, macId=%d\n\r",
+					   __FILE_DESC__, __LINE__, macId);
+				return MV_ERROR;
+			}
+		}
+
+		if (familyId == MV_88F66X0) { /* force SW mode is activated */
+			status = mvOnuEponMacTxmCppRpmReportConfigSet(EPON_RPM_BITMAP_ORDER_SW,
+								      EPON_RPM_QSET_ORDER_SW,
+								      EPON_RPM_REPORT_MODE_SW);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+					   "ERROR: (%s:%d) mvOnuEponMacTxmCppRpmReportConfigSet\n\r",
+					   __FILE_DESC__, __LINE__);
+				return MV_ERROR;
+			}
+		}
+	} else {
+		/* ==================================== */
+		/* ==         HW REPORT MODE         == */
+		/* ==================================== */
+		/* familyId == MV_88F66X0 and swDbaForceMode == MV_FALSE */
+
+		for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			/* HW report build for MC by default */
+			status  = mvOnuEponMacTxmCppReportConfig(0xFF,  /* Queueset2 not supported - set to 0xFF (queueReportQ2) */
+								 0x1,   /* Queueset2 not supported - set to 0x1, Software (reportBitmapQ2) */
+								 0x0,   /* Queueset1 supported - set to 0, means all 8 queues are active (queueReport) */
+								 0x1,   /* Number of queueSet - support for 1 queueset */
+								 0x0,   /* Queueset1 supported - set to 0x1, Software (reportBitmap) */
+								 macId);
+
+			status |= mvOnuEponMacTxmCppReportBitMap(0x00FF, macId); /* Queueset1 -
+										  * 8 queues enabled(0xFF),
+										  * 8 queues disabled(0x00) */
+			status |= mvOnuEponMacTxmCppReportQueueSet(0x1, macId);  /* Number of queuesets -
+										  * support for 1 queueset */
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+					   "ERROR: (%s:%d) mvOnuEponMacTxmCppReportConfig, macId=%d\n\r",
+					   __FILE_DESC__, __LINE__, macId);
+				return MV_ERROR;
+			}
+		}
+
+		status |= mvOnuEponMacTxmCppRpmReportConfigSet(EPON_RPM_BITMAP_ORDER_HW,
+							       EPON_RPM_QSET_ORDER_HW,
+							       EPON_RPM_REPORT_MODE_HW);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacTxmCppRpmReportConfigSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	} /* familyId == MV_88F66X0*/
+
+	if (familyId == MV_88F66X0) {
+		/* TOD interrupt setup */
+		status = mvOnuEponMacGenTimeOfDayIntConfigSet(EPON_TOD_INT_POL_ACTIVE_HIGH, EPON_TOD_INT_DEFAULT_WIDTH);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacGenTimeOfDayIntConfigSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		/* TX MUX Power Up */
+		status = mvOnuEponMacTxmPowerUpIndSet(EPON_TXM_POWERUP_DEFAULT_TIME);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacTxmPowerUpIndSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		/* UTM TX bitmap */
+		status =  mvOnuEponMacGenUtmActTxBitmapSet(EPON_UTM_TX_BITMAP_DEFAULT);
+		status |= mvOnuEponMacGenUtmActTxBitmapEnSet(EPON_UTM_TX_BITMAP_VALID_DEFAULT);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacGenUtmActTxBitmapSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	status = mvOnuEponMacGenUtmTcPeriodSet(0x100);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenUtmTcPeriodSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacGenUtmTcPeriodEnSet(0x1);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacGenUtmTcPeriodEnSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuPonMacBurstEnableInit();
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuPonMacBurstEnableInit\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+#endif  /* Z2,A0 and later */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponAsicReInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function re-init default onu EPON MAC configuration
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponAsicReInit(MV_U32 macId, MV_U32 silenceMode)
+{
+	MV_STATUS status;
+	MV_U32 rxGenFecEn    = 0;
+	MV_U32 txGenFecEn    = 0;
+	MV_U32 txMacFecEn[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+#ifdef PON_A0
+	MV_U32 llidIndex     = 0;
+#endif
+	status = mvOnuEponMacOnuStateSet(ONU_EPON_NOT_REGISTERD, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuStateSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacTxmLlidSet(ONU_DEF_TX_LLID, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmLlidSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacRxpLlidDataSet(ONU_DEF_RX_LLID, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpLlidDataSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* handle silence mode */
+	if ((onuEponDbOnuSilenceStateGet() != ONU_SILENCE_NOT_ACTIVE) &&
+	    (silenceMode == ONU_SILENCE_ENABLED)) {
+		/* Clear onu Silence Timers */
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonSilenceTimerId[macId]));
+
+		status  = mvOnuEponMacGenOnuConfigAutoAckSet(ONU_REG_ACK_AUTO_RES);
+		status |= mvOnuEponMacGenOnuConfigAutoRequestSet(ONU_REG_REQ_AUTO_RES);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to enable auto request / ack\n\r", __FILE_DESC__, __LINE__);
+			return status;
+		}
+
+		onuEponDbOnuCfgAutoSet(ONU_REG_REQ_AUTO_RES, ONU_REG_ACK_AUTO_RES, ONU_REPORT_AUTO_RES);
+	}
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+		   "DEBUG: (%s:%d) onuEponAsicReInit, rxGenFecEn(%d), txGenFecEn(%d), txMacFecEn(%d,%d,%d,%d,%d,%d,%d,%d)\n",
+		   __FILE_DESC__, __LINE__, rxGenFecEn, txGenFecEn, txMacFecEn[0], txMacFecEn[1], txMacFecEn[2], txMacFecEn[3],
+		   txMacFecEn[4], txMacFecEn[5], txMacFecEn[6], txMacFecEn[7]);
+
+	status = onuEponApiFecConfig(rxGenFecEn, txGenFecEn, txMacFecEn, ONU_FEC_CFG_RE_INIT);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponApiFecConfig\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* clear OAM SW FIFO - Tx */
+	onuEponOamFlushAllMsg();
+
+#ifdef PON_A0
+	/* clear TX control FIFO */
+	for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++)
+		mvOnuEponMacTxmTxCtrlFiFoFlush(llidIndex);
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+		   "DEBUG: (%s:%d) onuEponAsicReInit, onuEponOamFlushAllMsg\n\r", __FILE_DESC__, __LINE__);
+#endif
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponSwitchOn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu switchOn init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponSwitchOn(void)
+{
+	MV_STATUS rcode;
+
+	/* init onu RTOS resources */
+	rcode = onuEponRtosResourceInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuPonRtosResourceInit\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	onuEponAppInit();
+
+	/* onu epon counters table */
+	onuEponPmInit();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOperate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu operate init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponOperate(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init ONU
+**
+**  PARAMETERS:  IOCTL Init data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponInit(S_EponIoctlInit *ioctlInit)
+{
+	MV_STATUS status;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask = 0;
+	MV_U32 llidIdx = 0;                     /* Support for single LLID */
+	MV_U32 familyId = MV_88F66X0;           /*mvCtrlModelGet();*/
+
+	interruptMask = (ONU_EPON_INTERRUPTS);
+	interruptMask &= ~(ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+	interruptMask &= ~(ONU_EPON_GATE_MASK);
+
+	/* Set EPON OAM CPU RX queue */
+	status = onuEponDbEoamRxQueueSet(ioctlInit->eoamRxQueue);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponDbEoamRxQueueSet\n\r",
+			   __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	/* Create EOAM channel */
+	status = onuEponEoamChannelAdd(ioctlInit->eoamRxQueue);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponEoamChannelAdd", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (onuEponDbOnuDbaModeGet() != ONU_DBA_HW_RPRT_MODE) {
+		/* enable onu pon interrupt mask */
+
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			interruptMask  |= (ONU_EPON_GATE_MASK);
+			llidDbaIntMask |= 1 << llidIdx;
+
+		} else {        /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+				/* Start SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_TRUE);
+
+			interruptMask |= (ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			llidDbaIntMask = 0;
+		}
+	}
+
+	status = mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) failed to set LLID DBA interrupt mask\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	status = mvOnuEponMacPonInterruptMaskSet(interruptMask);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Enable PON interrupt mask\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	/* re-set DBA mode */
+	/* DBA working modes */
+	/* Device == 6601 && mode != force SW DBA ==> HW DBA mode */
+	/* Device != 6601 || mode == force SW DBA ==> SW DBA mode */
+	status = onuEponDbOnuDbaSwForceModeSet(ioctlInit->ponDbaMode);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponDbOnuDbaSwForceModeSet\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if ((familyId == MV_88F66X0) && (onuEponDbOnuDbaSwForceModeGet() == ONU_DBA_SW_FORCE_MODE_DIS))
+		status = onuEponDbaModeInit(ONU_DBA_HW_RPRT_MODE);
+	else
+		status = onuEponDbaModeInit(ONU_DBA_SW_RPRT_MODE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponDbaModeInit\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	if (familyId == MV_88F66X0) {
+		/* re-set DDM TX Polarity */
+		status = mvOnuEponMacDdmTxPolaritySet(EPON_DDM_TX_EN_MASK_DEFAULT,
+						      ioctlInit->ponXvrPolarity,
+						      EPON_DDM_TX_SERDES_POL_DEFAULT,
+						      EPON_DDM_TX_XVR_POL_DEFAULT,
+						      ioctlInit->ponXvrBurstEnPolarity);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacDdmTxPolaritySet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	} /* familyId == MV_88F66X0*/
+
+	ponXvrFunc = funcEponXvrSDStatus(ioctlInit->ponXvrPolarity);
+
+	onuP2PDbXvrBurstEnablePolaritySet(ioctlInit->p2pXvrBurstEnPolarity);
+
+	onuEponHwDbaAdditionalOamBytesSet(&ioctlInit->dbaOamByte);
+#ifdef PON_A0
+	if (E_EPON_DBA_OAM_HW_ENABLE == ioctlInit->dbaOamByte.state)
+		mvOnuEponMacTxmCppRpmFifoDbaConfig(1, ioctlInit->dbaOamByte.queue, ioctlInit->dbaOamByte.byte_num);
+	else
+		mvOnuEponMacTxmCppRpmFifoDbaConfig(0, 0, 0);
+#endif
+	onuEponOamFifoSizeSet(ioctlInit->oamFifoSize);
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	/* enable onu dying gasp interrupt mask */
+	status = mvOnuPonMacDgInterruptEn(ioctlInit->dgPolarity);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuPonMacDgInterruptEn\n", __FILE_DESC__, __LINE__);
+		return status;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	status = mvEponApi2kSupportedSet(ioctlInit->pkt2kSupported);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvEponApi2kSupportedSet\r\n", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	/* Enable MAC */
+	status = mvOnuEponMacOnuRxEnableSet(ONU_RX_EN);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuRxEnableSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Turn ON TX Power */
+	status = onuPonTxPowerOn(MV_TRUE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuPonTxPowerOn\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacOnuTxEnableSet(ONU_TX_EN, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuTxEnableSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuIOEnable\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	/* start onu pon pon pm timer */
+	onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonPmTimerId));
+
+	/* start onu pon pon mpc timer */
+	onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonMpcpTimerId));
+
+	/* set TX high priority TX state */
+#ifdef PON_A0
+	status = onuEponApiTxLlidMapStateSet(INT_TO_MV_BOOL(ioctlInit->highPriTx.state));
+	PON_IF_ERROR(PON_INIT_MODULE, status, "fail to set high priority TX state\n");
+	if (ioctlInit->highPriTx.state) {
+		status = onuEponApiTxLlidMapSet(ioctlInit->highPriTx.llid_bm);
+		PON_IF_ERROR(PON_INIT_MODULE, status, "fail to set high priority TX map\n");
+	}
+#endif
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.h
new file mode 100644
index 0000000..e08af08
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuInit.h
@@ -0,0 +1,125 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuInit.h                                             **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON init sequence definitions     **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_INIT_H
+#define _ONU_EPON_INIT_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponAsicInit(void);
+MV_STATUS onuGponAppInit(void);
+void      onuGponStateAndEventTblInit(void);
+void      onuGponInPmInit(void);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponPreSetup(void);
+MV_STATUS onuEponSetup(void);
+MV_STATUS onuEponSwitchOn(void);
+MV_STATUS onuEponOperate(void);
+
+MV_STATUS onuEponAsicReInit(MV_U32 macId, MV_U32 silenceMode);
+MV_STATUS onuEponRtosResourceRelease(void);
+MV_STATUS onuEponInit(S_EponIoctlInit *ioctlInit);
+
+#if 0 /* NOT USED */
+MV_STATUS onuEponAsicQueueEnable(MV_U32 macId);
+MV_STATUS onuEponAsicQueueDisable(MV_U32 macId);
+#endif /* NOT USED */
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_INIT_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.c
new file mode 100644
index 0000000..d27b8a5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.c
@@ -0,0 +1,1248 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuIsr.c                                              **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON Interrupt handling          **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuIsr.c"
+
+#define MV_NO_XVR_RST (0xFF)
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 onuEponCurrentInterrupt = 0;
+MV_U32 onuEponRxMacCtrlPackets = 0;
+MV_U32 onuEponTxMacByteAllowed = 0;
+MV_U32 recvGateFrameBase       = 0;
+MV_U32 recvDiscNotRegFrameBase = 0;
+MV_U32 sendCtrlRegReqFrameBase = 0;
+MV_U32 regRandomInitInd        = 0;
+MV_U32 regRandomCheckThreshold = 3 /*10*/;
+MV_U32 regRandomMaskThreshold  = 0x1FF; /* 0-512 msec */
+MV_U32 regRandomResetState     = 0;     /* Off */
+
+MV_U32 isrTimestampEventCnt    = 0;
+MV_U32 isrTimestampEventMiss   = 0;
+MV_U32 isrInvalidRegState      = 0;
+
+MV_U32 isrP2pPreviousFecState  = 0;
+
+MV_BOOL eponMgmtForceTxDisable = MV_FALSE;
+
+/*******************************************************************************
+**
+**  onuEponIsrLowRoutine
+**
+*******************************************************************************/
+void onuEponIsrLowRoutine(MV_U32 *interruptEvent, MV_U32 *interruptStatus)
+{
+	MV_U32 interrupt;
+
+	mvOnuEponMacPonInterruptGet(&interrupt);
+	onuEponCurrentInterrupt &= 0xFFFF0000;
+	onuEponCurrentInterrupt |= interrupt;
+
+	*interruptEvent  = (onuEponCurrentInterrupt >> ONU_EPON_EVENT_SHIFT) & ONU_EPON_INTERRUPTS;
+	*interruptStatus =  onuEponCurrentInterrupt                          & ONU_EPON_INTERRUPTS;
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+		   "DEBUG: (%s:%d) Event(0x%08X) Status(0x%08X)\n",
+		   __FILE_DESC__, __LINE__, *interruptEvent, *interruptStatus);
+
+	onuEponCurrentInterrupt = 0;
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements interrupt handler
+**
+**  PARAMETERS:  None, void* param
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None, void*
+**
+*******************************************************************************/
+void onuEponIsrRoutine(MV_U32 event, MV_U32 status)
+{
+	MV_BOOL state;
+	MV_U32 rxGenFecEn      = 0;
+	MV_U32 interruptEvent  = 0;
+	MV_U32 interruptStatus = 0;
+
+#ifdef PON_A0
+	MV_U32 llidIndex       = 0;
+#endif
+	LINKSTATUSFUNC linkStatusCallback;
+
+#ifdef MV_EPON_HW_INTERRUPT
+	onuEponIsrLowRoutine(&interruptEvent, &interruptStatus);
+#else
+	interruptEvent  = event;
+	interruptStatus = status;
+#endif  /* MV_GPON_HW_INTERRUPT */
+
+	/* Interrupt Protect */
+	/* ================= */
+
+	if (interruptEvent & ONU_EPON_XVR_SD_MASK) {
+		state = ponXvrFunc(interruptStatus, ONU_EPON_XVR_SD_MASK);
+		if (state == MV_FALSE) {
+			onuEponDbOnuSignalDetectSet(1); /* alarm is OFF */
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+				   "DEBUG: (%s:%d) Signal Detect ON\n", __FILE_DESC__, __LINE__);
+		} else if (state == MV_TRUE) {
+			onuEponDbOnuSignalDetectSet(0); /* alarm is ON */
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+				   "DEBUG: (%s:%d) Signal Detect OFF\n", __FILE_DESC__, __LINE__);
+		}
+
+		onuEponPonMngIntrAlarmHandler(ONU_EPON_XVR_SD_MASK, state);
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+			   "DEBUG: (%s:%d) Link %s\n", __FILE_DESC__, __LINE__, (state == MV_FALSE) ? "On" : "Off");
+
+		if (state == MV_FALSE) { /* alarm is OFF */
+			onuEponDbOnuRxFecCfgGet(&rxGenFecEn);
+
+			if (rxGenFecEn != ONU_RX_PCS_FEC_DIS)           /* config PCS synchronization */
+				mvOnuEponMacPcsDelaySet(0x1058);        /*configuration - FEC enabled */
+
+			onuEponIsrXvrReset();
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+				   "DEBUG: (%s:%d) ResetRandomStateMachine %s\n", __FILE_DESC__, __LINE__);
+			onuEponIsrResetRandomStateMachine();
+
+			/* Call link status callback function */
+			if (onuEponDbModeGet() == E_EPON_IOCTL_P2P_MODE) {
+				linkStatusCallback = onuEponDbLinkStatusCallbackGet();
+				if (linkStatusCallback != NULL) {
+					linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_TRUE);
+					mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+						   "DEBUG: (%s:%d) Notify link is UP\n", __FILE_DESC__, __LINE__);
+				}
+			}
+		} else if (state == MV_TRUE) { /* alarm is ON */
+			if (onuEponDbP2PForceModeGet())
+				/* set P2P mode */
+				onuEponDbModeSet(E_EPON_IOCTL_P2P_MODE);
+			else
+				/* set EPON mode */
+				onuEponDbModeSet(E_EPON_IOCTL_STD_MODE);
+
+			/* config PCS synchronization configuration  - FEC disabled */
+			mvOnuEponMacPcsDelaySet(0x1C58);
+			/* clear Rx Ctrl message FIFO */
+			onuEponPonMngIntrRxCtrlFifoCleanup();
+			/* clear OAM SW FIFO - Tx */
+			onuEponOamFlushAllMsg();
+#ifdef PON_A0
+			/* clear TX control FIFO */
+			for (llidIndex = 0; llidIndex < EPON_MAX_MAC_NUM; llidIndex++)
+				mvOnuEponMacTxmTxCtrlFiFoFlush(llidIndex);
+#endif
+			/* start xvr reset timer */
+			onuEponIsrXvrResetStateSet(MV_TRUE);
+		}
+	}
+
+	if (interruptEvent & ONU_EPON_SERDES_SD_MASK) {
+		state = (interruptStatus & ONU_EPON_SERDES_SD_MASK) ? MV_FALSE : MV_TRUE;
+		onuEponPonMngIntrAlarmHandler(ONU_EPON_SERDES_SD_MASK, state);
+	}
+
+	if (interruptEvent & ONU_EPON_TIMESTAMP_DRIFT_MASK) {
+		state = (interruptStatus & ONU_EPON_TIMESTAMP_DRIFT_MASK) ? MV_TRUE : MV_FALSE;
+		onuEponPonMngIntrAlarmHandler(ONU_EPON_TIMESTAMP_DRIFT_MASK, state);
+	}
+
+	if (interruptEvent & ONU_EPON_DS_SYNC_OK_PCS_MASK) {
+		state = (interruptStatus & ONU_EPON_DS_SYNC_OK_PCS_MASK) ? MV_TRUE : MV_FALSE;
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+			   "DEBUG: (%s:%d) PCS Sync %s\n", __FILE_DESC__, __LINE__, (state == MV_FALSE) ? "Off" : "On");
+
+		if (state == MV_TRUE)
+			onuEponDbOnuDsSyncOkPcsSet(1);  /* set DS Sync OK PCS to ON */
+		else if (state == MV_FALSE)
+			onuEponDbOnuDsSyncOkPcsSet(0);  /* set DS Sync OK PCS to OFF */
+	}
+
+	if (interruptEvent & ONU_EPON_REGISTERED_LLID_0_MASK) {
+		/* state = (interruptStatus & ONU_EPON_REGISTERED_LLID_0_MASK) ? MV_TRUE : MV_FALSE;
+		   onuEponPonMngIntrRegHandler(ONU_EPON_REGISTERED_LLID_0_MASK, state); */
+	}
+
+	/* Event is triggered for each change in the Status  */
+	/* Status == 0, means there is something in the FIFO */
+	/* Status == 1, means there is nothing in the FIFO   */
+	/* ================================================= */
+	if ((interruptEvent   & ONU_EPON_RX_CTRL_QUEUE_MASK) &&
+	    ((interruptStatus & ONU_EPON_RX_CTRL_QUEUE_MASK) == 0))
+		onuEponPonMngIntrMessageHandler(ONU_EPON_RX_CTRL_MSG);
+
+	if ((interruptEvent   & ONU_EPON_RX_RPRT_QUEUE_MASK) &&
+	    ((interruptStatus & ONU_EPON_RX_RPRT_QUEUE_MASK) == 0))
+		onuEponPonMngIntrMessageHandler(ONU_EPON_RX_RPRT_MSG);
+
+	if (interruptEvent & ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK) {
+		/* Set onu DBA Report interrupt */
+		onuEponPonMngTxCtrlMessageHandler();
+		onuEponDbaSwRprtMacTimerCfg(onuEponDbOnuSwRprtMacTimerIntervalGet());
+		isrTimestampEventCnt++;
+	}
+	if (interruptEvent & ONU_EPON_GATE_MASK) {
+		MV_U32 dbrInt, llidInt;
+
+		mvOnuEponMacPonDbrLlidInterruptGet(0, &llidInt); /* LLID 0 only for now */
+		mvOnuEponMacPonDbrInterruptGet(&dbrInt);
+		/* Checking the dbrInt should be enough, but it not always hits - TODO */
+		if ((dbrInt != 0) || (llidInt != 0))
+			onuEponPonMngTxCtrlMessageHandler();
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponDgIsrRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements Dying Gasp
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponDgIsrRoutine(void)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	onuEponPonMngIntrDgHandler();
+#endif
+#endif  /* PON_FPGA */
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrResetRandomStateMachine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear Random state machine
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrResetRandomStateMachine(void)
+{
+	/* enable tx */
+	if (onuEponForceTxDownStateGet(0) != MV_TRUE)
+		mvOnuEponMacOnuTxEnableSet(ONU_TX_EN, 0);
+
+	/* restore MPCP timer interval */
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonMpcpTimerId), 0, ONU_PON_TIMER_MPCP_INTERVAL, 1);
+
+	/* clear all required counters for handling random delay for ONU transmission */
+	recvGateFrameBase       = 0;
+	recvDiscNotRegFrameBase = 0;
+	sendCtrlRegReqFrameBase = 0;
+	regRandomInitInd        = 0;
+	regRandomResetState     = 0;
+	onuEponPmRandomReset();
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerMpcpHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function validate mpcp frames arrival rate
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrTimerMpcpHndl(unsigned long data)
+{
+	MV_U32 currentCtrlPackets      = 0;
+	MV_U32 currentTxByteAllowed    = 0;
+	MV_U32 recvGateFrame           = 0;
+	MV_U32 recvDiscoverNotRegFrame = 0;
+	MV_U32 sendCtrlRegReqFrame     = 0;
+	MV_U32 randomTime              = 0;
+	MV_U32 randomShift             = 0;
+	MV_U32 randomRange             = 0;
+	MV_U32 state                   = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonMpcpTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	if (regRandomResetState != 0) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+			   "DEBUG: (%s:%d) Reset Random State Machine\n", __FILE_DESC__, __LINE__);
+		onuEponIsrResetRandomStateMachine();
+	} else {
+		if (onuEponDbOnuStateGet(0) == ONU_EPON_03_OPERATION) {
+			/* = Rx Ctrl Packet Check = */
+			/* ======================== */
+			currentCtrlPackets   = onuEponPmCtrlCntGet(0);
+			currentTxByteAllowed = onuEponPmTxByteCntGet(0);
+
+			if ((currentTxByteAllowed == onuEponTxMacByteAllowed) ||
+			    (currentCtrlPackets   == onuEponRxMacCtrlPackets)) {
+				/* Holdover Active */
+				if (onuEponDbOnuHoldoverStateGet() != ONU_HOLDOVER_NOT_ACTIVE) {
+					if (onuEponDbOnuHoldoverExecGet() != ONU_HOLDOVER_ACTIVE) {
+						/* start onu epon pon holdover timer */
+						onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonHoldoverTimerId));
+						onuEponDbOnuHoldoverExecSet(ONU_HOLDOVER_ACTIVE);
+
+						mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+							   "DEBUG: (%s:%d) Holdover Timer Start(Tmr)\n",
+							   __FILE_DESC__, __LINE__);
+					}
+				} else  /* Holdover Not Active */
+					onuEponPonMngAlarmHandlerExecute(ALL_MAC_INDICATION);
+			}
+
+			onuEponRxMacCtrlPackets = currentCtrlPackets;
+			onuEponTxMacByteAllowed = currentTxByteAllowed;
+
+			/* clear all required counters for handling random delay for ONU transmission */
+			onuEponIsrResetRandomStateMachine();
+
+			isrInvalidRegState = 0;
+		}else { /* (onuEponDbOnuStateGet(0) != ONU_EPON_03_OPERATION) */
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+				   "DEBUG: (%s:%d) MPCP state not registered\n", __FILE_DESC__, __LINE__);
+
+			/* handling of invalid ONU register state */
+			/* ====================================== */
+			mvOnuEponMacOnuStateGet(&state, 0);
+			if (state != 0) {
+				isrInvalidRegState++;
+				if (isrInvalidRegState >= 2) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+						   "DEBUG: (%s:%d) Force ONU Re-registration\n",
+						   __FILE_DESC__, __LINE__);
+
+					mvOnuEponMacOnuStateSet(ONU_EPON_NOT_REGISTERD, 0);
+					isrInvalidRegState = 0;
+				}
+			}
+
+			/* handling of random delay for ONU transmission to disable transmission collisions */
+			/* ================================================================================ */
+			/* get counters for random transmission check */
+			onuEponPmRandomThresholdCheck(&recvGateFrame,
+						      &recvDiscoverNotRegFrame,
+						      &sendCtrlRegReqFrame);
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+				   "regRandomInitInd (%d)\n", regRandomInitInd);
+
+			if (regRandomInitInd == 0) {
+				/* save current counter state for future comparison */
+				recvGateFrameBase       = recvGateFrame;
+				recvDiscNotRegFrameBase = recvDiscoverNotRegFrame;
+				sendCtrlRegReqFrameBase = sendCtrlRegReqFrame;
+
+				regRandomInitInd = 1;
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+					   "DEBUG[0]: B-gate(%d)disc(%d)regReq(%d), regRandomInitInd(%d)\n",
+					   recvGateFrameBase, recvDiscNotRegFrameBase, sendCtrlRegReqFrameBase,
+					   regRandomInitInd);
+			}
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+				   "DEBUG[1]: C-gate(%d)disc(%d)regReq(%d)\n"
+				   "DEBUG[1]: B-gate(%d)disc(%d)regReq(%d), regRandomInitInd(%d), regRandomResetState(%d)\n",
+				   recvGateFrame, recvDiscoverNotRegFrame, sendCtrlRegReqFrame,
+				   recvGateFrameBase, recvDiscNotRegFrameBase, sendCtrlRegReqFrameBase,
+				   regRandomInitInd, regRandomResetState);
+
+			/* start random timer section */
+			if (((recvGateFrame           - recvGateFrameBase)       > regRandomCheckThreshold) &&
+			    ((recvDiscoverNotRegFrame - recvDiscNotRegFrameBase) > regRandomCheckThreshold) &&
+			    ((sendCtrlRegReqFrame     - sendCtrlRegReqFrameBase) > regRandomCheckThreshold)) {
+				/* calc random value */
+				onuEponPmRandomGet(&randomTime);
+				randomShift = ((randomTime >> 16) & 0xF);
+				randomRange = ((randomTime >> randomShift) & regRandomMaskThreshold);
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_ISR_RAND_MODULE,
+					   "DEBUG[2]: C-gate(%d)disc(%d)regReq(%d)\n"
+					   "DEBUG[2]: B-gate(%d)disc(%d)regReq(%d), thres(%d)randtime(%d)\n",
+					   recvGateFrame, recvDiscoverNotRegFrame, sendCtrlRegReqFrame,
+					   recvGateFrameBase, recvDiscNotRegFrameBase, sendCtrlRegReqFrameBase,
+					   regRandomCheckThreshold, randomRange);
+
+				/* wait random time */
+				onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonMpcpTimerId), 0, randomRange, 0);
+
+				regRandomResetState = 1;
+
+				/* disable tx */
+				mvOnuEponMacOnuTxEnableSet(ONU_TX_DIS, 0);
+			}
+		}
+	}
+
+	if ((onuPonResourceTbl_s.onuPonMpcpTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonMpcpTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerMpcpStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable epon mpcp timer
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrTimerMpcpStateSet(MV_BOOL mode)
+{
+	if (mode == MV_TRUE)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonMpcpTimerId));
+	else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonMpcpTimerId));
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerMpcpIntervalSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure epon mpcp timer interval
+**
+**  PARAMETERS:  MV_BOOL interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrTimerMpcpIntervalSet(MV_U32 interval)
+{
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonMpcpTimerId), 0, interval, 1);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerMpcpRandomResetSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure epon mpcp timer random reset params
+**
+**  PARAMETERS:  MV_U32 checkThreshold
+**               MV_U32 maskThreshold
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrTimerMpcpRandomResetSet(MV_U32 checkThreshold, MV_U32 maskThreshold)
+{
+	regRandomCheckThreshold = checkThreshold;
+	regRandomMaskThreshold  = maskThreshold;
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerHoldoverHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle holdover for epon
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrTimerHoldoverHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonHoldoverTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+		   "DEBUG: (%s:%d) Holdover Timer Expire\n", __FILE_DESC__, __LINE__);
+	onuEponPonMngAlarmHandlerExecute(ALL_MAC_INDICATION);
+
+	if ((onuPonResourceTbl_s.onuPonHoldoverTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonHoldoverTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerHoldoverIntervalSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure epon mpcp timer interval
+**
+**  PARAMETERS:  MV_BOOL interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrTimerHoldoverIntervalSet(MV_U32 interval, MV_U32 state)
+{
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonHoldoverTimerId), 0, interval, state);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerEventMissHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function validate interrupt event miss
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrTimerEventMissHndl(unsigned long data)
+{
+	MV_U32 currHwTime;
+	MV_U32 currHwThreshold;
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonIsrMissTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	if (isrTimestampEventCnt != 0)
+		isrTimestampEventCnt = 0;
+	else {
+		mvOnuEponMacGenLocalTimeStampGet(&currHwTime);
+		mvOnuEponMacGenTimeStampForIntrGet(&currHwThreshold);
+
+		if (isrTimestampEventMiss > 0) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_ISR_MISS_MODULE,
+				   "DEBUG: (%s:%d) Event miss(%d) Currtime(%x) CurrThreshold(%x)\n",
+				   __FILE_DESC__, __LINE__, isrTimestampEventMiss, currHwTime, currHwThreshold);
+
+			onuEponOamHandleMsg();
+			onuEponDbaSwRprtMacTimerCfg(62500);
+			isrTimestampEventMiss = 0;
+		}
+
+		isrTimestampEventMiss++;
+	}
+
+	if ((onuPonResourceTbl_s.onuPonIsrMissTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrMissTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrTimerEventMissStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable epon event miss timer
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrTimerEventMissStateSet(MV_BOOL mode)
+{
+	if (mode == MV_TRUE)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrMissTimerId));
+	else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrMissTimerId));
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrOamTxHwDbaHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handles OAM transmission in case of HW DBA
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrOamTxHwDbaHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	onuEponPonMngTxCtrlMessageHandler();
+
+	if ((onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrOamTxHwDbaStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable OAM transmission in case of HW DBA
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrOamTxHwDbaStateSet(MV_BOOL mode)
+{
+	if (mode == MV_TRUE)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId));
+	else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId));
+}
+
+/*******************************************************************************
+**
+**  onuEponDbaSwRprtMacTimerCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure abd trigger timestamp interupt
+**
+**  PARAMETERS:  MV_U32 interval - 16 nanaosec units
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponDbaSwRprtMacTimerCfg(MV_U32 interval)
+{
+	MV_U32 currentTimestamp;
+	MV_U32 maxHwTimer = 0xFFFFFFFF;
+
+	mvOnuEponMacGenLocalTimeStampGet(&currentTimestamp);
+
+	if ((maxHwTimer - currentTimestamp) < interval)
+		mvOnuEponMacGenTimeStampForIntrSet(interval);
+	else
+		mvOnuEponMacGenTimeStampForIntrSet(currentTimestamp + interval);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrXvrResetTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the EPON Interrupt handler to execute
+**               XVR reset sequence in case of a problem with XVR signal detect
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponIsrXvrResetTimerHndl(unsigned long data)
+{
+	MV_STATUS status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	status = onuEponIsrXvrReset();
+	if (status != MV_NO_XVR_RST) {
+		if ((onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerPeriodic) != 0)
+			onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+	} else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrXvrReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset xvr
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponIsrXvrReset(void)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	MV_STATUS status;
+	MV_U32 onuState;
+	MV_U32 initDone;
+
+	onuState = onuEponDbOnuStateGet(0);
+	if (onuState == ONU_EPON_02_REGISTER_PENDING) {
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+		if (status != MV_OK)
+			return status;
+
+		do {
+			status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+			if (status != MV_OK)
+				return status;
+
+		} while (initDone == 0);
+
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+		if (status != MV_OK)
+			return status;
+	} else
+		return MV_NO_XVR_RST;
+
+#endif
+#endif  /* PON_FPGA */
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponIsrXvrResetStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable onu xvr reset timer
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuEponIsrXvrResetStateSet(MV_BOOL mode)
+{
+	if (mode == MV_TRUE)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+	else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+}
+
+/*******************************************************************************
+**
+**  mvP2PStart
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function starts ONU P2P configuration
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS mvP2PStart(void)
+{
+#ifndef PON_Z1
+	MV_STATUS status;
+	MV_U32 pcsConfig;
+	MV_U32 overHead;
+	MV_U32 ignoreLlidCrcError;
+	MV_U32 ignoreFcsError;
+	MV_U32 ignoreGmiiError;
+	MV_U32 ignoreLengthError;
+	MV_U32 forwardAllLlid;
+	MV_U32 forwardBc0FFF;
+	MV_U32 forwardBc1FFF;
+	MV_U32 forwardBc1xxx;
+	MV_U32 dropBc1nnn;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask;
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	MV_U32 polarity;
+#endif
+#endif
+	MV_U32 interruptStatus;
+	MV_U32 state;
+	LINKSTATUSFUNC linkStatusCallback;
+
+	/* Check for XVR SD interrupt status */
+	mvOnuEponMacPonInterruptGet(&interruptStatus);
+	interruptStatus &= 0xFFFF;
+
+	state = ponXvrFunc(interruptStatus, ONU_EPON_XVR_SD_MASK);
+	if (state == MV_FALSE)
+		onuEponDbOnuSignalDetectSet(1); /* alarm is OFF */
+	else if (state == MV_TRUE)
+		onuEponDbOnuSignalDetectSet(0); /* alarm is ON */
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask &= ~(ONU_EPON_GATE_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			llidDbaIntMask = 0; /* clear all LLID DBA interrupts */
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask &= ~(ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+
+			/* Start SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_FALSE);
+		}
+	}
+
+	/* stop xvr reset timer */
+	onuEponIsrXvrResetStateSet(MV_FALSE);
+
+	/* Save EPON PCS configuration */
+	status = mvOnuEponMacPcsConfigGet(&pcsConfig);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacPcsConfigGet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	onuEponDbPcsCfgSet(pcsConfig);
+
+	/* Set P2P PCS */
+	status = asicOntGlbRegWrite(mvAsicReg_P2P_PCS_CONFIGURATION, ONU_P2P_PCS_TX_RX_NEW, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) asicOntGlbRegWrite\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Set TXM configuration mode */
+	status = asicOntGlbRegWrite(mvAsicReg_P2P_TXM_CFG_MODE, ONU_DEF_TXM_CFG_MODE_GE, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) asicOntGlbRegWrite\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Set configuration mode in the GEN ONT register */
+	status = asicOntGlbRegWrite(mvAsicReg_P2P_GEN_ONT_MODE, ONU_DEF_TXM_CFG_MODE_GE, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) asicOntGlbRegWrite\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Save TXM overhead value */
+	status = mvOnuEponMacTxmOverheadGet(&overHead);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmOverheadGet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	onuEponDbOverheadSet(overHead);
+
+	mvOnuEponMacTxmOverheadSet(ONU_DEF_TXM_CFG_P2P_OVERHEAD);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmOverheadSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Save current RXP packet filter */
+	mvOnuEponMacRxpPacketFilterGet(&ignoreLlidCrcError,
+				       &ignoreFcsError,
+				       &ignoreGmiiError,
+				       &ignoreLengthError,
+				       &forwardAllLlid,
+				       &forwardBc0FFF,
+				       &forwardBc1FFF,
+				       &forwardBc1xxx,
+				       &dropBc1nnn);
+
+	onuEponDbPktFilterPacketSet(forwardAllLlid, forwardBc1xxx, forwardBc1FFF, forwardBc0FFF, dropBc1nnn);
+	onuEponDbPktFilterErrorSet(ignoreLengthError, ignoreGmiiError, ignoreFcsError, ignoreLlidCrcError);
+
+	/* Set P2P RXP packet filter */
+	status = mvOnuEponMacRxpPacketFilterSet(ONU_FORWARD_LLID_CRC_ERR_PKT_IGNORE,
+						ONU_FORWARD_LLID_FCS_ERR_PKT,
+						ONU_FORWARD_LLID_GMII_ERR_PKT,
+						ONU_FORWARD_LLID_LEN_ERR_PKT,
+						ONU_FORWARD_LLID_ALL_PKT_FILTER,
+						ONU_FORWARD_LLID_7FFF_MODE_0_PKT,
+						ONU_FORWARD_LLID_7FFF_MODE_1_PKT,
+						ONU_FORWARD_LLID_XXXX_MODE_1_PKT,
+						ONU_DROP_LLID_NNNN_MODE_1_PKT);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpPacketFilterSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* MC ASIC     */
+	/* =========== */
+	if (1 /*mvCtrlModelGet() == MV_88F66X0*/) {
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		/* PHY control register - force enable */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_FORCE, 1, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		polarity = onuP2PDbXvrBurstEnablePolarityGet();
+
+		/* PHY control register - force enable value - according to polarity */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_VALUE, polarity, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+#endif
+#endif          /* PON_FPGA */
+	}
+
+	/* Read current FEC configuration */
+	status = mvOnuEponMacRxpEncConfigGet(&isrP2pPreviousFecState);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpEncConfigGet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Reset FEC configuration */
+	status = mvOnuEponMacRxpEncConfigSet(0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpEncConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	onuEponDbModeSet(E_EPON_IOCTL_P2P_MODE);
+
+	/* Call link status callback function */
+	linkStatusCallback = onuEponDbLinkStatusCallbackGet();
+	if (linkStatusCallback != NULL) {
+		linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_TRUE);
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+			   "DEBUG: (%s:%d) Notify link is UP\n", __FILE_DESC__, __LINE__);
+	}
+#endif  /* PON_Z1 */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvP2PStop
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function stops ONU P2P configuration
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS mvP2PStop(void)
+{
+#ifndef PON_Z1
+	MV_STATUS status;
+	MV_U32 pcsConfig;
+	MV_U32 overHead;
+	MV_U32 ignoreLlidCrcError;
+	MV_U32 ignoreFcsError;
+	MV_U32 ignoreGmiiError;
+	MV_U32 ignoreLengthError;
+	MV_U32 forwardAllLlid;
+	MV_U32 forwardBc0FFF;
+	MV_U32 forwardBc1FFF;
+	MV_U32 forwardBc1xxx;
+	MV_U32 dropBc1nnn;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask = 0;
+	MV_U32 llidIdx = 0;    /* Support for single LLID */
+
+	/* Set EPON PCS */
+	pcsConfig = onuEponDbPcsCfgGet();
+	status = mvOnuEponMacPcsConfigSet(pcsConfig);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacPcsConfigSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Set TXM configuration mode */
+	status = asicOntGlbRegWrite(mvAsicReg_P2P_TXM_CFG_MODE, ONU_DEF_TXM_CFG_MODE_EPON, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) asicOntGlbRegWrite\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Set configuration mode in the GEN ONT register */
+	status = asicOntGlbRegWrite(mvAsicReg_P2P_GEN_ONT_MODE, ONU_DEF_TXM_CFG_MODE_EPON, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) asicOntGlbRegWrite\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	overHead = onuEponDbOverheadGet();
+	status = mvOnuEponMacTxmOverheadSet(overHead);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacTxmOverheadSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Set EPON RXP packet filter */
+	onuEponDbPktFilterPacketGet(&forwardAllLlid, &forwardBc1xxx, &forwardBc1FFF, &forwardBc0FFF, &dropBc1nnn);
+	onuEponDbPktFilterErrorGet(&ignoreLengthError, &ignoreGmiiError, &ignoreFcsError, &ignoreLlidCrcError);
+
+	status = mvOnuEponMacRxpPacketFilterSet(ignoreLlidCrcError,
+						ignoreFcsError,
+						ignoreGmiiError,
+						ignoreLengthError,
+						forwardAllLlid,
+						forwardBc0FFF,
+						forwardBc1FFF,
+						forwardBc1xxx,
+						dropBc1nnn);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacRxpPacketFilterSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* MC ASIC     */
+	/* =========== */
+	if (1 /*MV_88F66X0 == mvCtrlModelGet()*/) {
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+		/* PHY control register - output status set */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		/* PHY control register - force disable */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_FORCE, 0, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+#endif
+#endif          /* PON_FPGA */
+	}
+
+	if (onuEponDbP2PForceModeGet())
+		/* set P2P mode */
+		onuEponDbModeSet(E_EPON_IOCTL_P2P_MODE);
+	else
+		/* set EPON mode */
+		onuEponDbModeSet(E_EPON_IOCTL_STD_MODE);
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_GATE_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			llidDbaIntMask |= 1 << llidIdx;
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+
+			onuEponDbaSwRprtMacTimerCfg(onuEponDbOnuSwRprtMacTimerIntervalGet());
+
+			/* Start SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_TRUE);
+
+			llidDbaIntMask = 0;
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		}
+	}
+
+	if (isrP2pPreviousFecState & 0x1) {
+		/* Set FEC configuration */
+		status = mvOnuEponMacRxpEncConfigSet(isrP2pPreviousFecState);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacRxpEncConfigSet\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	/* start xvr reset timer */
+	onuEponIsrXvrResetStateSet(MV_TRUE);
+
+#endif  /* PON_Z1*/
+
+	return MV_OK;
+}
+
+void onuEponForceTxDownStateSet(MV_U32 txEnable, MV_U32 macId)
+{
+	if (txEnable == 0)
+		eponMgmtForceTxDisable = MV_TRUE;
+	else
+		eponMgmtForceTxDisable = MV_FALSE;
+}
+
+MV_BOOL onuEponForceTxDownStateGet(MV_U32 macId)
+{
+	return eponMgmtForceTxDisable;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.h
new file mode 100644
index 0000000..5730016
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuIsr.h
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU GPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuIsr.h                                              **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON Interrupt implementation      **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_ISR_H
+#define _ONU_EPON_ISR_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define ONU_EPON_REGISTERED_LLID_0_MASK     (0x0001)
+#define ONU_EPON_REGISTERED_LLID_0_7_MASK   (0x0002)
+#define ONU_EPON_TIMESTAMP_DRIFT_MASK       (0x0004)
+#define ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK (0x0008)
+#define ONU_EPON_RX_CTRL_QUEUE_MASK         (0x0010)
+#define ONU_EPON_RX_RPRT_QUEUE_MASK         (0x0020)
+#define ONU_EPON_GATE_MASK                  (0x0040)
+#define ONU_EPON_DS_SYNC_OK_PCS_MASK        (0x0080)
+#define ONU_EPON_XVR_SD_MASK                (0x0100)
+#define ONU_EPON_SERDES_SD_MASK             (0x0200)
+
+#define ONU_EPON_EVENT_SHIFT                (16)
+
+#ifdef PON_Z1
+
+#define ONU_EPON_INTERRUPTS                 (ONU_EPON_RX_CTRL_QUEUE_MASK | \
+					     ONU_EPON_XVR_SD_MASK)
+
+#else /* Z2,A0 or later */
+
+#define ONU_EPON_INTERRUPTS                 (ONU_EPON_RX_CTRL_QUEUE_MASK         | \
+					     ONU_EPON_XVR_SD_MASK                | \
+					     ONU_EPON_DS_SYNC_OK_PCS_MASK        | \
+					     ONU_EPON_REGISTERED_LLID_0_MASK     | \
+					     ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK | \
+					     ONU_EPON_GATE_MASK)
+#endif /* Z2,A0 or later */
+
+/* Alarms Mask */
+#define ONU_EPON_ALARM_MASK                 (ONU_EPON_SERDES_SD_MASK | \
+					     ONU_EPON_XVR_SD_MASK    | \
+					     ONU_EPON_TIMESTAMP_DRIFT_MASK)
+/* Message Types */
+#define ONU_EPON_RX_CTRL_MSG                (1)
+#define ONU_EPON_RX_RPRT_MSG                (2)
+
+/* DBA Report Timer Types */
+#define ONU_EPON_SW_DBA_RPRT_TIMER          (0)
+#define ONU_EPON_HW_DBA_RPRT_TIMER          (1)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponIsrXvrReset(void);
+void      onuEponIsrResetRandomStateMachine(void);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+void onuEponIsrLowRoutine(MV_U32 *interruptEvent, MV_U32 *interruptStatus);
+void onuEponIsrRoutine(MV_U32 interruptEvent, MV_U32 interruptStatus);
+void onuEponDgIsrRoutine(void);
+void onuEponIsrTimerMpcpHndl(unsigned long data);
+void onuEponIsrTimerMpcpStateSet(MV_BOOL mode);
+void onuEponIsrTimerMpcpIntervalSet(MV_U32 interval);
+void onuEponIsrTimerMpcpRandomResetSet(MV_U32 checkThreshold, MV_U32 maskThreshold);
+void onuEponIsrTimerHoldoverHndl(unsigned long data);
+void onuEponIsrTimerHoldoverIntervalSet(MV_U32 interval, MV_U32 state);
+void onuEponDbaSwRprtMacTimerCfg(MV_U32 interval);
+void onuEponIsrTimerEventMissHndl(unsigned long data);
+void onuEponIsrTimerEventMissStateSet(MV_BOOL mode);
+void onuEponIsrOamTxHwDbaHndl(unsigned long data);
+void onuEponIsrOamTxHwDbaStateSet(MV_BOOL mode);
+void onuEponIsrXvrResetTimerHndl(unsigned long data);
+void onuEponIsrXvrResetStateSet(MV_BOOL mode);
+void onuEponForceTxDownStateSet(MV_U32 txEnable, MV_U32 macId);
+MV_BOOL onuEponForceTxDownStateGet(MV_U32 macId);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_ISR_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.c
new file mode 100644
index 0000000..9e2acd4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.c
@@ -0,0 +1,3190 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuMngr.c                                             **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON Manager functionality       **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuMngr.c"
+
+/* LSP Header Files */
+#include "mvPp2PrsHw.h"
+#include "mvPp2Prs.h"
+#include "cls/mvPp2ClsHw.h"
+
+#define OAM_MSG_NOT_TRANS   (0xFFFF)
+#define OAM_MSG_FIFO_LENGTH (16)
+#define OAM_MSG_REGS        (10)
+#define OAM_MSG_DG_IND      (1)
+
+#define DBA_RPRT_MAX_SIZE   (35) /* Report via EPON REGS */
+
+#define DBA_RPRT_PERIODIC_CYCLE (6)
+#define DBA_RPRT_TX_FIFO_SIZE (4 * 1024)
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+extern MV_U8 fixMacAddrs[8][6];
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* SW DBA params */
+MV_U32 llidDbaRprtCount = 0;
+MV_U32 llidDbaRprtValue = 0;
+
+MV_U32 llidDbaRprtForOamMsgInd = 0;
+
+MV_U32 llidCounter[8]           = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+MV_U32 llidQueueState[8][4][8]  = {
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } }
+};
+
+MV_U32 llidQueueThreshold[8][4][8] = {
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } },
+	{ { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 },
+				   { 0, 0, 0, 0, 0, 0, 0, 0 } }
+};
+
+MV_U32 llidNumOfQueuesets[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+MV_U32 llidNumOfQueues[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+MV_U32 llidQueuesBitMap[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+MV_U32 llidNumOfReportBytes[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+/* SW DBA array for Mix mode SW/HW */
+S_OnuEponDbaShadowRegMap dbaSwRprtRegShadow[] = {
+	/* Index 0 - queueset*/ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_SET, 0   },
+	/* Index 1 - bitmap*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_BIT_MAP,   0   },
+	/* Index 2 - queue0*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   0   },
+	/* Index 3 - queue1*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   0   },
+	/* Index 4 - queue2*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   0   },
+	/* Index 5 - queue3*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   0   },
+	/* Index 6 - queue4*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   0   },
+	/* Index 7 - queue5*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   0   },
+	/* Index 8 - queue6*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   0   },
+	/* Index 9 - queue7*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   0   }
+};
+
+S_OnuEponDbaSwRprtRegMap dbaSwRprtRegMap[] = {
+	/*  0 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_SET, 0,	0  },
+	/*  1 */ { mvAsicReg_EPON_TXM_CPP_RPRT_BIT_MAP,   0,	1  },
+	/*  2 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   8,	2  },
+	/*  3 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   0,	2  },
+	/*  4 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   8,	3  },
+	/*  5 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   0,	3  },
+	/*  6 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   8,	4  },
+	/*  7 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   0,	4  },
+	/*  8 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   8,	5  },
+	/*  9 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   0,	5  },
+	/* 10 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   8,	6  },
+	/* 11 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   0,	6  },
+	/* 12 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   8,	7  },
+	/* 13 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   0,	7  },
+	/* 14 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   8,	8  },
+	/* 15 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   0,	8  },
+	/* 16 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   8,	9  },
+	/* 17 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   0,	9  },
+	/* 18 */ { mvAsicReg_EPON_TXM_CPP_RPRT_BIT_MAP,   8,	1  },
+	/* 19 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   24,	2  },
+	/* 20 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   16,	2  },
+	/* 21 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   24,	3  },
+	/* 22 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   16,	3  },
+	/* 23 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   24,	4  },
+	/* 24 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   16,	4  },
+	/* 25 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   24,	5  },
+	/* 26 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   16,	5  },
+	/* 27 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   24,	6  },
+	/* 28 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   16,	6  },
+	/* 29 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   24,	7  },
+	/* 30 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   16,	7  },
+	/* 31 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   24,	8  },
+	/* 32 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   16,	8  },
+	/* 33 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   24,	9  },
+	/* 34 */ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   16,	9  }
+};
+
+/* SW DBA array for Mix mode SW/HW */
+S_OnuEponDbaShadowRegMap dbaDgSwRprtRegShadow[] = {
+	/* Index 0 - queueset*/ { mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_SET, 0x00000001   },
+	/* Index 1 - bitmap*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_BIT_MAP,   0x000000FF   },
+	/* Index 2 - queue7*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_0,   0x00000000   },
+	/* Index 3 - queue6*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_1,   0x00000000   },
+	/* Index 4 - queue5*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_2,   0x00000000   },
+	/* Index 5 - queue4*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_3,   0x00000000   },
+	/* Index 6 - queue3*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_4,   0x00000000   },
+	/* Index 7 - queue2*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_5,   0x00000000   },
+	/* Index 8 - queue1*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_6,   0x00000000   },
+	/* Index 9 - queue0*/	{ mvAsicReg_EPON_TXM_CPP_RPRT_QUEUE_7,   0x0000FFFF   }
+};
+
+MV_U32 llidPacketFcsCompensation[] = {
+	/*  0    0 add    0 */ 0,
+	/*  1   64 add  1/2 */ 2,
+	/*  2  128 add  1/4 */ 4,
+	/*  3  192 add  1/6 */ 6,
+	/*  4  256 add  1/5 */ 5,
+	/*  5  320 add  1/6 */ 6,
+	/*  6  384 add  1/8 */ 8,
+	/*  7  448 add  1/8 */ 8,
+	/*  8  512 add  1/8 */ 8,
+	/*  9  576 add  1/9 */ 9,
+	/* 10  640 add 1/10 */ 10,
+	/* 11  704 add 1/10 */ 10,
+	/* 12  768 add 1/10 */ 10,
+	/* 13  832 add 1/11 */ 11,
+	/* 14  896 add 1/11 */ 11,
+	/* 15  960 add 1/11 */ 11,
+	/* 16 1024 add 1/11 */ 11,
+	/* 17 1088 add 1/12 */ 12,
+	/* 18 1152 add 1/12 */ 12,
+	/* 19 1216 add 1/12 */ 12,
+	/* 20 1280 add 1/12 */ 12,
+	/* 21 1344 add 1/12 */ 12,
+	/* 22 1408 add 1/12 */ 12,
+	/* 23 1472 add 1/12 */ 12,
+	/* 24 1536 add 1/12 */ 12,
+	/* 25 1600 add 1/12 */ 12,
+	/* 26 1664 add 1/12 */ 12,
+	/* 27 1728 add 1/12 */ 12,
+	/* 28 1792 add 1/12 */ 12,
+	/* 29 1856 add 1/12 */ 12,
+	/* 30 1920 add 1/12 */ 12,
+	/* 31 1984 add 1/12 */ 12,
+	/* 32 2048 add 1/12 */ 12
+};
+
+/* SW DBA report additional bandwidth params */
+MV_U32 rprtLowRateThreshold;
+MV_U32 rprtLowRateValue;
+MV_U32 rprtLowRateConstValue;
+MV_U32 rprtHighRateThreshold;
+MV_U32 rprtHighRateValue;
+
+/* SW DBA report message */
+MV_U8 reportMsg[40];
+MV_U8 reportMsgIdx;
+
+/* OAM message transmission handling */
+/* S_OnuEponOamMsg oamDgMsgQueue; */
+S_OnuEponOamMsg oamMsgData[OAM_MSG_FIFO_LENGTH];
+
+/* Data array pointers definition */
+MV_U8 oamMsgWriteIndex = 0;
+MV_U8 oamMsgReadIndex  = 0;
+
+/* Dying Gasp message parameters */
+MV_U16 dgMsgEtype    = 0x8809;  /* Slow Protocol */
+MV_U16 dgMsgSubType  = 0x03;    /* OAM */
+MV_U16 dgMsgFlags    = 0x52;    /* Dying Gasp */
+MV_U8 dgMsgCode     = 0x0;      /* Information OAMPDU */
+S_OnuEponCtrlBuffer dgOamMsg;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Init Section                                       */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponAppInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init EPON App
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponAppInit(void)
+{
+	MV_U32 macId;
+
+	onuEponOamMsgFifoInit();
+
+	onuEponDgMsgDefaultMessageInit();
+
+	onuEponPonMngDbaParamsInit();
+
+	for (macId = 0; macId < 8; macId++)
+		onuEponDbaInfoUpdate(macId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamMsgFifoInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init OAM messages FIFO
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponOamMsgFifoInit(void)
+{
+	memset(oamMsgData, 0, sizeof(S_OnuEponOamMsg) * 8);
+	/* memset(&oamDgMsgQueue, 0, sizeof(S_OnuEponOamMsg)); */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngDbaParamsInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init DBA Report parameters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngDbaParamsInit(void)
+{
+	MV_U32 familyId = MV_88F66X0;
+
+	rprtLowRateThreshold  = ONU_EPON_DBA_LOW_RATE_THRESHOLD;
+	rprtLowRateValue      = ONU_EPON_DBA_LOW_RATE_VALUE;
+	rprtLowRateConstValue = ONU_EPON_DBA_LOW_RATE_CONST_VALUE;
+	rprtHighRateThreshold = ONU_EPON_DBA_HIGH_RATE_THRESHOLD;
+	rprtHighRateValue     = ONU_EPON_DBA_HIGH_RATE_VALUE;
+
+	if (familyId != MV_88F66X0)
+		/* LLID0 configuration */
+		onuEponPmGunitLlid0PktModMaxHeaderSizeSet(0);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbaInfoUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init DBA Report parameters
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponDbaInfoUpdate(MV_U32 macId)
+{
+	MV_U32 queueId;
+	MV_U32 queueSetId;
+
+	llidNumOfQueues[macId]    = onuEponDbOnuDbaNumOfQueuesGet(macId);
+	llidQueuesBitMap[macId]   = onuEponDbOnuDbaQueuesBitMapGet(macId);
+	llidNumOfQueuesets[macId] = onuEponDbOnuDbaNumOfQueuesetGet(macId);
+
+	llidNumOfReportBytes[macId] =  (((llidNumOfQueuesets[macId] * llidNumOfQueues[macId]) * 2) + /* number of bytes for queues */
+					llidNumOfQueuesets[macId] + /* number of bytes for bit map */
+					1); /* number of bytes for #queuesets */
+	if (llidNumOfReportBytes[macId] > DBA_RPRT_MAX_SIZE) /* hardware limit */
+		llidNumOfReportBytes[macId] = DBA_RPRT_MAX_SIZE;
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+		   "MAC[%d] QSet(%d) Q(%d) Rbytes(%d)\n",
+		   macId, llidNumOfQueuesets[macId], llidNumOfQueues[macId], llidNumOfReportBytes[macId]);
+
+	for (queueSetId = 0; queueSetId < llidNumOfQueuesets[macId]; queueSetId++) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+			   "QSet(%d) Q[thres:state]", queueSetId);
+
+		for (queueId = 0; queueId <  EPON_MAX_QUEUE; queueId++) {
+			onuEponDbOnuDbaQueueThresholdGet(&(llidQueueThreshold[macId][queueSetId][queueId]),
+							 &(llidQueueState[macId][queueSetId][queueId]),
+							 queueId, queueSetId, macId);
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "[%d:%d]",
+				   llidQueueThreshold[macId][queueSetId][queueId],
+				   llidQueueState[macId][queueSetId][queueId]);
+		}
+
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "\n");
+	}
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Alarm Section                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPonMngAlarmHandlerExecute
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt alarm
+**               functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngAlarmHandlerExecute(MV_U32 macId)
+{
+	MV_STATUS status;
+	MV_U32 startMacId;
+	MV_U32 endMacId;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask;
+	LINKSTATUSFUNC linkStatusCallback;
+
+	if (macId == ALL_MAC_INDICATION) {
+		startMacId = 0;
+		endMacId   = EPON_MAX_MAC_NUM;
+	} else {
+		startMacId = macId;
+		endMacId   = macId + 1;
+	}
+
+	if ((macId == 0) || (macId == ALL_MAC_INDICATION)) {
+		if (onuEponDbModeGet() == E_EPON_IOCTL_STD_MODE) {
+			mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "===================\n");
+			mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "== MPCP Sync Off ==\n");
+			mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "===================\n");
+		}
+	}
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			/* Clear onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask &= ~(ONU_EPON_GATE_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			llidDbaIntMask = 0; /* clear all LLID DBA interrupts */
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			/* Stop SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_FALSE);
+
+			/* Clear onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask &= ~(ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+		}
+	}
+
+	/* handle silence mode */
+	if (onuEponDbOnuSilenceStateGet() != ONU_SILENCE_NOT_ACTIVE) {
+		/* Clear onu Silence Timers */
+		for (macId = startMacId; macId < endMacId; macId++)
+			onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonSilenceTimerId[macId]));
+
+		status  = mvOnuEponMacGenOnuConfigAutoAckSet(ONU_REG_ACK_AUTO_RES);
+		status |= mvOnuEponMacGenOnuConfigAutoRequestSet(ONU_REG_REQ_AUTO_RES);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to enable auto request / ack\n\r", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		onuEponDbOnuCfgAutoSet(ONU_REG_REQ_AUTO_RES, ONU_REG_ACK_AUTO_RES, ONU_REPORT_AUTO_RES);
+	}
+
+	for (macId = startMacId; macId < endMacId; macId++) {
+		/* re-init onu database */
+		status = onuEponDbReInit(macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to re-init onu database\n\r", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* init onu Asic */
+		status = onuEponAsicReInit(macId, ONU_SILENCE_DISABLED);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to re-init onu EPON MAC\n\r", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* update LOID authentication state */
+		status = onuEponDbOnuLoidAuthStateSet(MV_TRUE, macId);
+		if (status)
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) fail to set LLID state for MAC\n", __FILE_DESC__, __LINE__);
+	}
+
+	/* Call link status callback function */
+	linkStatusCallback = onuEponDbLinkStatusCallbackGet();
+	if (linkStatusCallback != NULL) {
+		if (onuEponForceTxDownStateGet(0) != MV_TRUE) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) Notify link is DOWN\n", __FILE_DESC__, __LINE__);
+			linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_FALSE);
+		}
+	}
+
+	/* update holdover state */
+	if (onuEponDbOnuHoldoverStateGet() != ONU_HOLDOVER_NOT_ACTIVE)
+		if (onuEponDbOnuHoldoverExecGet() != ONU_HOLDOVER_NOT_ACTIVE)
+			onuEponDbOnuHoldoverExecSet(ONU_HOLDOVER_NOT_ACTIVE);
+
+	/* send signal to management layer */
+	onuEponStatusNotify(0 /*don't care*/);
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrAlarmHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt alarm
+**               functionality
+**
+**  PARAMETERS:  MV_U32 alarm
+**               MV_U32 alarmStatus
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngIntrAlarmHandler(MV_U32 alarm, MV_BOOL alarmStatus)
+{
+	if (alarmStatus != MV_FALSE) {
+		/* alarm is ON */
+		if (onuEponDbOnuHoldoverStateGet() != ONU_HOLDOVER_NOT_ACTIVE) {
+			if (onuEponDbOnuHoldoverExecGet() != ONU_HOLDOVER_ACTIVE) {
+				/* start onu epon pon holdover timer */
+				onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonHoldoverTimerId));
+				onuEponDbOnuHoldoverExecSet(ONU_HOLDOVER_ACTIVE);
+				mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+					   "DEBUG: (%s:%d) Holdover Timer Start(Intr)\n", __FILE_DESC__, __LINE__);
+			}
+		} else
+			onuEponPonMngAlarmHandlerExecute(ALL_MAC_INDICATION);
+
+		/* update alarm */
+		onuEponAlarmSet(alarm, alarmStatus);
+
+	} else {
+		/* alarm is OFF */
+		if (onuEponDbOnuHoldoverStateGet() != ONU_HOLDOVER_NOT_ACTIVE) {
+			if (onuEponDbOnuHoldoverExecGet() != ONU_HOLDOVER_NOT_ACTIVE) {
+				/* stop onu epon pon holdover timer */
+				onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonHoldoverTimerId));
+				onuEponDbOnuHoldoverExecSet(ONU_HOLDOVER_NOT_ACTIVE);
+				mvPonPrint(PON_PRINT_DEBUG, PON_ISR_STATE_MODULE,
+					   "DEBUG: (%s:%d) Holdover Timer Stop\n", __FILE_DESC__, __LINE__);
+			}
+		}
+
+		/* update alarm */
+		onuEponAlarmSet(alarm, alarmStatus);
+	}
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Register Section                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrRegHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt register
+**               functionality
+**
+**  PARAMETERS:  MV_U32 reg
+**               MV_U32 regStatus
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngIntrRegHandler(MV_U32 reg, MV_BOOL regStatus)
+{
+	MV_STATUS status;
+	MV_U32 delay;
+	MV_U32 laser;
+
+	/* Register State Active */
+	if (regStatus != MV_FALSE) {
+		delay  = ((0x0 << 8) | (0x0 + ONU_DEF_DDM_DELAY));
+		status = mvOnuEponMacDdmDelaySet(delay);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) mvAsicReg_EPON_DDM_1814_CONFIG\n\r", __FILE_DESC__, __LINE__);
+
+		laser  = (ONU_DEF_LASER_ON_OFF_TIME << 24) |
+			 (ONU_DEF_LASER_OFF_TIME << 8) |
+			 (ONU_DEF_LASER_ON_TIME);
+		status = mvOnuEponMacGenLaserParamSet(ONU_DEF_LASER_ON_OFF_TIME,
+						      ONU_DEF_LASER_ON_TIME,
+						      ONU_DEF_LASER_OFF_TIME);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacGenLaserParamSet\n\r", __FILE_DESC__, __LINE__);
+
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+			   "Register State[ON]: DDM_Config(0x%x) LASER_PARAM(0x%x)\n\r", delay, laser);
+	} else { /* Register State Not - Active */
+		delay  = ONU_DEF_DDM_DELAY;
+		status = mvOnuEponMacDdmDelaySet(delay);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) mvAsicReg_EPON_DDM_1814_CONFIG\n\r", __FILE_DESC__, __LINE__);
+
+		laser  = (ONU_DEF_LASER_ON_OFF_TIME << 24) |
+			 (ONU_DEF_LASER_OFF_TIME << 8) |
+			 (ONU_DEF_LASER_ON_TIME);
+		status = mvOnuEponMacGenLaserParamSet(ONU_DEF_LASER_ON_OFF_TIME,
+						      ONU_DEF_LASER_ON_TIME,
+						      ONU_DEF_LASER_OFF_TIME);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) mvOnuEponMacGenLaserParamSet\n\r", __FILE_DESC__, __LINE__);
+
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+			   "Register State[OFF]: DDM_Config(0x%x) LASER_PARAM(0x%x)\n\r", delay, laser);
+	}
+
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Message Section                                    */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPonMngTxCtrlMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt MPC message
+**               functionality
+**
+**  PARAMETERS:  MV_U32 msg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngTxCtrlMessageHandler(void)
+{
+	MV_BOOL oamMessageWaitingForTransmit = MV_FALSE;
+	MV_BOOL eponMacFifoFreeStatus        = MV_FALSE;
+	S_EponOamDbaByte dbaOamByte;
+
+	static MV_U32 addBytesToDbaReportForOAM = 0;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		/* handle OAM in SW DBA */
+		if (onuEponOamHandleMsg() != OAM_MSG_NOT_TRANS)
+			llidDbaRprtForOamMsgInd = 1;
+
+		/* handle SW DBA */
+		onuEponPonMngSwRprtMessageHandler();
+	}
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_HW_RPRT_MODE) {
+		if (MV_OK != onuEponHwDbaAdditionalOamBytesGet(&dbaOamByte)) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "fail to get DBA OAM additional byte information\n");
+			return;
+		}
+		if (dbaOamByte.state == E_EPON_DBA_OAM_HW_DISABLE) {
+			oamMessageWaitingForTransmit = onuEponOamHandleCheck();
+			eponMacFifoFreeStatus        = onuEponSendCtrlFrameDataFreeStatus(0);/* Support only ONT LLID */
+
+			/* OAM message waiting for TX - No		Yes		No		Yes        */
+			/* EPON MAC FIFO Status       - Empty		Empty		Full		Full       */
+			/* =====================================================================================   */
+			/* Action                       Close BW	Send OAM        Open BW		Open BW    */
+			/*                              (if Open)	Open BW                                    */
+
+			if ((oamMessageWaitingForTransmit == MV_FALSE) && /* Message is not waiting for transmit */
+			    (eponMacFifoFreeStatus        == MV_TRUE)) { /* FIFO is empty */
+				if (addBytesToDbaReportForOAM == 1) {
+					/* Remove additional bytes for the OAM report */
+					mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(0, dbaOamByte.queue); /* llidIndex, queueIndex */
+					mvOnuEponMacPPv2DbaQueueOverheadSet(0); /* queueOverhead */
+
+					/* Configure Flag */
+					addBytesToDbaReportForOAM = 0;
+				}
+
+				/* set timer to add bytes to 1 sec*/
+				onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId), 0,
+						  ONU_PON_TIMER_HW_DBA_OAM_TX_INTERVAL, 1);
+			} else {
+				if (addBytesToDbaReportForOAM == 0) {
+					/* Add additional bytes for the OAM report */
+					mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(0, dbaOamByte.queue); /* llidIndex, queueIndex */
+					mvOnuEponMacPPv2DbaQueueOverheadSet(dbaOamByte.byte_num);/* queueOverhead */
+
+					/* Configure Flag */
+					addBytesToDbaReportForOAM = 1;
+				}
+
+				if ((oamMessageWaitingForTransmit == MV_TRUE) &&  /* Message waiting for transmit */
+				    (eponMacFifoFreeStatus        == MV_TRUE))    /* FIFO is Empty */
+					/* Transmit */
+					onuEponOamHandleMsg();
+
+				/* set timer to add bytes to 10 msec*/
+				onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId), 0,
+						  ONU_PON_TIMER_HW_DBA_OAM_TX_FAST, 1);
+			}
+		} else
+			/* Transmit */
+			onuEponOamHandleMsg();
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngSwRprtMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager DBA SW report functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngSwRprtMessageHandler(void)
+{
+	MV_STATUS status;
+
+	status = onuEponPonMngDbaSwRprtHandler();
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_MODULE,
+			   "ERROR: (%s:%d) Handle SW DBA Report\n\r", __FILE_DESC__, __LINE__);
+		return;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager message handling functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngIntrMessageHandler(MV_U32 msg)
+{
+	MV_STATUS status;
+	S_OnuEponCtrlBuffer ctrlBuf;
+
+	memset((void *)&ctrlBuf, 0, sizeof(S_OnuEponCtrlBuffer));
+
+	if (msg == ONU_EPON_RX_CTRL_MSG) {
+		do {
+			status = onuEponRetrieveCtrlFrameData(&ctrlBuf);
+			if (status != MV_OK)
+				return;
+
+			status = onuEponPonMngIntrCtrlMessageHandler(&ctrlBuf);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Handle Rx Ctrl Frame\n\r", __FILE_DESC__, __LINE__);
+				onuEponPmSwRxCountersAdd(TOTAL_MPCP_RX_ERROR_FRAME_CNT, 0);
+				return;
+			}
+		} while (status == MV_OK);
+
+	} else if (msg == ONU_EPON_RX_RPRT_MSG) {
+		status = onuEponRetrieveReportFrameData(&ctrlBuf);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Read Rx Report Frame\n\r", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		status = onuEponPonMngIntrRprtMessageHandler(&ctrlBuf);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Handle Rx Report Frame\n\r", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+	} else {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Unsupported Frame\n\r", __FILE_DESC__, __LINE__);
+		return;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrRxCtrlFifoCleanup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear the pon manager RX ctrl message FIFO
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngIntrRxCtrlFifoCleanup(void)
+{
+	MV_STATUS status;
+	S_OnuEponCtrlBuffer ctrlBuf;
+
+	memset((void *)&ctrlBuf, 0, sizeof(S_OnuEponCtrlBuffer));
+
+	do
+		status = onuEponRetrieveCtrlFrameData(&ctrlBuf);
+
+	while (status == MV_OK);
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrCtrlMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt MPC Ctrl
+**               message functionality
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngIntrCtrlMessageHandler(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	MV_STATUS status;
+	S_OnuEponGenMpcFrame *genMpcMsg;
+	S_OnuEponRegMpcFrame *regMpcMsg;
+	MV_U16 regOpcode;
+	MV_U16 regFlags;
+
+	genMpcMsg = (S_OnuEponGenMpcFrame *)ctrlBuf->data;
+	onuEponConvertN2HShort(&genMpcMsg->genMpcPdu.opCode, &regOpcode);
+
+	if (regOpcode == MPC_OPCODE_REGISTER) {
+		regMpcMsg = (S_OnuEponRegMpcFrame *)ctrlBuf->data;
+		regFlags  = regMpcMsg->regMpcPdu.flags;
+
+		if (regFlags == REGISTER_FLAGS_ACK) {
+			onuEponPmSwRxCountersAdd(TOTAL_MPCP_REGISTER_ACK_CNT, 0);
+
+			status = onuEponPonMngRegMsgFlagAck(regMpcMsg);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Register with flag Ack\n\r", __FILE_DESC__, __LINE__);
+				return MV_ERROR;
+			}
+
+		} else if (regFlags == REGISTER_FLAGS_NACK) {
+			onuEponPmSwRxCountersAdd(TOTAL_MPCP_REGISTER_NACK_CNT, 0);
+
+			status = onuEponPonMngRegMsgFlagNack(regMpcMsg);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Register with flag Nack\n\r", __FILE_DESC__, __LINE__);
+				return MV_ERROR;
+			}
+
+		} else if (regFlags == REGISTER_FLAGS_REREG) {
+			onuEponPmSwRxCountersAdd(TOTAL_MPCP_REGISTER_REREG_FRAME_CNT, 0);
+
+			status = onuEponPonMngRegMsgFlagReReg(regMpcMsg);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Register with flag Re-Register\n\r",
+					   __FILE_DESC__, __LINE__);
+				return MV_ERROR;
+			}
+
+		} else if (regFlags == REGISTER_FLAGS_DEREG) {
+			onuEponPmSwRxCountersAdd(TOTAL_MPCP_REGISTER_DEREG_FRAME_CNT, 0);
+
+			status = onuEponPonMngRegMsgFlagDeReg(regMpcMsg);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Register with flag De-Register\n\r",
+					   __FILE_DESC__, __LINE__);
+				return MV_ERROR;
+			}
+
+		} else {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Invalid Control message flag(%d)\n\r",
+				   __FILE_DESC__, __LINE__, regFlags);
+			return MV_ERROR;
+		}
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrRprtMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt MPC Report
+**               message functionality
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngIntrRprtMessageHandler(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+		   "ERROR: (%s:%d) Report Messages are handled by the EPON MAC\n\r", __FILE_DESC__, __LINE__);
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngTimerRprtMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt MPC Report
+**               message transmit function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngTimerRprtMessageHandler(MV_U32 macId)
+{
+	MV_STATUS status;
+	S_OnuEponCtrlBuffer ctrlBuf;
+	S_OnuEponGenMpcFrame *genMpcMsg;
+	MV_U16 msgEtype  = 0x8808;
+	MV_U16 msgOpcode = 0x0003;
+	MV_U16 reportIdx;
+	MV_U16 frameIdx;
+
+	/* clear message */
+	memset(&ctrlBuf, 0, MIN_RPRT_FRAME_LEN);
+
+	/* set message length */
+	ctrlBuf.length = MIN_RPRT_FRAME_LEN;
+
+	genMpcMsg = (S_OnuEponGenMpcFrame *)&(ctrlBuf.data);
+
+	/* update message content */
+	genMpcMsg->stdEthFrame.destAddr[0] = 0x01;
+	genMpcMsg->stdEthFrame.destAddr[1] = 0x80;
+	genMpcMsg->stdEthFrame.destAddr[2] = 0xC2;
+	genMpcMsg->stdEthFrame.destAddr[3] = 0x00;
+	genMpcMsg->stdEthFrame.destAddr[4] = 0x00;
+	genMpcMsg->stdEthFrame.destAddr[5] = 0x01;
+
+	onuEponConvertH2NShort(&msgEtype,  &genMpcMsg->stdEthFrame.etherType);
+
+	onuEponConvertH2NShort(&msgOpcode, &genMpcMsg->genMpcPdu.opCode);
+
+	genMpcMsg->genMpcPdu.timeStamp  = 0;
+
+	genMpcMsg->stdEthFrame.srcAddr[0] = fixMacAddrs[macId][0];
+	genMpcMsg->stdEthFrame.srcAddr[1] = fixMacAddrs[macId][1];
+	genMpcMsg->stdEthFrame.srcAddr[2] = fixMacAddrs[macId][2];
+	genMpcMsg->stdEthFrame.srcAddr[3] = fixMacAddrs[macId][3];
+	genMpcMsg->stdEthFrame.srcAddr[4] = fixMacAddrs[macId][4];
+	genMpcMsg->stdEthFrame.srcAddr[5] = fixMacAddrs[macId][5];
+
+	for (reportIdx = 0, frameIdx = 20; reportIdx < 40; reportIdx++, frameIdx++)
+		ctrlBuf.data[frameIdx] = reportMsg[reportIdx];
+
+	status = onuEponSendCtrlFrameData(&ctrlBuf, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Handle OAM Message\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**  ========================================================================  **
+**                            SW Report Section                               **
+**  ========================================================================  **
+*******************************************************************************/
+/*******************************************************************************
+**
+**  onuEponPonMngDbaSwRprtHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager DBA SW report handler
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngDbaSwRprtHandler(void)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 idx;
+	MV_U32 llidIdx;
+	MV_32 queueSetIdx;
+	MV_32 queueIdx;
+	MV_U32 msgIdx;
+	MV_U32 msgTmpData;
+	MV_U32 llidQueuesByteCount;
+	MV_U32 llidTotalByteCount;
+	MV_U32 llidAvePacketLength;
+	MV_U32 llidPacketCountCompensationIdx;
+	MV_U32 llidPacketCountCompensation;
+	MV_U32 llidPacketCount = 0;
+	MV_U32 llidTransmittedPacketCount = 0;
+	MV_U32 tmpLlidHighQueue;      /* highest queue according to mng configuration */
+	MV_U32 llidTxFecState = 0;
+	MV_U32 ts[10] = { 0 };
+	MV_U32    *pTs = ts;
+	MV_U32 interval[6] = { 0 };
+	MV_U32 familyId = MV_88F66X0;    /*mvCtrlModelGet();*/
+
+#define COLLECT_DBA_TS          mvOnuEponMacGenLocalTimeStampGet(pTs++)
+
+	for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+		llidQueuesByteCount         = 0;
+		llidTotalByteCount          = 0;
+
+		if (familyId != MV_88F66X0) {
+			llidPacketCount             = 0;
+			llidPacketCountCompensation = 0;
+		}
+
+		/* Non-active LLID */
+		if (onuEponDbOnuDbaLlidActiveStatusGet(llidIdx) != ONU_DBA_ACTIVE_LLID)
+			continue;
+
+		COLLECT_DBA_TS;
+
+		/* ======================= */
+		/* Retrieve Queue Counters */
+		/* ======================= */
+
+		/* update counters in case FEC is enabled */
+		onuEponDbOnuTxFecCfgGet(&llidTxFecState, llidIdx);
+
+		queueSetIdx = 0;
+
+		for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++) {
+			/* for each queue */
+			if (llidQueuesBitMap[llidIdx] & (1 << queueIdx)) {
+				status = onuEponPmGunitLlidQueueCntGet(llidIdx, queueIdx, &(llidCounter[queueIdx]));
+				if (status != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+						   "ERROR: (%s:%d) Llid[%d] Queue[%d] Cnt Get Failed\n\r",
+						   __FILE_DESC__, __LINE__, llidIdx, queueIdx);
+					return MV_ERROR;
+				}
+
+			} else
+				llidCounter[queueIdx] = 0;
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_MODULE,
+				   "SW DBA, queue[%d] count[%d]\n", queueIdx, llidCounter[queueIdx]);
+
+			/* convert to TQ units */
+			llidCounter[queueIdx] /= 2;
+
+			/* sum queues TQ to verify data was received */
+			llidQueuesByteCount += llidCounter[queueIdx];
+		} /* for each queue */
+
+		/* Count the number of transmitted words in the GPUnit without - checksum and header modified bytes */
+		/* Counter is clear-on-read */
+		if (familyId != MV_88F66X0)
+			onuEponPmGunitLlid0PktModPktCountGet(&llidPacketCount);
+
+		tmpLlidHighQueue = onuEponDbOnuDbaHighestReportQueueGet(llidIdx);
+
+		if (familyId != MV_88F66X0)
+			llidTotalByteCount = (llidQueuesByteCount * 2) + (llidPacketCount * 2);
+		else
+			llidTotalByteCount = (llidQueuesByteCount * 2);
+
+		COLLECT_DBA_TS;
+
+		/* =========================== */
+		/* Low-Rate and Birsty Traffic */
+		/* =========================== */
+		/* Incase there is no data was found in the LLID queues, and */
+		/* The LLID packet count != 0, meaning packets were transmitted towards the GPON MAC */
+		/* Add the number of transmitted packets in words + threshold LLID to the highest queue report */
+		/* The number of transmitted packets does include packets checksum and header modified bytes */
+		/* The threshold is used to compensate checksum and header modified bytes */
+		/* The report is sent maximum of DBA_RPRT_PERIODIC_CYCLE (6) intervals, it will be periodicly transmitted */
+		/* until is identifes data in the LLID Queues or LLID FIFO. */
+		/* In case of very low rate traffic, it send the report DBA_RPRT_PERIODIC_CYCLE (6) intervals. */
+		/* This WA is to compensate the "breathing" scheme of OLT DBA GATE allocation */
+		if (familyId != MV_88F66X0) {
+			if (llidQueuesByteCount == 0) {
+				if (llidPacketCount != 0) {
+					llidDbaRprtCount = DBA_RPRT_PERIODIC_CYCLE;
+					/* If the previous GATE allowed large traffic burst, so all packets from queues got TXed and
+					 *  packet counter indicates more packets than theoretically can be waiting in TX FIFO,
+					 *  limit the counter value to the FIFO size in order to avoid bandwidth oversubscribtion needed
+					 *  for FIFO release
+					 */
+					if (llidPacketCount > DBA_RPRT_TX_FIFO_SIZE)
+						llidDbaRprtValue = DBA_RPRT_TX_FIFO_SIZE;
+					else
+						llidDbaRprtValue = llidPacketCount;
+				}
+
+				if ((llidDbaRprtCount > 0) && (llidDbaRprtCount <= DBA_RPRT_PERIODIC_CYCLE)) {
+					llidCounter[tmpLlidHighQueue] += (llidDbaRprtValue + (rprtLowRateConstValue / 2));
+
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_WA_MODULE,
+						   "DBA WA[%d], PktCnt(%d), RprtCnt(%d)\n",
+						   llidDbaRprtCount, llidDbaRprtValue, llidCounter[tmpLlidHighQueue]);
+
+					llidDbaRprtCount--;
+				}
+
+			} else {
+				llidDbaRprtCount = 0;
+				llidDbaRprtValue = 0;
+			}
+		}
+
+		COLLECT_DBA_TS;
+
+		/* ================= */
+		/* High-Rate Traffic */
+		/* ================= */
+		/* Incase data was found in the LLID queues, the 4K FIFO is full */
+		/* If total number of bytes in the LLID queues is less the 8192 bytes */
+		/* Add configurable number of TQ (default to 1000) to highest queue report */
+		if (familyId != MV_88F66X0)
+			if ((llidQueuesByteCount > 0) && (llidQueuesByteCount < (rprtHighRateThreshold / 2)))
+				llidCounter[tmpLlidHighQueue] += (rprtHighRateValue / 2);
+
+		/* =========== */
+		/* OAM Traffic */
+		/* =========== */
+		if (llidDbaRprtForOamMsgInd == 1) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_MODULE,
+				   "SW DBA, OAM Message addition to highQ[%d] \n", tmpLlidHighQueue);
+			llidCounter[tmpLlidHighQueue] += (rprtLowRateValue / 2);
+
+			llidDbaRprtForOamMsgInd = 0;
+		}
+
+		COLLECT_DBA_TS;
+
+		/* =========== */
+		/* FEC Section */
+		/* =========== */
+		if (familyId != MV_88F66X0) {
+			if (llidTxFecState != 0) {
+				status = onuEponPmTxDataPmLastIntervalGet(&llidTransmittedPacketCount, llidIdx);
+				if (status != MV_OK) {
+					for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++)
+						if (llidCounter[queueIdx] != 0)
+							llidCounter[queueIdx] = (llidCounter[queueIdx] + (llidCounter[queueIdx] / 12)); /* default */
+
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_FEC_MODULE, "SW DBA FEC, default setting\n");
+
+				} else {
+					if (llidTransmittedPacketCount != 0) {
+						llidAvePacketLength            = (llidTotalByteCount / llidTransmittedPacketCount);
+						llidPacketCountCompensationIdx = ((llidAvePacketLength / 64) + 1);
+
+						if (llidPacketCountCompensationIdx > 32 /*limit*/)
+							llidPacketCountCompensationIdx = 32;
+
+						llidPacketCountCompensation = llidPacketFcsCompensation[llidPacketCountCompensationIdx];
+
+						mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_FEC_MODULE,
+							   "SW DBA FEC, Total Bytes(%d), Total Pkt, Ave Pkt(%d), CompIdx(%d), CompVal(%d)\n",
+							   llidTotalByteCount, llidTransmittedPacketCount,
+							   llidAvePacketLength, llidPacketCountCompensationIdx, llidPacketCountCompensation);
+
+						for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++) {
+							if (llidCounter[queueIdx] != 0)
+								llidCounter[queueIdx] =
+									(llidCounter[queueIdx] + (llidCounter[queueIdx] / llidPacketCountCompensation));
+						}
+
+					}       /* llidTransmittedPacketCount != 0 */
+				}               /* llidTransmittedPacketCount != 0 */
+			}                       /* onuEponPmTxDataPmLastIntervalGet() == MV_OK */
+		}                               /* llidTxFecState != 0 */
+
+		COLLECT_DBA_TS;
+
+		/* ==================== */
+		/* Build Report Message */
+		/* ==================== */
+		/* Support for normal report
+		** Queue Set: [Qset1, Qset2, .., QsetN, BC]
+		** Queue: [Queue0, .., QueueN]
+		** Report is sent via EPON REGISTERS
+		** =================== */
+		memset(reportMsg, 0, 40);
+
+		reportMsgIdx = 0;
+		reportMsg[reportMsgIdx++] = llidNumOfQueuesets[llidIdx];
+
+		/* update queueset reports */
+		for (queueSetIdx = 0; queueSetIdx < llidNumOfQueuesets[llidIdx]; queueSetIdx++) {
+			reportMsg[reportMsgIdx++] = llidQueuesBitMap[llidIdx];
+
+			for (queueIdx = (EPON_MAX_QUEUE - 1); queueIdx >= 0; queueIdx--) {
+				if (llidQueueState[llidIdx][queueSetIdx][queueIdx] != 0) {
+					if (llidCounter[queueIdx] > llidQueueThreshold[llidIdx][queueSetIdx][queueIdx]) {
+						reportMsg[reportMsgIdx++] = ((llidQueueThreshold[llidIdx][queueSetIdx][queueIdx] >> 8) & 0xFF);
+						reportMsg[reportMsgIdx++] = (llidQueueThreshold[llidIdx][queueSetIdx][queueIdx] & 0xFF);
+					} else {
+						reportMsg[reportMsgIdx++] = ((llidCounter[queueIdx] >> 8) & 0xFF);
+						reportMsg[reportMsgIdx++] =  (llidCounter[queueIdx]       & 0xFF);
+					}
+				}
+			}       /* for each queue */
+		}               /* for each queueset */
+
+		/* Build report in message format */
+		for (idx = 0; idx < OAM_MSG_REGS; idx++)
+			dbaSwRprtRegShadow[idx].shadow = 0;
+
+		for (msgIdx = 0; msgIdx < llidNumOfReportBytes[llidIdx]; msgIdx++) {
+			msgTmpData = ((((MV_U32)(reportMsg[msgIdx])) << dbaSwRprtRegMap[msgIdx].shift) |
+				      (dbaSwRprtRegShadow[dbaSwRprtRegMap[msgIdx].shadowIdx].shadow));
+			dbaSwRprtRegShadow[dbaSwRprtRegMap[msgIdx].shadowIdx].shadow = msgTmpData;
+		}
+
+		/* =================== */
+		/* Send Report Message */
+		/* =================== */
+		for (msgIdx = 0; msgIdx < OAM_MSG_REGS; msgIdx++) {
+			status = asicOntGlbRegWrite(dbaSwRprtRegShadow[msgIdx].reg,
+						    dbaSwRprtRegShadow[msgIdx].shadow,
+						    llidIdx);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Llid[%d] msgIdx[%d] Regiter write failed\n\r",
+					   __FILE_DESC__, __LINE__, llidIdx, msgIdx);
+				return MV_ERROR;
+			}
+		}
+
+		COLLECT_DBA_TS;
+
+		for (idx = 0; idx < 4; idx++) {
+			if (ts[idx + 1] > ts[idx])
+				interval[idx] = (MV_U32)(-1) - ts[idx] + ts[idx + 1];
+			else
+				interval[idx] = ts[idx + 1] - ts[idx];
+			interval[5] += interval[idx];
+		}
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_DBA_TS_MODULE,
+			   "llid[%d] ticks - QC[%d], LR[%d], HR[%d], FEC[%d], TX[%d], TOTAL[%d - %dnS]\n\r",
+			   llidIdx, interval[0], interval[1], interval[2], interval[3], interval[4], interval[5],
+			   interval[5] * 16);
+
+	} /* For each LLID */
+
+	return status;
+} /* enf of onuEponPonMngDbaSwRprtHandler */
+
+/*******************************************************************************
+**
+**  onuEponPonMngDbaSwRprtHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager DBA SW report handler
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngDbaDgSwRprtHandler(void)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 llidIdx;
+	MV_U32 msgIdx;
+
+	for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+		/* Active LLID */
+		/* =========== */
+		if (onuEponDbOnuDbaLlidActiveStatusGet(llidIdx) == ONU_DBA_ACTIVE_LLID) {
+			/* Send Report Message */
+			/* =================== */
+			for (msgIdx = 0; msgIdx < OAM_MSG_REGS; msgIdx++) {
+				status = asicOntGlbRegWrite(dbaDgSwRprtRegShadow[msgIdx].reg,
+							    dbaDgSwRprtRegShadow[msgIdx].shadow,
+							    llidIdx);
+				if (status != MV_OK)
+					return MV_ERROR;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngDbaDgSwRprtCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function build DG DBA SW report
+**
+**  PARAMETERS:  MV_U32 numOfQueue
+**               MV_U32 queueReport
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPonMngDbaDgSwRprtCfg(MV_U32 numOfQueue, MV_U32 queueReport)
+{
+	MV_U32 msgIdx;
+	MV_U32 msgIdx_2;
+	MV_U8 bitMapArray[] = { /* 0  */ 0x00,
+					 /* 1  */ 0x80,
+					 /* 2  */ 0xC0,
+					 /* 3  */ 0xE0,
+					 /* 4  */ 0xF0,
+					 /* 5  */ 0xF8,
+					 /* 6  */ 0xFC,
+					 /* 7  */ 0xFE,
+					 /* 8  */ 0xFF };
+
+	if (numOfQueue > 8)
+		numOfQueue  = 8;
+	if (queueReport > 0xFFFF)
+		queueReport = 0xFFFF;
+
+	/* bit map */
+	dbaDgSwRprtRegShadow[1].shadow = bitMapArray[numOfQueue];
+
+	/* queues */
+	for (msgIdx = 2; msgIdx < (2 + numOfQueue); msgIdx++)
+		dbaDgSwRprtRegShadow[msgIdx].shadow = queueReport;
+
+	for (msgIdx_2 = msgIdx; msgIdx_2 < 10; msgIdx_2++)
+		dbaDgSwRprtRegShadow[msgIdx_2].shadow = 0;
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "DG DBA Report\n");
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queueset - 0x%08X\n", dbaDgSwRprtRegShadow[0].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Bitmap   - 0x%08X\n", dbaDgSwRprtRegShadow[1].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-0  - 0x%08X\n", dbaDgSwRprtRegShadow[2].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-1  - 0x%08X\n", dbaDgSwRprtRegShadow[3].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-2  - 0x%08X\n", dbaDgSwRprtRegShadow[4].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-3  - 0x%08X\n", dbaDgSwRprtRegShadow[5].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-4  - 0x%08X\n", dbaDgSwRprtRegShadow[6].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-5  - 0x%08X\n", dbaDgSwRprtRegShadow[7].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-6  - 0x%08X\n", dbaDgSwRprtRegShadow[8].shadow);
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "Queue-7  - 0x%08X\n", dbaDgSwRprtRegShadow[9].shadow);
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngTimerSilenceHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager silence timer handler
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+void onuEponPonMngTimerSilenceHndl(unsigned long macId)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonSilenceTimerId[macId].onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_SILENCE_MODULE,
+		   "DEBUG: (%s:%d) Silence Timer[%d] Expire\n", __FILE_DESC__, __LINE__, macId);
+	onuEponPonMngAlarmHandlerExecute(macId);
+
+	if ((onuPonResourceTbl_s.onuPonSilenceTimerId[macId].onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonSilenceTimerId[macId]));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         OAM - Dying Gasp Message Handling Section          */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPonMngDgMsgPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print DG message
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+void onuEponPonMngDgMsgPrint(void)
+{
+	S_OnuEponOamFrame *oamMsg;
+
+	oamMsg = ((S_OnuEponOamFrame *)(&(dgOamMsg.data[0])));
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "\n"
+		   "DG Message\n"
+		   "==========\n"
+		   "DestMac[%x:%x:%x:%x:%x:%x] SrcMac[%x:%x:%x:%x:%x:%x]\n"
+		   "Etype[0x%x] flags[%x] code[0x%x]\n",
+		   oamMsg->stdEthFrame.destAddr[0], oamMsg->stdEthFrame.destAddr[1],
+		   oamMsg->stdEthFrame.destAddr[2], oamMsg->stdEthFrame.destAddr[3],
+		   oamMsg->stdEthFrame.destAddr[4], oamMsg->stdEthFrame.destAddr[5],
+		   oamMsg->stdEthFrame.srcAddr[0],  oamMsg->stdEthFrame.srcAddr[1],
+		   oamMsg->stdEthFrame.srcAddr[2],  oamMsg->stdEthFrame.srcAddr[3],
+		   oamMsg->stdEthFrame.srcAddr[4],  oamMsg->stdEthFrame.srcAddr[5],
+		   dgMsgEtype, oamMsg->stdOamHeader.subType,
+		   dgMsgFlags, oamMsg->stdOamHeader.code);
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngDgMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager dying gasp interrupt
+**               message transmit function
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngDgMessageHandler(MV_U32 macId)
+{
+	MV_STATUS status = MV_ERROR;
+	MV_U32 transNum = 0;
+	MV_U32 maxTransNum = 100;
+
+	onuEponPonMngDbaDgSwRprtHandler();
+	do {
+		if (onuEponSendCtrlFrameDataFreeStatus(macId) != MV_TRUE)
+			continue;
+
+		status = onuEponSendCtrlFrameData(&dgOamMsg, macId);
+		transNum++;
+
+	} while ((status != MV_OK) && (transNum <= maxTransNum));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDgMsgDefaultMessageInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Create default dying gasp interrupt message
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponDgMsgDefaultMessageInit(void)
+{
+	MV_U32 macId = 0;
+	S_OnuEponOamFrame *oamMsg;
+
+	/* clear message */
+	memset(&dgOamMsg, 0, sizeof(S_OnuEponCtrlBuffer));
+
+	/* set message length */
+	dgOamMsg.length = MIN_DG_FRAME_LEN;
+
+	/* update message content */
+	oamMsg = ((S_OnuEponOamFrame *)(&(dgOamMsg.data[0])));
+
+	oamMsg->stdEthFrame.destAddr[0] = 0x01;
+	oamMsg->stdEthFrame.destAddr[1] = 0x80;
+	oamMsg->stdEthFrame.destAddr[2] = 0xC2;
+	oamMsg->stdEthFrame.destAddr[3] = 0x00;
+	oamMsg->stdEthFrame.destAddr[4] = 0x00;
+	oamMsg->stdEthFrame.destAddr[5] = 0x02;
+
+	oamMsg->stdEthFrame.srcAddr[0] = fixMacAddrs[macId][0];
+	oamMsg->stdEthFrame.srcAddr[1] = fixMacAddrs[macId][1];
+	oamMsg->stdEthFrame.srcAddr[2] = fixMacAddrs[macId][2];
+	oamMsg->stdEthFrame.srcAddr[3] = fixMacAddrs[macId][3];
+	oamMsg->stdEthFrame.srcAddr[4] = fixMacAddrs[macId][4];
+	oamMsg->stdEthFrame.srcAddr[5] = fixMacAddrs[macId][5];
+
+	onuEponConvertH2NShort(&dgMsgEtype,  &oamMsg->stdEthFrame.etherType);
+
+	oamMsg->stdOamHeader.subType = dgMsgSubType;
+
+	onuEponConvertH2NShort(&dgMsgFlags,  &oamMsg->stdOamHeader.flags);
+
+	oamMsg->stdOamHeader.code = dgMsgCode;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngIntrDgHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager dying gasp interrupt
+**               handler function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+void onuEponPonMngIntrDgHandler(void)
+{
+	static MV_U32 first_time = 1;
+	DYINGGASPFUNC dgCallback;
+	MV_U32 macId = 0;
+
+	onuEponPonMngDgMessageHandler(macId);
+
+	if (first_time) {
+		dgCallback = onuEponDbDgCallbackGet();
+
+		if (dgCallback != NULL) {
+			dgCallback();
+			first_time = 0;
+		}
+	}
+
+	onuPonDyingGaspExit();
+
+	onuEponPonMngDgMsgPrint();
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         MPC State Machine Handling Section                 */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPonMngRegMsgFlagAck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when REGISTER message with flag Ack is
+**               received
+**
+**  PARAMETERS:  S_OnuEponRegMpcFrame *mpcFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngRegMsgFlagAck(S_OnuEponRegMpcFrame *mpcFrame)
+{
+	MV_STATUS status;
+	MV_U32 macId;
+	MV_U32 macState;
+	MV_U16 msgEtype;
+	MV_U16 msgSyncTime;
+	MV_U16 msgLlid;
+	MV_U16 msgOpcode;
+	MV_U8 msgFlags;
+	MV_U8 msgEchoedPendingGrants;
+	MV_U32 interruptMask;
+	LINKSTATUSFUNC linkStatusCallback;
+	MV_U32 llidDbaIntMask = 0;
+	MV_U32 llidIdx = 0;    /* Support for single LLID */
+
+	status = matchDestAddressToMacId(mpcFrame->stdEthFrame.destAddr, &macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MAC_ADDR_MODULE,
+			   "ERROR: (%s:%d) matchDestAddressToMacId, invalid dest addr [%02X:%02X:%02X:%02X:%02X:%02X]\n",
+			   __FILE_DESC__, __LINE__,
+			   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+			   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+			   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5]);
+		return MV_OK;
+	}
+
+	onuEponConvertN2HShort(&mpcFrame->stdEthFrame.etherType, &msgEtype);
+	onuEponConvertN2HShort(&mpcFrame->genMpcPdu.opCode, &msgOpcode);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.assignedLlidPort, &msgLlid);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.syncTime, &msgSyncTime);
+	msgFlags               = mpcFrame->regMpcPdu.flags;
+	msgEchoedPendingGrants = mpcFrame->regMpcPdu.echoedPendingGrants;
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "\n"
+		   "REGISTER [Flag=Ack] Message\n"
+		   "===========================\n"
+		   "DestMac[%x:%x:%x:%x:%x:%x] SrcMac[%x:%x:%x:%x:%x:%x]\n"
+		   "Etype[0x%x] Opcode[%x] Sync[0x%x], LLID[%x] Grant[%x] Flag[%x]\n",
+		   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+		   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+		   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5],
+		   mpcFrame->stdEthFrame.srcAddr[0], mpcFrame->stdEthFrame.srcAddr[1],
+		   mpcFrame->stdEthFrame.srcAddr[2], mpcFrame->stdEthFrame.srcAddr[3],
+		   mpcFrame->stdEthFrame.srcAddr[4], mpcFrame->stdEthFrame.srcAddr[5],
+		   msgEtype,
+		   msgOpcode,
+		   msgSyncTime,
+		   msgLlid,
+		   msgEchoedPendingGrants,
+		   msgFlags);
+
+	/* Validate mac state was updated by HW */
+	status = mvOnuEponMacOnuStateGet(&macState, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuStateGet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	if (macState != ONU_EPON_REGISTERED) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Mac[%d] state is not Registered!!!!\n\r", __FILE_DESC__, __LINE__, macId);
+		return MV_ERROR;
+	}
+
+	onuEponApiFecReConfig();
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_GATE_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			llidDbaIntMask |= 1 << llidIdx;
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			onuEponDbaSwRprtMacTimerCfg(onuEponDbOnuSwRprtMacTimerIntervalGet());
+
+			/* Start SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_TRUE);
+		}
+	}
+
+	onuEponDbPktTxLlidSet(msgLlid, macId);
+	onuEponDbPktRxLlidSet(msgLlid, macId);
+	onuEponDbOnuStateSet(ONU_EPON_03_OPERATION, macId);
+
+	onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_ON);
+
+	mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+		   "= ONU Mac[%d] Registered =\n\r", macId);
+	if (macId == 0) {
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "==================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "== MPCP Sync On ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE, "==================\n");
+	}
+
+	/* Call link status callback function */
+	linkStatusCallback = onuEponDbLinkStatusCallbackGet();
+	if (linkStatusCallback != NULL) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_INT_MODULE,
+			   "DEBUG: (%s:%d) Notify link is UP\n", __FILE_DESC__, __LINE__);
+		linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_TRUE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngRegMsgFlagNack
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when REGISTER message with flag Nack
+**               is received
+**
+**  PARAMETERS:  S_OnuEponRegMpcFrame *mpcFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngRegMsgFlagNack(S_OnuEponRegMpcFrame *mpcFrame)
+{
+	MV_STATUS status;
+	MV_U32 macId;
+	MV_U16 msgEtype;
+	MV_U16 msgSyncTime;
+	MV_U16 msgLlid;
+	MV_U16 msgOpcode;
+	MV_U8 msgFlags;
+	MV_U8 msgEchoedPendingGrants;
+
+	status = matchDestAddressToMacId(mpcFrame->stdEthFrame.destAddr, &macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MAC_ADDR_MODULE,
+			   "ERROR: (%s:%d) matchDestAddressToMacId, invalid dest addr [%02X:%02X:%02X:%02X:%02X:%02X]\n",
+			   __FILE_DESC__, __LINE__,
+			   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+			   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+			   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5]);
+		return MV_OK;
+	}
+
+	onuEponConvertN2HShort(&mpcFrame->stdEthFrame.etherType, &msgEtype);
+	onuEponConvertN2HShort(&mpcFrame->genMpcPdu.opCode, &msgOpcode);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.assignedLlidPort, &msgLlid);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.syncTime, &msgSyncTime);
+	msgFlags               = mpcFrame->regMpcPdu.flags;
+	msgEchoedPendingGrants = mpcFrame->regMpcPdu.echoedPendingGrants;
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "\n"
+		   "REGISTER [Flag=Nack] Message\n"
+		   "============================\n"
+		   "DestMac[%x:%x:%x:%x:%x:%x] SrcMac[%x:%x:%x:%x:%x:%x]\n"
+		   "Etype[0x%x] Opcode[%x] Sync[0x%x], LLID[%x] Grant[%x] Flag[%x]\n",
+		   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+		   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+		   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5],
+		   mpcFrame->stdEthFrame.srcAddr[0], mpcFrame->stdEthFrame.srcAddr[1],
+		   mpcFrame->stdEthFrame.srcAddr[2], mpcFrame->stdEthFrame.srcAddr[3],
+		   mpcFrame->stdEthFrame.srcAddr[4], mpcFrame->stdEthFrame.srcAddr[5],
+		   msgEtype,
+		   msgOpcode,
+		   msgSyncTime,
+		   msgLlid,
+		   msgEchoedPendingGrants,
+		   msgFlags);
+
+	if (onuEponDbOnuSilenceStateGet() != ONU_SILENCE_NOT_ACTIVE) {
+		status  = mvOnuEponMacGenOnuConfigAutoAckSet(0);
+		status |= mvOnuEponMacGenOnuConfigAutoRequestSet(0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to disable auto request / ack\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		onuEponDbOnuCfgAutoSet(ONU_REG_REQ_SW_RES, ONU_REG_ACK_SW_RES, ONU_REPORT_AUTO_RES);
+
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonSilenceTimerId[macId]), macId, ONU_PON_TIMER_SILENCE_INTERVAL, 1);
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_SILENCE_MODULE,
+			   "DEBUG: (%s:%d) Silence Timer Start\n", __FILE_DESC__, __LINE__);
+	} else
+		onuEponPonMngAlarmHandlerExecute(macId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngRegMsgFlagReReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when REGISTER message with flag re-register
+**               is received
+**
+**  PARAMETERS:  S_OnuEponRegMpcFrame *mpcFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngRegMsgFlagReReg(S_OnuEponRegMpcFrame *mpcFrame)
+{
+	MV_STATUS status;
+	MV_U32 macId;
+	MV_U32 macState;
+	MV_U16 msgEtype;
+	MV_U16 msgSyncTime;
+	MV_U16 msgLlid;
+	MV_U16 msgOpcode;
+	MV_U8 msgFlags;
+	MV_U8 msgEchoedPendingGrants;
+
+	status = matchDestAddressToMacId(mpcFrame->stdEthFrame.destAddr, &macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MAC_ADDR_MODULE,
+			   "ERROR: (%s:%d) matchDestAddressToMacId, invalid dest addr [%02X:%02X:%02X:%02X:%02X:%02X]\n",
+			   __FILE_DESC__, __LINE__,
+			   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+			   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+			   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5]);
+		return MV_OK;
+	}
+
+	onuEponConvertN2HShort(&mpcFrame->stdEthFrame.etherType, &msgEtype);
+	onuEponConvertN2HShort(&mpcFrame->genMpcPdu.opCode, &msgOpcode);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.assignedLlidPort, &msgLlid);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.syncTime, &msgSyncTime);
+	msgFlags               = mpcFrame->regMpcPdu.flags;
+	msgEchoedPendingGrants = mpcFrame->regMpcPdu.echoedPendingGrants;
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "\n"
+		   "REGISTER [Flag=ReReg] Message\n"
+		   "=============================\n"
+		   "DestMac[%x:%x:%x:%x:%x:%x] SrcMac[%x:%x:%x:%x:%x:%x]\n"
+		   "Etype[0x%x] Opcode[%x] Sync[0x%x], LLID[%x] Grant[%x] Flag[%x]\n",
+		   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+		   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+		   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5],
+		   mpcFrame->stdEthFrame.srcAddr[0], mpcFrame->stdEthFrame.srcAddr[1],
+		   mpcFrame->stdEthFrame.srcAddr[2], mpcFrame->stdEthFrame.srcAddr[3],
+		   mpcFrame->stdEthFrame.srcAddr[4], mpcFrame->stdEthFrame.srcAddr[5],
+		   msgEtype,
+		   msgOpcode,
+		   msgSyncTime,
+		   msgLlid,
+		   msgEchoedPendingGrants,
+		   msgFlags);
+
+	/* Validate mac state was updated by HW */
+	status = mvOnuEponMacOnuStateGet(&macState, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuStateGet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	if (macState != ONU_EPON_REGISTERED) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Mac[%d] state is not Registered!!!!\n\r", __FILE_DESC__, __LINE__, macId);
+		return MV_ERROR;
+	}
+
+	onuEponDbPktTxLlidSet(msgLlid, macId);
+	onuEponDbPktRxLlidSet(msgLlid, macId);
+	onuEponDbOnuStateSet(ONU_EPON_03_OPERATION, macId);
+
+	onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_ON);
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "= ONU Mac[%d] Registered =\n\r", macId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPonMngRegMsgFlagDeReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when REGISTER message with flag de-register
+**               is received
+**
+**  PARAMETERS:  S_OnuEponRegMpcFrame *mpcFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPonMngRegMsgFlagDeReg(S_OnuEponRegMpcFrame *mpcFrame)
+{
+	MV_STATUS status;
+	MV_U32 macId;
+	/* MV_U32    interruptMask; */
+	/* MV_U32    llidDbaIntMask; */
+	MV_U16 msgEtype;
+	MV_U16 msgSyncTime;
+	MV_U16 msgLlid;
+	MV_U16 msgOpcode;
+	MV_U8 msgFlags;
+	MV_U8 msgEchoedPendingGrants;
+
+	/* LINKSTATUSFUNC linkStatusCallback;*/
+
+	status = matchDestAddressToMacId(mpcFrame->stdEthFrame.destAddr, &macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MAC_ADDR_MODULE,
+			   "ERROR: (%s:%d) matchDestAddressToMacId, invalid dest addr [%02X:%02X:%02X:%02X:%02X:%02X]\n",
+			   __FILE_DESC__, __LINE__,
+			   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+			   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+			   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5]);
+		return MV_OK;
+	}
+
+	onuEponConvertN2HShort(&mpcFrame->stdEthFrame.etherType, &msgEtype);
+	onuEponConvertN2HShort(&mpcFrame->genMpcPdu.opCode, &msgOpcode);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.assignedLlidPort, &msgLlid);
+	onuEponConvertN2HShort(&mpcFrame->regMpcPdu.syncTime, &msgSyncTime);
+	msgFlags               = mpcFrame->regMpcPdu.flags;
+	msgEchoedPendingGrants = mpcFrame->regMpcPdu.echoedPendingGrants;
+
+	mvPonPrint(PON_PRINT_INFO, PON_MNG_MODULE,
+		   "\n"
+		   "REGISTER [Flag=DeReg] Message\n"
+		   "=============================\n"
+		   "DestMac[%x:%x:%x:%x:%x:%x] SrcMac[%x:%x:%x:%x:%x:%x]\n"
+		   "Etype[0x%x] Opcode[%x] Sync[0x%x], LLID[%x] Grant[%x] Flag[%x]\n",
+		   mpcFrame->stdEthFrame.destAddr[0], mpcFrame->stdEthFrame.destAddr[1],
+		   mpcFrame->stdEthFrame.destAddr[2], mpcFrame->stdEthFrame.destAddr[3],
+		   mpcFrame->stdEthFrame.destAddr[4], mpcFrame->stdEthFrame.destAddr[5],
+		   mpcFrame->stdEthFrame.srcAddr[0], mpcFrame->stdEthFrame.srcAddr[1],
+		   mpcFrame->stdEthFrame.srcAddr[2], mpcFrame->stdEthFrame.srcAddr[3],
+		   mpcFrame->stdEthFrame.srcAddr[4], mpcFrame->stdEthFrame.srcAddr[5],
+		   msgEtype,
+		   msgOpcode,
+		   msgSyncTime,
+		   msgLlid,
+		   msgEchoedPendingGrants,
+		   msgFlags);
+
+	if ((onuEponDbOnuSilenceStateGet() != ONU_SILENCE_NOT_ACTIVE) &&
+	    (onuEponDbOnuLoidAuthStateGet(macId) == MV_FALSE)) {
+		status  = mvOnuEponMacGenOnuConfigAutoAckSet(0);
+		status |= mvOnuEponMacGenOnuConfigAutoRequestSet(0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Failed to disable auto request / ack\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		onuEponDbOnuCfgAutoSet(ONU_REG_REQ_SW_RES, ONU_REG_ACK_SW_RES, ONU_REPORT_AUTO_RES);
+
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonSilenceTimerId[macId]), macId,
+				  ONU_PON_TIMER_SILENCE_INTERVAL, 1);
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_SILENCE_MODULE,
+			   "DEBUG: (%s:%d) Silence Timer Start\n", __FILE_DESC__, __LINE__);
+	} else
+		onuEponPonMngAlarmHandlerExecute(macId);
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         MPC Message Handling Section                       */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponReadCtrlFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function read control frame from the Rx Control queue
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponReadCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	MV_STATUS status;
+	MV_U32 usedCount;
+	MV_U32 data;
+	MV_U32 index;
+
+	status = mvOnuEponMacCpqRxCtrlQueueUsedCountGet(&usedCount);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Ctrl Queue Used Count\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (usedCount < ctrlBuf->length) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Not enough data,  Frame Length = %d, usedCount = %d\n\r",
+			   __FILE_DESC__, __LINE__, ctrlBuf->length, usedCount);
+		return MV_ERROR;
+	}
+
+	for (index = 0; index < ctrlBuf->length; index++) {
+		status = mvOnuEponMacCpqRxCtrlQueueReadData(&data);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Read Rx Ctrl Queue Data\n\r", __FILE_DESC__, __LINE__);
+			return status;
+		} else
+			ctrlBuf->data[index] = (MV_U8)data;
+	}
+
+	onuEponPmSwRxCountersAdd(TOTAL_MPCP_RX_FRAME_CNT, 0);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponRetrieveCtrlFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieve control frame from the Rx Control queue
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponRetrieveCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	MV_STATUS status;
+	MV_U32 usedHeaderCount;
+	MV_U32 flagLow;
+	MV_U32 flagHigh;
+	MV_U32 frameLength;
+
+	ctrlBuf->length = 0;
+
+	status = mvOnuEponMacCpqRxCtrlHeaderQueueUsedCountGet(&usedHeaderCount);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Ctrl Header Queue Used Count\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (usedHeaderCount <= 0)
+		return MV_ERROR;
+
+	status = mvOnuEponMacCpqRxCtrlHeaderQueueReadData(&flagLow, &flagHigh);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Ctrl Header Queue Data\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	frameLength = ((flagLow & MPC_FRAME_LENGTH_MASK) >> MPC_FRAME_LENGTH_SHIFT);
+	if ((frameLength > 0) && (frameLength <= sizeof(ctrlBuf->data))) {
+		ctrlBuf->length = frameLength;
+		status = onuEponReadCtrlFrameData(ctrlBuf);
+		if (status != MV_OK)
+			return status;
+	} else {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Unexpected frame length %d\n\r", __FILE_DESC__, __LINE__, frameLength);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponSendCtrlFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function check for free space for transmission of control frame
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FALSE
+**
+*******************************************************************************/
+MV_BOOL onuEponSendCtrlFrameDataFreeStatus(MV_U32 macId)
+{
+	MV_STATUS status;
+	MV_U32 numFreeFrames;
+	MV_U32 numFreeData;
+
+	status = mvOnuEponMacCpqTxCtrlHeaderQueueFree(&numFreeFrames, macId);
+	if (status != MV_OK)
+		return MV_FALSE;
+
+	status = mvOnuEponMacCpqTxCtrlQueueFree(&numFreeData, macId);
+	if (status != MV_OK)
+		return MV_FALSE;
+
+	if ((numFreeFrames <= 0) || (numFreeData < onuEponOamFifoSizeGet()))
+		return MV_FALSE;
+
+	return MV_TRUE;
+}
+
+/*******************************************************************************
+**
+**  onuEponSendCtrlFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function send control frame to the Tx Control queue
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponSendCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf, MV_U32 macId)
+{
+	MV_STATUS status;
+	MV_U32 numFreeFrames;
+	MV_U32 numFreeData;
+	MV_U32 index;
+
+	status = mvOnuEponMacCpqTxCtrlHeaderQueueFree(&numFreeFrames, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Tx Ctrl Header Queue\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	status = mvOnuEponMacCpqTxCtrlQueueFree(&numFreeData, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Tx Ctrl Queue\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (numFreeFrames <= 0) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) No free place in Tx Ctrl Header Queue (%d), data(%d)\n\r",
+			   __FILE_DESC__, __LINE__, numFreeFrames, numFreeData);
+		return MV_ERROR;
+	}
+
+	if (numFreeData < ctrlBuf->length) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) No free place in Tx Ctrl Data Queue\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	for (index = 0; index < ctrlBuf->length; index++) {
+		status = mvOnuEponMacCpqTxCtrlQueueWrite(ctrlBuf->data[index], macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Write Tx Ctrl Queue Data\n\r", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+
+	status = mvOnuEponMacCpqTxCtrlHeaderQueueWrite(ctrlBuf->length, macId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Write Tx Ctrl Header Queue\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	onuEponPmSwTxCountersAdd(TOTAL_MPCP_TX_FRAME_CNT, macId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponReadReportFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function read report frame from the Rx report queue
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponReadReportFrameData(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	MV_STATUS status;
+	MV_U32 usedCount;
+	MV_U32 data;
+	MV_U32 index;
+
+	status = mvOnuEponMacCpqRxRprtQueueUsedCountGet(&usedCount);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Report Queue Used Count\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (usedCount < ctrlBuf->length) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Not enough data,  Frame Length = %i, usedCount = %i\n\r",
+			   __FILE_DESC__, __LINE__, ctrlBuf->length, usedCount);
+		return MV_ERROR;
+	}
+
+	for (index = 0; index < usedCount; index++) {
+		status = mvOnuEponMacCpqRxRprtQueueReadData(&data);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Read Rx Report Queue Data\n\r", __FILE_DESC__, __LINE__);
+			return status;
+		} else
+			ctrlBuf->data[index] = (MV_U8)data;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponRetrieveReportFrameData
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieve report frame from the Rx report queue
+**
+**  PARAMETERS:  S_OnuEponCtrlBuffer *ctrlBuf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponRetrieveReportFrameData(S_OnuEponCtrlBuffer *ctrlBuf)
+{
+	MV_STATUS status;
+	MV_U32 usedHeaderCount;
+	MV_U32 flagLow;
+	MV_U32 flagHigh;
+	MV_U32 frameLength;
+
+	ctrlBuf->length = 0;
+
+	status = mvOnuEponMacCpqRxRprtHeaderQueueUsedCountGet(&usedHeaderCount);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Report Header Queue Used Count\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	if (usedHeaderCount <= 0) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) No frames received,  Used Header Count = %i\n\r",
+			   __FILE_DESC__, __LINE__, usedHeaderCount);
+		return MV_ERROR;
+	}
+
+	status = mvOnuEponMacCpqRxRprtHeaderQueueReadData(&flagLow, &flagHigh);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read Rx Report Header Queue Data\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	frameLength = flagLow & MPC_FRAME_LENGTH_MASK;
+	if (frameLength > 0 && frameLength <= sizeof(ctrlBuf->data)) {
+		ctrlBuf->length = frameLength;
+		status = onuEponReadReportFrameData(ctrlBuf);
+		if (status != MV_OK)
+			return status;
+	} else {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Unexpected frame length %d\n\r", __FILE_DESC__, __LINE__, frameLength);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponConvertN2HShort
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function convert MV_U16 from Netwotk order to Host
+**
+**  PARAMETERS:  void *srcValPtr
+**               void *destValPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponConvertN2HShort(void *srcValPtr, void *destValPtr)
+{
+	MV_U16 src;
+	MV_U16 dest;
+
+	memcpy(&src, srcValPtr, sizeof(src));
+
+	dest = ((src       & 0xFF) << 8) |
+	       ((src >> 8) & 0xFF);
+
+	memcpy(destValPtr, &dest, sizeof(dest));
+}
+
+/*******************************************************************************
+**
+**  onuEponConvertH2NShort
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function convert MV_U16 from Host order to Network
+**
+**  PARAMETERS:  void *srcValPtr
+**               void *destValPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponConvertH2NShort(void *srcValPtr, void *destValPtr)
+{
+	MV_U16 src;
+	MV_U16 dest;
+
+	memcpy(&src, srcValPtr, sizeof(src));
+
+	dest = ((src       & 0xFF) << 8) |
+	       ((src >> 8) & 0xFF);
+
+	memcpy(destValPtr, &dest, sizeof(dest));
+}
+
+/*******************************************************************************
+**
+**  onuEponConvertN2HLong
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function convert MV_U32 from Netwotk order to Host
+**
+**  PARAMETERS:  void *srcValPtr
+**               void *destValPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponConvertN2HLong(void *srcValPtr, void *destValPtr)
+{
+	MV_U32 src;
+	MV_U32 dest;
+
+	memcpy(&src, srcValPtr, sizeof(src));
+
+	dest =  ((src        & 0xFF) << 24) |
+	       (((src >>  8) & 0xFF) << 16) |
+	       (((src >> 16) & 0xFF) <<  8) |
+	       ((src >> 24) & 0xFF);
+
+	memcpy(destValPtr, &dest, sizeof(dest));
+}
+
+/*******************************************************************************
+**
+**  onuEponConvertH2NLong
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function convert MV_U32 from Host order to Network
+**
+**  PARAMETERS:  void *srcValPtr
+**               void *destValPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponConvertH2NLong(void *srcValPtr, void *destValPtr)
+{
+	MV_U32 src;
+	MV_U32 dest;
+
+	memcpy(&src, srcValPtr, sizeof(src));
+
+	dest =  ((src        & 0xFF) << 24) |
+	       (((src >>  8) & 0xFF) << 16) |
+	       (((src >> 16) & 0xFF) <<  8) |
+	       ((src >> 24) & 0xFF);
+
+	memcpy(destValPtr, &dest, sizeof(dest));
+}
+
+/*******************************************************************************
+**
+**  onuEponOamHandleCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return the state of the OAM message FIFO
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     No messages = 0
+**               messages    = 1
+**
+*******************************************************************************/
+MV_BOOL onuEponOamHandleCheck(void)
+{
+	if (oamMsgReadIndex != oamMsgWriteIndex)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamHandleMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function transmit OAM frames from SW FIFO
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponOamHandleMsg(void)
+{
+	MV_STATUS status;
+	MV_U8 nextOamMsgReadIndex;
+	S_OnuEponOamMsg *oamMsg;
+
+	if (oamMsgReadIndex != oamMsgWriteIndex) {
+		nextOamMsgReadIndex = oamMsgReadIndex + 1;
+		/* roll over */
+		if (nextOamMsgReadIndex == OAM_MSG_FIFO_LENGTH)
+			nextOamMsgReadIndex = 0;
+		oamMsg = (S_OnuEponOamMsg *)(&(oamMsgData[nextOamMsgReadIndex]));
+
+		if (onuEponSendCtrlFrameDataFreeStatus(oamMsg->macId) != MV_TRUE)
+			return OAM_MSG_NOT_TRANS;
+
+		/* Send OAM message to queue */
+		status = onuEponSendCtrlFrameData(&(oamMsg->msg), oamMsg->macId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) onuEponSendCtrlFrameData OAM", __FILE_DESC__, __LINE__);
+			return OAM_MSG_NOT_TRANS;
+		}
+
+		oamMsgReadIndex = nextOamMsgReadIndex;
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+			   "Handle read(%d) write(%d)\n", oamMsgReadIndex, oamMsgWriteIndex);
+
+		return MV_OK;
+	}
+
+	return OAM_MSG_NOT_TRANS;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamFlushAllMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function flush OAM frames from SW FIFO
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponOamFlushAllMsg(void)
+{
+	oamMsgReadIndex = oamMsgWriteIndex;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponOamAllocMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function allocate OAM frame for transmission
+**
+**  PARAMETERS:  S_OnuEponOamMsg *msg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponOamAllocMsg(S_OnuEponCtrlBuffer *msg, MV_U32 macId)
+{
+	MV_U8 nextOamMsgWriteIndex;
+
+	if ((oamMsgWriteIndex + 1) != oamMsgReadIndex) {
+		nextOamMsgWriteIndex = oamMsgWriteIndex + 1;
+		/* roll over */
+		if (nextOamMsgWriteIndex == OAM_MSG_FIFO_LENGTH)
+			nextOamMsgWriteIndex = 0;
+
+		/* update OAM message to the FIFO */
+		oamMsgData[nextOamMsgWriteIndex].macId = macId;
+		memcpy(&(oamMsgData[nextOamMsgWriteIndex].msg), msg, sizeof(S_OnuEponCtrlBuffer));
+
+		/* update index */
+		oamMsgWriteIndex = nextOamMsgWriteIndex;
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+			   "Alloc read(%d) write(%d\n", oamMsgReadIndex, oamMsgWriteIndex);
+
+		if (((oamMsgWriteIndex > oamMsgReadIndex)              &&
+		     ((oamMsgWriteIndex - oamMsgReadIndex) > 2))       ||
+		    ((oamMsgWriteIndex < oamMsgReadIndex)              &&
+		     ((OAM_MSG_FIFO_LENGTH - (oamMsgReadIndex - oamMsgWriteIndex)) > 2))) {
+			onuEponOamHandleMsg();
+			onuEponDbaSwRprtMacTimerCfg(62500);
+		}
+	} else
+		return MV_ERROR;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponDbaModeInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON PHY output register value
+**
+**  PARAMETERS:  dbaMode either ONU_DBA_HW_RPRT_MODE or ONU_DBA_SW_RPRT_MODE
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 status
+**
+*******************************************************************************/
+MV_STATUS onuEponDbaModeInit(MV_32 dbaMode)
+{
+	MV_U32 macId;
+	MV_U32 queueId;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask = 0;
+	MV_U32 llidIdx = 0;                     /* Support for single LLID */
+	MV_STATUS status = MV_OK;
+	MV_U32 familyId = MV_88F66X0;           /*mvCtrlModelGet();*/
+
+	switch (dbaMode) {
+	case ONU_DBA_HW_RPRT_MODE:
+
+		/* Start OAM transmit timer */
+		onuEponIsrOamTxHwDbaStateSet(MV_TRUE);
+
+		/* Stop SW DBA event miss timer */
+		onuEponIsrTimerEventMissStateSet(MV_FALSE);
+
+		/* Clear onu DBA Report interrupt */
+		mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+		interruptMask &= ~(ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+		interruptMask &= ~(ONU_EPON_GATE_MASK);
+		mvOnuEponMacPonInterruptMaskSet(interruptMask);
+		llidDbaIntMask = 0; /* clear all LLID DBA interrupts */
+		mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+
+		/* Configure MAC DBA Report Registers */
+		for (status = MV_OK, macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			/* HW report build for MC by default */
+			status |= mvOnuEponMacTxmCppReportConfig(0xFF,  /* Queueset2 not supported - set to 0xFF (queueReportQ2) */
+								 0x1,   /* Queueset2 not supported - set to 0x1, Software (reportBitmapQ2)*/
+								 0x0,   /* Queueset1 supported - set to 0, means all 8 queues are active (queueReport) */
+								 0x1,   /* Number of queueSet - support for 1 queueset */
+								 0x0,   /* Queueset1 supported - set to 0x1, Software (reportBitmap) */
+								 macId);
+
+			status |= mvOnuEponMacTxmCppReportBitMap(0x00FF, macId); /* Queueset1 -
+										  * 8 queues enabled(0xFF),
+										  * 8 queues disabled(0x00) */
+			status |= mvOnuEponMacTxmCppReportQueueSet(0x1, macId);  /* Number of queuesets -
+										  * support for 1 queueset */
+
+			status |= mvOnuEponMacTxmCppRpmReportConfigSet(EPON_RPM_BITMAP_ORDER_HW,
+								       EPON_RPM_QSET_ORDER_HW,
+								       EPON_RPM_REPORT_MODE_HW);
+
+			for (queueId = 0; queueId < 7; queueId++)
+				status |= mvOnuEponMacTxmCppReportQueueX(queueId, 0x03FF, macId);
+
+			status |= mvOnuEponMacTxmCppReportQueueX(queueId, 0x03FF, macId);
+			if (status != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+					   "ERROR: (%s:%d) mvOnuEponMacTxmCppReport...\n\r", __FILE_DESC__, __LINE__);
+				break;
+			}
+		}
+
+		for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(macId, 0);
+			mvOnuEponMacPPv2DbaPostFecSet(16);
+
+			for (queueId = 0; queueId < ONU_DBA_DEF_NUM_OF_QUEUE; queueId++) {
+				mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(macId, queueId);
+				mvOnuEponMacPPv2DbaPktModSet(24);
+			}
+
+		}
+
+		/* Set HW DBA mode */
+		onuEponDbOnuDbaModeSet(ONU_DBA_HW_RPRT_MODE);
+
+		break;
+
+	case ONU_DBA_SW_RPRT_MODE:
+
+		/* Stop OAM transmit timer */
+		onuEponIsrOamTxHwDbaStateSet(MV_FALSE);
+
+		if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_GATE_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			llidDbaIntMask |= 1 << llidIdx;
+			mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+		} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			/* Set SW DBA report update interval - 1 msec */
+			onuEponDbOnuSwRprtMacTimerIntervalSet(62500);
+			onuEponDbaSwRprtMacTimerCfg(onuEponDbOnuSwRprtMacTimerIntervalGet());
+
+			/* Set onu DBA Report interrupt */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+			interruptMask |= (ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+			mvOnuEponMacPonInterruptMaskSet(interruptMask);
+
+			/* Start SW DBA event miss timer */
+			onuEponIsrTimerEventMissStateSet(MV_TRUE);
+		}
+
+		for (status = MV_OK, macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			status |= mvOnuEponMacTxmCppReportConfig(0xFF,  /* Queueset2 not supported - set to 0xFF (queueReportQ2) */
+								 0x1,   /* Queueset2 not supported - set to 0x1, Software (reportBitmapQ2)*/
+								 0xFF,  /* Queueset1 supported - set to 0, means all 8 queues are active (queueReport) */
+								 0x1,   /* Number of queueSet - support for 1 queueset */
+								 0x1,   /* Queueset1 supported - set to 0x1, Software (reportBitmap) */
+								 macId);
+		}
+
+		if (familyId == MV_88F66X0) /* Legacy mode is activated */
+			status |= mvOnuEponMacTxmCppRpmReportConfigSet(EPON_RPM_BITMAP_ORDER_SW,
+								       EPON_RPM_QSET_ORDER_SW,
+								       EPON_RPM_REPORT_MODE_SW);
+
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) onuEponDbaModeInit...\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+			mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(macId, 0);
+			mvOnuEponMacPPv2DbaPostFecSet(0);
+
+			for (queueId = 0; queueId < ONU_DBA_DEF_NUM_OF_QUEUE; queueId++) {
+				mvOnuEponMacPPv2DbaLlidAndQueueIndirectAccess(macId, queueId);
+				mvOnuEponMacPPv2DbaPktModSet(24);
+			}
+
+		}
+
+		/* Set SW DBA mode */
+		onuEponDbOnuDbaModeSet(ONU_DBA_SW_RPRT_MODE);
+
+		break;
+
+	default:
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuEponDbaModeInit: Wrong DBA mode!\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponTimerTxPwrHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function start / stop 1 sec timer that will disable Tx if
+**               expired
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponTimerTxPwrHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonTxPwrTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	if (onuEponDbOnuStateGet(0) < ONU_EPON_03_OPERATION)
+		onuPonTxPowerOn(MV_FALSE);
+
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonTxPwrTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponEoamClsRuleAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds classifier rule for EOAM channel
+**
+**  PARAMETERS:  MV_U8 luid
+**               MV_U8 rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponEoamClsRuleAdd(MV_U8 luid, MV_U8 rxCpuQueue)
+{
+	MV_32 rcode;
+	MV_PP2_CLS_LKP_ENTRY fe;
+
+	/* Set EPON OAM parsing rule in PP parser */
+	mvPp2ClsSwLkpClear(&fe);
+
+	rcode = mvPp2ClsSwLkpFlowSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsSwLkpFlowSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpModSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpEnSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsSwLkpEnSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpRxqSet(&fe, (MV_32)rxCpuQueue + MV_PMAC_RX_QUEUE_SHIFT);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsHwLkpWrite(luid, MV_PP2_PON_WAY, &fe);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpRxqSet(&fe, (MV_32)rxCpuQueue + MV_GMAC0_RX_QUEUE_SHIFT);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsHwLkpWrite(luid, MV_PP2_ETH_WAY, &fe);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponEoamClsRuleDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes classifier rule for EOAM API channel
+**
+**  PARAMETERS:  MV_U8 luid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponEoamClsRuleDel(MV_U8 luid)
+{
+	MV_32 rcode;
+
+	/* Delete EPON OAM channel rule in issue engine */
+	rcode = mvPp2ClsHwLkpClear(luid, MV_PP2_PON_WAY);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+	rcode = mvPp2ClsHwLkpClear(luid, MV_PP2_ETH_WAY);
+	if (rcode) {
+		printk(KERN_ERR "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponEoamChannelAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds EOAM API channel
+**
+**  PARAMETERS:  MV_U8 rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponEoamChannelAdd(MV_U8 rxCpuQueue)
+{
+	S_OnuEoamChannel eoamChannel;
+	MV_U32 luid;
+	MV_U32 tid;
+	MV_32 rcode;
+	MV_STATUS rc;
+
+	/* Check wether OMCC already exsits */
+	rc = onuEponDbEoamChannelGet(&eoamChannel);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Fail to call onuEponDbEoamChannelGet \n");
+		return MV_ERROR;
+	}
+	if (eoamChannel.state == MV_TRUE) {
+		printk(KERN_ERR "PON OAM channel already exsits \n");
+		return MV_ERROR;
+	}
+
+	/* Rx queue checking */
+	if (rxCpuQueue >= MV_RX_QUEUE_MAX_NUM) {
+		printk(KERN_ERR "Invalid EPON OAM CPU RX queue(%d)\n", rxCpuQueue);
+		return MV_ERROR;
+	}
+
+	/* Set EPON OAM parsing rule in PP parser */
+	rcode = mvPrsEthTypeSet(MV_PP2_PON_PORT_BM | MV_PP2_GMAC0_PORT_BM | MV_PP2_GMAC1_PORT_BM,
+				MV_PP2_EOAM_ETH_TYPE,
+				MV_PP2_CPU_CODE_SPECIAL_PKT | MV_PP2_UDF3_SPECIAL_PKT,
+				MV_PP2_CPU_CODE_MASK | MV_PP2_UDF3_MASK,
+				1);
+	if (rcode) {
+		printk(KERN_ERR "Failed to add EOAM Eth parser rule\n");
+		return MV_ERROR;
+	}
+
+	/* Get valid LU ID fomr LSP */
+	luid = mvPrsFlowIdLastFreeGet();
+	if (luid == MV_PP2_PRS_INVALID_FLOW_ID) {
+		printk(KERN_ERR "Can not get LU ID for EPON OAM port\n");
+		return MV_ERROR;
+	}
+
+	/* Get last free entry,  go through the all entires from last to first */
+	tid = mvPp2PrsTcamFirstFree(MV_PP2_PRS_TCAM_SIZE - 1, 0);
+	if (tid > MV_PP2_PRS_TCAM_SIZE - 1) {
+		printk(KERN_ERR "No free TCAM entry for traffic\n");
+		return MV_ERROR;
+	}
+	rcode = mvPrsFlowIdGen(tid,
+			       luid,
+			       MV_PP2_UDF3_SPECIAL_PKT,
+			       MV_PP2_UDF3_MASK,
+			       PORT_MASK);
+	if (rcode) {
+		printk(KERN_ERR "Failed to add PP parser rule for OMCC\n");
+		return MV_ERROR;
+	}
+
+	/* Add CLS rule to filter packet to CPU */
+	rc = onuEponEoamClsRuleAdd(luid, rxCpuQueue);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Failed to add CLS rule\n");
+		return MV_ERROR;
+	}
+
+	/* Set PON way */
+	rc = mvPp2ClsHwPortWaySet(MV_PP2_PON_PORT, MV_PP2_PON_WAY);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Failed to set PON way\n");
+		return MV_ERROR;
+	}
+
+	/* Save OMCC status and RX queue to DB */
+	eoamChannel.state      = MV_TRUE;
+	eoamChannel.cpuRxQueue = rxCpuQueue;
+	eoamChannel.luid       = luid;
+	eoamChannel.prsTid     = tid;
+	rc = onuEponDbEoamChannelSet(&eoamChannel);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Failed to call onuEponDbEoamChannelSet \n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponEoamChannelDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes EOAM API channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponEoamChannelDel(void)
+{
+	S_OnuEoamChannel eoamChannel;
+	MV_32 rcode;
+	MV_STATUS rc;
+
+	/* Check wether OMCC already exsits */
+	rc = onuEponDbEoamChannelGet(&eoamChannel);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Fail to call onuEponDbEoamChannelGet \n");
+		return MV_ERROR;
+	}
+
+	if (eoamChannel.state == MV_FALSE) {
+		printk(KERN_ERR "EPON OAM channel already exsits\n");
+		return MV_OK;
+	}
+
+	/* Delete parser ETH type EPON OAM rule */
+	rcode = mvPrsEthTypeDel(MV_PP2_PON_PORT_BM | MV_PP2_GMAC0_PORT_BM | MV_PP2_GMAC1_PORT_BM,
+				MV_PP2_EOAM_ETH_TYPE);
+	if (rcode) {
+		printk(KERN_ERR "Failed to delete Parser ETH type EPON OAM rule\n");
+		return MV_ERROR;
+	}
+
+	/* Delete parser ETH type rule */
+	rcode = mvPrsFlowIdRelease(eoamChannel.luid);
+	if (rcode) {
+		printk(KERN_ERR "Failed to free parser LU ID\n");
+		return MV_ERROR;
+	}
+
+	/* Delete parser flow rule */
+	rcode = mvPrsFlowIdDel(eoamChannel.prsTid);
+	if (rcode) {
+		printk(KERN_ERR "Fail to delete PP parser rule for OMCC\n");
+		return MV_ERROR;
+	}
+
+	/* Delete CLS rule to filter packet to CPU */
+	rc = onuEponEoamClsRuleDel(eoamChannel.luid);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Fail to delete CLS rule\n");
+		return MV_ERROR;
+	}
+
+	/* Save OMCC status and RX queue to DB */
+	eoamChannel.state = MV_FALSE;
+	rc = onuEponDbEoamChannelSet(&eoamChannel);
+	if (rc != MV_OK) {
+		printk(KERN_ERR "Fail to call onuEponDbEoamChannelSet\n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponEoamChannelPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints EOAM API channel information
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponEoamChannelPrint(char *buf)
+{
+	S_OnuEoamChannel eoamChannel;
+	MV_STATUS rc;
+	int off = 0;
+
+	/* Check wether OMCC already exsits */
+	rc = onuEponDbEoamChannelGet(&eoamChannel);
+	if (rc != MV_OK) {
+		off += mvOsSPrintf(buf + off, "Fail to call onuEponDbEoamChannelGet \n");
+		return off;
+	}
+
+	if (eoamChannel.state == MV_FALSE)
+		off += mvOsSPrintf(buf + off, "EPON OAM channel: disabled\n");
+	else
+		off += mvOsSPrintf(buf + off, "EPON OAM channel: enabled. CPU rx queue:%d, luid:%d, tid:%d\n",
+				   eoamChannel.cpuRxQueue, eoamChannel.luid, eoamChannel.prsTid);
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiHighPriTxPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints OMCI API channel information
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponUiHighPriTxPrint(char *buf)
+{
+	MV_BOOL state;
+	MV_U32 llid_bm;
+	MV_STATUS rc;
+	int off = 0;
+
+	/* Check wether OMCC already exsits */
+	rc = onuEponDbHighPriTxStateGet(&state);
+	if (rc != MV_OK) {
+		off += mvOsSPrintf(buf + off, "Fail to call onuEponDbHighPriTxStateGet\n");
+		return off;
+	}
+
+	/* Check wether OMCC already exsits */
+	rc = onuEponDbHighPriTxMapGet(&llid_bm);
+	if (rc != MV_OK) {
+		off += mvOsSPrintf(buf + off, "Fail to call onuEponDbHighPriTxMapGet\n");
+		return off;
+	}
+
+	off += mvOsSPrintf(buf + off, "EPON high priority TX: %s, LLID bitmap:0x%x\n",
+			   (state == MV_TRUE) ? "enabled" : "disabled", llid_bm);
+	return off;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.h
new file mode 100644
index 0000000..91048aa
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuMngr.h
@@ -0,0 +1,219 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU GPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuMngr.h                                             **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON Manager definitions           **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_MNGR_H
+#define _ONU_EPON_MNGR_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define MPC_FRAME_LENGTH_MASK  (0x000000FF)
+#define MPC_FRAME_LENGTH_SHIFT (0)
+
+#define ALL_MAC_INDICATION     (0xFF)
+
+/* PPv2 Definitions
+   ------------------------------------------------------------------------------*/
+#define MV_PP2_PON_PORT                  (7)
+#define MV_PP2_PON_PORT_BM               (1 << MV_PP2_PON_PORT)
+#define MV_PP2_GMAC0_PORT                (0)
+#define MV_PP2_GMAC0_PORT_BM             (1 << MV_PP2_GMAC0_PORT)
+#define MV_PP2_GMAC1_PORT                (1)
+#define MV_PP2_GMAC1_PORT_BM             (1 << MV_PP2_GMAC1_PORT)
+#define MV_PP2_OMCI_MH_MASK              (0x0FFF)
+#define MV_PP2_SPECIAL_MH_ADD            (1)
+#define MV_PP2_SPECIAL_MH_DEL            (0)
+#define MV_PP2_EOAM_ETH_TYPE             (0x8809)
+
+#define MV_PP2_TO_MASK(off, size)        (((1 << size) - 1) << off)
+
+/* CPU Code, bits 4 - 6 */
+#define MV_PP2_CPU_CODE_OFFS             (4)
+#define MV_PP2_CPU_CODE_BITS             (3)
+#define MV_PP2_CPU_CODE_MASK             MV_PP2_TO_MASK(MV_PP2_CPU_CODE_OFFS, MV_PP2_CPU_CODE_BITS)
+#define MV_PP2_CPU_CODE_SPECIAL_PKT      (1 << MV_PP2_CPU_CODE_OFFS)
+
+/* UDF3 , bits 20 - 21 */
+#define MV_PP2_UDF3_OFFS                (20)
+#define MV_PP2_UDF3_BITS                (2)
+#define MV_PP2_UDF3_MASK                MV_PP2_TO_MASK(MV_PP2_UDF3_OFFS, MV_PP2_UDF3_BITS)
+#define MV_PP2_UDF3_SPECIAL_PKT         (2 << MV_PP2_UDF3_OFFS)
+
+#define MV_SPECIAL_PKT_TO_CPU_ID         (4)
+#define MV_SPECIAL_PKT_DEF_CPU_QUEUE     (7)
+#define MV_PP2_PON_WAY                   (1)
+#define MV_PP2_ETH_WAY                   (0)
+
+#define MV_RX_QUEUE_MAX_NUM              (8)
+#define MV_GMAC0_RX_QUEUE_SHIFT          (0)
+#define MV_GMAC1_RX_QUEUE_SHIFT          (8)
+
+#ifndef PON_FPGA
+#define MV_PMAC_RX_QUEUE_SHIFT           (0x18)
+#else
+#define MV_PMAC_RX_QUEUE_SHIFT           (0x10)
+#endif
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	E_EPON_DBA_OAM_HW_DISABLE = 0,
+	E_EPON_DBA_OAM_HW_ENABLE  = 1
+} E_EponDbaOamByteState;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+/* Interrupt handler Functions */
+void      onuEponPonMngIntrAlarmHandler(MV_U32 alarm, MV_BOOL alarmStatus);
+void      onuEponPonMngIntrMessageHandler(MV_U32 msg);
+void      onuEponPonMngIntrRxCtrlFifoCleanup(void);
+MV_STATUS onuEponPonMngIntrCtrlMessageHandler(S_OnuEponCtrlBuffer *ctrlBuf);
+MV_STATUS onuEponPonMngIntrRprtMessageHandler(S_OnuEponCtrlBuffer *ctrlBuf);
+MV_STATUS onuEponPonMngTimerRprtMessageHandler(MV_U32 macId);
+
+/* State Machine Functions */
+MV_STATUS onuEponPonMngRegMsgFlagAck(S_OnuEponRegMpcFrame *mpcFrame);
+MV_STATUS onuEponPonMngRegMsgFlagNack(S_OnuEponRegMpcFrame *mpcFrame);
+MV_STATUS onuEponPonMngRegMsgFlagReReg(S_OnuEponRegMpcFrame *mpcFrame);
+MV_STATUS onuEponPonMngRegMsgFlagDeReg(S_OnuEponRegMpcFrame *mpcFrame);
+
+/* MPC Message Handling Functions */
+MV_STATUS onuEponReadCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf);
+MV_STATUS onuEponRetrieveCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf);
+MV_STATUS onuEponReadReportFrameData(S_OnuEponCtrlBuffer *ctrlBuf);
+MV_STATUS onuEponRetrieveReportFrameData(S_OnuEponCtrlBuffer *ctrlBuf);
+
+void      onuEponConvertN2HShort(void *srcValPtr, void *destValPtr);
+void      onuEponConvertN2HLong(void *srcValPtr, void *destValPtr);
+void      onuEponConvertH2NShort(void *srcValPtr, void *destValPtr);
+void      onuEponConvertH2NLong(void *srcValPtr, void *destValPtr);
+
+MV_STATUS onuEponOamMsgFifoInit(void);
+MV_STATUS onuEponPonMngDbaParamsInit(void);
+MV_STATUS onuEponPonMngDbaSwRprtHandler(void);
+MV_STATUS onuEponPonMngDbaDgSwRprtHandler(void);
+
+MV_STATUS onuEponSendCtrlFrameData(S_OnuEponCtrlBuffer *ctrlBuf, MV_U32 macId);
+MV_BOOL   onuEponSendCtrlFrameDataFreeStatus(MV_U32 macId);
+void      onuEponDgMsgDefaultMessageInit(void);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* Interrupt handler Functions */
+void onuEponPonMngIntrAlarmHandler(MV_U32 alarm, MV_BOOL alarmStatus);
+void onuEponPonMngIntrRegHandler(MV_U32 reg, MV_BOOL regStatus);
+void onuEponPonMngIntrMessageHandler(MV_U32 msg);
+void onuEponPonMngIntrRxCtrlFifoCleanup(void);
+void onuEponPonMngTxCtrlMessageHandler(void);
+void onuEponPonMngSwRprtMessageHandler(void);
+
+void onuEponPonMngDbaDgSwRprtCfg(MV_U32 numOfQueue, MV_U32 queueReport);
+void onuEponPonMngIntrDgHandler(void);
+
+void onuEponPonMngAlarmHandlerExecute(MV_U32 macId);
+
+MV_STATUS onuEponAppInit(void);
+MV_BOOL   onuEponOamHandleCheck(void);
+MV_STATUS onuEponOamHandleMsg(void);
+MV_STATUS onuEponOamFlushAllMsg(void);
+MV_STATUS onuEponOamAllocMsg(S_OnuEponCtrlBuffer *msg, MV_U32 macId);
+MV_STATUS onuEponDbaModeInit(MV_32 dba_mode);
+MV_STATUS onuEponDbaInfoUpdate(MV_U32 macId);
+
+void      onuEponPonMngTimerSilenceHndl(unsigned long data);
+void      onuEponPonMngTimerHwRprtTxModHndl(unsigned long data);
+
+void      onuEponTimerTxPwrHndl(unsigned long data);
+MV_STATUS onuEponEoamChannelAdd(MV_U8 rxCpuQueue);
+MV_STATUS onuEponEoamChannelDel(void);
+MV_STATUS onuEponEoamChannelPrint(char *buf);
+MV_STATUS onuEponUiHighPriTxPrint(char *buf);
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_MNGR_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.c
new file mode 100644
index 0000000..0fe1c60
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.c
@@ -0,0 +1,1337 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU GPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuPm.c                                               **/
+/**                                                                          **/
+/**  DESCRIPTION : This file implements ONU EPON Alarm and Statistics        **/
+/**                functionality                                             **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/epon/eponOnuPm.c"
+
+#define POLYNOMIAL (0x04c11db7)
+
+/* Index = LLID_num * 8 + Queue_num,
+   register relative address = 0x8200 + 4 * Index
+
+   LLID 0 Queue 0 = 0x88200
+   LLID 0 Queue 1 = 0x88204
+   LLID 0 Queue 2 = 0x88208
+   LLID 0 Queue 3 = 0x8820C
+   LLID 0 Queue 4 = 0x88210
+   LLID 0 Queue 5 = 0x88214
+   LLID 0 Queue 6 = 0x88218
+   LLID 0 Queue 7 = 0x8821C
+
+   LLID 1 Queue 0 = 0x88220
+   ..
+   LLID 1 Queue 7 = 0x8823C
+
+   LLID 2 Queue 0 = 0x88240
+   ..
+   LLID 2 Queue 7 = 0x8825C
+
+   LLID 3 Queue 0 = 0x88260
+   ..
+   LLID 3 Queue 7 = 0x8827C
+
+   LLID 4 Queue 0 = 0x88280
+   ..
+   LLID 4 Queue 7 = 0x8829C
+
+   LLID 5 Queue 0 = 0x882A0
+   ..
+   LLID 5 Queue 7 = 0x882BC
+
+   LLID 6 Queue 0 = 0x882C0
+   ..
+   LLID 6 Queue 7 = 0x882DC
+
+   LLID 7 Queue 0 = 0x882E0
+   ..
+   LLID 7 Queue 7 = 0x882FC
+ */
+#define MV_PON_GUNIT_TX_N_QUEUES(llid, queue) (0xF8200 + 4 * ((llid * 8) + queue))
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_EponPm g_OnuEponPm[EPON_MAX_MAC_NUM];
+S_SwPm g_OnuEponSwPm[EPON_MAX_MAC_NUM];
+MV_U32 g_OnuEponSwPmAddCntPerLlidAndQueue[EPON_MAX_MAC_NUM][EPON_MAX_QUEUE];
+MV_U32 g_OnuEponSwPmAddCntPerLlidFifo[EPON_MAX_MAC_NUM];
+
+#define GPON_RANDOM_ARR_SZ      8
+#define GPON_RANDOM_VAL_ARR_SZ  256
+MV_U32 g_OnuEponRandomNum[GPON_RANDOM_ARR_SZ] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+MV_U32 g_OnuEponRandomCount = 0;
+MV_U32 g_OnuEponRandomValues[GPON_RANDOM_VAL_ARR_SZ] = { 0 };
+
+static MV_U32 crc_table[256];
+static S_apiLlidPmConfigDb apiLlidPmConfigDb;
+
+extern spinlock_t onuPonIrqLock;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Statistics Section                                 */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPmInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init the onu epon pm table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPmInit(void)
+{
+	MV_U32 index;
+
+	/* reset all counters */
+	memset(&g_OnuEponPm,   0, sizeof(S_EponPm) * EPON_MAX_MAC_NUM);
+	memset(&g_OnuEponSwPm, 0, sizeof(S_SwPm)   * EPON_MAX_MAC_NUM);
+	memset(g_OnuEponSwPmAddCntPerLlidAndQueue, 0, (sizeof(MV_U32) * EPON_MAX_MAC_NUM * EPON_MAX_QUEUE));
+
+	for (index = 0; index < EPON_MAX_MAC_NUM; index++)
+		g_OnuEponSwPmAddCntPerLlidFifo[index] = 4000;
+
+	/* generate crc table */
+	onuEponPmGenCrcTable();
+
+	mvOnuEponMacGenLocalTimeStampGet(&g_OnuEponRandomNum[0]);
+}
+
+/*******************************************************************************
+**
+**  onuEponPmTimerPmHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the EPON PM timer
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPmTimerPmHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+	/* Call PM handler */
+	onuEponPmTimerExpireHndl();
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	if ((onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonPmTimerId));
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponPmTimerExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine execute PM handler functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponPmTimerExpireHndl(void)
+{
+	onuEponPmCountersAdd();
+}
+
+/*******************************************************************************
+**
+**  onuEponPmCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine read statistics values from ASIC to the database
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmCountersAdd(void)
+{
+	MV_U32 counter;
+	MV_U32 llidTxFecState;
+	MV_U32 macId;
+	S_PcsPm statCounters;
+
+	/* Rx Counters - One set of counters for all MACs */
+	/* ============================================== */
+	mvOnuEponMacRxStatsFcsErrorGet(&counter, 0);            /* Count number of received frames with FCS errors */
+	g_OnuEponPm[0].rx.fcsErrorFramesCnt += counter;
+	mvOnuEponMacRxStatsShortErrorGet(&counter, 0);          /* Count number of short frames received */
+	g_OnuEponPm[0].rx.shortFramesCnt += counter;
+	mvOnuEponMacRxStatsLongErrorGet(&counter, 0);           /* Count number of long frames received */
+	g_OnuEponPm[0].rx.longFramesCnt += counter;
+	mvOnuEponMacRxStatsDataFrameGet(&counter, 0);           /* Count number of data frames received */
+	g_OnuEponPm[0].rx.dataFramesCnt += counter;
+	mvOnuEponMacRxStatsCtrlFrameGet(&counter, 0);           /* Count number of control frames received */
+	g_OnuEponPm[0].rx.ctrlFramesCnt += counter;
+	mvOnuEponMacRxStatsReportFrameGet(&counter, 0);         /* Count number of report frames received */
+	g_OnuEponPm[0].rx.reportFramesCnt += counter;
+	mvOnuEponMacRxStatsGateFrameGet(&counter, 0);           /* Count number of gate frames received */
+	g_OnuEponPm[0].rx.gateFramesCnt += counter;
+
+	/* PCS Stats counters - one for all MACs */
+	mvOnuEponMacPcsStatsGet(&statCounters.legalFrameCnt,
+				&statCounters.maxFrameSizeErrCnt,
+				&statCounters.parityLenErrCnt,
+				&statCounters.longGateErrCnt,
+				&statCounters.protocolErrCnt,
+				&statCounters.minFrameSizeErrCnt,
+				&statCounters.legalFecFrameCnt,
+				&statCounters.legalNonFecFrameCnt);
+
+	g_OnuEponPm[0].pcs.legalFrameCnt += statCounters.legalFrameCnt;
+	g_OnuEponPm[0].pcs.maxFrameSizeErrCnt += statCounters.maxFrameSizeErrCnt;
+	g_OnuEponPm[0].pcs.parityLenErrCnt += statCounters.parityLenErrCnt;
+	g_OnuEponPm[0].pcs.longGateErrCnt += statCounters.longGateErrCnt;
+	g_OnuEponPm[0].pcs.protocolErrCnt += statCounters.protocolErrCnt;
+	g_OnuEponPm[0].pcs.minFrameSizeErrCnt += statCounters.minFrameSizeErrCnt;
+	g_OnuEponPm[0].pcs.legalFecFrameCnt += statCounters.legalFecFrameCnt;
+	g_OnuEponPm[0].pcs.legalNonFecFrameCnt += statCounters.legalNonFecFrameCnt;
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		/* Tx Counters */
+		/* =========== */
+		/* Count number of register request frames transmitted */
+		mvOnuEponMacTxStatsCtrlRegReqFrameGet(&counter, macId);
+		g_OnuEponPm[macId].tx.ctrlRegReqFramesCnt += counter;
+		/* Count number of register acknowledge frames transmitted */
+		mvOnuEponMacTxStatsCtrlRegAckFrameGet(&counter, macId);
+		g_OnuEponPm[macId].tx.ctrlRegAckFramesCnt += counter;
+		/* Count number of report frames transmitted */
+		mvOnuEponMacTxStatsCtrlReportFrameGet(&counter, macId);
+		g_OnuEponPm[macId].tx.reportFramesCnt += counter;
+		/* Count number of Tx Byte Allow counter */
+		mvOnuEponMacTxStatsTxAllowedByteCountGet(&counter, macId);
+		g_OnuEponPm[macId].tx.txAllowedBytesCnt += counter;
+
+		/* update counters in case FEC is disabled */
+		onuEponDbOnuTxFecCfgGet(&llidTxFecState, macId);
+		if (llidTxFecState == 0) {
+			/* Count number of data frames transmitted */
+			mvOnuEponMacTxStatsDataFrameGet(&counter, macId);
+			g_OnuEponPm[macId].tx.dataFramesCnt += counter;
+		}
+
+		/* Sw Counters */
+		/* =========== */
+		onuEponPmSwCountersUpdate(&g_OnuEponPm[macId].sw, macId);
+
+		/* Gpm Counters */
+		/* ============ */
+		mvOnuEponMacGpmGrantValidCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.grantValidCnt += counter;
+		mvOnuEponMacGpmGrantMaxFutureTimeErrorCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.grantMaxFutureTimeErrorCnt += counter;
+		mvOnuEponMacGpmMinProcTimeErrorCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.minProcTimeErrorCnt += counter;
+		mvOnuEponMacGpmLengthErrorCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.lengthErrorCnt += counter;
+		mvOnuEponMacGpmDiscoveryAndRegisterCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.discoveryAndRegCnt += counter;
+		mvOnuEponMacGpmFifoFullErrorCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.fifoFullErrorCnt += counter;
+		mvOnuEponMacGpmOpcDiscoveryNotRegisterBcastCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcDiscoveryNotRegBcastCnt += counter;
+		mvOnuEponMacGpmOpcRegisterNotDiscoveryCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcRegisterNotDiscoveryCnt += counter;
+		mvOnuEponMacGpmOpcDiscoveryNotRegisterNotBcastCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcDiscoveryNotRegNotBcastCnt += counter;
+		mvOnuEponMacGpmOpcDropGrantCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcDropGrantCnt += counter;
+		mvOnuEponMacGpmOpcHiddenGrantCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcHiddenGrantCnt += counter;
+		mvOnuEponMacGpmOpcBackToBackCounterGet(&counter, macId);
+		g_OnuEponPm[macId].gpm.opcBackToBackCnt += counter;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmSwCountersUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates software counters
+**
+**  PARAMETERS:  S_SwPm *swPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmSwCountersUpdate(S_SwPm *swPm, MV_U32 macId)
+{
+	MV_U32 index;
+
+	/* MAC 0 counts RX statitics for all modules */
+	for (index = 0; index < MAX_EPON_RX_SW_CNT; index++)
+		swPm->swRxCnt[index] = g_OnuEponSwPm[macId].swRxCnt[index];
+
+	for (index = 0; index < MAX_EPON_TX_SW_CNT; index++)
+		swPm->swTxCnt[index] = g_OnuEponSwPm[macId].swTxCnt[index];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmSwRxCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates SW Rx counters
+**
+**  PARAMETERS:  MV_U32 cnt
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmSwRxCountersAdd(MV_U32 cnt, MV_U32 macId)
+{
+	if (cnt >= MAX_EPON_RX_SW_CNT)
+		return MV_ERROR;
+
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	g_OnuEponSwPm[macId].swRxCnt[cnt]++;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmSwTxCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates SW counters
+**
+**  PARAMETERS:  MV_U32 cnt
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmSwTxCountersAdd(MV_U32 cnt, MV_U32 macId)
+{
+	if (cnt >= MAX_EPON_TX_SW_CNT)
+		return MV_ERROR;
+
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	g_OnuEponSwPm[macId].swTxCnt[cnt]++;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmRxPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx counters
+**
+**  PARAMETERS:  S_RxPm *rxPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmRxPmGet(S_RxPm *rxPm, MV_U32 macId)
+{
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	rxPm->fcsErrorFramesCnt = g_OnuEponPm[macId].rx.fcsErrorFramesCnt;
+	rxPm->shortFramesCnt    = g_OnuEponPm[macId].rx.shortFramesCnt;
+	rxPm->longFramesCnt     = g_OnuEponPm[macId].rx.longFramesCnt;
+	rxPm->dataFramesCnt     = g_OnuEponPm[macId].rx.dataFramesCnt;
+	rxPm->ctrlFramesCnt     = g_OnuEponPm[macId].rx.ctrlFramesCnt;
+	rxPm->reportFramesCnt   = g_OnuEponPm[macId].rx.reportFramesCnt;
+	rxPm->gateFramesCnt     = g_OnuEponPm[macId].rx.gateFramesCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmCtrlCntGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu control packet counters
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_U32 onuEponPmCtrlCntGet(MV_U32 macId)
+{
+	return g_OnuEponPm[macId].rx.ctrlFramesCnt;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmTxPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Tx counters
+**
+**  PARAMETERS:  S_TxPm *txPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmTxPmGet(S_EponTxPm *txPm, MV_U32 macId)
+{
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	txPm->ctrlRegReqFramesCnt = g_OnuEponPm[macId].tx.ctrlRegReqFramesCnt;
+	txPm->ctrlRegAckFramesCnt = g_OnuEponPm[macId].tx.ctrlRegAckFramesCnt;
+	txPm->reportFramesCnt     = g_OnuEponPm[macId].tx.reportFramesCnt;
+	txPm->dataFramesCnt       = g_OnuEponPm[macId].tx.dataFramesCnt;
+	txPm->txAllowedBytesCnt   = g_OnuEponPm[macId].tx.txAllowedBytesCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmTxDataPmLastIntervalGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Tx datacounters
+**
+**  PARAMETERS:  MV_U32 *txDataPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmTxDataPmLastIntervalGet(MV_U32 *txDataPm, MV_U32 macId)
+{
+	MV_U32 counter;
+	MV_STATUS status = MV_OK;
+
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	status = mvOnuEponMacTxStatsDataFrameGet(&counter, macId); /* Count number of data frames transmitted */
+	if (status == MV_OK) {
+		g_OnuEponPm[macId].tx.dataFramesCnt += counter;
+		*txDataPm = counter;
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmTxByteCntGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu control tx byte allowed counter
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_U32 onuEponPmTxByteCntGet(MV_U32 macId)
+{
+	return g_OnuEponPm[macId].tx.txAllowedBytesCnt;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmSwPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu SW counters
+**
+**  PARAMETERS:  S_SwPm *swPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmSwPmGet(S_SwPm *swPm, MV_U32 macId)
+{
+	MV_U32 index;
+
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	for (index = 0; index < MAX_EPON_RX_SW_CNT; index++)
+		swPm->swRxCnt[index] = g_OnuEponPm[macId].sw.swRxCnt[index];
+
+	for (index = 0; index < MAX_EPON_TX_SW_CNT; index++)
+		swPm->swTxCnt[index] = g_OnuEponPm[macId].sw.swTxCnt[index];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGpmPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Gpm counters
+**
+**  PARAMETERS:  S_GpmPm *gpmPm
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmGpmPmGet(S_GpmPm *gpmPm, MV_U32 macId)
+{
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	gpmPm->grantValidCnt                 = g_OnuEponPm[macId].gpm.grantValidCnt;
+	gpmPm->grantMaxFutureTimeErrorCnt    = g_OnuEponPm[macId].gpm.grantMaxFutureTimeErrorCnt;
+	gpmPm->minProcTimeErrorCnt           = g_OnuEponPm[macId].gpm.minProcTimeErrorCnt;
+	gpmPm->lengthErrorCnt                = g_OnuEponPm[macId].gpm.lengthErrorCnt;
+	gpmPm->discoveryAndRegCnt            = g_OnuEponPm[macId].gpm.discoveryAndRegCnt;
+	gpmPm->fifoFullErrorCnt              = g_OnuEponPm[macId].gpm.fifoFullErrorCnt;
+	gpmPm->opcDiscoveryNotRegBcastCnt    = g_OnuEponPm[macId].gpm.opcDiscoveryNotRegBcastCnt;
+	gpmPm->opcRegisterNotDiscoveryCnt    = g_OnuEponPm[macId].gpm.opcRegisterNotDiscoveryCnt;
+	gpmPm->opcDiscoveryNotRegNotBcastCnt = g_OnuEponPm[macId].gpm.opcDiscoveryNotRegNotBcastCnt;
+	gpmPm->opcDropGrantCnt               = g_OnuEponPm[macId].gpm.opcDropGrantCnt;
+	gpmPm->opcHiddenGrantCnt             = g_OnuEponPm[macId].gpm.opcHiddenGrantCnt;
+	gpmPm->opcBackToBackCnt              = g_OnuEponPm[macId].gpm.opcBackToBackCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGpmValidGrantGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Gpm valid grant counter
+**
+**  PARAMETERS:  MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Gpm valid grant counter
+**
+*******************************************************************************/
+MV_U32 onuEponPmGpmValidGrantGet(MV_U32 macId)
+{
+	if (macId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	return g_OnuEponPm[macId].gpm.grantValidCnt;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmPcsPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Pcs counters
+**
+**  PARAMETERS:  S_PcsPm *pcsPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponPmPcsPmGet(S_PcsPm *pcsPm)
+{
+	if (pcsPm == 0)
+		return MV_BAD_PARAM;
+
+	pcsPm->legalFrameCnt       = g_OnuEponPm[0].pcs.legalFrameCnt;
+	pcsPm->maxFrameSizeErrCnt  = g_OnuEponPm[0].pcs.maxFrameSizeErrCnt;
+	pcsPm->parityLenErrCnt     = g_OnuEponPm[0].pcs.parityLenErrCnt;
+	pcsPm->longGateErrCnt      = g_OnuEponPm[0].pcs.longGateErrCnt;
+	pcsPm->protocolErrCnt      = g_OnuEponPm[0].pcs.protocolErrCnt;
+	pcsPm->minFrameSizeErrCnt  = g_OnuEponPm[0].pcs.minFrameSizeErrCnt;
+	pcsPm->legalFecFrameCnt    = g_OnuEponPm[0].pcs.legalFecFrameCnt;
+	pcsPm->legalNonFecFrameCnt = g_OnuEponPm[0].pcs.legalNonFecFrameCnt;
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         GUNIT LLID TX Queues Section                       */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponPmDbaAddBytePerLlidFifo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion add additional bytes per LLID FIFO
+**
+**  PARAMETERS:  MV_U32 llId
+**               MV_U32 counter
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OK or ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponPmDbaAddBytePerLlidFifo(MV_U32 llId, MV_U32 counter)
+{
+	if (llId >= EPON_MAX_MAC_NUM)
+		return MV_ERROR;
+
+	g_OnuEponSwPmAddCntPerLlidFifo[llId] = counter;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmDbaAddBytePerLlidFifoGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return additional bytes per LLID FIFO
+**
+**  PARAMETERS:  MV_U32 llId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Additional bytes per LLID FIFO
+**
+*******************************************************************************/
+MV_U32 onuEponPmDbaAddBytePerLlidFifoGet(MV_U32 llId)
+{
+	if (llId >= EPON_MAX_MAC_NUM)
+		return 0;
+
+	return g_OnuEponSwPmAddCntPerLlidFifo[llId];
+}
+
+/*******************************************************************************
+**
+**  onuEponPmDbaAddBytePerLlidAndQueue
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion add additional bytes per queue
+**
+**  PARAMETERS:  MV_U32 llId
+**				 MV_U32 queueId
+**               MV_U32 counter
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OK or ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponPmDbaAddBytePerLlidAndQueue(MV_U32 llId, MV_U32 queueId, MV_U32 counter)
+{
+	if ((queueId >= EPON_MAX_QUEUE) || (llId >= EPON_MAX_MAC_NUM))
+		return MV_ERROR;
+
+	g_OnuEponSwPmAddCntPerLlidAndQueue[llId][queueId] = counter;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmDbaAddBytePerLlidAndQueueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return additional bytes per queue
+**
+**  PARAMETERS:  MV_U32 llId
+**				 MV_U32 queueId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Additional bytes per queue
+**
+*******************************************************************************/
+MV_U32 onuEponPmDbaAddBytePerLlidAndQueueGet(MV_U32 llId, MV_U32 queueId)
+{
+	if ((queueId >= EPON_MAX_QUEUE) || (llId >= EPON_MAX_MAC_NUM))
+		return 0;
+
+	return g_OnuEponSwPmAddCntPerLlidAndQueue[llId][queueId];
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGunitLlidQueueCntGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Gunit LLID TX queue counter
+**
+**  PARAMETERS:  MV_U32 llId
+**               MV_U32 queueId
+**               MV_U32 *counter
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     nu Gunit LLID TX queue counter
+**
+*******************************************************************************/
+MV_STATUS onuEponPmGunitLlidQueueCntGet(MV_U32 llid, MV_U32 queueId, MV_U32 *counter)
+{
+	/* This function is called from IRQ context, therefore the registers access should be as fast as possible
+	   For this purpose the standard call to asicOntMiscRegRead() API is not used and registers are indexed
+	   and accesses using macros only
+	 */
+	if ((llid >= EPON_MAX_MAC_NUM) || (queueId > onuEponDbOnuDbaHighestReportQueueGet(llid)) || (counter == 0))
+		return MV_ERROR;
+
+	*counter = MV_REG_READ(MV_PON_GUNIT_TX_N_QUEUES(llid, queueId));
+	*counter += onuEponPmDbaAddBytePerLlidAndQueueGet(llid, queueId);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGunitLlid0PktModMaxHeaderSizeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion configure LLID0 Packet Modification max header size to 2 bytes
+**
+**  PARAMETERS:  MV_U32 headerSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or Error
+**
+*******************************************************************************/
+MV_STATUS onuEponPmGunitLlid0PktModMaxHeaderSizeSet(MV_U32 headerSize)
+{
+	MV_STATUS status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_GUNIT_TX_0_PKT_MOD_MAX_HEAD_SIZE_CFG, headerSize, 0);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGunitLlid0PktModPktCountGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return LLID0 Packet Modification long header packet
+**               counter
+**
+**  PARAMETERS:  MV_U32 *packetCount
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Onu Gunit LLID0 Packet Modification long header packet count
+**
+*******************************************************************************/
+MV_STATUS onuEponPmGunitLlid0PktModPktCountGet(MV_U32 *packetCount)
+{
+	MV_STATUS status;
+
+	status  = asicOntMiscRegRead(mvAsicReg_GUNIT_TX_0_PKT_MOD_STATS_PKT_COUNT, packetCount, 0);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmRandomGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu random number
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0nu random number
+**
+*******************************************************************************/
+MV_STATUS onuEponPmRandomGet(MV_U32 *random)
+{
+	MV_U32 addressLow;
+	MV_U32 addressHigh;
+	MV_U32 thermalRegValue;
+	MV_U32 thermalRegAddr = 0x000184D8;
+	MV_STATUS status;
+	S_PcsPm pcsPm;
+
+	if (random == 0)
+		return MV_BAD_PARAM;
+
+	status = onuEponDbOnuMacAddrGet(&addressLow, &addressHigh, 0);
+	if (status == MV_OK)
+		status = onuEponPmPcsPmGet(&pcsPm); /* take stat counters from DB */
+
+	if (status != MV_OK)
+		return status;
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	g_OnuEponRandomNum[7] = thermalRegValue;
+	mvOsDelay(addressLow & 0xFF);
+
+	g_OnuEponRandomNum[1] = pcsPm.legalFrameCnt;
+	g_OnuEponRandomNum[2] = pcsPm.parityLenErrCnt | (pcsPm.maxFrameSizeErrCnt << 16);
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	g_OnuEponRandomNum[7] |= thermalRegValue << 9;
+	mvOsDelay(addressLow & 0xFF);
+
+	g_OnuEponRandomNum[3] = pcsPm.protocolErrCnt | (pcsPm.longGateErrCnt << 16);
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	g_OnuEponRandomNum[7] |= thermalRegValue << 18;
+	mvOsDelay(addressLow & 0xFF);
+
+	g_OnuEponRandomNum[4] = pcsPm.minFrameSizeErrCnt;
+	g_OnuEponRandomNum[5] = pcsPm.legalNonFecFrameCnt | (pcsPm.legalFecFrameCnt << 16);
+
+	g_OnuEponRandomNum[6] = addressLow;
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1F);
+	g_OnuEponRandomNum[7] |= thermalRegValue << 27;
+
+	*random = onuEponPmGenCrcKey(g_OnuEponRandomNum, GPON_RANDOM_ARR_SZ);
+	/* Count number of random value requests and put value into DB */
+	g_OnuEponRandomValues[g_OnuEponRandomCount % GPON_RANDOM_VAL_ARR_SZ] = *random;
+	g_OnuEponRandomCount++;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmRandomReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion reset onu random number
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0nu random number
+**
+*******************************************************************************/
+MV_STATUS onuEponPmRandomReset(void)
+{
+	MV_U32 i;
+
+	for (i = 0; i < GPON_RANDOM_ARR_SZ; i++)
+		g_OnuEponRandomNum[i] = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmRandomThresholdCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu random threshold check parameters
+**
+**  PARAMETERS:  MV_U32 *gateFrames
+**               MV_U32 *discNotRegFrames
+**               MV_U32 *regReqframes
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0nu random number
+**
+*******************************************************************************/
+MV_STATUS onuEponPmRandomThresholdCheck(MV_U32 *gateFrames, MV_U32 *discNotRegFrames,
+					MV_U32 *regReqframes)
+{
+	*gateFrames       = g_OnuEponPm[0].rx.gateFramesCnt;
+	*discNotRegFrames = g_OnuEponPm[0].gpm.opcDiscoveryNotRegBcastCnt;
+	*regReqframes     = g_OnuEponPm[0].tx.ctrlRegReqFramesCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGenCrcTable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function generate table of CRC remainders
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponPmGenCrcTable(void)
+{
+	register int i, j;
+	register MV_U32 crc_accum;
+
+	for (i = 0;  i < 256;  i++) {
+		crc_accum = ((MV_U32)i << 24);
+		for (j = 0;  j < 8;  j++) {
+			if ( crc_accum & 0x80000000)
+				crc_accum = (crc_accum << 1) ^ POLYNOMIAL;
+			else
+				crc_accum = (crc_accum << 1);
+		}
+		crc_table[i] = crc_accum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponPmGenCrcKey
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function calculate CRC key
+**
+**      PARAMETERS:  unsigned long msg[]
+**				 int           size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_U32 onuEponPmGenCrcKey(MV_U32 msg[], MV_U32 size)
+{
+	MV_U8 data;
+	MV_U32 idx;
+	MV_U32 calcCrc = 0;
+
+	for (idx = 0;  idx < size;  idx++) {
+		data    = (MV_U8)((msg[idx]) ^ (calcCrc >> 24));
+		calcCrc = ((crc_table[data]) ^ (calcCrc << 8));
+	}
+
+	return calcCrc;
+}
+
+void onuEponPmLlidPmInit(void)
+{
+	int indx;
+
+	for (indx = 0; indx < MAX_ENTRIES_LLIDPM_CONFIG_DB; indx++)
+		apiLlidPmConfigDb.apiLlidPmConfigAra[indx].in_use = MV_FALSE;
+
+	if (asicOntMiscRegRead(mvAsicReg_PON_MIB_DEFAULT, &apiLlidPmConfigDb.origRxMibDefaultReg, 0) != MV_OK)
+		printk("%s: asicOntMiscRegRead failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+		__func__, mvAsicReg_PON_MIB_DEFAULT);
+}
+
+int onuEponPmLlidPmGetNumUsedEntries(void)
+{
+	int indx;
+	int usedEntries = 0;
+
+	for (indx = 0; indx < MAX_ENTRIES_LLIDPM_CONFIG_DB; indx++)
+		if (apiLlidPmConfigDb.apiLlidPmConfigAra[indx].in_use == MV_TRUE)
+			usedEntries++;
+	return usedEntries;
+}
+
+MV_STATUS onuEponPmLlidPmSetControl(int counter_set, MV_U32 direction, MV_U32 ctrlValue)
+{
+	MV_STATUS rcode = MV_OK;
+	MV_U32 baseControlReg;
+	MV_U32 registersAra[] = {
+		mvAsicReg_PON_MAC_MIB_CONTROL_0, mvAsicReg_PON_MAC_MIB_CONTROL_1, mvAsicReg_PON_MAC_MIB_CONTROL_2,
+		mvAsicReg_PON_MAC_MIB_CONTROL_3, mvAsicReg_PON_MAC_MIB_CONTROL_4, mvAsicReg_PON_MAC_MIB_CONTROL_5,
+		mvAsicReg_PON_MAC_MIB_CONTROL_6, mvAsicReg_PON_MAC_MIB_CONTROL_7, mvAsicReg_PON_MAC_MIB_CONTROL_8,
+		mvAsicReg_PON_MAC_MIB_CONTROL_9, mvAsicReg_PON_MAC_MIB_CONTROL_10, mvAsicReg_PON_MAC_MIB_CONTROL_11,
+		mvAsicReg_PON_MAC_MIB_CONTROL_12, mvAsicReg_PON_MAC_MIB_CONTROL_13,  mvAsicReg_PON_MAC_MIB_CONTROL_14,
+		mvAsicReg_PON_MAC_MIB_CONTROL_15
+	};
+
+	if (counter_set >= sizeof(registersAra) / sizeof(registersAra[0])) {
+		printk("%s: counter_set(%d) is out of range (should be < %d)\n",
+		       __func__, counter_set, sizeof(registersAra) / sizeof(registersAra[0]));
+		return rcode;
+	}
+
+	baseControlReg = registersAra[counter_set];
+	if (direction == LLIDPMDIRECTION_BIDI || direction == LLIDPMDIRECTION_DS) {
+		if ((rcode = asicOntMiscRegWrite(baseControlReg, ctrlValue, ONU_MIB_PM_RX_MIB_Control)) != MV_OK) {
+			printk("%s: asicOntMiscRegWrite failed for counter_set(%d), direction(%d), Rx-offset(%d)\n",
+			       __func__, counter_set, direction, ONU_MIB_PM_RX_MIB_Control);
+			return rcode;
+		}
+	}
+
+	if (direction == LLIDPMDIRECTION_BIDI || direction == LLIDPMDIRECTION_US)
+		if ((rcode = asicOntMiscRegWrite(baseControlReg, ctrlValue, ONU_MIB_PM_TX_MIB_Control)) != MV_OK)
+			printk("%s: asicOntMiscRegWrite failed for counter_set(%d), direction(%d), Tx-offset(%d)\n",
+			       __func__, counter_set, direction, ONU_MIB_PM_TX_MIB_Control);
+	return rcode;
+}
+
+static MV_STATUS onuEponPmLlidTranslation(MV_U16 llid, MV_U32 *translatedLlid)
+{
+	MV_STATUS rcode;
+	MV_U32 regValue;
+
+	if ((rcode = asicOntGlbRegRead(mvAsicReg_EPON_RXP_LLT_LLID_DATA_VALID, &regValue, llid)) == MV_OK) {
+		if (regValue == 1) {
+			if ((rcode = asicOntGlbRegRead(mvAsicReg_EPON_RXP_LLT_LLID_DATA_INDEX, &regValue, llid)) == MV_OK)
+				*translatedLlid = regValue;
+			else
+				printk("%s: asicOntGlbRegRead failed to read mvAsicReg_EPON_RXP_LLT_LLID_DATA_INDEX for llid(%d)\n",
+				__func__, llid);
+		} else {
+			printk("%s: Error - mvAsicReg_EPON_RXP_LLT_LLID_DATA_VALID had valid bit 0 for llid(%d)\n",
+				__func__, llid);
+			rcode = MV_BAD_VALUE;
+		}
+	} else
+		printk("%s: asicOntGlbRegRead failed to read mvAsicReg_EPON_RXP_LLT_LLID_DATA_VALID for llid(%d)\n",
+		       __func__, llid);
+	return rcode;
+}
+
+MV_STATUS onuEponPmLlidPmStart(MV_U16 llid, MV_U32 direction)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiLlidPmConfig    *apiLlidPmConfig;
+	S_apiLlidPmConfig    *tgtApiLlidPmConfig = 0;
+	int freeIndx;
+	MV_U32 mibCtrlValue;
+	MV_U32 translatedLlid;
+
+	for (indx = 0; indx < MAX_SUPPORTED_LLIDS_FOR_PM; indx++) {
+		apiLlidPmConfig = &apiLlidPmConfigDb.apiLlidPmConfigAra[indx];
+		if (apiLlidPmConfig->in_use == MV_TRUE && apiLlidPmConfig->llid == llid) {
+			if (apiLlidPmConfig->direction == direction) {
+				printk("%s: llid(%d), direction(%d) already configured\n",
+					__func__, llid, direction);
+				return MV_ALREADY_EXIST;
+			} else if (apiLlidPmConfig->direction == LLIDPMDIRECTION_BIDI) {
+				printk("%s: llid(%d) bidi PM already configured\n", __func__, llid);
+				return MV_NOT_ALLOWED;
+			} else if (direction == LLIDPMDIRECTION_BIDI) {
+				printk("%s: llid(%d) unidirectional PM already configured\n", __func__, llid);
+				return MV_NOT_ALLOWED;
+			}
+		}
+	}
+
+	for (indx = 0; indx < MAX_SUPPORTED_LLIDS_FOR_PM; indx++) {
+		apiLlidPmConfig = &apiLlidPmConfigDb.apiLlidPmConfigAra[indx];
+		if (apiLlidPmConfig->in_use == MV_FALSE) {
+			tgtApiLlidPmConfig = apiLlidPmConfig;
+			freeIndx           = indx;
+			break;
+		}
+	}
+
+	if (tgtApiLlidPmConfig == 0) {
+		printk("%s: LLID MIB PM table full. llid = %d (start)\n", __func__, llid);
+		return MV_NO_MORE;
+	}
+
+	if (onuEponPmLlidPmGetNumUsedEntries() == 0) {
+		if ((rcode = asicOntMiscRegRead(mvAsicReg_PON_MIB_DEFAULT, &apiLlidPmConfigDb.origRxMibDefaultReg, 0))
+		    != MV_OK) {
+			printk("%s: asicOntMiscRegRead failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+		mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+		if ((rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, mibCtrlValue, 0)) != MV_OK) {
+			printk("%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+	}
+
+	if ((rcode = onuEponPmLlidTranslation(llid, &translatedLlid)) == MV_OK) {
+		mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_VALID_BIT, freeIndx, translatedLlid);
+		if ((rcode = onuEponPmLlidPmSetControl(freeIndx, direction, mibCtrlValue)) != MV_OK)
+			printk("%s: Failed to start LLID MIB PM for llid(%d), direction(%d), counter_set(%d)\n",
+				__func__, llid, direction, freeIndx);
+		else {
+			tgtApiLlidPmConfig->llid        = llid;
+			tgtApiLlidPmConfig->counter_set = freeIndx;
+			tgtApiLlidPmConfig->direction   = direction;
+			tgtApiLlidPmConfig->in_use      = MV_TRUE;
+		}
+	}
+	return rcode;
+}
+
+MV_STATUS  onuEponPmLlidPmStop(MV_U16 llid, MV_U32 direction)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiLlidPmConfig    *apiLlidPmConfig;
+	S_apiLlidPmConfig    *tgtApiLlidPmConfig = 0;
+	MV_U32 mibCtrlValue;
+
+	for (indx = 0; indx < MAX_SUPPORTED_LLIDS_FOR_PM; indx++) {
+		apiLlidPmConfig = &apiLlidPmConfigDb.apiLlidPmConfigAra[indx];
+		if (apiLlidPmConfig->in_use == MV_TRUE && apiLlidPmConfig->llid == llid &&
+		    apiLlidPmConfig->direction == direction) {
+			tgtApiLlidPmConfig = apiLlidPmConfig;
+			break;
+		}
+	}
+
+	if (tgtApiLlidPmConfig == 0) {
+		printk("%s: llid %d, direction(%d) not configured\n", __func__, llid, direction);
+		return MV_NOT_FOUND;
+	}
+
+	mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+	rcode = onuEponPmLlidPmSetControl(indx, direction, mibCtrlValue);
+	if (rcode != MV_OK) {
+		printk("%s: Failed to stop LLID MIB PM for llid(%d), direction(%d), counter_set(%d)\n",
+			__func__, llid, direction, indx);
+		return rcode;
+	} else
+		tgtApiLlidPmConfig->in_use = MV_FALSE;
+
+	if (onuEponPmLlidPmGetNumUsedEntries() == 0) {
+		rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, apiLlidPmConfigDb.origRxMibDefaultReg, 0);
+		if (rcode != MV_OK) {
+			printk("%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+	}
+	return rcode;
+}
+
+MV_STATUS onuEponPmLlidPmReset(void)
+{
+	MV_STATUS rcode;
+	int indx;
+	uint32_t mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+
+	for (indx = 0; indx < MAX_ENTRIES_LLIDPM_CONFIG_DB; indx++) {
+		apiLlidPmConfigDb.apiLlidPmConfigAra[indx].in_use = MV_FALSE;
+		rcode = onuEponPmLlidPmSetControl(indx, LLIDPMDIRECTION_BIDI, mibCtrlValue);
+		if (rcode != MV_OK) {
+			printk("%s: Failed to stop LLID MIB PM for counter_set(%d), bidi\n", __func__, indx);
+			return rcode;
+		}
+	}
+	rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, apiLlidPmConfigDb.origRxMibDefaultReg, 0);
+	if (rcode != MV_OK) {
+		printk("%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+			__func__, mvAsicReg_PON_MIB_DEFAULT);
+		return rcode;
+	}
+	return MV_OK;
+}
+
+MV_STATUS onuEponPmLlidPmGet(S_EponIoctlLlidMibCounters *llidMibCounters)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiLlidPmConfig    *apiLlidPmConfig;
+	S_apiLlidPmConfig    *tgtApiLlidPmConfig = 0;
+	MV_U32 baseCounterReg;
+	MV_U32 lowvalue;
+	MV_U32 hivalue;
+	MV_U32 registersAra[] = {
+		mvAsicReg_PON_MAC_MIB_COUNTERS_0,  mvAsicReg_PON_MAC_MIB_COUNTERS_1,   mvAsicReg_PON_MAC_MIB_COUNTERS_2,    mvAsicReg_PON_MAC_MIB_COUNTERS_3,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_4,  mvAsicReg_PON_MAC_MIB_COUNTERS_5,   mvAsicReg_PON_MAC_MIB_COUNTERS_6,    mvAsicReg_PON_MAC_MIB_COUNTERS_7,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_8,  mvAsicReg_PON_MAC_MIB_COUNTERS_9,   mvAsicReg_PON_MAC_MIB_COUNTERS_10,   mvAsicReg_PON_MAC_MIB_COUNTERS_11,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_12, mvAsicReg_PON_MAC_MIB_COUNTERS_13,  mvAsicReg_PON_MAC_MIB_COUNTERS_14,   mvAsicReg_PON_MAC_MIB_COUNTERS_15,
+	};
+
+	for (indx = 0; indx < MAX_SUPPORTED_LLIDS_FOR_PM; indx++) {
+		apiLlidPmConfig = &apiLlidPmConfigDb.apiLlidPmConfigAra[indx];
+		if (apiLlidPmConfig->in_use == MV_TRUE && apiLlidPmConfig->llid == llidMibCounters->llid &&
+		    apiLlidPmConfig->direction == llidMibCounters->direction) {
+			baseCounterReg = registersAra[apiLlidPmConfig->counter_set];
+			tgtApiLlidPmConfig = apiLlidPmConfig;
+			break;
+		}
+	}
+
+	if (tgtApiLlidPmConfig != 0) {
+		rcode |= asicOntMiscRegRead(baseCounterReg, &lowvalue, ONU_MIB_PM_GoodOctetsReceived_low);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &hivalue,  ONU_MIB_PM_GoodOctetsReceived_high);
+		llidMibCounters->good_octets_received = (uint64_t)hivalue << 32 | lowvalue;
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->bad_octets_received,       ONU_MIB_PM_BadOctetsReceived);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->mac_trans_error,           ONU_MIB_PM_MACTransError);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->good_frames_received,      ONU_MIB_PM_GoodFramesReceived);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->bad_frames_received,       ONU_MIB_PM_BadFramesReceived);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->broadcast_frames_received, ONU_MIB_PM_BroadcastFramesReceived);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->multicast_frames_received, ONU_MIB_PM_MulticastFramesReceived);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_64_octets,          ONU_MIB_PM_Frames64Octets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_65_to_127_octets,   ONU_MIB_PM_Frames65to127Octets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_128_to_255octets,   ONU_MIB_PM_Frames128to255Octets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_256_to_511_octets,  ONU_MIB_PM_Frames256to511Octets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_512_to_1023_octets, ONU_MIB_PM_Frames512to1023Octets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->frames_1024_to_max_octets, ONU_MIB_PM_Frames1024toMaxOctets);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &lowvalue, ONU_MIB_PM_GoodOctetsSent_low);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &hivalue,  ONU_MIB_PM_GoodOctetsSent_high);
+		llidMibCounters->good_octets_sent = (uint64_t)hivalue << 32 | lowvalue;
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->good_frames_sent, ONU_MIB_PM_GoodFramesSent);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->multicast_frames_sent, ONU_MIB_PM_MulticastFramesSent);
+		rcode |= asicOntMiscRegRead(baseCounterReg, &llidMibCounters->broadcast_frames_sent, ONU_MIB_PM_BroadcastFramesSent);
+		if (rcode != MV_OK) {
+			printk("%s: asicOntMiscRegRead failure, rcode(%d), baseCounterReg(%d)\n", __func__, rcode, baseCounterReg);
+			return MV_ERROR;
+		}
+	} else {
+		printk("%s: llid(%d), direction(%d) not configured\n", __func__, llidMibCounters->llid, llidMibCounters->direction);
+		return MV_NOT_FOUND;
+	}
+	return rcode;
+}
+
+MV_STATUS onuEponPmLlidPmConfigGet(MV_U16 dbIdx, S_apiLlidPmConfig *llidPmConfig)
+{
+	memset(llidPmConfig, 0, sizeof(S_apiLlidPmConfig));
+	if (dbIdx >= MAX_SUPPORTED_LLIDS_FOR_PM) {
+		printk("%s: Invalid index = %d\n", __func__, dbIdx);
+		return MV_OUT_OF_RANGE;
+	}
+	if (apiLlidPmConfigDb.apiLlidPmConfigAra[dbIdx].in_use == MV_FALSE)
+		return MV_GET_ERROR;
+	memcpy(llidPmConfig, &apiLlidPmConfigDb.apiLlidPmConfigAra[dbIdx], sizeof(S_apiLlidPmConfig));
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.h
new file mode 100644
index 0000000..775d342
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuPm.h
@@ -0,0 +1,232 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU GPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnuPm.h                                               **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON Alarm and Statistics          **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_PM_H
+#define _ONU_EPON_PM_H
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	TOTAL_MPCP_TX_FRAME_CNT             = 0,
+	TOTAL_MPCP_TX_ERROR_FRAME_CNT       = 1,
+	MAX_EPON_TX_SW_CNT
+} E_EponTxSwCnt;
+
+typedef enum {
+	TOTAL_MPCP_RX_FRAME_CNT             = 0,
+	TOTAL_MPCP_RX_ERROR_FRAME_CNT       = 1,
+	TOTAL_MPCP_REGISTER_ACK_CNT         = 2,
+	TOTAL_MPCP_REGISTER_NACK_CNT        = 3,
+	TOTAL_MPCP_REGISTER_DEREG_FRAME_CNT = 4,
+	TOTAL_MPCP_REGISTER_REREG_FRAME_CNT = 5,
+	MAX_EPON_RX_SW_CNT
+} E_EponRxSwCnt;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 ctrlRegReqFramesCnt;     /* Count number of register request frames transmitted     */
+	MV_U32 ctrlRegAckFramesCnt;     /* Count number of register acknowledge frames transmitted */
+	MV_U32 reportFramesCnt;         /* Count number of report frames transmitted               */
+	MV_U32 dataFramesCnt;           /* Count number of data frames transmitted                 */
+	MV_U32 txAllowedBytesCnt;       /* Count number of Tx Byte Allow counter                   */
+} S_EponTxPm;
+
+typedef struct {
+	MV_U32 fcsErrorFramesCnt;       /* Count number of received frames with FCS errors */
+	MV_U32 shortFramesCnt;          /* Count number of short frames received           */
+	MV_U32 longFramesCnt;           /* Count number of long frames received            */
+	MV_U32 dataFramesCnt;           /* Count number of data frames received            */
+	MV_U32 ctrlFramesCnt;           /* Count number of control frames received         */
+	MV_U32 reportFramesCnt;         /* Count number of report frames received          */
+	MV_U32 gateFramesCnt;           /* Count number of gate frames received            */
+} S_RxPm;
+
+typedef struct {
+	MV_U32 grantValidCnt;                   /* Count number of valid grant                          */
+	MV_U32 grantMaxFutureTimeErrorCnt;      /* Count number of grant max future time error          */
+	MV_U32 minProcTimeErrorCnt;             /* Count number of min proc time error                  */
+	MV_U32 lengthErrorCnt;                  /* Count number of length error                         */
+	MV_U32 discoveryAndRegCnt;              /* Count number of discovery & register                 */
+	MV_U32 fifoFullErrorCnt;                /* Count number of fifo full error                      */
+	MV_U32 opcDiscoveryNotRegBcastCnt;      /* Count number of opc discoveryNotRegBcastCnt          */
+	MV_U32 opcRegisterNotDiscoveryCnt;      /* Count number of opc register not discovery           */
+	MV_U32 opcDiscoveryNotRegNotBcastCnt;   /* Count number of opc discovery not register not bcast */
+	MV_U32 opcDropGrantCnt;                 /* Count number of opc drop grant                       */
+	MV_U32 opcHiddenGrantCnt;               /* Count number of opc hidden grant                     */
+	MV_U32 opcBackToBackCnt;                /* Count number of opc back to back                     */
+} S_GpmPm;
+
+typedef struct {
+	MV_U32 legalFrameCnt;           /* stat0[31:0]	*/
+	MV_U32 maxFrameSizeErrCnt;      /* stat1[31:16]	*/
+	MV_U32 parityLenErrCnt;         /* stat1[15:0]	*/
+	MV_U32 longGateErrCnt;          /* stat2[31:16]	*/
+	MV_U32 protocolErrCnt;          /* stat2[15:0]	*/
+	MV_U32 minFrameSizeErrCnt;      /* stat3[15:0]	*/
+	MV_U32 legalFecFrameCnt;        /* stat4[31:16]	*/
+	MV_U32 legalNonFecFrameCnt;     /* stat4[15:0]	*/
+} S_PcsPm;
+
+typedef struct {
+	MV_U32 swTxCnt[MAX_EPON_TX_SW_CNT];
+	MV_U32 swRxCnt[MAX_EPON_RX_SW_CNT];
+} S_SwPm;
+
+typedef struct {
+	S_RxPm rx;
+	S_EponTxPm tx;
+	S_SwPm sw;
+	S_GpmPm gpm;
+	S_PcsPm pcs;
+} S_EponPm;
+
+// LLID MIB PM
+typedef struct {
+	MV_BOOL in_use;
+	MV_U16 llid;
+	MV_U32 counter_set;
+	MV_U32 direction;
+} S_apiLlidPmConfig;
+
+#define MAX_SUPPORTED_LLIDS_FOR_PM           16
+#define MAX_ENTRIES_LLIDPM_CONFIG_DB         (MAX_SUPPORTED_LLIDS_FOR_PM)
+typedef struct {
+	S_apiLlidPmConfig apiLlidPmConfigAra[MAX_ENTRIES_LLIDPM_CONFIG_DB];
+	MV_U32 origRxMibDefaultReg;
+} S_apiLlidPmConfigDb;
+
+
+MV_STATUS onuEponPmSwCountersUpdate(S_SwPm *swPm, MV_U32 macId);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+void      onuEponPmInit(void);
+void      onuEponPmTimerPmHndl(unsigned long data);
+void      onuEponPmTimerExpireHndl(void);
+MV_STATUS onuEponPmCountersAdd(void);
+MV_STATUS onuEponPmSwRxCountersAdd(MV_U32 cnt, MV_U32 macId);
+MV_STATUS onuEponPmSwTxCountersAdd(MV_U32 cnt, MV_U32 macId);
+MV_STATUS onuEponPmSwPmGet(S_SwPm *swPm, MV_U32 macId);
+MV_STATUS onuEponPmRxPmGet(S_RxPm *rxPm, MV_U32 macId);
+MV_STATUS onuEponPmTxPmGet(S_EponTxPm *txPm, MV_U32 macId);
+MV_STATUS onuEponPmTxDataPmLastIntervalGet(MV_U32 *txDataPm, MV_U32 macId);
+MV_STATUS onuEponPmGpmPmGet(S_GpmPm *gpmPm, MV_U32 macId);
+MV_U32    onuEponPmGpmValidGrantGet(MV_U32 macId);
+MV_STATUS onuEponPmPcsPmGet(S_PcsPm *pcsPm);
+MV_U32    onuEponPmCtrlCntGet(MV_U32 macId);
+MV_U32    onuEponPmTxByteCntGet(MV_U32 macId);
+
+MV_STATUS onuEponPmDbaAddBytePerLlidAndQueue(MV_U32 llId, MV_U32 queueId, MV_U32 counter);
+MV_U32    onuEponPmDbaAddBytePerLlidAndQueueGet(MV_U32 llId, MV_U32 queueId);
+MV_STATUS onuEponPmDbaAddBytePerLlidFifo(MV_U32 llId, MV_U32 counter);
+MV_U32    onuEponPmDbaAddBytePerLlidFifoGet(MV_U32 llId);
+
+MV_STATUS onuEponPmGunitLlidQueueCntGet(MV_U32 llid, MV_U32 queueId, MV_U32 *counter);
+MV_STATUS onuEponPmGunitLlid0PktModMaxHeaderSizeSet(MV_U32 headerSize);
+MV_STATUS onuEponPmGunitLlid0PktModPktCountGet(MV_U32 *packetCount);
+
+MV_STATUS onuEponAlarmSet(MV_U32 alarm, MV_BOOL state);
+void      onuEponAlarmGet(MV_U32 *alarm);
+void      onuEponLosAlarmGet(MV_U32 *alarm);
+
+MV_STATUS onuEponPmGenCrcTable(void);
+MV_U32    onuEponPmGenCrcKey(MV_U32 msg[], MV_U32 size);
+MV_STATUS onuEponPmRandomGet(MV_U32 *random);
+MV_STATUS onuEponPmRandomReset(void);
+MV_STATUS onuEponPmRandomThresholdCheck(MV_U32 *gateFrames, MV_U32 *discNotRegFrames,
+					MV_U32 *regReqframes);
+
+MV_STATUS onuEponPmLlidPmStart(MV_U16 llid, MV_U32 direction);
+MV_STATUS onuEponPmLlidPmStop(MV_U16 llid, MV_U32 direction);
+MV_STATUS onuEponPmLlidPmGet(S_EponIoctlLlidMibCounters *llidMibCounters);
+MV_STATUS onuEponPmLlidPmReset(void);
+void      onuEponPmLlidPmInit(void);
+MV_STATUS onuEponPmLlidPmConfigGet(MV_U16 dbIdx, S_apiLlidPmConfig *llidPmConfig);
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_PM_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuStd.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuStd.h
new file mode 100644
index 0000000..ef6710a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/epon/eponOnuStd.h
@@ -0,0 +1,290 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : eponOnustd.h                                              **/
+/**                                                                          **/
+/**  DESCRIPTION : This file contains ONU EPON standard definitions          **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*
+******************************************************************************/
+#ifndef _ONU_EPON_STD_H
+#define _ONU_EPON_STD_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define MIN_ETH_FRAME_LEN  (256)
+#define MIN_RPRT_FRAME_LEN (64)
+#define MIN_DG_FRAME_LEN   (64)
+#define MAC_ADDR_LEN       (6)
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	MPC_OPCODE_GATE          = 2,
+	MPC_OPCODE_REPORT        = 3,
+	MPC_OPCODE_REGISTER_REQ  = 4,
+	MPC_OPCODE_REGISTER      = 5,
+	MPC_OPCODE_REGISTER_ACK  = 6
+} E_EponMpcOpcode;
+
+typedef enum {
+	REGISTER_FLAGS_REREG     = 1,
+	REGISTER_FLAGS_DEREG     = 2,
+	REGISTER_FLAGS_ACK       = 3,
+	REGISTER_FLAGS_NACK      = 4
+} E_EponMpcRegFlag;
+
+typedef enum {
+	REGISTER_ACK_FLAGS_NACK  = 0,
+	REGISTER_ACK_FLAGS_ACK   = 1
+} E_EponMpcRegAckFlag;
+
+typedef enum {
+	REGISTER_REQ_FLAGS_REG   = 1,
+	REGISTER_REQ_FLAGS_DEREG = 3
+} E_EponMpcRegReqFlag;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+#pragma pack(1)
+typedef struct {
+	MV_U32 length;
+	MV_U8 data[MIN_ETH_FRAME_LEN];
+} S_OnuEponCtrlBuffer;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         General MPC Frame Definitions                      */
+/* ========================================================================== */
+/******************************************************************************/
+#pragma pack(1)
+typedef struct {
+	MV_U8 destAddr[MAC_ADDR_LEN];
+	MV_U8 srcAddr[MAC_ADDR_LEN];
+	MV_U16 etherType;
+} S_OnuEponStdEthFrame;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	MV_U16 opCode;
+	MV_U32 timeStamp;
+} S_OnuEponGenMpcPdu;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponGenMpcPdu genMpcPdu;
+} S_OnuEponGenMpcFrame;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Register MPC Frame Definitions                     */
+/* ========================================================================== */
+/******************************************************************************/
+#pragma pack(1)
+typedef struct {
+	MV_U16 assignedLlidPort;
+	MV_U8 flags;
+	MV_U16 syncTime;
+	MV_U8 echoedPendingGrants;
+} S_OnuEponRegMpcPdu;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponGenMpcPdu genMpcPdu;
+	S_OnuEponRegMpcPdu regMpcPdu;
+} S_OnuEponRegMpcFrame;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Register Ack MPC Frame Definitions                 */
+/* ========================================================================== */
+/******************************************************************************/
+#pragma pack(1)
+typedef struct {
+	MV_U8 flags;
+	MV_U16 echoedAssignedport;
+	MV_U16 echoedSyncTime;
+} S_OnuEponRegAckMpcPdu;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponGenMpcPdu genMpcPdu;
+	S_OnuEponRegAckMpcPdu regAckMpcPdu;
+} S_OnuEponRegAckMpcFrame;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Register Request MPC Frame Definitions             */
+/* ========================================================================== */
+/******************************************************************************/
+#pragma pack(1)
+typedef struct {
+	MV_U8 flags;
+	MV_U8 pendingGrants;
+} S_OnuEponRegReqMpcPdu;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponGenMpcPdu genMpcPdu;
+	S_OnuEponRegReqMpcPdu regReqMpcPdu;
+} S_OnuEponRegReqMpcFrame;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Report MPC Frame Definitions                       */
+/* ========================================================================== */
+/******************************************************************************/
+#pragma pack(1)
+typedef struct {
+	MV_U8 numQueueSets;
+} S_OnuEponReportMpcPduStart;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	MV_U16 queueLength;
+} S_OnuEponReportQueueReport;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	MV_U8 bitMap;
+	S_OnuEponReportQueueReport queueReport;
+} S_OnuEponReportQueueSetStart;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponGenMpcPdu genMpcPdu;
+	S_OnuEponReportMpcPduStart reportMpcPduStart;
+	MV_U8 next;
+} S_OnuEponReportMpcFrame;
+#pragma pack(0)
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                                OAM Frame Definitions                       */
+/* ========================================================================== */
+/******************************************************************************/
+
+#pragma pack(1)
+typedef struct {
+	MV_U8 subType;
+	MV_U16 flags;
+	MV_U8 code;
+} S_OnuEponOamHeader;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponStdEthFrame stdEthFrame;
+	S_OnuEponOamHeader stdOamHeader;
+} S_OnuEponOamFrame;
+#pragma pack(0)
+
+#pragma pack(1)
+typedef struct {
+	S_OnuEponCtrlBuffer msg;
+	MV_U32 macId;
+	MV_U32 valid;
+} S_OnuEponOamMsg;
+#pragma pack(0)
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_STD_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.c
new file mode 100644
index 0000000..dc23860
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.c
@@ -0,0 +1,791 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponCustomerApi.c                                          **
+**                                                                           **
+*******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include <linux/string.h>
+#include "gponCustomerApi.h"
+#include "mvTypes.h"
+#include <linux/types.h>
+#include "mvPonOnuDefines.h"
+#include <linux/cdev.h>
+#include "gponOnuLnxKsMI.h"
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets T-cont configuration.
+**
+**  INPUTS     : unsigned int allocId: Alloc ID.
+**               unsigned int tcontId: T-CONT ID.
+**               unsigned char mode  : The scheduling mode of T-CONT.
+**                                     0 - SP mode.
+**                                     1 - WRR mode.
+**                                     2 - SP+WRR mode.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Parameter mode is out of the scope of GPON module, handled in
+**               PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_tcont(unsigned int allocId, unsigned int tcontId,
+			    unsigned char mode)
+{
+	int ret = 0;
+
+	UNUSED(mode);
+
+	ret = onuGponApiTcontConfig(allocId, tcontId);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes T-cont configuration.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_tcont(unsigned int tcontId)
+{
+	int ret = 0;
+
+	ret = onuGponApiTcontClear(tcontId);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_clr_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all the T-CONT
+**               (Not including the one used for OMCC).
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_clr_tcont(void)
+{
+	int ret = 0;
+
+	ret = onuGponApiTcontsReset();
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_tcont_queue
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets T-CONT queue configuration.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**               unsigned int queueId: Queue ID.
+**               unsigned char mode  : The scheduling mode of queue in T-CONT.
+**                                     0 - SP mode.
+**                                     1 - WRR mode.
+**               unsigned char weight: Weight value under WRR mode.
+**               unsigned char pri   : Priority value under SP mode.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : This API is out of the scope of GPON module, handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_tcont_queue(unsigned int tcontId, unsigned int queueId,
+				  unsigned char mode, unsigned char weight,
+				  unsigned char pri)
+{
+	int ret = 0;
+
+	UNUSED(tcontId);
+	UNUSED(queueId);
+	UNUSED(mode);
+	UNUSED(weight);
+	UNUSED(pri);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ratelimt
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets rate limit of a queue in T-CONT.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**               unsigned int queueId: Queue ID.
+**               unsigned int sir    : SIR, measured by kbps.
+**               unsigned int pir    : PIR, measured by kbps.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : This API is out of the scope of GPON module, handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ratelimt(unsigned int tcontId, unsigned int queueId,
+			       unsigned int sir, unsigned int pir)
+{
+	int ret = 0;
+
+	UNUSED(tcontId);
+	UNUSED(queueId);
+	UNUSED(sir);
+	UNUSED(pir);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_add_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**
+*******************************************************************************/
+int mrvl_api_gpon_add_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem)
+{
+	int ret = 0;
+
+	UNUSED(direction);
+	UNUSED(gemIndex);
+
+	ret = onuGponApiGemPortIdConfig(gem);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gem       : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameter direction.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_gemport(unsigned char direction, unsigned int gem)
+{
+	int ret = 0;
+
+	UNUSED(direction);
+
+	ret = onuGponApiGemPortIdClear(gem);
+
+	return ret;
+}
+
+#if 0
+/*******************************************************************************
+**
+**  mrvl_api_gpon_add_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**               unsigned int allocId   : Alloc-ID.
+**               unsigned int tcontId   : T-CONT ID.
+**               unsigned int queue     : Queue ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**               The parameters allocId, tcontId, queue are handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_add_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem, unsigned int allocId,
+			      unsigned int tcontId, unsigned int queue)
+{
+	int ret = 0;
+
+	UNUSED(direction);
+	UNUSED(gemIndex);
+	UNUSED(allocId);
+	UNUSED(tcontId);
+	UNUSED(queue);
+
+	ret = onuGponApiGemPortIdConfig(gem);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**               unsigned int allocId   : Alloc-ID.
+**               unsigned int tcontId   : T-CONT ID.
+**               unsigned int queue     : Queue ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**               The parameters allocId, tcontId, queue are handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem, unsigned int allocId,
+			      unsigned int tcontId, unsigned int queue)
+{
+	int ret = 0;
+
+	UNUSED(direction);
+	UNUSED(gemIndex);
+	UNUSED(allocId);
+	UNUSED(tcontId);
+	UNUSED(queue);
+
+	/* why can't delete gemport like
+	   mrvl_api_gpon_del_gemport(unsigned char direction, unsigned int gem) */
+
+	return ret;
+}
+
+#endif
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_clr_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all the GEM-PORT IDs on ONU
+**               (not including the one used for OMCC).
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_clr_gemport(void)
+{
+	int ret = 0;
+
+	ret = onuGponApiGemClearAll(onuGponDbGemRestoreGet());
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_sn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets serial number of ONU.
+**
+**  INPUTS     : unsigned char *sn: Serial number.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_sn(unsigned char *sn)
+{
+	int ret = 0;
+
+	ret = onuGponApiSerialNumberSet(sn);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_pwd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets password of ONU.
+**
+**  INPUTS     : unsigned char *pwd: Password.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_pwd(unsigned char *pwd)
+{
+	int ret = 0;
+
+	ret = onuGponApiPasswordSet(pwd);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_gemport_encrypt
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets encrypt function of GEM-PORT.
+**
+**  INPUTS     : unsigned char enable : Enable or disable the encrypt function.
+**               unsigned int gemIndex: The index number of GEM-PORT.
+**               unsigned int gem     : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameter gemIndex.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_gemport_encrypt(unsigned char enable, unsigned int gemIndex,
+				      unsigned int gem)
+{
+	int ret = 0;
+
+	UNUSED(gemIndex);
+
+	ret = onuGponApiGemPortEncryptSet(gem, enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_gemport_adkey
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the encrypt key of GEM-PORT.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char *key: Encrypt key of GEM-PORT.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_gemport_adkey(unsigned char *key)
+{
+	int ret = 0;
+
+	ret = onuGponApiGemPortAdKeyGet(key);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ponsend
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets transmit of PON port.
+**
+**  INPUTS     : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ponsend(unsigned char enable)
+{
+	int ret = 0;
+
+	if (enable == 0)
+		ret = onuGponApiOpticalTxEnableSet(MV_FALSE);
+	else if (enable == 1)
+		ret = onuGponApiOpticalTxEnableSet(MV_TRUE);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ponrcv
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets receive of PON port.
+**
+**  INPUTS     : unsigned char enable: Enable or disable receive of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ponrcv(unsigned char enable)
+{
+	int ret = 0;
+
+	if (enable == 0)
+		ret = onuGponApiOpticalRxEnableSet(MV_FALSE);
+	else if (enable == 1)
+		ret = onuGponApiOpticalRxEnableSet(MV_TRUE);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_sfsd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the threshold value of SF and SD.
+**
+**  INPUTS     : unsigned char sf: The threshold of SF.
+**               unsigned char sd: The threshold of SD.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_sfsd(unsigned char sf, unsigned char sd)
+{
+	int ret = 0;
+
+	ret = onuGponApiSfSdThresholdSet(sf, sd);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_longlaser
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets long laser enable or disable.
+**
+**  INPUTS     : unsigned char enable: Enable or disable long laser.
+**                                     0 - Disable long laser.
+**                                     1 - Enable long laser.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_longlaser(unsigned char enable)
+{
+	int ret = 0;
+
+	if (enable == 1) {
+		ret = onuGponApiPattenBurstSet(0x80, 1, 2000, 4000);
+		onuGponDbOnuLongLaserSet(MV_TRUE);
+	} else if (enable == 0) {
+		ret = onuPonPatternBurstOff();
+		onuGponDbOnuLongLaserSet(MV_FALSE);
+	}
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_longlaser
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets long laser status.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char enable: Enable or disable long laser.
+**                                     0 - Disable long laser.
+**                                     1 - Enable long laser.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_longlaser(unsigned char *enable)
+{
+	int ret = 0;
+
+	onuGponDbOnuLongLaserGet(enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_o7state
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets O7 status of ONU.
+**
+**  INPUTS     : unsigned char enable: Enable or disable O7 status.
+**                                     0 - Disable O7 status, ONU can register.
+**                                     1 - Enable O7 status, ONU stays in
+**                                         O7 status without trsnsition.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_o7state(unsigned char enable)
+{
+	int ret = 0;
+
+	ret = onuGponApiO7StateEnableSet(enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_opstate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the register status of ONU.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char *state: The status of ONU.
+**                                     1~7 - O1~O7.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_opstate(unsigned char *state)
+{
+	int ret = 0;
+
+	ret = onuGponApiOperationStateGet(state);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_gemport_stat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of GEM-PORT.
+**
+**  INPUTS     : unsigned int gem: GEM-PORT ID.
+**
+**  OUTPUTS    : ZTE_GEM_STAT *stat: The statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_gemport_stat(unsigned int gem, MRVL_GEM_STAT *stat)
+{
+	int ret = 0;
+	S_GponIoctlGemPortMibCounters gemMibCounters;
+
+	memset(&gemMibCounters, 0, sizeof(S_GponIoctlGemPortMibCounters));
+
+	gemMibCounters.gem_port  = gem;
+	gemMibCounters.direction = GEMPORTPMDIRECTION_BIDI;
+	onuGponApiGemPortPmGet(&gemMibCounters);
+	stat->tranframes = gemMibCounters.good_frames_sent;
+	stat->rcvframes  = gemMibCounters.good_frames_received;
+	stat->tranoctets = gemMibCounters.good_octets_sent;
+	stat->rcvoctets  = gemMibCounters.good_octets_received;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_fec_stat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of FEC.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MRVL_FEC_STAT *stat: The statistic information of FEC.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_fec_stat(MRVL_FEC_STAT *stat)
+{
+	int ret = 0;
+	S_GponIoctlFecPm fecPm;
+
+	ret = onuGponApiPmFecPmGet(&fecPm, MV_TRUE);
+
+	stat->crtbytes = fecPm.correctedBytes;
+	/*stat->crtcodewords = fecPm->receivedCodeWords;*/
+	/*stat->fecseconds =*/
+	stat->totalcodewords = fecPm.receivedCodeWords;
+	stat->uncrtcodewords = fecPm.uncorrectedCodeWords;
+
+	return ret;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.h
new file mode 100644
index 0000000..58b4b81
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponCustomerApi.h
@@ -0,0 +1,589 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponCustomerApi.h                                          **
+**                                                                           **
+*******************************************************************************/
+#ifndef GPON_CUSTOMER_API_H
+#define GPON_CUSTOMER_API_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/* Macro Definition
+   ------------------------------------------------------------------------------*/
+#define UNUSED(x)
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	unsigned long long tranframes;  /* Then number of transited frames */
+	unsigned long long rcvframes;   /* Then number of received frames */
+	unsigned long long tranoctets;  /* Then number of transited bytes */
+	unsigned long long rcvoctets;   /* Then number of received bytes */
+} MRVL_GEM_STAT;
+
+typedef struct {
+	unsigned long long crtbytes;            /* The number of correct bytes */
+	unsigned long long crtcodewords;        /* The number of correct code words */
+	unsigned long long uncrtcodewords;      /* The number of uncorrect code words */
+	unsigned long long totalcodewords;      /* The number of total code words */
+	unsigned long long fecseconds;
+} MRVL_FEC_STAT;
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets T-cont configuration.
+**
+**  INPUTS     : unsigned int allocId: Alloc ID.
+**               unsigned int tcontId: T-CONT ID.
+**               unsigned char mode  : The scheduling mode of T-CONT.
+**                                     0 - SP mode.
+**                                     1 - WRR mode.
+**                                     2 - SP+WRR mode.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Parameter mode is out of the scope of GPON module, handled in
+**               PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_tcont(unsigned int allocId, unsigned int tcontId,
+			    unsigned char mode);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes T-cont configuration.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_tcont(unsigned int tcontId);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_clr_tcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all the T-CONT
+**               (Not including the one used for OMCC).
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_clr_tcont(void);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_tcont_queue
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets T-CONT queue configuration.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**               unsigned int queueId: Queue ID.
+**               unsigned char mode  : The scheduling mode of queue in T-CONT.
+**                                     0 - SP mode.
+**                                     1 - WRR mode.
+**               unsigned char weight: Weight value under WRR mode.
+**               unsigned char pri   : Priority value under SP mode.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : This API is out of the scope of GPON module, handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_tcont_queue(unsigned int tcontId, unsigned int queueId,
+				  unsigned char mode, unsigned char weight,
+				  unsigned char pri);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ratelimt
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets rate limit of a queue in T-CONT.
+**
+**  INPUTS     : unsigned int tcontId: T-CONT ID.
+**               unsigned int queueId: Queue ID.
+**               unsigned int sir    : SIR, measured by kbps.
+**               unsigned int pir    : PIR, measured by kbps.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : This API is out of the scope of GPON module, handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ratelimt(unsigned int tcontId, unsigned int queueId,
+			       unsigned int sir, unsigned int pir);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_add_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**
+*******************************************************************************/
+int mrvl_api_gpon_add_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gem       : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameter direction.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_gemport(unsigned char direction, unsigned int gem);
+
+#if 0
+/*******************************************************************************
+**
+**  mrvl_api_gpon_add_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**               unsigned int allocId   : Alloc-ID.
+**               unsigned int tcontId   : T-CONT ID.
+**               unsigned int queue     : Queue ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**               The parameters allocId, tcontId, queue are handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_add_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem, unsigned int allocId,
+			      unsigned int tcontId, unsigned int queue);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_del_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes a GEM-PORT ID on ONU.
+**
+**  INPUTS     : unsigned char direction: Direction of GEM flow.
+**                                        0 - For upstream.
+**                                        1 - For downstream.
+**                                        2 - For upstream and downstream.
+**               unsigned int gemIndex  : The index number of GEM-PORT ID.
+**               unsigned int gem       : GEM-PORT ID.
+**               unsigned int allocId   : Alloc-ID.
+**               unsigned int tcontId   : T-CONT ID.
+**               unsigned int queue     : Queue ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameters direction and gemIndex.
+**               The parameters allocId, tcontId, queue are handled in PPv2.
+**
+*******************************************************************************/
+int mrvl_api_gpon_del_gemport(unsigned char direction, unsigned int gemIndex,
+			      unsigned int gem, unsigned int allocId,
+			      unsigned int tcontId, unsigned int queue);
+#endif
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_clr_gemport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all the GEM-PORT IDs on ONU
+**               (not including the one used for OMCC).
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_clr_gemport(void);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_sn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets serial number of ONU.
+**
+**  INPUTS     : unsigned char *sn: Serial number.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_sn(unsigned char *sn);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_pwd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets password of ONU.
+**
+**  INPUTS     : unsigned char *pwd: Password.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_pwd(unsigned char *pwd);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_gemport_encrypt
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets encrypt function of GEM-PORT.
+**
+**  INPUTS     : unsigned char enable : Enable or disable the encrypt function.
+**               unsigned int gemIndex: The index number of GEM-PORT.
+**               unsigned int gem     : GEM-PORT ID.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+**  NOTE       : Not support parameter gemIndex.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_gemport_encrypt(unsigned char enable, unsigned int gemIndex,
+				      unsigned int gem);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_gemport_adkey
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the encrypt key of GEM-PORT.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char *key: Encrypt key of GEM-PORT.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_gemport_adkey(unsigned char *key);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ponsend
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets transmit of PON port.
+**
+**  INPUTS     : unsigned char enable: Enable or disable transmit of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ponsend(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_ponrcv
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets receive of PON port.
+**
+**  INPUTS     : unsigned char enable: Enable or disable receive of PON port.
+**                                     0 - Disable transmit.
+**                                     1 - Enable transmit.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_ponrcv(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_sfsd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the threshold value of SF and SD.
+**
+**  INPUTS     : unsigned char sf: The threshold of SF.
+**               unsigned char sd: The threshold of SD.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_sfsd(unsigned char sf, unsigned char sd);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_longlaser
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets long laser enable or disable.
+**
+**  INPUTS     : unsigned char enable: Enable or disable long laser.
+**                                     0 - Disable long laser.
+**                                     1 - Enable long laser.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_longlaser(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_longlaser
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets long laser status.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char enable: Enable or disable long laser.
+**                                     0 - Disable long laser.
+**                                     1 - Enable long laser.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_longlaser(unsigned char *enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_set_o7state
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets O7 status of ONU.
+**
+**  INPUTS     : unsigned char enable: Enable or disable O7 status.
+**                                     0 - Disable O7 status, ONU can register.
+**                                     1 - Enable O7 status, ONU stays in
+**                                         O7 status without trsnsition.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_set_o7state(unsigned char enable);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_opstate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the register status of ONU.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : unsigned char *state: The status of ONU.
+**                                     1~7 - O1~O7.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_opstate(unsigned char *state);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_gemport_stat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of GEM-PORT.
+**
+**  INPUTS     : unsigned int gem: GEM-PORT ID.
+**
+**  OUTPUTS    : ZTE_GEM_STAT *stat: The statistic information.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_gemport_stat(unsigned int gem, MRVL_GEM_STAT *stat);
+
+/*******************************************************************************
+**
+**  mrvl_api_gpon_get_fec_stat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets statistic information of FEC.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MRVL_FEC_STAT *stat: The statistic information of FEC.
+**
+**  RETURNS    : 0     - No error.
+**               Not 0 - Error code.
+**
+*******************************************************************************/
+int mrvl_api_gpon_get_fec_stat(MRVL_FEC_STAT *stat);
+
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.c
new file mode 100644
index 0000000..3efa0c3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.c
@@ -0,0 +1,1027 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuAlloc.c                                             **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON BW Allocation Table          **
+**                                                                           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuAlloc.c"
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 onuIdleAllocTcont = PON_ONU_IDLE_ALLOC_TCONT;
+
+/*
+** ALLOC ID & T-CONT Handling
+** ==========================
+** Three tables to used to handle Alloc-Id and T-Cont management
+**
+** Software tables:
+** ==> Alloc Id table           - contains all Alloc Id configured by the OLT
+** ==> Idle Alloc Id table      - contains all configured Alloc not connected to HW
+** ==> T-Cont table             - contains the XC between configured Alloc Id and T-Cont
+**
+** Hanrdware table
+** ==> BW Map table             - contains the hardware configuration of the GMAC
+**
+** Rules
+** =====
+** 1. Default Alloc Id == ONU ID, is set to default T-Cont and can not be changed
+** 2. Configure T-cont is only valid for a pre-defined Alloc Id which is not used
+*/
+
+MV_BOOL sendNotifyToMng = MV_FALSE;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                     SoC BW MAP Table Access Operations                     */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init Rx Bw Map
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacInit(void)
+{
+	MV_U32 iEntry;
+	MV_STATUS status = MV_OK;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++)
+		status |= mvOnuGponMacRxBwMapSet(iEntry, 0, GPON_BW_MAP_IDLE_TCONT, MV_FALSE);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacAllocExistCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function checks if allocId is configured to T-Cont and
+**               returns T-Cont entry index in the BW MAP table
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *entry
+**
+**  OUTPUTS:     MV_U32 *entry
+**
+**  RETURNS:     MV_TRUE or MV_FALSE
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacAllocExistCheck(MV_U32 allocId, MV_U32 *entry, MV_U32 *tcont)
+{
+	MV_U32 iEntry;
+	MV_U32 macAllocId;
+	MV_U32 tcontNum;
+	MV_BOOL valid;
+	MV_STATUS status;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		status = mvOnuGponMacRxBwMapGet(iEntry, &macAllocId, &valid, &tcontNum);
+		if ((status == MV_OK) && (macAllocId == allocId) && (valid == MV_TRUE)) {
+			*entry = iEntry;
+			*tcont = tcontNum;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacAllocCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function checks if BW Map entry is valid and return T-Cont
+**               and Alloc Number
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     MV_U32 *allocId
+**               MV_U32 *tcont
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacAllocCheck(MV_U32 index, MV_U32 *allocId, MV_U32 *tcont)
+{
+	MV_U32 macAllocId;
+	MV_U32 tcontNum;
+	MV_BOOL valid;
+	MV_STATUS status;
+
+	status = mvOnuGponMacRxBwMapGet(index, &macAllocId, &valid, &tcontNum);
+	if ((status == MV_OK) && (valid == MV_TRUE)) {
+		*allocId = macAllocId;
+		*tcont   = tcontNum;
+		return MV_OK;
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacAllocFreeEntryGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns free T-Cont entry in the BW MAP table
+**
+**  PARAMETERS:  MV_U32 *entry
+**
+**  OUTPUTS:     MV_U32 *entry
+**
+**  RETURNS:     MV_TRUE or MV_FALSE
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacAllocFreeEntryGet(MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 macAllocId;
+	MV_U32 tcontNum;
+	MV_BOOL valid;
+	MV_STATUS status;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		status = mvOnuGponMacRxBwMapGet(iEntry, &macAllocId, &valid, &tcontNum);
+		if ((status == MV_OK) && (valid == MV_FALSE)) {
+			*entry = iEntry;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds an entry to the BW MAP table
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 tcontId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacAdd(MV_U32 allocId, MV_U32 tcontId)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 entry;
+
+	status = onuGponAllocIdMacAllocFreeEntryGet(&entry);
+	if (status != MV_OK)
+		return MV_ERROR;
+
+	status = mvOnuGponMacRxBwMapSet(entry, allocId, tcontId, MV_TRUE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponAllocIdMacAdd, failed to add alloc Id(%d) entry(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, entry);
+		return status;
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacConnect
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function connect Alloc-Id to  T-Cont
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 tcontnum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacConnect(MV_U32 allocId, MV_U32 tcontNum)
+{
+	MV_STATUS status;
+	MV_U32 entry;
+	MV_U32 tcont;
+	MV_U32 newIdleTcontEntry;
+	MV_U32 freeTcontEntry;
+	MV_U32 entryAllocId;
+	MV_U32 bwMapEntry;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) AllocIdMacConnect, AllocId(%d), Tcont(%d)\n",
+		   __FILE_DESC__, __LINE__, allocId, tcontNum);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* validate that requested alloc-Id is configured in HW and is valid */
+	status = onuGponAllocIdMacAllocExistCheck(allocId, &entry, &tcont);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponAllocIdMacConnect, alloc Id(%d) entry(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, entry);
+		return MV_ERROR;
+	}
+
+	if (tcontNum == onuIdleAllocTcont) {
+		/* If the input T-Cont is the T-Cont used as an Idle T-Cont, all alloc-Id connected to the T-Cont
+		** should be changed to another Idle T-Cont */
+
+		/* Check for a free (idle) entry in the Tcont DB table */
+		status = onuGponDbBwTcontFreeGet(allocId, &freeTcontEntry);
+		if (status != MV_OK) {
+#ifdef MV_GPON_DEBUG_PRINT
+			mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+				   "DEBUG: (%s:%d) onuGponAllocIdMacConnect, alloc Id(%d) freeTcontEntry(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, freeTcontEntry);
+#endif                  /* MV_GPON_DEBUG_PRINT */
+		} else {
+			/* new idle Tcont entry allocated, update it globally */
+			onuIdleAllocTcont = freeTcontEntry;
+
+			/* scan all T-Cont / Alloc-Id in DB and update each HW Idle Alloc-Id to the new Idle T-Cont */
+			for (newIdleTcontEntry = 0 ; newIdleTcontEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; newIdleTcontEntry++) {
+				/* find the idle Alloc ID for this Tcont entry in DB */
+				onuGponDbBwIdleAllocGet(newIdleTcontEntry, &entryAllocId);
+				if (entryAllocId != PON_ONU_ALLOC_NOT_EXIST) {
+					/* Check if this idle Alloc ID exists in the HW table */
+					status = onuGponAllocIdMacAllocExistCheck(entryAllocId, &bwMapEntry, &tcont);
+					if (status == MV_OK) {
+						/* re-assign this Alloc ID to the new idle Tcont in HW */
+						status = mvOnuGponMacRxBwMapSet(bwMapEntry, entryAllocId, onuIdleAllocTcont, MV_TRUE);
+						if (status != MV_OK) {
+							mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+								   "ERROR: (%s:%d) onuGponAllocIdMacConnect, Faild to re-ssign alloc Id(%d) "
+								   "to idle Tcont(%d)%d\n",
+								   __FILE_DESC__, __LINE__, entryAllocId, onuIdleAllocTcont);
+						}
+					} else {
+						/* Gewalt! DB and HW are not in sync! */
+						mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+							   "ERROR: (%s:%d) onuGponAllocIdMacConnect, alloc Id(%d) is not in sync!\n",
+							   __FILE_DESC__, __LINE__, allocId);
+					}
+				} /* entryAllocId != PON_ONU_ALLOC_NOT_EXIST */
+			}
+		}
+		/* There is a free entry in Tcont table */
+	} /* tcontNum == onuIdleAllocTcont */
+
+	/* update input Alloc-Id and T-Cont in the HW */
+	status = mvOnuGponMacRxBwMapSet(entry, allocId, tcontNum, MV_TRUE);
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) TCONT (%d) active, Connect\n",
+		   __FILE_DESC__, __LINE__, tcontNum);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponWqTcontActivate(tcontNum);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacReconnect
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reconnect alloc-Id to idle tcont
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 tcontNum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacReconnect(MV_U32 allocId, MV_U32 tcontNum)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 entry;
+	MV_U32 onuId;
+	MV_U32 tcont;
+	MV_U32 tcontFreeNum;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) AllocIdMacReconnect, AllocId(%d), Tcont(%d)\n",
+		   __FILE_DESC__, __LINE__, allocId, tcontNum);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Get free entry */
+	status = onuGponAllocIdMacAllocExistCheck(allocId, &entry, &tcont);
+	if (status == MV_OK)
+		return status;
+
+	status = onuGponDbBwTcontFreeGet(allocId, &tcontFreeNum);
+	if (status != MV_OK)
+		onuIdleAllocTcont = tcontFreeNum;
+
+	/* Check if default Alloc Id */
+	onuId = onuGponDbOnuIdGet();
+	if (allocId != onuId) {
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) AllocIdMacReconnect, tpm_deactive_tcont, Tcont(%d)\n",
+			   __FILE_DESC__, __LINE__, tcontNum);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		/* Set Alloc Id to T-Cont in the GMAC hardware */
+		status = mvOnuGponMacRxBwMapSet(entry, allocId, onuIdleAllocTcont, MV_TRUE);
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacReActivate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reactivate onu tcont incase the tcont is not
+**               clear and set by mng
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacReActivate(void)
+{
+	MV_STATUS status;
+	MV_U32 entry;
+	MV_U32 allocId;
+	MV_U32 tcont;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) onuGponAllocIdMacReActivate\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	for (entry = 0; entry < ONU_GPON_MAX_NUM_OF_T_CONTS; entry++) {
+		status = onuGponAllocIdMacAllocCheck(entry, &allocId, &tcont);
+		if (status == MV_OK) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+				   "DEBUG: (%s:%d) TCONT (%d) active, Connect\n",
+				   __FILE_DESC__, __LINE__, tcont);
+
+			onuGponWqTcontActivate(tcont);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdMacDisconnect
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function disconnect alloc-Id from tcont
+**
+**  PARAMETERS:  MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdMacDisconnect(MV_U32 allocId)
+{
+	MV_U32 onuId;
+	MV_U32 entry;
+	MV_U32 tcont;
+	MV_STATUS status = MV_OK;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) AllocIdMacDisconnect, AllocId(%d)\n",
+		   __FILE_DESC__, __LINE__, allocId);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Check if already exist */
+	status = onuGponAllocIdMacAllocExistCheck(allocId, &entry, &tcont);
+	if (status != MV_OK)
+		return MV_ERROR;
+
+	/* Check if default Alloc Id */
+	onuId = onuGponDbOnuIdGet();
+	if (allocId != onuId) {
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) TCONT (%d) flush, Disconnect\n",
+			   __FILE_DESC__, __LINE__, tcont);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		onuGponWqTcontFlush(tcont);
+
+		status = mvOnuGponMacRxBwMapSet(entry, 0, 0, MV_FALSE);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdMacDisconnect, failed to disconnect  Alloc Id(%d), T-Cont(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, tcont);
+		}
+	}
+
+	return status;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                                    APIs                                    */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponAllocIdInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init Tconts Bitmap
+**
+**  PARAMETERS:  MV_U32 existTcontsBitmap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdInit(MV_U32 existTcontsBitmap)
+{
+	MV_U32 iEntry;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) Tconts Bitmap(0x%x)\n", __FILE_DESC__, __LINE__, existTcontsBitmap);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		/* Check if T-CONT Exist */
+		if ((existTcontsBitmap >> iEntry) & 0x01)
+			onuGponDbBwTcontSet(iEntry, MV_TRUE, PON_ONU_ALLOC_NOT_EXIST, MV_FALSE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdAssign
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Assign Alloc ID
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 notifyFlag
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdAssign(MV_U32 allocId, MV_U32 notifyFlag)
+{
+	MV_STATUS status;
+	MV_U32 entry;
+	MV_U32 idleEntry;
+	MV_U32 onuId;
+	MV_BOOL allocIdExist;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) Alloc ID Assign, alloc Id(%d)\n", __FILE_DESC__, __LINE__, allocId);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* check if Alloc-Id exist in the alloc Id DB table */
+	allocIdExist = onuGponDbBwAllocExist(allocId);
+	if (allocIdExist == MV_TRUE)
+		return MV_NO_CHANGE /*MV_OK*/;
+
+	/* set the Alloc-Id exist to the database */
+	status = onuGponDbBwAllocInsert(allocId, &entry);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponDbBwAllocInsert, alloc Id(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+		return status;
+	}
+
+	onuId = onuGponDbOnuIdGet();
+
+	/* Default AllocId */
+	/* =============== */
+	/* configured in the T-Cont table and BW MAP */
+	if (allocId == onuId) {
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc ID Assign, default alloc Id(%d) set to T-Cont 0(def)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		/* Set default Alloc Id to T-Cont table */
+		status = onuGponDbBwTcontAlloc(PON_ONU_DEFAULT_ALLOC_TCONT, allocId);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) tcont to alloc set failed, tcont (%d) alloc Id(%d)\n",
+				   __FILE_DESC__, __LINE__, PON_ONU_DEFAULT_ALLOC_TCONT, allocId);
+			return MV_ERROR;
+		}
+
+		sendNotifyToMng = MV_TRUE;
+
+	} else {
+		/* Data AllocId  */
+		/* ============= */
+		/* Configured in the Idle Alloc table and BW MAP */
+		/* set the Alloc-Id exist to the database */
+		status = onuGponDbBwIdleAllocInsert(allocId, &idleEntry);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponDbBwIdleAllocInsert, alloc Id(%d))\n",
+				   __FILE_DESC__, __LINE__, allocId);
+			return status;
+		}
+
+		/* set the Alloc-Id exist to the BW table in the MAC (hardware) */
+		status = onuGponAllocIdMacAdd(allocId, onuIdleAllocTcont);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdMacAdd, alloc Id(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId);
+			return status;
+		}
+
+		sendNotifyToMng = MV_TRUE;
+	}
+
+	if ((sendNotifyToMng == MV_TRUE) && (notifyFlag != 0))
+		/* Send Status Notification to upper layer */
+		onuGponSrvcStatusNotify(GPON_ONU_STATUS_RANGED);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdDeAssign
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function De-Assign Alloc ID
+**
+**  PARAMETERS:  MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdDeAssign(MV_U32 allocId)
+{
+	MV_STATUS status;
+	MV_U32 entry;
+	MV_U32 tcontNum;
+	MV_BOOL allocIdExist;
+	MV_BOOL valid;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) De-Assign Alloc ID, alloc Id(%d)\n", __FILE_DESC__, __LINE__, allocId);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Check if Alloc-Id exist in the database alloc Id, if not exist */
+	allocIdExist = onuGponDbBwAllocExist(allocId);
+	if (allocIdExist == MV_FALSE)
+		return MV_OK;
+
+	/* Delete the Alloc Id from the BW MAP table (if it is not the default T-Cont) */
+	status = onuGponAllocIdMacDisconnect(allocId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponAllocIdMacDisconnect, alloc Id(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+		return status;
+	}
+
+	/* check if Alloc-Id is connected Data T-Cont */
+	status = onuGponDbBwTcontConnectCheck(allocId, &tcontNum, &valid);
+	if ((status == MV_OK) && (valid == MV_TRUE))
+		/* Delete Alloc ID from the Alloc Id / T-Cont table in the database */
+		onuGponDbBwTcontClear(tcontNum);
+
+	/* check if Alloc-Id is Idle Alloc-Id */
+	if (onuGponDbBwIdleAllocExist(allocId, &entry) == MV_TRUE) {
+		/* Delete Alloc ID from the Idle Alloc Id table */
+		status = onuGponDbBwIdleAllocRemove(allocId, &entry);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponDbBwIdleAllocRemove, alloc Id(%d) entry(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, entry);
+			return status;
+		}
+	}
+
+	/* Delete Alloc Id from the Alloc Id table in the database */
+	status = onuGponDbBwAllocRemove(allocId, &entry);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponDbBwAllocRemove, alloc Id(%d) entry(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, entry);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdFreeAllBuffers
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release all buffers assigned to All Alloc IDs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdFreeAllBuffers(void)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 tcontNum = 0xFF;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) FreeAllBuffers\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponWqTcontFlush(tcontNum);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdDeAssignAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function De-Assign All Alloc IDs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdDeAssignAll(void)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) De-Assign All Alloc IDs and T-Conts\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponDbBwAllocInit();
+	onuGponAllocIdMacInit();
+	onuGponAllocIdInit(0xFFFF);
+
+	sendNotifyToMng = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdTcontSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Set Alloc ID to T-CONT
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 tcontnum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdTcontSet(MV_U32 allocId, MV_U32 tcontNum)
+{
+	MV_STATUS status;
+	MV_U32 otherTcontNum;
+	MV_U32 dbAllocId;
+	MV_U32 entry;
+	MV_BOOL valid;
+	MV_BOOL exist;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) Set Alloc ID to T-CONT, alloc Id(%d) tcont(%d)\n",
+		   __FILE_DESC__, __LINE__, allocId, tcontNum);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Check if Alloc Id was assigned by the OLT */
+	exist = onuGponDbBwAllocExist(allocId);
+	if (exist == MV_FALSE) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) Alloc ID Not Exist, alloc Id(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, tcontNum);
+		return MV_OK;
+	}
+
+	/* Check if T-CONT Exist - all 8 tconts are set to exist during onuGponAllocIdInit function */
+	status = onuGponDbBwTcontExist(tcontNum, &exist);
+	if ((status != MV_OK) || (exist == MV_FALSE)) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) Tcont Not Exist, alloc Id(%d) tcont(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, tcontNum);
+		return MV_ERROR;
+	}
+
+	/* Check that Alloc Id is not exist on other T-CONT */
+	status = onuGponDbBwTcontConnectCheck(allocId, &otherTcontNum, &valid);
+	if ((status == MV_OK) && (valid == MV_TRUE)) {
+		if (otherTcontNum == tcontNum) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) Alloc Id/T-CONT Already Configured, alloc Id(%d) tcont(%d) otherTcontNum(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, tcontNum, otherTcontNum);
+			return MV_OK;
+
+		} else {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) Alloc Id Already Exist on T-CONT, alloc Id(%d) tcont(%d) otherTcontNum(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, tcontNum, otherTcontNum);
+			return MV_ERROR;
+		}
+	}
+
+	/* Check that the T-CONT is valid */
+	onuGponDbBwTcontGet(tcontNum, &exist, &dbAllocId, &valid);
+	if (valid == MV_TRUE) {
+		if (dbAllocId != PON_ONU_ALLOC_NOT_EXIST) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) Alloc Id/T-CONT Already Configured, alloc Id(%d) tcont(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, tcontNum);
+			return MV_OK;
+		}
+	}
+
+	/* configure Alloc Id / T-Cont table */
+	status = onuGponDbBwTcontAlloc(tcontNum, allocId);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponDbBwTcontAlloc, alloc Id(%d) tcont(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, tcontNum);
+		return MV_ERROR;
+	}
+
+	/* remove Alloc Id from Idle Alloc table */
+	status = onuGponDbBwIdleAllocRemove(allocId, &entry);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponDbBwIdleAllocRemove, alloc Id(%d) entry(%d) removed from Idle table\n",
+			   __FILE_DESC__, __LINE__, allocId, entry);
+		return MV_ERROR;
+	}
+
+	/* set Alloc Id to T-Cont in the GMAC hardware */
+	status = onuGponAllocIdMacConnect(allocId, tcontNum);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) onuGponAllocIdMacConnect, alloc Id(%d) tcont(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, tcontNum);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdTcontClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Clear Alloc ID from T-CONT
+**
+**  PARAMETERS:  MV_U32 tcontnum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdTcontClear(MV_U32 tcontNum)
+{
+	MV_STATUS status;
+	MV_U32 allocId;
+	MV_U32 onuId;
+	MV_U32 idleEntry;
+	MV_BOOL valid;
+	MV_BOOL exist;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "   DEBUG: (%s:%d) Clear Alloc ID from T-CONT: T-CONT(%d)\n",
+		   __FILE_DESC__, __LINE__, tcontNum);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Check if T-CONT Exist */
+	status = onuGponDbBwTcontExist(tcontNum, &exist);
+	if ((status != MV_OK) || (exist == MV_FALSE)) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+			   "ERROR: (%s:%d) T-CONT Not Exist, tcont(%d)\n",
+			   __FILE_DESC__, __LINE__, tcontNum);
+		return MV_ERROR;
+	}
+
+	/* Get tcont params from the database */
+	onuGponDbBwTcontGet(tcontNum, &exist, &allocId, &valid);
+	if (valid == MV_FALSE)
+		return MV_OK;
+
+	/* Check if Alloc Id Exist */
+	exist = onuGponDbBwAllocExist(allocId);
+	if (exist == MV_TRUE) {
+		/* Clear T-Cont in hardware in case T-Cont is not connected to default Alloc-Id (== ONU ID) */
+		status = onuGponAllocIdMacReconnect(allocId, tcontNum);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdMacReconnect, alloc Id(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId);
+			return MV_ERROR;
+		}
+	}
+
+	/* Clear T-Cont in the database */
+	onuId = onuGponDbOnuIdGet();
+	if (allocId != onuId) {
+		onuGponDbBwTcontClear(tcontNum);
+
+		/* set the Alloc-Id exist to the idle alloc-Id */
+		status = onuGponDbBwIdleAllocInsert(allocId, &idleEntry);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ALLOC_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdTcontClear, idle alloc Id(%d) entry(%d)\n",
+				   __FILE_DESC__, __LINE__, allocId, idleEntry);
+			return status;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAllocIdTcontClearAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Clear All Alloc-Ids from T-TCONTs
+**
+**  PARAMETERS:  MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAllocIdTcontClearAll(void)
+{
+	MV_U32 iEntry;
+	MV_BOOL exist;
+	MV_STATUS status = MV_OK;
+	MV_U32 tcontNum = 0xFF;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_ALLOC_MODULE,
+		   "DEBUG: (%s:%d) TCONT flush, Clear All\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		/* Check if T-CONT Exist */
+		status = onuGponDbBwTcontExist(iEntry, &exist);
+		if ((status == MV_OK) && (exist == MV_TRUE))
+			onuGponAllocIdTcontClear(iEntry);
+	}
+
+	onuGponWqTcontFlush(tcontNum);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIdleAllocIdTcontGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return Idle Alloc-Id
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 allocId
+**
+*******************************************************************************/
+MV_U32 onuGponIdleAllocIdTcontGet(void)
+{
+	return onuIdleAllocTcont;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.h
new file mode 100644
index 0000000..ad2737e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlloc.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuAlloc.h                                             **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON BW Allocation Table            **
+**                prototypes                                                 **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef ONU_GPON_ALLOC_H
+#define ONU_GPON_ALLOC_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define PON_ONU_ALLOC_NOT_EXIST     (0x1000)
+#define PON_ONU_DEFAULT_ALLOC_TCONT (0)
+#define PON_ONU_IDLE_ALLOC_TCONT    (1)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponAllocIdTcontClearAll(void);
+MV_STATUS onuGponAllocIdTcontSet(MV_U32 allocId, MV_U32 tcontNum);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponAllocIdInit(MV_U32 existTcontsBitmap);
+MV_STATUS onuGponAllocIdAssign(MV_U32 allocId, MV_U32 notifyFlag);
+MV_STATUS onuGponAllocIdDeAssign(MV_U32 allocId);
+MV_STATUS onuGponAllocIdTcontSet(MV_U32 allocId, MV_U32 tcontNum);
+MV_STATUS onuGponAllocIdTcontClear(MV_U32 tcontNum);
+MV_STATUS onuGponAllocIdDeAssignAll(void);
+MV_STATUS onuGponAllocIdFreeAllBuffers(void);
+MV_STATUS onuGponAllocIdTcontClearAll(void);
+MV_STATUS onuGponAllocIdMacReActivate(void);
+MV_U32    onuGponIdleAllocIdTcontGet(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* ONU_GPON_ALLOC_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.c
new file mode 100644
index 0000000..f8e6f40
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.c
@@ -0,0 +1,473 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuAlrm.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Alarm and Statistics         **
+**                functionality                                              **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuAlrm.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_OnuGponApmTbl onuGponApmTbl_s;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U16 l_onuGponPreviousAlarmState = ONU_GPON_ALARM_DEF_STATE;
+MV_U16 l_onuGponCurrentAlarmState  = ONU_GPON_ALARM_DEF_STATE;
+MV_U32 l_onuGponDsSyncFlag         = 1;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Alarm Section                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponAlarmTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init the onu gpon alarm table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponAlarmTblInit(void)
+{
+	/* set alarm Off as default for all alarms */
+	memset(&(onuGponApmTbl_s.onuGponAlarmTbl_s.onuGponAlarmTbl[0]),
+	       ONU_GPON_ALARM_OFF, sizeof(S_OnuGponAlarmTbl));
+
+	/* set alarms on as default only for LOS, LOF, and LCDG */
+	onuGponApmTbl_s.onuGponAlarmTbl_s.onuGponAlarmTbl[ONU_GPON_ALARM_LOS]  = ONU_GPON_ALARM_ON;
+	onuGponApmTbl_s.onuGponAlarmTbl_s.onuGponAlarmTbl[ONU_GPON_ALARM_LOF]  = ONU_GPON_ALARM_ON;
+}
+
+/*******************************************************************************
+**
+**  onuGponAlarmSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu gpon alarm
+**
+**  PARAMETERS:  E_OnuGponAlarmType  alarm
+**               E_OnuGponAlarmState status
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAlarmSet(E_OnuGponAlarmType alarm,
+			  E_OnuGponAlarmState state)
+{
+	if (alarm > ONU_GPON_ALARM_RDI) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALARM_MODULE,
+			   "ERROR: (%s:%d) invalid alarm(%d) type\n", __FILE_DESC__, __LINE__, alarm);
+		return MV_ERROR;
+	}
+
+	if (state > ONU_GPON_ALARM_ON) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALARM_MODULE,
+			   "ERROR: (%s:%d)  invalid alarm(%d) state(%d)\n", __FILE_DESC__, __LINE__, alarm, state);
+		return MV_ERROR;
+	}
+
+	onuGponApmTbl_s.onuGponAlarmTbl_s.onuGponAlarmTbl[alarm] = state;
+
+	if (onuGponDbOnuStateGet() == ONU_GPON_06_POPUP)
+		return MV_OK;
+
+	if (state == ONU_GPON_ALARM_OFF)
+		l_onuGponCurrentAlarmState &= ~(1 << alarm);
+	else
+		l_onuGponCurrentAlarmState |= (1 << alarm);
+
+	onuGponAlarmProcess();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAlarmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu gpon alarm state
+**
+**  PARAMETERS:  E_OnuGponAlarmType alarm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu gpon alarm state
+**
+*******************************************************************************/
+E_OnuGponAlarmState onuGponAlarmGet(E_OnuGponAlarmType alarm)
+{
+	if (alarm > ONU_GPON_ALARM_RDI) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ALARM_MODULE,
+			   "ERROR: (%s:%d) invalid alarm(%d) type\n", __FILE_DESC__, __LINE__, alarm);
+		return MV_ERROR;
+	}
+
+	return onuGponApmTbl_s.onuGponAlarmTbl_s.onuGponAlarmTbl[alarm];
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicAlarmStatusGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu gpon alarm state, alarm is off if all
+**               asic alarms (LOS, LOF, and LCDG) are off, else alarm is on
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu gpon alarm state
+**
+*******************************************************************************/
+E_OnuGponAlarmState onuGponAsicAlarmStatusGet(void)
+{
+	if ((onuGponAlarmGet(ONU_GPON_ALARM_LOS) == ONU_GPON_ALARM_OFF) &&
+	    (onuGponAlarmGet(ONU_GPON_ALARM_LOF) == ONU_GPON_ALARM_OFF))
+		return ONU_GPON_ALARM_OFF;
+	else
+		return ONU_GPON_ALARM_ON;
+}
+
+/*******************************************************************************
+**
+**  onuGponAlarmProcess
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function process the current alarm state and notify screen
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponAlarmProcess(void)
+{
+	MV_U32 onuGponPreviousAlarmState;
+	MV_U32 onuGponCurrentAlarmState;
+	MV_U32 onuGponChangeAlarm;
+	LINKSTATUSFUNC linkStatusCallback;
+
+	/* get the ASIC prvious alarm status */
+	onuGponPreviousAlarmState = l_onuGponPreviousAlarmState;
+
+	/* get the ASIC current alarm status */
+	onuGponCurrentAlarmState = l_onuGponCurrentAlarmState;
+
+	/* alarm changed */
+	if ((onuGponCurrentAlarmState ^ onuGponPreviousAlarmState) != 0) {
+		onuGponChangeAlarm = (onuGponCurrentAlarmState ^ onuGponPreviousAlarmState);
+
+		if ((onuGponChangeAlarm & onuGponCurrentAlarmState) != 0) {
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LOS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LOS On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LOS, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LOF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LOF On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LOF, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LCDG_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LCDG On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LCDG, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_TF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm TF On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_TF, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_SUF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm SUF On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_SUF, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_MEM_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm MEM On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_MEM, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_DACT_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm DACT On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_DACT, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_DIS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm DIS On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_DIS, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_MIS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm MIS On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_MIS, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_PEE_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm PEE On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_PEE, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_RDI_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm RDI On ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_RDI, GPON_ONU_ALARM_STATUS_ON);
+			}
+
+			if ((onuGponAsicAlarmStatusGet() == ONU_GPON_ALARM_ON) &&
+			    l_onuGponDsSyncFlag == 0) {
+				/* Turn OFF LED */
+				onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_OFF);
+
+				mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=======================\n");
+				mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== Upstream sync Off ==\n");
+				mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=======================\n");
+
+				/* Call link status callback function */
+				linkStatusCallback = onuGponDbLinkStatusCallbackGet();
+				if (linkStatusCallback != NULL)
+					linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_FALSE);
+
+				/* onuPonTxPowerOn(MV_FALSE); */
+				onuPonTxPowerTimerStateSet(MV_TRUE);
+
+				onuGponSrvcStatusNotify(GPON_ONU_STATUS_DISCONNECTED);
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "=========================\n");
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "== Downstream sync Off ==\n");
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "=========================\n");
+				l_onuGponDsSyncFlag = 1;
+			}
+		} else { /* ((onuGponChangeAlarm & onuGponCurrentAlarmState) == 0) */
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LOS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LOS Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LOS, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LOF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LOF Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LOF, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_LCDG_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm LCDG Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_LCDG, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_TF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm TF Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_TF, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_SUF_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm SUF Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_SUF, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_MEM_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm MEM Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_MEM, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_DACT_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm DACT Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_DACT, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_DIS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm DIS Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_DIS, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_MIS_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm MIS Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_MIS, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_PEE_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm PEE Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_PEE, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if (onuGponChangeAlarm & ONU_GPON_ALARM_RDI_LOC) {
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+					   "INFO: (%s:%d) === Alarm RDI Off ===\n", __FILE_DESC__, __LINE__);
+				onuGponSrvcAlarmNotify(GPON_ONU_ALARM_RDI, GPON_ONU_ALARM_STATUS_OFF);
+			}
+
+			if ((onuGponAsicAlarmStatusGet() == ONU_GPON_ALARM_OFF) &&
+			    l_onuGponDsSyncFlag == 1) {
+				/* Turn LED ON */
+				onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_SLOW);
+
+				onuGponSrvcStatusNotify(GPON_ONU_STATUS_NOT_RANGED);
+
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "========================\n");
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "== Downstream sync On ==\n");
+				mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "========================\n");
+				l_onuGponDsSyncFlag = 0;
+
+				onuPonTxPowerOn(MV_TRUE);
+				mvOnuGponMacXvrActivate();
+				onuGponDbOnuDsSyncOnSet(1);
+			}
+		}
+
+		l_onuGponPreviousAlarmState = l_onuGponCurrentAlarmState;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponOnuAlarmShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print current alarm statsus
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponOnuAlarmShow(void)
+{
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE,
+		   "ONU Gpon alarms state\n"
+		   "=====================\n");
+
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm LOS  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_LOS_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm LOF  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_LOF_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm LCDG - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_LCDG_LOC) ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm TF   - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_TF_LOC)   ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm SUF  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_SUF_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm MEM  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_MEM_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm DACT - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_DACT_LOC) ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm DIS  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_DIS_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm MIS  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_MIS_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm PEE  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_PEE_LOC)  ? ("On") : ("Off"));
+	mvPonPrint(PON_PRINT_INFO, PON_ALARM_MODULE, "Alarm RDI  - %s\n",
+		   (l_onuGponCurrentAlarmState & ONU_GPON_ALARM_RDI_LOC)  ? ("On") : ("Off"));
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.h
new file mode 100644
index 0000000..39d82e9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuAlrm.h
@@ -0,0 +1,193 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuAlrm.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Alarm and Statistics           **
+**                                                                           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_ALRM_H
+#define _ONU_GPON_ALRM_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define ONU_GPON_ALARM_LOS_LOC   (0x0001)
+#define ONU_GPON_ALARM_LOF_LOC   (0x0002)
+#define ONU_GPON_ALARM_LCDA_LOC  (0x0004)
+#define ONU_GPON_ALARM_LCDG_LOC  (0x0008)
+#define ONU_GPON_ALARM_SF_LOC    (0x0010)
+#define ONU_GPON_ALARM_SD_LOC    (0x0020)
+#define ONU_GPON_ALARM_TF_LOC    (0x0040)
+#define ONU_GPON_ALARM_SUF_LOC   (0x0080)
+#define ONU_GPON_ALARM_MEM_LOC   (0x0100)
+#define ONU_GPON_ALARM_DACT_LOC  (0x0200)
+#define ONU_GPON_ALARM_DIS_LOC   (0x0400)
+#define ONU_GPON_ALARM_MIS_LOC   (0x0800)
+#define ONU_GPON_ALARM_PEE_LOC   (0x1000)
+#define ONU_GPON_ALARM_RDI_LOC   (0x2000)
+
+#define ONU_GPON_ALARM_DEF_STATE (ONU_GPON_ALARM_LOS_LOC | \
+				  ONU_GPON_ALARM_LOF_LOC | \
+				  ONU_GPON_ALARM_LCDG_LOC)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	/* ASIC Alarms */
+	ONU_GPON_ALARM_LOS = 0,
+	ONU_GPON_ALARM_LOF,
+	ONU_GPON_ALARM_LCDA,
+	ONU_GPON_ALARM_LCDG,
+	/* SW Alarms */
+	ONU_GPON_ALARM_SF,
+	ONU_GPON_ALARM_SD,
+	ONU_GPON_ALARM_TF,
+	ONU_GPON_ALARM_SUF,
+	ONU_GPON_ALARM_MEM,
+	ONU_GPON_ALARM_DACT,
+	ONU_GPON_ALARM_DIS,
+	ONU_GPON_ALARM_MIS,
+	ONU_GPON_ALARM_PEE,
+	ONU_GPON_ALARM_RDI,
+	ONU_GPON_MAX_ALARMS
+} E_OnuGponAlarmType;
+
+typedef enum {
+	ONU_GPON_ALARM_OFF,
+	ONU_GPON_ALARM_ON
+} E_OnuGponAlarmState;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* ONU GPON Alarm table */
+typedef struct {
+	E_OnuGponAlarmState onuGponAlarmTbl[ONU_GPON_NUM_OF_ALARMS];
+} S_OnuGponAlarmTbl;
+
+/* ONU GPON Stats table */
+typedef struct {
+	MV_U32 onuGponInComingPloamCrcErrCnt;
+	MV_U32 onuGponInComingPloamOverflowCnt;
+	MV_U32 onuGponOutGoingBwCrcErrCnt;
+	MV_U32 onuGponOutGoingBwCrcCorrectErrCnt;
+} S_OnuGponStatsTbl;
+
+/* ONU GPON APM table */
+typedef struct {
+	S_OnuGponAlarmTbl onuGponAlarmTbl_s;
+	S_OnuGponStatsTbl onuGponStatsTbl_s;
+} S_OnuGponApmTbl;
+
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+/* ONU GPON APM table */
+extern S_OnuGponApmTbl onuGponApmTbl_s;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+void onuGponAlarmProcess(void);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* ONU GPON Alarm table init function */
+void                onuGponAlarmTblInit(void);
+
+/* ONU GPON Alarm table API functions */
+MV_STATUS           onuGponAlarmSet(E_OnuGponAlarmType alarm, E_OnuGponAlarmState state);
+E_OnuGponAlarmState onuGponAlarmGet(E_OnuGponAlarmType alarm);
+E_OnuGponAlarmState onuGponAsicAlarmStatusGet(void);
+
+void                onuGponOnuAlarmShow(void);
+
+/* ONU GPON Stats API functions */
+void                onuGponOnuStatsAccmulate(void);
+void                onuGponOnuStatsReset(void);
+void                onuGponOnuStatsShow(void);
+
+MV_STATUS           onuGponInComingPloamCrcErrSet(MV_U32 count);
+MV_U32              onuGponInComingPloamCrcErrGet(void);
+MV_STATUS           onuGponInComingPloamOverflowCntSet(MV_U32 count);
+MV_U32              onuGponInComingPloamOverflowCntGet(void);
+MV_STATUS           onuGponOutGoingBwCrcErrCntSet(MV_U32 count);
+MV_U32              onuGponOutGoingBwCrcErrCntGet(void);
+MV_STATUS           onuGponOutGoingBwCrcCorrErrCntSet(MV_U32 count);
+MV_U32              onuGponOutGoingBwCrcCorrErrCntGet(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_ALRM_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.c
new file mode 100644
index 0000000..cd897c7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.c
@@ -0,0 +1,2727 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuApi.c                                               **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON API functionality            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+#include "mv_netdev.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gonuGponApi.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_GponPm g_OnuGponOutPm;
+
+MV_U32 g_UponDebugMode = 0;
+extern u8 mvMacAddr[MV_ETH_MAX_PORTS][MV_MAC_ADDR_SIZE];
+
+struct mv_eth_ext_mac_ops gpon_mac_ops;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+#ifdef MV_GPON_STATIC_GEM_PORT
+MV_U32 staticGemPortConfig[4096];
+MV_U32 staticGemPortConfigFlag  = 0;
+#endif /* MV_GPON_STATIC_GEM_PORT */
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Initialization Section                             */
+/* ========================================================================== */
+/******************************************************************************/
+/*******************************************************************************
+**
+**  onuGponApiInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu gpon API
+**
+**  PARAMETERS:  MV_U8 *serialNumber
+**               MV_U8 *password
+**               MV_BOOL  disabled
+**               MV_U32   sn_src
+**               MV_U32 fecHyst
+**               MV_U32 couplingMode
+**               MV_U32 omccRxQueue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiInit(MV_U8 *serialNumber,
+			 MV_U8 *password,
+			 MV_BOOL disabled,
+			 MV_U32 sn_src,
+			 MV_U32 fecHyst,
+			 MV_U32 couplingMode,
+			 MV_U32 omccRxQueue)
+{
+	MV_STATUS rcode;
+	MV_U32 i;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiInit Serial number (%s) Password (%s)\n",
+		   __FILE_DESC__, __LINE__, serialNumber, password);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponDbOmccRxQueueSet(omccRxQueue);
+
+	onuGponDbPasswordSet(password);
+	if (sn_src == 1) {
+		/*the digit part of the serial number is taken from the 4lower pairs of the MAC address*/
+		for (i = 0; i < 4; i++)
+			serialNumber[i + 4] = mvMacAddr[3][i + 2];
+	}
+
+	rcode = onuGponSrvcSerialNumberSet(serialNumber);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponSrvcSerialNumberSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuGponMacRxFecHysteresisSet(fecHyst);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacRxFecHysteresisSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponApiCouplingModeSet(couplingMode);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacCouplingModeSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponSrvcRangingRandomInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponRangingRandomInit", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	if (disabled == MV_TRUE) {
+		/* update asic */
+		rcode = mvOnuGponMacOnuStateSet(ONU_GPON_07_EMERGANCY_STOP);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacOnuStateSet", __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+
+		/* update database */
+		onuGponDbOnuStateSet(ONU_GPON_07_EMERGANCY_STOP);
+	}
+
+	memset(&g_OnuGponOutPm, 0, sizeof(S_GponPm));
+
+	onuGponDbInitSet(MV_TRUE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiAlarmNotifyRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register alarm callback function
+**
+**  PARAMETERS:  ALARMNOTIFYFUNC notifyCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAlarmNotifyRegister(ALARMNOTIFYFUNC notifyCallBack)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiAlarmNotifyRegister\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponDbAlarmNotifySet(notifyCallBack);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAlarmNotifyRegister", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiStatusNotifyRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register status callback function
+**
+**  PARAMETERS:  STATUSNOTIFYFUNC notifyCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiStatusNotifyRegister(STATUSNOTIFYFUNC notifyCallBack)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiStatusNotifyRegister\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponDbStatusNotifySet(notifyCallBack);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiStatusNotifyRegister", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOmccNotifyRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register omcc callback function
+**
+**  PARAMETERS:  OMCCNOTIFYFUNC notifyCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOmccNotifyRegister(OMCCNOTIFYFUNC notifyCallBack)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiOmccNotifyRegister\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponDbOmccNotifySet(notifyCallBack);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiOmccNotifyRegister", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiDisableNotifyRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register disable onu callback function
+**
+**  PARAMETERS:  DISABLENOTIFYFUNC notifyCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiDisableNotifyRegister(DISABLENOTIFYFUNC notifyCallBack)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiDisableNotifyRegister\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponDbDisableNotifySet(notifyCallBack);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiDisableNotifyRegister", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiTcontConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function validates and configures Alloc-Id to T-cont
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 tcontId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiTcontConfig(MV_U32 allocId, MV_U32 tcontId)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiTcontConfig alloc Id (%d) tcont (%d)\n",
+		   __FILE_DESC__, __LINE__, allocId, tcontId);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponAllocIdTcontSet(allocId, tcontId);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiTcontConfig", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiBerThresholdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures the SD / SF thresholds for GPON ONU
+**
+**  PARAMETERS:  MV_U32 sd
+**               MV_U32 sf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiBerThresholdConfig(MV_U32 sd, MV_U32 sf)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiBerThresholdConfig sd (%d) sf (%d)\n",
+		   __FILE_DESC__, __LINE__, sd, sf);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	if ((sf >= sd) ||
+	    (sf > ONU_GPON_MAX_SF_THRESHOLD) || (sf < ONU_GPON_MIN_SF_THRESHOLD) ||
+	    (sd > ONU_GPON_MAX_SD_THRESHOLD) || (sd < ONU_GPON_MIN_SD_THRESHOLD))
+		/* SD threshold must be higher than SF */
+		return MV_ERROR;
+
+	rcode = onuGponDbSdThresholdSet(sd);
+	rcode |= onuGponDbSfThresholdSet(sf);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiBerThresholdConfig", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiBerIntervalConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures the ONU BER interval,
+**               which defines the time the ONU send BER information
+**
+**  PARAMETERS:  MV_U32 interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiBerIntervalConfig(MV_U32 interval)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiBerIntervalConfig interval (%d)\n",
+		   __FILE_DESC__, __LINE__, interval);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponBerIntervalSet(interval);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiBerCoefficientConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures the BER coefficient, which are used
+**               in the BER Calculation formula
+**
+**  PARAMETERS:  MV_U32 denominator
+**               MV_U32 numerator
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponApiBerCoefficientConfig(MV_U32 denominator, MV_U32 numerator)
+{
+	S_BerCoefficient coef;
+
+	coef.denominator = denominator;
+	coef.numerator   = numerator;
+	onuGponBerCoefficientSet(&coef);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiTcontClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all Alloc-Ids from T-cont
+**
+**  PARAMETERS:  MV_U32 tcontId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiTcontClear(MV_U32 tcontId)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiTcontClear tcontId (%d)\n",
+		   __FILE_DESC__, __LINE__, tcontId);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponAllocIdTcontClear(tcontId);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiTcontClear", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiTcontsReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears all Alloc-Ids from all T-conts
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiTcontsReset(void)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiTcontsReset\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponAllocIdTcontClearAll();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiTcontsReset", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Adds or removes a gem port by the action
+**
+**  PARAMETERS:  gemmap bit map, corresponding action per this group
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemConfig(MV_U32 *gemmap, E_GponIoctlGemAction action)
+{
+	MV_U32 index, bit, mask;
+	MV_U32 portId;
+	MV_STATUS rcode = MV_OK;
+
+	for (index = 0; index < GPON_ONU_MAX_GEM_PORTS / 32; index++) {
+		if (gemmap[index] != 0) {
+			mask = 1;
+			for (bit = 0 ; bit < 32 ; bit++) {
+				if (gemmap[index] & mask) {
+					portId = index * 32 + bit;
+					if (action != E_GEPON_IOCTL_GEM_REMOVE) {
+						rcode  = onuGponApiGemPortIdConfig(portId);
+						if (rcode != MV_OK) {
+							mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+								   "ERROR: (%s:%d) onuGponApiGemConfig",
+								   __FILE_DESC__, __LINE__);
+							break;
+						}
+						if (onuGponDbGemPortAesGet(portId) == MV_TRUE)
+							/*update HW as well*/
+							mvOnuGponMacAesPortIdSet(portId, MV_TRUE);
+					} else {
+						rcode  = onuGponApiGemPortIdClear(portId);
+						if (rcode != MV_OK) {
+							mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+								   "ERROR: (%s:%d) onuGponApiGemConfig",
+								   __FILE_DESC__, __LINE__);
+							break;
+						}
+						if (onuGponDbGemPortAesGet(portId) == MV_TRUE)
+							/*remove HW configuration but keep SW encryption indication*/
+							mvOnuGponMacAesPortIdSet(portId, MV_FALSE);
+					}
+
+				}
+				mask = mask << 1;
+			}
+		}
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemClearAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function removes all gem port
+**
+**  PARAMETERS:  savePorts
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemClearAll(MV_BOOL savePorts)
+{
+	if (savePorts == MV_TRUE)
+		onuGponDbGemPortSaveAll();
+
+	onuGponDbGemPortClearAll();
+	mvOnuGponMacGemInit();
+	/*reconfigure omcc port*/
+	onuGponApiGemPortIdConfig(onuGponDbOmccPortGet());
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemRestoreAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function restores all previously saved gem ports
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemRestoreAll(void)
+{
+	MV_U32 gemPortId;
+	MV_STATUS rcode = MV_OK;
+
+	for (gemPortId = 0; gemPortId < GPON_ONU_MAX_GEM_PORTS; gemPortId++) {
+		if (onuGponDbGemPortSavedValidGet(gemPortId) == MV_TRUE)
+			rcode = onuGponApiGemPortIdConfig(gemPortId);
+
+		if (rcode != MV_OK)
+			break;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemOmccIdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure omcc port Id
+**
+**  PARAMETERS:  MV_U32 gemPortid
+**               MV_U32 valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemOmccIdConfig(MV_U32 gemPortid, MV_BOOL valid)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_STATIC_GEM_PORT
+	MV_U32 index;
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiGemOmcctIdConfig gemPortid (%d) valid (%d)\n",
+		   __FILE_DESC__, __LINE__, gemPortid, valid);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = mvOnuGponMacGemOmciPortIdSet(gemPortid, (valid == MV_TRUE) ? (1) : (0)); /* Rx */
+	rcode |= mvOnuGponMacUtmOmciPortIdSet(gemPortid, (valid == MV_TRUE) ? (1) : (0)); /* Tx */
+	rcode |= mvOnuGponMacPortIdValidSet(gemPortid, valid); /* Gem Port-Id Valid Table */
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiGemOmcctIdConfig", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	onuGponDbGemPortValidSet(gemPortid, valid);
+
+#ifdef MV_GPON_STATIC_GEM_PORT
+	if (staticGemPortConfigFlag != 0) {
+		for (index = 0; index < 4096; index++)
+			if (staticGemPortConfig[index] != 0)
+				onuGponApiGemPortIdConfig(index);
+	}
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortIdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure gem port Id from MAC
+**
+**  PARAMETERS:  MV_U32 gemPortid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortIdConfig(MV_U32 gemPortid)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiGemPortIdConfig gemPortid (%d)\n",
+		   __FILE_DESC__, __LINE__, gemPortid);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = mvOnuGponMacPortIdValidSet(gemPortid, MV_TRUE);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiGemPortIdConfig", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+	onuGponDbGemPortValidSet(gemPortid, MV_TRUE);
+
+#ifdef MV_GPON_STATIC_GEM_PORT
+	if (staticGemPortConfigFlag == 0)
+		if (gemPortid < 4096)
+			staticGemPortConfig[gemPortid] = 1;
+
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortIdClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears gem port Id from MAC
+**
+**  PARAMETERS:  MV_U32 gemPortid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortIdClear(MV_U32 gemPortid)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiGemPortIdClear gemPortid (%d)\n",
+		   __FILE_DESC__, __LINE__, gemPortid);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = mvOnuGponMacPortIdValidSet(gemPortid, MV_FALSE);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiGemPortIdClear", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+	onuGponDbGemPortValidSet(gemPortid, MV_FALSE);
+
+	return rcode;
+}
+
+#ifdef MV_GPON_STATIC_GEM_PORT
+/*******************************************************************************
+**
+**  onuGponApiGemPortIdStaticConfigReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears dummy gem port Id table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortIdStaticConfigFlag(MV_U32 flag)
+{
+	staticGemPortConfigFlag = flag;
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortIdStaticConfigReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears dummy gem port Id table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortIdStaticConfigReset(void)
+{
+	MV_U32 index;
+
+	for (index = 0; index < 4096; index++)
+		staticGemPortConfig[index] = 0;
+
+	return MV_OK;
+}
+
+#endif /* MV_GPON_STATIC_GEM_PORT */
+
+/*******************************************************************************
+**
+**  onuGponApiInformationGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu info
+**
+**  PARAMETERS:  S_OnuInfo *onuInfo
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponApiInformationGet(S_OnuInfo *onuInfo)
+{
+	onuGponDbPasswordGet(onuInfo->password);
+	onuGponDbSerialNumGet(onuInfo->serialNumber);
+	onuInfo->onuId             = onuGponDbOnuIdGet();
+	onuInfo->state             = onuGponDbOnuStateGet();
+	onuInfo->sdThreshold       = onuGponDbSdThresholdGet();
+	onuInfo->sfThreshold       = onuGponDbSfThresholdGet();
+	onuInfo->localBerInterval  = onuGponDbBerCalcIntervalGet();
+	onuInfo->remoteBerInterval = onuGponDbBerIntervalGet();
+	onuInfo->omccPortId        = onuGponDbOmccPortGet();
+	onuInfo->constDelay        = onuGponDbConstDelayGet();
+	onuInfo->eqDelay           = onuGponDbEqualizationDelayGet();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiAlarmsGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu alarms bit map
+**
+**  PARAMETERS:  MV_U32 *alarms
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAlarmsGet(MV_U32 *alarms)
+{
+	MV_U32 i;
+	MV_U32 status;
+
+	*alarms = 0;
+	for (i = ONU_GPON_ALARM_LOS ; i < ONU_GPON_MAX_ALARMS ; i++) {
+		status = onuGponAlarmGet(i);
+		if (status == ONU_GPON_ALARM_ON)
+			*alarms |= 1 << i;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmFecPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               FEC PM counters
+**
+**  PARAMETERS:  S_IoctlFecPm *fecPm
+**               MV_BOOL      a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPmFecPmGet(S_GponIoctlFecPm *fecPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_RxFecPm inCounters;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiPmFecPmGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponPmFecPmGet(&inCounters);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiPmFecPmGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	fecPm->receivedBytes        = inCounters.receivedBytes        - g_OnuGponOutPm.rxFec.receivedBytes;
+	fecPm->correctedBytes       = inCounters.correctedBytes       - g_OnuGponOutPm.rxFec.correctedBytes;
+	fecPm->correctedBits        = inCounters.correctedBits        - g_OnuGponOutPm.rxFec.correctedBits;
+	fecPm->receivedCodeWords    = inCounters.receivedCodeWords    - g_OnuGponOutPm.rxFec.receivedCodeWords;
+	fecPm->uncorrectedCodeWords = inCounters.uncorrectedCodeWords - g_OnuGponOutPm.rxFec.uncorrectedCodeWords;
+
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.rxFec.receivedBytes        = inCounters.receivedBytes;
+		g_OnuGponOutPm.rxFec.correctedBytes       = inCounters.correctedBytes;
+		g_OnuGponOutPm.rxFec.correctedBits        = inCounters.correctedBits;
+		g_OnuGponOutPm.rxFec.receivedCodeWords    = inCounters.receivedCodeWords;
+		g_OnuGponOutPm.rxFec.uncorrectedCodeWords = inCounters.uncorrectedCodeWords;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmRxPloamPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Rx Ploam counters
+**
+**  PARAMETERS:  S_IoctlPloamRxPm *rxPloamPm
+**               MV_BOOL           a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPmRxPloamPmGet(S_GponIoctlPloamRxPm *rxPloamPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_RxPloamPm inCounters;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiPmRxPloamPmGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponPmRxPloamPmGet(&inCounters);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiPmRxPloamPmGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rxPloamPm->rxCrcErrorPloam      = inCounters.crcErrorPloamCounter          - g_OnuGponOutPm.rxPloam.crcErrorPloamCounter;
+	rxPloamPm->rxBroadcastPloam     = inCounters.receivedBroadcastPloamCounter - g_OnuGponOutPm.rxPloam.receivedBroadcastPloamCounter;
+	rxPloamPm->rxOnuIdPloam         = inCounters.receivedOnuIdPloamCounter     - g_OnuGponOutPm.rxPloam.receivedOnuIdPloamCounter;
+	rxPloamPm->rxFifoOverErrorPloam = inCounters.fifoOverErrorPloamCounter     - g_OnuGponOutPm.rxPloam.fifoOverErrorPloamCounter;
+	rxPloamPm->rxIdlePloam          = inCounters.idlePloamCounter              - g_OnuGponOutPm.rxPloam.idlePloamCounter;
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.rxPloam.crcErrorPloamCounter          = inCounters.crcErrorPloamCounter;
+		g_OnuGponOutPm.rxPloam.receivedBroadcastPloamCounter = inCounters.receivedBroadcastPloamCounter;
+		g_OnuGponOutPm.rxPloam.receivedOnuIdPloamCounter     = inCounters.receivedOnuIdPloamCounter;
+		g_OnuGponOutPm.rxPloam.fifoOverErrorPloamCounter     = inCounters.fifoOverErrorPloamCounter;
+		g_OnuGponOutPm.rxPloam.idlePloamCounter              = inCounters.idlePloamCounter;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmTxPloamPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Tx Ploam counters
+**
+**  PARAMETERS:  S_TxPloamAdvApiPm *txPloamPm
+**               S_RxPloamAdvApiPm *rxPloamPm
+**               MV_BOOL              a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAdvancedPloamsCounterGet(S_GponIoctlPloamTxPm *txPloamPm,
+					     S_GponIoctlPloamRxPm *rxPloamPm,
+					     MV_BOOL a_clear)
+{
+	MV_STATUS status;
+	S_TxPloamPm inCounters1;
+	S_RxPloamPm inCounters2;
+	MV_U32 numOfDsMsgIdIndex;
+	MV_U32 numOfUsMsgIdIndex;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiAdvancedPloamsCounterGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	status  = onuGponPmTxPloamPmGet(&inCounters1);
+	status |= onuGponPmRxPloamPmGet(&inCounters2);
+
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAdvancedPloamsCounterGet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	txPloamPm->txMsgTotalPloam = inCounters1.txMsgTotalPloamCounter - g_OnuGponOutPm.txPloam.txMsgTotalPloamCounter;
+
+	for (numOfUsMsgIdIndex = 1 ; numOfUsMsgIdIndex <= ONU_GPON_US_MSG_LAST ; numOfUsMsgIdIndex++) {
+		txPloamPm->txMsgIdPloam[numOfUsMsgIdIndex]    = inCounters1.txMsgIdPloamCounter[numOfUsMsgIdIndex]    -
+								g_OnuGponOutPm.txPloam.txMsgIdPloamCounter[numOfUsMsgIdIndex];
+		txPloamPm->txErrMsgIdPloam[numOfUsMsgIdIndex] = inCounters1.txErrMsgIdPloamCounter[numOfUsMsgIdIndex] -
+								g_OnuGponOutPm.txPloam.txErrMsgIdPloamCounter[numOfUsMsgIdIndex];
+	}
+
+	rxPloamPm->rxMsgTotalPloam = inCounters2.rxMsgTotalPloamCounter - g_OnuGponOutPm.rxPloam.rxMsgTotalPloamCounter;
+
+	for (numOfDsMsgIdIndex = 0 ; numOfDsMsgIdIndex <= ONU_GPON_DS_MSG_LAST ; numOfDsMsgIdIndex++)
+		rxPloamPm->rxMsgIdPloam[numOfDsMsgIdIndex] = inCounters2.rxMsgIdPloamCounter[numOfDsMsgIdIndex] -
+							     g_OnuGponOutPm.rxPloam.rxMsgIdPloamCounter[numOfDsMsgIdIndex];
+
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.txPloam.txMsgTotalPloamCounter = inCounters1.txMsgTotalPloamCounter;
+
+		for (numOfUsMsgIdIndex = 0 ; numOfUsMsgIdIndex <= ONU_GPON_US_MSG_LAST ; numOfUsMsgIdIndex++) {
+			g_OnuGponOutPm.txPloam.txErrMsgIdPloamCounter[numOfUsMsgIdIndex] = inCounters1.txErrMsgIdPloamCounter[numOfUsMsgIdIndex];
+			g_OnuGponOutPm.txPloam.txMsgIdPloamCounter[numOfUsMsgIdIndex]    = inCounters1.txMsgIdPloamCounter[numOfUsMsgIdIndex];
+		}
+
+		g_OnuGponOutPm.rxPloam.rxMsgTotalPloamCounter = inCounters2.rxMsgTotalPloamCounter;
+
+		for (numOfDsMsgIdIndex = 0 ; numOfDsMsgIdIndex <= ONU_GPON_DS_MSG_LAST ; numOfDsMsgIdIndex++)
+			g_OnuGponOutPm.rxPloam.rxMsgIdPloamCounter[numOfDsMsgIdIndex] = inCounters2.rxMsgIdPloamCounter[numOfDsMsgIdIndex];
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmRxBwMapPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Rx Bw Map counters
+**
+**  PARAMETERS:  S_RxBwMapApiPm *rxBwMapPm
+**               MV_BOOL           a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPmRxBwMapPmGet(S_GponIoctlBwMapPm *rxBwMapPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_RxBwMapPm inCounters;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiPmRxBwMapPmGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponPmRxBwMapPmGet(&inCounters);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiPmRxBwMapPmGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rxBwMapPm->allocCorrec              = inCounters.allocCorrec              - g_OnuGponOutPm.rxBwMap.allocCorrec;
+	rxBwMapPm->allocCorrectableCrcErr   = inCounters.allocCorrectableCrcErr   - g_OnuGponOutPm.rxBwMap.allocCorrectableCrcErr;
+	rxBwMapPm->allocCrcErr              = inCounters.allocCrcErr              - g_OnuGponOutPm.rxBwMap.allocCrcErr;
+	rxBwMapPm->allocUnCorrectableCrcErr = inCounters.allocUnCorrectableCrcErr - g_OnuGponOutPm.rxBwMap.allocUnCorrectableCrcErr;
+	rxBwMapPm->totalReceivedAllocBytes  = inCounters.totalReceivedAllocBytes  - g_OnuGponOutPm.rxBwMap.totalReceivedAllocBytes;
+
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.rxBwMap.allocCorrec              = inCounters.allocCorrec;
+		g_OnuGponOutPm.rxBwMap.allocCorrectableCrcErr   = inCounters.allocCorrectableCrcErr;
+		g_OnuGponOutPm.rxBwMap.allocCrcErr              = inCounters.allocCrcErr;
+		g_OnuGponOutPm.rxBwMap.allocUnCorrectableCrcErr = inCounters.allocUnCorrectableCrcErr;
+		g_OnuGponOutPm.rxBwMap.totalReceivedAllocBytes  = inCounters.totalReceivedAllocBytes;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmRxBwMapPmDumpSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable dump BW MAP counters before
+**               ONU state changing
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPmRxBwMapPmDumpSet(MV_BOOL enable)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiPmRxBwMapPmDumpSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	if (enable == MV_TRUE)
+		onuPonTimerDisable(&onuPonResourceTbl_s.onuPonPmTimerId);
+	else
+		onuPonTimerEnable(&onuPonResourceTbl_s.onuPonPmTimerId);
+
+	rcode  = onuGponDbBwMapCntDumpSet(enable);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiExtendedBurstDelaySet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmRxBwMapPmDump
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu bw map counters
+**
+**  PARAMETERS:  MV_U32 currstate
+**               MV_U32 newstate
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponApiPmRxBwMapPmDump(MV_U32 currstate, MV_U32 newstate)
+{
+	MV_STATUS rcode;
+	S_GponIoctlBwMapPm counters;
+
+	rcode = onuGponApiPmRxBwMapPmGet(&counters, MV_TRUE);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	printk(KERN_INFO "ONT STATE CHANGING: FROM [%d] TO [%d] - allocCor[%10u]\n",
+	       currstate, newstate, counters.allocCorrec);
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPmRxStandardPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Rx Standard counters
+**
+**  PARAMETERS:  S_RxStandardApiPm *rxStandardPm
+**               MV_BOOL              a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPmRxStandardPmGet(S_RxStandardApiPm *rxStandardPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_RxBip8Pm inCounter1;
+	S_RxPlendPm inCounter2;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiPmRxStandardPmGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponPmRxBip8PmGet(&inCounter1);
+	rcode |= onuGponPmRxPlendPmGet(&inCounter2);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiPmRxStandardPmGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rxStandardPm->bip8  = inCounter1.bip8  - g_OnuGponOutPm.rxBip8.bip8;
+	rxStandardPm->plend = inCounter2.plend - g_OnuGponOutPm.rxPlend.plend;
+
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.rxBip8.bip8   = inCounter1.bip8;
+		g_OnuGponOutPm.rxPlend.plend = inCounter2.plend;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemRxCounterGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               GEM counters
+**
+**  PARAMETERS:  S_IoctlGemRxPm *gemPm
+**               MV_BOOL         a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemRxCounterGet(S_GponIoctlGemRxPm *gemPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_GemPm inCounters;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiGemCounterGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponPmGemPmGet(&inCounters);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiGemCounterGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	gemPm->gemRxIdleGemFrames                              = inCounters.receivedIdleGemFrames               -
+								 g_OnuGponOutPm.gem.receivedIdleGemFrames;
+	gemPm->gemRxValidGemFrames                             = inCounters.receivedValidGemFrames              -
+								 g_OnuGponOutPm.gem.receivedValidGemFrames;
+	gemPm->gemRxUndefinedGemFrames                         = inCounters.receivedUndefinedGemFrames          -
+								 g_OnuGponOutPm.gem.receivedUndefinedGemFrames;
+	gemPm->gemRxOmciFrames                                 = inCounters.receivedOmciFrames                  -
+								 g_OnuGponOutPm.gem.receivedOmciFrames;
+	gemPm->gemRxDroppedGemFrames                           = inCounters.droppedGemFrames                    -
+								 g_OnuGponOutPm.gem.droppedGemFrames;
+	gemPm->gemRxDroppedOmciFrames                          = inCounters.droppedOmciFrames                   -
+								 g_OnuGponOutPm.gem.droppedOmciFrames;
+	gemPm->gemRxGemFramesWithUncorrHecErr                  = inCounters.receivedGemFramesWithUncorrHecErr   -
+								 g_OnuGponOutPm.gem.receivedGemFramesWithUncorrHecErr;
+	gemPm->gemRxGemFramesWithOneFixedHecErr                = inCounters.receivedGemFramesWithOneFixedHecErr -
+								 g_OnuGponOutPm.gem.receivedGemFramesWithOneFixedHecErr;
+	gemPm->gemRxGemFramesWithTwoFixedHecErr                = inCounters.receivedGemFramesWithTwoFixedHecErr -
+								 g_OnuGponOutPm.gem.receivedGemFramesWithTwoFixedHecErr;
+	gemPm->gemRxTotalByteCountOfReceivedValidGemFrames     = inCounters.totalByteCountOfReceivedValidGemFrames     -
+								 g_OnuGponOutPm.gem.totalByteCountOfReceivedValidGemFrames;
+	gemPm->gemRxTotalByteCountOfReceivedUndefinedGemFrames = inCounters.totalByteCountOfReceivedUndefinedGemFrames -
+								 g_OnuGponOutPm.gem.totalByteCountOfReceivedUndefinedGemFrames;
+	gemPm->gemRxGemReassembleMemoryFlush                   = inCounters.gemReassembleMemoryFlush            -
+								 g_OnuGponOutPm.gem.gemReassembleMemoryFlush;
+	gemPm->gemRxGemSynchLost                               = inCounters.gemSynchLost                        -
+								 g_OnuGponOutPm.gem.gemSynchLost;
+	gemPm->gemRxEthFramesWithCorrFcs                       = inCounters.receivedEthFramesWithCorrFcs        -
+								 g_OnuGponOutPm.gem.receivedEthFramesWithCorrFcs;
+	gemPm->gemRxEthFramesWithFcsError                      = inCounters.receivedEthFramesWithFcsError       -
+								 g_OnuGponOutPm.gem.receivedEthFramesWithFcsError;
+	gemPm->gemRxOmciFramesWithCorrCrc                      = inCounters.receivedOmciFramesWithCorrCrc       -
+								 g_OnuGponOutPm.gem.receivedOmciFramesWithCorrCrc;
+	gemPm->gemRxOmciFramesWithCrcError                     = inCounters.receivedOmciFramesWithCrcError      -
+								 g_OnuGponOutPm.gem.receivedOmciFramesWithCrcError;
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.gem.receivedIdleGemFrames                      = inCounters.receivedIdleGemFrames;
+		g_OnuGponOutPm.gem.receivedValidGemFrames                     = inCounters.receivedValidGemFrames;
+		g_OnuGponOutPm.gem.receivedUndefinedGemFrames                 = inCounters.receivedUndefinedGemFrames;
+		g_OnuGponOutPm.gem.receivedOmciFrames                         = inCounters.receivedOmciFrames;
+		g_OnuGponOutPm.gem.droppedGemFrames                           = inCounters.droppedGemFrames;
+		g_OnuGponOutPm.gem.droppedOmciFrames                          = inCounters.droppedOmciFrames;
+		g_OnuGponOutPm.gem.receivedGemFramesWithUncorrHecErr          = inCounters.receivedGemFramesWithUncorrHecErr;
+		g_OnuGponOutPm.gem.receivedGemFramesWithOneFixedHecErr        = inCounters.receivedGemFramesWithOneFixedHecErr;
+		g_OnuGponOutPm.gem.receivedGemFramesWithTwoFixedHecErr        = inCounters.receivedGemFramesWithTwoFixedHecErr;
+		g_OnuGponOutPm.gem.totalByteCountOfReceivedValidGemFrames     = inCounters.totalByteCountOfReceivedValidGemFrames;
+		g_OnuGponOutPm.gem.totalByteCountOfReceivedUndefinedGemFrames = inCounters.totalByteCountOfReceivedUndefinedGemFrames;
+		g_OnuGponOutPm.gem.gemReassembleMemoryFlush                   = inCounters.gemReassembleMemoryFlush;
+		g_OnuGponOutPm.gem.gemSynchLost                               = inCounters.gemSynchLost;
+		g_OnuGponOutPm.gem.receivedEthFramesWithCorrFcs               = inCounters.receivedEthFramesWithCorrFcs;
+		g_OnuGponOutPm.gem.receivedEthFramesWithFcsError              = inCounters.receivedEthFramesWithFcsError;
+		g_OnuGponOutPm.gem.receivedOmciFramesWithCorrCrc              = inCounters.receivedOmciFramesWithCorrCrc;
+		g_OnuGponOutPm.gem.receivedOmciFramesWithCrcError             = inCounters.receivedOmciFramesWithCrcError;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemTxCounterGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is used to retrieve and clear (if requested) ONU
+**               Tx counters
+**
+**  PARAMETERS:  S_TxApiPm *txPm
+**               MV_BOOL       a_clear
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemTxCounterGet(S_GponIoctlGemTxPm *txPm, MV_BOOL a_clear)
+{
+	MV_STATUS rcode;
+	S_GponTxPm inCounters;
+	MV_U32 tcont;
+	MV_BOOL exist;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiTxCounterGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponPmTxPmGet(&inCounters);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiTxCounterGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	txPm->gemTxGemPtiTypeOneFrames  = inCounters.transmittedGemPtiTypeOneFrames  - g_OnuGponOutPm.tx.transmittedGemPtiTypeOneFrames;
+	txPm->gemTxGemPtiTypeZeroFrames = inCounters.transmittedGemPtiTypeZeroFrames - g_OnuGponOutPm.tx.transmittedGemPtiTypeZeroFrames;
+	txPm->gemTxIdleGemFrames        = inCounters.transmittedIdleGemFrames        - g_OnuGponOutPm.tx.transmittedIdleGemFrames;
+
+	for (tcont = 0; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+		rcode = onuGponDbBwTcontExist(tcont, &exist);
+		if ((rcode == MV_OK) && (exist != MV_FALSE)) {
+			txPm->gemTxEthFramesViaTconti[tcont]     = inCounters.transmittedEthFramesViaTconti[tcont]     - g_OnuGponOutPm.tx.transmittedEthFramesViaTconti[tcont];
+			txPm->gemTxEthBytesViaTconti[tcont]      = inCounters.transmittedEthBytesViaTconti[tcont]      - g_OnuGponOutPm.tx.transmittedEthBytesViaTconti[tcont];
+			txPm->gemTxGemFramesViaTconti[tcont]     = inCounters.transmittedGemFramesViaTconti[tcont]     - g_OnuGponOutPm.tx.transmittedGemFramesViaTconti[tcont];
+			txPm->gemTxIdleGemFramesViaTconti[tcont] = inCounters.transmittedIdleGemFramesViaTconti[tcont] - g_OnuGponOutPm.tx.transmittedIdleGemFramesViaTconti[tcont];
+		}
+	}
+
+	if (a_clear == MV_TRUE) {
+		g_OnuGponOutPm.tx.transmittedGemPtiTypeOneFrames    = inCounters.transmittedGemPtiTypeOneFrames;
+		g_OnuGponOutPm.tx.transmittedGemPtiTypeZeroFrames   = inCounters.transmittedGemPtiTypeZeroFrames;
+		g_OnuGponOutPm.tx.transmittedIdleGemFrames          = inCounters.transmittedIdleGemFrames;
+
+		for (tcont = 0; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+			rcode = onuGponDbBwTcontExist(tcont, &exist);
+			if ((rcode == MV_OK) && (exist != MV_FALSE)) {
+				g_OnuGponOutPm.tx.transmittedEthFramesViaTconti[tcont]     = inCounters.transmittedEthFramesViaTconti[tcont];
+				g_OnuGponOutPm.tx.transmittedEthBytesViaTconti[tcont]      = inCounters.transmittedEthBytesViaTconti[tcont];
+				g_OnuGponOutPm.tx.transmittedGemFramesViaTconti[tcont]     = inCounters.transmittedGemFramesViaTconti[tcont];
+				g_OnuGponOutPm.tx.transmittedIdleGemFramesViaTconti[tcont] = inCounters.transmittedIdleGemFramesViaTconti[tcont];
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiResetAllCtr
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset all ONU PM information
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponApiResetAllCtr(void)
+{
+	onuGponPmInPmInit();                                    /* reset pm counters */
+	onuGponBerClear();                                      /* reset ber counters */
+	memset(&(g_OnuGponOutPm), 0, sizeof(g_OnuGponOutPm));   /* reset api counters */
+}
+
+/*******************************************************************************
+**
+**  onuGponApiBurstConfigSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures ONU TX Burst enable parameters
+**
+**  PARAMETERS:  S_apiBurstConfig *burstConfigSet
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiBurstConfigSet(S_apiBurstConfig *burstConfigSet)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiBurstConfigSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = mvOnuGponMacTxBurstEnParamSet(burstConfigSet->mask,
+					      burstConfigSet->polarity,
+					      burstConfigSet->order,
+					      burstConfigSet->stop,
+					      burstConfigSet->start);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiPmRxStandardPmGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiBurstConfigGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves ONU TX Burst enable parameters
+**
+**  PARAMETERS:  S_apiBurstConfig *burstConfigSet
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiBurstConfigGet(S_apiBurstConfig *burstConfigGet)
+{
+	MV_STATUS rcode;
+	MV_U32 mask;
+	MV_U32 polarity;
+	MV_U32 order;
+	MV_U32 stop;
+	MV_U32 start;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiBurstConfigGet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = mvOnuGponMacTxBurstEnParamGet(&mask, &polarity, &order, &stop, &start);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiBurstConfigGet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	burstConfigGet->start    = start;
+	burstConfigGet->stop     = stop;
+	burstConfigGet->order    = order;
+	burstConfigGet->polarity = polarity;
+	burstConfigGet->mask     = mask;
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiExtendedBurstSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to override ONU Type 3 preamble
+**               bytes assigned from the OLT with input values
+**
+**  PARAMETERS:  MV_BOOL   enable
+**               MV_U32 range
+**               MV_U32 oper
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiExtendedBurstSet(MV_BOOL enable, MV_U32 range, MV_U32 oper)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiExtendedBurstSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbExtendedBurstOverrideSet(enable);
+	rcode |= onuGponDbExtendedBurstOverrideValueSet(range, oper);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiExtendedBurstSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiExtendedBurstDelaySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to add configured delay to ONU Type 3 preamble
+**               bytes assigned from the OLT with input values
+**
+**  PARAMETERS:  MV_BOOL enable
+**               MV_U32  syncDel
+**               MV_U32  operDel
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiExtendedBurstDelaySet(MV_BOOL enable, MV_U32 syncDel, MV_U32 operDel)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiExtendedBurstDelaySet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbExtendedBurstDelayAddSet(enable);
+	rcode |= onuGponDbExtendedBurstDelayValueSet(syncDel, operDel);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiExtendedBurstDelaySet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiDelimiterSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to override ONU delimiter
+**               assigned from the OLT with input value
+**
+**  PARAMETERS:  MV_BOOL   enable
+**               MV_U32 delimiter
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiDelimiterSet(MV_BOOL enable, MV_U32 delimiter)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiDelimiterSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbDelimiterOverrideSet(enable);
+	rcode |= onuGponDbDelimiterOverrideValueSet(delimiter);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiDelimiterSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOnuIdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to override ONU ID assigned
+**               from the OLT with input value
+**
+**  PARAMETERS:  MV_BOOL   enable
+**               MV_U32 onuId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOnuIdSet(MV_BOOL enable, MV_U32 onuId)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiOnuIdSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbOnuIdOverrideSet(enable);
+	rcode |= onuGponDbOnuIdOverrideValueSet(onuId);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiOnuIdSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOmccPortIdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to override ONU OMCC assigned
+**               from the OLT with input value
+**
+**  PARAMETERS:  MV_BOOL   enable
+**               MV_U32 portId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOmccPortIdSet(MV_BOOL enable, MV_U32 portId)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiOmccPortIdSet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbOmccPortOverrideSet(enable);
+	rcode |= onuGponDbOmccPortOverrideValueSet(portId);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiOmccPortIdSet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiEqualizationDelaySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable to override ONU Equalization
+**               Delay measured and assigned from the OLT with input value
+**
+**  PARAMETERS:  MV_BOOL   enable
+**               MV_U32 eqD
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiEqualizationDelaySet(MV_BOOL enable, MV_U32 eqD)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiEqualizationDelaySet\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbEqualizationDelayOverrideSet(enable);
+	rcode |= onuGponDbEqualizationDelayOverrideValueSet(eqD);
+
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiEqualizationDelaySet", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiEqualizationDelayChange
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enables changes in the ONU Equalization Delay
+**
+**  PARAMETERS:  MV_U32 direction
+**               MV_U32 size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiEqualizationDelayChange(MV_U32 direction, MV_U32 size)
+{
+	MV_U32 eqD;
+	MV_U32 newEqD;
+	MV_U32 newFinalEqD;
+	MV_U32 onuState = onuGponDbOnuStateGet();
+	MV_U8 onuId;
+	MV_U8 newEqDelay[5];
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiEqualizationDelayChange\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	if (onuState != ONU_GPON_05_OPERATION) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) EqD change failed. EqD can only be changed in state 05\n",
+			   __FILE_DESC__, __LINE__);
+		return MV_OK;
+	}
+	eqD    = onuGponDbEqualizationDelayGet();
+	newEqD = (direction == 1) ? eqD + size : eqD - size;
+	newFinalEqD = M_ONU_GPON_RANG_MSG_FINAL_DELAY(newEqD);
+
+	if (newFinalEqD < GPON_TX_FINAL_DELAY_MIN || newFinalEqD > GPON_TX_FINAL_DELAY_MAX) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) EqD change failed. New Final eqD value is out of range\n",
+			   __FILE_DESC__, __LINE__);
+		return MV_OK;
+	}
+
+	newEqDelay[4] = newEqD & 0xFF;        /* LSB */
+	newEqDelay[3] = (newEqD >> 8) & 0xFF;
+	newEqDelay[2] = (newEqD >> 16) & 0xFF;
+	newEqDelay[1] = (newEqD >> 24) & 0xFF; /* MSB */
+
+	onuId = onuGponDbOnuIdGet();
+	onuGponPonMngPloamProcess(onuId, ONU_GPON_DS_MSG_RANGING_TIME, newEqDelay);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiSnMaskConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure sn mask
+**
+**  PARAMETERS:  MV_BOOL enable
+**               MV_BOOL match
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiSnMaskConfig(MV_BOOL enable, MV_BOOL match)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiSnMaskConfig\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode  = onuGponDbSnMaskSet(enable);
+	rcode |= onuGponDbSerialNumberMaskEnableSet(enable);
+	rcode |= onuGponDbSerialNumberMaskMatchSet(match);
+
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiSnMaskConfig\n", __FILE_DESC__, __LINE__);
+
+	return rcode;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         GEM Port PM Section                                */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortPmConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures HW so that MIB Counter PM is activated
+**               for a GEM port
+**
+**  PARAMETERS:  S_GponIoctlGemPortPmConfig *
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortPmConfig(S_GponIoctlGemPortPmConfig *gponIoctlGemPortPmConfig)
+{
+	MV_STATUS rcode = MV_ERROR;
+
+	if (gponIoctlGemPortPmConfig->gem_port > GPON_MAX_GEMPORTID) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, portId(%d) invalid\n", __FILE_DESC__, __LINE__, gponIoctlGemPortPmConfig->gem_port);
+		return MV_BAD_PARAM;
+	}
+
+	if (!(gponIoctlGemPortPmConfig->direction == GEMPORTPMDIRECTION_BIDI ||
+	      gponIoctlGemPortPmConfig->direction == GEMPORTPMDIRECTION_DS   ||
+	      gponIoctlGemPortPmConfig->direction == GEMPORTPMDIRECTION_US)) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, direction(%d) invalid\n", __FILE_DESC__, __LINE__,
+			   gponIoctlGemPortPmConfig->direction);
+		return MV_BAD_PARAM;
+	}
+
+	if (gponIoctlGemPortPmConfig->command == GEMPORTPMCMD_START)
+		rcode = onuGponPmGemPortPmStart(gponIoctlGemPortPmConfig->gem_port,
+		gponIoctlGemPortPmConfig->direction);
+	else if (gponIoctlGemPortPmConfig->command == GEMPORTPMCMD_STOP)
+		rcode = onuGponPmGemPortPmStop(gponIoctlGemPortPmConfig->gem_port,
+			gponIoctlGemPortPmConfig->direction);
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves MIB Counter PM for GEM Port
+**
+**  PARAMETERS:  S_GponIoctlGemPortMibCounters *
+**
+**  OUTPUTS:     MIB counters copied
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortPmGet(S_GponIoctlGemPortMibCounters *gemPortMibCounters)
+{
+	MV_STATUS rcode = MV_OK;
+
+	if (gemPortMibCounters->gem_port > GPON_MAX_GEMPORTID) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, portId(%d) invalid\n", __FILE_DESC__, __LINE__, gemPortMibCounters->gem_port);
+		return MV_BAD_PARAM;
+	}
+	if (!(gemPortMibCounters->direction == GEMPORTPMDIRECTION_BIDI ||
+	      gemPortMibCounters->direction == GEMPORTPMDIRECTION_DS ||
+	      gemPortMibCounters->direction == GEMPORTPMDIRECTION_US)) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, direction(%d) invalid\n", __FILE_DESC__, __LINE__, gemPortMibCounters->direction);
+		return MV_BAD_PARAM;
+	}
+
+	rcode = onuGponPmGemPortPmGet(gemPortMibCounters);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortPmReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Reset MIB Counter PM for GEM Port
+**
+**  PARAMETERS:  S_GponIoctlGemPortMibCounters *
+**
+**  OUTPUTS:     MIB counters copied
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortPmReset(void)
+{
+	MV_STATUS rcode = MV_OK;
+
+	rcode = onuGponPmGemPortPmReset();
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiUponDebugSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Set UPON debug flag
+**
+**  PARAMETERS:  MV_U32 mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void      onuGponApiUponDebugSet(MV_U32 mode)
+{
+	g_UponDebugMode = mode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiUponDebugGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Get UPON debug flag
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuGponApiUponDebugGet(void)
+{
+	return g_UponDebugMode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiDgCallbackRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Dying Gasp callback function
+**
+**  PARAMETERS:  DYINGGASPFUNC dgCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiDgCallbackRegister(DYINGGASPFUNC dgCallBack)
+{
+	MV_STATUS status;
+
+	status = onuGponDbDgCallbackSet(dgCallBack);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponDbDgCallbackSet", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiLinkStatusCallbackRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Link Status callback function
+**
+**  PARAMETERS:  LINKSTATUSFUNC linkStatusCallBack
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponApiLinkStatusCallbackRegister(void)
+{
+	struct mv_eth_ext_mac_ops *ptr_pon_mac_ops;
+	struct mv_netdev_notify_ops *ptr_netdev_ops;
+
+	gpon_mac_ops.link_status_get = onuGponLinkIsUp;
+	gpon_mac_ops.max_pkt_size_set = onuGponMtuCfg;
+	gpon_mac_ops.mac_addr_set = NULL;
+	gpon_mac_ops.mib_counters_show = NULL;
+	gpon_mac_ops.port_disable = onuGponApiAdminDownSet;
+	gpon_mac_ops.port_enable = onuGponApiAdminUpSet;
+
+	ptr_pon_mac_ops = &gpon_mac_ops;
+
+	mv_eth_ext_mac_ops_register(MV_PON_LOGIC_PORT_GET(), &ptr_pon_mac_ops, &ptr_netdev_ops);
+
+	onuGponDb_s.onuGponGenTbl_s.onuLinkStatusCallback = ptr_netdev_ops->link_notify;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponLinkIsUp
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function register Link Status callback function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_BOOL onuGponLinkIsUp(int port_id)
+{
+	if (onuGponDbOnuStateGet() == ONU_GPON_05_OPERATION)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuGponMtuCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config MTU size
+**
+**  PARAMETERS:  MV_U32 maxEthFrame
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS onuGponMtuCfg(int port_id, MV_U32 maxEthFrame)
+{
+	MV_STATUS status;
+
+	status = mvOnuGponMacGemEthFrameLenSet(maxEthFrame, GPON_MIN_ETH_FRAME_LEN);
+	if (status != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponMtuCfg eth failed\n", __FILE_DESC__, __LINE__);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiAdminUpSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enables pon port
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAdminUpSet(int port_id)
+{
+	MV_STATUS status;
+
+	/* Enable MAC RX */
+	status = mvOnuGponMacRxConfigSet(MV_TRUE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAdminUpSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Enable MAC TX - via SERDES */
+	status = onuGponAdminStateSet(0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAdminUpSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* set onu to port state up */
+	onuGponDbOnuGponPortStateSet(ONU_PON_PORT_UP);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiAdminDownSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function disables pon port
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAdminDownSet(int port_id)
+{
+	MV_STATUS status;
+
+	/* set onu to port state down */
+	onuGponDbOnuGponPortStateSet(ONU_PON_PORT_DOWN);
+
+	/* Disable MAC RX */
+	status = mvOnuGponMacRxConfigSet(MV_FALSE);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAdminDownSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Disable MAC TX - via SERDES */
+	status = onuGponAdminStateSet(1);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponApiAdminDownSet\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiAdminStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure PON Admin state
+**
+**  PARAMETERS:  MV_U32 mode 0-Enable, 1 Disable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiAdminStateSet(MV_U32 mode)
+{
+	return onuGponAdminStateSet(mode);
+}
+
+/*******************************************************************************
+**
+**  onuGponApiFecStatusGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return FEC Status
+**
+**  PARAMETERS:  MV_U32 fecStatus 0-Off, 1-On
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiFecStatusGet(MV_U32 *fecMode)
+{
+	return mvOnuGponMacRxFecStatusGet(fecMode);
+}
+
+/*******************************************************************************
+**
+**  mvGponAipCouplingModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures the coupling mode
+**
+**  PARAMETERS:  MV_U32 couplingMode 0 : DC, 1 : AC
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiCouplingModeSet(MV_U32 couplingMode)
+{
+	MV_STATUS status;
+	MV_U32 familyId;
+	MV_U32 burstMode = 0;
+	MV_U32 burstTime = 0;
+	MV_U8 dataPattern1 = 0;
+	MV_U8 dataPattern2 = 0;
+
+	familyId = mvCtrlModelGet();
+	if (familyId != MV_88F66X0)
+		return MV_OK;
+
+	if (couplingMode == 1) { /* AC coupling mode */
+		burstMode = GPON_TX_AC_COUPL_BUST_MODE_0;
+		burstTime = GPON_TX_AC_COUPL_PREACT_BURST_TIME;
+		dataPattern1 = GPON_TX_AC_COUPL_DATA_PATTERN_1;
+		dataPattern2 = GPON_TX_AC_COUPL_DATA_PATTERN_2;
+	}
+
+	status = mvOnuGponMacTxConfigAcCouplingSet(burstMode, burstTime, dataPattern1, dataPattern2);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiSerialNumberSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the ONU serial number.
+**
+**  INPUTS     : MV_U8 *sn: Serial number.
+**
+**  OUTPUTS    : None
+**
+**  RETURNS    : MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiSerialNumberSet(MV_U8 *sn)
+{
+	MV_STATUS status;
+
+	status = onuGponSrvcSerialNumberSet(sn);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPasswordSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the ONU password.
+**
+**  INPUTS     : MV_U8 *pwd: Password.
+**
+**  OUTPUTS    : None
+**
+**  RETURNS    : MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPasswordSet(MV_U8 *pwd)
+{
+	MV_STATUS status;
+
+	status = onuGponDbPasswordSet(pwd);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortEncryptSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets encrypt for GEM port.
+**
+**  INPUTS     : MV_U32 gem: GEM port ID.
+**               MV_U8 enable: Enable or disable the encrypt of GEM port.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortEncryptSet(MV_U32 gem, MV_U8 enable)
+{
+	MV_STATUS ret = 0;
+
+	if (enable == MV_TRUE) {
+		if (onuGponDbGemPortValidGet(gem) != MV_TRUE) {
+			/* Gem port was not yet configured,
+			   so avoid updating the HW and "just" mark the SW */
+			onuGponDbGemPortAesSet(gem, enable);
+
+			return ret;
+		}
+	}
+
+	ret = mvOnuGponMacAesPortIdSet(gem, enable);
+
+	ret |= onuGponDbGemPortAesSet(gem, enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiGemPortAdKeyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets ONU encryption key.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MV_U8 *key: ONU encryption key.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiGemPortAdKeyGet(MV_U8 *key)
+{
+	MV_STATUS ret = 0;
+
+	ret = onuGponDbEncryptionKeyGet(key);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOpticalTxEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU optical TX enabled or disabled.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable optical TX.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOpticalTxEnableSet(MV_BOOL enable)
+{
+	MV_STATUS ret = 0;
+
+	ret = onuPonTxPowerOn(enable);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOpticalRxEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU optical RX enabled or disabled.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable optical RX.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOpticalRxEnableSet(MV_BOOL enable)
+{
+	MV_STATUS ret = 0;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiSfSdThresholdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the threshold value of SF and SD.
+**
+**  INPUTS     : MV_U8 sf: The threshold of SF.
+**               MV_U8 sd: The threshold of SD.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiSfSdThresholdSet(MV_U8 sf, MV_U8 sd)
+{
+	MV_STATUS ret = 0;
+
+	ret = onuGponApiBerThresholdConfig(sd, sf);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiPattenBurstSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function start TX transmissions of a selected pattern
+**               as periodic or static burst.
+**
+**  INPUTS     : MV_U32 pattern : 0x1-1T, 0x2-2T,
+**                                0x80-RPBS-9, 0x82-RPBS-15, 0x83-RPBS-23.
+**               MV_BOOL burst  : 0-static, 1-periodic.
+**               MV_U32 duration: Peak time interval[micro seconds].
+**               MV_U32 period  : Full cycle time interval[micro seconds].
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiPattenBurstSet(MV_U32 pattern, MV_BOOL burst,
+				   MV_U32 duration, MV_U32 period)
+{
+	MV_STATUS ret = 0;
+
+	ret = onuPonPatternBurstOn(pattern, burst, period, duration);
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiO7StateEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets ONU O7 state enabled or disabled.
+**
+**  INPUTS     : MV_U8 enable: Enable or disable O7 state.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiO7StateEnableSet(MV_U8 enable)
+{
+	MV_STATUS ret = 0;
+	MV_STATUS rcode;
+	MV_U32 onuState;
+
+	onuState = onuGponDbOnuStateGet();
+
+	/* Disable */
+	if ((enable == 0) && (onuState != ONU_GPON_07_EMERGANCY_STOP)) {
+		onuPonTxPowerOn(MV_FALSE);
+
+		/* clear onu information */
+		/* ===================== */
+		rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_NONE);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngClearOnuInfo\n", __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+
+		/* clear GEM ports */
+		/* =============== */
+		rcode = onuGponApiGemClearAll(onuGponDbGemRestoreGet());
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponApiGemClearAll\n", __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+
+		/* alarm handling */
+		/* ============== */
+		onuGponAlarmSet(ONU_GPON_ALARM_DIS, ONU_GPON_ALARM_ON);
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_07_EMERGANCY_STOP);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngrUpdateState(7)\n",
+				   __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=========================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== ONT ENTERS O7 STATE ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=========================\n");
+
+		if (g_onuGponDisableFunc != NULL)
+			g_onuGponDisableFunc(MV_TRUE);
+
+		/* Send Disable Notification to upper layer and save parameter */
+		onuGponSrvcDisableMsgNotify(MV_TRUE, MV_TRUE);
+
+		/* If was ranged then now ont is not ranged - send status notification */
+		if (onuState == ONU_GPON_05_OPERATION)
+			onuGponSrvcStatusNotify(GPON_ONU_STATUS_NOT_RANGED);
+	} else if ((enable == 1) && (onuState == ONU_GPON_07_EMERGANCY_STOP)) {
+		onuPonTxPowerOn(MV_TRUE);
+
+		/* alarm handling */
+		/* ============== */
+		onuGponAlarmSet(ONU_GPON_ALARM_DIS, ONU_GPON_ALARM_OFF);
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngrUpdateState(2)\n",
+				   __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=========================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== ONT LEAVES O7 STATE ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=========================\n");
+
+		if (g_onuGponDisableFunc != NULL)
+			g_onuGponDisableFunc(MV_FALSE);
+
+		onuGponSrvcDisableMsgNotify(MV_FALSE, MV_TRUE);
+
+		/* Restore saved GEM ports */
+		if (onuGponDbGemRestoreGet() == MV_TRUE) {
+			rcode = onuGponApiGemRestoreAll();
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) DISABLE: onuGponApiGemRestoreAll\n",
+					   __FILE_DESC__, __LINE__);
+				return rcode;
+			}
+		}
+	}
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOperationStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets ONU operation state.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MV_U8 *state: Operation state.
+**                             1~7 - O1~O7
+**
+**  RETURNS    : MV_OK or MV_ERROR.
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOperationStateGet(MV_U8 *state)
+{
+	MV_STATUS ret = 0;
+	MV_U32 currentState;
+
+	currentState = onuGponDbOnuStateGet();
+
+	*state =  (MV_U8)currentState;
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOmciChannelAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds OMCI API channel
+**
+**  PARAMETERS:  MV_U16 gemPort
+**               MV_U8  rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOmciChannelAdd(MV_U16 gemPort, MV_U8 rxCpuQueue)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiOmciChannelAdd\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponOmciChannelAdd(gemPort, rxCpuQueue);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiOmciChannelAdd", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiOmciChannelDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes OMCI API channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiOmciChannelDel(void)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_API_MODULE,
+		   "DEBUG: (%s:%d) onuGponApiOmciChannelDel\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	rcode = onuGponOmciChannelDel();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) onuGponApiOmciChannelDel", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiHighPriTxStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure high priority TX state
+**
+**  PARAMETERS:  MV_U32 mode MV_TRUE-Enable, MV_FALSE-Disable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiHighPriTxStateSet(MV_BOOL mode)
+{
+	MV_STATUS rcode;
+
+	/* Do nothig in case the state is not changed */
+	if (mode == onuGponDbHighPriTxStateGet()) {
+		mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+			   "INFO: (%s:%d) PON high pri TX state is the same, do nothing",
+			   __FILE_DESC__, __LINE__);
+		return MV_OK;
+	}
+
+	/* Set HW for high priority TX */
+	rcode = mvOnuGponHighPriTxEnableSet(MV_BOOL_TO_INT(mode));
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX to HW\n");
+
+	/* update DB */
+	rcode = onuGponDbHighPriTxStateSet(mode);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX to DB\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiHighPriTxMapAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds high priority TX map
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiHighPriTxMapAdd(S_OnuTcontMap *tcontMap)
+{
+	MV_STATUS rcode;
+
+	/* checking */
+	rcode = onuGponDbHighPriTxMapCheck(tcontMap);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to check new high pri Tx map\n");
+
+	/* set HW for high priority TX map*/
+	rcode = onuGponHighPriTxMapAdd(tcontMap);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX map to HW\n");
+
+	/* update DB */
+	rcode = onuGponDbHighPriTxMapSet(tcontMap);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to set high priority TX map to DB\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponApiHighPriTxMapDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes high priority TX map
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponApiHighPriTxMapDel(MV_U32 hostTcont)
+{
+	S_OnuTcontMap tcontMap;
+	MV_STATUS rcode;
+
+	/* validation */
+	PON_POS_RANGE_VALIDATE(PON_API_MODULE, hostTcont, ONU_GPON_MAX_NUM_OF_T_CONTS - 1, "Invalid host T-CONT");
+
+	/* get high priority TX map from DB */
+	tcontMap.hostTcont = hostTcont;
+	rcode = onuGponDbHighPriTxMapGet(&tcontMap);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to get high priority TX map from DB\n");
+
+	/* delete high priority TX map from HW */
+	rcode = onuGponHighPriTxMapDel(tcontMap.hostTcont);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to delete high priority TX map from HW\n");
+
+	/* update DB */
+	rcode = onuGponDbHighPriTxMapDel(hostTcont);
+	PON_IF_ERROR(PON_API_MODULE, rcode, "fail to delete high priority TX map from DB\n");
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.h
new file mode 100644
index 0000000..a47346f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuApi.h
@@ -0,0 +1,314 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuApi.h                                                **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON API definitions                **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_API_H
+#define _ONU_GPON_API_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define GPON_ONU_ITEM_NOT_CONIGURED             (0xFFFFFFFF)
+
+#define GPON_MAX_GEMPORTID                      (4095)
+
+/* Notify Types */
+#define GPON_NOTIFY_OPERATION                   (0)
+#define GPON_NOTIFY_ALARM                       (1)
+#define GPON_NOTIFY_OMCC                        (2)
+
+/* Counter Sizes */
+#define GPON_ONU_RX_PLOAM_CNT_SIZE              (21)
+#define GPON_ONU_TX_PLOAM_CNT_SIZE              (10)
+
+/* Operational Statuses */
+#define GPON_ONU_STATUS_DISCONNECTED            (0)             /* No Downstream sync */
+#define GPON_ONU_STATUS_NOT_RANGED              (1)             /* Downstream sync, not ranged */
+#define GPON_ONU_STATUS_RANGED                  (2)             /* Ranged */
+#define GPON_ONU_STATUS_DG                      (3)
+#define GPON_ONU_STATUS_MAX                     (GPON_ONU_STATUS_DG)
+
+/* Alarms */
+#define GPON_ONU_ALARM_LOS                      (0)
+#define GPON_ONU_ALARM_LOF                      (1)
+#define GPON_ONU_ALARM_LCDA                     (2)
+#define GPON_ONU_ALARM_LCDG                     (3)
+#define GPON_ONU_ALARM_SF                       (4)
+#define GPON_ONU_ALARM_SD                       (5)
+#define GPON_ONU_ALARM_TF                       (6)
+#define GPON_ONU_ALARM_SUF                      (7)
+#define GPON_ONU_ALARM_MEM                      (8)
+#define GPON_ONU_ALARM_DACT                     (9)
+#define GPON_ONU_ALARM_DIS                      (10)
+#define GPON_ONU_ALARM_MIS                      (11)
+#define GPON_ONU_ALARM_PEE                      (12)
+#define GPON_ONU_ALARM_RDI                      (13)
+
+#define GPON_ONU_ALARM_STATUS_OFF               (0)
+#define GPON_ONU_ALARM_STATUS_ON                (1)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Structs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U8 password[10];
+	MV_U8 serialNumber[8];
+	MV_U32 onuId;
+	MV_U32 state;
+	MV_U32 sdThreshold;
+	MV_U32 sfThreshold;
+	MV_U32 localBerInterval;
+	MV_U32 remoteBerInterval;
+	MV_U32 omccPortId;
+	MV_U32 constDelay;
+	MV_U32 eqDelay;
+} S_OnuInfo;
+
+typedef struct {
+	MV_U32 bip8;
+	MV_U32 plend;
+} S_RxStandardApiPm;
+
+typedef struct {
+	MV_U32 start;
+	MV_U32 stop;
+	MV_U32 order;
+	MV_U32 polarity;
+	MV_U32 mask;
+} S_apiBurstConfig;
+
+typedef struct {
+	MV_BOOL valid;          /* whether this T-CONT mapping is valid        */
+	MV_U32 hostTcont;       /* host T-CONT                                 */
+	MV_U32 addTcont;        /* additional T-CONT associated w/ host T-CONT */
+} S_OnuTcontMap;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef void (*ALARMNOTIFYFUNC)(MV_U32 alarm, MV_U32 status);
+typedef void (*OMCCNOTIFYFUNC)(MV_U32 omccPortId);
+typedef void (*DISABLENOTIFYFUNC)(MV_BOOL disable);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiGemPortIdConfig(MV_U32 gemPortid);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Init API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiInit(MV_U8 *serialNumber,
+			 MV_U8 *password,
+			 MV_BOOL disabled,
+			 MV_U32 sn_src,
+			 MV_U32 fecHyst,
+			 MV_U32 couplingMode,
+			 MV_U32 omccRxQueue);
+
+/* Notify API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiStatusNotifyRegister(STATUSNOTIFYFUNC notifyCallBack);
+MV_STATUS onuGponApiAlarmNotifyRegister(ALARMNOTIFYFUNC notifyCallBack);
+MV_STATUS onuGponApiOmccNotifyRegister(OMCCNOTIFYFUNC notifyCallBack);
+MV_STATUS onuGponApiDisableNotifyRegister(DISABLENOTIFYFUNC notifyCallBack);
+
+/* Ber API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiBerThresholdConfig(MV_U32 sd, MV_U32 sf);
+MV_STATUS onuGponApiBerIntervalConfig(MV_U32 interval);
+MV_STATUS onuGponApiBerCoefficientConfig(MV_U32 denominator, MV_U32 numerator);
+
+/* Tcont API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiTcontConfig(MV_U32 allocId, MV_U32 tcontId);
+MV_STATUS onuGponApiTcontClear(MV_U32 tcontId);
+MV_STATUS onuGponApiTcontsReset(void);
+
+/* GEM API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiGemOmccIdConfig(MV_U32 gemPortid, MV_BOOL valid);
+MV_STATUS onuGponApiGemPortIdConfig(MV_U32 gemPortid);
+MV_STATUS onuGponApiGemPortIdClear(MV_U32 gemPortid);
+#ifdef MV_GPON_STATIC_GEM_PORT
+MV_STATUS onuGponApiGemPortIdStaticConfigReset(void);
+MV_STATUS onuGponApiGemPortIdStaticConfigFlag(MV_U32 flag);
+MV_STATUS onuGponApiGemConfig(MV_U32 *gemmap, E_GponIoctlGemAction action);
+MV_STATUS onuGponApiGemClearAll(MV_BOOL savePorts);
+MV_STATUS onuGponApiGemRestoreAll(void);
+#endif /* MV_GPON_STATIC_GEM_PORT */
+
+/* Information API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiInformationGet(S_OnuInfo *onuInfo);
+
+/* Alarm API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiAlarmsGet(MV_U32 *alarms);
+
+/* PM API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiPmFecPmGet(S_GponIoctlFecPm *fecPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiPmRxPloamPmGet(S_GponIoctlPloamRxPm *rxPloamPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiPmRxBwMapPmGet(S_GponIoctlBwMapPm *rxBwMapPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiPmRxBwMapPmDumpSet(MV_BOOL enable);
+void      onuGponApiPmRxBwMapPmDump(MV_U32 currstate, MV_U32 newstate);
+MV_STATUS onuGponApiAdvancedPloamsCounterGet(S_GponIoctlPloamTxPm *txPloamPm,
+					     S_GponIoctlPloamRxPm *rxPloamPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiGemRxCounterGet(S_GponIoctlGemRxPm *gemPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiGemTxCounterGet(S_GponIoctlGemTxPm *txPm, MV_BOOL a_clear);
+MV_STATUS onuGponApiPmRxStandardPmGet(S_RxStandardApiPm *rxStandardPm, MV_BOOL a_clear);
+
+/* Genral API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiBurstConfigSet(S_apiBurstConfig *burstConfigSet);
+MV_STATUS onuGponApiBurstConfigGet(S_apiBurstConfig *burstConfigGet);
+void      onuGponApiResetAllCtr(void);
+void      onuGponApiUponDebugSet(MV_U32 mode);
+MV_U32    onuGponApiUponDebugGet(void);
+MV_STATUS onuGponApiAdminStateSet(MV_U32 mode);
+MV_STATUS onuGponApiFecStatusGet(MV_U32 *fecMode);
+MV_STATUS onuGponApiCouplingModeSet(MV_U32 couplingMode);
+MV_STATUS onuGponApiSerialNumberSet(MV_U8 *sn);
+MV_STATUS onuGponApiPasswordSet(MV_U8 *pwd);
+MV_STATUS onuGponApiGemPortEncryptSet(MV_U32 gem, MV_U8 enable);
+MV_STATUS onuGponApiGemPortAdKeyGet(MV_U8 *key);
+MV_STATUS onuGponApiOpticalTxEnableSet(MV_BOOL enable);
+MV_STATUS onuGponApiOpticalRxEnableSet(MV_BOOL enable);
+MV_STATUS onuGponApiSfSdThresholdSet(MV_U8 sf, MV_U8 sd);
+MV_STATUS onuGponApiPattenBurstSet(MV_U32 pattern, MV_BOOL burst,
+				   MV_U32 duration, MV_U32 period);
+MV_STATUS onuGponApiO7StateEnableSet(MV_U8 enable);
+MV_STATUS onuGponApiOperationStateGet(MV_U8 *state);
+
+/* Sn Mask  API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiSnMaskConfig(MV_BOOL enable, MV_BOOL match);
+
+/* Interoperability API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiExtendedBurstSet(MV_BOOL enable, MV_U32 range, MV_U32 oper);
+MV_STATUS onuGponApiExtendedBurstDelaySet(MV_BOOL enable, MV_U32 syncDel, MV_U32 operDel);
+MV_STATUS onuGponApiDelimiterSet(MV_BOOL enable, MV_U32 delimiter);
+MV_STATUS onuGponApiOnuIdSet(MV_BOOL enable, MV_U32 onuId);
+MV_STATUS onuGponApiOmccPortIdSet(MV_BOOL enable, MV_U32 portId);
+MV_STATUS onuGponApiEqualizationDelaySet(MV_BOOL enable, MV_U32 eqD);
+MV_STATUS onuGponApiEqualizationDelayChange(MV_U32 direction, MV_U32 size);
+
+/* GEM Port MIB Counters PM  API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiGemPortPmConfig(S_GponIoctlGemPortPmConfig *ioctlGemPortPmConfig);
+MV_STATUS onuGponApiGemPortPmGet(S_GponIoctlGemPortMibCounters *ioctlGemPortMibCounters);
+MV_STATUS onuGponApiGemPortPmReset(void);
+
+/* Dying Gasp API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiDgCallbackRegister(DYINGGASPFUNC dgCallBack);
+
+/* Link status API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiLinkStatusCallbackRegister(void);
+MV_BOOL   onuGponLinkIsUp(int port_id);
+MV_STATUS onuGponMtuCfg(int port_id, MV_U32 maxEthFrame);
+MV_STATUS onuGponApiHwfCallbackRegister(DATAFORWARDFUNC *hwfCallback);
+MV_STATUS onuGponApiSwfCallbackRegister(DATAFORWARDFUNC *swfCallback);
+
+/* Admin API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiAdminUpSet(int port_id);
+MV_STATUS onuGponApiAdminDownSet(int port_id);
+
+/* OMCI channel API
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiOmciChannelAdd(MV_U16 gemPort, MV_U8 rxCpuQueue);
+MV_STATUS onuGponApiOmciChannelDel(void);
+
+/* High priority TX
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponApiHighPriTxStateSet(MV_BOOL mode);
+MV_STATUS onuGponApiHighPriTxMapAdd(S_OnuTcontMap *tcontMap);
+MV_STATUS onuGponApiHighPriTxMapDel(MV_U32 hostTcont);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_API_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.c
new file mode 100644
index 0000000..423db73
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.c
@@ -0,0 +1,518 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuBer.c                                               **
+**                                                                           **
+**  DESCRIPTION : This file implements the OLT GPON Bit Error Rate Mechanism **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuBer.c"
+
+#define PON_BER_PERIOD_LENGTH  (ONU_PON_TIMER_PM_INTERVAL)
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 g_numsOfPeriodInInterval;
+MV_U32 g_intervalSeconds;
+S_BerCoefficient g_berCoefficient;
+S_PonBer onuBer;
+
+/* Local Prototypes
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuGponBerInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu BER parameters
+**
+**  PARAMETERS:  S_BerCoefficient coefficient - the perdentage of the current BER in overall BER
+**			     MV_U32			  interval    - the interval of BER measures (seconds)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponBerInit(S_BerCoefficient *coefficient, MV_U32 interval)
+{
+	/* Keep how many periods pass before BER is checked */
+	g_numsOfPeriodInInterval     = (interval * 1000) / PON_BER_PERIOD_LENGTH;
+	g_intervalSeconds            = interval;
+	g_berCoefficient.numerator   = coefficient->numerator;
+	g_berCoefficient.denominator = coefficient->denominator;
+
+	onuGponBerClear();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerPeriodPass
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function calculate BER if interval expired
+**
+**  PARAMETERS:  S_BerCoefficient coefficient - the perdentage of the current BER in overall BER
+**			     MV_U32			  interval    - the interval of BER measures (seconds)
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponBerPeriodPass(MV_U32 inbip8Counter)
+{
+	onuBer.periodsCounter++;
+	onuBer.intervalBandwidth += ONU_GPON_DS_DEF_RATE;
+
+	/* Check if is BER caculating Time */
+	if (onuBer.periodsCounter < g_numsOfPeriodInInterval)
+		/* Do nothing */
+		return MV_OK;
+	else{
+		/* Need to calculate BER */
+		onuGponBerBerCaculate(inbip8Counter);
+		onuBer.periodsCounter = 0;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerBerCaculate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine Calculate the BER
+**  NIOS doen't support floating-point, so we need to pass that limit:
+**  We use this method OvarallBER(n) = Coefficient * IntervalBer(n) +
+**  (1 - Coefficient) * OvarallBER(n-1)
+**  Coefficient is structure of ( numerator / denominator )
+**  IntervalBer is Bip8Counter(Interval)/OverallBits(Interval)
+**  Since the lowest BER we'd like to measure is 10^(-10) (standard lowest
+**  value to Cacel SD condition), we shell multiple all values by 10^(10).
+**  The thresholds also will be multiple by 10^(10).
+**  The Ber calculation will be as the following (for 1.244 upstream rate):
+**
+**  Bip8Counter(Interval) x 10^11     Bip8Counter(Interval) x 10^11
+**  IntervalBer(n) = ---------------------------- = ---------------------------------
+**  OverallBits(Interval)        actual bits passed(Interval)
+**
+**  Bip8Counter(Interval) x 10^5
+**  = --------------------------------
+**   Mbits
+**
+**  (IntervalBer(n) x Coef.numerator) + (OverAllBer(n-1) x (Coef.denominator - Coef.numerator))
+**  OverAllBer(n) = -------------------------------------------------------------------------------------------
+**  Coef.denominator
+**
+**  PARAMETERS:	 MV_U32 inbip8Counter
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponBerBerCaculate(MV_U32 inbip8Counter)
+{
+	onuBer.intervalBip8ErrorsCounter = inbip8Counter - onuBer.outBip8Counter;
+	onuBer.newBer = (onuBer.intervalBip8ErrorsCounter * 100000) / onuBer.intervalBandwidth;
+
+	onuBer.ber = ((g_berCoefficient.numerator * onuBer.newBer) +
+		      ((g_berCoefficient.denominator - g_berCoefficient.numerator) * onuBer.ber)) /
+		      g_berCoefficient.denominator;
+
+	onuGponBerAlarmsCheck(onuBer.ber);
+	onuBer.outBip8Counter = inbip8Counter;
+	onuBer.intervalBandwidth = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerAlarmsCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine check the Ber Value and decide whether there is a
+**				 change in the alarms SD and SF condistion.
+**
+**  PARAMETERS:	 MV_U32 ber
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponBerAlarmsCheck(MV_U32 ber)
+{
+	MV_U32 sdThreshold;
+	MV_U32 sfThreshold;
+	MV_U32 sdDetectValue;
+	MV_U32 sdCancelValue;
+	MV_U32 sfDetectValue;
+	MV_U32 sfCancelValue;
+	MV_BOOL onuSd;
+	MV_BOOL onuSf;
+	MV_BOOL sd = MV_FALSE;
+	MV_BOOL sf = MV_FALSE;
+
+	/* Get curent alarm condition */
+	onuSf         = onuGponAlarmGet(ONU_GPON_ALARM_SF);
+	onuSd         = onuGponAlarmGet(ONU_GPON_ALARM_SD);
+
+	sfThreshold   = onuGponDbSfThresholdGet();
+	sdThreshold   = onuGponDbSdThresholdGet();
+
+	sdDetectValue = onuGponBerPower(10, (11 - sdThreshold));
+	sdCancelValue = onuGponBerPower(10, (11 - sdThreshold - 1));
+	sfDetectValue = onuGponBerPower(10, (11 - sfThreshold));
+	sfCancelValue = onuGponBerPower(10, (11 - sfThreshold - 1));
+
+	/* check Detect Alarm */
+	if (ber >= sfDetectValue)
+		sf = MV_TRUE;
+	else if (ber >= sdDetectValue)
+		sd = MV_TRUE;
+
+	/* check Cancel Alarm */
+	if (ber < sdCancelValue)
+		sd = MV_FALSE;
+	else if (ber < sfCancelValue)
+		sf = MV_FALSE;
+
+	if ((onuSf == MV_FALSE) && (onuSd == MV_FALSE)) {
+		if ((sd == MV_FALSE) && (sf == MV_TRUE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SF, MV_TRUE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SF, MV_TRUE);
+		} else if ((sd == MV_TRUE) && (sf == MV_FALSE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SD, MV_TRUE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SD, MV_TRUE);
+		}
+	} else if ((onuSf == MV_TRUE) && (onuSd == MV_FALSE)) {
+		if ((sd == MV_FALSE) && (sf == MV_FALSE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SF, MV_FALSE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SF, MV_FALSE);
+		} else if ((sd == MV_TRUE) && (sf == MV_FALSE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SD, MV_TRUE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SD, MV_TRUE);
+
+			onuGponAlarmSet(ONU_GPON_ALARM_SF, MV_FALSE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SF, MV_FALSE);
+		}
+	} else if ((onuSf == MV_FALSE) && (onuSd == MV_TRUE)) {
+		if ((sd == MV_FALSE) && (sf == MV_FALSE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SD, MV_FALSE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SD, MV_FALSE);
+		} else if ((sd == MV_FALSE) && (sf == MV_TRUE)) {
+			onuGponAlarmSet(ONU_GPON_ALARM_SD, MV_FALSE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SD, MV_FALSE);
+
+			onuGponAlarmSet(ONU_GPON_ALARM_SF, MV_TRUE);
+			onuGponSrvcAlarmNotify(ONU_GPON_ALARM_SF, MV_TRUE);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear all BER counters and thresholds
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponBerClear(void)
+{
+	onuBer.periodsCounter            = 0;
+	onuBer.intervalBip8ErrorsCounter = 0;
+	onuBer.ber                       = 0;
+	onuBer.newBer                    = 0;
+	onuBer.outBip8Counter            = 0;
+	onuBer.intervalBandwidth         = 0;
+
+	onuGponAlarmSet(ONU_GPON_ALARM_SD, MV_FALSE);
+	onuGponAlarmSet(ONU_GPON_ALARM_SF, MV_FALSE);
+}
+
+/*******************************************************************************
+**
+**  onuGponBerBip8CounterGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return bip8 counter
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     bip8 counter
+**
+*******************************************************************************/
+MV_U32 onuGponBerBip8CounterGet(void)
+{
+	MV_U32 counter;
+	S_RxBip8Pm inBip8Pm;
+
+	onuGponPmRxBip8PmGet(&inBip8Pm);
+	counter = inBip8Pm.bip8 - onuBer.outBip8Counter;
+
+	return counter;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerLastIntervalBip8CounterGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return bip8 counter of the last interval
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     bip8 counter
+**
+*******************************************************************************/
+MV_U32 onuGponBerLastIntervalBip8CounterGet(void)
+{
+	MV_U32 counter;
+
+	counter = onuBer.intervalBip8ErrorsCounter;
+
+	return counter;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerBerValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu ber
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu ber
+**
+*******************************************************************************/
+MV_U32 onuGponBerBerValueGet(void)
+{
+	return onuBer.ber;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerIntervalBerValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return ber interval value
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ber interval
+**
+*******************************************************************************/
+MV_U32 onuGponBerIntervalBerValueGet(void)
+{
+	return onuBer.newBer;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerCoefficientGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return ber coefficient
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ber coefficient
+**
+*******************************************************************************/
+S_BerCoefficient onuGponBerCoefficientGet(void)
+{
+	return g_berCoefficient;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerIntervalSecondsGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return ber interval in seconds
+**
+**  PARAMETERS:	 None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     ber interval in seconds
+**
+*******************************************************************************/
+MV_U32 onuGponBerIntervalSecondsGet(void)
+{
+	return g_intervalSeconds;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerCoefficientSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ber coefficient
+**
+**  PARAMETERS:	 S_BerCoefficient *coefficient
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponBerCoefficientSet(S_BerCoefficient *coefficient)
+{
+	g_berCoefficient.numerator   = coefficient->numerator;
+	g_berCoefficient.denominator = coefficient->denominator;
+}
+
+/*******************************************************************************
+**
+**  onuGponBerIntervalSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ber interval
+**
+**  PARAMETERS:	 MV_U32 interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponBerIntervalSet(MV_U32 interval)
+{
+	g_intervalSeconds        = interval;
+	g_numsOfPeriodInInterval = (interval * 1000) / PON_BER_PERIOD_LENGTH;
+	onuGponDbBerCalcIntervalSet(interval);
+}
+
+/*******************************************************************************
+**
+**  onuGponBerPower
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is a BER utility function
+**
+**  PARAMETERS:	 MV_U32 x
+**               MV_U32 y
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     calculated value
+**
+*******************************************************************************/
+MV_U32 onuGponBerPower(MV_U32 x, MV_U32 y)
+{
+	MV_U32 i;
+	MV_U32 sum = 1;
+
+	for (i = 0 ; i < y ; i++)
+		sum = sum * x;
+
+	return sum;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.h
new file mode 100644
index 0000000..0d519b7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuBer.h
@@ -0,0 +1,128 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuBer.h                                               **
+**                                                                           **
+**  DESCRIPTION : This is header file of external interface of OLT           **
+**                GPON BER mechnism                                          **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef PON_ONU_BER_H
+#define PON_ONU_BER_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Structs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 periodsCounter;
+	MV_U32 intervalBip8ErrorsCounter;
+	MV_U32 ber;
+	MV_U32 newBer;
+	MV_U32 outBip8Counter;
+	MV_U32 intervalBandwidth;
+} S_PonBer;
+
+typedef struct {
+	MV_U32 numerator;
+	MV_U32 denominator;
+} S_BerCoefficient;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Prototypes
+   ------------------------------------------------------------------------------*/
+MV_STATUS        onuGponBerInit(S_BerCoefficient *coefficient, MV_U32 interval);
+MV_STATUS        onuGponBerPeriodPass(MV_U32 inbip8Counter);
+MV_STATUS        onuGponBerBerCaculate(MV_U32 inbip8Counter);
+MV_STATUS        onuGponBerAlarmsCheck(MV_U32 ber);
+void             onuGponBerClear(void);
+MV_U32           onuGponBerBip8CounterGet(void);
+MV_U32           onuGponBerLastIntervalBip8CounterGet(void);
+MV_U32           onuGponBerBerValueGet(void);
+MV_U32           onuGponBerIntervalBerValueGet(void);
+S_BerCoefficient onuGponBerCoefficientGet(void);
+MV_U32           onuGponBerIntervalSecondsGet(void);
+void             onuGponBerCoefficientSet(S_BerCoefficient *coefficient);
+void             onuGponBerIntervalSet(MV_U32 interval);
+MV_U32           onuGponBerPower(MV_U32 x, MV_U32 y);
+
+#endif /* PON_ONU_BER_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.c
new file mode 100644
index 0000000..4d9c9c7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.c
@@ -0,0 +1,3974 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuDb.c                                                **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON database functionality       **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuDb.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+/* ONU GPON Database */
+S_OnuGponDb onuGponDb_s;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U8 onuGponPassword[ONU_GPON_PASS_LEN] = { 0x01, 0x02, 0x03, 0x04, 0x05,
+					     0x0A, 0x0B, 0x0C, 0x0D, 0x0E };
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Initialization Section                             */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponDbDbInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database to default values
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbInit(void)
+{
+	MV_STATUS rcode = MV_OK;
+
+	onuGponDbOnuGenTblInit();
+	onuGponDbOnuSyncParamTblInit();
+	onuGponDbOnuOperParamTblInit();
+	onuGponDbBwAllocInit();
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuGenTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database general table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbOnuGenTblInit(void)
+{
+	/* clear onu database general table */
+	memset((&(onuGponDb_s.onuGponGenTbl_s)), 0, sizeof(S_OnuGponGenTbl));
+
+	/* set onu to state 01 */
+	onuGponDbOnuStateSet(GPON_ONU_ID_STATE_01);
+
+	/* set onu to port state down */
+	onuGponDbOnuGponPortStateSet(ONU_PON_PORT_DOWN);
+
+	/* set onu Id to undefined onu */
+	onuGponDbOnuIdSet(GPON_ONU_ID_ONU_ID_DEF);
+
+	/* set gpon rate to default value */
+	onuGponDbRateSet(GPON_FRAME_DELINEATION_FR);
+
+	/* set gpon xvr polarity to default value */
+
+	/* set onu init status to be MV_FALSE */
+	onuGponDbInitSet(MV_FALSE);
+
+	/* set OMCC Valid to be MV_FALSE */
+	onuGponDbOmccValidSet(MV_FALSE);
+
+	/* set OnuId Override to be MV_FALSE */
+	onuGponDbOnuIdOverrideSet(MV_FALSE);
+
+#ifdef PON_A0
+	/* set ONU high priority TX to be MV_FALSE */
+	onuGponDbHighPriTxStateSet(MV_FALSE);
+#endif
+
+	/* Set NULL in Notify functions */
+	onuGponDbAlarmNotifySet(NULL);
+	onuGponDbStatusNotifySet(NULL);
+	onuGponDbOmccNotifySet(NULL);
+	onuGponDbDisableNotifySet(NULL);
+
+	onuGponDbOmccPortSet(0xFFFF);
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuSyncParamTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database sync params table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbOnuSyncParamTblInit(void)
+{
+	MV_U32 IdleMsgData[ONU_GPON_MSG_LEN];
+	MV_U32 snMsgData[ONU_GPON_MSG_LEN];
+	MV_U8 serialNumber[ONU_GPON_SN_LEN];
+
+	/* clear onu database sync params table */
+	memset((&(onuGponDb_s.onuGponSyncParamsTbl_s)), 0, sizeof(S_OnuGponSyncParamsTbl));
+
+	/* set onu guard bits */
+	onuGponDbGuardBitsSet(0);
+
+	/* set onu delays */
+	onuGponDbConstDelaySet(GPON_TX_DELAY_TD_1244);
+	onuGponDbEqualizationDelaySet(GPON_TX_EQUAL_DELAY_TD);
+
+	/* set onu preamble */
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_01, ONU_TX_PREAMBLE_TYPE_01_P, ONU_TX_PREAMBLE_TYPE_01_PC);
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_02, ONU_TX_PREAMBLE_TYPE_02_P, ONU_TX_PREAMBLE_TYPE_02_PC);
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_03, ONU_TX_PREAMBLE_TYPE_03_P, ONU_TX_PREAMBLE_TYPE_03_DEF_PC);
+
+	/* set onu delimiter */
+	onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_01, GPON_TX_DELIMITER_D0);
+	onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_02, GPON_TX_DELIMITER_D1);
+	onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_03, GPON_TX_DELIMITER_D2);
+	onuGponDbDelimiterSizeSet(GPON_TX_DELIMITER_DS);
+	onuGponDbDelimiterOverrideSet(MV_FALSE);
+
+	/* set onu serial number */
+	serialNumber[0] = ONU_GPON_SN_DEF_BYTE_1;
+	serialNumber[1] = ONU_GPON_SN_DEF_BYTE_2;
+	serialNumber[2] = ONU_GPON_SN_DEF_BYTE_3;
+	serialNumber[3] = ONU_GPON_SN_DEF_BYTE_4;
+	serialNumber[4] = ONU_GPON_SN_DEF_BYTE_5;
+	serialNumber[5] = ONU_GPON_SN_DEF_BYTE_6;
+	serialNumber[6] = ONU_GPON_SN_DEF_BYTE_7;
+	serialNumber[7] = ONU_GPON_SN_DEF_BYTE_8;
+
+	/* set onu serial number mask parametrs */
+	onuGponDbSerialNumberMaskEnableSet(ONU_GPON_SN_MSK_GEN_ENA);
+	onuGponDbSerialNumberMaskMatchSet(ONU_GPON_SN_MSK_DEF_MATCH);
+	onuGponDbSnMaskSet(MV_FALSE);
+
+	onuGponDbSerialNumSet(&(serialNumber[0]));
+
+	IdleMsgData[0] = ((MV_U32)0) |
+			 (((MV_U32)0) << 8) |
+			 (((MV_U32)ONU_GPON_IDLE_MSG_DEF_BYTE_02) << 16) |
+			 (((MV_U32)ONU_GPON_IDLE_MSG_DEF_BYTE_01) << 24);
+	IdleMsgData[1] = ((MV_U32)0) |
+			 (((MV_U32)0) << 8) |
+			 (((MV_U32)0) << 16) |
+			 (((MV_U32)0) << 24);
+	IdleMsgData[2] = ((MV_U32)0) |
+			 (((MV_U32)0) << 8) |
+			 (((MV_U32)0) << 16) |
+			 (((MV_U32)0) << 24);
+
+	onuGponDbIdleMsgSet(IdleMsgData);
+
+	snMsgData[0] = ((MV_U32)serialNumber[1]) |
+		       (((MV_U32)serialNumber[0]) << 8) |
+		       (((MV_U32)ONU_GPON_SN_MSG_DEF_BYTE_02) << 16) |
+		       (((MV_U32)ONU_GPON_SN_MSG_DEF_BYTE_01) << 24);
+	snMsgData[1] = ((MV_U32)serialNumber[5]) |
+		       (((MV_U32)serialNumber[4]) << 8) |
+		       (((MV_U32)serialNumber[3]) << 16) |
+		       (((MV_U32)serialNumber[2]) << 24);
+	snMsgData[2] = ((MV_U32)ONU_GPON_SN_MSG_DEF_BYTE_12) |
+		       (((MV_U32)ONU_GPON_SN_MSG_DEF_BYTE_11) << 8) |
+		       (((MV_U32)serialNumber[7]) << 16) |
+		       (((MV_U32)serialNumber[6]) << 24);
+
+	onuGponDbSnMsgSet(snMsgData);
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuOperParamTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database oper params table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbOnuOperParamTblInit(void)
+{
+	/* clear onu database oper params table */
+	memset((&(onuGponDb_s.onuGponOperParamsTbl_s)), 0, sizeof(S_OnuGponOperParamsTbl));
+
+	/* set ber, signal fail threshold and signal degraded threshold */
+	onuGponDbBerIntervalSet(GPON_BIP_PERIOD_CNTR);
+	onuGponDbBerCalcIntervalSet(ONU_GPON_DEF_INTERNAL_BER_INTERVAL);
+	onuGponDbSfThresholdSet(ONU_GPON_DEF_SF_THRESHOLD);
+	onuGponDbSdThresholdSet(ONU_GPON_DEF_SD_THRESHOLD);
+
+	/* Init GEM Port AES table */
+	onuGponDbGemPortAesClearAll();
+
+	/* Init GEM Port table */
+	onuGponDbGemPortClearAll();
+	onuGponDbGemPortSavedClearAll();
+
+	/* set onu REI sequence number */
+	onuGponDbReiSeqNumSet(ONU_GPON_DEF_REI_SEQ_NUM);
+
+	/* set onu password */
+	onuGponDbPasswordSet(&(onuGponPassword[0]));
+
+	/* set ONU long laser enable or disable */
+	onuGponDbOnuLongLaserSet(MV_FALSE);
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu database bandwidth allocation table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwAllocInit(void)
+{
+	MV_U32 iEntry;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwTcontSet(iEntry, MV_FALSE, PON_ONU_ALLOC_NOT_EXIST, MV_FALSE);
+		onuGponDbBwAllocSet(iEntry, PON_ONU_ALLOC_NOT_EXIST, MV_FALSE);
+		onuGponDbBwIdleAllocSet(iEntry, PON_ONU_ALLOC_NOT_EXIST);
+	}
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Interface Section                                  */
+/* ========================================================================== */
+/******************************************************************************/
+
+/********************************************/
+/* ======================================== */
+/*   ONU GPON General Table API Functions   */
+/* ======================================== */
+/********************************************/
+
+/*******************************************************************************
+**
+**  onuGponDbOnuStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu state in the database
+**
+**  PARAMETERS:  E_OnuState onuState_e - ONU_GPON_01_INIT
+**                                       ONU_GPON_02_STANDBY
+**                                       ONU_GPON_03_SERIAL_NUM
+**                                       ONU_GPON_04_RANGING
+**                                       ONU_GPON_05_OPERATION
+**                                                                       ONU_GPON_06_POPUP
+**                                                                       ONU_GPON_07_EMERGANCY_STOP
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuStateSet(MV_U32 onuState)
+{
+	if ((onuState < ONU_GPON_01_INIT) ||
+	    (onuState > ONU_GPON_07_EMERGANCY_STOP))
+		return MV_ERROR;
+
+	onuGponDb_s.onuGponGenTbl_s.onuGponOnuState = onuState;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuStateGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOnuState;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Id in the database
+**
+**  PARAMETERS:  MV_U32 onuId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuIdSet(MV_U32 onuId)
+{
+	MV_U32 idleMsg[3];
+	MV_U32 snNumMsg[3];
+
+	onuGponDb_s.onuGponGenTbl_s.onuGponOnuId = onuId;
+
+	onuGponDbIdleMsgGet(idleMsg);
+
+	idleMsg[0] &= (0x00FFFFFF);
+	idleMsg[0] |=  (onuId << 24);
+
+	onuGponDbIdleMsgSet(idleMsg);
+
+	onuGponDbSnMsgGet(snNumMsg);
+
+	snNumMsg[0] &= (0x00FFFFFF);
+	snNumMsg[0] |=  (onuId << 24);
+
+	onuGponDbSnMsgSet(snNumMsg);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Id
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Id
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuIdGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOnuId;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuSignalDetectSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu signal detect state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuSignalDetectSet(MV_U32 state)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponSignalDetect = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuSignalDetectGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu signal detect state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuSignalDetectGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponSignalDetect;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuDsSyncOnSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu DS Sync state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuDsSyncOnSet(MV_U32 state)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponDsSyncOn = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuDsSyncOnGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return DS Sync state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuDsSyncOnGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponDsSyncOn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuGponPortStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu gpon port state in the database
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuGponPortStateSet(MV_U32 state)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponPortState = state;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuGponPortStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return gpon port state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu state
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuGponPortStateGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponPortState;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Id override value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Id
+**
+*******************************************************************************/
+MV_U32 onuGponDbOnuIdOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOnuIdOverrideVal;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Id override value
+**
+**  PARAMETERS:  MV_U32 onuId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuIdOverrideValueSet(MV_U32 onuId)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOnuIdOverrideVal = onuId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Id override state
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuIdOverrideSet(MV_BOOL enable)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOnuIdOverrideEn = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Id override state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Id
+**
+*******************************************************************************/
+MV_BOOL onuGponDbOnuIdOverrideGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOnuIdOverrideEn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbdGaspEnSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set dying gasp in the database
+**
+**  PARAMETERS:  MV_BOOL dGaspEn
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbdGaspEnSet(MV_BOOL dGaspEn)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponDyingGaspEn = dGaspEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbdGaspEnGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu dying gasp state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Id
+**
+*******************************************************************************/
+MV_BOOL onuGponDbdGaspEnGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponDyingGaspEn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbInitSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ONU Init status in the database
+**
+**  PARAMETERS:  MV_BOOL init
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbInitSet(MV_BOOL init)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponInit = init;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbInitGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu init state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu init state - MV_TRUE/MV_FALSE
+**
+*******************************************************************************/
+MV_BOOL onuGponDbInitGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponInit;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccValidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu OMCC state in the database
+**
+**  PARAMETERS:  MV_BOOL omccValid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccValidSet(MV_BOOL omccValid)
+{
+	onuGponDb_s.onuGponGenTbl_s.omccValid = omccValid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccValidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu OMCC state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OMCC - MV_TRUE/MV_FALSE
+**
+*******************************************************************************/
+MV_BOOL onuGponDbOmccValidGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.omccValid;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccPortdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu OMCC value in the database
+**
+**  PARAMETERS:  MV_U32 omccPort
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccPortSet(MV_U32 omccPort)
+{
+	onuGponDb_s.onuGponGenTbl_s.omccPort = omccPort;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccPortGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu OMCC port
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OMCC port
+**
+*******************************************************************************/
+MV_U32 onuGponDbOmccPortGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.omccPort;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu OMCC override value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OMCC override value
+**
+*******************************************************************************/
+MV_U32 onuGponDbOmccPortOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOmccPortOverrideVal;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuIdOverrideValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu OMCC override value in the database
+**
+**  PARAMETERS:  MV_U32 OmccPort
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccPortOverrideValueSet(MV_U32 OmccPort)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOmccPortOverrideVal = OmccPort;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccPortOverrideSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu OMCC override state in the database
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccPortOverrideSet(MV_BOOL enable)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOmccPortOverrideEn = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccPortOverrideGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu OMCC override state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OMCC override state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbOmccPortOverrideGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponOmccPortOverrideEn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbRateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ONU Rate in the database
+**
+**  PARAMETERS:  MV_U32 rate
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbRateSet(MV_U32 rate)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponRate = rate;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbRateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Rate
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu Rate
+**
+*******************************************************************************/
+MV_U32 onuGponDbRateGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponRate;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbAlarmNotifySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Alarm Notify Callback in the database
+**
+**  PARAMETERS:  ALARMNOTIFYFUNC alarmCallback - alarm callback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbAlarmNotifySet(ALARMNOTIFYFUNC alarmCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.alarmCallback = alarmCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbAlarmNotifyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Alarm Notify Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Alarm Notify Callback
+**
+*******************************************************************************/
+ALARMNOTIFYFUNC onuGponDbAlarmNotifyGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.alarmCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbStatusNotifySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Status Notify Callback in the database
+**
+**  PARAMETERS:  STATUSNOTIFYFUNC statusCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbStatusNotifySet(STATUSNOTIFYFUNC statusCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.statusCallback = statusCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbStatusNotifyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Status Notify Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Status Notify Callback
+**
+*******************************************************************************/
+STATUSNOTIFYFUNC onuGponDbStatusNotifyGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.statusCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccNotifySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu Omcc Notify Callback in the database
+**
+**  PARAMETERS:  OMCCNOTIFYFUNC omccCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccNotifySet(OMCCNOTIFYFUNC omccCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.omccCallback = omccCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccNotifyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Omcc Notify Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Omcc Notify Callback
+**
+*******************************************************************************/
+OMCCNOTIFYFUNC onuGponDbOmccNotifyGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.omccCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDisableNotifySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu disable Notify Callback in the database
+**
+**  PARAMETERS:  DISABLENOTIFYFUNC disableCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDisableNotifySet(DISABLENOTIFYFUNC disableCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.disableCallback = disableCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDisableNotifyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu disable Notify Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Disable Notify Callback
+**
+*******************************************************************************/
+DISABLENOTIFYFUNC onuGponDbDisableNotifyGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.disableCallback;
+}
+
+/***********************************************/
+/* =========================================== */
+/*   ONU GPON Sync Params Table API Functions  */
+/* =========================================== */
+/***********************************************/
+
+/*******************************************************************************
+**
+**  onuGponDbSnMaskSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SN mask in the database
+**
+**  PARAMETERS:  MV_U32 snMaskEn
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSnMaskSet(MV_U32 snMaskEn)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskDefEnable = snMaskEn;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGuardBitsSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead guard bit
+**
+**  PARAMETERS:  MV_U32 guardBit
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGuardBitsSet(MV_U32 guardBit)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponGuardBits = guardBit;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGuardBitsGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead guard bit
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Overhead guard bit
+**
+*******************************************************************************/
+MV_U32 onuGponDbGuardBitsGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponGuardBits;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPreambleSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead preamble type and count
+**
+**  PARAMETERS:  E_OnuOverheadPreambleType premType_e
+**               MV_U32                    premVal
+**               MV_U32                    premCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbPreambleSet(E_OnuOverheadPreambleType premType_e,
+			       MV_U32 premVal,
+			       MV_U32 premCnt)
+{
+	if (premType_e > ONU_GPON_PREM_TYPE_03)
+		return MV_ERROR;
+
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPreambleVal[premType_e] = premVal;
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPreambleCnt[premType_e] = premCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPreambleGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead preamble type and count
+**
+**  PARAMETERS:  E_OnuOverheadPreambleType premType_e
+**               MV_U32                    *premVal
+**               MV_U32                    *premCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbPreambleGet(E_OnuOverheadPreambleType premType_e,
+			  MV_U32 *premVal,
+			  MV_U32 *premCnt)
+{
+	*premVal = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPreambleVal[premType_e];
+	*premCnt = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPreambleCnt[premType_e];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleStatusSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead extended preamble type3 status
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtPreambleStatusSet(MV_U32 extendPremStatus)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleStatus = extendPremStatus;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleStatusGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead extended preamble type3 status
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     extended preamble type3 status
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtPreambleStatusGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleStatus;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleSyncSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead extended preamble type3 - state 3/4
+**
+**  PARAMETERS:  MV_U32 extendPremCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtPreambleSyncSet(MV_U32 extendPremCnt)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSync = extendPremCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleSyncGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead extended preamble type3
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead extended preamble type3 count - state 3/4
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtPreambleSyncGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSync;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleOperSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead extended preamble type3 - state 5
+**
+**  PARAMETERS:  MV_U32 extendPremCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtPreambleOperSet(MV_U32 extendPremCnt)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOper = extendPremCnt;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtPreambleOperGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead extended preamble type3
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead extended preamble type3 count - state 5
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtPreambleOperGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOper;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead delimiter byte
+**
+**  PARAMETERS:  E_OnuOverheadDelimiterByte delimByte_e
+**               MV_U32                     delimVal
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDelimiterSet(E_OnuOverheadDelimiterByte delimByte_e,
+				MV_U32 delimVal)
+{
+	if (delimByte_e > ONU_GPON_DELM_BYTE_03)
+		return MV_ERROR;
+
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiter[delimByte_e] = delimVal;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead delimiter byte
+**
+**  PARAMETERS:  E_OnuOverheadDelimiterByte delimByte_e
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead delimiter byte
+**
+*******************************************************************************/
+MV_U32 onuGponDbDelimiterGet(E_OnuOverheadDelimiterByte delimByte_e)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiter[delimByte_e];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterSizeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead delimiter size
+**
+**  PARAMETERS:  MV_U32 delimSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDelimiterSizeSet(MV_U32 delimSize)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterSize = delimSize;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterSizeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead delimiter size
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead delimiter size
+**
+*******************************************************************************/
+MV_U32 onuGponDbDelimiterSizeGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterSize;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterOverrideValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead delimiter override value
+**
+**  PARAMETERS:  MV_U32 delimVal
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDelimiterOverrideValueSet(MV_U32 delimVal)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterOverrideValue = delimVal;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDelimiterOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead delimiter override value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu overhead delimiter override value
+**
+*******************************************************************************/
+MV_U32 onuGponDbDelimiterOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterOverrideValue;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterOverrideSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead delimiter override state
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu overhead delimiter state
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDelimiterOverrideSet(MV_BOOL enable)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterOverride = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDelimiterOverridGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead delimiter override state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead delimiter override state
+**
+*******************************************************************************/
+MV_U32 onuGponDbDelimiterOverrideGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponDelimiterOverride;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstDelayAddSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu extended burst delay add state
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtendedBurstDelayAddSet(MV_BOOL enable)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleDelayAdd = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstDelayAddGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst delay add state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst delay add state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbExtendedBurstDelayAddGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleDelayAdd;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstDelayValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu extended burst delay values
+**
+**  PARAMETERS:  MV_U32 exBurstSync
+**               MV_U32 exBurstOper
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtendedBurstDelayValueSet(MV_U32 exBurstSync, MV_U32 exBurstOper)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSyncDelay = exBurstSync;
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOperDelay = exBurstOper;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstSyncDelayValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst delay value (O3/O4)
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst delay value (O3/O4)
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtendedBurstSyncDelayValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSyncDelay;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstOperDelayValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst delay value (O5)
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst delay value (O5)
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtendedBurstOperDelayValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOperDelay;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstOverrideSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu extended burst override state
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtendedBurstOverrideSet(MV_BOOL enable)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOverride = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstOverrideGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst override state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst override state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbExtendedBurstOverrideGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOverride;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstOverrideValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu extended burst override values
+**
+**  PARAMETERS:  MV_U32 exBurstRange
+**               MV_U32 exBurstOper
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbExtendedBurstOverrideValueSet(MV_U32 exBurstRange, MV_U32 exBurstOper)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSyncOverride = exBurstRange;
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOperOverride = exBurstOper;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstSyncOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst override value (O3/O4)
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst override value (O3/O4)
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtendedBurstSyncOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleSyncOverride;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbExtendedBurstOperOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu extended burst override value (O5)
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu extended burst override value (O5)
+**
+*******************************************************************************/
+MV_U32 onuGponDbExtendedBurstOperOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponExtPreambleOperOverride;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbMaxExtraSnTransSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set overhead max extra sn transmissions
+**
+**  PARAMETERS:  MV_U32 maxExtraSnTrans
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbMaxExtraSnTransSet(MV_U32 maxExtraSnTrans)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponMaxExtraSnTrans = maxExtraSnTrans;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbMaxExtraSnTransGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return overhead max extra sn transmissions
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     overhead max extra sn transmissions
+**
+*******************************************************************************/
+MV_U32 onuGponDbMaxExtraSnTransGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponMaxExtraSnTrans;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu serial number
+**
+**  PARAMETERS:  MV_U8 *serialNum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSerialNumSet(MV_U8 *serialNum)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_SN_LEN; index++)
+		onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNum[index] = *(serialNum + index);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu serial number
+**
+**  PARAMETERS:  MV_U8 *serialNum
+**
+**  OUTPUTS:     MV_U8 *serialNum
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbSerialNumGet(MV_U8 *serialNum)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_SN_LEN; index++)
+		*(serialNum + index) = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNum[index];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumberMaskEnableGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SN mask enable state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     SN mask enable state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbSerialNumberMaskEnableGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskEnable;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumberMaskEnableSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SN mask enable state
+**
+**  PARAMETERS:  MV_BOOL a_SerialNumberMaskEnable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSerialNumberMaskEnableSet(MV_BOOL a_SerialNumberMaskEnable)
+{
+	MV_BOOL profileSnMaskValue;
+
+	profileSnMaskValue = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskDefEnable;
+
+	if (profileSnMaskValue == MV_TRUE)
+		onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskEnable = a_SerialNumberMaskEnable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumberMaskMatchGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SN mask match state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     SN mask match state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbSerialNumberMaskMatchGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskMatch;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSerialNumberMaskMatchSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SN mask enable state
+**
+**  PARAMETERS:  MV_BOOL a_SerialNumberMaskMatch
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSerialNumberMaskMatchSet(MV_BOOL a_SerialNumberMaskMatch)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSerialNumberMaskMatch = a_SerialNumberMaskMatch;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbConstDelaySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu const delay
+**
+**  PARAMETERS:  MV_U32 constDelay
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbConstDelaySet(MV_U32 constDelay)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponConstDelay = constDelay;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbConstDelayGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu const delay
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu const delay
+**
+*******************************************************************************/
+MV_U32 onuGponDbConstDelayGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponConstDelay;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelaySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu equalization delay
+**
+**  PARAMETERS:  MV_U32 equalizationDelay
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbEqualizationDelaySet(MV_U32 equalizationDelay)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelay = equalizationDelay;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelayGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu equalization delay
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu equalization delay
+**
+*******************************************************************************/
+MV_U32 onuGponDbEqualizationDelayGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelay;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelayOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu equalization delay override value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu equalization delay override value
+**
+*******************************************************************************/
+MV_U32 onuGponDbEqualizationDelayOverrideValueGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelayOverrideValue;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelayOverrideValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu equalization delay override value
+**
+**  PARAMETERS:  MV_U32 equalizationDelayOverrideVal
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbEqualizationDelayOverrideValueSet(MV_U32 equalizationDelayOverrideVal)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelayOverrideValue = equalizationDelayOverrideVal;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelayOverrideValueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu equalization delay override state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu equalization delay override state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbEqualizationDelayOverrideGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelayOverride;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEqualizationDelayOverrideSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu equalization delay override state
+**
+**  PARAMETERS:  MV_BOOL OverrideEqualizationDelay
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbEqualizationDelayOverrideSet(MV_BOOL OverrideEqualizationDelay)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponEqualizationDelayOverride = OverrideEqualizationDelay;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPowerLevelSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu power level
+**
+**  PARAMETERS:  MV_U32 powerLevel
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbPowerLevelSet(MV_U32 powerLevel)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPowerLevel = powerLevel;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPowerLevelGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu power level
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu power level
+**
+*******************************************************************************/
+MV_U32 onuGponDbPowerLevelGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponPowerLevel;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbIdleMsgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu idle message
+**
+**  PARAMETERS:  MV_U32 *idleMsg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbIdleMsgSet(MV_U32 *idleMsg)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_MSG_LEN; index++)
+		onuGponDb_s.onuGponSyncParamsTbl_s.onuGponIdleMsg[index] = *(idleMsg + index);
+}
+
+/*******************************************************************************
+**
+**  onuGponDbIdleMsgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu idle message
+**
+**  PARAMETERS:  MV_U32 *idleMsg
+**
+**  OUTPUTS:     MV_U32 *idleMsg
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbIdleMsgGet(MV_U32 *idleMsg)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_MSG_LEN; index++)
+		*(idleMsg + index) = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponIdleMsg[index];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSnMsgSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu serial number message
+**
+**  PARAMETERS:  MV_U32 *snMsg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbSnMsgSet(MV_U32 *snMsg)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_MSG_LEN; index++)
+		onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSnMsg[index] = *(snMsg + index);
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSnMsgGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu serial number message
+**
+**  PARAMETERS:  MV_U32 *snMsg
+**
+**  OUTPUTS:     MV_U32 *snMsg
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbSnMsgGet(MV_U32 *snMsg)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_MSG_LEN; index++)
+		*(snMsg + index) = onuGponDb_s.onuGponSyncParamsTbl_s.onuGponSnMsg[index];
+}
+
+/***********************************************/
+/* =========================================== */
+/*   ONU GPON Oper Params Table API Functions  */
+/* =========================================== */
+/***********************************************/
+
+/*******************************************************************************
+**
+**  onuGponDbBerIntervalSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu ber interval
+**
+**  PARAMETERS:  MV_U32 berInterval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBerIntervalSet(MV_U32 berInterval)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerInterval = berInterval;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBerIntervalGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu ber interval
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu ber interval
+**
+*******************************************************************************/
+MV_U32 onuGponDbBerIntervalGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerInterval;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBipInterruptStatusValueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function update onu ber interval value
+**
+**  PARAMETERS:  MV_U32 Bip8
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBipInterruptStatusValueSet(MV_U32 Bip8)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerIntervalValue = Bip8;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBerIntervalGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu ber interval value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu ber interval value
+**
+*******************************************************************************/
+MV_U32 onuGponDbBipInterruptStatusValueGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerIntervalValue;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemResetSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets onu gem reset on fiber disconnection
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGemResetSet(MV_U32 gem_reset)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponResetGemPorts = gem_reset;
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemResetGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu gem reset on fiber disconnection
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     return onu gem reset on fiber disconnection
+**
+*******************************************************************************/
+MV_U32 onuGponDbGemResetGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponResetGemPorts;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbTcontResetSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets onu TCONT reset on fiber disconnection
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbTcontResetSet(MV_U32 tcont_reset)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponResetTconts = tcont_reset;
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbTcontResetGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu tcont reset on fiber disconnection
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     return onu gem reset on fiber disconnection
+**
+*******************************************************************************/
+MV_U32 onuGponDbTcontResetGet(void)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponResetTconts;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemRestoreSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets flag "restore GEM ports on exiting from state 7"
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_VOID onuGponDbGemRestoreSet(MV_BOOL gem_restore)
+{
+	onuGponDb_s.onuGponSyncParamsTbl_s.onuGponRestoreGemPorts = gem_restore;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemRestoreGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return flag "GEM ports restore on exiting from state 7"
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     return onu gem restore on exiting from state 7
+**
+*******************************************************************************/
+MV_BOOL onuGponDbGemRestoreGet(MV_VOID)
+{
+	return onuGponDb_s.onuGponSyncParamsTbl_s.onuGponRestoreGemPorts;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBerCalcIntervalSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu internal ber interval
+**
+**  PARAMETERS:  MV_U32 internalBerInterval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBerCalcIntervalSet(MV_U32 internalBerInterval)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerCalcInterval = internalBerInterval;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBerCalcIntervalGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu internal ber interval
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu internal ber interval
+**
+*******************************************************************************/
+MV_U32 onuGponDbBerCalcIntervalGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponBerCalcInterval;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSfThresholdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SF threshold
+**
+**  PARAMETERS:  MV_U32 SF_Threshold
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSfThresholdSet(MV_U32 SF_Threshold)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponSfThreshold = SF_Threshold;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSfThresholdGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SF threshold
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu SF threshold
+**
+*******************************************************************************/
+MV_U32 onuGponDbSfThresholdGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponSfThreshold;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSdThresholdSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu SD threshold
+**
+**  PARAMETERS:  MV_U32 SD_Threshold
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSdThresholdSet(MV_U32 SD_Threshold)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponSdThreshold = SD_Threshold;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSdThresholdGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SD threshold
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu SD threshold
+**
+*******************************************************************************/
+MV_U32 onuGponDbSdThresholdGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponSdThreshold;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortValidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set gem port valid state
+**
+**  PARAMETERS:  MV_U32 gemPortId
+**               MV_BOOL   valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGemPortValidSet(MV_U32 gemPortId, MV_BOOL valid)
+{
+	if (gemPortId >= GPON_ONU_MAX_GEM_PORTS)
+		return MV_ERROR;
+
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortValid[gemPortId] = valid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortValidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return gem port valid state
+**
+**  PARAMETERS:  MV_U32 gemPortId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     gem port valid state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbGemPortValidGet(MV_U32 gemPortId)
+{
+	if (gemPortId >= GPON_ONU_MAX_GEM_PORTS)
+		return MV_FALSE;
+
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortValid[gemPortId];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortClearAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear all gem ports
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGemPortClearAll(void)
+{
+	MV_U32 iPort;
+
+	for (iPort = 0 ; iPort < GPON_ONU_MAX_GEM_PORTS ; iPort++)
+		onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortValid[iPort] = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortSavedClearAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear all saved gem ports
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_VOID onuGponDbGemPortSavedClearAll(void)
+{
+	MV_U32 iPort;
+
+	for (iPort = 0 ; iPort < GPON_ONU_MAX_GEM_PORTS ; iPort++)
+		onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortSave[iPort] = MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortSaveAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function saves validity state of all gem ports
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_VOID onuGponDbGemPortSaveAll(void)
+{
+	MV_U32 iPort;
+
+	for (iPort = 0 ; iPort < GPON_ONU_MAX_GEM_PORTS ; iPort++)
+		onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortSave[iPort] =
+			onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortValid[iPort];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortSavedValidGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return gem port valid state from "saved ports" array
+**
+**  PARAMETERS:  MV_U32 gemPortId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     gem port valid state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbGemPortSavedValidGet(MV_U32 gemPortId)
+{
+	if (gemPortId >= GPON_ONU_MAX_GEM_PORTS)
+		return MV_FALSE;
+
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortSave[gemPortId];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortAesSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set gem port encryption state
+**
+**  PARAMETERS:  MV_U32 gemPortId
+**               MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGemPortAesSet(MV_U32 gemPortId, MV_BOOL mode)
+{
+	if (gemPortId >= GPON_ONU_MAX_GEM_PORTS)
+		return MV_ERROR;
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortAes[gemPortId] = mode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortAesGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return gem port encryption state
+**
+**  PARAMETERS:  MV_U32 gemPortId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     gem port encryption state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbGemPortAesGet(MV_U32 gemPortId)
+{
+	if (gemPortId >= GPON_ONU_MAX_GEM_PORTS)
+		return MV_FALSE;
+
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortAes[gemPortId];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbGemPortAesClearAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear all AES gem ports
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbGemPortAesClearAll(void)
+{
+	MV_U32 iPort;
+
+	for (iPort = 0 ; iPort < GPON_ONU_MAX_GEM_PORTS ; iPort++)
+		onuGponDb_s.onuGponOperParamsTbl_s.onuGponGemPortAes[iPort] = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbReiSeqNumSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu REI sequence number
+**
+**  PARAMETERS:  MV_U32 reiSeqNum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbReiSeqNumSet(MV_U32 reiSeqNum)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponReiSeqNum = reiSeqNum;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbReiSeqNumGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu REI sequence number
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu REI sequence number
+**
+*******************************************************************************/
+MV_U32 onuGponDbReiSeqNumGet(void)
+{
+	return onuGponDb_s.onuGponOperParamsTbl_s.onuGponReiSeqNum;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPasswordSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu password
+**
+**  PARAMETERS:  MV_U8 *password
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbPasswordSet(MV_U8 *password)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_PASS_LEN; index++)
+		onuGponDb_s.onuGponOperParamsTbl_s.onuGponPassword[index] = *(password + index);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbPasswordGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu password
+**
+**  PARAMETERS:  MV_U8 *password
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDbPasswordGet(MV_U8 *password)
+{
+	MV_U32 index;
+
+	for (index = 0; index < ONU_GPON_PASS_LEN; index++)
+		*(password + index) = onuGponDb_s.onuGponOperParamsTbl_s.onuGponPassword[index];
+}
+
+/********************************************/
+/* ======================================== */
+/*   ONU GPON BW Alloc Table API Functions  */
+/* ======================================== */
+/********************************************/
+
+/* ======================================== */
+/*   ONU BW ALLOC SECTION                   */
+/* ======================================== */
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets Alloc-Id value & state to T-Cont
+**
+**  PARAMETERS:  MV_U32 entry
+**               MV_U32 allocId
+**               MV_BOOL valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwAllocSet(MV_U32 entry, MV_U32 allocId, MV_BOOL valid)
+{
+	if (entry >= ONU_GPON_MAX_NUM_OF_T_CONTS)
+		return MV_ERROR;
+
+	onuGponDb_s.onuGponBwTbl_s.onuAllocIds[entry].allocId = allocId;
+	onuGponDb_s.onuGponBwTbl_s.onuAllocIds[entry].valid   = valid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return Alloc-Id value & state to T-Cont
+**
+**  PARAMETERS:  MV_U32 entry
+**               MV_U32 allocId
+**               MV_BOOL valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Alloc-Id value & state
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwAllocGet(MV_U32 entry, MV_U32 *allocId, MV_BOOL *valid)
+{
+	if (entry >= ONU_GPON_MAX_NUM_OF_T_CONTS) {
+		*allocId = 0;
+		*valid   = MV_FALSE;
+		return MV_ERROR;
+	}
+
+	*allocId = onuGponDb_s.onuGponBwTbl_s.onuAllocIds[entry].allocId;
+	*valid   = onuGponDb_s.onuGponBwTbl_s.onuAllocIds[entry].valid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocExist
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function true if Alloc-Id exist in the onu
+**
+**  PARAMETERS:  MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Alloc-Id existance
+**
+*******************************************************************************/
+MV_BOOL onuGponDbBwAllocExist(MV_U32 allocId)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+	MV_BOOL valid;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwAllocGet(iEntry, &entryAllocId, &valid);
+		if ((entryAllocId == allocId) && (valid == MV_TRUE))
+			return MV_TRUE;
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocInsert
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function assign Alloc-Id to T-Cont
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *entry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwAllocInsert(MV_U32 allocId, MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+	MV_BOOL valid;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwAllocGet(iEntry, &entryAllocId, &valid);
+		if (valid == MV_FALSE) {
+			onuGponDbBwAllocSet(iEntry, allocId, MV_TRUE);
+			*entry = iEntry;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwAllocRemove
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function remove Alloc-Id from T-Cont
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *entry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwAllocRemove(MV_U32 allocId, MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+	MV_BOOL valid;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwAllocGet(iEntry, &entryAllocId, &valid);
+		if ((entryAllocId == allocId) && (valid == MV_TRUE)) {
+			onuGponDbBwAllocSet(iEntry, PON_ONU_ALLOC_NOT_EXIST, MV_FALSE);
+			*entry = iEntry;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/* ======================================== */
+/*   ONU BW IDLE ALLOC SECTION              */
+/* ======================================== */
+
+/*******************************************************************************
+**
+**  onuGponDbBwIdleAllocSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets Idle Alloc-Id value
+**
+**  PARAMETERS:  MV_U32 entry
+**               MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     NONE
+**
+*******************************************************************************/
+MV_VOID onuGponDbBwIdleAllocSet(MV_U32 entry, MV_U32 allocId)
+{
+	if (entry < ONU_GPON_MAX_NUM_OF_T_CONTS)
+		onuGponDb_s.onuGponBwTbl_s.onuIdleAllocIds[entry] = allocId;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwIdleAllocGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return Idle Alloc-Id value
+**
+**  PARAMETERS:  MV_U32 entry
+**               MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     NONE
+**
+*******************************************************************************/
+MV_VOID onuGponDbBwIdleAllocGet(MV_U32 entry, MV_U32 *allocId)
+{
+	if (entry < ONU_GPON_MAX_NUM_OF_T_CONTS)
+		*allocId = onuGponDb_s.onuGponBwTbl_s.onuIdleAllocIds[entry];
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwIdleAllocExist
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function true if Idle Alloc-Id exist in the onu
+**
+**  PARAMETERS:  MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Alloc-Id existance
+**
+*******************************************************************************/
+MV_BOOL onuGponDbBwIdleAllocExist(MV_U32 allocId, MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwIdleAllocGet(iEntry, &entryAllocId);
+		if (entryAllocId == allocId) {
+			*entry = entryAllocId;
+			return MV_TRUE;
+		}
+	}
+
+	*entry = 0;
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwIdleAllocInsert
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function add Idle Alloc-Id
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *entry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwIdleAllocInsert(MV_U32 allocId, MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwIdleAllocGet(iEntry, &entryAllocId);
+		if (entryAllocId == PON_ONU_ALLOC_NOT_EXIST) {
+			onuGponDbBwIdleAllocSet(iEntry, allocId);
+			*entry = iEntry;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwIdleAllocRemove
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function remove Idle Alloc-Id
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *entry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwIdleAllocRemove(MV_U32 allocId, MV_U32 *entry)
+{
+	MV_U32 iEntry;
+	MV_U32 entryAllocId;
+
+	for (iEntry = 0 ; iEntry < ONU_GPON_MAX_NUM_OF_T_CONTS ; iEntry++) {
+		onuGponDbBwIdleAllocGet(iEntry, &entryAllocId);
+		if (entryAllocId == allocId) {
+			onuGponDbBwIdleAllocSet(iEntry, PON_ONU_ALLOC_NOT_EXIST);
+			*entry = iEntry;
+			return MV_OK;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/* ======================================== */
+/*   ONU BW TCONT SECTION                   */
+/* ======================================== */
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set an entry in the T-Cont table
+**
+**  PARAMETERS:  MV_U32  tcontNum
+**               MV_BOOL exist
+**               MV_U32  allocId
+**               MV_BOOL valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     NONE
+**
+*******************************************************************************/
+MV_VOID onuGponDbBwTcontSet(MV_U32 tcontNum,
+			    MV_BOOL exist,
+			    MV_U32 allocId,
+			    MV_BOOL valid)
+{
+	if (tcontNum < ONU_GPON_MAX_NUM_OF_T_CONTS) {
+		onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].exist   = exist;
+		onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].allocId = allocId;
+		onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].valid   = valid;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return an entry from the T-Cont table
+**
+**  PARAMETERS:  MV_U32  tcontNum
+**               MV_BOOL *exist
+**               MV_U32  *allocId
+**               MV_BOOL *valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     NONE
+**
+*******************************************************************************/
+MV_VOID onuGponDbBwTcontGet(MV_U32 tcontNum,
+			    MV_BOOL *exist,
+			    MV_U32  *allocId,
+			    MV_BOOL *valid)
+{
+	if (tcontNum < ONU_GPON_MAX_NUM_OF_T_CONTS) {
+		*exist   = onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].exist;
+		*allocId = onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].allocId;
+		*valid   = onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].valid;
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontExist
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return true if T-Cont entry is valid
+**
+**  PARAMETERS:  MV_U32 tcontNum
+**               MV_BOOL   *exist
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwTcontExist(MV_U32 tcontNum, MV_BOOL *exist)
+{
+	if (tcontNum >= ONU_GPON_MAX_NUM_OF_T_CONTS)
+		return MV_ERROR;
+
+	*exist = onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].exist;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset T-Cont table entry
+**
+**  PARAMETERS:  MV_U32 tcontNum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwTcontClear(MV_U32 tcontNum)
+{
+	if ((tcontNum >= ONU_GPON_MAX_NUM_OF_T_CONTS) ||
+	    (onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].exist != MV_TRUE))
+		return MV_ERROR;
+
+	onuGponDbBwTcontSet(tcontNum, MV_TRUE, PON_ONU_ALLOC_NOT_EXIST, MV_FALSE);
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontAlloc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set T-Cont table entry
+**
+**  PARAMETERS:  MV_U32 tcontNum
+**               MV_U32 allocId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwTcontAlloc(MV_U32 tcontNum, MV_U32 allocId)
+{
+	if ((tcontNum >= ONU_GPON_MAX_NUM_OF_T_CONTS) ||
+	    (onuGponDb_s.onuGponBwTbl_s.onuTcontIds[tcontNum].exist != MV_TRUE))
+		return MV_ERROR;
+
+	onuGponDbBwTcontSet(tcontNum, MV_TRUE, allocId, MV_TRUE);
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontConnectCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return T-Cont table entry according to Alloc-Id
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *tcontNum
+**               MV_BOOL   *valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwTcontConnectCheck(MV_U32 allocId, MV_U32 *tcontNum, MV_BOOL *valid)
+{
+	MV_BOOL exist;
+	MV_U32 dbAllocId;
+	MV_BOOL dbValid;
+	MV_U32 iTcont;
+
+	for (iTcont = 0 ; iTcont < ONU_GPON_MAX_NUM_OF_T_CONTS ; iTcont++) {
+		onuGponDbBwTcontGet(iTcont, &exist, &dbAllocId, &dbValid);
+		if ((exist == MV_TRUE) && (dbValid == MV_TRUE) && (allocId == dbAllocId)) {
+			*valid    = dbValid;
+			*tcontNum = iTcont;
+			return MV_OK;
+		}
+	}
+
+	*valid    = MV_FALSE;
+	*tcontNum = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwTcontFreeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return free T-Cont table entry according to Alloc-Id
+**
+**  PARAMETERS:  MV_U32 allocId
+**               MV_U32 *tcontNum
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE if there is a free entry, MV_FALSE otherwise
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwTcontFreeGet(MV_U32 allocId, MV_U32 *tcontNum)
+{
+	MV_BOOL exist;
+	MV_U32 dbAllocId;
+	MV_BOOL dbValid;
+	MV_U32 iTcont;
+	MV_U32 tempTcont = 0;
+
+	for (iTcont = 0 ; iTcont < ONU_GPON_MAX_NUM_OF_T_CONTS ; iTcont++) {
+		onuGponDbBwTcontGet(iTcont, &exist, &dbAllocId, &dbValid);
+		if ((exist == MV_TRUE) && (dbValid == MV_FALSE)) {
+			*tcontNum = iTcont;
+			return MV_OK;
+		}
+
+		if (dbAllocId == allocId)
+			tempTcont = iTcont;
+	}
+
+	*tcontNum = tempTcont;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwMapCntDumpSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enables/disables BW MAP counters dump before
+**               ONU state changing
+**
+**  PARAMETERS:  MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbBwMapCntDumpSet(MV_U32 enable)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponBwMapDumpEn = enable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbBwMapCntDumpGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the BW MAP counters dump state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     enabled/disabled
+**
+*******************************************************************************/
+MV_BOOL onuGponDbBwMapCntDumpGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuGponBwMapDumpEn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the OMCC status and CPU RX queue for OMCI
+**
+**  PARAMETERS:  S_OnuOmcc *omcc
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccSet(S_OnuOmcc *omcc)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.state = omcc->state;
+	if (omcc->state == MV_TRUE) {
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.gemPort    = omcc->gemPort;
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.luid       = omcc->luid;
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.prsTid     = omcc->prsTid;
+	} else {
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.gemPort    = 0;
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.luid       = 0;
+		onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.prsTid     = 0;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmciFastPathSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu OMCI D/S fast path
+**
+**  PARAMETERS:  MV_BOOL valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmciFastPathSet(MV_BOOL valid)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuOmciFastPathEn = valid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmciFastPathGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu OMCI D/S fast path state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OMCI D/S fast path state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbOmciFastPathGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuOmciFastPathEn;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the OMCC status and CPU RX queue for OMCI
+**
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     S_OnuOmcc *omcc
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccGet(S_OnuOmcc *omcc)
+{
+	omcc->state      = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.state;
+	omcc->gemPort    = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.gemPort;
+	omcc->cpuRxQueue = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.cpuRxQueue;
+	omcc->luid       = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.luid;
+	omcc->prsTid     = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.prsTid;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccRxQueueSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the OMCC CPU RX queue
+**
+**  PARAMETERS:  MV_U32 cpuRxQueue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccRxQueueSet(MV_U32 cpuRxQueue)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.cpuRxQueue = cpuRxQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOmccRxQueueGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns the OMCC CPU RX queue
+**
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     MV_U32 *cpuRxQueue
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOmccRxQueueGet(MV_U32 *cpuRxQueue)
+{
+	*cpuRxQueue = onuGponDb_s.onuGponGenTbl_s.onuGponOmcc.cpuRxQueue;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDgCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Dying Gasp Callback in the database
+**
+**  PARAMETERS:  DYINGGASPFUNC dgCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbDgCallbackSet(DYINGGASPFUNC dgCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuDgCallback = dgCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbDgCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Dying Gasp Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Dying Gasp Callback
+**
+*******************************************************************************/
+DYINGGASPFUNC onuGponDbDgCallbackGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuDgCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbLinkStatusCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set Link Status Callback in the database
+**
+**  PARAMETERS:  LINKSTATUSFUNC linkStatusCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbLinkStatusCallbackSet(LINKSTATUSFUNC linkStatusCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuLinkStatusCallback = linkStatusCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbLinkStatusCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Link Status Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Link Status Callback
+**
+*******************************************************************************/
+LINKSTATUSFUNC onuGponDbLinkStatusCallbackGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuLinkStatusCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHwfCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set HWF Callback in the database
+**
+**  PARAMETERS:  DATAFORWARDFUNC hwfCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHwfCallbackSet(DATAFORWARDFUNC hwfCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuHwfCallback = hwfCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHwfCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu HWF Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Hardware Forwarding Callback
+**
+*******************************************************************************/
+DATAFORWARDFUNC onuGponDbHwfCallbackGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuHwfCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSwfCallbackSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set SWF Callback in the database
+**
+**  PARAMETERS:  DATAFORWARDFUNC swfCallback
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbSwfCallbackSet(DATAFORWARDFUNC swfCallback)
+{
+	onuGponDb_s.onuGponGenTbl_s.onuSwfCallback = swfCallback;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbSwfCallbackGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu SWF Callback
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Software Forwarding Callback
+**
+*******************************************************************************/
+DATAFORWARDFUNC onuGponDbSwfCallbackGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuSwfCallback;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the state of high priority T-CONT TX
+**
+**  PARAMETERS:  MV_BOOL state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxStateSet(MV_BOOL state)
+{
+	MV_U32 idx;
+
+	/* update high priority TX state */
+	onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.state = state;
+	/* clear high priority TX in disable case */
+	if (state == MV_FALSE) {
+		memset(&onuGponDb_s.onuGponGenTbl_s.onuHighPriTx, 0, sizeof(S_OnuHighPriTx));
+		for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++)
+			onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.tcontMap[idx].valid = MV_FALSE;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxStateGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the state of high priority T-CONT TX
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_BOOL state
+**
+*******************************************************************************/
+MV_BOOL onuGponDbHighPriTxStateGet(void)
+{
+	return onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.state;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxMapCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function checks the map of high priority T-CONT TX
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxMapCheck(S_OnuTcontMap *tcontMap)
+{
+	MV_U32 idx;
+	S_OnuTcontMap *map;
+
+	if (onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.state != MV_TRUE) {
+		mvPonPrint(PON_PRINT_ERROR, PON_DB_MODULE,
+			   "ERROR: (%s:%d) onuGponDbHighPriTxMapCheck, high priority TX is not enabled,"
+			   "do not allow set the map\n", __FILE_DESC__, __LINE__);
+		return MV_FALSE;
+	}
+
+	/* check high priority TX state */
+	PON_IF_NULL(PON_DB_MODULE, tcontMap);
+	PON_POS_RANGE_VALIDATE(PON_DB_MODULE, tcontMap->hostTcont, ONU_GPON_MAX_NUM_OF_T_CONTS - 1,
+		"Invalid host T-CONT");
+	PON_POS_RANGE_VALIDATE(PON_DB_MODULE, tcontMap->addTcont, ONU_GPON_MAX_NUM_OF_T_CONTS - 1,
+		"Invalid host T-CONT");
+	if (tcontMap->hostTcont == tcontMap->addTcont) {
+		mvPonPrint(PON_PRINT_ERROR, PON_DB_MODULE,
+			   "ERROR: (%s:%d) host T-CONT(%d) equals to additional T-CONT, illegal\n",
+			   __FILE_DESC__, __LINE__, tcontMap->hostTcont);
+		return MV_ERROR;
+	}
+
+	/* check high priority TX mapping */
+	for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++) {
+		map = &onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.tcontMap[idx];
+
+		if (map->valid == MV_FALSE)
+			continue;
+
+		/* compare the config */
+		if ((map->addTcont  == tcontMap->addTcont) ||
+		    (map->addTcont  == tcontMap->hostTcont) ||
+		    (map->hostTcont == tcontMap->addTcont)) {
+			mvPonPrint(PON_PRINT_ERROR, PON_DB_MODULE,
+				   "ERROR: (%s:%d) onuGponDbHighPriTxMapCheck, conflict tcont\n",
+				   __FILE_DESC__, __LINE__);
+			return MV_FALSE;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxMapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the map of high priority T-CONT TX
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxMapSet(S_OnuTcontMap *tcontMap)
+{
+	MV_U32 idx;
+	S_OnuTcontMap *map;
+
+	/* NULL validation */
+	PON_IF_NULL(PON_DB_MODULE, tcontMap);
+
+	/* save high priority TX mapping */
+	for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++) {
+		map = &onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.tcontMap[idx];
+
+		if ((map->valid == MV_TRUE) && (map->hostTcont != tcontMap->hostTcont))
+			continue;
+
+		/* save the config */
+		map->hostTcont  = tcontMap->hostTcont;
+		map->addTcont   = tcontMap->addTcont;
+		map->valid      = MV_TRUE;
+
+		return MV_OK;
+	}
+
+	mvPonPrint(PON_PRINT_ERROR, PON_DB_MODULE,
+		   "ERROR: (%s:%d) onuGponDbHighPriTxMapSet, TX map table is full\n", __FILE_DESC__, __LINE__);
+
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxMapGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the map of high priority T-CONT TX
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     S_OnuTcontMap *tcontMap
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxMapGet(S_OnuTcontMap *tcontMap)
+{
+	MV_U32 idx;
+	S_OnuTcontMap *map;
+
+	/* NULL validation */
+	PON_IF_NULL(PON_DB_MODULE, tcontMap);
+
+	/* get high priority TX mapping */
+	for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++) {
+		map = &onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.tcontMap[idx];
+
+		if (map->valid == MV_FALSE)
+			continue;
+
+		if (map->hostTcont == tcontMap->hostTcont) {
+			/* get the config */
+			tcontMap->hostTcont  = map->hostTcont;
+			tcontMap->addTcont   = map->addTcont;
+			tcontMap->valid      = map->valid;
+		}
+
+		return MV_OK;
+	}
+
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxMapDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes the map of high priority T-CONT TX
+**
+**  PARAMETERS:  MV_U32 hostTcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxMapDel(MV_U32 hostTcont)
+{
+	MV_U32 idx;
+	S_OnuTcontMap *map;
+
+	/* get high priority TX mapping */
+	for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++) {
+		map = &onuGponDb_s.onuGponGenTbl_s.onuHighPriTx.tcontMap[idx];
+
+		if (map->valid == MV_FALSE)
+			continue;
+
+		if (map->hostTcont == hostTcont) {
+			/* get the config */
+			map->hostTcont  = 0;
+			map->addTcont   = 0;
+			map->valid      = MV_FALSE;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbHighPriTxMapGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function gets the high priority T-CONT TX
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     high priority T-CONT TX
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbHighPriTxGet(S_OnuHighPriTx *highPriTx)
+{
+	/* NULL validation */
+	PON_IF_NULL(PON_DB_MODULE, highPriTx);
+	memcpy(highPriTx, &onuGponDb_s.onuGponGenTbl_s.onuHighPriTx, sizeof(S_OnuHighPriTx));
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEncryptionKeySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function save ONU encryption key in DB.
+**
+**  INPUTS     : MV_U8 *key: ONU encryption key.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponDbEncryptionKeySet(MV_U8 *key)
+{
+	memcpy(onuGponDb_s.onuGponOperParamsTbl_s.onuGponEncryptionKey, key,
+	       sizeof(onuGponDb_s.onuGponOperParamsTbl_s.onuGponEncryptionKey));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbEncryptionKeyGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves ONU encryption key from DB.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MV_U8 *key: ONU encryption key.
+**
+**  RETURNS    : MV_OK or error.
+**
+*******************************************************************************/
+MV_STATUS onuGponDbEncryptionKeyGet(MV_U8 *key)
+{
+	memcpy(key, onuGponDb_s.onuGponOperParamsTbl_s.onuGponEncryptionKey,
+	       sizeof(onuGponDb_s.onuGponOperParamsTbl_s.onuGponEncryptionKey));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuLongLaserSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function saves ONU long laser enable in DB.
+**
+**  INPUTS     : MV_U8 longLaserEnable: Enable or disable the long laser.
+**
+**  OUTPUTS    : None.
+**
+**  RETURNS    : MV_OK or error.
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuLongLaserSet(MV_U8 longLaserEnable)
+{
+	onuGponDb_s.onuGponOperParamsTbl_s.onuGponLongLaserEnable = longLaserEnable;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDbOnuLongLaserGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves ONU long laser enable from DB.
+**
+**  INPUTS     : None.
+**
+**  OUTPUTS    : MV_U8 *longLaserEnable: Enable or disable the long laser.
+**
+**  RETURNS    : MV_OK or error.
+**
+*******************************************************************************/
+MV_STATUS onuGponDbOnuLongLaserGet(MV_U8 *longLaserEnable)
+{
+	*longLaserEnable = onuGponDb_s.onuGponOperParamsTbl_s.onuGponLongLaserEnable;
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.h
new file mode 100644
index 0000000..b60c44c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuDb.h
@@ -0,0 +1,450 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuDb.h                                                **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON database definitions           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_DB_H
+#define _ONU_GPON_DB_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+/******************************************************************************/
+/* ========================================================================== */
+/*                               Database Definitions                         */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* GPON Definitions */
+#define ONU_GPON_SN_LEN          (8)
+#define ONU_GPON_PASS_LEN        (10)
+#define ONU_GPON_PREAMBLE_LEN    (3)
+#define ONU_GPON_DELIMITER_LEN   (3)
+#define ONU_GPON_MSG_LEN         (3)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+/******************************************************************************/
+/* ========================================================================== */
+/*                               Database Definitions                         */
+/* ========================================================================== */
+/******************************************************************************/
+
+/**************************************/
+/* ONU GPON functions prototype       */
+/**************************************/
+typedef void (*GPONFUNCPTR)(MV_U8, MV_U8, MV_U8*);
+
+/**************************************/
+/* ONU GPON general table             */
+/**************************************/
+typedef struct {
+	MV_BOOL state;
+	MV_U32 gemPort;
+	MV_U32 cpuRxQueue;
+	MV_U32 luid;
+	MV_U32 prsTid;
+} S_OnuOmcc;
+
+typedef struct {
+	MV_BOOL state;                                          /* Enable or disable this feature   */
+	S_OnuTcontMap tcontMap[ONU_GPON_MAX_NUM_OF_T_CONTS];    /* T-CONT mapping for high pri TX */
+} S_OnuHighPriTx;
+
+typedef struct {
+	MV_U32 onuGponOnuState;                         /* ONU State */
+	MV_U32 onuGponOnuId;                            /* ONU ID */
+	MV_U32 onuGponSignalDetect;                     /* ONU Signal Detect */
+	MV_U32 onuGponDsSyncOn;                         /* ONU DS Sync On */
+	MV_U32 onuGponPortState;                        /* ONU Port state */
+	MV_U32 onuGponOnuIdOverrideEn;                  /* ONU ID Overeide Enable*/
+	MV_U32 onuGponOnuIdOverrideVal;                 /* ONU ID Overeide value*/
+	MV_U32 onuGponRate;
+	MV_U32 onuGponP2pXvrBurstEnPolarity;
+	GPONFUNCPTR onuGponStateAndEventTbl[ONU_GPON_NUM_OF_EVENTS][ONU_GPON_NUM_OF_STATES];
+	MV_BOOL onuGponInit;                     /* Is ONU initialized? */
+	MV_BOOL omccValid;
+	MV_U32 omccPort;
+	MV_U32 onuGponOmccPortOverrideVal;
+	MV_U32 onuGponOmccPortOverrideEn;
+	MV_BOOL onuGponDyingGaspEn;
+	MV_BOOL onuGponBwMapDumpEn;
+	S_OnuOmcc onuGponOmcc;
+	MV_BOOL onuOmciFastPathEn;
+	S_OnuHighPriTx onuHighPriTx;
+
+	ALARMNOTIFYFUNC alarmCallback;
+	STATUSNOTIFYFUNC statusCallback;
+	OMCCNOTIFYFUNC omccCallback;
+	DISABLENOTIFYFUNC disableCallback;
+	DYINGGASPFUNC onuDgCallback;
+	LINKSTATUSFUNC onuLinkStatusCallback;
+	DATAFORWARDFUNC onuHwfCallback;
+	DATAFORWARDFUNC onuSwfCallback;
+
+} S_OnuGponGenTbl;
+
+/**************************************/
+/* ONU GPON Sync param table          */
+/**************************************/
+typedef struct {
+	MV_U32 onuGponGuardBits;                    /* ONU number of guard bits */
+	MV_U32 onuGponPreambleVal[ONU_GPON_PREAMBLE_LEN]; /* ONU preamble value */
+	MV_U32 onuGponPreambleCnt[ONU_GPON_PREAMBLE_LEN]; /* ONU preamble count */
+	MV_U32 onuGponDelimiter[ONU_GPON_DELIMITER_LEN];        /* ONU delimiter value */
+	MV_U32 onuGponDelimiterSize;                            /* ONU delimiter size */
+	MV_U32 onuGponDelimiterOverrideValue;                   /* ONU delimiter value override */
+	MV_BOOL onuGponDelimiterOverride;                       /* ONU delimiter override */
+
+	MV_U32 onuGponExtPreambleStatus;                        /* ONU extended preamble status (on/off) */
+	MV_U32 onuGponExtPreambleSync;                          /* ONU extended preamble type 3 - state 3/4 */
+	MV_U32 onuGponExtPreambleOper;                          /* ONU extended preamble type 3 - state 5 */
+	MV_U32 onuGponExtPreambleSyncOverride;                  /* ONU extended preamble override type 3 - state 3/4 */
+	MV_U32 onuGponExtPreambleOperOverride;                  /* ONU extended preamble override type 3 - state 5 */
+	MV_BOOL onuGponExtPreambleOverride;                     /* ONU extended Preamble override */
+	MV_BOOL onuGponExtPreambleDelayAdd;                     /* ONU extended Preamble delay add */
+	MV_U32 onuGponExtPreambleSyncDelay;                     /* ONU extended preamble override type 3 - state 3/4 */
+	MV_U32 onuGponExtPreambleOperDelay;                     /* ONU extended preamble override type 3 - state 5 */
+
+	MV_U32 onuGponMaxExtraSnTrans;                          /* ONU max extra SN transmissions */
+
+	MV_U8 onuGponSerialNum[ONU_GPON_SN_LEN];                /* ONU Serial number */
+	MV_U32 onuGponConstDelay;                               /* ONU Const Delay - cannot be changed */
+	MV_U32 onuGponEqualizationDelay;                        /* ONU Equalization Delay */
+	MV_U32 onuGponEqualizationDelayOverrideValue;           /* ONU delimiter override */
+	MV_BOOL onuGponEqualizationDelayOverride;               /* ONU delimiter override */
+
+	MV_U32 onuGponPowerLevel;                               /* ONU power level */
+
+	MV_BOOL onuGponSerialNumberMaskEnable;                  /* ONU Serial Number Mask */
+	MV_BOOL onuGponSerialNumberMaskMatch;                   /* ONU Serial Number Mask  Match Mode */
+	MV_BOOL onuGponSerialNumberMaskDefEnable;               /* ONU Serial Number Mask profile override status */
+
+	MV_U32 onuGponIdleMsg[ONU_GPON_MSG_LEN];                /* ONU idle message */
+	MV_U32 onuGponSnMsg[ONU_GPON_MSG_LEN];                  /* ONU serial number message */
+	MV_U32 onuGponResetGemPorts;                            /* ONU reset Gem on disconnection */
+	MV_U32 onuGponResetTconts;                              /* ONU reset Tcont on disconnection */
+	MV_BOOL onuGponRestoreGemPorts;                         /* ONU restore Gem on exiting from state 7 */
+} S_OnuGponSyncParamsTbl;
+
+/**************************************/
+/* ONU GPON Oper param table          */
+/**************************************/
+typedef struct {
+	MV_U32 onuGponBerInterval;                      /* ONU Ber Interval - set by the OLT */
+	MV_U32 onuGponBerCalcInterval;                  /* ONU Calc Ber Interval - internal for ONU */
+	MV_U32 onuGponSfThreshold;                      /* ONU Signal Fail Threshold */
+	MV_U32 onuGponSdThreshold;                      /* ONU Signal degraded Threshold */
+	MV_U32 onuGponBerIntervalValue;                 /* ONU Ber Interval Value of Bip8 Errors */
+	MV_BOOL onuGponGemPortAes[GPON_ONU_MAX_GEM_PORTS];
+	MV_BOOL onuGponGemPortValid[GPON_ONU_MAX_GEM_PORTS];
+	MV_BOOL onuGponGemPortSave[GPON_ONU_MAX_GEM_PORTS];
+	MV_U8 onuGponPassword[ONU_GPON_PASS_LEN];       /* ONU password */
+	MV_U16 onuGponReiSeqNum;                        /* ONU REI sequence number */
+	MV_U8 onuGponEncryptionKey[16];                 /* ONU encryption key */
+	MV_U8 onuGponLongLaserEnable;                   /* ONU long laser enable or disable */
+} S_OnuGponOperParamsTbl;
+
+/**************************************/
+/* ONU GPON BW Allocation param table */
+/**************************************/
+typedef struct {
+	MV_U32 allocId;
+	MV_BOOL valid;
+} S_OnuAllocIds;
+
+typedef struct {
+	MV_BOOL exist;
+	MV_U32 allocId;
+	MV_BOOL valid;
+} S_OnuTcontIds;
+
+typedef struct {
+	S_OnuTcontIds onuTcontIds[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	S_OnuAllocIds onuAllocIds[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 onuIdleAllocIds[ONU_GPON_MAX_NUM_OF_T_CONTS];
+} S_OnuGponBwAllocTbl;
+
+/* ONU GPON Database */
+typedef struct {
+	S_OnuGponGenTbl onuGponGenTbl_s;
+	S_OnuGponSyncParamsTbl onuGponSyncParamsTbl_s;
+	S_OnuGponOperParamsTbl onuGponOperParamsTbl_s;
+	S_OnuGponBwAllocTbl onuGponBwTbl_s;
+} S_OnuGponDb;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+/* ONU GPON Database */
+extern S_OnuGponDb onuGponDb_s;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+void      onuGponDbOnuGenTblInit(void);
+void      onuGponDbOnuSyncParamTblInit(void);
+void      onuGponDbOnuOperParamTblInit(void);
+MV_STATUS onuGponDbGemPortAesClearAll(void);
+MV_STATUS onuGponDbSerialNumberMaskEnableSet(MV_BOOL a_SerialNumberMaskEnable);
+MV_BOOL   onuGponDbSerialNumberMaskEnableGet(void);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* ONU GPON database init function */
+MV_STATUS onuGponDbInit(void);
+
+void       onuGponOnuGenTblInit(void);
+void       onuGponDbOnuSyncParamTblInit(void);
+void       onuGponDbOnuOperParamTblInit(void);
+void       onuGponDbOnuTcontTblInit(void);
+void       onuGponDbOnuPortTblInit(void);
+MV_STATUS onuGponDbBwAllocInit(void);
+
+/* ONU GPON general table API functions */
+MV_STATUS onuGponDbOnuStateSet(MV_U32 onuState);
+MV_U32    onuGponDbOnuStateGet(void);
+MV_STATUS onuGponDbOnuIdSet(MV_U32 onuId);
+MV_U32    onuGponDbOnuIdGet(void);
+MV_STATUS onuGponDbOnuSignalDetectSet(MV_U32 state);
+MV_U32    onuGponDbOnuSignalDetectGet(void);
+MV_STATUS onuGponDbOnuDsSyncOnSet(MV_U32 state);
+MV_U32    onuGponDbOnuDsSyncOnGet(void);
+MV_STATUS onuGponDbOnuGponPortStateSet(MV_U32 state);
+MV_U32    onuGponDbOnuGponPortStateGet(void);
+MV_STATUS onuGponDbOnuIdOverrideSet(MV_BOOL enable);
+MV_BOOL   onuGponDbOnuIdOverrideGet(void);
+MV_STATUS onuGponDbOnuIdOverrideValueSet(MV_U32 onuId);
+MV_U32    onuGponDbOnuIdOverrideValueGet(void);
+MV_STATUS onuGponDbInitSet(MV_BOOL init);
+MV_BOOL   onuGponDbInitGet(void);
+MV_STATUS onuGponDbOmccValidSet(MV_BOOL omccValid);
+MV_BOOL   onuGponDbOmccValidGet(void);
+MV_STATUS onuGponDbOmccPortSet(MV_U32 omccPort);
+MV_U32    onuGponDbOmccPortGet(void);
+MV_BOOL   onuGponDbOmccPortOverrideGet(void);
+MV_STATUS onuGponDbOmccPortOverrideSet(MV_BOOL enable);
+MV_U32    onuGponDbOmccPortOverrideValueGet(void);
+MV_STATUS onuGponDbOmccPortOverrideValueSet(MV_U32 omccPort);
+MV_STATUS onuGponDbRateSet(MV_U32 rate);
+MV_U32    onuGponDbRateGet(void);
+MV_BOOL   onuGponDbdGaspEnGet(void);
+MV_STATUS onuGponDbdGaspEnSet(MV_BOOL dGaspEn);
+MV_STATUS onuGponDbAlarmNotifySet(ALARMNOTIFYFUNC alarmCallback);
+ALARMNOTIFYFUNC   onuGponDbAlarmNotifyGet(void);
+MV_STATUS         onuGponDbStatusNotifySet(STATUSNOTIFYFUNC statusCallback);
+STATUSNOTIFYFUNC  onuGponDbStatusNotifyGet(void);
+MV_STATUS         onuGponDbOmccNotifySet(OMCCNOTIFYFUNC omccCallback);
+OMCCNOTIFYFUNC    onuGponDbOmccNotifyGet(void);
+MV_STATUS         onuGponDbDisableNotifySet(DISABLENOTIFYFUNC disableCallback);
+DISABLENOTIFYFUNC onuGponDbDisableNotifyGet(void);
+MV_STATUS         onuGponDbDgCallbackSet(DYINGGASPFUNC dgCallback);
+DYINGGASPFUNC     onuGponDbDgCallbackGet(void);
+MV_STATUS         onuGponDbLinkStatusCallbackSet(LINKSTATUSFUNC linkStatusCallback);
+LINKSTATUSFUNC    onuGponDbLinkStatusCallbackGet(void);
+MV_STATUS         onuGponDbHwfCallbackSet(DATAFORWARDFUNC hwfCallback);
+DATAFORWARDFUNC   onuGponDbHwfCallbackGet(void);
+MV_STATUS         onuGponDbSwfCallbackSet(DATAFORWARDFUNC swfCallback);
+DATAFORWARDFUNC   onuGponDbSwfCallbackGet(void);
+
+MV_STATUS onuGponDbHighPriTxStateSet(MV_BOOL state);
+MV_BOOL   onuGponDbHighPriTxStateGet(void);
+MV_STATUS onuGponDbHighPriTxMapCheck(S_OnuTcontMap *tcontMap);
+MV_STATUS onuGponDbHighPriTxMapSet(S_OnuTcontMap *tcontMap);
+MV_STATUS onuGponDbHighPriTxMapGet(S_OnuTcontMap *tcontMap);
+MV_STATUS onuGponDbHighPriTxMapDel(MV_U32 hostTcont);
+MV_STATUS onuGponDbHighPriTxGet(S_OnuHighPriTx *highPriTx);
+
+/* ONU GPON Sync param table API functions */
+MV_STATUS onuGponDbGuardBitsSet(MV_U32 guardBit);
+MV_U32    onuGponDbGuardBitsGet(void);
+MV_STATUS onuGponDbPreambleSet(E_OnuOverheadPreambleType premType_e, MV_U32 premVal, MV_U32 premCnt);
+void      onuGponDbPreambleGet(E_OnuOverheadPreambleType premType_e, MV_U32 *premVal, MV_U32 *premCnt);
+MV_BOOL   onuGponDbExtendedBurstOverrideGet(void);
+MV_STATUS onuGponDbExtendedBurstOverrideSet(MV_BOOL enable);
+MV_BOOL   onuGponDbExtendedBurstDelayAddGet(void);
+MV_STATUS onuGponDbExtendedBurstDelayAddSet(MV_BOOL enable);
+MV_STATUS onuGponDbExtendedBurstOverrideValueSet(MV_U32 exBurstRange, MV_U32 exBurstOper);
+MV_STATUS onuGponDbExtendedBurstDelayValueSet(MV_U32 exBurstSync, MV_U32 exBurstOper);
+MV_U32    onuGponDbExtendedBurstSyncDelayValueGet(void);
+MV_U32    onuGponDbExtendedBurstOperDelayValueGet(void);
+MV_U32    onuGponDbExtendedBurstSyncOverrideValueGet(void);
+MV_U32    onuGponDbExtendedBurstOperOverrideValueGet(void);
+MV_STATUS onuGponDbDelimiterSet(E_OnuOverheadDelimiterByte delimType_e, MV_U32 delimVal);
+MV_U32    onuGponDbDelimiterGet(E_OnuOverheadDelimiterByte delimType_e);
+MV_STATUS onuGponDbDelimiterSizeSet(MV_U32 delimSize);
+MV_U32    onuGponDbDelimiterSizeGet(void);
+MV_STATUS onuGponDbDelimiterOverrideSet(MV_BOOL enable);
+MV_U32    onuGponDbDelimiterOverrideGet(void);
+MV_STATUS onuGponDbDelimiterOverrideValueSet(MV_U32 delimVal);
+MV_U32    onuGponDbDelimiterOverrideValueGet(void);
+MV_STATUS onuGponDbExtPreambleSyncSet(MV_U32 extendPremCnt);
+MV_U32    onuGponDbExtPreambleSyncGet(void);
+MV_STATUS onuGponDbExtPreambleOperSet(MV_U32 extendPremCnt);
+MV_U32    onuGponDbExtPreambleOperGet(void);
+MV_STATUS onuGponDbMaxExtraSnTransSet(MV_U32 maxExtraSnTrans);
+MV_U32    onuGponDbMaxExtraSnTransGet(void);
+MV_STATUS onuGponDbSerialNumSet(MV_U8 *serialNum);
+void      onuGponDbSerialNumGet(MV_U8 *serialNum);
+void      onuGponDbConstDelaySet(MV_U32 constDelay);
+MV_U32    onuGponDbConstDelayGet(void);
+MV_BOOL   onuGponDbSerialNumberMaskEnableGet(void);
+MV_STATUS onuGponDbSerialNumberMaskEnableSet(MV_BOOL a_SerialNumberMaskEnable);
+MV_BOOL   onuGponDbSerialNumberMaskMatchGet(void);
+MV_STATUS onuGponDbSerialNumberMaskMatchSet(MV_BOOL a_SerialNumberMaskMatch);
+MV_STATUS onuGponDbSnMaskSet(MV_U32 snMaskEn);
+MV_STATUS onuGponDbEqualizationDelaySet(MV_U32 equalizationDelay);
+MV_U32    onuGponDbEqualizationDelayGet(void);
+MV_STATUS onuGponDbEqualizationDelayOverrideSet(MV_BOOL OverrideEqualizationDelay);
+MV_BOOL   onuGponDbEqualizationDelayOverrideGet(void);
+MV_U32    onuGponDbEqualizationDelayOverrideValueGet(void);
+MV_STATUS onuGponDbEqualizationDelayOverrideValueSet(MV_U32 equalizationDelayOverrideVal);
+MV_STATUS onuGponDbPowerLevelSet(MV_U32 powerLevel);
+MV_U32    onuGponDbPowerLevelGet(void);
+void      onuGponDbIdleMsgSet(MV_U32 *idleMsg);
+void      onuGponDbIdleMsgGet(MV_U32 *idleMsg);
+void      onuGponDbSnMsgSet(MV_U32 *snMsg);
+void      onuGponDbSnMsgGet(MV_U32 *snMsg);
+
+/* ONU GPON Oper param table API functions */
+MV_STATUS onuGponDbBerIntervalSet(MV_U32 berInterval);
+MV_U32    onuGponDbBerIntervalGet(void);
+MV_STATUS onuGponDbBerCalcIntervalSet(MV_U32 internalBerInterval);
+MV_U32    onuGponDbBerCalcIntervalGet(void);
+MV_STATUS onuGponDbSfThresholdSet(MV_U32 SF_Threshold);
+MV_U32    onuGponDbSfThresholdGet(void);
+MV_STATUS onuGponDbSdThresholdSet(MV_U32 SD_Threshold);
+MV_U32    onuGponDbSdThresholdGet(void);
+MV_STATUS onuGponDbGemPortValidSet(MV_U32 gemPortId, MV_BOOL mode);
+MV_BOOL   onuGponDbGemPortValidGet(MV_U32 gemPortId);
+MV_STATUS onuGponDbGemPortClearAll(void);
+MV_VOID   onuGponDbGemPortSavedClearAll(void);
+MV_VOID   onuGponDbGemPortSaveAll(void);
+MV_BOOL   onuGponDbGemPortSavedValidGet(MV_U32 gemPortId);
+MV_STATUS onuGponDbGemPortAesSet(MV_U32 gemPortId, MV_BOOL mode);
+MV_BOOL   onuGponDbGemPortAesGet(MV_U32 gemPortId);
+MV_STATUS onuGponDbGemPortAesClearAll(void);
+MV_STATUS onuGponDbReiSeqNumSet(MV_U32 reiSeqNum);
+MV_U32    onuGponDbReiSeqNumGet(void);
+MV_STATUS onuGponDbPasswordSet(MV_U8 *password);
+void      onuGponDbPasswordGet(MV_U8 *password);
+MV_STATUS onuGponDbBipInterruptStatusValueSet(MV_U32 Bip8);
+MV_U32    onuGponDbBipInterruptStatusValueGet(void);
+MV_STATUS onuGponDbGemResetSet(MV_U32 gem_reset);
+MV_U32    onuGponDbGemResetGet(void);
+MV_STATUS onuGponDbTcontResetSet(MV_U32 tcont_reset);
+MV_U32    onuGponDbTcontResetGet(void);
+MV_VOID   onuGponDbGemRestoreSet(MV_BOOL gem_restore);
+MV_BOOL   onuGponDbGemRestoreGet(MV_VOID);
+MV_STATUS onuGponDbOnuLongLaserSet(MV_U8 longLaserEnable);
+MV_STATUS onuGponDbOnuLongLaserGet(MV_U8 *longLaserEnable);
+MV_STATUS onuGponDbEncryptionKeyGet(MV_U8 *key);
+
+/* ONU GPON BW Alloc param table API functions */
+MV_STATUS onuGponDbBwAllocSet(MV_U32 entry, MV_U32 allocId, MV_BOOL valid);
+MV_STATUS onuGponDbBwAllocGet(MV_U32 entry, MV_U32 *allocId, MV_BOOL *valid);
+MV_BOOL   onuGponDbBwAllocExist(MV_U32 allocId);
+MV_STATUS onuGponDbBwAllocInsert(MV_U32 allocId, MV_U32 *entry);
+MV_STATUS onuGponDbBwAllocRemove(MV_U32 allocId, MV_U32 *entry);
+
+MV_VOID onuGponDbBwIdleAllocSet(MV_U32 entry, MV_U32 allocId);
+MV_VOID onuGponDbBwIdleAllocGet(MV_U32 entry, MV_U32 *allocId);
+MV_BOOL   onuGponDbBwIdleAllocExist(MV_U32 allocId, MV_U32 *entry);
+MV_STATUS onuGponDbBwIdleAllocInsert(MV_U32 allocId, MV_U32 *entry);
+MV_STATUS onuGponDbBwIdleAllocRemove(MV_U32 allocId, MV_U32 *entry);
+
+MV_VOID onuGponDbBwTcontSet(MV_U32 tcontNum, MV_BOOL exist, MV_U32 allocId, MV_BOOL valid);
+MV_VOID onuGponDbBwTcontGet(MV_U32 tcontNum, MV_BOOL *exist, MV_U32 *allocId, MV_BOOL *valid);
+MV_STATUS onuGponDbBwTcontExist(MV_U32 tcontNum, MV_BOOL *exist);
+MV_STATUS onuGponDbBwTcontClear(MV_U32 tcontNum);
+MV_STATUS onuGponDbBwTcontAlloc(MV_U32 tcontNum, MV_U32 allocId);
+MV_STATUS onuGponDbBwTcontConnectCheck(MV_U32 allocId, MV_U32 *tcontNum, MV_BOOL *valid);
+MV_STATUS onuGponDbBwTcontFreeGet(MV_U32 allocId, MV_U32 *tcontNum);
+
+MV_STATUS onuGponDbBwMapCntDumpSet(MV_U32 enable);
+MV_BOOL   onuGponDbBwMapCntDumpGet(void);
+
+MV_STATUS onuGponDbOmccSet(S_OnuOmcc *omcc);
+MV_STATUS onuGponDbOmccGet(S_OnuOmcc *omcc);
+MV_STATUS onuGponDbOmciFastPathSet(MV_BOOL valid);
+MV_BOOL   onuGponDbOmciFastPathGet(void);
+MV_STATUS onuGponDbOmccRxQueueSet(MV_U32 cpuRxQueue);
+MV_STATUS onuGponDbOmccRxQueueGet(MV_U32 *cpuRxQueue);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_DB_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuHeader.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuHeader.h
new file mode 100644
index 0000000..484dd9d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuHeader.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuHeader.h                                            **
+**                                                                           **
+**  DESCRIPTION : This file pon module header files                          **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_HEADER_H
+#define _ONU_GPON_HEADER_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuRtos.h"
+#include "mvPonOnuDefines.h"
+#include "mvPonOnuRegs.h"
+#include "mvPonOnuMac.h"
+#include "gponOnuBoard.h"
+#include "gponOnuLnxKsOs.h"
+#include "gponOnuLnxKsMI.h"
+#include "gponOnuLnxKsUI.h"
+#include "gponOnuInit.h"
+#include "gponOnuIsr.h"
+#include "gponOnuApi.h"
+#include "gponOnuDb.h"
+#include "gponOnuPm.h"
+#include "gponOnuAlrm.h"
+#include "gponOnuMngr.h"
+#include "gponOnuSrvc.h"
+#include "gponOnuAlloc.h"
+#include "gponOnuBer.h"
+#include "ponOnuBoard.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_HEADER_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.c
new file mode 100644
index 0000000..de3c974
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.c
@@ -0,0 +1,1382 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuInit.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON init sequence                **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuInit.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuGponPreSetup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu pre-setup init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**               MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponPreSetup(void)
+{
+	MV_STATUS rcode = MV_OK;
+
+	/* init PON spin lock */
+	spin_lock_init(&onuPonIrqLock);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponSetup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu setup init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**               MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponSetup(void)
+{
+	MV_STATUS rcode;
+
+	/* init onu base address */
+	rcode = onuGponGlbAddrInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init onu base address\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	ponXvrFunc = GponXvrSDPolarityHighStatus;
+
+	/* init onu database */
+	rcode = onuGponDbInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init onu database\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* init onu Asic */
+	rcode = onuGponAsicInit(MV_TRUE);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init asic\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	rcode = onuGponPmInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Failed to init pm\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+	onuGponIsrInit();
+	onuGponSrvcInit();
+	onuGponAllocIdInit(0xFFFF);
+	/* onuGponPmGemPortPmInit(); */
+
+	onuPonEventInit();
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicLedsInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu leds
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicLedsInit(void)
+{
+	onuPonLedInit();
+
+	onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_OFF);
+	onuPonLedHandler(ONU_PON_SYS_LED, ACTIVE_LED_ON);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponOnuStateAndIdInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu Id and state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicOnuStateAndIdInit(void)
+{
+	MV_STATUS rcode;
+	MV_U32 onuState;
+	MV_U32 onuId;
+	MV_BOOL onuIdEnable;
+
+	/* ONU State Register */
+	/* get onu state */
+	onuState = onuGponDbOnuStateGet();
+	rcode    = mvOnuGponMacOnuStateSet(onuState);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacOnuStateSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	/* ONU-ID Register */
+	onuId       = onuGponDbOnuIdGet();
+	onuIdEnable = (onuId == ONU_GPON_UNDEFINED_ONU_ID) ? MV_FALSE : MV_TRUE;
+	rcode = mvOnuGponMacOnuIdSet(onuId, onuIdEnable);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacOnuIdSet onu Id(%d), enable(%d)\n",
+			   __FILE_DESC__, __LINE__, onuId, onuIdEnable);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicDelayInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu delay: const, equilization, and
+**               Final
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicDelayInit(void)
+{
+	MV_STATUS rcode;
+	MV_U32 eqDelay;
+	MV_U32 finalDelay;
+	MV_U32 equalizationDelay;
+	MV_U32 constDelay;
+	MV_U32 snForRandomSeed;
+	MV_U8 sn[8];
+
+	/* TX Delay Register - const */
+	constDelay = onuGponDbConstDelayGet();
+	rcode      = mvOnuGponMacRxInternalDelaySet(constDelay);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacRxInternalDelaySet, constDelay(0x%x)\n",
+			   __FILE_DESC__, __LINE__, constDelay);
+		return rcode;
+	}
+
+	/* calc delay */
+	eqDelay           = onuGponDbEqualizationDelayGet();
+	finalDelay        = M_ONU_GPON_RANG_MSG_FINAL_DELAY(eqDelay);
+	equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(eqDelay);
+
+	/* TX Delay Register - equilization */
+	rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacRxInternalDelaySet, constDelay(0x%x)\n",
+			   __FILE_DESC__, __LINE__, constDelay);
+		return rcode;
+	}
+
+	/* TX Final Delay Register */
+	rcode = mvOnuGponMacTxFinalDelaySet(GPON_TX_FINAL_DELAY_FD);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	/* Update two last bytes of Serial Number -Help Asic generate Random numbers
+	   for S/N Request answer delay */
+	onuGponDbSerialNumGet(sn);
+	snForRandomSeed = sn[7] + (MV_U32)(sn[6] << 8);
+	rcode = mvOnuGponMacSerialNumberSet(snForRandomSeed);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicOverheadInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu overhead parameters: Preamble, and
+**               Delimiter
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicOverheadInit(void)
+{
+	MV_STATUS rcode;
+	MV_U32 preambleType1Ctr;
+	MV_U32 preambleType1Pattern;
+	MV_U32 preambleType2Ctr;
+	MV_U32 preambleType2Pattern;
+	MV_U32 preambleType3Ctr;
+	MV_U32 preambleType3Pattern;
+	MV_U32 delimiterByte1;
+	MV_U32 delimiterByte2;
+	MV_U32 delimiterByte3;
+	MV_U32 delimiter;
+
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_01, &preambleType1Pattern, &preambleType1Ctr);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_02, &preambleType2Pattern, &preambleType2Ctr);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_03, &preambleType3Pattern, &preambleType3Ctr);
+
+	/* TX Preamble Register */
+	rcode = mvOnuGponMacPreambleSet(ONU_TX_PREAMBLE_TYPE_01_P, preambleType1Ctr,
+					ONU_TX_PREAMBLE_TYPE_02_P, preambleType2Ctr,
+					preambleType3Pattern, preambleType3Ctr);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacPreambleSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	/* TX Delimiter Register */
+	delimiterByte1 = onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_01);
+	delimiterByte2 = onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_02);
+	delimiterByte3 = onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_03);
+
+	delimiter = (delimiterByte3 << 16) | (delimiterByte2 << 8) | delimiterByte1;
+	rcode = mvOnuGponMacTxDelimiterSet(delimiter, GPON_TX_DELIMITER_DS);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacTxDelimiterSet, delimiter(0x%x)\n",
+			   __FILE_DESC__, __LINE__, delimiter);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicBerCounterInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu ber interval
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicBerCounterInit(void)
+{
+#if 0
+	MV_U32 berInterval;
+	MV_STATUS rcode;
+
+	berInterval = onuGponDbBerIntervalGet();
+	/* ONU BIP period Counter Register */
+	rcode = mvOnuGponMacBerIntervalSet(berInterval);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponDbBerIntervalGet, berInterval(%d)\n",
+			   __FILE_DESC__, __LINE__, berInterval);
+		return rcode;
+	}
+#endif
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicPloamParamInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu Rx PLOAM configuration
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicPloamParamInit(void)
+{
+	MV_STATUS rcode;
+
+	rcode = mvOnuGponMacRxPloamConfigSet(MV_FALSE, MV_FALSE, MV_FALSE);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacRxPloamConfigSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicFrameDelineationInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu frame delineation
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicFrameDelineationInit(void)
+{
+	MV_STATUS rcode;
+
+	/* Frame Delineation Register */
+	rcode = mvOnuGponMacRxPsaConfigSet(GPON_FRAME_DELINEATION_M1,
+					   GPON_FRAME_DELINEATION_M2,
+					   GPON_FRAME_DELINEATION_M2,
+					   4);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacRxPsaConfigSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicBurstEnableInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu burst enable
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicBurstEnableInit(void)
+{
+	MV_STATUS rcode;
+
+	/* BURST enable parameter */
+	rcode = mvOnuGponMacTxBurstEnParamSet(GPON_BURST_EN_MASK,
+					      GPON_BURST_EN_P,
+					      GPON_BURST_EN_ORDER,
+					      GPON_BURST_EN_STOP,
+					      GPON_BURST_EN_START);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacTxBurstEnParamSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuGponMacTxTxEnableCounterThresholdSet(GPON_BURST_THRESHOLD);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacTxTxEnableCounterThresholdSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicFrameLengthInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu frame lengths
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicFrameLengthInit(void)
+{
+	MV_STATUS rcode;
+
+	rcode = mvOnuGponMacGemPayloadLenSet(GPON_MAX_GEM_PAYLOAD_LEN);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacGemPayloadLenSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuGponMacGemEthFrameLenSet(GPON_MAX_ETH_FRAME_LEN, GPON_MIN_ETH_FRAME_LEN);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacGemEthFrameLenSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuGponMacGemOmciFrameLenSet(GPON_MAX_OMCI_FRAME_LEN, GPON_MIN_OMCI_FRAME_LEN);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacGemOmciFrameLenSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicPortInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu gem and aes tables
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicPortInit(void)
+{
+	MV_STATUS rcode;
+
+	rcode = mvOnuGponMacAesInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAesInit\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuGponMacGemInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacGemInit\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicBoardInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu Serdes and Dying Gasp
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicBoardInit(void)
+{
+	MV_STATUS status;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	if (mvBoardIdGet() == RD_6660_ID) {
+		status = onuGponMppInit();
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) onuGponMppInit\n", __FILE_DESC__, __LINE__);
+			return status;
+		}
+	}
+#endif
+#endif  /* PON_FPGA */
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	status = onuGponSerdesInit();
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuPonSerdesInit\n", __FILE_DESC__, __LINE__);
+		return status;
+	}
+#endif
+#endif  /* PON_FPGA */
+	status = mvOnuPonMacBurstEnableInit();
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuPonMacBurstEnableInit\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	/* Setup TX power ON/OFF GPP and turn TX power OFF */
+	status = onuPonTxPowerControlInit();
+
+	if (status == MV_OK)
+		status = onuPonTxPowerOn(MV_FALSE);
+
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Unable to configure TX POWER GPP\n\r", __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicUtmBitmapInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init UTM Active TX Bitmap
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicUtmBitmapInit(void)
+{
+	MV_STATUS status;
+
+	status =  mvOnuGponMacUtmActiveTxBitmapSet(GPON_UTM_ACTIVE_TX_BITMAP);
+	if (status == MV_OK) {
+		status =  mvOnuGponMacUtmActiveTxBitmapValidSet(GPON_UTM_ACTIVE_TX_BITMAP_VALID);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacUtmActiveTxBitmapValidSet\n\r",
+				   __FILE_DESC__, __LINE__);
+	} else
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacUtmActiveTxBitmapSet\n\r",
+			   __FILE_DESC__, __LINE__);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicTodIntInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init Time Of Day Interrupt registers
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicTodIntInit(void)
+{
+	MV_STATUS status;
+
+	status =  mvOnuGponSuperFrameCouterSet(0);
+	if (status == MV_OK) {
+		status =  mvOnuGponTimeOfDayIntWidthSet(GPON_TOD_INT_DEFAULT_WIDTH,
+							GPON_TOD_INT_MODE_BIP_INTERVAL,
+							GPON_TOD_INT_POL_ACTIVE_HIGH);
+		if (status != MV_OK)
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "%s: ERROR in mvOnuGponTimeOfDayIntWidthSet call\n\r", __func__);
+	} else
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "%s: ERROR in mvOnuGponSuperFrameCouterSet call\n\r", __func__);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicGseTransmitThresholdInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init GSE Transmit Threshold
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicGseTransmitThresholdInit(void)
+{
+	MV_STATUS status;
+	MV_U32 threshold;
+
+	threshold = ((GPON_GST_TX_DATA_THRESHOLD << GPON_GST_TX_DATA_SHIFT) |
+		     GPON_GST_TX_IDLE_THRESHOLD);
+
+	status =  mvOnuGponMacTxGseTransCounterThresholdSet(threshold);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacUtmActiveTxBitmapValidSet\n\r",
+			   __FILE_DESC__, __LINE__);
+		return status;
+	}
+
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+**
+**  onuGponAsicInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init default onu GPON MAC configuration
+**
+**  PARAMETERS:  MV_BOOL initTime - init indication flag, true = init sequence
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponAsicInit(MV_BOOL initTime)
+{
+	MV_STATUS rcode;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	rcode =  onuGponAsicBoardInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicBoardInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	onuGponAsicLedsInit();
+
+	rcode = onuGponAsicOnuStateAndIdInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicOnuStateAndIdInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = onuGponAsicDelayInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicDelayInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = onuGponAsicOverheadInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicOverheadInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = onuGponAsicBerCounterInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicBerCounterInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = onuGponAsicFrameDelineationInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicFrameDelineationInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = onuGponAsicPloamParamInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicPloamParamInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Const RAM - serial number message + Idle message */
+	rcode = onuGponSrvcConstPloamFromDbInit(initTime);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponSrvcConstPloamFromDbInit, initTime (%d)\n",
+			   __FILE_DESC__, __LINE__, initTime);
+		return rcode;
+	}
+
+	rcode =  onuGponAsicBurstEnableInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicBurstEnableInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode =  onuGponAsicFrameLengthInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicFrameLengthInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode =  onuGponAsicPortInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicPortInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode =  mvOnuGponMacUtmTcValidSet(1);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacUtmTcValidSet\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	rcode = mvOnuPonMacAcCouplingInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuPonMacAcCouplingInit\n\r", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = mvOnuPonMacRandomDelayInit();
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) mvOnuPonMacRandomDelayInit\n\r", __FILE_DESC__, __LINE__);
+
+	rcode = onuGponAsicGseTransmitThresholdInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAsicGseTransmitThresholdInit\n\r", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	if (familyId == MV_88F66X0) {
+		rcode = onuGponAsicUtmBitmapInit();
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) onuGponAsicUtmBitmapInit\n", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+
+		rcode = onuGponAsicTodIntInit();
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) onuGponAsicTodIntInit\n", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSwitchOn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu switchOn init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponSwitchOn(void)
+{
+	MV_STATUS rcode;
+	S_BerCoefficient berCoeff;
+
+	/* init onu RTOS resources */
+	rcode = onuGponRtosResourceInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponRtosResourceInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* init onu application strcutures */
+	rcode = onuGponAppInit();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) onuGponAppInit\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	berCoeff.numerator   = ONU_GPON_BER_DEF_COEFF_NUMERATOR;
+	berCoeff.denominator = ONU_GPON_BER_DEF_COEFF_DENOMINATOR;
+	onuGponBerInit(&berCoeff, ONU_GPON_DEF_INTERNAL_BER_INTERVAL);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAppInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu gpon application: state & event table,
+**               and alarm table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponAppInit(void)
+{
+	/* onu gpon state & event table */
+	onuGponStateAndEventTblInit();
+
+	/* onu gpon alarm table */
+	onuGponAlarmTblInit();
+
+	/* onu gpon counters table */
+	onuGponPmInPmInit();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponStateAndEventTblInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function initialize the State and Event Table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponStateAndEventTblInit(void)
+{
+	MV_U32 event;
+	MV_U32 state;
+	S_OnuGponGenTbl *onuGponGenTbl_p = &(onuGponDb_s.onuGponGenTbl_s);
+
+	/* ========================================== */
+	/* Initial setup for the Status & Event table */
+	/* ========================================== */
+
+	/* set onuGponIsrNotExpected function as default */
+	for (event = 0; event < ONU_GPON_NUM_OF_EVENTS; event++)
+		for (state = 0; state < ONU_GPON_NUM_OF_STATES; state++)
+			onuGponGenTbl_p->onuGponStateAndEventTbl[event][state] = (GPONFUNCPTR)onuGponPonMngIsrNotExpected;
+
+	/* ================================== */
+	/* Message state transittions section */
+	/* ================================== */
+
+	/* ONU GPON STANDBY STATE 02 */
+	/* ------------------------- */
+	state = ONU_GPON_02_STANDBY;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_OVERHEAD][state]      = (GPONFUNCPTR)onuGponPonMngOverheadMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_PHYSICAL_EQUIP_ERR][state] = (GPONFUNCPTR)onuGponPonMngPhyEquErrMsg;
+
+	/* ONU GPON SERIAL NUM STATE 03 */
+	/* ---------------------------- */
+	state = ONU_GPON_03_SERIAL_NUM;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_SN_MASK][state] = (GPONFUNCPTR)onuGponPonMngSerialNumberMaskMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_EXT_BURST_LEN][state] = (GPONFUNCPTR)onuGponPonMngExtBurstMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_ASSIGN_ONU_ID][state] = (GPONFUNCPTR)onuGponPonMngOnuIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_PHYSICAL_EQUIP_ERR][state] = (GPONFUNCPTR)onuGponPonMngPhyEquErrMsg;
+
+	/* ONU GPON RANGING STATE 04 */
+	/* ------------------------- */
+	state = ONU_GPON_04_RANGING;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_EXT_BURST_LEN][state] = (GPONFUNCPTR)onuGponPonMngExtBurstMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_RANGING_TIME][state]  = (GPONFUNCPTR)onuGponPonMngRangeTimeMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DACT_ONU_ID][state]   = (GPONFUNCPTR)onuGponPonMngDactOnuIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_PHYSICAL_EQUIP_ERR][state] = (GPONFUNCPTR)onuGponPonMngPhyEquErrMsg;
+
+	/* ONU GPON OPERATION STATE 05 */
+	/* --------------------------- */
+	state = ONU_GPON_05_OPERATION;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_EXT_BURST_LEN][state] = (GPONFUNCPTR)onuGponPonMngExtBurstMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_RANGING_TIME][state]  = (GPONFUNCPTR)onuGponPonMngRangeTimeMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DACT_ONU_ID][state]   = (GPONFUNCPTR)onuGponPonMngDactOnuIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_CONFIG_PORT_ID][state] = (GPONFUNCPTR)onuGponPonMngCfgPortIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_PHYSICAL_EQUIP_ERR][state] = (GPONFUNCPTR)onuGponPonMngPhyEquErrMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_ENCRYPT_VPI_PORT_ID][state] = (GPONFUNCPTR)onuGponPonMngEncrptPortIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_ASSIGN_ALLOC_ID][state] = (GPONFUNCPTR)onuGponPonMngAssignAllocIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_REQ_PASSWORD][state]  = (GPONFUNCPTR)onuGponPonMngReqPassMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_REQ_KEY][state]       = (GPONFUNCPTR)onuGponPonMngReqKeyMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_BER_INTERVAL][state]  = (GPONFUNCPTR)onuGponPonMngBerIntervalMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_KEY_SWITCH_TIME][state] = (GPONFUNCPTR)onuGponPonMngKeySwitchTimeMsg;
+
+	/* ONU GPON POPUP STATE 06 */
+	/* ----------------------- */
+	state = ONU_GPON_06_POPUP;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_POPUP][state]         = (GPONFUNCPTR)onuGponPonMngPopupMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DACT_ONU_ID][state]   = (GPONFUNCPTR)onuGponPonMngDactOnuIdMsg;
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+
+	/* ONU GPON EMERGANCY STOP STATE 07 */
+	/* -------------------------------- */
+	state = ONU_GPON_07_EMERGANCY_STOP;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_MSG_DIS_SN][state]        = (GPONFUNCPTR)onuGponPonMngDisSnMsg;
+
+	/* =================== */
+	/* Alarm event section */
+	/* =================== */
+	for (state  = ONU_GPON_01_INIT; state <= ONU_GPON_07_EMERGANCY_STOP; state++) {
+		/* generate */
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_GEN_LOS][state]     = (GPONFUNCPTR)onuGponPonMngGenCritAlarm;
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_GEN_LOF][state]     = (GPONFUNCPTR)onuGponPonMngGenCritAlarm;
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_GEN_LCDG][state]    = (GPONFUNCPTR)onuGponPonMngGenCritAlarm;
+
+		/* cancel */
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_CAN_LOS][state]     = (GPONFUNCPTR)onuGponPonMngCanCritAlarm;
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_CAN_LOF][state]     = (GPONFUNCPTR)onuGponPonMngCanCritAlarm;
+		onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_CAN_LCDG][state]    = (GPONFUNCPTR)onuGponPonMngCanCritAlarm;
+	}
+
+	/* MEM alarm */
+	/* --------- */
+	state = ONU_GPON_05_OPERATION;
+
+	onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_GEN_MEM][state]       = (GPONFUNCPTR)onuGponPonMngGenMemAlarm;
+}
+
+/*******************************************************************************
+**
+**  onuGponOperate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function execute onu operate init sequence
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponOperate(void)
+{
+#if 0   /* standalone bring up */
+	MV_STATUS rcode;
+	MV_U32 interruptMask;
+	MV_BOOL disabledSnState;
+	MV_U8 serialNumber[8];
+	MV_U8 password[10];
+
+	/* ======================================================= */
+	/* ================ Disable SN Section =================== */
+	/* ======================================================= */
+
+	/* register disable SN handler */
+	onuGponPonMngDisableSetRegister(onuGponDisableSnSetHandler);
+
+	/* get disable State */
+	onuGponDisableSnGetHandler(&disabledSnState);
+	if (disabledSnState == MV_FALSE)
+		/* Send Disable Notification to upper layer */
+		onuGponSrvcDisableMsgNotify(MV_FALSE, MV_TRUE);
+	else{
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "==================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "== ONT DISABLED ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "==================\n");
+		/* Send Disable Notification to upper layer */
+		onuGponSrvcDisableMsgNotify(MV_TRUE, MV_TRUE);
+	}
+
+	/* ======================================================= */
+	/* ================ Serial NUmber Section ================ */
+	/* ======================================================= */
+	onuGponSerialNumberHandler(serialNumber);
+
+	/* ======================================================= */
+	/* ================ Password Section ===================== */
+	/* ======================================================= */
+	onuGponPasswordHandler(password);
+
+	/* ======================================================= */
+	/* ================ Init App Section ===================== */
+	/* ======================================================= */
+	onuGponApiSnMaskConfig(MV_FALSE, MV_FALSE);
+	onuGponApiInit(serialNumber, password, disabledSnState, 0, 1, 0, 7);
+
+	/* XVR reset sequence */
+	mvOnuGponMacXvrReset(0);
+
+	/* Enable AES in SoC */
+	mvOnuGponMacAesEnableSet(MV_TRUE);
+
+	/* enable onu gpon interrupt mask */
+	interruptMask = 0;
+	interruptMask |= ONU_GPON_INTERRUPTS_BAISC << 16;
+	rcode = mvOnuGponMacPonInterruptMaskSet(interruptMask);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Enable PON interrupt mask\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	/* enable onu dying gasp interrupt mask */
+	rcode = mvOnuPonMacDgInterruptEn(0x1); /* Active High */
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Enable Dying Gasp interrupt mask\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	/* ======================================================= */
+	/* ================ Enable MAC RX ======================== */
+	/* ======================================================= */
+	mvOnuGponMacRxConfigSet(MV_TRUE);
+
+#else   /* dynamic bring up */
+
+	onuGponApiSnMaskConfig(MV_FALSE, MV_FALSE);
+
+	/* XVR reset sequence */
+	mvOnuGponMacXvrReset(0);
+
+	/* Enable AES in SoC */
+	mvOnuGponMacAesEnableSet(MV_TRUE);
+
+#endif
+
+	printk(KERN_INFO "= PON Module Operate ended successfully =\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponStart
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function start onu app
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponStart(S_GponIoctlInfo *onuInit)
+{
+	MV_STATUS rcode;
+	MV_U32 interruptMask;
+	MV_BOOL disabledSnConfig;
+	MV_BOOL disabledSnSaving;
+	MV_BOOL disabledSn;
+
+	/* ======================================================= */
+	/* ================ Disable SN Section =================== */
+	/* ======================================================= */
+	disabledSnConfig = (onuInit->disableSn != 0) ? (MV_TRUE) : (MV_FALSE);
+	disabledSnSaving = (onuInit->disStatus != 0) ? (MV_TRUE) : (MV_FALSE);
+
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "%s:%d disableSn(%d) disStatus(%d)\n",
+		   __func__, __LINE__, onuInit->disableSn, onuInit->disStatus);
+
+	if (disabledSnConfig == MV_FALSE) { /* Not disabled by configuration */
+		if (disabledSnSaving == MV_FALSE)   /* Not saved as disabled */
+			disabledSn = MV_FALSE;
+		else    /* Saved as disabled */
+			disabledSn = MV_TRUE;
+	} else  /* disabled by configuration */
+		disabledSn = MV_TRUE;
+
+	if (disabledSn == MV_TRUE) {
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "==================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "== ONT DISABLED ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "==================\n");
+
+		/* Send Disable Notification to upper layer(no save) */
+		onuGponSrvcDisableMsgNotify(MV_TRUE, MV_FALSE);
+	}
+
+	/* ======================================================= */
+	/* ================ Init App Section ===================== */
+	/* ======================================================= */
+	onuGponApiInit(onuInit->serialNum,
+		       onuInit->password,
+		       disabledSn,
+		       onuInit->serialNumSource,
+		       onuInit->fecHyst,
+		       onuInit->couplingMode,
+		       onuInit->omciCpuRxQueue);
+	onuGponDbGemResetSet(INT_TO_MV_BOOL(onuInit->clearGem));
+	onuGponDbTcontResetSet(INT_TO_MV_BOOL(onuInit->clearTcont));
+	onuGponDbGemRestoreSet(INT_TO_MV_BOOL(onuInit->restoreGem));
+	onuGponDbOmciFastPathSet(INT_TO_MV_BOOL(onuInit->omciFastPath));
+	onuGponHighPriTxMapInit(&onuInit->ponHighPriTx);
+
+	/* ======================================================= */
+	/* ================ Enable PON Interrupt Section ========= */
+	/* ======================================================= */
+	interruptMask = 0;
+	if (MV_TRUE == onuGponDbOmciFastPathGet())
+		interruptMask |= ONU_GPON_INTERRUPTS_EXTEND << 16;
+	else
+		interruptMask |= ONU_GPON_INTERRUPTS_BASIC << 16;
+
+	rcode = mvOnuGponMacPonInterruptMaskSet(interruptMask);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Enable PON interrupt mask\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	/* ======================================================= */
+	/* ================ PON XVR polarity Section ============= */
+	/* ======================================================= */
+	rcode = mvOnuGponMacTxBurstEnPolaritySet(onuInit->ponXvrBurstEnPolarity);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Set XVR polarity\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	ponXvrFunc = funcGponXvrSDStatus(onuInit->ponXvrPolarity);
+
+	onuP2PDbXvrBurstEnablePolaritySet(onuInit->p2pXvrBurstEnPolarity);
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	/* ========================================================== */
+	/* ================ Dying Gasp Interrupt / Polarity Section = */
+	/* ========================================================== */
+	rcode = mvOnuPonMacDgInterruptEn(onuInit->dgPolarity);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Enable Dying Gasp interrupt mask\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	/* ======================================================= */
+	/* ================ Enable MAC RX ======================== */
+	/* ======================================================= */
+	mvOnuGponMacRxConfigSet(MV_TRUE);
+	mvOnuGponMacRxConfigBitOrderSet(1);
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	rcode = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) mvOnuEponMacOnuIOEnable\n\r", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+#ifdef PON_A0
+	/* ======================================================= */
+	/* ================ Enable D/S OMCI fast path ============ */
+	/* ======================================================= */
+	rcode = mvOnuGponMacGemOmciFastPathSet(onuInit->omciFastPath);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) set PON D/S OMCC fast path\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+#endif
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonMacAcCouplingInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function inits AC coupling configuration
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS mvOnuPonMacAcCouplingInit(void)
+{
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (familyId != MV_88F66X0)
+		return MV_OK;
+
+	return mvOnuGponMacTxConfigAcCouplingSet(GPON_TX_AC_COUPL_BUST_MODE_0,
+						 GPON_TX_AC_COUPL_PREACT_BURST_TIME,
+						 GPON_TX_AC_COUPL_DATA_PATTERN_1,
+						 GPON_TX_AC_COUPL_DATA_PATTERN_2);
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonMacRandomDelayInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function inits random delay units
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS mvOnuPonMacRandomDelayInit(void)
+{
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (familyId != MV_88F66X0)
+		return mvOnuGponMacTxRandomDelayUnitsSet(0);  /* old mode */
+	else
+		return mvOnuGponMacTxRandomDelayUnitsSet(5);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.h
new file mode 100644
index 0000000..332e470
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuInit.h
@@ -0,0 +1,125 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuInit.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON init sequence definitions      **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_INIT_H
+#define _ONU_GPON_INIT_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponAsicDelayInit(void);
+MV_STATUS onuGponAsicOverheadInit(void);
+MV_STATUS onuGponAsicPortIdsInit(void);
+MV_STATUS onuGponAsicBerCounterInit(void);
+MV_STATUS onuGponAsicPloamParamInit(void);
+MV_STATUS onuGponAsicFrameDelineationInit(void);
+MV_STATUS onuGponAsicTxInit(void);
+MV_STATUS onuGponAsicBurstEnableInit(void);
+MV_STATUS onuGponAsicFrameLengthInit(void);
+MV_STATUS onuGponAsicPortInit(void);
+MV_STATUS onuGponAsicBoardInit(void);
+MV_STATUS onuGponAsicInit(MV_BOOL initTime);
+MV_STATUS onuGponAppInit(void);
+void	  onuGponStateAndEventTblInit(void);
+void	  onuGponInPmInit(void);
+MV_STATUS mvOnuPonMacAcCouplingInit(void);
+MV_STATUS mvOnuPonMacRandomDelayInit(void);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponPreSetup(void);
+MV_STATUS onuGponSetup(void);
+MV_STATUS onuGponSwitchOn(void);
+MV_STATUS onuGponOperate(void);
+MV_STATUS onuGponStart(S_GponIoctlInfo *onuInit);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_INIT_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.c
new file mode 100644
index 0000000..afed2d2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.c
@@ -0,0 +1,553 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuIsr.c                                               **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Interrupt handling           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuIsr.c"
+
+#define MV_NO_XVR_RST (0xFF)
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+extern MV_U32 berIntervalForTypeB_Flag;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 g_onuGponPreviousInterrupt = ONU_GPON_INT_ALARMS;
+MV_U32 g_onuGponCurrentInterrupt = 0;
+S_OnuGponIsrCounters g_onuGponIsrCounters;
+MV_BOOL g_ponDebugMode = MV_FALSE;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Operational Section                                */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponIsrInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset onu interrupt counters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponIsrInit(void)
+{
+	MV_U32 i;
+
+	g_onuGponIsrCounters.interruptReadError = 0;
+	g_onuGponIsrCounters.ploamStatusNoInterrupt = 0;
+	for (i = 0; i < ONU_GPON_ISR_TYPE_MAX; i++) {
+		g_onuGponIsrCounters.sendMessageError[i] = 0;
+		g_onuGponIsrCounters.setEventError[i] = 0;
+	}
+
+	for (i = 0; i < ON_GPON_MAX_ALARMS; i++)
+		g_onuGponIsrCounters.interruptSameStatus[i] = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIsrXvrResetTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the GPON Iterrupt handler to execute
+**               XVR reset sequence in case of a problem with XVR signal detect
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponIsrXvrResetTimerHndl(unsigned long data)
+{
+	MV_STATUS status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 3, 1, 0);
+	if (berIntervalForTypeB_Flag != 0) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 5, 0, 1);
+		berIntervalForTypeB_Flag = 0;
+		mvOnuGponMacBipInterruptIntervalSet(onuGponDbBerIntervalGet());
+	}
+
+	status = onuGponIsrXvrReset();
+	if (status != MV_NO_XVR_RST) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 3, 1, 1);
+		if ((onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerPeriodic) != 0)
+			onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+	} else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponDgIsrRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements Dying Gasp
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponDgIsrRoutine(void)
+{
+	onuGponPonMngIntrDgHandler();
+}
+
+/*******************************************************************************
+**
+**  onuGponIsrLowRoutine
+**  onuGponIsrRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements interrupt polling mode, it polls the
+**               current status of an interrupt compare it to the previous
+**               status, and if an interrupt is active trigger the operation
+**               of the pon manager task.
+**
+**  PARAMETERS:  None, void* param
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None, void*
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponIsrLowRoutine
+**
+*******************************************************************************/
+void onuGponIsrLowRoutine(MV_U32 *interruptEvent, MV_U32 *interruptStatus)
+{
+	MV_U32 interrupt;
+	MV_U32 interruptRawEvent;
+	MV_U32 bip8InterruptValue;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_ISR_PERFORMANCE]);
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+	mvOnuGponMacPonInterruptGet(&interrupt);
+	g_onuGponCurrentInterrupt &= 0xFFFF0000;
+	g_onuGponCurrentInterrupt |= interrupt;
+
+#ifdef PON_A0
+	if (MV_TRUE == onuGponDbOmciFastPathGet())
+		interruptRawEvent = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) &
+				    ONU_GPON_INTERRUPTS_EXTEND;
+	else
+		interruptRawEvent = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) &
+				    ONU_GPON_INTERRUPTS_BASIC;
+#else
+	interruptRawEvent = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) &
+			    ONU_GPON_INTERRUPTS_BASIC;
+#endif
+
+	if (interruptRawEvent & ONU_GPON_BIP_INERVAL_MASK) {
+		mvOnuGponMacBipInterruptStatusValueGet(&bip8InterruptValue);
+		onuGponDbBipInterruptStatusValueSet(bip8InterruptValue);
+	}
+#ifdef PON_A0
+	if (MV_TRUE == onuGponDbOmciFastPathGet()) {
+		*interruptEvent  = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) & ONU_GPON_INTERRUPTS_EXTEND;
+		*interruptStatus = (g_onuGponCurrentInterrupt) & ONU_GPON_INTERRUPTS_EXTEND;
+	} else {
+		*interruptEvent  = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) & ONU_GPON_INTERRUPTS_BASIC;
+		*interruptStatus = (g_onuGponCurrentInterrupt) & ONU_GPON_INTERRUPTS_BASIC;
+	}
+#else
+	*interruptEvent  = (g_onuGponCurrentInterrupt >> ONU_GPON_EVENT_SHIFT) & ONU_GPON_INTERRUPTS_BASIC;
+	*interruptStatus = (g_onuGponCurrentInterrupt) & ONU_GPON_INTERRUPTS_BASIC;
+#endif
+	onuGponSyncLog(ONU_GPON_LOG_INTERRUPT, g_onuGponCurrentInterrupt, 0, 0);
+
+	g_onuGponCurrentInterrupt = 0;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+}
+
+/*******************************************************************************
+**
+**  onuGponIsrRoutine
+**
+*******************************************************************************/
+void onuGponIsrRoutine(MV_U32 event, MV_U32 status)
+{
+	MV_BOOL state;
+	MV_U32 interruptEvent;
+	MV_U32 interruptStatus;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	MV_U32 timer = 0;
+#endif
+
+#ifdef MV_GPON_HW_INTERRUPT
+	onuGponIsrLowRoutine(&interruptEvent, &interruptStatus);
+#else
+	interruptEvent  = event;
+	interruptStatus = status;
+#endif  /* MV_GPON_HW_INTERRUPT */
+
+	if (g_ponDebugMode != MV_TRUE) {
+#ifdef MV_GPON_DEBUG_PRINT
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT, &timer, 0);
+		mvPonPrint(PON_PRINT_DEBUG, PON_ISR_MODULE,
+			   "DEBUG: (%s:%d) Event(0x%08x) Status(0x%08x) timestamp(%d)\n",
+			   __FILE_DESC__, __LINE__, interruptEvent, interruptStatus, timer);
+#endif
+
+		if ((interruptEvent & ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK) &&
+		    (interruptEvent & ONU_GPON_LOF_ALARM_MASK)) {
+			/* Handle LOF ALARM */
+			/* ================ */
+			state = (interruptStatus & ONU_GPON_LOF_ALARM_MASK) ? MV_TRUE : MV_FALSE;
+			onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOF_ALARM, state);
+
+			onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_LOF, state, 0, 0);
+
+			if (state != MV_TRUE)
+				onuGponPonMngIntrMessageHandler();
+
+			/* Handle LOS ALARM */
+			/* ================ */
+			state = ponXvrFunc(interruptStatus, ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK);
+
+			if (state == MV_TRUE) {
+				onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOS_ALARM, MV_FALSE);
+				onuGponDbOnuSignalDetectSet(1);
+				onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 3, 0, 0);
+				onuGponIsrXvrReset();
+				onuGponIsrXvrResetStateSet(MV_TRUE);
+			} else if (state == MV_FALSE) {
+				onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOS_ALARM, MV_TRUE);
+				onuGponDbOnuSignalDetectSet(0);
+			}
+			onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_XVR_SD, state, 0, 0);
+		} else {
+			/* Handle LOS ALARM */
+			/* ================ */
+			if (interruptEvent & ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK) {
+				state = ponXvrFunc(interruptStatus, ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK);
+
+				if (state == MV_TRUE) {
+					onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOS_ALARM, MV_FALSE);
+					/* Set signal detect to ON */
+					onuGponDbOnuSignalDetectSet(1);
+
+#ifdef MV_GPON_DEBUG_PRINT
+					mvPonPrint(PON_PRINT_DEBUG, PON_ISR_MODULE,
+						   "DEBUG: (%s:%d) Set signal detect to ON = 1 \n",
+						   __FILE_DESC__, __LINE__);
+#endif                                  /* MV_GPON_DEBUG_PRINT */
+					onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 3, 0, 1);
+					onuGponIsrXvrReset();
+					onuGponIsrXvrResetStateSet(MV_TRUE);
+				} else if (state == MV_FALSE) {
+					onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOS_ALARM, MV_TRUE);
+					/* Set signal detect to OFF */
+					onuGponDbOnuSignalDetectSet(0);
+
+#ifdef MV_GPON_DEBUG_PRINT
+					mvPonPrint(PON_PRINT_DEBUG, PON_ISR_MODULE,
+						   "DEBUG: (%s:%d) Set signal detect to OFF = 0\n",
+						   __FILE_DESC__, __LINE__);
+#endif                                  /* MV_GPON_DEBUG_PRINT */
+				}
+
+				onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_XVR_SD, state, 0, 0);
+			}
+
+			/* Handle LOF ALARM */
+			/* ================ */
+			if (interruptEvent & ONU_GPON_LOF_ALARM_MASK) {
+				state = (interruptStatus & ONU_GPON_LOF_ALARM_MASK) ? MV_TRUE : MV_FALSE;
+				onuGponPonMngIntrAlarmHandler(ONU_PON_MNGR_LOF_ALARM, state);
+
+				onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_LOF, state, 0, 0);
+
+				if (state != MV_TRUE)
+					onuGponPonMngIntrMessageHandler();
+			}
+		}
+
+		if (interruptEvent & ONU_GPON_DS_PLOAM_MASK)
+			onuGponPonMngIntrMessageHandler();
+
+
+		/* Handle BER INTERVAL */
+		/* =================== */
+		if (interruptEvent & ONU_GPON_BIP_INERVAL_MASK) {
+			if (berIntervalForTypeB_Flag != 0) {
+				onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 5, 0, 0);
+				onuGponIsrXvrReset();
+				berIntervalForTypeB_Flag = 0;
+				mvOnuGponMacBipInterruptIntervalSet(onuGponDbBerIntervalGet());
+			} else
+				onuGponPonMngIntrBeCounterHandler();
+		}
+
+#ifdef PON_A0
+		/* Handle OMCI message */
+		/* =================== */
+		if (interruptEvent & ONU_GPON_HQ_EMPTY_MASK)
+			onuGponPonMngOmciHandler();
+
+#endif
+
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngDebugModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu debug mode
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngDebugModeSet(MV_BOOL mode)
+{
+	g_ponDebugMode = mode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngDebugModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns onu debug mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     Debug mode
+**
+*******************************************************************************/
+MV_BOOL onuGponPonMngDebugModeGet(void)
+{
+	return g_ponDebugMode;
+}
+
+/*******************************************************************************
+**
+**  onuGponIsrXvrReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset xvr
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponIsrXvrReset(void)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+	MV_STATUS status;
+	MV_U32 onuState;
+	MV_U32 initDone;
+	MV_U32 durationStart = 0;
+	MV_U32 durationEnd   = 0;
+
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 0, 0);
+	onuState = onuGponDbOnuStateGet();
+	if ((onuState == ONU_GPON_01_INIT) ||
+	    ((onuState == ONU_GPON_07_EMERGANCY_STOP) && (onuGponAsicAlarmStatusGet() == ONU_GPON_ALARM_ON)) ||
+	    ((onuState == ONU_GPON_06_POPUP)&& ((onuGponAlarmGet(ONU_GPON_ALARM_LOS) == ONU_GPON_ALARM_OFF) &&
+	     (onuGponAlarmGet(ONU_GPON_ALARM_LOF) == ONU_GPON_ALARM_ON)))) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 1, 0);
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT, &durationStart, 0);
+		onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_SERDES_START, 0, 0, 0);
+
+		status = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+		if (status != MV_OK)
+			return status;
+
+		do {
+			status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+			if (status != MV_OK) {
+				onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 2, 0);
+				return status;
+			}
+
+			asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT, &durationEnd, 0);
+			if (abs((durationEnd - durationStart)) >= 6000) {
+				onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 3, 0);
+				return MV_OK;
+			}
+
+		} while (initDone == 0);
+
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 4, 0);
+
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+		if (status != MV_OK)
+			return status;
+
+		onuGponSyncLog(ONU_GPON_LOG_INTERRUPT_SERDES_STOP, 0, 0, 0);
+	} else {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 5, 0);
+		return MV_NO_XVR_RST;
+	}
+
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 2, 6, 0);
+#endif
+#endif  /* PON_FPGA */
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIsrXvrResetStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable onu xvr reset timer
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponIsrXvrResetStateSet(MV_BOOL mode)
+{
+	MV_STATUS rcode = MV_OK;
+
+	if (mode == MV_TRUE) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 1, 1,
+			       onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerId.expires);
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 1, 2,
+			       onuPonResourceTbl_s.onuPonIsrXvrRstTimerId.onuPonTimerId.expires);
+	} else {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 1, 0, 0);
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId));
+	}
+
+	return rcode;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.h
new file mode 100644
index 0000000..505f65b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuIsr.h
@@ -0,0 +1,182 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuIsr.h                                               **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Interrupt implementation       **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_ISR_H
+#define _ONU_GPON_ISR_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define ONU_GPON_LOS_ALARM_MASK                 (0x0001)
+#define ONU_GPON_LOF_ALARM_MASK                 (0x0002)
+#define ONU_GPON_LCDG_ALARM_MASK                (0x0004)
+#define ONU_GPON_DS_PLOAM_MASK                  (0x0008)
+#define ONU_GPON_CDR_LOL_MASK                   (0x0010)
+#define ONU_GPON_BIP_INERVAL_MASK               (0x0020)
+#define ONU_GPON_RAM_TEST_GRX_PARITY_ERR_MASK   (0x0040)
+#define ONU_GPON_RAM_TEST_GEM_PARITY_ERR_MASK   (0x0080)
+#define ONU_GPON_RAM_TEST_GTX_PARITY_ERR_MASK   (0x0100)
+#define ONU_GPON_RAM_TEST_UTM_PARITY_ERR_MASK   (0x0200)
+#define ONU_GPON_PHY_READY_STATUS_MASK          (0x0400)
+#define ONU_GPON_PHY_SIGNAL_DETECT_STATUS_MASK  (0x0800)
+#define ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK  (0x1000)
+#define ONU_GPON_HQ_EMPTY_MASK                  (0x8000)
+
+#define ONU_GPON_LOS_ALARM_SHIFT                (0)
+#define ONU_GPON_LOF_ALARM_SHIFT                (1)
+#define ONU_GPON_LCDG_ALARM_SHIFT               (2)
+#define ONU_GPON_DS_PLOAM_SHIFT                 (3)
+#define ONU_GPON_CDR_LOL_SHIFT                  (4)
+#define ONU_GPON_BIP_INERVAL_SHIFT              (5)
+#define ONU_GPON_RAM_TEST_GRX_PARITY_ERR_SHIFT  (6)
+#define ONU_GPON_RAM_TEST_GEM_PARITY_ERR_SHIFT  (7)
+#define ONU_GPON_RAM_TEST_GTX_PARITY_ERR_SHIFT  (8)
+#define ONU_GPON_RAM_TEST_UTM_PARITY_ERR_SHIFT  (9)
+#define ONU_GPON_PHY_READY_STATUS_SHIFT         (10)
+#define ONU_GPON_PHY_SIGNAL_DETECT_STATUS_SHIFT (11)
+#define ONU_GPON_XVR_SIGNAL_DETECT_STATUS_SHIFT (12)
+#define ONU_GPON_HQ_EMPTY_SHIFT                 (15)
+
+#define ONU_GPON_EVENT_SHIFT                    (16)
+
+#define ON_GPON_MAX_ALARMS                      (3)
+
+#define ONU_GPON_INT_ALARMS                     (ONU_GPON_LOF_ALARM_MASK)
+
+#define ONU_GPON_PARITY_ERROR                   (ONU_GPON_RAM_TEST_GRX_PARITY_ERR_MASK  | \
+						 ONU_GPON_RAM_TEST_GEM_PARITY_ERR_MASK  | \
+						 ONU_GPON_RAM_TEST_GTX_PARITY_ERR_MASKK | \
+						 ONU_GPON_RAM_TEST_UTM_PARITY_ERR_MASK)
+
+#define ONU_GPON_READY_STATUS                   (ONU_GPON_PHY_READY_STATUS_SHIFT         | \
+						 ONU_GPON_PHY_SIGNAL_DETECT_STATUS_SHIFT | \
+						 ONU_GPON_XVR_SIGNAL_DETECT_STATUS_SHIFT)
+
+#define ONU_GPON_INTERRUPTS_BASIC               (ONU_GPON_INT_ALARMS | \
+						 ONU_GPON_DS_PLOAM_MASK | \
+						 ONU_GPON_BIP_INERVAL_MASK | \
+						 ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK)
+
+#define ONU_GPON_INTERRUPTS_EXTEND              (ONU_GPON_INT_ALARMS | \
+						 ONU_GPON_DS_PLOAM_MASK | \
+						 ONU_GPON_BIP_INERVAL_MASK | \
+						 ONU_GPON_XVR_SIGNAL_DETECT_STATUS_MASK | \
+						 ONU_GPON_HQ_EMPTY_MASK)
+
+#define ONU_GPON_INTERRUPT_INTERVAL             (10)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	ONU_GPON_ISR_ALARM,
+	ONU_GPON_ISR_PLOAM,
+	ONU_GPON_ISR_BIP,
+	ONU_GPON_ISR_TYPE_MAX
+} E_OnuGponIsrTypes;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 interruptReadError;
+	MV_U32 sendMessageError[ONU_GPON_ISR_TYPE_MAX];
+	MV_U32 setEventError[ONU_GPON_ISR_TYPE_MAX];
+	MV_U32 interruptSameStatus[ON_GPON_MAX_ALARMS];
+	MV_U32 ploamStatusNoInterrupt;
+} S_OnuGponIsrCounters;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponIsrXvrReset(void);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponIsrInit(void);
+void      onuGponIsrLowRoutine(MV_U32 *interruptEvent, MV_U32 *interruptStatus);
+void      onuGponIsrRoutine(MV_U32 interruptEvent, MV_U32 interruptStatus);
+void      onuGponDgIsrRoutine(void);
+void      onuGponIsrXvrResetTimerHndl(unsigned long data);
+MV_STATUS onuGponIsrXvrResetStateSet(MV_BOOL mode);
+void      onuGponPonMngDebugModeSet(MV_BOOL mode);
+MV_BOOL   onuGponPonMngDebugModeGet(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_ISR_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.c
new file mode 100644
index 0000000..f739427
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.c
@@ -0,0 +1,651 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuMngr.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Manager functionality        **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+#include "mvDebug.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuMngr.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+MV_U32 g_mngrSuspiciousFifoErrCounter = 0;
+MV_U32 g_mngrDecidedFifoErrCounter    = 0;
+
+MV_U8 *dsPloamText[MAC_LAST_DOWNSTREAM_PLOAM + 1] = {
+	"UNKNOWN",
+	"UPSTREAM OVERHEAD",
+	"SERIAL_NUMBER MASK",
+	"ASSIGN ONU ID",
+	"RANGING TIME",
+	"DEACTIVATE ONU ID",
+	"DISABLE SERIAL NUMBER",
+	"CONFIGURE VP/VC",
+	"ENCRYPTED PORT-ID/VPI",
+	"REQUEST PASSWORD",
+	"ASSIGN ALLOC ID",
+	"NO MESSAGE",
+	"POPUP",
+	"REQUEST KEY",
+	"CONFIGURE PORT-ID",
+	"PEE",
+	"CHANGE POWER LEVEL",
+	"PST MESSAGE",
+	"BER INTERVAL",
+	"KEY SWITCHING TIME",
+	"EXTENDED BURST LENGTH"
+};
+
+extern spinlock_t onuPonIrqLock;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Operational Section                                */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPonMngIntrAlarmHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt alarm
+**               functionality
+**               - handle alarms (LOS, LOF, and LCDG)
+**
+**  PARAMETERS:  MV_U32 alarm
+**               MV_U32 alarmStatus
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngIntrAlarmHandler(MV_U32 alarm, MV_BOOL alarmStatus)
+{
+	MV_U32 onuState;
+	MV_U32 alarmIndex;
+	MV_U32 alarmEvent;
+	GPONFUNCPTR ptrFunc;
+	S_OnuGponGenTbl *onuGponGenTbl_p;
+	MV_U32 eventBase;
+
+	/* Events State Machine Table */
+	onuGponGenTbl_p = &(onuGponDb_s.onuGponGenTbl_s);
+
+	/* get onu state */
+	onuState = onuGponDbOnuStateGet();
+
+	/* Get the Alarm Index in the Event Table */
+	switch (alarm) {
+	case ONU_PON_MNGR_LOS_ALARM:
+		alarmIndex = ONU_GPON_ALARM_LOS;
+		alarmEvent = ONU_GPON_EVENT_ALARM_LOS;
+		break;
+	case ONU_PON_MNGR_LOF_ALARM:
+		alarmIndex = ONU_GPON_ALARM_LOF;
+		alarmEvent = ONU_GPON_EVENT_ALARM_LOF;
+		break;
+	case ONU_PON_MNGR_LCDG_ALARM:
+		alarmIndex = ONU_GPON_ALARM_LCDG;
+		alarmEvent = ONU_GPON_EVENT_ALARM_LCDG;
+		break;
+	default:
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Unkown Alarm Type, alarm(%d), status(%d)\n",
+			   __FILE_DESC__, __LINE__, alarm, alarmStatus);
+		return;
+	}
+
+	/* Get the Base Enum in the Event Table */
+	eventBase = (alarmStatus == MV_TRUE) ? ONU_GPON_ALARM_GEN_BASE : ONU_GPON_ALARM_CAN_BASE;
+
+	/* handle alarm deactivation */
+	ptrFunc = onuGponGenTbl_p->onuGponStateAndEventTbl[eventBase + alarmEvent][onuState];
+	if (ptrFunc == NULL) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Cancel alarm - function is NULL, alarm(%d), status(%d)\n",
+			   __FILE_DESC__, __LINE__, alarm, alarmStatus);
+	} else
+		(*ptrFunc)(alarmIndex, 0, NULL);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngIntrMessageHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt message
+**               functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngIntrMessageHandler(void)
+{
+	MV_STATUS rcode;
+	MV_U32 ploamFifoSize;
+	static MV_U32 ploamErrorCounter = 0;
+	MV_U32 i;
+	MV_U32 dummyBuffer;
+	MV_U8 msgData[12];
+	MV_U8 msgOnuId;
+	MV_U8 msgId;
+	MV_BOOL onuValid;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_MNG1_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+	/* Get the Init value of the ONU (if it MV_FALSE - not Valid yet) */
+	onuValid = onuGponDbInitGet();
+
+	/* read fifo size */
+	rcode = mvOnuGponMacRxPloamDataUsedGet(&ploamFifoSize);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read ploam message fifo size\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+		   "DEBUG: (%s:%d) PLOAM FIFO Used (%d) words\n", __FILE_DESC__, __LINE__, ploamFifoSize);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+	/* there is at least one full ploam message in the fifo */
+	while (ploamFifoSize >= 3) {
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_MNG2_PERFORMANCE]);
+
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* clear received message content */
+		memset((void *)msgData, 0, sizeof(msgData));
+
+		/* read message from fifo */
+		rcode = mvOnuGponMacMessageReceive(&msgOnuId, &msgId, msgData);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Read ploam message\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+			   "[DS PLOAM] %s, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+			   dsPloamText[(msgId > 20) ? 0 : msgId], msgOnuId, msgId,
+			   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+			   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		if (msgId == 12)
+			onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 6, 0, 0);
+
+		onuGponPmRxSwCountersAdd(msgId);
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+		if (tmpPmCheckNode->uSecCntIdx < 255)
+			tmpPmCheckNode->uSecCntIdx++;
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* If ONU wasn't init ONU will receive Downstream PLOAMs but won't handle it */
+		if (onuValid != MV_FALSE)
+			onuGponPonMngPloamProcess(msgOnuId, msgId, msgData);
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_MNG3_PERFORMANCE]);
+
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* Check first if there are any complete message in FIFO */
+		rcode = mvOnuGponMacRxPloamDataUsedGet(&ploamFifoSize);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "ERROR: (%s:%d) Read ploam message\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+		if (tmpPmCheckNode->uSecCntIdx < 255)
+			tmpPmCheckNode->uSecCntIdx++;
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+	} /* while */
+
+	/* Clean FIFO if it lost alignment */
+	if ((ploamFifoSize > 0) && (ploamFifoSize < 3)) {
+		ploamErrorCounter++;
+		g_mngrSuspiciousFifoErrCounter++;
+		if (ploamErrorCounter == 3) {
+			g_mngrDecidedFifoErrCounter++;
+			for (i = 0; i < ploamFifoSize; i++)
+				mvOnuGponMacRxPloamDataGet(&dummyBuffer);
+		}
+	} else
+		ploamErrorCounter = 0;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngPloamProcess
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Hadnle single received PLAOM message
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngPloamProcess(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_U32 appOnuId;
+	MV_U32 onuState;
+	GPONFUNCPTR ptrFunc;
+	S_OnuGponGenTbl *onuGponGenTbl_p = &(onuGponDb_s.onuGponGenTbl_s);
+	MV_U32          *msgData_p = (MV_U32 *)msgData;
+
+	/* get onu Id */
+	appOnuId = onuGponDbOnuIdGet();
+
+	/* get onu state */
+	onuState = onuGponDbOnuStateGet();
+
+	/* Filter for messages with invalid ONU Id */
+	if ((onuId == ONU_GPON_BROADCAST_ONU_ID) || (onuId == appOnuId)) {
+		/* Handle valid messages */
+		if ((msgId >= ONU_GPON_DS_MSG_OVERHEAD) && (msgId <= ONU_GPON_DS_MSG_EXT_BURST_LEN)) {
+			/* Call the relevant event function */
+			ptrFunc = (onuGponGenTbl_p->onuGponStateAndEventTbl[(msgId)][onuState]);
+			if (ptrFunc == NULL) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Msg function is NULL, onuId(%d), msgId(%d)\n",
+					   __FILE_DESC__, __LINE__, onuId, msgId);
+			} else {
+				onuGponSyncLog(ONU_GPON_LOG_MSG, onuId, msgId, 0);
+				onuGponSyncLog(ONU_GPON_LOG_MSG_CONTENT, *(msgData_p),
+					       *(msgData_p + 1), *(msgData_p + 2));
+				(*ptrFunc)(onuId, msgId, msgData);
+			}
+
+		} else { /* handle invalid messages */
+			/* Call the relevant function */
+			ptrFunc = (onuGponGenTbl_p->onuGponStateAndEventTbl[ONU_GPON_EVENT_ALM_GEN_MEM][onuState]);
+			if (ptrFunc == NULL) {
+				mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+					   "ERROR: (%s:%d) Msg function is NULL, onuId(%d), msgId(%d)\n",
+					   __FILE_DESC__, __LINE__, onuId, msgId);
+			} else
+				(*ptrFunc)(ONU_GPON_ALARM_MEM, 0, NULL);
+		}
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngIntrBeCounterHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt BER counter
+**               expired functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngIntrBeCounterHandler(void)
+{
+	MV_U32 onuState;
+	MV_U32 bipErrorsCounter = 0;
+	MV_U8 onuId;
+
+	onuState = onuGponDbOnuStateGet();
+	onuId    = onuGponDbOnuIdGet();
+
+	if (onuState != ONU_GPON_05_OPERATION)
+		return;
+
+	/* Read BIP8 errors counter in MAC */
+	bipErrorsCounter = onuGponDbBipInterruptStatusValueGet();
+
+	/* Send an upstream REI message */
+	mvOnuGponMacReiMessageSend(onuId, bipErrorsCounter);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngIntrDgHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt dying gasp
+**               functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngIntrDgHandler(void)
+{
+	MV_U8 onuId = onuGponDbOnuIdGet();
+	static MV_U32 first_time = 1;
+	DYINGGASPFUNC dgCallback;
+
+	mvOnuGponMacDgMessageSend(onuId);
+
+	if (first_time) {
+		dgCallback = onuGponDbDgCallbackGet();
+
+		if (dgCallback != NULL) {
+			dgCallback();
+			first_time = 0;
+		}
+	}
+
+	onuPonDyingGaspExit();
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngrFifoErrCountersGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function
+**
+**  PARAMETERS:    None
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:       None
+**
+*******************************************************************************/
+MV_U32 onuGponPonMngrFifoErrCountersGet(MV_U32 *suspiciousCounter)
+{
+	MV_U32 suspected;
+	MV_U32 decided;
+
+	suspected = g_mngrSuspiciousFifoErrCounter;
+	decided = g_mngrDecidedFifoErrCounter;
+
+	g_mngrSuspiciousFifoErrCounter = 0;
+	g_mngrDecidedFifoErrCounter = 0;
+
+	*suspiciousCounter = suspected;
+	return decided;
+}
+
+/*******************************************************************************
+**
+**  onuGponTimerFifoAuditHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the GPON PM timer and trigger the
+**               GPON handler to execute SW FIFO Audit
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponTimerFifoAuditHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	/* Lock GPON interrupt */
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonSwFIFOTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	/* Call PM handler */
+	mvOnuGponFifoAuditTimerExpireHndl();
+
+	if ((onuPonResourceTbl_s.onuPonSwFIFOTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonSwFIFOTimerId));
+
+	/* Unlock GPON interrupt */
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonOmciAvailable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function checks whether more OMCI packet is available
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     1: avaible, 0:not avaible
+**
+*******************************************************************************/
+MV_U32 onuGponPonOmciAvailable(void)
+{
+	MV_STATUS rcode;
+	MV_U32 ctrlFifoSize;
+
+	/* read control cmd fifo used */
+	rcode = mvOnuGponMacRxCtrlCmdUsedGet(&ctrlFifoSize);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Read control message fifo size\n", __FILE_DESC__, __LINE__);
+		return 0;
+	}
+
+	if (ctrlFifoSize)
+		return 1;
+	else
+		return 0;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngOmciHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function implements the pon manager interrupt OMCI message
+**               functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponPonMngOmciHandler(void)
+{
+	MV_STATUS rcode;
+	MV_U32 ctrlFifoSize;
+	MV_U32 times;
+	MV_U8 omciMsg[48];
+	MV_U32 value;
+	MV_BOOL onuValid;
+
+	/* get the Init value of the ONU (if it MV_FALSE - not Valid yet) */
+	onuValid = onuGponDbInitGet();
+
+	/* there is valid OMCI message in the control command fifo */
+	do {
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_MNG4_PERFORMANCE]);
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* read HQ header length for control cmd fifo size */
+		rcode = mvOnuGponMacRxCtrlHeadLenGet(&ctrlFifoSize);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "failed to read control message fifo size\n");
+
+		if (ctrlFifoSize > GPON_STD_OMCI_MSG_LEN) {
+			mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) OMCI FIFO Used (%d) is illegal\n",
+				   __FILE_DESC__, __LINE__, ctrlFifoSize);
+			return MV_FAIL;
+		}
+		printk(KERN_DEBUG "DEBUG: (%s:%d) OMCI FIFO Used (%d) words\n",
+			__FILE_DESC__, __LINE__, ctrlFifoSize);
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+			   "DEBUG: (%s:%d) OMCI FIFO Used (%d) words\n", __FILE_DESC__, __LINE__, ctrlFifoSize);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+		if (tmpPmCheckNode->uSecCntIdx < 255)
+			tmpPmCheckNode->uSecCntIdx++;
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_MNG5_PERFORMANCE]);
+
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* clear received message content */
+		memset((void *)omciMsg, 0, sizeof(omciMsg));
+		/* read message from fifo */
+		for (times = 0; times < ((ctrlFifoSize + 3) / 4); times++) {
+			rcode = mvOnuGponMacRxCtrlCmdGet(&value);
+			*(MV_U32 *)(&omciMsg[0] + (4 * times)) = ntohl(value);
+		}
+
+#ifdef MV_GPON_DEBUG_PRINT
+		mvDebugMemDump(omciMsg, 48, 1);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		/* Increase OMCI counters from fast path */
+		onuGponPmRxOmciCountersAdd();
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+		asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+					 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+		if (tmpPmCheckNode->uSecCntIdx < 255)
+			tmpPmCheckNode->uSecCntIdx++;
+#endif          /* MV_GPON_PERFORMANCE_CHECK */
+
+		/* If ONU wasn't init ONU will receive Downstream OMCIs but won't handle it */
+		if (onuValid != MV_FALSE) {
+			rcode = onuPonEventOmciMsgSend(omciMsg);
+			PON_IF_ERROR(PON_MNG_MODULE, rcode, "failed to send OMCI message event\n");
+		}
+
+	} while (onuGponPonOmciAvailable());
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.h
new file mode 100644
index 0000000..3d622f4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngr.h
@@ -0,0 +1,213 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuMngr.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Manager definitions            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_MNGR_H
+#define _ONU_GPON_MNGR_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+/* Disable Message disable/Enable Options */
+#define GPON_ONU_DISABLE                    (0xFF)
+#define GPON_ONU_ENABLE_ALL             (0x0F)
+#define GPON_ONU_ENABLE_ONU             (0x00)
+
+/* timer sub types */
+#define TIMER_T01_EXPIRE            (1)
+#define TIMER_T02_EXPIRE            (2)
+#define TIMER_PEE_EXPIRE            (3)
+
+/* stats sub types */
+#define STATS_ACCMULATE             (1)
+#define STATS_RESET                 (2)
+#define STATS_SHOW                  (3)
+
+/* Alarms Types */
+#define ONU_PON_MNGR_LOS_ALARM      (0)
+#define ONU_PON_MNGR_LOF_ALARM      (1)
+#define ONU_PON_MNGR_LCDG_ALARM     (2)
+
+/* Assign Alloc Id Types */
+#define ONU_GPON_ATM_PAYLOAD        (0)
+#define ONU_GPON_GEM_PAYLOAD        (1)
+#define ONU_GPON_DBA_PAYLOAD        (2)
+#define ONU_GPON_DEALLOCATE         (255)
+
+/* OMCI message length */
+#define GPON_STD_OMCI_MSG_LEN       (48)
+
+#define INDICATION_BIT_MAP_NONE                 (0x00000000)
+#define INDICATION_BIT_MAP_FIBER_EVENT          (0x00000001)
+#define INDICATION_BIT_MAP_FORCE_TCONT_CLEAR    (0x00000002)
+#define INDICATION_BIT_MAP_FORCE_TCONT_RECONFIG (0x00000004)
+#define INDICATION_BIT_MAP_RESERVED             (0x00000008)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef MV_STATUS (*DISABLESTATSETFUNC)(MV_BOOL disable);
+
+typedef struct {
+	MV_U32 msgType;
+	MV_U32 subType;
+	MV_U32 status;
+	MV_U32 param;
+} S_MngrMsg;
+
+typedef struct {
+	MV_U32 msgType;
+	MV_U32 subType;
+	MV_U8 onuId;
+	MV_U8 msgId;
+	MV_U8 data[10];
+} S_MngrDebugMsg;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern DISABLESTATSETFUNC g_onuGponDisableFunc;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* Interrupt handler Functions */
+void      onuGponPonMngIntrAlarmHandler(MV_U32 alarm, MV_BOOL alarmStatus);
+void      onuGponPonMngIntrMessageHandler(void);
+void      onuGponPonMngIntrBeCounterHandler(void);
+void      onuGponPonMngIntrDgHandler(void);
+int       onuGponPonMngOmciHandler(void);
+
+/* Timer handler Functions */
+void      onuGponTimerFifoAuditHndl(unsigned long data);
+
+/* State Machine Functions */
+void      onuGponPonMngPloamProcess(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+
+void      onuGponPonMngIsrNotExpected(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngOverheadMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngSerialNumberMaskMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngOnuIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngRangeTimeMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngDactOnuIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngDisSnMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngCfgVpVcMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngEncrptPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngAssignAllocIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngNoMsgMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngPopupMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngCfgPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngPhyEquErrMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngChgPwrLvlMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngPstMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngKeySwitchTimeMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngExtBurstMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+
+void      onuGponPonMngTimerT01Hndl(unsigned long data);
+void      onuGponPonMngTimerT02Hndl(unsigned long data);
+void      onuGponPonMngTimerPopupWaHndl(unsigned long data);
+void      onuGponPonMngTimerPeeHndl(unsigned long data);
+void      onuGponPonMngTimerT01ExpireHndl(void);
+void      onuGponPonMngTimerT02ExpireHndl(void);
+void      onuGponPonMngTimerPopupWaExpireHndl(void);
+void      onuGponPonMngTimerPeeExpireHndl(void);
+void      onuGponTimerTxPwrHndl(unsigned long data);
+
+/* Alarm Functions */
+void      onuGponPonMngGenCritAlarm(E_OnuGponAlarmType alarmType_e, MV_U8 dummyVal, MV_U8 *dummyPtr);
+void      onuGponPonMngCanCritAlarm(E_OnuGponAlarmType alarmType_e, MV_U8 dummyVal, MV_U8 *dummyPtr);
+void      onuGponPonMngGenMemAlarm(E_OnuGponAlarmType alarmType_e, MV_U8 dummyVal, MV_U8 *dummyPtr);
+/* Operation State Functions */
+void      onuGponPonMngConfigPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngReqPassMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngBerIntervalMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngPhyEquipErrMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngReqKeyMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngEncryptPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+void      onuGponPonMngKeySwitchTimwMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData);
+
+void      onuGponPonMngOverheadManualModeSet(MV_BOOL mode);
+MV_BOOL   onuGponPonMngOverheadManualModeGet(void);
+MV_U32    onuGponPonMngrFifoErrCountersGet(MV_U32 *suspiciousCounter);
+MV_STATUS onuGponPonMngDisableSetRegister(DISABLESTATSETFUNC disableFunc);
+
+MV_STATUS onuGponPonMngClearOnuInfo(MV_U32 indicationBitMap);
+MV_STATUS onuGponPonMngrUpdateState(MV_U32 newState);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_MNGR_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngrStateMachine.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngrStateMachine.c
new file mode 100644
index 0000000..a006fb8c4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuMngrStateMachine.c
@@ -0,0 +1,3117 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuMngrStateMachine.c                                  **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Manager state machine        **
+**                functionality                                              **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuStateMachine.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+extern MV_BOOL ponRandomDelayLegacyMode;
+extern MV_U32 berIntervalForTypeB_Flag;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_BOOL g_overheadManualMode = MV_FALSE;
+DISABLESTATSETFUNC g_onuGponDisableFunc = NULL;
+MV_BOOL g_periodicTimerState = MV_FALSE;
+MV_U32 g_overheadPreAssignDelayForPopup = 0;
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+extern MV_STATUS onuGponAllocIdMacAdd(MV_U32 allocId, MV_U32 tcontId);
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponPonMngrUpdateState(MV_U32 newState);
+MV_STATUS onuGponPonMngClearOnuInfo(MV_U32 indicationBitMap);
+MV_STATUS onuGponPonMngClearOnuTconts(MV_U32 indicationBitMap);
+MV_STATUS onuGponPonMngClearOnuBuffers(MV_U32 indicationBitMap);
+MV_STATUS onuGponPonMngClearOnuPorts(void);
+MV_STATUS onuGponPonMngClearOnuId(void);
+MV_STATUS onuGponPonMngClearOnuDelay(void);
+MV_STATUS onuGponPonMngClearOnuOverhead(void);
+MV_STATUS onuGponPonMngClearBerInterval(void);
+MV_STATUS onuGponPonMngPreambleSet(MV_U32 onuState);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Messages Section                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPonMngUpdateState
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when a change of state in the ONU
+**               state machine is needed.
+**
+**  PARAMETERS:  MV_U32 newState
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngrUpdateState(MV_U32 newState)
+{
+	MV_STATUS rcode;
+	MV_U32 currentState;
+	MV_U32 asicNewState = newState;
+	MV_BOOL dumpEnabled;
+
+	/* get onu state */
+	currentState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) ONT STATE CHANGING: FROM STATE[%d] TO STATE [%d]\n",
+		   __FILE_DESC__, __LINE__, currentState, newState);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	dumpEnabled = onuGponDbBwMapCntDumpGet();
+
+	if (dumpEnabled == MV_TRUE)
+		onuGponPmRxBwMapCountersAdd();
+
+	if (newState == ONU_GPON_01_INIT) {
+		/*Reset All Counters*/
+		onuGponApiResetAllCtr();
+
+		/* No Downstream - Turn LED OFF */
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_OFF);
+
+		/* stop onu periodic timers */
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonPmTimerId));
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonSwFIFOTimerId));
+		mvOnuGponMacMessageCleanSwFifo();
+	}
+
+	if (newState == ONU_GPON_02_STANDBY) {
+		/* Downstream ON - Blink the LED */
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_SLOW);
+
+		/* start onu periodic timers */
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonPmTimerId));
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonSwFIFOTimerId));
+		mvOnuGponMacMessageCleanSwFifo();
+
+		/* stop onu gpon xvr reset timer */
+		onuGponIsrXvrResetStateSet(MV_FALSE);
+	}
+
+	rcode = onuGponPonMngPreambleSet(newState);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) Preamble Set\n", __FILE_DESC__, __LINE__);
+
+	if (newState == ONU_GPON_03_SERIAL_NUM) {
+		/* Sync sequence - Blink the LED fast */
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_FAST);
+
+		if ((onuGponDbSerialNumberMaskMatchGet()  == MV_FALSE) &&
+		    (onuGponDbSerialNumberMaskEnableGet() == MV_TRUE))
+			asicNewState = ONU_GPON_02_STANDBY;
+	}
+
+	/* update state */
+	/* ============ */
+
+	/* update asic */
+	rcode = mvOnuGponMacOnuStateSet(asicNewState);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacOnuStateSet\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	onuGponSyncLog(ONU_GPON_LOG_STATE, asicNewState, 0, 0);
+	/* update database */
+	onuGponDbOnuStateSet(newState);
+
+	if (dumpEnabled == MV_TRUE)
+		onuGponApiPmRxBwMapPmDump(currentState, newState);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuBuffers
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset onu buffers to its default state
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuBuffers(MV_U32 indicationBitMap)
+{
+	MV_STATUS rcode = MV_OK;
+
+	rcode = onuGponAllocIdFreeAllBuffers();
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuBuffers\n", __FILE_DESC__, __LINE__);
+
+
+	if ((onuGponDbTcontResetGet() != MV_TRUE) &&
+	    (indicationBitMap & INDICATION_BIT_MAP_FIBER_EVENT)) {
+		rcode = onuGponAllocIdMacReActivate();
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponPonMngClearOnuTconts\n", __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuInfo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset onu information to its default state:
+**               asic & application
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuInfo(MV_U32 indicationBitMap)
+{
+	MV_STATUS rcode;
+
+	rcode = onuGponPonMngClearOnuPorts();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuPorts\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearOnuTconts(indicationBitMap);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuTconts\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearOnuBuffers(indicationBitMap);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuBuffers\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearOnuId();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuId\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearOnuDelay();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuDelay\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearOnuOverhead();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuOverhead\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	rcode = onuGponPonMngClearBerInterval();
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearBerInterval\n", __FILE_DESC__, __LINE__);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuPorts
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear onu ports information from the
+**               asic & application
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuPorts(void)
+{
+	/* Remove Encryption from all ports */
+	onuGponDbGemPortAesClearAll();
+	mvOnuGponMacAesInit();
+
+	/* Remove all gem ports */
+	if (onuGponDbGemResetGet() == MV_TRUE) {
+		onuGponDbGemPortClearAll();
+		mvOnuGponMacGemInit();
+		/* Remove OMCC port */
+		onuGponApiGemOmccIdConfig(0, MV_FALSE);
+		onuGponDbOmccPortSet(0);
+	}
+
+	/* Set OMCC To be not Valid */
+	onuGponDbOmccValidSet(MV_FALSE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuTconts
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear onu tcont information from the
+**               asic & application
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuTconts(MV_U32 indicationBitMap)
+{
+	MV_STATUS rcode = MV_OK;
+
+	if ((onuGponDbTcontResetGet() == MV_TRUE) ||
+	    (indicationBitMap & INDICATION_BIT_MAP_FORCE_TCONT_CLEAR)) {
+		rcode = onuGponAllocIdDeAssignAll();
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponPonMngClearOnuTconts\n", __FILE_DESC__, __LINE__);
+			return rcode;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuId
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function clear onu Id information from the
+**                 asic & application
+**
+**  PARAMETERS:    None
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:       MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuId(void)
+{
+	MV_STATUS rcode;
+
+	/* update asic */
+	rcode = onuGponSrvcOnuIdUpdate(ONU_GPON_UNDEFINED_ONU_ID, MV_FALSE);
+	if (rcode != MV_OK)
+		return rcode;
+
+	/* update database */
+	onuGponDbOnuIdSet(ONU_GPON_UNDEFINED_ONU_ID);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuDelay
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function clear onu delay information from the
+**                 asic & application
+**
+**  PARAMETERS:    None
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:       MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuDelay(void)
+{
+	MV_STATUS rcode;
+
+	/* update asic */
+	rcode = mvOnuGponMacRxEqualizationDelaySet(GPON_TX_EQUAL_DELAY_TD);
+	if (rcode != MV_OK)
+		return rcode;
+
+	rcode = mvOnuGponMacTxFinalDelaySet(GPON_TX_FINAL_DELAY_FD);
+	if (rcode != MV_OK)
+		return rcode;
+
+	/* update database */
+	onuGponDbEqualizationDelaySet(GPON_TX_EQUAL_DELAY_TD);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearOnuOverhead
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function clear onu overhead information from the
+**                 asic & application
+**
+**  PARAMETERS:    None
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:       MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearOnuOverhead(void)
+{
+	MV_STATUS rcode;
+
+	if (g_overheadManualMode == MV_TRUE)
+		return MV_OK;
+
+	/* update asic */
+	rcode = mvOnuGponMacPreambleSet(ONU_TX_PREAMBLE_TYPE_01_P, ONU_TX_PREAMBLE_TYPE_01_PC,
+					ONU_TX_PREAMBLE_TYPE_02_P, ONU_TX_PREAMBLE_TYPE_02_PC,
+					ONU_TX_PREAMBLE_TYPE_03_P, ONU_TX_PREAMBLE_TYPE_03_DEF_PC);
+	if (rcode != MV_OK)
+		return rcode;
+
+	rcode = mvOnuGponMacTxDelimiterSet(GPON_TX_DELIMITER, GPON_TX_DELIMITER_DS);
+	if (rcode != MV_OK)
+		return rcode;
+
+	/* update database */
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_01, ONU_TX_PREAMBLE_TYPE_01_P, ONU_TX_PREAMBLE_TYPE_01_PC);
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_02, ONU_TX_PREAMBLE_TYPE_02_P, ONU_TX_PREAMBLE_TYPE_02_PC);
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_03, ONU_TX_PREAMBLE_TYPE_03_P, ONU_TX_PREAMBLE_TYPE_03_DEF_PC);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngClearBerInterval
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function clear ber interval information from the
+**                 asic & application
+**
+**  PARAMETERS:    None
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:       MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngClearBerInterval(void)
+{
+	MV_STATUS rcode;
+
+	if (berIntervalForTypeB_Flag == 0) {
+		rcode = mvOnuGponMacBipInterruptIntervalSet(GPON_BIP_PERIOD_CNTR);
+		if (rcode != MV_OK)
+			return rcode;
+	}
+
+	/* Update S/W Database */
+	onuGponDbBerIntervalSet(GPON_BIP_PERIOD_CNTR);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngIsrNotExpected
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when a combination of state and event
+**               is not expected
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngIsrNotExpected(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) not expected, onuId(%d), msgId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet());
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngOverheadMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when upstream overhead message is
+**               received (message 01)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngOverheadMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U8 totalPlouBytes;
+	MV_U8 numOfGaurdBits;
+	MV_U8 preambleType1Cnt;
+	MV_U8 preambleType2Cnt;
+	MV_U8 preambleType3Cnt;
+	MV_U8 preambleType3Pattern;
+	MV_U8 delimiterByte_01;
+	MV_U8 delimiterByte_02;
+	MV_U8 delimiterByte_03;
+	MV_U32 delimiter;
+	MV_U8 overheadStatus;
+	MV_U32 preAssignDelay;
+	MV_U32 preAssignDelayTemp;
+	MV_U32 finalDelay;
+	MV_U32 equalizationDelay;
+	MV_U32 extendedPreambleSyncSize;
+	MV_U32 extendedPreambleOperSize;
+	MV_BOOL extendedBurstOverride;
+	MV_BOOL delimiterOverride;
+	MV_U32 familyId = MV_88F66X0;    /*mvCtrlModelGet();*/
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_OVERHEAD_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) OVERHEAD, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	if (g_overheadManualMode == MV_FALSE) {
+		/* Support 1.244 G Rate */
+		totalPlouBytes = GPON_US_1244_PLOU_TOTAL_BYTES_SIZE;
+
+		/* guard handling */
+		/* ============== */
+		numOfGaurdBits = msgData[0];
+
+		/* preamble handling */
+		/* ================= */
+		preambleType1Cnt = msgData[1];          /* ploam message byte 4 */
+		preambleType2Cnt = msgData[2];          /* ploam message byte 5 */
+		preambleType3Pattern = msgData[3];      /* ploam message byte 6 */
+
+		preambleType1Cnt /= UINT8_NUM_OF_BITS;  /* preamble type 1 count in bytes */
+		preambleType2Cnt /= UINT8_NUM_OF_BITS;  /* preamble type 2 count in bytes */
+
+		extendedBurstOverride = onuGponDbExtendedBurstOverrideGet();
+
+		if (extendedBurstOverride == MV_TRUE) {
+			extendedPreambleSyncSize = onuGponDbExtendedBurstSyncOverrideValueGet();
+			extendedPreambleOperSize = onuGponDbExtendedBurstOperOverrideValueGet();
+
+			onuGponDbExtPreambleSyncSet(extendedPreambleSyncSize);
+			onuGponDbExtPreambleOperSet(extendedPreambleOperSize);
+
+			preambleType3Cnt = ONU_TX_PREAMBLE_TYPE_03_DEF_PC;
+		} else {
+			/* preamble type 3 count in bytes */
+			/* Total Time = Guard Time + Preamble Time(Types 1, 2, 3) + Delimiter Time */
+			preambleType3Cnt = totalPlouBytes - GPON_TX_DELIMITER_DS - preambleType1Cnt -
+					   preambleType2Cnt - (numOfGaurdBits / UINT8_NUM_OF_BITS);
+
+			onuGponDbExtPreambleOperSet(preambleType3Cnt);
+			onuGponDbExtPreambleSyncSet(preambleType3Cnt);
+		}
+
+		/* update database */
+		onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_01, (MV_U32)ONU_TX_PREAMBLE_TYPE_01_P,
+				(MV_U32)preambleType1Cnt);
+		onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_02, (MV_U32)ONU_TX_PREAMBLE_TYPE_02_P,
+				(MV_U32)preambleType2Cnt);
+		onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_03, (MV_U32)preambleType3Pattern, (MV_U32)preambleType3Cnt);
+
+		/* delimiter handling */
+		/* ================== */
+		delimiterOverride = onuGponDbDelimiterOverrideGet();
+
+		if (delimiterOverride == MV_FALSE) {
+			delimiterByte_01 = msgData[4];  /* ploam message byte 7 */
+			delimiterByte_02 = msgData[5];  /* ploam message byte 8 */
+			delimiterByte_03 = msgData[6];  /* ploam message byte 9 */
+			delimiter = (((MV_U32)delimiterByte_01) << 16) | (((MV_U32)delimiterByte_02) << 8) |
+				    ((MV_U32)delimiterByte_03);
+
+			/* update database */
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_01, (MV_U32)delimiterByte_01);
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_02, (MV_U32)delimiterByte_02);
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_03, (MV_U32)delimiterByte_03);
+			onuGponDbDelimiterSizeSet(GPON_TX_DELIMITER_DS);
+
+		} else {
+			delimiter = onuGponDbDelimiterOverrideValueGet();
+
+			/* update database with override value */
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_01, (delimiter & 0xFF));
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_02, (delimiter >> 8) & 0xFF);
+			onuGponDbDelimiterSet(ONU_GPON_DELM_BYTE_03, (delimiter >> 16) & 0xFF);
+
+		}
+
+		mvOnuGponMacTxDelimiterSet(delimiter, GPON_TX_DELIMITER_DS);
+
+		/* status handling */
+		/* =============== */
+		overheadStatus = msgData[7]; /* ploam message byte 10 */
+
+		if (overheadStatus & ONU_GPON_OVER_MSG_STATUS_XX) { /* future use */
+		}
+
+		if (overheadStatus & ONU_GPON_OVER_MSG_STATUS_M)  /* Serial Number Mask Enabled*/
+			onuGponDbSerialNumberMaskEnableSet(MV_TRUE);
+
+		if (overheadStatus & ONU_GPON_OVER_MSG_STATUS_SS) { /* future use */
+		}
+
+		if (overheadStatus & ONU_GPON_OVER_MSG_STATUS_PP) { /* future use */
+		}
+
+		/* pre-assign equalization delay handling */
+		/* ====================================== */
+		if (overheadStatus & ONU_GPON_OVER_MSG_STATUS_E) {
+			preAssignDelayTemp  = msgData[8] << UINT8_OFFSET;       /* ploam message byte 11 */
+			preAssignDelayTemp |= msgData[9];                       /* ploam message byte 12 */
+
+			preAssignDelayTemp <<= UINT8_OFFSET;                    /* align to bytes from words */
+
+			/* save pre-assign delay */
+			preAssignDelay = preAssignDelayTemp;
+
+			/* calc delay */
+			finalDelay        = M_ONU_GPON_RANG_MSG_FINAL_DELAY(preAssignDelayTemp);
+			equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(preAssignDelayTemp);
+
+			/* update asic */
+			if ((familyId != MV_88F66X0) || (ponRandomDelayLegacyMode != MV_FALSE)) {
+				MV_U32 randomRange[2];
+
+				get_random_bytes((void *)randomRange, sizeof(randomRange));
+
+				equalizationDelay += ((randomRange[0] & 0x7F) + (randomRange[1] & 0x3F) + 24) * 32;
+			}
+
+			rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+					   __FILE_DESC__, __LINE__, equalizationDelay);
+				return;
+			}
+
+			/* update asic */
+			finalDelay |= (MV_U32)GPON_TX_FINAL_DELAY_FD;
+
+			rcode = mvOnuGponMacTxFinalDelaySet(finalDelay);
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet finalDelay(%d)\n",
+					   __FILE_DESC__, __LINE__, finalDelay);
+				return;
+			}
+
+			/* update database */
+			onuGponDbEqualizationDelaySet(preAssignDelay);
+
+			g_overheadPreAssignDelayForPopup = preAssignDelay;
+		}
+	} /* g_overheadManualMode */
+
+	/* alarm handling */
+	/* ============== */
+
+	/* cancel deactivate onu alarm (if enabled) */
+	onuGponAlarmSet(ONU_GPON_ALARM_DACT, ONU_GPON_ALARM_OFF);
+
+	/* T01 timer handling */
+	/* ================== */
+
+	/* start onu gpon pon mng T01 timer */
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 0);
+	onuPonTimerEnable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+
+	/* state handling */
+	/* ============== */
+
+	/* Before changing state check SN_Mask VALUE and serialNumberMaskDefaultStateFlag mode.
+	** Add Support for HW and SW state machine */
+	rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_03_SERIAL_NUM);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngrUpdateState(3)\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngSerialNumberMaskMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when serial number mask message is
+**               received (message 02)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngSerialNumberMaskMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U8 numOfValidMaskBits;
+	MV_U8 numOfValidMaskBytes;
+	MV_U8 serialNumber[8];
+	MV_U8 maskIndex;
+	MV_U8 maskShift;
+	MV_U8 lastByteMask;
+	MV_U8 serialNumIndex = 7;
+	MV_U8 maskMsgOffset  = 8;
+
+	if (onuGponDbSerialNumberMaskEnableGet() == MV_TRUE) {
+		/* Get Serial Number */
+		onuGponDbSerialNumGet(&(serialNumber[0]));
+
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+			   "DEBUG: (%s:%d) SN_MASK, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x  ]\n",
+			   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+			   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+			   msgData[5], msgData[6], msgData[7], msgData[8]);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		/* numOfValidMaskBits handling */
+		numOfValidMaskBits  = msgData[0];
+		numOfValidMaskBytes = (numOfValidMaskBits / UINT8_NUM_OF_BITS) + 1;
+
+		/* Creating the last byte mask -if needed*/
+		maskIndex = ((maskMsgOffset - numOfValidMaskBytes) + 1);
+		if (numOfValidMaskBits <= UINT8_NUM_OF_BITS)
+			maskShift = numOfValidMaskBits;
+		else
+			maskShift = (numOfValidMaskBits % UINT8_NUM_OF_BITS);
+		if (maskShift != 0) {
+			lastByteMask = ((1 << (maskShift)) - 1);
+			msgData[maskIndex] &= lastByteMask;
+			serialNumber[maskIndex - 1] &= lastByteMask;
+		}
+
+		/* Compering the active bytes in the Serial number mask to ONU's serial number*/
+		for (maskIndex = 0; maskIndex < numOfValidMaskBytes; maskIndex++) {
+			if (serialNumber[serialNumIndex - maskIndex] != msgData[maskMsgOffset - maskIndex]) {
+				/* updating serial number flag to - no match */
+				onuGponDbSerialNumberMaskMatchSet(MV_FALSE);
+
+				/* state handling */
+				rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_03_SERIAL_NUM);
+				if (rcode != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+						   "ERROR: (%s:%d) onuGponPonMngrUpdateState(3)\n",
+						   __FILE_DESC__, __LINE__);
+					return;
+				}
+				return;
+			}
+		}
+
+		/* updating serial number flag to - match */
+		onuGponDbSerialNumberMaskMatchSet(MV_TRUE);
+
+		/* state handling */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_03_SERIAL_NUM);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponPonMngrUpdateState(3)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngOnuIdMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when onu Id message is received
+**               (message 03)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngOnuIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U8 serialNum[8];
+	MV_U32 msgOnuId;
+	MV_U32 equalizationDelay;
+	MV_U32 equalizationDelayTemp;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_ONU_ID_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) ASSIGN ONU ID, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* serial number handling */
+	/* ====================== */
+
+	/* get onu serial number */
+	onuGponDbSerialNumGet(&(serialNum[0]));
+
+	/* match onu serial number with message serial number */
+	if ((msgData[1] == serialNum[0]) &&
+	    (msgData[2] == serialNum[1]) &&
+	    (msgData[3] == serialNum[2]) &&
+	    (msgData[4] == serialNum[3]) &&
+	    (msgData[5] == serialNum[4]) &&
+	    (msgData[6] == serialNum[5]) &&
+	    (msgData[7] == serialNum[6]) &&
+	    (msgData[8] == serialNum[7])) {
+		/* extract onuId from the message */
+		if (onuGponDbOnuIdOverrideGet() == MV_FALSE)
+			msgOnuId = msgData[0];
+		else
+			msgOnuId = onuGponDbOnuIdOverrideValueGet();
+
+		/* update asic */
+		rcode = onuGponSrvcOnuIdUpdate(msgOnuId, MV_TRUE);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponSrvcOnuIdUpdate\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* update database */
+		onuGponDbOnuIdSet(msgOnuId);
+
+		/* set Default allocId according to the onuId */
+		rcode = onuGponAllocIdAssign(msgOnuId, 0);
+		if ((rcode != MV_OK) && (rcode != MV_NO_CHANGE)) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdAssign\n", __FILE_DESC__, __LINE__);
+			return;
+		} else if ((rcode != MV_OK) && (rcode == MV_NO_CHANGE))
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponAllocIdAssign, Alloc Id exist\n", __FILE_DESC__, __LINE__);
+		else    /* MV_OK */
+			onuGponAllocIdMacAdd(msgOnuId, PON_ONU_DEFAULT_ALLOC_TCONT);
+
+		/* Set delay received from OLT */
+		equalizationDelayTemp = onuGponDbEqualizationDelayGet();
+		equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(equalizationDelayTemp);
+		rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+				   __FILE_DESC__, __LINE__, equalizationDelay);
+			return;
+		}
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_04_RANGING);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponPonMngrUpdateState(4)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+	}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngRangeTimeMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when ranging time message is received
+**               (message 04)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngRangeTimeMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U8 delay[4];
+	MV_U32 msgDelay;
+	MV_U32 msgDelayTemp;
+	MV_U32 equalizationDelay;
+	MV_U32 finalDelay;
+	MV_U32 currentDelay;
+	MV_U32 changeDelay;
+	MV_U32 currFinalDelay;
+	MV_BOOL equalizationDelayOverride;
+	LINKSTATUSFUNC linkStatusCallback;
+	MV_U32 onuState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_RNG_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) RANGE TIME, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuState,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	equalizationDelayOverride = onuGponDbEqualizationDelayOverrideGet();
+
+	if ((equalizationDelayOverride == MV_FALSE) || (onuState == ONU_GPON_05_OPERATION)) {
+		/* equalization delay handling */
+		/* =========================== */
+		delay[0] = msgData[1]; /* MSB */
+		delay[1] = msgData[2];
+		delay[2] = msgData[3];
+		delay[3] = msgData[4]; /* LSB */
+
+		msgDelayTemp  = delay[3];
+		msgDelayTemp |= delay[2] << 8;
+		msgDelayTemp |= delay[1] << 16;
+		msgDelayTemp |= delay[0] << 24;
+
+		msgDelay = msgDelayTemp;
+	} else
+		msgDelay = onuGponDbEqualizationDelayOverrideValueGet();
+
+	/* calc delay */
+	finalDelay        = M_ONU_GPON_RANG_MSG_FINAL_DELAY(msgDelay);
+	equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(msgDelay);
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "Range Debug Info: (%s:%d), State O4, Message: equalizationDelay(%d:0x%x), finalDelay(%d:0x%x)\n",
+		   __FILE_DESC__, __LINE__, equalizationDelay, equalizationDelay, finalDelay, finalDelay);
+
+	/* sync state */
+	/* ========== */
+	if (onuState != ONU_GPON_05_OPERATION) {
+		/* stop onu gpon pon mng T01 timer */
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 3);
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+
+		/* update asic */
+		rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+				   __FILE_DESC__, __LINE__, equalizationDelay);
+			return;
+		}
+
+		/* update asic */
+		finalDelay += (MV_U32)GPON_TX_FINAL_DELAY_FD;
+
+		rcode = mvOnuGponMacTxFinalDelaySet(finalDelay);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet finalDelay(%d)\n",
+				   __FILE_DESC__, __LINE__, finalDelay);
+			return;
+		}
+
+		/* update database */
+		onuGponDbEqualizationDelaySet(msgDelay);
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+			   "Range Debug Info: (%s:%d), State O4, Calc: equalizationDelay(%d:0x%x), finalDelay(%d:0x%x)\n",
+			   __FILE_DESC__, __LINE__, equalizationDelay, equalizationDelay, finalDelay, finalDelay);
+
+		/* alarm handling */
+		/* ============== */
+		onuGponAlarmSet(ONU_GPON_ALARM_SUF, ONU_GPON_ALARM_OFF);
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_05_OPERATION);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponPonMngrUpdateState(5)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		onuPonTimerEnable(&onuPonResourceTbl_s.onuPonSwFIFOTimerId);
+
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_ON);
+
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "======================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== Upstream sync On ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "======================\n");
+
+		/* Call link status callback function */
+		linkStatusCallback = onuGponDbLinkStatusCallbackGet();
+		if (linkStatusCallback != NULL)
+			linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_TRUE);
+	} else { /* operational state */
+		/* get current delay */
+		currentDelay = onuGponDbEqualizationDelayGet();
+
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+			   "Range Debug Info: (%s:%d), State O5, Current equalization Delay from DB(%d:0x%x)\n",
+			   __FILE_DESC__, __LINE__, currentDelay, currentDelay);
+
+		/* Reduce Equlization delay */
+		if (currentDelay > msgDelay) {
+			changeDelay = currentDelay - msgDelay;
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+				   "Range Debug Info: (%s:%d), State O5, Current equalization Delay(0x%x) > Message equalization Delay(0x%x), change(0x%x)\n",
+				   __FILE_DESC__, __LINE__, currentDelay, msgDelay, changeDelay);
+
+			mvOnuGponMacTxFinalDelayGet(&currFinalDelay);
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+				   "Range Debug Info: (%s:%d), State O5, Final delay from DB (0x%x)\n",
+				   __FILE_DESC__, __LINE__, currFinalDelay);
+
+			/* Check if can change the TX Final Delay only */
+			if (changeDelay <= currFinalDelay) {
+				finalDelay = currFinalDelay - changeDelay;
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+					   "Range Debug Info: (%s:%d), State O5, Change delay <= Final delay, updated final delay, finalDelay = currFinalDelay - changeDelay, (0x%x)\n",
+					   __FILE_DESC__, __LINE__, finalDelay);
+			} else {
+#ifdef MV_GPON_DEBUG_PRINT
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) Change Range delay while O5 - Update EqD\n",
+					   __FILE_DESC__, __LINE__);
+#endif                          /* MV_GPON_DEBUG_PRINT */
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+					   "Range Debug Info: (%s:%d), State O5, Change > Final delay, updated equalization delay\n",
+					   __FILE_DESC__, __LINE__);
+
+				/* calc delay */
+				finalDelay        = M_ONU_GPON_RANG_MSG_FINAL_DELAY(msgDelay) +
+						    (MV_U32)GPON_TX_FINAL_DELAY_FD;
+				equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(msgDelay);
+				/* update asic */
+				rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+				if (rcode != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+						   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+						   __FILE_DESC__, __LINE__, equalizationDelay);
+					return;
+				}
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+					   "Range Debug Info: (%s:%d), State O5, Updated: equalizationDelay(%d:0x%x), finalDelay(%d:0x%x)\n",
+					   __FILE_DESC__, __LINE__, equalizationDelay, equalizationDelay, finalDelay, finalDelay);
+			}
+
+			rcode = mvOnuGponMacTxFinalDelaySet(finalDelay);
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet finalDelay(%d)\n",
+					   __FILE_DESC__, __LINE__, finalDelay);
+				return;
+			}
+			/* update database */
+			onuGponDbEqualizationDelaySet(msgDelay);
+		} else if (currentDelay < msgDelay) {
+			changeDelay = msgDelay - currentDelay;
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+				   "Range Debug Info: (%s:%d), State O5, Current equalization Delay(0x%x) < Message equalization Delay(0x%x), change(0x%x)\n",
+				   __FILE_DESC__, __LINE__, currentDelay, msgDelay, changeDelay);
+
+			mvOnuGponMacTxFinalDelayGet(&currFinalDelay);
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+				   "Range Debug Info: (%s:%d), State O5, Final delay from DB (0x%x)\n",
+				   __FILE_DESC__, __LINE__, currFinalDelay);
+			/* Check if can change the TX Final Delay only */
+			if (changeDelay + currFinalDelay <= GPON_TX_FINAL_DELAY_MAX) {
+				finalDelay = currFinalDelay + changeDelay;
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+					   "Range Debug Info: (%s:%d), State O5, Change delay + current Final delay <= MAX Final delay(0x3F), updated final delay, finalDelay = currFinalDelay + changeDelay, (0x%x)\n",
+					   __FILE_DESC__, __LINE__, finalDelay);
+			} else {
+#ifdef MV_GPON_DEBUG_PRINT
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+					   "DEBUG: (%s:%d) Change Range delay while O5 - Update EqD\n",
+					   __FILE_DESC__, __LINE__);
+#endif                          /* MV_GPON_DEBUG_PRINT */
+
+				mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+					   "Range Debug Info: (%s:%d), State O5, Change delay + Final delay > MAX Final delay = 0x3F, updated equalization delay\n",
+					   __FILE_DESC__, __LINE__);
+
+				/* calc delay */
+				finalDelay        = M_ONU_GPON_RANG_MSG_FINAL_DELAY(msgDelay) +
+						   (MV_U32)GPON_TX_FINAL_DELAY_FD;
+				equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(msgDelay);
+
+				/* update asic */
+				rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+				if (rcode != MV_OK) {
+					mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+						   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+						   __FILE_DESC__, __LINE__, equalizationDelay);
+					return;
+				}
+			}
+
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+				   "Range Debug Info: (%s:%d), State O5, Updated: equalizationDelay(%d:0x%x), finalDelay(%d:0x%x)\n",
+				   __FILE_DESC__, __LINE__, equalizationDelay, equalizationDelay, finalDelay, finalDelay);
+
+			rcode = mvOnuGponMacTxFinalDelaySet(finalDelay);
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) mvOnuGponMacTxFinalDelaySet finalDelay(%d)\n",
+					   __FILE_DESC__, __LINE__, finalDelay);
+				return;
+			}
+			/* update database */
+			onuGponDbEqualizationDelaySet(msgDelay);
+		}
+	}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngDactOnuIdMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when deactivate onu message is received
+**               (message 05)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngDactOnuIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	LINKSTATUSFUNC linkStatusCallback;
+
+	MV_U32 onuState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_DACT_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) DEACTIVATE, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuState,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* timer T01 is running */
+	if ((onuState >= ONU_GPON_02_STANDBY) &&
+	    (onuState <= ONU_GPON_04_RANGING)) {
+		/* stop onu gpon pon mng T01 timer */
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 6);
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+	}
+
+	/* clear onu information */
+	/* ===================== */
+	rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_FORCE_TCONT_CLEAR);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuInfo\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* alarm handling */
+	/* ============== */
+	onuGponAlarmSet(ONU_GPON_ALARM_DACT, ONU_GPON_ALARM_ON);
+
+	/* state handling */
+	/* ============== */
+	rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngrUpdateState(2)\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	if (onuState == ONU_GPON_05_OPERATION) {
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=======================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== Upstream sync Off ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=======================\n");
+
+		/* Send Status Notification to upper layer */
+		onuGponSrvcStatusNotify(GPON_ONU_STATUS_NOT_RANGED);
+
+		/* Call link status callback function */
+		linkStatusCallback = onuGponDbLinkStatusCallbackGet();
+		if (linkStatusCallback != NULL)
+			linkStatusCallback(MV_PON_LOGIC_PORT_GET(), MV_FALSE);
+	}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngDisSnMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when disable onu message is received
+**               (message 06)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngDisSnMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U32 onuState = onuGponDbOnuStateGet();
+	MV_U32 disableStatus;
+	MV_U8 msgSerialNumber[8];
+	MV_U8 onuSerialNumber[8];
+	MV_BOOL isSnMatch;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) DISABLE, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuState,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	disableStatus = msgData[0];
+	memcpy(msgSerialNumber, &(msgData[1]), 8);
+	onuGponDbSerialNumGet(onuSerialNumber);
+	if (memcmp(msgSerialNumber, onuSerialNumber, 8) == 0)
+		isSnMatch = MV_TRUE;
+	else
+		isSnMatch = MV_FALSE;
+
+	/* Disable */
+	if ((disableStatus == GPON_ONU_DISABLE) && (isSnMatch == MV_TRUE) &&
+	    (onuState != ONU_GPON_07_EMERGANCY_STOP)) {
+		onuPonTxPowerOn(MV_FALSE);
+
+		/* clear onu information */
+		/* ===================== */
+		rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_FORCE_TCONT_CLEAR);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngClearOnuInfo\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* clear GEM ports */
+		/* =============== */
+		rcode = onuGponApiGemClearAll(onuGponDbGemRestoreGet());
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponApiGemClearAll\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* alarm handling */
+		/* ============== */
+		onuGponAlarmSet(ONU_GPON_ALARM_DIS, ONU_GPON_ALARM_ON);
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_07_EMERGANCY_STOP);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngrUpdateState(7)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "==================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== ONT DISABLED ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "==================\n");
+
+		if (g_onuGponDisableFunc != NULL)
+			g_onuGponDisableFunc(MV_TRUE);
+
+		/* Send Disable Notification to upper layer */
+		onuGponSrvcDisableMsgNotify(MV_TRUE, MV_TRUE);
+
+		/* If was ranged then now ont is not ranged - send status notification */
+		if (onuState == ONU_GPON_05_OPERATION)
+			onuGponSrvcStatusNotify(GPON_ONU_STATUS_NOT_RANGED);
+
+		/* Enable */
+	} else if (((disableStatus == GPON_ONU_ENABLE_ALL) ||
+		    ((disableStatus == GPON_ONU_ENABLE_ONU) && (isSnMatch == MV_TRUE))) &&
+		   (onuState == ONU_GPON_07_EMERGANCY_STOP)) {
+		onuPonTxPowerOn(MV_TRUE);
+
+		/* alarm handling */
+		/* ============== */
+		onuGponAlarmSet(ONU_GPON_ALARM_DIS, ONU_GPON_ALARM_OFF);
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) DISABLE: onuGponPonMngrUpdateState(2)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=================\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "== ONT ENABLED ==\n");
+		mvPonPrint(PON_PRINT_INFO, PON_SM_MODULE, "=================\n");
+
+		if (g_onuGponDisableFunc != NULL)
+			g_onuGponDisableFunc(MV_FALSE);
+
+		/* Send Disable Notification to upper layer */
+		onuGponSrvcDisableMsgNotify(MV_FALSE, MV_TRUE);
+
+		/* Restore saved GEM ports */
+		if (onuGponDbGemRestoreGet() == MV_TRUE) {
+			rcode = onuGponApiGemRestoreAll();
+			if (rcode != MV_OK) {
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) DISABLE: onuGponApiGemRestoreAll\n",
+					   __FILE_DESC__, __LINE__);
+				return;
+			}
+		}
+
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngCfgVpVcMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when config Vp/Vc message is received
+**               (message 07)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngCfgVpVcMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) config Vp/Vc, onuId(%d), msgId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId,  onuGponDbOnuStateGet());
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) config Vp/Vc, function not supported\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngEncrptPortIdMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when encrpt port Id message is received
+**               (message 08)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngEncrptPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS status;
+	MV_BOOL encrypted;
+	MV_BOOL gem;
+	MV_U32 portId;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	MV_U8     *text[] = { "NOT Encrypted", "Encrypted" };
+#endif
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_ENC_PORT_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) ENCRYPTED PORT, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Send Acknowledge PLOAM */
+	status = mvOnuGponMacAcknowledgeMessageSend(onuId, msgId, msgData);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAcknowledgeMessageSend msgId(%d)\n",
+			   __FILE_DESC__, __LINE__, msgId);
+		return;
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] ACKNOWLEDGE, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   onuId, msgId,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	portId    = ((MV_U32)(msgData[1]) << 4) +
+		    ((MV_U32)(msgData[2]) >> 4);
+	encrypted = (msgData[0] & 0x01) ? MV_TRUE : MV_FALSE;
+	gem       = (msgData[0] & 0x02) ? MV_TRUE : MV_FALSE;
+	if (gem != MV_TRUE) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) ONT Does not support ATM\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* to start AES on a port Id, it should be valid */
+	if (encrypted == MV_TRUE) {
+		if (onuGponDbGemPortValidGet(portId) != MV_TRUE) {
+			/*Gem port was not yet configured, so avoid updating the HW and "just" mark the SW*/
+			onuGponDbGemPortAesSet(portId, encrypted);
+			return;
+		}
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_AES_MODULE,
+		   "DEBUG: (%s:%d) SM AES: PORT ID [%d] - %s Encrypted\n",
+		   __FILE_DESC__, __LINE__, portId, text[encrypted]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	mvOnuGponMacAesPortIdSet(portId, encrypted);
+	onuGponDbGemPortAesSet(portId, encrypted);
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngReqPassMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when request password message is received
+**               (message 09)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngReqPassMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_U8 password[10];
+	MV_U8 srcOnuId;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_PASS_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) PASSWORD REQUEST, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	onuGponDbPasswordGet(password);
+	srcOnuId = onuGponDbOnuIdGet();
+	/* Send Upstream Password message */
+	mvOnuGponMacPasswordMessageSend(srcOnuId, password, 3);
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] PASSWORD, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   srcOnuId, msgId,
+		   password[0], password[1], password[2], password[3], password[4],
+		   password[5], password[6], password[7], password[8], password[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngAssignAllocIdMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when assign allocId password message
+**               is received (message 10)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngAssignAllocIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS status;
+	MV_U32 allocId;
+	MV_U32 assignType;
+	MV_BOOL curAllocStatus;
+	MV_BOOL newAllocStatus;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_ALLOC_ID_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) ASSIGN ALLOC ID, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	allocId = (((MV_U32)(msgData[0])) << 4) + (((MV_U32)(msgData[1])) >> 4);
+	assignType = msgData[2];
+
+	switch (assignType) {
+	case ONU_GPON_ATM_PAYLOAD:
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc Id Type ATM - Not supported, allocId (%d)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		return;
+		break;
+	case ONU_GPON_GEM_PAYLOAD:
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc Id Type GEM, allocId (%d)\n", __FILE_DESC__, __LINE__, allocId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		newAllocStatus = MV_TRUE;
+		break;
+	case ONU_GPON_DBA_PAYLOAD:
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc Id Type DBA - Not supported, allocId (%d)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		return;
+		break;
+	case ONU_GPON_DEALLOCATE:
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc Id Type DEALLOCATE, allocId (%d)\n",
+			   __FILE_DESC__, __LINE__, allocId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+		newAllocStatus = MV_FALSE;
+		break;
+	default:
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+			   "DEBUG: (%s:%d) Alloc Id Type - Not supported, allocId (%d) type(%d)\n",
+			   __FILE_DESC__, __LINE__, allocId, assignType);
+		return;
+	}
+	/* Scan the alloc-Id table and check if the Alloc-Id has been defined and is valid */
+	curAllocStatus = onuGponDbBwAllocExist(allocId);
+	if (curAllocStatus == newAllocStatus) {
+#ifdef MV_GPON_DEBUG_PRINT
+		if (assignType == ONU_GPON_GEM_PAYLOAD)
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+				   "DEBUG: (%s:%d) Alloc Id Type - exist, allocId (%d)\n",
+				   __FILE_DESC__, __LINE__, allocId);
+		else if (assignType == ONU_GPON_DEALLOCATE)
+			mvPonPrint(PON_PRINT_DEBUG, PON_SM_ALLOC_MODULE,
+				   "DEBUG: (%s:%d) Alloc Id Type - removed, allocId (%d)\n",
+				   __FILE_DESC__, __LINE__, allocId);
+
+#endif          /* MV_GPON_DEBUG_PRINT */
+	} else {
+		/* Assign new Alloc Id */
+		if (newAllocStatus == MV_TRUE) {
+			status = onuGponAllocIdAssign(allocId, 1);
+			if ((status != MV_OK) && (status != MV_NO_CHANGE))
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) onuGponAllocIdAssign onuId(%d), allocId(%d)\n",
+					   __FILE_DESC__, __LINE__, onuId, allocId);
+		} else { /* De-Assign exist Alloc Id */
+			status = onuGponAllocIdDeAssign(allocId);
+			if (status != MV_OK)
+				mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+					   "ERROR: (%s:%d) onuGponAllocIdDeAssign onuId(%d), allocId(%d)\n",
+					   __FILE_DESC__, __LINE__, onuId, allocId);
+		}
+	}
+
+	/* Send Acknowledge PLOAM */
+	status = mvOnuGponMacAcknowledgeMessageSend(onuId, msgId, msgData);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAcknowledgeMessageSend onuId(%d), allocId(%d)\n",
+			   __FILE_DESC__, __LINE__, onuId, allocId);
+		return;
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] ACKNOWLEDGE, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   onuId, msgId,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngNoMsgMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when downstream no message is received
+**               (message 11)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngNoMsgMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) no message, onuId(%d), msgId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId,  onuGponDbOnuStateGet());
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngPopupMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when popup message is received
+**               (message 12)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngPopupMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U32 equalizationDelay;
+	MV_U32 equalizationDelayTemp;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) POPUP, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* stop onu gpon pon mng T02 timer */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT02_TimerId));
+	/* stop onu gpon xvr reset timer */
+	onuGponIsrXvrResetStateSet(MV_FALSE);
+
+	if (onuId == ONU_GPON_BROADCAST_ONU_ID) { /* Broadcast ONU-ID */
+		/* T01 timer handling */
+		/* ================== */
+		/* start onu gpon pon mng T01 timer */
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 2);
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 8, 0, 0);
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuGponPopupWaTimerId));
+
+		/* state handling */
+		mvOnuGponMacMessageCleanSwFifo();
+
+		/* update pre-assign delay before re-range */
+		equalizationDelayTemp = g_overheadPreAssignDelayForPopup;
+		equalizationDelay = M_ONU_GPON_RANG_MSG_EQUAL_DELAY(equalizationDelayTemp);
+		rcode = mvOnuGponMacRxEqualizationDelaySet(equalizationDelay);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacRxEqualizationDelaySet equalizationDelay(%d)\n",
+				   __FILE_DESC__, __LINE__, equalizationDelay);
+			return;
+		}
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_04_RANGING);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) POPUP: onuGponPonMngrUpdateState(4)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+	} else {        /* ONU ID is directed */
+			/* state handling */
+			/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_05_OPERATION);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) POPUP: onuGponPonMngrUpdateState(5)\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "========================\n");
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "== Recover from POPUP ==\n");
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "========================\n");
+#endif          /* MV_GPON_DEBUG_PRINT */
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngReqKeyMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when request key message is received
+**               (message 13)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngReqKeyMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U8 key[16];
+	MV_U32 i;
+	static MV_U8 keyIndex;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_REQ_KEY_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) REQUEST KEY, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	keyIndex++;
+
+	/* Generate new AES Key */
+	onuGponSrvcAesKeyGenerate(key);
+
+	/* Write it to asic */
+	rcode = mvOnuGponMacAesKeyShadowWrite(key);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAesKeyShadowWrite\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* Send the Key 3 times */
+	for (i = 0 ; i < 3 ; i++) {
+		rcode  = mvOnuGponMacEncryptionKeyMessageSend(onuId, keyIndex, 0, key);
+		rcode |= mvOnuGponMacEncryptionKeyMessageSend(onuId, keyIndex, 1, &(key[8]));
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) mvOnuGponMacEncryptionKeyMessageSend\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_AES_MODULE,
+		   "DEBUG: (%s:%d) SM AES: INDEX [%u] KEY [%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   __FILE_DESC__, __LINE__, keyIndex,
+		   key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7],
+		   key[8], key[9], key[10], key[11], key[12], key[13], key[14], key[15]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngCfgPortIdMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when config portId message is received
+**               (message 14)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngCfgPortIdMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS status;
+	MV_BOOL active;
+	MV_U32 portId;
+	MV_U32 currentOmcc;
+	MV_BOOL omccValid;
+	MV_U32 omccRxQueue;
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_CFG_PORT_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) CONFIG PORT ID, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Get Enable */
+	active = (msgData[0] == 1) ? MV_TRUE : MV_FALSE;  /* 0x00 - Activate, 0x01 - Deactivate */
+
+	if (onuGponDbOmccPortOverrideGet() == MV_FALSE) {
+		/* Get Port ID */
+		/* PLOAM Octet 4 (msgData[1]) - Port-ID[11:4] */
+		/* 4 MSB bits of PLOAM Octet 5 (msgData[2]) - Port-ID[3:0] */
+		portId = (msgData[1] << 4) + (msgData[2] >> 4);
+	} else
+		portId = onuGponDbOmccPortOverrideValueGet();
+
+	/* Send Acknowledge PLOAM */
+	status = mvOnuGponMacAcknowledgeMessageSend(onuId, msgId, msgData);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAcknowledgeMessageSend, msgId(%d) , active(%d)\n",
+			   __FILE_DESC__, __LINE__, msgId, active);
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] ACKNOWLEDGE, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   onuId, msgId,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Get OMCC State */
+	omccValid = onuGponDbOmccValidGet();
+	if (omccValid == active) {
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_OMCC_MODULE,
+			   "DEBUG: (%s:%d) Configure Port Id - Activness not changed, portId(%d), active(%d), omccValid(%d)\n",
+			   __FILE_DESC__, __LINE__, portId, active, omccValid);
+		return;
+	}
+
+	/* Update the new OMCC State */
+	onuGponDbOmccValidSet(active);
+
+	/*get current */
+	currentOmcc = onuGponDbOmccPortGet();
+	/*when system is configured to keep gem port configuration
+	   BUT onu id changed, remove ALL gem port configuration */
+	if ((currentOmcc != portId) &&
+	    (currentOmcc != GPON_ONU_ID_ONU_ID_DEF) &&
+	    (onuGponDbGemResetGet() == MV_FALSE)) {
+		onuGponDbGemPortClearAll();
+		mvOnuGponMacGemInit();
+		rcode = onuGponOmciChannelDel();
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponOmciChannelDel",
+				   __FILE_DESC__, __LINE__);
+		}
+	}
+	/*configure the omcc port when value changed */
+	if (currentOmcc != portId) {
+		/* Set OMCC Port Id */
+		status = onuGponApiGemOmccIdConfig(portId, active);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponApiGemOmccIdConfig portId(%d) active(%d)\n",
+				   __FILE_DESC__, __LINE__, portId, active);
+		}
+		onuGponDbOmccPortSet(portId);
+
+		/* Create OMCI channel */
+		rcode = onuGponDbOmccRxQueueGet(&omccRxQueue);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponDbOmccRxQueueGet",
+				   __FILE_DESC__, __LINE__);
+		}
+		rcode = onuGponOmciChannelAdd(portId, omccRxQueue);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) onuGponApiOmciChannelAdd",
+				   __FILE_DESC__, __LINE__);
+		}
+	}
+
+	/* Send Status Notification to upper layer */
+	onuGponSrvcStatusNotify(GPON_ONU_STATUS_RANGED);
+
+	if (active == MV_TRUE) {
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_OMCC_MODULE,
+			   "DEBUG: (%s:%d) GPON SM: OMCC ACTIVE: GEM Port[%d]\n", __FILE_DESC__, __LINE__, portId);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		/* Upstream ON - Turn LED On */
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_ON);
+	} else {
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_OMCC_MODULE,
+			   "DEBUG: (%s:%d) GPON SM: OMCC DEACTIVE\n", __FILE_DESC__, __LINE__);
+#endif          /* MV_GPON_DEBUG_PRINT */
+
+		/* Upstream OFF - Blink the LED (Downstream only) */
+		onuPonLedHandler(ONU_PON_SYNC_LED, ACTIVE_LED_BLINK_SLOW);
+	}
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngPhyEquErrMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when physical equipt error message is
+**               received (message 15)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngPhyEquErrMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) PEE, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Stop PEE Timer */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponPeeTimerId));
+
+	/* Start PEE Timer */
+	onuPonTimerEnable(&(onuPonResourceTbl_s.onuGponPeeTimerId));
+
+	/* Generate PEE Alarm */
+	onuGponAlarmSet(ONU_GPON_ALARM_PEE, ONU_GPON_ALARM_ON);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngChgPwrLvlMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when change power level message is
+**               received (message 16)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngChgPwrLvlMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) change power level, onuId(%d), msgId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId,  onuGponDbOnuStateGet());
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) change power level, function not supported\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngPstMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when PST message is received
+**               (message 17)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngPstMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) pst, onuId(%d), msgId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId,  onuGponDbOnuStateGet());
+
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_DEBUG_MODULE,
+		   "DEBUG: (%s:%d) pst, function not supported\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngBerIntervalMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when ber interval message is received
+**               (message 18)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngBerIntervalMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS status;
+	MV_U32 berInterval;
+	MV_U32 currentBerInterval;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) BER INTERVAL, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* BER Interval in Downstream Superframes */
+	berInterval = (MV_U32)(msgData[0] << 24) + (MV_U32)(msgData[1] << 16) +
+		      (MV_U32)(msgData[2] << 8) + (MV_U32)msgData[3];
+
+	/* Send Acknowledge PLOAM */
+	status = mvOnuGponMacAcknowledgeMessageSend(onuId, msgId, msgData);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) BER: mvOnuGponMacAcknowledgeMessageSend onuId(%d), msgId(%d)\n",
+			   __FILE_DESC__, __LINE__, onuId, msgId);
+		return;
+	}
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] ACKNOWLEDGE, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   onuId, msgId,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	currentBerInterval = onuGponDbBerIntervalGet();
+	if (currentBerInterval == berInterval)
+		return;
+
+	if (berIntervalForTypeB_Flag == 0) {
+		status = mvOnuGponMacBipInterruptIntervalSet(berInterval);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) BER: mvOnuGponMacBipInterruptIntervalSet onuId(%d), msgId(%d), interval(%d)\n",
+				   __FILE_DESC__, __LINE__, onuId, msgId, berInterval);
+			return;
+		}
+	}
+
+	/* Update S/W Database */
+	onuGponDbBerIntervalSet(berInterval);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngKeySwitchTimeMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when key switch time message is received
+**               (message 19)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngKeySwitchTimeMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS status;
+	MV_U32 time;
+	MV_U8 realOnuId;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_KEY_SWITCH_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "DEBUG: (%s:%d) KEY SWITCHING TIME, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuGponDbOnuStateGet(),
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	time = (MV_U32)(msgData[3]) + (((MV_U32)(msgData[2])) << 8) + (((MV_U32)(msgData[1])) << 16) +
+	       (((MV_U32)((msgData[0]) & 0x3F)) << 24);
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_AES_MODULE,
+		   "DEBUG: (%s:%d) SM AES: SWITCHING TIME [0x%x (%u)]\n",
+		   __FILE_DESC__, __LINE__, time, time);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	realOnuId = (MV_U8)onuGponDbOnuIdGet();
+
+	/* Send Acknowledge PLOAM */
+	status = mvOnuGponMacAcknowledgeMessageSend(realOnuId, msgId, msgData);
+	if (status != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacAcknowledgeMessageSend\n", __FILE_DESC__, __LINE__);
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "[US PLOAM] ACKNOWLEDGE, onuId(%d), msgId(%d), msg[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   realOnuId, msgId,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngExtBurstMsg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when ext burst message is received
+**               (message 20)
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngExtBurstMsg(MV_U8 onuId, MV_U8 msgId, MV_U8 *msgData)
+{
+	MV_STATUS rcode;
+	MV_U32 onuState = onuGponDbOnuStateGet();
+	MV_U8 preambleCnt_03Oper;
+	MV_U8 preambleCnt_03Sync;
+	MV_U8 preambleDelay_03Oper = 0;
+	MV_U8 preambleDelay_03Sync = 0;
+	MV_U32 currentExtPreambleSync;
+	MV_U32 currentExtPreambleOper;
+	MV_BOOL burstOverride;
+	MV_BOOL burstDelayAdd;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	S_GponPerformanceCheckNode *tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[PON_EXT_BURST_PLOAM_PERFORMANCE]);
+
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStart[tmpPmCheckNode->uSecCntIdx]), 0);
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_STATE_MODULE,
+		   "INFO: (%s:%d) EXT BURST, onuId(%d), msgId(%d), state(%d) msg[0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+		   __FILE_DESC__, __LINE__, onuId, msgId, onuState,
+		   msgData[0], msgData[1], msgData[2], msgData[3], msgData[4],
+		   msgData[5], msgData[6], msgData[7], msgData[8], msgData[9]);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	burstDelayAdd = onuGponDbExtendedBurstDelayAddGet();
+
+	if (burstDelayAdd == MV_TRUE) {
+		preambleDelay_03Oper = onuGponDbExtendedBurstOperDelayValueGet();
+		preambleDelay_03Sync = onuGponDbExtendedBurstSyncDelayValueGet();
+	}
+
+	currentExtPreambleSync = onuGponDbExtPreambleSyncGet();
+	currentExtPreambleOper = onuGponDbExtPreambleOperGet();
+	if (g_overheadManualMode == MV_TRUE)
+		return;
+
+	burstOverride = onuGponDbExtendedBurstOverrideGet();
+
+	if (burstOverride == MV_TRUE) {
+		preambleCnt_03Sync = onuGponDbExtendedBurstSyncOverrideValueGet();
+		preambleCnt_03Oper = onuGponDbExtendedBurstOperOverrideValueGet();
+
+		onuGponDbExtPreambleSyncSet(preambleCnt_03Sync);
+		onuGponDbExtPreambleOperSet(preambleCnt_03Oper);
+	} else {
+		/* preamble handling */
+		/* ================= */
+		preambleCnt_03Sync = msgData[0] + preambleDelay_03Sync;
+		preambleCnt_03Oper = msgData[1] + preambleDelay_03Oper;
+
+		if ((currentExtPreambleSync == preambleCnt_03Sync) &&
+		    (currentExtPreambleOper == preambleCnt_03Oper))
+			return;
+
+		onuGponDbExtPreambleSyncSet(preambleCnt_03Sync);
+		onuGponDbExtPreambleOperSet(preambleCnt_03Oper);
+	}
+	rcode = onuGponPonMngPreambleSet(onuState);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) Preamble Set\n", __FILE_DESC__, __LINE__);
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT,
+				 &(tmpPmCheckNode->uSecCntStop[tmpPmCheckNode->uSecCntIdx]), 0);
+	if (tmpPmCheckNode->uSecCntIdx < 255)
+		tmpPmCheckNode->uSecCntIdx++;
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerT01Hndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when timer T01 expires
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerT01Hndl(unsigned long data)
+{
+	unsigned long flags;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) onuGponPonMngTimerT01Hndl\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	onuPonResourceTbl_s.onuGponT01_TimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 4);
+
+	if (onuGponDbOnuStateGet() != ONU_GPON_05_OPERATION) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 5);
+		onuGponPonMngTimerT01ExpireHndl();
+	}
+	/* stop onu gpon pon mng T01 timer */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerT01ExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function executes timer T01 functionality
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerT01ExpireHndl(void)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) TIMER TO1 Expired, state(%d)\n", __FILE_DESC__, __LINE__, onuGponDbOnuStateGet());
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* state handling */
+	/* ============== */
+	rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngrUpdateState(2)\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* clear onu information */
+	/* ===================== */
+	rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_FIBER_EVENT);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuInfo\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* alarm handling */
+	/* ============== */
+	onuGponAlarmSet(ONU_GPON_ALARM_SUF, ONU_GPON_ALARM_ON);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerT02Hndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when timer T02 expires
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerT02Hndl(unsigned long data)
+{
+	unsigned long flags;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) onuGponPonMngTimerT02Hndl\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuGponT02_TimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+	onuGponPonMngTimerT02ExpireHndl();
+	/* stop onu gpon pon mng T02 timer */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT02_TimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerT02ExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function executes timer T02 functionality
+**
+**  PARAMETERS:  MV_U8 onuId
+**               MV_U8 msgId
+**               MV_U8 *msgData
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerT02ExpireHndl(void)
+{
+	MV_STATUS rcode;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) TIMER TO2 Expired, state(%d)\n", __FILE_DESC__, __LINE__, onuGponDbOnuStateGet());
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* clear onu information */
+	/* ===================== */
+	rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_FIBER_EVENT);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngClearOnuInfo\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* state handling */
+	/* ============== */
+	if (onuGponAsicAlarmStatusGet() == ONU_GPON_ALARM_OFF)
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+	else
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_01_INIT);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) onuGponPonMngrUpdateState(1)\n", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	/* start xvr reset timer */
+	onuGponIsrXvrResetStateSet(MV_TRUE);
+
+	onuGponDbOnuDsSyncOnSet(0);
+
+	onuGponAlarmSet(ONU_GPON_ALARM_LOF, ONU_GPON_ALARM_ON);
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "==================\n");
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "== POPUP Expire ==\n");
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "==================\n");
+#endif  /* MV_GPON_DEBUG_PRINT */
+}
+
+/*******************************************************************************
+**
+**  onuGponTimerPopupWaHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when timer POPUP WA expires
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerPopupWaHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuGponPopupWaTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	onuGponPonMngTimerPopupWaExpireHndl();
+
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponPopupWaTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerPpopupWaExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function executes timer POPUP WA functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerPopupWaExpireHndl(void)
+{
+	MV_U32 onuState;
+
+	onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 8, 0, 1);
+	onuState = onuGponDbOnuStateGet();
+	if (onuState == ONU_GPON_04_RANGING) {
+		onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 8, 0, 2);
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+		onuGponPonMngrUpdateState((MV_U32)ONU_GPON_05_OPERATION);
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerPeeHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called when timer Pee expires
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerPeeHndl(unsigned long data)
+{
+	unsigned long flags;
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) onuGponPonMngTimerPeeHndl\n", __FILE_DESC__, __LINE__);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuGponPeeTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+	onuGponPonMngTimerPeeExpireHndl();
+	/* stop onu gpon pon mng Pee timer */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponPeeTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngTimerPeeExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function executes timer PEE functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngTimerPeeExpireHndl(void)
+{
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_TIMER_MODULE,
+		   "DEBUG: (%s:%d) TIMER PEE Expired, state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuGponDbOnuStateGet());
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Cancel PEE Alarm */
+	onuGponAlarmSet(ONU_GPON_ALARM_PEE, ONU_GPON_ALARM_OFF);
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Alarm Section                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPonMngGenCritAlarm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function generate critical alarm
+**
+**  PARAMETERS:  E_OnuGponAlarmType alarmType_e
+**               MV_U8              dummyVal
+**               MV_U8              *dummyPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngGenCritAlarm(E_OnuGponAlarmType alarmType_e,
+			       MV_U8 dummyVal,
+			       MV_U8 *dummyPtr)
+{
+	MV_STATUS rcode;
+	MV_U32 currentState;
+	MV_U32 onuId;
+
+	onuId        = onuGponDbOnuIdGet();
+	currentState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE,
+		   "DEBUG: (%s:%d) ALARM ON - (%d), onuId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, alarmType_e, onuId, currentState);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* Operation State */
+	/* =============== */
+	if (currentState == ONU_GPON_05_OPERATION) {
+		/* special care for operation state */
+		/* move to popup state - start T02 timer */
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_06_POPUP);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) Set onu state to state 06\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* T02 timer handling */
+		/* ================== */
+
+		/* start onu gpon pon mng T02 timer */
+		if ((alarmType_e == ONU_PON_MNGR_LOS_ALARM) ||
+		    (alarmType_e == ONU_PON_MNGR_LOF_ALARM))
+			onuPonTimerEnable(&(onuPonResourceTbl_s.onuGponT02_TimerId));
+		else
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) wrong start to T02\n", __FILE_DESC__, __LINE__);
+
+		/* start xvr reset timer */
+		onuGponIsrXvrResetStateSet(MV_TRUE);
+
+#ifdef MV_GPON_DEBUG_PRINT
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "===========\n");
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "== POPUP ==\n");
+		mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE, "===========\n");
+#endif          /* MV_GPON_DEBUG_PRINT */
+	} else if (currentState == ONU_GPON_06_POPUP) { /* POPUP State */
+		if (alarmType_e == ONU_PON_MNGR_LOF_ALARM)
+			onuGponIsrXvrResetStateSet(MV_TRUE);
+	} else if ((currentState >= ONU_GPON_01_INIT) &&
+		   (currentState <= ONU_GPON_04_RANGING)) { /* Ranging States */
+		/* timer T01 is running */
+		if ((currentState >= ONU_GPON_02_STANDBY) &&
+		    (currentState <= ONU_GPON_04_RANGING)) {
+			/* stop onu gpon pon mng T01 timer */
+			onuGponSyncLog(ONU_GPON_LOG_FREE_TEXT, 4, 0, 1);
+			onuPonTimerDisable(&(onuPonResourceTbl_s.onuGponT01_TimerId));
+		}
+
+		/* clear onu information */
+		/* ===================== */
+		rcode = onuGponPonMngClearOnuInfo(INDICATION_BIT_MAP_FIBER_EVENT);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) Clear onu information\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_01_INIT);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) Set onu state to state 01\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+
+		/* start xvr reset timer */
+		onuGponIsrXvrResetStateSet(MV_TRUE);
+
+		onuGponDbOnuDsSyncOnSet(0);
+	} else if (currentState == ONU_GPON_07_EMERGANCY_STOP)  /* Emergancy Stop State */
+		/* start xvr reset timer */
+		onuGponIsrXvrResetStateSet(MV_TRUE);
+
+	/* alarm handling */
+	/* ============== */
+	onuGponAlarmSet(alarmType_e, ONU_GPON_ALARM_ON);
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngCanCritAlarm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function cancel critical alarm
+**
+**  PARAMETERS:  E_OnuGponAlarmType alarmType_e
+**               MV_U8              dummyVal
+**               MV_U8              *dummyPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngCanCritAlarm(E_OnuGponAlarmType alarmType_e,
+			       MV_U8 dummyVal,
+			       MV_U8 *dummyPtr)
+{
+	MV_STATUS rcode;
+	MV_U32 currentState;
+	MV_U32 onuId;
+
+	onuId        = onuGponDbOnuIdGet();
+	currentState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE,
+		   "DEBUG: (%s:%d) ALARM OFF - (%d), onuId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, alarmType_e, onuId, currentState);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* alarm handling */
+	/* ============== */
+	onuGponAlarmSet(alarmType_e, ONU_GPON_ALARM_OFF);
+
+	if ((onuGponAsicAlarmStatusGet() == ONU_GPON_ALARM_OFF) &&
+	    currentState == ONU_GPON_01_INIT) {
+		/* state handling */
+		/* ============== */
+		rcode = onuGponPonMngrUpdateState((MV_U32)ONU_GPON_02_STANDBY);
+		if (rcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+				   "ERROR: (%s:%d) Set onu state to state 02\n", __FILE_DESC__, __LINE__);
+			return;
+		}
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngGenMemAlarm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle mem alarm (received unsupported message)
+**
+**  PARAMETERS:  E_OnuGponAlarmType alarmType_e
+**               MV_U8              dummyVal
+**               MV_U8              *dummyPtr
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngGenMemAlarm(E_OnuGponAlarmType alarmType_e,
+			      MV_U8 dummyVal,
+			      MV_U8 *dummyPtr)
+{
+	MV_U32 currentState;
+	MV_U32 onuId;
+
+	onuId        = onuGponDbOnuIdGet();
+	currentState = onuGponDbOnuStateGet();
+
+#ifdef MV_GPON_DEBUG_PRINT
+	mvPonPrint(PON_PRINT_DEBUG, PON_SM_MODULE,
+		   "DEBUG: (%s:%d) generate mem, onuId(%d), state(%d)\n",
+		   __FILE_DESC__, __LINE__, onuId, currentState);
+#endif  /* MV_GPON_DEBUG_PRINT */
+
+	/* alarm handling */
+	/* ============== */
+	onuGponAlarmSet(alarmType_e, ONU_GPON_ALARM_ON);
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         UTILS Routines                                     */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPonMngPreambleSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function update onu preamble according to onu state
+**
+**  PARAMETERS:  MV_U32 onuState
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngPreambleSet(MV_U32 onuState)
+{
+	MV_STATUS rcode;
+	MV_U32 type1Size;
+	MV_U32 type2Size;
+	MV_U32 type3Size = 0;
+	MV_U32 type3Pattern;
+	MV_U32 dummy;
+
+	/* Get Preambles Parameters */
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_01, &dummy, &type1Size);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_02, &dummy, &type2Size);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_03, &type3Pattern, &dummy);
+	switch (onuState) {
+	case ONU_GPON_01_INIT:
+	case ONU_GPON_02_STANDBY:
+		break;
+	case ONU_GPON_03_SERIAL_NUM:
+	case ONU_GPON_04_RANGING:
+		type3Size = onuGponDbExtPreambleSyncGet();
+		break;
+	case ONU_GPON_05_OPERATION:
+		type3Size = onuGponDbExtPreambleOperGet();
+		break;
+	case ONU_GPON_06_POPUP:
+	case ONU_GPON_07_EMERGANCY_STOP:
+	default:
+		break;
+	}
+
+	/* update asic */
+	rcode = mvOnuGponMacPreambleSet(ONU_TX_PREAMBLE_TYPE_01_P, type1Size,
+					ONU_TX_PREAMBLE_TYPE_02_P, type2Size,
+					type3Pattern, type3Size);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_SM_MODULE,
+			   "ERROR: (%s:%d) mvOnuGponMacPreambleSet type3 size(%d) type3 pattern(%d)\n",
+			   __FILE_DESC__, __LINE__, type3Size, type3Pattern);
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngOverheadManualModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu overhead manual mode
+**
+**  PARAMETERS:  MV_BOOL mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPonMngOverheadManualModeSet(MV_BOOL mode)
+{
+	g_overheadManualMode = mode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngOverheadManualModeGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu overhead manual mode
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     onu overhead manual mode
+**
+*******************************************************************************/
+MV_BOOL onuGponPonMngOverheadManualModeGet(void)
+{
+	return g_overheadManualMode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPonMngDisableSetRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set onu disable function
+**
+**  PARAMETERS:  DISABLESTATSETFUNC disableFunc
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPonMngDisableSetRegister(DISABLESTATSETFUNC disableFunc)
+{
+	g_onuGponDisableFunc = disableFunc;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponTimerTxPwrHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the GPON handler in the case of DS
+**               sync off to start 1 sec timer that will disable Tx if expired
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponTimerTxPwrHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonTxPwrTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	if (onuGponDbOnuStateGet() < ONU_GPON_02_STANDBY)
+		onuPonTxPowerOn(MV_FALSE);
+
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonTxPwrTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.c
new file mode 100644
index 0000000..5e3ca7a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.c
@@ -0,0 +1,1180 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuPm.c                                                **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Alarm and Statistics         **
+**                functionality                                              **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuPm.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+/* ONU GPON PM table */
+S_GponPm g_OnuGponPm;
+S_PloamSwPm g_OnuGponSwPm;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+S_GponPerformanceCheck g_GponPmCheck;
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+extern spinlock_t onuPonIrqLock;
+
+static S_apiGemPortPmConfigDb apiGemPortPmConfigDb;
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Init Section                                       */
+/* ========================================================================== */
+/******************************************************************************/
+#ifdef MV_GPON_PERFORMANCE_CHECK
+MV_STATUS onuGponPmInit(void)
+{
+	MV_U32 index;
+
+	for (index = 0; index < PON_MAX_PERFORMANCE; index++) {
+		g_GponPmCheck.pmCheckNode[index].uSecCntStart = (MV_U32 *)onuPonMemAlloc(256 * sizeof(MV_U32));
+		if (g_GponPmCheck.pmCheckNode[index].uSecCntStart == NULL)
+			return MV_ERROR;
+
+		g_GponPmCheck.pmCheckNode[index].uSecCntStop = (MV_U32 *)onuPonMemAlloc(256 * sizeof(MV_U32));
+		if (g_GponPmCheck.pmCheckNode[index].uSecCntStop == NULL)
+			return MV_ERROR;
+
+		g_GponPmCheck.pmCheckNode[index].uSecCntIdx = 0;
+	}
+
+	return MV_OK;
+}
+
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         Statistics Section                                 */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPmInPmInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init the onu gpon alarm table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPmInPmInit(void)
+{
+	/* reset all counters */
+	memset(&g_OnuGponPm,   0, sizeof(S_GponPm));
+	memset(&g_OnuGponSwPm, 0, sizeof(S_PloamSwPm));
+}
+
+/*******************************************************************************
+**
+**  onuGponPmTimerPmHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is called by the GPON PM timer and trigger the
+**               GPON handler to execute PM functionality
+**
+**  PARAMETERS:  unsigned long data
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPmTimerPmHndl(unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+	/* Call PM handler */
+	onuGponPmTimerExpireHndl();
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	if ((onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerPeriodic) != 0)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonPmTimerId));
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuGponPmTimerExpireHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine execute PM handler functionality
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponPmTimerExpireHndl(void)
+{
+	S_RxBip8Pm inBip8Pm;
+	unsigned long flags;
+
+	onuGponPmCountersAdd();
+	onuGponPmRxBip8PmGet(&inBip8Pm);
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+	onuGponBerPeriodPass(inBip8Pm.bip8);
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+	onuGponRougeOnuCheck();
+}
+
+/*******************************************************************************
+**
+**  onuGponRougeOnuCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine validate rouge ONU statistics values
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponRougeOnuCheck(void)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 txBurstEnCnt;
+
+	onuGponPmTxBurstEnCntGet(&txBurstEnCnt);
+
+	if (txBurstEnCnt >= GPON_BURST_THRESHOLD) {
+		mvPonPrint(PON_PRINT_ERROR, PON_PM_MODULE, "===========================\n");
+		mvPonPrint(PON_PRINT_ERROR, PON_PM_MODULE, "== ROUGE ONU             ==\n");
+		mvPonPrint(PON_PRINT_ERROR, PON_PM_MODULE, "== Shutting Down the XVR ==\n");
+		mvPonPrint(PON_PRINT_ERROR, PON_PM_MODULE, "===========================\n");
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+		/* Set the output enable of the GP_BEN IO to Input */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_INPUT, 0);
+		if (status != MV_OK)
+			return status;
+#endif
+#endif          /* PON_FPGA */
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  ponOltPmOnuCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine read statistics values from ASIC to the database
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmCountersAdd(void)
+{
+	MV_U32 tempCounter1;
+	MV_U32 tempCounter2;
+	MV_U32 tempCounter3;
+	MV_U32 tempCounter4;
+	MV_U32 tcont;
+	MV_BOOL exist;
+	MV_STATUS status;
+
+	/* BIP8 Counter */
+	/* ============ */
+	mvOnuGponMacBipStatusValueGet(&tempCounter1);
+	g_OnuGponPm.rxBip8.bip8 += tempCounter1;
+
+	/* Ploam Counters */
+	/* ============== */
+	mvOnuGponMacRxPloamLostCrcCounterGet(&tempCounter1); /* Error CRC */
+	g_OnuGponPm.rxPloam.crcErrorPloamCounter += tempCounter1;
+	mvOnuGponMacRxPloamLostFullCounterGet(&tempCounter1); /* Downstream lost due to full FIFO */
+	g_OnuGponPm.rxPloam.fifoOverErrorPloamCounter += tempCounter1;
+	mvOnuGponMacRxPloamRcvdIdleCounterGet(&tempCounter1); /* Downstream received idle */
+	g_OnuGponPm.rxPloam.idlePloamCounter += tempCounter1;
+	mvOnuGponMacRxPloamRcvdBroadCounterGet(&tempCounter1); /* Downstream received broadcast */
+	g_OnuGponPm.rxPloam.receivedBroadcastPloamCounter += tempCounter1;
+	mvOnuGponMacRxPloamRcvdOnuIdCounterGet(&tempCounter1); /* Downstream received ONU ID */
+	g_OnuGponPm.rxPloam.receivedOnuIdPloamCounter += tempCounter1;
+
+	/* BW MAP counters  */
+	/* =============== */
+	mvOnuGponMacRxBwMapAllocatrionsCounterGet(&tempCounter1, &tempCounter2, &tempCounter3, &tempCounter4);
+	g_OnuGponPm.rxBwMap.allocCorrec += tempCounter1;              /* Received allocations errors free */
+	g_OnuGponPm.rxBwMap.allocUnCorrectableCrcErr += tempCounter2; /* Received allocations with uncorrectable CRC errors */
+	g_OnuGponPm.rxBwMap.allocCorrectableCrcErr += tempCounter3; /* Received allocations with correctable CRC errors or errors free */
+	g_OnuGponPm.rxBwMap.allocCrcErr += tempCounter4;/* Received allocations with CRC error */
+	mvOnuGponMacRxBwMapTotalBwGet(&tempCounter1); /* Total received byte allocations */
+	g_OnuGponPm.rxBwMap.totalReceivedAllocBytes += tempCounter1;
+
+	/* PLEND unusable counter */
+	/* ====================== */
+	mvOnuGponMacInComingPlendCntGet(&tempCounter1);
+	g_OnuGponPm.rxPlend.plend += tempCounter1;
+
+	/* FEC Counters */
+	/* ============ */
+	mvOnuGponMacRxFecBytesCounterGet(&tempCounter1); /* Received bytes */
+	g_OnuGponPm.rxFec.receivedBytes += tempCounter1;
+	mvOnuGponMacRxFecCorrectCounterGet(&tempCounter1, &tempCounter2);
+	g_OnuGponPm.rxFec.correctedBits += tempCounter2; /* Received corrected bits */
+	g_OnuGponPm.rxFec.correctedBytes += tempCounter1; /* Received corrected bytes */
+	mvOnuGponMacRxFecInorrectCounterGet(&tempCounter1, &tempCounter2);
+	g_OnuGponPm.rxFec.receivedCodeWords += tempCounter2; /* Received code words */
+	g_OnuGponPm.rxFec.uncorrectedCodeWords += tempCounter1; /* Received corrected code words */
+
+	/* GEM Counters */
+	/* ============ */
+	mvOnuGponMacGemRcvdIdleGemFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedIdleGemFrames += tempCounter1;
+	mvOnuGponMacGemRcvdValidGemFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedValidGemFrames += tempCounter1;
+	mvOnuGponMacGemRcvdUndefGemFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedUndefinedGemFrames += tempCounter1;
+	mvOnuGponMacGemRcvdOmciFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedOmciFrames += tempCounter1;
+	mvOnuGponMacGemDropGemFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.droppedGemFrames += tempCounter1;
+	mvOnuGponMacGemDropOmciFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.droppedOmciFrames += tempCounter1;
+	mvOnuGponMacGemRcvdGemFramesWithUncorrHecErrCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedGemFramesWithUncorrHecErr += tempCounter1;
+	mvOnuGponMacGemRcvdGemFramesWithOneFixedHecErrCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedGemFramesWithOneFixedHecErr += tempCounter1;
+	mvOnuGponMacGemRcvdGemFramesWithTwoFixedHecErrCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedGemFramesWithTwoFixedHecErr += tempCounter1;
+	mvOnuGponMacGemRcvdValidGemFramesTotalByteCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.totalByteCountOfReceivedValidGemFrames += tempCounter1;
+	mvOnuGponMacGemRcvdUndefGemFramesTotalByteCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.totalByteCountOfReceivedUndefinedGemFrames += tempCounter1;
+	mvOnuGponMacGemReassembleMemoryFlushCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.gemReassembleMemoryFlush += tempCounter1;
+	mvOnuGponMacGemSynchLostCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.gemSynchLost += tempCounter1;
+	mvOnuGponMacGemRcvdEthFramesWithCorrFcsCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedEthFramesWithCorrFcs += tempCounter1;
+	mvOnuGponMacGemRcvdEthFramesWithFcsErrCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedEthFramesWithFcsError += tempCounter1;
+	mvOnuGponMacGemRcvdOmciFramesWithCorrCrcCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedOmciFramesWithCorrCrc += tempCounter1;
+	mvOnuGponMacGemRcvdOmciFramesWithCrcErrCounterGet(&tempCounter1);
+	g_OnuGponPm.gem.receivedOmciFramesWithCrcError += tempCounter1;
+
+	/* Tx Counters */
+	/* =========== */
+	mvOnuGponMacTxGemPtiTypeOneFrameCounterGet(&tempCounter1);
+	g_OnuGponPm.tx.transmittedGemPtiTypeOneFrames += tempCounter1;
+	mvOnuGponMacTxGemPtiTypeZeroFrameCounterGet(&tempCounter1);
+	g_OnuGponPm.tx.transmittedGemPtiTypeZeroFrames += tempCounter1;
+	mvOnuGponMacTxIdleGemFramesCounterGet(&tempCounter1);
+	g_OnuGponPm.tx.transmittedIdleGemFrames += tempCounter1;
+	mvOnuGponMacTxTxEnableCounterGet(&tempCounter1);
+	g_OnuGponPm.tx.transmittedTxEnableCount += tempCounter1;
+
+	for (tcont = 0; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+		status = onuGponDbBwTcontExist(tcont, &exist);
+		if ((status == MV_OK) && (exist != MV_FALSE)) {
+			mvOnuGponMacTxEthFramesTcontiCounterGet(tcont, &tempCounter1);
+			g_OnuGponPm.tx.transmittedEthFramesViaTconti[tcont] += tempCounter1;
+			mvOnuGponMacTxEthBytesTcontiCounterGet(tcont, &tempCounter1);
+			g_OnuGponPm.tx.transmittedEthBytesViaTconti[tcont] += tempCounter1;
+			mvOnuGponMacTxGemFramesTcontiCounterGet(tcont, &tempCounter1);
+			g_OnuGponPm.tx.transmittedGemFramesViaTconti[tcont] += tempCounter1;
+			mvOnuGponMacTxIdleGemFramesTcontiCounterGet(tcont, &tempCounter1);
+			g_OnuGponPm.tx.transmittedIdleGemFramesViaTconti[tcont] += tempCounter1;
+		}
+	}
+
+	/* Sw Counters */
+	/* =========== */
+	onuGponPmSwCountersUpdate(&g_OnuGponPm.rxPloam, &g_OnuGponPm.txPloam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxSwCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates Rx Ploam message counters
+**
+**  PARAMETERS:  MV_U8 a_msgId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxSwCountersAdd(MV_U8 a_msgId)
+{
+	g_OnuGponSwPm.rxMsgTotalPloamCounter++;
+	g_OnuGponSwPm.rxMsgIdPloamCounter[a_msgId]++;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmSwCountersUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates Rx Ploam message counters
+**
+**  PARAMETERS:  MV_U8 a_msgId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmSwCountersUpdate(S_RxPloamPm *rxPloamPm, S_TxPloamPm *txPloamPm)
+{
+	MV_U32 numOfMsgIdIndex;
+
+	/* Rx PLOAM */
+	rxPloamPm->rxMsgTotalPloamCounter = g_OnuGponSwPm.rxMsgTotalPloamCounter;
+
+	for (numOfMsgIdIndex = ONU_GPON_DS_MSG_OVERHEAD;
+	     numOfMsgIdIndex <= ONU_GPON_DS_MSG_EXT_BURST_LEN;
+	     numOfMsgIdIndex++)
+		rxPloamPm->rxMsgIdPloamCounter[numOfMsgIdIndex] = g_OnuGponSwPm.rxMsgIdPloamCounter[numOfMsgIdIndex];
+
+	mvOnuGponMacTxSwCountersGet((void *)txPloamPm);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxOmciCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function updates Rx Ploam message counters
+**
+**  PARAMETERS:  MV_U8 a_msgId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxOmciCountersAdd(void)
+{
+	g_OnuGponPm.rxOmci.receivedOmciCounter++;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmFecPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx FEC counters
+**
+**  PARAMETERS:  S_RxFecPm *fecPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmFecPmGet(S_RxFecPm *fecPm)
+{
+	fecPm->receivedBytes        = g_OnuGponPm.rxFec.receivedBytes;
+	fecPm->correctedBytes       = g_OnuGponPm.rxFec.correctedBytes;
+	fecPm->correctedBits        = g_OnuGponPm.rxFec.correctedBits ;
+	fecPm->receivedCodeWords    = g_OnuGponPm.rxFec.receivedCodeWords;
+	fecPm->uncorrectedCodeWords = g_OnuGponPm.rxFec.uncorrectedCodeWords;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxPloamPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx PLOAM counters
+**
+**  PARAMETERS:  S_RxPloamPm *rxPloamPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxPloamPmGet(S_RxPloamPm *rxPloamPm)
+{
+	MV_U32 numOfMsgIdIndex;
+
+	rxPloamPm->crcErrorPloamCounter          = g_OnuGponPm.rxPloam.crcErrorPloamCounter;
+	rxPloamPm->receivedBroadcastPloamCounter = g_OnuGponPm.rxPloam.receivedBroadcastPloamCounter;
+	rxPloamPm->receivedOnuIdPloamCounter     = g_OnuGponPm.rxPloam.receivedOnuIdPloamCounter;
+	rxPloamPm->fifoOverErrorPloamCounter     = g_OnuGponPm.rxPloam.fifoOverErrorPloamCounter;
+	rxPloamPm->idlePloamCounter              = g_OnuGponPm.rxPloam.idlePloamCounter;
+	rxPloamPm->rxMsgTotalPloamCounter        = g_OnuGponPm.rxPloam.rxMsgTotalPloamCounter;
+
+	for (numOfMsgIdIndex = 0 ; numOfMsgIdIndex <= ONU_GPON_DS_MSG_LAST; numOfMsgIdIndex++)
+		rxPloamPm->rxMsgIdPloamCounter[numOfMsgIdIndex] = g_OnuGponPm.rxPloam.rxMsgIdPloamCounter[numOfMsgIdIndex];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmTxPloamPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Tx PLOAM counters
+**
+**  PARAMETERS:  S_TxPloamPm *txPloamPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmTxPloamPmGet(S_TxPloamPm *txPloamPm)
+{
+	MV_U32 numOfMsgIdIndex;
+
+	txPloamPm->txMsgTotalPloamCounter = g_OnuGponPm.txPloam.txMsgTotalPloamCounter;
+
+	for (numOfMsgIdIndex = 1; numOfMsgIdIndex <= ONU_GPON_US_MSG_LAST; numOfMsgIdIndex++) {
+		txPloamPm->txMsgIdPloamCounter[numOfMsgIdIndex] = g_OnuGponPm.txPloam.txMsgIdPloamCounter[numOfMsgIdIndex];
+		txPloamPm->txErrMsgIdPloamCounter[numOfMsgIdIndex] = g_OnuGponPm.txPloam.txErrMsgIdPloamCounter[numOfMsgIdIndex];
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxBwMapCountersAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: This routine read BW MAP counters from ASIC to the database
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxBwMapCountersAdd(void)
+{
+	MV_U32 tempCounter1;
+	MV_U32 tempCounter2;
+	MV_U32 tempCounter3;
+	MV_U32 tempCounter4;
+
+	mvOnuGponMacRxBwMapAllocatrionsCounterGet(&tempCounter1, &tempCounter2, &tempCounter3, &tempCounter4);
+	/* Received allocations errors free */
+	g_OnuGponPm.rxBwMap.allocCorrec              += tempCounter1;
+	/* Received allocations with uncorrectable CRC errors */
+	g_OnuGponPm.rxBwMap.allocUnCorrectableCrcErr += tempCounter2;
+	/* Received allocations with correctable CRC errors or errors free */
+	g_OnuGponPm.rxBwMap.allocCorrectableCrcErr   += tempCounter3;
+	/* Received allocations with CRC error */
+	g_OnuGponPm.rxBwMap.allocCrcErr              += tempCounter4;
+	/* Total received byte allocations */
+	mvOnuGponMacRxBwMapTotalBwGet(&tempCounter1);
+	g_OnuGponPm.rxBwMap.totalReceivedAllocBytes  += tempCounter1;
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxBwMapPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx BW MAP counters
+**
+**  PARAMETERS:  S_RxPloamPm *rxPloamPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxBwMapPmGet(S_RxBwMapPm *rxBwMapPm)
+{
+	rxBwMapPm->allocCorrec              = g_OnuGponPm.rxBwMap.allocCorrec;
+	rxBwMapPm->allocCorrectableCrcErr   = g_OnuGponPm.rxBwMap.allocCorrectableCrcErr;
+	rxBwMapPm->allocCrcErr              = g_OnuGponPm.rxBwMap.allocCrcErr;
+	rxBwMapPm->allocUnCorrectableCrcErr = g_OnuGponPm.rxBwMap.allocUnCorrectableCrcErr;
+	rxBwMapPm->totalReceivedAllocBytes  = g_OnuGponPm.rxBwMap.totalReceivedAllocBytes;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxPlendPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx Plend counter
+**
+**  PARAMETERS:  S_RxPlendPm *rxPlendPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxPlendPmGet(S_RxPlendPm *rxPlendPm)
+{
+	rxPlendPm->plend = g_OnuGponPm.rxPlend.plend;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxBip8PmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx Bip8 counter
+**
+**  PARAMETERS:  S_RxBip8Pm *rxBip8Pm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxBip8PmGet(S_RxBip8Pm *rxBip8Pm)
+{
+	rxBip8Pm->bip8 = g_OnuGponPm.rxBip8.bip8;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmRxOmciPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Rx OMCI counter
+**
+**  PARAMETERS:  S_RxOmciPm *rxOmciPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmRxOmciPmGet(S_RxOmciPm *rxOmciPm)
+{
+	rxOmciPm->receivedOmciCounter = g_OnuGponPm.rxOmci.receivedOmciCounter;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Gem pm counters
+**
+**  PARAMETERS:  S_GemPm *gemPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPmGet(S_GemPm *gemPm)
+{
+	gemPm->receivedIdleGemFrames                       = g_OnuGponPm.gem.receivedIdleGemFrames;
+	gemPm->receivedValidGemFrames                      = g_OnuGponPm.gem.receivedValidGemFrames;
+	gemPm->receivedUndefinedGemFrames                  = g_OnuGponPm.gem.receivedUndefinedGemFrames;
+	gemPm->receivedOmciFrames                          = g_OnuGponPm.gem.receivedOmciFrames;
+	gemPm->droppedGemFrames                            = g_OnuGponPm.gem.droppedGemFrames;
+	gemPm->droppedOmciFrames                           = g_OnuGponPm.gem.droppedOmciFrames;
+	gemPm->receivedGemFramesWithUncorrHecErr           = g_OnuGponPm.gem.receivedGemFramesWithUncorrHecErr;
+	gemPm->receivedGemFramesWithOneFixedHecErr         = g_OnuGponPm.gem.receivedGemFramesWithOneFixedHecErr;
+	gemPm->receivedGemFramesWithTwoFixedHecErr         = g_OnuGponPm.gem.receivedGemFramesWithTwoFixedHecErr;
+	gemPm->totalByteCountOfReceivedValidGemFrames      = g_OnuGponPm.gem.totalByteCountOfReceivedValidGemFrames;
+	gemPm->totalByteCountOfReceivedUndefinedGemFrames  = g_OnuGponPm.gem.totalByteCountOfReceivedUndefinedGemFrames;
+	gemPm->gemReassembleMemoryFlush                    = g_OnuGponPm.gem.gemReassembleMemoryFlush;
+	gemPm->gemSynchLost                                = g_OnuGponPm.gem.gemSynchLost;
+	gemPm->receivedEthFramesWithCorrFcs                = g_OnuGponPm.gem.receivedEthFramesWithCorrFcs;
+	gemPm->receivedEthFramesWithFcsError               = g_OnuGponPm.gem.receivedEthFramesWithFcsError;
+	gemPm->receivedOmciFramesWithCorrCrc               = g_OnuGponPm.gem.receivedOmciFramesWithCorrCrc;
+	gemPm->receivedOmciFramesWithCrcError              = g_OnuGponPm.gem.receivedOmciFramesWithCrcError;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmTxPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Tx pm counters
+**
+**  PARAMETERS:  S_TxPm *txPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmTxPmGet(S_GponTxPm *txPm)
+{
+	MV_U32 tcont;
+	MV_BOOL exist;
+	MV_STATUS status;
+
+	txPm->transmittedGemPtiTypeOneFrames    = g_OnuGponPm.tx.transmittedGemPtiTypeOneFrames;
+	txPm->transmittedGemPtiTypeZeroFrames   = g_OnuGponPm.tx.transmittedGemPtiTypeZeroFrames;
+	txPm->transmittedIdleGemFrames          = g_OnuGponPm.tx.transmittedIdleGemFrames;
+	txPm->transmittedTxEnableCount          = g_OnuGponPm.tx.transmittedTxEnableCount;
+
+	for (tcont = 0; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+		status = onuGponDbBwTcontExist(tcont, &exist);
+		if ((status == MV_OK) && (exist != MV_FALSE)) {
+			txPm->transmittedEthFramesViaTconti[tcont]     = g_OnuGponPm.tx.transmittedEthFramesViaTconti[tcont];
+			txPm->transmittedEthBytesViaTconti[tcont]      = g_OnuGponPm.tx.transmittedEthBytesViaTconti[tcont];
+			txPm->transmittedGemFramesViaTconti[tcont]     = g_OnuGponPm.tx.transmittedGemFramesViaTconti[tcont];
+			txPm->transmittedIdleGemFramesViaTconti[tcont] = g_OnuGponPm.tx.transmittedIdleGemFramesViaTconti[tcont];
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmTxBurstEnCntGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The funtion return onu Tx burst enable counter
+**
+**  PARAMETERS:  unsigned int *txBurstEnCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponPmTxBurstEnCntGet(unsigned int *txBurstEnCnt)
+{
+	*txBurstEnCnt = g_OnuGponPm.tx.transmittedTxEnableCount;
+
+	g_OnuGponPm.tx.transmittedTxEnableCount = 0;
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                         GEM Port PM Section                                */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears GEM Port PM database
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuGponPmGemPortPmInit(void)
+{
+	int indx;
+
+	for (indx = 0; indx < MAX_ENTRIES_GEMPORTPM_CONFIG_DB; indx++)
+		apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx].in_use = MV_FALSE;
+
+	if (asicOntGlbRegRead(mvAsicReg_PON_MIB_DEFAULT, &apiGemPortPmConfigDb.origRxMibDefaultReg, 0) != MV_OK)
+		printk(KERN_ERR "%s: asicOntGlbRegRead failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+			__func__, mvAsicReg_PON_MIB_DEFAULT);
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmGetNumUsedEntries
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function counts the number of used GEM port entries in the DB
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     int
+**
+*******************************************************************************/
+int onuGponPmGemPortPmGetNumUsedEntries(void)
+{
+	int indx;
+	int usedEntries = 0;
+
+	for (indx = 0; indx < MAX_ENTRIES_GEMPORTPM_CONFIG_DB; indx++)
+		if (apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx].in_use == MV_TRUE)
+			usedEntries++;
+	return usedEntries;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmSetControl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the GEM Port MIB PM control registers
+**
+**  PARAMETERS:  int    counter_set
+**               MV_U32 direction
+**               MV_U32 ctrlValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPortPmSetControl(int counter_set, MV_U32 direction, MV_U32 ctrlValue)
+{
+	MV_STATUS rcode = MV_OK;
+	MV_U32 baseControlReg;
+	MV_U32 registersAra[] = {
+		mvAsicReg_PON_MAC_MIB_CONTROL_0,  mvAsicReg_PON_MAC_MIB_CONTROL_1,  mvAsicReg_PON_MAC_MIB_CONTROL_2,   mvAsicReg_PON_MAC_MIB_CONTROL_3,
+		mvAsicReg_PON_MAC_MIB_CONTROL_4,  mvAsicReg_PON_MAC_MIB_CONTROL_5,  mvAsicReg_PON_MAC_MIB_CONTROL_6,   mvAsicReg_PON_MAC_MIB_CONTROL_7,
+		mvAsicReg_PON_MAC_MIB_CONTROL_8,  mvAsicReg_PON_MAC_MIB_CONTROL_9,  mvAsicReg_PON_MAC_MIB_CONTROL_10,  mvAsicReg_PON_MAC_MIB_CONTROL_11,
+		mvAsicReg_PON_MAC_MIB_CONTROL_12, mvAsicReg_PON_MAC_MIB_CONTROL_13, mvAsicReg_PON_MAC_MIB_CONTROL_14,  mvAsicReg_PON_MAC_MIB_CONTROL_15,
+		mvAsicReg_PON_MAC_MIB_CONTROL_16, mvAsicReg_PON_MAC_MIB_CONTROL_17, mvAsicReg_PON_MAC_MIB_CONTROL_18,  mvAsicReg_PON_MAC_MIB_CONTROL_19,
+		mvAsicReg_PON_MAC_MIB_CONTROL_20, mvAsicReg_PON_MAC_MIB_CONTROL_21, mvAsicReg_PON_MAC_MIB_CONTROL_22,  mvAsicReg_PON_MAC_MIB_CONTROL_23,
+		mvAsicReg_PON_MAC_MIB_CONTROL_24, mvAsicReg_PON_MAC_MIB_CONTROL_25, mvAsicReg_PON_MAC_MIB_CONTROL_26,  mvAsicReg_PON_MAC_MIB_CONTROL_27,
+		mvAsicReg_PON_MAC_MIB_CONTROL_28, mvAsicReg_PON_MAC_MIB_CONTROL_29, mvAsicReg_PON_MAC_MIB_CONTROL_30,  mvAsicReg_PON_MAC_MIB_CONTROL_31
+	};
+
+	baseControlReg = registersAra[counter_set];
+
+	if (direction == GEMPORTPMDIRECTION_BIDI || direction == GEMPORTPMDIRECTION_DS) {
+		rcode = asicOntMiscRegWrite(baseControlReg, ctrlValue, ONU_MIB_PM_RX_MIB_Control);
+		if (rcode != MV_OK)
+			printk(KERN_INFO "%s: asicOntMiscRegWrite failed for counter_set(%d), direction(%d), Rx-offset(%d)\n",
+				__func__, counter_set, direction, ONU_MIB_PM_RX_MIB_Control);
+	}
+
+	if (direction == GEMPORTPMDIRECTION_BIDI || direction == GEMPORTPMDIRECTION_US) {
+		rcode = asicOntMiscRegWrite(baseControlReg, ctrlValue, ONU_MIB_PM_TX_MIB_Control);
+		if (rcode != MV_OK)
+			printk(KERN_INFO "%s: asicOntMiscRegWrite failed for counter_set(%d), direction(%d), Tx-offset(%d)\n",
+				__func__, counter_set, direction, ONU_MIB_PM_TX_MIB_Control);
+	}
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmStart
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function activates MIB Counter PM for a GEM port
+**
+**  PARAMETERS:  S_GponIoctlGemPortPmConfig *
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPortPmStart(MV_U16 gemPort, MV_U32 direction)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiGemPortPmConfig *apiGemPortPmConfig;
+	S_apiGemPortPmConfig *tgtApiGemPortPmConfig = 0;
+	int freeIndx;
+	MV_U32 mibCtrlValue;
+
+	/* Does the GEM Port already appear in table */
+	for (indx = 0; indx < MAX_SUPPORTED_GEMPORTS_FOR_PM; indx++) {
+		apiGemPortPmConfig = &apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx];
+		if (apiGemPortPmConfig->in_use == MV_TRUE && apiGemPortPmConfig->gem_port == gemPort) {
+			if (apiGemPortPmConfig->direction == direction) {
+				printk(KERN_INFO "%s: gemPort(%d), direction(%d) already configured\n",
+					__func__, gemPort, direction);
+				return MV_ALREADY_EXIST;
+			} else if (apiGemPortPmConfig->direction == GEMPORTPMDIRECTION_BIDI) {
+				printk(KERN_INFO "%s: gemPort(%d) bidi PM already configured\n", __func__, gemPort);
+				return MV_NOT_ALLOWED;
+			} else if (direction == GEMPORTPMDIRECTION_BIDI) {
+				printk(KERN_INFO "%s: gemPort(%d) unidirectional PM already configured\n", __func__, gemPort);
+				return MV_NOT_ALLOWED;
+			}
+		}
+	}
+
+	for (indx = 0; indx < MAX_SUPPORTED_GEMPORTS_FOR_PM; indx++) {
+		apiGemPortPmConfig = &apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx];
+		if (apiGemPortPmConfig->in_use == MV_FALSE) {
+			tgtApiGemPortPmConfig = apiGemPortPmConfig;
+			freeIndx              = indx;
+			break;
+		}
+	}
+
+	/* Did we find a free entry */
+	if (tgtApiGemPortPmConfig == 0) {
+		printk(KERN_INFO "%s: GEM Port MIB PM table full. gemPort = %d (start)\n", __func__, gemPort);
+		return MV_NO_MORE;
+	}
+
+	if (onuGponPmGemPortPmGetNumUsedEntries() == 0) {
+		rcode = asicOntGlbRegRead(mvAsicReg_PON_MIB_DEFAULT, &apiGemPortPmConfigDb.origRxMibDefaultReg, 0);
+		if (rcode != MV_OK) {
+			printk(KERN_ERR "%s: asicOntGlbRegRead failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+		mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+		rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, mibCtrlValue, 0);
+		if (rcode!= MV_OK) {
+			printk(KERN_ERR "%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+	}
+
+	/* Now start the GEM Port MIB PM */
+	mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_VALID_BIT, freeIndx, gemPort);
+	rcode = onuGponPmGemPortPmSetControl(freeIndx, direction, mibCtrlValue);
+	if (rcode != MV_OK)
+		printk(KERN_ERR "%s: Failed to start GEM Port MIB PM for gemPort(%d), direction(%d), counter_set(%d)\n",
+		__func__, gemPort, direction, freeIndx);
+	else {
+		tgtApiGemPortPmConfig->gem_port    = gemPort;
+		tgtApiGemPortPmConfig->counter_set = freeIndx;
+		tgtApiGemPortPmConfig->direction   = direction;
+		tgtApiGemPortPmConfig->in_use      = MV_TRUE;
+	}
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmStop
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function activates MIB Counter PM for a GEM port
+**
+**  PARAMETERS:  S_GponIoctlGemPortPmConfig *
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS  onuGponPmGemPortPmStop(MV_U16 gemPort, MV_U32 direction)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiGemPortPmConfig *apiGemPortPmConfig;
+	S_apiGemPortPmConfig *tgtApiGemPortPmConfig = 0;
+	MV_U32 mibCtrlValue;
+
+	/* Does the GEM Port already appear in table */
+	for (indx = 0; indx < MAX_SUPPORTED_GEMPORTS_FOR_PM; indx++) {
+		apiGemPortPmConfig = &apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx];
+		if (apiGemPortPmConfig->in_use == MV_TRUE && apiGemPortPmConfig->gem_port == gemPort &&
+			apiGemPortPmConfig->direction == direction) {
+			tgtApiGemPortPmConfig = apiGemPortPmConfig;
+			break;
+		}
+	}
+
+	/* Did we find a free entry */
+	if (tgtApiGemPortPmConfig == 0) {
+		printk(KERN_INFO "%s: gemPort %d, direction(%d) not configured\n", __func__, gemPort, direction);
+		return MV_NOT_FOUND;
+	}
+
+	mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+	rcode = onuGponPmGemPortPmSetControl(indx, direction, mibCtrlValue);
+	if (rcode != MV_OK)
+		printk(KERN_ERR "%s: Failed to stop GEM Port MIB PM for gemPort(%d), direction(%d), counter_set(%d)\n",
+			__func__, gemPort, direction, indx);
+	else
+		tgtApiGemPortPmConfig->in_use = MV_FALSE;
+
+	/* If no more GEM ports are being monitored, restore the original RX_MIB_DEFAULT register value */
+	if (onuGponPmGemPortPmGetNumUsedEntries() == 0) {
+		rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, apiGemPortPmConfigDb.origRxMibDefaultReg, 0);
+		if (rcode != MV_OK) {
+			printk(KERN_ERR "%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+				__func__, mvAsicReg_PON_MIB_DEFAULT);
+			return rcode;
+		}
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears HW register for PM collection for GEM Port
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPortPmReset(void)
+{
+	MV_STATUS rcode;
+	int indx;
+	uint32_t mibCtrlValue = MAKE_MIB_COUNTER_CONTROL(MIB_COUNTER_CONTROL_INVALID_BIT, 0, 0);
+
+	for (indx = 0; indx < MAX_ENTRIES_GEMPORTPM_CONFIG_DB; indx++) {
+		/* Clear Gem Ports configured array and HW registers */
+		apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx].in_use = MV_FALSE;
+		rcode = onuGponPmGemPortPmSetControl(indx, GEMPORTPMDIRECTION_BIDI, mibCtrlValue);
+		if (rcode != MV_OK) {
+			printk(KERN_ERR "%s: Failed to stop GEM Port MIB PM for counter_set(%d), bidi\n",
+				__func__, indx);
+			return rcode;
+		}
+	}
+
+	rcode = asicOntMiscRegWrite(mvAsicReg_PON_MIB_DEFAULT, apiGemPortPmConfigDb.origRxMibDefaultReg, 0);
+	if (rcode  != MV_OK) {
+		printk(KERN_ERR "%s: asicOntMiscRegWrite failed for mvAsicReg_PON_MIB_DEFAULT(%d)\n",
+			__func__, mvAsicReg_PON_MIB_DEFAULT);
+		return rcode;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function retrieves MIB Counter PM for GEM Port
+**
+**  PARAMETERS:  S_GponIoctlGemPortMibCounters *
+**
+**  OUTPUTS:     Reads MIB counters from HW
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPortPmGet(S_GponIoctlGemPortMibCounters *gemPortMibCounters)
+{
+	MV_STATUS rcode = MV_OK;
+	int indx;
+	S_apiGemPortPmConfig *apiGemPortPmConfig;
+	S_apiGemPortPmConfig *tgtApiGemPortPmConfig = 0;
+	MV_U32 baseCounterReg;
+	MV_U32 lowvalue;
+	MV_U32 hivalue;
+	MV_U32 registersAra[] = {
+		mvAsicReg_PON_MAC_MIB_COUNTERS_0,  mvAsicReg_PON_MAC_MIB_COUNTERS_1,  mvAsicReg_PON_MAC_MIB_COUNTERS_2,   mvAsicReg_PON_MAC_MIB_COUNTERS_3,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_4,  mvAsicReg_PON_MAC_MIB_COUNTERS_5,  mvAsicReg_PON_MAC_MIB_COUNTERS_6,   mvAsicReg_PON_MAC_MIB_COUNTERS_7,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_8,  mvAsicReg_PON_MAC_MIB_COUNTERS_9,  mvAsicReg_PON_MAC_MIB_COUNTERS_10,  mvAsicReg_PON_MAC_MIB_COUNTERS_11,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_12, mvAsicReg_PON_MAC_MIB_COUNTERS_13, mvAsicReg_PON_MAC_MIB_COUNTERS_14,  mvAsicReg_PON_MAC_MIB_COUNTERS_15,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_16, mvAsicReg_PON_MAC_MIB_COUNTERS_17, mvAsicReg_PON_MAC_MIB_COUNTERS_18,  mvAsicReg_PON_MAC_MIB_COUNTERS_19,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_20, mvAsicReg_PON_MAC_MIB_COUNTERS_21, mvAsicReg_PON_MAC_MIB_COUNTERS_22,  mvAsicReg_PON_MAC_MIB_COUNTERS_23,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_24, mvAsicReg_PON_MAC_MIB_COUNTERS_25, mvAsicReg_PON_MAC_MIB_COUNTERS_26,  mvAsicReg_PON_MAC_MIB_COUNTERS_27,
+		mvAsicReg_PON_MAC_MIB_COUNTERS_28, mvAsicReg_PON_MAC_MIB_COUNTERS_29, mvAsicReg_PON_MAC_MIB_COUNTERS_30,  mvAsicReg_PON_MAC_MIB_COUNTERS_31
+	};
+
+	for (indx = 0; indx < MAX_SUPPORTED_GEMPORTS_FOR_PM; indx++) {
+		apiGemPortPmConfig = &apiGemPortPmConfigDb.apiGemPortPmConfigAra[indx];
+		if (apiGemPortPmConfig->in_use == MV_TRUE &&
+		    apiGemPortPmConfig->gem_port == gemPortMibCounters->gem_port &&
+		    apiGemPortPmConfig->direction == gemPortMibCounters->direction) {
+			baseCounterReg = registersAra[apiGemPortPmConfig->counter_set];
+			tgtApiGemPortPmConfig = apiGemPortPmConfig;
+			break;
+		}
+	}
+
+	if (tgtApiGemPortPmConfig != 0) {
+
+		/* 64 bit counter treatment: read the low part first, to lock the high part */
+		rcode |= asicOntGlbRegRead(baseCounterReg, &lowvalue, ONU_MIB_PM_GoodOctetsReceived_low);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &hivalue,  ONU_MIB_PM_GoodOctetsReceived_high);
+		gemPortMibCounters->good_octets_received = (uint64_t)hivalue << 32 | lowvalue;
+
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->bad_octets_received,       ONU_MIB_PM_BadOctetsReceived);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->mac_trans_error,           ONU_MIB_PM_MACTransError);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->good_frames_received,      ONU_MIB_PM_GoodFramesReceived);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->bad_frames_received,       ONU_MIB_PM_BadFramesReceived);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->broadcast_frames_received, ONU_MIB_PM_BroadcastFramesReceived);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->multicast_frames_received, ONU_MIB_PM_MulticastFramesReceived);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_64_octets,          ONU_MIB_PM_Frames64Octets);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_65_to_127_octets,   ONU_MIB_PM_Frames65to127Octets);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_128_to_255octets,   ONU_MIB_PM_Frames128to255Octets);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_256_to_511_octets,  ONU_MIB_PM_Frames256to511Octets);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_512_to_1023_octets, ONU_MIB_PM_Frames512to1023Octets);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->frames_1024_to_max_octets, ONU_MIB_PM_Frames1024toMaxOctets);
+
+		/* 64 bit counter treatment: read the low part first, to lock the high part */
+		rcode |= asicOntGlbRegRead(baseCounterReg, &lowvalue, ONU_MIB_PM_GoodOctetsSent_low);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &hivalue,  ONU_MIB_PM_GoodOctetsSent_high);
+		gemPortMibCounters->good_octets_sent = (uint64_t)hivalue << 32 | lowvalue;
+
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->good_frames_sent, ONU_MIB_PM_GoodFramesSent);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->multicast_frames_sent, ONU_MIB_PM_MulticastFramesSent);
+		rcode |= asicOntGlbRegRead(baseCounterReg, &gemPortMibCounters->broadcast_frames_sent, ONU_MIB_PM_BroadcastFramesSent);
+
+		if (rcode != MV_OK) {
+			printk(KERN_ERR "%s: asicOntGlbRegRead failure, rcode(%d), baseCounterReg(%d)\n",
+				__func__, rcode, baseCounterReg);
+			return MV_ERROR;
+		}
+	} else {
+		printk(KERN_ERR "%s: gemPort(%d), direction(%d) not configured\n",
+			__func__, gemPortMibCounters->gem_port, gemPortMibCounters->direction);
+		return MV_NOT_FOUND;
+	}
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponPmGemPortPmConfigGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns configured GEM port data
+**
+**  PARAMETERS:  Index in the GEM port DB
+**
+**  OUTPUTS:     S_apiGemPortPmConfig
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponPmGemPortPmConfigGet(MV_U16 dbIdx, S_apiGemPortPmConfig *gemPortPmConfig)
+{
+	memset(gemPortPmConfig, 0, sizeof(S_apiGemPortPmConfig));
+
+	if (dbIdx >= MAX_SUPPORTED_GEMPORTS_FOR_PM) {
+		printk(KERN_ERR "%s: Invalid index = %d\n", __func__, dbIdx);
+		return MV_OUT_OF_RANGE;
+	}
+
+	if (apiGemPortPmConfigDb.apiGemPortPmConfigAra[dbIdx].in_use == MV_FALSE)
+		return MV_GET_ERROR;
+
+	memcpy(gemPortPmConfig, &apiGemPortPmConfigDb.apiGemPortPmConfigAra[dbIdx], sizeof(S_apiGemPortPmConfig));
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.h
new file mode 100644
index 0000000..f6cf0a3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuPm.h
@@ -0,0 +1,274 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuPm.h                                                **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Alarm and Statistics           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_PM_H
+#define _ONU_GPON_PM_H
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+#ifdef MV_GPON_PERFORMANCE_CHECK
+typedef enum {
+	PON_ISR_PERFORMANCE              = 0,
+	PON_MNG1_PERFORMANCE             = 1,
+	PON_MNG2_PERFORMANCE             = 2,
+	PON_MNG3_PERFORMANCE             = 3,
+	PON_MNG4_PERFORMANCE             = 4,
+	PON_MNG5_PERFORMANCE             = 5,
+	PON_EXT_BURST_PLOAM_PERFORMANCE  = 6,
+	PON_KEY_SWITCH_PLOAM_PERFORMANCE = 7,
+	PON_CFG_PORT_PLOAM_PERFORMANCE   = 8,
+	PON_REQ_KEY_PLOAM_PERFORMANCE    = 8,
+	PON_ALLOC_ID_PLOAM_PERFORMANCE   = 10,
+	PON_PASS_PLOAM_PERFORMANCE       = 11,
+	PON_ENC_PORT_PLOAM_PERFORMANCE   = 12,
+	PON_DIS_PLOAM_PERFORMANCE        = 13,
+	PON_DACT_PLOAM_PERFORMANCE       = 14,
+	PON_RNG_PLOAM_PERFORMANCE        = 15,
+	PON_ONU_ID_PLOAM_PERFORMANCE     = 16,
+	PON_OVERHEAD_PLOAM_PERFORMANCE   = 17,
+	PON_MAX_PERFORMANCE              = 18
+} E_GponPerformanceCheck;
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 rxMsgIdPloamCounter[ONU_GPON_DS_MSG_LAST + 1];
+	MV_U32 rxMsgTotalPloamCounter;
+	MV_U32 txErrMsgIdPloamCounter[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgIdPloamCounter[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgTotalPloamCounter;
+} S_PloamSwPm;
+
+typedef struct {
+	MV_U32 idlePloamCounter;
+	MV_U32 crcErrorPloamCounter;
+	MV_U32 fifoOverErrorPloamCounter;
+	MV_U32 receivedBroadcastPloamCounter;
+	MV_U32 receivedOnuIdPloamCounter;
+	MV_U32 rxMsgIdPloamCounter[ONU_GPON_DS_MSG_LAST + 1];
+	MV_U32 rxMsgTotalPloamCounter;
+} S_RxPloamPm;
+
+typedef struct {
+	MV_U32 txErrMsgIdPloamCounter[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgIdPloamCounter[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgTotalPloamCounter;
+} S_TxPloamPm;
+
+typedef struct {
+	MV_U32 allocCrcErr;
+	MV_U32 allocCorrectableCrcErr;
+	MV_U32 allocUnCorrectableCrcErr;
+	MV_U32 allocCorrec;
+	MV_U32 totalReceivedAllocBytes;
+} S_RxBwMapPm;
+
+typedef struct {
+	MV_U32 receivedBytes;
+	MV_U32 correctedBytes;
+	MV_U32 correctedBits;
+	MV_U32 receivedCodeWords;
+	MV_U32 uncorrectedCodeWords;
+} S_RxFecPm;
+
+typedef struct {
+	MV_U32 plend;
+} S_RxPlendPm;
+
+typedef struct {
+	MV_U32 bip8;
+} S_RxBip8Pm;
+
+typedef struct {
+	MV_U32 receivedOmciCounter;
+} S_RxOmciPm;
+
+typedef struct {
+	MV_U32 receivedIdleGemFrames;
+	MV_U32 receivedValidGemFrames;
+	MV_U32 receivedUndefinedGemFrames;
+	MV_U32 receivedOmciFrames;
+	MV_U32 droppedGemFrames;
+	MV_U32 droppedOmciFrames;
+	MV_U32 receivedGemFramesWithUncorrHecErr;
+	MV_U32 receivedGemFramesWithOneFixedHecErr;
+	MV_U32 receivedGemFramesWithTwoFixedHecErr;
+	MV_U32 totalByteCountOfReceivedValidGemFrames;
+	MV_U32 totalByteCountOfReceivedUndefinedGemFrames;
+	MV_U32 gemReassembleMemoryFlush;
+	MV_U32 gemSynchLost;
+	MV_U32 receivedEthFramesWithCorrFcs;
+	MV_U32 receivedEthFramesWithFcsError;
+	MV_U32 receivedOmciFramesWithCorrCrc;
+	MV_U32 receivedOmciFramesWithCrcError;
+} S_GemPm;
+
+typedef struct {
+	MV_U32 transmittedGemPtiTypeOneFrames;
+	MV_U32 transmittedGemPtiTypeZeroFrames;
+	MV_U32 transmittedIdleGemFrames;
+	MV_U32 transmittedTxEnableCount;
+	MV_U32 transmittedEthFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 transmittedEthBytesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 transmittedGemFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 transmittedIdleGemFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+} S_GponTxPm;
+
+typedef struct {
+	S_RxBwMapPm rxBwMap;
+	S_RxPloamPm rxPloam;
+	S_TxPloamPm txPloam;
+	S_RxPlendPm rxPlend;
+	S_RxFecPm rxFec;
+	S_RxBip8Pm rxBip8;
+	S_RxOmciPm rxOmci;
+	S_GemPm gem;
+	S_GponTxPm tx;
+} S_GponPm;
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+typedef struct {
+	MV_U32 *uSecCntStart;
+	MV_U32 *uSecCntStop;
+	MV_U32 uSecCntIdx;
+} S_GponPerformanceCheckNode;
+
+typedef struct {
+	S_GponPerformanceCheckNode pmCheckNode[PON_MAX_PERFORMANCE];
+} S_GponPerformanceCheck;
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+
+typedef struct {
+	MV_BOOL in_use;
+	MV_U16 gem_port;
+	MV_U32 counter_set;
+	MV_U32 direction;
+} S_apiGemPortPmConfig;
+
+#define MAX_SUPPORTED_GEMPORTS_FOR_PM           32
+#define MAX_ENTRIES_GEMPORTPM_CONFIG_DB         (MAX_SUPPORTED_GEMPORTS_FOR_PM)
+typedef struct {
+	S_apiGemPortPmConfig apiGemPortPmConfigAra[MAX_ENTRIES_GEMPORTPM_CONFIG_DB];
+	MV_U32 origRxMibDefaultReg;
+} S_apiGemPortPmConfigDb;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+#ifdef MV_GPON_PERFORMANCE_CHECK
+extern S_GponPerformanceCheck g_GponPmCheck;
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+void       onuGponPmInPmInit(void);
+MV_STATUS onuGponPmCountersAdd(void);
+MV_STATUS onuGponRougeOnuCheck(void);
+#ifdef MV_GPON_PERFORMANCE_CHECK
+MV_STATUS onuGponPmInit(void);
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+void      onuGponPmInPmInit(void);
+void      onuGponPmTimerPmHndl(unsigned long data);
+void      onuGponPmTimerExpireHndl(void);
+MV_STATUS onuGponPmCountersAdd(void);
+MV_STATUS onuGponPmRxSwCountersAdd(MV_U8 a_msgId);
+MV_STATUS onuGponPmSwCountersUpdate(S_RxPloamPm *rxPloamPm, S_TxPloamPm *txPloamPm);
+MV_STATUS onuGponPmRxOmciCountersAdd(void);
+MV_STATUS onuGponPmFecPmGet(S_RxFecPm *fecPm);
+MV_STATUS onuGponPmRxPloamPmGet(S_RxPloamPm *rxPloamPm);
+MV_STATUS onuGponPmTxPloamPmGet(S_TxPloamPm *txPloamPm);
+MV_STATUS onuGponPmRxBwMapPmGet(S_RxBwMapPm *rxBwMapPm);
+MV_STATUS onuGponPmRxBwMapCountersAdd(void);
+MV_STATUS onuGponPmRxPlendPmGet(S_RxPlendPm *rxPlendPm);
+MV_STATUS onuGponPmRxBip8PmGet(S_RxBip8Pm *rxBip8Pm);
+MV_STATUS onuGponPmRxOmciPmGet(S_RxOmciPm *rxOmciPm);
+MV_STATUS onuGponPmGemPmGet(S_GemPm *gemPm);
+MV_STATUS onuGponPmTxPmGet(S_GponTxPm *txPm);
+MV_STATUS onuGponPmTxBurstEnCntGet(unsigned int *txBurstEnCnt);
+
+MV_STATUS onuGponPmGemPortPmStart(MV_U16 gemPort, MV_U32 direction);
+MV_STATUS onuGponPmGemPortPmStop(MV_U16 gemPort, MV_U32 direction);
+MV_STATUS onuGponPmGemPortPmGet(S_GponIoctlGemPortMibCounters *gemPortMibCounters);
+MV_STATUS onuGponPmGemPortPmReset(void);
+void      onuGponPmGemPortPmInit(void);
+MV_STATUS onuGponPmGemPortPmConfigGet(MV_U16 dbIdx, S_apiGemPortPmConfig *gemPortPmConfig);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_PM_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.c
new file mode 100644
index 0000000..93489fe
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.c
@@ -0,0 +1,1914 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuSrvc.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Service Routines             **
+**                functionality                                              **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+#ifndef PON_FPGA
+#ifdef DISABLE_TCONT_FLUSH_FOR_AVANTA_LP
+#include "tpm_api.h"
+#endif
+#endif /* PON_FPGA */
+
+/* LSP Header Files */
+#include "mvPp2PrsHw.h"
+#include "mvPp2Prs.h"
+#include "cls/mvPp2ClsHw.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/core/gpon/gponOnuSrvc.c"
+
+#define POLYNOMIAL (0x04c11db7)
+
+static unsigned long crc_table[256];
+MV_U32 randomInternalDelayKey[5] = { 0, 0, 0, 0, 0 };
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_DbrBlockSize gponDbrArray[2048];
+MV_U32 gponDbrBlock2048AndMore;
+
+extern u8 mvMacAddr[MV_ETH_MAX_PORTS][MV_MAC_ADDR_SIZE];
+
+MV_U32 randomCode = 0;
+MV_U32 randomType = 0;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+S_OnuGponLogEntry onuGponLogDb[ONU_GPON_LOG_SIZE + 1];
+MV_32 onuGponLogDbEntryIndex = 0;
+MV_32 onuGponLogDbEntryCount = 0;
+MV_BOOL onuGponLogEnable = MV_FALSE;
+
+MV_32 onuGponTcontFlushState[8] = { TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE,
+				    TCONT_FLUSH_READY_STATE };
+
+/*******************************************************************************
+**
+**  onuGponSrvcInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu CRC generator
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcInit(void)
+{
+	MV_STATUS rcode;
+
+	rcode = onuGponSrvcGenDbrTable();
+	if (rcode != MV_OK)
+		return MV_ERROR;
+
+	rcode = onuGponSrvcGenCrcTable();
+	if (rcode != MV_OK)
+		return MV_ERROR;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcGenCrcTable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function generate the table of CRC remainders
+**               for all possible bytes
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcGenCrcTable(void)
+{
+	register int i, j;
+	register unsigned long crc_accum;
+
+	for (i = 0; i < 256; i++) {
+		crc_accum = ( (unsigned long)i << 24);
+		for (j = 0; j < 8; j++) {
+			if (crc_accum & 0x80000000)
+				crc_accum = (crc_accum << 1) ^ POLYNOMIAL;
+			else
+				crc_accum = (crc_accum << 1);
+		}
+		crc_table[i] = crc_accum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcUpdateCrc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function CRC table
+**
+**      PARAMETERS:  unsigned long crc_accum
+**                               char          *data_blk_ptr
+**				 int           data_blk_size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+unsigned long onuGponSrvcUpdateCrc(unsigned long crc_accum, char *data_blk_ptr, int data_blk_size)
+{
+	register int i, j;
+
+	for (j = 0; j < data_blk_size; j++) {
+		i = ((int)(crc_accum >> 24) ^ *data_blk_ptr++) & 0xff;
+		crc_accum = (crc_accum << 8) ^ crc_table[i];
+	}
+
+	return crc_accum ^ 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcCalcCrc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function calc CRC
+**
+**      PARAMETERS:  unsigned long crc_accum
+**                               char          *data_blk_ptr
+**				 int           data_blk_size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+unsigned int onuGponSrvcCalcCrc(unsigned char msg[], int size)
+{
+	unsigned char data;
+	unsigned int idx;
+	unsigned int calcCrc = 0;
+
+	for (idx = 0; idx < size; idx++) {
+		data    = (unsigned char)((msg[idx]) ^ (calcCrc >> 24));
+		calcCrc = ((crc_table[data]) ^ (calcCrc << 8));
+	}
+
+	return calcCrc;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcSerialNumberSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set SN in database and GPON MAC
+**
+**  PARAMETERS:  MV_U8 *serialNumber
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcSerialNumberSet(MV_U8 *serialNumber)
+{
+	MV_STATUS rcode;
+	MV_U32 snMsg[ONU_GPON_MSG_LEN];
+	MV_U32 onuId;
+
+	/* Update Serial Number In Data Base */
+	/* --------------------------------- */
+	rcode = onuGponDbSerialNumSet((MV_U8 *)serialNumber);
+	if (rcode != MV_OK)
+		return rcode;
+
+	/* Get Serial Number Message from Database */
+	onuGponDbSnMsgGet(snMsg);
+
+	/* Update the Serial Number in S/N Message */
+	snMsg[0] = (snMsg[0] & 0xFFFF0000) |
+		   (((MV_U32)(serialNumber[1])) |
+		    (((MV_U32)(serialNumber[0])) << 8));
+	snMsg[1] = (((MV_U32)(serialNumber[5])) |
+		    (((MV_U32)(serialNumber[4])) << 8) |
+		    (((MV_U32)(serialNumber[3])) << 16) |
+		    (((MV_U32)(serialNumber[2])) << 24));
+	snMsg[2] = ((((MV_U32)(serialNumber[7])) << 16) |
+		    (((MV_U32)(serialNumber[6])) << 24) |
+		    0x00000505);
+
+	/* Put back the updated Serial Number Message to Database */
+	onuGponDbSnMsgSet(snMsg);
+
+	/* Update Serial Number in ASIC */
+	/* ---------------------------- */
+	onuId = onuGponDbOnuIdGet();
+
+	rcode = mvOnuGponMacTxConstSerialNumberMsgSet(onuId, serialNumber, 0);
+
+	if (rcode != MV_OK)
+		return rcode;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcConstPloamFromDbInit
+**  ____________________________________________________________________________
+**
+**      DESCRIPTION: The function initialize the Constant Ploams in ASIC
+**	                         by values are in Database
+**
+**  PARAMETERS:  MV_BOOL initTime
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcConstPloamFromDbInit(MV_BOOL initTime)
+{
+	MV_U32 onuId;
+	MV_U8 serialNumber[8];
+	MV_STATUS rcode;
+
+	if (initTime != MV_FALSE) { /* In init time we wouldn't want to use semaphore */
+		onuId = onuGponDbOnuIdGet();
+		onuGponDbSerialNumGet(serialNumber);
+
+		rcode  = mvOnuGponMacTxConstIdleMsgSet(onuId);
+		rcode |= mvOnuGponMacTxConstSerialNumberMsgSet(onuId, serialNumber, 0);
+
+		return rcode;
+	}
+
+	onuId = onuGponDbOnuIdGet();
+	onuGponDbSerialNumGet(serialNumber);
+
+	rcode  = mvOnuGponMacTxConstIdleMsgSet(onuId);
+	rcode |= mvOnuGponMacTxConstSerialNumberMsgSet(onuId, serialNumber, 0);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcOnuIdUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function update the ONU ID in the ASIC register and
+**               const ram
+**
+**  PARAMETERS:  MV_U32 onuId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcOnuIdUpdate(MV_U32 onuId, MV_BOOL valid)
+{
+	MV_STATUS rcode;
+	MV_U32 snMsg[ONU_GPON_MSG_LEN];
+	MV_U32 idleMsg[ONU_GPON_MSG_LEN];
+	MV_U8 serialNumber[8];
+
+	/* update onu Id register */
+	rcode = mvOnuGponMacOnuIdSet(onuId, valid);
+	if (rcode != MV_OK)
+		return rcode;
+
+	/* Get Serial Number Message from Database */
+	onuGponDbSnMsgGet(snMsg);
+
+	/* Update the Serial Number in S/N Message */
+	snMsg[0] = (ONU_GPON_US_MSG_SN_ONU << 16) | (onuId << 24) |
+		   (snMsg[0] & 0x0000FFFF);
+
+	/* Put back the updated Serial Number Message to Database */
+	onuGponDbSnMsgSet(snMsg);
+
+	/* Get Idle Message from Database */
+	onuGponDbIdleMsgGet(idleMsg);
+
+	/* Update the Serial Number in S/N Message */
+	idleMsg[0] = (ONU_GPON_US_MSG_NO_MESSAGE << 16) | (onuId << 24) |
+		     (idleMsg[0] & 0x0000FFFF);
+	/* Put back the updated Serial Number Message to Database */
+	onuGponDbIdleMsgSet(idleMsg);
+
+	onuGponDbSerialNumGet(serialNumber);
+
+	/* Write to ASIC the new Constant Messages */
+	rcode  = mvOnuGponMacTxConstIdleMsgSet(onuId);
+	rcode |= mvOnuGponMacTxConstSerialNumberMsgSet(onuId, serialNumber, 0);
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcAlarmNotify
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function call Alarm Notification routine (if exist)
+**
+**      PARAMETERS:  MV_U32 alarm
+**	             MV_U32 status
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponSrvcAlarmNotify(MV_U32 alarm, MV_U32 status)
+{
+	ALARMNOTIFYFUNC alarmFunc;
+
+	alarmFunc = onuGponDbAlarmNotifyGet();
+	if (alarmFunc != NULL)
+		alarmFunc(alarm, status);
+
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcStatusNotify
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function call Status Notification routine (if exist)
+**
+**  PARAMETERS:  MV_U32 status
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponSrvcStatusNotify(MV_U32 status)
+{
+	/* Send signal to management layer ONLY for US sync */
+	if (status == GPON_ONU_STATUS_RANGED)
+		onuPonEventOmciSyncInfo();
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcOmccNotify
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function call OMCC Port Notification routine (if exist)
+**
+**  PARAMETERS:  MV_U32 omccPortId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponSrvcOmccNotify(MV_U32 omccPortId)
+{
+	OMCCNOTIFYFUNC omccFunc;
+
+	omccFunc = onuGponDbOmccNotifyGet();
+	if (omccFunc != NULL)
+		omccFunc(omccPortId);
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcDisableMsgNotify
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function call onu dusable Notification routine (if exist)
+**
+**  PARAMETERS:  MV_BOOL disable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponSrvcDisableMsgNotify(MV_BOOL disable, MV_BOOL paramSave)
+{
+	DISABLENOTIFYFUNC disableFunc;
+
+	if (paramSave == MV_TRUE) {
+		if (disable == MV_TRUE)
+			ponOnuCfgParamSave(E_PON_PARAM_DISABLE_GPON_SN, "1", 1);
+		else
+			ponOnuCfgParamSave(E_PON_PARAM_DISABLE_GPON_SN, "0", 1);
+	}
+
+	disableFunc = onuGponDbDisableNotifyGet();
+	if (disableFunc != NULL)
+		disableFunc(disable);
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcAesKeyGenerate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function generates AES key
+**
+**  PARAMETERS:  MV_U8 *key
+**
+**  OUTPUTS:     8 bytes buffer
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponSrvcAesKeyGenerate(MV_U8 *key)
+{
+	MV_U32 aesKey[4] = { 0x00000000, 0x00000000, 0x00000000, 0x00000000 };
+	MV_U32 i;
+	MV_U32 j;
+	static MV_U32 counter = 0;
+	MV_U32 microSec;
+	MV_U32 microSec_1;
+	MV_U32 advancer;
+	MV_U32 bw;
+	MV_U32 sfc;
+
+	mvOnuGponMacMicroSecCounterGet(&microSec);
+	mvOnuGponMacTxPloamDataFreeGet(&advancer);
+	mvOnuGponMacMicroSecCounterGet(&microSec_1);
+	microSec_1 += 0x11111111;
+	bw = 0xA5A5A5A5;
+	mvOnuGponMacRxSuperFrameCounterGet(&sfc);
+	bw ^= sfc;
+
+	for (i = 0 ; i < 8 ; i++) {
+		aesKey[0] |= (MV_U32)((microSec >> i)   & 0x1) << (4 * i);
+		aesKey[0] |= (MV_U32)((bw >> i)         & 0x1) << (4 * i + 1);
+		aesKey[0] |= (MV_U32)((counter >> i)    & 0x1) << (4 * i + 2);
+		aesKey[0] |= (MV_U32)((microSec_1 >> i) & 0x1) << (4 * i + 3);
+	}
+	for (i = 8 ; i < 16 ; i++) {
+		aesKey[1] |= (MV_U32)((microSec >> i)   & 0x1) << (4 * (i - 8));
+		aesKey[1] |= (MV_U32)((bw >> i)         & 0x1) << (4 * (i - 8) + 1);
+		aesKey[1] |= (MV_U32)((counter >> i)    & 0x1) << (4 * (i - 8) + 2);
+		aesKey[1] |= (MV_U32)((microSec_1 >> i) & 0x1) << (4 * (i - 8) + 3);
+	}
+	for (i = 16 ; i < 24 ; i++) {
+		aesKey[2] |= (MV_U32)((microSec >> i)   & 0x1) << (4 * (i - 16));
+		aesKey[2] |= (MV_U32)((bw >> i)         & 0x1) << (4 * (i - 16) + 1);
+		aesKey[2] |= (MV_U32)((counter >> i)    & 0x1) << (4 * (i - 16) + 2);
+		aesKey[2] |= (MV_U32)((microSec_1 >> i) & 0x1) << (4 * (i - 16) + 3);
+	}
+	for (i = 24 ; i < 32 ; i++) {
+		aesKey[3] |= (MV_U32)((microSec >> i)   & 0x1) << (4 * (i - 24));
+		aesKey[3] |= (MV_U32)((bw >> i)         & 0x1) << (4 * (i - 24) + 1);
+		aesKey[3] |= (MV_U32)((counter >> i)    & 0x1) << (4 * (i - 24) + 2);
+		aesKey[3] |= (MV_U32)((microSec_1 >> i) & 0x1) << (4 * (i - 24) + 3);
+	}
+
+	counter += advancer;
+
+	for (i = 0 ; i < 4 ; i++)
+		for (j = 0 ; j < 4 ; j++)
+			key[(j * 4) + i] = (MV_U8)((aesKey[j] >> (8 * (3 - i))) & 0xFF);
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcGenDbrTable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu DBR table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcGenDbrTable(void)
+{
+	MV_U32 index;
+
+	/*  DBR table for all block size supported - NOT sorted
+	   ===================================================
+
+	   Config       1/512	1/256	1/128	1/64	1/32	1/16	SUM	    1/SUM	    (1/SUM) * 4	 Block Size
+	   0	    0.0000	0.0000	0.0000	0.0000	0.0000	0.0000	0.0000	0.0000      0.0000       0
+	   000001	0.0000	0.0000	0.0000	0.0000	0.0000	0.0625	0.0625	16.0000         64.0000      64
+	   000010	0.0000	0.0000	0.0000	0.0000	0.0313	0.0000	0.0313	32.0000         128.0000     128
+	   000011	0.0000	0.0000	0.0000	0.0000	0.0313	0.0625	0.0938	10.6667         42.6667	     43
+	   000100	0.0000	0.0000	0.0000	0.0156	0.0000	0.0000	0.0156	64.0000         256.0000     256
+	   000101	0.0000	0.0000	0.0000	0.0156	0.0000	0.0625	0.0781	12.8000         51.2000      51
+	   000110	0.0000	0.0000	0.0000	0.0156	0.0313	0.0000	0.0469	21.3333         85.3333      85
+	   000111	0.0000	0.0000	0.0000	0.0156	0.0313	0.0625	0.1094	9.1429      36.5714      37
+	   001000	0.0000	0.0000	0.0078	0.0000	0.0000	0.0000	0.0078	128.0000	512.0000     512
+	   001001	0.0000	0.0000	0.0078	0.0000	0.0000	0.0625	0.0703	14.2222         56.8889	     57
+	   001010	0.0000	0.0000	0.0078	0.0000	0.0313	0.0000	0.0391	25.6000         102.4000     102
+	   001011	0.0000	0.0000	0.0078	0.0000	0.0313	0.0625	0.1016	9.8462      39.3846	     39
+	   001100	0.0000	0.0000	0.0078	0.0156	0.0000	0.0000	0.0234	42.6667         170.6667     171
+	   001101	0.0000	0.0000	0.0078	0.0156	0.0000	0.0625	0.0859	11.6364         46.5455      47
+	   001110	0.0000	0.0000	0.0078	0.0156	0.0313	0.0000	0.0547	18.2857         73.1429      73
+	   001111	0.0000	0.0000	0.0078	0.0156	0.0313	0.0625	0.1172	8.5333      34.1333      34
+	   010000	0.0000	0.0039	0.0000	0.0000	0.0000	0.0000	0.0039	256.0000	1024.0000    1024
+	   010001	0.0000	0.0039	0.0000	0.0000	0.0000	0.0625	0.0664	15.0588         60.2353	     60
+	   010010	0.0000	0.0039	0.0000	0.0000	0.0313	0.0000	0.0352	28.4444         113.7778     114
+	   010011	0.0000	0.0039	0.0000	0.0000	0.0313	0.0625	0.0977	10.2400         40.9600	     41
+	   010100	0.0000	0.0039	0.0000	0.0156	0.0000	0.0000	0.0195	51.2000         204.8000     205
+	   010101	0.0000	0.0039	0.0000	0.0156	0.0000	0.0625	0.0820	12.1905         48.7619      49
+	   010110	0.0000	0.0039	0.0000	0.0156	0.0313	0.0000	0.0508	19.6923         78.7692      79
+	   010111	0.0000	0.0039	0.0000	0.0156	0.0313	0.0625	0.1133	8.8276      35.3103      35
+	   011000	0.0000	0.0039	0.0078	0.0000	0.0000	0.0000	0.0117	85.3333         341.3333     341
+	   011001	0.0000	0.0039	0.0078	0.0000	0.0000	0.0625	0.0742	13.4737         53.8947      54
+	   011010	0.0000	0.0039	0.0078	0.0000	0.0313	0.0000	0.0430	23.2727         93.0909      93
+	   011011	0.0000	0.0039	0.0078	0.0000	0.0313	0.0625	0.1055	9.4815      37.9259      38
+	   011100	0.0000	0.0039	0.0078	0.0156	0.0000	0.0000	0.0273	36.5714         146.2857     146
+	   011101	0.0000	0.0039	0.0078	0.0156	0.0000	0.0625	0.0898	11.1304         44.5217      45
+	   011110	0.0000	0.0039	0.0078	0.0156	0.0313	0.0000	0.0586	17.0667         68.2667      68
+	   011111	0.0000	0.0039	0.0078	0.0156	0.0313	0.0625	0.1211	8.2581      33.0323      33
+	   100000	0.0020	0.0000	0.0000	0.0000	0.0000	0.0000	0.0020	512.0000	2048.0000    2048
+	   100001	0.0020	0.0000	0.0000	0.0000	0.0000	0.0625	0.0645	15.5152         62.0606	     62
+	   100010	0.0020	0.0000	0.0000	0.0000	0.0313	0.0000	0.0332	30.1176         120.4706     120
+	   100011	0.0020	0.0000	0.0000	0.0000	0.0313	0.0625	0.0957	10.4490         41.7959      42
+	   100100	0.0020	0.0000	0.0000	0.0156	0.0000	0.0000	0.0176	56.8889         227.5556     228
+	   100101	0.0020	0.0000	0.0000	0.0156	0.0000	0.0625	0.0801	12.4878         49.9512      50
+	   100110	0.0020	0.0000	0.0000	0.0156	0.0313	0.0000	0.0488	20.4800         81.9200      82
+	   100111	0.0020	0.0000	0.0000	0.0156	0.0313	0.0625	0.1113	8.9825      35.9298      36
+	   101000	0.0020	0.0000	0.0078	0.0000	0.0000	0.0000	0.0098	102.4000	409.6000     410
+	   101001	0.0020	0.0000	0.0078	0.0000	0.0000	0.0625	0.0723	13.8378         55.3514      55
+	   101010	0.0020	0.0000	0.0078	0.0000	0.0313	0.0000	0.0410	24.3810         97.5238      98
+	   101011	0.0020	0.0000	0.0078	0.0000	0.0313	0.0625	0.1035	9.6604      38.6415      39
+	   101100	0.0020	0.0000	0.0078	0.0156	0.0000	0.0000	0.0254	39.3846         157.5385     158
+	   101101	0.0020	0.0000	0.0078	0.0156	0.0000	0.0625	0.0879	11.3778         45.5111      46
+	   101110	0.0020	0.0000	0.0078	0.0156	0.0313	0.0000	0.0566	17.6552         70.6207      71
+	   101111	0.0020	0.0000	0.0078	0.0156	0.0313	0.0625	0.1191	8.3934      33.5738      34
+	   110000	0.0020	0.0039	0.0000	0.0000	0.0000	0.0000	0.0059	170.6667	682.6667     683
+	   110001	0.0020	0.0039	0.0000	0.0000	0.0000	0.0625	0.0684	14.6286         58.5143      59
+	   110010	0.0020	0.0039	0.0000	0.0000	0.0313	0.0000	0.0371	26.9474         107.7895     108
+	   110011	0.0020	0.0039	0.0000	0.0000	0.0313	0.0625	0.0996	10.0392         40.1569      40
+	   110100	0.0020	0.0039	0.0000	0.0156	0.0000	0.0000	0.0215	46.5455         186.1818     186
+	   110101	0.0020	0.0039	0.0000	0.0156	0.0000	0.0625	0.0840	11.9070         47.6279      48
+	   110110	0.0020	0.0039	0.0000	0.0156	0.0313	0.0000	0.0527	18.9630         75.8519      76
+	   110111	0.0020	0.0039	0.0000	0.0156	0.0313	0.0625	0.1152	8.6780      34.7119      35
+	   111000	0.0020	0.0039	0.0078	0.0000	0.0000	0.0000	0.0137	73.1429         292.5714     293
+	   111001	0.0020	0.0039	0.0078	0.0000	0.0000	0.0625	0.0762	13.1282         52.5128      53
+	   111010	0.0020	0.0039	0.0078	0.0000	0.0313	0.0000	0.0449	22.2609         89.0435      89
+	   111011	0.0020	0.0039	0.0078	0.0000	0.0313	0.0625	0.1074	9.3091      37.2364      37
+	   111100	0.0020	0.0039	0.0078	0.0156	0.0000	0.0000	0.0293	34.1333         136.5333     137
+	   111101	0.0020	0.0039	0.0078	0.0156	0.0000	0.0625	0.0918	10.8936         43.5745      44
+	   111110	0.0020	0.0039	0.0078	0.0156	0.0313	0.0000	0.0605	16.5161         66.0645      66
+	   111111	0.0020	0.0039	0.0078	0.0156	0.0313	0.0625	0.1230	8.1270      32.5079      33
+
+	   DBR table for all block size supported - Sorted by Block Size
+	   =============================================================
+
+	   Config	1/512	1/256	1/128	1/64	1/32	1/16	SUM	    1/SUM	  (1/SUM) * 4	Block Size
+	   0	    0.0000	0.0000	0.0000	0.0000	0.0000	0.0000	0.0000	0.0000    0.0000        0
+	   111111	0.0020	0.0039	0.0078	0.0156	0.0313	0.0625	0.1230	8.1270    32.5079       33
+	   011111	0.0000	0.0039	0.0078	0.0156	0.0313	0.0625	0.1211	8.2581    33.0323       33
+	   101111	0.0020	0.0000	0.0078	0.0156	0.0313	0.0625	0.1191	8.3934    33.5738       34
+	   001111	0.0000	0.0000	0.0078	0.0156	0.0313	0.0625	0.1172	8.5333    34.1333       34
+	   110111	0.0020	0.0039	0.0000	0.0156	0.0313	0.0625	0.1152	8.6780    34.7119       35
+	   010111	0.0000	0.0039	0.0000	0.0156	0.0313	0.0625	0.1133	8.8276    35.3103       35
+	   100111	0.0020	0.0000	0.0000	0.0156	0.0313	0.0625	0.1113	8.9825    35.9298       36
+	   000111	0.0000	0.0000	0.0000	0.0156	0.0313	0.0625	0.1094	9.1429    36.5714       37
+	   111011	0.0020	0.0039	0.0078	0.0000	0.0313	0.0625	0.1074	9.3091    37.2364       37
+	   011011	0.0000	0.0039	0.0078	0.0000	0.0313	0.0625	0.1055	9.4815    37.9259       38
+	   101011	0.0020	0.0000	0.0078	0.0000	0.0313	0.0625	0.1035	9.6604    38.6415       39
+	   001011	0.0000	0.0000	0.0078	0.0000	0.0313	0.0625	0.1016	9.8462    39.3846       39
+	   110011	0.0020	0.0039	0.0000	0.0000	0.0313	0.0625	0.0996	10.0392         40.1569         40
+	   010011	0.0000	0.0039	0.0000	0.0000	0.0313	0.0625	0.0977	10.2400         40.9600         41
+	   100011	0.0020	0.0000	0.0000	0.0000	0.0313	0.0625	0.0957	10.4490         41.7959         42
+	   000011	0.0000	0.0000	0.0000	0.0000	0.0313	0.0625	0.0938	10.6667         42.6667         43
+	   111101	0.0020	0.0039	0.0078	0.0156	0.0000	0.0625	0.0918	10.8936         43.5745         44
+	   011101	0.0000	0.0039	0.0078	0.0156	0.0000	0.0625	0.0898	11.1304         44.5217         45
+	   101101	0.0020	0.0000	0.0078	0.0156	0.0000	0.0625	0.0879	11.3778         45.5111         46
+	   001101	0.0000	0.0000	0.0078	0.0156	0.0000	0.0625	0.0859	11.6364         46.5455         47
+	   110101	0.0020	0.0039	0.0000	0.0156	0.0000	0.0625	0.0840	11.9070         47.6279         48
+	   010101	0.0000	0.0039	0.0000	0.0156	0.0000	0.0625	0.0820	12.1905         48.7619         49
+	   100101	0.0020	0.0000	0.0000	0.0156	0.0000	0.0625	0.0801	12.4878         49.9512         50
+	   000101	0.0000	0.0000	0.0000	0.0156	0.0000	0.0625	0.0781	12.8000         51.2000         51
+	   111001	0.0020	0.0039	0.0078	0.0000	0.0000	0.0625	0.0762	13.1282         52.5128         53
+	   011001	0.0000	0.0039	0.0078	0.0000	0.0000	0.0625	0.0742	13.4737         53.8947         54
+	   101001	0.0020	0.0000	0.0078	0.0000	0.0000	0.0625	0.0723	13.8378         55.3514         55
+	   001001	0.0000	0.0000	0.0078	0.0000	0.0000	0.0625	0.0703	14.2222         56.8889         57
+	   110001	0.0020	0.0039	0.0000	0.0000	0.0000	0.0625	0.0684	14.6286         58.5143         59
+	   010001	0.0000	0.0039	0.0000	0.0000	0.0000	0.0625	0.0664	15.0588         60.2353         60
+	   100001	0.0020	0.0000	0.0000	0.0000	0.0000	0.0625	0.0645	15.5152         62.0606         62
+	   000001	0.0000	0.0000	0.0000	0.0000	0.0000	0.0625	0.0625	16.0000         64.0000         64
+	   111110	0.0020	0.0039	0.0078	0.0156	0.0313	0.0000	0.0605	16.5161         66.0645         66
+	   011110	0.0000	0.0039	0.0078	0.0156	0.0313	0.0000	0.0586	17.0667         68.2667         68
+	   101110	0.0020	0.0000	0.0078	0.0156	0.0313	0.0000	0.0566	17.6552         70.6207         71
+	   001110	0.0000	0.0000	0.0078	0.0156	0.0313	0.0000	0.0547	18.2857         73.1429         73
+	   110110	0.0020	0.0039	0.0000	0.0156	0.0313	0.0000	0.0527	18.9630         75.8519         76
+	   010110	0.0000	0.0039	0.0000	0.0156	0.0313	0.0000	0.0508	19.6923         78.7692         79
+	   100110	0.0020	0.0000	0.0000	0.0156	0.0313	0.0000	0.0488	20.4800         81.9200         82
+	   000110	0.0000	0.0000	0.0000	0.0156	0.0313	0.0000	0.0469	21.3333         85.3333         85
+	   111010	0.0020	0.0039	0.0078	0.0000	0.0313	0.0000	0.0449	22.2609         89.0435         89
+	   011010	0.0000	0.0039	0.0078	0.0000	0.0313	0.0000	0.0430	23.2727         93.0909         93
+	   101010	0.0020	0.0000	0.0078	0.0000	0.0313	0.0000	0.0410	24.3810         97.5238         98
+	   001010	0.0000	0.0000	0.0078	0.0000	0.0313	0.0000	0.0391	25.6000         102.4000    102
+	   110010	0.0020	0.0039	0.0000	0.0000	0.0313	0.0000	0.0371	26.9474         107.7895    108
+	   010010	0.0000	0.0039	0.0000	0.0000	0.0313	0.0000	0.0352	28.4444         113.7778    114
+	   100010	0.0020	0.0000	0.0000	0.0000	0.0313	0.0000	0.0332	30.1176         120.4706    120
+	   000010	0.0000	0.0000	0.0000	0.0000	0.0313	0.0000	0.0313	32.0000         128.0000    128
+	   111100	0.0020	0.0039	0.0078	0.0156	0.0000	0.0000	0.0293	34.1333         136.5333    137
+	   011100	0.0000	0.0039	0.0078	0.0156	0.0000	0.0000	0.0273	36.5714         146.2857    146
+	   101100	0.0020	0.0000	0.0078	0.0156	0.0000	0.0000	0.0254	39.3846         157.5385    158
+	   001100	0.0000	0.0000	0.0078	0.0156	0.0000	0.0000	0.0234	42.6667         170.6667    171
+	   110100	0.0020	0.0039	0.0000	0.0156	0.0000	0.0000	0.0215	46.5455         186.1818    186
+	   010100	0.0000	0.0039	0.0000	0.0156	0.0000	0.0000	0.0195	51.2000         204.8000    205
+	   100100	0.0020	0.0000	0.0000	0.0156	0.0000	0.0000	0.0176	56.8889         227.5556    228
+	   000100	0.0000	0.0000	0.0000	0.0156	0.0000	0.0000	0.0156	64.0000         256.0000    256
+	   111000	0.0020	0.0039	0.0078	0.0000	0.0000	0.0000	0.0137	73.1429         292.5714    293
+	   011000	0.0000	0.0039	0.0078	0.0000	0.0000	0.0000	0.0117	85.3333         341.3333    341
+	   101000	0.0020	0.0000	0.0078	0.0000	0.0000	0.0000	0.0098	102.4000	409.6000    410
+	   001000	0.0000	0.0000	0.0078	0.0000	0.0000	0.0000	0.0078	128.0000	512.0000    512
+	   110000	0.0020	0.0039	0.0000	0.0000	0.0000	0.0000	0.0059	170.6667	682.6667    683
+	   010000	0.0000	0.0039	0.0000	0.0000	0.0000	0.0000	0.0039	256.0000	1024.0000       1024
+	   100000	0.0020	0.0000	0.0000	0.0000	0.0000	0.0000	0.0020	512.0000	2048.0000       2048
+	 */
+
+	for (index = 0; index < 34; index++) {
+		gponDbrArray[index].bitMask   = 0x3F; /* 0b111111; */
+		gponDbrArray[index].blockSize = 33;
+	}
+	gponDbrArray[34].bitMask   = 0x2F;     /* 0b101111; */
+	gponDbrArray[34].blockSize = 34;
+	gponDbrArray[35].bitMask   = 0x37;     /* 0b110111; */
+	gponDbrArray[35].blockSize = 35;
+	gponDbrArray[36].bitMask   = 0x27;     /* 0b100111; */
+	gponDbrArray[36].blockSize = 36;
+	gponDbrArray[37].bitMask   = 0x07;     /* 0b000111; */
+	gponDbrArray[37].blockSize = 37;
+	gponDbrArray[38].bitMask   = 0x1B;     /* 0b011011; */
+	gponDbrArray[38].blockSize = 38;
+	gponDbrArray[39].bitMask   = 0x2B;     /* 0b101011; */
+	gponDbrArray[39].blockSize = 39;
+	gponDbrArray[40].bitMask   = 0x33;     /* 0b110011; */
+	gponDbrArray[40].blockSize = 40;
+	gponDbrArray[41].bitMask   = 0x13;     /* 0b010011; */
+	gponDbrArray[41].blockSize = 41;
+	gponDbrArray[42].bitMask   = 0x23;     /* 0b100011; */
+	gponDbrArray[42].blockSize = 42;
+	gponDbrArray[43].bitMask   = 0x03;     /* 0b000011; */
+	gponDbrArray[43].blockSize = 43;
+	gponDbrArray[44].bitMask   = 0x3D;     /* 0b111101; */
+	gponDbrArray[44].blockSize = 44;
+	gponDbrArray[45].bitMask   = 0x1D;     /* 0b011101; */
+	gponDbrArray[45].blockSize = 45;
+	gponDbrArray[46].bitMask   = 0x2D;     /* 0b101101; */
+	gponDbrArray[46].blockSize = 46;
+	gponDbrArray[47].bitMask   = 0x0D;     /* 0b001101; */
+	gponDbrArray[47].blockSize = 47;
+	gponDbrArray[48].bitMask   = 0x35;     /* 0b110101; */
+	gponDbrArray[48].blockSize = 48;
+	gponDbrArray[49].bitMask   = 0x15;     /* 0b010101; */
+	gponDbrArray[49].blockSize = 49;
+	gponDbrArray[50].bitMask   = 0x25;     /* 0b100101; */
+	gponDbrArray[50].blockSize = 50;
+	gponDbrArray[51].bitMask   = 0x05;     /* 0b000101; */
+	gponDbrArray[51].blockSize = 51;
+	gponDbrArray[52].bitMask   = 0x05;     /* 0b000101; */
+	gponDbrArray[52].blockSize = 51;
+	gponDbrArray[53].bitMask   = 0x39;     /* 0b111001; */
+	gponDbrArray[53].blockSize = 53;
+	gponDbrArray[54].bitMask   = 0x19;     /* 0b011001; */
+	gponDbrArray[54].blockSize = 54;
+	gponDbrArray[55].bitMask   = 0x29;     /* 0b101001; */
+	gponDbrArray[55].blockSize = 55;
+	gponDbrArray[56].bitMask   = 0x29;     /* 0b101001; */
+	gponDbrArray[56].blockSize = 55;
+	gponDbrArray[57].bitMask   = 0x09;     /* 0b001001; */
+	gponDbrArray[57].blockSize = 57;
+	gponDbrArray[58].bitMask   = 0x09;     /* 0b001001; */
+	gponDbrArray[58].blockSize = 57;
+	gponDbrArray[59].bitMask   = 0x31;     /* 0b110001; */
+	gponDbrArray[59].blockSize = 59;
+	gponDbrArray[60].bitMask   = 0x11;     /* 0b010001; */
+	gponDbrArray[60].blockSize = 60;
+	gponDbrArray[61].bitMask   = 0x11;     /* 0b010001; */
+	gponDbrArray[61].blockSize = 60;
+	gponDbrArray[62].bitMask   = 0x21;     /* 0b100001; */
+	gponDbrArray[62].blockSize = 62;
+	gponDbrArray[63].bitMask   = 0x21;     /* 0b100001; */
+	gponDbrArray[63].blockSize = 62;
+	gponDbrArray[64].bitMask   = 0x01;     /* 0b000001; */
+	gponDbrArray[64].blockSize = 64;
+	gponDbrArray[65].bitMask   = 0x01;     /* 0b000001; */
+	gponDbrArray[65].blockSize = 64;
+	gponDbrArray[66].bitMask   = 0x3E;     /* 0b111110; */
+	gponDbrArray[66].blockSize = 66;
+	gponDbrArray[67].bitMask   = 0x3E;     /* 0b111110; */
+	gponDbrArray[67].blockSize = 66;
+	gponDbrArray[68].bitMask   = 0x1E;     /* 0b011110; */
+	gponDbrArray[68].blockSize = 68;
+	gponDbrArray[69].bitMask   = 0x1E;     /* 0b011110; */
+	gponDbrArray[69].blockSize = 68;
+	gponDbrArray[70].bitMask   = 0x1E;     /* 0b011110; */
+	gponDbrArray[70].blockSize = 68;
+	gponDbrArray[71].bitMask   = 0x2E;     /* 0b101110; */
+	gponDbrArray[71].blockSize = 71;
+	gponDbrArray[72].bitMask   = 0x2E;     /* 0b101110; */
+	gponDbrArray[72].blockSize = 71;
+
+	for (index = 73; index < 76; index++) {
+		gponDbrArray[index].bitMask   = 0x0E; /* 0b001110; */
+		gponDbrArray[index].blockSize = 73;
+	}
+	for (index = 76; index < 79; index++) {
+		gponDbrArray[index].bitMask   = 0x36; /* 0b110110; */
+		gponDbrArray[index].blockSize = 76;
+	}
+	for (index = 79; index < 82; index++) {
+		gponDbrArray[index].bitMask   = 0x16; /* 0b010110; */
+		gponDbrArray[index].blockSize = 79;
+	}
+	for (index = 82; index < 85; index++) {
+		gponDbrArray[index].bitMask   = 0x26; /* 0b100110; */
+		gponDbrArray[index].blockSize = 82;
+	}
+	for (index = 85; index < 89; index++) {
+		gponDbrArray[index].bitMask   = 0x06; /* 0b000110; */
+		gponDbrArray[index].blockSize = 85;
+	}
+	for (index = 89; index < 93; index++) {
+		gponDbrArray[index].bitMask   = 0x3A; /* 0b111010; */
+		gponDbrArray[index].blockSize = 89;
+	}
+	for (index = 93; index < 98; index++) {
+		gponDbrArray[index].bitMask   = 0x1A; /* 0b011010; */
+		gponDbrArray[index].blockSize = 93;
+	}
+	for (index = 98; index < 102; index++) {
+		gponDbrArray[index].bitMask   = 0x2A; /* 0b101010; */
+		gponDbrArray[index].blockSize = 98;
+	}
+	for (index = 102; index < 108; index++) {
+		gponDbrArray[index].bitMask   = 0x0A; /* 0b001010; */
+		gponDbrArray[index].blockSize = 102;
+	}
+	for (index = 108; index < 114; index++) {
+		gponDbrArray[index].bitMask   = 0x32; /* 0b110010; */
+		gponDbrArray[index].blockSize = 108;
+	}
+	for (index = 114; index < 120; index++) {
+		gponDbrArray[index].bitMask   = 0x12; /* 0b010010; */
+		gponDbrArray[index].blockSize = 114;
+	}
+	for (index = 120; index < 128; index++) {
+		gponDbrArray[index].bitMask   = 0x22; /* 0b100010; */
+		gponDbrArray[index].blockSize = 120;
+	}
+	for (index = 128; index < 137; index++) {
+		gponDbrArray[index].bitMask   = 0x02; /* 0b000010; */
+		gponDbrArray[index].blockSize = 128;
+	}
+	for (index = 137; index < 146; index++) {
+		gponDbrArray[index].bitMask   = 0x3C; /* 0b111100; */
+		gponDbrArray[index].blockSize = 137;
+	}
+	for (index = 137; index < 146; index++) {
+		gponDbrArray[index].bitMask   = 0x3C; /* 0b111100; */
+		gponDbrArray[index].blockSize = 137;
+	}
+	for (index = 146; index < 158; index++) {
+		gponDbrArray[index].bitMask   = 0x1C; /* 0b011100; */
+		gponDbrArray[index].blockSize = 146;
+	}
+	for (index = 158; index < 171; index++) {
+		gponDbrArray[index].bitMask   = 0x2C; /* 0b101100; */
+		gponDbrArray[index].blockSize = 158;
+	}
+	for (index = 171; index < 186; index++) {
+		gponDbrArray[index].bitMask   = 0x0C; /* 0b001100; */
+		gponDbrArray[index].blockSize = 171;
+	}
+	for (index = 186; index < 205; index++) {
+		gponDbrArray[index].bitMask   = 0x34; /* 0b110100; */
+		gponDbrArray[index].blockSize = 186;
+	}
+	for (index = 205; index < 228; index++) {
+		gponDbrArray[index].bitMask   = 0x14; /* 0b010100; */
+		gponDbrArray[index].blockSize = 205;
+	}
+	for (index = 228; index < 256; index++) {
+		gponDbrArray[index].bitMask   = 0x24; /* 0b100100; */
+		gponDbrArray[index].blockSize = 228;
+	}
+	for (index = 256; index < 293; index++) {
+		gponDbrArray[index].bitMask   = 0x04; /* 0b000100; */
+		gponDbrArray[index].blockSize = 256;
+	}
+	for (index = 293; index < 341; index++) {
+		gponDbrArray[index].bitMask   = 0x38; /* 0b111000; */
+		gponDbrArray[index].blockSize = 293;
+	}
+	for (index = 341; index < 410; index++) {
+		gponDbrArray[index].bitMask   = 0x18; /* 0b011000; */
+		gponDbrArray[index].blockSize = 341;
+	}
+	for (index = 410; index < 512; index++) {
+		gponDbrArray[index].bitMask   = 0x28; /* 0b101000; */
+		gponDbrArray[index].blockSize = 410;
+	}
+	for (index = 512; index < 683; index++) {
+		gponDbrArray[index].bitMask   = 0x08; /* 0b001000; */
+		gponDbrArray[index].blockSize = 512;
+	}
+	for (index = 683; index < 1024; index++) {
+		gponDbrArray[index].bitMask   = 0x30; /* 0b110000; */
+		gponDbrArray[index].blockSize = 683;
+	}
+	for (index = 1024; index < 2048; index++) {
+		gponDbrArray[index].bitMask   = 0x10; /* 0b010000; */
+		gponDbrArray[index].blockSize = 1024;
+	}
+
+	gponDbrBlock2048AndMore = 0x20; /* 0b100000; */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcDbrBlockSizeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure DBR block size
+**
+**  PARAMETERS:  MV_U32 blockSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcDbrBlockSizeSet(MV_U32 blockSize, MV_U32 *actualBlockSize)
+{
+	MV_STATUS rcode;
+	MV_U32 macBlockSizeBitMask;
+	MV_U32 macBlockSizeValue;
+
+	if (blockSize >= 2048) {
+		macBlockSizeBitMask = gponDbrBlock2048AndMore;
+		macBlockSizeValue   = 2048;
+	} else {
+		macBlockSizeBitMask = gponDbrArray[blockSize].bitMask;
+		macBlockSizeValue   = gponDbrArray[blockSize].blockSize;
+	}
+
+	rcode = mvOnuGponMacTxDbrBlockSizeSet(macBlockSizeBitMask);
+	if (rcode != MV_OK)
+		return rcode;
+
+	*actualBlockSize = macBlockSizeValue;
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuGponSrvcRangingRandomInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu gpon ranging random number
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponSrvcRangingRandomInit(void)
+{
+	MV_U32 thermalRegAddr  = 0x000184D8;
+	MV_U32 thermalRegValue = 0;
+
+	MV_U32 temp            = 0;
+	int tmp_size;
+
+	/* 0 MAC          */
+	/* 1 Thermal      */
+	/* 2 Micro Timer  */
+	/* 3 Randon Num 1 */
+	/* 4 Randon Num 2 */
+
+	/* Generate internal delay random part */
+	randomInternalDelayKey[0]  =  (mvMacAddr[2][2]);
+	randomInternalDelayKey[0] |= ((mvMacAddr[2][3]) << 8);
+	randomInternalDelayKey[0] |= ((mvMacAddr[2][4]) << 16);
+	randomInternalDelayKey[0] |= ((mvMacAddr[2][5]) << 24);
+
+	mvOsDelay((mvMacAddr[2][2]) + (mvMacAddr[2][3]) + (mvMacAddr[2][4]) + (mvMacAddr[2][5]));
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	randomInternalDelayKey[1] = thermalRegValue;
+
+	mvOsDelay((thermalRegValue & 0xFF) + (mvMacAddr[2][4]) + (mvMacAddr[2][5]));
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[2] = (temp & 0xFFFF);
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	randomInternalDelayKey[1] |= thermalRegValue << 9;
+
+	mvOsDelay((thermalRegValue & 0xFF) + (mvMacAddr[2][3]));
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1FF);
+	randomInternalDelayKey[1] |= thermalRegValue << 18;
+
+	mvOsDelay((thermalRegValue & 0xFF) + (mvMacAddr[2][2]));
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[3] = (temp & 0xFFFF);
+
+	thermalRegValue = ((MV_REG_READ(thermalRegAddr) >> 10)  & 0x1F);
+	randomInternalDelayKey[1] |= thermalRegValue << 27;
+
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[2] |= ((temp & 0xFFFF) << 16);
+
+	mvOsDelay(randomInternalDelayKey[2] & 0xFF);
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[4] = (temp & 0xFFFF);
+
+	mvOsDelay((randomInternalDelayKey[1] & 0xFF000) >> 12);
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[4] |= (((temp & 0xFFFF00) >> 8) << 16);
+
+	mvOsDelay((randomInternalDelayKey[1] & 0xFF00000) >> 20);
+	mvOnuGponMacMicroSecCounterGet(&temp);
+	randomInternalDelayKey[3] |= (((temp & 0xFFFF000) >> 12) << 16);
+
+	for (tmp_size = 0; tmp_size < 5; tmp_size++)
+		add_input_randomness(randomType, randomCode, randomInternalDelayKey[tmp_size]);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**                            SYNC LOG SECTION
+**
+********************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponSyncLogEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable log mechanism to start record events
+**
+**  PARAMETERS:  MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuGponSyncLogEnable(MV_U32 enable)
+{
+	if (enable == 0) {
+		onuGponLogEnable = MV_FALSE;
+
+		onuGponLogDbEntryCount = 0;
+		onuGponLogDbEntryIndex = 0;
+	} else
+		onuGponLogEnable = MV_TRUE;
+}
+
+/*******************************************************************************
+**
+**  onuGponSyncLog
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function logs records into the cyclic log buffer
+**
+**  PARAMETERS:  MV_U32 event, MV_U32 data1, MV_U32 data2, MV_U32 data3
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuGponSyncLog(MV_U32 event, MV_U32 data1, MV_U32 data2, MV_U32 data3)
+{
+	MV_U32 currentState;
+	MV_U32 timeStamp;
+
+	if (onuGponLogEnable != MV_TRUE)
+		return;
+
+	currentState = onuGponDbOnuStateGet();
+	asicOntGlbRegReadNoCheck(mvAsicReg_GPON_GEN_MICRO_SEC_CNT, &timeStamp, 0);
+
+	if (onuGponLogDbEntryIndex == ONU_GPON_LOG_SIZE)
+		onuGponLogDbEntryIndex = 0;
+
+	/* save log information */
+	onuGponLogDb[onuGponLogDbEntryIndex].event    = event;
+	onuGponLogDb[onuGponLogDbEntryIndex].state    = currentState;
+	onuGponLogDb[onuGponLogDbEntryIndex].time     = timeStamp;
+	onuGponLogDb[onuGponLogDbEntryIndex].dataVal1 = data1;
+	onuGponLogDb[onuGponLogDbEntryIndex].dataVal2 = data2;
+	onuGponLogDb[onuGponLogDbEntryIndex].dataVal3 = data3;
+
+	onuGponLogDbEntryIndex++;
+
+	/* The max number of counter is 512 */
+	if (onuGponLogDbEntryCount < ONU_GPON_LOG_SIZE)
+		onuGponLogDbEntryCount++;
+}
+
+/*******************************************************************************
+**
+**  onuGponSyncLogPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print the records placed in the log
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuGponSyncLogPrint(void)
+{
+	MV_32 index;
+	MV_U32 printEntry;
+	MV_BOOL logEnabled;
+
+	logEnabled = onuGponLogEnable;
+	onuGponLogEnable = MV_FALSE;
+
+	printk(KERN_INFO "=======GPON LOG has %d items=======\r\n", onuGponLogDbEntryCount);
+
+	for (index = 0; index < onuGponLogDbEntryCount; index++) {
+		if ((onuGponLogDbEntryIndex - index) > 0)
+			printEntry = onuGponLogDbEntryIndex - index - 1;
+		else
+			printEntry = ((MV_U32)ONU_GPON_LOG_SIZE - 1) - (index - onuGponLogDbEntryIndex);
+
+		switch (onuGponLogDb[printEntry].event) {
+		case ONU_GPON_LOG_MSG:
+			printk(KERN_INFO "[%03d] PLOAM message, state=%d, time=%08x, onuId=%d, msgId=%d\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time,
+			       onuGponLogDb[printEntry].dataVal1,
+			       onuGponLogDb[printEntry].dataVal2);
+			break;
+
+		case ONU_GPON_LOG_MSG_CONTENT:
+			printk(KERN_INFO "[%03d] PLOAM message, data=0x%08x%08x%08x [030201000706050411100908]\n", printEntry,
+			       onuGponLogDb[printEntry].dataVal1,
+			       onuGponLogDb[printEntry].dataVal2,
+			       onuGponLogDb[printEntry].dataVal3);
+			break;
+
+		case ONU_GPON_LOG_INTERRUPT:
+			printk(KERN_INFO "[%03d] Interrupt, state=%d, time=%08x, event&status=0x%08x\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time,
+			       onuGponLogDb[printEntry].dataVal1);
+			printk(KERN_INFO "==========================================================\n");
+			break;
+
+		case ONU_GPON_LOG_INTERRUPT_XVR_SD:
+			printk(KERN_INFO "[%03d] LOS Interrupt, state=%d, time=%08x, status=%d\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time,
+			       onuGponLogDb[printEntry].dataVal1);
+			break;
+
+		case ONU_GPON_LOG_INTERRUPT_LOF:
+			printk(KERN_INFO "[%03d] LOF Interrupt, state=%d, time=%08x, status=%d\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time,
+			       onuGponLogDb[printEntry].dataVal1);
+			break;
+
+		case ONU_GPON_LOG_INTERRUPT_SERDES_START:
+			printk(KERN_INFO "[%03d] SERDES Start, state=%d, time=%08x\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time);
+			break;
+
+		case ONU_GPON_LOG_INTERRUPT_SERDES_STOP:
+			printk(KERN_INFO "[%03d] SERDES Stop, state=%d, time=%08x\n", printEntry,
+			       onuGponLogDb[printEntry].state,
+			       onuGponLogDb[printEntry].time);
+			break;
+
+		case ONU_GPON_LOG_STATE:
+			printk(KERN_INFO "[%03d] State, state=%d, time=%08x\n", printEntry,
+			       onuGponLogDb[printEntry].dataVal1,
+			       onuGponLogDb[printEntry].time);
+			break;
+
+		case ONU_GPON_LOG_FREE_TEXT:
+			printk(KERN_INFO "[%03d] Free, time=%08x %d %d %d\n", printEntry,
+			       onuGponLogDb[printEntry].time,
+			       onuGponLogDb[printEntry].dataVal1,
+			       onuGponLogDb[printEntry].dataVal2,
+			       onuGponLogDb[printEntry].dataVal3);
+			break;
+
+		default:
+			printk(KERN_INFO "[%03d] Other\r\n", printEntry);
+			break;
+		}
+	}
+
+	onuGponLogDbEntryCount = 0;
+	onuGponLogDbEntryIndex = 0;
+
+	onuGponLogEnable = logEnabled;
+}
+
+/*******************************************************************************
+**
+**                            T-CONT FLUSH SECTION
+**
+********************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponWqTcontFlush
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function schedule T-Cont queue flush work to the T-Cont
+**               work queue
+**
+**  PARAMETERS:  MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponWqTcontFlush(MV_U32 tcont)
+{
+	if (tcont != 0xFF)
+		queue_work(gponTcontFlushWq.ponWq, (struct work_struct *)&gponTcontCleanWork[tcont]);
+	else
+		queue_work(gponTcontFlushWq.ponWq, (struct work_struct *)&gponTcontCleanAllWork);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponWqTcontActivate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function schedule T-Cont queue activate work to the T-Cont
+**               work queue
+**
+**  PARAMETERS:  MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponWqTcontActivate(MV_U32 tcont)
+{
+	queue_work(gponTcontFlushWq.ponWq, (struct work_struct *)&gponTcontActiveWork[tcont]);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponWqTcontFunc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function process incoming work to the T-Cont work queue
+**
+**  PARAMETERS:  struct work_struct *work
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void onuGponWqTcontFunc(struct work_struct *work)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_TCONT_FLUSH_FOR_AVANTA_LP
+	DATAFORWARDFUNC dataForwardCallback;
+#endif
+#endif
+	S_onuPonWork *currentWork = (S_onuPonWork *)work;
+	MV_U32 tcont = currentWork->param;
+	MV_STATUS rcode;
+
+	MV_U8 *stateText[] = { "",
+			       "Ready State   ",
+			       "Running State ",
+			       "Blocking State" };
+
+	/* Handle T-Cont Clear */
+	/* =================== */
+	if (currentWork->action == TCONT_CLEAN_EVENT) {
+		if (onuGponTcontFlushState[tcont] == TCONT_FLUSH_RUNNING_STATE) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) TCONT (%d) CLEAN_EVENT\n", __FILE_DESC__, __LINE__, tcont);
+			onuGponTcontFlushState[tcont] = TCONT_FLUSH_BLOCKING_STATE;
+#ifndef PON_FPGA
+#ifdef DISABLE_TCONT_FLUSH_FOR_AVANTA_LP
+			dataForwardCallback = onuGponDbHwfCallbackGet();
+			if (dataForwardCallback != NULL) {
+				rcode = dataForwardCallback(tcont, MV_FALSE);
+				if (MV_OK != rcode) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+						   "DEBUG: (%s:%d) failed to set HWF T-CONT state\n",
+						   __FILE_DESC__, __LINE__);
+					return;
+				}
+			}
+
+			dataForwardCallback = onuGponDbSwfCallbackGet();
+			if (dataForwardCallback != NULL) {
+				rcode = dataForwardCallback(tcont, MV_FALSE);
+				if (MV_OK != rcode) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+						   "DEBUG: (%s:%d) failed to set SWF T-CONT state\n",
+						   __FILE_DESC__, __LINE__);
+					return;
+				}
+			}
+#endif
+#endif                  /* PON_FPGA */
+			onuGponTcontFlushState[tcont] = TCONT_FLUSH_READY_STATE;
+#ifdef PON_A0
+			rcode = onuGponTxFlush(tcont);
+			if (MV_OK != rcode) {
+				mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+					   "DEBUG: (%s:%d) failed to flush TX\n", __FILE_DESC__, __LINE__);
+				return;
+			}
+#endif
+		} else {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) Received TCONT_CLEAN_EVENT while in T-CONT(%d) state(%s)\n",
+				   __FILE_DESC__, __LINE__, tcont, stateText[onuGponTcontFlushState[tcont]]);
+		}
+	} else if (currentWork->action == TCONT_CLEAN_ALL_EVENT) { /* Handle All T-Cont Clear */
+		for (tcont = 0; tcont < 8; tcont++) {
+			if (onuGponTcontFlushState[tcont] == TCONT_FLUSH_RUNNING_STATE) {
+				mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+					   "DEBUG: (%s:%d) TCONT (%d) CLEAN_EVENT\n", __FILE_DESC__, __LINE__, tcont);
+				onuGponTcontFlushState[tcont] = TCONT_FLUSH_BLOCKING_STATE;
+#ifndef PON_FPGA
+#ifdef DISABLE_TCONT_FLUSH_FOR_AVANTA_LP
+				dataForwardCallback = onuGponDbHwfCallbackGet();
+				if (dataForwardCallback != NULL) {
+					rcode = dataForwardCallback(tcont, MV_FALSE);
+					if (MV_OK != rcode) {
+						mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+							   "DEBUG: (%s:%d) failed to set HWF T-CONT state\n",
+							   __FILE_DESC__, __LINE__);
+						return;
+					}
+				}
+
+				dataForwardCallback = onuGponDbSwfCallbackGet();
+				if (dataForwardCallback != NULL) {
+					rcode = dataForwardCallback(tcont, MV_FALSE);
+					if (MV_OK != rcode) {
+						mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+							   "DEBUG: (%s:%d) failed to set SWF T-CONT state\n",
+							   __FILE_DESC__, __LINE__);
+						return;
+					}
+				}
+#endif
+#endif                          /* PON_FPGA */
+				onuGponTcontFlushState[tcont] = TCONT_FLUSH_READY_STATE;
+#ifdef PON_A0
+				rcode = onuGponTxFlush(tcont);
+				if (MV_OK != rcode) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+						   "DEBUG: (%s:%d) failed to flush TX\n", __FILE_DESC__, __LINE__);
+					return;
+				}
+#endif
+			} else {
+				mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+					   "DEBUG: (%s:%d) Received TCONT_CLEAN_EVENT while in T-CONT(%d) state(%s)\n",
+					   __FILE_DESC__, __LINE__, tcont, stateText[onuGponTcontFlushState[tcont]]);
+			}
+		}
+	} else if (currentWork->action == TCONT_ACTIVE_EVENT) { /* Handle T-Cont Activate */
+		if (onuGponTcontFlushState[tcont] == TCONT_FLUSH_READY_STATE) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) TCONT (%d) ACTIVE_EVENT\n", __FILE_DESC__, __LINE__, tcont);
+			onuGponTcontFlushState[tcont] = TCONT_FLUSH_RUNNING_STATE;
+#ifndef PON_FPGA
+#ifdef DISABLE_TCONT_FLUSH_FOR_AVANTA_LP
+			dataForwardCallback = onuGponDbHwfCallbackGet();
+			if (dataForwardCallback != NULL) {
+				rcode = dataForwardCallback(tcont, MV_TRUE);
+				if (MV_OK != rcode) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+						   "DEBUG: (%s:%d) failed to set HWF T-CONT state\n",
+						   __FILE_DESC__, __LINE__);
+					return;
+				}
+			}
+
+			dataForwardCallback = onuGponDbSwfCallbackGet();
+			if (dataForwardCallback != NULL) {
+				rcode = dataForwardCallback(tcont, MV_TRUE);
+				if (MV_OK != rcode) {
+					mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+						   "DEBUG: (%s:%d) failed to set SWF T-CONT state\n",
+						   __FILE_DESC__, __LINE__);
+					return;
+				}
+			}
+#endif
+#endif                  /* PON_FPGA */
+		} else {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_MODULE,
+				   "DEBUG: (%s:%d) Received TCONT_ACTIVE_EVENT while in T-CONT state(%s)\n",
+				   __FILE_DESC__, __LINE__, stateText[onuGponTcontFlushState[tcont]]);
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+**
+**  onuGponOmciClsRuleAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds classifier rule for OMCI API channel
+**
+**  PARAMETERS:  MV_U8 luid
+**               MV_U8 rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponOmciClsRuleAdd(MV_U8 luid, MV_U8 rxCpuQueue)
+{
+	MV_32 rcode;
+	MV_PP2_CLS_LKP_ENTRY fe;
+
+	/* Set OMCI parsing rule in PP parser */
+	mvPp2ClsSwLkpClear(&fe);
+
+	rcode = mvPp2ClsSwLkpRxqSet(&fe, (MV_32)rxCpuQueue + MV_PMAC_RX_QUEUE_SHIFT);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpFlowSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsSwLkpFlowSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpModSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpEnSet(&fe, 0);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsSwLkpEnSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsHwLkpWrite(luid, MV_PP2_PON_WAY, &fe);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsSwLkpRxqSet(&fe, (MV_32)rxCpuQueue);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsSwLkpRxqSet\n");
+		return MV_ERROR;
+	}
+
+	rcode = mvPp2ClsHwLkpWrite(luid, MV_PP2_ETH_WAY, &fe);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponOmciClsRuleDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes classifier rule for OMCI API channel
+**
+**  PARAMETERS:  MV_U8 luid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponOmciClsRuleDel(MV_U8 luid)
+{
+	MV_32 rcode;
+
+	/* Delete OMCI parsing rule in PP parser */
+	rcode = mvPp2ClsHwLkpClear(luid, MV_PP2_PON_WAY);
+	if (rcode) {
+		printk(KERN_INFO "Fail to call mvPp2ClsHwLkpWrite\n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponOmciChannelAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds OMCI API channel
+**
+**  PARAMETERS:  MV_U16 gemPort
+**               MV_U8  rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponOmciChannelAdd(MV_U16 gemPort, MV_U8 rxCpuQueue)
+{
+	S_OnuOmcc omcc;
+	MV_U32 luid;
+	MV_U32 tid;
+	MV_32 rcode;
+	MV_STATUS rc;
+
+	/* Check wether OMCC already exsits */
+	rc = onuGponDbOmccGet(&omcc);
+	if (rc != MV_OK) {
+		printk(KERN_INFO "Fail to call onuGponDbOmccGet \n");
+		return MV_ERROR;
+	}
+	if (omcc.state == MV_TRUE) {
+		printk(KERN_INFO "GPON OMCC already exsits \n");
+		return MV_ERROR;
+	}
+
+	/* GEM port checking */
+	if (gemPort >= MV_ALLOC_ID_MAX_NUM) {
+		printk(KERN_INFO "Invalid GPON OMCC GEM port(%d)\n", gemPort);
+		return MV_ERROR;
+	}
+
+	/* Rx queue checking */
+	if (rxCpuQueue >= MV_RX_QUEUE_MAX_NUM) {
+		printk(KERN_INFO "Invalid GPON OMCI CPU RX queue(%d)\n", rxCpuQueue);
+		return MV_ERROR;
+	}
+
+	/* Set OMCI parsing rule in PP parser */
+	rcode = mvPrsMhSet(MV_PP2_PON_PORT_BM,
+			   gemPort,
+			   MV_PP2_OMCI_MH_MASK,
+			   MV_PP2_CPU_CODE_SPECIAL_PKT | MV_PP2_UDF3_SPECIAL_PKT,
+			   MV_PP2_CPU_CODE_MASK | MV_PP2_UDF3_MASK,
+			   1);
+	if (rcode) {
+		printk(KERN_INFO "Failed to add OMCI MH parser rule\n");
+		return MV_ERROR;
+	}
+
+	/* Get valid LU ID fomr LSP */
+	luid = mvPrsFlowIdLastFreeGet();
+	if (luid == MV_PP2_PRS_INVALID_FLOW_ID) {
+		printk(KERN_INFO "Can not get LU ID for OMCC port\n");
+		return MV_ERROR;
+	}
+
+	/* Get first free parser entry,  go through the all entires from last to first */
+	tid = mvPp2PrsTcamFirstFree(MV_PP2_PRS_TCAM_SIZE - 1, 0);
+	if (tid > MV_PP2_PRS_TCAM_SIZE - 1) {
+		printk(KERN_INFO "No free TCAM entry for traffic\n");
+		return MV_ERROR;
+	}
+	rcode = mvPrsFlowIdGen(tid,
+			       luid,
+			       MV_PP2_UDF3_SPECIAL_PKT,
+			       MV_PP2_UDF3_MASK,
+			       PORT_MASK);
+	if (rcode) {
+		printk(KERN_INFO "Failed to add PP parser rule for OMCC\n");
+		return MV_ERROR;
+	}
+
+	/* Add CLS rule to filter packet to CPU */
+	rc = onuGponOmciClsRuleAdd(luid, rxCpuQueue);
+	if (rc != MV_OK) {
+		printk(KERN_INFO "Failed to add CLS rule\n");
+		return MV_ERROR;
+	}
+
+	/* Set PON way */
+	rc = mvPp2ClsHwPortWaySet(MV_PP2_PON_PORT, MV_PP2_PON_WAY);
+	if (rc != MV_OK) {
+		printk(KERN_INFO "Failed to set PON way\n");
+		return MV_ERROR;
+	}
+
+	/* Save OMCC status and RX queue to DB */
+	omcc.state      = MV_TRUE;
+	omcc.gemPort    = gemPort;
+	omcc.cpuRxQueue = rxCpuQueue;
+	omcc.luid       = luid;
+	omcc.prsTid     = tid;
+	rc = onuGponDbOmccSet(&omcc);
+	if (rc != MV_OK) {
+		printk(KERN_INFO "Failed to call onuGponDbOmccSet \n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponOmciChannelDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes OMCI API channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponOmciChannelDel(void)
+{
+	S_OnuOmcc omcc;
+	MV_32 rcode;
+	MV_STATUS rc;
+
+	/* Check wether OMCC already exsits */
+	rc = onuGponDbOmccGet(&omcc);
+	if (rc != MV_OK) {
+		printk(KERN_INFO KERN_ERR "Fail to call onuGponDbOmccGet \n");
+		return MV_ERROR;
+	}
+	if (omcc.state == MV_FALSE) {
+		printk(KERN_INFO KERN_ERR "GPON OMCC already exsits \n");
+		return MV_OK;
+	}
+
+	/* Delete MH parsing rule in PP parser */
+	rcode = mvPrsMhDel(MV_PP2_PON_PORT_BM,
+			   omcc.gemPort,
+			   MV_PP2_OMCI_MH_MASK);
+	if (rcode) {
+		printk(KERN_INFO KERN_ERR "Failed to set OMCI MH parse rule\n");
+		return MV_ERROR;
+	}
+
+	/* Free LU ID from LSP */
+	rcode = mvPrsFlowIdRelease(omcc.luid);
+	if (rcode != MV_OK) {
+		printk(KERN_INFO KERN_ERR "Can not free LU ID for OMCC port\n");
+		return MV_ERROR;
+	}
+
+	/* Delete Parser flow rule */
+	rcode = mvPrsFlowIdDel(omcc.prsTid);
+	if (rcode) {
+		printk(KERN_INFO KERN_ERR "Fail to delete PP parser rule for OMCC\n");
+		return MV_ERROR;
+	}
+
+	/* Delete CLS rule to filter packet to CPU */
+	rc = onuGponOmciClsRuleDel(omcc.luid);
+	if (rc != MV_OK) {
+		printk(KERN_INFO KERN_ERR "Fail to delete CLS rule\n");
+		return MV_ERROR;
+	}
+
+	/* Save OMCC status and RX queue to DB */
+	omcc.state = MV_FALSE;
+	rc = onuGponDbOmccSet(&omcc);
+	if (rc != MV_OK) {
+		printk(KERN_INFO KERN_ERR "Fail to call onuGponDbOmccSet \n");
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponOmciChannelPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints OMCI API channel information
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponOmciChannelPrint(char* buf)
+{
+	S_OnuOmcc omcc;
+	MV_STATUS rc;
+	int off = 0;
+
+	/* Check wether OMCC already exsits */
+	rc = onuGponDbOmccGet(&omcc);
+	if (rc != MV_OK) {
+		off += mvOsSPrintf(buf + off, "Fail to call onuGponDbOmccGet\n");
+		return off;
+	}
+
+	if (omcc.state == MV_FALSE)
+		off += mvOsSPrintf(buf + off, "GPON OMCI channel: disabled\n");
+	else
+		off += mvOsSPrintf(buf + off,
+				   "GPON OMCI channel: enabled. gem port:%d, cpu rx queue:%d, luid:%d, tid:%d \n",
+				   omcc.gemPort, omcc.cpuRxQueue, omcc.luid, omcc.prsTid);
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponHighPriTxMapAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds high priority TX map to HW
+**
+**  PARAMETERS:  S_OnuTcontMap *tcontMap
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponHighPriTxMapAdd(S_OnuTcontMap *tcontMap)
+{
+	MV_U32 shift;
+	MV_U32 tcontBm;
+	MV_U32 l_tcontMap;
+	MV_STATUS rcode;
+
+	/* NULL validation */
+	PON_IF_NULL(PON_MNG_MODULE, tcontMap);
+
+	/* enable host T-cont */
+	rcode = mvOnuGponHighPriTxValidBmGet(&tcontBm);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to read valid T-CONT bitmap\n");
+	tcontBm |= (1 << tcontMap->hostTcont);
+	rcode = mvOnuGponHighPriTxValidBmSet(tcontBm);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to write valid T-CONT bitmap\n");
+
+	/* update high priority mapping */
+	if (tcontMap->hostTcont < 8) {
+		/* Set T-CONT map 0 */
+		rcode = mvOnuGponHighPriTxMap0Get(&l_tcontMap);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to read valid T-CONT map 0\n");
+		shift = (4 * tcontMap->hostTcont);
+		l_tcontMap &= ~(ONU_GPON_TCONT_MASK << shift);
+		l_tcontMap |= ((tcontMap->addTcont & ONU_GPON_TCONT_MASK) << shift);
+		rcode = mvOnuGponHighPriTxMap0Set(l_tcontMap);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to write valid T-CONT map 0\n");
+	} else {
+		/* Set T-CONT map 1 */
+		rcode = mvOnuGponHighPriTxMap1Get(&l_tcontMap);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to read valid T-CONT map 1\n");
+		shift = (4 * (tcontMap->hostTcont - 8));
+		l_tcontMap &= ~(ONU_GPON_TCONT_MASK << shift);
+		l_tcontMap |= ((tcontMap->addTcont & ONU_GPON_TCONT_MASK) << shift);
+		rcode = mvOnuGponHighPriTxMap1Set(l_tcontMap);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to write valid T-CONT map 1\n");
+	}
+
+	/* update T-CONT table */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponHighPriTxMapDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes high priority TX map to HW
+**
+**  PARAMETERS:  MV_U32 hostTcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponHighPriTxMapDel(MV_U32 hostTcont)
+{
+	MV_U32 tcontBm;
+	MV_STATUS rcode;
+
+	/* disable host T-cont */
+	rcode = mvOnuGponHighPriTxValidBmGet(&tcontBm);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to read valid T-CONT bitmap\n");
+	tcontBm &= ~(1 << hostTcont);
+	rcode = mvOnuGponHighPriTxValidBmSet(tcontBm);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to write valid T-CONT bitmap\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponHighPriTxMapInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init GPON high priority TX
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponHighPriTxMapInit(S_PonHighPriTx *highPriTx)
+{
+	MV_U32 idx;
+	S_OnuTcontMap tcontMap;
+	MV_STATUS rcode;
+
+	PON_IF_NULL(PON_MNG_MODULE, highPriTx);
+
+	/* init the state of PON high priority feature */
+	rcode = onuGponApiHighPriTxStateSet(INT_TO_MV_BOOL(highPriTx->state));
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to set PON high priority feature\n");
+
+	/* set T-CONT map when this feature is enabled */
+	if (highPriTx->state) {
+		for (idx = 0; idx < highPriTx->map_num; idx++) {
+			tcontMap.valid = MV_TRUE;
+			tcontMap.hostTcont = highPriTx->tx_map[idx].host_tx;
+			tcontMap.addTcont  = highPriTx->tx_map[idx].add_tx;
+			rcode = onuGponApiHighPriTxMapAdd(&tcontMap);
+			PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to add T-CONT map\n");
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponTxFlush
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function flush all TXs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponTxFlush(MV_U32 tcontNum)
+{
+	MV_U32 state;
+	MV_STATUS rcode;
+
+	/* enable UTM TX flush */
+	rcode = mvOnuGponMacUtmFlushSet(tcontNum, ONU_GPON_TX_FLUSH_EN);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to enable TX flush\n");
+
+	/* Poll the UTM debug status */
+	do {
+		rcode = mvOnuGponMacUtmDebugGet(tcontNum, &state);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to get TX flush status\n");
+
+	} while (state == 0);
+
+	/* clear UTM TX flush */
+	rcode = mvOnuGponMacUtmFlushSet(tcontNum, ONU_GPON_TX_FLUSH_CLEAR);
+	PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to clear TX flush\n");
+
+	/* Poll the UTM status */
+	do {
+		rcode = mvOnuGponMacUtmFlushGet(tcontNum, &state);
+		PON_IF_ERROR(PON_MNG_MODULE, rcode, "fail to get TX flush status\n");
+
+	} while (state != 0);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.h
new file mode 100644
index 0000000..cd86b43
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/core/gpon/gponOnuSrvc.h
@@ -0,0 +1,220 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuSrvc.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Services routines              **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_SRVC_H
+#define _ONU_GPON_SRVC_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define ONU_GPON_LOG_INTERRUPT                  (1)
+#define ONU_GPON_LOG_INTERRUPT_XVR_SD           (2)
+#define ONU_GPON_LOG_INTERRUPT_LOF              (3)
+#define ONU_GPON_LOG_INTERRUPT_SERDES_START     (4)
+#define ONU_GPON_LOG_INTERRUPT_SERDES_STOP      (5)
+#define ONU_GPON_LOG_STATE                      (6)
+#define ONU_GPON_LOG_MSG                        (7)
+#define ONU_GPON_LOG_MSG_CONTENT                (8)
+#define ONU_GPON_LOG_FREE_TEXT                  (9)
+
+#define ONU_GPON_LOG_SIZE                       (512)
+
+#define TCONT_CLEAN_EVENT                       (0)
+#define TCONT_CLEAN_ALL_EVENT                   (1)
+#define TCONT_ACTIVE_EVENT                      (2)
+
+#define TCONT_FLUSH_READY_STATE                 (1)
+#define TCONT_FLUSH_RUNNING_STATE               (2)
+#define TCONT_FLUSH_BLOCKING_STATE              (3)
+
+#define BIT_NUM_OF_INT                          (32)
+
+/* PPv2 Definitions
+   ------------------------------------------------------------------------------*/
+#define MV_PP2_PON_PORT                  (7)
+#define MV_PP2_PON_PORT_BM               (1 << MV_PP2_PON_PORT)
+#define MV_PP2_OMCI_MH_MASK              (0x0FFF)
+#define MV_PP2_SPECIAL_MH_ADD            (1)
+#define MV_PP2_SPECIAL_MH_DEL            (0)
+#define MV_PP2_EOAM_ETH_TYPE             (0x8809)
+#define MV_PP2_MPCP_ETH_TYPE             (0x8808)
+
+#define MV_PP2_TO_MASK(off, size)        (((1 << size) - 1) << off)
+
+/* CPU Code, bits 4 - 6 */
+#define MV_PP2_CPU_CODE_OFFS             (4)
+#define MV_PP2_CPU_CODE_BITS             (3)
+#define MV_PP2_CPU_CODE_MASK             MV_PP2_TO_MASK(MV_PP2_CPU_CODE_OFFS, MV_PP2_CPU_CODE_BITS)
+#define MV_PP2_CPU_CODE_SPECIAL_PKT      (1 << MV_PP2_CPU_CODE_OFFS)
+
+/* UDF3 , bits 20 - 21 */
+#define MV_PP2_UDF3_OFFS                 (20)
+#define MV_PP2_UDF3_BITS                 (2)
+#define MV_PP2_UDF3_MASK                 MV_PP2_TO_MASK(MV_PP2_UDF3_OFFS, MV_PP2_UDF3_BITS)
+#define MV_PP2_UDF3_SPECIAL_PKT          (2 << MV_PP2_UDF3_OFFS)
+
+#define MV_SPECIAL_PKT_TO_CPU_ID         (4)
+#define MV_SPECIAL_PKT_DEF_CPU_QUEUE     (7)
+#define MV_PP2_PON_WAY                   (1)
+#define MV_PP2_ETH_WAY                   (0)
+
+#define MV_RX_QUEUE_MAX_NUM              (8)
+#define MV_ALLOC_ID_MAX_NUM              (256)
+#define MV_GMAC0_RX_QUEUE_SHIFT          (0)
+#define MV_GMAC1_RX_QUEUE_SHIFT          (8)
+
+#ifndef PON_FPGA
+#define MV_PMAC_RX_QUEUE_SHIFT           (0x18)
+#else
+#define MV_PMAC_RX_QUEUE_SHIFT           (0x10)
+#endif
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	ONU_GPON_TX_FLUSH_CLEAR = 0,
+	ONU_GPON_TX_FLUSH_EN,
+	ONU_GPON_TX_FLUSH_DIS,
+	ONU_GPON_TX_ON_GOING,
+	ONU_GPON_TX_FLUSH_TYPE_MAX
+} E_OnuGponTxFlushTypes;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 bitMask;
+	MV_U32 blockSize;
+} S_DbrBlockSize;
+
+typedef struct {
+	MV_U16 event;
+	MV_U16 state;
+	MV_U32 time;
+	MV_U32 dataVal1;
+	MV_U32 dataVal2;
+	MV_U32 dataVal3;
+} S_OnuGponLogEntry;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS     onuGponSrvcGenCrcTable(void);
+unsigned long onuGponSrvcUpdateCrc(unsigned long crc_accum, char *data_blk_ptr, int data_blk_size);
+MV_STATUS     onuGponSrvcGenDbrTable(void);
+
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern S_onuPonWork gponTcontCleanWork[8];
+extern S_onuPonWork gponTcontCleanAllWork;
+extern S_onuPonWork gponTcontActiveWork[8];
+extern S_onuPonWorkQueue gponTcontFlushWq;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS     onuGponSrvcInit(void);
+MV_STATUS     onuGponSrvcSerialNumberSet(MV_U8 *serialNumber);
+MV_STATUS     onuGponSrvcConstPloamFromDbInit(MV_BOOL initTime);
+MV_STATUS     onuGponSrvcOnuIdUpdate(MV_U32 onuId, MV_BOOL valid);
+void          onuGponSrvcAlarmNotify(MV_U32 alarm, MV_U32 status);
+void          onuGponSrvcStatusNotify(MV_U32 status);
+void          onuGponSrvcOmccNotify(MV_U32 omccPortId);
+void onuGponSrvcDisableMsgNotify(MV_BOOL disable, MV_BOOL paramSave);
+unsigned long onuGponSrvcUpdateCrc(unsigned long crc_accum, char *data_blk_ptr, int data_blk_size);
+unsigned int  onuGponSrvcCalcCrc(unsigned char msg[], int size);
+void          onuGponSrvcAesKeyGenerate(MV_U8 *key);
+MV_STATUS     onuGponSrvcDbrBlockSizeSet(MV_U32 blockSize, MV_U32 *actualBlockSize);
+MV_STATUS     onuGponSrvcRangingRandomInit(void);
+
+void          onuGponSyncLog(MV_U32 event, MV_U32 data1, MV_U32 data2, MV_U32 data3);
+void          onuGponSyncLogEnable(MV_U32 enable);
+void          onuGponSyncLogPrint(void);
+
+MV_STATUS     onuGponOmciChannelAdd(MV_U16 gemPort, MV_U8 rxCpuQueue);
+MV_STATUS     onuGponOmciChannelDel(void);
+MV_STATUS     onuGponOmciChannelPrint(char *buf);
+
+MV_STATUS     onuGponHighPriTxMapAdd(S_OnuTcontMap *tcontMap);
+MV_STATUS     onuGponHighPriTxMapDel(MV_U32 hostTcont);
+MV_STATUS     onuGponHighPriTxMapInit(S_PonHighPriTx *highPriTx);
+MV_STATUS     onuGponTxFlush(MV_U32 tcontNum);
+extern void onuGponWqTcontFunc(struct work_struct *work);
+extern MV_STATUS onuGponWqTcontFlush(MV_U32 tcont);
+extern MV_STATUS onuGponWqTcontActivate(MV_U32 tcont);
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_APM_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.c
new file mode 100644
index 0000000..eab1274
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.c
@@ -0,0 +1,1256 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsMI.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Management Interface         **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include <linux/version.h>
+#include "eponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/perf/epon/eponOnuLnxKsMI.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+static S_EponIoctlTdmQueue ioctlTdmQueue;
+static S_EponIoctlDba ioctlDba;
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuEponMiInfoGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu info
+**
+**  PARAMETERS:  S_IoctlInfo *info
+**               MV_U32      macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponMiInfoGet(S_EponIoctlInfo *info, MV_U32 macId)
+{
+	return onuEponApiInformationGet(info, macId);
+}
+
+/*******************************************************************************
+**
+**  onuEponMiPm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu pm info
+**
+**  PARAMETERS:  S_IoctlPm *ioctlPm
+**               MV_U32    macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponMiPm(S_EponIoctlPm *ioctlPm, MV_U32 macId)
+{
+	switch (ioctlPm->section) {
+	case E_EPON_IOCTL_PM_RX:
+		return onuEponApiRxPmGet((&(ioctlPm->rxCnt)), MV_TRUE, 0);
+		break;
+	case E_EPON_IOCTL_PM_TX:
+		return onuEponApiTxPmGet((&(ioctlPm->txCnt)), MV_TRUE, macId);
+		break;
+	case E_EPON_IOCTL_PM_SW:
+		return onuEponApiSwPmGet((&(ioctlPm->swCnt)), MV_TRUE, macId);
+		break;
+	case E_EPON_IOCTL_PM_GPM:
+		return onuEponApiGpmPmGet((&(ioctlPm->gpmCnt)), MV_TRUE, macId);
+		break;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiFecConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu FEC
+**
+**  PARAMETERS:  MV_U32 rxGenFecEn
+**               MV_U32 txGenFecEn
+**               MV_U32 txMacFecEn[8]
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiFecConfig(MV_U32 rxGenFecEn, MV_U32 txGenFecEn, MV_U32 *txMacFecEn)
+{
+	return onuEponApiFecConfig(rxGenFecEn, txGenFecEn, txMacFecEn, ONU_FEC_CFG_INIT);
+}
+
+/*******************************************************************************
+**
+**  onuEponMiEncConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu ENC
+**
+**  PARAMETERS:  MV_U32 onuEncryptCfg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiEncConfig(MV_U32 onuEncryptCfg)
+{
+	MV_STATUS status;
+
+	status  = onuEponApiEncryptionConfig(onuEncryptCfg);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiEncConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu ENC
+**
+**  PARAMETERS:  MV_U32 encryptKey
+**               MV_U32 encryptKeyIndex
+**               MV_U32 macId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiEncKey(MV_U32 encryptKey, MV_U32 encryptKeyIndex, MV_U32 macId)
+{
+	MV_STATUS status;
+
+	status = onuEponApiEncryptionKeyConfig(encryptKey, encryptKeyIndex, macId);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiDbaConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu DBA report
+**
+**  PARAMETERS:  S_EponIoctlDba *ioctlDba
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiDbaConfig(S_EponIoctlDba *ioctlDba)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 validReportQueueBitMap;
+	MV_U32 highestReportQueue;
+	MV_U32 llidIdx;
+	MV_U32 queueSetIdx;
+	MV_U32 queueIdx;
+	MV_U32 numOfQueues;
+	MV_U32 numOfQueueSets;
+	MV_U32 interruptMask;
+	MV_U32 llidDbaIntMask = 0;
+
+	MV_U32 reportLimit[4] = {   /* Queueset, Queues */
+		/* 1 */ 8,
+		/* 2 */ 8,
+		/* 3 */ 5,
+		/* 4 */ 3
+	};
+
+	for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+		validReportQueueBitMap = 0;
+		highestReportQueue     = 0;
+
+		/* LLID */
+		/* ==== */
+		if (!ioctlDba->validLlid[llidIdx]) {
+			onuEponDbOnuDbaLlidActiveStatusSet(ONU_DBA_NON_ACTIVE_LLID, llidIdx);
+			continue;
+		}
+
+		onuEponDbOnuDbaLlidActiveStatusSet(ONU_DBA_UPDATE_LLID, llidIdx);
+
+		numOfQueues    = ioctlDba->dbaLlid[llidIdx].numOfQueues;
+		numOfQueueSets = ioctlDba->dbaLlid[llidIdx].numOfQueueSets;
+
+		/* Queue Set */
+		/* ========= */
+		if (ioctlDba->dbaLlid[llidIdx].numOfQueueSets == 0)
+			continue;
+
+		/* support up to 4 queuesets */
+		if (numOfQueueSets > EPON_MAX_QUEUE_SET_NUMBER)
+			numOfQueueSets = EPON_MAX_QUEUE_SET_NUMBER;
+
+		for (queueSetIdx = 0; queueSetIdx < numOfQueueSets; queueSetIdx++) {
+			/* Queue Id */
+			/* ======== */
+			for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++) {
+				if (ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].state != 0) {
+					validReportQueueBitMap |= 1 << queueIdx;
+					highestReportQueue = queueIdx;
+
+					onuEponDbOnuDbaQueueThresholdSet(
+						ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].threshold,
+						ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].state,
+						queueIdx,
+						queueSetIdx,
+						llidIdx);
+					printk(KERN_INFO "onuEponMiDbaConfig Qset(%d) queue(%d) state(%d) thres(%d)\n",
+					       queueSetIdx,
+					       queueIdx,
+					       ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].state,
+					       ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].threshold);
+
+				} else {
+					onuEponDbOnuDbaQueueThresholdSet(0,             /* threshold */
+									 0,             /* state     */
+									 queueIdx,
+									 queueSetIdx,
+									 llidIdx);
+					printk(KERN_INFO "onuEponMiDbaConfig Qset(%d) queue(%d) state(%d) thres(%d)\n",
+					       queueSetIdx,
+					       queueIdx,
+					       ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].state,
+					       ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].threshold);
+
+				}
+			}       /* for each queueIdx */
+		}               /* for each queueIdx */
+
+		/* Report Validation Check                                                  */
+		/* =======================                                                  */
+		/* Number of bytes for queue report = 39 bytes (64 - mac, type, fcs, etc')  */
+		/* Formula - Number of Queueset X                                           */
+		/*           Number of Queues   X                                           */
+		/*           Queue bytes [2]    +                                           */
+		/*           Number of reports ( == Number of Queueset)                     */
+		/*                                                                          */
+		/* SW REPORT via EPON REGS is limited to 34 bytes                           */
+		/*                                       ========                           */
+		/*                                                                          */
+		/*  QueueSet    1         2        3        4                               */
+		/*  Report      1b        1b       -        -                               */
+		/*  Queue0      2b        2b                                                */
+		/*  Queue1      2b        2b                                                */
+		/*  Queue2      2b        2b                                                */
+		/*  Queue3      2b        2b                                                */
+		/*  Queue4      2b        2b                                                */
+		/*  Queue5      2b        2b                                                */
+		/*  Queue6      2b        2b                                                */
+		/*  Queue7      2b        2b                      = 2 X 8 X 2 + 2 = 34bytes */
+		/*                                                                          */
+		/*  QueueSet    1         2        3        4                               */
+		/*  Report      1b        1b       1b       -                               */
+		/*  Queue0      2b        2b       2b                                       */
+		/*  Queue1      2b        2b       2b                                       */
+		/*  Queue2      2b        2b       2b                                       */
+		/*  Queue3      2b        2b       2b                                       */
+		/*  Queue4      2b        2b       2b                                       */
+		/*  Queue5                                                                  */
+		/*  Queue6                                                                  */
+		/*  Queue7                                        = 3 X 5 X 2 + 3 = 33bytes */
+		/*                                                                          */
+		/*  QueueSet    1         2        3        4                               */
+		/*  Report      1b        1b       1b       1b                              */
+		/*  Queue0      2b        2b       2b       2b                              */
+		/*  Queue1      2b        2b       2b       2b                              */
+		/*  Queue2                                                                  */
+		/*  Queue3                                                                  */
+		/*  Queue4                                                                  */
+		/*  Queue5                                                                  */
+		/*  Queue6                                                                  */
+		/*  Queue7                                        = 4 X 3 X 2 + 4 = 28bytes */
+		/*                                                                          */
+		/*  MV_U32 reportLimit[4] = {Queueset, Queues                               */
+		/*                              1         8,                                */
+		/*                              2         8,                                */
+		/*                              3         5,                                */
+		/*                              4         3};                               */
+
+		printk(KERN_INFO "numOfQueues(%d), numOfQueueSets(%d), reportLimit[numOfQueueSets](%d)\n",
+		       numOfQueues, numOfQueueSets, reportLimit[numOfQueueSets - 1]);
+
+		while (numOfQueues > reportLimit[numOfQueueSets - 1])
+			numOfQueueSets--;
+
+		onuEponDbOnuDbaHighestReportQueueSet(highestReportQueue, llidIdx);
+		onuEponDbOnuDbaNumOfQueuesSet(numOfQueues, llidIdx);
+		onuEponDbOnuDbaNumOfQueuesetSet(numOfQueueSets, llidIdx);
+		onuEponDbOnuDbaQueuesBitMapSet(validReportQueueBitMap, llidIdx);
+
+		printk(KERN_INFO "highestReportQueue(%d), numOfQueues(%d, bit map 0x%08x), numOfQueueSets(%d)\n",
+		       highestReportQueue, numOfQueues, validReportQueueBitMap, numOfQueueSets);
+
+		onuEponDbaInfoUpdate(llidIdx);
+
+		onuEponDbOnuDbaLlidActiveStatusSet(ONU_DBA_ACTIVE_LLID, llidIdx);
+
+		/* Switch DBA MODE from SW to HW */
+		/* ============================= */
+		/* Not supported */
+
+		/* Switch DBA MODE from HW to SW */
+		/* ============================= */
+		if ((onuEponDbOnuDbaModeGet() == ONU_DBA_HW_RPRT_MODE) && (numOfQueueSets > 1)) {
+			status = onuEponDbaModeInit(ONU_DBA_SW_RPRT_MODE);
+			if (status != MV_OK)
+				return status;
+
+			/* Set Gate INT enable for this LLID */
+			llidDbaIntMask |= 1 << llidIdx;
+
+			/* set onu pon interrupt mask */
+			mvOnuEponMacPonInterruptMaskGet(&interruptMask);
+
+			if (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_GATE_INTRRUPT) {
+				/* Stop SW DBA event miss timer */
+				onuEponIsrTimerEventMissStateSet(MV_FALSE);
+
+				interruptMask |=  (ONU_EPON_GATE_MASK);
+				interruptMask &= ~(ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+
+				status  = mvOnuEponMacPonDbrInterruptMaskSet(llidDbaIntMask);
+				if (status == MV_OK)
+					printk(KERN_INFO "Failed to configue Gate interrupt in SW DBA mode\n");
+			} else { /* (onuEponDbOnuDbaSwGateIntModeGet() == ONU_DBA_SW_TIMER) */
+			       /* Start SW DBA event miss timer */
+				onuEponIsrTimerEventMissStateSet(MV_TRUE);
+
+				interruptMask |=  (ONU_EPON_TIMESTAMP_VALUE_MATCH_MASK);
+				interruptMask &= ~(ONU_EPON_GATE_MASK);
+			}
+
+			status = mvOnuEponMacPonInterruptMaskSet(interruptMask);
+			if (status == MV_OK)
+				printk(KERN_INFO "Failed to configue pon interrupt in DBA mode\n");
+
+			onuEponDbOnuDbaModeSet(ONU_DBA_SW_RPRT_MODE);
+		}
+
+	} /* for each llidIdx */
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiDbaRprt
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu DBA report
+**
+**  PARAMETERS:  S_EponIoctlDba *ioctlDba
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiDbaRprt(S_EponIoctlDba *ioctlDba)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 llidIdx;
+	MV_U32 queueSetIdx;
+	MV_U32 queueIdx;
+	MV_U32 queueState;
+	MV_U32 queueThreshold;
+
+	for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+		/* LLID */
+		/* ==== */
+		if (ioctlDba->validLlid[llidIdx]) {
+			ioctlDba->dbaLlid[llidIdx].numOfQueues    = onuEponDbOnuDbaNumOfQueuesGet(llidIdx);
+			ioctlDba->dbaLlid[llidIdx].numOfQueueSets = onuEponDbOnuDbaNumOfQueuesetGet(llidIdx);
+
+			/* Queue Set */
+			/* ========= */
+			for (queueSetIdx = 0; queueSetIdx < ioctlDba->dbaLlid[llidIdx].numOfQueueSets; queueSetIdx++) {
+				/* Queue Id */
+				/* ======== */
+				for (queueIdx = 0; queueIdx < ioctlDba->dbaLlid[llidIdx].numOfQueues; queueIdx++) {
+					onuEponDbOnuDbaQueueThresholdGet(&(queueThreshold),
+									 &(queueState),
+									 queueIdx,
+									 queueSetIdx,
+									 llidIdx);
+
+					ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].threshold = (MV_U16)queueThreshold;
+					ioctlDba->dbaLlid[llidIdx].threshold[queueSetIdx][queueIdx].state     = (MV_U8)queueState;
+				}
+			}
+		}
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiHoldoverConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu Holdover time
+**
+**  PARAMETERS:  S_EponIoctlHoldOver *ioctlHoldover
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiHoldoverConfig(S_EponIoctlHoldOver *ioctlHoldover)
+{
+	MV_STATUS status = MV_OK;
+
+	onuEponDbOnuHoldoverStateSet(ioctlHoldover->holdoverState);
+	onuEponDbOnuHoldoverTimeSet(ioctlHoldover->holdoverTime);
+
+	/* Add the newly configured holdover time with OpticalLosTime */
+	onuEponIsrTimerHoldoverIntervalSet(onuEponDbOnuHoldoverTimeGet() +
+					   onuEponDbOnuOpticalLosTimeGet(), 0);
+
+	mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+		   "DEBUG: Holdover config, state(%d), time(%d))\n",
+		   ioctlHoldover->holdoverState, ioctlHoldover->holdoverTime);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiHoldoverReport
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu Holdover parameters
+**
+**  PARAMETERS:  S_EponIoctlHoldOver *ioctlHoldover
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiHoldoverReport(S_EponIoctlHoldOver *ioctlHoldover)
+{
+	MV_STATUS status = MV_OK;
+
+	ioctlHoldover->holdoverState = onuEponDbOnuHoldoverStateGet();
+	ioctlHoldover->holdoverTime  = onuEponDbOnuHoldoverTimeGet();
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiLosTimeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the time delay for entering holdover status
+**
+**  PARAMETERS:  *ioctlLosTime - time delay value
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiLosTimeConfig(S_EponIoctlLosTime *ioctlLosTime)
+{
+	MV_STATUS status = MV_OK;
+
+	MV_U16 opticalLosTime;
+	MV_U16 macLosTime;
+
+	opticalLosTime = ioctlLosTime->optical_los_time;
+	macLosTime     = ioctlLosTime->mac_los_time;
+
+	status = mvEponApiLosTimeConfig(opticalLosTime, macLosTime);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiTxPowerControlConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function controls the TX power on and off
+**
+**  PARAMETERS:  ioctlTxControl - on, off and time delay before off
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiTxPowerControlConfig(S_EponIoctlTxControl *ioctlTxControl)
+{
+	MV_STATUS status = MV_OK;
+	MV_U16 action;
+	MV_U16 time;
+
+	action = ioctlTxControl->action;
+	time   = ioctlTxControl->time * 1000; /* The time from user space is expressed in second */
+
+	status = mvEponApiTxPowerCtrlConfig(action, time);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiPowerSavingConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets maxSleepDuration for power saving mode
+**
+**  PARAMETERS:  *ioctlPowerSaving - power saving mode duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiPowerSavingConfig(S_EponIoctlPowerSaving *ioctlPowerSaving)
+{
+	MV_STATUS status = MV_OK;
+
+	MV_U8 earlyWakeup;
+	MV_U32 maxSleepDuration;
+
+	earlyWakeup      = ioctlPowerSaving->earlyWakeUp;
+	maxSleepDuration = ioctlPowerSaving->maxSleepDuration;
+
+	status = mvEponApiPowerSavingConfig(earlyWakeup, maxSleepDuration);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiControlSleepConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function triggers the action of power mode transformation
+**
+**  PARAMETERS:  *ioctlControlSleep - power control and sleep/wakeup duration
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiControlSleepConfig(S_EponIoctlControlSleep *ioctlControlSleep)
+{
+	MV_STATUS status = MV_OK;
+
+	uint8_t action;
+
+	action = ioctlControlSleep->action;
+
+	if (action == E_GPON_SLEEP_ACTION_DISABLE)
+		mvEponApiSleepCtrlDisable();
+	else if (action == E_GPON_SLEEP_ACTION_ENABLE)
+		mvEponApiSleepCtrlEnable();
+	else if (action == E_GPON_SLEEP_ACTION_CONFIG) {
+		mvEponApiSleepCtrlCfg(ioctlControlSleep->sleepMode,
+				      ioctlControlSleep->sleepDuration,
+				      ioctlControlSleep->waitDuration);
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiSilenceConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu silence state
+**
+**  PARAMETERS:  S_EponIoctlSilence *ioctlSilence
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiSilenceConfig(S_EponIoctlSilence *ioctlSilence)
+{
+	MV_STATUS status = MV_OK;
+
+	onuEponDbOnuSilenceStateSet(ioctlSilence->silenceState);
+
+	mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+		   "DEBUG: Silence config, state(%d)\n", ioctlSilence->silenceState);
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiAlarmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function get EPON alarm(PON LOS)
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     alarm bit0:XVR LoS, alarm bit1:SERDES Los.
+**               bit8: XVR ON, bit9: SERDES ON
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiAlarmGet(MV_U32 *alarm)
+{
+	MV_STATUS status = MV_OK;
+
+	onuEponLosAlarmGet(alarm);
+
+/*
+   mvPonPrint(PON_PRINT_INFO, PON_API_MODULE,
+	     "DEBUG: EPON Alarm[%x], bit0: XVR LoS, bit1:SERDES LoS, bit8: XVR ON, bit9:SERDES ON\n", *alarm);
+ */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiTdmQueueConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu tdm queue params
+**
+**  PARAMETERS:  S_EponIoctlTdmQueue *ioctlTdm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuEponMiTdmQueueConfig(S_EponIoctlTdmQueue *ioctlTdm)
+{
+	MV_STATUS status = MV_OK;
+	MV_U32 llidIdx;
+	MV_U32 queueIdx;
+	MV_U32 numOfQueues;
+
+	for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+		if (onuEponDbOnuDbaLlidActiveStatusGet(llidIdx) == ONU_DBA_ACTIVE_LLID) {
+			numOfQueues = onuEponDbOnuDbaNumOfQueuesGet(llidIdx);
+
+			for (queueIdx = 0; queueIdx < numOfQueues; queueIdx++)
+				onuEponPmDbaAddBytePerLlidAndQueue(llidIdx, queueIdx,
+					ioctlTdm->tdmQueCnt[llidIdx][queueIdx]);
+		}
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMiCfgMacTxEn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac TX enable
+**
+**  PARAMETERS:  enable - enable [1] or disable [0] TX
+**
+**  OUTPUTS:
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponMiCfgMacTxEn(MV_U32 enable, MV_U32 macId)
+{
+	onuPonTxPowerOn(enable == 1 ? MV_TRUE : MV_FALSE);
+	onuEponForceTxDownStateSet(enable, macId);
+	mvOnuEponMacOnuTxEnableSet(enable, macId);
+}
+
+/*******************************************************************************
+**
+**  onuEponMiCfgLoidAuth
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac LOID authentication state
+**
+**  PARAMETERS:  enable - enable [1] or disable [0] TX
+**
+**  OUTPUTS:
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponMiCfgLoidAuth(MV_U32 enable, MV_U32 macId)
+{
+	onuEponDbOnuLoidAuthStateSet(INT_TO_MV_BOOL(enable), macId);
+}
+
+/*******************************************************************************
+**
+**  mvEponCdevIoctl
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function execute IO commands
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**               unsigned int cmd
+**               unsigned long arg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+long mvEponCdevIoctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	MV_STATUS status;
+	S_EponIoctlInit ioctlInit;
+	S_EponIoctlInfo ioctlInfo;
+	S_EponIoctlPm ioctlPm;
+	S_EponIoctlFec ioctlFec;
+	S_EponIoctlEnc ioctlEnc;
+	S_EponIoctlOamTx ioctlTxOam;
+	S_EponIoctlHoldOver ioctlHoldover;
+	S_EponIoctlSilence ioctlSilence;
+	MV_U32 ioctlState;
+	MV_U32 ioctlAlarm;
+	S_EponIoctlRogueOnu ioctlRogueOnu;
+	S_EponIoctlLosTime ioctlLosTime;
+	S_EponIoctlTxControl ioctlTxControl;
+	S_EponIoctlPowerSaving ioctlPowerSaving;
+	S_EponIoctlControlSleep ioctlControlSleep;
+	S_EponIoctlLoid ioctlLoidAuth;
+	S_EponIoctlLlidPmConfig ioctlLlidPmConfig;
+	S_EponIoctlLlidMibCounters ioctlLlidMibCounters;
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	/* ====== MVEPON_IOCTL_INIT ======= */
+	case MVEPON_IOCTL_INIT:
+		if (copy_from_user(&ioctlInit, (S_EponIoctlInit *)arg, sizeof(S_EponIoctlInit))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		onuEponInit(&ioctlInit);
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_FEC_CONFIG ======= */
+	case MVEPON_IOCTL_FEC_CONFIG:
+		if (copy_from_user(&ioctlFec, (S_EponIoctlFec *)arg, sizeof(S_EponIoctlFec))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiFecConfig(ioctlFec.rxGenFecEn,
+					    ioctlFec.txGenFecEn,
+					    ioctlFec.txMacFecEn);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_ENC_CONFIG ======== */
+	case MVEPON_IOCTL_ENC_CONFIG:
+		if (copy_from_user(&ioctlEnc, (S_EponIoctlEnc *)arg, sizeof(S_EponIoctlEnc))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiEncConfig(ioctlEnc.encEnable);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_ENC_KEY ======== */
+	case MVEPON_IOCTL_ENC_KEY:
+		if (copy_from_user(&ioctlEnc, (S_EponIoctlEnc *)arg, sizeof(S_EponIoctlEnc))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiEncKey(ioctlEnc.encKey,
+					 ioctlEnc.encKeyIndex & 0x1,
+					 ioctlEnc.macId);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_INFO ==================== */
+	case MVEPON_IOCTL_INFO:
+		if (copy_from_user(&ioctlInfo, (S_EponIoctlInfo *)arg, sizeof(S_EponIoctlInfo))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		status = onuEponMiInfoGet(&ioctlInfo, ioctlInfo.macId);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		if (copy_to_user((S_EponIoctlInfo *)arg, &ioctlInfo, sizeof(S_EponIoctlInfo))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_PM ==================== */
+	case MVEPON_IOCTL_PM:
+		if (copy_from_user(&ioctlPm, (S_EponIoctlPm *)arg, sizeof(S_EponIoctlPm))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		status = onuEponMiPm(&ioctlPm, ioctlPm.macId);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		if (copy_to_user((S_EponIoctlPm *)arg, &ioctlPm, sizeof(S_EponIoctlPm))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_OAM_TX ==================== */
+	case MVEPON_IOCTL_OAM_TX:
+		if (copy_from_user(&ioctlTxOam, (S_EponIoctlOamTx *)arg, sizeof(S_EponIoctlOamTx))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponApiTransmitOamFrame((S_OnuEponCtrlBuffer *)&(ioctlTxOam.oamFrame), ioctlTxOam.macId);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_DEBUG, PON_MNG_OAM_TX_MODULE,
+				   "ERROR: (%s:%d) onuEponSendCtrlFrameData\n\r", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_DBA_CFG ==================== */
+	case MVEPON_IOCTL_DBA_CFG:
+		if (copy_from_user(&ioctlDba, (S_EponIoctlDba *)arg, sizeof(S_EponIoctlDba))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiDbaConfig((S_EponIoctlDba *)&(ioctlDba));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_DBA_RPRT =================== */
+	case MVEPON_IOCTL_DBA_RPRT:
+		if (copy_from_user(&ioctlDba, (S_EponIoctlDba *)arg, sizeof(S_EponIoctlDba))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		status = onuEponMiDbaRprt((S_EponIoctlDba *)&(ioctlDba));
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		if (copy_to_user((S_EponIoctlDba *)arg, &ioctlDba, sizeof(S_EponIoctlDba))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_HOLDOVER_CFG ==================== */
+	case MVEPON_IOCTL_HOLDOVER_CFG:
+		if (copy_from_user(&ioctlHoldover, (S_EponIoctlHoldOver *)arg, sizeof(S_EponIoctlHoldOver))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiHoldoverConfig((S_EponIoctlHoldOver *)&(ioctlHoldover));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_HOLDOVER_RPRT ==================== */
+	case MVEPON_IOCTL_HOLDOVER_RPRT:
+		status = onuEponMiHoldoverReport((S_EponIoctlHoldOver *)&(ioctlHoldover));
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		if (copy_to_user((S_EponIoctlHoldOver *)arg, &ioctlHoldover, sizeof(S_EponIoctlHoldOver))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_LOS_TIME ==================== */
+	case MVEPON_IOCTL_LOS_TIME:
+		if (copy_from_user(&ioctlLosTime, (S_EponIoctlLosTime *)arg, sizeof(S_EponIoctlLosTime))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiLosTimeConfig(&(ioctlLosTime));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+
+		break;
+
+	/* ====== MVEPON_IOCTL_TX_CONTROL ==================== */
+	case MVEPON_IOCTL_TX_CONTROL:
+		if (copy_from_user(&ioctlTxControl, (S_EponIoctlTxControl *)arg, sizeof(S_EponIoctlTxControl))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiTxPowerControlConfig(&(ioctlTxControl));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+
+		break;
+
+	/* ====== MVEPON_IOCTL_POWER_SAVING ==================== */
+	case MVEPON_IOCTL_POWER_SAVING:
+		if (copy_from_user(&ioctlPowerSaving, (S_EponIoctlPowerSaving *)arg, sizeof(S_EponIoctlPowerSaving))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiPowerSavingConfig(&(ioctlPowerSaving));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+
+		break;
+
+	/* ====== MVEPON_IOCTL_CONTROL_SLEEP ==================== */
+	case MVEPON_IOCTL_CONTROL_SLEEP:
+		if (copy_from_user(&ioctlControlSleep, (S_EponIoctlControlSleep *)arg, sizeof(S_EponIoctlControlSleep))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiControlSleepConfig(&(ioctlControlSleep));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+
+		break;
+	/* ====== MVEPON_IOCTL_SILENCE ==================== */
+	case MVEPON_IOCTL_SILENCE:
+		if (copy_from_user(&ioctlSilence, (S_EponIoctlSilence *)arg, sizeof(S_EponIoctlSilence))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiSilenceConfig((S_EponIoctlSilence *)&(ioctlSilence));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_P2P_SET ==================== */
+	case MVEPON_IOCTL_P2P_SET:
+		if (copy_from_user(&ioctlState, (MV_U32*)arg, sizeof(MV_U32))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		if (ioctlState)
+			status = mvP2PStart();
+		else
+			status = mvP2PStop();
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_P2P_ FORCE_MODE_SET ==================== */
+	case MVEPON_IOCTL_P2P_FORCE_MODE_SET:
+		if (copy_from_user(&ioctlState, (MV_U32 *)arg, sizeof(MV_U32))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+
+		status = onuEponDbP2PForceModeSet(ioctlState);
+
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_TDM_QUE_CFG ==================== */
+	case MVEPON_IOCTL_TDM_QUE_CFG:
+		if (copy_from_user(&ioctlTdmQueue,  (S_EponIoctlTdmQueue *)arg, sizeof(S_EponIoctlTdmQueue))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuEponMiTdmQueueConfig((S_EponIoctlTdmQueue *)&(ioctlTdmQueue));
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_ALARM_GET ==================== */
+	case MVEPON_IOCTL_ALARM_GET:
+		status = onuEponMiAlarmGet(&ioctlAlarm);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		if (copy_to_user((MV_U32 *)arg, &ioctlAlarm, sizeof(MV_U32))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_ROGUE_ONU_SET ==================== */
+	case MVEPON_IOCTL_ROGUE_ONU_SET:
+		if (copy_from_user(&ioctlRogueOnu, (S_EponIoctlRogueOnu *)arg, sizeof(S_EponIoctlRogueOnu))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		onuEponMiCfgMacTxEn(ioctlRogueOnu.enable, ioctlRogueOnu.macId);
+
+		ret = 0;
+		break;
+
+	case MVEPON_IOCTL_LLID_PM_CONFIG:
+		if (copy_from_user(&ioctlLlidPmConfig, (S_EponIoctlLlidPmConfig *)arg, sizeof(S_EponIoctlLlidPmConfig))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		status = onuEponApiLlidPmConfig(&ioctlLlidPmConfig);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	case MVEPON_IOCTL_LLID_PM_GET:
+		if (copy_from_user(&ioctlLlidMibCounters, (S_EponIoctlLlidMibCounters *)arg, sizeof(S_EponIoctlLlidMibCounters))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		status = onuEponApiLlidPmGet(&ioctlLlidMibCounters);
+		if (status != MV_OK)
+			goto ioctlErr;
+		if (copy_to_user((S_EponIoctlLlidMibCounters *)arg, &ioctlLlidMibCounters, sizeof(S_EponIoctlLlidMibCounters))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	case MVEPON_IOCTL_LLID_PM_RESET:
+		status = onuEponPmLlidPmReset();
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVEPON_IOCTL_LOID_AUTH ==================== */
+	case MVEPON_IOCTL_LOID_AUTH:
+		if (copy_from_user(&ioctlLoidAuth, (S_EponIoctlLoid *)arg, sizeof(S_EponIoctlLoid))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		onuEponMiCfgLoidAuth(INT_TO_MV_BOOL(ioctlLoidAuth.state), ioctlLoidAuth.macId);
+
+		ret = 0;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+ioctlErr:
+
+	return ret;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.h
new file mode 100644
index 0000000..327ec0d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsMI.h
@@ -0,0 +1,437 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsMI.h                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Management Interface           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_EPON_LINUX_KS_MNG_INTERFACE_H
+#define _ONU_EPON_LINUX_KS_MNG_INTERFACE_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define MVEPON_IOCTL_INIT          _IOW(MVPON_IOCTL_MAGIC, 1, unsigned int)
+#define MVEPON_IOCTL_FEC_CONFIG    _IOW(MVPON_IOCTL_MAGIC, 2, unsigned int)
+#define MVEPON_IOCTL_ENC_CONFIG    _IOW(MVPON_IOCTL_MAGIC, 3, unsigned int)
+#define MVEPON_IOCTL_ENC_KEY       _IOW(MVPON_IOCTL_MAGIC, 4, unsigned int)
+#define MVEPON_IOCTL_INFO          _IOR(MVPON_IOCTL_MAGIC, 5, unsigned int)
+#define MVEPON_IOCTL_PM            _IOR(MVPON_IOCTL_MAGIC, 6, unsigned int)
+#define MVEPON_IOCTL_OAM_TX        _IOW(MVPON_IOCTL_MAGIC, 7, unsigned int)
+#define MVEPON_IOCTL_DBA_CFG       _IOW(MVPON_IOCTL_MAGIC, 8, unsigned int)
+#define MVEPON_IOCTL_DBA_RPRT      _IOR(MVPON_IOCTL_MAGIC, 8, unsigned int)
+#define MVEPON_IOCTL_HOLDOVER_CFG  _IOW(MVPON_IOCTL_MAGIC, 9, unsigned int)
+#define MVEPON_IOCTL_HOLDOVER_RPRT _IOW(MVPON_IOCTL_MAGIC, 10, unsigned int)
+#define MVEPON_IOCTL_SILENCE       _IOW(MVPON_IOCTL_MAGIC, 11, unsigned int)
+#define MVEPON_IOCTL_P2P_SET       _IOW(MVPON_IOCTL_MAGIC, 12, unsigned int)
+#define MVEPON_IOCTL_P2P_FORCE_MODE_SET _IOW(MVPON_IOCTL_MAGIC, 13, unsigned int)
+#define MVEPON_IOCTL_TDM_QUE_CFG   _IOW(MVPON_IOCTL_MAGIC, 14, unsigned int)
+#define MVEPON_IOCTL_ALARM_GET     _IOR(MVPON_IOCTL_MAGIC, 15, unsigned int)
+#define MVEPON_IOCTL_ROGUE_ONU_SET _IOW(MVPON_IOCTL_MAGIC, 16, unsigned int)
+#define MVEPON_IOCTL_LOS_TIME      _IOW(MVPON_IOCTL_MAGIC, 17, unsigned int)
+#define MVEPON_IOCTL_TX_CONTROL    _IOW(MVPON_IOCTL_MAGIC, 18, unsigned int)
+#define MVEPON_IOCTL_POWER_SAVING  _IOW(MVPON_IOCTL_MAGIC, 19, unsigned int)
+#define MVEPON_IOCTL_CONTROL_SLEEP _IOW(MVPON_IOCTL_MAGIC, 20, unsigned int)
+#define MVEPON_IOCTL_LOID_AUTH     _IOW(MVPON_IOCTL_MAGIC, 21, unsigned int)
+#define MVEPON_IOCTL_LLID_PM_CONFIG     _IOW(MVPON_IOCTL_MAGIC, 22, unsigned int)
+#define MVEPON_IOCTL_LLID_PM_GET        _IOR(MVPON_IOCTL_MAGIC, 23, unsigned int)
+#define MVEPON_IOCTL_LLID_PM_RESET      _IOW(MVPON_IOCTL_MAGIC, 24, unsigned int)
+
+#define EPON_MAX_NUM_OF_MAC          (8)
+#define EPON_MAX_NUM_OF_QUEUE        (8)
+#define EPON_MAC_LEN                 (6)
+
+#define EPON_API_MAX_OAM_FRAME_SIZE      (512)
+/*db threshold set*/
+#define EPON_MIN_QUEUE_SET_NUMBER        (2)
+#define EPON_MAX_QUEUE_SET_NUMBER        (4)
+#define EPON_MAX_THRESHOLD_SET_RER_QUEUE (8)
+#define EPON_MAX_QUEUE                   (8)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	E_EPON_IOCTL_PM_RX  = 1,
+	E_EPON_IOCTL_PM_TX  = 2,
+	E_EPON_IOCTL_PM_SW  = 3,
+	E_EPON_IOCTL_PM_GPM = 4
+} E_EponIoctlPmSection;
+
+typedef enum {
+	E_EPON_IOCTL_MPCP_TX_FRAME_CNT             = 0,
+	E_EPON_IOCTL_MPCP_TX_ERROR_FRAME_CNT       = 1,
+	E_EPON_IOCTL_MAX_TX_SW_CNT
+} E_EponIoctlTxSwCnt;
+
+typedef enum {
+	E_EPON_IOCTL_MPCP_RX_FRAME_CNT             = 0,
+	E_EPON_IOCTL_MPCP_RX_ERROR_FRAME_CNT       = 1,
+	E_EPON_IOCTL_MPCP_REGISTER_ACK_CNT         = 2,
+	E_EPON_IOCTL_MPCP_REGISTER_NACK_CNT        = 3,
+	E_EPON_IOCTL_MPCP_REGISTER_DEREG_FRAME_CNT = 4,
+	E_EPON_IOCTL_MPCP_REGISTER_REREG_FRAME_CNT = 5,
+	E_EPON_IOCTL_MAX_RX_SW_CNT
+} E_EponIoctlRxSwCnt;
+
+typedef enum {
+	E_EPON_IOCTL_STD_MODE,
+	E_EPON_IOCTL_P2P_MODE,
+	E_EPON_IOCTL_MAX_MODE_NUM,
+} E_EponIoctlMode;
+
+typedef enum {
+	E_EPON_IOCTL_ENABLE_TX        = 0,
+	E_EPON_IOCTL_DISABLE_TX       = 1,
+	E_EPON_IOCTL_DISABLE_TX_DELAY = 2,
+} E_EponIoctlTxControl;
+
+typedef enum {
+	E_GPON_SLEEP_ACTION_DISABLE = 0,
+	E_GPON_SLEEP_ACTION_ENABLE  = 1,
+	E_GPON_SLEEP_ACTION_CONFIG  = 2,
+} E_GponSleepAction;
+
+typedef enum {
+	E_GPON_SLEEP_MODE_DO_NOTHING = 0,
+	E_GPON_SLEEP_MODE_TX         = 1,
+	E_GPON_SLEEP_MODE_TX_RX      = 2,
+} E_GponSleepMode;
+typedef enum {
+	LLIDPMCMD_STOP  = 0,
+	LLIDPMCMD_START = 1
+} E_EponIoctlLlidPmCmd;
+typedef enum {
+	LLIDPMDIRECTION_BIDI = 0,
+	LLIDPMDIRECTION_DS   = 1,
+	LLIDPMDIRECTION_US   = 2
+} E_EponIoctlLlidPmDirection;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+/* TX Counters */
+typedef struct {
+	MV_U32 ctrlRegReqFramesCnt;     /* Count number of register request frames transmitted     */
+	MV_U32 ctrlRegAckFramesCnt;     /* Count number of register acknowledge frames transmitted */
+	MV_U32 reportFramesCnt;         /* Count number of report frames transmitted               */
+	MV_U32 dataFramesCnt;           /* Count number of data frames transmitted                 */
+	MV_U32 txAllowedBytesCnt;       /* Count number of Tx Byte Allow counter                   */
+} S_EponIoctlTxPm;
+
+/* RX Counters */
+typedef struct {
+	MV_U32 fcsErrorFramesCnt;       /* Count number of received frames with FCS errors */
+	MV_U32 shortFramesCnt;          /* Count number of short frames received           */
+	MV_U32 longFramesCnt;           /* Count number of long frames received            */
+	MV_U32 dataFramesCnt;           /* Count number of data frames received            */
+	MV_U32 ctrlFramesCnt;           /* Count number of control frames received         */
+	MV_U32 reportFramesCnt;         /* Count number of report frames received          */
+	MV_U32 gateFramesCnt;           /* Count number of gate frames received            */
+} S_EponIoctlRxPm;
+
+/* SW Counters */
+typedef struct {
+	MV_U32 swTxCnt[E_EPON_IOCTL_MAX_TX_SW_CNT];
+	MV_U32 swRxCnt[E_EPON_IOCTL_MAX_RX_SW_CNT];
+} S_EponIoctlSwPm;
+
+/* GEM Counters */
+typedef struct {
+	MV_U32 grantValidCnt;                   /* Count number of valid grant                          */
+	MV_U32 grantMaxFutureTimeErrorCnt;      /* Count number of grant max future time error          */
+	MV_U32 minProcTimeErrorCnt;             /* Count number of min proc time error                  */
+	MV_U32 lengthErrorCnt;                  /* Count number of length error                         */
+	MV_U32 discoveryAndRegCnt;              /* Count number of discovery & register                 */
+	MV_U32 fifoFullErrorCnt;                /* Count number of fifo full error                      */
+	MV_U32 opcDiscoveryNotRegBcastCnt;      /* Count number of opc discoveryNotRegBcastCnt          */
+	MV_U32 opcRegisterNotDiscoveryCnt;      /* Count number of opc register not discovery           */
+	MV_U32 opcDiscoveryNotRegNotBcastCnt;   /* Count number of opc discovery not register not bcast */
+	MV_U32 opcDropGrantCnt;                 /* Count number of opc drop grant                       */
+	MV_U32 opcHiddenGrantCnt;               /* Count number of opc hidden grant                     */
+	MV_U32 opcBackToBackCnt;                /* Count number of opc back to back                     */
+} S_EponIoctlGpmPm;
+
+/* PM Counters */
+typedef struct {
+	MV_U32 macId;
+	MV_U32 section;
+	union {
+		S_EponIoctlRxPm rxCnt;
+		S_EponIoctlTxPm txCnt;
+		S_EponIoctlSwPm swCnt;
+		S_EponIoctlGpmPm gpmCnt;
+	};
+} S_EponIoctlPm;
+
+/* INFO */
+typedef struct {
+	MV_U32 macId;
+	MV_U32 onuEponState;                    /* ONU State                   */
+	MV_U32 onuEponPortState;                /* ONU Port State              */
+	MV_U32 onuEponSignalDetect;             /* ONU Signal Detect           */
+	MV_U32 onuEponDsSyncOkPcs;              /* ONU DS Sync OK - PCS        */
+	MV_U32 onuEponCtrlType;                 /* ONU Control Type            */
+	MV_U8 onuEponMacAddr[EPON_MAC_LEN];     /* ONU MAC Address             */
+	MV_U8 onuEponBcastAddr[EPON_MAC_LEN];   /* ONU MAC Broadcast Address   */
+	MV_U32 onuEponRxLLID;                   /* ONU Rx Packet Rx LLID Array */
+	MV_U32 onuEponTxLLID;                   /* ONU Rx Packet Tx LLID Array */
+	MV_U32 onuEponMode;                     /* ONU mode (EPON, P2P)        */
+	MV_U32 onuEponDbaMode;                  /* ONU dba mode (HW, SW)       */
+} S_EponIoctlInfo;
+
+typedef struct {
+	MV_U32 state;           /* Enable or disable this feature           */
+	MV_U32 queue;           /* DBA queue used to add bytes for OAM      */
+	MV_U32 byte_num;        /* byte number should be added to DBA queue */
+} S_EponOamDbaByte;
+
+typedef struct {
+	MV_U32 state;   /* Enable or disable this feature */
+	MV_U32 llid_bm; /* LLID mapping bitmap            */
+} S_EponHighPriTx;
+
+/* Init */
+typedef struct {
+	MV_U32 ponXvrBurstEnPolarity;
+	MV_U32 ponXvrPolarity;
+	MV_U32 p2pXvrBurstEnPolarity;
+	MV_U32 p2pXvrPolarity;
+	MV_U32 dgPolarity;
+	MV_U32 pkt2kSupported;
+	MV_U32 ponDbaMode;
+	MV_U32 oamFifoSize;
+	MV_U32 eoamRxQueue;
+	S_EponOamDbaByte dbaOamByte;
+	S_EponHighPriTx highPriTx;
+	MV_U8 macAddr[EPON_MAX_NUM_OF_MAC][EPON_MAC_LEN];
+} S_EponIoctlInit;
+
+/* FEC */
+typedef struct {
+	MV_U32 rxGenFecEn;
+	MV_U32 txGenFecEn;
+	MV_U32 txMacFecEn[EPON_MAX_NUM_OF_MAC];
+} S_EponIoctlFec;
+
+/* Encryption */
+typedef struct {
+	MV_U32 macId;
+	MV_U32 encEnable;
+	MV_U32 encKey;
+	MV_U32 encKeyIndex;
+} S_EponIoctlEnc;
+
+/* OAM Transmission */
+typedef struct {
+	MV_U32 length;
+	MV_U8 data[EPON_API_MAX_OAM_FRAME_SIZE];
+} S_EponOamFrame;
+
+typedef struct {
+	MV_U32 macId;
+	S_EponOamFrame oamFrame;
+} S_EponIoctlOamTx;
+
+/* DBA */
+typedef struct {
+	MV_U8 state;            /* Is threshold configuration active for the queue */
+	MV_U16 threshold;       /* Queue threshold: range 0 - 65535                */
+} S_EponDbaThreshold;
+
+typedef struct {
+	MV_U32 numOfQueueSets;
+	MV_U32 numOfQueues;
+	MV_U32 aggrThreshold;
+	S_EponDbaThreshold threshold[EPON_MAX_QUEUE_SET_NUMBER][EPON_MAX_THRESHOLD_SET_RER_QUEUE];
+} S_EponIoctlDbaLlid;
+
+typedef struct {
+	MV_U8 validLlid[EPON_MAX_NUM_OF_MAC];
+	S_EponIoctlDbaLlid dbaLlid[EPON_MAX_NUM_OF_MAC];
+} S_EponIoctlDba;
+
+/* Holdover */
+typedef struct {
+	MV_U32 holdoverState; /* 0 - Deactivate, 1 - Activate */
+	MV_U32 holdoverTime;
+} S_EponIoctlHoldOver;
+
+typedef struct {
+	uint16_t optical_los_time;
+	uint16_t mac_los_time;
+} S_EponIoctlLosTime;
+
+typedef struct {
+	uint16_t action;
+	uint16_t time;
+} S_EponIoctlTxControl;
+
+typedef struct {
+	uint8_t earlyWakeUp;
+	uint32_t maxSleepDuration;
+} S_EponIoctlPowerSaving;
+
+typedef struct {
+	uint8_t action;
+	uint8_t sleepMode;
+	uint32_t sleepDuration;
+	uint32_t waitDuration;
+} S_EponIoctlControlSleep;
+/* Silence */
+typedef struct {
+	MV_U32 silenceState; /* 0 - Deactivate, 1 - Activate */
+} S_EponIoctlSilence;
+
+typedef struct {
+	uint32_t tdmQueCnt[EPON_MAX_NUM_OF_MAC][EPON_MAX_NUM_OF_QUEUE];
+} S_EponIoctlTdmQueue;
+
+/* Rogue ONU */
+typedef struct {
+	uint32_t macId;
+	uint32_t enable;
+} S_EponIoctlRogueOnu;
+
+/* LLID MIB PM   */
+typedef struct {
+	E_EponIoctlLlidPmCmd command;
+	MV_U16 llid;
+	E_EponIoctlLlidPmDirection direction;
+} S_EponIoctlLlidPmConfig;
+
+typedef struct {
+	MV_U16 llid;
+	E_EponIoctlLlidPmDirection direction;
+	MV_U64 good_octets_received;
+	MV_U32 bad_octets_received;
+	MV_U32 mac_trans_error;
+	MV_U32 good_frames_received;
+	MV_U32 bad_frames_received;
+	MV_U32 broadcast_frames_received;
+	MV_U32 multicast_frames_received;
+	MV_U32 frames_64_octets;
+	MV_U32 frames_65_to_127_octets;
+	MV_U32 frames_128_to_255octets;
+	MV_U32 frames_256_to_511_octets;
+	MV_U32 frames_512_to_1023_octets;
+	MV_U32 frames_1024_to_max_octets;
+	MV_U64 good_octets_sent;
+	MV_U32 good_frames_sent;
+	MV_U32 multicast_frames_sent;
+	MV_U32 broadcast_frames_sent;
+	MV_U32 bad_crc_received;
+} S_EponIoctlLlidMibCounters;
+
+/* LODI authentication */
+typedef struct {
+	MV_U32 macId;
+	MV_U32 state;
+} S_EponIoctlLoid;
+
+typedef struct {
+	S_EponIoctlInit init;
+	S_EponIoctlInfo e_info;
+	S_EponIoctlPm e_pm;
+	S_EponIoctlFec fec;
+	S_EponIoctlEnc enc;
+	S_EponIoctlDba dba;
+	S_EponIoctlHoldOver holdover;
+	S_EponIoctlSilence silence;
+	S_EponIoctlTdmQueue tdmQueue;
+	S_EponIoctlRogueOnu rogueOnu;
+	S_EponIoctlLoid loidAuth;
+	S_EponIoctlLlidPmConfig llidPmConfig;
+	S_EponIoctlLlidMibCounters llidtMibCounters;
+	struct cdev cdev;
+} S_EponModuleCdev;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+MV_STATUS onuEponMngInterfaceCreate(void);
+MV_STATUS onuEponMngInterfaceRelease(void);
+void      onuEponMiNotifyCallback(MV_U32 onuState);
+
+MV_STATUS onuEponMiLosTimeConfig(S_EponIoctlLosTime *ioctlLosTime);
+MV_STATUS onuEponMiTxPowerControlConfig(S_EponIoctlTxControl *ioctlTxControl);
+MV_STATUS onuEponMiPowerSavingConfig(S_EponIoctlPowerSaving *ioctlPowerSaving);
+MV_STATUS onuEponMiControlSleepConfig(S_EponIoctlControlSleep *ioctlControlSleep);
+
+MV_STATUS mvP2PStart(void);
+MV_STATUS mvP2PStop(void);
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_LINUX_KS_MNG_INTERFACE_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.c
new file mode 100644
index 0000000..9ce599b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.c
@@ -0,0 +1,2887 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsUI.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON CLI functionality            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "eponOnuHeader.h"
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+#include "mvSysPonConfig.h"
+#endif
+#endif /* PON_FPGA */
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/perf/epon/eponOnuLnxKsUI.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern MV_U32 llidQueueState[8][4][8];
+extern MV_U32 llidQueueThreshold[8][4][8];
+extern MV_U32 llidNumOfQueuesets[8];
+extern MV_U32 llidNumOfQueues[8];
+extern MV_U32 llidNumOfReportBytes[8];
+
+extern MV_U32 g_OnuEponRandomCount;
+extern MV_U32 g_OnuEponRandomValues[];
+
+extern MV_U32 regRandomMaskThreshold;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_BOOL infoEponCntReadClearInd = MV_TRUE;
+
+/* ========================================================================== */
+/*                            Info Commands                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponUiInfoShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu information
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiInfoShow(char *buf)
+{
+	MV_STATUS status;
+	S_EponIoctlInfo info[EPON_MAX_MAC_NUM];
+	MV_U8           *stateDesc[] = { "", "Pending", "Active" };
+	int off = 0;
+	int macId;
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = onuEponApiInformationGet(&info[macId], macId);
+		if (status != MV_OK) {
+			off += mvOsSPrintf(buf + off, "Failed read mac information!!!\n");
+			return off;
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "ONT Information:\n");
+	off += mvOsSPrintf(buf + off, "---------------------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     State    Ether    Unicast             Bcast               Tx LLId  Tx LLId  \n");
+	off += mvOsSPrintf(buf + off, "              Type     Mac Addr            Mac Addr                              \n");
+	off += mvOsSPrintf(buf + off, " MAC                                                                             \n");
+	off += mvOsSPrintf(buf + off, "---------------------------------------------------------------------------------\n");
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		off += mvOsSPrintf(buf + off, "[%02d] %-8s %8x %02x:%02x:%02x:%02x:%02x:%02x %02x:%02x:%02x:%02x:%02x:%02x %8u %8u\n",
+				   macId,
+				   stateDesc[info[macId].onuEponState],
+				   info[macId].onuEponCtrlType,
+				   info[macId].onuEponMacAddr[0], info[macId].onuEponMacAddr[1],
+				   info[macId].onuEponMacAddr[2],
+				   info[macId].onuEponMacAddr[3], info[macId].onuEponMacAddr[4],
+				   info[macId].onuEponMacAddr[5],
+				   info[macId].onuEponBcastAddr[0], info[macId].onuEponBcastAddr[1],
+				   info[macId].onuEponBcastAddr[2],
+				   info[macId].onuEponBcastAddr[3], info[macId].onuEponBcastAddr[4],
+				   info[macId].onuEponBcastAddr[5],
+				   info[macId].onuEponTxLLID,
+				   info[macId].onuEponRxLLID);
+	}
+	off += mvOsSPrintf(buf + off, "--------------------------------------------------\n\r");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiAlarmShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu alarms
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiAlarmShow(char *buf)
+{
+	MV_U32 alarm[2];
+	MV_U8  *statusText[] = { "OFF", "ON " };
+	int off = 0;
+
+	onuEponAlarmGet(alarm);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "-------------\n");
+	off += mvOsSPrintf(buf + off, "|ONU ALARMS |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+	off += mvOsSPrintf(buf + off, "| XVR SD    | SERDES SD |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+	off += mvOsSPrintf(buf + off, "| %9s | %9s |\n", statusText[alarm[0]], statusText[alarm[1]]);
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiDebugReadReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function test requested address space
+**
+**  PARAMETERS:  MV_U32 readOffset
+**               MV_U32 readEntry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiDebugReadReg(MV_U32 readOffset, MV_U32 readEntry)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+	MV_U32 regValue;
+
+	regValue = MV_REG_READ((MV_EPON_MAC_REGS_BASE) + readOffset + (readEntry * sizeof(MV_U32)));
+
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "Read register offset 0x%x, entry %d = [0x%08X]\n\r", readOffset, readEntry, regValue);
+#endif
+#endif  /* PON_FPGA */
+}
+
+/*******************************************************************************
+**
+**  onuEponUiDebugWriteReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function test requested address space
+**
+**  PARAMETERS:  MV_U32 writeOffset
+**               MV_U32 writeEntry
+**               MV_U32 regValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiDebugWriteReg(MV_U32 writeOffset, MV_U32 writeEntry, MV_U32 regValue)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+	MV_REG_WRITE((MV_EPON_MAC_REGS_BASE) + writeOffset + (writeEntry * sizeof(MV_U32)), regValue);
+#endif
+#endif  /* PON_FPGA */
+
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "Write  register offset 0x%x, entry %d = [0x%08X]\n\r", writeOffset, writeEntry, regValue);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiInfoHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print info help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiInfoHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[HEX]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [Offset] [Entry]           > readReg   - read onu reg\n");
+	off += mvOsSPrintf(buf + off, " echo [Offset] [Entry] [Value]   > writeReg  - write onu reg\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat info  - dump onu information\n");
+	off += mvOsSPrintf(buf + off, " cat alarm - dump onu alarms\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Pm Commands                                     */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuEponUiRxCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu rx counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiRxCountersShow(char *buf)
+{
+	MV_STATUS status;
+	S_EponIoctlRxPm rxCounters;
+	int off = 0;
+
+	status = onuEponApiRxPmGet(&rxCounters, infoEponCntReadClearInd, 0);
+	if (status != MV_OK) {
+		off += mvOsSPrintf(buf + off, "Failed read Rx pm information!!!\n");
+		return off;
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "Rx Counters\n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     FCS      Short    Long     Data     Ctrl     Rprt     Gate    \n");
+	off += mvOsSPrintf(buf + off, "     Frames   Frames   Frames   Frames   Frames   Frames   Frames  \n");
+	off += mvOsSPrintf(buf + off, " MAC Rece     Rece     Rece     Rece     Rece     Rece     Rece    \n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "[00] %8u %8u %8u %8u %8u %8u %8u\n",
+			   rxCounters.fcsErrorFramesCnt,
+			   rxCounters.shortFramesCnt,
+			   rxCounters.longFramesCnt,
+			   rxCounters.dataFramesCnt,
+			   rxCounters.ctrlFramesCnt,
+			   rxCounters.reportFramesCnt,
+			   rxCounters.gateFramesCnt);
+	off += mvOsSPrintf(buf + off, "-------------------------------------------------------------------\n\r");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiTxCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu tx counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiTxCountersShow(char *buf)
+{
+	MV_STATUS status;
+	S_EponIoctlTxPm txCounters[EPON_MAX_MAC_NUM];
+	int macId;
+	int off = 0;
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = onuEponApiTxPmGet(&txCounters[macId], infoEponCntReadClearInd, macId);
+		if (status != MV_OK) {
+			off += mvOsSPrintf(buf + off, "Failed read Tx pm information!!!\n");
+			return off;
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "Tx Counters\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     Register Register Report   Data     Tx Byte  \n");
+	off += mvOsSPrintf(buf + off, "     Request  Ack      Frames   Frames   Allow    \n");
+	off += mvOsSPrintf(buf + off, " MAC Frames   Frames                              \n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------------\n");
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		off += mvOsSPrintf(buf + off, "[%02d] %8u %8u %8u %8u %8u\n",
+				   macId,
+				   txCounters[macId].ctrlRegReqFramesCnt,
+				   txCounters[macId].ctrlRegAckFramesCnt,
+				   txCounters[macId].reportFramesCnt,
+				   txCounters[macId].dataFramesCnt,
+				   txCounters[macId].txAllowedBytesCnt);
+	}
+	off += mvOsSPrintf(buf + off, "--------------------------------------------------\n\r");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiSwCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu sw counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiSwCountersShow(char *buf)
+{
+	MV_STATUS status;
+	S_EponIoctlSwPm swCounters[EPON_MAX_MAC_NUM];
+	int macId;
+	int off = 0;
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = onuEponApiSwPmGet(&swCounters[macId], infoEponCntReadClearInd, macId);
+		if (status != MV_OK) {
+			off += mvOsSPrintf(buf + off, "Failed read Sw pm information!!!\n");
+			return off;
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "Sw Counters\n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     Total    Total    Total    Total    Total    Total    Total    Total   \n");
+	off += mvOsSPrintf(buf + off, "     MPC Tx   MPC Tx   MPC Rx   MPC Rx   MPC Reg  MPC Reg  MPC Reg  MPC Reg \n");
+	off += mvOsSPrintf(buf + off, "     Frames   Error    Frames   Error    Ack      Nack     De-Reg   Re-Reg  \n");
+	off += mvOsSPrintf(buf + off, " MAC          Frames            Frames   Frames   Frames   Frames   Frames  \n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------------------------\n");
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		off += mvOsSPrintf(buf + off, "[%02d] %8u %8u %8u %8u %8u %8u %8u %8u\n",
+				   macId,
+				   swCounters[macId].swTxCnt[TOTAL_MPCP_TX_FRAME_CNT],
+				   swCounters[macId].swTxCnt[TOTAL_MPCP_TX_ERROR_FRAME_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_RX_FRAME_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_RX_ERROR_FRAME_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_REGISTER_ACK_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_REGISTER_NACK_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_REGISTER_DEREG_FRAME_CNT],
+				   swCounters[macId].swRxCnt[TOTAL_MPCP_REGISTER_REREG_FRAME_CNT]);
+	}
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiGpmCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu gpm counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiGpmCountersShow(char *buf)
+{
+	MV_STATUS status;
+	S_EponIoctlGpmPm gpmCounters[EPON_MAX_MAC_NUM];
+	int macId;
+	int off = 0;
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		status = onuEponApiGpmPmGet(&gpmCounters[macId], infoEponCntReadClearInd, macId);
+		if (status != MV_OK) {
+			off += mvOsSPrintf(buf + off, "Failed read Gpm pm information!!!\n");
+			return off;
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "GPM Counters\n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     Valid    Grant    Min Proc Length   Discover Fifo    \n");
+	off += mvOsSPrintf(buf + off, "     Grant    Max Time Time     Error    And      Full    \n");
+	off += mvOsSPrintf(buf + off, " MAC          Error    Error             Register Error   \n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		off += mvOsSPrintf(buf + off, "[%02d] %8u %8u %8u %8u %8u %8u\n",
+				   macId,
+				   gpmCounters[macId].grantValidCnt,
+				   gpmCounters[macId].grantMaxFutureTimeErrorCnt,
+				   gpmCounters[macId].minProcTimeErrorCnt,
+				   gpmCounters[macId].lengthErrorCnt,
+				   gpmCounters[macId].discoveryAndRegCnt,
+				   gpmCounters[macId].fifoFullErrorCnt);
+	}
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "     OPC      OPC      OPC      OPC      OPC      OPC     \n");
+	off += mvOsSPrintf(buf + off, "     Discover Register Discover Drop     Hidden   Back to \n");
+	off += mvOsSPrintf(buf + off, "     Not      Not      Not      Grant    Grant    Back    \n");
+	off += mvOsSPrintf(buf + off, "     Register Discover Register                           \n");
+	off += mvOsSPrintf(buf + off, "     Bcast             Or Bcast                           \n");
+	off += mvOsSPrintf(buf + off, " MAC                                                      \n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+
+	for (macId = 0; macId < EPON_MAX_MAC_NUM; macId++) {
+		off += mvOsSPrintf(buf + off, "[%02d] %8u %8u %8u %8u %8u %8u\n",
+				   macId,
+				   gpmCounters[macId].opcDiscoveryNotRegBcastCnt,
+				   gpmCounters[macId].opcRegisterNotDiscoveryCnt,
+				   gpmCounters[macId].opcDiscoveryNotRegNotBcastCnt,
+				   gpmCounters[macId].opcDropGrantCnt,
+				   gpmCounters[macId].opcHiddenGrantCnt,
+				   gpmCounters[macId].opcBackToBackCnt);
+	}
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n\r");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiAllCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print all onu counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiAllCountersShow(char *buf)
+{
+	int off = 0;
+
+	off += onuEponUiRxCountersShow(buf);
+	off += onuEponUiTxCountersShow(buf + off);
+	off += onuEponUiSwCountersShow(buf + off);
+	off += onuEponUiGpmCountersShow(buf + off);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiPmHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print pm help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiPmHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[DEC]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [state]               > cntRdClrState - onu counters flag, Read[0], "
+			   "Read Clear[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [llid][Queue][#Bytes] > addDbaBytesPerLlidQueue - add bytes per LLID "
+			   "/ Queue\n");
+	off += mvOsSPrintf(buf + off, " echo [llid][#Bytes]        > addDbaBytesPerLlidFifo - add bytes per LLID FIFO\n");
+	off += mvOsSPrintf(buf + off, " echo [llid][#Bytes]        > addDbaBytesPerLlidFifo - add bytes per LLID FIFO\n");
+	off += mvOsSPrintf(buf + off, " echo [llid] [dirn]         > startLlidMibPm - Start LLID MIB PM. llid: 0-7, dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, " echo [llid] [dirn]         > stopLlidMibPm  - Stop  LLID MIB PM. llid: 0-7, dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, " echo [dummy]               > resetLlidMibPm - Reset LLID MIB PM\n");
+	off += mvOsSPrintf(buf + off, " echo [llid] [dirn]         > getLlidMibPm   - Get LLID MIB counters. llid: 0-7, dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat rxCnt                    - dump Rx counters\n");
+	off += mvOsSPrintf(buf + off, " cat txCnt                    - dump Tx counters\n");
+	off += mvOsSPrintf(buf + off, " cat swCnt                    - dump Sw counters\n");
+	off += mvOsSPrintf(buf + off, " cat gpmCnt                   - dump GPM counters\n");
+	off += mvOsSPrintf(buf + off, " cat allCnt                   - dump All counters\n");
+	off += mvOsSPrintf(buf + off, " cat showDbaBytesPerLlidQueue - dump byres addition per LLID / Queue\n");
+	off += mvOsSPrintf(buf + off, " cat showDbaBytesPerLlidFifo  - dump byres addition per LLID FIFO\n");
+	off += mvOsSPrintf(buf + off, " cat showRandom               - dump random generator counters\n");
+	off += mvOsSPrintf(buf + off, " cat showPcsStat              - dump accumulates PCS statistics counters\n");
+	off += mvOsSPrintf(buf + off, " cat showLlidMibPmDb          - display LLIDs enabled for MIB PM\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCountersReadClearFlag
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu clear counters flag
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCountersReadClearFlag(MV_BOOL clear)
+{
+	infoEponCntReadClearInd = clear;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiAddLlidQueueBytes
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function add bytes for LLID queue for DBA report
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiAddLlidQueueBytes(MV_U32 llId, MV_U32 queueId, MV_U32 counter)
+{
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE)
+		onuEponPmDbaAddBytePerLlidAndQueue(llId, queueId, counter);
+	else
+		printk(KERN_INFO "HW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiAddLlidQueueBytes
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function show bytes added for LLID queue for DBA report
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiShowLlidQueueBytes(char *buf)
+{
+	MV_U32 llldIndex;
+	MV_U32 queueIndex;
+	MV_U32 counter;
+	int off = 0;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "Additional Bytes per Queue\n");
+		off += mvOsSPrintf(buf + off, "---------------------------------------------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "LLID Queue0   Queue1   Queue2   Queue3   Queue4   Queue5   Queue6   Queue7  \n");
+
+		for (llldIndex = 0; llldIndex < EPON_MAX_MAC_NUM; llldIndex++) {
+			off += mvOsSPrintf(buf + off, "[%02d]", llldIndex);
+
+			for (queueIndex = 0; queueIndex < EPON_MAX_QUEUE; queueIndex++) {
+				counter = onuEponPmDbaAddBytePerLlidAndQueueGet(llldIndex, queueIndex);
+				off += mvOsSPrintf(buf + off, " %8u", counter);
+			}
+			off += mvOsSPrintf(buf + off, "\n");
+		}
+
+		off += mvOsSPrintf(buf + off, "---------------------------------------------------------------------------\n");
+	} else
+		off += mvOsSPrintf(buf + off, "HW DBA Working Mode\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiAddLlidFifoBytes
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function add bytes for LLID FIFO for DBA report
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiAddLlidFifoBytes(MV_U32 llId, MV_U32 counter)
+{
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE)
+		onuEponPmDbaAddBytePerLlidFifo(llId, counter);
+	else
+		printk(KERN_INFO "HW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiShowLlidFifoBytes
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function show bytes added for queueset FIFO for DBA report
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiShowLlidFifoBytes(char *buf)
+{
+	MV_U32 llldIndex;
+	MV_U32 counter;
+	int off = 0;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "Additional Bytes per LLID FIFO\n");
+		off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "LLID0     LLID1     LLID2     LLID3     LLID4     LLID5     LLID6     LLID7   \n");
+
+		for (llldIndex = 0; llldIndex < EPON_MAX_MAC_NUM; llldIndex++) {
+			counter = onuEponPmDbaAddBytePerLlidFifoGet(llldIndex);
+			off += mvOsSPrintf(buf + off, "%8u  ", counter);
+		}
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+	} else
+		off += mvOsSPrintf(buf + off, "HW DBA Working Mode\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiShowRandom
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function show random generation counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiShowRandom(char *buf)
+{
+	int off = 0;
+	int i;
+	MV_U32 randomShift = 0;
+	MV_U32 randomRange = 0;
+
+	off += mvOsSPrintf(buf + off, "\n");
+
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "onuEponPmRandomGet was called %d times ", g_OnuEponRandomCount);
+
+	if (g_OnuEponRandomCount != 0) {
+		off += mvOsSPrintf(buf + off, "and the following random values were generated:");
+		for (i = 0; i < g_OnuEponRandomCount; i++) {
+			if ((i % 4) == 0) /* 4 values in one row */
+				off += mvOsSPrintf(buf + off, "\n");
+			off += mvOsSPrintf(buf + off, "0x%08x\t", g_OnuEponRandomValues[i]);
+		}
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "The same random values after processing:");
+		for (i = 0; i < g_OnuEponRandomCount; i++) {
+			if ((i % 4) == 0) /* 4 values in one row */
+				off += mvOsSPrintf(buf + off, "\n");
+
+			randomShift = ((g_OnuEponRandomValues[i] >> 16) & 0xF);
+			randomRange = ((g_OnuEponRandomValues[i] >> randomShift) & regRandomMaskThreshold);
+			off += mvOsSPrintf(buf + off, "%04d\t", randomRange);
+		}
+		off += mvOsSPrintf(buf + off, "\n");
+	} else
+		off += mvOsSPrintf(buf + off, ", no random values were generated\n");
+
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiShowPcsStat
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function show PCS statistics
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiShowPcsStat(char *buf)
+{
+	S_PcsPm statCounters;
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+
+	onuEponPmPcsPmGet(&statCounters);
+
+	off += mvOsSPrintf(buf + off, "Accumulated counter values in DB:\n");
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "legalFrameCnt                     0x%08x\n", statCounters.legalFrameCnt);
+	off += mvOsSPrintf(buf + off, "maxFrameSizeErrCnt                0x%08x\n", statCounters.maxFrameSizeErrCnt);
+	off += mvOsSPrintf(buf + off, "parityLenErrCnt                   0x%08x\n", statCounters.parityLenErrCnt);
+	off += mvOsSPrintf(buf + off, "longGateErrCnt                    0x%08x\n", statCounters.longGateErrCnt);
+	off += mvOsSPrintf(buf + off, "protocolErrCnt                    0x%08x\n", statCounters.protocolErrCnt);
+	off += mvOsSPrintf(buf + off, "minFrameSizeErrCnt                0x%08x\n", statCounters.minFrameSizeErrCnt);
+	off += mvOsSPrintf(buf + off, "legalFecFrameCnt                  0x%08x\n", statCounters.legalFecFrameCnt);
+	off += mvOsSPrintf(buf + off, "legalNonFecFrameCnt               0x%08x\n", statCounters.legalNonFecFrameCnt);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print cfg help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuEponUiCfgHelpShow(char *buf)
+{
+	int off = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[HEX]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [enable]        > rxEn            - onu RX enbale, Disable[0], Enable[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [enable][macId] > txEn            - onu mac TX enbale, Disable[0], Enable[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [enable]        > ctrlTimerEn     - control timer for  reception of MPCP "
+			   "/ GATES, Disable[0], Enable[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [interval]      > ctrlTimerVal    - control timer interval\n");
+	off += mvOsSPrintf(buf + off, " echo [limit][mask]   > ctrlTimerRandom - control timer random reset, expire limit"
+			   " and expire duration\n");
+	off += mvOsSPrintf(buf + off, " echo [queue][Threshold][llid]\n");
+	off += mvOsSPrintf(buf + off, "                      > dbaHwParamsCfg  - configuration of HW DBA queues "
+			   "(Max Threshold 0xFFFF)\n");
+	off += mvOsSPrintf(buf + off, " echo [interval]      > dbaSwIntervalCfg- configure SW report interval\n");
+	off += mvOsSPrintf(buf + off, " echo [#qset][qBitMap][T0][T1][T2]\n");
+	off += mvOsSPrintf(buf + off, "                      > dbaSwParamsCfg  - simulate configuration of SW DBA "
+			   "queues for LLID 0\n");
+	off += mvOsSPrintf(buf + off, " echo [qset][queue]   > dbaSwOptionCfg  - configure SW report direction [0]normal"
+			   " [1]reverse\n");
+	off += mvOsSPrintf(buf + off, " echo [time][state]   > holdoverDebug   - simulate configuration of Holdover\n");
+	off += mvOsSPrintf(buf + off, " echo [state]         > silenceMode     - Set Silence Mode\n");
+	off += mvOsSPrintf(buf + off, " echo [state]         > silenceSim      - simulate Silence Mode\n");
+	off += mvOsSPrintf(buf + off, " echo [dummy]         > dgDebug         - simulate reception of Dying Gasp "
+			   "Interrupt\n");
+	off += mvOsSPrintf(buf + off, " echo [#Queue][Thresh]> dgCfg           - configure Dying Gasp DBA report\n");
+	off += mvOsSPrintf(buf + off, " echo [module][Level][Options]   > printMask - change printing options\n");
+	off += mvOsSPrintf(buf + off, " echo [action][time]  > txPowerControl  - action(0:enable,1:disable,2:shut down then enable)\n");
+	off += mvOsSPrintf(buf + off, " echo [enable][time]  > powerSaving     - configure early wakeup and max sleep duration\n");
+	off += mvOsSPrintf(buf + off, " echo [action][mode][time][time] > sleepControl - configure sleep/wakeup parameters\n");
+	off += mvOsSPrintf(buf + off, " echo [patternMSB][pattern][patternLSB]\n");
+	off += mvOsSPrintf(buf + off, "                      > prbsUserDefinedPattern - 80bit user data: 16bit patternMLSB + 32bit pattern + 32bit patternLSB\n");
+	off += mvOsSPrintf(buf + off, " echo [enable][pattern][burst][duration][period] \n");
+	off += mvOsSPrintf(buf + off, "                      > prbsPreDefinedPattern  - start enable[1] or stop [0] transmission of\n");
+	off += mvOsSPrintf(buf + off, "                                           pattern: 0x1-1T, 0x2-2T, 0x5-User, 0x80-PRBS-7, 0x81-PRBS-9, 0x82-PRBS-15, 0x83-PRBS-23\n");
+	off += mvOsSPrintf(buf + off, "                                           burst: 0-static, 1-periodic\n");
+	off += mvOsSPrintf(buf + off, " echo [CPU Rx queue]  > eoamChannelAdd  - Add EPON OAM channel\n");
+	off += mvOsSPrintf(buf + off, " echo 0               > eoamChannelDel  - Delete EPON OAM channel\n");
+#ifdef PON_A0
+	off += mvOsSPrintf(buf + off, " echo [state]         > highPriTxStateSet- Set high priority TX state, 0:disable, 1:enable\n");
+	off += mvOsSPrintf(buf + off, " echo [llid_bm]       > highPriTxMapSet - Set LLID bitmap to LLID0\n");
+#endif
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " echo [latency][size]  > pcsFrameLimits   - Configure PCS Frame Size limits\n");
+		off += mvOsSPrintf(buf + off, " echo [threshold]      > rxDataFifoThresh - Configure RX Parser Data FIFO threshold\n");
+		off += mvOsSPrintf(buf + off, " echo [pkt2kSupported] > pkt2kEn - Configure 2K packet supported\n");
+		off += mvOsSPrintf(buf + off, " echo [polarity][width]> timeOfDayInt     - Configure Time of Day Interrupt width\n");
+		off += mvOsSPrintf(buf + off, " echo [time]           > txmPowerUpTime   - Configure TXM Power Up Time\n");
+		off += mvOsSPrintf(buf + off, " echo [txMask][txP][serdesP][xvrP][burstEn] > ddmTxPolarity - Configure  DDM Polarity settings\n");
+		off += mvOsSPrintf(buf + off, " echo [BM][QS][Mode]   > rpmReportCfg     - Configure RPM Report settings\n");
+		off += mvOsSPrintf(buf + off, " echo [BM][valid(0|1)] > utmActTxBitmap   - Configure General UTM Active TX Bitmap\n");
+		off += mvOsSPrintf(buf + off, " echo [0|1]            > legacyMode       - Config legacyMode ON/OFF\n");
+	}
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat printMask         - dump printing options\n");
+	off += mvOsSPrintf(buf + off, " cat dbaSwCfgPrint     - dump DBA cfg\n");
+	off += mvOsSPrintf(buf + off, " cat prbsUserPattern   - dump PRBS user defined pattern\n");
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " cat pcsFrameLimits    - dump PCS Frame Size Limits\n");
+		off += mvOsSPrintf(buf + off, " cat rxDataFifoThresh  - dump RX Parser Data FIFO threshold\n");
+		off += mvOsSPrintf(buf + off, " cat pkt2kEn           - dump 2K packet supported registers\n");
+		off += mvOsSPrintf(buf + off, " cat timeOfDayInt      - dump Time of Day Interrupt settings\n");
+		off += mvOsSPrintf(buf + off, " cat txmPowerUpTime    - dump TXM Power Up Time settings\n");
+		off += mvOsSPrintf(buf + off, " cat dbaSwForceMode    - show dba SW Force Mode config\n");
+		off += mvOsSPrintf(buf + off, " cat eoamChannelShow   - show EPON OAM channel\n");
+#ifdef PON_A0
+		off += mvOsSPrintf(buf + off, " cat highPriTxShow     - show high priority TX\n");
+#endif
+	}
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCountersReadClearFlag
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu RX enable
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgMacRxEn(MV_U32 enable)
+{
+	mvOnuEponMacOnuRxEnableSet(enable);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgMacTxEn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac TX enable
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgMacTxEn(MV_U32 enable, MV_U32 macId)
+{
+	onuEponMiCfgMacTxEn(enable, macId);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgMpcpTimerEn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac MPCP timer enable
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgMpcpTimerEn(MV_U32 enable)
+{
+	onuEponIsrTimerMpcpStateSet((enable == 1) ? (MV_TRUE) : (MV_FALSE));
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgMpcpTimerVal
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac MPCP timer enable
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgMpcpTimerVal(MV_U32 value)
+{
+	onuEponIsrTimerMpcpIntervalSet(value);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgMpcpTimerRandom
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config onu mac MPCP timer random reset
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgMpcpTimerRandom(MV_U32 limit, MV_U32 mask)
+{
+	onuEponIsrTimerMpcpRandomResetSet(limit, mask);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaHwDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure HW DBA queues thresholds for LLID 0
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDbaHwDebug(MV_U32 queueId, MV_U32 threshold, MV_U32 llid)
+{
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_HW_RPRT_MODE)
+		mvOnuEponMacTxmCppReportQueueX(queueId, (threshold / 64), llid);
+	else
+		printk(KERN_INFO "SW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaSwRprtDir
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure DBA SW report direction [0]Normal [1]Reverse
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDbaSwRprtDir(MV_U32 queueSetDir, MV_U32 queueDir)
+{
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		onuEponDbOnuDbaSwModeQueuesetDirSet(queueSetDir);
+		onuEponDbOnuDbaSwModeQueueDirSet(queueDir);
+	} else
+		printk(KERN_INFO "HW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaSwDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function simulate configuration of DBA queues for LLID 0
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDbaSwDebug(MV_U32 queueSet, MV_U32 queueBitMap,
+			    MV_U32 queueSet0, MV_U32 queueSet1, MV_U32 queueSet2, MV_U32 queueSet3)
+{
+	MV_U32 idx;
+	MV_U32 qsetidx;
+	MV_U32 numOfQueues = 0;
+	static S_EponIoctlDba ioctlDba;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		memset(&ioctlDba, 0, sizeof(S_EponIoctlDba));
+
+		for (qsetidx = 0; qsetidx < queueSet; qsetidx++) {
+			for (idx = 0; idx < EPON_MAX_QUEUE; idx++) {
+				if (queueBitMap & (1 << idx)) {
+					if (qsetidx == 0) {
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].state     = 1;
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].threshold = queueSet0;
+					} else if (qsetidx == 1) {
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].state     = 1;
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].threshold = queueSet1;
+					} else if (qsetidx == 2) {
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].state     = 1;
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].threshold = queueSet2;
+					} else if (qsetidx == 3) {
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].state     = 1;
+						ioctlDba.dbaLlid[0].threshold[qsetidx][idx].threshold = queueSet3;
+					}
+
+					if (qsetidx == 0) numOfQueues++;
+				}
+			}
+		}
+
+		ioctlDba.validLlid[0]              = 1;
+		ioctlDba.dbaLlid[0].numOfQueueSets = queueSet;
+		ioctlDba.dbaLlid[0].numOfQueues    = numOfQueues;
+
+		onuEponMiDbaConfig(&ioctlDba);
+	} else
+		printk(KERN_INFO "HW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDgCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure DG DBA report
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDgCfg(MV_U32 numOfQueue, MV_U32 queueReport)
+{
+	onuEponPonMngDbaDgSwRprtCfg(numOfQueue, queueReport);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaSwInterval
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure Sw DBA interval
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDbaSwInterval(MV_U32 interval)
+{
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE)
+		onuEponDbOnuSwRprtMacTimerIntervalSet(interval);
+	else
+		printk(KERN_INFO "HW DBA Working Mode\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaCfgPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print configuration of DBA queues for LLID 0
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgDbaCfgPrint(char *buf)
+{
+	MV_U32 llidIdx;
+	MV_U32 queueSetIdx;
+	MV_U32 queueIdx;
+	MV_U32 threshold;
+	MV_U32 state;
+	MV_U32 numOfQueueSets;
+	MV_U32 numOfQueues;
+	int off = 0;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+			if (onuEponDbOnuDbaLlidActiveStatusGet(llidIdx) == ONU_DBA_ACTIVE_LLID) {
+				numOfQueueSets = onuEponDbOnuDbaNumOfQueuesetGet(llidIdx);
+				numOfQueues    = onuEponDbOnuDbaNumOfQueuesGet(llidIdx);
+
+				off += mvOsSPrintf(buf + off, "LLID[%d]: #Queuesets = (%d), #Queues = (%d)\n",
+						   llidIdx, numOfQueueSets, numOfQueues);
+
+				for (queueSetIdx = 0; queueSetIdx < numOfQueueSets; queueSetIdx++) {
+					off += mvOsSPrintf(buf + off, "Queueset[%d]: Queues:", queueSetIdx);
+
+					/* Queue Id */
+					/* ======== */
+					for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++) {
+						onuEponDbOnuDbaQueueThresholdGet(&threshold, &state, queueIdx, queueSetIdx, llidIdx);
+
+						off += mvOsSPrintf(buf + off, " [%d-%3s-0x%04x]",
+								   queueIdx, ((state == 0) ? "off" : "on"), ((state == 0) ? 0 : threshold));
+					}
+
+					off += mvOsSPrintf(buf + off, "\n");
+				}
+			}
+		}
+	} else
+		off += mvOsSPrintf(buf + off, "HW DBA Working Mode\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaStaticCfgPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print static configuration of DBA info
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgDbaStaticCfgPrint(char *buf)
+{
+	MV_U32 llidIdx;
+	MV_U32 queueSetIdx;
+	MV_U32 queueIdx;
+	MV_U32 threshold;
+	MV_U32 state;
+	MV_U32 numOfQueueSets;
+	MV_U32 numOfQueues;
+	int off = 0;
+
+	if (onuEponDbOnuDbaModeGet() == ONU_DBA_SW_RPRT_MODE) {
+		for (llidIdx = 0; llidIdx < EPON_MAX_MAC_NUM; llidIdx++) {
+			if (onuEponDbOnuDbaLlidActiveStatusGet(llidIdx) == ONU_DBA_ACTIVE_LLID) {
+				numOfQueueSets = onuEponDbOnuDbaNumOfQueuesetGet(llidIdx);
+				numOfQueues    = onuEponDbOnuDbaNumOfQueuesGet(llidIdx);
+
+				off += mvOsSPrintf(buf + off, "LLID[%d]: #Queuesets = (%d), #Queues = (%d)\n",
+						   llidIdx, numOfQueueSets, numOfQueues);
+
+				for (queueSetIdx = 0; queueSetIdx < numOfQueueSets; queueSetIdx++) {
+					off += mvOsSPrintf(buf + off, "Queueset[%d]: Queues:", queueSetIdx);
+
+					/* Queue Id */
+					/* ======== */
+					for (queueIdx = 0; queueIdx < EPON_MAX_QUEUE; queueIdx++) {
+						onuEponDbOnuDbaQueueThresholdGet(&threshold, &state,
+							queueIdx, queueSetIdx, llidIdx);
+
+						off += mvOsSPrintf(buf + off, " [%d-%3s-0x%04x]",
+								   queueIdx, ((state == 0) ? "off" : "on"),
+								   ((state == 0) ? 0 : threshold));
+					}
+
+					off += mvOsSPrintf(buf + off, "\n");
+				}
+			}
+		}
+	} else
+		off += mvOsSPrintf(buf + off, "HW DBA Working Mode\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgPrbsUserPattern
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print PRBS user defined pattern
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgPrbsUserPattern(char *buf)
+{
+	MV_U32 userPattern[3];
+	int off = 0;
+
+	mvOnuPonMacPrbsUserDefinedPatternGet(userPattern);
+
+	off += mvOsSPrintf(buf + off, "PRBS User Pattern 0x%4x%8x%8x\n",
+			   userPattern[2], userPattern[1], userPattern[0]);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgHoldoverDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function simulate configuration of Holdover
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgHoldoverDebug(MV_U32 time, MV_U32 state)
+{
+	S_EponIoctlHoldOver ioctlHoldover;
+
+	ioctlHoldover.holdoverState = state;
+	ioctlHoldover.holdoverTime  = time;
+
+	onuEponMiHoldoverConfig(&ioctlHoldover);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSilenceModeDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function simulate configuration of Silence
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSilenceModeDebug(MV_U32 state)
+{
+	S_EponIoctlSilence ioctlSilence;
+
+	ioctlSilence.silenceState = state;
+
+	onuEponMiSilenceConfig(&ioctlSilence);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSilenceSimDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function simulate configuration of Silence
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSilenceSimDebug(void)
+{
+	MV_STATUS status;
+	S_EponIoctlSilence ioctlSilence;
+
+	ioctlSilence.silenceState = 1;
+
+	onuEponMiSilenceConfig(&ioctlSilence);
+
+	status  = mvOnuEponMacGenOnuConfigAutoAckSet(0);
+	status |= mvOnuEponMacGenOnuConfigAutoRequestSet(0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "ERROR: (%s:%d) Failed to disable auto request / ack\n\r", __FILE_DESC__, __LINE__);
+		return;
+	}
+
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonSilenceTimerId[0]), 0, ONU_PON_TIMER_SILENCE_INTERVAL, 1);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDgDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function simulate reception of DG interrupt
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgDgDebug(MV_U32 dummy)
+{
+	mvOnuPonMacDgInterruptDis();
+	onuPonDyingGaspProcess();
+	onuEponDgIsrRoutine();
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetUserPatternBurst
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config start/stop onu transmission of user defined
+**               pattern burst
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetUserPatternBurst(MV_U32 patternMSB, MV_U32 pattern, MV_U32 patternLSB)
+{
+	MV_U32 userPattern[3];
+
+	userPattern[0] = patternLSB;
+	userPattern[1] = pattern;
+	userPattern[2] = patternMSB;
+
+	mvOnuPonMacPrbsUserDefinedPatternSet(userPattern);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetDefinedPatternBurst
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config start/stop onu transmission of pre-defined
+**               pattern burst
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetDefinedPatternBurst(MV_U32 enable, MV_U32 pattern, MV_U32 burst, MV_U32 duration, MV_U32 period)
+{
+	if (enable == 0)
+		onuPonPatternBurstOff();
+	else {
+		onuPonTxPowerOn(MV_TRUE);
+		onuPonPatternBurstOn(pattern, (MV_BOOL)burst, period, duration);
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgLosTime
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the time duration to be used
+**               when no optical detected and no GATE MPCPDU received
+**
+**  PARAMETERS:  opticalLosTime - time duration to be used when no optical detected
+**               macLosTime     - time duration to be used when no GATE MPCPDU received
+**  OUTPUTS:     void
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgLosTime(MV_U32 opticalLosTime, MV_U32 macLosTime)
+{
+	onuEponDbOnuOpticalLosTimeSet(opticalLosTime);
+	onuEponDbOnuMacLosTimeSet(macLosTime);
+
+	/* If the holdover timer is not active, we add the OpticalLosTimer to the holdover time and save */
+	if (onuPonResourceTbl_s.onuPonHoldoverTimerId.onuPonTimerActive == ONU_PON_TIMER_NOT_ACTIVE) {
+		/* Add the configured OptLosTime to holdover time and save for next holdover */
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonHoldoverTimerId), 0,
+				  onuEponDbOnuHoldoverTimeGet() + onuEponDbOnuOpticalLosTimeGet(), 0);
+	}
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgTxPowerControl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function controls the TX power on and off
+**
+**  PARAMETERS:  action - turn on and turn off the TX power, or turn off after
+**                        certain time duration.
+**               time   - time duration to be expired before turning off TX
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+void onuEponUiCfgTxPowerControl(MV_U32 action, MV_U32 time)
+{
+	if (action == E_EPON_IOCTL_ENABLE_TX) {
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponTxControlTimerId));
+		onuPonTxPowerOn(MV_TRUE);
+	} else if (action == E_EPON_IOCTL_DISABLE_TX) {
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponTxControlTimerId));
+		onuPonTxPowerOn(MV_FALSE);
+	} else if (action == E_EPON_IOCTL_DISABLE_TX_DELAY)
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponTxControlTimerId), 0, time, 1);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgPowerSaving
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the parameters for power saving mode
+**
+**  PARAMETERS:  earlyWakeup - set the ability of supporting early wake up
+**               maxSleepDuration - time period for keeping power saving mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_TRUE or MV_FLASE
+**
+*******************************************************************************/
+void onuEponUiCfgPowerSaving(MV_U32 earlyWakeup, MV_U32 maxSleepDuration)
+{
+	if ((onuEponDbOnuSleepDurationGet() + onuEponDbOnuWakeupDurationGet()) >= maxSleepDuration) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: Wrong parameters, sleep(%d) + wakeup(%d) >= maxSleepDuration(%d)\r\n",
+			   onuEponDbOnuSleepDurationGet(), onuEponDbOnuWakeupDurationGet(),
+			   maxSleepDuration);
+		return;
+	}
+
+	onuEponDbOnuPowerSavingWakeupSet(earlyWakeup);
+	onuEponDbOnuPowerSavingMaxSleepDurationSet(maxSleepDuration);
+
+	if (onuPonResourceTbl_s.onuEponMaxSleepTimerId.onuPonTimerActive == ONU_PON_TIMER_ACTIVE)
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId), 0,
+				  maxSleepDuration, 1);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgControlSleep
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function triggers the action of power mode transformation
+**
+**  PARAMETERS:  action         - enable, disable or configure
+**               sleepMode      - turn off tx or tx/rx
+**               sleepDuration  - periodical time duration for sleep
+**               wakeupDuration - periodical time duration for wakeup
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiCfgControlSleep(MV_U32 action, MV_U32 sleepMode, MV_U32 sleepDuration, MV_U32 wakeupDuration)
+{
+	if (action == E_GPON_SLEEP_ACTION_DISABLE)
+		mvEponApiSleepCtrlDisable();
+	else if (action == E_GPON_SLEEP_ACTION_ENABLE)
+		mvEponApiSleepCtrlEnable();
+	else if (action == E_GPON_SLEEP_ACTION_CONFIG)
+		mvEponApiSleepCtrlCfg(sleepMode, sleepDuration, wakeupDuration);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetPcsFrameLimits
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures PCS Frame Limits
+**
+**  PARAMETERS:  MV_U32 latency - FED decoder latency in unit of clock cycles
+**               MV_U32 size    - Maximum frame size
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetPcsFrameLimits(MV_U32 latency, MV_U32 size)
+{
+	mvOnuEponMacPcsFrameSizeLimitsSet(size, latency);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgShowPcsFrameLimits
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows PCS Frame Limits
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgShowPcsFrameLimits(char *buf)
+{
+	int off = 0;
+	MV_STATUS status;
+	MV_U32 size, latency;
+
+	status = mvOnuEponMacPcsFrameSizeLimitsGet(&size, &latency);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain PCS Frame Limits!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "FEC Decoder Latency = %#x\n", latency);
+		off += mvOsSPrintf(buf + off, "Maximum Frame Size  = %#x\n", size);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetRxDataFifoThresh
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures RX Parser Data FIFO Threshold
+**
+**  PARAMETERS:  MV_U32 threshold - RX Data FIFO MAX allowed capacity
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetRxDataFifoThresh(MV_U32 threshold)
+{
+	mvOnuEponMacRxpDataFifoThresholdSet(threshold);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgShowRxDataFifoThresh
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows RX Parser Data FIFO Threshold
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgShowRxDataFifoThresh(char *buf)
+{
+	int off = 0;
+	MV_STATUS status;
+	MV_U32 threshold;
+
+	status = mvOnuEponMacRxpDataFifoThresholdGet(&threshold);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain RX Parser Data FIFO Threshold!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "RX Parser Data FIFO Threshold = %#x\n", threshold);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetPkt2kEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures 2K packet supported
+**
+**  PARAMETERS:  MV_U32 enable - 2K packet supported enable or disable
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetPkt2kEnable(MV_U32 enable)
+{
+	/* Before setting register, needs to disable Rx */
+	mvOnuEponMacPcsRxEnableSet(EPON_PCS_CONFIG_RX_DISABLE);
+
+	mvEponApi2kSupportedSet(enable);
+
+	/* After setting register, enable Rx */
+	mvOnuEponMacPcsRxEnableSet(EPON_PCS_CONFIG_RX_ENABLE);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgShowPkt2kEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows 2K packet supported
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     offset of buf
+**
+*******************************************************************************/
+int onuEponUiCfgShowPkt2kEnable(char *buf)
+{
+	int off = 0;
+	MV_STATUS status;
+	MV_U32 frameSizeLimitSize;
+	MV_U32 frameSizeLimitLatency;
+	MV_U32 dataFifoThreshold;
+
+	status = mvOnuEponMacPcsFrameSizeLimitsGet(&frameSizeLimitSize, &frameSizeLimitLatency);
+	status |= mvOnuEponMacRxpDataFifoThresholdGet(&dataFifoThreshold);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain 2K packet support related register value!\r\n");
+	else {
+		off += mvOsSPrintf(buf + off, "\r\n");
+		off += mvOsSPrintf(buf + off, "PcsFrameSizeLimitSize    = %d\r\n", frameSizeLimitSize);
+		off += mvOsSPrintf(buf + off, "PcsFrameSizeLimitLatency = %d\r\n", frameSizeLimitLatency);
+		off += mvOsSPrintf(buf + off, "DataFifoThreshold        = %d\r\n", dataFifoThreshold);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetTimeIfDayIntWidth
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures Time Of Day Interrupt width
+**
+**  PARAMETERS:  MV_U32 polarity  - interrupt polarity
+**               MV_U32 width     - interrupt width
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetTimeIfDayIntWidth(MV_U32 polarity, MV_U32 width)
+{
+	mvOnuEponMacGenTimeOfDayIntConfigSet(polarity, width);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgShowTimeIfDayIntWidth
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows Time Of Day Interrupt width
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgShowTimeIfDayIntWidth(char *buf)
+{
+	int off = 0;
+	MV_STATUS status;
+	MV_U32 polarity, width;
+
+	status = mvOnuEponMacGenTimeOfDayIntConfigGet(&polarity, &width);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain Time Of Day Interrupt Width!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "Time Of Day Interrupt Width = %#x, Polarity = %x\n", width, polarity);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetTxMuxPowerUpTime
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures TX MUX Power Up time
+**
+**  PARAMETERS:  MV_U32 time  - TX MUX Power Up time in clock cycle units [8ns]
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetTxMuxPowerUpTime(MV_U32 time)
+{
+	mvOnuEponMacTxmPowerUpIndSet(time);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgShowTxMuxPowerUpTime
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows TX MUX Power Up time
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuEponUiCfgShowTxMuxPowerUpTime(char *buf)
+{
+	int off = 0;
+	MV_STATUS status;
+	MV_U32 time;
+
+	status = mvOnuEponMacTxmPowerUpIndGet(&time);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain TX MUX Power Up time!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "\n");
+		off += mvOsSPrintf(buf + off, "TX MUX Power Up time in clock cycle units is %#x [*8ns]\n", time);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetDdmTxPolarity
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures DDM TX polarity
+**
+**  PARAMETERS:  MV_U32 txEnable
+**               MV_U32 txPol
+**               MV_U32 serdesPol
+**               MV_U32 xvrPol
+**               MV_U32 burstEn
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetDdmTxPolarity(MV_U32 txEnable, MV_U32 txPol, MV_U32 serdesPol, MV_U32 xvrPol, MV_U32 burstEn)
+{
+	mvOnuEponMacDdmTxPolaritySet(txEnable, txPol, serdesPol, xvrPol, burstEn);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetRpmReportConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures RPM Report configuration
+**
+**  PARAMETERS:  MV_U32 bitmap    - bitmap order
+**               MV_U32 qsOrder   - qset order
+**               MV_U32 mode      - report generation mode
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetRpmReportConfig(MV_U32 bitmap, MV_U32 qsOrder, MV_U32 mode)
+{
+	mvOnuEponMacTxmCppRpmReportConfigSet(bitmap, qsOrder, mode);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgSetUtmActTxBitmap
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures General UTM Active TX Bitmap
+**
+**  PARAMETERS:  MV_U32 bitmap    - bitmap
+**               MV_U32 valid     - bitmap valid
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponUiCfgSetUtmActTxBitmap(MV_U32 bitmap, MV_U32 valid)
+{
+	mvOnuEponMacGenUtmActTxBitmapSet(bitmap);
+	mvOnuEponMacGenUtmActTxBitmapEnSet(valid);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaSwForceModeShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints legacy mode status
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuEponUiCfgDbaSwForceModeShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+	if (onuEponDbOnuDbaSwForceModeGet() == ONU_DBA_SW_FORCE_MODE_EN)
+		off += mvOsSPrintf(buf + off, "The system is running in SW DBA mode\n");
+	else
+		off += mvOsSPrintf(buf + off, "The system is running in HW DBA mode\n");
+	off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiCfgDbaSwForceModeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets legacy mode configuration
+**
+**  PARAMETERS:  MV_U32 legacyMode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiCfgDbaSwForceModeConfig(MV_U32 legacyMode)
+{
+	if (legacyMode != 0)
+		onuEponDbOnuDbaSwForceModeSet(1);
+	else
+		onuEponDbOnuDbaSwForceModeSet(0);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiOmciChannelAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds EOAM channel
+**
+**  PARAMETERS:  MV_U32 rxCpuQueue, ranging from 0~7
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+void onuEponUiEoamChannelAdd(MV_U32 rxCpuQueue)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponApiEoamChannelAdd((MV_U8)rxCpuQueue);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Failed to add EPON OAM channel\n");
+	else
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Succeeded to add EPON OAM channel\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiEoamChannelDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes EOAM channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+void onuEponUiEoamChannelDel(void)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponApiEoamChannelDel();
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Failed to delete EPON OAM channel\n");
+	else
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Succeeded to delete EPON OAM channel\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiEoamChannelShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows EOAM channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+int onuEponUiEoamChannelShow(char *buf)
+{
+	return onuEponEoamChannelPrint(buf);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiLlidPmStart
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function starts LLID PM.
+**
+**  PARAMETERS:  MV_U32 llid
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiLlidPmStart(MV_U32 llid, MV_U32 direction)
+{
+	S_EponIoctlLlidPmConfig llidPm;
+
+	llidPm.command   = LLIDPMCMD_START;
+	llidPm.llid      = llid;
+	llidPm.direction = direction;
+
+	onuEponApiLlidPmConfig(&llidPm);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiLlidPmStop
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function stops LLID PM.
+**
+**  PARAMETERS:  MV_U32 llid
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiLlidPmStop(MV_U32 llid, MV_U32 direction)
+{
+	S_EponIoctlLlidPmConfig llidPm;
+
+	llidPm.command   = LLIDPMCMD_STOP;
+	llidPm.llid      = llid;
+	llidPm.direction = direction;
+
+	onuEponApiLlidPmConfig(&llidPm);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiLlidPmReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function resets LLID MIB counters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiLlidPmReset(void)
+{
+	onuEponApiLlidPmReset();
+}
+
+/*******************************************************************************
+**
+**  onuEponUiLlidMibPmDbShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints LLID PM configured for PM
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuEponUiLlidMibPmDbShow(char *buf)
+{
+	S_apiLlidPmConfig llidCfg;
+	int off = 0;
+	MV_U16 dbIdx;
+	int displayIndx = 0;
+	MV_STATUS rc;
+	char                *pdirnstr;
+
+	off += mvOsSPrintf(buf + off, "LLID MIB PM \n");
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	off += mvOsSPrintf(buf + off, " #   Counter  LLID  direction\n");
+	off += mvOsSPrintf(buf + off, "     set      \n");
+	off += mvOsSPrintf(buf + off, "=============================\n");
+
+	for (dbIdx = 0; dbIdx < MAX_SUPPORTED_LLIDS_FOR_PM; dbIdx++) {
+		rc = onuEponPmLlidPmConfigGet(dbIdx, &llidCfg);
+		if (rc == MV_OK) {
+			/* Emergency printout in case direction is illegal */
+			if (llidCfg.direction == LLIDPMDIRECTION_US)
+				pdirnstr = "us";
+			else if (llidCfg.direction == LLIDPMDIRECTION_DS)
+				pdirnstr = "ds";
+			else if (llidCfg.direction == LLIDPMDIRECTION_BIDI)
+				pdirnstr = "bidi";
+			else
+				pdirnstr = "unkn";
+			displayIndx++;
+			off += mvOsSPrintf(buf + off, "%2d   %-2d       %-4d  %s(%d)\n",
+				displayIndx, llidCfg.counter_set, llidCfg.llid, pdirnstr, llidCfg.direction);
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuEponUiLlidPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints LLID MIB counters
+**
+**  PARAMETERS:  MV_U32 llid
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuEponUiLlidPmGet(MV_U32 llid, MV_U32 direction)
+{
+	S_EponIoctlLlidMibCounters mibCounters;
+	MV_STATUS rcode;
+
+	MV_U8 *rxCounterText[] = {
+		"Good frames      received   ",
+		"Multicast frames received   ",
+		"Broadcast frames received   ",
+		"Good octets      received   ",
+		"Bad frames       received   "
+	};
+
+	MV_U8 *txCounterText[] = {
+		"Good frames      transmitted",
+		"Multicast frames transmitted",
+		"Broadcast frames transmitted",
+		"Good octets      transmitted",
+		"MAC transmission errors     "
+	};
+
+	MV_U8 *sizeCounterText[] = {
+		"Frames 64         octets    ",
+		"Frames 65  - 127  octets    ",
+		"Frames 128 - 255  octets    ",
+		"Frames 256 - 511  octets    ",
+		"Frames 512 - 1023 octets    ",
+		"Frames 1024- max  octets    "
+	};
+
+	memset(&mibCounters, 0, sizeof(S_EponIoctlLlidMibCounters));
+
+	mibCounters.llid      = llid;
+	mibCounters.direction = direction;
+	rcode = onuEponApiLlidPmGet(&mibCounters);
+	if (rcode == MV_OK) {
+		mvOsPrintf("\n");
+		mvOsPrintf("------------------------------------------------------------------\n");
+		mvOsPrintf("|MIB COUNTERS for LLID:  %d, %s\n", llid,
+			   (direction == LLIDPMDIRECTION_DS) ? "downstream" : (direction == LLIDPMDIRECTION_US) ? "upstream" : "bidirectional");
+		mvOsPrintf("------------------------------------------------\n");
+		mvOsPrintf("|COUNTER                         |  VALUE      |\n");
+		mvOsPrintf("------------------------------------------------\n");
+		if (direction == LLIDPMDIRECTION_DS || direction == LLIDPMDIRECTION_BIDI) {
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[0], mibCounters.good_frames_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[1], mibCounters.multicast_frames_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[2], mibCounters.broadcast_frames_received);
+			mvOsPrintf(" %s   | %10llu  |\n", rxCounterText[3], mibCounters.good_octets_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[4], mibCounters.bad_frames_received);
+		}
+		if (direction == LLIDPMDIRECTION_US || direction == LLIDPMDIRECTION_BIDI) {
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[0], mibCounters.good_frames_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[1], mibCounters.multicast_frames_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[2], mibCounters.broadcast_frames_sent);
+			mvOsPrintf(" %s   | %10llu  |\n", txCounterText[3], mibCounters.good_octets_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[4], mibCounters.mac_trans_error);
+		}
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[0], mibCounters.frames_64_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[1], mibCounters.frames_65_to_127_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[2], mibCounters.frames_128_to_255octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[3], mibCounters.frames_256_to_511_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[4], mibCounters.frames_512_to_1023_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[5], mibCounters.frames_1024_to_max_octets);
+
+		mvOsPrintf("------------------------------------------------------------------\n");
+	} else
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get mibCounters value, portId(%d) direction(%d), rcode(%d)\n",
+			   __FILE_DESC__, __LINE__, llid, direction, rcode);
+}
+
+/*******************************************************************************
+**
+**  onuEponUiHighPriTxStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON high priority TX state
+**
+**  PARAMETERS:  MV_U32 state
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+void onuEponUiHighPriTxStateSet(MV_U32 state)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponApiTxLlidMapStateSet(INT_TO_MV_BOOL(state));
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Failed to set EPON high priority TX state\n");
+	else
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Succeeded to EPON high priority TX state\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiHighPriTxMapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets the EPON high priority TX map
+**
+**  PARAMETERS:  MV_U32 llid_bm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+void onuEponUiHighPriTxMapSet(MV_U32 llid_bm)
+{
+	MV_STATUS rcode;
+
+	rcode = onuEponApiTxLlidMapSet(llid_bm);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Failed to set the EPON high priority TX map\n");
+	else
+		mvPonPrint(PON_PRINT_ERROR, PON_MNG_MODULE,
+			   "Succeeded to set the EPON high priority TX map\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUiHighPriTxShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function shows EOAM channel
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+int onuEponUiHighPriTxShow(char *buf)
+{
+	return onuEponUiHighPriTxPrint(buf);
+}
+
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/*                            ONU SYS FS Definition                           */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Info Group                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Info Commands                                   */
+/* ========================================================================== */
+static ssize_t epon_info_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	const char* name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "infoEpon"))
+		return onuEponUiInfoShow(buf);
+	else if (!strcmp(name, "alarmEpon"))
+		return onuEponUiAlarmShow(buf);
+	else if (!strcmp(name, "helpEInfo"))
+		return onuEponUiInfoHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t epon_info_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t len)
+{
+	const char* name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x %x", &param1, &param2, &param3);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "readRegEpon"))
+		onuEponUiDebugReadReg((MV_U32)param1, (MV_U32)param2);                          /* readOffset, readEntry */
+	else if (!strcmp(name, "writeRegEpon"))
+		onuEponUiDebugWriteReg((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);         /*  writeOffset, writeEntry, regValue */
+	else
+		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Info Attributes                                 */
+/* ========================================================================== */
+static DEVICE_ATTR(infoEpon,     S_IRUSR, epon_info_show, epon_info_store);
+static DEVICE_ATTR(alarmEpon,    S_IRUSR, epon_info_show, epon_info_store);
+static DEVICE_ATTR(helpEInfo,    S_IRUSR, epon_info_show, epon_info_store);
+static DEVICE_ATTR(readRegEpon,  S_IWUSR, epon_info_show, epon_info_store);
+static DEVICE_ATTR(writeRegEpon, S_IWUSR, epon_info_show, epon_info_store);
+
+static struct attribute *epon_info_attrs[] = {
+	&dev_attr_infoEpon.attr,
+	&dev_attr_alarmEpon.attr,
+	&dev_attr_readRegEpon.attr,
+	&dev_attr_writeRegEpon.attr,
+	&dev_attr_helpEInfo.attr,
+	NULL
+};
+
+static struct attribute_group epon_info_group = {
+	.name	= "info",
+	.attrs	= epon_info_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Pm Group                                        */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Pm Commands                                     */
+/* ========================================================================== */
+static ssize_t epon_pm_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	const char* name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "rxCnt"))
+		return onuEponUiRxCountersShow(buf);
+	else if (!strcmp(name, "txCnt"))
+		return onuEponUiTxCountersShow(buf);
+	else if (!strcmp(name, "swCnt"))
+		return onuEponUiSwCountersShow(buf);
+	else if (!strcmp(name, "gpmCnt"))
+		return onuEponUiGpmCountersShow(buf);
+	else if (!strcmp(name, "allCnt"))
+		return onuEponUiAllCountersShow(buf);
+	else if (!strcmp(name, "showDbaBytesPerLlidQueue"))
+		return onuEponUiShowLlidQueueBytes(buf);
+	else if (!strcmp(name, "showDbaBytesPerLlidFifo"))
+		return onuEponUiShowLlidFifoBytes(buf);
+	else if (!strcmp(name, "showRandom"))
+		return onuEponUiShowRandom(buf);
+	else if (!strcmp(name, "showPcsStat"))
+		return onuEponUiShowPcsStat(buf);
+	else if (!strcmp(name, "showLlidMibPmDb"))
+		return onuEponUiLlidMibPmDbShow(buf);
+	else if (!strcmp(name, "helpPm"))
+		return onuEponUiPmHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t epon_pm_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	const char* name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d", &param1, &param2, &param3);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "cntRdClrState"))
+		onuEponUiCountersReadClearFlag((MV_BOOL)param1);
+	else if (!strcmp(name, "addDbaBytesPerLlidQueue"))
+		onuEponUiAddLlidQueueBytes(param1, param2, param3);
+	else if (!strcmp(name, "addDbaBytesPerLlidFifo"))
+		onuEponUiAddLlidFifoBytes(param1, param2);
+	else if (!strcmp(name, "startLlidMibPm"))
+		onuEponUiLlidPmStart((MV_U32)param1, (MV_U32)param2);           /* Start LLID PM */
+	else if (!strcmp(name, "stopLlidMibPm"))
+		onuEponUiLlidPmStop((MV_U32)param1, (MV_U32)param2);            /* Stop LLID PM */
+	else if (!strcmp(name, "resetLlidMibPm"))
+		onuEponUiLlidPmReset();                                         /* Reset LLID PM*/
+	else if (!strcmp(name, "getLlidMibPm"))
+		onuEponUiLlidPmGet((MV_U32)param1, (MV_U32)param2);             /* Get LLID counters */
+	else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            PM Attributes                                   */
+/* ========================================================================== */
+static DEVICE_ATTR(rxCnt,                    S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(txCnt,                    S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(swCnt,                    S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(gpmCnt,                   S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(allCnt,                   S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(showDbaBytesPerLlidQueue, S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(addDbaBytesPerLlidQueue,  S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(showDbaBytesPerLlidFifo,  S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(addDbaBytesPerLlidFifo,   S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(cntRdClrState,            S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(showRandom,               S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(showPcsStat,              S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(helpPm,                   S_IRUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(startLlidMibPm,           S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(stopLlidMibPm,            S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(resetLlidMibPm,           S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(getLlidMibPm,             S_IWUSR, epon_pm_show, epon_pm_store);
+static DEVICE_ATTR(showLlidMibPmDb,          S_IRUSR, epon_pm_show, epon_pm_store);
+
+static struct attribute *epon_pm_attrs[] = {
+	&dev_attr_rxCnt.attr,
+	&dev_attr_txCnt.attr,
+	&dev_attr_swCnt.attr,
+	&dev_attr_gpmCnt.attr,
+	&dev_attr_allCnt.attr,
+	&dev_attr_showDbaBytesPerLlidQueue.attr,
+	&dev_attr_addDbaBytesPerLlidQueue.attr,
+	&dev_attr_showDbaBytesPerLlidFifo.attr,
+	&dev_attr_addDbaBytesPerLlidFifo.attr,
+	&dev_attr_cntRdClrState.attr,
+	&dev_attr_showRandom.attr,
+	&dev_attr_showPcsStat.attr,
+	&dev_attr_startLlidMibPm.attr,
+	&dev_attr_stopLlidMibPm.attr,
+	&dev_attr_resetLlidMibPm.attr,
+	&dev_attr_getLlidMibPm.attr,
+	&dev_attr_showLlidMibPmDb.attr,
+	&dev_attr_helpPm.attr,
+	NULL
+};
+
+static struct attribute_group epon_pm_group = {
+	.name	= "pm",
+	.attrs	= epon_pm_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg Group                                       */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Cfg Commands                                    */
+/* ========================================================================== */
+static ssize_t cfg_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	const char* name = attr->attr.name;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "printMask"))
+		return ponOnuPrintStatus(buf);
+	else if (!strcmp(name, "dbaSwCfgPrint"))
+		return onuEponUiCfgDbaCfgPrint(buf);
+	else if (!strcmp(name, "dbaStaticCfgPrint"))
+		return onuEponUiCfgDbaStaticCfgPrint(buf);
+	else if (!strcmp(name, "prbsUserPattern"))
+		return onuEponUiCfgPrbsUserPattern(buf);
+	else if (!strcmp(name, "helpCfg"))
+		return onuEponUiCfgHelpShow(buf);
+	else if (!strcmp(name, "eoamChannelShow"))
+		return onuEponUiEoamChannelShow(buf);
+	else if (!strcmp(name, "highPriTxShow"))
+		return onuEponUiHighPriTxShow(buf);
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "pcsFrameLimits"))
+			return onuEponUiCfgShowPcsFrameLimits(buf);
+		else if (!strcmp(name, "rxDataFifoThresh"))
+			return onuEponUiCfgShowRxDataFifoThresh(buf);
+		else if (!strcmp(name, "pkt2kEn"))
+			return onuEponUiCfgShowPkt2kEnable(buf);
+		else if (!strcmp(name, "timeOfDayInt"))
+			return onuEponUiCfgShowTimeIfDayIntWidth(buf);
+		else if (!strcmp(name, "txmPowerUpTime"))
+			return onuEponUiCfgShowTxMuxPowerUpTime(buf);
+		else if (!strcmp(name, "dbaSwForceMode"))
+			return onuEponUiCfgDbaSwForceModeShow(buf);
+	}
+
+	return 0;
+}
+
+static ssize_t cfg_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t len)
+{
+	const char* name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+	unsigned int param4 = 0;
+	unsigned int param5 = 0;
+	unsigned int param6 = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x %x %x %x %x", &param1, &param2, &param3, &param4, &param5, &param6);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "rxEn"))
+		onuEponUiCfgMacRxEn((MV_U32)param1);
+	else if (!strcmp(name, "txEn"))
+		onuEponUiCfgMacTxEn((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "ctrlTimerEn"))
+		onuEponUiCfgMpcpTimerEn((MV_U32)param1);
+	else if (!strcmp(name, "ctrlTimerVal"))
+		onuEponUiCfgMpcpTimerVal((MV_U32)param1);
+	else if (!strcmp(name, "ctrlTimerRandom"))
+		onuEponUiCfgMpcpTimerRandom((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "dbaHwParamsCfg"))
+		onuEponUiCfgDbaHwDebug((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "dbaSwIntervalCfg"))
+		onuEponUiCfgDbaSwInterval((MV_U32)param1);
+	else if (!strcmp(name, "dbaSwParamsCfg"))
+		onuEponUiCfgDbaSwDebug((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4, (MV_U32)param5, (MV_U32)param6);
+	else if (!strcmp(name, "dbaSwOptionCfg"))
+		onuEponUiCfgDbaSwRprtDir((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "holdoverDebug"))
+		onuEponUiCfgHoldoverDebug((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "silenceMode"))
+		onuEponUiCfgSilenceModeDebug((MV_U32)param1);
+	else if (!strcmp(name, "silenceSim"))
+		onuEponUiCfgSilenceSimDebug();
+	else if (!strcmp(name, "dgCfg"))
+		onuEponUiCfgDgCfg((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "dgDebug"))
+		onuEponUiCfgDgDebug((MV_U32)param1);
+	else if (!strcmp(name, "prbsUserDefinedPattern"))
+		onuEponUiCfgSetUserPatternBurst((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);                                        /* 80bit user data: 16bit patternMLSB + 32bit pattern + 32bit patternLSB\n" */
+	else if (!strcmp(name, "prbsPreDefinedPattern"))
+		onuEponUiCfgSetDefinedPatternBurst((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4, (MV_U32)param5);     /* pattern type, burst type, duration, period */
+
+	else if (!strcmp(name, "printMask"))                                                                                            /* module, print level, options */
+		ponOnuChangePrintStatus((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "txPowerControl"))
+		onuEponUiCfgTxPowerControl((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "powerSaving"))
+		onuEponUiCfgPowerSaving((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "sleepControl"))
+		onuEponUiCfgControlSleep((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4);
+	else if (!strcmp(name, "eoamChannelAdd"))       /* Add EPON OAM channel */
+		onuEponUiEoamChannelAdd((MV_U32)param1);
+	else if (!strcmp(name, "eoamChannelDel"))       /* Delete EPON OAM channel */
+		onuEponUiEoamChannelDel();
+	else if (!strcmp(name, "highPriTxStateSet"))    /* Set EPON high priority TX state */
+		onuEponUiHighPriTxStateSet((MV_U32)param1);
+	else if (!strcmp(name, "highPriTxMapSet"))      /* Set EPON high priority TX map */
+		onuEponUiHighPriTxMapSet((MV_U32)param1);
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "pcsFrameLimits"))
+			onuEponUiCfgSetPcsFrameLimits((MV_U32)param1, (MV_U32)param2);
+		else if (!strcmp(name, "rxDataFifoThresh"))
+			onuEponUiCfgSetRxDataFifoThresh((MV_U32)param1);
+		else if (!strcmp(name, "pkt2kEn"))
+			onuEponUiCfgSetPkt2kEnable((MV_U32)param1);
+		else if (!strcmp(name, "timeOfDayInt"))         /* polarity, width */
+			onuEponUiCfgSetTimeIfDayIntWidth((MV_U32)param1, (MV_U32)param2);
+		else if (!strcmp(name, "txmPowerUpTime"))       /* time */
+			onuEponUiCfgSetTxMuxPowerUpTime((MV_U32)param1);
+		else if (!strcmp(name, "ddmTxPolarity"))        /* txEnable, txPol, serdesPol, xvrPol, burstEn */
+			onuEponUiCfgSetDdmTxPolarity((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4, (MV_U32)param5);
+		else if (!strcmp(name, "rpmReportCfg"))         /* bitmap, qsOrder, mode */
+			onuEponUiCfgSetRpmReportConfig((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+		else if (!strcmp(name, "utmActTxBitmap"))       /* bitmap, enable */
+			onuEponUiCfgSetUtmActTxBitmap((MV_U32)param1, (MV_U32)param2);
+		else if (!strcmp(name, "dbaSwForceMode"))       /* legacy mode */
+			onuEponUiCfgDbaSwForceModeConfig((MV_U32)param1);
+		else
+			printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	} else
+		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Cfg Attributes                                  */
+/* ========================================================================== */
+static DEVICE_ATTR(rxEn,                    S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(txEn,                    S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(ctrlTimerEn,             S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(ctrlTimerVal,            S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(ctrlTimerRandom,         S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaHwParamsCfg,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaSwIntervalCfg,        S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaSwParamsCfg,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaSwOptionCfg,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaSwCfgPrint,           S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaStaticCfgPrint,       S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(holdoverDebug,           S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(silenceMode,             S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(silenceSim,              S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dgCfg,                   S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dgDebug,                 S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(prbsUserPattern,         S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(prbsUserDefinedPattern,  S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(prbsPreDefinedPattern,   S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(printMask,               S_IRUSR | S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(pcsFrameLimits,          S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(rxDataFifoThresh,        S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(timeOfDayInt,            S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(txmPowerUpTime,          S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(ddmTxPolarity,           S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(pkt2kEn,                 S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(rpmReportCfg,            S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(utmActTxBitmap,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(dbaSwForceMode,          S_IWUSR | S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(txPowerControl,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(powerSaving,             S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(sleepControl,            S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(eoamChannelAdd,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(eoamChannelDel,          S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(eoamChannelShow,         S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(highPriTxStateSet,       S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(highPriTxMapSet,         S_IWUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(highPriTxShow,           S_IRUSR, cfg_show, cfg_store);
+static DEVICE_ATTR(helpCfg,                 S_IRUSR, cfg_show, cfg_store);
+
+static struct attribute *cfg_attrs[] = {
+	&dev_attr_rxEn.attr,
+	&dev_attr_txEn.attr,
+	&dev_attr_ctrlTimerEn.attr,
+	&dev_attr_ctrlTimerVal.attr,
+	&dev_attr_ctrlTimerRandom.attr,
+	&dev_attr_dbaHwParamsCfg.attr,
+	&dev_attr_dbaSwIntervalCfg.attr,
+	&dev_attr_dbaSwParamsCfg.attr,
+	&dev_attr_dbaSwOptionCfg.attr,
+	&dev_attr_dbaSwCfgPrint.attr,
+	&dev_attr_dbaStaticCfgPrint.attr,
+	&dev_attr_holdoverDebug.attr,
+	&dev_attr_silenceMode.attr,
+	&dev_attr_silenceSim.attr,
+	&dev_attr_dgCfg.attr,
+	&dev_attr_dgDebug.attr,
+	&dev_attr_prbsUserPattern.attr,
+	&dev_attr_prbsUserDefinedPattern.attr,
+	&dev_attr_prbsPreDefinedPattern.attr,
+	&dev_attr_printMask.attr,
+	&dev_attr_pcsFrameLimits.attr,
+	&dev_attr_rxDataFifoThresh.attr,
+	&dev_attr_timeOfDayInt.attr,
+	&dev_attr_txmPowerUpTime.attr,
+	&dev_attr_ddmTxPolarity.attr,
+	&dev_attr_pkt2kEn.attr,
+	&dev_attr_rpmReportCfg.attr,
+	&dev_attr_utmActTxBitmap.attr,
+	&dev_attr_dbaSwForceMode.attr,
+	&dev_attr_txPowerControl.attr,
+	&dev_attr_powerSaving.attr,
+	&dev_attr_sleepControl.attr,
+	&dev_attr_eoamChannelAdd.attr,
+	&dev_attr_eoamChannelDel.attr,
+	&dev_attr_eoamChannelShow.attr,
+	&dev_attr_highPriTxStateSet.attr,
+	&dev_attr_highPriTxMapSet.attr,
+	&dev_attr_highPriTxShow.attr,
+	&dev_attr_helpCfg.attr,
+	NULL
+};
+
+static struct attribute_group cfg_group = {
+	.name	= "cfg",
+	.attrs	= cfg_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            ONU SYS FS                                      */
+/* ========================================================================== */
+/******************************************************************************/
+int epon_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "epon");
+	if (!pd) {
+		platform_device_register_simple("epon", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "epon");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR "%s: cannot find epon device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &epon_info_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &epon_pm_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &cfg_group);
+	if (err) {
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	printk(KERN_INFO "= EPON Module SYS FS Init ended successfully =\n");
+out:
+	return err;
+}
+
+void epon_sysfs_delete(void)
+{
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "epon");
+	if (!pd) {
+		printk(KERN_ERR "%s: cannot find epon device\n", __func__);
+		return;
+	}
+
+	sysfs_remove_group(&pd->kobj, &epon_info_group);
+	sysfs_remove_group(&pd->kobj, &epon_pm_group);
+	sysfs_remove_group(&pd->kobj, &cfg_group);
+
+	printk(KERN_INFO "= EPON Module SYS FS Remove ended successfully =\n");
+}
+
+/*******************************************************************************
+**
+**  onuEponUsrInterfaceCreate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function create user interface - sys fs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponUsrInterfaceCreate(void)
+{
+	if (epon_sysfs_init() != 0)
+		return MV_ERROR;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponUsrInterfaceRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release user interface - sys fs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuEponUsrInterfaceRelease(void)
+{
+	epon_sysfs_delete();
+
+	return MV_OK;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.h
new file mode 100644
index 0000000..8afd80b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/epon/eponOnuLnxKsUI.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsUI.h                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU EPON User Interface - SysFs         **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_EPON_LINUX_KS_USR_INTERFACE_H
+#define _ONU_EPON_LINUX_KS_USR_INTERFACE_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern MV_BOOL infoEponCntReadClearInd;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+extern MV_STATUS onuEponMiDbaConfig(S_EponIoctlDba *ioctlDba);
+extern MV_STATUS onuEponMiHoldoverConfig(S_EponIoctlHoldOver *ioctlHoldover);
+extern MV_STATUS onuEponMiSilenceConfig(S_EponIoctlSilence *ioctlSilence);
+extern MV_STATUS onuEponMiAlarmGet(MV_U32 *alarm);
+extern void      onuEponMiCfgMacTxEn(MV_U32 enable, MV_U32 macId);
+
+extern void rprtThresholdSet(MV_U32 lowThCnt, MV_U32 lowThVal, MV_U32 hiThCnt, MV_U32 hiThVal);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuEponUsrInterfaceCreate(void);
+MV_STATUS onuEponUsrInterfaceRelease(void);
+
+void onuEponUiCfgLosTime(MV_U32 opticalLosTime, MV_U32 macLosTime);
+void onuEponUiCfgTxPowerControl(MV_U32 action, MV_U32 time);
+void onuEponUiCfgPowerSaving(MV_U32 earlyWakeup, MV_U32 maxSleepDuration);
+void onuEponUiCfgControlSleep(MV_U32 action, MV_U32 sleepMode,
+			      MV_U32 sleepDuration, MV_U32 wakeupDuration);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_LINUX_KS_USR_INTERFACE_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.c
new file mode 100644
index 0000000..74dfac2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.c
@@ -0,0 +1,596 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsMI.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Management Interface         **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include <linux/version.h>
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/perf/gpon/gponOnuLnxKsMI.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuGponMiInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init onu
+**
+**  PARAMETERS:  MV_U32 alloc
+**               MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponMiInit(S_GponIoctlInfo *ioctlInfo)
+{
+	return onuGponStart(ioctlInfo);
+}
+
+/*******************************************************************************
+**
+**  onuGponMiInfoGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu info
+**
+**  PARAMETERS:  S_IoctlInfo *onuInfo
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponMiInfoGet(S_GponIoctlInfo *onuInfo)
+{
+	MV_U32 uponDebugState;
+
+	uponDebugState = onuGponApiUponDebugGet();
+
+	if (uponDebugState)
+		onuInfo->onuState = ONU_GPON_DEBUG_STATE;
+	else
+		onuInfo->onuState = onuGponDbOnuStateGet();
+
+	onuInfo->onuId           = onuGponDbOnuIdGet();
+	onuInfo->omccPort        = onuGponDbOmccPortGet();
+	onuInfo->omccValid       = onuGponDbOmccValidGet();
+	onuInfo->onuSignalDetect = onuGponDbOnuSignalDetectGet();
+	onuInfo->onuDsSyncOn     = onuGponDbOnuDsSyncOnGet();
+	onuInfo->onuGponPortState = onuGponDbOnuGponPortStateGet();
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponMiAlarm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu alarms
+**
+**  PARAMETERS:  S_IoctlAlarm *ioctlAlarm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponMiAlarm(S_GponIoctlAlarm *ioctlAlarm)
+{
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_LOS]  = onuGponAlarmGet(ONU_GPON_ALARM_LOS);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_LOF]  = onuGponAlarmGet(ONU_GPON_ALARM_LOF);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_LCDA] = onuGponAlarmGet(ONU_GPON_ALARM_LCDA);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_LCDG] = onuGponAlarmGet(ONU_GPON_ALARM_LCDG);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_SF]   = onuGponAlarmGet(ONU_GPON_ALARM_SF);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_SD]   = onuGponAlarmGet(ONU_GPON_ALARM_SD);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_TF]   = onuGponAlarmGet(ONU_GPON_ALARM_TF);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_SUF]  = onuGponAlarmGet(ONU_GPON_ALARM_SUF);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_MEM]  = onuGponAlarmGet(ONU_GPON_ALARM_MEM);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_DACT] = onuGponAlarmGet(ONU_GPON_ALARM_DACT);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_DIS]  = onuGponAlarmGet(ONU_GPON_ALARM_DIS);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_MIS]  = onuGponAlarmGet(ONU_GPON_ALARM_MIS);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_PEE]  = onuGponAlarmGet(ONU_GPON_ALARM_PEE);
+	ioctlAlarm->alarmTbl[ONU_GPON_ALARM_RDI]  = onuGponAlarmGet(ONU_GPON_ALARM_RDI);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponMiPm
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu pm info
+**
+**  PARAMETERS:  S_IoctlPm *ioctlPm
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponMiPm(S_GponIoctlPm *ioctlPm)
+{
+	MV_STATUS status;
+	S_GponIoctlPloamTxPm ploamTxPm;
+	S_GponIoctlPloamRxPm ploamRxPm;
+
+	switch (ioctlPm->section) {
+	case E_GPON_IOCTL_PM_PLOAM_RX:
+		status  = onuGponApiPmRxPloamPmGet(&(ioctlPm->ploamRx), MV_TRUE);
+		status |= onuGponApiAdvancedPloamsCounterGet(&ploamTxPm, &(ioctlPm->ploamRx), MV_TRUE);
+		return status;
+		break;
+	case E_GPON_IOCTL_PM_PLOAM_TX:
+		status = onuGponApiAdvancedPloamsCounterGet(&(ioctlPm->ploamTx), &ploamRxPm, MV_TRUE);
+		break;
+	case E_GPON_IOCTL_PM_BW_MAP:
+		return onuGponApiPmRxBwMapPmGet(&(ioctlPm->bwMap), MV_TRUE);
+		break;
+	case E_GPON_IOCTL_PM_FEC:
+		return onuGponApiPmFecPmGet(&(ioctlPm->fec), MV_TRUE);
+		break;
+	case E_GPON_IOCTL_PM_GEM_RX:
+		return onuGponApiGemRxCounterGet(&(ioctlPm->gemRx), MV_TRUE);
+		break;
+	case E_GPON_IOCTL_PM_GEM_TX:
+		return onuGponApiGemTxCounterGet(&(ioctlPm->gemTx), MV_TRUE);
+		break;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponMiTcontConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu tcont <--> alloc
+**
+**  PARAMETERS:  MV_U32 alloc
+**               MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponMiTcontConfig(MV_U32 alloc, MV_U32 tcont)
+{
+	return onuGponApiTcontConfig(alloc, tcont);
+}
+
+/*******************************************************************************
+**
+**  onuGponMiResetTcontsConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset onu bw map table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponMiResetTcontsConfig(void)
+{
+	return onuGponApiTcontsReset();
+}
+
+/*******************************************************************************
+**
+**  onuGponMiClearTcontConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears the specifid tcont configuration
+**
+**  PARAMETERS:  MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+MV_STATUS onuGponMiClearTcontConfig(MV_U32 tcont)
+{
+	return onuGponApiTcontClear(tcont);
+}
+
+/*******************************************************************************
+**
+**  onuGponMiGem
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return onu pm info
+**
+**  PARAMETERS:  S_GponIoctlGem *ioctlGem
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponMiGem(S_GponIoctlGem *ioctlGem)
+{
+	MV_STATUS status = MV_OK;
+
+	switch (ioctlGem->action) {
+	case E_GEPON_IOCTL_GEM_ADD:
+		status = onuGponApiGemConfig(ioctlGem->gemmap, ioctlGem->action);
+		break;
+	case E_GEPON_IOCTL_GEM_REMOVE:
+		status = onuGponApiGemConfig(ioctlGem->gemmap, ioctlGem->action);
+		break;
+	case E_GEPON_IOCTL_GEM_CLEARALL:
+		status = onuGponApiGemClearAll(MV_FALSE);
+		break;
+		break;
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevIoctl
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function execute IO commands
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**               unsigned int cmd
+**               unsigned long arg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+long mvGponCdevIoctl(struct file  *filp, unsigned int cmd, unsigned long arg)
+{
+	MV_STATUS status;
+	static S_GponIoctlData ioctlData;
+	static S_GponIoctlInfo ioctlInfo;
+	static S_GponIoctlAlarm ioctlAlarm;
+	static S_GponIoctlPm ioctlPm;
+	static S_GponIoctlXvr ioctlXvr;
+	static S_GponIoctlGem ioctlGem;
+	static S_GponIoctlGemPortPmConfig ioctlGemPortPmConfig;
+	static S_GponIoctlGemPortMibCounters ioctlGemPortMibCounters;
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	/* =========================== */
+	/* ====== Init Section ======= */
+	/* =========================== */
+
+	/* ====== MVGPON_IOCTL_INIT ==================== */
+	case MVGPON_IOCTL_INIT:
+		if (copy_from_user(&ioctlInfo, (S_GponIoctlInfo *)arg, sizeof(S_GponIoctlInfo))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuGponMiInit(&ioctlInfo);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_BEN_INIT ================ */
+	case MVGPON_IOCTL_BEN_INIT:
+		if (copy_from_user(&ioctlXvr, (S_GponIoctlXvr *)arg, sizeof(S_GponIoctlXvr))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = mvOnuGponMacTxBurstEnParamSet(ioctlXvr.mask,
+						       ioctlXvr.polarity,
+						       ioctlXvr.delay,
+						       ioctlXvr.enStop,
+						       ioctlXvr.enStart);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+		break;
+
+	/* =========================== */
+	/* ====== Data Section ======= */
+	/* =========================== */
+
+	/* ====== MVGPON_IOCTL_DATA_TCONT_CONFIG ======= */
+	case MVGPON_IOCTL_DATA_TCONT_CONFIG:
+		if (copy_from_user(&ioctlData, (S_GponIoctlData *)arg, sizeof(S_GponIoctlData))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuGponMiTcontConfig(ioctlData.alloc,
+					      ioctlData.tcont);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_DATA_TCONT_RESET ======== */
+	case MVGPON_IOCTL_DATA_TCONT_RESET:
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuGponMiResetTcontsConfig();
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status == MV_OK)
+			ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_DATA_TCONT_CLEAR ======== */
+	case MVGPON_IOCTL_DATA_TCONT_CLEAR:
+		if (copy_from_user(&ioctlData, (S_GponIoctlData *)arg, sizeof(S_GponIoctlData))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status = onuGponMiClearTcontConfig(ioctlData.tcont);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (status != MV_OK)
+			goto ioctlErr;
+
+		ret = 0;
+
+		break;
+	/* ====== MVGPON_IOCTL_GEMPORT_STATE_SET ======= */
+	case MVGPON_IOCTL_GEMPORT_STATE_SET:
+		if (copy_from_user(&ioctlData, (S_GponIoctlData *)arg, sizeof(S_GponIoctlData))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		if (ioctlData.gemState != 0)
+			status = onuGponApiGemPortIdConfig(ioctlData.gemPort);
+		else
+			status = onuGponApiGemPortIdClear(ioctlData.gemPort);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_GEMPORT_STATE_GET ======= */
+	case MVGPON_IOCTL_GEMPORT_STATE_GET:
+
+		if (copy_from_user(&ioctlData, (S_GponIoctlData *)arg, sizeof(S_GponIoctlData))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		ioctlData.gemState = mvOnuGponMacPortIdValidGet(ioctlData.gemPort);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		if (copy_to_user((S_GponIoctlData *)arg, &ioctlData, sizeof(S_GponIoctlData))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* =========================== */
+	/* ====== Info Section ======= */
+	/* =========================== */
+
+	/* ====== MVGPON_IOCTL_INFO ==================== */
+	case MVGPON_IOCTL_INFO:
+		status = onuGponMiInfoGet(&ioctlInfo);
+		if (status != MV_OK)
+			goto ioctlErr;
+		if (copy_to_user((S_GponIoctlInfo *)arg, &ioctlInfo, sizeof(S_GponIoctlInfo))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_ALARM =================== */
+	case MVGPON_IOCTL_ALARM:
+		status = onuGponMiAlarm(&ioctlAlarm);
+		if (status != MV_OK)
+			goto ioctlErr;
+		if (copy_to_user((S_GponIoctlAlarm *)arg, &ioctlAlarm, sizeof(S_GponIoctlAlarm))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* =========================== */
+	/* ====== PM Section ======= */
+	/* =========================== */
+
+	/* ====== MVGPON_IOCTL_PM ==================== */
+	case MVGPON_IOCTL_PM:
+		if (copy_from_user(&ioctlPm, (S_GponIoctlPm *)arg, sizeof(S_GponIoctlPm))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		status = onuGponMiPm(&ioctlPm);
+		if (status != MV_OK)
+			goto ioctlErr;
+		if (copy_to_user((S_GponIoctlPm *)arg, &ioctlPm, sizeof(S_GponIoctlPm))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ================================== */
+	/* ====== GEM Port PM Section ======= */
+	/* ================================== */
+
+	/* ====== MVGPON_IOCTL_GEMPORT_PM_CONFIG =========== */
+	case MVGPON_IOCTL_GEMPORT_PM_CONFIG:
+		if (copy_from_user(&ioctlGemPortPmConfig, (S_GponIoctlGemPortPmConfig *)arg, sizeof(S_GponIoctlGemPortPmConfig))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		status = onuGponApiGemPortPmConfig(&ioctlGemPortPmConfig);
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_GEMPORT_PM_GET =========== */
+	case MVGPON_IOCTL_GEMPORT_PM_GET:
+		if (copy_from_user(&ioctlGemPortMibCounters, (S_GponIoctlGemPortMibCounters *)arg, sizeof(S_GponIoctlGemPortMibCounters))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_from_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		status = onuGponApiGemPortPmGet(&ioctlGemPortMibCounters);
+		if (status != MV_OK)
+			goto ioctlErr;
+		if (copy_to_user((S_GponIoctlGemPortMibCounters *)arg, &ioctlGemPortMibCounters, sizeof(S_GponIoctlGemPortMibCounters))) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy_to_user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_GEMPORT_PM_RESET =========== */
+	case MVGPON_IOCTL_GEMPORT_PM_RESET:
+		status = onuGponPmGemPortPmReset();
+		if (status != MV_OK)
+			goto ioctlErr;
+		ret = 0;
+		break;
+
+	/* ====== MVGPON_IOCTL_GEM ==================== */
+	case MVGPON_IOCTL_GEM:
+		if (copy_from_user(&ioctlGem, (S_GponIoctlGem *)arg, sizeof(S_GponIoctlGem))) {
+			printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		spin_lock_irqsave(&onuPonIrqLock, flags);
+		status =  onuGponMiGem(&ioctlGem);
+		spin_unlock_irqrestore(&onuPonIrqLock, flags);
+		ret = 0;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+ioctlErr:
+
+	return ret;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.h
new file mode 100644
index 0000000..78343ef
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsMI.h
@@ -0,0 +1,330 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsMI.h                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Management Interface           **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_LINUX_KS_MNG_INTERFACE_H
+#define _ONU_GPON_LINUX_KS_MNG_INTERFACE_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define MVGPON_IOCTL_INIT               _IOW(MVPON_IOCTL_MAGIC, 1,  unsigned int)
+#define MVGPON_IOCTL_BEN_INIT           _IOW(MVPON_IOCTL_MAGIC, 2,  unsigned int)
+#define MVGPON_IOCTL_DATA_TCONT_CONFIG  _IOW(MVPON_IOCTL_MAGIC, 3,  unsigned int)
+#define MVGPON_IOCTL_DATA_TCONT_CLEAR   _IOR(MVPON_IOCTL_MAGIC, 4,  unsigned int)
+#define MVGPON_IOCTL_DATA_TCONT_RESET    _IO(MVPON_IOCTL_MAGIC, 5)
+#define MVGPON_IOCTL_INFO               _IOR(MVPON_IOCTL_MAGIC, 6,  unsigned int)
+#define MVGPON_IOCTL_ALARM              _IOR(MVPON_IOCTL_MAGIC, 7,  unsigned int)
+#define MVGPON_IOCTL_PM                 _IOR(MVPON_IOCTL_MAGIC, 8,  unsigned int)
+#define MVGPON_IOCTL_GEM                _IOW(MVPON_IOCTL_MAGIC, 9,  unsigned int)
+#define MVGPON_IOCTL_GEMPORT_PM_CONFIG  _IOW(MVPON_IOCTL_MAGIC, 10, unsigned int)
+#define MVGPON_IOCTL_GEMPORT_PM_GET     _IOR(MVPON_IOCTL_MAGIC, 11, unsigned int)
+#define MVGPON_IOCTL_GEMPORT_PM_RESET   _IOW(MVPON_IOCTL_MAGIC, 12, unsigned int)
+#define MVGPON_IOCTL_GEMPORT_STATE_GET  _IOW(MVPON_IOCTL_MAGIC, 13, unsigned int)
+#define MVGPON_IOCTL_GEMPORT_STATE_SET  _IOW(MVPON_IOCTL_MAGIC, 14, unsigned int)
+
+#define ONU_GPON_DEBUG_STATE        (0xFF)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	E_GPON_IOCTL_PM_PLOAM_RX = 1,
+	E_GPON_IOCTL_PM_PLOAM_TX = 2,
+	E_GPON_IOCTL_PM_BW_MAP   = 3,
+	E_GPON_IOCTL_PM_FEC      = 4,
+	E_GPON_IOCTL_PM_GEM_RX   = 5,
+	E_GPON_IOCTL_PM_GEM_TX   = 6
+} E_GponIoctlPmSection;
+
+typedef enum {
+	E_GEPON_IOCTL_GEM_ADD         = 1,
+	E_GEPON_IOCTL_GEM_REMOVE      = 2,
+	E_GEPON_IOCTL_GEM_CLEARALL    = 3
+} E_GponIoctlGemAction;
+
+typedef enum {
+	GEMPORTPMCMD_STOP  = 0,
+	GEMPORTPMCMD_START = 1
+} E_GponIoctlGemPortPmCmd;
+
+typedef enum {
+	GEMPORTPMDIRECTION_BIDI = 0,
+	GEMPORTPMDIRECTION_DS   = 1,
+	GEMPORTPMDIRECTION_US   = 2
+} E_GponIoctlGemPortPmDirection;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef struct {
+	MV_U32 rxIdlePloam;
+	MV_U32 rxCrcErrorPloam;
+	MV_U32 rxFifoOverErrorPloam;
+	MV_U32 rxBroadcastPloam;
+	MV_U32 rxOnuIdPloam;
+	MV_U32 rxMsgIdPloam[ONU_GPON_DS_MSG_LAST + 1];
+	MV_U32 rxMsgTotalPloam;
+} S_GponIoctlPloamRxPm;
+
+typedef struct {
+	MV_U32 txErrMsgIdPloam[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgIdPloam[ONU_GPON_US_MSG_LAST + 1];
+	MV_U32 txMsgTotalPloam;
+} S_GponIoctlPloamTxPm;
+
+typedef struct {
+	MV_U32 allocCrcErr;
+	MV_U32 allocCorrectableCrcErr;
+	MV_U32 allocUnCorrectableCrcErr;
+	MV_U32 allocCorrec;
+	MV_U32 totalReceivedAllocBytes;
+} S_GponIoctlBwMapPm;
+
+typedef struct {
+	MV_U32 receivedBytes;
+	MV_U32 correctedBytes;
+	MV_U32 correctedBits;
+	MV_U32 receivedCodeWords;
+	MV_U32 uncorrectedCodeWords;
+} S_GponIoctlFecPm;
+
+typedef struct {
+	MV_U32 gemRxIdleGemFrames;
+	MV_U32 gemRxValidGemFrames;
+	MV_U32 gemRxUndefinedGemFrames;
+	MV_U32 gemRxOmciFrames;
+	MV_U32 gemRxDroppedGemFrames;
+	MV_U32 gemRxDroppedOmciFrames;
+	MV_U32 gemRxGemFramesWithUncorrHecErr;
+	MV_U32 gemRxGemFramesWithOneFixedHecErr;
+	MV_U32 gemRxGemFramesWithTwoFixedHecErr;
+	MV_U32 gemRxTotalByteCountOfReceivedValidGemFrames;
+	MV_U32 gemRxTotalByteCountOfReceivedUndefinedGemFrames;
+	MV_U32 gemRxGemReassembleMemoryFlush;
+	MV_U32 gemRxGemSynchLost;
+	MV_U32 gemRxEthFramesWithCorrFcs;
+	MV_U32 gemRxEthFramesWithFcsError;
+	MV_U32 gemRxOmciFramesWithCorrCrc;
+	MV_U32 gemRxOmciFramesWithCrcError;
+} S_GponIoctlGemRxPm;
+
+typedef struct {
+	MV_U32 gemTxGemPtiTypeOneFrames;
+	MV_U32 gemTxGemPtiTypeZeroFrames;
+	MV_U32 gemTxIdleGemFrames;
+	MV_U32 gemTxEthFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 gemTxEthBytesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 gemTxGemFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+	MV_U32 gemTxIdleGemFramesViaTconti[ONU_GPON_MAX_NUM_OF_T_CONTS];
+} S_GponIoctlGemTxPm;
+
+typedef struct {
+	unsigned int section;
+	union {
+		S_GponIoctlPloamRxPm ploamRx;
+		S_GponIoctlPloamTxPm ploamTx;
+		S_GponIoctlBwMapPm bwMap;
+		S_GponIoctlFecPm fec;
+		S_GponIoctlGemRxPm gemRx;
+		S_GponIoctlGemTxPm gemTx;
+	};
+} S_GponIoctlPm;
+
+typedef struct {
+	MV_U32 alarmTbl[ONU_GPON_NUM_OF_ALARMS];
+} S_GponIoctlAlarm;
+
+/* TX Map */
+typedef struct {
+	MV_U32 host_tx;
+	MV_U32 add_tx;
+} S_PonTxMap;
+
+/* PON High Priority TX */
+#define PON_MAX_TCONT_NUM (16)
+
+typedef struct {
+	MV_U32 state;
+	MV_U32 map_num;
+	S_PonTxMap tx_map[PON_MAX_TCONT_NUM];
+} S_PonHighPriTx;
+
+typedef struct {
+	MV_U32 onuId;
+	MV_U32 onuState;
+	MV_U32 onuSignalDetect;
+	MV_U32 onuDsSyncOn;
+	MV_U32 onuGponPortState;
+	MV_U32 omccPort;
+	MV_U32 omccValid;
+	MV_U32 serialNumSource;
+	MV_U8 serialNum[8];
+	MV_U8 password[12];
+	MV_U32 disableSn;
+	MV_U32 clearGem;
+	MV_U32 clearTcont;
+	MV_U32 restoreGem;
+	MV_U32 dgPolarity;
+	MV_U32 ponXvrBurstEnPolarity;
+	MV_U32 ponXvrPolarity;
+	MV_U32 p2pXvrBurstEnPolarity;
+	MV_U32 p2pXvrPolarity;
+	MV_U32 fecHyst;
+	MV_U32 couplingMode; /* AC Coupling Mode */
+	MV_U32 disStatus;
+	MV_U32 omciCpuRxQueue;
+	MV_U32 omciFastPath;
+	S_PonHighPriTx ponHighPriTx;
+} S_GponIoctlInfo;
+
+typedef struct {
+	MV_U32 alloc;
+	MV_U32 tcont;
+	MV_U32 gemPort;
+	MV_U32 gemState;
+} S_GponIoctlData;
+
+typedef struct {
+	MV_U32 mask;
+	MV_U32 polarity;
+	MV_U32 delay;
+	MV_U32 enStop;
+	MV_U32 enStart;
+} S_GponIoctlXvr;
+
+/* Gem */
+typedef struct {
+	uint32_t gemmap[GPON_ONU_MAX_GEM_PORTS / 32];
+	E_GponIoctlGemAction action;
+} S_GponIoctlGem;
+
+typedef struct {
+	E_GponIoctlGemPortPmCmd command;
+	MV_U16 gem_port;
+	E_GponIoctlGemPortPmDirection direction;
+} S_GponIoctlGemPortPmConfig;
+
+typedef struct {
+	MV_U16 gem_port;
+	E_GponIoctlGemPortPmDirection direction;
+
+	MV_U64 good_octets_received;
+	MV_U32 bad_octets_received;
+	MV_U32 mac_trans_error;
+	MV_U32 good_frames_received;
+	MV_U32 bad_frames_received;
+	MV_U32 broadcast_frames_received;
+	MV_U32 multicast_frames_received;
+	MV_U32 frames_64_octets;
+	MV_U32 frames_65_to_127_octets;
+	MV_U32 frames_128_to_255octets;
+	MV_U32 frames_256_to_511_octets;
+	MV_U32 frames_512_to_1023_octets;
+	MV_U32 frames_1024_to_max_octets;
+	MV_U64 good_octets_sent;
+	MV_U32 good_frames_sent;
+	MV_U32 multicast_frames_sent;
+	MV_U32 broadcast_frames_sent;
+	MV_U32 bad_crc_received;
+} S_GponIoctlGemPortMibCounters;
+
+typedef struct {
+	S_GponIoctlInfo g_info;
+	S_GponIoctlAlarm alarm;
+	S_GponIoctlPm g_pm;
+	S_GponIoctlData data;
+	struct cdev cdev;
+} S_GponModuleCdev;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+MV_STATUS onuGponMngInterfaceCreate(void);
+MV_STATUS onuGponMngInterfaceRelease(void);
+void      onuGponMiNotifyCallback(MV_U32 onuState);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_LINUX_KS_MNG_INTERFACE_H */
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.c
new file mode 100644
index 0000000..4d4136c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.c
@@ -0,0 +1,4820 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsUI.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON CLI functionality            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "gponOnuHeader.h"
+
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+#include "mvSysPonConfig.h"
+#endif
+#endif /* PON_FPGA */
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/perf/gpon/gponOnuLnxKsUI.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+MV_BOOL ponRandomDelayLegacyMode = MV_TRUE;
+extern MV_BOOL onuGponLogEnable;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+MV_BOOL infoGponCntReadClearInd = MV_TRUE;
+MV_U32 maxPloamsSend = 270;
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Info Commands                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiInfoShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu information
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiInfoShow(char *buf)
+{
+	MV_U8   *stateText[] = { "",
+				 "INITIAL",
+				 "STANDBY",
+				 "SERIAL NUMBER",
+				 "RANGING",
+				 "OPERATION",
+				 "POPUP",
+				 "EMERGENCY STOP" };
+	MV_U8   *boolText[] = { "FALSE", "TRUE" };
+	MV_U8 serialNumber[8];
+	MV_U8 password[10];
+	MV_U32 onuId, onuState;
+	MV_BOOL init, omcc, snMaskEnable, snMaskMatchMode;
+	MV_U32 berInt, dummy, omccPort;
+	MV_U32 guard, pre1Size;
+	MV_U32 pre2Size, pre3RaSize, pre3OpSize, pre3Pat;
+	MV_U32 dbDelimiter, asicDelimiter, sd, sf;
+	MV_U32 intDelay, eqdDb, eqdAsic, fDelay;
+	MV_U32 snMsg[3], idleMsg[3];
+	MV_U8   *mchText[] = { "NO MATCH", "MATCH " };
+	int off = 0;
+
+	onuGponDbSerialNumGet(serialNumber);
+	onuState        = onuGponDbOnuStateGet();
+	onuId           = onuGponDbOnuIdGet();
+	init            = onuGponDbInitGet();
+	omcc            = onuGponDbOmccValidGet();
+	omccPort        = onuGponDbOmccPortGet();
+	snMaskEnable    = onuGponDbSerialNumberMaskEnableGet();
+	snMaskMatchMode = onuGponDbSerialNumberMaskMatchGet();
+	onuGponDbPasswordGet(password);
+	guard           = onuGponDbGuardBitsGet();
+	berInt          = onuGponDbBerIntervalGet();
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_01, &dummy, &pre1Size);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_02, &dummy, &pre2Size);
+	onuGponDbPreambleGet(ONU_GPON_PREM_TYPE_03, &pre3Pat, &dummy);
+	pre3OpSize      = onuGponDbExtPreambleOperGet();
+	pre3RaSize      = onuGponDbExtPreambleSyncGet();
+	sd              = onuGponDbSdThresholdGet();
+	sf              = onuGponDbSfThresholdGet();
+	intDelay        = onuGponDbConstDelayGet();
+	eqdDb           = onuGponDbEqualizationDelayGet();
+	mvOnuGponMacRxEqualizationDelayGet(&eqdAsic);
+	mvOnuGponMacTxFinalDelayGet(&fDelay);
+	dbDelimiter     = onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_01) |
+			  (onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_02) << 8) |
+			  (onuGponDbDelimiterGet(ONU_GPON_DELM_BYTE_03) << 16);
+	mvOnuGponMacTxDelimiterGet(&asicDelimiter, &dummy);
+	onuGponDbSnMsgGet(snMsg);
+	onuGponDbIdleMsgGet(idleMsg);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "ONT Full Information:\n");
+	off += mvOsSPrintf(buf + off, "---------------------\n");
+	off += mvOsSPrintf(buf + off, "SN[VENDOR ID]:                 %02X:%02X:%02X:%02X [%c%c%c%c]\n",
+			   serialNumber[0], serialNumber[1], serialNumber[2], serialNumber[3],
+			   serialNumber[0], serialNumber[1], serialNumber[2], serialNumber[3]);
+	off += mvOsSPrintf(buf + off, "SN[Serial Number]:             %02X:%02X:%02X:%02X\n",
+			   serialNumber[4], serialNumber[5], serialNumber[6], serialNumber[7]);
+	off += mvOsSPrintf(buf + off, "ONU ID:                        %d\n", onuId);
+	off += mvOsSPrintf(buf + off, "ONU STATE:                     %d [%s]\n", onuState, stateText[onuState]);
+	off += mvOsSPrintf(buf + off, "INIT STATE:                    %s\n", boolText[init]);
+	off += mvOsSPrintf(buf + off, "OMCC Valid:                    %s\n", boolText[omcc]);
+	off += mvOsSPrintf(buf + off, "OMCC Port:                     %d\n", omccPort);
+	off += mvOsSPrintf(buf + off, "Password:                      %02X.%02X.%02X.%02X.%02X.%02X.%02X.%02X.%02X.%02X\n",
+			   password[0], password[1], password[2], password[3], password[4],
+			   password[5], password[6], password[7], password[8], password[9]);
+	off += mvOsSPrintf(buf + off, "BER Interval:                  %d\n", berInt);
+	off += mvOsSPrintf(buf + off, "SD Threshold:                  %d\n", sd);
+	off += mvOsSPrintf(buf + off, "SF Threshold:                  %d\n", sf);
+	off += mvOsSPrintf(buf + off, "Guard Bits:                    %d\n", guard);
+	off += mvOsSPrintf(buf + off, "Preamble Type1 Size:           %d\n", pre1Size);
+	off += mvOsSPrintf(buf + off, "Preamble Type2 Size:           %d\n", pre2Size);
+	off += mvOsSPrintf(buf + off, "Preamble Type3 Pattern:        0x%02X\n", pre3Pat);
+	off += mvOsSPrintf(buf + off, "Preamble Type3 Range Size:     %d\n", pre3RaSize);
+	off += mvOsSPrintf(buf + off, "Preamble Type3 Oper Size:      %d\n", pre3OpSize);
+	off += mvOsSPrintf(buf + off, "Delimiter:                     0x%08X [0x%08X]\n", dbDelimiter, asicDelimiter);
+	off += mvOsSPrintf(buf + off, "Internal Delay:                %d [0x%x]\n", intDelay, intDelay);
+	off += mvOsSPrintf(buf + off, "Equalization Delay:            %d [0x%x] (HW:0x%x)\n", eqdDb, eqdDb, eqdAsic);
+	off += mvOsSPrintf(buf + off, "Final Delay:                   %d\n", fDelay);
+	off += mvOsSPrintf(buf + off, "Const Idle Ploam:              [0x%08X][0x%08X][0x%08X]\n", idleMsg[0], idleMsg[1], idleMsg[2]);
+	off += mvOsSPrintf(buf + off, "Const Serial Number Ploam:     [0x%08X][0x%08X][0x%08X]\n", snMsg[0], snMsg[1], snMsg[2]);
+	off += mvOsSPrintf(buf + off, "Serial Number Mask Enable:     %s\n", boolText[snMaskEnable]);
+	off += mvOsSPrintf(buf + off, "Serial Number Mask Match Mode: %s\n", mchText [snMaskMatchMode]);
+	off += mvOsSPrintf(buf + off, "Debug Mode:                    %s\n", boolText[onuGponPonMngDebugModeGet()]);
+	off += mvOsSPrintf(buf + off, "Overhead Manual Mode:          %s\n", boolText[onuGponPonMngOverheadManualModeGet()]);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiAlarmShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu alarms
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiAlarmShow(char *buf)
+{
+	MV_STATUS rcode;
+	MV_U32 alarms;
+	MV_U32 iAlarm;
+	MV_U8     *alarmText[] = { "LOS ", "LOF ", "LCDA", "LCDG", " SF ", " SD ", " TF ",
+				   "SUF ", "MEM ", "DACT", "DIS ", "MIS ", "PEE ", "RDI " };
+	MV_U8     *statusText[] = { "OFF", "ON " };
+	MV_U32 status;
+	int off = 0;
+
+	rcode = onuGponApiAlarmsGet(&alarms);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get alarms status, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "------------------\n");
+	off += mvOsSPrintf(buf + off, "|ONU ALARMS:     |\n");
+	off += mvOsSPrintf(buf + off, "------------------\n");
+	off += mvOsSPrintf(buf + off, "| ALARM | STATUS |\n");
+	off += mvOsSPrintf(buf + off, "------------------\n");
+
+	for (iAlarm = 0 ; iAlarm < ONU_GPON_MAX_ALARMS ; iAlarm++) {
+		status = (alarms >> iAlarm) & 0x01;
+		off += mvOsSPrintf(buf + off, " %s   | %s    |\n", alarmText[iAlarm], statusText[status]);
+	}
+
+	off += mvOsSPrintf(buf + off, "------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiFifoShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints US PLOAM statistics
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiFifoShow(char *buf)
+{
+	S_MacFifoCtrl*  fifo;
+	int auditEn, auditAc, fifoSup;
+	int msgSend, allocFifo, freeFifo, ploamSend;
+	int off = 0;
+
+	mvOnuGponMacFifoGetInfo(&fifo, &fifoSup);
+	mvOnuGponMacFifoGetStat(&msgSend, &allocFifo, &freeFifo, &ploamSend);
+	mvOnuGponMacFifoAuditGetStat(&auditEn, &auditAc);
+
+	if (fifoSup) {
+		off += mvOsSPrintf(buf + off, "===========================\n");
+		off += mvOsSPrintf(buf + off, "GPON SW FIFO\n");
+		off += mvOsSPrintf(buf + off, "===========================\n");
+		off += mvOsSPrintf(buf + off, "FIFO size               %d\n", GPON_SW_FIFO_SIZE);
+		off += mvOsSPrintf(buf + off, "Write index             %d\n", fifo->fifoWriteIndex);
+		off += mvOsSPrintf(buf + off, "Read index              %d\n", fifo->fifoReadIndex);
+		off += mvOsSPrintf(buf + off, "Repeating cycle number  %d\n", fifo->fifoReparoundNum);
+		off += mvOsSPrintf(buf + off, "===========================\n");
+		off += mvOsSPrintf(buf + off, "FIFO Audit Enter cnt.   %d\n", auditEn);
+		off += mvOsSPrintf(buf + off, "FIFO Audit Action cnt.  %d\n", auditAc);
+	}
+
+	off += mvOsSPrintf(buf + off, "===========================\n");
+	off += mvOsSPrintf(buf + off, "US msg. send cnt.       %d\n", msgSend);
+
+	if (fifoSup) {
+		off += mvOsSPrintf(buf + off, "Add to SW FIFO cnt.     %d\n", allocFifo);
+		off += mvOsSPrintf(buf + off, "Free SW FIFO cnt.       %d\n", freeFifo);
+	}
+
+	off += mvOsSPrintf(buf + off, "Add to HW FIFO cnt.     %d\n", ploamSend);
+	off += mvOsSPrintf(buf + off, "===========================\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiFecStatus
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints DS FEC Statsus
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiFecStatus(char *buf)
+{
+	MV_U32 fecMode;
+	int off = 0;
+
+	onuGponApiFecStatusGet(&fecMode);
+
+	off += mvOsSPrintf(buf + off, "GPON FEC Status - %s\n", (fecMode == 0) ? ("Off") : ("On"));
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiInfoHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print info help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiInfoHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat info      - dump onu information\n");
+	off += mvOsSPrintf(buf + off, " cat alarm     - dump onu alarms\n");
+	off += mvOsSPrintf(buf + off, " cat fecStatus - dump onu fec status\n");
+	off += mvOsSPrintf(buf + off, " cat swfifo    - dump onu SW FIFO info\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            PM Commands                                     */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiCountersReadClearFlag
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu FEC counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuGponUiCountersReadClearFlag(MV_BOOL clear)
+{
+	infoGponCntReadClearInd = clear;
+}
+
+/*******************************************************************************
+**
+**  onuGponBwMapCountersEnDisFlag
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu FEC counters
+**
+**  PARAMETERS:  MV_BOOL enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponBwMapCountersEnDisFlag(MV_BOOL enable)
+{
+	return onuGponApiPmRxBwMapPmDumpSet(enable);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiFecCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu FEC counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiFecCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_GponIoctlFecPm counters;
+	int off = 0;
+
+	MV_U8  *counterText[] = { "FEC received Bytes       ",
+				  "FEC corrected Bytes      ",
+				  "FEC corrected Bits       ",
+				  "FEC received CodeWords   ",
+				  "FEC uncorrected CodeWords" };
+
+	rcode = onuGponApiPmFecPmGet(&counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "------------------\n");
+	off += mvOsSPrintf(buf + off, "| FEC COUNTERS:   |\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| COUNTER                   |   VALUE      |\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[0], counters.receivedBytes);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[1], counters.correctedBytes);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[2], counters.correctedBits);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[3], counters.receivedCodeWords);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[4], counters.uncorrectedCodeWords);
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiRxPloamCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu Rx Ploam counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiRxPloamCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_GponIoctlPloamRxPm counters;
+	S_GponIoctlPloamTxPm countDummy;
+	MV_U32 MsgId;
+	int off = 0;
+
+	MV_U8 *counterText[] = { "Idle Ploam Counter                 ",
+				 "CRC Error Ploam Counter            ",
+				 "FIFO Overflaw Error Ploam Counter  ",
+				 "received Broadcast Ploam Counter   ",
+				 "Received Onu Id Ploam Counter      " };
+
+	MV_U8 *msgIdCntText  =  { "Total PLOAM        " };
+	MV_U8 *msgIdText[]   =  { "ERROR PLOAM        ",
+				  "OVERHEAD           ",
+				  "SN_MASK            ",
+				  "ASSIGN_ONU_ID      ",
+				  "RANGING_TIME       ",
+				  "DACT_ONU_ID        ",
+				  "DIS_SN             ",
+				  "CONFIG_VP_VC       ",
+				  "ENCRYPT_VPI_PORT_ID",
+				  "REQ_PASSWORD       ",
+				  "ASSIGN_ALLOC_ID    ",
+				  "NO_MESSAGE         ",
+				  "POPUP              ",
+				  "REQ_KEY            ",
+				  "CONFIG_PORT_ID     ",
+				  "PHYSICAL_EQUIP_ERR ",
+				  "CHANGE_POWER_LEVEL ",
+				  "PST                ",
+				  "BER_INTERVAL       ",
+				  "KEY_SWITCH_TIME    ",
+				  "EXT_BURST_LEN      " };
+
+	rcode  = onuGponApiPmRxPloamPmGet(&counters, infoGponCntReadClearInd);
+	rcode |= onuGponApiAdvancedPloamsCounterGet(&countDummy, &counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+	off += mvOsSPrintf(buf + off, "|RX PLOAM COUNTERS:     |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| HW COUNTERS                          |    VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[0], counters.rxIdlePloam);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[1], counters.rxCrcErrorPloam);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[2], counters.rxFifoOverErrorPloam);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[3], counters.rxBroadcastPloam);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[4], counters.rxOnuIdPloam);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| SW COUNTERS          |    VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", msgIdCntText, counters.rxMsgTotalPloam);
+
+	for (MsgId = 0; MsgId <= ONU_GPON_DS_MSG_LAST; MsgId++)
+		off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", msgIdText[MsgId], counters.rxMsgIdPloam[MsgId]);
+
+	off += mvOsSPrintf(buf + off, "--------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiTxPloamCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu Tx Ploam counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiTxPloamCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_GponIoctlPloamRxPm countDummy;
+	S_GponIoctlPloamTxPm counters;
+	MV_U32 MsgId;
+	int off = 0;
+
+	MV_U8 *msgIdText[] = { "Total Ploams Recived",
+			       "SN_ONU              ",
+			       "PASSWORD            ",
+			       "DYING_GASP          ",
+			       "NO_MESSAGE          ",
+			       "ENCRYPT_KEY         ",
+			       "PHYSICAL_EQUIP_ERR  ",
+			       "PST                 ",
+			       "REI                 ",
+			       "ACK                 " };
+
+	rcode = onuGponApiAdvancedPloamsCounterGet(&counters, &countDummy, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+	off += mvOsSPrintf(buf + off, "|TX PLOAM COUNTERS:     |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| COUNTER             |    VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s | %10d  |\n", msgIdText[0], counters.txMsgTotalPloam);
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| TX Error            |    VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+
+	for (MsgId = 1; MsgId <= ONU_GPON_US_MSG_LAST; MsgId++)
+		off += mvOsSPrintf(buf + off, " %s | %10d  |\n", msgIdText[MsgId], counters.txErrMsgIdPloam[MsgId]);
+
+
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| TX Correct          |    VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+
+	for (MsgId = 1; MsgId <= ONU_GPON_US_MSG_LAST; MsgId++)
+		off += mvOsSPrintf(buf + off, " %s | %10d  |\n", msgIdText[MsgId], counters.txMsgIdPloam[MsgId]);
+
+	off += mvOsSPrintf(buf + off, "-------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiBwMapCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu bw map counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiBwMapCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_GponIoctlBwMapPm counters;
+	int off = 0;
+
+	MV_U8 *counterText[] = { "Alloc Crc Error               ",
+				 "Alloc Correctable Crc Error   ",
+				 "Alloc UnCorrectable Crc Error ",
+				 "Alloc Correct                 ",
+				 "Total Received Alloc Bytes    " };
+
+	rcode = onuGponApiPmRxBwMapPmGet(&counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "----------------------\n");
+	off += mvOsSPrintf(buf + off, "| BWMAP COUNTERS:    |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| COUNTER                         |   VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s   | %10u |\n", counterText[0], counters.allocCrcErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u |\n", counterText[1], counters.allocCorrectableCrcErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u |\n", counterText[2], counters.allocUnCorrectableCrcErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u |\n", counterText[3], counters.allocCorrec);
+	off += mvOsSPrintf(buf + off, " %s   | %10u |\n", counterText[4], counters.totalReceivedAllocBytes);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiStandardCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu standard counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiStandardCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_RxStandardApiPm counters;
+	int off = 0;
+
+	MV_U8 *counterText[] = { "bip8 Error Counter     ",
+				 "plend Counter          " };
+
+	rcode = onuGponApiPmRxStandardPmGet(&counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "-------------------------\n");
+	off += mvOsSPrintf(buf + off, "|STANDARD COUNTERS:     |\n");
+	off += mvOsSPrintf(buf + off, "-----------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| COUNTER                  |    VALUE   |\n");
+	off += mvOsSPrintf(buf + off, "-----------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " %s   | %8u   |\n", counterText[0], counters.bip8);
+	off += mvOsSPrintf(buf + off, " %s   | %8u   |\n", counterText[1], counters.plend);
+	off += mvOsSPrintf(buf + off, "-----------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu gem counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiGemCountersShow(char *buf)
+{
+	MV_STATUS rcode;
+	S_GponIoctlGemRxPm counters;
+	int off = 0;
+
+	MV_U8 *counterText[] = { "Received Idle Gem Frames                       ",
+				 "Received Valid Gem Frames                      ",
+				 "Received Undefined Gem Frames                  ",
+				 "Received Omci Frames                           ",
+				 "Dropped Gem Frames                             ",
+				 "Dropped Omci Frames                            ",
+				 "Received Gem Frames With Uncorr Hec Error      ",
+				 "Received Gem Frames With One Fixed Hec Error   ",
+				 "Received Gem Frames With Two Fixed Hec Error   ",
+				 "Received Valid Gem Frames Total Byte Count     ",
+				 "Received Undefined Gem Frames Total Byte Count ",
+				 "Gem Reassemble Memory Flush                    ",
+				 "Gem Synch Lost                                 ",
+				 "Received Eth Frames With Correct FCS           ",
+				 "Received Eth Frames With FCS Error             ",
+				 "Received Omci Frames With Correct CRC          ",
+				 "Received Omci Frames With CRC Error            " };
+
+	rcode = onuGponApiGemRxCounterGet(&counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "----------------------\n");
+	off += mvOsSPrintf(buf + off, "|GEM COUNTERS:       |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| COUNTER                                          |  VALUE      |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------\n");
+
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[0], counters.gemRxIdleGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[1], counters.gemRxValidGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[2], counters.gemRxUndefinedGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[3], counters.gemRxOmciFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[4], counters.gemRxDroppedGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[5], counters.gemRxDroppedOmciFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[6], counters.gemRxGemFramesWithUncorrHecErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[7], counters.gemRxGemFramesWithOneFixedHecErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[8], counters.gemRxGemFramesWithTwoFixedHecErr);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[9], counters.gemRxTotalByteCountOfReceivedValidGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[10], counters.gemRxTotalByteCountOfReceivedUndefinedGemFrames);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[11], counters.gemRxGemReassembleMemoryFlush);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[12], counters.gemRxGemSynchLost);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[13], counters.gemRxEthFramesWithCorrFcs);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[14], counters.gemRxEthFramesWithFcsError);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[15], counters.gemRxOmciFramesWithCorrCrc);
+	off += mvOsSPrintf(buf + off, " %s   | %10u  |\n", counterText[16], counters.gemRxOmciFramesWithCrcError);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiTxCountersShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu tx counters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0
+**
+*******************************************************************************/
+int onuGponUiTxCountersShow(void)
+{
+	MV_STATUS rcode;
+	S_GponIoctlGemTxPm counters;
+	MV_BOOL exist;
+	MV_U32 tcont;
+	int off = 0;
+
+	MV_U8 *counterText[] = { "Transmitted Gem Pti Type-1 Frames              ",
+				 "Transmitted Gem Pti Type-0 Frames              ",
+				 "Transmitted Idle Gem Frames                    ",
+				 "Transmitted Eth Frames Via Tcont               ",
+				 "Transmitted Eth Bytes Via Tcont                ",
+				 "Transmitted Gem Frames Via Tcont               ",
+				 "Transmitted Idle Gem Frames Via Tcont          " };
+
+	rcode = onuGponApiGemTxCounterGet(&counters, infoGponCntReadClearInd);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get counters value, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	mvOsPrintf("\n");
+	mvOsPrintf("----------------------\n");
+	mvOsPrintf("|TX COUNTERS:        |\n");
+	mvOsPrintf("------------------------------------------------------------------\n");
+	mvOsPrintf("| COUNTER                                          |  VALUE      |\n");
+	mvOsPrintf("------------------------------------------------------------------\n");
+	mvOsPrintf(" %s   | %10u  |\n", counterText[0], counters.gemTxGemPtiTypeOneFrames);
+	mvOsPrintf(" %s   | %10u  |\n", counterText[1], counters.gemTxGemPtiTypeZeroFrames);
+	mvOsPrintf(" %s   | %10u  |\n", counterText[2], counters.gemTxIdleGemFrames);
+
+	for (tcont = 0; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+		rcode = onuGponDbBwTcontExist(tcont, &exist);
+		if ((rcode == MV_OK) && (exist != MV_FALSE)) {
+			mvOsPrintf("T-Cont [%d] Counters                                              |\n", tcont);
+			mvOsPrintf("------------------------------------------------------------------\n");
+			mvOsPrintf(" %s   | %10u  |\n", counterText[3], counters.gemTxEthFramesViaTconti[tcont]);
+			mvOsPrintf(" %s   | %10u  |\n", counterText[4], counters.gemTxEthBytesViaTconti[tcont]);
+			mvOsPrintf(" %s   | %10u  |\n", counterText[5], counters.gemTxGemFramesViaTconti[tcont]);
+			mvOsPrintf(" %s   | %10u  |\n", counterText[6], counters.gemTxIdleGemFramesViaTconti[tcont]);
+		}
+	}
+
+	mvOsPrintf("------------------------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiRawCounters
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu counters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiRaw_1Counters(char *buf)
+{
+	MV_U32 suspected;
+	MV_U32 decided;
+	S_RxPloamPm inRxPloamCounters;
+	S_RxBwMapPm inRxBwMapCounters;
+	S_RxBip8Pm inBip8Counter;
+	S_RxOmciPm inOmciCounter;
+	S_RxPlendPm inPlendCounter;
+	S_RxFecPm inRxFecCounters;
+	S_GemPm gemCounters;
+	int off = 0;
+
+	decided = onuGponPonMngrFifoErrCountersGet(&suspected);
+	onuGponPmFecPmGet(&inRxFecCounters);
+	onuGponPmRxBwMapPmGet(&inRxBwMapCounters);
+	onuGponPmRxBip8PmGet(&inBip8Counter);
+	onuGponPmRxOmciPmGet(&inOmciCounter);
+	onuGponPmRxPlendPmGet(&inPlendCounter);
+	onuGponPmRxPloamPmGet(&inRxPloamCounters);
+	onuGponPmGemPmGet(&gemCounters);
+
+	off += mvOsSPrintf(buf + off, "ONT GPON Counters\n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "PLOAM FIFO SYNC ERROR SUSPECTED:                   %u\n", suspected);
+	off += mvOsSPrintf(buf + off, "PLOAM FIFO SYNC ERROR DECIDED:                     %u\n", decided);
+	off += mvOsSPrintf(buf + off, "This ONU ID PLOAMs:                                %u\n", inRxPloamCounters.receivedOnuIdPloamCounter);
+	off += mvOsSPrintf(buf + off, "Broadcast PLOAMs:                                  %u\n", inRxPloamCounters.receivedBroadcastPloamCounter);
+	off += mvOsSPrintf(buf + off, "Idles PLOAMs:                                      %u\n", inRxPloamCounters.idlePloamCounter);
+	off += mvOsSPrintf(buf + off, "CRC Error PLOAMs:                                  %u\n", inRxPloamCounters.crcErrorPloamCounter);
+	off += mvOsSPrintf(buf + off, "FIFO Full Dropped PLOAMs:                          %u\n", inRxPloamCounters.fifoOverErrorPloamCounter);
+	off += mvOsSPrintf(buf + off, "BW Error Free Allocs:                              %u\n", inRxBwMapCounters.allocCorrec);
+	off += mvOsSPrintf(buf + off, "BW Uncorrectable Allocs:                           %u\n", inRxBwMapCounters.allocUnCorrectableCrcErr);
+	off += mvOsSPrintf(buf + off, "BW Bad CRC Allocs:                                 %u\n", inRxBwMapCounters.allocCrcErr);
+	off += mvOsSPrintf(buf + off, "BW Error Free and Correctable Allocs:              %u\n", inRxBwMapCounters.allocCorrectableCrcErr);
+	off += mvOsSPrintf(buf + off, "BW Total Allocation:                               %u\n", inRxBwMapCounters.totalReceivedAllocBytes);
+	off += mvOsSPrintf(buf + off, "Bip8:                                              %u\n", inBip8Counter.bip8);
+#ifdef PON_A0
+	off += mvOsSPrintf(buf + off, "D/S OMCI packets received by fast path:            %u\n", inOmciCounter.receivedOmciCounter);
+#endif
+	off += mvOsSPrintf(buf + off, "Plend:                                             %u\n", inPlendCounter.plend);
+	off += mvOsSPrintf(buf + off, "FEC correctedBits:                                 %u\n", inRxFecCounters.correctedBits);
+	off += mvOsSPrintf(buf + off, "FEC correctedBytes:                                %u\n", inRxFecCounters.correctedBytes);
+	off += mvOsSPrintf(buf + off, "FEC receivedBytes:                                 %u\n", inRxFecCounters.receivedBytes);
+	off += mvOsSPrintf(buf + off, "FEC receivedCodeWords:                             %u\n", inRxFecCounters.receivedCodeWords);
+	off += mvOsSPrintf(buf + off, "FEC uncorrectedCodeWords:                          %u\n", inRxFecCounters.uncorrectedCodeWords);
+	off += mvOsSPrintf(buf + off, "GEM Received Idle Gem Frames                       %u\n", gemCounters.receivedIdleGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Received Valid Gem Frames                      %u\n", gemCounters.receivedValidGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Received Undefined Gem Frames                  %u\n", gemCounters.receivedUndefinedGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Received Omci Frames                           %u\n", gemCounters.receivedOmciFrames);
+	off += mvOsSPrintf(buf + off, "GEM Dropped Gem Frames                             %u\n", gemCounters.droppedGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Dropped Omci Frames                            %u\n", gemCounters.droppedOmciFrames);
+	off += mvOsSPrintf(buf + off, "GEM Received Gem Frames With Uncorr Hec Error      %u\n", gemCounters.receivedGemFramesWithUncorrHecErr);
+	off += mvOsSPrintf(buf + off, "GEM Received Gem Frames With One Fixed Hec Error   %u\n", gemCounters.receivedGemFramesWithOneFixedHecErr);
+	off += mvOsSPrintf(buf + off, "GEM Received Gem Frames With Two Fixed Hec Error   %u\n", gemCounters.receivedGemFramesWithTwoFixedHecErr);
+	off += mvOsSPrintf(buf + off, "GEM Received Valid Gem Frames Total Byte Count     %u\n", gemCounters.totalByteCountOfReceivedValidGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Received Undefined Gem Frames Total Byte Count %u\n", gemCounters.totalByteCountOfReceivedUndefinedGemFrames);
+	off += mvOsSPrintf(buf + off, "GEM Gem Reassemble Memory Flush                    %u\n", gemCounters.gemReassembleMemoryFlush);
+	off += mvOsSPrintf(buf + off, "GEM Gem Synch Lost                                 %u\n", gemCounters.gemSynchLost);
+	off += mvOsSPrintf(buf + off, "GEM Received Eth Frames With Correct FCS           %u\n", gemCounters.receivedEthFramesWithCorrFcs);
+	off += mvOsSPrintf(buf + off, "GEM Received Eth Frames With FCS Error             %u\n", gemCounters.receivedEthFramesWithFcsError);
+	off += mvOsSPrintf(buf + off, "GEM Received Omci Frames With Correct CRC          %u\n", gemCounters.receivedOmciFramesWithCorrCrc);
+	off += mvOsSPrintf(buf + off, "GEM Received Omci Frames With CRC Error            %u\n", gemCounters.receivedOmciFramesWithCrcError);
+
+	return off;
+}
+
+int onuGponUiRaw_2Counters(char *buf)
+{
+	S_GponTxPm txCounters;
+	MV_U32 tcont;
+	int off = 0;
+
+	onuGponPmTxPmGet(&txCounters);
+
+	off += mvOsSPrintf(buf + off, "ONT GPON Raw Counters T-Cont 0 to 7\n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+
+	off += mvOsSPrintf(buf + off, "Transmitted Gem Pti Type-1 Frames                  %u\n", txCounters.transmittedGemPtiTypeOneFrames);
+	off += mvOsSPrintf(buf + off, "Transmitted Gem Pti Type-0 Frames                  %u\n", txCounters.transmittedGemPtiTypeZeroFrames);
+	off += mvOsSPrintf(buf + off, "Transmitted Idle Gem Frames                        %u\n", txCounters.transmittedIdleGemFrames);
+	off += mvOsSPrintf(buf + off, "Transmitted Tx Enable Count                        %u\n", txCounters.transmittedTxEnableCount);
+
+	for (tcont = 0; tcont < 8; tcont++) {
+		off += mvOsSPrintf(buf + off, "T-Cont [%d] Counters                                      \n", tcont);
+		off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "Transmitted Eth Frames Via Tcont                   %u\n", txCounters.transmittedEthFramesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Eth Bytes Via Tcont                    %u\n", txCounters.transmittedEthBytesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Gem Frames Via Tcont                   %u\n", txCounters.transmittedGemFramesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Idle Gem Frames Via Tcont              %u\n", txCounters.transmittedIdleGemFramesViaTconti[tcont]);
+	}
+
+	return off;
+}
+
+int onuGponUiRaw_3Counters(char *buf)
+{
+	S_GponTxPm txCounters;
+	MV_U32 tcont;
+	int off = 0;
+
+	onuGponPmTxPmGet(&txCounters);
+
+	off += mvOsSPrintf(buf + off, "ONT GPON Raw Counters T-Cont 8 to 15\n");
+	for (tcont = 8; tcont < ONU_GPON_MAX_NUM_OF_T_CONTS; tcont++) {
+		off += mvOsSPrintf(buf + off, "T-Cont [%d] Counters                                      \n", tcont);
+		off += mvOsSPrintf(buf + off, "----------------------------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "Transmitted Eth Frames Via Tcont                   %u\n", txCounters.transmittedEthFramesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Eth Bytes Via Tcont                    %u\n", txCounters.transmittedEthBytesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Gem Frames Via Tcont                   %u\n", txCounters.transmittedGemFramesViaTconti[tcont]);
+		off += mvOsSPrintf(buf + off, "Transmitted Idle Gem Frames Via Tcont              %u\n", txCounters.transmittedIdleGemFramesViaTconti[tcont]);
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiPmHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print pm help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiPmHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[DEC]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [state] > cntRdClrFlState  - onu counters flag, Read[0], Read Clear[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [state] > bwMapCntByState  - dump bw map counters before changing ONU state\n");
+	off += mvOsSPrintf(buf + off, "                                   Disable[0], Enable[1]                    \n");
+	off += mvOsSPrintf(buf + off, " echo [gemport] [dirn] > startGemPortMibPm - Start GEM port MIB PM. dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, " echo [gemport] [dirn] > stopGemPortMibPm  - Stop  GEM port MIB PM. dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, " echo [dummy]          > resetMibPm        - Reset MIB PM\n");
+	off += mvOsSPrintf(buf + off, " echo [gemport] [dirn] > getMibPm          - Get GEM port MIB counters. dirn: bidi[0], DS[1], US[2]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat rxPloamCnt               - dump Rx PLOAM counters\n");
+	off += mvOsSPrintf(buf + off, " cat txPloamCnt               - dump Tx PLOAM counters\n");
+	off += mvOsSPrintf(buf + off, " cat bwMapCnt                 - dump bw map counters\n");
+	off += mvOsSPrintf(buf + off, " cat stdCnt                   - dump standard counters\n");
+	off += mvOsSPrintf(buf + off, " cat fecCnt                   - dump fec counters\n");
+	off += mvOsSPrintf(buf + off, " cat gemCnt                   - dump gem counters\n");
+	off += mvOsSPrintf(buf + off, " cat txCnt                    - dump Tx counters\n");
+	off += mvOsSPrintf(buf + off, " cat rawCnt_1                 - dump raw counters\n");
+	off += mvOsSPrintf(buf + off, " cat rawCnt_2                 - dump raw counters\n");
+	off += mvOsSPrintf(buf + off, " cat rawCnt_3                 - dump raw counters\n");
+	off += mvOsSPrintf(buf + off, " cat showGemPortMibPmDb       - display list of gem ports enabled for MIB PM\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Data Commands                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiTcontConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu tcont <--> alloc
+**
+**  PARAMETERS:  MV_U32 alloc
+**               MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiTcontConfig(MV_U32 alloc, MV_U32 tcont)
+{
+	MV_STATUS rcode;
+
+	rcode = onuGponApiTcontConfig(alloc, tcont);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "ONU Allocation Id(%d) to T-CONT(%d) Config - FAIL\n", alloc, tcont);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiClearTcontConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clear onu tcont
+**
+**  PARAMETERS:  MV_U32 tcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiClearTcontConfig(MV_U32 tcont)
+{
+	MV_STATUS rcode;
+
+	rcode = onuGponApiTcontClear(tcont);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "ONU T-CONT(%d) Clear - FAIL\n", tcont);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiResetTcontsConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset onu bw map table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiResetTcontsConfig(void)
+{
+	onuGponApiTcontsReset();
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugTcont
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu tcont
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0
+**
+*******************************************************************************/
+int onuGponUiDebugTcont(void)
+{
+	MV_U32 allocId;
+	MV_U32 idleAllocId;
+	MV_U32 validCount = 0;
+	MV_BOOL valid;
+	MV_BOOL exist;
+	MV_U32 i;
+	MV_U8   *boolText[2] = { "NO ", "YES" };
+	MV_U32 fAllocId;
+	MV_BOOL fEna;
+	MV_U32 fTcont;
+	MV_U32 knowTcont;
+	MV_U8   *knowTcontText[] = { "T-CONT 0  ", "T-CONT 1  ", "T-CONT 2  ",
+				     "T-CONT 3  ", "T-CONT 4  ", "T-CONT 5  ",
+				     "T-CONT 6  ", "T-CONT 7  ", "T-CONT 8  ",
+				     "T-CONT 9  ", "T-CONT 10 ", "T-CONT 11 ",
+				     "T-CONT 12 ", "T-CONT 13 ", "T-CONT 14 ",
+				     "T-CONT 15 ", "T-Def     ", "T-Idle    " };
+	int off = 0;
+	MV_STATUS status;
+
+	mvOsPrintf("\n");
+	mvOsPrintf("-------------------------------------\n");
+	mvOsPrintf("| Alloc Id Table                    |\n");
+	mvOsPrintf("-------------------------------------\n");
+	mvOsPrintf("| Assigned             ||   Idle    |\n");
+	mvOsPrintf("|-----------------------------------|\n");
+	mvOsPrintf("| ALLOC-ID | Valid     ||           |\n");
+	mvOsPrintf("|-----------------------------------|\n");
+
+	for (i = 0 ; i < ONU_GPON_MAX_NUM_OF_T_CONTS; i++) {
+		onuGponDbBwAllocGet(i, &allocId, &valid);
+		onuGponDbBwIdleAllocGet(i, &idleAllocId);
+		if (idleAllocId != PON_ONU_ALLOC_NOT_EXIST)
+			mvOsPrintf("|   %04d   |  %3s      ||   %04d    |\n", allocId, boolText[valid], idleAllocId);
+		else
+			mvOsPrintf("|   %04d   |  %3s      ||   ====    |\n", allocId, boolText[valid]);
+	}
+
+	mvOsPrintf("-------------------------------------\n");
+	mvOsPrintf("-------------------------------------\n");
+	mvOsPrintf("| Alloc Id to T-CONT Connect  Table |\n");
+	mvOsPrintf("|-----------------------------------|\n");
+	mvOsPrintf("| T-CONT | Exist | ALLOC-ID | Valid |\n");
+	mvOsPrintf("|-----------------------------------|\n");
+
+	for (i = 0 ; i < ONU_GPON_MAX_NUM_OF_T_CONTS; i++) {
+		onuGponDbBwTcontGet(i, &exist, &allocId, &valid);
+		mvOsPrintf("|   %02d   |  %s  |   %04d   |  %s  |\n", i, boolText[exist], allocId, boolText[valid]);
+		if (valid != MV_FALSE) validCount++;
+	}
+
+	mvOsPrintf("-------------------------------------\n");
+	mvOsPrintf("----------------------------------------------------\n");
+	mvOsPrintf("| BW MAC - SoC Table                |              |\n");
+	mvOsPrintf("|-----------------------------------|              |\n");
+	mvOsPrintf("| Index | ALLOC-ID | T-CONT | Valid | KNOWN T-CONT |\n");
+	mvOsPrintf("|--------------------------------------------------|\n");
+
+	for (i = 0 ; i < ONU_GPON_MAX_NUM_OF_T_CONTS ; i++) {
+		status = mvOnuGponMacRxBwMapGet(i, &fAllocId, &fEna, &fTcont);
+		if (status != MV_OK)
+			mvOsPrintf("Error calling mvOnuGponMacRxBwMapGet, Tcont(%d)\n", i);
+
+		if (fTcont == PON_ONU_DEFAULT_ALLOC_TCONT)
+			knowTcont = 16;
+		else {
+			if ((fTcont == onuGponIdleAllocIdTcontGet()) && (validCount < 16))
+				knowTcont = 17;
+			else
+				knowTcont = fTcont;
+		}
+
+		mvOsPrintf("|  %02d   |   %04d   |   %02d   |  %s  |  %s  |\n",
+			   i, fAllocId, fTcont, boolText[fEna], knowTcontText[knowTcont]);
+	}
+
+	mvOsPrintf("----------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPortidValidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable gem port Id valid configuration
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugGemPortidValidSet(MV_U32 portId, MV_U32 enable)
+{
+	if (enable != 0) onuGponApiGemPortIdConfig(portId);
+	else onuGponApiGemPortIdClear(portId);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPortidValidSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable gem port Id valid configuration
+**
+**  PARAMETERS:  MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugAllGemPortidValidSet(MV_U32 enable)
+{
+	MV_U32 portId;
+
+	if (enable != 0)
+		for (portId = 0; portId < 4096; portId++)
+			onuGponApiGemPortIdConfig(portId);
+	else
+		for (portId = 0; portId < 4096; portId++)
+			onuGponApiGemPortIdClear(portId);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPmStart
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function starts Gem Port PM.
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugGemPmStart(MV_U32 portId, MV_U32 direction)
+{
+	S_GponIoctlGemPortPmConfig gemPm;
+
+	gemPm.command   = GEMPORTPMCMD_START;
+	gemPm.gem_port  = portId;
+	gemPm.direction = direction;
+
+	onuGponApiGemPortPmConfig(&gemPm);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPmStop
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function stops Gem Port PM.
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugGemPmStop(MV_U32 portId, MV_U32 direction)
+{
+	S_GponIoctlGemPortPmConfig gemPm;
+
+	gemPm.command   = GEMPORTPMCMD_STOP;
+	gemPm.gem_port  = portId;
+	gemPm.direction = direction;
+
+	onuGponApiGemPortPmConfig(&gemPm);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPmReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function resets GEM PM MIB counters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugGemPmReset(void)
+{
+	onuGponApiGemPortPmReset();
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPortMibPmDbShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints Gem PM ports enabled to collect MIB counters
+**
+**  PARAMETERS:  MV_U32 portId
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugGemPortMibPmDbShow(char *buf)
+{
+	S_apiGemPortPmConfig gemPortCfg;
+	int off = 0;
+	MV_U16 dbIdx;
+	int displayIndx = 0;
+	MV_STATUS rc;
+	char                    *pdirnstr;
+
+	off += mvOsSPrintf(buf + off, "GEM Port MIB PM \n");
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	off += mvOsSPrintf(buf + off, " #   Counter  GEM   direction\n");
+	off += mvOsSPrintf(buf + off, "     set      port\n");
+	off += mvOsSPrintf(buf + off, "=============================\n");
+
+	for (dbIdx = 0; dbIdx < MAX_SUPPORTED_GEMPORTS_FOR_PM; dbIdx++) {
+		rc = onuGponPmGemPortPmConfigGet(dbIdx, &gemPortCfg);
+		if (rc == MV_OK) {
+			/* Emergency printout in case direction is illegal */
+			if (gemPortCfg.direction == GEMPORTPMDIRECTION_US)
+				pdirnstr = "us";
+			else if (gemPortCfg.direction == GEMPORTPMDIRECTION_DS)
+				pdirnstr = "ds";
+			else if (gemPortCfg.direction == GEMPORTPMDIRECTION_BIDI)
+				pdirnstr = "bidi";
+			else
+				pdirnstr = "unkn";
+			displayIndx++;
+			off += mvOsSPrintf(buf + off, "%2d   %-2d       %-4d  %s(%d)\n", displayIndx, gemPortCfg.counter_set, gemPortCfg.gem_port, pdirnstr, gemPortCfg.direction);
+		}
+	}
+
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugHighPriTxShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints PON high priority TX parameters
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugHighPriTxShow(char *buf)
+{
+	S_OnuHighPriTx highPriTx;
+	int off = 0;
+	MV_U16 idx;
+	MV_U32 num = 0;
+	MV_STATUS rc;
+
+	rc = onuGponDbHighPriTxGet(&highPriTx);
+	PON_IF_ERROR(PON_MNG_MODULE, rc, "fail to get high priority TX map from DB\n");
+
+	off += mvOsSPrintf(buf + off, "PON high priority TX\n");
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	off += mvOsSPrintf(buf + off, "state:%s\n", highPriTx.state ? "enabled" : "disabled");
+	off += mvOsSPrintf(buf + off, "host T-CONT --> additional T-CONT\n");
+
+	for (idx = 0; idx < ONU_GPON_MAX_NUM_OF_T_CONTS; idx++) {
+		if (highPriTx.tcontMap[idx].valid == MV_TRUE) {
+			off += mvOsSPrintf(buf + off, "%8d        %8d\n", highPriTx.tcontMap[idx].hostTcont, highPriTx.tcontMap[idx].addTcont);
+			num++;
+		}
+
+	}
+	off += mvOsSPrintf(buf + off, "total TX map number:%d\n", num);
+	off += mvOsSPrintf(buf + off, "=============================\n");
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPmGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints Gem PM counters
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 direction
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugGemPmGet(MV_U32 portId, MV_U32 direction)
+{
+	S_GponIoctlGemPortMibCounters mibCounters;
+	MV_STATUS rcode = MV_OK;
+
+	MV_U8 *rxCounterText[] = {
+		"Good frames      received   ",
+		"Multicast frames received   ",
+		"Broadcast frames received   ",
+		"Good octets      received   ",
+		"Bad frames       received   "
+	};
+
+	MV_U8 *txCounterText[] = {
+		"Good frames      transmitted",
+		"Multicast frames transmitted",
+		"Broadcast frames transmitted",
+		"Good octets      transmitted",
+		"MAC transmission errors     "
+	};
+
+	MV_U8 *sizeCounterText[] = {
+		"Frames 64         octets    ",
+		"Frames 65  - 127  octets    ",
+		"Frames 128 - 255  octets    ",
+		"Frames 256 - 511  octets    ",
+		"Frames 512 - 1023 octets    ",
+		"Frames 1024- max  octets    "
+	};
+
+	memset(&mibCounters, 0, sizeof(S_GponIoctlGemPortMibCounters));
+
+	mibCounters.gem_port  = portId;
+	mibCounters.direction = direction;
+	rcode = onuGponApiGemPortPmGet(&mibCounters);
+	if (rcode == MV_OK) {
+		mvOsPrintf("\n");
+		mvOsPrintf("------------------------------------------------------------------\n");
+		mvOsPrintf("|MIB COUNTERS for GEM port:  %d, %s\n", portId,
+			   (direction == GEMPORTPMDIRECTION_DS) ? "downstream" : (direction == GEMPORTPMDIRECTION_US) ? "upstream" : "bidirectional");
+		mvOsPrintf("------------------------------------------------\n");
+		mvOsPrintf("|COUNTER                         |  VALUE      |\n");
+		mvOsPrintf("------------------------------------------------\n");
+		if (direction == GEMPORTPMDIRECTION_DS || direction == GEMPORTPMDIRECTION_BIDI) {
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[0], mibCounters.good_frames_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[1], mibCounters.multicast_frames_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[2], mibCounters.broadcast_frames_received);
+			mvOsPrintf(" %s   | %10llu  |\n", rxCounterText[3], mibCounters.good_octets_received);
+			mvOsPrintf(" %s   | %10u  |\n", rxCounterText[4], mibCounters.bad_frames_received);
+		}
+		if (direction == GEMPORTPMDIRECTION_US || direction == GEMPORTPMDIRECTION_BIDI) {
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[0], mibCounters.good_frames_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[1], mibCounters.multicast_frames_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[2], mibCounters.broadcast_frames_sent);
+			mvOsPrintf(" %s   | %10llu  |\n", txCounterText[3], mibCounters.good_octets_sent);
+			mvOsPrintf(" %s   | %10u  |\n", txCounterText[4], mibCounters.mac_trans_error);
+		}
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[0], mibCounters.frames_64_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[1], mibCounters.frames_65_to_127_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[2], mibCounters.frames_128_to_255octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[3], mibCounters.frames_256_to_511_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[4], mibCounters.frames_512_to_1023_octets);
+		mvOsPrintf(" %s   | %10u  |\n", sizeCounterText[5], mibCounters.frames_1024_to_max_octets);
+
+		mvOsPrintf("------------------------------------------------------------------\n");
+	} else
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get mibCounters value, portId(%d) direction(%d), rcode(%d)\n",
+			   __FILE_DESC__, __LINE__, portId, direction, rcode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugGemPortid
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return gem port Id valid configuration
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiDebugGemPortid(char *buf, int range)
+{
+	MV_BOOL enable;
+	MV_U32 portId;
+	MV_U32 startRange;
+	MV_U32 endRange;
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "GEM port ids list\n");
+	off += mvOsSPrintf(buf + off, "=================\n");
+
+	switch (range) {
+	case 1:  startRange = 1000; endRange = 1999; break;
+	case 2:  startRange = 2000; endRange = 2999; break;
+	case 3:  startRange = 3000; endRange = 4096; break;
+	default: startRange = 0;    endRange = 999;  break;
+	}
+
+	for (portId = startRange ; portId < endRange ; portId++) {
+		enable = mvOnuGponMacPortIdValidGet(portId);
+		if (enable == MV_TRUE) off += mvOsSPrintf(buf + off, "[%04d]", portId);
+		if ((portId / 14) == 0) off += mvOsSPrintf(buf + off, "\n");
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	return off;
+}
+
+#ifdef MV_GPON_STATIC_GEM_PORT
+/*******************************************************************************
+**
+**  onuGponUiDebugDummyGemPortFlagSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set dummy gem port flag
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugDummyGemPortFlagSet(MV_U32 flag)
+{
+	onuGponApiGemPortIdStaticConfigFlag(flag);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugDummyGemPortReset
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function reset dummy gem port table
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     OK or ERROR
+**
+*******************************************************************************/
+void onuGponUiDebugDummyGemPortReset(void)
+{
+	onuGponApiGemPortIdStaticConfigReset();
+}
+
+#endif /* MV_GPON_STATIC_GEM_PORT */
+
+/*******************************************************************************
+**
+**  onuGponUiDataHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print data help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiDataHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[DEC]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [AllocId] [T-Cont] > cfgTcont          - config alloc to tcont\n");
+	off += mvOsSPrintf(buf + off, " echo [T-Cont]           > clrTcont          - clear alloc Ids from T-Cont\n");
+	off += mvOsSPrintf(buf + off, " echo [0]                > rstTcont          - clear T-Cont configuration\n");
+	off += mvOsSPrintf(buf + off, " echo [GemPort] [Valid]  > cfgGem            - config gem port valid state, Disable[0], Enable[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [Valid]            > cfgAllGem         - config all gem ports valid state, Disable[0], Enable[1]\n");
+#ifdef MV_GPON_STATIC_GEM_PORT
+	off += mvOsSPrintf(buf + off, " echo [state]            > dummyGemState     - static gem port flag, Disable[0], Enable[1]\n");
+	off += mvOsSPrintf(buf + off, " echo [0]                > dummyGemRst       - clear static gem port table\n");
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+	off += mvOsSPrintf(buf + off, " echo [PortId] [State]   > cfgAesPort        - config gem port encryption state\n");
+	off += mvOsSPrintf(buf + off, " echo [State]            > cfgAllAes         - config all gem ports encryption state\n");
+#ifdef PON_A0
+	off += mvOsSPrintf(buf + off, " echo [mode]             > cfgOmciPath       - config the mode to get OMCI, 0: normal mode, 1:fast path\n");
+	off += mvOsSPrintf(buf + off, " echo [mode]             > cfgHighPriTx      - config high priority TX, 0: disable, 1:enable\n");
+	off += mvOsSPrintf(buf + off, " echo [host] [add]       > addTcontMap       - add T-CONT map, host:host T-CONT, add: additional T-CONT\n");
+	off += mvOsSPrintf(buf + off, " echo [host]             > delTcontMap       - delete T-CONT map, host:host T-CONT\n");
+#endif
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat showTcont                               - dump T-Cont configuration\n");
+#ifdef PON_A0
+	off += mvOsSPrintf(buf + off, " cat showHighPriTx                           - dump high priority TX map\n");
+#endif
+	off += mvOsSPrintf(buf + off, " cat showGem0xxx showGem1xxx showGem2xxx showGem3xxx - dump valid gem port list\n");
+	off += mvOsSPrintf(buf + off, " cat showAes0xxx showAes1xxx showAes2xxx showAes3xxx - dump encrypted gem port list\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Introp Commands                                 */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiOverrideShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu override parameters info
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiOverrideShow(char *buf)
+{
+	MV_U8 *parametersText[] = { "ExtendedBurst",
+				    "Delimiter        ",
+				    "OnuId            ",
+				    "OmccPortId       ",
+				    "EqualizationDelay" };
+	MV_U8  *enableText[]    = { "disabled", "enabled" };
+	MV_U32 tempValue1;
+	MV_U32 tempValue2;
+	MV_U32 status;
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "|  ONU OVERRIDE:                           |\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "|    PARAMETER       |  VALUE   |  STATUS  |\n");
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+
+	tempValue1 = onuGponDbExtendedBurstOperOverrideValueGet();
+	tempValue2 = onuGponDbExtendedBurstSyncOverrideValueGet();
+	status     = (MV_U32)onuGponDbExtendedBurstOverrideGet();
+	off += mvOsSPrintf(buf + off, "| %s SYNC | %8u | %s |\n", parametersText[0], tempValue1, enableText[status]);
+	off += mvOsSPrintf(buf + off, "| %s OPER | %8u | %s |\n", parametersText[0], tempValue2, enableText[status]);
+
+	tempValue1 = onuGponDbDelimiterOverrideValueGet();
+	status     = (MV_U32)onuGponDbDelimiterOverrideGet();
+	off += mvOsSPrintf(buf + off, "| %s  | %8u | %s |\n", parametersText[1], tempValue1, enableText[status]);
+
+	tempValue1 = onuGponDbOnuIdOverrideValueGet();
+	status     = (MV_U32)onuGponDbOnuIdOverrideGet();
+	off += mvOsSPrintf(buf + off, "| %s  | %8u | %s |\n", parametersText[2], tempValue1, enableText[status]);
+
+	tempValue1 = onuGponDbOmccPortOverrideValueGet();
+	status     = (MV_U32)onuGponDbOmccPortOverrideGet();
+	off += mvOsSPrintf(buf + off, "| %s  | %8u | %s |\n", parametersText[3], tempValue1, enableText[status]);
+
+	tempValue1 = onuGponDbEqualizationDelayOverrideValueGet();
+	status     = (MV_U32)onuGponDbEqualizationDelayOverrideGet();
+	off += mvOsSPrintf(buf + off, "| %s  | %8u | %s |\n", parametersText[4], tempValue1, enableText[status]);
+	off += mvOsSPrintf(buf + off, "--------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDelimiterConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu delimiter
+**
+**  PARAMETERS:  MV_U32 enable
+**               MV_U32 DelValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDelimiterConfig(MV_U32 enable, MV_U32 DelValue)
+{
+	onuGponApiDelimiterSet((MV_BOOL)enable, DelValue);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiOnuIdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu Id
+**
+**  PARAMETERS:  MV_U32 onuId
+**               MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiOnuIdConfig(MV_U32 onuId, MV_U32 enable)
+{
+	onuGponApiOnuIdSet((MV_BOOL)enable, onuId);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiPortIdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu omcc port Id
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiPortIdConfig(MV_U32 portId, MV_U32 enable)
+{
+	onuGponApiOmccPortIdSet((MV_BOOL)enable, portId);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiEquDelaySetConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu equalization delay
+**
+**  PARAMETERS:  MV_U32 equDelayVal
+**               MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiEquDelaySetConfig(MV_U32 equDelayVal, MV_U32 enable)
+{
+	onuGponApiEqualizationDelaySet((MV_BOOL)enable, equDelayVal);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiEquDelayChangeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu equalization delay
+**
+**  PARAMETERS:  MV_U32 direction
+**               MV_U32 size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiEquDelayChangeConfig(MV_U32 direction, MV_U32 size)
+{
+	onuGponApiEqualizationDelayChange(direction, size);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiExtendedBurstConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu extended burst
+**
+**  PARAMETERS:  MV_U32 enable
+**               MV_U32 rangeValue
+**               MV_U32 operValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiExtendedBurstConfig(MV_U32 enable, MV_U32 rangeValue, MV_U32 operValue)
+{
+	onuGponApiExtendedBurstSet((MV_BOOL)enable, rangeValue, operValue);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiExtendedBurstDelayConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure delay for the received onu extended burst
+**
+**  PARAMETERS:  MV_U32 enable
+**               MV_U32 rangeValue
+**               MV_U32 operValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiExtendedBurstDelayConfig(MV_U32 enable, MV_U32 rangeValue, MV_U32 operValue)
+{
+	onuGponApiExtendedBurstDelaySet((MV_BOOL)enable, rangeValue, operValue);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugOverheadMode
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu overhead mode
+**
+**  PARAMETERS:  MV_U32 overMode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugOverheadMode(MV_U32 overMode)
+{
+	MV_BOOL mode = (overMode == 0) ? MV_FALSE : MV_TRUE;
+
+	onuGponPonMngOverheadManualModeSet(mode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugOverheadGuard
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu overhead guard bits
+**
+**  PARAMETERS:  MV_U32 guard
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugOverheadGuard(MV_U32 guard)
+{
+	onuGponDbGuardBitsSet(guard);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugOverheadPreamble
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu overhead preamble
+**
+**  PARAMETERS:  MV_U32 pream3RangeCnt
+**               MV_U32 pream3OperCnt
+**               MV_U32 pream3PattCnt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugOverheadPreamble(MV_U32 pream3RangeCnt,
+				    MV_U32 pream3OperCnt,
+				    MV_U32 pream3PattCnt)
+{
+	MV_U32 onuState;
+
+	onuGponDbPreambleSet(ONU_GPON_PREM_TYPE_03, pream3PattCnt, 0);
+	onuGponDbExtPreambleSyncSet(pream3RangeCnt);
+	onuGponDbExtPreambleOperSet(pream3OperCnt);
+	onuState = onuGponDbOnuStateGet();
+	if (onuState == ONU_GPON_05_OPERATION) mvOnuGponMacPreambleType3Set(pream3PattCnt, pream3OperCnt);
+	else mvOnuGponMacPreambleType3Set(pream3PattCnt, pream3RangeCnt);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiIntropHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print introp help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiIntropHelpShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[DEC]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [OnuId] [Enable]                   > onuIdCfg     - override configured OnuId\n");
+	off += mvOsSPrintf(buf + off, " echo [PortId] [Enable]                  > portIdCfg    - override configured omcc portId\n");
+	off += mvOsSPrintf(buf + off, " echo [EquDelay] [Enable]                > eqdCfg       - override configured Equ Delay\n");
+	off += mvOsSPrintf(buf + off, " echo [Direction] [Size]                 > eqdChange    - change Equ Delay\n");
+	off += mvOsSPrintf(buf + off, " echo [Enable] [RangeValue] [OperValue]  > extBurstCfg  - override configured external burst\n");
+	off += mvOsSPrintf(buf + off, " echo [Enable] [RangeValue] [OperValue]  > extBurstDelayCfg  - add configured delay to received external burst\n");
+	off += mvOsSPrintf(buf + off, " echo [Enable] [Value]                   > delimiterCfg - override configured delimiter\n");
+	off += mvOsSPrintf(buf + off, " echo [RangeValue] [OperValue] [Pattern] > preambleCfg  - override configured preamble type3\n");
+	off += mvOsSPrintf(buf + off, " echo [Guard Bits]                       > guardCfg     - configure guard bits\n");
+	off += mvOsSPrintf(buf + off, " echo [Mode]                             > manModeCfg   - configure override parameters mode\n");
+	off += mvOsSPrintf(buf + off, " echo [Mode]                             > adminCfg     - configure onu Tx mode:(0)Enable, (1)Disable\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat manMode                              - override parameters mode\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Protocol Commands                               */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiDebugBurstConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu tx burst
+**
+**  PARAMETERS:  MV_U32 start
+**               MV_U32 stop
+**               MV_U32 order
+**               MV_U32 polarity
+**               MV_U32 mask
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugBurstConfig(MV_U32 start,
+			       MV_U32 stop,
+			       MV_U32 order,
+			       MV_U32 polarity,
+			       MV_U32 mask)
+{
+	S_apiBurstConfig burstConfig;
+
+	burstConfig.start    = start;
+	burstConfig.stop     = stop;
+	burstConfig.order    = order;
+	burstConfig.polarity = polarity;
+	burstConfig.mask     = mask;
+
+	onuGponApiBurstConfigSet(&burstConfig);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugBurstInfo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu tx burst info
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiDebugBurstInfo(char *buf)
+{
+	S_apiBurstConfig burstConfig;
+	int off = 0;
+
+	onuGponApiBurstConfigGet(&burstConfig);
+
+	off += mvOsSPrintf(buf + off, "----------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| Burst Parameters                           |\n");
+	off += mvOsSPrintf(buf + off, "|--------------------------------------------|\n");
+	off += mvOsSPrintf(buf + off, "|  Start |  Stop  | Order  |Polarity| Mask   |\n");
+	off += mvOsSPrintf(buf + off, "|--------------------------------------------|\n");
+	off += mvOsSPrintf(buf + off, "|   %02d   |   %02d   |   %02d   |   %02d   |   %02d   |\n",
+			   burstConfig.start, burstConfig.stop, burstConfig.order,
+			   burstConfig.polarity, burstConfig.mask);
+	off += mvOsSPrintf(buf + off, "|--------------------------------------------|\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiInfoBerDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function get Global OLT BER Information
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiInfoBerDebug(char *buf)
+{
+	S_BerCoefficient coeff;
+	MV_U32 seconds;
+	MV_U32 ber;
+	MV_U32 intervalBer;
+	MV_U32 bip, lastBip;
+	MV_U32 sdThreshold;
+	MV_U32 sfThreshold;
+	MV_U32 sdDetectValue;
+	MV_U32 sdCancelValue;
+	MV_U32 sfDetectValue;
+	MV_U32 sfCancelValue;
+	int off = 0;
+
+	coeff         = onuGponBerCoefficientGet();
+	seconds       = onuGponBerIntervalSecondsGet();
+	sdThreshold   = onuGponDbSdThresholdGet();
+	sfThreshold   = onuGponDbSfThresholdGet();
+
+	sdDetectValue = onuGponBerPower(10, (11 - sdThreshold));
+	sdCancelValue = onuGponBerPower(10, (11 - sdThreshold - 1));
+	sfDetectValue = onuGponBerPower(10, (11 - sfThreshold));
+	sfCancelValue = onuGponBerPower(10, (11 - sfThreshold - 1));
+
+	ber           = onuGponBerBerValueGet();
+	intervalBer   = onuGponBerIntervalBerValueGet();
+	bip           = onuGponBerBip8CounterGet();
+	lastBip       = onuGponBerLastIntervalBip8CounterGet();
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "----------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| BER Information                      |\n");
+	off += mvOsSPrintf(buf + off, "|--------------------------------------|\n");
+	off += mvOsSPrintf(buf + off, "|Interval of %2d Seconds                |\n", seconds);
+	off += mvOsSPrintf(buf + off, "|Coefficient is %2d/%2d                  |\n", coeff.numerator, coeff.denominator);
+	off += mvOsSPrintf(buf + off, "-----------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "|Interval BER|   BER      | BIP8       | Inter.BIP8 |\n");
+	off += mvOsSPrintf(buf + off, "-----------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "   %010u | %010u | %010u | %010u |\n", intervalBer, ber, bip, lastBip);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, " | DET SD TH  | CNC SD TH  | DET SF TH  | CNC SF TH  |\n");
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+	off += mvOsSPrintf(buf + off, "   %010u | %010u | %010u | %010u |\n", sdDetectValue, sdCancelValue, sfDetectValue, sfCancelValue);
+	off += mvOsSPrintf(buf + off, "------------------------------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugBerIntervalDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu ber interval
+**
+**  PARAMETERS:  MV_U32 interval
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugBerIntervalDebug(MV_U32 interval)
+{
+	onuGponApiBerIntervalConfig(interval);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugBerCoefficientDebug
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu ber coefficient
+**
+**  PARAMETERS:  MV_U32 numerator
+**               MV_U32 denominator
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugBerCoefficientDebug(MV_U32 numerator, MV_U32 denominator)
+{
+	onuGponApiBerCoefficientConfig(denominator, numerator);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiBerThresholdsConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu ber thresholds
+**
+**  PARAMETERS:  MV_U32 sd
+**               MV_U32 sf
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiBerThresholdsConfig(MV_U32 sd, MV_U32 sf)
+{
+	onuGponApiBerThresholdConfig(sd, sf);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugAesSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu AES port configuration
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugAesSet(MV_U32 portId, MV_U32 enable)
+{
+	MV_STATUS rcode = MV_OK;
+	MV_BOOL enaBool;
+	MV_BOOL valid;
+
+	/* to start AES on a port Id, it should be valid */
+	if (enable == 1) {
+		valid = onuGponDbGemPortValidGet(portId);
+		if (valid != MV_TRUE) {
+			mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+				   "Set GEM Port AES: Port(%d) is not Valid\n", portId);
+			return;
+		}
+	}
+
+	enaBool = (enable == 0) ? MV_FALSE : MV_TRUE;
+
+	rcode = mvOnuGponMacAesPortIdSet(portId, enaBool);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "Set GEM Port AES: Port(%d) enable(%d) failed\n", portId, enable);
+
+	onuGponDbGemPortAesSet(portId, enaBool);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugAesSetAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu AES port configuration
+**
+**  PARAMETERS:  MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugAesSetAll(MV_U32 enable)
+{
+	MV_STATUS rcode = MV_OK;
+	MV_BOOL enaBool;
+	MV_BOOL valid;
+	MV_U32 portId;
+
+	for (portId = 0; portId < 4096; portId++) {
+		/* to start AES on a port Id, it should be valid */
+		if (enable == 1) {
+			valid = onuGponDbGemPortValidGet(portId);
+			if (valid != MV_TRUE) {
+				mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+					   "Set GEM Port AES: Port(%d) is not Valid\n", portId);
+				return;
+			}
+		}
+
+		enaBool = (enable == 0) ? MV_FALSE : MV_TRUE;
+
+		rcode = mvOnuGponMacAesPortIdSet(portId, enaBool);
+		if (rcode != MV_OK)
+			mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+				   "Set GEM Port AES: Port(%d) enable(%d) failed\n", portId, enable);
+
+		onuGponDbGemPortAesSet(portId, enaBool);
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugOmciPathSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets OMCI path mode
+**
+**  PARAMETERS:  MV_U32 mode, 0:normal mode, 1:fast path mode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugOmciPathSet(MV_U32 mode)
+{
+	MV_U32 interruptMask;
+	MV_STATUS rcode;
+
+	/* update DB */
+	onuGponDbOmciFastPathSet(INT_TO_MV_BOOL(mode));
+
+	/* re-set GPON interrupt mask */
+	interruptMask = 0;
+	if (mode)
+		interruptMask |= ONU_GPON_INTERRUPTS_EXTEND << 16;
+	else
+		interruptMask |= ONU_GPON_INTERRUPTS_BASIC << 16;
+	rcode = mvOnuGponMacPonInterruptMaskSet(interruptMask);
+	if (rcode != MV_OK) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "Set PON interrupt mask: interruptMask(%x) failed\n", interruptMask);
+		return;
+	}
+
+	rcode = mvOnuGponMacGemOmciFastPathSet(mode);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "Set OMCI fast path: mode(%d) failed\n", mode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugHighPriTxSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets high pririty TX
+**
+**  PARAMETERS:  MV_U32 mode, 0:disable, 1:enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugHighPriTxSet(MV_U32 mode)
+{
+	onuGponApiHighPriTxStateSet(mode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugTcontMapAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds T-CONT map
+**
+**  PARAMETERS:  MV_U32 hostTcont, MV_U32 addTcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugTcontMapAdd(MV_U32 hostTcont, MV_U32 addTcont)
+{
+	S_OnuTcontMap tcontMap;
+
+	tcontMap.hostTcont  = hostTcont;
+	tcontMap.addTcont   = addTcont;
+
+	onuGponApiHighPriTxMapAdd(&tcontMap);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugTcontMapDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets OMCI path mode
+**
+**  PARAMETERS:  MV_U32 hostTcont
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugTcontMapDel(MV_U32 hostTcont)
+{
+	onuGponApiHighPriTxMapDel(hostTcont);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugAesGemAll
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return a list of all gem port AES and status
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiDebugAesGemAll(char *buf, int range)
+{
+	MV_U32 portId;
+	MV_BOOL enable;
+	MV_U32 startRange;
+	MV_U32 endRange;
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "Encrypted GEM port ids list\n");
+	off += mvOsSPrintf(buf + off, "===========================\n");
+
+	switch (range) {
+	case 1:
+		startRange = 1000;
+		endRange = 1999;
+		break;
+	case 2:
+		startRange = 2000;
+		endRange = 2999;
+		break;
+	case 3:
+		startRange = 3000;
+		endRange = 4096;
+		break;
+	default:
+		startRange = 0;
+		endRange = 999;
+		break;
+	}
+
+	for (portId = startRange; portId < endRange; portId++) {
+		if (onuGponDbGemPortValidGet(portId) == MV_TRUE) {
+			enable = onuGponDbGemPortAesGet(portId);
+			if (enable == MV_TRUE)
+				off += mvOsSPrintf(buf + off, "[%04d]", portId);
+		}
+		if ((portId / 14) == 0)
+			off += mvOsSPrintf(buf + off, "\n");
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerSendPloam
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function transmit US ploam message
+**
+**  PARAMETERS:  MV_U32 msgId
+**               MV_U32 onuId
+**               MV_U32 data1
+**               MV_U32 data2
+**               MV_U32 data3
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerSendPloam(MV_U32 msgId,
+				    MV_U32 onuId,
+				    MV_U32 data1,
+				    MV_U32 data2,
+				    MV_U32 data3)
+{
+	MV_U8 msgData[12];
+	MV_STATUS rcode;
+
+	msgData[0]  = (MV_U8)((data1 >> 24) & 0xFF);
+	msgData[1]  = (MV_U8)((data1 >> 16) & 0xFF);
+	msgData[2]  = (MV_U8)((data1 >> 8) & 0xFF);
+	msgData[3]  = (MV_U8)((data1) & 0xFF);
+	msgData[4]  = (MV_U8)((data2 >> 24) & 0xFF);
+	msgData[5]  = (MV_U8)((data2 >> 16) & 0xFF);
+	msgData[6]  = (MV_U8)((data2 >> 8) & 0xFF);
+	msgData[7]  = (MV_U8)((data2) & 0xFF);
+	msgData[8]  = (MV_U8)((data3 >> 24) & 0xFF);
+	msgData[9]  = (MV_U8)((data3 >> 16) & 0xFF);
+	msgData[10] = (MV_U8)((data3 >> 8) & 0xFF);
+	msgData[11] = (MV_U8)((data3) & 0xFF);
+
+	rcode = mvOnuGponMacMessageSend(onuId, msgId, msgData);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "mvOnuGponMacMessageSend failed\n");
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerReceivePloam
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function receive DS ploam message
+**
+**  PARAMETERS:  MV_U32 msgId
+**               MV_U32 onuId
+**               MV_U32 data1
+**               MV_U32 data2
+**               MV_U32 data3
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerReceivePloam(MV_U32 msgId,
+				       MV_U32 onuId,
+				       MV_U32 data1,
+				       MV_U32 data2,
+				       MV_U32 data3)
+{
+	MV_U8 msgData[12];
+
+	msgData[0]  = (MV_U8)((data1 >> 24) & 0xFF);
+	msgData[1]  = (MV_U8)((data1 >> 16) & 0xFF);
+	msgData[2]  = (MV_U8)((data1 >> 8) & 0xFF);
+	msgData[3]  = (MV_U8)((data1) & 0xFF);
+	msgData[4]  = (MV_U8)((data2 >> 24) & 0xFF);
+	msgData[5]  = (MV_U8)((data2 >> 16) & 0xFF);
+	msgData[6]  = (MV_U8)((data2 >> 8) & 0xFF);
+	msgData[7]  = (MV_U8)((data2) & 0xFF);
+	msgData[8]  = (MV_U8)((data3 >> 24) & 0xFF);
+	msgData[9]  = (MV_U8)((data3 >> 16) & 0xFF);
+	msgData[10] = (MV_U8)((data3 >> 8) & 0xFF);
+	msgData[11] = (MV_U8)((data3) & 0xFF);
+
+	onuGponPonMngPloamProcess((MV_U8)onuId, (MV_U8)msgId, msgData);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerRcvBurstPloams
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function receives DS ploam messages
+**
+**  PARAMETERS:  MV_U32 msgId
+**               MV_U32 onuId
+**               MV_U32 data1
+**               MV_U32 data2
+**               MV_U32 data3
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerRcvBurstPloams(MV_U32 msgId,
+					 MV_U32 onuId,
+					 MV_U32 data1,
+					 MV_U32 data2,
+					 MV_U32 data3)
+{
+	int i;
+
+	for (i = 0; i < maxPloamsSend; i++)
+		onuGponUiDebugManagerReceivePloam(msgId, onuId, data1, data2, data3);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerRcvBurstCfg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures DS PLOAM burst size
+**
+**  PARAMETERS:  MV_U32 size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerRcvBurstCfg(MV_U32 size)
+{
+	maxPloamsSend = size;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerFifoCntsClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function clears SW FIFO counters
+**
+**  PARAMETERS:  MV_U32 size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerFifoCntsClear(MV_U32 value)
+{
+	mvOnuGponMacFifoCountersSet(value);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerFifoSupportSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enables or disables SW FIFO support
+**
+**  PARAMETERS:  MV_U32 size
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerFifoSupportSet(MV_U32 enDis)
+{
+	mvOnuGponMacFifoSupportSet(enDis);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerAcCouplingSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures TX AC coupling parameters
+**
+**  PARAMETERS:  MV_U32 mode
+**               MV_U32 time
+**               MV_U32 pattern1
+**               MV_U32 pattern2
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerAcCouplingSet(MV_U32 mode, MV_U32 time, MV_U32 pattern1, MV_U32 pattern2)
+{
+	mvOnuGponMacTxConfigAcCouplingSet(mode, time, pattern1, pattern2);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerAcCouplingGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints TX AC coupling parameters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugManagerAcCouplingGet(char *buf)
+{
+	int off = 0;
+	MV_U32 mode, time;
+	MV_U8 pattern1, pattern2;
+	MV_STATUS status;
+
+	status = mvOnuGponMacTxConfigAcCouplingGet(&mode, &time, &pattern1, &pattern2);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain AC coupling configuration!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "| AC Coupling Parameters (HEX val)  |\n");
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+		off += mvOsSPrintf(buf + off, "| Mode | Time | Pattern1 | Pattern2 |\n");
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+		off += mvOsSPrintf(buf + off, "|  %02x  | %04x |    %02x    |    %02x    |\n",
+				   mode, time, pattern1, pattern2);
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerRandomDelaySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures TX Random Delay Units
+**
+**  PARAMETERS:  MV_U32 rdUnits - random delay units
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerRandomDelaySet(MV_U32 rdUnits)
+{
+	mvOnuGponMacTxRandomDelayUnitsSet(rdUnits);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerRandomDelayGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints TX Random Delay Units value
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugManagerRandomDelayGet(char *buf)
+{
+	int off = 0;
+	MV_U32 rdUnits;
+	MV_STATUS status;
+
+	status = mvOnuGponMacTxRandomDelayUnitsGet(&rdUnits);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain Random Delay Units!\n");
+	else
+		off += mvOsSPrintf(buf + off, "Random Delay Units = %#x (%dB)\n", rdUnits, (1 << rdUnits));
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerActiveTxBitmapSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures UTM Active TX Bitmap
+**
+**  PARAMETERS:  MV_U32 bitmap - bitmap
+**               MV_U32 valid  - valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerActiveTxBitmapSet(MV_U32 bitmap, MV_U32 valid)
+{
+	mvOnuGponMacUtmActiveTxBitmapSet(bitmap);
+	mvOnuGponMacUtmActiveTxBitmapValidSet(valid);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerActiveTxBitmapGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints UTM Active TX bitmap
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugManagerActiveTxBitmapGet(char *buf)
+{
+	int off = 0;
+	MV_U32 bitmap, valid;
+	MV_STATUS status;
+
+	status  = mvOnuGponMacUtmActiveTxBitmapConfigGet(&bitmap, &valid);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain UTM Active TX bitmap!\n");
+	else
+		off += mvOsSPrintf(buf + off, "UTM Active TX bitmap = %#x valid = %d\n", bitmap, valid);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerSfcSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures General Super Frame Counter value
+**
+**  PARAMETERS:  MV_U32 sfc - Super Frame Counter value
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerSfcSet(MV_U32 sfc)
+{
+	mvOnuGponSuperFrameCouterSet(sfc);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerSfcGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints General Super Frame Counter value
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugManagerSfcGet(char *buf)
+{
+	int off = 0;
+	MV_U32 sfc;
+	MV_STATUS status;
+
+	status = mvOnuGponSuperFrameCouterGet(&sfc);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain Super Frame Counter value!\n");
+	else
+		off += mvOsSPrintf(buf + off, "Super Frame Counter = %#x\n", sfc);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerTodSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configures Time Of Day Interrupt parameters
+**
+**  PARAMETERS:  MV_U32 polarity
+**               MV_U32 mode
+**               MV_U32 width
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugManagerTodSet(MV_U32 polarity, MV_U32 mode, MV_U32 width)
+{
+	mvOnuGponTimeOfDayIntWidthSet(width, mode, polarity);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugManagerTodGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints Time Of Day Interrupt parameters
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiDebugManagerTodGet(char *buf)
+{
+	int off = 0;
+	MV_U32 width;
+	MV_U8 mode, polarity;
+	MV_STATUS status;
+
+	status = mvOnuGponTimeOfDayIntWidthGet(&width, &mode, &polarity);
+
+	if (status != MV_OK)
+		off += mvOsSPrintf(buf + off, "Failed to obtain Time Of Day Interrupt settings!\n");
+	else {
+		off += mvOsSPrintf(buf + off, "------------------------------------\n");
+		off += mvOsSPrintf(buf + off, "| Time Of Day INT settings          |\n");
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+		off += mvOsSPrintf(buf + off, "| Polarity |   Mode   |    Width    |\n");
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+		off += mvOsSPrintf(buf + off, "|    %d     |    %d     |  0x%07x  |\n",
+				   polarity, mode, width);
+		off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiRandomDelayLegacyModeShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function prints legacy mode status
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiRandomDelayLegacyModeShow(char *buf)
+{
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+	if (ponRandomDelayLegacyMode != MV_FALSE)
+		off += mvOsSPrintf(buf + off, "The system is running in LEGACY mode\n");
+	else
+		off += mvOsSPrintf(buf + off, "The system is running in NORMAL mode\n");
+	off += mvOsSPrintf(buf + off, "|-----------------------------------|\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiRandomDelayLegacyModeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets legacy mode configuration
+**
+**  PARAMETERS:  MV_U32 legacyMode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiRandomDelayLegacyModeConfig(MV_U32 legacyMode)
+{
+	if (legacyMode != 0)
+		ponRandomDelayLegacyMode = MV_TRUE;
+	else
+		ponRandomDelayLegacyMode = MV_FALSE;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemOmciPortIdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu omci port Id
+**
+**  PARAMETERS:  MV_U32 portId
+**               MV_U32 valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiGemOmciPortIdConfig(MV_U32 portId, MV_U32 valid)
+{
+	mvOnuGponMacGemOmciPortIdSet(portId, valid);    /* Rx */
+	mvOnuGponMacUtmOmciPortIdSet(portId, valid);    /* Tx */
+
+	onuGponDbOmccPortSet(portId);
+	onuGponDbOmccValidSet(valid);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemOmciPortIdShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu omcc port Id
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiGemOmciPortIdShow(char *buf)
+{
+	MV_STATUS rcode;
+	MV_U32 gemPortId;
+	MV_U32 gemPortValid;
+	MV_U32 utmPortId;
+	MV_U32 utmPortValid;
+	int off = 0;
+
+	rcode = mvOnuGponMacGemOmciPortIdGet(&gemPortId, &gemPortValid);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get Rx(gem) omci portId, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	rcode = mvOnuGponMacUtmOmciPortIdGet(&utmPortId, &utmPortValid);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get Tx(Utm) omci portId, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "OMCI Rx(Gem) PortId %8d valid %s\n", gemPortId, (gemPortValid == 0) ? ("FALSE") : ("TRUE"));
+	off += mvOsSPrintf(buf + off, "OMCI Tx(Utm) PortId %8d valid %s\n", utmPortId, (utmPortValid == 0) ? ("FALSE") : ("TRUE"));
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemFrameLengthShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print onu frame lengths
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiGemFrameLengthShow(char *buf)
+{
+	MV_STATUS rcode;
+	MV_U32 payloadlen;
+	MV_U32 maxEthFrameLen;
+	MV_U32 minEthFrameLen;
+	MV_U32 maxOmciFrameLen;
+	MV_U32 minOmciFrameLen;
+	int off = 0;
+
+	rcode = mvOnuGponMacGemPayloadLenGet(&payloadlen);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get gem payload length value, rcode(%d)\n",
+			   __FILE_DESC__, __LINE__, rcode);
+
+	rcode = mvOnuGponMacGemEthFrameLenGet(&maxEthFrameLen, &minEthFrameLen);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get ethernet frame length value, rcode(%d)\n",
+			   __FILE_DESC__, __LINE__, rcode);
+
+	rcode = mvOnuGponMacGemOmciFrameLenGet(&maxOmciFrameLen, &minOmciFrameLen);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to get omci frame value, rcode(%d)\n",
+			   __FILE_DESC__, __LINE__, rcode);
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "----------------------\n");
+	off += mvOsSPrintf(buf + off, "|Frame Length        |\n");
+	off += mvOsSPrintf(buf + off, "-----------------------------------\n");
+	off += mvOsSPrintf(buf + off, "| Frame              |   VALUE    |\n");
+	off += mvOsSPrintf(buf + off, "-----------------------------------\n");
+	off += mvOsSPrintf(buf + off, "Gem payload          | %10d |\n", payloadlen);
+	off += mvOsSPrintf(buf + off, "Gem min eth frame    | %10d |\n", minEthFrameLen);
+	off += mvOsSPrintf(buf + off, "Gem max eth frame    | %10d |\n", maxEthFrameLen);
+	off += mvOsSPrintf(buf + off, "Gem min omci frame   | %10d |\n", minOmciFrameLen);
+	off += mvOsSPrintf(buf + off, "Gem max omci frame   | %10d |\n", maxOmciFrameLen);
+	off += mvOsSPrintf(buf + off, "-----------------------------------\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemPayloadLenConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu gem payload length
+**
+**  PARAMETERS:  MV_U32 payloadLen
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiGemPayloadLenConfig(MV_U32 payloadLen)
+{
+	mvOnuGponMacGemPayloadLenSet(payloadLen);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemEthFrameLenConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu ethernet min/max frame length
+**
+**  PARAMETERS:  MV_U32 minFrameLenArg
+**               MV_U32 maxFrameLenArg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiGemEthFrameLenConfig(MV_U32 minFrameLenArg, MV_U32 maxFrameLenArg)
+{
+	mvOnuGponMacGemEthFrameLenSet(maxFrameLenArg, minFrameLenArg);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiGemOmciFrameLenConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu omci min/max frame length
+**
+**  PARAMETERS:  MV_U32 minFrameLenArg
+**               MV_U32 maxFrameLenArg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiGemOmciFrameLenConfig(MV_U32 minFrameLenArg, MV_U32 maxFrameLenArg)
+{
+	mvOnuGponMacGemOmciFrameLenSet(maxFrameLenArg, minFrameLenArg);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiProtoHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print protocol help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiProtoHelpShow(char *buf)
+{
+	int off = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[DEC]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [BER Interval]            > berIntervalCfg  - config ber interval\n");
+	off += mvOsSPrintf(buf + off, " echo [Numerator] [Denominator] > berCoeffCfg     - "
+			   "config ber coeff numerator, denominator\n");
+	off += mvOsSPrintf(buf + off, " echo [SD] [SF]                 > berThesholdCfg  - "
+			   "config ber SD, SF thresholds\n");
+	off += mvOsSPrintf(buf + off, " echo [OmccPortId] [State]      > omciPortCfg     - config omcc gem port state\n");
+	off += mvOsSPrintf(buf + off, " echo [Len]                     > gemFrameLenCfg  - "
+			   "config gem frame payload len\n");
+	off += mvOsSPrintf(buf + off, " echo [MinLen] [MaxLen]         > ethFrameLenCfg  - "
+			   "config eth frame min & max lengths\n");
+	off += mvOsSPrintf(buf + off, " echo [MinLen] [MaxLen]         > omciFrameLenCfg - "
+			   "config omci frame min & max lengths\n");
+	off += mvOsSPrintf(buf + off, " echo [Start] [Stop] [Order] [Pola] [Mask] > txBurstCfg   - config tx burst\n");
+	off += mvOsSPrintf(buf + off, " echo [MsgId] [OnuId] [Data] [Data] [Data] > ploamMsgSend - "
+			   "simulate transmit of US PLOAM msg\n");
+	off += mvOsSPrintf(buf + off, " echo [MsgId] [OnuId] [Data] [Data] [Data] > ploamMsgRece - "
+			   "simulate reception and process of DS PLOAM msg\n");
+	off += mvOsSPrintf(buf + off, " echo [MsgId] [OnuId] [Data] [Data] [Data] > ploamBurstRcv - "
+			   "simulate reception and process of DS burst PLOAM msgs\n");
+	off += mvOsSPrintf(buf + off, " echo [DS burst size]           > ploamBurstCfg - config DS PLOAM burst size\n");
+	off += mvOsSPrintf(buf + off, " echo 0                         > clearFifoCnts - clear all SW FIFO counters\n");
+	off += mvOsSPrintf(buf + off, " echo [enable(1) or disable(0)] > fifoSupport - config US SW FIFO support\n");
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " echo [Mode] [Time] [Pattern1] [Pattern2] > acCoupling - "
+				   "configure TX AC Coupling parameters\n");
+		off += mvOsSPrintf(buf + off, " echo [Units]                             > randDelay - "
+				   "configure TX Random Delay Units\n");
+		off += mvOsSPrintf(buf + off, " echo [Bitmap] [Valid]                    > activeTxBm - "
+				   "configure UTM Active TX Bitmap\n");
+	}
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat txBurst                              - dump tx burst info\n");
+	off += mvOsSPrintf(buf + off, " cat gemFrameLen                          - dump frame lengths\n");
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " cat acCoupling                           - "
+				   "dump TX AC Coupling parameters\n");
+		off += mvOsSPrintf(buf + off, " cat randDelay - "
+				   "show TX Random Delay Units value\n");
+		off += mvOsSPrintf(buf + off, " cat activeTxBm - "
+				   "show UTM Active TX Bitmap\n");
+	}
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Misc Commands                                   */
+/* ========================================================================== */
+/******************************************************************************/
+
+/*******************************************************************************
+**
+**  onuGponUiDebugSerialNumberSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ONU serial Number
+**
+**  PARAMETERS:  ON_U32 serialNumber1
+**               MV_U32 serialNumber2
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugSerialNumberSet(MV_U32 serialNumber1, MV_U32 serialNumber2)
+{
+	MV_STATUS rcode;
+	MV_U8 serialNumber[8];
+
+	serialNumber[0] = (MV_U8)((serialNumber1 >> 24) & 0xFF);
+	serialNumber[1] = (MV_U8)((serialNumber1 >> 16) & 0xFF);
+	serialNumber[2] = (MV_U8)((serialNumber1 >> 8) & 0xFF);
+	serialNumber[3] = (MV_U8)((serialNumber1) & 0xFF);
+	serialNumber[4] = (MV_U8)((serialNumber2 >> 24) & 0xFF);
+	serialNumber[5] = (MV_U8)((serialNumber2 >> 16) & 0xFF);
+	serialNumber[6] = (MV_U8)((serialNumber2 >> 8) & 0xFF);
+	serialNumber[7] = (MV_U8)((serialNumber2) & 0xFF);
+
+	rcode = onuGponSrvcSerialNumberSet(serialNumber);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to set Serial Number, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugSerialNumberSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set ONU serial Number
+**
+**  PARAMETERS:  ON_U32 serialNumber1
+**               MV_U32 serialNumber2
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugPasswordSet(MV_U32 passwordNumber1,
+			       MV_U32 passwordNumber2,
+			       MV_U32 passwordNumber3)
+{
+	MV_STATUS rcode;
+	MV_U8 password[10];
+
+	password[0] = (MV_U8)((passwordNumber1 >> 24) & 0xFF);
+	password[1] = (MV_U8)((passwordNumber1 >> 16) & 0xFF);
+	password[2] = (MV_U8)((passwordNumber1 >> 8) & 0xFF);
+	password[3] = (MV_U8)((passwordNumber1) & 0xFF);
+	password[4] = (MV_U8)((passwordNumber2 >> 24) & 0xFF);
+	password[5] = (MV_U8)((passwordNumber2 >> 16) & 0xFF);
+	password[6] = (MV_U8)((passwordNumber2 >> 8) & 0xFF);
+	password[7] = (MV_U8)((passwordNumber2) & 0xFF);
+	password[8] = (MV_U8)((passwordNumber3 >> 24) & 0xFF);
+	password[9] = (MV_U8)((passwordNumber3 >> 16) & 0xFF);
+
+	rcode = onuGponDbPasswordSet(password);
+	if (rcode != MV_OK)
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "%s:%d, failed to set password, rcode(%d)\n", __FILE_DESC__, __LINE__, rcode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiTxEnThresholdConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu tx enable threshold
+**
+**  PARAMETERS:  MV_U32 threshold
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiTxEnThresholdConfig(MV_U32 threshold)
+{
+	mvOnuGponMacTxTxEnableCounterThresholdSet(threshold);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiUtmTcPeriodConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu utm tc period
+**
+**  PARAMETERS:  MV_U32 period
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiUtmTcPeriodConfig(MV_U32 period)
+{
+	mvOnuGponMacUtmTcPeriodSet(period);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiUtmTcValidConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu utm tc valid
+**
+**  PARAMETERS:  MV_U32 valid
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiUtmTcValidConfig(MV_U32 valid)
+{
+	mvOnuGponMacUtmTcValidSet(valid);
+}
+
+/*******************************************************************************
+**
+**  onuGponUitxDbrBlockSizeConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function change onu dbr block size
+**
+**  PARAMETERS:  MV_U32 blockSize
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUitxDbrBlockSizeConfig(MV_U32 blockSize)
+{
+	MV_U32 configuredBlockSize;
+
+	onuGponSrvcDbrBlockSizeSet(blockSize, &configuredBlockSize);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugMemReadReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function test requested address space
+**
+**  PARAMETERS:  MV_U32 readOffset
+**               MV_U32 readEntry
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugReadReg(MV_U32 readOffset, MV_U32 readEntry)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+	MV_U32 regValue;
+	regValue = MV_REG_READ((MV_GPON_MAC_REGS_BASE) + readOffset + (readEntry * sizeof(MV_U32)));
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "Read register offset 0x%x, entry %d = [0x%08X]\n\r", readOffset, readEntry, regValue);
+#endif
+#endif  /* PON_FPGA */
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugWriteReg
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function test requested address space
+**
+**  PARAMETERS:  MV_U32 writeOffset
+**               MV_U32 writeEntry
+**               MV_U32 regValue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugWriteReg(MV_U32 writeOffset, MV_U32 writeEntry, MV_U32 regValue)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+	MV_REG_WRITE((MV_GPON_MAC_REGS_BASE) + writeOffset + (writeEntry * sizeof(MV_U32)), regValue);
+#endif
+#endif  /* PON_FPGA */
+
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "Write  register offset 0x%x, entry %d = [0x%08X]\n\r", writeOffset, writeEntry, regValue);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugDebugModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu denug mode
+**
+**  PARAMETERS:  MV_U32 debugMode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugDebugModeSet(MV_U32 debugMode)
+{
+	MV_BOOL mode;
+
+	mode = (debugMode == 0) ? MV_FALSE : MV_TRUE;
+	onuGponPonMngDebugModeSet(mode);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugUponModeSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure onu UPON mode
+**
+**  PARAMETERS:  MV_U32 debugMode
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugUponModeSet(MV_U32 uponMode)
+{
+	MV_BOOL mode;
+
+	mode = (uponMode == 0) ? MV_FALSE : MV_TRUE;
+	onuGponApiUponDebugSet(mode);
+}
+
+/*******************************************************************************
+****  onuGponUiCfgSetUserPatternBurst
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config start onu transmission of user-defined
+**               pattern burst
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuGponUiCfgSetUserPatternBurst(MV_U32 patternMSB, MV_U32 pattern, MV_U32 patternLSB)
+{
+	MV_U32 userPattern[3];
+
+	userPattern[0] = patternLSB;
+	userPattern[1] = pattern;
+	userPattern[2] = patternMSB;
+
+	mvOnuPonMacPrbsUserDefinedPatternSet(userPattern);
+}
+
+/*******************************************************************************
+****  onuGponUiCfgSetDefinedPatternBurst
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function config start onu transmission of pre-defined
+**               pattern burst
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuGponUiCfgSetDefinedPatternBurst(MV_U32 enable, MV_U32 pattern, MV_U32 burst, MV_U32 duration, MV_U32 period)
+{
+	if (enable == 0)
+		onuPonPatternBurstOff();
+	else{
+		onuPonTxPowerOn(MV_TRUE);
+		onuPonPatternBurstOn(pattern, (MV_BOOL)burst, period, duration);
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponUiDebugAdminMode
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handle onu admin mode
+**
+**  PARAMETERS:  MV_U32 admin
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiDebugAdminMode(MV_U32 mode)
+{
+	onuGponApiAdminStateSet(mode);
+}
+
+#ifdef MV_GPON_PERFORMANCE_CHECK
+
+/*******************************************************************************
+**
+**  onuGponCliDebugPerformanceCheck
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  MV_U32 step
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponCliDebugPerformanceCheck(MV_U32 step)
+{
+	MV_U32 minCheck   = 0;
+	MV_U32 maxCheck   = 0;
+	MV_U32 aveCheck   = 0;
+	MV_U32 aveCount   = 0;
+	MV_U32 tempCheck  = 0;
+	MV_U32 minMaxTemp = 0;
+	MV_U32 index;
+
+	S_GponPerformanceCheckNode *tmpPmCheckNode;
+
+	char* pmStepDesc[] =
+	{
+		"ISR        ",
+		"MNG1       ",
+		"MNG2       ",
+		"MNG3       ",
+		"MNG4       ",
+		"MNG5       ",
+		"ExtB       ",
+		"Key Switch ",
+		"Cfg Port   ",
+		"Req Key    ",
+		"AllocId    ",
+		"Password   ",
+		"Enc Port   ",
+		"Dis        ",
+		"Dact       ",
+		"Rng        ",
+		"OnuId      ",
+		"Over       "
+	};
+
+	if (step >= PON_MAX_PERFORMANCE) {
+		mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+			   "Invalid performance step(%d)\n", step);
+		return;
+	}
+
+	tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[step]);
+
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "             Interval    Minimum     Maximum     Average\n");
+
+	aveCount = 0;
+	for (index = 0; index < tmpPmCheckNode->uSecCntIdx; index++) {
+		tempCheck = tmpPmCheckNode->uSecCntStop[index] -
+			    tmpPmCheckNode->uSecCntStart[index];
+
+		if (tempCheck < 1000) {
+			aveCheck += tempCheck;
+			aveCount++;
+
+			if (minMaxTemp == 0) {
+				minCheck = maxCheck = tempCheck;
+				minMaxTemp = 1;
+			} else {
+				if (tempCheck > maxCheck)
+					maxCheck = tempCheck;
+				else if (tempCheck < minCheck)
+					minCheck = tempCheck;
+			}
+		}
+	}
+
+	if (aveCount > 0)
+		aveCheck = aveCheck / aveCount;
+
+	mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+		   "%11s  %8u    %7lu     %7lu     %7lu\n",
+		   pmStepDesc[step], tmpPmCheckNode->uSecCntIdx, minCheck, maxCheck, aveCheck);
+
+	if (tmpPmCheckNode->uSecCntIdx > 0) {
+		for (index = 0; index < tmpPmCheckNode->uSecCntIdx - 1; index++) {
+			mvPonPrint(PON_PRINT_INFO, PON_CLI_MODULE,
+				   "%11s   Start %u Stop %u diff %u\n",
+				   pmStepDesc[step],
+				   tmpPmCheckNode->uSecCntStart[index],
+				   tmpPmCheckNode->uSecCntStop[index],
+				   (tmpPmCheckNode->uSecCntStop[index] - tmpPmCheckNode->uSecCntStart[index]));
+		}
+	}
+}
+
+/*******************************************************************************
+**
+**  onuGponCliDebugPerformanceClear
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponCliDebugPerformanceClear(void)
+{
+	MV_U32 step;
+	MV_U32 index;
+	S_GponPerformanceCheckNode *tmpPmCheckNode;
+
+	for (step = 0; step < PON_MAX_PERFORMANCE; step++) {
+		tmpPmCheckNode = &(g_GponPmCheck.pmCheckNode[step]);
+
+		for (index = 0; index < tmpPmCheckNode->uSecCntIdx; index++) {
+			tmpPmCheckNode->uSecCntStop[index]  = 0;
+			tmpPmCheckNode->uSecCntStart[index] = 0;
+		}
+
+		tmpPmCheckNode->uSecCntIdx = 0;
+	}
+}
+
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+
+/*******************************************************************************
+**
+**  onuGponUiT01IntervalConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiT01IntervalConfig(MV_U32 interval)
+{
+	S_OnuPonTimer  *timerId = &(onuPonResourceTbl_s.onuGponT01_TimerId);
+
+	if (timerId->onuPonTimerActive != ONU_PON_TIMER_ACTIVE) {
+		onuPonTimerUpdate(timerId,
+				  timerId->onuPonTimerId.data,
+				  interval,
+				  0);
+	} else
+		printk(KERN_INFO KERN_ERR "GPON T01 timer is running, the value is not accepted\n");
+
+}
+
+/*******************************************************************************
+**
+**  onuGponUiT02IntervalConfig
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiT02IntervalConfig(MV_U32 interval)
+{
+	S_OnuPonTimer  *timerId = &(onuPonResourceTbl_s.onuGponT02_TimerId);
+
+	if (timerId->onuPonTimerActive != ONU_PON_TIMER_ACTIVE) {
+		onuPonTimerUpdate(timerId,
+				  timerId->onuPonTimerId.data,
+				  interval,
+				  0);
+	} else
+		printk(KERN_INFO KERN_ERR "GPON T02 timer is running, the value is not accepted\n");
+
+}
+
+/*******************************************************************************
+**
+**  onuGponUiCfgPrbsUserPattern
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print PRBS user defined pattern
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+int onuGponUiCfgPrbsUserPattern(char *buf)
+{
+	MV_U32 userPattern[3];
+	int off = 0;
+
+	mvOnuPonMacPrbsUserDefinedPatternGet(userPattern);
+
+	off += mvOsSPrintf(buf + off, "PRBS User Pattern 0x%4x%8x%8x\n",
+			   userPattern[2], userPattern[1], userPattern[0]);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiSyncLogEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  MV_U32 enable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiSyncLogEnable(MV_U32 enable)
+{
+	onuGponSyncLogEnable(enable);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiSyncLogPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiSyncLogPrint(void)
+{
+	onuGponSyncLogPrint();
+
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  onuGponUiOmccAdd
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function adds OMCC
+**
+**  PARAMETERS:  MV_U32 gem
+**               MV_U32 queue
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiOmccAdd(MV_U32 gem, MV_U32 queue)
+{
+	int rc;
+
+	rc = onuGponApiOmciChannelAdd((MV_U16)gem, (MV_U8)queue);
+	if (rc == MV_OK)
+		printk(KERN_INFO "Succeed to add OMCI channel, GEM port:%d, queue:%d\n", gem, queue);
+	else
+		printk(KERN_INFO "Fail to add OMCI channel, GEM port:%d, queue:%d\n", gem, queue);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiOmccDel
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function deletes OMCC
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void onuGponUiOmccDel(void)
+{
+	int rc;
+
+	rc = onuGponApiOmciChannelDel();
+	if (rc == MV_OK)
+		printk(KERN_INFO "Succeed to delete OMCI channel\n");
+	else
+		printk(KERN_INFO "Fail to delete OMCI channel\n");
+
+}
+
+/*******************************************************************************
+**
+**  onuGponUiOmccShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function show OMCC information
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+int onuGponUiOmccShow(char *buf)
+{
+	return onuGponOmciChannelPrint(buf);
+}
+
+/*******************************************************************************
+**
+**  onuGponUiMiscHelpShow
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function print misc help
+**
+**  PARAMETERS:  char *buf
+**
+**  OUTPUTS:     char *buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int onuGponUiMiscHelpShow(char *buf)
+{
+	int off = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Configuration Commands[HEX]\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " echo [SN1] [SN2]                > serialNumCfg    - config serial number\n");
+	off += mvOsSPrintf(buf + off, " echo [PWD1] [PWD2] [PWD3]       > passwordCfg     - config password\n");
+	off += mvOsSPrintf(buf + off, "                                                     10 bytes: PWD1, PWD2, 2 MSB of PWD3\n");
+	off += mvOsSPrintf(buf + off, " echo [TxEnThreshold]            > txEnThresCfg    - config tx enable threshold\n");
+	off += mvOsSPrintf(buf + off, " echo [TC Period]                > utmTxPeriodCfg  - config utm tc period\n");
+	off += mvOsSPrintf(buf + off, " echo [TC Valid]                 > utmTcValidCfg   - config utm tc valid\n");
+	off += mvOsSPrintf(buf + off, " echo [DBR Block Size]           > txDbrBlkSizeCfg - config dbr block size\n");
+	off += mvOsSPrintf(buf + off, " echo [Offset] [Entry]           > readReg         - "
+			   "read onu reg [Id from mvPonOnuRegs.h]\n");
+	off += mvOsSPrintf(buf + off, " echo [Offset] [Entry] [Value]   > writeReg        - "
+			   "write onu reg [Id from mvPonOnuRegs.h]\n");
+	off += mvOsSPrintf(buf + off, " echo [Mode]                     > debugModeCfg    - config debug mode\n");
+	off += mvOsSPrintf(buf + off, " echo [Mode]                     > stopPonSw       - "
+			   "stop PON switching (enabled/disabled)\n");
+	off += mvOsSPrintf(buf + off, " echo [Section]                  > pmCheck         - performance check section\n");
+	off += mvOsSPrintf(buf + off, " echo [0]                        > pmClear         - performance check reset\n");
+	off += mvOsSPrintf(buf + off, " echo [module] [Level] [Options] > printMask       - change printing options\n");
+	off += mvOsSPrintf(buf + off, " echo [state]                    > adminCfg        - "
+			   "change PON BE (TX EN) state 0=Enable, 1=Disable\n");
+	off += mvOsSPrintf(buf + off, " echo [patternMSB][pattern][patternLSB]\n");
+	off += mvOsSPrintf(buf + off, "                                 > prbsUserDefinedPattern - 80bit user data: 16bit patternMLSB + 32bit pattern + 32bit patternLSB\n");
+	off += mvOsSPrintf(buf + off, " echo [enable][pattern][burst][duration][period]\n");
+	off += mvOsSPrintf(buf + off, "                                 > prbsPreDefinedPattern\n");
+	off += mvOsSPrintf(buf + off, "                                                   - start enable[1] or stop [0] transmission of\n");
+	off += mvOsSPrintf(buf + off, "                                                     pattern: 0x1-1T, 0x2-2T, 0x5-User, 0x80-PRBS-7, 0x81-PRBS-9, 0x82-PRBS-15\n");
+	off += mvOsSPrintf(buf + off, "                                                     burst: 0-static, 1-periodic\n");
+	off += mvOsSPrintf(buf + off, "                                                     duration: peak time interval[micro seconds]\n");
+	off += mvOsSPrintf(buf + off, "                                                     period - full cycle time interval[micro seconds]\n");
+	off += mvOsSPrintf(buf + off, " echo [T01 Interval]             > t01IntervalCfg  - "
+			   "config T01 timer interval in mS\n");
+	off += mvOsSPrintf(buf + off, " echo [T02 Interval]             > t02IntervalCfg  - "
+			   "config T02 timer interval in mS\n");
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " echo [SFC Value]                > genSFC          - "
+				   "configure value of General Super Frame Counter\n");
+		off += mvOsSPrintf(buf + off, " echo [polarity] [mode] [width]  > genTOD          - "
+				   "configure General Time Of Day interrupt\n");
+		off += mvOsSPrintf(buf + off, " echo [0|1]                      > legacyMode      - "
+				   "config random delay legacyMode ON/OFF\n");
+	}
+	off += mvOsSPrintf(buf + off, " echo [0]                        > syncLogEnable   - Enable or Disable record GPON range log\n");
+	off += mvOsSPrintf(buf + off, " echo [GEM port] [CPU RX queue]  > omccAdd         - Add OMCI channel\n");
+	off += mvOsSPrintf(buf + off, " echo [0]                        > omccDel         - Delete OMCI channel\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, "Display Commands: cat <file>\n");
+	off += mvOsSPrintf(buf + off, "============================================================================\n");
+	off += mvOsSPrintf(buf + off, " cat printMask                                     - dump printing options\n");
+	if (familyId == MV_88F66X0) {
+		off += mvOsSPrintf(buf + off, " cat genSFC                                        - "
+				   "dump value of General Super Frame Counter\n");
+		off += mvOsSPrintf(buf + off, " cat genTOD                                        - "
+				   "dump General Time Of Day interrupt configuration\n");
+		off += mvOsSPrintf(buf + off, " cat legacyMode                                    - "
+				   "dump random delay legacy mode config\n");
+	}
+	off += mvOsSPrintf(buf + off, " cat syncLogEnable                                 - dump GPON range log enable status\n");
+	off += mvOsSPrintf(buf + off, " cat syncLog                                       - print GPON range log\n");
+	off += mvOsSPrintf(buf + off, " cat omccShow                                      - print OMCC status\n");
+
+	return off;
+}
+
+int onuGponUiSyncLogEnableShow(char *buf)
+{
+	printk(KERN_INFO "The Sync Log is ");
+
+	if (onuGponLogEnable == MV_TRUE)
+		printk(KERN_INFO "enabled\r\n");
+	else
+		printk(KERN_INFO "disabled\r\n");
+
+	return 0;
+}
+
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/*                            ONU SYS FS Definition                           */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/* ========================================================================== */
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Misc Commands                                   */
+/* ========================================================================== */
+static ssize_t misc_show(struct device *dev,
+			 struct device_attribute *attr,
+			 char *buf)
+{
+	const char *name = attr->attr.name;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "printMask"))
+		return ponOnuPrintStatus(buf);
+	else if (!strcmp(name, "prbsUserPattern"))
+		return onuGponUiCfgPrbsUserPattern(buf);
+	else if (!strcmp(name, "helpMisc"))
+		return onuGponUiMiscHelpShow(buf);
+	else if (!strcmp(name, "omccShow"))             /* Show OMCC state */
+		return onuGponUiOmccShow(buf);
+	else if (!strcmp(name, "syncLogEnable"))        /* sync log enable or disable */
+		return onuGponUiSyncLogEnableShow(buf);
+	else if (!strcmp(name, "syncLog"))              /* sync log stop */
+		return onuGponUiSyncLogPrint();
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "genSFC"))
+			return onuGponUiDebugManagerSfcGet(buf);
+		else if ((familyId == MV_88F66X0) && (!strcmp(name, "genTOD")))
+			return onuGponUiDebugManagerTodGet(buf);
+		else if (!strcmp(name, "randomDelaylegacyMode"))
+			return onuGponUiRandomDelayLegacyModeShow(buf);
+	}
+
+	return 0;
+}
+
+static ssize_t misc_store(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	const char *name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+	unsigned int param4 = 0;
+	unsigned int param5 = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x %x %x %x", &param1, &param2, &param3, &param4, &param5);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "serialNumCfg"))              /* serialNumber1, serialNumber2 */
+		onuGponUiDebugSerialNumberSet((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "passwordCfg"))          /* serialNumber1, serialNumber2 */
+		onuGponUiDebugPasswordSet((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "txEnThresCfg"))         /* threshold */
+		onuGponUiTxEnThresholdConfig((MV_U32)param1);
+	else if (!strcmp(name, "utmTxPeriodCfg"))       /* period */
+		onuGponUiUtmTcPeriodConfig((MV_U32)param1);
+	else if (!strcmp(name, "utmTcValidCfg"))        /* valid */
+		onuGponUiUtmTcValidConfig((MV_U32)param1);
+	else if (!strcmp(name, "txDbrBlkSizeCfg"))      /* blockSize */
+		onuGponUitxDbrBlockSizeConfig((MV_U32)param1);
+	else if (!strcmp(name, "readReg"))              /* readOffset, readEntry */
+		onuGponUiDebugReadReg((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "writeReg"))             /*  writeOffset, writeEntry, regValue */
+		onuGponUiDebugWriteReg((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "debugModeCfg"))         /* debugMode */
+		onuGponUiDebugDebugModeSet((MV_U32)param1);
+	else if (!strcmp(name, "stopPonSw"))            /* uponMode */
+		onuGponUiDebugUponModeSet((MV_U32)param1);
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	else if (!strcmp(name, "pmCheck"))              /* step */
+		onuGponCliDebugPerformanceCheck((MV_U32)param1);
+	else if (!strcmp(name, "pmClear"))
+		onuGponCliDebugPerformanceClear();
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+	else if (!strcmp(name, "prbsUserDefinedPattern"))
+		onuGponUiCfgSetUserPatternBurst((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "prbsPreDefinedPattern"))
+		onuGponUiCfgSetDefinedPatternBurst((MV_U32)param1, (MV_U32)param2, (MV_U32)param3, (MV_U32)param4, (MV_U32)param5);
+	else if (!strcmp(name, "printMask")) /* module, print level, options */
+		ponOnuChangePrintStatus((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+	else if (!strcmp(name, "adminCfg")) /* admin 0=enable 1 = disable */
+		onuGponUiDebugAdminMode((MV_U32)param1);
+	else if (!strcmp(name, "t01IntervalCfg")) /* T01 interval in mS */
+		onuGponUiT01IntervalConfig((MV_U32)param1);
+	else if (!strcmp(name, "t02IntervalCfg")) /* T02 interval in mS */
+		onuGponUiT02IntervalConfig((MV_U32)param1);
+	else if (!strcmp(name, "syncLogEnable")) /* sync log enable or disable */
+		onuGponUiSyncLogEnable((MV_U32)param1);
+	else if (!strcmp(name, "omccAdd")) /* Add OMCC */
+		onuGponUiOmccAdd((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "omccDel")) /* Delete OMCC */
+		onuGponUiOmccDel();
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "genSFC"))                            /* SFC value */
+			onuGponUiDebugManagerSfcSet((MV_U32)param1);
+		else if (!strcmp(name, "genTOD"))                       /* polarity, mode, width */
+			onuGponUiDebugManagerTodSet((MV_U32)param1, (MV_U32)param2, (MV_U32)param3);
+		else if (!strcmp(name, "randomDelaylegacyMode"))        /* legacy mode */
+			onuGponUiRandomDelayLegacyModeConfig((MV_U32)param1);
+		else
+			printk(KERN_INFO KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	} else
+		printk(KERN_INFO KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Misc Attributes                                 */
+/* ========================================================================== */
+static DEVICE_ATTR(serialNumCfg,          S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(passwordCfg,           S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(txEnThresCfg,          S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(utmTxPeriodCfg,        S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(utmTcValidCfg,         S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(txDbrBlkSizeCfg,       S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(readReg,               S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(writeReg,              S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(debugModeCfg,          S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(stopPonSw,             S_IWUSR, misc_show, misc_store);
+#ifdef MV_GPON_PERFORMANCE_CHECK
+static DEVICE_ATTR(pmCheck,               S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(pmClear,               S_IWUSR, misc_show, misc_store);
+#endif /* MV_GPON_PERFORMANCE_CHECK */
+static DEVICE_ATTR(prbsUserDefinedPattern, S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(prbsPreDefinedPattern, S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(prbsUserPattern,       S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(printMask,             S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(adminCfg,              S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(helpMisc,              S_IRUSR, misc_show, misc_store);
+static DEVICE_ATTR(t01IntervalCfg,        S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(t02IntervalCfg,        S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(syncLogEnable,         S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(syncLog,               S_IRUSR, misc_show, misc_store);
+static DEVICE_ATTR(genSFC,                S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(genTOD,                S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(randomDelaylegacyMode, S_IRUSR | S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(omccAdd,               S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(omccDel,               S_IWUSR, misc_show, misc_store);
+static DEVICE_ATTR(omccShow,              S_IRUSR, misc_show, misc_store);
+
+static struct attribute *misc_attrs[] = {
+	&dev_attr_serialNumCfg.attr,
+	&dev_attr_passwordCfg.attr,
+	&dev_attr_txEnThresCfg.attr,
+	&dev_attr_utmTxPeriodCfg.attr,
+	&dev_attr_utmTcValidCfg.attr,
+	&dev_attr_txDbrBlkSizeCfg.attr,
+	&dev_attr_readReg.attr,
+	&dev_attr_writeReg.attr,
+	&dev_attr_debugModeCfg.attr,
+	&dev_attr_stopPonSw.attr,
+#ifdef MV_GPON_PERFORMANCE_CHECK
+	&dev_attr_pmCheck.attr,
+	&dev_attr_pmClear.attr,
+#endif  /* MV_GPON_PERFORMANCE_CHECK */
+	&dev_attr_prbsUserDefinedPattern.attr,
+	&dev_attr_prbsPreDefinedPattern.attr,
+	&dev_attr_prbsUserPattern.attr,
+	&dev_attr_printMask.attr,
+	&dev_attr_adminCfg.attr,
+	&dev_attr_helpMisc.attr,
+	&dev_attr_t01IntervalCfg.attr,
+	&dev_attr_t02IntervalCfg.attr,
+	&dev_attr_syncLogEnable.attr,
+	&dev_attr_syncLog.attr,
+	&dev_attr_genSFC.attr,
+	&dev_attr_genTOD.attr,
+	&dev_attr_randomDelaylegacyMode.attr,
+	&dev_attr_omccAdd.attr,
+	&dev_attr_omccDel.attr,
+	&dev_attr_omccShow.attr,
+	NULL
+};
+
+static struct attribute_group misc_group = {
+	.name	= "misc",
+	.attrs	= misc_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Protocol Group                                 */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Protocol Commands                               */
+/* ========================================================================== */
+static ssize_t protocol_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	const char *name = attr->attr.name;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "txBurst"))
+		return onuGponUiDebugBurstInfo(buf);
+	else if (!strcmp(name, "gemFrameLen"))
+		return onuGponUiGemFrameLengthShow(buf);
+	else if (!strcmp(name, "helpProto"))
+		return onuGponUiProtoHelpShow(buf);
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "acCoupling"))
+			return onuGponUiDebugManagerAcCouplingGet(buf);
+		else if (!strcmp(name, "randDelay"))
+			return onuGponUiDebugManagerRandomDelayGet(buf);
+		else if (!strcmp(name, "activeTxBm"))
+			return onuGponUiDebugManagerActiveTxBitmapGet(buf);
+	}
+	return 0;
+}
+
+static ssize_t protocol_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t len)
+{
+	const char *name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+	unsigned int param4 = 0;
+	unsigned int param5 = 0;
+	MV_U32 familyId = MV_88F66X0; /*mvCtrlModelGet();*/
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d %d %d", &param1, &param2, &param3, &param4, &param5);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "txBurstCfg"))                /* start, stop, order, polarity, mask */
+		onuGponUiDebugBurstConfig((MV_U32)param1, (MV_U32)param2, (MV_U32)param3,
+					  (MV_U32)param4, (MV_U32)param5);
+	else if (!strcmp(name, "berIntervalCfg"))       /* interval */
+		onuGponUiDebugBerIntervalDebug((MV_U32)param1);
+	else if (!strcmp(name, "berCoeffCfg"))          /* numerator, denominator*/
+		onuGponUiDebugBerCoefficientDebug((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "berThesholdCfg"))       /* sd, sf */
+		onuGponUiBerThresholdsConfig((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "omciPortCfg"))          /* portId, valid */
+		onuGponUiGemOmciPortIdConfig((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "gemFrameLenCfg"))       /* payloadLen */
+		onuGponUiGemPayloadLenConfig((MV_U32)param1);
+	else if (!strcmp(name, "ethFrameLenCfg"))       /* minFrameLenArg, maxFrameLenArg */
+		onuGponUiGemEthFrameLenConfig((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "omciFrameLenCfg"))      /* minFrameLenArg, maxFrameLenArg */
+		onuGponUiGemOmciFrameLenConfig((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "ploamMsgSend"))         /* msgId, onuId, data1, data2, data3 */
+		onuGponUiDebugManagerSendPloam((MV_U32)param1, (MV_U32)param2, (MV_U32)param3,
+					       (MV_U32)param4, (MV_U32)param5);
+	else if (!strcmp(name, "ploamMsgRece"))         /* msgId, onuId, data1, data2, data3 */
+		onuGponUiDebugManagerReceivePloam((MV_U32)param1, (MV_U32)param2, (MV_U32)param3,
+						  (MV_U32)param4, (MV_U32)param5);
+	else if (!strcmp(name, "ploamBurstRcv"))        /* msgId, onuId, data1, data2, data3 */
+		onuGponUiDebugManagerRcvBurstPloams((MV_U32)param1, (MV_U32)param2, (MV_U32)param3,
+						    (MV_U32)param4, (MV_U32)param5);
+	else if (!strcmp(name, "ploamBurstCfg"))        /* burst size */
+		onuGponUiDebugManagerRcvBurstCfg((MV_U32)param1);
+	else if (!strcmp(name, "clearFifoCnts"))        /* value */
+		onuGponUiDebugManagerFifoCntsClear((MV_U32)param1);
+	else if (!strcmp(name, "fifoSupport"))          /* enable/disable */
+		onuGponUiDebugManagerFifoSupportSet((MV_U32)param1);
+	else if (familyId == MV_88F66X0) {
+		if (!strcmp(name, "acCoupling"))                                /* mode, time, pattern1, pattern2 */
+			onuGponUiDebugManagerAcCouplingSet((MV_U32)param1, (MV_U32)param2, (MV_U32)param3,
+							   (MV_U32)param4);
+		else if (!strcmp(name, "randDelay"))                            /* delay units */
+			onuGponUiDebugManagerRandomDelaySet((MV_U32)param1);
+		else if (!strcmp(name, "activeTxBm"))                           /* bitmap, valid */
+			onuGponUiDebugManagerActiveTxBitmapSet((MV_U32)param1, (MV_U32)param2);
+		else
+			printk(KERN_INFO KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	} else
+		printk(KERN_INFO KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Protocol Attributes                             */
+/* ========================================================================== */
+static DEVICE_ATTR(txBurstCfg,       S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(txBurst,          S_IRUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(berIntervalCfg,   S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(berCoeffCfg,      S_IRUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(berThesholdCfg,   S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(omciPortCfg,      S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(gemFrameLen,      S_IRUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(gemFrameLenCfg,   S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(ethFrameLenCfg,   S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(omciFrameLenCfg,  S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(ploamMsgSend,     S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(ploamMsgRece,     S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(ploamBurstRcv,    S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(ploamBurstCfg,    S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(clearFifoCnts,    S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(fifoSupport,      S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(acCoupling,       S_IRUSR | S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(randDelay,        S_IRUSR | S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(activeTxBm,       S_IRUSR | S_IWUSR, protocol_show, protocol_store);
+static DEVICE_ATTR(helpProto,        S_IRUSR, protocol_show, protocol_store);
+
+static struct attribute *protocol_attrs[] = {
+	&dev_attr_txBurstCfg.attr,
+	&dev_attr_txBurst.attr,
+	&dev_attr_berIntervalCfg.attr,
+	&dev_attr_berCoeffCfg.attr,
+	&dev_attr_berThesholdCfg.attr,
+	&dev_attr_omciPortCfg.attr,
+	&dev_attr_gemFrameLen.attr,
+	&dev_attr_gemFrameLenCfg.attr,
+	&dev_attr_ethFrameLenCfg.attr,
+	&dev_attr_omciFrameLenCfg.attr,
+	&dev_attr_ploamMsgSend.attr,
+	&dev_attr_ploamMsgRece.attr,
+	&dev_attr_ploamBurstRcv.attr,
+	&dev_attr_ploamBurstCfg.attr,
+	&dev_attr_clearFifoCnts.attr,
+	&dev_attr_fifoSupport.attr,
+	&dev_attr_acCoupling.attr,
+	&dev_attr_randDelay.attr,
+	&dev_attr_activeTxBm.attr,
+	&dev_attr_helpProto.attr,
+	NULL
+};
+
+static struct attribute_group protocol_group = {
+	.name	= "protocol",
+	.attrs	= protocol_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Introp Group                                    */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Introp Commands                                 */
+/* ========================================================================== */
+static ssize_t introp_show(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	const char *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "manMode"))
+		return onuGponUiOverrideShow(buf);
+	else if (!strcmp(name, "helpIot"))
+		return onuGponUiIntropHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t introp_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t len)
+{
+	const char *name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+	unsigned int param3 = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d", &param1, &param2, &param3);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "onuIdCfg"))
+		onuGponUiOnuIdConfig((MV_U32)param1, (MV_U32)param2); /* onuId, enable */
+	else if (!strcmp(name, "portIdCfg"))
+		onuGponUiPortIdConfig((MV_U32)param1, (MV_U32)param2); /* portId, enable */
+	else if (!strcmp(name, "eqdCfg"))
+		onuGponUiEquDelaySetConfig((MV_U32)param1, (MV_U32)param2); /* equDelayVal, enable*/
+	else if (!strcmp(name, "eqdChange"))
+		onuGponUiEquDelayChangeConfig((MV_U32)param1, (MV_U32)param2); /* direction, size */
+	else if (!strcmp(name, "extBurstCfg"))
+		onuGponUiExtendedBurstConfig((MV_U32)param1, (MV_U32)param2, (MV_U32)param3); /* enable, rangeValue, operValue */
+	else if (!strcmp(name, "extBurstDelayCfg"))
+		onuGponUiExtendedBurstDelayConfig((MV_U32)param1, (MV_U32)param2, (MV_U32)param3); /* enable, rangeValue, operValue */
+	else if (!strcmp(name, "delimiterCfg"))
+		onuGponUiDelimiterConfig((MV_U32)param1, (MV_U32)param2); /* enable , value*/
+	else if (!strcmp(name, "preambleCfg"))
+		onuGponUiDebugOverheadPreamble((MV_U32)param1, (MV_U32)param2, (MV_U32)param3); /* pream3RangeCnt, pream3OperCnt, pream3PattCnt */
+	else if (!strcmp(name, "guardCfg"))
+		onuGponUiDebugOverheadGuard((MV_U32)param1); /* guard */
+	else if (!strcmp(name, "manModeCfg"))
+		onuGponUiDebugOverheadMode((MV_U32)param1); /* overMode */
+	else
+		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Introp Attributes                                 */
+/* ========================================================================== */
+static DEVICE_ATTR(onuIdCfg,        S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(portIdCfg,       S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(eqdCfg,          S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(eqdChange,       S_IRUSR, introp_show, introp_store);
+static DEVICE_ATTR(extBurstCfg,     S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(extBurstDelayCfg, S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(delimiterCfg,    S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(preambleCfg,     S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(guardCfg,        S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(manModeCfg,      S_IWUSR, introp_show, introp_store);
+static DEVICE_ATTR(manMode,         S_IRUSR, introp_show, introp_store);
+static DEVICE_ATTR(helpIot,         S_IRUSR, introp_show, introp_store);
+
+static struct attribute *introp_attrs[] = {
+	&dev_attr_onuIdCfg.attr,
+	&dev_attr_portIdCfg.attr,
+	&dev_attr_eqdCfg.attr,
+	&dev_attr_eqdChange.attr,
+	&dev_attr_extBurstCfg.attr,
+	&dev_attr_extBurstDelayCfg.attr,
+	&dev_attr_delimiterCfg.attr,
+	&dev_attr_preambleCfg.attr,
+	&dev_attr_guardCfg.attr,
+	&dev_attr_manModeCfg.attr,
+	&dev_attr_manMode.attr,
+	&dev_attr_helpIot.attr,
+	NULL
+};
+
+static struct attribute_group introp_group = {
+	.name	= "introp",
+	.attrs	= introp_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Data Group                                      */
+/* ========================================================================== */
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Data Commands                                   */
+/* ========================================================================== */
+static ssize_t data_show(struct device *dev,
+			 struct device_attribute *attr,
+			 char *buf)
+{
+	const char *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "showTcont"))
+		return onuGponUiDebugTcont();
+	else if (!strcmp(name, "showGem0xxx"))
+		return onuGponUiDebugGemPortid(buf, 0);
+	else if (!strcmp(name, "showGem1xxx"))
+		return onuGponUiDebugGemPortid(buf, 1);
+	else if (!strcmp(name, "showGem2xxx"))
+		return onuGponUiDebugGemPortid(buf, 2);
+	else if (!strcmp(name, "showGem3xxx"))
+		return onuGponUiDebugGemPortid(buf, 3);
+	else if (!strcmp(name, "showAes0xxx"))
+		return onuGponUiDebugAesGemAll(buf, 0);
+	else if (!strcmp(name, "showAes1xxx"))
+		return onuGponUiDebugAesGemAll(buf, 1);
+	else if (!strcmp(name, "showAes2xxx"))
+		return onuGponUiDebugAesGemAll(buf, 2);
+	else if (!strcmp(name, "showAes3xxx"))
+		return onuGponUiDebugAesGemAll(buf, 3);
+	else if (!strcmp(name, "showHighPriTx"))
+		return onuGponUiDebugHighPriTxShow(buf);
+	else if (!strcmp(name, "helpData"))
+		return onuGponUiDataHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t data_store(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	const char *name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d", &param1, &param2);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "cfgTcont"))
+		onuGponUiTcontConfig((MV_U32)param1, (MV_U32)param2); /* alloc, tcont */
+	else if (!strcmp(name, "clrTcont"))
+		onuGponUiClearTcontConfig((MV_U32)param1); /* tcont */
+	else if (!strcmp(name, "rstTcont"))
+		onuGponUiResetTcontsConfig();
+	else if (!strcmp(name, "cfgGem"))
+		onuGponUiDebugGemPortidValidSet((MV_U32)param1, (MV_U32)param2); /* portId, enable */
+	else if (!strcmp(name, "cfgAllGem"))
+		onuGponUiDebugAllGemPortidValidSet((MV_U32)param1); /* enable */
+#ifdef MV_GPON_STATIC_GEM_PORT
+	else if (!strcmp(name, "dummyGemState"))
+		onuGponUiDebugDummyGemPortFlagSet((MV_U32)param1); /* flag */
+	else if (!strcmp(name, "dummyGemRst"))
+		onuGponUiDebugDummyGemPortReset();
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+	else if (!strcmp(name, "cfgAesPort"))
+		onuGponUiDebugAesSet((MV_U32)param1, (MV_U32)param2); /* portId, enable */
+	else if (!strcmp(name, "cfgAllAes"))
+		onuGponUiDebugAesSetAll((MV_U32)param1); /* enable */
+	else if (!strcmp(name, "cfgOmciPath"))
+		onuGponUiDebugOmciPathSet((MV_U32)param1);
+	else if (!strcmp(name, "cfgHighPriTx"))
+		onuGponUiDebugHighPriTxSet((MV_U32)param1);
+	else if (!strcmp(name, "addTcontMap"))
+		onuGponUiDebugTcontMapAdd((MV_U32)param1, (MV_U32)param2);
+	else if (!strcmp(name, "delTcontMap"))
+		onuGponUiDebugTcontMapDel((MV_U32)param1);
+	else
+		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            Data Attributes                                 */
+/* ========================================================================== */
+static DEVICE_ATTR(cfgTcont,          S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(clrTcont,          S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(rstTcont,          S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(showTcont,         S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(cfgGem,            S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(cfgAllGem,         S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(showGem0xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showGem1xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showGem2xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showGem3xxx,       S_IRUSR, data_show, data_store);
+#ifdef MV_GPON_STATIC_GEM_PORT
+static DEVICE_ATTR(dummyGemState,     S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(dummyGemRst,       S_IWUSR, data_show, data_store);
+#endif /* MV_GPON_STATIC_GEM_PORT */
+static DEVICE_ATTR(cfgAesPort,        S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(cfgAllAes,         S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(cfgOmciPath,       S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(cfgHighPriTx,      S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(addTcontMap,       S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(delTcontMap,       S_IWUSR, data_show, data_store);
+static DEVICE_ATTR(showHighPriTx,     S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showAes0xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showAes1xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showAes2xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(showAes3xxx,       S_IRUSR, data_show, data_store);
+static DEVICE_ATTR(helpData,          S_IRUSR, data_show, data_store);
+
+static struct attribute *data_attrs[] = {
+	&dev_attr_cfgTcont.attr,
+	&dev_attr_clrTcont.attr,
+	&dev_attr_rstTcont.attr,
+	&dev_attr_showTcont.attr,
+	&dev_attr_cfgGem.attr,
+	&dev_attr_cfgAllGem.attr,
+	&dev_attr_showGem0xxx.attr,
+	&dev_attr_showGem1xxx.attr,
+	&dev_attr_showGem2xxx.attr,
+	&dev_attr_showGem3xxx.attr,
+#ifdef MV_GPON_STATIC_GEM_PORT
+	&dev_attr_dummyGemState.attr,
+	&dev_attr_dummyGemRst.attr,
+#endif  /* MV_GPON_STATIC_GEM_PORT */
+	&dev_attr_cfgAesPort.attr,
+	&dev_attr_cfgAllAes.attr,
+	&dev_attr_cfgOmciPath.attr,
+	&dev_attr_cfgHighPriTx.attr,
+	&dev_attr_addTcontMap.attr,
+	&dev_attr_delTcontMap.attr,
+	&dev_attr_showHighPriTx.attr,
+	&dev_attr_showAes0xxx.attr,
+	&dev_attr_showAes1xxx.attr,
+	&dev_attr_showAes2xxx.attr,
+	&dev_attr_showAes3xxx.attr,
+	&dev_attr_helpData.attr,
+	NULL
+};
+
+static struct attribute_group data_group = {
+	.name	= "data",
+	.attrs	= data_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Pm Group                                        */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Pm Commands                                     */
+/* ========================================================================== */
+static ssize_t gpon_pm_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	const char *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "fecCnt"))
+		return onuGponUiFecCountersShow(buf);
+	else if (!strcmp(name, "rxPloamCnt"))
+		return onuGponUiRxPloamCountersShow(buf);
+	else if (!strcmp(name, "txPloamCnt"))
+		return onuGponUiTxPloamCountersShow(buf);
+	else if (!strcmp(name, "bwMapCnt"))
+		return onuGponUiBwMapCountersShow(buf);
+	else if (!strcmp(name, "stdCnt"))
+		return onuGponUiStandardCountersShow(buf);
+	else if (!strcmp(name, "gemCnt"))
+		return onuGponUiGemCountersShow(buf);
+	else if (!strcmp(name, "txPktCnt"))
+		return onuGponUiTxCountersShow();
+	else if (!strcmp(name, "rawCnt_1"))
+		return onuGponUiRaw_1Counters(buf);
+	else if (!strcmp(name, "rawCnt_2"))
+		return onuGponUiRaw_2Counters(buf);
+	else if (!strcmp(name, "rawCnt_3"))
+		return onuGponUiRaw_3Counters(buf);
+	else if (!strcmp(name, "showGemPortMibPmDb"))
+		return onuGponUiDebugGemPortMibPmDbShow(buf);
+	else if (!strcmp(name, "helpGPm"))
+		return onuGponUiPmHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t gpon_pm_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	const char *name = attr->attr.name;
+	unsigned long flags;
+	unsigned int param1 = 0;
+	unsigned int param2 = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d", &param1, &param2);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "cntRdClrFlState"))
+		onuGponUiCountersReadClearFlag((MV_BOOL)param1);
+	if (!strcmp(name, "bwMapCntByState"))
+		onuGponBwMapCountersEnDisFlag((MV_BOOL)param1);
+	else if (!strcmp(name, "startGemPortMibPm"))
+		onuGponUiDebugGemPmStart((MV_U32)param1, (MV_U32)param2);               /* Start Gem port PM */
+	else if (!strcmp(name, "stopGemPortMibPm"))
+		onuGponUiDebugGemPmStop((MV_U32)param1, (MV_U32)param2);                /* Stop Gem port PM */
+	else if (!strcmp(name, "resetMibPm"))
+		onuGponUiDebugGemPmReset();                                             /* Reset PM*/
+	else if (!strcmp(name, "getMibPm"))
+		onuGponUiDebugGemPmGet((MV_U32)param1, (MV_U32)param2);                 /* Get GEM PM counters */
+	else
+		printk(KERN_INFO "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+/* ========================================================================== */
+/*                            PM Attributes                                   */
+/* ========================================================================== */
+static DEVICE_ATTR(fecCnt,        S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(rxPloamCnt,    S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(txPloamCnt,    S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(bwMapCnt,      S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(stdCnt,        S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(gemCnt,        S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(txPktCnt,      S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(rawCnt_1,      S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(rawCnt_2,      S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(rawCnt_3,      S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(cntRdClrFlState, S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(bwMapCntByState, S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(helpGPm,       S_IRUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(startGemPortMibPm, S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(stopGemPortMibPm,  S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(resetMibPm,        S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(getMibPm,          S_IWUSR, gpon_pm_show, gpon_pm_store);
+static DEVICE_ATTR(showGemPortMibPmDb, S_IRUSR, gpon_pm_show, gpon_pm_store);
+
+static struct attribute *gpon_pm_attrs[] = {
+	&dev_attr_fecCnt.attr,
+	&dev_attr_rxPloamCnt.attr,
+	&dev_attr_txPloamCnt.attr,
+	&dev_attr_bwMapCnt.attr,
+	&dev_attr_stdCnt.attr,
+	&dev_attr_gemCnt.attr,
+	&dev_attr_txPktCnt.attr,
+	&dev_attr_rawCnt_1.attr,
+	&dev_attr_rawCnt_2.attr,
+	&dev_attr_rawCnt_3.attr,
+	&dev_attr_cntRdClrFlState.attr,
+	&dev_attr_bwMapCntByState.attr,
+	&dev_attr_helpGPm.attr,
+	&dev_attr_startGemPortMibPm.attr,
+	&dev_attr_stopGemPortMibPm.attr,
+	&dev_attr_resetMibPm.attr,
+	&dev_attr_getMibPm.attr,
+	&dev_attr_showGemPortMibPmDb.attr,
+	NULL
+};
+
+static struct attribute_group gpon_pm_group = {
+	.name	= "pm",
+	.attrs	= gpon_pm_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Info Group                                      */
+/* ========================================================================== */
+/******************************************************************************/
+
+/* ========================================================================== */
+/*                            Info Commands                                   */
+/* ========================================================================== */
+static ssize_t gpon_info_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	const char *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "infoGpon"))
+		return onuGponUiInfoShow(buf);
+	else if (!strcmp(name, "alarmGpon"))
+		return onuGponUiAlarmShow(buf);
+	else if (!strcmp(name, "swfifoGpon"))
+		return onuGponUiFifoShow(buf);
+	else if (!strcmp(name, "fecStatus"))
+		return onuGponUiFecStatus(buf);
+	else if (!strcmp(name, "helpGInfo"))
+		return onuGponUiInfoHelpShow(buf);
+
+	return 0;
+}
+
+static ssize_t gpon_info_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t len)
+{
+	return 0;
+}
+
+/* ========================================================================== */
+/*                            Info Attributes                                 */
+/* ========================================================================== */
+static DEVICE_ATTR(infoGpon,   S_IRUSR, gpon_info_show, gpon_info_store);
+static DEVICE_ATTR(alarmGpon,  S_IRUSR, gpon_info_show, gpon_info_store);
+static DEVICE_ATTR(swfifoGpon, S_IRUSR, gpon_info_show, gpon_info_store);
+static DEVICE_ATTR(fecStatus,  S_IRUSR, gpon_info_show, gpon_info_store);
+static DEVICE_ATTR(helpGInfo,  S_IRUSR, gpon_info_show, gpon_info_store);
+
+static struct attribute *gpon_info_attrs[] = {
+	&dev_attr_infoGpon.attr,
+	&dev_attr_alarmGpon.attr,
+	&dev_attr_swfifoGpon.attr,
+	&dev_attr_fecStatus.attr,
+	&dev_attr_helpGInfo.attr,
+	NULL
+};
+
+static struct attribute_group gpon_info_group = {
+	.name	= "info",
+	.attrs	= gpon_info_attrs,
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            ONU SYS FS                                      */
+/* ========================================================================== */
+/******************************************************************************/
+int __devinit gpon_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "gpon");
+	if (!pd) {
+		platform_device_register_simple("gpon", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "gpon");
+	}
+
+	if (!pd) {
+		printk(KERN_INFO KERN_ERR "%s: cannot find gpon device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &gpon_info_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &gpon_pm_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &data_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &introp_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &protocol_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &misc_group);
+	if (err) {
+		printk(KERN_INFO KERN_INFO "sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	printk(KERN_INFO KERN_INFO "= PON Module SYS FS Init ended successfully =\n");
+out:
+	return err;
+}
+
+void gpon_sysfs_delete(void)
+{
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "gpon");
+	if (!pd) {
+		printk(KERN_INFO "%s: cannot find gpon device\n", __func__);
+		return;
+	}
+
+	sysfs_remove_group(&pd->kobj, &gpon_info_group);
+	sysfs_remove_group(&pd->kobj, &gpon_pm_group);
+	sysfs_remove_group(&pd->kobj, &data_group);
+	sysfs_remove_group(&pd->kobj, &introp_group);
+	sysfs_remove_group(&pd->kobj, &protocol_group);
+	sysfs_remove_group(&pd->kobj, &misc_group);
+
+	printk(KERN_INFO KERN_INFO "= PON Module SYS FS Remove ended successfully =\n");
+}
+
+/*******************************************************************************
+**
+**  onuGponUsrInterfaceCreate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function create user interface - sys fs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponUsrInterfaceCreate(void)
+{
+	if (gpon_sysfs_init() != 0)
+		return MV_ERROR;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponUsrInterfaceRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release user interface - sys fs
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponUsrInterfaceRelease(void)
+{
+	gpon_sysfs_delete();
+
+	return MV_OK;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.h
new file mode 100644
index 0000000..fe96b7d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/gpon/gponOnuLnxKsUI.h
@@ -0,0 +1,102 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsUI.h                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON User Interface - SysFs         **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_LINUX_KS_USR_INTERFACE_H
+#define _ONU_GPON_LINUX_KS_USR_INTERFACE_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponUsrInterfaceCreate(void);
+MV_STATUS onuGponUsrInterfaceRelease(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_LINUX_KS_USR_INTERFACE_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.c
new file mode 100644
index 0000000..3318ac9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.c
@@ -0,0 +1,642 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuLnxKsMI.c                                            **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU PON Management Interface MUX      **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   27 Nov 2011  Konstantin Porotchkin   created                              *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include <linux/version.h>
+#include "ponOnuHeader.h"
+#include "ponOnuLnxKsMI.h"
+#include "eponOnuHeader.h"
+#include "gponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/perf/ponOnuLnxKsMI.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+S_PonModuleCdev ponDev;
+/*
+   static char *drvMode = "epon";
+   module_param(drvMode, charp, 0);
+   MODULE_PARM_DESC(drvMode, "PON driver mode (epon/gpon)");
+ */
+/* udev class's */
+struct class  *pon_udev_class;
+struct device *pon_udev_dev;
+
+struct fasync_struct *mvPonAsqueue;
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+
+/*******************************************************************************
+**
+**  mvPonMiInit
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: Pre-Initialize driver
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0) on success or error
+**
+*******************************************************************************/
+int mvPonMiPreInit(void)
+{
+	MV_STATUS status = 0;
+
+	status = ponDev.func.ponOnuPreSetup();
+	if (status != MV_OK)
+		printk(KERN_INFO "= PON Module pre-setup failed =\n");
+
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvPonMiInit
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: Initialize driver
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0) on success or error
+**
+*******************************************************************************/
+int mvPonMiInit(void)
+{
+	MV_STATUS status = 0;
+
+	status = ponDev.func.ponOnuSetup();
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module setup failed =\n");
+		goto ponInitError;
+	}
+
+	status = ponDev.func.ponOnuSwitchOn();
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module switch ON failed =\n");
+		goto ponInitError;
+	}
+
+	status = ponDev.func.ponOnuOperate();
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module operate failed =\n");
+		goto ponInitError;
+	}
+
+	/* create user interface */
+	status = ponDev.func.userInterfaceCreate();
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module UI creation failed =\n");
+		goto ponInitError;
+	}
+
+	/* register mng notification callback */
+	status = ponDev.func.apiStatusNotifyRegister(onuPonMiNotifyCallback);
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module API status notification callback registration failed =\n");
+		goto ponInitError;
+	}
+
+	/* register link status callback */
+	status = ponDev.func.apiLinkStatusCallbackRegister();
+	if (status != MV_OK) {
+		printk(KERN_INFO "= PON Module link status notification callback registration failed =\n");
+		goto ponInitError;
+	}
+
+	printk(KERN_INFO "= PON Module Init ended successfully =\n");
+
+ponInitError:
+	return status;
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevIoctl
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function execute IO commands
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**               unsigned int cmd
+**               unsigned long arg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+long mvPonCdevIoctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = -EINVAL;
+	unsigned long flags;
+	E_PonDriverMode drvMode;
+
+	switch (cmd) {
+	/* ====== MVPON_IOCTL_START ======= */
+	case MVPON_IOCTL_START:
+		if (ponDev.drvMode == E_PON_DRIVER_UNDEF_MODE) {
+			/* The driver only alows transition from Undefined to EPON or GPON mode */
+			ret = get_user(drvMode, (E_PonDriverMode __user *)arg);
+			if (ret != 0) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) copy from user failed\n", __FILE_DESC__, __LINE__);
+				goto ioctlErr;
+			}
+
+			/* pre-setup without spin lock */
+			if (drvMode == E_PON_DRIVER_EPON_MODE)
+				ponDev.func.ponOnuPreSetup = onuEponPreSetup;
+			else if (drvMode == E_PON_DRIVER_GPON_MODE)
+				ponDev.func.ponOnuPreSetup = onuGponPreSetup;
+			else {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) requested unsupported PON mode 0x%x\n",
+					   __FILE_DESC__, __LINE__, arg);
+				goto ioctlErr;
+			}
+
+			ret = mvPonMiPreInit();
+			if (ret != 0) {
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) error init when switch to %s mode\n",
+					   __FILE_DESC__, __LINE__,
+					   (drvMode == E_PON_DRIVER_EPON_MODE) ? "EPON" : "GPON");
+				goto ioctlErr;
+			}
+
+			spin_lock_irqsave(&onuPonIrqLock, flags);
+
+			if (drvMode == E_PON_DRIVER_EPON_MODE) {
+				ponDev.func.ponOnuSetup = onuEponSetup;
+				ponDev.func.ponOnuSwitchOn = onuEponSwitchOn;
+				ponDev.func.ponOnuOperate = onuEponOperate;
+				ponDev.func.userInterfaceCreate = onuEponUsrInterfaceCreate;
+				ponDev.func.usrInterfaceRelease = onuEponUsrInterfaceRelease;
+				ponDev.func.rtosResourceRelease = onuEponRtosResourceRelease;
+				ponDev.func.memRelease = 0;
+				ponDev.func.apiStatusNotifyRegister = onuEponApiStatusNotifyRegister;
+				ponDev.func.apiLinkStatusCallbackRegister = onuEponApiLinkStatusCallbackRegister;
+				ponDev.func.cdevIoctl = mvEponCdevIoctl;
+
+			} else if (drvMode == E_PON_DRIVER_GPON_MODE) {
+				ponDev.func.ponOnuSetup = onuGponSetup;
+				ponDev.func.ponOnuSwitchOn = onuGponSwitchOn;
+				ponDev.func.ponOnuOperate = onuGponOperate;
+				ponDev.func.userInterfaceCreate = onuGponUsrInterfaceCreate;
+				ponDev.func.usrInterfaceRelease = onuGponUsrInterfaceRelease;
+				ponDev.func.rtosResourceRelease = onuGponRtosResourceRelease;
+				ponDev.func.memRelease = onuPonMemRelease;
+				ponDev.func.apiStatusNotifyRegister = onuGponApiStatusNotifyRegister;
+				ponDev.func.apiLinkStatusCallbackRegister = onuGponApiLinkStatusCallbackRegister;
+				ponDev.func.cdevIoctl = mvGponCdevIoctl;
+
+			} else {
+				spin_unlock_irqrestore(&onuPonIrqLock, flags);
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) requested unsupported PON mode 0x%x\n",
+					   __FILE_DESC__, __LINE__, arg);
+				goto ioctlErr;
+			}
+
+			ret = mvPonMiInit();
+			if (ret != 0) {
+				spin_unlock_irqrestore(&onuPonIrqLock, flags);
+				mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+					   "ERROR: (%s:%d) error switching to %s mode\n",
+					   __FILE_DESC__, __LINE__,
+					   (drvMode == E_PON_DRIVER_EPON_MODE) ? "EPON" : "GPON");
+				goto ioctlErr;
+			}
+			ponDev.drvMode = drvMode;
+
+			spin_unlock_irqrestore(&onuPonIrqLock, flags);
+
+		} else {
+			/* Switching between EPON-GPON modes requires reboot initiated by US application */
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) command MVPON_IOCTL_INIT is not supported in this mode\n",
+				   __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+
+		break;
+
+	/* ====== MVPON_IOCTL_MODE_GET ======= */
+	case MVPON_IOCTL_MODE_GET:
+		ret = put_user(ponDev.drvMode, (int __user *)arg);
+		if (ret != 0) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) copy to user failed\n", __FILE_DESC__, __LINE__);
+			goto ioctlErr;
+		}
+		break;
+
+	/* ====== All GPON/EPON-specific IOCTLs ======= */
+	default:
+		if (ponDev.drvMode != E_PON_DRIVER_UNDEF_MODE)
+			ret = ponDev.func.cdevIoctl(filp, cmd, arg);
+		else
+			ret = -EINVAL;
+	}
+
+ioctlErr:
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevFasync
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function execute notification to User space
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**               unsigned int cmd
+**               unsigned long arg
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+
+void onuPonMiNotifyCallback(MV_U32 onuState)
+{
+	if (mvPonAsqueue)
+		kill_fasync(&mvPonAsqueue, SIGIO, POLL_IN);
+}
+
+int mvPonCdevFasync(int fd, struct file *filp, int mode)
+{
+	return fasync_helper(fd, filp, mode, &mvPonAsqueue);
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevPoll
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function polls the PON Char device
+**
+**  PARAMETERS:  struct file *filp
+**               struct poll_table_struct *pt
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     mask
+**
+*******************************************************************************/
+unsigned int mvPonCdevPoll(struct file *filp, struct poll_table_struct *pt)
+{
+	unsigned int mask = 0;
+
+	poll_wait(filp, &(ponDev.r_wait), pt);
+
+	/* Kernel to user */
+	if (ponEventQueueIsEmpty() == MV_FALSE)
+		mask |= POLLIN;
+
+	return mask;
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevRead
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function reads the PON Char device
+**
+**  PARAMETERS:  struct file *filp
+**               char __user *buf
+**               size_t count
+**               loff_t *ppos
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     mask
+**
+*******************************************************************************/
+ssize_t mvPonCdevRead(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+	MV_U32 len = 0;
+	S_PonEventInfo eventInfo;
+
+	if (ponEventQueueIsEmpty() == MV_FALSE) {
+		ponEventQueuePull(&eventInfo);
+
+		if (copy_to_user(buf, &eventInfo, sizeof(S_PonEventInfo)))
+			return -1;
+
+		len = sizeof(S_PonEventInfo);
+	}
+
+	return len;
+}
+
+/*******************************************************************************
+**
+**  mvEponCdevOpen
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function opens the EPON Char device
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+int mvPonCdevOpen(struct inode *inode, struct file *filp)
+{
+	S_PonModuleCdev *dev;
+
+	/* find the device structure */
+	dev = container_of(inode->i_cdev, S_PonModuleCdev, cdev);
+	dev->devOpen++;
+	filp->private_data = dev;
+
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  mvPonCdevRelease
+**  ___________________________________________________________________________
+**
+**  DESCRIPTION: The function releases the EPON Char device
+**
+**  PARAMETERS:  struct inode *inode
+**               struct file *filp
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     (0)
+**
+*******************************************************************************/
+int mvPonCdevRelease(struct inode *inode, struct file *filp)
+{
+	S_PonModuleCdev *dev = filp->private_data;
+
+	dev->devOpen--;
+
+	return 0;
+}
+
+/*******************************************************************************
+**  PON device operations
+*******************************************************************************/
+const struct file_operations ponCdevFops = {
+	.owner			= THIS_MODULE,
+	.open			= mvPonCdevOpen,
+	.release		= mvPonCdevRelease,
+	.unlocked_ioctl		= mvPonCdevIoctl,
+	.fasync			= mvPonCdevFasync,
+	.poll			= mvPonCdevPoll,
+	.read			= mvPonCdevRead,
+};
+
+/*******************************************************************************
+**
+**  onuPonMngInterfaceCreate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function create management interface - char device
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuPonMngInterfaceCreate(void)
+{
+	int rcode;
+	dev_t dev;
+
+	dev   = MKDEV(MV_PON_MAJOR, 0);
+	rcode = register_chrdev_region(dev, PON_NUM_DEVICES, PON_DEV_NAME);
+	if (rcode < 0) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Pon Char Device\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	cdev_init(&ponDev.cdev, &ponCdevFops);
+	ponDev.cdev.owner = THIS_MODULE;
+	ponDev.drvMode = E_PON_DRIVER_UNDEF_MODE;
+
+	rcode = cdev_add(&ponDev.cdev, dev, 1);
+	if (rcode < 0) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) Pon Char Device Add\n", __FILE_DESC__, __LINE__);
+
+		cdev_del(&ponDev.cdev);
+		unregister_chrdev_region(dev, PON_NUM_DEVICES);
+
+		return MV_ERROR;
+	}
+
+	/* create device for udev */
+	pon_udev_class = class_create(THIS_MODULE, PON_DEV_NAME);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	pon_udev_dev   = device_create(pon_udev_class, NULL, dev, PON_DEV_NAME);
+#else
+	pon_udev_dev   = device_create(pon_udev_class, NULL, dev, NULL, PON_DEV_NAME);
+#endif
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonMngInterfaceRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release management interface - char device
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuPonMngInterfaceRelease(void)
+{
+	dev_t dev = MKDEV(MV_PON_MAJOR, 0);
+
+	device_destroy(pon_udev_class, dev);
+	class_unregister(pon_udev_class);
+	class_destroy(pon_udev_class);
+
+	unregister_chrdev_region(dev, PON_NUM_DEVICES);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonModule_init
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Driver INIT function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     0
+**
+*******************************************************************************/
+int __init mvOnuPonModule_init(void)
+{
+	MV_STATUS status;
+
+	printk(KERN_INFO "= PON Module Init =\n");
+
+	memset(&ponDev, 0, sizeof(ponDev));
+	status = onuPonMngInterfaceCreate();
+	if (status != MV_OK) {
+		printk(KERN_ERR "= PON Module Init FAILED =\n");
+		return status;
+	}
+
+	printk(KERN_INFO "= PON Module Init ended successfully =\n");
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonModule_exit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Driver EXIT function
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     None
+**
+*******************************************************************************/
+void __exit mvOnuPonModule_exit(void)
+{
+	printk(KERN_INFO "= PON Module Exit =\n");
+
+	/* release allocated memory */
+	if (ponDev.func.memRelease != 0)
+		ponDev.func.memRelease();
+
+	/* release rtos resources */
+	if (ponDev.func.rtosResourceRelease != 0)
+		ponDev.func.rtosResourceRelease();
+
+	/* release user interface */
+	if (ponDev.func.usrInterfaceRelease != 0)
+		ponDev.func.usrInterfaceRelease();
+
+	/* release mng interface */
+	onuPonMngInterfaceRelease();
+
+	return;
+}
+
+module_init(mvOnuPonModule_init);
+module_exit(mvOnuPonModule_exit);
+
+MODULE_AUTHOR("Konstantin Porotchkin");
+MODULE_DESCRIPTION("United PON Driver for Marvell MV66xx");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.h
new file mode 100644
index 0000000..8b83bf2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/perf/ponOnuLnxKsMI.h
@@ -0,0 +1,137 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuLnxKsMI.h                                            **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU PON Management Interface            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   27 Nov 2011  Konstantin Porotchkin   created                              *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_PON_LINUX_KS_MNG_INTERFACE_H
+#define _ONU_PON_LINUX_KS_MNG_INTERFACE_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define MVPON_IOCTL_START         _IOW(MVPON_IOCTL_MAGIC, 30, unsigned int)
+#define MVPON_IOCTL_MODE_GET      _IOR(MVPON_IOCTL_MAGIC, 31, unsigned int)
+
+typedef enum {
+	E_PON_DRIVER_UNDEF_MODE = 0,
+	E_PON_DRIVER_EPON_MODE  = 1,
+	E_PON_DRIVER_GPON_MODE  = 2,
+	E_PON_DRIVER_MAX_MODE
+} E_PonDriverMode;
+
+typedef struct {
+	MV_STATUS (*ponOnuPreSetup)(void);
+	MV_STATUS (*ponOnuSetup)(void);
+	MV_STATUS (*ponOnuSwitchOn)(void);
+	MV_STATUS (*ponOnuOperate)(void);
+	MV_STATUS (*userInterfaceCreate)(void);
+	MV_STATUS (*usrInterfaceRelease)(void);
+	MV_STATUS (*rtosResourceRelease)(void);
+	void (*memRelease)(void);
+	MV_STATUS (*apiStatusNotifyRegister)(STATUSNOTIFYFUNC notifyCallBack);
+	MV_STATUS (*apiLinkStatusCallbackRegister)(void);
+	long (*cdevIoctl)(struct file *, unsigned int, unsigned long);
+} S_PonFunctions;
+
+typedef struct {
+	E_PonDriverMode drvMode;
+	int devOpen;
+	S_PonFunctions func;
+	struct cdev cdev;
+	wait_queue_head_t r_wait;
+	wait_queue_head_t w_wait;
+} S_PonModuleCdev;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern S_PonModuleCdev ponDev;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+void onuPonMiNotifyCallback(MV_U32 onuState);
+extern long mvGponCdevIoctl(struct file  *filp, unsigned int cmd, unsigned long arg);
+extern long mvEponCdevIoctl(struct file  *filp, unsigned int cmd, unsigned long arg);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuPonMngInterfaceCreate(void);
+MV_STATUS onuPonMngInterfaceRelease(void);
+void onuPonMiNotifyCallback(MV_U32 onuState);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_PON_LINUX_KS_MNG_INTERFACE_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.c
new file mode 100644
index 0000000..923cb9c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.c
@@ -0,0 +1,752 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuBoard.c                                             **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU Board specific                    **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+#include "eponOnuDb.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/plat/epon/eponOnuBoard.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+extern MV_STATUS mvEponApiSleepModeCtrl(MV_U32 enable);
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+/*******************************************************************************
+**
+**  onuEponSerdesInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set serdes
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponSerdesInit(void)
+{
+#ifdef PON_A0
+	MV_STATUS status = MV_OK;
+	MV_U32 txReady;
+	MV_U32 rxReady;
+	MV_U32 initDone;
+
+	/* Reset SERDES */
+	/* ============ */
+	/* GponPhyReset         (0x184F4 bit3 set 1);   PHY in reset                    */
+	/* GponPhyPuPll         (0x184F4 bit0 set 0);   Power UP PLL PowerDown;         */
+	/* GponPhyPuRx          (0x184F4 bit1 set 0);   Power UP Receiver PowerDown;    */
+	/* GponPhyPuTx          (0x184F4 bit2 set 0);   Power UP Transmitter PowerDown; */
+	/* GponPhyResetCore     (0x184F4 bit5 set 1);   PHY core in reset;              */
+	/* GponPhyResetTxDout   (0x184F4 bit4 set 1);   TX_OUTs in reset;               */
+	/* PonBeOEn             (0x184F4 bit24 set 1);  BEN - input                     */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_Pll, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_RX, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_TX, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_CORE, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* PON SerDes source: */
+	/* ================== */
+	/* GponPhySource        (0x184F8 bit0 set 0);   PHY in reset */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_1_PHY_SOURCE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Configuration */
+	/* ============= */
+	/* GponPhyReset         (0x184F4 bit3 set 0);   PHY in normal      */
+	/* GponPhyResetCore     (0x184F4 bit5 set 0);   PHY core in normal */
+	/*                                                                 */
+	/* GPONPhySelGEpon      (0x184F4 bit9)          0 - GPON 1 - EPON  */
+	/* EponModeSel          (0x184F4 bit30)         0 - GPON 1 - EPON  */
+	/* GPONPhyRefClk25M     (0x184F4 bit 12 set 1)  1=25 MHz           */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_CORE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_SEL_GEPON, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_EPON_MODE_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_REF_CLK_25M, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Clock */
+	/* ===== */
+	/* PonMACClockSel0x18754 bit 3 set 1);	1=PON_TX_CLK; PON_TX_CLK;PON MAC uses PON_TX_CLK from the PON SERDES. */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock disable			      */
+	/* PONSERDESClkEn       (0x18754 bit 2 set 0) */
+	/* PonRefClkEn		(0x18754 bit 4 set 0) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_REF_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock from SerDes                          */
+	/* PONSERDESClkSel      (0x18754 bit 1 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock enable                               */
+	/* PONSERDESClkEn       (0x18754 bit 2 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Internal Regs */
+	/* ============= */
+	/* Set power_reg0	(0xd0032004 set 0xfc00);recheck bits 7,2,3                                            */
+	/* Set register 0x51	(0xd0032144 set 0x104);	interface_reg2, Interface and Digital Reference Clock Control */
+	/* Set register 0x3d    (0xd00320f4 set 0x400);                                                               */
+	/* Loop timing		(0xd003208c set 0x1000;                                                               */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_POWER_REG_0, 0xFC00, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_51, 0x104, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_3D, 0x400, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_23_LOOP_TIMING, 0x1000, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Power UP */
+	/* ======== */
+	/* GponPhyPuPll         (0x184F4 bit0 set 1);	Power UP PLL PowerUp;         */
+	/* GponPhyPuRx          (0x184F4 bit1 set 1);	Power UP Receiver PowerUp;    */
+	/* GponPhyPuTx          (0x184F4 bit2 set 1);	Power UP Transmitter PowerUp; */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_Pll, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_RX, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_TX, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Check Rx / Tx Ready */
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_TX, &txReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_RX, &rxReady, 0);
+		if (status != MV_OK)
+			return status;
+
+	} while ((txReady == 0) || (rxReady == 0));
+
+	/* RX Init */
+	/* ======= */
+	/* GPONPhyRxInit        (0x184F4 bit6 set 0); */
+	/* GPONPhyRxInit        (0x184F4 bit6 set 1); */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+		if (status != MV_OK)
+			return status;
+
+	} while (initDone == 0);
+
+	/* Open TX output */
+	/* ============== */
+	/* GponPhyResetTxDout	(0x184F4 bit4 set 0);   TX_OUTs in normal; */
+	/* PonBeOEn		(0x184F4 bit24 set 0);  BEN - output       */
+	/* Set register 0x26    (0xd0032098  set 0)                        */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_26_TX_DRV_IDLE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	return status;
+#else
+	MV_STATUS status = MV_OK;
+	MV_U32 txReady;
+	MV_U32 rxReady;
+	MV_U32 initDone;
+
+	/* U-Boot Init Sequence */
+	/* ==================== */
+	/* mw 0xf10184f4 0x53000238 */
+	/* mw 0xf1018258 0x3fff6 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f8 0x0 */
+	/* mw 0xf10184f4 0x53000210 */
+	/* mw 0xf10184f4 0x53001210 */
+	/* mw 0xf1018754 0x8 */
+	/* mw 0xf1018754 0xA */
+	/* mw 0xf1018754 0xE */
+	/* mw 0xf1018258 0x3fffe */
+	/* md 0xf1032004 1 */
+	/* mw 0xf1032004 0xfc00 */
+	/* mw 0xf1032144 0x104 */
+	/* mw 0xf10320f4 0x400 */
+	/* md 0xf103208c 1 */
+	/* mw 0xf103208c 0x1000 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x53001217 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x52001247 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x52001207 */
+	/* mw 0xf1032098 0x0 */
+	/* mw 0xf10cc800 1 */
+
+	/* SERDES Config */
+	/* ============= */
+	/* GponPhyPuPll             (0x184F4 bit0 set 0);	 Power UP PLL PowerDown                      */
+	/* GponPhyPuRx				   (0x184F4 bit1 set 0);	Power UP Receiver PowerDown  */
+	/* GponPhyPuTx				   (0x184F4 bit2 set 0);	Power UP Transmitter PowerDown */
+	/* GponPhyReset            (0x184F4 bit3 set 1);	PHY in reset			    */
+	/* GponPhyResetTxDout		  (0x184F4 bit4 set 1);        TX_OUTs in reset              */
+	/* GponPhyResetCore (0x184F4 bit5 set 1);	 PHY core in reset	*/
+	/* GPONPhySelGEpon (0x184F4 bit9 set 1);	1 - EPON	 */
+	/* PonBeOEn			(0x184F4 bit24 set 1);	   BEN - input	*/
+	/* PonBenSWHWSelect		   (0x184F4 bit25 set 1);     SW Control  */
+	/* PonTodOveride	  (0x184F4 bit28 set 1);     Normal	 */
+	/* EponModeSel				    (0x184F4 bit30 set 1);     1 - EPON  */
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x53000238, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* XPON MAC SW reset assert */
+	status      = asicOntMiscRegWrite(mvAsicReg_PON_MAC_SW_RESET_CTRL, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* PON SerDes source: */
+	/* ================== */
+	/* GponPhySource	    (0x184F8 bit0 set 0);   PHY in reset */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_1_PHY_SOURCE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* SERDES Config */
+	/* ============= */
+	/* GponPhyReset            (0x184F4 bit3 set 0);	PHY out of reset	*/
+	/* GponPhyResetCore (0x184F4 bit5 set 0);	 Take PHY core out of reset	     */
+	status      = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x53000210, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* SERDES Config */
+	/* ============= */
+	/* GPONPhyRefClk25M		   (0x184F4 bit12 set 1);     25Mhz Clock		*/
+	status      = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x53001210, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock */
+	/* ===== */
+	/* PonMACClockSel(0x18754 bit 3 set 1);  1=PON_TX_CLK; PON_TX_CLK;PON MAC uses PON_TX_CLK from the PON SERDES.*/
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock disable				  */
+	/* PONSERDESClkEn	    (0x18754 bit 2 set 0) */
+	/* PonRefClkEn	    (0x18754 bit 4 set 0) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_REF_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock from SerDes			  */
+	/* PONSERDESClkSel	    (0x18754 bit 1 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock enable				  */
+	/* PONSERDESClkEn	    (0x18754 bit 2 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* XPON MAC SW reset de-assert */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_SW_RESET_CTRL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Internal Regs */
+	/* ============= */
+	/* Set power_reg0	    (0xd0032004 set 0xfc00);recheck bits 7,2,3 */
+	/* Set register 0x51    (0xd0032144 set 0x104); interface_reg2, Interface and Digital Reference Clock Control */
+	/* Set register 0x3d    (0xd00320f4 set 0x400);								  */
+	/* Loop timing	    (0xd003208c set 0x1000;								  */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_POWER_REG_0, 0xFC00, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_51, 0x104, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_3D, 0x400, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_23_LOOP_TIMING, 0x1000, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Power UP */
+	/* ======== */
+	/* GponPhyPuPll	    (0x184F4 bit0 set 1);   Power UP PLL PowerUp;	  */
+	/* GponPhyPuRx	    (0x184F4 bit1 set 1);   Power UP Receiver PowerUp;	  */
+	/* GponPhyPuTx	    (0x184F4 bit2 set 1);   Power UP Transmitter PowerUp; */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x53001217, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Check Rx / Tx Ready */
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_TX, &txReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_RX, &rxReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		mvOsDelay(20);
+
+	} while ((txReady == 0) || (rxReady == 0));
+
+	/* RX Init */
+	/* ======= */
+	/* GPONPhyRxInit	    (0x184F4 bit6 set 0); */
+	/* GPONPhyRxInit	    (0x184F4 bit6 set 1); */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+		if (status != MV_OK)
+			return status;
+
+		mvOsDelay(20);
+
+	} while (initDone == 0);
+
+	/* Open TX output */
+	/* ============== */
+	/* GponPhyResetTxDout   (0x184F4 bit4 set 0);   TX_OUTs in normal; */
+	/* PonBeOEn         (0x184F4 bit24 set 0);  BEN - output       */
+	/* Set register 0x26    (0xd0032098  set 0)                    */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x52001207, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_26_TX_DRV_IDLE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	return status;
+
+#endif
+}
+
+#endif
+#endif /* PON_FPGA */
+
+/*******************************************************************************
+**
+**  onuEponTxControlTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is the timer callback when timer for
+**               shutting the Tx is expired
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     void
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponTxControlTimerHndl(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponTxControlTimerId));
+
+	/* Turn off the tx power */
+	onuPonTxPowerOn(MV_FALSE);
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponMaxSleepTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is the timer callback when timer for
+**               keeping power saving mode is expired
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     void
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponMaxSleepTimerHndl(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId));
+
+	if (onuPonResourceTbl_s.onuEponSleepDurationTimerId.onuPonTimerActive == ONU_PON_TIMER_ACTIVE)
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId));
+
+	/* Leave power saving mode */
+	onuEponDbOnuSleepWakeupStatusSet(E_EPON_NOT_POWER_SAVING_STATUS);
+
+	/* Enable TX/RX */
+	mvEponApiSleepModeCtrl(MV_FALSE);
+
+	/* Send SleepStatusUpdate alarm to OLT */
+	/* todo */
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuEponSleepWakeDurationTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is the timer callback when periodical timer for
+**               switching between sleep status and wakeup status is expired
+**
+**  PARAMETERS:  void
+**
+**  OUTPUTS:     void
+**
+**  RETURNS:     void
+**
+*******************************************************************************/
+void onuEponSleepWakeDurationTimerHndl(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	if (onuEponDbOnuSleepWakeupStatusGet() == E_EPON_POWER_SAVING_SLEEP_STATUS) {
+		/* Change the status to wakeup */
+		onuEponDbOnuSleepWakeupStatusSet(E_EPON_POWER_SAVING_WAKEUP_STATUS);
+
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId),
+				  0,
+				  onuEponDbOnuWakeupDurationGet(),
+				  1);
+
+		/* Enable TX/RX */
+		mvEponApiSleepModeCtrl(MV_FALSE);
+	} else if (onuEponDbOnuSleepWakeupStatusGet() == E_EPON_POWER_SAVING_WAKEUP_STATUS) {
+		/* Change the status to sleep */
+		onuEponDbOnuSleepWakeupStatusSet(E_EPON_POWER_SAVING_SLEEP_STATUS);
+
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId),
+				  0,
+				  onuEponDbOnuSleepDurationGet(),
+				  1);
+
+		/* Disable TX/RX */
+		mvEponApiSleepModeCtrl(MV_TRUE);
+	}
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+typedef struct {
+	E_asicGlobalRegs registerId;
+	MV_U32 value;
+	char             *registerName;
+} RegisterSetting_S;
+
+typedef struct {
+	char *groupName;
+	int groupSize;
+	RegisterSetting_S *pRegisterSettingAra;
+} RegGroupSettings_S;
+
+/***********************************************************
+* MPP GROUP
+*
+* WAN control
+* -----------
+* MPP65 config:  GPIO 0x18020 bits 4-7 <-0
+* As output: 0x18184 bit1 <-0
+*         PON mode - 1 at bit 1 of 0x18180
+*         SFP mode - 0 at bit 1 of 0x18180
+*/
+
+static RegisterSetting_S mppEponRegisterSettingAra[] =
+{
+	/* PON WAN */
+	{mvAsicReg_PON_MPP_65,                  0, "mvAsicReg_PON_MPP_65"},
+	{mvAsicReg_PON_XVR_TX_DATA_OUT_65,      0, "mvAsicReg_PON_XVR_TX_DATA_OUT_65"},
+	{mvAsicReg_PON_XVR_TX_OUTPUT_ENABLE_65, 1, "mvAsicReg_PON_XVR_TX_OUTPUT_ENABLE_65"}, /* Value will be WAN_PON */
+};
+
+static RegGroupSettings_S mppEponRegGroupSettings =
+{
+	"EPON MPP settings", sizeof(mppEponRegisterSettingAra) / sizeof(mppEponRegisterSettingAra[0]),
+		mppEponRegisterSettingAra
+};
+
+/*******************************************************************************
+**
+**  programRegGroup
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function initializes MPP for SFP
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+static MV_STATUS programRegGroup(RegGroupSettings_S *pRegGroupSettings)
+{
+	MV_STATUS status = MV_OK;
+	int indx;
+	RegisterSetting_S *pRegisterSetting;
+	MV_U32 regAddr;
+
+	for (indx = 0; indx < pRegGroupSettings->groupSize; indx++) {
+		pRegisterSetting = &pRegGroupSettings->pRegisterSettingAra[indx];
+
+		if (asicOntMiscRegAddressGet(pRegisterSetting->registerId, 0, &regAddr) == MV_OK)
+			printk(KERN_ERR "[%d] %s, reg. %s (%d) at 0x%x, value = 0x%x",
+			       indx, pRegGroupSettings->groupName, pRegisterSetting->registerName,
+			       pRegisterSetting->registerId, regAddr, pRegisterSetting->value);
+
+		status  = asicOntMiscRegWrite(pRegisterSetting->registerId, pRegisterSetting->value, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+				   "ERROR: (%s:%d) asicOntMiscRegWrite failed for %s, reg. %s (%d), value = %u\n",
+				   __FILE_DESC__, __LINE__,
+				   pRegGroupSettings->groupName, pRegisterSetting->registerName,
+				   pRegisterSetting->registerId, pRegisterSetting->value);
+			return status;
+		}
+		mvOsDelay(20);
+	}
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuEponMppInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function initializes MPP for EPON
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponMppInit(void)
+{
+	return programRegGroup(&mppEponRegGroupSettings);
+}
+
+#endif
+#endif /* PON_FPGA */
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.h
new file mode 100644
index 0000000..6aa59c9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuBoard.h
@@ -0,0 +1,109 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuBoard.h                                             **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON board specific definitions     **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_EPON_BOARD_H
+#define _ONU_EPON_BOARD_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+void onuEponTxControlTimerHndl(void);
+void onuEponMaxSleepTimerHndl(void);
+void onuEponSleepWakeDurationTimerHndl(void);
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+MV_STATUS onuEponSerdesInit(void);
+MV_STATUS onuEponMppInit(void);
+#endif
+#endif /* PON_FPGA */
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_BOARD_H */
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.c
new file mode 100644
index 0000000..4435951
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.c
@@ -0,0 +1,513 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsOs.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Linux OS handling            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+#include "eponOnuHeader.h"
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+#include "mvSysPonConfig.h"
+#endif
+#endif /* PON_FPGA */
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/plat/epon/eponOnuLnxKsOs.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* ========================================================================== */
+/* ===========================  ISR SECTION  ================================ */
+/* ========================================================================== */
+MV_U32 eponCurrentInterruptEvent  = 0;
+MV_U32 eponCurrentInterruptStatus = 0;
+
+/*******************************************************************************
+**
+**  onuEponRtosResourceInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function allocates onu RTOS resources
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponRtosResourceInit(void)
+{
+	MV_STATUS retcode;
+	MV_U32 idx;
+
+	/* Timer */
+	/* ===== */
+
+	/* onu epon pm timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonPmTimerId),     /* timer Id */
+				    "epon_Pm",                                  /* timer description */
+				    (PTIMER_FUNCPTR)onuEponPmTimerPmHndl,       /* timer function */
+				    0,                                          /* timer function param */
+				    ONU_PON_TIMER_PM_INTERVAL,                  /* init value */
+				    1);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon PM timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon Pattern Burst timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId),   /* timer Id */
+				    "epon_PatternBurst",                                /* timer description */
+				    (PTIMER_FUNCPTR)onuPonPatternBurstTimerHndl,        /* timer function */
+				    0,                                                  /* timer function param */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon Pattern Burst timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon mpcp timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonMpcpTimerId),   /* timer Id */
+				    "epon_mpc",                                 /* timer description */
+				    (PTIMER_FUNCPTR)onuEponIsrTimerMpcpHndl,    /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer function param */
+				    ONU_PON_TIMER_MPCP_INTERVAL,                /* init value */
+				    1);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon mpcp timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon Isr miss timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonIsrMissTimerId),        /* timer Id */
+				    "epon_tx",                                          /* timer description */
+				    (PTIMER_FUNCPTR)onuEponIsrTimerEventMissHndl,       /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* timer function param */
+				    ONU_PON_TIMER_EVENT_MISS_INTERVAL,                  /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon event miss timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon OAM Tx timer - for HW DBA mode */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonIsrOamTxHwDbaTimerId), /* timer Id */
+				    "epon_Om",                                  /* timer description */
+				    (PTIMER_FUNCPTR)onuEponIsrOamTxHwDbaHndl,   /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer function param */
+				    ONU_PON_TIMER_HW_DBA_OAM_TX_INTERVAL,       /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon event hw dba oam transmit timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon xvr reset timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId),      /* timer Id */
+				    "epon_xvr",                                         /* timer description */
+				    (PTIMER_FUNCPTR)onuEponIsrXvrResetTimerHndl,        /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* timer active (run) state */
+				    ONU_PON_TIMER_XVR_RST_INTERVAL,                     /* init value */
+				    1);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon Cvr Reset timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon holdover timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonHoldoverTimerId),       /* timer Id */
+				    "epon_hold",                                        /* timer description */
+				    (PTIMER_FUNCPTR)onuEponIsrTimerHoldoverHndl,        /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* timer function param */
+				    ONU_PON_TIMER_HOLDOVER_INTERVAL,                    /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon holdover timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+	/* ONU EPON tx_power supply control timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuEponTxControlTimerId),     /* timer Id */
+				    "epon_TxControlTimer",                              /* timer description */
+				    (PTIMER_FUNCPTR)onuEponTxControlTimerHndl,          /* timer function */
+				    0,                                                  /* timer function param */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) EPON Tx power control timer create\n\r",
+			   __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* ONU EPON sleep mode: max sleep timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuEponMaxSleepTimerId),      /* timer Id */
+				    "epon_MaxSleepTimer",                               /* timer description */
+				    (PTIMER_FUNCPTR)onuEponMaxSleepTimerHndl,           /* timer function */
+				    0,                                                  /* timer function param */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) EPON power saving mode: max sleep timer create\n\r",
+			   __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* ONU EPON sleep mode: sleep duration and wait duration timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuEponSleepDurationTimerId), /* timer Id */
+				    "epon_SleepWakeDurationTimer",                      /* timer description */
+				    (PTIMER_FUNCPTR)onuEponSleepWakeDurationTimerHndl,  /* timer function */
+				    0,                                                  /* timer function param */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) EPON power saving mode: sleep and wait duration timer create\n\r",
+			   __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu epon silence timer */
+	for (idx = 0; idx < EPON_MAX_MAC_NUM; idx++) {
+		retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonSilenceTimerId[idx]), /* timer Id */
+					    "epon_Sile",                                   /* timer description */
+					    (PTIMER_FUNCPTR)onuEponPonMngTimerSilenceHndl, /* timer function */
+					    ONU_PON_TIMER_NOT_ACTIVE,                     /* timer function param */
+					    ONU_PON_TIMER_SILENCE_INTERVAL,               /* init value */
+					    0);                                          /* periodic value */
+		if (retcode != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+				   "ERROR: (%s:%d) pon holdover timer create\n\r", __FILE_DESC__, __LINE__);
+			return MV_ERROR;
+		}
+	}
+
+	/* onu pon TX Power timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonTxPwrTimerId),  /* timer Id */
+				    "pon_txPwr",                                /* timer description */
+				    (PTIMER_FUNCPTR)onuEponTimerTxPwrHndl,      /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_TX_PWR_INTERVAL,              /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon Tx Power timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Interrupt */
+	/* ========= */
+	retcode = onuPonIrqInit();
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) epon interrupt init\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	retcode = onuEponIrqTaskletInit(&(onuPonResourceTbl_s.onuPonIrqId));
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) epon interrupt tasklet\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	retcode = onuEponIrqRegister(&(onuPonResourceTbl_s.onuPonIrqId));
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) epon interrupt register\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponRtosResourceRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release onu RTOS resources
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuEponRtosResourceRelease(void)
+{
+	del_timer(&(onuPonResourceTbl_s.onuPonMpcpTimerId.onuPonTimerId));
+	del_timer(&(onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerId));
+
+	free_irq(onuPonResourceTbl_s.onuPonIrqId.onuPonIrqNum, &(onuPonResourceTbl_s.onuPonIrqId));
+	printk(KERN_INFO "onuPonResourceTbl_s.onuPonIrqId.onuDgIrqNum, &(onuPonResourceTbl_s.onuPonIrqId\n\r");
+	free_irq(onuPonResourceTbl_s.onuPonIrqId.onuDgIrqNum, &(onuPonResourceTbl_s.onuPonIrqId));
+
+	tasklet_kill(&(onuPonResourceTbl_s.onuPonIrqId.onuPonTasklet));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponIrqTaskletInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: EPON Interrupt tasklet init
+**
+**  PARAMETERS:  S_onuPonIrq irqId
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponIrqTaskletInit(S_onuPonIrq *irqId)
+{
+	tasklet_init(&(irqId->onuPonTasklet), onuEponTaskletFunc, (unsigned int)0);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponIrqRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: EPON Interrupt register
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     EPON Interrupt number
+**
+*******************************************************************************/
+MV_STATUS onuEponIrqRegister(S_onuPonIrq *irqId)
+{
+	int rcode;
+
+	rcode = request_irq(irqId->onuPonIrqNum, onuEponIrqRoutine, IRQF_DISABLED, "mvEpon", (void *)irqId);
+	if (rcode) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) epon interrupt register\n", __FILE_DESC__, __LINE__);
+		free_irq(irqId->onuPonIrqNum, NULL);
+		return MV_ERROR;
+	}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	rcode = request_irq(irqId->onuDgIrqNum, onuEponDgIrqRoutine, IRQF_DISABLED, "mvDyGasp", (void *)irqId);
+	if (rcode) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) EPON Dying Gasp interrupt register\n", __FILE_DESC__, __LINE__);
+		free_irq(irqId->onuDgIrqNum, NULL);
+		return MV_ERROR;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuEponIrqRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: EPON Interrupt routinr
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IRQ_HANDLED
+**
+*******************************************************************************/
+irqreturn_t onuEponIrqRoutine(int irq, void *arg)
+{
+#ifdef MV_EPON_HW_INTERRUPT
+	onuEponIsrRoutine(0, 0);
+#else   /* SW_INTERRUPT - TASKLET */
+	MV_U32 interruptEvent;
+	MV_U32 interruptStatus;
+
+	S_onuPonIrq *irqId = (S_onuPonIrq *)arg;
+	onuEponIsrLowRoutine(&interruptEvent, &interruptStatus);
+	eponCurrentInterruptEvent  = interruptEvent;
+	eponCurrentInterruptStatus = interruptStatus;
+	tasklet_hi_schedule(&(irqId->onuPonTasklet));
+#endif
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+**
+**  onuEponDgIrqRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Dying Gasp Interrupt routinr
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IRQ_HANDLED
+**
+*******************************************************************************/
+irqreturn_t onuEponDgIrqRoutine(int irq, void *arg)
+{
+	mvOnuPonMacDgInterruptDis();
+	onuPonDyingGaspProcess();
+	onuEponDgIsrRoutine();
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+**
+**  onuEponTaskletFunc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: EPON Interrupt tasklet function
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     GPON Interrupt number
+**
+*******************************************************************************/
+void onuEponTaskletFunc(unsigned long dummy)
+{
+	MV_U32 interruptEvent  = eponCurrentInterruptEvent;
+	MV_U32 interruptStatus = eponCurrentInterruptStatus;
+
+	onuPonIrqDisable(&(onuPonResourceTbl_s.onuPonIrqId)); /* disable EPON interrupt */
+
+	onuEponIsrRoutine(interruptEvent, interruptStatus);
+
+	onuPonIrqEnable(&(onuPonResourceTbl_s.onuPonIrqId)); /* enable EPON interrupt */
+}
+
+/*******************************************************************************
+**
+**  onuEponGlbAddrInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Allocate a memory space for EPON MAC register space
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IAMBA_OK
+**
+*******************************************************************************/
+MV_STATUS onuEponGlbAddrInit(void)
+{
+#ifdef PON_A0
+#ifdef PON_FPGA
+	/* set base address in the pon onu register table */
+	ponOnuGlbAddrSet((MV_U32)(0x58000)); /* MV_EPON_MAC_REGS_BASE */
+#else
+	/* set base address in the pon onu register table */
+	ponOnuGlbAddrSet((MV_U32)(0x58000)); /* MV_EPON_MAC_REGS_BASE */
+#endif
+#else
+	ponOnuGlbAddrSet((MV_U32)(0xCC000)); /* MV_EPON_MAC_REGS_BASE */
+#endif
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.h
new file mode 100644
index 0000000..bf5f1a0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/epon/eponOnuLnxKsOs.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : eponOnuLnxKsOs.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Linux OS resources             **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_EPON_LINUX_KS_OS_H
+#define _ONU_EPON_LINUX_KS_OS_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+void        onuEponTaskletFunc(unsigned long dummy);
+irqreturn_t onuEponIrqRoutine(int irq, void *arg);
+irqreturn_t onuEponDgIrqRoutine(int irq, void *arg);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* Init API */
+extern MV_STATUS onuEponGlbAddrInit(void);
+extern MV_STATUS onuEponRtosResourceInit(void);
+extern MV_STATUS onuEponRtosResourceRelease(void);
+
+/* Interrupt API */
+extern MV_STATUS onuEponIrqRegister(S_onuPonIrq *irqId);
+extern MV_STATUS onuEponIrqTaskletInit(S_onuPonIrq *irqId);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_EPON_LINUX_KS_OS_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.c
new file mode 100644
index 0000000..851a95f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.c
@@ -0,0 +1,643 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuBoard.c                                             **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU Board specific                    **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/plat/gpon/gponOnuBoard.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuGponDisableSnSetHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function saves disable SN state to non-volatile memory
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponDisableSnSetHandler(MV_BOOL state)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponDisableSnGetHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function extract disable SN state from non-volatile memory
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponDisableSnGetHandler(MV_BOOL *state)
+{
+	*state = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponPasswordHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function extract password from external source
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponPasswordHandler(MV_U8 *password)
+{
+	MV_U8 defaultPassword[10] = ONU_GPON_PASSWORD_DEFAULT;
+
+	memcpy(password, defaultPassword, 10);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponSerialNumberHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function extract serial number from external source
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponSerialNumberHandler(MV_U8 *serialNumber)
+{
+	MV_U8 defaultSerialNumber[8] = ONU_GPON_SN_DEFAULT;
+
+	memcpy(serialNumber, defaultSerialNumber, 8);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponAdminStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function configure PON Admin state
+**
+**  PARAMETERS:  mode 0-Enable, 1 Disable
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuGponAdminStateSet(MV_U32 mode)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_ADMIN_FOR_AVANTA_LP
+	MV_STATUS status;
+
+	status = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, mode, 0);
+	if (status != MV_OK)
+		return status;
+#endif
+#endif  /* PON_FPGA */
+	return MV_OK;
+}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+/*******************************************************************************
+**
+**  onuGponSerdesInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function set serdes
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponSerdesInit(void)
+{
+#ifdef PON_A0
+	MV_STATUS status = MV_OK;
+	MV_U32 txReady;
+	MV_U32 rxReady;
+	MV_U32 initDone;
+
+	/* Reset SERDES */
+	/* ============ */
+	/* GponPhyReset         (0x184F4 bit3 set 1);   PHY in reset                    */
+	/* GponPhyPuPll         (0x184F4 bit0 set 0);   Power UP PLL PowerDown;         */
+	/* GponPhyPuRx          (0x184F4 bit1 set 0);   Power UP Receiver PowerDown;    */
+	/* GponPhyPuTx          (0x184F4 bit2 set 0);   Power UP Transmitter PowerDown; */
+	/* GponPhyResetCore     (0x184F4 bit5 set 1);   PHY core in reset;              */
+	/* GponPhyResetTxDout   (0x184F4 bit4 set 1);   TX_OUTs in reset;               */
+	/* PonBeOEn             (0x184F4 bit24 set 1);  BEN - input                     */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_Pll, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_RX, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_TX, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_CORE, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* PON SerDes source */
+	/* ================= */
+	/* GponPhySource        (0x184F8 bit0 set 0);   PHY in reset */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_1_PHY_SOURCE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Configuration */
+	/* ============= */
+	/* GponPhyReset         (0x184F4 bit3 set 0);   PHY in normal      */
+	/* GponPhyResetCore     (0x184F4 bit5 set 0);   PHY core in normal */
+	/*                                                                 */
+	/* GPONPhySelGEpon      (0x184F4 bit9)          0 - GPON 1 - EPON  */
+	/* EponModeSel          (0x184F4 bit30)         0 - GPON 1 - EPON  */
+	/* GPONPhyRefClk25M     (0x184F4 bit 12 set 1)  1=25 MHz	   */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_CORE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_SEL_GEPON, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_EPON_MODE_SEL, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_REF_CLK_25M, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Clock */
+	/* ===== */
+	/* PonMACClockSel 0x18754 bit 3 set 1);	1=PON_TX_CLK; PON_TX_CLK;PON MAC uses PON_TX_CLK from the PON SERDES */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock disable			      */
+	/* PONSERDESClkEn       (0x18754 bit 2 set 0) */
+	/* PonRefClkEn		(0x18754 bit 4 set 0) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_REF_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock from SerDes                          */
+	/* PONSERDESClkSel      (0x18754 bit 1 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	/* Clock enable                               */
+	/* PONSERDESClkEn       (0x18754 bit 2 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Internal Regs */
+	/* ============= */
+	/* Set power_reg0	(0xd0032004 set 0xfc00);recheck bits 7,2,3                                            */
+	/* Set register 0x51	(0xd0032144 set 0x104);	interface_reg2, Interface and Digital Reference Clock Control */
+	/* Set register 0x3d    (0xd00320f4 set 0x400);                                                               */
+	/* Loop timing		(0xd003208c set 0x1000;                                                               */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_POWER_REG_0, 0xFC00, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_51, 0x104, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_3D, 0x400, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_23_LOOP_TIMING, 0x1000, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Power UP */
+	/* ======== */
+	/* GponPhyPuPll         (0x184F4 bit0 set 1);	Power UP PLL PowerUp;         */
+	/* GponPhyPuRx          (0x184F4 bit1 set 1);	Power UP Receiver PowerUp;    */
+	/* GponPhyPuTx          (0x184F4 bit2 set 1);	Power UP Transmitter PowerUp; */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_Pll, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_RX, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_PU_TX, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Check Rx / Tx Ready */
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_TX, &txReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_RX, &rxReady, 0);
+		if (status != MV_OK)
+			return status;
+
+	} while ((txReady == 0) || (rxReady == 0));
+
+	/* RX Init */
+	/* ======= */
+	/* GPONPhyRxInit        (0x184F4 bit6 set 0); */
+	/* GPONPhyRxInit        (0x184F4 bit6 set 1); */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+		if (status != MV_OK)
+			return status;
+
+	} while (initDone == 0);
+
+	/* Open TX output */
+	/* ============== */
+	/* GponPhyResetTxDout	(0x184F4 bit4 set 0);   TX_OUTs in normal; */
+	/* PonBeOEn		(0x184F4 bit24 set 0);  BEN - output       */
+	/* Set register 0x26    (0xd0032098  set 0)                        */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RST_TX_DOUT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_26_TX_DRV_IDLE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	return status;
+#else
+	/* U-Boot Init Sequence */
+	/* ==================== */
+	/* mw 0xf10184f4 0x13000038 */
+	/* mw 0xf1018258 0x3fff6 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f8 0x0 */
+	/* mw 0xf10184f4 0x13000010 */
+	/* mw 0xf10184f4 0x13001010 */
+	/* mw 0xf1018754 0x8 */
+	/* mw 0xf1018754 0xA */
+	/* mw 0xf1018754 0xE */
+	/* mw 0xf1018258 0x3fffe */
+	/* md 0xf1032004 1 */
+	/* mw 0xf1032004 0xfc00 */
+	/* mw 0xf1032144 0x104 */
+	/* mw 0xf10320f4 0x400 */
+	/* md 0xf103208c 1 */
+	/* mw 0xf103208c 0x1000 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x13001017 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x12001047 */
+	/* md 0xf10184fc 1 */
+	/* mw 0xf10184f4 0x12001007 */
+	/* mw 0xf1032098 0x0 */
+	/* mw 0xf10cc800 1 */
+
+	/* SERDES Config */
+	/* ============= */
+	/* GponPhyPuPll		(0x184F4 bit0 set 0);	     Power UP PLL PowerDown			    */
+	/* GponPhyPuRx			       (0x184F4 bit1 set 0);	    Power UP Receiver PowerDown        */
+	/* GponPhyPuTx				   (0x184F4 bit2 set 0);	Power UP Transmitter PowerDown	*/
+	/* GponPhyReset            (0x184F4 bit3 set 1);	PHY in reset			    */
+	/* GponPhyResetTxDout		  (0x184F4 bit4 set 1);        TX_OUTs in reset              */
+	/* GponPhyResetCore (0x184F4 bit5 set 1);	 PHY core in reset				*/
+	/* GPONPhySelGEpon (0x184F4 bit9 set 1);	0 - GPON					     */
+	/* PonBeOEn			(0x184F4 bit24 set 1);	   BEN - input		 */
+	/* PonBenSWHWSelect		   (0x184F4 bit25 set 1);     SW Control	*/
+	/* PonTodOveride	  (0x184F4 bit28 set 1);     Normal		 */
+	/* EponModeSel				    (0x184F4 bit30 set 1);     0 - GPON    */
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x13000038, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* XPON MAC SW reset assert */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_SW_RESET_CTRL, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* PON SerDes source */
+	/* ================= */
+	/* GponPhySource	    (0x184F8 bit0 set 0);   PHY in reset */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_1_PHY_SOURCE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* SERDES Config */
+	/* ============= */
+	/* GponPhyReset	       (0x184F4 bit3 set 0);	    PHY out of reset */
+	/* GponPhyResetCore (0x184F4 bit5 set 0);	     Take PHY core out of reset
+	 */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x13000010, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* SERDES Config */
+	/* ============= */
+	/* GPONPhyRefClk25M		   (0x184F4 bit12 set 1);     25Mhz Clock
+	 */
+	status      = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x13001010, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock */
+	/* ===== */
+	/* PonMACClockSel(0x18754 bit 3 set 1);  1=PON_TX_CLK; PON_TX_CLK;PON MAC uses PON_TX_CLK from the PON SERDES */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock disable				  */
+	/* PONSERDESClkEn	    (0x18754 bit 2 set 0) */
+	/* PonRefClkEn	    (0x18754 bit 4 set 0) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_REF_CLK_EN, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock from SerDes			  */
+	/* PONSERDESClkSel	    (0x18754 bit 1 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_SEL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Clock enable				  */
+	/* PONSERDESClkEn	    (0x18754 bit 2 set 1) */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_CLK_EN, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* XPON MAC SW reset de-assert */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_MAC_SW_RESET_CTRL, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Internal Regs */
+	/* ============= */
+	/* Set power_reg0	    (0xd0032004 set 0xfc00);recheck bits 7,2,3 */
+	/* Set register	    (0xd0032178 set 0xd543);		       */
+	/* Set register	    (0xd0032148 set 0xf008);		       */
+	/* Loop timing	    (0xd003208c set 0x1400;		       */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_POWER_REG_0, 0xFC00, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_OFFSET_178, 0xd543, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_OFFSET_148, 0xf008, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_23_LOOP_TIMING, 0x1400, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Power UP */
+	/* ======== */
+	/* GponPhyPuPll	    (0x184F4 bit0 set 1);   Power UP PLL PowerUp;	  */
+	/* GponPhyPuRx	    (0x184F4 bit1 set 1);   Power UP Receiver PowerUp;	  */
+	/* GponPhyPuTx	    (0x184F4 bit2 set 1);   Power UP Transmitter PowerUp; */
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x13001017, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	/* Check Rx / Tx Ready */
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_TX, &txReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_READY_RX, &rxReady, 0);
+		if (status != MV_OK)
+			return status;
+
+		mvOsDelay(20);
+
+	} while ((txReady == 0) || (rxReady == 0));
+
+	/* RX Init */
+	/* ======= */
+	/* GPONPhyRxInit	    (0x184F4 bit6 set 0); */
+	/* GPONPhyRxInit	    (0x184F4 bit6 set 1); */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_RX_INIT, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	do {
+		status  = asicOntMiscRegRead(mvAsicReg_PON_SERDES_PHY_STATUS_INIT_DONE, &initDone, 0);
+		if (status != MV_OK)
+			return status;
+
+		mvOsDelay(20);
+
+	} while (initDone == 0);
+
+	/* Open TX output */
+	/* ============== */
+	/* GponPhyResetTxDout   (0x184F4 bit4 set 0);   TX_OUTs in normal; */
+	/* PonBeOEn         (0x184F4 bit24 set 0);  BEN - output       */
+	/* Set register 0x26    (0xd0032098  set 0)                    */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0, 0x12001007, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_REG_26_TX_DRV_IDLE, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	mvOsDelay(20);
+
+	return status;
+
+#endif
+}
+
+#endif
+#endif /* PON_FPGA */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.h
new file mode 100644
index 0000000..b7dbbf2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuBoard.h
@@ -0,0 +1,111 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuBoard.h                                             **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON board specific definitions     **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_BOARD_H
+#define _ONU_GPON_BOARD_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuGponDisableSnSetHandler(MV_BOOL state);
+MV_STATUS onuGponDisableSnGetHandler(MV_BOOL *state);
+MV_STATUS onuGponPasswordHandler(MV_U8 *password);
+MV_STATUS onuGponSerialNumberHandler(MV_U8 *serialNumber);
+MV_STATUS onuGponAdminStateSet(MV_U32 mode);
+#ifndef PON_FPGA
+#ifdef DISABLE_SERDES_FOR_AVANTA_LP
+MV_STATUS onuGponSerdesInit(void);
+MV_STATUS onuGponMppInit(void);
+#endif
+#endif /* PON_FPGA */
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_BOARD_H */
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.c
new file mode 100644
index 0000000..d89a7d6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.c
@@ -0,0 +1,526 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsOs.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Linux OS handling            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+#include "gponOnuHeader.h"
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+#include "mvSysPonConfig.h"
+#endif
+#endif /* PON_FPGA */
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/plat/gpon/gponOnuLnxKsOs.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_onuPonWork gponTcontCleanWork[8];
+S_onuPonWork gponTcontCleanAllWork;
+S_onuPonWork gponTcontActiveWork[8];
+S_onuPonWorkQueue gponTcontFlushWq;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* ========================================================================== */
+/* ===========================  ISR SECTION  ================================ */
+/* ========================================================================== */
+MV_U32 gponCurrentInterruptEvent  = 0;
+MV_U32 gponCurrentInterruptStatus = 0;
+
+/*******************************************************************************
+**
+**  onuPonWqInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function allocates GPON work queue and init two work
+**               structures for TCONT clean and activate
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonWqInit(void)
+{
+	MV_U32 tcontIndex;
+
+	gponTcontFlushWq.ponWq = create_workqueue("gponTcontFlushWQ");
+	if (gponTcontFlushWq.ponWq) {
+		for (tcontIndex = 0; tcontIndex < 8; tcontIndex++) {
+			INIT_WORK((struct work_struct *)&gponTcontCleanWork[tcontIndex], onuGponWqTcontFunc);
+			gponTcontCleanWork[tcontIndex].action = TCONT_CLEAN_EVENT;
+			gponTcontCleanWork[tcontIndex].param  = tcontIndex;
+
+			INIT_WORK((struct work_struct *)&gponTcontActiveWork[tcontIndex], onuGponWqTcontFunc);
+			gponTcontActiveWork[tcontIndex].action = TCONT_ACTIVE_EVENT;
+			gponTcontActiveWork[tcontIndex].param  = tcontIndex;
+		}
+
+		INIT_WORK((struct work_struct *)&gponTcontCleanAllWork, onuGponWqTcontFunc);
+		gponTcontCleanAllWork.action = TCONT_CLEAN_ALL_EVENT;
+
+		return MV_OK;
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  onuGponRtosResourceInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function allocates onu RTOS resources
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponRtosResourceInit(void)
+{
+	MV_STATUS retcode;
+
+	/* Timer */
+	/* ===== */
+
+	/* onu gpon T01 timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuGponT01_TimerId),  /* timer Id */
+				    "gpon_T01",                                 /* timer description */
+				    (PTIMER_FUNCPTR)onuGponPonMngTimerT01Hndl,  /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_T01_INTERVAL,                 /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon T01 timer create\n", __FILE_DESC__, __LINE__);
+		return retcode;
+	}
+
+	/* onu gpon T02 timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuGponT02_TimerId),  /* timer Id */
+				    "gpon_T02",                                 /* timer description */
+				    (PTIMER_FUNCPTR)onuGponPonMngTimerT02Hndl,  /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_T02_INTERVAL,                 /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon T02 timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu gpon PEE timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuGponPeeTimerId),   /* timer Id */
+				    "gpon_Pee",                                 /* timer description */
+				    (PTIMER_FUNCPTR)onuGponPonMngTimerPeeHndl,  /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_PEE_INTERVAL,                 /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon Pee timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu gpon xvr reset timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId),      /* timer Id */
+				    "gpon_xvr",                                         /* timer description */
+				    (PTIMER_FUNCPTR)onuGponIsrXvrResetTimerHndl,        /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* timer active (run) state */
+				    ONU_PON_TIMER_XVR_RST_INTERVAL,                     /* init value */
+				    1);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon Cvr Reset timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu gpon pm timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonPmTimerId),     /* timer Id */
+				    "gpon_Pm",                                  /* timer description */
+				    (PTIMER_FUNCPTR)onuGponPmTimerPmHndl,       /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_PM_INTERVAL,                  /* init value */
+				    1);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon PM timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu gpon Pattern Burst timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId),   /* timer Id */
+				    "gpon_PatternBurst",                                /* timer description */
+				    (PTIMER_FUNCPTR)onuPonPatternBurstTimerHndl,        /* timer function */
+				    0,                                                  /* timer function param */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_API_MODULE,
+			   "ERROR: (%s:%d) pon Pattern Burst timer create\n\r", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu gpon sw fifo timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonSwFIFOTimerId), /* timer Id */
+				    "gpon_Fifo",                                /* timer description */
+				    (PTIMER_FUNCPTR)onuGponTimerFifoAuditHndl,  /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_FIFO_AUDIT_INTERVAL,          /* init value */
+				    1);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon FIFO Audit timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu pon TX Power timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuPonTxPwrTimerId),  /* timer Id */
+				    "pon_txPwr",                                /* timer description */
+				    (PTIMER_FUNCPTR)onuGponTimerTxPwrHndl,      /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                   /* timer active (run) state */
+				    ONU_PON_TIMER_TX_PWR_INTERVAL,              /* init value */
+				    0);                                         /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon Tx Power timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* onu pon POPUP WA timer */
+	retcode = onuPonTimerCreate(&(onuPonResourceTbl_s.onuGponPopupWaTimerId), /* timer Id */
+				    "pon_popup",                                        /* timer description */
+				    (PTIMER_FUNCPTR)onuGponPonMngTimerPopupWaHndl,      /* timer function */
+				    ONU_PON_TIMER_NOT_ACTIVE,                           /* timer active (run) state */
+				    ONU_PON_TIMER_POPUP_WA_INTERVAL,                    /* init value */
+				    0);                                                 /* periodic value */
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon POPUP WA timer create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Work Queue */
+	/* ========== */
+	retcode = onuPonWqInit();
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) pon work queue create\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	/* Interrupt */
+	/* ========= */
+	retcode = onuPonIrqInit();
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) gpon interrupt init\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	retcode = onuGponIrqTaskletInit(&(onuPonResourceTbl_s.onuPonIrqId));
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) gpon interrupt tasklet\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	retcode = onuGponIrqRegister(&(onuPonResourceTbl_s.onuPonIrqId));
+	if (retcode != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) gpon interrupt register\n", __FILE_DESC__, __LINE__);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponRtosResourceRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function release onu RTOS resources
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuGponRtosResourceRelease(void)
+{
+	del_timer(&(onuPonResourceTbl_s.onuGponT01_TimerId.onuPonTimerId));
+	del_timer(&(onuPonResourceTbl_s.onuGponT02_TimerId.onuPonTimerId));
+	del_timer(&(onuPonResourceTbl_s.onuGponPeeTimerId.onuPonTimerId));
+	del_timer(&(onuPonResourceTbl_s.onuPonSwFIFOTimerId.onuPonTimerId));
+	del_timer(&(onuPonResourceTbl_s.onuPonPmTimerId.onuPonTimerId));
+
+	free_irq(onuPonResourceTbl_s.onuPonIrqId.onuPonIrqNum, &(onuPonResourceTbl_s.onuPonIrqId));
+	printk("onuPonResourceTbl_s.onuPonIrqId.onuDgIrqNum, &(onuPonResourceTbl_s.onuPonIrqId\n\r");
+	free_irq(onuPonResourceTbl_s.onuPonIrqId.onuDgIrqNum, &(onuPonResourceTbl_s.onuPonIrqId));
+
+	tasklet_kill(&(onuPonResourceTbl_s.onuPonIrqId.onuPonTasklet));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIrqTaskletInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt tasklet init
+**
+**  PARAMETERS:  S_onuPonIrq irqId
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponIrqTaskletInit(S_onuPonIrq *irqId)
+{
+	tasklet_init(&(irqId->onuPonTasklet), onuGponTaskletFunc, (unsigned int)0);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIrqRegister
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt register
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     GPON Interrupt number
+**
+*******************************************************************************/
+MV_STATUS onuGponIrqRegister(S_onuPonIrq *irqId)
+{
+	int rcode;
+
+	rcode = request_irq(irqId->onuPonIrqNum, onuGponIrqRoutine, IRQF_DISABLED, "mvGpon", (void*)irqId);
+	if (rcode) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) gpon interrupt register\n", __FILE_DESC__, __LINE__);
+		free_irq(irqId->onuPonIrqNum, NULL);
+		return MV_ERROR;
+	}
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	rcode = request_irq(irqId->onuDgIrqNum, onuGponDgIrqRoutine, IRQF_DISABLED, "mvDyGasp", (void*)irqId);
+	if (rcode) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "ERROR: (%s:%d) GPON Dying Gasp interrupt register\n", __FILE_DESC__, __LINE__);
+		free_irq(irqId->onuDgIrqNum, NULL);
+		return MV_ERROR;
+	}
+#endif
+#endif  /* PON_FPGA */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuGponIrqRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt routinr
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IRQ_HANDLED
+**
+*******************************************************************************/
+irqreturn_t onuGponIrqRoutine(int irq, void *arg)
+{
+#ifdef MV_GPON_HW_INTERRUPT
+	onuGponIsrRoutine(0, 0);
+#else   /* SW_INTERRUPT - TASKLET */
+	MV_U32 interruptEvent;
+	MV_U32 interruptStatus;
+
+	S_onuPonIrq *irqId = (S_onuPonIrq*)arg;
+	onuGponIsrLowRoutine(&interruptEvent, &interruptStatus);
+	gponCurrentInterruptEvent  = interruptEvent;
+	gponCurrentInterruptStatus = interruptStatus;
+	tasklet_hi_schedule(&(irqId->onuPonTasklet));
+#endif  /* MV_GPON_HW_INTERRUPT */
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+**
+**  onuGponDgIrqRoutine
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Dying Gasp Interrupt routinr
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IRQ_HANDLED
+**
+*******************************************************************************/
+irqreturn_t onuGponDgIrqRoutine(int irq, void *arg)
+{
+	mvOnuPonMacDgInterruptDis();
+	onuPonDyingGaspProcess();
+	onuGponDgIsrRoutine();
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+**
+**  onuGponTaskletFunc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt tasklet function
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     GPON Interrupt number
+**
+*******************************************************************************/
+void onuGponTaskletFunc(unsigned long dummy)
+{
+	MV_U32 interruptEvent  = gponCurrentInterruptEvent;
+	MV_U32 interruptStatus = gponCurrentInterruptStatus;
+
+	onuPonIrqDisable(&(onuPonResourceTbl_s.onuPonIrqId)); /* disable GPON interrupt */
+
+	onuGponIsrRoutine(interruptEvent, interruptStatus);
+
+	onuPonIrqEnable(&(onuPonResourceTbl_s.onuPonIrqId)); /* enable GPON interrupt */
+}
+
+/*******************************************************************************
+**
+**  gponOnuGlbAddrInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Allocate a memory space for GPON MAC register space
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IAMBA_OK
+**
+*******************************************************************************/
+MV_STATUS onuGponGlbAddrInit(void)
+{
+#ifdef PON_A0
+#ifdef PON_FPGA
+	/* set base address in the pon onu register table */
+	ponOnuGlbAddrSet((MV_U32)(0x58000));
+#else
+	/* set base address in the pon onu register table, to be modified */
+	ponOnuGlbAddrSet((MV_U32)(0x58000));
+#endif
+#else
+	ponOnuGlbAddrSet((MV_U32)(0xCC000)); /* MV_GPON_MAC_REGS_BASE */
+#endif
+
+	return MV_OK;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.h
new file mode 100644
index 0000000..77bc3e9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/gpon/gponOnuLnxKsOs.h
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : gponOnuLnxKsOs.c                                           **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Linux OS resources             **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_LINUX_KS_OS_H
+#define _ONU_GPON_LINUX_KS_OS_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+void        onuGponTaskletFunc(unsigned long dummy);
+irqreturn_t onuGponIrqRoutine(int irq, void *arg);
+irqreturn_t onuGponDgIrqRoutine(int irq, void *arg);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern S_onuPonWork gponTcontCleanWork[8];
+extern S_onuPonWork gponTcontCleanAllWork;
+extern S_onuPonWork gponTcontActiveWork[8];
+extern S_onuPonWorkQueue gponTcontFlushWq;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* Init API */
+extern MV_STATUS onuGponGlbAddrInit(void);
+extern MV_STATUS onuGponRtosResourceInit(void);
+extern MV_STATUS onuGponRtosResourceRelease(void);
+
+/* Interrupt API */
+extern MV_STATUS onuGponIrqRegister(S_onuPonIrq *irqId);
+extern MV_STATUS onuGponIrqTaskletInit(S_onuPonIrq *irqId);
+
+/* Work queue API */
+extern void onuGponWqTcontInit(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_LINUX_KS_OS_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.c
new file mode 100644
index 0000000..ffce5bb
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.c
@@ -0,0 +1,915 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuBoard.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU Board specific                    **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuHeader.h"
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_OnuP2PDb onuP2PDb_s;
+t_ponXvrFuncPtr ponXvrFunc;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+MV_U32 prbsUserDefinedPattern[3] = { 0xA5A5A5A5,        /* [31:00] */
+				     0xA5A5A5A5,        /* [63:32] */
+				     0xA5A5 };          /* [79:64] */
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+extern spinlock_t onuPonIrqLock;
+
+MV_U32 time_interval_up   = 0;
+MV_U32 time_interval_down = 0;
+MV_BOOL transmit_up;
+
+/*******************************************************************************
+**
+**  onuPonLedInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init led operation
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuPonLedInit(void)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_LED_FOR_AVANTA_LP
+	MV_U32 gpioGroup, gpioMask;
+
+	PON_GPIO_GET(BOARD_GPP_SYS_LED, gpioGroup, gpioMask);
+	if (gpioMask != PON_GPIO_NOT_USED) {
+		status = mvGppTypeSet(gpioGroup, gpioMask, 0 /*output*/);
+		if (status != MV_OK)
+			return status;
+	}
+
+	PON_GPIO_GET(BOARD_GPP_PON_LED, gpioGroup, gpioMask);
+	if (gpioMask != PON_GPIO_NOT_USED) {
+		status = mvGppTypeSet(gpioGroup, gpioMask, 0 /*output*/);
+		if (status != MV_OK)
+			return status;
+	}
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_LED_BLINK_FREQ_A_ON, 0x30000000, 0);
+	if (status != MV_OK)
+		return status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_LED_BLINK_FREQ_A_OFF, 0x30000000, 0);
+	if (status != MV_OK)
+		return status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_LED_BLINK_FREQ_B_ON, 0x15000000, 0);
+	if (status != MV_OK)
+		return status;
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_LED_BLINK_FREQ_B_OFF, 0x15000000, 0);
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonLedHandler
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function handles led operation
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS onuPonLedHandler(MV_U32 led, MV_U32 action)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_LED_FOR_AVANTA_LP
+	MV_STATUS status = MV_OK;
+	MV_U32 gpioGroup = 0;
+	MV_U32 gpioMask = 0;
+
+	if (led == ONU_PON_SYS_LED) {
+		PON_GPIO_GET(BOARD_GPP_SYS_LED, gpioGroup, gpioMask);
+		if (gpioMask != PON_GPIO_NOT_USED) {
+			status = mvGppValueSet(gpioGroup, gpioMask, gpioMask);
+			if (status != MV_OK)
+				return status;
+		}
+
+	} else if (led == ONU_PON_SYNC_LED) {
+		PON_GPIO_GET(BOARD_GPP_PON_LED, gpioGroup, gpioMask);
+		if (gpioMask != PON_GPIO_NOT_USED) {
+			switch (action) {
+			case ACTIVE_LED_OFF:
+				status  = mvGppValueSet(gpioGroup, gpioMask, ~gpioMask);
+				if (status != MV_OK)
+					return status;
+				break;
+
+			case ACTIVE_LED_BLINK_SLOW:
+				status  = mvGppValueSet(gpioGroup, gpioMask, gpioMask);
+				if (status != MV_OK)
+					return status;
+				status  = mvGppBlinkEn(gpioGroup, gpioMask, gpioMask);
+				if (status != MV_OK)
+					return status;
+				status  = asicOntMiscRegWrite(mvAsicReg_PON_SYNC_LED_BLINK_FREQ, 0, 0);
+				if (status != MV_OK)
+					return status;
+				break;
+
+			case ACTIVE_LED_BLINK_FAST:
+				status  = mvGppValueSet(gpioGroup, gpioMask, gpioMask);
+				if (status != MV_OK)
+					return status;
+				status  = mvGppBlinkEn(gpioGroup, gpioMask, gpioMask);
+				if (status != MV_OK)
+					return status;
+				status  = asicOntMiscRegWrite(mvAsicReg_PON_SYNC_LED_BLINK_FREQ, 1, 0);
+				if (status != MV_OK)
+					return status;
+				break;
+
+			case ACTIVE_LED_ON:
+				status  = mvGppValueSet(gpioGroup, gpioMask, gpioMask);
+				if (status != MV_OK)
+					return status;
+				status  = mvGppBlinkEn(gpioGroup, gpioMask, ~gpioMask);
+				if (status != MV_OK)
+					return status;
+				break;
+			}
+		}
+	}
+#endif
+#endif  /* PON_FPGA */
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonDyingGaspProcess
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function process dying gasp function, kill VoIP
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonDyingGaspProcess(void)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	MV_U32 boardType;
+
+	/* GPON/EPON configuration of Dying Gasp */
+	/* ===================================== */
+	boardType = mvBoardIdGet();
+	switch (boardType) {
+	case RD_6650_ID:
+	case DB_6650_ID:
+	case RD_6660_ID:
+	case DB_6660_ID:
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_MPP_19, 0, 0); /* power down voip */
+		break;
+	default:
+		status = MV_ERROR;
+	}
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonDyingGaspExit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function forces system reset after dying gasp
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonDyingGaspExit(void)
+{
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "\n\n\n");
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "=========================================\n");
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "======= Dying Gasp Detected =============\n");
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "======= System Need To Reboot !!!!! =====\n");
+	mvPonPrint(PON_PRINT_INFO, PON_INIT_MODULE, "=========================================\n");
+#endif
+#endif  /* PON_FPGA */
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonMacBurstEnableInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init Burst Enable MPP
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS mvOnuPonMacBurstEnableInit(void)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+
+	if (1 /*mvCtrlModelGet() == MV_88F66X0*/) {
+		/* PHY control register - output status set */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: asicOntMiscRegWrite failed for PON phy ctrl enable - output\n\r");
+			return MV_ERROR;
+		}
+
+		/* Set SW BEN control for MC tranciever */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_HW_SELECT, 1, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: asicOntMiscRegWrite failed for PON phy SW ctrl select\n\r");
+			return MV_ERROR;
+		}
+
+		/* PHY control register - force disable */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_FORCE, 0, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: asicOntMiscRegWrite failed for PON phy SW ctrl not force\n\r");
+			return MV_ERROR;
+		}
+	}
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuP2PDbXvrBurstEnablePolaritySet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function sets EPON XVR polarity register value in the database
+**
+**  PARAMETERS:  MV_U32 val
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuP2PDbXvrBurstEnablePolaritySet(MV_U32 val)
+{
+	onuP2PDb_s.onuP2PGenTbl_s.xvrBurstEnPolarity = val;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuP2PDbXvrBurstEnablePolarityGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function returns EPON XVR polarity register value
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_U32 mode
+**
+*******************************************************************************/
+MV_U32 onuP2PDbXvrBurstEnablePolarityGet(void)
+{
+	return onuP2PDb_s.onuP2PGenTbl_s.xvrBurstEnPolarity;
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonMacPrbsUserDefinedPatternSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function init User defined PRBS pattern
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void mvOnuPonMacPrbsUserDefinedPatternSet(MV_U32 *prbsUserPattern)
+{
+	prbsUserDefinedPattern[0] = prbsUserPattern[0];
+	prbsUserDefinedPattern[1] = prbsUserPattern[1];
+	prbsUserDefinedPattern[2] = prbsUserPattern[2];
+}
+
+/*******************************************************************************
+**
+**  mvOnuPonMacPrbsUserDefinedPatternGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function return User defined PRBS pattern
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void mvOnuPonMacPrbsUserDefinedPatternGet(MV_U32 *prbsUserPattern)
+{
+	prbsUserPattern[0] = prbsUserDefinedPattern[0];
+	prbsUserPattern[1] = prbsUserDefinedPattern[1];
+	prbsUserPattern[2] = prbsUserDefinedPattern[2];
+}
+
+/*******************************************************************************
+**
+**  onuPonPatternBurstTransmit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function turn on or off actuacl burst transmission
+**
+**  PARAMETERS:  when on  == true  transmission is on
+**               when off == false transmission is off
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonPatternBurstTransmit(MV_BOOL on)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	/* ASIC Rev A0 */
+	/* =========== */
+
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+	if (status != MV_OK) {
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: asicOntMiscRegWrite failed for PON phy ctrl enable - output\n\r");
+		return MV_ERROR;
+	}
+
+	transmit_up = on;
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonPatternBurstEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:
+**
+**  PARAMETERS:  bool on
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonPatternBurstEnable(bool on)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	MV_U32 trans_value = 0;
+	MV_U32 polarity;
+
+	if (1 /*mvCtrlModelGet() == MV_88F66X0*/) {
+		/* PHY control register - force enable */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_FORCE, 1, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: asicOntMiscRegWrite failed for PON phy SW ctrl force\n\r");
+			return MV_ERROR;
+		}
+
+		polarity = onuP2PDbXvrBurstEnablePolarityGet();
+
+		/* PHY control register - force enable value - according to polarity */
+		status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_SW_VALUE, polarity, 0);
+		if (status != MV_OK) {
+			mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+				   "ERROR: asicOntMiscRegWrite failed for PON phy ctrl SW force value %d\n\r",
+				   trans_value);
+			return MV_ERROR;
+		}
+	}
+
+	transmit_up = on;
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonPatternBurstOn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function start TX transmissions of a selected pattern as periodic or static burst
+**
+**  PARAMETERS:
+**      MV_U32 pattern      0x1     1T
+**                          0x2     2T
+**                          0x80    PRBS - 9
+**                          0x82    PRBS - 15
+**                          0x83    PRBS - 23
+**     MV_BOOL isPeriodic   TX burst can be either static (in this case the following parameters has no effect)
+**                          and this parameter is FALSE OR periodic in this case this parameters is TRUE
+**     MV_U32 period        cycle time - the time in micro seconds between the start of on peak and the other
+**                          (must be greater then the duration interval)
+**     MV_U32 duration      peak time interval in micro seconds  (must be smaller then the duration interval)
+
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonPatternBurstOn(MV_U32 pattern, MV_BOOL isPeriodic, MV_U32 period, MV_U32 duration)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	/*pattern validation*/
+	if (!((pattern == ONU_PON_TX_PATTERN_TYPE_T1) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_T2) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_USER) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_PRBS_7) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_PRBS_9) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_PRBS_15) ||
+	      (pattern == ONU_PON_TX_PATTERN_TYPE_PRBS_23))) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE, "Wrong pattern type value %d \n", pattern);
+		return MV_BAD_VALUE;
+	}
+
+	if ((isPeriodic == MV_TRUE) && (duration >= period)) {
+		mvPonPrint(PON_PRINT_ERROR, PON_INIT_MODULE,
+			   "Period value %d MUST be greater then duration value %d \n", period, duration);
+		return MV_BAD_VALUE;
+	}
+
+	/*in case of sequential call to onuPonPatternBurstOn*/
+	/*stop timer operation and transmissions*/
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId));
+	onuPonPatternBurstTransmit(MV_TRUE);
+	onuPonPatternBurstEnable(MV_FALSE);
+	time_interval_up     = 0;
+	time_interval_down   = 0;
+	/* ASIC Rev A0 */
+	/* =========== */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_EN_LOOP_TIMING, 0x0, 0); */
+	if (status != MV_OK)
+		return status;
+
+	/* Set system in PHY mode, meaning disconnect the PON MAC */
+	/* status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_OPEN_TX_DOOR_15, 0x1, 0); */
+	if (status != MV_OK)
+		return status;
+
+	/* Set sedes power up in phy mode */
+	status = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_POWER_PHY_MODE, 0xfd04, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* set select on pattern */
+	status  = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_SELECT, 0x7, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* set pattern type */
+	if (pattern != ONU_PON_TX_PATTERN_TYPE_USER) {
+		status  = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_DATA, pattern, 0);
+		if (status != MV_OK)
+			return status;
+	} else {
+		/*
+		**  0xF10A2E6C <- PHY Test Data[15:0];  [UserData[8:0], Type = 5}
+		**  0xF10A2E68 <- PHY Test Data[31:16]; [UserData[23:9]}
+		**  0xF10A2E64 <- PHY Test Data[47:32]; [UserData[39:24]}
+		**  0xF10A2E60 <- PHY Test Data[63:48]; [UserData[55:40]}
+		**  0xF10A2E5C <- PHY Test Data[79:64]; [UserData[71:56]}
+		**  0xF10A2E58 <- PHY Test Data[96:80]; [UserData[79:72]}
+		*/
+		status  = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_DATA,
+			(((prbsUserDefinedPattern[0] &  0xFF) << 8)   | (pattern & 0xFF)), 0);
+		status |= asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_USER_DATA_01,
+			((prbsUserDefinedPattern[0] >> 8)  & 0xFFFF), 0);
+		status |= asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_USER_DATA_02,
+			(((prbsUserDefinedPattern[0] >> 24) & 0xFF)   | ((prbsUserDefinedPattern[1] & 0xFF) << 8)), 0);
+		status |= asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_USER_DATA_03,
+			((prbsUserDefinedPattern[1] >> 8)  & 0xFFFF), 0);
+		status |= asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_USER_DATA_04,
+			(((prbsUserDefinedPattern[1] >> 24) & 0xFF)   | ((prbsUserDefinedPattern[2] & 0xFF) << 8)), 0);
+		status |= asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_USER_DATA_05,
+			((prbsUserDefinedPattern[2] >> 8)  & 0xFF), 0);
+		if (status != MV_OK)
+			return status;
+	}
+
+	/*turn on selected pattern*/
+	status  = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_ENABLED, 0x1, 0);
+	if (status != MV_OK)
+		return status;
+
+	onuPonPatternBurstEnable(MV_TRUE);
+	if (isPeriodic == MV_TRUE) {
+		/*periosic burst*/
+		time_interval_up     = duration;
+		time_interval_down   = (period - duration);
+		transmit_up          = MV_TRUE;
+		onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId), 0, time_interval_up, 1);
+
+	}
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonPatternBurstOff
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function Turn off  pattern burst and reconnect PON MAC
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonPatternBurstOff(void)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	onuPonPatternBurstTransmit(MV_TRUE);
+	onuPonPatternBurstEnable(MV_FALSE);
+
+	/* status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_EN_LOOP_TIMING, 0x1, 0); */
+	if (status != MV_OK)
+		return status;
+
+	/* Set system in MAC mode, meaning connect the PON MAC */
+	/* status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_INTERNAL_OPEN_TX_DOOR_15, 0x0, 0); */
+	if (status != MV_OK)
+		return status;
+
+	/* Set serdes power down in phy mode */
+	status = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_POWER_PHY_MODE, 0x8d00, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* Set the output enable of the GP_BEN IO to Output */
+	status  = asicOntMiscRegWrite(mvAsicReg_PON_SERDES_PHY_CTRL_0_BEN_IO_EN, ONU_PHY_OUTPUT, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* turn off selected pattern */
+	status  = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_ENABLED, 0x0, 0);
+	if (status != MV_OK)
+		return status;
+
+	/* stop tranmission */
+	status = onuPonPatternBurstTransmit(MV_FALSE);
+	if (status != MV_OK)
+		return status;
+	/* stop timer operation */
+	onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId));
+
+	time_interval_up     = 0;
+	time_interval_down   = 0;
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonPatternBurstTimerHndl
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function is the timer callback when periodic burst is enabled
+**
+**  PARAMETERS:  when on  == true  transmission is on
+**               when off == false transmission is off
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+void      onuPonPatternBurstTimerHndl(void)
+{
+	MV_U32 time_interval;
+	MV_BOOL is_transmit_up;
+	unsigned long flags;
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	MV_STATUS status;
+#endif
+#endif  /* PON_FPGA */
+
+	spin_lock_irqsave(&onuPonIrqLock, flags);
+
+	onuPonResourceTbl_s.onuPonPatternBurstTimerId.onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+
+	time_interval  = (transmit_up == MV_TRUE ? time_interval_down : time_interval_up);
+	is_transmit_up = (transmit_up == MV_TRUE ? MV_FALSE : MV_TRUE);
+
+	if (onuPonResourceTbl_s.onuPonPatternBurstTimerId.onuPonTimerPeriodic == 0)
+		onuPonResourceTbl_s.onuPonPatternBurstTimerId.onuPonTimerPeriodic = 1;
+
+	onuPonPatternBurstTransmit(is_transmit_up);
+#ifndef PON_FPGA
+#ifdef DISABLE_PRBS_FOR_AVANTA_LP
+	/*switch on/off selected pattern*/
+	status = asicOntMiscRegWrite(mvAsicReg_PT_PATTERN_ENABLED, is_transmit_up, 0);
+	if (status != MV_OK)
+		mvPonPrint(PON_PRINT_ERROR, PON_ISR_MODULE,
+			   "ERROR: asicOntMiscRegWrite failed in PON pattern burst timer handler\n\r");
+
+	onuPonTimerUpdate(&(onuPonResourceTbl_s.onuPonPatternBurstTimerId), 0, time_interval, 1);
+#endif
+#endif  /* PON_FPGA */
+
+	spin_unlock_irqrestore(&onuPonIrqLock, flags);
+}
+
+/*******************************************************************************
+**
+**  onuPonTxPowerTimerStateSet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function enable / disable TX power off timer
+**
+**  PARAMETERS:  MV_BOOL mode - MV_TRUE  - start timer
+**                              MV_FALSE - stop timer
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonTxPowerTimerStateSet(MV_BOOL mode)
+{
+	MV_STATUS rcode = MV_OK;
+
+	if (mode == MV_TRUE)
+		onuPonTimerEnable(&(onuPonResourceTbl_s.onuPonTxPwrTimerId));
+	else
+		onuPonTimerDisable(&(onuPonResourceTbl_s.onuPonTxPwrTimerId));
+
+	return rcode;
+}
+
+/*******************************************************************************
+**
+**  onuPonTxPowerOn
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function turns ON/OFF TX tranciever power using MPP
+**
+**  PARAMETERS:  MV_BOOL txOn - MV_TRUE - turn TX XVR ON, othervise OFF
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonTxPowerOn(MV_BOOL txOn)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_GPIO_FOR_AVANTA_LP
+	MV_U32 gpioGroup, gpioMask;
+	MV_U32 familyId = MV_88F66X0;          /*mvCtrlModelGet();*/
+
+	PON_GPIO_GET(BOARD_GPP_PON_XVR_TX_POWER, gpioGroup, gpioMask);
+
+	if (gpioMask != PON_GPIO_NOT_USED) {
+		if (txOn == MV_TRUE)
+			status = mvGppValueSet(gpioGroup, gpioMask, gpioMask);
+		else
+			status = mvGppValueSet(gpioGroup, gpioMask, 0);
+	} else if (familyId == MV_88F66X0)
+		status = MV_ERROR;
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+/*******************************************************************************
+**
+**  onuPonTxPowerControlInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function initialyzes TX power control pins
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonTxPowerControlInit(void)
+{
+	MV_STATUS status = MV_OK;
+
+#ifndef PON_FPGA
+#ifdef DISABLE_GPIO_FOR_AVANTA_LP
+	MV_U32 gpioPinNum, gpioGroup, gpioMask;
+	MV_U32 regVal, mppGroup;
+	MV_GPP_HAL_DATA halData;
+	MV_U32 familyId = MV_88F66X0;          /*mvCtrlModelGet();*/
+
+	gpioPinNum = mvBoarGpioPinNumGet(BOARD_GPP_PON_XVR_TX_POWER, 0);
+
+	if (gpioPinNum != MV_ERROR) {
+		mppGroup = mvCtrlMppRegGet(gpioPinNum / 8);
+		/* Set TX power MPP to GPP mode */
+		regVal = MV_REG_READ(mppGroup);
+		regVal &= ~(0xf << ((gpioPinNum % 8) * 4));
+		MV_REG_WRITE(mppGroup, regVal);
+
+		halData.ctrlRev = mvCtrlRevGet();
+
+		status = mvGppInit(&halData);
+		if (status == MV_OK) {
+			/* Set TX power GPP pin direction to OUT */
+			gpioGroup = gpioPinNum / 32;
+			gpioMask = 1 << gpioPinNum;
+			status = mvGppTypeSet(gpioGroup, gpioMask, (MV_GPP_OUT & gpioMask));
+		}
+	} else if (familyId == MV_88F66X0)
+		status = MV_ERROR;
+#endif
+#endif  /* PON_FPGA */
+	return status;
+}
+
+MV_STATUS EponXvrSDPolarityHighStatus(MV_U32 interruptStatus, MV_U32 statusMask)
+{
+	return (interruptStatus & statusMask) ? MV_FALSE : MV_TRUE;
+}
+
+MV_STATUS EponXvrSDPolarityLowStatus(MV_U32 interruptStatus, MV_U32 statusMask)
+{
+	return (~interruptStatus & statusMask) ? MV_FALSE : MV_TRUE;
+}
+
+MV_STATUS GponXvrSDPolarityHighStatus(MV_U32 interruptStatus, MV_U32 statusMask)
+{
+	return (interruptStatus & statusMask) ? MV_TRUE : MV_FALSE;
+}
+
+MV_STATUS GponXvrSDPolarityLowStatus(MV_U32 interruptStatus, MV_U32 statusMask)
+{
+	return (~interruptStatus & statusMask) ? MV_TRUE : MV_FALSE;
+}
+
+t_ponXvrFuncPtr funcEponXvrSDStatus(MV_U32 polarity)
+{
+	if (polarity == 0)
+		return EponXvrSDPolarityHighStatus;
+	else
+		return EponXvrSDPolarityLowStatus;
+}
+
+t_ponXvrFuncPtr funcGponXvrSDStatus(MV_U32 polarity)
+{
+	if (polarity == 0)
+		return GponXvrSDPolarityHighStatus;
+	else
+		return GponXvrSDPolarityLowStatus;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.h
new file mode 100644
index 0000000..aa8df92
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuBoard.h
@@ -0,0 +1,187 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuBoard.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON board specific definitions     **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_PON_BOARD_H
+#define _ONU_PON_BOARD_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+#define PON_NUM_DEVICES     (1)
+#define PON_DEV_NAME        ("pon")
+#define MVPON_IOCTL_MAGIC   ('P')
+
+#define DB_88F65xx_XVR_SD (0x6)
+#define RD_88F65xx_XVR_SD (0x5)
+
+#define DB_88F65xx_DG     (0x3)
+#define RD_88F65xx_DG     (0x4)
+
+#define ONU_PON_TX_PATTERN_TYPE_T1        (0x1)
+#define ONU_PON_TX_PATTERN_TYPE_T2        (0x2)
+#define ONU_PON_TX_PATTERN_TYPE_USER      (0x5)
+#define ONU_PON_TX_PATTERN_TYPE_PRBS_7    (0x80)
+#define ONU_PON_TX_PATTERN_TYPE_PRBS_9    (0x81)
+#define ONU_PON_TX_PATTERN_TYPE_PRBS_15   (0x82)
+#define ONU_PON_TX_PATTERN_TYPE_PRBS_23   (0x83)
+
+#define ONU_PON_XVR_POLARITY_ACT_HIGH     (0x1)
+#define ONU_PON_XVR_POLARITY_ACT_LOW      (0x0)
+
+#define ONU_XVR_GPIO_OUTPUT               (0x0)
+#define ONU_XVR_GPIO_INPUT                (0x1)
+
+#define ONU_PHY_OUTPUT                    (0x0)
+#define ONU_PHY_INPUT                     (0x1)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	ONU_PON_SYS_LED       = 0,
+	ONU_PON_SYNC_LED      = 1
+} E_OnuPonLedTypes;
+
+typedef enum {
+	ACTIVE_LED_OFF        = 0,
+	ACTIVE_LED_BLINK_SLOW = 1,
+	ACTIVE_LED_BLINK_FAST = 2,
+	ACTIVE_LED_ON         = 3
+} E_OnuPonLedActivation;
+
+/* Struct
+   ------------------------------------------------------------------------------*/
+/* ONU P2P Database */
+typedef struct {
+	MV_U32 xvrBurstEnPolarity;
+	MV_U32 xvrPolarity;
+} S_OnuP2PGenTbl;
+
+typedef struct {
+	S_OnuP2PGenTbl onuP2PGenTbl_s;
+} S_OnuP2PDb;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef MV_STATUS (*t_ponXvrFuncPtr)(MV_U32, MV_U32);
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern t_ponXvrFuncPtr ponXvrFunc;
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+MV_STATUS onuPonPatternBurstEnable(bool on);
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* led */
+MV_STATUS onuPonLedInit(void);
+MV_STATUS onuPonLedHandler(MV_U32 led, MV_U32 action);
+
+/* dying gasp */
+MV_STATUS onuPonDyingGaspProcess(void);
+MV_STATUS onuPonDyingGaspExit(void);
+
+/* prbs */
+void      mvOnuPonMacPrbsUserDefinedPatternSet(MV_U32 *prbsUserPattern);
+void      mvOnuPonMacPrbsUserDefinedPatternGet(MV_U32 *prbsUserPattern);
+MV_STATUS onuPonPatternBurstOn(MV_U32 pattern, MV_BOOL isPeriodic, MV_U32 period, MV_U32 duration);
+MV_STATUS onuPonPatternBurstOff(void);
+void      onuPonPatternBurstTimerHndl(void);
+
+/* burst enable */
+MV_STATUS mvOnuPonMacBurstEnableInit(void);
+MV_STATUS onuP2PDbXvrBurstEnablePolaritySet(MV_U32 val);
+MV_U32    onuP2PDbXvrBurstEnablePolarityGet(void);
+
+/* tx power */
+MV_STATUS onuPonTxPowerOn(MV_BOOL txOn);
+MV_STATUS onuPonTxPowerControlInit(void);
+MV_STATUS onuPonTxPowerTimerStateSet(MV_BOOL mode);
+
+MV_STATUS EponXvrSDPolarityHighStatus(MV_U32 interruptStatus, MV_U32 statusMask);
+MV_STATUS EponXvrSDPolarityLowStatus(MV_U32 interruptStatus, MV_U32 statusMask);
+MV_STATUS GponXvrSDPolarityHighStatus(MV_U32 interruptStatus, MV_U32 statusMask);
+MV_STATUS GponXvrSDPolarityLowStatus(MV_U32 interruptStatus, MV_U32 statusMask);
+t_ponXvrFuncPtr funcEponXvrSDStatus(MV_U32 polarity);
+t_ponXvrFuncPtr funcGponXvrSDStatus(MV_U32 polarity);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_PON_BOARD_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuHeader.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuHeader.h
new file mode 100644
index 0000000..57b52fa
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuHeader.h
@@ -0,0 +1,117 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************/
+/**                                                                          **/
+/**  MODULE      : ONU EPON                                                  **/
+/**                                                                          **/
+/**  FILE        : ponOnuHeader.h                                            **/
+/**                                                                          **/
+/**  DESCRIPTION : This file pon module header files                         **/
+/**                                                                          **/
+/******************************************************************************
+*                                                                            *
+*  MODIFICATION HISTORY:                                                     *
+*                                                                            *
+*   26Jan10  oren_ben_hayun    created                                       *
+* ========================================================================== *
+*                                                                            *
+******************************************************************************/
+
+#ifndef _ONU_PON_HEADER_H
+#define _ONU_PON_HEADER_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "mvCommon.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvPonOnuDefines.h"
+#include "mvPonOnuRegs.h"
+#include "mvPonOnuMac.h"
+#include "ponOnuBoard.h"
+#include "ponOnuLnxKsOs.h"
+#include "gpp/mvGpp.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+extern MV_STATUS ponOnuGlbAddrSet(MV_U32 address);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_PON_HEADER_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.c
new file mode 100644
index 0000000..8290364
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.c
@@ -0,0 +1,937 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuLnxKsOs.c                                            **
+**                                                                           **
+**  DESCRIPTION : This file implements ONU GPON Linux OS handling            **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "../perf/ponOnuLnxKsMI.h"
+#include "ponOnuLnxKsOs.h"
+#include "gponOnuHeader.h"
+#ifndef PON_FPGA
+#ifdef DISABLE_ADDR_FOR_AVANTA_LP
+#include "mvSysPonConfig.h"
+#endif
+#endif /* PON_FPGA */
+
+/* Local Constant
+   ------------------------------------------------------------------------------*/
+#define __FILE_DESC__ "mv_pon/plat/ponOnuLnxKsOs.c"
+
+/* Global Variables
+   ------------------------------------------------------------------------------*/
+S_OnuPonResourceTbl onuPonResourceTbl_s;
+
+S_PonModulePrint gponModulePrint_s[PON_LAST_MODULE + 1] = {
+	{ 0,              0 },
+	/* PON_MAC_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_INIT_MODULE  */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_ISR_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_CLI_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_MNG_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_SM_MODULE    */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_PM_MODULE    */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_ALARM_MODULE */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_BER_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_API_MODULE   */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_ALLOC_MODULE */ { PON_PRINT_INFO, 0 },   /* No Options */
+	/* PON_DB_MODULE    */ { PON_PRINT_INFO, 0 }  /* No Options */
+};
+
+MV_U32 berIntervalForTypeB_Flag = 0;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+spinlock_t onuPonIrqLock;
+
+S_PonEventQueue gPonEventQueue;
+
+/* Local Variables
+   ------------------------------------------------------------------------------*/
+
+/* ========================================================================== */
+/* ===========================  MEMORY SECTION  ============================= */
+/* ========================================================================== */
+void *onuPonMemoryAllocArray[128];
+MV_U32 onuPonMemoryAllocIndex = 0;
+
+/* Export Functions
+   ------------------------------------------------------------------------------*/
+
+/* Local Functions
+   ------------------------------------------------------------------------------*/
+
+/*******************************************************************************
+**
+**  onuPonIrqInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: The function inits PON interrupts
+**
+**  PARAMETERS:  None
+**
+**  OUTPUTS:     None
+**
+**  RETURNS:     MV_OK or error
+**
+*******************************************************************************/
+MV_STATUS onuPonIrqInit(void)
+{
+	/* Interrupt */
+	/* ========= */
+	onuPonIrqNumInit();
+
+	return MV_OK;
+}
+
+/* ========================================================================== */
+/* ===========================  TIMER SECTION  ============================== */
+/* ========================================================================== */
+
+/*******************************************************************************
+**
+**  onuPonTimerCreate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+MV_STATUS onuPonTimerCreate(S_OnuPonTimer  *timerId,
+			    MV_U8          *timerDesc,
+			    PTIMER_FUNCPTR timerFunc,
+			    MV_U32 timerParam,
+			    MV_U32 timerInterval,
+			    MV_U32 timerPeriodic)
+{
+	memset(&(timerId->onuPonTimerId), 0, sizeof(struct timer_list));
+	timerId->onuPonTimerId.function = timerFunc;
+	timerId->onuPonTimerId.data     = (-1);
+
+	timerId->onuPonTimerInterval    = timerInterval;
+	timerId->onuPonTimerPeriodic    = timerPeriodic;
+	init_timer(&(timerId->onuPonTimerId));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonTimerUpdate
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+int onuPonTimerUpdate(S_OnuPonTimer *timerId, MV_U32 data, MV_U32 interval, MV_U32 state)
+{
+	onuPonTimerDisable(timerId);
+	timerId->onuPonTimerId.data  = data;
+	timerId->onuPonTimerInterval = interval;
+	if (state != 0)
+		onuPonTimerEnable(timerId);
+
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  onuPonTimerEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+int onuPonTimerEnable(S_OnuPonTimer *timerId)
+{
+	MV_U32 onuState = onuGponDbOnuStateGet();
+
+	if (timerId->onuPonTimerActive != ONU_PON_TIMER_ACTIVE) {
+		del_timer(&(timerId->onuPonTimerId));
+		timerId->onuPonTimerId.expires = jiffies + (((timerId->onuPonTimerInterval) * HZ) / 1000); /* ms */
+		add_timer(&(timerId->onuPonTimerId));
+		timerId->onuPonTimerActive = ONU_PON_TIMER_ACTIVE;
+
+		if (((&(onuPonResourceTbl_s.onuPonIsrXvrRstTimerId)) == timerId) &&
+		    (onuState == ONU_GPON_06_POPUP)) {
+			berIntervalForTypeB_Flag = 1;
+			mvOnuGponMacBipInterruptIntervalSet(40 /*125micro * 40 = 5 msec*/);
+		}
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  onuPonTimerDisable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION:   The function
+**
+**  PARAMETERS:
+**
+**  OUTPUTS:       None
+**
+**  RETURNS:
+**
+*******************************************************************************/
+int onuPonTimerDisable(S_OnuPonTimer *timerId)
+{
+	if (timerId->onuPonTimerActive != ONU_PON_TIMER_NOT_ACTIVE) {
+		del_timer(&(timerId->onuPonTimerId));
+		timerId->onuPonTimerActive = ONU_PON_TIMER_NOT_ACTIVE;
+	}
+
+	return 0;
+}
+
+/* ========================================================================== */
+/* ===========================  ISR SECTION  ================================ */
+/* ========================================================================== */
+
+/*******************************************************************************
+**
+**  onuPonIrqNumGet
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt number get
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     GPON Interrupt number
+**
+*******************************************************************************/
+MV_STATUS onuPonIrqNumInit(void)
+{
+#ifdef PON_A0
+	onuPonResourceTbl_s.onuPonIrqId.onuPonIrqNum = 111;     /* GPON_MAC_IRQ_NUM */
+#else
+	onuPonResourceTbl_s.onuPonIrqId.onuPonIrqNum = 83;      /* GPON_MAC_IRQ_NUM */
+#endif
+
+#ifndef PON_FPGA
+#ifdef DISABLE_DG_FOR_AVANTA_LP
+	onuPonResourceTbl_s.onuPonIrqId.onuDgIrqNum  = 89; /* DYNGASP_IRQ_NUM; */
+#endif
+#endif /* PON_FPGA */
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**  onuPonIrqEnable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt enable
+**
+**  PARAMETERS:  S_onuPonIrq irqId
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+int onuPonIrqEnable(S_onuPonIrq *irqId)
+{
+	enable_irq(irqId->onuPonIrqNum);
+
+	return 0;
+}
+
+/*******************************************************************************
+**
+**  onuPonIrqDisable
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON Interrupt disable
+**
+**  PARAMETERS:  S_onuPonIrq irqId
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+int onuPonIrqDisable(S_onuPonIrq *irqId)
+{
+	disable_irq(irqId->onuPonIrqNum);
+
+	return 0;
+}
+
+/* ========================================================================== */
+/* ===========================  MEMORY SECTION  ============================= */
+/* ========================================================================== */
+
+/*******************************************************************************
+**
+**  onuPonMemAlloc
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Allocate a memory space for GPON MAC
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IAMBA_OK
+**
+*******************************************************************************/
+void *onuPonMemAlloc(unsigned int size)
+{
+	void *memoryAlloc = kmalloc(size, GFP_KERNEL);
+
+	onuPonMemoryAllocArray[onuPonMemoryAllocIndex] = memoryAlloc;
+	onuPonMemoryAllocIndex++;
+
+	return memoryAlloc;
+}
+
+/*******************************************************************************
+**
+**  onuPonMemRelease
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: release all allocated memory for GPON module
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     IAMBA_OK
+**
+*******************************************************************************/
+void onuPonMemRelease(void)
+{
+	MV_U32 index;
+
+	for (index = 0; index < onuPonMemoryAllocIndex; index++)
+		kfree(onuPonMemoryAllocArray[index]);
+}
+
+/* ========================================================================== */
+/* ===========================  PRINT SECTION  ============================== */
+/* ========================================================================== */
+
+/*******************************************************************************
+**
+**  mvPonPrint
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: GPON print function
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK
+**
+*******************************************************************************/
+MV_STATUS mvPonPrint(MV_U32 level, MV_U32 bitMask, const char *format, ...)
+{
+	MV_STATUS rcode;
+	char buf[256];
+	va_list argptr;
+
+	/* check module printing status */
+	rcode = ponOnuCheckPrintStatus(level, bitMask);
+	if (rcode != MV_OK)
+		return MV_OK;
+
+	/* build message */
+	va_start(argptr, format);
+	vsnprintf(buf, sizeof(buf), format, argptr);
+	va_end(argptr);
+
+	/* print message */
+	switch (level) {
+	case PON_PRINT_ERROR:
+		printk(KERN_ERR "%s", buf);
+		break;
+	case PON_PRINT_INFO:
+		printk(KERN_INFO "%s", buf);
+		break;
+	case PON_PRINT_DEBUG:
+	default:
+		printk(KERN_DEBUG "%s", buf);
+		break;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  ponOnuCheckPrintStatus
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Check module printing status
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK / MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS ponOnuCheckPrintStatus(MV_U32 printLevel,
+				 MV_U32 moduleOptions)
+{
+	MV_U32 module;
+	MV_U32 options;
+	MV_U32 modulePrintLevel;
+	MV_U32 modulePrintOptions;
+	MV_BOOL printLevelInd;
+	MV_BOOL printOptionsInd;
+
+	/* input params */
+	module             =  moduleOptions        & MODULE_MASK;
+	options            = (moduleOptions >> 16) & OPTIONS_MASK;
+
+	/* current module params */
+	modulePrintLevel   = gponModulePrint_s[module].modulePrintLevel;
+	modulePrintOptions = gponModulePrint_s[module].moduleOptions;
+
+	/* check print level */
+	if (printLevel <= modulePrintLevel)
+		printLevelInd = MV_TRUE;
+	else
+		printLevelInd = MV_FALSE;
+
+	/* check module options */
+	if (options == 0)
+		printOptionsInd = MV_TRUE; /* no options */
+	else{
+		if (options & modulePrintOptions)
+			printOptionsInd = MV_TRUE;
+		else
+			printOptionsInd = MV_FALSE;
+	}
+
+	if ((printLevelInd == MV_TRUE) && (printOptionsInd == MV_TRUE))
+		return MV_OK;
+	else
+		return MV_ERROR;
+}
+
+/*******************************************************************************
+**
+**  ponOnuChangePrintStatus
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Change module printing status
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK / MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS ponOnuChangePrintStatus(MV_U32 module,
+				  MV_U32 printLevel,
+				  MV_U32 moduleOptions)
+{
+	gponModulePrint_s[module].modulePrintLevel = printLevel;
+	gponModulePrint_s[module].moduleOptions    = moduleOptions;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  ponOnuGetPrintStatus
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Change module printing status
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK / MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS ponOnuGetPrintStatus(MV_U32 module,
+			       MV_U32 *printLevel,
+			       MV_U32 *moduleOptions)
+{
+	*printLevel    = gponModulePrint_s[module].modulePrintLevel;
+	*moduleOptions = gponModulePrint_s[module].moduleOptions;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  ponOnuPrintStatus
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: print modules printing status
+**
+**  PARAMETERS:  char* buf
+**
+**  OUTPUTS:     char* buf
+**
+**  RETURNS:     message length
+**
+*******************************************************************************/
+int ponOnuPrintStatus(char *buf)
+{
+	MV_U32 index;
+	MV_U32 printLevel;
+	MV_U32 moduleOptions;
+
+	char *moduleDesc[PON_LAST_MODULE + 1] = {
+		"",
+		"MAC   -  1            ",
+		"INIT  -  2            ",
+		"ISR   -  3            ",
+		"CLI   -  4            ",
+		"MNG   -  5            ",
+		"SM    -  6 (GPON Only)",
+		"PM    -  7 (GPON Only)",
+		"ALARM -  8            ",
+		"BER   -  9 (GPON Only)",
+		"API   - 10            ",
+		"ALLOC - 11 (GPON Only)",
+		"DB    - 12            "
+	};
+
+	char *printLevelDesc[4] = {
+		"",
+		"ERROR",
+		"INFO",
+		"DEBUG"
+	};
+
+	int off = 0;
+
+	off += mvOsSPrintf(buf + off, "Module                  Print Level  Options\n");
+	for (index = 0; index < PON_LAST_MODULE; index++) {
+		ponOnuGetPrintStatus(index, &printLevel, &moduleOptions);
+		off += mvOsSPrintf(buf + off, "%22s  %11s   0x%08x\n", moduleDesc[index], printLevelDesc[printLevel],
+			moduleOptions);
+	}
+
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "GPON              | EPON\n");
+	off += mvOsSPrintf(buf + off, "==================+====================\n");
+	off += mvOsSPrintf(buf + off, "SM Module Options | ISR Module Options\n");
+	off += mvOsSPrintf(buf + off, "DEBUG    - 0x0001 | INT      - 0x0001\n");
+	off += mvOsSPrintf(buf + off, "STATE    - 0x0002 | MISS     - 0x0002\n");
+	off += mvOsSPrintf(buf + off, "AES      - 0x0004 | STATE    - 0x0004\n");
+	off += mvOsSPrintf(buf + off, "ALLOC    - 0x0008 | RAND     - 0x0008\n");
+	off += mvOsSPrintf(buf + off, "OMCC     - 0x0010 | \n");
+	off += mvOsSPrintf(buf + off, "TIMER    - 0x0020 | MNG Module Options\n");
+	off += mvOsSPrintf(buf + off, "ALARM    - 0x0040 | DBA      - 0x0001\n");
+	off += mvOsSPrintf(buf + off, "                  | SILENCE  - 0x0002\n");
+	off += mvOsSPrintf(buf + off, "                  | MAC ADDR - 0x0004\n");
+	off += mvOsSPrintf(buf + off, "                  | OAM TX   - 0x0008\n");
+	off += mvOsSPrintf(buf + off, "                  | DBA WA   - 0x0010\n");
+	off += mvOsSPrintf(buf + off, "                  | DBA FEC  - 0x0020\n");
+	off += mvOsSPrintf(buf + off, "                  | DBA TS   - 0x0040\n");
+	off += mvOsSPrintf(buf + off, "==================+====================\n");
+	off += mvOsSPrintf(buf + off, "GPON Print Levels\n");
+	off += mvOsSPrintf(buf + off, "ERROR    - 1\n");
+	off += mvOsSPrintf(buf + off, "INFO     - 2\n");
+	off += mvOsSPrintf(buf + off, "DEBUG    - 3\n");
+	off += mvOsSPrintf(buf + off, "\n");
+	off += mvOsSPrintf(buf + off, "Kernel Print Levels\n");
+	off += mvOsSPrintf(buf + off, "KERN_ERR   - 4\n");
+	off += mvOsSPrintf(buf + off, "KERN_INFO  - 7\n");
+	off += mvOsSPrintf(buf + off, "KERN_DEBUG - 8\n");
+	off += mvOsSPrintf(buf + off, "Change Kernel Print Level >> dmesg -n[level]\n");
+	off += mvOsSPrintf(buf + off, "\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  ponOnuCfgParamSave
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Request configuration parameter save
+**
+**  PARAMETERS:  E_PonCfgParam param : param that needs to be saved
+**               char *value         : vlaue of param
+**               unsigned int len    : length of value
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_OK / MV_ERROR
+**
+*******************************************************************************/
+MV_STATUS ponOnuCfgParamSave(E_PonCfgParam param, unsigned char *value, unsigned int len)
+{
+	int rcode;
+
+	rcode = onuPonEventSavingParamInfo(param, value, len);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonEventSavingParamInfo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Create an event of saving a parameter in XML
+**               and push to queue
+**
+**  PARAMETERS:  E_PonCfgParam param: param that needs to be saved
+**               char *value        : vlaue of param
+**               unsigned int len   : length of value
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_FALSE or MV_OK
+**
+*******************************************************************************/
+int onuPonEventSavingParamInfo(E_PonCfgParam param, unsigned char *value, unsigned int len)
+{
+	S_PonEventInfo eventInfo;
+	S_PonEventParamPayload *pCfg;
+
+	eventInfo.eventId = E_PON_EVENT_ID_SAVE_PARAM;
+	pCfg = (S_PonEventParamPayload *)(eventInfo.payload);
+	pCfg->paramIndex = param;
+	memcpy(pCfg->paramValue, value, len);
+
+	if (ponEventQueuePush(&eventInfo) == MV_FULL)
+		return MV_FULL;
+
+	wake_up(&(ponDev.r_wait));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonEventOmciSyncInfo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Create an event of OMCC ready and push to queue
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_FALSE or MV_OK
+**
+*******************************************************************************/
+int onuPonEventOmciSyncInfo(void)
+{
+	S_PonEventInfo eventInfo;
+
+	eventInfo.eventId = E_GPON_EVENT_ID_OMCI_SYNC;
+
+	if (ponEventQueuePush(&eventInfo) == MV_FULL)
+		return MV_FULL;
+
+	wake_up(&(ponDev.r_wait));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonEventDyingGaspInfo
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Create an event of dying gasp and push to queue
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_FALSE or MV_OK
+**
+*******************************************************************************/
+int onuPonEventDyingGaspInfo(void)
+{
+	S_PonEventInfo eventInfo;
+
+	eventInfo.eventId = E_GPON_EVENT_ID_DYING_GASP;
+
+	if (ponEventQueuePush(&eventInfo) == MV_FULL)
+		return MV_FULL;
+
+	wake_up(&(ponDev.r_wait));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonEventOmciMsgSend
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Create an event of OMCC message and push to queue
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_FALSE or MV_OK
+**
+*******************************************************************************/
+int onuPonEventOmciMsgSend(MV_U8 *msg)
+{
+	S_PonEventInfo eventInfo;
+
+	eventInfo.eventId = E_GPON_EVENT_ID_OMCI_MSG;
+	memcpy(eventInfo.payload, msg, GPON_STD_OMCI_MSG_LEN);
+
+	if (ponEventQueuePush(&eventInfo) != MV_OK)
+		return MV_FULL;
+
+	wake_up(&(ponDev.r_wait));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  onuPonEventInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Insert the PON device into wait queue for polling and
+**               initialize the event queue.
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_STATUS
+**
+*******************************************************************************/
+MV_STATUS onuPonEventInit(void)
+{
+	int ret = MV_OK;
+
+	init_waitqueue_head(&(ponDev.r_wait));
+
+	ponEventQueueInit();
+
+	return ret;
+}
+
+/*******************************************************************************
+**
+**  ponEventQueueInit
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Initialize the event queue.
+**
+**  PARAMETERS:  none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     none
+**
+*******************************************************************************/
+void ponEventQueueInit(void)
+{
+	memset(gPonEventQueue.ponEventQueue, 0, sizeof(gPonEventQueue.ponEventQueue));
+	gPonEventQueue.queueHead = 0;
+	gPonEventQueue.queueTail = 0;
+	gPonEventQueue.queueLen  = 0;
+
+	spin_lock_init(&(gPonEventQueue.queueLock));
+}
+
+/*******************************************************************************
+**
+**  ponEventQueuePush
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Event Queue operation: push an event into queue.
+**
+**  PARAMETERS:  S_PonEventInfo *event - event
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_BAD_PARAM/MV_FULL/MV_OK
+**
+*******************************************************************************/
+int ponEventQueuePush(S_PonEventInfo *event)
+{
+	spin_lock(&(gPonEventQueue.queueLock));
+
+	if (event == NULL) {
+		spin_unlock(&(gPonEventQueue.queueLock));
+		return MV_BAD_PARAM;
+	}
+
+	if (gPonEventQueue.queueLen == PON_EVENT_QUEUE_SIZE) {
+		spin_unlock(&(gPonEventQueue.queueLock));
+		return MV_FULL;
+	}
+
+	memcpy(&(gPonEventQueue.ponEventQueue[gPonEventQueue.queueTail]),
+	       event, sizeof(S_PonEventInfo));
+	if (gPonEventQueue.queueTail == (PON_EVENT_QUEUE_SIZE - 1))
+		gPonEventQueue.queueTail = 0;
+	else
+		gPonEventQueue.queueTail++;
+
+	gPonEventQueue.queueLen++;
+
+	spin_unlock(&(gPonEventQueue.queueLock));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  ponEventQueuePull
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Event Queue operation: pull an event out of queue.
+**
+**  INPUTS :     none
+**
+**  OUTPUTS:     S_PonEventInfo *event - event
+**
+**  RETURNS:     MV_BAD_PARAM/MV_ENPTY/MV_OK
+**
+*******************************************************************************/
+int ponEventQueuePull(S_PonEventInfo *event)
+{
+	spin_lock(&(gPonEventQueue.queueLock));
+
+	if (event == NULL) {
+		spin_unlock(&(gPonEventQueue.queueLock));
+		return MV_BAD_PARAM;
+	}
+
+	if (gPonEventQueue.queueLen == 0) {
+		spin_unlock(&(gPonEventQueue.queueLock));
+		return MV_EMPTY;
+	}
+
+	memcpy(event, &(gPonEventQueue.ponEventQueue[gPonEventQueue.queueHead]),
+	       sizeof(S_PonEventInfo));
+	if (gPonEventQueue.queueHead == (PON_EVENT_QUEUE_SIZE - 1))
+		gPonEventQueue.queueHead = 0;
+	else
+		gPonEventQueue.queueHead++;
+
+	gPonEventQueue.queueLen--;
+
+	spin_unlock(&(gPonEventQueue.queueLock));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+**
+**  ponEventQueueIsEmpty
+**  ____________________________________________________________________________
+**
+**  DESCRIPTION: Event Queue operation: check if the queue is empty.
+**
+**  INPUTS :     none
+**
+**  OUTPUTS:     none
+**
+**  RETURNS:     MV_TRUE/MV_FALSE;
+**
+*******************************************************************************/
+MV_BOOL ponEventQueueIsEmpty(void)
+{
+	return gPonEventQueue.queueLen == 0 ? MV_TRUE : MV_FALSE;
+}
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.h
new file mode 100644
index 0000000..0928f16
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuLnxKsOs.h
@@ -0,0 +1,468 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuLnxKsOs.c                                            **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Linux OS resources             **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_PON_LINUX_KS_OS_H
+#define _ONU_PON_LINUX_KS_OS_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/byteorder/generic.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/workqueue.h>
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mv_netdev.h"
+#include "ponOnuHeader.h"
+#include "mvPonOnuDefines.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Printing Definitions */
+#define PON_PRINT_ERROR           (1)
+#define PON_PRINT_INFO            (2)
+#define PON_PRINT_DEBUG           (3)
+
+#define MODULE_SHIFT              (16)
+#define MODULE_MASK               (0x001F)
+#define OPTIONS_MASK              (0xFFFF)
+
+#define ONU_PON_SM_DEBUG_ATTR     (0x0001)
+#define ONU_PON_SM_STATE_ATTR     (0x0002)
+#define ONU_PON_SM_AES_ATTR       (0x0004)
+#define ONU_PON_SM_ALLOC_ATTR     (0x0008)
+#define ONU_PON_SM_OMCC_ATTR      (0x0010)
+#define ONU_PON_SM_TIMER_ATTR     (0x0020)
+#define ONU_PON_SM_ALARM_ATTR     (0x0040)
+
+#define ONU_PON_MNG_DBA_ATTR      (0x0001)
+#define ONU_PON_MNG_SILENCE_ATTR  (0x0002)
+#define ONU_PON_MNG_MAC_ADDR_ATTR (0x0004)
+#define ONU_PON_MNG_OAM_TX_ATTR   (0x0008)
+#define ONU_PON_MNG_DBA_WA_ATTR   (0x0010)
+#define ONU_PON_MNG_DBA_FEC_ATTR  (0x0020)
+#define ONU_PON_MNG_DBA_TS_ATTR   (0x0040)
+
+#define ONU_PON_ISR_INT_ATTR      (0x0001)
+#define ONU_PON_ISR_MISS_ATTR     (0x0002)
+#define ONU_PON_ISR_STATE_ATTR    (0x0004)
+#define ONU_PON_ISR_RAND_ATTR     (0x0008)
+
+#define PON_MAC_MODULE            (1)
+#define PON_INIT_MODULE           (2)
+#define PON_ISR_MODULE            (3)
+#define PON_ISR_INT_MODULE        (3 | (ONU_PON_ISR_INT_ATTR   << MODULE_SHIFT))
+#define PON_ISR_MISS_MODULE       (3 | (ONU_PON_ISR_MISS_ATTR  << MODULE_SHIFT))
+#define PON_ISR_STATE_MODULE      (3 | (ONU_PON_ISR_STATE_ATTR << MODULE_SHIFT))
+#define PON_ISR_RAND_MODULE       (3 | (ONU_PON_ISR_RAND_ATTR  << MODULE_SHIFT))
+#define PON_CLI_MODULE            (4)
+#define PON_MNG_MODULE            (5)
+#define PON_MNG_DBA_MODULE        (5 | (ONU_PON_MNG_DBA_ATTR      << MODULE_SHIFT))
+#define PON_MNG_SILENCE_MODULE    (5 | (ONU_PON_MNG_SILENCE_ATTR  << MODULE_SHIFT))
+#define PON_MNG_MAC_ADDR_MODULE   (5 | (ONU_PON_MNG_MAC_ADDR_ATTR << MODULE_SHIFT))
+#define PON_MNG_OAM_TX_MODULE     (5 | (ONU_PON_MNG_OAM_TX_ATTR   << MODULE_SHIFT))
+#define PON_MNG_DBA_WA_MODULE     (5 | (ONU_PON_MNG_DBA_WA_ATTR   << MODULE_SHIFT))
+#define PON_MNG_DBA_FEC_MODULE    (5 | (ONU_PON_MNG_DBA_FEC_ATTR  << MODULE_SHIFT))
+#define PON_MNG_DBA_TS_MODULE     (5 | (ONU_PON_MNG_DBA_TS_ATTR   << MODULE_SHIFT))
+#define PON_SM_MODULE             (6)
+#define PON_SM_DEBUG_MODULE       (6 | (ONU_PON_SM_DEBUG_ATTR << MODULE_SHIFT))
+#define PON_SM_STATE_MODULE       (6 | (ONU_PON_SM_STATE_ATTR << MODULE_SHIFT))
+#define PON_SM_AES_MODULE         (6 | (ONU_PON_SM_AES_ATTR   << MODULE_SHIFT))
+#define PON_SM_ALLOC_MODULE       (6 | (ONU_PON_SM_ALLOC_ATTR << MODULE_SHIFT))
+#define PON_SM_OMCC_MODULE        (6 | (ONU_PON_SM_OMCC_ATTR  << MODULE_SHIFT))
+#define PON_SM_TIMER_MODULE       (6 | (ONU_PON_SM_TIMER_ATTR << MODULE_SHIFT))
+#define PON_SM_ALARM_MODULE       (6 | (ONU_PON_SM_ALARM_ATTR << MODULE_SHIFT))
+#define PON_PM_MODULE             (7)
+#define PON_ALARM_MODULE          (8)
+#define PON_BER_MODULE            (9)
+#define PON_API_MODULE            (10)
+#define PON_ALLOC_MODULE          (11)
+#define PON_DB_MODULE             (12)
+#define PON_LAST_MODULE           (13)
+
+/* Timers Definitions */
+#define ONU_PON_TIMER_T01_INTERVAL           (10000)    /* 10 sec */
+#define ONU_PON_TIMER_T02_INTERVAL           (100)      /* 100 msec */
+#define ONU_PON_TIMER_FIFO_AUDIT_INTERVAL    (20)       /* 20 msec */
+#define ONU_PON_TIMER_PM_INTERVAL            (1000)     /* 1 sec */
+#define ONU_PON_TIMER_PEE_INTERVAL           (3000)     /* 3 sec */
+#define ONU_PON_TIMER_PON_EVT_CLEAN_INTERVAL (5000)     /* 5 sec */
+#define ONU_PON_TIMER_XVR_RST_INTERVAL       (4)        /* 4 msec */
+#define ONU_PON_TIMER_MPCP_INTERVAL          (1000)     /* 1 sec */
+#define ONU_PON_TIMER_RPRT_INTERVAL          (1)        /* 1 msec */
+#define ONU_PON_TIMER_HOLDOVER_INTERVAL      (200)      /* 200 msec */
+#define ONU_PON_TIMER_MAX_SLEEP_INTERVAL     (60000)    /* 60 sec */
+#define ONU_PON_TIMER_SLEEP_DURATION         (500)      /* 0.5 sec */
+#define ONU_PON_TIMER_WAKEUP_DURATION        (500)      /* 0.5 sec */
+#define ONU_PON_TIMER_SILENCE_INTERVAL       (60000)    /* 60 sec */
+#define ONU_PON_TIMER_EVENT_MISS_INTERVAL    (10)       /* 10 msec */
+#define ONU_PON_TIMER_TX_PWR_INTERVAL        (6000)     /* 1 sec */
+#define ONU_PON_TIMER_POPUP_WA_INTERVAL      (50)       /* 50 msec */
+#define ONU_PON_TIMER_HW_DBA_OAM_TX_INTERVAL (1000)     /* 1   sec  */
+#define ONU_PON_TIMER_HW_DBA_OAM_TX_FAST     (10)       /* 10  msec */
+
+#define ONU_PON_TIMER_ACTIVE                 (1)
+#define ONU_PON_TIMER_NOT_ACTIVE             (0)
+
+#define PON_EVENT_PAYLOAD_MAX_LEN            (64)
+#define PARAM_MAX_LEN                        (20)
+
+#define PON_IF_ERROR(module, ret, format, ...)									\
+	if (ret) {												\
+		mvPonPrint(PON_PRINT_ERROR, module,								\
+			   "(error) %s(%d)(rc=%d):  " format, __func__, __LINE__, ret, ## __VA_ARGS__);		\
+		return ret;											 \
+	}
+
+#define PON_IF_NULL(module, ptr)										\
+	if (ptr == NULL) {											\
+		mvPonPrint(PON_PRINT_ERROR, module, " recvd NULL pointer\n");					\
+		return MV_FAIL;										 \
+	}
+
+#define PON_IF_EQUAL(module, var, expect, format, ...) \
+	if (var == expect) { \
+		mvPonPrint(PON_PRINT_ERROR, module, "%s(%d) (var=%d): " format, \
+		__func__, __LINE__, var, ## __VA_ARGS__); \
+		return MV_BAD_VALUE; \
+	}
+
+#define PON_IF_NOT_EQUAL(module, var, expect, format, ...) \
+	if (var != expect) { \
+		mvPonPrint(PON_PRINT_ERROR, module, "%s(%d) (var!=%d): " format, \
+		__func__, __LINE__, var, ## __VA_ARGS__); \
+		return MV_BAD_VALUE; \
+	}
+
+#define PON_IF_NULL_NO_RET(module, ptr)	\
+	if (ptr == NULL) { \
+		mvPonPrint(PON_PRINT_ERROR, module, "%s(%d) NULL pointer \n", __func__, __LINE__); \
+		return;	\
+	}
+
+#define PON_DECIMAL_RANGE_VALIDATE(module, value, min, max) { \
+		if (((value) > (max)) || ((value) < (min))) { \
+			mvPonPrint(PON_PRINT_ERROR, module, \
+				   "(error) %s(%d) value (%d/0x%x) is out of range[%d, %d]\n", \
+				   __func__, __LINE__, (value), (value), (min), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_HEX_RANGE_VALIDATE(module, value, min, max) { \
+		if (((value) > (max)) || ((value) < (min))) { \
+			mvPonPrint(PON_PRINT_ERROR, module, \
+			"(error) %s(%d) value(%d/0x%x) is out of range[0x%X, 0x%X]\n", \
+				   __func__, __LINE__, (value), (value), (min), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_DECIMAL_RANGE_VALIDATE_STR(module, value, min, max, str) { \
+		if (((value) > (max)) || ((value) < (min))) { \
+			mvPonPrint(PON_PRINT_ERROR, module, "(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n", \
+				   __func__, __LINE__, (str), (value), (value), (min), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_HEX_RANGE_VALIDATE_STR(module, value, min, max, str) { \
+		if (((value) > (max)) || ((value) < (min))) { \
+			mvPonPrint(PON_PRINT_ERROR, module, "(error) %s(%d) %s(%d/0x%x), out of range[0x%X, 0x%X]\n", \
+				   __func__, __LINE__, (str), (value), (value), (min), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_BIT_RANGE_VALIDATE(module, value, str) { \
+		if (((value) != (0)) || ((value) != (1))) { \
+			mvPonPrint(PON_PRINT_ERROR, module, "(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n", \
+				   __func__, __LINE__, (str), (value), (value), (0), (1)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_POS_RANGE_VALIDATE(module, value, max, str) { \
+		if ((value) > (max)) { \
+			mvPonPrint(PON_PRINT_ERROR, module, "(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n", \
+				   __func__, __LINE__, (str), (value), (value), (0), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+
+#define PON_POS_HEX_RANGE_VALIDATE(module, value, max, str) { \
+		if ((value) > (max)) { \
+			mvPonPrint(PON_PRINT_ERROR, module, "(error) %s(%d) %s(%d/0x%x), out of range[0x%X, 0x%X]\n", \
+				   __func__, __LINE__, (str), (value), (value), (0), (max)); \
+			return MV_BAD_VALUE; \
+		} \
+}
+#define MV_BOOL_TO_INT(var) ((var == MV_TRUE) ? 1 : 0)
+#define INT_TO_MV_BOOL(var) ((var != 0) ? MV_TRUE : MV_FALSE)
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+typedef enum {
+	E_PON_PARAM_DISABLE_GPON_SN = 0,
+	E_PON_PARAM_LAST
+} E_PonCfgParam;
+
+typedef enum {
+	E_PON_EVENT_ID_SAVE_PARAM = 0,
+	E_GPON_EVENT_ID_OMCI_SYNC,
+	E_GPON_EVENT_ID_DYING_GASP,
+	E_GPON_EVENT_ID_OMCI_MSG,
+	E_PON_EVENT_MAX
+} E_PonEventId;
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+typedef void (*PTIMER_FUNCPTR)(unsigned long data);
+typedef void (*STATUSNOTIFYFUNC)(MV_U32 status);
+typedef void (*DYINGGASPFUNC)(void);
+typedef void (*LINKSTATUSFUNC)(int port_id, MV_BOOL state);
+typedef void (*DATAFORWARDFUNC)(MV_U32 tcont, MV_BOOL state);
+
+typedef struct {
+	E_PonEventId eventId;
+	unsigned char payload[PON_EVENT_PAYLOAD_MAX_LEN];
+} S_PonEventInfo;
+
+typedef struct {
+	E_PonCfgParam paramIndex;
+	unsigned char paramValue[PARAM_MAX_LEN];
+} S_PonEventParamPayload;
+
+/* Work queue for PON events */
+#define PON_EVENT_QUEUE_SIZE 64
+
+typedef struct {
+	S_PonEventInfo ponEventQueue[PON_EVENT_QUEUE_SIZE];
+	uint32_t queueHead;
+	uint32_t queueTail;
+	uint32_t queueLen;
+	spinlock_t queueLock;
+} S_PonEventQueue;
+
+/* Timer Id */
+typedef struct {
+	struct timer_list onuPonTimerId;
+	PTIMER_FUNCPTR onuPonTimerFunc;
+	MV_U32 onuPonTimerActive;
+	MV_U32 onuPonTimerInterval;
+	MV_U32 onuPonTimerPeriodic;
+} S_OnuPonTimer;
+
+/* Interrupt */
+typedef struct {
+	int onuPonIrqNum;
+	int onuDgIrqNum;
+	spinlock_t onuPonIrqLock;
+	struct tasklet_struct onuPonTasklet;
+} S_onuPonIrq;
+
+/* Work queue */
+typedef struct {
+	struct work_struct ponWork;
+	int action;
+	int param;
+} S_onuPonWork;
+
+typedef struct {
+	struct workqueue_struct *ponWq;
+} S_onuPonWorkQueue;
+/* ONU GPON resource table */
+typedef struct {
+	/* Timer */
+	S_OnuPonTimer onuGponT01_TimerId;               /* ONU GPON T01 timer */
+	S_OnuPonTimer onuGponT02_TimerId;               /* ONU GPON T02 timer */
+	S_OnuPonTimer onuGponPeeTimerId;                /* ONU GPON PEE timer */
+	S_OnuPonTimer onuPonSwFIFOTimerId;              /* ONU GPON SW FIFO timer */
+	S_OnuPonTimer onuGponPopupWaTimerId;            /* ONU GPON POPUP WA timer */
+
+	S_OnuPonTimer onuPonMpcpTimerId;                /* ONU EPON MPCP timer */
+	S_OnuPonTimer onuPonHwRprtTxModTimerId;         /* ONU EPON Tx Module timer */
+	S_OnuPonTimer onuPonIsrMissTimerId;             /* ONU EPON ISR Miss timer */
+	S_OnuPonTimer onuPonIsrOamTxHwDbaTimerId;       /* ONU EPON HW DBA Tx OAM timer */
+	S_OnuPonTimer onuPonHoldoverTimerId;            /* ONU EPON Holdover timer */
+	S_OnuPonTimer onuPonSilenceTimerId[8];          /* ONU EPON Silence timer */
+
+	S_OnuPonTimer onuPonTxPwrTimerId;               /* ONU PON TX Power timer */
+	S_OnuPonTimer onuPonPmTimerId;                  /* ONU PON PM timer */
+	S_OnuPonTimer onuPonPatternBurstTimerId;        /* ONU PON Pattern Burst timer */
+
+	S_OnuPonTimer onuEponTxControlTimerId;          /* EPON tx_control delay timer */
+	S_OnuPonTimer onuEponMaxSleepTimerId;           /* EPON power_saving mode: max sleep duration timer */
+	S_OnuPonTimer onuEponSleepDurationTimerId; /* EPON power_saving mode: sleep duration and wait duration timer */
+
+	S_OnuPonTimer onuPonIsrXvrRstTimerId;     /* ONU PON XVR Reset timer */
+
+	/* Interrupt */
+	S_onuPonIrq onuPonIrqId;
+} S_OnuPonResourceTbl;
+
+/* Printing Options */
+typedef struct {
+	MV_U32 modulePrintLevel;        /* Severity printing level per module */
+	MV_U32 moduleOptions;           /* Optional module printing options */
+} S_PonModulePrint;
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+extern S_OnuPonResourceTbl onuPonResourceTbl_s;
+extern spinlock_t onuPonIrqLock;
+
+extern S_PonEventInfo gPonEventInfo;
+extern MV_BOOL gPonEventOccurred;
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+/* Init API */
+extern MV_STATUS onuPonRtosResourceInit(void);
+
+/* Timer API */
+extern MV_STATUS onuPonTimerCreate(S_OnuPonTimer *timerId,
+				   MV_U8         *timerDesc,
+				   PTIMER_FUNCPTR timerFunc,
+				   MV_U32 timerParam,
+				   MV_U32 timerInterval,
+				   MV_U32 timerPeriodic);
+extern int       onuPonTimerUpdate(S_OnuPonTimer *timerId,
+				   MV_U32 data,
+				   MV_U32 interval,
+				   MV_U32 state);
+extern int       onuPonTimerEnable(S_OnuPonTimer *timerId);
+extern int       onuPonTimerDisable(S_OnuPonTimer *timerId);
+
+/* Memory API */
+extern MV_STATUS ponOnuGlbAddrInit(void);
+extern void*     onuPonMemAlloc(unsigned int size);
+extern void      onuPonMemRelease(void);
+
+/* Interrupt API */
+MV_STATUS onuPonIrqInit(void);
+
+extern MV_STATUS onuPonIrqNumInit(void);
+extern int       onuPonIrqEnable(S_onuPonIrq *irqId);
+extern int       onuPonIrqDisable(S_onuPonIrq *irqId);
+
+/* Printing API */
+extern MV_STATUS mvPonPrint(MV_U32 level, MV_U32 bitMask, const char *format, ...);
+extern MV_STATUS ponOnuCheckPrintStatus(MV_U32 printLevel, MV_U32 moduleOptions);
+extern MV_STATUS ponOnuChangePrintStatus(MV_U32 module, MV_U32 printLevel, MV_U32 moduleOptions);
+extern MV_STATUS ponOnuGetPrintStatus(MV_U32 module, MV_U32 *printLevel, MV_U32 *moduleOptions);
+extern int       ponOnuPrintStatus(char* buf);
+
+extern int       onuGponUiCfgPrbsUserPattern(char* buf);
+
+/* Configuration parameters handling */
+MV_STATUS ponOnuCfgParamSave(E_PonCfgParam param, unsigned char *value, unsigned int len);
+
+int onuPonEventSavingParamInfo(E_PonCfgParam param, unsigned char *value, unsigned int len);
+int onuPonEventOmciSyncInfo(void);
+int onuPonEventDyingGaspInfo(void);
+int onuPonEventOmciMsgSend(MV_U8 *msg);
+MV_STATUS onuPonEventInit(void);
+
+void ponEventQueueInit(void);
+int ponEventQueuePush(S_PonEventInfo *event);
+int ponEventQueuePull(S_PonEventInfo *event);
+MV_BOOL ponEventQueueIsEmpty(void);
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+#endif /* _ONU_PON_LINUX_KS_OS_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuRtos.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuRtos.h
new file mode 100644
index 0000000..b5bef6b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/plat/ponOnuRtos.h
@@ -0,0 +1,101 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  *   Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+
+  *   Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+  *   Neither the name of Marvell nor the names of its contributors may be
+      used to endorse or promote products derived from this software without
+      specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : ponOnuRtos.h                                               **
+**                                                                           **
+**  DESCRIPTION : This file contains ONU GPON Linux OS resources             **
+*******************************************************************************
+*                                                                             *
+*  MODIFICATION HISTORY:                                                      *
+*                                                                             *
+*   29Oct06  Oren Ben Hayun   created                                         *
+* =========================================================================== *
+******************************************************************************/
+#ifndef _ONU_GPON_RTOS_H
+#define _ONU_GPON_RTOS_H
+
+/* Include Files
+   ------------------------------------------------------------------------------*/
+#include "ponOnuLnxKsOs.h"
+
+/* Definitions
+   ------------------------------------------------------------------------------*/
+
+/* Enums
+   ------------------------------------------------------------------------------*/
+
+/* Typedefs
+   ------------------------------------------------------------------------------*/
+
+/* Global variables
+   ------------------------------------------------------------------------------*/
+
+/* Global functions
+   ------------------------------------------------------------------------------*/
+
+/* Macros
+   ------------------------------------------------------------------------------*/
+
+#endif /* _ONU_GPON_RTOS_H */
-- 
1.7.5.4

