From dd5548de39375914f15cd86abe7ace443a165e12 Mon Sep 17 00:00:00 2001
From: Neta Zur <neta@marvell.com>
Date: Mon, 22 Jul 2013 15:17:27 +0300
Subject: [PATCH 0875/1825] axp:SRAM: Add U-Boot command to init SRAM memory

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit cda656d7fd986000ed184eccd28647e126e0d1c1

	The init SRAM commands do the following steps:
	- set lockdown registers
	- init the SRAM ways
	- open SRAM windows
	- Set L2$-SRAM WAs

Change-Id: I487c141fa2b6fd166e719504c7706a06f3101a1c
Signed-off-by: Neta Zur <neta@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2788
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-by: Eli Nidam <elini@marvell.com>
Tested-by: Eli Nidam <elini@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.c        |  102 ++++++++++++++++++++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.h        |    1 +
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h |    1 +
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h     |    5 +
 4 files changed, 109 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
index 0703e8a..0e1a104 100755
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -2163,5 +2163,107 @@ MV_U32 mvCtrlGetJuncTemp(MV_VOID)
 	return (3153000 - (10000 * reg)) / 13825;
 }
 
+/*******************************************************************************
+* mvCtrlSramInit
+*
+* DESCRIPTION:
+*	Init SRAM memory:
+*	- set lockdown registers
+*	- init the SRAM ways
+*	- open SRAM windows
+*	- Set L2$-SRAM WAs
+*
+* INPUT:
+*       regs_base_address - Internal Registers Base Address
+*				(to support init of other CPUs' SRAM)
+*	sram_base         - SRAM base address
+*	ways_num          - number of SRAM ways to init, allocate the ways from
+*				the end od the SRAM.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Status
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSramInit(MV_U32 baseAddr, MV_U32 sramBase, MV_U32 waysNum)
+{
+	MV_U32 sramTotalWaysNum;
+	MV_U32 leftWaysNum;
+	MV_U32 firstWay;
+	MV_U32 cpu;
+	MV_U32 i;
+	MV_U32 temp;
+
+	/* get the number of L2 ways */
+	sramTotalWaysNum = (4 << ((MV_MEMIO32_READ(baseAddr | CPU_L2_AUX_CTRL_REG)
+					& CL2ACR_L2_SIZE_MASK) >> CL2ACR_L2_SIZE_OFFS));
 
+	if (sramTotalWaysNum < waysNum)
+		waysNum = sramTotalWaysNum;
+
+	/* use the upper ways for SRAM */
+	firstWay = (sramTotalWaysNum - waysNum);
+
+	/* Configure CPUs Data Lockdown */
+	temp = ((1 << waysNum) - 1) << firstWay;
+
+	for (cpu = 0; cpu < mvCtrlGetCpuNum(); cpu++) {
+		MV_MEMIO32_WRITE((baseAddr | CPU_L2_DATA_LOCKDOWN_REG(cpu)), temp);
+		MV_MEMIO32_WRITE((baseAddr | CPU_L2_INSTRUCTION_LOCKDOWN_REG(cpu)), temp);
+	}
+
+	MV_MEMIO32_WRITE(baseAddr | CPU_IO_BRIDGE_LOCKDOWN_REG, temp);
+
+	/* Configure L2 upper ways to be SRAM */
+	for (i = 0; i < waysNum; i++) {
+		/* set current way as SRAM and set the way base address */
+		MV_MEMIO32_WRITE((baseAddr | CPU_L2_BLOCK_ALLOCATION_REG),
+				(sramBase | (i * _64K) | (i + firstWay)));
+
+		if ((i % SRAMWCR_MAX_WIN_WAYS) == 0) {
+			/* Open the SRAM windows, each SRAM window covers up to 8 ways */
+			leftWaysNum = waysNum - i;
+			if (leftWaysNum <= SRAMWCR_MAX_WIN_WAYS) {
+				temp = leftWaysNum;
+				leftWaysNum = 0;
+
+				/* calculate the window real size */
+				if (temp >= 5) {
+					/* 256KB - 512KB */
+					temp = 8;
+				} else if (temp >= 3) {
+					/* 128KB - 256KB */
+					temp = 4;
+				}
+			} else {
+				temp = SRAMWCR_MAX_WIN_WAYS;
+			}
+
+			MV_MEMIO32_WRITE((baseAddr | SRAM_WIN_CTRL_REG(i / SRAMWCR_MAX_WIN_WAYS)),
+					((sramBase + (i * _64K)) |
+					 ((temp - 1) << SRAMWCR_SIZE_OFFS) |
+					 SRAMWCR_ENABLE));
+		}
+	}
+
+	/* disable the "Shared L2 Present" bit in CPU Configuration register.
+	   The "Shared L2 Present" bit affects the "level of coherence" value in the clidr CP15
+	   register. Cache operation functions such as "flush all" and "invalidate all"
+	   operate on all the cache levels that included in the defined level of coherence.
+	   When IOCC is enabled, this bit causes unnecessary flushes of the L2 cache. */
+	for (cpu = 0; cpu < mvCtrlGetCpuNum(); cpu++) {
+		MV_MEMIO32_WRITE((baseAddr | CPU_CONFIG_REG(cpu)),
+				(MV_MEMIO32_READ(baseAddr | CPU_CONFIG_REG(cpu)) &
+				 MV_32BIT_LE_FAST(~(1 << 16))));
+	}
+
+	/* Set point of coherence (PoC) to L2 - valid only when IOCC is enabled */
+	MV_MEMIO32_WRITE((baseAddr | SOC_CFU_CFG_REG),
+			(MV_MEMIO32_READ(baseAddr | SOC_CFU_CFG_REG) &
+			 MV_32BIT_LE_FAST(~(1 << 17))));
+
+	return MV_OK;
+}
 
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
index 65c7fc0..a3326a9 100755
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -275,5 +275,6 @@ MV_U32 mvCtrlDDRBudWidth(MV_VOID);
 MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
 MV_BOOL mvCtrlDDRECC(MV_VOID);
 MV_U32 mvCtrlGetJuncTemp(MV_VOID);
+MV_STATUS mvCtrlSramInit(MV_U32 baseAddr, MV_U32 sramBase, MV_U32 waysNum);
 
 #endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
index 50fd816..185b1c7 100644
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -129,6 +129,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
 #define SRAMWCR_BASE_OFFS			16
 #define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+#define SRAMWCR_MAX_WIN_WAYS			8
 
 /**********************/
 /* MBUS BRIDGE WINDOW */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
index 5a3fd8d..0d96d82 100755
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -88,10 +88,15 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
 #define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
 #define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define CPU_L2_BLOCK_ALLOCATION_REG             (MV_L2C_REGS_BASE + 0x78c)
+#define CPU_L2_DATA_LOCKDOWN_REG(cpu)           (MV_L2C_REGS_BASE + 0x900 + (cpu)*0x8)
+#define CPU_L2_INSTRUCTION_LOCKDOWN_REG(cpu)    (MV_L2C_REGS_BASE + 0x904 + (cpu)*0x8)
+#define CPU_IO_BRIDGE_LOCKDOWN_REG              (MV_L2C_REGS_BASE + 0x984)
 #define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
 #define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
 #define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
 #define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CFU_CFG_REG                                (MV_COHERENCY_FABRIC_REGS_BASE + 0x28)
 #define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
 #define CFU_CFG_REG				(MV_COHERENCY_FABRIC_REGS_BASE + 0x28)
 
-- 
1.7.5.4

