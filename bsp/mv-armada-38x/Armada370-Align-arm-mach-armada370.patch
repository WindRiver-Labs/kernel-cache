From bcd4bbde754545daed8efe7fb875084cc37b0377 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Wed, 24 Oct 2012 10:40:49 +0200
Subject: [PATCH 0274/1825] Armada370: Align arm/mach-armada370.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4acf7e1245bbaf9289d4fda178e044589cb14698

Change-Id: I10a44f9a7eda1cc9c421b82ed1b846bc4e16711f
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/armada370_defconfig               |  334 +++++
 arch/arm/mach-armada370/Kconfig                    |   13 +
 arch/arm/mach-armada370/Makefile                   |  212 +++
 arch/arm/mach-armada370/Makefile.boot              |    3 +
 arch/arm/mach-armada370/clock.c                    |   50 +
 arch/arm/mach-armada370/clock.h                    |    5 +
 arch/arm/mach-armada370/config/mvRules.mk          |  179 +++
 arch/arm/mach-armada370/config/mvSysAudioConfig.h  |   42 +
 arch/arm/mach-armada370/config/mvSysCesaConfig.h   |   45 +
 arch/arm/mach-armada370/config/mvSysCntmrConfig.h  |   36 +
 arch/arm/mach-armada370/config/mvSysDdrConfig.h    |   44 +
 arch/arm/mach-armada370/config/mvSysEthConfig.h    |  151 +++
 arch/arm/mach-armada370/config/mvSysEthPhyConfig.h |   31 +
 arch/arm/mach-armada370/config/mvSysGppConfig.h    |   37 +
 arch/arm/mach-armada370/config/mvSysHwConfig.h     |  226 ++++
 arch/arm/mach-armada370/config/mvSysNfcConfig.h    |   36 +
 arch/arm/mach-armada370/config/mvSysPciConfig.h    |   25 +
 arch/arm/mach-armada370/config/mvSysPexConfig.h    |   53 +
 arch/arm/mach-armada370/config/mvSysPonConfig.h    |   37 +
 arch/arm/mach-armada370/config/mvSysRtcConfig.h    |   36 +
 arch/arm/mach-armada370/config/mvSysSataConfig.h   |   36 +
 arch/arm/mach-armada370/config/mvSysSdmmcConfig.h  |   36 +
 arch/arm/mach-armada370/config/mvSysSpiConfig.h    |   36 +
 arch/arm/mach-armada370/config/mvSysTdmConfig.h    |  119 ++
 arch/arm/mach-armada370/config/mvSysTsConfig.h     |   37 +
 arch/arm/mach-armada370/config/mvSysTwsiConfig.h   |   35 +
 arch/arm/mach-armada370/config/mvSysUsbConfig.h    |   36 +
 arch/arm/mach-armada370/config/mvSysXorConfig.h    |   36 +
 arch/arm/mach-armada370/core.c                     | 1269 +++++++++++++++++
 arch/arm/mach-armada370/dbg-trace.c                |  111 ++
 arch/arm/mach-armada370/dbg-trace.h                |   24 +
 arch/arm/mach-armada370/dump_cp15_regs.c           |  218 +++
 arch/arm/mach-armada370/export.c                   |  203 +++
 arch/arm/mach-armada370/flashmap.c                 |  274 ++++
 arch/arm/mach-armada370/hwmon.c                    |  343 +++++
 arch/arm/mach-armada370/include/mach/armada370.h   |  146 ++
 arch/arm/mach-armada370/include/mach/clkdev.h      |    7 +
 arch/arm/mach-armada370/include/mach/debug-macro.S |   29 +
 arch/arm/mach-armada370/include/mach/dma.h         |   16 +
 arch/arm/mach-armada370/include/mach/entry-macro.S |  145 ++
 arch/arm/mach-armada370/include/mach/gpio.h        |   55 +
 arch/arm/mach-armada370/include/mach/hardware.h    |   14 +
 arch/arm/mach-armada370/include/mach/ide.h         |   15 +
 arch/arm/mach-armada370/include/mach/io.h          |   32 +
 arch/arm/mach-armada370/include/mach/irqs.h        |  153 +++
 arch/arm/mach-armada370/include/mach/kw_macro.h    |   39 +
 arch/arm/mach-armada370/include/mach/memory.h      |   32 +
 arch/arm/mach-armada370/include/mach/param.h       |   15 +
 arch/arm/mach-armada370/include/mach/serial.h      |   40 +
 arch/arm/mach-armada370/include/mach/smp.h         |   29 +
 arch/arm/mach-armada370/include/mach/system.h      |   37 +
 arch/arm/mach-armada370/include/mach/timex.h       |    9 +
 arch/arm/mach-armada370/include/mach/uncompress.h  |  133 ++
 arch/arm/mach-armada370/include/mach/vmalloc.h     |   10 +
 arch/arm/mach-armada370/irq.c                      |  160 +++
 arch/arm/mach-armada370/leds.c                     |   49 +
 arch/arm/mach-armada370/mpp.h                      |   34 +
 arch/arm/mach-armada370/mv_hal_if/mvSysAudio.c     |  175 +++
 arch/arm/mach-armada370/mv_hal_if/mvSysAudioApi.h  |   72 +
 arch/arm/mach-armada370/mv_hal_if/mvSysCesa.c      |  122 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysCesaApi.h   |   71 +
 arch/arm/mach-armada370/mv_hal_if/mvSysDdr.c       |  133 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysEth.c       |  131 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysEthApi.h    |   71 +
 arch/arm/mach-armada370/mv_hal_if/mvSysEthPhy.c    |  104 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysEthPhyApi.h |   71 +
 arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c      |  149 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysNetaApi.h   |   71 +
 arch/arm/mach-armada370/mv_hal_if/mvSysPci.c       | 1422 ++++++++++++++++++++
 arch/arm/mach-armada370/mv_hal_if/mvSysPci.h       |  256 ++++
 arch/arm/mach-armada370/mv_hal_if/mvSysPex.c       |  128 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysPexApi.h    |   71 +
 arch/arm/mach-armada370/mv_hal_if/mvSysSFlash.c    |  225 +++
 arch/arm/mach-armada370/mv_hal_if/mvSysSata.c      |   81 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysSataApi.h   |   70 +
 arch/arm/mach-armada370/mv_hal_if/mvSysSpi.c       |  125 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysSpiApi.h    |   70 +
 arch/arm/mach-armada370/mv_hal_if/mvSysTdm.c       |  245 ++++
 arch/arm/mach-armada370/mv_hal_if/mvSysTdmApi.h    |   78 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysTs.c        |   86 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysTsApi.h     |   73 +
 arch/arm/mach-armada370/mv_hal_if/mvSysTwsi.c      |  136 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysUsb.c       |  105 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysUsbApi.h    |   70 +
 arch/arm/mach-armada370/mv_hal_if/mvSysXor.c       |   85 ++
 arch/arm/mach-armada370/mv_hal_if/mvSysXorApi.h    |   70 +
 arch/arm/mach-armada370/pci.c                      |  242 ++++
 arch/arm/mach-armada370/pex.c                      |  399 ++++++
 arch/arm/mach-armada370/proc_aurora_dbg.c          |   87 ++
 arch/arm/mach-armada370/sysmap.c                   |  167 +++
 arch/arm/mach-armada370/time.c                     |  244 ++++
 arch/arm/mach-armada370/usb.c                      |  158 +++
 92 files changed, 11470 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/configs/armada370_defconfig
 create mode 100644 arch/arm/mach-armada370/Kconfig
 create mode 100644 arch/arm/mach-armada370/Makefile
 create mode 100644 arch/arm/mach-armada370/Makefile.boot
 create mode 100644 arch/arm/mach-armada370/clock.c
 create mode 100644 arch/arm/mach-armada370/clock.h
 create mode 100644 arch/arm/mach-armada370/config/mvRules.mk
 create mode 100644 arch/arm/mach-armada370/config/mvSysAudioConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysCesaConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysCntmrConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysDdrConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysEthConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysEthPhyConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysGppConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysNfcConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysPciConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysPexConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysPonConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysRtcConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysSataConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysSdmmcConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysSpiConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysTdmConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysTsConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysTwsiConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysUsbConfig.h
 create mode 100644 arch/arm/mach-armada370/config/mvSysXorConfig.h
 create mode 100644 arch/arm/mach-armada370/core.c
 create mode 100644 arch/arm/mach-armada370/dbg-trace.c
 create mode 100644 arch/arm/mach-armada370/dbg-trace.h
 create mode 100644 arch/arm/mach-armada370/dump_cp15_regs.c
 create mode 100644 arch/arm/mach-armada370/export.c
 create mode 100644 arch/arm/mach-armada370/flashmap.c
 create mode 100644 arch/arm/mach-armada370/hwmon.c
 create mode 100644 arch/arm/mach-armada370/include/mach/armada370.h
 create mode 100644 arch/arm/mach-armada370/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-armada370/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-armada370/include/mach/dma.h
 create mode 100644 arch/arm/mach-armada370/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-armada370/include/mach/gpio.h
 create mode 100644 arch/arm/mach-armada370/include/mach/hardware.h
 create mode 100644 arch/arm/mach-armada370/include/mach/ide.h
 create mode 100644 arch/arm/mach-armada370/include/mach/io.h
 create mode 100644 arch/arm/mach-armada370/include/mach/irqs.h
 create mode 100644 arch/arm/mach-armada370/include/mach/kw_macro.h
 create mode 100644 arch/arm/mach-armada370/include/mach/memory.h
 create mode 100644 arch/arm/mach-armada370/include/mach/param.h
 create mode 100644 arch/arm/mach-armada370/include/mach/serial.h
 create mode 100644 arch/arm/mach-armada370/include/mach/smp.h
 create mode 100644 arch/arm/mach-armada370/include/mach/system.h
 create mode 100644 arch/arm/mach-armada370/include/mach/timex.h
 create mode 100644 arch/arm/mach-armada370/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-armada370/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-armada370/irq.c
 create mode 100644 arch/arm/mach-armada370/leds.c
 create mode 100644 arch/arm/mach-armada370/mpp.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysAudio.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysAudioApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysCesa.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysCesaApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysDdr.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysEth.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysEthApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysEthPhy.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysEthPhyApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysNetaApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysPci.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysPci.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysPex.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysPexApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysSFlash.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysSata.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysSataApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysSpi.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysSpiApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysTdm.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysTdmApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysTs.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysTsApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysTwsi.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysUsb.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysUsbApi.h
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysXor.c
 create mode 100644 arch/arm/mach-armada370/mv_hal_if/mvSysXorApi.h
 create mode 100644 arch/arm/mach-armada370/pci.c
 create mode 100644 arch/arm/mach-armada370/pex.c
 create mode 100644 arch/arm/mach-armada370/proc_aurora_dbg.c
 create mode 100644 arch/arm/mach-armada370/sysmap.c
 create mode 100644 arch/arm/mach-armada370/time.c
 create mode 100644 arch/arm/mach-armada370/usb.c

diff --git a/arch/arm/configs/armada370_defconfig b/arch/arm/configs/armada370_defconfig
new file mode 100644
index 0000000..00ecdb9
--- /dev/null
+++ b/arch/arm/configs/armada370_defconfig
@@ -0,0 +1,334 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_ARMADA370=y
+CONFIG_ARMADA370=y
+# CONFIG_MV_INCLUDE_LEGACY_NAND is not set
+# CONFIG_MV_INCLUDE_SWITCH is not set
+CONFIG_MV_PMU_PROC=y
+CONFIG_MV_ETH_NETA=y
+CONFIG_MV_ETH_PORTS_NUM=2
+CONFIG_MV_ETH_RXQ=8
+CONFIG_MV_ETH_TXQ=8
+CONFIG_NET_SKB_HEADROOM=96
+# CONFIG_MV_ETH_BM is not set
+# CONFIG_MV_ETH_PNC is not set
+CONFIG_MV_ETH_GRO_DEF=y
+CONFIG_MV_ETH_TSO_DEF=y
+# CONFIG_MV_ETH_STAT_INF is not set
+CONFIG_MV_ETH_RX_DESC_PREFETCH=y
+CONFIG_MV_ETH_RX_PKT_PREFETCH=y
+# CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA is not set
+CONFIG_MV_CESA_OCF=y
+CONFIG_MV_OCF_OCF=y
+CONFIG_MV_OCF_CRYPTODEV=y
+CONFIG_MV_CESA_TOOL=y
+CONFIG_MV_CESA_CHANNELS=1
+CONFIG_MV_CESA_CHAIN_MODE=y
+CONFIG_CPU_SHEEVA_PJ4B_V7=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
+CONFIG_SHEEVA_DEEP_IDLE=y
+CONFIG_STANDBY_UART_WAKE=y
+CONFIG_PCI_DEBUG=y
+CONFIG_NO_HZ=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_ADVANCED is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_FTP=y
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_MANGLE is not set
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_TARGET_LOG is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_MANGLE is not set
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_NET_PKTGEN=m
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=m
+CONFIG_CHR_DEV_SG=m
+CONFIG_ATA=y
+CONFIG_SATA_MV=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_E100=y
+CONFIG_E1000E=y
+CONFIG_SKY2=y
+CONFIG_PHYLIB=y
+# CONFIG_PPP=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MV64XXX=y
+CONFIG_SPI=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_SENSORS_JC42=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_USB=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_PRINTER=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_TEST=m
+CONFIG_MMC=y
+CONFIG_MMC_MVSDIO=y
+CONFIG_NEW_LEDS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_MV=y
+CONFIG_DMADEVICES=y
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_MV_XOR=y
+CONFIG_DMA_ENGINE=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+CONFIG_XFS_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_ROOT_NFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_UTF8=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_FTRACE is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRC_CCITT=y
+CONFIG_LIBCRC32C=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_PCI=y
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_SOC=y
+CONFIG_SND_KIRKWOOD_SOC=y
+CONFIG_SND_KIRKWOOD_SOC_I2S=y
+CONFIG_SND_ARMADA370_SOC=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_ALL_CODECS=y
+CONFIG_SND_SOC_WM_HUBS=y
+CONFIG_SND_SOC_AD1836=y
+CONFIG_SND_SOC_AD193X=y
+CONFIG_SND_SOC_AD73311=y
+CONFIG_SND_SOC_ADAU1373=y
+CONFIG_SND_SOC_ADAV80X=y
+CONFIG_SND_SOC_ADS117X=y
+CONFIG_SND_SOC_AK4104=y
+CONFIG_SND_SOC_AK4535=y
+CONFIG_SND_SOC_AK4641=y
+CONFIG_SND_SOC_AK4642=y
+CONFIG_SND_SOC_AK4671=y
+CONFIG_SND_SOC_ALC5623=y
+CONFIG_SND_SOC_CS42L51=y
+CONFIG_SND_SOC_CS4270=y
+CONFIG_SND_SOC_CS4271=y
+CONFIG_SND_SOC_CX20442=y
+CONFIG_SND_SOC_JZ4740_CODEC=y
+CONFIG_SND_SOC_L3=y
+CONFIG_SND_SOC_DA7210=y
+CONFIG_SND_SOC_DFBMCS320=y
+CONFIG_SND_SOC_MAX98088=y
+CONFIG_SND_SOC_MAX98095=y
+CONFIG_SND_SOC_MAX9850=y
+CONFIG_SND_SOC_PCM3008=y
+CONFIG_SND_SOC_RT5631=y
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SOC_SSM2602=y
+CONFIG_SND_SOC_STA32X=y
+CONFIG_SND_SOC_TLV320AIC23=y
+CONFIG_SND_SOC_TLV320AIC26=y
+CONFIG_SND_SOC_TLV320AIC32X4=y
+CONFIG_SND_SOC_TLV320AIC3X=y
+CONFIG_SND_SOC_TLV320DAC33=y
+CONFIG_SND_SOC_UDA134X=y
+CONFIG_SND_SOC_UDA1380=y
+CONFIG_SND_SOC_WM1250_EV1=y
+CONFIG_SND_SOC_WM5100=y
+CONFIG_SND_SOC_WM8510=y
+CONFIG_SND_SOC_WM8523=y
+CONFIG_SND_SOC_WM8580=y
+CONFIG_SND_SOC_WM8711=y
+CONFIG_SND_SOC_WM8727=y
+CONFIG_SND_SOC_WM8728=y
+CONFIG_SND_SOC_WM8731=y
+CONFIG_SND_SOC_WM8737=y
+CONFIG_SND_SOC_WM8741=y
+CONFIG_SND_SOC_WM8750=y
+CONFIG_SND_SOC_WM8753=y
+CONFIG_SND_SOC_WM8770=y
+CONFIG_SND_SOC_WM8776=y
+CONFIG_SND_SOC_WM8782=y
+CONFIG_SND_SOC_WM8804=y
+CONFIG_SND_SOC_WM8900=y
+CONFIG_SND_SOC_WM8903=y
+CONFIG_SND_SOC_WM8904=y
+CONFIG_SND_SOC_WM8940=y
+CONFIG_SND_SOC_WM8955=y
+CONFIG_SND_SOC_WM8960=y
+CONFIG_SND_SOC_WM8961=y
+CONFIG_SND_SOC_WM8962=y
+CONFIG_SND_SOC_WM8971=y
+CONFIG_SND_SOC_WM8974=y
+CONFIG_SND_SOC_WM8978=y
+CONFIG_SND_SOC_WM8983=y
+CONFIG_SND_SOC_WM8985=y
+CONFIG_SND_SOC_WM8988=y
+CONFIG_SND_SOC_WM8990=y
+CONFIG_SND_SOC_WM8991=y
+CONFIG_SND_SOC_WM8993=y
+CONFIG_SND_SOC_WM8995=y
+CONFIG_SND_SOC_WM8996=y
+CONFIG_SND_SOC_WM9081=y
+CONFIG_SND_SOC_LM4857=y
+CONFIG_SND_SOC_MAX9877=y
+CONFIG_SND_SOC_TPA6130A2=y
+CONFIG_SND_SOC_WM2000=y
+CONFIG_SND_SOC_WM9090=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
diff --git a/arch/arm/mach-armada370/Kconfig b/arch/arm/mach-armada370/Kconfig
new file mode 100644
index 0000000..88dcc30
--- /dev/null
+++ b/arch/arm/mach-armada370/Kconfig
@@ -0,0 +1,13 @@
+if ARCH_ARMADA370
+
+config ARMADA_370
+	bool "Armada-370 SoC Family"
+#	select ARMADA_XP_DEEP_IDLE_UNMASK_INTS_WA
+	select SHEEVA_ERRATA_ARM_CPU_5114 if (CPU_V6)
+	select SHEEVA_ERRATA_ARM_CPU_4742
+	select SHEEVA_ERRATA_ARM_CPU_4659
+	select SHEEVA_ERRATA_ARM_CPU_4611
+	select MACH_ARMADA_370
+	default y
+
+endif
diff --git a/arch/arm/mach-armada370/Makefile b/arch/arm/mach-armada370/Makefile
new file mode 100644
index 0000000..0b1dede
--- /dev/null
+++ b/arch/arm/mach-armada370/Makefile
@@ -0,0 +1,212 @@
+#*******************************************************************************
+# Marvell GPL License Option
+#
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
+# disclaimer.
+#*******************************************************************************/
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+ifdef CONFIG_MV_ETH_NFP
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o  $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o \
+		$(LSP_NET_DEV_DIR)/mv_eth_nfp.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_fib_arp_sysfs.o
+ifdef CONFIG_IPV6
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/ipv6_parsing.o $(LSP_NFP_MGR_DIR)/nfp_fib6_arp_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct_sysfs.o
+ifdef CONFIG_IPV6
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct6_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_classification_sysfs.o $(LSP_NFP_MGR_DIR)/nfp_exact_classification_sysfs.o \
+		   $(LSP_NFP_MGR_DIR)/nfp_prio_classification_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_bridge_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_VLAN
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_vlan_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_PPP
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ppp_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfp.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpCt.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+ifdef CONFIG_MV_ETH_NFP_FDB_MODE
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+else
+	NFPOBJS    += $(HAL_ETH_NFP_DIR)/mvNfpBridge.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFib.o
+endif
+
+ifeq ($(CONFIG_MV_ETH_NFP),m)
+nfp-objs = $(NFPOBJS)
+obj-m := nfp.o
+endif
+
+# Objects list
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_RTC_DIR)/mvRtc.o					\
+                  $(HAL_CNTMR_DIR)/mvCntmr.o					\
+		  $(HAL_TWSI_DIR)/mvTwsi.o $(HAL_IF_DIR)/mvSysTwsi.o		\
+                  $(HAL_UART_DIR)/mvUart.o $(HAL_GPP_DIR)/mvGpp.o               \
+                  $(HAL_DRAM_DIR)/mvDramIf.o  					\
+		  $(HAL_IF_DIR)/mvSysDdr.o
+
+ARMADA_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o $(SOC_ENV_DIR)/mvCtrlEnvLib.o	\
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
+		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
+		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o
+
+QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
+                  $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o	\
+                  $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o	\
+                  $(HAL_QD_DIR)/src/platform/gtDebug.o $(HAL_QD_DIR)/src/msapi/gtBrgFdb.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgStp.o $(HAL_QD_DIR)/src/msapi/gtBrgVlan.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtEvents.o $(HAL_QD_DIR)/src/msapi/gtPortCtrl.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtPortStat.o $(HAL_QD_DIR)/src/msapi/gtPortStatus.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtQosMap.o $(HAL_QD_DIR)/src/msapi/gtPIRL.o  		\
+                  $(HAL_QD_DIR)/src/msapi/gtPhyCtrl.o $(HAL_QD_DIR)/src/msapi/gtPhyInt.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysConfig.o $(HAL_QD_DIR)/src/msapi/gtSysCtrl.o	\
+                  $(HAL_QD_DIR)/src/msapi/gtVersion.o $(HAL_QD_DIR)/src/msapi/gtUtils.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgVtu.o $(HAL_QD_DIR)/src/msapi/gtPortRmon.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o\
+                  $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
+
+LSP_OBJS        = core.o irq.o time.o leds.o sysmap.o export.o clock.o
+
+obj-y   				:=  armada370.o
+armada370-objs  			:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
+					  $(ARMADA_FAM_OBJS)
+
+armada370-$(CONFIG_MV_INCLUDE_SDIO) 	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
+armada370-$(CONFIG_MV_INCLUDE_XOR) 	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysXor.o
+armada370-$(CONFIG_MV_INCLUDE_PEX) 	+= $(HAL_PEX_DIR)/mvPex.o					\
+					   $(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
+armada370-$(CONFIG_MV_INCLUDE_PCI) 	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+armada370-$(CONFIG_MV_INCLUDE_USB) 	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysUsb.o
+armada370-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
+
+ifneq ($(CONFIG_MV_ETH_NFP),m)
+	armada370-y += $(NFPOBJS)
+endif
+
+# Legacy Giga driver
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+armada370-$(CONFIG_MV_ETH_LEGACY)	+= $(HAL_ETH_GBE_DIR)/mvEth.o $(HAL_ETH_GBE_DIR)/mvEthDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvEthAddrDec.o $(HAL_IF_DIR)/mvSysEth.o
+armada370-$(CONFIG_MV_ETH_NFP)           += $(HAL_ETH_NFP_DIR)/mvNfp.o
+armada370-$(CONFIG_MV_ETH_NFP_NAT) 	+= $(HAL_ETH_NFP_DIR)/mvNfpNat.o
+armada370-$(CONFIG_MV_ETH_NFP_FDB) 	+= $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+armada370-$(CONFIG_MV_ETH_NFP_PPP) 	+= $(HAL_ETH_NFP_DIR)/mvNfpPpp.o
+armada370-$(CONFIG_MV_ETH_NFP_SEC)	+= $(HAL_ETH_NFP_DIR)/mvNfpSec.o
+
+endif
+
+# NETA Giga driver
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+armada370-$(CONFIG_MV_ETH_NETA)	        += $(HAL_ETH_GBE_DIR)/mvNeta.o $(HAL_ETH_GBE_DIR)/mvNetaDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvNetaAddrDec.o $(HAL_IF_DIR)/mvSysNeta.o
+armada370-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o $(HAL_ETH_PNC_DIR)/mvPnc.o
+armada370-$(CONFIG_MV_ETH_BM) 	        += $(HAL_ETH_BM_DIR)/mvBm.o
+armada370-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o
+armada370-$(CONFIG_MV_ETH_HWF)           += $(HAL_ETH_GBE_DIR)/mvHwf.o
+endif
+
+armada370-$(CONFIG_MV_INCLUDE_CESA) 	+= $(HAL_CESA_DIR)/mvCesa.o \
+					   $(HAL_CESA_DIR)/mvCesaDebug.o 				\
+					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
+					   $(HAL_CESA_DIR)/mvMD5.o $(HAL_CESA_DIR)/mvSHA1.o 		\
+					   $(HAL_CESA_DIR)/mvSHA256.o					\
+					   $(HAL_CESA_AES_DIR)/mvAesAlg.o $(HAL_CESA_AES_DIR)/mvAesApi.o\
+					   $(HAL_IF_DIR)/mvSysCesa.o
+
+armada370-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
+					   $(HAL_SATA_DIR)/mvSataAddrDec.o
+armada370-$(CONFIG_MV_INCLUDE_SPI) 	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o 		\
+					   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
+					   $(HAL_IF_DIR)/mvSysSpi.o
+armada370-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
+armada370-$(CONFIG_MV_INCLUDE_AUDIO) 	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
+					   $(HAL_AUDIO_DIR)/mvAudioAddrDec.o
+armada370-$(CONFIG_MV_INCLUDE_TS) 	+= $(HAL_TS_DIR)/mvTsu.o $(HAL_IF_DIR)/mvSysTs.o		\
+					   $(HAL_TS_DIR)/mvTsuAddrDec.o
+armada370-$(CONFIG_MV_CPU_PERF_CNTRS)    += $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
+armada370-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
+armada370-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
+
+# drivers part
+# Legacy Giga driver
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+obj-$(CONFIG_MV_ETH_NFP) 	        += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o
+obj-$(CONFIG_MV_ETH_NFP_SEC)            += $(LSP_NFP_MGR_DIR)/mv_nfp_sec.o
+endif
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+obj-$(CONFIG_MV_ETH_PNC)                += $(LSP_PNC_DIR)/pnc_sysfs.o
+obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o  $(LSP_BM_DIR)/mv_eth_bm.o
+obj-$(CONFIG_MV_ETH_PMT)		+= $(LSP_PMT_DIR)/pmt_sysfs.o
+obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o
+obj-$(CONFIG_MV_ETH_L2FW)               += $(LSP_L2FW_DIR)/l2fw_sysfs.o $(LSP_L2FW_DIR)/mv_eth_l2fw.o
+endif
+
+obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
+obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
+#obj-y					+= $(PLAT_DRIVERS)/mv_btns/
+obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
+obj-$(CONFIG_SENSORS_ARMADA)		+= hwmon.o
+# The rest of the drivers are compiled through the driver dir directly.
+
+
+# LSP part
+armada370-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
+armada370-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+armada370-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+armada370-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+armada370-$(CONFIG_MV_DBG_TRACE) 	+= dbg-trace.o
+armada370-$(CONFIG_PROC_FS)           += dump_cp15_regs.o
+
diff --git a/arch/arm/mach-armada370/Makefile.boot b/arch/arm/mach-armada370/Makefile.boot
new file mode 100644
index 0000000..67039c3
--- /dev/null
+++ b/arch/arm/mach-armada370/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-armada370/clock.c b/arch/arm/mach-armada370/clock.c
new file mode 100644
index 0000000..15b04ae
--- /dev/null
+++ b/arch/arm/mach-armada370/clock.c
@@ -0,0 +1,50 @@
+/*
+ *  linux/arch/arm/mach-dove/clock.c
+ */
+
+/* TODO: Implement the functions below...	*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+
+#include "clock.h"
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+void clks_register(struct clk *clks, size_t num)
+{
+}
+
+static int __init clk_init(void)
+{
+	/* TODO: Call clks_register with appropriate params. */
+	clks_register(NULL, 0);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-armada370/clock.h b/arch/arm/mach-armada370/clock.h
new file mode 100644
index 0000000..3fd3a3b
--- /dev/null
+++ b/arch/arm/mach-armada370/clock.h
@@ -0,0 +1,5 @@
+struct clk {
+	unsigned int dummy;
+};
+
+void clks_register(struct clk *clks, size_t num);
diff --git a/arch/arm/mach-armada370/config/mvRules.mk b/arch/arm/mach-armada370/config/mvRules.mk
new file mode 100644
index 0000000..e9d618c
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvRules.mk
@@ -0,0 +1,179 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F78xx0
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+PLAT_PATH	  = ../plat-armada
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR           = $(PLAT_PATH)/mv_hal
+COMMON_DIR        = $(PLAT_PATH)/common
+OSSERV_DIR        = $(PLAT_PATH)/linux_oss
+CONFIG_DIR        = config
+HAL_IF		  = mv_hal_if
+
+# HALs
+HAL_ETHPHY_DIR    = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR     = $(HAL_DIR)/flash
+HAL_RTC_DIR       = $(HAL_DIR)/rtc/integ_rtc
+HAL_VOICEBAND     = $(HAL_DIR)/voiceband
+HAL_SLIC_DIR      = $(HAL_VOICEBAND)/slic
+HAL_DAA_DIR       = $(HAL_VOICEBAND)/daa
+HAL_SATA_DIR      = $(HAL_DIR)/sata/CoreDriver/
+HAL_QD_DIR        = $(HAL_DIR)/qd-dsdt
+HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
+HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3
+HAL_DRAM_SPD_DIR  = $(HAL_DIR)/ddr2_3/spd
+HAL_GPP_DIR       = $(HAL_DIR)/gpp
+HAL_TWSI_DIR      = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR      = $(HAL_DIR)/uart
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+HAL_ETH_DIR       = $(HAL_DIR)/neta
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
+HAL_ETH_NFP_DIR   = $(HAL_DIR)/neta/nfp
+HAL_ETH_PNC_DIR   = $(HAL_DIR)/neta/pnc
+HAL_ETH_BM_DIR    = $(HAL_DIR)/neta/bm
+HAL_ETH_PMT_DIR   = $(HAL_DIR)/neta/pmt
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_neta
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/net_dev
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+LSP_PNC_DIR       = $(LSP_NETWORK_DIR)/pnc
+LSP_PMT_DIR       = $(LSP_NETWORK_DIR)/pmt
+LSP_HWF_DIR       = $(LSP_NETWORK_DIR)/hwf
+LSP_L2FW_DIR      = $(LSP_NETWORK_DIR)/l2fw
+LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
+endif
+
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+HAL_ETH_DIR       = $(HAL_DIR)/eth
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/eth/gbe
+HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_network
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/mv_etherent
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+endif
+
+HAL_CPU_DIR       = $(HAL_DIR)/cpu
+HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
+ifeq ($(CONFIG_MV_INCLUDE_PEX),y)
+HAL_PCI_DIR	  = $(HAL_DIR)/pci
+HAL_PEX_DIR       = $(HAL_DIR)/pex
+endif
+ifeq ($(CONFIG_MV_INCLUDE_TDM),y)
+HAL_TDM_DIR       = $(HAL_DIR)/voiceband/tdm
+endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+HAL_USB_DIR       = $(HAL_DIR)/usb
+endif
+ifeq ($(CONFIG_MV_INCLUDE_CESA),y)
+HAL_CESA_DIR	  = $(HAL_DIR)/cesa
+HAL_CESA_AES_DIR  = $(HAL_DIR)/cesa/AES
+endif
+ifeq ($(CONFIG_MV_INCLUDE_XOR),y)
+HAL_XOR_DIR       = $(HAL_DIR)/xor
+endif
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR       = $(HAL_DIR)/spi
+endif
+ifeq ($(CONFIG_MV_INCLUDE_AUDIO),y)
+HAL_AUDIO_DIR     = $(HAL_DIR)/audio
+endif
+ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
+HAL_NFC_DIR     = $(HAL_DIR)/nfc
+endif
+
+# Environment components
+ARMADA370_FAM_DIR	= armada_370_family
+SOC_DEVICE_DIR		= $(ARMADA370_FAM_DIR)/device
+SOC_CPU_DIR		= $(ARMADA370_FAM_DIR)/cpu
+BOARD_ENV_DIR		= $(ARMADA370_FAM_DIR)/boardEnv
+SOC_ENV_DIR		= $(ARMADA370_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR		= $(ARMADA370_FAM_DIR)/ctrlEnv/sys
+HAL_IF_DIR		= mv_hal_if
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I      	= $(srctree)/arch/arm/mach-armada370
+PLAT_PATH_I		= $(srctree)/arch/arm/plat-armada
+
+HAL_PATH        	= -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+ARMADA370_FAM_PATH	= -I$(LSP_PATH_I)/$(ARMADA370_FAM_DIR)
+QD_PATH         	= -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
+			-I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
+
+COMMON_PATH   		= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+
+OSSERV_PATH     	= -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH        	= -I$(LSP_PATH_I)
+CONFIG_PATH     	= -I$(LSP_PATH_I)/$(CONFIG_DIR)
+HAL_IF_PATH		= -I$(LSP_PATH_I)/$(HAL_IF)
+DRIVERS_LSP_PATH 	= -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR)	\
+			  -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR)
+
+EXTRA_INCLUDE  		= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(ARMADA370_FAM_PATH) \
+			$(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+
+
+ifeq ($(CONFIG_MV_GATEWAY),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+EXTRA_INCLUDE   += $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_CESA_TEST),y)
+EXTRA_CFLAGS 	+= -DCONFIG_MV_CESA_TEST
+endif
+
+ifeq ($(CONFIG_SATA_DEBUG_ON_ERROR),y)
+EXTRA_CFLAGS    += -DMV_LOG_ERROR
+endif
+
+ifeq ($(CONFIG_SATA_FULL_DEBUG),y)
+EXTRA_CFLAGS    += -DMV_LOG_DEBUG
+endif
+
+ifeq ($(CONFIG_MV_SATA_SUPPORT_ATAPI),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_ATAPI
+endif
+
+ifeq ($(CONFIG_MV_SATA_ENABLE_1MB_IOS),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_1MBYTE_IOS
+endif
+
+ifeq ($(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT),y)
+EXTRA_CFLAGS    +=-DPCIE_VIRTUAL_BRIDGE_SUPPORT
+endif
+
+ifeq ($(CONFIG_MV_CESA_CHAIN_MODE_SUPPORT),y)
+EXTRA_CFLAGS    += -DMV_CESA_CHAIN_MODE_SUPPORT
+endif
+
+EXTRA_CFLAGS 	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS 	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-armada370/config/mvSysAudioConfig.h b/arch/arm/mach-armada370/config/mvSysAudioConfig.h
new file mode 100644
index 0000000..ef45d19
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysAudioConfig.h
@@ -0,0 +1,42 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysAudioConfig.h - Marvell Audio unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for audio registers.
+*/
+#define MV_AUDIO_REGS_BASE(unit) 	(MV_AUDIO_REGS_OFFSET(unit))
+
+/*
+** Don't perform decoding / playback address decoding fix in the HAL, as it
+** will be done in the Audio driver.
+*/
+#define MV_AUDIO_SKIP_WIN_DECODING
diff --git a/arch/arm/mach-armada370/config/mvSysCesaConfig.h b/arch/arm/mach-armada370/config/mvSysCesaConfig.h
new file mode 100644
index 0000000..cd0fc77
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysCesaConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCesaConfig.h - Marvell Cesa unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+//#include "mvSysHwConfig.h"
+#include  "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for cesa registers.
+*/
+#define MV_CESA_REGS_BASE(chan) 	(MV_CESA_REGS_OFFSET(chan))
+
+#define MV_CESA_TDMA_REGS_BASE(chan)	(MV_CESA_TDMA_REGS_OFFSET(chan))
+
+#define MV_CESA_CHANNELS		(CONFIG_MV_CESA_CHANNELS)
+
+#ifdef CONFIG_MV_CESA_CHAIN_MODE
+	#define MV_CESA_CHAIN_MODE
+#endif
diff --git a/arch/arm/mach-armada370/config/mvSysCntmrConfig.h b/arch/arm/mach-armada370/config/mvSysCntmrConfig.h
new file mode 100644
index 0000000..b6646ae
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysCntmrConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCntmrConfig.h - Marvell Counter Manager unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for counter manager registers.
+*/
+#define MV_CNTMR_REGS_BASE		(MV_CNTMR_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysDdrConfig.h b/arch/arm/mach-armada370/config/mvSysDdrConfig.h
new file mode 100644
index 0000000..6dfd446
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysDdrConfig.h
@@ -0,0 +1,44 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for DDR registers.
+*/
+#define MV_DDR_WIN_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_DDR_CTRL_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+/* used for ddr2 "bak" files */
+#define MV_DDR_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+#ifndef MV_BOOTROM
+#define MV_STATIC_DRAM_ON_BOARD
+#endif
diff --git a/arch/arm/mach-armada370/config/mvSysEthConfig.h b/arch/arm/mach-armada370/config/mvSysEthConfig.h
new file mode 100644
index 0000000..23df325
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysEthConfig.h
@@ -0,0 +1,151 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for ethernet registers.
+*/
+#ifdef CONFIG_MV_PON
+#define MV_PON_PORT(p)		((p) == MV_PON_PORT_ID)
+#define MV_PON_REG_BASE         MV_PON_REGS_OFFSET
+#define MV_ETH_REGS_BASE(p)	(MV_PON_PORT(p) ? MV_PON_REGS_OFFSET : MV_ETH_REGS_OFFSET(p))
+#else
+#define MV_PON_PORT(p)		MV_FALSE
+#define MV_ETH_REGS_BASE(p)	MV_ETH_REGS_OFFSET(p)
+#endif /* CONFIG_MV_PON */
+
+#define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
+#define MV_PNC_REG_BASE         MV_PNC_REGS_OFFSET
+#define MV_ETH_SGMII_PHY_REGS_BASE(p)  MV_ETH_SGMII_PHY_REGS_OFFSET(p)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0
+
+#ifdef CONFIG_MV_ETH_LEGACY
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL    		    200
+#define ETH_RX_COAL    		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff --git a/arch/arm/mach-armada370/config/mvSysEthPhyConfig.h b/arch/arm/mach-armada370/config/mvSysEthPhyConfig.h
new file mode 100644
index 0000000..ce9ff4a
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysEthPhyConfig.h
@@ -0,0 +1,31 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthPhyConfig.h - Marvell Ethernet-PHY specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
diff --git a/arch/arm/mach-armada370/config/mvSysGppConfig.h b/arch/arm/mach-armada370/config/mvSysGppConfig.h
new file mode 100644
index 0000000..7e37a90
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysGppConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysGppConfig.h - Marvell GPP unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for GPP registers.
+*/
+#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-armada370/config/mvSysHwConfig.h b/arch/arm/mach-armada370/config/mvSysHwConfig.h
new file mode 100644
index 0000000..ad0250d
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysHwConfig.h
@@ -0,0 +1,226 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+#define CONFIG_MARVELL	1
+
+/* includes */
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_PCI
+#define MV_INCLUDE_PCI
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_CESA
+#define MV_INCLUDE_CESA
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_SATA
+#endif
+#ifdef CONFIG_MV_INCLUDE_USB
+#define MV_INCLUDE_USB
+#define MV_USB_VOLTAGE_FIX
+#endif
+#ifdef CONFIG_MV_INCLUDE_LEGACY_NAND
+#define MV_INCLUDE_LEGACY_NAND
+#endif
+#ifdef CONFIG_MV_INCLUDE_TDM
+#define MV_INCLUDE_TDM
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+#define MV_INCLUDE_XOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_NORFLASH_MTD
+#define MV_INCLUDE_NOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#define MV_INCLUDE_AUDIO
+#endif
+#ifdef CONFIG_MV_INCLUDE_TS
+#define MV_INCLUDE_TS
+#endif
+#ifdef CONFIG_MV_INCLUDE_SDIO
+#define MV_INCLUDE_SDIO
+#endif
+#ifdef CONFIG_MTD_NAND_LNC_BOOT
+#define MTD_NAND_LNC_BOOT
+#endif
+#ifdef CONFIG_MTD_NAND_LNC
+#define MTD_NAND_LNC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+#define MTD_NAND_NFC
+#endif
+#ifdef CONFIG_MV_INCLUDE_PDMA
+#define MV_INCLUDE_PDMA
+#endif
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define AURORA_IO_CACHE_COHERENCY
+#endif
+
+/* convert Definitions for Errata used in the HAL */
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4413
+#define SHEEVA_ERRATA_ARM_CPU_4413
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_BTS61
+#define SHEEVA_ERRATA_ARM_CPU_BTS61
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+#define SHEEVA_ERRATA_ARM_CPU_4611
+#endif
+
+
+/****************************************************************/
+/************* General    configuration ********************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Disable the DEVICE BAR in the PEX */
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+
+
+/****************************************************************/
+/************* CESA configuration ********************/
+/****************************************************************/
+
+#ifdef MV_INCLUDE_CESA
+
+#define MV_CESA_MAX_CHAN               4
+
+/* Use 2K of SRAM */
+#define MV_CESA_MAX_BUF_SIZE           1600
+
+#endif /* MV_INCLUDE_CESA */
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+/* We use the following registers to store DRAM interface pre configuration   */
+/* auto-detection results													  */
+/* IMPORTANT: We are using mask register for that purpose. Before writing     */
+/* to units mask register, make sure main maks register is set to disable     */
+/* all interrupts.                                                            */
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Board clock detection */
+#define TCLK_AUTO_DETECT    	/* Use Tclk auto detection   */
+#define SYSCLK_AUTO_DETECT	/* Use SysClk auto detection */
+#define PCLCK_AUTO_DETECT  	/* Use PClk auto detection   */
+#define L2CLK_AUTO_DETECT 	/* Use L2Clk auto detection   */
+
+#endif /* __INCmvSysHwConfigh */
diff --git a/arch/arm/mach-armada370/config/mvSysNfcConfig.h b/arch/arm/mach-armada370/config/mvSysNfcConfig.h
new file mode 100644
index 0000000..a8365b64
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysNfcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_NFC_REGS_BASE		(MV_NFC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysPciConfig.h b/arch/arm/mach-armada370/config/mvSysPciConfig.h
new file mode 100644
index 0000000..925af19
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysPciConfig.h
@@ -0,0 +1,25 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PCI_IF_REGS_BASE(pciIf) 		(MV_PEX_IF_REGS_OFFSET(pciIf))
diff --git a/arch/arm/mach-armada370/config/mvSysPexConfig.h b/arch/arm/mach-armada370/config/mvSysPexConfig.h
new file mode 100644
index 0000000..a8e3367
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysPexConfig.h
@@ -0,0 +1,53 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysPciIfConfig.h - Marvell PCI / Pex units specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PEX_IF_REGS_BASE(unit) 		(MV_PEX_IF_REGS_OFFSET(unit))
+
+/* PEX Bridge*/
+#define PEX0_PTP		0		/* no Bridge on pciIf0*/
+#define PEX1_PTP		0		/* no Bridge on pciIf1*/
+
+/* PEX Work arround */
+/* the target we will use for the workarround */
+#define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
+/*a flag that indicates if we are going to use the
+size and base of the target we using for the workarround
+window */
+#define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
+/* if the above flag is 0 then the following values
+will be used for the workarround window base and size,
+otherwise the following defines will be ignored */
+#define PEX_CONFIG_RW_WA_BASE 0xF3000000
+#define PEX_CONFIG_RW_WA_SIZE _16M
diff --git a/arch/arm/mach-armada370/config/mvSysPonConfig.h b/arch/arm/mach-armada370/config/mvSysPonConfig.h
new file mode 100644
index 0000000..a29f56f
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysPonConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for PON registers.
+*/
+#define MV_EPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+#define MV_GPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysRtcConfig.h b/arch/arm/mach-armada370/config/mvSysRtcConfig.h
new file mode 100644
index 0000000..d1be308
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysRtcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysRtcConfig.h - Marvell Real-Time clock unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for RTC registers.
+*/
+#define MV_RTC_REGS_BASE		(MV_RTC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysSataConfig.h b/arch/arm/mach-armada370/config/mvSysSataConfig.h
new file mode 100644
index 0000000..b9df314
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysSataConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSataConfig.h - Marvell Sata unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SATA_REGS_BASE		(MV_SATA_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysSdmmcConfig.h b/arch/arm/mach-armada370/config/mvSysSdmmcConfig.h
new file mode 100644
index 0000000..7e39c3b
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysSdmmcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSdmmcConfig.h - Marvell SDMMC unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for audio registers.
+*/
+#define MV_SDMMC_REGS_BASE		(MV_SDMMC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada370/config/mvSysSpiConfig.h b/arch/arm/mach-armada370/config/mvSysSpiConfig.h
new file mode 100644
index 0000000..9901193
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysSpiConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SPI_REGS_BASE(unit)		(MV_SPI_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada370/config/mvSysTdmConfig.h b/arch/arm/mach-armada370/config/mvSysTdmConfig.h
new file mode 100644
index 0000000..28d71b0
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysTdmConfig.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysTdmConfig.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvOs.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_SUPPORT)
+	#define MV_TDM_SUPPORT
+	#define MV_TDM_REGS_BASE	MV_TDM_REGS_OFFSET
+#elif defined(CONFIG_MV_COMM_UNIT_SUPPORT)
+	#define MV_COMM_UNIT_SUPPORT
+	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
+#endif
+
+/* SLIC vendor */
+#if defined(CONFIG_SILABS_SLIC_SUPPORT)
+	#define SILABS_SLIC_SUPPORT
+	#if defined(CONFIG_SILABS_SLIC_3215)
+		#define SILABS_SLIC_3215
+	#elif defined(CONFIG_SILABS_SLIC_3217)
+		#define SILABS_SLIC_3217
+	#endif
+#else /* CONFIG_ZARLINK_SLIC_SUPPORT) */
+	#define ZARLINK_SLIC_SUPPORT
+	#define SLIC_TIMER_EVENT_SUPPORT
+	#if defined(CONFIG_ZARLINK_SLIC_VE880)
+		#define ZARLINK_SLIC_VE880
+	#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+		#define ZARLINK_SLIC_VE792
+	#endif
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+#if defined(CONFIG_MV_TDM_PCM_CLK_8MHZ)
+	#define MV_TDM_PCM_CLK_8MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_4MHZ)
+	#define MV_TDM_PCM_CLK_4MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_2MHZ)
+	#define MV_TDM_PCM_CLK_2MHZ
+#endif
diff --git a/arch/arm/mach-armada370/config/mvSysTsConfig.h b/arch/arm/mach-armada370/config/mvSysTsConfig.h
new file mode 100644
index 0000000..8fae50f
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysTsConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTsConfig.h - Marvell TS unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for TS registers.
+*/
+#define MV_TSU_GLOBAL_REGS_BASE		(MV_TSU_GLOBAL_REGS_OFFSET)
+#define MV_TSU_REGS_BASE(port)		(MV_TSU_REGS_OFFSET(port))
diff --git a/arch/arm/mach-armada370/config/mvSysTwsiConfig.h b/arch/arm/mach-armada370/config/mvSysTwsiConfig.h
new file mode 100644
index 0000000..b23eb22
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysTwsiConfig.h
@@ -0,0 +1,35 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTwsiConfig.h - Marvell TWSI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+/*
+** Base address for TWSI registers.
+*/
+#define MV_TWSI_SLAVE_REGS_BASE(unit) 	(MV_TWSI_SLAVE_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada370/config/mvSysUsbConfig.h b/arch/arm/mach-armada370/config/mvSysUsbConfig.h
new file mode 100644
index 0000000..de9bded
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysUsbConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysUsbConfig.h - Marvell USB unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for USB registers.
+*/
+#define MV_USB_REGS_BASE(unit) 		(MV_USB_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada370/config/mvSysXorConfig.h b/arch/arm/mach-armada370/config/mvSysXorConfig.h
new file mode 100644
index 0000000..ae86fc6
--- /dev/null
+++ b/arch/arm/mach-armada370/config/mvSysXorConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysXorConfig.h - Marvell XOR unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for XOR registers.
+*/
+#define MV_XOR_REGS_BASE(unit)		(MV_XOR_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada370/core.c b/arch/arm/mach-armada370/core.c
new file mode 100644
index 0000000..62697c3
--- /dev/null
+++ b/arch/arm/mach-armada370/core.c
@@ -0,0 +1,1269 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/mbus.h>
+#include <asm/mach/time.h>
+#include <linux/clocksource.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <mach/system.h>
+
+#include <linux/tty.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/ata_platform.h>
+#include <asm/serial.h>
+#include <plat/cache-aurora-l2.h>
+
+#include <mach/serial.h>
+#include <plat/audio.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "plat/gpio.h"
+#include "cpu/mvCpu.h"
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+#include "sdmmc/mvSdmmc.h"
+#include <plat/mvsdio.h>
+#endif
+#if defined(CONFIG_MV_INCLUDE_CESA)
+#include "cesa/mvCesa.h"
+#endif
+#if defined(CONFIG_MV_INCLUDE_AUDIO)
+#include <plat/i2s-orion.h>
+#endif
+
+#include <plat/mv_xor.h>
+
+/* I2C */
+#include <linux/i2c.h>
+#include <linux/mv643xx_i2c.h>
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+/* SPI */
+#include "mvSysSpiApi.h"
+
+/* Eth Phy */
+#include "mvSysEthPhyApi.h"
+
+/* NAND */
+#ifdef CONFIG_MTD_NAND_NFC
+#include "mv_mtd/nand_nfc.h"
+#endif
+
+/* DLB */
+#define MV_DLB_CTRL_REG				(INTER_REGS_BASE + 0x1700)
+#define MV_DLB_BUS_OPT_WEIGHTS_REG		(INTER_REGS_BASE + 0x1704)
+#define MV_DLB_CMD_PRIO_REG			(INTER_REGS_BASE + 0x1708)
+#define MV_MBUS_UNITS_PRIO_CTRL_REG		(INTER_REGS_BASE + 0x20420)
+#define MV_FABRIC_UNITS_PRIO_CTRL_REG		(INTER_REGS_BASE + 0x20424)
+
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+extern unsigned int irq_int_type[];
+extern void __init axp_map_io(void);
+extern void __init mv_init_irq(void);
+extern struct sys_timer axp_timer;
+extern MV_CPU_DEC_WIN* mv_sys_map(void);
+#if defined(CONFIG_MV_INCLUDE_CESA)
+extern u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+extern void axp_init_irq(void);
+unsigned int support_wait_for_interrupt;
+u32 bit_mask_config;
+
+/* for debug putstr */
+static char arr[256];
+MV_U32 mvTclk = 166666667;
+MV_U32 mvSysclk = 200000000;
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+MV_U8 mvMacAddr[CONFIG_MV_ETH_PORTS_NUM][6];
+MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
+#endif
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0180 + ((n) << 2))
+#define DDR_SIZE_CS_OFF(n)	(0x0184 + ((n) << 2))
+#define TARGET_DDR		0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC	0x1
+
+struct mbus_dram_target_info armadaxp_mbus_dram_info;
+
+
+/*********************************************************************************/
+/**************                 Early Printk Support                **************/
+/*********************************************************************************/
+#ifdef MV_INCLUDE_EARLY_PRINTK
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+extern void putstr(const char *ptr);
+void mv_early_printk(char *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	vsprintf(arr,fmt,args);
+	va_end(args);
+	putstr(arr);
+}
+#endif
+
+/*********************************************************************************/
+/**************               UBoot Tagging Parameters              **************/
+/*********************************************************************************/
+extern MV_U32 gBoardId;
+extern unsigned int elf_hwcap;
+extern u32 mvIsUsbHost;
+
+static int __init parse_tag_mv_uboot(const struct tag *tag)
+{
+	unsigned int mvUbootVer = 0;
+	int i = 0;
+
+	printk("Using UBoot passing parameters structure\n");
+	mvUbootVer = tag->u.mv_uboot.uboot_version;
+	mvIsUsbHost = tag->u.mv_uboot.isUsbHost;
+	gBoardId =  (mvUbootVer & 0xff);
+	bit_mask_config = tag->u.mv_uboot.bit_mask_config;
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+#if defined (CONFIG_OVERRIDE_ETH_CMDLINE)
+		memset(mvMacAddr[i], 0, 6);
+		mvMtu[i] = 0;
+#else
+printk(">>>>>>>Tag MAC %02x:%02x:%02x:%02x:%02x:%02x\n", tag->u.mv_uboot.macAddr[i][5], tag->u.mv_uboot.macAddr[i][4],
+	tag->u.mv_uboot.macAddr[i][3], tag->u.mv_uboot.macAddr[i][2], tag->u.mv_uboot.macAddr[i][1], tag->u.mv_uboot.macAddr[i][0]);
+		memcpy(mvMacAddr[i], tag->u.mv_uboot.macAddr[i], 6);
+		mvMtu[i] = tag->u.mv_uboot.mtu[i];
+#endif
+	}
+#endif
+
+#ifdef CONFIG_MV_NAND
+	/* get NAND ECC type(1-bit or 4-bit) */
+	mv_nand_ecc = tag->u.mv_uboot.nand_ecc;
+#endif
+	return 0;
+}
+
+__tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
+
+/*********************************************************************************/
+/**************                Command Line Parameters              **************/
+/*********************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+#include "mvSysUsbApi.h"
+/* Required to get the configuration string from the Kernel Command Line */
+static char *usb0Mode = "host";
+static char *usb1Mode = "host";
+int mv_usb0_cmdline_config(char *s);
+int mv_usb1_cmdline_config(char *s);
+__setup("usb0Mode=", mv_usb0_cmdline_config);
+__setup("usb1Mode=", mv_usb1_cmdline_config);
+
+int mv_usb0_cmdline_config(char *s)
+{
+    usb0Mode = s;
+    return 1;
+}
+
+int mv_usb1_cmdline_config(char *s)
+{
+    usb1Mode = s;
+    return 1;
+}
+#endif
+
+#ifdef CONFIG_CACHE_AURORA_L2
+static int noL2 = 0;
+static int __init noL2_setup(char *__unused)
+{
+     noL2 = 1;
+     return 1;
+}
+
+__setup("noL2", noL2_setup);
+#endif
+
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+unsigned int l0_disable_flag = 0;		/* L0 Enabled by Default */
+static int __init l0_disable_setup(char *__unused)
+{
+     l0_disable_flag = 1;
+     return 1;
+}
+
+__setup("l0_disable", l0_disable_setup);
+#endif
+
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+unsigned int sp_enable_flag = 0;		/* SP Disabled by Default */
+static int __init spec_prefesth_setup(char *__unused)
+{
+     sp_enable_flag = 1;
+     return 1;
+}
+
+__setup("sp_enable", spec_prefesth_setup);
+#endif
+
+char *nfcConfig = NULL;
+static int __init nfcConfig_setup(char *s)
+{
+	nfcConfig = s;
+	return 1;
+}
+__setup("nfcConfig=", nfcConfig_setup);
+
+static int dlb_enable = 1;
+static int __init dlb_setup(char *__unused)
+{
+     dlb_enable = 0;
+     return 1;
+}
+
+__setup("noDLB", dlb_setup);
+
+void __init armadaxp_setup_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+	u8 coherency_status = 0;
+
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
+#endif
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	armadaxp_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	addr = (void __iomem *)DDR_WINDOW_CPU_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+
+			w = &armadaxp_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->mbus_attr |= coherency_status << 4;
+			w->base = base & 0xff000000;
+			w->size = (size | 0x00ffffff) + 1;
+		}
+	}
+	armadaxp_mbus_dram_info.num_cs = cs;
+}
+
+/*********************************************************************************/
+/**************               I/O Devices Platform Info             **************/
+/*********************************************************************************/
+/*************
+ * I2C(TWSI) *
+ *************/
+static struct mv64xxx_i2c_pdata axp_i2c_pdata = {
+       .freq_m         = 8, /* assumes 166 MHz TCLK */
+       .freq_n         = 3,
+       .timeout        = 1000, /* Default timeout of 1 second */
+};
+
+static struct resource axp_i2c_0_resources[] = {
+	{
+		.name   = "i2c base",
+		.start  = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0),
+		.end    = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0) + 0x20 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "i2c irq",
+		.start  = IRQ_AURORA_I2C0,
+		.end    = IRQ_AURORA_I2C0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device axp_i2c = {
+	.name           = MV64XXX_I2C_CTLR_NAME,
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(axp_i2c_0_resources),
+	.resource       = axp_i2c_0_resources,
+	.dev            = {
+		.platform_data = &axp_i2c_pdata,
+	},
+};
+
+/**********
+ * UART-0 *
+ **********/
+static struct plat_serial8250_port aurora_uart0_data[] = {
+	{
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(0)),
+		.irq		= IRQ_AURORA_UART0,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(0) | 0x7C),
+		.type		= PORT_16550A,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource aurora_uart0_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART0,
+		.end		= IRQ_AURORA_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart0_data,
+	},
+	.resource		= aurora_uart0_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart0_resources),
+};
+
+
+void __init serial_initialize(void)
+{
+	aurora_uart0_data[0].uartclk = mvBoardTclkGet();
+	platform_device_register(&aurora_uart0);
+}
+
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+
+/*****************************************************************************
+ * I2S/SPDIF
+ ****************************************************************************/
+static struct resource mv_i2s_resources[] = {
+	[0] = {
+		.start	= INTER_REGS_PHYS_BASE + MV_AUDIO_REGS_OFFSET(0),
+		.end	= INTER_REGS_PHYS_BASE + MV_AUDIO_REGS_OFFSET(0) + SZ_16K -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_AUDIO,
+		.end	= IRQ_AURORA_AUDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 mv_i2s0_dmamask = 0xFFFFFFFFUL;
+
+static struct orion_i2s_platform_data mv_i2s_plat_data = {
+	.dram	= NULL,
+	.spdif_rec = 1,
+	.spdif_play = 1,
+	.i2s_rec = 1,
+	.i2s_play = 1,
+};
+
+
+static struct platform_device mv_i2s = {
+	.name           = "mv88fx_snd",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &mv_i2s0_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		.platform_data	= &mv_i2s_plat_data,
+	},
+	.num_resources  = ARRAY_SIZE(mv_i2s_resources),
+	.resource       = mv_i2s_resources,
+};
+
+static struct platform_device mv_mv88fx_i2s = {
+	.name           = "mv88fx-i2s",
+	.id             = -1,
+};
+
+/*****************************************************************************
+ * A2D on I2C bus
+ ****************************************************************************/
+static struct i2c_board_info __initdata i2c_a2d = {
+	I2C_BOARD_INFO("i2s_i2c", 0x4A),
+};
+
+
+void __init mv_audio_init(void)
+{
+       if (MV_TRUE == mvCtrlPwrClckGet(AUDIO_UNIT_ID, 0)) {
+		platform_device_register(&mv_mv88fx_i2s);
+		platform_device_register(&mv_i2s);
+		i2c_register_board_info(0, &i2c_a2d, 1);
+       }
+}
+
+#endif /* #ifdef CONFIG_MV_INCLUDE_AUDIO */
+
+/*****************************************************************************
+ * Audio
+ ****************************************************************************/
+static struct resource kirkwood_i2s_resources[] = {
+	[0] = {
+		.start	= INTER_REGS_PHYS_BASE + MV_AUDIO_REGS_OFFSET(0),
+		.end	= INTER_REGS_PHYS_BASE + MV_AUDIO_REGS_OFFSET(0) + SZ_16K -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_AUDIO,
+		.end	= IRQ_AURORA_AUDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct kirkwood_asoc_platform_data kirkwood_i2s_data = {
+	.dram        = &armadaxp_mbus_dram_info,
+	.burst       = 128,
+};
+
+static struct platform_device kirkwood_i2s_device = {
+	.name		= "kirkwood-i2s",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(kirkwood_i2s_resources),
+	.resource	= kirkwood_i2s_resources,
+	.dev		= {
+		.platform_data	= &kirkwood_i2s_data,
+	},
+};
+
+static struct platform_device kirkwood_pcm_device = {
+	.name		= "kirkwood-pcm-audio",
+	.id		= -1,
+};
+
+/*****************************************************************************
+ * A2D on I2C bus
+ ****************************************************************************/
+static struct i2c_board_info __initdata i2c_a2d = {
+	I2C_BOARD_INFO("cs42l51", 0x4A),
+};
+
+
+void __init kirkwood_audio_init(void)
+{
+	if (MV_TRUE == mvCtrlPwrClckGet(AUDIO_UNIT_ID, 0)) {
+		platform_device_register(&kirkwood_i2s_device);
+		platform_device_register(&kirkwood_pcm_device);
+		i2c_register_board_info(0, &i2c_a2d, 1);
+	}
+}
+
+/********
+ * SDIO *
+ ********/
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+static struct resource mvsdio_resources[] = {
+	[0] = {
+		.start	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET + SZ_1K -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_SDIO,
+		.end	= IRQ_AURORA_SDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+
+};
+
+static u64 mvsdio_dmamask = 0xffffffffUL;
+
+static struct mvsdio_platform_data mvsdio_data = {
+	.gpio_write_protect	= 0,
+	.gpio_card_detect	= 0,
+	.dram			= NULL,
+};
+
+static struct platform_device mv_sdio_plat = {
+	.name		= "mvsdio",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &mvsdio_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data	= &mvsdio_data,
+	},
+	.num_resources	= ARRAY_SIZE(mvsdio_resources),
+	.resource	= mvsdio_resources,
+};
+#endif /* #if defined(CONFIG_MV_INCLUDE_SDIO) */
+
+/*******
+ * GBE *
+ *******/
+#ifdef CONFIG_MV_ETHERNET
+#if defined(CONFIG_MV_ETH_LEGACY)
+static struct platform_device mv88fx_eth = {
+	.name           = "mv88fx_eth",
+	.id             = 0,
+	.num_resources  = 0,
+};
+#elif defined(CONFIG_MV_ETH_NETA)
+static struct platform_device mv88fx_neta = {
+	.name           = "mv88fx_neta",
+	.id             = 0,
+	.num_resources  = 0,
+};
+#else
+#error "Ethernet Mode is not defined (should be Legacy or NETA)"
+#endif /* Ethernet mode: legacy or NETA */
+
+static void __init eth_init(void)
+{
+#if defined(CONFIG_MV_ETH_LEGACY)
+	platform_device_register(&mv88fx_eth);
+#elif defined(CONFIG_MV_ETH_NETA)
+	platform_device_register(&mv88fx_neta);
+#endif /* Ethernet mode: legacy or NETA */
+}
+#endif /* CONFIG_MV_ETHERNET */
+
+
+/*******
+ * RTC *
+ *******/
+static struct resource axp_rtc_resource[] = {
+	{
+		.start	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_AURORA_RTC,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static void __init rtc_init(void)
+{
+	platform_device_register_simple("rtc-mv", -1, axp_rtc_resource, 2);
+}
+
+/********
+ * SATA *
+ ********/
+#ifdef CONFIG_SATA_MV
+#define SATA_PHYS_BASE (INTER_REGS_PHYS_BASE | MV_SATA_REGS_OFFSET)
+
+static struct mv_sata_platform_data dbdsmp_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct resource armadaxp_sata_resources[] = {
+	{
+		.name	= "sata base",
+		.start	= SATA_PHYS_BASE,
+		.end	= SATA_PHYS_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "sata irq",
+		.start	= IRQ_AURORA_SATA(0),
+		.end	= IRQ_AURORA_SATA(0),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device armadaxp_sata = {
+	.name		= "sata_mv",
+	.id		= 0,
+	.dev		= {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_sata_resources),
+	.resource	= armadaxp_sata_resources,
+};
+
+void __init armadaxp_sata_init(struct mv_sata_platform_data *sata_data)
+{
+
+	/* If Port1 is disabled, then reduce the number of ports. */
+	if (mvCtrlPwrClckGet(SATA_UNIT_ID, 1) == MV_FALSE)
+		sata_data->n_ports--;
+
+	/* Cannot enable port1 if port 0 is disabled. */
+	if (mvCtrlPwrClckGet(SATA_UNIT_ID, 0) == MV_FALSE) {
+		sata_data->n_ports = 0;
+		return;
+	}
+
+	if (sata_data->n_ports != 0) {
+		armadaxp_sata.dev.platform_data = sata_data;
+		sata_data->dram = &armadaxp_mbus_dram_info;
+		platform_device_register(&armadaxp_sata);
+	}
+}
+#endif
+/*****************************************************************************
+ * SoC hwmon Thermal Sensor
+ ****************************************************************************/
+void __init armadaxp_hwmon_init(void)
+{
+	platform_device_register_simple("axp-temp", 0, NULL, 0);
+}
+
+/*************
+ * 7-Segment *
+ *************/
+static struct timer_list axp_db_timer;
+static void axp_db_7seg_event(unsigned long data)
+{
+	static int count = 0;
+
+	/* Update the 7 segment */
+	mvBoardDebugLed(count);
+
+	/* Incremnt count and arm the timer*/
+	count = (count + 1) & 7;
+	mod_timer(&axp_db_timer, jiffies + 1 * HZ);
+}
+
+static int __init axp_db_7seg_init(void)
+{
+	/* Create the 7segment timer */
+	setup_timer(&axp_db_timer, axp_db_7seg_event, 0);
+
+	/* Arm it expire in 1 second */
+	mod_timer(&axp_db_timer, jiffies + 1 * HZ);
+
+	return 0;
+}
+__initcall(axp_db_7seg_init);
+
+#ifdef CONFIG_MTD_NAND_NFC
+/*****************************************************************************
+ * NAND controller
+ ****************************************************************************/
+static struct resource axp_nfc_resources[] = {
+	{
+		.start  = INTER_REGS_BASE + MV_NFC_REGS_OFFSET,
+		.end    = INTER_REGS_BASE + MV_NFC_REGS_OFFSET + 0x400 -1,
+		.flags  = IORESOURCE_MEM,
+	}
+};
+
+
+static struct mtd_partition nand_parts_info[] = {
+	{
+		.name		= "UBoot",
+		.offset		= 0,
+		.size		= 1 * SZ_1M
+	},
+	{
+		.name		= "UImage",
+		.offset	= MTDPART_OFS_APPEND,
+		.size		= 4 * SZ_1M },
+	{
+		.name		= "Root",
+		.offset	= MTDPART_OFS_APPEND,
+		.size         = MTDPART_SIZ_FULL
+	},
+};
+
+
+static struct nfc_platform_data axp_nfc_data = {
+	.nfc_width	= 8,
+	.num_devs	= 1,
+	.num_cs		= 1,
+	.use_dma	= 0,
+	.ecc_type	= MV_NFC_ECC_BCH_2K,
+	.parts		= nand_parts_info,
+	.nr_parts	= ARRAY_SIZE(nand_parts_info),
+};
+
+static struct platform_device axp_nfc = {
+	.name           = "armada-nand",
+	.id             = 0,
+	.dev            = {
+							.platform_data = &axp_nfc_data,
+						},
+	.num_resources  = ARRAY_SIZE(axp_nfc_resources),
+	.resource       = axp_nfc_resources,
+
+};
+
+static void __init axp_db_nfc_init(void)
+{
+	/* Check for ganaged mode */
+	if (nfcConfig) {
+		if (strncmp(nfcConfig, "ganged", 6) == 0) {
+			axp_nfc_data.nfc_width = 16;
+			axp_nfc_data.num_devs = 2;
+			nfcConfig += 7;
+		}
+
+		/* Check for ECC type directive */
+		if (strcmp(nfcConfig, "8bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
+		} else if (strcmp(nfcConfig, "12bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
+		} else if (strcmp(nfcConfig, "16bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
+		}
+	}
+
+	axp_nfc_data.tclk = mvBoardTclkGet();
+
+	platform_device_register(&axp_nfc);
+}
+#endif
+/*********************************************************************************/
+/**************                      Helper Routines                **************/
+/*********************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+unsigned char*  mv_sram_usage_get(int* sram_size_ptr)
+{
+	int used_size = 0;
+
+#if defined(CONFIG_MV_CESA)
+	used_size = sizeof(MV_CESA_SRAM_MAP);
+#endif
+
+	if(sram_size_ptr != NULL)
+		*sram_size_ptr = _8K - used_size;
+
+	return (char *)(mv_crypto_virt_base_get(0) + used_size);
+}
+#endif
+
+void print_board_info(void)
+{
+	char name_buff[50];
+	printk("\n  Marvell Armada370 Board");
+
+	mvBoardNameGet(name_buff);
+	printk("-- %s ",name_buff);
+
+	mvCtrlModelRevNameGet(name_buff);
+	printk(" Soc: %s",  name_buff);
+#if defined(MV_CPU_LE)
+	printk(" LE");
+#else
+	printk(" BE");
+#endif
+	printk("\n  LSP version: %s\n", LSP_VERSION);
+	printk("\n\n");
+	printk(" Detected Tclk %d, SysClk %d, FabricClk %d\n",mvTclk, mvSysclk, mvCpuL2ClkGet());
+}
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+static void io_coherency_init(void)
+{
+	MV_U32 reg;
+
+	/* set CIB read snoop command to ReadUnique */
+	reg = MV_REG_READ(MV_CIB_CTRL_CFG_REG);
+	reg &= ~(7 << 16);
+	reg |= (7 << 16);
+	MV_REG_WRITE(MV_CIB_CTRL_CFG_REG, reg);
+
+        /* enable snoop CPU enable */
+	MV_REG_BIT_SET(MV_COHERENCY_FABRIC_CTRL_REG, (1 << 24));
+}
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(const char *);
+static void check_cpu_mode(void)
+{
+                u32 cpu_id_code_ext;
+                int cpu_mode = 0;
+                asm volatile("mrc p15, 1, %0, c15, c12, 0": "=r"(cpu_id_code_ext));
+
+                if (((cpu_id_code_ext >> 16) & 0xF) == 0x2)
+                        cpu_mode = 6;
+                else if (((cpu_id_code_ext >> 16) & 0xF) == 0x3)
+                        cpu_mode = 7;
+                else
+                        pr_err("unknow cpu mode!!!\n");
+#ifdef CONFIG_DEBUGGER_MODE_V6
+		if (cpu_mode != 6) {
+			printascii("cpu mode (ARMv7) doesn't mach kernel configuration\n");
+			panic("cpu mode mismatch");
+		}
+#else
+#ifdef CONFIG_CPU_V7
+                if (cpu_mode != 7) {
+                        printascii("cpu mode (ARMv6) doesn't mach kernel configuration\n");
+                        panic("cpu mode mismatch");
+                }
+#endif
+#endif
+	printk("Armada370: Working in ARMv%d mode\n",cpu_mode);
+}
+#endif
+
+/*****************************************************************************
+ * XOR
+ ****************************************************************************/
+static struct mv_xor_platform_shared_data armadaxp_xor_shared_data = {
+	.dram		= &armadaxp_mbus_dram_info,
+};
+
+static u64 armadaxp_xor_dmamask = DMA_BIT_MASK(32);
+
+/*****************************************************************************
+ * XOR0
+ ****************************************************************************/
+static struct resource armadaxp_xor0_shared_resources[] = {
+	{
+		.name	= "xor 0 low",
+		.start	= XOR0_PHYS_BASE,
+		.end	= XOR0_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 0 high",
+		.start	= XOR0_HIGH_PHYS_BASE,
+		.end	= XOR0_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device armadaxp_xor0_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data = &armadaxp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_xor0_shared_resources),
+	.resource	= armadaxp_xor0_shared_resources,
+};
+
+static struct resource armadaxp_xor00_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR0_CH0,
+		.end	= IRQ_AURORA_XOR0_CH0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor00_data = {
+	.shared		= &armadaxp_xor0_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor00_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor00_resources),
+	.resource	= armadaxp_xor00_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.platform_data		= &armadaxp_xor00_data,
+	},
+};
+
+static struct resource armadaxp_xor01_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR0_CH1,
+		.end	= IRQ_AURORA_XOR0_CH1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor01_data = {
+	.shared		= &armadaxp_xor0_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor01_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor01_resources),
+	.resource	= armadaxp_xor01_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.platform_data		= &armadaxp_xor01_data,
+	},
+};
+
+static void __init armadaxp_xor0_init(void)
+{
+	platform_device_register(&armadaxp_xor0_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	//dma_cap_set(DMA_MEMCPY, armadaxp_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, armadaxp_xor00_data.cap_mask);
+	platform_device_register(&armadaxp_xor00_channel);
+
+	//dma_cap_set(DMA_MEMCPY, armadaxp_xor01_data.cap_mask);
+	//dma_cap_set(DMA_MEMSET, armadaxp_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, armadaxp_xor01_data.cap_mask);
+	platform_device_register(&armadaxp_xor01_channel);
+}
+
+/*****************************************************************************
+ * XOR1
+ ****************************************************************************/
+static struct resource armadaxp_xor1_shared_resources[] = {
+	{
+		.name	= "xor 1 low",
+		.start	= XOR1_PHYS_BASE,
+		.end	= XOR1_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 1 high",
+		.start	= XOR1_HIGH_PHYS_BASE,
+		.end	= XOR1_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device armadaxp_xor1_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 1,
+	.dev		= {
+		.platform_data = &armadaxp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_xor1_shared_resources),
+	.resource	= armadaxp_xor1_shared_resources,
+};
+
+static struct resource armadaxp_xor10_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR1_CH0,
+		.end	= IRQ_AURORA_XOR1_CH0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor10_data = {
+	.shared		= &armadaxp_xor1_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor10_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor10_resources),
+	.resource	= armadaxp_xor10_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.platform_data		= &armadaxp_xor10_data,
+	},
+};
+
+static struct resource armadaxp_xor11_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR1_CH1,
+		.end	= IRQ_AURORA_XOR1_CH1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor11_data = {
+	.shared		= &armadaxp_xor1_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor11_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor11_resources),
+	.resource	= armadaxp_xor11_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.platform_data		= &armadaxp_xor11_data,
+	},
+};
+
+static void __init armadaxp_xor1_init(void)
+{
+	platform_device_register(&armadaxp_xor1_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_MEMCPY, armadaxp_xor10_data.cap_mask);
+	//dma_cap_set(DMA_XOR, armadaxp_xor10_data.cap_mask);
+	platform_device_register(&armadaxp_xor10_channel);
+
+	dma_cap_set(DMA_MEMCPY, armadaxp_xor11_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, armadaxp_xor11_data.cap_mask);
+	//dma_cap_set(DMA_XOR, armadaxp_xor11_data.cap_mask);
+	platform_device_register(&armadaxp_xor11_channel);
+}
+
+static void dram_dlb_setup(void)
+{
+	if (dlb_enable) {
+		printk("Enable DLB and DRAM write coalescing\n");
+		writel(0x9083, MV_DLB_BUS_OPT_WEIGHTS_REG);
+		writel(0x250020, MV_DLB_CMD_PRIO_REG);
+		writel(0x55555555, MV_MBUS_UNITS_PRIO_CTRL_REG);
+		writel(0x2, MV_FABRIC_UNITS_PRIO_CTRL_REG);
+		writel(0x7, MV_DLB_CTRL_REG);
+	}
+}
+
+static void cpu_fabric_common_init(void)
+{
+	MV_U32	reg;
+
+#ifdef CONFIG_DEBUG_LL
+        check_cpu_mode();
+#endif
+
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+	printk("L0 cache Disabled (by Errata #4948)\n");
+#else
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (reg));
+	if (l0_disable_flag) {
+		printk("L0 cache Disabled\n");
+		reg |= (1 << 0);
+	} else {
+		printk("L0 cache Enabled\n");
+		reg &= ~(1 << 0);
+	}
+	__asm volatile ("mcr p15, 1, %0, c15, c1, 0" : : "r" (reg));
+#endif
+
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+	printk("Speculative Prefetch Disabled (by Errata #5315)\n");
+#else
+	__asm volatile ("mrc p15, 1, %0, c15, c2, 0" : "=r" (reg));
+	if (sp_enable_flag) {
+		printk("Speculative Prefetch Enabled\n");
+		reg &= ~(1 << 7);
+	} else {
+		printk("Speculative Prefetch Disabled\n");
+		reg |= (1 << 7);
+	}
+	__asm volatile ("mcr p15, 1, %0, c15, c2, 0" : : "r" (reg));
+#endif
+
+#ifdef CONFIG_CACHE_AURORA_L2
+	if (!noL2)
+		aurora_l2_init((void __iomem *)(INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET));
+#endif
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+	printk("Support IO coherency.\n");
+	io_coherency_init();
+#endif
+}
+
+/*****************************************************************************
+ * DB BOARD: Main Initialization
+ ****************************************************************************/
+static void __init axp_db_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Enable DLB and DRAM write coalescing */
+	dram_dlb_setup();
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	/* Set configuration according to bit mask passed from U-Boot */
+	mvBoardBitMaskConfigSet(bit_mask_config);
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	support_wait_for_interrupt = 1;
+
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_BTS61
+	support_wait_for_interrupt = 0;
+#endif
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize();
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	mvCpuIfAddDecShow();
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	/* SPI */
+	mvSysSpiInit(0, _16M);
+	mvSysSpiInit(1, _16M);
+
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+	/* Audio */
+	mv_audio_init();
+#endif
+	kirkwood_audio_init();
+
+	/* ETH-PHY */
+	mvSysEthPhyInit();
+
+	/* Sata */
+#ifdef CONFIG_SATA_MV
+	armadaxp_sata_init(&dbdsmp_sata_data);
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+	/* NAND */
+	axp_db_nfc_init();
+#endif
+	/* HWMON */
+	armadaxp_hwmon_init();
+
+	/* XOR */
+	armadaxp_xor0_init();
+	armadaxp_xor1_init();
+
+	/* I2C */
+	platform_device_register(&axp_i2c);
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+			irq_int_type[mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT)+IRQ_AURORA_GPIO_START] = GPP_IRQ_TYPE_CHANGE_LEVEL;
+		}
+
+		if(mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+       }
+#endif
+
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
+	return;
+}
+
+MACHINE_START(ARMADA_370, "Marvell Armada-370")
+	/* MAINTAINER("MARVELL") */
+	.atag_offset	= 0x00000100,
+	.map_io		= axp_map_io,
+	.init_irq	= axp_init_irq,
+	.timer		= &axp_timer,
+	.init_machine	= axp_db_init,
+MACHINE_END
diff --git a/arch/arm/mach-armada370/dbg-trace.c b/arch/arm/mach-armada370/dbg-trace.c
new file mode 100644
index 0000000..0de3ca7
--- /dev/null
+++ b/arch/arm/mach-armada370/dbg-trace.c
@@ -0,0 +1,111 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include "dbg-trace.h"
+
+#define TRACE_ARR_LEN   800
+#define STR_LEN         128
+struct trace {
+	struct timeval tv;
+	char str[STR_LEN];
+	unsigned int callback_val1;
+	unsigned int callback_val2;
+	char valid;
+};
+
+static unsigned int (*trc_callback1) (unsigned char) = NULL;
+static unsigned int (*trc_callback2) (unsigned char) = NULL;
+static unsigned char trc_param1 = 0;
+static unsigned char trc_param2 = 0;
+struct trace *trc_arr;
+static int trc_index;
+static int trc_active = 0;
+
+void TRC_START()
+{
+	trc_active = 1;
+}
+
+void TRC_STOP()
+{
+	trc_active = 0;
+}
+
+void TRC_INIT(void *callback1, void *callback2, unsigned char callback1_param, unsigned char callback2_param)
+{
+	printk("Marvell debug tracing is on\n");
+	trc_arr = (struct trace *)kmalloc(TRACE_ARR_LEN*sizeof(struct trace),GFP_KERNEL);
+	if(trc_arr == NULL)
+	{
+		printk("Can't allocate Debug Trace buffer\n");
+		return;
+	}
+	memset(trc_arr,0,TRACE_ARR_LEN*sizeof(struct trace));
+	trc_index = 0;
+	trc_callback1 = callback1;
+	trc_callback2 = callback2;
+	trc_param1 = callback1_param;
+	trc_param2 = callback2_param;
+}
+
+void TRC_REC(char *fmt,...)
+{
+	va_list args;
+	struct trace *trc = &trc_arr[trc_index];
+
+	if(trc_active == 0)
+		return;
+
+	do_gettimeofday(&trc->tv);
+	if(trc_callback1)
+		trc->callback_val1 = trc_callback1(trc_param1);
+	if(trc_callback2)
+		trc->callback_val2 = trc_callback2(trc_param2);
+	va_start(args, fmt);
+	vsprintf(trc->str,fmt,args);
+	va_end(args);
+	trc->valid = 1;
+	if((++trc_index) == TRACE_ARR_LEN)
+		trc_index = 0;
+}
+
+void TRC_OUTPUT(void)
+{
+	int i,j;
+	struct trace *p;
+	printk("\n\nTrace %d items\n",TRACE_ARR_LEN);
+	for(i=0,j=trc_index; i<TRACE_ARR_LEN; i++,j++) {
+		if(j == TRACE_ARR_LEN)
+			j = 0;
+		p = &trc_arr[j];
+		if(p->valid) {
+			unsigned long uoffs;
+			struct trace *plast;
+			if(p == &trc_arr[0])
+				plast = &trc_arr[TRACE_ARR_LEN-1];
+			else
+				plast = p-1;
+			if(p->tv.tv_sec == ((plast)->tv.tv_sec))
+				uoffs = (p->tv.tv_usec - ((plast)->tv.tv_usec));
+			else
+				uoffs = (1000000 - ((plast)->tv.tv_usec)) +
+					((p->tv.tv_sec - ((plast)->tv.tv_sec) - 1) * 1000000) +
+					p->tv.tv_usec;
+			printk("%03d: [+%ld usec]", j, (unsigned long)uoffs);
+			if(trc_callback1)
+				printk("[%u]",p->callback_val1);
+			if(trc_callback2)
+				printk("[%u]",p->callback_val2);
+			printk(": %s",p->str);
+		}
+		p->valid = 0;
+	}
+	memset(trc_arr,0,TRACE_ARR_LEN*sizeof(struct trace));
+	trc_index = 0;
+}
+
+void TRC_RELEASE(void)
+{
+	kfree(trc_arr);
+	trc_index = 0;
+}
diff --git a/arch/arm/mach-armada370/dbg-trace.h b/arch/arm/mach-armada370/dbg-trace.h
new file mode 100644
index 0000000..c1ad60b
--- /dev/null
+++ b/arch/arm/mach-armada370/dbg-trace.h
@@ -0,0 +1,24 @@
+
+#ifndef _MV_DBG_TRCE_H_
+#define _MV_DBG_TRCE_H_
+
+#ifdef CONFIG_MV_DBG_TRACE
+void TRC_INIT(void *callback1, void *callback2,
+		unsigned char callback1_param, unsigned char callback2_param);
+void TRC_REC(char *fmt,...);
+void TRC_OUTPUT(void);
+void TRC_RELEASE(void);
+void TRC_START(void);
+void TRC_STOP(void);
+
+#else
+#define TRC_INIT(x1,x2,x3,x4)
+#define TRC_REC(X...)
+#define TRC_OUTPUT()
+#define TRC_RELEASE()
+#define TRC_START()
+#define TRC_STOP()
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-armada370/dump_cp15_regs.c b/arch/arm/mach-armada370/dump_cp15_regs.c
new file mode 100644
index 0000000..5ec2a48
--- /dev/null
+++ b/arch/arm/mach-armada370/dump_cp15_regs.c
@@ -0,0 +1,218 @@
+/*
+ * arch/arm/mach-dove/dump_cp15_regs.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+static int
+proc_dump_cp15_read(char *page, char **start, off_t off, int count, int *eof,
+			void *data)
+{
+	char *p = page;
+	int len;
+	unsigned int value;
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Main ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Cache Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 2": "=r"(value));
+	p += sprintf(p, "TCM Type: 0x%08x\n", value);
+#endif
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3": "=r"(value));
+	p += sprintf(p, "TLB Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 5": "=r"(value));
+	p += sprintf(p, "Microprocessor ID: 0x%08x\n", value);
+#endif
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0": "=r"(value));
+	p += sprintf(p, "Processor Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 1": "=r"(value));
+	p += sprintf(p, "Processor Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 2": "=r"(value));
+	p += sprintf(p, "Debug Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 3": "=r"(value));
+	p += sprintf(p, "Auxiliary Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 4": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 5": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 6": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 0": "=r"(value));
+	p += sprintf(p, "Set Attribute 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 1": "=r"(value));
+	p += sprintf(p, "Set Attribute 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 2": "=r"(value));
+	p += sprintf(p, "Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3": "=r"(value));
+	p += sprintf(p, "Set Attribute 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 4": "=r"(value));
+	p += sprintf(p, "Set Attribute 4: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 5": "=r"(value));
+	p += sprintf(p, "Set Attribute 5: 0x%08x\n", value);
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 1, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Current Cache Size ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 7": "=r"(value));
+	p += sprintf(p, "Silicon ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Cache Size Selection: 0x%08x\n", value);
+
+#endif
+	asm volatile("mrc p15, 0, %0, c1, c0, 0": "=r"(value));
+	p += sprintf(p, "Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2": "=r"(value));
+	p += sprintf(p, "Coprocessor Access Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 0": "=r"(value));
+	p += sprintf(p, "Secure Configuration : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 0": "=r"(value));
+	p += sprintf(p, "Translation Table Base 0 : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 1": "=r"(value));
+	p += sprintf(p, "Translation Table Base 1 : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 2": "=r"(value));
+	p += sprintf(p, "Translation Table Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c3, c0, 0": "=r"(value));
+	p += sprintf(p, "Domain Access Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1": "=r"(value));
+	p += sprintf(p, "Instruction Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 1": "=r"(value));
+	p += sprintf(p, "Watchpoint Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2": "=r"(value));
+	p += sprintf(p, "Instruction Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c7, c10, 6": "=r"(value));
+	p += sprintf(p, "Cache Dirty Status: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 1: 0x%08x\n", value);
+
+#if 1
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Control Configuration: 0x%08x\n", value);
+	p += sprintf(p, "    Write Buffer Coalescing\t: %s\n", (value & (1 << 8)) ?
+		     "Enabled" : "Disabled");
+	if (value & (1 << 8))
+		p += sprintf(p, "    WB WAIT CYC\t: 0x%x\n", (value >> 9) & 0x7);
+
+	p += sprintf(p, "    Coprocessor dual issue \t: %s\n", (value & (1 << 15)) ?
+		     "Disabled" : "Enabled");
+
+	p += sprintf(p, "    L2 write allocate\t: %s\n", (value & (1 << 28)) ?
+		     "Enabled" : "Disabled");
+
+	p += sprintf(p, "    Streaming\t: %s\n", (value & (1 << 29)) ?
+		     "Enabled" : "Disabled");
+#endif
+	asm volatile("mrc p15, 1, %0, c15, c12, 0": "=r"(value));
+	p += sprintf(p, "CPU ID Code Extension: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 0": "=r"(value));
+	p += sprintf(p, "User mode access for PMC registers: %s\n", (value & 1) ?
+		     "Enabled" : "Disabled");
+	asm volatile("mrc p15, 0, %0, c10, c2, 0": "=r"(value));
+	p += sprintf(p, "Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1": "=r"(value));
+	p += sprintf(p, "Memory Attribute NMRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 2": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 1: 0x%08x\n", value);
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+int dump_init_module(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	res = create_proc_entry("mv_dump_cp15", S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+
+	res->read_proc = proc_dump_cp15_read;
+#endif
+
+	return 0;
+}
+
+void dump_cleanup_module(void)
+{
+	remove_proc_entry("mv_dump_cp15", NULL);
+}
+
+module_init(dump_init_module);
+module_exit(dump_cleanup_module);
+
+MODULE_AUTHOR("Saeed Bishara");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-armada370/export.c b/arch/arm/mach-armada370/export.c
new file mode 100644
index 0000000..ed5eebd
--- /dev/null
+++ b/arch/arm/mach-armada370/export.c
@@ -0,0 +1,203 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvOs.h"
+
+
+/*************************************************************************************************************
+ * Environment
+ *************************************************************************************************************/
+extern u32 mvTclk;
+extern u32 mvSysclk;
+
+EXPORT_SYMBOL(mv_early_printk);
+EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlModelRevGet);
+EXPORT_SYMBOL(mvTclk);
+EXPORT_SYMBOL(mvSysclk);
+EXPORT_SYMBOL(mvCtrlModelGet);
+EXPORT_SYMBOL(mvOsIoUncachedMalloc);
+EXPORT_SYMBOL(mvOsIoUncachedFree);
+EXPORT_SYMBOL(mvOsIoCachedMalloc);
+EXPORT_SYMBOL(mvOsIoCachedFree);
+EXPORT_SYMBOL(mvDebugMemDump);
+EXPORT_SYMBOL(mvHexToBin);
+EXPORT_SYMBOL(mvBinToHex);
+EXPORT_SYMBOL(mvSizePrint);
+EXPORT_SYMBOL(mvDebugPrintMacAddr);
+EXPORT_SYMBOL(mvCtrlEthMaxPortGet);
+EXPORT_SYMBOL(mvCtrlTargetNameGet);
+EXPORT_SYMBOL(mvBoardIdGet);
+EXPORT_SYMBOL(mvBoardPhyAddrGet);
+EXPORT_SYMBOL(mvCpuIfTargetWinGet);
+EXPORT_SYMBOL(mvMacStrToHex);
+EXPORT_SYMBOL(mvBoardTclkGet);
+EXPORT_SYMBOL(mvBoardMacSpeedGet);
+EXPORT_SYMBOL(mvWinOverlapTest);
+EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
+EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
+EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
+EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+
+#include "spi/mvSpiCmnd.h"
+EXPORT_SYMBOL(mvSpiWriteThenWrite);
+EXPORT_SYMBOL(mvSpiWriteThenRead);
+#include "spi/mvSpi.h"
+EXPORT_SYMBOL(mvSpiParamsSet);
+#include "gpp/mvGpp.h"
+EXPORT_SYMBOL(mvGppValueSet);
+
+/*************************************************************************************************************
+ * TDM
+ *************************************************************************************************************/
+#if defined(MV_INCLUDE_TDM)
+EXPORT_SYMBOL(mvCtrlTdmUnitIrqGet);
+EXPORT_SYMBOL(mvCtrlTdmUnitTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * Audio
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#include "audio/mvAudio.h"
+#include "mvSysAudioApi.h"
+EXPORT_SYMBOL(mvSPDIFRecordTclockSet);
+EXPORT_SYMBOL(mvSPDIFPlaybackCtrlSet);
+EXPORT_SYMBOL(mvI2SPlaybackCtrlSet);
+EXPORT_SYMBOL(mvAudioPlaybackControlSet);
+EXPORT_SYMBOL(mvAudioDCOCtrlSet);
+EXPORT_SYMBOL(mvI2SRecordCntrlSet);
+EXPORT_SYMBOL(mvAudioRecordControlSet);
+EXPORT_SYMBOL(mvSysAudioInit);
+#endif
+
+/*************************************************************************************************************
+ * USB
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+extern u32 mvIsUsbHost;
+
+#include "usb/mvUsb.h"
+EXPORT_SYMBOL(mvIsUsbHost);
+EXPORT_SYMBOL(mvCtrlUsbMaxGet);
+EXPORT_SYMBOL(mvUsbGetCapRegAddr);
+#ifdef MV_USB_VOLTAGE_FIX
+EXPORT_SYMBOL(mvUsbGppInit);
+EXPORT_SYMBOL(mvUsbBackVoltageUpdate);
+#endif
+#endif /* CONFIG_MV_INCLUDE_USB */
+
+/*************************************************************************************************************
+ * CESA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+#include "mvSysCesaApi.h"
+#include "cesa/mvCesa.h"
+#include "cesa/mvMD5.h"
+#include "cesa/mvSHA1.h"
+extern unsigned char*  mv_sram_usage_get(int* sram_size_ptr);
+
+EXPORT_SYMBOL(mvSysCesaInit);
+EXPORT_SYMBOL(mvCesaSessionOpen);
+EXPORT_SYMBOL(mvCesaSessionClose);
+EXPORT_SYMBOL(mvCesaAction);
+EXPORT_SYMBOL(mvCesaReadyGet);
+EXPORT_SYMBOL(mvCesaCopyFromMbuf);
+EXPORT_SYMBOL(mvCesaCopyToMbuf);
+EXPORT_SYMBOL(mvCesaMbufCopy);
+EXPORT_SYMBOL(mvCesaCryptoIvSet);
+EXPORT_SYMBOL(mvMD5);
+EXPORT_SYMBOL(mvSHA1);
+
+EXPORT_SYMBOL(mvCesaDebugQueue);
+EXPORT_SYMBOL(mvCesaDebugSram);
+EXPORT_SYMBOL(mvCesaDebugSAD);
+EXPORT_SYMBOL(mvCesaDebugStatus);
+EXPORT_SYMBOL(mvCesaDebugMbuf);
+EXPORT_SYMBOL(mvCesaDebugSA);
+EXPORT_SYMBOL(mv_sram_usage_get);
+
+extern u32 mv_crypto_virt_base_get(void);
+extern u32 mv_crypto_phys_base_get(void);
+EXPORT_SYMBOL(mv_crypto_virt_base_get);
+EXPORT_SYMBOL(mv_crypto_phys_base_get);
+EXPORT_SYMBOL(cesaReqResources);
+EXPORT_SYMBOL(mvCesaFinish);
+
+#endif
+
+/*************************************************************************************************************
+ * Flashes
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_INCLUDE_SPI)
+#include <sflash/mvSFlash.h>
+#include <sflash/mvSFlashSpec.h>
+EXPORT_SYMBOL(mvSFlashInit);
+EXPORT_SYMBOL(mvSFlashSectorErase);
+EXPORT_SYMBOL(mvSFlashChipErase);
+EXPORT_SYMBOL(mvSFlashBlockRd);
+EXPORT_SYMBOL(mvSFlashBlockWr);
+EXPORT_SYMBOL(mvSFlashIdGet);
+EXPORT_SYMBOL(mvSFlashWpRegionSet);
+EXPORT_SYMBOL(mvSFlashWpRegionGet);
+EXPORT_SYMBOL(mvSFlashStatRegLock);
+EXPORT_SYMBOL(mvSFlashSizeGet);
+EXPORT_SYMBOL(mvSFlashPowerSaveEnter);
+EXPORT_SYMBOL(mvSFlashPowerSaveExit);
+EXPORT_SYMBOL(mvSFlashModelGet);
+#endif
+
+
+/*************************************************************************************************************
+ * SATA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#include <sata/CoreDriver/mvSata.h>
+EXPORT_SYMBOL(mvSataWinInit);
+#endif
+
+/*************************************************************************************************************
+ * DMA/XOR
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_XOR_MEMCOPY) || defined (CONFIG_MV_IDMA_MEMCOPY)
+EXPORT_SYMBOL(asm_memcpy);
+#endif
+
+#ifdef CONFIG_MV_SP_I_FTCH_DB_INV
+EXPORT_SYMBOL(mv_l2_inv_range);
+#endif
+
+/*************************************************************************************************************
+ * Marvell TRACE
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_DBG_TRACE
+#include "dbg-trace.h"
+EXPORT_SYMBOL(TRC_INIT);
+EXPORT_SYMBOL(TRC_REC);
+EXPORT_SYMBOL(TRC_OUTPUT);
+EXPORT_SYMBOL(TRC_START);
+EXPORT_SYMBOL(TRC_RELEASE);
+#endif
diff --git a/arch/arm/mach-armada370/flashmap.c b/arch/arm/mach-armada370/flashmap.c
new file mode 100644
index 0000000..75dd10d
--- /dev/null
+++ b/arch/arm/mach-armada370/flashmap.c
@@ -0,0 +1,274 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+
+/*#define MTD_FLASH_MAP_DEBUG*/
+
+#ifdef MTD_FLASH_MAP_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+#define MTD_MAX_FLASH_NUMBER	4
+#define MTD_DUMMY_BANK_WIDTH	2
+
+struct maps_init_info
+{
+	struct map_info mapInfo;
+	char ** mtdDrv;
+	struct mtd_info * mtdInfo;
+	char name[32];
+};
+
+static struct maps_init_info maps[MTD_MAX_FLASH_NUMBER];
+static unsigned int mapsNum = 0;
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+static char * cfiDev = "cfi_flash";
+static char * cfiMtdList[] = { "cfi_probe", "jedec_probe", "map_rom", NULL };
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+static char * sflashDev = "spi_flash";
+static char * sflashMtdList[] = {"sflash", NULL};
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition *mtd_parts;
+static int                   mtd_parts_nb;
+static const char *part_probes[] __initdata = {"cmdlinepart", NULL};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static int flashInfoFill(void)
+{
+	int expectedDevs = 0;
+	int devs, i;
+
+	/* clear the whole array */
+	memset((void*)maps, 0x0, sizeof(maps));
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+	/* gather the CFI and JEDEC NOR flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_NOR_FLASH);
+
+	for(i=0; i<devs; i++)
+	{
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER)
+		{
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = cfiMtdList;
+		sprintf(maps[expectedDevs].name, "%s_%d", cfiDev, i);
+		maps[expectedDevs].mapInfo.name = maps[expectedDevs].name;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = (mvBoardGetDeviceBusWidth(i, BOARD_DEV_NOR_FLASH) / 8);
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF))
+		{
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+	          (unsigned int)maps[expectedDevs].mapInfo.phys, (unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		}
+		else
+		{
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)", __FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+	/* gather the SPI flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_SPI_FLASH);
+
+	for(i=0; i<devs; i++)
+	{
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER)
+		{
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = sflashMtdList;
+		maps[expectedDevs].mapInfo.name = sflashDev;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = MTD_DUMMY_BANK_WIDTH;
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF))
+		{
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+						(unsigned int)maps[expectedDevs].mapInfo.phys,
+						(unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		}
+		else
+		{
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+					__FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+	DB(printk("\nINFO: %s - Found %d Flash Devices", __FUNCTION__, expectedDevs));
+	return expectedDevs;
+}
+
+static int flashProbe(char ** mtdDrv, struct map_info * map, struct mtd_info ** mtd)
+{
+	if ((mtdDrv == NULL) || (map == NULL) || (mtd == NULL))
+	{
+		printk(KERN_NOTICE "\nERROR: NULL pointer parameter at %s entry", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* remap the physical address to a virtual address */
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt)
+	{
+		printk(KERN_NOTICE "\nERROR: Failed to ioremap Flash device at physical base 0x%x.", (unsigned int)map->phys);
+		return -EIO;
+	}
+
+	DB(printk("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+				(unsigned int)map->phys, (unsigned int)map->virt));
+
+	simple_map_init(map);
+
+	*mtd = NULL;
+	for(; (!(*mtd) && *mtdDrv); mtdDrv++)
+	{
+		DB(printk("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+					*mtdDrv, map->name, (unsigned int)map->phys,
+					(unsigned int)map->size, map->bankwidth));
+		if ((*mtd = do_map_probe(*mtdDrv, map)))
+		{
+			DB(printk(" - detected OK"));
+			/*map->size = (*mtd)->size;*/
+			(*mtd)->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_PARTITIONS
+			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0);
+
+			if (mtd_parts_nb > 0)
+			{
+				add_mtd_partitions (*mtd, mtd_parts, mtd_parts_nb);
+				return 0;
+			}
+#endif
+
+			if (mtd_device_register(*mtd, NULL,0))
+			{
+				printk(KERN_NOTICE "\nERROR: %s - Failed to add the mtd device", __FUNCTION__);
+				iounmap((void *)map->virt);
+				map->virt = 0;
+				return -ENXIO;
+			}
+
+			return 0;
+		}
+		else
+		{
+			DB(printk(" - Not detected"));
+		}
+	}
+
+	iounmap((void *)map->virt);
+	map->virt = 0;
+	return -ENXIO;
+}
+
+static int __init flash_map_init(void)
+{
+	int i;
+
+	mapsNum = flashInfoFill();
+	DB(printk("\nINFO: flash_map_init - detected %d devices",  mapsNum));
+
+	for (i=0; i<mapsNum; i++)
+	{
+		DB(printk("MTD: Initialize the %s device at address 0x%08x", maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
+		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0)
+		{
+			DB(printk(" - OK.\n"));
+		}
+		else
+		{
+			maps[i].mtdInfo = NULL;
+			DB(printk(" - FAILED!\n"));
+		}
+	}
+
+	return 0;
+}
+
+static void __exit flash_map_exit(void)
+{
+	int i;
+
+	for (i=0; i<mapsNum; i++)
+	{
+		if (maps[i].mtdInfo)
+		{
+			mtd_device_unregister(maps[i].mtdInfo);
+			map_destroy(maps[i].mtdInfo);
+		}
+
+		if (maps[i].mapInfo.virt)
+		{
+			iounmap((void *)maps[i].mapInfo.virt);
+			maps[i].mapInfo.virt = 0;
+		}
+	}
+}
+
+module_init(flash_map_init);
+module_exit(flash_map_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for Marvell platforms");
diff --git a/arch/arm/mach-armada370/hwmon.c b/arch/arm/mach-armada370/hwmon.c
new file mode 100644
index 0000000..0ed155d
--- /dev/null
+++ b/arch/arm/mach-armada370/hwmon.c
@@ -0,0 +1,343 @@
+/*
+ * hwmon-axp.c - temperature monitoring driver for Dove SoC
+ *
+ * Inspired from other hwmon drivers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <asm/io.h>
+//#include <linux/delay.h>
+#include <linux/slab.h>
+//#include "pmu/mvPmuRegs.h"
+
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x18300
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		19
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG				0x18304
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+
+#define ARMADAXP_OVERHEAT_TEMP	105000		/* milidegree Celsius */
+#define ARMADAXP_OVERHEAT_DELAY	0x700
+#define ARMADAXP_OVERCOOL_TEMP	10000		/* milidegree Celsius */
+#define	ARMADAXP_OVERCOOL_DELAY	0x700
+#define ARMADAXP_OVERHEAT_MIN	0
+#define ARMADAXP_OVERHEAT_MAX	110000
+#define ARMADAXP_OVERCOOL_MIN	0
+#define ARMADAXP_OVERCOOL_MAX	110000
+
+/* Junction Temperature */
+#define ARMADAXP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define ARMADAXP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+#if 0
+/* Dove */
+((2281638 - (10 * x)) / 7298)    /* in millCelsius */
+ ((2281638 - (7298 * x)) / 10)
+#endif
+
+#define LABEL "T-junction"
+static struct device *hwmon_dev;
+unsigned int temp_min = ARMADAXP_OVERCOOL_TEMP;
+unsigned int temp_max = ARMADAXP_OVERHEAT_TEMP;
+
+typedef enum {
+	SHOW_TEMP,
+	TEMP_MAX,
+	TEMP_MIN,
+	SHOW_NAME,
+	SHOW_TYPE,
+	SHOW_LABEL } SHOW;
+
+static void axptemp_set_thresholds(unsigned int max, unsigned int min)
+{
+#if 0
+	u32 temp, reg;
+
+	/* Set the overheat threashold & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(max);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
+	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the overcool threshole & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(min);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_COOL_THRSH_MASK;
+	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+#endif
+}
+
+static int axptemp_init_sensor(void)
+{
+	u32 reg;
+
+	/* init the TSEN sensor once */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_OTF_CALIB_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_REF_CAL_MASK);
+	reg |= (0xf1 << 11);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_SOFT_RESET_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	//udelay(1000);
+
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	//udelay(10000);
+
+#if 0
+	/* Set thresholds */
+	axptemp_set_thresholds(temp_max, temp_min);
+
+	/* Set delays */
+	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_BASE | PMU_TM_COOLING_DLY_REG));
+#endif
+
+	return 0;
+}
+
+static int axptemp_read_temp(void)
+{
+	int reg;
+
+	reg = readl(INTER_REGS_BASE | TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+//	value = ((3153000 - (10000 * reg)) / 13825);
+
+	return ARMADAXP_TSEN_RAW2TEMP(reg);
+}
+
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			  *devattr, char *buf) {
+	return sprintf(buf, "%s\n", "axp-hwmon");
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+#if 0
+	int alarm = 0;
+	u32 reg;
+
+	reg = readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG);
+	if (reg & PMU_INT_OVRHEAT_MASK)
+	{
+		alarm = 1;
+		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+	else if (reg & PMU_INT_COOLING_MASK)
+	{
+		alarm = 2;
+		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+#endif
+	return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t show_info(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TYPE)
+		ret = sprintf(buf, "%d\n", 3);
+	else if (attr->index == SHOW_LABEL)
+		ret = sprintf(buf, "%s\n", LABEL);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+	return ret;
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TEMP)
+		ret = sprintf(buf, "%d\n", axptemp_read_temp());
+	else if (attr->index == TEMP_MAX)
+		ret = sprintf(buf, "%d\n", temp_max);
+	else if (attr->index == TEMP_MIN)
+		ret = sprintf(buf, "%d\n", temp_min);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+
+	return ret;
+}
+
+static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
+			 const char *buf, size_t count) {
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	unsigned int temp;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		printk(KERN_WARNING "Invalid input string for temperature!");
+
+	if (attr->index == TEMP_MAX) {
+		if((temp < ARMADAXP_OVERHEAT_MIN) || (temp > ARMADAXP_OVERHEAT_MAX))
+			printk(KERN_WARNING "Invalid max temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERHEAT_MIN, ARMADAXP_OVERHEAT_MAX);
+		else {
+			temp_max = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else if (attr->index == TEMP_MIN) {
+		if((temp < ARMADAXP_OVERCOOL_MIN) || (temp > ARMADAXP_OVERCOOL_MAX))
+			printk(KERN_WARNING "Invalid min temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERCOOL_MIN, ARMADAXP_OVERCOOL_MAX);
+		else {
+			temp_min = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else
+		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
+
+	printk(KERN_INFO "set_temp got string: %d\n", temp);
+
+	return count;
+}
+
+/* TODO - Add read/write support in order to support setting max/min */
+static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
+			  SHOW_TYPE);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_info, NULL,
+			  SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
+			  SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MAX);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MIN);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *axptemp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group axptemp_group = {
+	.attrs = axptemp_attributes,
+};
+
+static int __devinit axptemp_probe(struct platform_device *pdev)
+{
+	int err;
+
+	err = axptemp_init_sensor();
+	if (err)
+		goto exit;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &axptemp_group);
+	if (err)
+		goto exit;
+
+	hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon_dev)) {
+		dev_err(&pdev->dev, "Class registration failed (%d)\n",
+			err);
+		goto exit;
+	}
+
+	printk(KERN_INFO "Armada XP hwmon thermal sensor initialized.\n");
+
+	return 0;
+
+exit:
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	return err;
+}
+
+static int __devexit axptemp_remove(struct platform_device *pdev)
+{
+	struct axptemp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(hwmon_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static int axptemp_resume(struct platform_device *dev)
+{
+	return axptemp_init_sensor();
+}
+
+static struct platform_driver axptemp_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "axp-temp",
+	},
+	.probe = axptemp_probe,
+	.remove = __devexit_p(axptemp_remove),
+	.resume = axptemp_resume,
+};
+
+static int __init axptemp_init(void)
+{
+	return platform_driver_register(&axptemp_driver);
+}
+
+static void __exit axptemp_exit(void)
+{
+	platform_driver_unregister(&axptemp_driver);
+}
+
+MODULE_AUTHOR("Marvell Semiconductors");
+MODULE_DESCRIPTION("Marvell Armada XP SoC hwmon driver");
+MODULE_LICENSE("GPL");
+
+module_init(axptemp_init)
+module_exit(axptemp_exit)
diff --git a/arch/arm/mach-armada370/include/mach/armada370.h b/arch/arm/mach-armada370/include/mach/armada370.h
new file mode 100644
index 0000000..07b1891
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/armada370.h
@@ -0,0 +1,146 @@
+/*
+ * Generic definitions for Marvell Armada MV88F6710 SoC
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_AURORA_H
+#define __ASM_ARCH_AURORA_H
+
+#include <mach/vmalloc.h>
+
+/****************************************************************/
+/******************* System Address Mapping *********************/
+/****************************************************************/
+
+/*
+ * Armada-XP address maps.
+ *
+ * phys		virt		size
+ * e0000000	@runtime	128M	PCIe-0 Memory space
+ * e8000000	@runtime	128M	PCIe-1 Memory space
+ * f0000000	fab00000	16M	SPI-CS0 (Flash)
+ * d0000000	fbb00000	1M	Internal Registers
+ * f1100000	fbc00000	1M	PCIe-0 I/O space
+ * f1200000	fbd00000	1M	PCIe-1 I/O space
+ * f1b00000	fc600000	1M	DMA based UART
+ * f2000000	fc700000	32M	Device-CS0 (NOR Flash)
+ * f4000000	fe700000	1M	Boot-Device CS
+ * f4100000	fe800000	1M	Device-CS1 (NOR Flash)
+ * f4200000	fe900000	1M	Device-CS2 (NOR Flash)
+ * f4300000	fea00000	1M	Device-CS3 (NOR Flash)
+ * f4400000	feb00000	1M	CESA SRAM
+ * f4600000	fed00000	1M	BootROM
+ * f4700000	fee00800	1M	PMU Scratch pad
+ * f4800000	fef00000	1M	Legacy Nand Flash
+ */
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE  		0x00000000
+#define SDRAM_CS0_SIZE  		_256M
+#define SDRAM_CS1_BASE  		0x10000000
+#define SDRAM_CS1_SIZE  		_256M
+#define SDRAM_CS2_BASE  		0x20000000
+#define SDRAM_CS2_SIZE  		_256M
+#define SDRAM_CS3_BASE  		0x30000000
+#define SDRAM_CS3_SIZE  		_256M
+
+/*
+ * PEX Address Decoding
+ * Virtual address not specified - remapped @runtime
+ */
+#define PEX0_MEM_PHYS_BASE		0xE0000000
+#define PEX0_MEM_SIZE			_32M
+#define PEX1_MEM_PHYS_BASE		0xE2000000
+#define PEX1_MEM_SIZE			_32M
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_VIRT_BASE		0xFAB00000
+#define SPI_CS0_SIZE			_16M
+
+#define INTER_REGS_PHYS_BASE		0xD0000000
+#define INTER_REGS_BASE			0xFBB00000
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_VIRT_BASE		0xFBC00000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_VIRT_BASE		0xFBD00000
+#define PEX1_IO_SIZE			_1M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_VIRT_BASE			0xFC600000
+#define UART_SIZE			_1M
+
+#define DEVICE_CS0_PHYS_BASE		0xF2000000
+#define DEVICE_CS0_VIRT_BASE		0xFC700000
+#define DEVICE_CS0_SIZE			_32M
+#define DEVICE_BOOTCS_PHYS_BASE		0xF5000000
+#define DEVICE_BOOTCS_VIRT_BASE		0xF5000000
+#define DEVICE_BOOTCS_SIZE		_16M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_VIRT_BASE		0xFE800000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_VIRT_BASE		0xFE900000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_VIRT_BASE		0xFEA00000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	0xC8010000
+#define CRYPT_ENG_VIRT_BASE(chan)	0xFEB00000
+#define CRYPT_ENG_SIZE			_64K
+
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60A00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFE700000
+#define BOOTROM_SIZE			_1M
+
+#define PMU_SCRATCH_PHYS_BASE		0xF4700000
+#define PMU_SCRATCH_VIRT_BASE		0xFEE00000
+#define PMU_SCRATCH_SIZE		_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_VIRT_BASE		0xFEF00000
+#define LEGACY_NAND_SIZE		_1M
+
+#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+
+/*
+ * Linux native definitiotns
+ */
+#define AXP_UART0_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x12000)
+#define DDR_VIRT_BASE			(INTER_REGS_BASE | 0x00000)
+#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x20000)
+#define AXP_BRIDGE_VIRT_BASE		(INTER_REGS_BASE | 0x20000)
+#define AXP_SW_TRIG_IRQ			(AXP_BRIDGE_VIRT_BASE | 0x0A04)
+#define AXP_PER_CPU_BASE		(AXP_BRIDGE_VIRT_BASE | 0x1000)
+#define AXP_IRQ_VIRT_BASE		(AXP_PER_CPU_BASE)
+#define AXP_IRQ_SEL_CAUSE_OFF		0xA0
+#define AXP_IN_DOORBELL_CAUSE		0x78
+#define AXP_IN_DRBEL_MSK		(AXP_PER_CPU_BASE | 0x7c)
+#define AXP_CPU_RESUME_CTRL_REG		(AXP_BRIDGE_VIRT_BASE | 0x988)
+#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | (0x2124+(cpu)*0x100))
+#define AXP_CPU_RESET_REG(cpu)		(AXP_BRIDGE_VIRT_BASE | (0x800+(cpu)*8))
+#define AXP_L2_CLEAN_WAY_REG		(INTER_REGS_BASE | 0x87BC)
+#define AXP_L2_MNTNC_STAT_REG		(INTER_REGS_BASE | 0x8704)
+#define AXP_ASM_GPP_IRQ_CAUSE_REG	(INTER_REGS_BASE + 0x18110) 	/* level interrupts for gpp cause */
+#define AXP_ASM_GPP_IRQ_MID_CAUSE_REG	(INTER_REGS_BASE + 0x18150) 	/* level interrupts for gpp mid cause */
+#define AXP_ASM_GPP_IRQ_HIGH_CAUSE_REG	(INTER_REGS_BASE + 0x18190) 	/* level interrupts for gpp high cause */
+#define AXP_ASM_GPP_IRQ_MASK_REG        (INTER_REGS_BASE + 0x1811c) 	/* level low mask */
+#define AXP_ASM_GPP_IRQ_MID_MASK_REG	(INTER_REGS_BASE + 0x1815c)	/* level mid mask */
+#define AXP_ASM_GPP_IRQ_HIGH_MASK_REG	(INTER_REGS_BASE + 0x1819c)	/* level high mask */
+#define AXP_ASM_SOC_MAIN_ERR_CAUSE_REG	(INTER_REGS_BASE + 0x20A20)	/* SoC main error cause */
+#define AXP_ASM_SOC_MAIN_ERR_MASK_REG	(INTER_REGS_BASE + 0x218C0)	/* SoC main error mask */
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/clkdev.h b/arch/arm/mach-armada370/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/debug-macro.S b/arch/arm/mach-armada370/include/mach/debug-macro.S
new file mode 100644
index 0000000..51f9fb8
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/debug-macro.S
@@ -0,0 +1,29 @@
+/*
+ * debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <mach/armada370.h>
+
+	.macro  addruart, rp, rv, tmp
+	ldr	\rp, =INTER_REGS_PHYS_BASE
+	ldr	\rv, =INTER_REGS_BASE
+	orr	\rp, \rp, #0x00012000
+	orr	\rv, \rv, #0x00012000
+	.endm
+
+
+#if 0
+	.macro	addruart,rx, tmp
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1					@ MMU enabled?
+	ldreq	\rx, =INTER_REGS_PHYS_BASE
+	ldrne	\rx, =INTER_REGS_BASE
+	orr	\rx, \rx, #0x00012000
+	.endm
+#endif
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-armada370/include/mach/dma.h b/arch/arm/mach-armada370/include/mach/dma.h
new file mode 100644
index 0000000..8e2f2d0
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/dma.h
@@ -0,0 +1,16 @@
+/*
+ * DaVinci DMA definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS			0xffffffff
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-armada370/include/mach/entry-macro.S b/arch/arm/mach-armada370/include/mach/entry-macro.S
new file mode 100644
index 0000000..aab77b6
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/entry-macro.S
@@ -0,0 +1,145 @@
+/*
+ * arch/arm/mach-armada370/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell Armada370 platform
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/armada370.h>
+
+	.macro  disable_fiq
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =AXP_IRQ_VIRT_BASE
+	.endm
+
+#if defined(CONFIG_CPU_BIG_ENDIAN)
+		.macro	HTOLL sr, tt		@ sr   = A  ,B  ,C  ,D
+		eor \tt, \sr, \sr, ror #16 ;    @ temp = A^C,B^
+		bic \tt, \tt, #0xff0000 ;       @ temp = A^C,0  ,C^A,D^B
+		mov \sr, \sr, ror #8 ;          @ sr   = D  ,A  ,B  ,C
+		eor \sr, \sr, \tt, lsr #8       @ sr   = D  ,C  ,B  ,A
+		.endm
+#else
+		.macro	HTOLL sr, tt
+		.endm
+#endif
+	/* TBD - need to be optimized 29*(sel-1) + cls 						*/
+	/* r1 - we shouldnt use it here 							*/
+	/* in case of SMP we only handle bit 0,1 (doorbell) and 5,6 (timer) from cause Vec 0 	*/
+	/* return value is: irqnr and the flag state!!!!!!!!!!!!				*/
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #AXP_IRQ_SEL_CAUSE_OFF]
+	HTOLL	\irqstat, \tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1004f
+	mov 	\tmp, \irqstat
+	mov 	\tmp, \tmp, lsr #29 			@ determine the irq group,
+	bics	\tmp, \tmp, #4 	 			@ clear irq_stat bit
+	bic	\irqstat, \irqstat, #(0xE0000000) 	@ leave irq bits, clear the rest
+	mov    	\irqnr, #0x1F
+	orrs    \irqnr, \irqnr, \tmp, lsl #5    	@ irqnr = 0x1F, 0x3F, 0x5F, 0x7f, make sure Z is off
+	clz	\irqstat, \irqstat	              	@ find first active interrupt source
+	sub	\irqnr, \irqnr, \irqstat
+	mov 	r1, #3
+	mul	\tmp, r1, \tmp
+	sub 	\irqnr, \irqnr, \tmp			@ irqnr = per cpu irq number
+	cmp	\irqnr, #82				@ GPP LOW 0-7
+	beq	1000f
+	cmp	\irqnr, #83				@ GPP LOW 8-15
+	beq	1000f
+	cmp	\irqnr, #84				@ GPP LOW 16-23
+	beq	1000f
+	cmp	\irqnr, #85				@ GPP LOW 24-31
+	beq	1000f
+	cmp	\irqnr, #87				@ GPP LOW 32-39
+	beq	1001f
+	cmp	\irqnr, #88				@ GPP LOW 40-47
+	beq	1001f
+	cmp	\irqnr, #89				@ GPP LOW 48-55
+	beq	1001f
+	cmp	\irqnr, #90				@ GPP LOW 56-63
+	beq	1001f
+	cmp	\irqnr, #91				@ GPP LOW 64-66
+	beq	1002f
+	cmp	\irqnr, #4				@ SoC Main Error Summary
+	beq	1003f
+	b	1004f
+
+1000:
+	ldr     \tmp, =AXP_ASM_GPP_IRQ_MASK_REG
+        ldr     \tmp, [\tmp]    				@ get gpp mask
+        ldr	\irqstat, =AXP_ASM_GPP_IRQ_CAUSE_REG
+        ldr     \irqstat, [\irqstat]                		@ get gpp data in (cause)
+        ands    \irqstat, \irqstat, \tmp                        @ and mask and cause
+	beq	1004f						@ if eq to 0 jump to 1004
+	HTOLL	\irqstat, \tmp
+	clz     \irqnr, \irqstat
+	mov     \tmp, #31
+	subs    \irqnr, \tmp, \irqnr
+	add	\irqnr,\irqnr, #128				@ set GPIO base irq
+	teq     \irqnr, #160                                    @ if irq isn't 160 unset the flag
+	b	1004f
+
+1001:
+	ldr     \tmp, =AXP_ASM_GPP_IRQ_MID_MASK_REG
+        ldr     \tmp, [\tmp]    				@ get gpp mask
+        ldr	\irqstat, =AXP_ASM_GPP_IRQ_MID_CAUSE_REG
+        ldr     \irqstat, [\irqstat]                		@ get gpp data in (cause)
+        ands    \irqstat, \irqstat, \tmp                        @ and mask and cause
+	beq	1004f						@ if eq to 0 jump to 1004
+	HTOLL	\irqstat, \tmp
+	clz     \irqnr, \irqstat
+	mov     \tmp, #31
+	subs    \irqnr, \tmp, \irqnr
+	add	\irqnr,\irqnr, #160				@ set GPIO base irq
+	teq     \irqnr, #192                                    @ if irq isn't 192 unset the flag
+	b	1004f
+
+1002:
+	ldr     \tmp, =AXP_ASM_GPP_IRQ_HIGH_MASK_REG
+        ldr     \tmp, [\tmp]    				@ get gpp mask
+        ldr	\irqstat, =AXP_ASM_GPP_IRQ_HIGH_CAUSE_REG
+        ldr     \irqstat, [\irqstat]                		@ get gpp data in (cause)
+        ands    \irqstat, \irqstat, \tmp                        @ and mask and cause
+	beq	1004f						@ if eq to 0 jump to 1004
+	HTOLL	\irqstat, \tmp
+	clz     \irqnr, \irqstat
+	mov     \tmp, #31
+	subs    \irqnr, \tmp, \irqnr
+	add	\irqnr,\irqnr, #192				@ set GPIO base irq
+	teq     \irqnr, #224                                    @ if irq isn't 224 unset the flag
+	b	1004f
+
+1003:
+	ldr     \tmp, =AXP_ASM_SOC_MAIN_ERR_MASK_REG
+        ldr     \tmp, [\tmp]    				@ get SoC main error mask
+        ldr	\irqstat, =AXP_ASM_SOC_MAIN_ERR_CAUSE_REG
+        ldr     \irqstat, [\irqstat]                		@ get SoC main error cause
+        ands    \irqstat, \irqstat, \tmp                        @ and mask and cause
+	beq	1004f						@ if eq to 0 jump to 1004
+	HTOLL	\irqstat, \tmp
+	clz     \irqnr, \irqstat
+	mov     \tmp, #31
+	subs    \irqnr, \tmp, \irqnr
+	add	\irqnr,\irqnr, #224				@ set GPIO base irq
+	teq     \irqnr, #256                                    @ if irq isn't 256 unset the flag
+	b	1004f
+
+1004:
+	.endm
+
+	.macro test_for_pmuirq, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1005f
+	ands 	\tmp, \irqstat, #0x00000008		@ was it mp
+1005:
+	.endm
diff --git a/arch/arm/mach-armada370/include/mach/gpio.h b/arch/arm/mach-armada370/include/mach/gpio.h
new file mode 100644
index 0000000..7ca789d
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * include/asm-arm/arch-dove/gpio.h
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/errno.h>
+#include <mach/irqs.h>
+#include <plat/gpio.h>
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+
+#define GPIO_MAX	64
+
+#define GPIO_BASE_LO		(AURORA_GPIO_VIRT_BASE + 0x00)
+#define GPIO_BASE_HI		(AURORA_GPIO_VIRT_BASE + 0x20)
+
+#define GPIO_BASE(pin)		((pin < 32) ? GPIO_BASE_LO : GPIO_BASE_HI)
+
+#define GPIO_OUT(pin)		(GPIO_BASE(pin) + 0x00)
+#define GPIO_IO_CONF(pin)	(GPIO_BASE(pin) + 0x04)
+#define GPIO_BLINK_EN(pin)	(GPIO_BASE(pin) + 0x08)
+#define GPIO_IN_POL(pin)	(GPIO_BASE(pin) + 0x0c)
+#define GPIO_DATA_IN(pin)	(GPIO_BASE(pin) + 0x10)
+#define GPIO_EDGE_CAUSE(pin)	(GPIO_BASE(pin) + 0x14)
+#define GPIO_EDGE_MASK(pin)	(GPIO_BASE(pin) + 0x18)
+#define GPIO_LEVEL_MASK(pin)	(GPIO_BASE(pin) + 0x1c)
+
+static inline int gpio_to_irq(int pin)
+{
+	if (pin < NR_GPIO_IRQS)
+		return pin + IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+static inline int irq_to_gpio(int irq)
+{
+	if (IRQ_AURORA_GPIO_START < irq && irq < NR_IRQS)
+		return irq - IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/hardware.h b/arch/arm/mach-armada370/include/mach/hardware.h
new file mode 100644
index 0000000..e31d9aa
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * include/asm-arm/arch-dove/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "armada370.h"
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/ide.h b/arch/arm/mach-armada370/include/mach/ide.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/ide.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-armada370/include/mach/io.h b/arch/arm/mach-armada370/include/mach/io.h
new file mode 100644
index 0000000..f358ee0
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/io.h
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-dove/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "armada370.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define IO_SPACE_REMAP 		PEX0_IO_PHYS_BASE
+
+#define __io(a)			((a) + PEX0_IO_VIRT_BASE)
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(a)
+
+/*#define aurora_setbits(r, mask)	writel(readl(r) | (mask), (r))
+#define aurora_clrbits(r, mask)	writel(readl(r) & ~(mask), (r))*/
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define dma_io_sync()	do {				\
+	writel(0x1, INTER_REGS_BASE + 0x21810);		\
+	while (readl(INTER_REGS_BASE + 0x21810) & 0x1);	\
+} while (0)
+#else
+#define dma_io_sync()	do { } while (0)
+#endif
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/irqs.h b/arch/arm/mach-armada370/include/mach/irqs.h
new file mode 100644
index 0000000..8caadb9
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/irqs.h
@@ -0,0 +1,153 @@
+/*
+ * include/asm-arm/arch-aurora/irqs.h
+ *
+ * IRQ definitions for Marvell Dove MV88F6781 SoC
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * Aurora Low Interrupt Controller
+ */
+
+#define IRQ_AURORA_IN_DRBL_LOW	0
+#define IRQ_AURORA_IN_DRBL_HIGH	1
+#define IRQ_AURORA_OUT_DRBL 	2
+#define IRQ_AURORA_MP		3
+#define IRQ_AURORA_SOC_ERROR	4
+#define IRQ_AURORA_TIMER0	5
+#define IRQ_LOCALTIMER 		IRQ_AURORA_TIMER0
+#define IRQ_AURORA_TIMER1	6
+#define IRQ_AURORA_WD		7
+#define IRQ_AURORA_GBE0_FIC	8
+#define IRQ_AURORA_GBE0_SIC	9
+#define IRQ_AURORA_GBE1_FIC	10
+#define IRQ_AURORA_GBE1_SIC	11
+
+#define IRQ_AURORA_SPI          30
+#define IRQ_AURORA_I2C0		31
+#define IRQ_AURORA_I2C1		32
+
+#define IRQ_AURORA_GLOB_TIMER0	37
+#define IRQ_AURORA_GLOB_TIMER1	38
+#define IRQ_AURORA_GLOB_TIMER2	39
+#define IRQ_AURORA_GLOB_TIMER3	40
+
+#define IRQ_AURORA_UART0	41
+#define IRQ_AURORA_UART1	42
+
+#define IRQ_AURORA_USB0		45
+#define IRQ_AURORA_USB1		46
+#define IRQ_AURORA_USB(x)	(45 + x)
+
+#define IRQ_AURORA_CRYPTO(chan)	48
+
+#define IRQ_AURORA_RTC		50
+
+#define IRQ_AURORA_XOR0_CH0	51
+#define IRQ_AURORA_XOR0_CH1	52
+
+#define IRQ_AURORA_SDIO		54
+#define IRQ_AURORA_SATA0	55
+#define IRQ_AURORA_TDM		56
+#define IRQ_AURORA_SATA1	57
+#define IRQ_AURORA_PCIE0	58
+
+#define IRQ_AURORA_PCIE1	62
+
+#define IRQ_AURORA_GBE0		66
+#define IRQ_AURORA_GBE0_RX	67
+#define IRQ_AURORA_GBE0_TX	68
+#define IRQ_AURORA_GBE0_MISC	69
+#define IRQ_AURORA_GBE1		70
+#define IRQ_AURORA_GBE1_RX	71
+#define IRQ_AURORA_GBE1_TX	72
+#define IRQ_AURORA_GBE1_MISC	73
+
+#define IRQ_AURORA_GPIO_0_7	82
+#define IRQ_AURORA_GPIO_8_15	83
+#define IRQ_AURORA_GPIO_16_23	84
+#define IRQ_AURORA_GPIO_24_31	85
+#define IRQ_AURORA_GPIO_32_39	87
+#define IRQ_AURORA_GPIO_40_47	88
+#define IRQ_AURORA_GPIO_48_55	89
+#define IRQ_AURORA_GPIO_56_63	90
+#define IRQ_AURORA_GPIO_64_66	91
+
+#define IRQ_AURORA_AUDIO	93
+
+#define IRQ_AURORA_XOR1_CH0	94
+#define IRQ_AURORA_XOR1_CH1	95
+
+#define IRQ_AURORA_OUTB_DB0	96
+#define IRQ_AURORA_OUTB_DB1	97
+#define IRQ_AURORA_OUTB_DB2	98
+
+#define IRQ_AURORA_DRAM		108
+#define IRQ_AURORA_NET_WKUP0	109
+#define IRQ_AURORA_NET_WKUP1	110
+
+#define IRQ_AURORA_NFC		113
+#define IRQ_AURORA_MTL_FIX	114
+
+#define IRQ_MAIN_INTS_NUM	115
+
+/*
+ * AURORA General Purpose Pins
+ */
+#define IRQ_AURORA_GPIO_START		128
+#define NR_GPIO_IRQS			96 /* only 67 irqs are valid ,but just to be aligned */
+
+#define GPP_IRQ_TYPE_LEVEL		0
+#define GPP_IRQ_TYPE_CHANGE_LEVEL	1
+
+/*
+ * Aurora Error interrupts
+ */
+
+#define MV_SOC_MAIN_INT_ERR_MASK_REG	0x218C0
+#define MV_SOC_MAIN_INT_ERR_CAUSE_REG	0x20A20
+
+#define IRQ_AURORA_ERR_START		224
+#define NR_SOC_MAIN_ERR_IRQS		32
+
+#define INT_ERR_CESA0         		0
+#define INT_ERR_DEVBUS         		1
+#define INT_ERR_PCIE(unit)		((unit == 0) ? 4 : 5)
+
+/*
+ * IRQ HAL remapping
+ */
+#define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_AURORA_GBE0_FIC + ((x) * 2))
+#define SATA_IRQ_NUM			(IRQ_AURORA_SATA0)
+#define CESA_IRQ(chan)			IRQ_AURORA_CRYPTO(chan)
+#define IRQ_GPP_START			IRQ_AURORA_GPIO_START
+#define IRQ_AURORA_SATA(x)		((x == 0) ? IRQ_AURORA_SATA0 : IRQ_AURORA_SATA1)
+
+#define MV_PCI_MASK_REG(unit)		((unit == 0) ? 0x41910 : 0x81910)
+#define MV_PCI_IRQ_CAUSE_REG(unit)    	((unit == 0) ? 0x41900 : 0x81900)
+#define MV_PCI_MASK_ABCD		(BIT24 | BIT25 | BIT26 | BIT27 )
+
+/* Description for bit from PCI Express Interrupt Mask Register
+** BIT3 - Erroneous Write Attempt to Internal Register
+** BIT4 - Hit Default Window Error
+** BIT6 and BIT7 -Rx and Tx RAM Parity Error
+** BIT9 and BIT10 - Non Fatal and Fatal Error Detected
+** BIT14 - Flow Control Protocol Error
+** BIT23 - Link Failure Indication
+*/
+#define MV_PCI_MASK_ERR                        (BIT3 | BIT4 | BIT6 | BIT7 | BIT9 | BIT10 | BIT14 | BIT23)
+
+#define NR_IRQS			(IRQ_AURORA_ERR_START + NR_SOC_MAIN_ERR_IRQS)
+
+/* Interrupt Macros for backward compatibility */
+#define IRQ_USB_CTRL(x)			((x == 0) ? IRQ_AURORA_USB0 : IRQ_AURORA_USB1)
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/kw_macro.h b/arch/arm/mach-armada370/include/mach/kw_macro.h
new file mode 100644
index 0000000..1209922
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/kw_macro.h
@@ -0,0 +1,39 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Assembler-only file
+ */
+
+
+support_wait_for_interrupt_address:
+        .word   support_wait_for_interrupt
+
+/* rd, rs, rt, re - are temp registers that will b used (non are input/output) */
+.macro mv_flush_all, rd, rs, rt, re
+	mov     \re, #0
+
+        mov     \rd, #(4 - 1) << 30      @ 4 way cache
+        mov     \rs, #(256 * CACHE_DLINESIZE)
+
+1:      orr     \rt, \re, \rd
+2:      mcr     p15, 0, \rt, c7, c14, 2          @ clean & invalidate D index
+        subs    \rt, \rt, #1 << 30
+        bcs     2b                              @ entries 3 to 0
+        add     \re, \re, #32
+        cmp     \re, \rs
+        bne     1b
+
+/* exit */
+	.endm
diff --git a/arch/arm/mach-armada370/include/mach/memory.h b/arch/arm/mach-armada370/include/mach/memory.h
new file mode 100644
index 0000000..aafcbb7
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/memory.h
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-mv78xx0/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET		UL(0x00000000)
+
+/* #define __virt_to_bus(x)	__virt_to_phys(x) */
+/* #define __bus_to_virt(x)	__phys_to_virt(x) */
+
+
+/* Override the ARM default */
+#ifdef CONFIG_FB_AURORA_CONSISTENT_DMA_SIZE
+
+#if (CONFIG_FB_AURORA_CONSISTENT_DMA_SIZE == 0)
+#undef CONFIG_FB_AURORA_CONSISTENT_DMA_SIZE
+#define CONFIG_FB_AURORA_CONSISTENT_DMA_SIZE 2
+#endif
+
+#define CONSISTENT_DMA_SIZE \
+	(((CONFIG_FB_AURORA_CONSISTENT_DMA_SIZE + 1) & ~1) * 1024 * 1024)
+
+#endif
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define arch_is_coherent()  1
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/param.h b/arch/arm/mach-armada370/include/mach/param.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/param.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-armada370/include/mach/serial.h b/arch/arm/mach-armada370/include/mach/serial.h
new file mode 100644
index 0000000..7af1a8f
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/serial.h
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/irq.h>
+
+#include "../arch/arm/mach-armada370/config/mvSysHwConfig.h"
+
+extern unsigned int mvTclk;
+
+#undef  BASE_BAUD
+#define BASE_BAUD (mvTclk / 16)
+
+#define PORT0_BASE	(INTER_REGS_BASE + 0x12000) /* port 0 base */
+#define PORT1_BASE 	(INTER_REGS_BASE + 0x12100) /* port 1 base */
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST /* | ASYNC_SPD_VHI  115200 */ )
+
+#define STD_SERIAL_PORT_DEFNS
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/smp.h b/arch/arm/mach-armada370/include/mach/smp.h
new file mode 100644
index 0000000..1f6a67d
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/smp.h
@@ -0,0 +1,29 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+#include <asm/io.h>
+#include <mach/armada370.h>
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void smp_cross_call(const struct cpumask *mask)
+{
+	unsigned long map = *cpus_addr(*mask);
+	void __iomem *addr = (void __iomem *)(AXP_SW_TRIG_IRQ);
+
+	//printk("smp_cross_call %x \n",(unsigned int)( ((map & 0x3) << 8) | 0x0) );
+	writel( ( ((map & 0xf) << 8) | 0x0), addr);
+
+	return;
+}
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/system.h b/arch/arm/mach-armada370/include/mach/system.h
new file mode 100644
index 0000000..e0b189f
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/mach/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
+#define LSP_PG_SZ_VER  " (Large Page)"
+#else
+#define LSP_PG_SZ_VER  ""
+#endif
+#define LSP_VERSION    "Armada370_LSP_3.1.0_NQ" LSP_PG_SZ_VER
+
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk("Reseting...\n");
+	mvBoardReset();
+	while (1);/* This should never be reached */
+}
+
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/timex.h b/arch/arm/mach-armada370/include/mach/timex.h
new file mode 100644
index 0000000..c8cf294
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-dove/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
diff --git a/arch/arm/mach-armada370/include/mach/uncompress.h b/arch/arm/mach-armada370/include/mach/uncompress.h
new file mode 100644
index 0000000..2927925
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/uncompress.h
@@ -0,0 +1,133 @@
+/*
+ * include/asm-arm/arch-aurora/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/armada370.h>
+
+#define UART_THR ((volatile unsigned char *)(AXP_UART0_PHYS_BASE + 0x0))
+#define UART_LSR ((volatile unsigned char *)(AXP_UART0_PHYS_BASE + 0x14))
+
+#define LSR_THRE	0x20
+
+static void putc(const char c)
+{
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		/* Transmit fifo not full? */
+		if (*UART_LSR & LSR_THRE)
+			break;
+	}
+
+	*UART_THR = c;
+}
+
+static void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#if 0
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include <linux/autoconf.h>
+#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
+#include <linux/serial_reg.h>
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+
+#if 0
+static void putc(const char c)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+#endif
+#if 0
+static void flush(void)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+#endif
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+#endif
diff --git a/arch/arm/mach-armada370/include/mach/vmalloc.h b/arch/arm/mach-armada370/include/mach/vmalloc.h
new file mode 100644
index 0000000..da4836c
--- /dev/null
+++ b/arch/arm/mach-armada370/include/mach/vmalloc.h
@@ -0,0 +1,10 @@
+/*
+ * include/asm-arm/arch-aurora/vmalloc.h
+ */
+
+/* Dove LCD driver performs big allocations for FrameBuffer memory, we need to
+ * move CONSISTENT_BASE by 32MB
+ */
+/* Was 0x2000000 */
+
+#define VMALLOC_END	(0xfa800000)
diff --git a/arch/arm/mach-armada370/irq.c b/arch/arm/mach-armada370/irq.c
new file mode 100644
index 0000000..64b3e9f
--- /dev/null
+++ b/arch/arm/mach-armada370/irq.c
@@ -0,0 +1,160 @@
+/*
+ * arch/arm/mach/irq.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvOs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+unsigned int  irq_int_type[NR_IRQS];
+
+static void axp_unmask_fabric_interrupt(void)
+{
+	u32 val;
+
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG);
+	val |= 1;
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG, val);
+}
+
+static void axp_mask_fabric_interrupt(void)
+{
+	u32 val;
+
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG);
+	val &=  ~1;
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG, val);
+}
+
+void axp_irq_mask(struct irq_data *d)
+{
+
+	u32 irq=d->irq;
+
+	if (irq < IRQ_MAIN_INTS_NUM) {
+		MV_REG_BIT_RESET(CPU_INT_SOURCE_CONTROL_REG(irq), BIT0);
+
+	}
+	else if (irq < (IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)) {
+		MV_U32 bitmask = 1 << (irq & 0x1F);
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+	else if (irq < (IRQ_AURORA_ERR_START + NR_SOC_MAIN_ERR_IRQS)) {
+		MV_U32 bitmask = (1 << (irq - IRQ_AURORA_ERR_START));
+		MV_REG_BIT_RESET(MV_SOC_MAIN_INT_ERR_MASK_REG, bitmask);
+	}
+	else
+		printk("%s: Error, invalid irqnr(%u)\n", __func__, irq);
+}
+
+void axp_irq_unmask(struct irq_data *d)
+{
+        u32 irq=d->irq;
+	if (irq < IRQ_MAIN_INTS_NUM) {
+		if(irq < 16)
+			MV_REG_BIT_SET(CPU_INT_SOURCE_CONTROL_REG(irq), BIT0);
+		else
+			MV_REG_BIT_SET(CPU_INT_SOURCE_CONTROL_REG(irq), (BIT0 | BIT28));
+	}
+	else if (irq < (IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)) {
+		MV_U32 bitmask = 1 << (irq & 0x1F);
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+	else if (irq < (IRQ_AURORA_ERR_START + NR_SOC_MAIN_ERR_IRQS)) {
+		MV_U32 bitmask = (1 << (irq - IRQ_AURORA_ERR_START));
+		MV_REG_BIT_SET(MV_SOC_MAIN_INT_ERR_MASK_REG, bitmask);
+	}
+	else
+		printk("%s: Error, invalid irqnr(%u)\n", __func__, irq);
+}
+
+
+static struct irq_chip axp_irq_chip = {
+	.name		= "armada370_irq",
+	.irq_mask	= axp_irq_mask,
+	.irq_mask_ack	= axp_irq_mask,
+	.irq_unmask	= axp_irq_unmask,
+	.irq_disable	= axp_irq_mask,
+	.irq_enable	= axp_irq_unmask,
+};
+
+
+void __init axp_init_irq(void)
+{
+	u32 irq, i;
+
+	/* MASK all interrupts */
+	for (irq = 0; irq < IRQ_MAIN_INTS_NUM; irq++) {
+		axp_irq_mask(irq_get_irq_data(irq));
+	}
+
+	/* Clear SoC main error masks & cause registers */
+	MV_REG_WRITE(MV_SOC_MAIN_INT_ERR_MASK_REG, 0);
+	MV_REG_WRITE(MV_SOC_MAIN_INT_ERR_CAUSE_REG, 0);
+
+	/* Enable SoC main error summary bit */
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_SOC_ERROR));
+
+	/* Disable and clear all GPIO interrupts */
+        for(i = 0; i < MV_GPP_MAX_GROUP; i++) {
+                MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+        }
+
+	/* Init GPP IRQs in default level mode */
+	for (i = 0; i < NR_IRQS; i++)
+		irq_int_type[i] = GPP_IRQ_TYPE_LEVEL;
+
+	/* Enable GPIO interrupts */
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_0_7));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_8_15));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_16_23));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_24_31));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_32_39));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_40_47));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_48_55));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_56_63));
+	axp_irq_unmask(irq_get_irq_data(IRQ_AURORA_GPIO_64_66));
+
+	/* Register IRQ sources */
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		irq_set_chip(irq, &axp_irq_chip);
+		irq_set_chip_data(irq, 0);
+		irq_set_handler(irq, handle_level_irq);
+		irq_set_status_flags(irq,IRQ_LEVEL);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
+
+int pmu_request_irq(int irq, irq_handler_t handler)
+{
+	int ret = request_irq(irq, handler, IRQF_DISABLED | IRQF_NOBALANCING, "armpmu", NULL);
+	if (!ret)
+		axp_unmask_fabric_interrupt();
+
+	return ret;
+}
+
+void pmu_free_irq(int irq)
+{
+	axp_mask_fabric_interrupt();
+	free_irq(irq, NULL);
+}
diff --git a/arch/arm/mach-armada370/leds.c b/arch/arm/mach-armada370/leds.c
new file mode 100644
index 0000000..f611b5a
--- /dev/null
+++ b/arch/arm/mach-armada370/leds.c
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include "boardEnv/mvBoardEnvLib.h"
+
+static	u32		last_jiffies = 0;
+static	u32		led_val = 0;
+
+
+void mv_leds_hearbeat(void)
+{
+	u32 sec = jiffies_to_msecs(jiffies - last_jiffies) / 1000;
+
+	if (!sec)
+		return;
+
+	led_val = (led_val % (1 << mvBoardDebugLedNumGet(mvBoardIdGet())));
+	mvBoardDebugLed(led_val);
+	led_val++;
+	last_jiffies = jiffies;
+}
+
+static int __init leds_init(void)
+{
+	return 0;
+}
+
+__initcall(leds_init);
diff --git a/arch/arm/mach-armada370/mpp.h b/arch/arm/mach-armada370/mpp.h
new file mode 100644
index 0000000..1065468
--- /dev/null
+++ b/arch/arm/mach-armada370/mpp.h
@@ -0,0 +1,34 @@
+#ifndef __ARCH_DOVE_MPP_H
+#define __ARCH_DOVE_MPP_H
+
+enum aurora_mpp_type {
+	/*
+	 * This MPP is unused.
+	 */
+	MPP_UNUSED,
+
+	/*
+	 * This MPP pin is used as a generic GPIO pin.
+	 */
+	MPP_GPIO,
+
+        /*
+         * This MPP is used as a SATA activity LED.
+         */
+        MPP_SATA_LED,
+        /*
+         * This MPP is used as a functional pad.
+         */
+        MPP_FUNCTIONAL,
+
+};
+
+struct aurora_mpp_mode {
+	int			mpp;
+	enum aurora_mpp_type	type;
+};
+
+void aurora_mpp_conf(struct aurora_mpp_mode *mode);
+
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysAudio.c b/arch/arm/mach-armada370/mv_hal_if/mvSysAudio.c
new file mode 100644
index 0000000..065f919
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysAudio.c
@@ -0,0 +1,175 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "audio/mvAudio.h"
+#include "audio/mvAudioRegs.h"
+
+
+/*******************************************************************************
+* mvSysAudioInit - Initialize the Audio subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysAudioInit(MV_U8 unit)
+{
+	MV_AUDIO_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status = MV_OK;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvAudioWinInit(unit, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.tclk = mvBoardTclkGet();
+		mvAudioHalInit(unit,&halData);
+	}
+
+	return status;
+}
+
+#if 0
+/*******************************************************************************
+* mvSysAudioCodecRegRead
+*
+* DESCRIPTION:
+*	System interface for reading an Audio codec register.
+*
+* INPUT:
+*       codecHandle: Handle passed by OS glue by which an audio codec is
+*		     identified.
+*       regOffset:   Offset of codec register to be read.
+*
+* OUTPUT:
+*       regData:     Register data
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysAudioCodecRegRead(MV_VOID *codecHandle, MV_U32  regOffset, MV_U32 *regData)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = mvBoardA2DTwsiAddrGet(0);
+	slave.slaveAddr.type = mvBoardA2DTwsiAddrTypeGet(0);
+	slave.validOffset = MV_TRUE;
+	slave.offset = regOffset;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(mvBoardA2DTwsiChanNumGet(0), &slave, (MV_U8*)regData, 1);
+}
+
+
+/*******************************************************************************
+* mvSysAudioCodecRegWrite
+*
+* DESCRIPTION:
+*	System interface for writing an Audio codec register.
+*
+* INPUT:
+*       codecHandle: Handle passed by OS glue by which an audio codec is
+*		     identified.
+*       regOffset:   Offset of codec register to be written.
+*       regData:     Register data to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysAudioCodecRegWrite(MV_VOID *codecHandle, MV_U32  regOffset, MV_U32 regData)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = mvBoardA2DTwsiAddrGet(0);
+	slave.slaveAddr.type = mvBoardA2DTwsiAddrTypeGet(0);
+	slave.validOffset = MV_TRUE;
+	slave.offset = regOffset;
+	slave.moreThen256 = MV_FALSE;
+
+	return	mvTwsiWrite(mvBoardA2DTwsiChanNumGet(0), &slave, (MV_U8*)&regData, 1);
+}
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysAudioApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysAudioApi.h
new file mode 100644
index 0000000..402b3f6
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysAudioApi.h
@@ -0,0 +1,72 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_AUDIO_API_H__
+#define __MV_SYS_AUDIO_API_H__
+
+
+MV_STATUS mvSysAudioInit(MV_U8 unit);
+MV_VOID mvAudioAddrDecShow(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysCesa.c b/arch/arm/mach-armada370/mv_hal_if/mvSysCesa.c
new file mode 100644
index 0000000..3d0dec5
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysCesa.c
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mv_cesa/cesa_if.h"
+
+extern u32 mv_crypto_phys_base_get(u8 chan);
+extern u32 mv_crypto_virt_base_get(u8 chan);
+
+/*******************************************************************************
+* mvSysCesaInit - Initialize the Cesa subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle)
+{
+	MV_CESA_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	MV_U8 chan;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+
+	if(status == MV_OK) {
+		for(chan = 0; chan < MV_CESA_CHANNELS; chan++) {
+			status = mvCesaIfTdmaWinInit(chan, addrWinMap);
+
+			if(status != MV_OK) {
+				mvOsPrintf("Error, unable to initialize CESA windows for channel(%d)\n", chan);
+				break;
+			}
+			halData.sramPhysBase[chan] = (MV_ULONG)mv_crypto_phys_base_get(chan);
+			halData.sramVirtBase[chan] = (MV_U8*)mv_crypto_virt_base_get(chan);
+#ifdef CONFIG_ARMADA_SUPPORT_DEEP_IDLE_FAST_EXIT
+			halData.sramOffset[chan] = 32;
+#else
+			halData.sramOffset[chan] = 0;
+#endif
+		}
+
+		if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+			status = mvCesaIfInit (numOfSession, queueDepth,
+					osHandle, &halData);
+	}
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysCesaApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysCesaApi.h
new file mode 100644
index 0000000..ce8aa9b
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysCesaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_CESA_API_H__
+#define __MV_SYS_CESA_API_H__
+
+
+MV_STATUS mvSysCesaInit (int numOfSession, int queueDepth, void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysDdr.c b/arch/arm/mach-armada370/mv_hal_if/mvSysDdr.c
new file mode 100644
index 0000000..b6e992d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysDdr.c
@@ -0,0 +1,133 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+
+/*******************************************************************************
+* mvSysDdrSpdRead
+*
+* DESCRIPTION:
+*	System interface for reading DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer to read data into.
+*       size:	Number of bytes to read.
+*
+* OUTPUT:
+*       data:	SPD data.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
+
+/*******************************************************************************
+* mvSysDdrSpdWrite
+*
+* DESCRIPTION:
+*	System interface for writing DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer holding the data to be written.
+*       size:	Number of bytes to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return	mvTwsiWrite(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysEth.c b/arch/arm/mach-armada370/mv_hal_if/mvSysEth.c
new file mode 100644
index 0000000..f6f9acc
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysEth.c
@@ -0,0 +1,131 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "eth/mvEth.h"
+
+
+/*******************************************************************************
+* mvSysEthInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysEthInit(MV_VOID)
+{
+	MV_ETH_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status != MV_OK)
+		return;
+
+	{
+		int i;
+		for(i = 0; i < MAX_TARGETS; i++) {
+			if(addrWinMap[i].enable == MV_FALSE)
+				continue;
+			printk("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+					addrWinMap[i].addrWin.baseLow,
+					addrWinMap[i].addrWin.size);
+		}
+	}
+	halData.maxPortNum = mvCtrlEthMaxPortGet();
+	halData.cpuPclk = mvCpuPclkGet();
+	halData.tclk = mvBoardTclkGet();
+#ifdef ETH_DESCR_IN_SRAM
+	halData.sramSize = mvCtrlSramSizeGet();
+#endif
+
+	for (port=0;port < halData.maxPortNum;port++) {
+		if(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE) {
+			halData.portData[port].powerOn = MV_FALSE;
+			continue;
+		}
+		status = mvEthWinInit(port, addrWinMap);
+		if(status == MV_OK) {
+			halData.portData[port].powerOn = MV_TRUE;
+			halData.portData[port].phyAddr = mvBoardPhyAddrGet(port);
+			halData.portData[port].isSgmii = mvBoardIsPortInSgmii(port);
+			halData.portData[port].macSpeed = mvBoardMacSpeedGet(port);
+		}
+	}
+
+	mvEthHalInit(&halData);
+
+	return;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysEthApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysEthApi.h
new file mode 100644
index 0000000..e1016e4
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysEthApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETH_API_H__
+#define __MV_SYS_ETH_API_H__
+
+
+MV_VOID mvSysEthInit(void);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhy.c b/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhy.c
new file mode 100644
index 0000000..d817e71
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhy.c
@@ -0,0 +1,104 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "eth-phy/mvEthPhy.h"
+#if defined(MV_ETH_LEGACY)
+#include "eth/gbe/mvEthRegs.h"
+#else
+#include "neta/gbe/mvEthRegs.h"
+#endif
+
+
+/*******************************************************************************
+* mvSysEthPhyInit - Initialize the EthPhy subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysEthPhyInit(void)
+{
+	MV_ETHPHY_HAL_DATA halData;
+	MV_U32 port;
+
+	for (port=0; port < mvCtrlEthMaxPortGet(); port++) {
+		halData.phyAddr[port] = mvBoardPhyAddrGet(port);
+		halData.boardSpecInit = MV_FALSE;
+	}
+
+	halData.ethPhySmiReg = ETH_SMI_REG(MV_ETH_SMI_PORT);
+
+	return mvEthPhyHalInit(&halData);
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhyApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhyApi.h
new file mode 100644
index 0000000..eab268a
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysEthPhyApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETHPHY_API_H__
+#define __MV_SYS_ETHPHY_API_H__
+
+
+MV_STATUS mvSysEthPhyInit(void);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c b/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
new file mode 100644
index 0000000..4030f25
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
@@ -0,0 +1,149 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "neta/gbe/mvNeta.h"
+
+
+/*******************************************************************************
+* mvSysNetaInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+void 	mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask)
+{
+	MV_NETA_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	int i;
+
+	memset(&halData, 0, sizeof(halData));
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK)
+		return;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (addrWinMap[i].enable == MV_FALSE)
+			continue;
+
+#ifdef CONFIG_MV_SUPPORT_L2_DEPOSIT
+		/* Setting DRAM windows attribute to :
+		   0x3 - Shared transaction + L2 write allocate (L2 Deposit) */
+		if (MV_TARGET_IS_DRAM(i)) {
+			addrWinMap[i].attrib &= ~(0x30);
+			addrWinMap[i].attrib |= 0x30;
+		}
+#endif
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+                                addrWinMap[i].addrWin.baseLow,
+                                addrWinMap[i].addrWin.size);
+	}
+	halData.portMask = portMask;
+	halData.cpuMask  = cpuMask;
+
+	halData.maxPort = mvCtrlEthMaxPortGet();
+	halData.pClk = mvCpuPclkGet();
+	halData.tClk = mvBoardTclkGet();
+	halData.maxCPUs = mvCtrlEthMaxCPUsGet();
+	halData.iocc = arch_is_coherent();
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+#ifdef CONFIG_MV_ETH_BM
+	halData.bmPhysBase = PNC_BM_PHYS_BASE;
+	halData.bmVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_BM */
+
+#ifdef CONFIG_MV_ETH_PNC
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_PNC */
+
+	for (port = 0; port < halData.maxPort; port++) {
+		if (!(MV_BIT_CHECK(portMask, port)))
+			continue;
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE)
+			continue;
+
+		mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), mvBoardIsPortInRgmii(port));
+		status = mvNetaWinInit(port, addrWinMap);
+		if (status != MV_OK)
+			continue;
+	}
+	mvNetaHalInit(&halData);
+
+	return;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysNetaApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysNetaApi.h
new file mode 100644
index 0000000..2c4a08d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysNetaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_NETA_API_H__
+#define __MV_SYS_NETA_API_H__
+
+
+void mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask);
+
+#endif /* __MV_SYS_NETA_API_H__ */
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysPci.c b/arch/arm/mach-armada370/mv_hal_if/mvSysPci.c
new file mode 100644
index 0000000..435181b
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysPci.c
@@ -0,0 +1,1422 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysPci.h"
+#include "ddr2_3/mvDramIf.h"
+
+/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
+/* register offsets	and its function where its is located.			*/
+/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
+/* describes address remap register offsets					*/
+typedef struct _pciBarRegInfo
+{
+	MV_U32 funcNum;
+	MV_U32 baseLowRegOffs;
+	MV_U32 baseHighRegOffs;
+	MV_U32 sizeRegOffs;
+	MV_U32 remapLowRegOffs;
+	MV_U32 remapHighRegOffs;
+}PCI_BAR_REG_INFO;
+
+typedef struct _pciBarStatus
+{
+	MV_PCI_BAR	bar;
+	int		enable;
+}PCI_BAR_STATUS;
+
+PCI_BAR_STATUS pciBarStatusMap[] =
+{
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	{CS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+        {CS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+        {CS2_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+        {CS3_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	{DEVCS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	{DEVCS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	{DEVCS2_BAR, EN},
+#endif
+	{BOOTCS_BAR, EN},
+	{MEM_INTER_REGS_BAR, EN},
+	{IO_INTER_REGS_BAR, EN},
+	{P2P_MEM0, DIS},
+	{P2P_IO, DIS},
+	{TBL_TERM, TBL_TERM}
+};
+
+/* PCI BAR table. Note that table entry number must match its target 		*/
+/* enumerator. For example, table entry '4' must describe Deivce CS0 		*/
+/* target which is represent by DEVICE_CS0 enumerator (4).                  */
+#if 0
+MV_PCI_BAR_WIN pciBarMap[] =
+{
+/*     base low      base high      size        enable/disable				*/
+	{{SDRAM_CS0_BASE , 0, SDRAM_CS0_SIZE      	 },   EN},
+	{{SDRAM_CS1_BASE , 0, SDRAM_CS1_SIZE      	 },   EN},
+	{{SDRAM_CS2_BASE , 0, SDRAM_CS2_SIZE      	 },   EN},
+	{{SDRAM_CS3_BASE , 0, SDRAM_CS3_SIZE      	 },   EN},
+	{{DEVICE_CS0_BASE, 0, DEVICE_CS0_SIZE     	 },   EN},
+	{{DEVICE_CS1_BASE, 0, DEVICE_CS1_SIZE     	 },   EN},
+	{{DEVICE_CS2_BASE, 0, DEVICE_CS2_SIZE     	 },   EN},
+	{{BOOTDEV_CS_BASE, 0, BOOTDEV_CS_SIZE     	 },   EN},
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS}, 	/* Ignore P2P 	*/
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS},	/* Ignore P2P 	*/
+    /* Table terminator */
+    {{TBL_TERM, TBL_TERM, TBL_TERM}, TBL_TERM}
+};
+#endif
+
+/* Locals */
+static MV_U32 pciBurstBytes2Reg(MV_U32 size);
+static MV_U32 pciBurstReg2Bytes(MV_U32 size);
+
+static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar,
+									 MV_ADDR_WIN *pAddrWin);
+
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, MV_PCI_BAR bar,
+								  PCI_BAR_REG_INFO *pBarRegInfo);
+
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
+
+/* Forward declarations */
+const MV_8* pciBarNameGet(MV_PCI_BAR bar);
+
+static MV_TARGET pciBarToTarget(MV_PCI_BAR bar)
+{
+    switch(bar)
+    {
+	#if defined(MV_INCLUDE_SDRAM_CS0)
+	case CS0_BAR:
+			return SDRAM_CS0;
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS1)
+	case CS1_BAR:
+			return SDRAM_CS1;
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS2)
+	case CS2_BAR:
+			return SDRAM_CS2;
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS3)
+	case CS3_BAR:
+			return SDRAM_CS3;
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS0)
+	case DEVCS0_BAR:
+			return DEVICE_CS0;
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS1)
+	case DEVCS1_BAR:
+			return DEVICE_CS1;
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS2)
+	case DEVCS2_BAR:
+			return DEVICE_CS2;
+	#endif
+	case BOOTCS_BAR:
+			return  DEV_BOOCS;
+	case MEM_INTER_REGS_BAR:
+	case IO_INTER_REGS_BAR:
+			return  INTER_REGS;
+
+	default:
+		mvOsPrintf("pciBarToTarget: ERR. no such target\n");
+    }
+
+	return -1;
+
+}
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*       This function initiate the PCI interface:
+*       1) Set local bus number. In case of convential PCI it gets the bus
+*          number using mvPciLocalBusNumGet(). In case of PCI-X this
+*          information is read only.
+*       2) Interface device number. In case of conventional PCI it gets the
+*          device number using mvPciLocalDevNumGet(). In case of PCI-X this
+*          information is read only.
+*       3) PCI Arbiter if needed.
+*       4) Enable Master and Slave on PCI interfaces.
+*	5) Open PCI BARs according to default setting.
+*	   Note that PCI bridge (P2P) is NOT initialized.
+*	6) Enable CPU to PCI ordering.
+*
+* INPUT:
+*
+*       pciIf   - PCI interface number.
+*		localBus - Local Bus of the PCI interface to be set
+*		localDev - Local Dev of the PCI interface to be set
+*		bFirstCall - Indicates wether this is the first call of this
+*					 function .
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
+{
+	MV_PCI_BAR     bar, barix=0;
+	MV_PCI_MODE    pciMode;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_PCI_PROT_WIN pciProtWin;
+	MV_PCI_BAR_WIN pciBarMap[PCI_MAX_BARS];
+
+	/* Parameter checking  */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	/* device and bus numbers */
+	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
+		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
+		return MV_ERROR;
+	}
+
+	/* First disable all PCI target windows  */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++)
+		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+
+	/* WA CQ 4382*/
+	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf) ,BIT15);
+
+	/* Loop over all BARs and copy enabled SDRAM windows only */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++) {
+		if ((bar >= CS0_BAR) && (bar <= CS3_BAR)) {
+			if (mvCpuIfTargetWinGet(pciBarToTarget(bar), &addrDecWin) == MV_OK) {
+				if (addrDecWin.enable) {
+					pciBarMap[barix].addrWin.baseLow = addrDecWin.addrWin.baseLow;
+					pciBarMap[barix].addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+					pciBarMap[barix].addrWin.size = addrDecWin.addrWin.size;
+					pciBarMap[barix].enable = EN;
+					barix++;
+				}
+			}
+		}
+	}
+
+	/* Initialize all non used BARs */
+	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
+		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
+		pciBarMap[bar].addrWin.baseHigh = 0;
+		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
+		pciBarMap[bar].enable = DIS;
+	}
+
+	/* finally fill table with TBL_TERM entry */
+	bar = PCI_MAX_BARS - 1;
+	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
+	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
+	pciBarMap[bar].addrWin.size = TBL_TERM;
+	pciBarMap[bar].enable =  TBL_TERM;
+
+
+	/* Memory Mapped Internal Registers BAR can not be disabled.            */
+	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
+	if (MV_OK != mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR, &pciBarMap[MEM_INTER_REGS_BAR])) {
+		mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	/* Now, go through all targets in default table until table terminator	*/
+	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++)
+	{
+		/* Skip the P2P BARs. They should be configured seperately			*/
+		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
+			continue;
+
+		/* check if the size passed is zero ! */
+		if (0 == pciBarMap[bar].addrWin.size) {
+			/* disable the bar */
+			mvPciTargetWinEnable(pciIf,bar,MV_FALSE);
+			continue;
+		}
+
+		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
+			mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet %d failed\n", bar);
+			return MV_ERROR;
+		}
+	}
+
+	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf), PADCR_REMAP_REG_WR_DIS);
+
+	/* configure access control unit 0 to DDR to enhance performance */
+	pciProtWin.addrWin.baseLow = 0;
+	pciProtWin.addrWin.baseHigh = 0;
+	pciProtWin.addrWin.size = mvDramIfSizeGet();
+#ifdef AURORA_IO_CACHE_COHERENCY
+	pciProtWin.attributes.snoop = WT_CACHE_COHER;
+#else
+	pciProtWin.attributes.snoop = NO_CACHE_COHER;
+#endif
+	pciProtWin.attributes.access = ALLOWED;
+	pciProtWin.attributes.write = ALLOWED;
+	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
+	pciProtWin.attributes.readMaxBurst = 128;
+	pciProtWin.attributes.readBurst = 256;
+	pciProtWin.attributes.writeMaxBurst = 128;
+	pciProtWin.attributes.pciOrder = MV_FALSE;
+	pciProtWin.enable = MV_TRUE;
+	if( mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK ) {
+		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	mvPciHalInit(pciIf, pciIfmod);
+
+	return MV_OK;
+}
+
+
+
+/*******************************************************************************
+* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
+*
+* DESCRIPTION:
+*       This function sets an address window from PCI to a peripheral
+*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs.
+*       A new PCI BAR window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing PCI to access
+*       the target window.
+*
+* INPUT:
+*       pciIf       - PCI interface number.
+*       bar         - BAR to be accessed by slave.
+*       pAddrBarWin - PCI target window information data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params
+*       MV_ERROR otherwise
+*       (e.g. address window overlapps with other active PCI target window).
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf,
+							MV_PCI_BAR bar,
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 pciData;
+	MV_U32 sizeToReg;
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	size     = pAddrBarWin->addrWin.size;
+	baseLow  = pAddrBarWin->addrWin.baseLow;
+	baseHigh = pAddrBarWin->addrWin.baseHigh;
+
+	/* Parameter checking   */
+	if(pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if(bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+
+	/* if the address windows is disabled , we only disable the appropriare
+	pci bar and ignore other settings */
+
+	if (MV_FALSE == pAddrBarWin->enable)
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+		return MV_OK;
+	}
+
+	if (0 == pAddrBarWin->addrWin.size)
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n",bar);
+        return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(baseLow, size))
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+    /* 2) Check if the requested window overlaps with current windows		*/
+	if(MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin))
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Overlap detected for target %d\n",
+																		bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Get size register value according to window size						*/
+	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
+
+	/* Size parameter validity check.                                   */
+	if (-1 == sizeToReg)
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n",bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{
+		/* Update size register */
+		MV_REG_WRITE(barRegInfo.sizeRegOffs, (sizeToReg << BAR_SIZE_OFFS));
+	}
+
+	/* Read current address */
+	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+													barRegInfo.baseLowRegOffs);
+
+	/* Clear current address */
+	pciData &= ~PBBLR_BASE_MASK;
+	pciData |= (baseLow & PBBLR_BASE_MASK);
+
+	/* Write new address */
+	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+											barRegInfo.baseLowRegOffs, pciData);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+										barRegInfo.baseHighRegOffs, baseHigh);
+	}
+
+	/* Enable/disable the BAR */
+    if (MV_TRUE == pAddrBarWin->enable)
+    {
+        MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+    }
+	else
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinGet - Get PCI to peripheral target address window
+*
+* DESCRIPTION:
+*		Get the PCI to peripheral target address window BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*       bar   - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       pAddrBarWin - PCI target window information data structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR bar,
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	MV_U32 barEnable;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Reading Base Low bar */
+	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+												barRegInfo.baseLowRegOffs);
+
+	baseLow &= PBBLR_BASE_MASK;
+
+	/* Skip base high if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		/* Reading Base High */
+		baseHigh = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+												barRegInfo.baseHighRegOffs);
+	}
+	else
+	{
+		baseHigh = 0;
+	}
+
+    /* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{
+		/* Reading bar size*/
+		size = ctrlRegToSize(
+					(MV_REG_READ(barRegInfo.sizeRegOffs) >> PBSR_SIZE_OFFS),
+														PBBLR_BASE_ALIGNMET);
+	}
+	else
+	{
+		size = INTER_REGS_SIZE;
+	}
+
+	/* Assign value to user struct */
+	pAddrBarWin->addrWin.baseLow  = baseLow;
+	pAddrBarWin->addrWin.baseHigh = baseHigh;
+	pAddrBarWin->addrWin.size     = size;
+
+	/* Check if window is enabled   */
+	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	if (~barEnable & (BARER_ENABLE(bar)))
+    {
+        pAddrBarWin->enable = MV_TRUE;
+    }
+    else
+    {
+        pAddrBarWin->enable = MV_FALSE;
+    }
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetWinEnable - Enable/disable a PCI BAR window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI BAR window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling PCI accesses for that BAR (before enabling the
+*       window it is tested for overlapping). Otherwise, the window will
+*       be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       bar    - BAR to be accessed by slave.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, MV_PCI_BAR bar, MV_BOOL enable)
+{
+	MV_PCI_BAR_WIN barWin;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n",
+                                                                        pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TRUE == enable)
+	{   /* First check for overlap with other enabled windows				*/
+        /* Get current window */
+		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin))
+		{
+			mvOsPrintf("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+
+		/* Check for overlapping */
+		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin))
+
+		{   /* Overlap detected	*/
+			mvOsPrintf("mvPciTargetWinEnable: ERR. Overlap detected\n");
+			return MV_ERROR;
+		}
+		else
+		{
+			/* No Overlap. Enable address decode target window              */
+			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf),BARER_ENABLE(bar));
+		}
+	}
+	else
+	{
+		/* Disable address decode target window                             */
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinSet - Set PCI protection access window
+*
+* DESCRIPTION:
+*       This function sets a specified address window with access protection
+*       attributes. If protection structure enables the window the routine will
+*       also enable the protection window.
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - Protection window structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf,
+						  MV_U32 winNum,
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow,
+                                 pProtWin->addrWin.size))
+	{
+        mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%x\n",
+                   pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
+
+		return MV_BAD_PARAM;
+	}
+
+	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
+					                            pProtWin->attributes.swapType);
+		return MV_BAD_PARAM;
+
+	}
+
+	/* 1) Calculate protection window base low register value	*/
+	protBaseLow  =  pProtWin->addrWin.baseLow;
+
+	/* Setting the appropriate bits according to the passed values */
+	if (MV_TRUE == pProtWin->enable)
+	{
+		protBaseLow |= PACBLR_EN;
+	}
+	else
+	{
+		protBaseLow &= ~PACBLR_EN;
+	}
+
+	/* I/O Cache Coherency */
+	protBaseLow |= ((MV_U32)pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
+
+	/* Access protect */
+	if (ALLOWED == pProtWin->attributes.access)
+	{
+		protBaseLow &= ~PACBLR_ACCPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_ACCPROT;
+	}
+
+	/* Write Protect */
+	if (ALLOWED == pProtWin->attributes.write)
+	{
+		protBaseLow &= ~PACBLR_WRPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_WRPROT;
+	}
+
+	/* PCI slave Data Swap Control */
+	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
+
+
+	/* Read Max Burst */
+	if (( pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS);
+
+
+	/* Typical PCI read transaction Size. Only valid for PCI conventional */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS);
+
+
+	/* 2) Calculate protection window base high register value	*/
+	protBaseHigh =  pProtWin->addrWin.baseHigh;
+
+	/* 3) Calculate protection window size register value	*/
+	protSize     =  ctrlSizeToReg(pProtWin->addrWin.size, PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
+
+
+	/* Write Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
+		return MV_ERROR;
+	}
+	protSize |= (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+    if (MV_TRUE == pProtWin->attributes.pciOrder)
+	{
+		protSize |= PACSR_PCI_ORDERING;
+	}
+	else
+	{
+		protSize &= ~PACSR_PCI_ORDERING;
+	}
+
+	/* Writing protection window walues into registers */
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), protBaseLow);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum), protBaseHigh);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum),  protSize);
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvPciProtWinGet - Get PCI protection access window
+*
+* DESCRIPTION:
+*       This function gets a specified address window and access protection
+*       attributes for a specific protection window .
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - pointer to a Protection window structure.
+*
+* OUTPUT:
+*       pProtWin - Protection window structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf,
+						  MV_U32 winNum,
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Writing protection window walues into registers */
+	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum));
+	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum));
+	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum));
+
+
+	/* 1) Get Protection Windows base low 	*/
+	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
+
+	/* Get the appropriate protection attributes according to register bits*/
+
+	/* Is Windows enabled ? */
+	if (protBaseLow & PACBLR_EN)
+	{
+		pProtWin->enable = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->enable = MV_FALSE;
+	}
+
+
+	/* What is access protect ? */
+	if (protBaseLow & PACBLR_ACCPROT)
+	{
+		pProtWin->attributes.access = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.access = ALLOWED;
+	}
+
+	/* Is write protect ? */
+	if (protBaseLow & PACBLR_WRPROT)
+	{
+		pProtWin->attributes.write = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.write = ALLOWED;
+	}
+
+
+	/* PCI slave Data Swap Control */
+	pProtWin->attributes.swapType = (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
+
+
+	/* Read Max Burst */
+	pProtWin->attributes.readMaxBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >> PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. */
+	pProtWin->attributes.readBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >> PACBLR_RDSIZE_OFFS);
+
+
+	/* window base high register value	*/
+	pProtWin->addrWin.baseHigh = protBaseHigh;
+
+	/*Calculate protection window size register value	*/
+	pProtWin->addrWin.size = ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS),PACSR_SIZE_ALIGNMENT);
+
+
+	/* Write Max Burst */
+	pProtWin->attributes.writeMaxBurst = pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >> PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (protSize & PACSR_PCI_ORDERING)
+	{
+		pProtWin->attributes.pciOrder = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->attributes.pciOrder = MV_FALSE;
+	}
+
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinEnable - Enable/disable a PCI protection access window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI protection access window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       protection window, otherwise, the protection window will be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       winNum - Protecion window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n",
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+    if (MV_TRUE == enable)
+    {
+        MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+    }
+	else
+	{
+        MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetRemap - Set PCI to target address window remap.
+*
+* DESCRIPTION:
+*       The PCI interface supports remap of the BAR original address window.
+*       For each BAR it is possible to define a remap address. For example
+*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
+*       according to remap register but will also be targeted to the
+*       SDRAM CS[0].
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       bar      - Peripheral target enumerator accessed by slave.
+*       pAddrWin - Address window to be checked.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf,
+						   MV_PCI_BAR bar,
+                           MV_ADDR_WIN *pAddrWin)
+{
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n",
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT))
+	{
+		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
+				   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+				   pciIf,
+				   pciBarNameGet(bar),
+                   pAddrWin->baseLow,
+				   pAddrWin->size);
+		return MV_ERROR;
+	}
+
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Set remap low register value */
+	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.remapHighRegOffs)
+	{
+		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciWinOverlapDetect - Detect address windows overlapping
+*
+* DESCRIPTION:
+*       This function detects address window overlapping of a given address
+*       window in PCI BARs.
+*
+* INPUT:
+*       pAddrWin - Address window to be checked.
+*       bar      - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32		barEnableReg;
+	MV_U32		targetBar;
+	MV_PCI_BAR_WIN	barAddrWin;
+
+	/* Read base address enable register. Do not check disabled windows		*/
+	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	for(targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
+	        /* don't check our target or illegal targets */
+		if (targetBar == bar)
+			continue;
+
+		/* Do not check disabled windows	*/
+		if (barEnableReg & (BARER_ENABLE(targetBar)))
+			continue;
+
+		/* Get window parameters 	*/
+		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+
+		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR*/
+		if (((bar == MEM_INTER_REGS_BAR)&&(targetBar == IO_INTER_REGS_BAR)) ||
+			((bar == IO_INTER_REGS_BAR)&&(targetBar == MEM_INTER_REGS_BAR))) {
+			return MV_FALSE;
+		} else if(MV_TRUE == mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: BAR %d overlap current %d\n", bar, targetBar);
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* cpuWinIsValid - Check if the given address window is valid
+*
+* DESCRIPTION:
+*		PCI spec restrict BAR base to be aligned to BAR size.
+*		This function checks if the given address window is valid.
+*
+* INPUT:
+*       baseLow - 32bit low base address.
+*       size    - Window size.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
+{
+
+	/* PCI spec restrict BAR base to be aligned to BAR size					*/
+	if(MV_IS_NOT_ALIGN(baseLow, size))
+	{
+		return MV_ERROR;
+	}
+	else
+	{
+		return MV_TRUE;
+	}
+}
+
+/*******************************************************************************
+* pciBarRegInfoGet - Get BAR register information
+*
+* DESCRIPTION:
+* 		PCI BARs registers offsets are inconsecutive.
+*		This function gets a PCI BAR register information like register offsets
+*		and function location of the BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*		bar	  - The PCI BAR in question.
+*
+* OUTPUT:
+*       pBarRegInfo - BAR register info struct.
+*
+* RETURN:
+*		MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
+*
+*******************************************************************************/
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf,
+								  MV_PCI_BAR bar,
+								  PCI_BAR_REG_INFO *pBarRegInfo)
+{
+	switch (bar)
+	{
+		/* Function 0 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR:      		/* SDRAM chip select 0 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR:      		/* SDRAM chip select 1 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case MEM_INTER_REGS_BAR: /* Memory Mapped Internal bar */
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
+			pBarRegInfo->baseHighRegOffs  = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
+			pBarRegInfo->sizeRegOffs      = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+
+		/* Function 1 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR:      		/* SDRAM chip select 2 bar*/
+			pBarRegInfo->funcNum          = 1;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR:      		/* SDRAM chip select 3 bar*/
+			pBarRegInfo->funcNum		  = 1;
+			pBarRegInfo->baseLowRegOffs	  = PCI_SCS3_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS3_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_CS3_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS3_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS0)
+		/* Function 2 Bars */
+		case DEVCS0_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS1)
+		case DEVCS1_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS2)
+		case DEVCS2_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case BOOTCS_BAR:      	/* Boot device chip select bar*/
+			pBarRegInfo->funcNum		  = 3;
+			pBarRegInfo->baseLowRegOffs	  = PCI_BOOTCS_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_BOOTCS_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_BOOTCS_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+
+		/* Function 4 Bars */
+		case P2P_MEM0:      		/* P2P memory 0 */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_P2P_MEM0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_P2P_MEM0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
+			break;
+		case P2P_IO:        		/* P2P IO */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs   = PCI_P2P_IO_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_IO_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		case IO_INTER_REGS_BAR: /* IO Mapped Internal bar */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+
+
+		default:
+			mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
+			return MV_ERROR;
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciBarNameGet - Get the string name of PCI BAR.
+*
+* DESCRIPTION:
+*		This function get the string name of PCI BAR.
+*
+* INPUT:
+*       bar - PCI bar number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       pointer to the string name of PCI BAR.
+*
+*******************************************************************************/
+const MV_8* pciBarNameGet( MV_PCI_BAR bar )
+{
+	switch( bar )
+	{
+	#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR:
+			return "CS0_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR:
+			return "CS1_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR:
+			return "CS2_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR:
+			return "CS3_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS0)
+		case DEVCS0_BAR:
+			return "DEVCS0_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS1)
+		case DEVCS1_BAR:
+			return "DEVCS1_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS2)
+		case DEVCS2_BAR:
+			return "DEVCS2_BAR...........";
+	#endif
+		case BOOTCS_BAR:
+			return "BOOTCS_BAR...........";
+		case MEM_INTER_REGS_BAR:
+			return "MEM_INTER_REGS_BAR...";
+		case IO_INTER_REGS_BAR:
+			return "IO_INTER_REGS_BAR....";
+		case P2P_MEM0:
+			return "P2P_MEM0.............";
+		case P2P_IO:
+			return "P2P_IO...............";
+		default:
+			 return "target unknown";
+	}
+}
+
+/*******************************************************************************
+* mvPciAddrDecShow - Print the PCI address decode map (BARs).
+*
+* DESCRIPTION:
+*		This function print the PCI address decode map (BARs).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvPciAddrDecShow(MV_VOID)
+{
+	MV_PCI_BAR_WIN win;
+	MV_PCI_BAR bar;
+	MV_U32 pciIf;
+
+	for( pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++ )
+	{
+		mvOsOutput( "\n" );
+		mvOsOutput( "PCI%d:\n", pciIf );
+		mvOsOutput( "-----\n" );
+
+		for( bar = 0; bar < PCI_MAX_BARS; bar++ )
+		{
+			memset( &win, 0, sizeof(MV_PCI_BAR_WIN) );
+
+			mvOsOutput( "%s ", pciBarNameGet(bar) );
+
+			if( mvPciTargetWinGet( pciIf, bar, &win ) == MV_OK )
+			{
+				if( win.enable )
+				{
+                    mvOsOutput( "base %08x, ", win.addrWin.baseLow );
+                    mvSizePrint( win.addrWin.size );
+                    mvOsOutput( "\n" );
+				}
+				else
+					mvOsOutput( "disable\n" );
+			}
+		}
+	}
+}
+
+/* convert burst bytes to register value*/
+static MV_U32 pciBurstBytes2Reg(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 32: ret = 0; break;
+                case 64: ret = 1; break;
+                case 128: ret = 2; break;
+                case 256: ret = 3; break;
+                default: ret = 0xF; /* error */
+        }
+        return ret;
+}
+
+/* convert register value to burst bytes*/
+static MV_U32 pciBurstReg2Bytes(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 0: ret = 32; break;
+                case 1: ret = 64; break;
+                case 2: ret = 128; break;
+                case 3: ret = 256; break;
+                default: ret = 0x0; /* error */
+        }
+        return ret;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysPci.h b/arch/arm/mach-armada370/mv_hal_if/mvSysPci.h
new file mode 100644
index 0000000..ffa393f7
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysPci.h
@@ -0,0 +1,256 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCSysPCIH
+#define __INCSysPCIH
+
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "pci/mvPci.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvSysPciConfig.h"
+
+#define PCI_MAX_PROT_WIN			6
+
+/* 4KB granularity */
+#define MINIMUM_WINDOW_SIZE     		0x1000
+#define MINIMUM_BAR_SIZE        		0x1000
+#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
+#define BAR_SIZE_OFFS				12
+#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
+
+#define PCI_IO_WIN_NUM          		1   /* Number of PCI_IO windows  */
+#define PCI_MEM_WIN_NUM         		4   /* Number of PCI_MEM windows */
+
+#ifndef MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvLib.h"
+typedef enum _mvPCIBars
+{
+	PCI_BAR_TBL_TERM = -1, /* none valid bar, used as bars list terminator */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	CS0_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	CS1_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	CS2_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	CS3_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEVCS0_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEVCS1_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEVCS2_BAR,
+#endif
+	BOOTCS_BAR,      	/* Boot device chip select bar*/
+	MEM_INTER_REGS_BAR, 	/* Memory Mapped Internal bar */
+	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
+	P2P_MEM0,      		/* P2P memory 0 */
+	P2P_IO,        		/* P2P IO */
+	PCI_MAX_BARS
+}MV_PCI_BAR;
+#endif /* MV_ASMLANGUAGE */
+
+#if defined(MV_INCLUDE_SDRAM_CS3)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar) 		((bar >= CS0_BAR) && (bar <= CS3_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS2)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS1)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS0)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
+#endif
+
+
+/****************************************/
+/* PCI Slave Address Decoding registers */
+/****************************************/
+#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
+#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
+#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
+#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
+#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80))
+#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80))
+#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80))
+#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80))
+#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80))
+#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80))
+#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
+#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
+#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
+
+/* PCI Bars Size Registers (PBSR) */
+#define PBSR_SIZE_OFFS				12
+#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
+
+/* Base Address Registers Enable Register (BARER) */
+#define BARER_ENABLE(target)			(1 << (target))
+
+/* PCI Base Address Remap Registers (PBARR) */
+#define PBARR_REMAP_OFFS			12
+#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
+#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
+
+/* PCI DRAM Bar Bank Select Register (PDBBSR) */
+#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
+#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
+
+/* PCI Address Decode Control Register (PADCR)*/
+#define PADCR_REMAP_REG_WR_DIS			BIT0
+#define PADCR_MSG_REG_ACC			BIT3
+
+#define PADCR_VPD_HIGH_ADDR_OFFS		8 /* Bits [31:15] of the VPD address */
+#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
+
+/* PCI Headers Retarget Control Register (PHRCR) */
+#define PHRCR_ENABLE				BIT0
+#define PHRCR_BUFF_SIZE_OFFS			1
+#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_MASK1_OFFS			16
+#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
+
+/* PCI Headers Retarget Base Register (PHRBR) */
+#define PHRBR_BASE_OFFS				16
+#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
+
+/* PCI Headers Retarget Base High Register (PHRBHR) */
+#define PHRBHR_BASE_OFFS			0
+#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
+
+/* This structure describes a PCI BAR. It is also refered as PCI target     */
+/* window to keep consistency with other address decode units in the system */
+typedef struct _mvPciBarWin
+{
+    MV_ADDR_WIN		addrWin;	/* Address window       */
+    MV_BOOL     	enable;		/* BAR enable/disable   */
+}MV_PCI_BAR_WIN;
+
+typedef enum
+{
+    NO_CACHE_COHER = 0,
+    WT_CACHE_COHER,
+    WB_CACHE_COHER
+}MV_PCI_SNOOP;
+
+/* This structure describes PCI region attributes                           */
+typedef struct _mvPciRegionAttr
+{
+    MV_PCI_SNOOP	snoop;		/* Cache Coherenc			*/
+    MV_PROT_RIGHT	access;         /* Access protection                    */
+    MV_PROT_RIGHT	write;          /* Write protection                     */
+    MV_SWAP_TYPE	swapType;       /* Data swap mode for that region       */
+    MV_U32		readMaxBurst;   /* Read max burst                       */
+    MV_U32		readBurst;      /* Read burst. Conventional PCI only    */
+    MV_U32		writeMaxBurst;  /* Write max burst                      */
+    MV_BOOL		pciOrder;       /* Hardware support for PCI ordering    */
+}MV_PCI_REGION_ATTR;
+
+/* The PCI slave interface supports configurable access control.            */
+/* It is possible to define up to six address ranges to different           */
+/* configurations. This structure describes the PCI access region           */
+typedef struct _mvPciProtWin
+{
+    MV_ADDR_WIN         addrWin;	/* An address window                    */
+    MV_PCI_REGION_ATTR  attributes;	/* Window attributes                    */
+    MV_BOOL             enable;		/* Window enabled/disabled              */
+}MV_PCI_PROT_WIN;
+
+/* Global Functions prototypes */
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf,MV_PCI_BAR slaveTarget, MV_BOOL enable);
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_ADDR_WIN *pAddrWin);
+MV_VOID   mvPciAddrDecShow(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysPex.c b/arch/arm/mach-armada370/mv_hal_if/mvSysPex.c
new file mode 100644
index 0000000..f296bd3
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysPex.c
@@ -0,0 +1,128 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+
+MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum, MV_PEX_DEC_WIN *pAddrDecWin);
+
+
+/*******************************************************************************
+* mvSysPexInit - Initialize the Pex subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
+{
+	MV_PEX_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvPexWinInit(pexIf, pexType, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.maxPexIf = mvCtrlPexMaxIfGet();
+		status = mvPexInit(pexIf, pexType, &halData);
+	}
+
+	return status;
+}
+
+/*******************************************************************************
+* mvSysPexCpuIfEnable -
+*
+* DESCRIPTION:
+*       Enable PCI-E in CPU subsystem.
+*
+* INPUT:
+*       pexIf - The PCI-E Interface number to enable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvSysPexCpuIfEnable(MV_U32 pexIf)
+{
+        mvCpuIfEnablePex(pexIf);
+        return;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysPexApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysPexApi.h
new file mode 100644
index 0000000..7ae7e26
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysPexApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_PEX_API_H__
+#define __MV_SYS_PEX_API_H__
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
+MV_VOID mvSysPexCpuIfEnable(MV_U32 pexIf);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysSFlash.c b/arch/arm/mach-armada370/mv_hal_if/mvSysSFlash.c
new file mode 100644
index 0000000..e4b5944
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysSFlash.c
@@ -0,0 +1,225 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "sflash/mvSysSFlash.h"
+
+#define MV_SYS_SFLASH_MAX_CMD_LEN 8
+
+static struct {
+	MV_U8 buf[MV_SYS_SFLASH_MAX_CMD_LEN];
+	MV_U32 bufLen;
+	MV_U8  transType;
+} mvSysSflashCmd;
+
+/*******************************************************************************
+* mvSysSflashCommandSet
+*
+* DESCRIPTION:
+*	System interface for sending a command to the SPI flash.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*      	cmdBuff:     Command data to be written.
+*	cmdLen:	     Command length in bytes.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashCommandSet(MV_VOID *flashHandle, MV_U8* cmdBuff, MV_U32 cmdLen,
+		MV_U8 transType)
+{
+	if (cmdLen > MV_SYS_SFLASH_MAX_CMD_LEN)
+		return MV_ERROR;
+
+	if (!(transType & SYS_SFLASH_TRANS_START) || (mvSysSflashCmd.transType != 0))
+		return MV_ERROR;
+
+	mvSpiParamsSet(0, 0, SPI_TYPE_FLASH);
+
+	memcpy(mvSysSflashCmd.buf,cmdBuff,cmdLen);
+	mvSysSflashCmd.bufLen = cmdLen;
+	mvSysSflashCmd.transType = transType;
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		return mvSysSflashDataWrite(flashHandle, NULL, 0, transType);
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataRead
+*
+* DESCRIPTION:
+*	System interface for reading SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer to read the data into.
+*	dataLen:     Number of bytes to read.
+*	dummyBytes:  Number of dummy bytes to read before reading the real
+*		     data.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	dataBuff: The data as read from flash.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataRead(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U32 dummyBytes, MV_U8 transType)
+{
+	MV_STATUS  ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+
+	ret = mvSpiWriteThenRead (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+			dataBuff, dataLen, dummyBytes);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataWrite
+*
+* DESCRIPTION:
+*	System interface for writing SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer holding the data to be written.
+*	dataLen:     Number of bytes to write.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataWrite(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenWrite (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen, dataBuff, dataLen);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashFreqSet
+*
+* DESCRIPTION:
+*	System interface for controlling the SPI interface frequency.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	freq:	     The new frequency to be configured for the SPI IF.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashFreqSet(MV_VOID *flashHandle, MV_U32 freq)
+{
+
+	return mvSpiBaudRateSet(0, freq);
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysSata.c b/arch/arm/mach-armada370/mv_hal_if/mvSysSata.c
new file mode 100644
index 0000000..8086760
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysSata.c
@@ -0,0 +1,81 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "sata/CoreDriver/mvSata.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+MV_STATUS mvSysSataWinInit(MV_VOID)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvSataWinInit(addrWinMap);
+
+	return status;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysSataApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysSataApi.h
new file mode 100644
index 0000000..8cca7d0
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysSataApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SATA_API_H__
+#define __MV_SYS_SATA_API_H__
+
+MV_STATUS mvSysSataWinInit(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysSpi.c b/arch/arm/mach-armada370/mv_hal_if/mvSysSpi.c
new file mode 100644
index 0000000..05e44f2
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysSpi.c
@@ -0,0 +1,125 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSysSpi.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+
+/*******************************************************************************
+* mvSysSpiInit - Initialize the SPI subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
+{
+	MV_SPI_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.tclk = mvBoardTclkGet();
+
+	return mvSpiInit(spiId, serialBaudRate, &halData);
+}
+
+
+/*******************************************************************************
+* mvSysSpiMppConfig
+*
+* DESCRIPTION:
+*	System interface for configuring the MPP's configuration to enable /
+*	disable SPI mode.
+*
+* INPUT:
+*      	mode:	The mode to be set into MPP unit.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
+{
+#if 0
+	if(mode == SYS_SPI_MPP_ENABLE)
+		mvMPPConfigToSPI();
+	else
+		mvMPPConfigToDefault();
+#endif
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysSpiApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysSpiApi.h
new file mode 100644
index 0000000..80888c0
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysSpiApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SPI_API_H__
+#define __MV_SYS_SPI_API_H__
+
+MV_STATUS   mvSysSpiInit(MV_U8 spi_id, MV_U32 serialBaudRate);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysTdm.c b/arch/arm/mach-armada370/mv_hal_if/mvSysTdm.c
new file mode 100644
index 0000000..db94038
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysTdm.c
@@ -0,0 +1,245 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#ifdef CONFIG_MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+ #include "gpp/mvGpp.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "spi/mvSpi.h"
+
+#define MAX_DATA_LENGTH		255
+
+/*******************************************************************************
+* mvSysTdmInit - Initialize the TDM subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
+{
+	MV_TDM_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmWinInit(addrWinMap);
+#else
+		status = mvCommUnitWinInit(addrWinMap);
+#endif
+
+	if(status == MV_OK) {
+		halData.spiMode = mvBoardTdmSpiModeGet();
+		halData.model = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+		halData.frameTs = MV_FRAME_128TS;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+		halData.frameTs = MV_FRAME_64TS;
+#else /* MV_TDM_PCM_CLK_2MHZ */
+		halData.frameTs = MV_FRAME_32TS;
+#endif
+
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmHalInit (tdmParams, &halData);
+#else
+		halData.maxCs = mvBoardTdmDevicesCountGet();
+		status = mvCommUnitHalInit (tdmParams, &halData);
+
+		/* Issue SLIC reset */
+		mvGppValueSet(0, BIT25, 0);
+		mvOsUDelay(60);
+		mvGppValueSet(0, BIT25, BIT25);
+#endif
+	}
+
+	return status;
+}
+
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(mvBoardTdmSpiIdGet(), mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenRead (mvBoardTdmSpiIdGet(), cmdBuff, cmdSize, dataBuff, dataSize, 0))
+		printk("SPI read failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmSpiWrite - telephony register write via SPI interface
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(mvBoardTdmSpiIdGet(), mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenWrite (mvBoardTdmSpiIdGet(), cmdBuff, cmdSize, dataBuff, dataSize))
+		printk("SPI write failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmIntEnable - Enable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntEnable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntEnable(deviceId);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmIntDisable - Disable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntDisable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntDisable(deviceId);
+
+#endif
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysTdmApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysTdmApi.h
new file mode 100644
index 0000000..74ca023
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysTdmApi.h
@@ -0,0 +1,78 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TDM_API_H__
+#define __MV_SYS_TDM_API_H__
+
+#include "mvSysTdmConfig.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+  #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+MV_STATUS mvSysTdmInit (MV_TDM_PARAMS* tdmParams);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysTs.c b/arch/arm/mach-armada370/mv_hal_if/mvSysTs.c
new file mode 100644
index 0000000..c68d75d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysTs.c
@@ -0,0 +1,86 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ts/mvTsu.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ts/mvTsuRegs.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvTsuWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		status = mvTsuHalInit(coreClock, mode, osHandle);
+	return status;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysTsApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysTsApi.h
new file mode 100644
index 0000000..837782d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysTsApi.h
@@ -0,0 +1,73 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TS_API_H__
+#define __MV_SYS_TS_API_H__
+
+#include "ts/mvTsu.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysTwsi.c b/arch/arm/mach-armada370/mv_hal_if/mvSysTwsi.c
new file mode 100644
index 0000000..5c51c03
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysTwsi.c
@@ -0,0 +1,136 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+
+/*******************************************************************************
+* mvSysTwsiInterruptEnable
+*
+* DESCRIPTION:
+*	Mask or unmask TWSI main interrupt cause bit.
+*
+* INPUT:
+*	chanNum	- TWSI channel number.
+*	mask	- MV_TRUE to enable the interrupt,
+*		  MV_FALSE to disable the interrupt.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysTwsiInterruptEnable(MV_U32 chanNum, MV_BOOL enable)
+{
+	MV_U32 val;
+
+	val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(CPU_MAIN_INT_CAUSE_TWSI(chanNum)));
+
+	if (enable == MV_TRUE)
+		val |= (1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS);
+	else
+		val &= ~(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS);
+
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(CPU_MAIN_INT_CAUSE_TWSI(chanNum)), val);
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvSysTwsiMainCauseIsSet
+*
+* DESCRIPTION:
+*	Check if the TWSI interrupt was triggered in the main interrupt cause
+*	register.
+*
+* INPUT:
+*	chanNum	- TWSI channel number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if interrupt was triggered.
+*	MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvSysTwsiMainCauseIsSet(MV_U32 chanNum)
+{
+	MV_U32 val;
+
+	/* Pass dummy 0 to keep compatibility with HAL */
+	val = MV_REG_READ(MV_TWSI_CPU_MAIN_INT_CAUSE(chanNum, 0));
+
+	if (val & (1 << CPU_MAIN_INT_TWSI_OFFS(chanNum)))
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysUsb.c b/arch/arm/mach-armada370/mv_hal_if/mvSysUsb.c
new file mode 100644
index 0000000..8cb862d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysUsb.c
@@ -0,0 +1,105 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "usb/mvUsb.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "usb/mvUsbRegs.h"
+
+/*******************************************************************************
+* mvSysUsbHalInit - Initialize the USB subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
+{
+	MV_USB_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvUsbWinInit(dev, addrWinMap);
+
+	if (dev == 0)
+		mvUsbPllInit();
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+		status = mvUsbHalInit(dev, isHost, &halData);
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysUsbApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysUsbApi.h
new file mode 100644
index 0000000..675b608
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysUsbApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_USB_API_H__
+#define __MV_SYS_USB_API_H__
+
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost);
+
+#endif
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysXor.c b/arch/arm/mach-armada370/mv_hal_if/mvSysXor.c
new file mode 100644
index 0000000..ebbe210
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysXor.c
@@ -0,0 +1,85 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "xor/mvXor.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "xor/mvXorRegs.h"
+
+MV_VOID mvSysXorInit (void)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvXorWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		mvXorHalInit(MV_XOR_MAX_CHAN);
+	return;
+}
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysXorApi.h b/arch/arm/mach-armada370/mv_hal_if/mvSysXorApi.h
new file mode 100644
index 0000000..fb2b06d
--- /dev/null
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysXorApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_XOR_API_H__
+#define __MV_SYS_XOR_API_H__
+
+MV_VOID mvSysXorInit (void);
+
+#endif
diff --git a/arch/arm/mach-armada370/pci.c b/arch/arm/mach-armada370/pci.c
new file mode 100644
index 0000000..64b011d
--- /dev/null
+++ b/arch/arm/mach-armada370/pci.c
@@ -0,0 +1,242 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysPci.h"
+#include "pci/mvPci.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x)
+#endif
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+
+	if (mvCtrlPciMaxIfGet() > 1)
+		panic("Single PCI is supported ONLY!");
+
+	mvPciInit(0, MV_PCI_MOD_HOST);
+
+	/* I/O remmap */
+	win.baseLow = 0x0;
+	win.baseHigh = 0x0;
+	mvCpuIfPciRemap(PCI_IF0_IO, &win);
+}
+
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+                          int size, u32 *val)
+{
+
+        MV_U32 bus_num,func,regOff,dev_no,temp;
+	MV_U32 localBus;
+
+	*val = 0xffffffff;
+
+        bus_num = bus->number;
+        dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPciLocalBusNumGet(0);
+	if((dev_no == 0) && ( bus_num == localBus)) {
+		DB(printk("PCI 0 read from our own dev return 0xffffffff \n"));
+		return 0xffffffff;
+	}
+
+        func = PCI_FUNC(devfn);
+        regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	if ((func == 0)&&(dev_no < 2))
+		DB(printk("PCI 0 read: bus = %x dev = %x func = %x regOff = %x ",bus_num,dev_no,func,regOff));
+
+
+        temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+
+        switch (size) {
+        case 1:
+                temp = (temp >>  (8*(where & 0x3))) & 0xff;
+                break;
+
+        case 2:
+                temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+                break;
+
+        default:
+                break;
+        }
+
+	*val = temp;
+
+	if ((func == 0)&&(dev_no < 2)) {
+		DB(printk(" got %x \n",temp));
+	}
+
+        return 0;
+}
+
+static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+        MV_U32 bus_num,func,regOff,dev_no,temp, mask , shift;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	DB(printk("PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x \n",val,size,bus_num,dev_no,func,regOff));
+	if( size != 4)
+		temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+        switch (size) {
+        case 1:
+		shift = (8*(where & 0x3));
+		mask = 0xff;
+                break;
+
+        case 2:
+		shift = (8*(where & 0x2));
+                mask = 0xffff;
+                break;
+
+        default:
+		shift = 0;
+		mask = 0xffffffff;
+                break;
+        }
+
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
+
+        return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci0_read_config,
+        .write  = mv_pci0_write_config,
+};
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+        struct resource *res;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+        sys->map_irq = mv_map_irq;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+        if (!res)
+                panic("PCI: unable to alloc resources");
+
+        memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
+	res[0].end   =  mv_pci_io_base_get(0) - IO_SPACE_REMAP +  mv_pci_io_size_get(0) - 1;
+	res[0].name  = "PCI0 IO Primary";
+	res[0].flags = IORESOURCE_IO;
+
+	res[1].start =  mv_pci_mem_base_get(0);
+	res[1].end   =  mv_pci_mem_base_get(0) +  mv_pci_mem_size_get(0) - 1;
+	res[1].name  = "PCI0 Memory Primary";
+	res[1].flags = IORESOURCE_MEM;
+
+        if (request_resource(&ioport_resource, &res[0]))
+		printk ("IO Request resource failed - Pci If %x\n",nr);
+
+	if (request_resource(&iomem_resource, &res[1]))
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+
+        sys->resource[0] = &res[0];
+        sys->resource[1] = &res[1];
+        sys->resource[2] = NULL;
+        sys->io_offset   = 0x0;
+
+        return 1;
+
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops;
+	struct pci_bus *bus;
+
+        if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	ops = &mv_pci_ops;
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCI0;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .map_irq                = mv_map_irq,
+        .setup                  = mv_pci_setup,
+        .scan                   = mv_pci_scan_bus,
+        .preinit                = mv_pci_preinit,
+};
+
+static int __init mv_pci_init(void)
+{
+	MV_U32 ifnum = mvCtrlPciMaxIfGet();
+	if (ifnum) {
+		mv_pci.nr_controllers = ifnum;
+		pci_common_init(&mv_pci);
+	}
+
+    return 0;
+}
+
+subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-armada370/pex.c b/arch/arm/mach-armada370/pex.c
new file mode 100644
index 0000000..4306282
--- /dev/null
+++ b/arch/arm/mach-armada370/pex.c
@@ -0,0 +1,399 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+//#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysPexApi.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x)
+#endif
+
+#define PCI_ERR_NAME_LEN 12
+#define MV_MAX_PEX_IF_NUMBER 2
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin);
+
+void mv_pci_error_init(u32 pciIf);
+
+static irqreturn_t pex_error_interrupt(int irq, void *dev_id);
+
+static struct pex_if_error {
+	MV_8 irq_name[PCI_ERR_NAME_LEN];
+	MV_U32 ifNumber;
+} pex_err[MV_MAX_PEX_IF_NUMBER];
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+	MV_STATUS retval;
+	u32 pciIf;
+	u32 maxif = mvCtrlPexMaxIfGet();
+
+	/* Check Power State */
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, 0))
+		return;
+
+	for (pciIf = 0; pciIf < maxif; pciIf++)
+        {
+
+		retval = mvSysPexInit(pciIf, MV_PEX_ROOT_COMPLEX);
+
+		if(retval == MV_NO_SUCH){
+			//printk("pci_init:no such calling mvPexInit for PEX-%x\n",pciIf);
+			continue;
+		}
+
+		if (retval != MV_OK)
+		{
+			printk("pci_init:Error calling mvPexInit for PEX-%x\n",pciIf);
+			continue;
+		}
+
+		/* unmask inter A/B/C/D */
+		//printk("writing %x tp %x \n",MV_PCI_MASK_ABCD, MV_PCI_MASK_REG(pciIf) );
+		MV_REG_WRITE(MV_PCI_MASK_REG(pciIf), MV_PCI_MASK_ABCD );
+
+		/* init PCI express error handling */
+		mv_pci_error_init(pciIf);
+
+		/* remmap IO !! */
+		win.baseLow = (pciIf? PEX1_IO_PHYS_BASE : PEX0_IO_PHYS_BASE) - IO_SPACE_REMAP;
+		win.baseHigh = 0x0;
+		win.size = pciIf? PEX1_IO_SIZE : PEX0_IO_SIZE;
+		mvCpuIfPexRemap((pciIf? PEX1_IO : PEX0_IO), &win);
+	}
+}
+
+/**
+* mv_pci_error_init
+* DESCRIPTION: init PCI express error handling
+* INPUTS:      pciIf - number of pex device
+* OUTPUTS:     N/A
+* RETURNS:     N/A
+**/
+void mv_pci_error_init(u32 pciIf)
+{
+	MV_U32      reg_val;
+
+	/* init pex_err structure per each pex */
+	pex_err[pciIf].ifNumber = pciIf;
+	snprintf(pex_err[pciIf].irq_name, PCI_ERR_NAME_LEN, "error_pex%d", pciIf);
+
+	/* register interrupt for PCI express error */
+	if (request_irq((IRQ_AURORA_ERR_START + INT_ERR_PCIE(pciIf)), pex_error_interrupt, IRQF_DISABLED,
+				(const char*)pex_err[pciIf].irq_name, &pex_err[pciIf].ifNumber) < 0) {
+		panic("Could not allocate IRQ for PCI express error!");
+	}
+
+	/* get current value of Interrupt Mask Register */
+	reg_val = MV_REG_READ(MV_PCI_MASK_REG(pciIf));
+
+	/* set relevant mask to Interrupt Mask Register */
+	MV_REG_WRITE(MV_PCI_MASK_REG(pciIf), (reg_val | MV_PCI_MASK_ERR));
+}
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+                          int size, u32 *val)
+{
+
+        MV_U32 bus_num,func,regOff,dev_no,temp;
+	MV_U32 localBus;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+        u32 pciIf = sysdata->mv_controller_num;
+
+	*val = 0xffffffff;
+
+	/* Check Power State */
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, 0))
+		return 0;
+
+        bus_num = bus->number;
+        dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if((dev_no == 0) && ( bus_num == localBus))
+	{
+		DB(printk("PCI %x read from our own dev return 0xffffffff \n", pciIf));
+		return 0xffffffff;
+	}
+
+        func = PCI_FUNC(devfn);
+        regOff = (MV_U32)where & PXCAR_REG_NUM_MASK;
+
+#if PEX0_PTP
+	/* WA: use only the first function of the bridge and te first bus*/
+	if( (bus_num == mvPexLocalBusNumGet(pciIf)) && (dev_no == 1) && (func != 0) )
+	{
+		DB(printk("PCI %x read from bridge func != 0 return 0xffffffff \n",pciIf));
+		return 0xffffffff;
+	}
+#endif
+	if ((func == 0)&&(dev_no < 2))
+	{
+		DB(printk("PCI %x read: bus = %x dev = %x func = %x regOff = %x ",pciIf, bus_num,dev_no,func,regOff));
+	}
+
+
+        temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+
+        switch (size) {
+        case 1:
+                temp = (temp >>  (8*(where & 0x3))) & 0xff;
+                break;
+
+        case 2:
+                temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+                break;
+
+        default:
+                break;
+        }
+
+
+	*val = temp;
+
+	if ((func == 0)&&(dev_no < 2))
+	{
+		DB(printk(" got %x \n",temp));
+	}
+
+        return 0;
+}
+
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+        MV_U32 bus_num,func,regOff,dev_no,temp, mask , shift;
+        struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+        u32 pciIf = sysdata->mv_controller_num;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & PXCAR_REG_NUM_MASK;
+
+	DB(printk("PCI %x: writing data %x size %x to bus %x dev %x func %x offs %x \n",pciIf, val,size,bus_num,dev_no,func,regOff));
+	if( size != 4)
+	{
+		temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	}
+	else
+	{
+		temp = val;
+	}
+
+        switch (size) {
+        case 1:
+		shift = (8*(where & 0x3));
+		mask = 0xff;
+                break;
+
+        case 2:
+		shift = (8*(where & 0x2));
+                mask = 0xffff;
+                break;
+
+        default:
+		shift = 0;
+		mask = 0xffffffff;
+                break;
+        }
+
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPexConfigWrite(pciIf,bus_num,dev_no,func,regOff,temp);
+
+        return 0;
+
+}
+
+
+
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci_read_config,
+        .write  = mv_pci_write_config,
+};
+
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+        struct resource *res;
+
+        switch (nr) {
+        case 0:
+                sys->map_irq = mv_map_irq_0;
+                break;
+        case 1:
+                sys->map_irq = mv_map_irq_1;
+                break;
+        default:
+		printk("mv_pci_setup: nr(%d) out of scope\n",nr);
+                return 0;
+        }
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+        if (!res)
+                panic("PCI: unable to alloc resources");
+
+        memset(res, 0, sizeof(struct resource) * 2);
+
+	if(!nr) {
+		res[0].start = PEX0_IO_PHYS_BASE - IO_SPACE_REMAP;
+		res[0].end   = PEX0_IO_PHYS_BASE - IO_SPACE_REMAP + PEX0_IO_SIZE - 1;
+		res[0].name  = "PEX0 IO";
+		res[0].flags = IORESOURCE_IO;
+
+		res[1].start = PEX0_MEM_PHYS_BASE;
+		res[1].end   = PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE - 1;
+		res[1].name  = "PEX0 Memory";
+		res[1].flags = IORESOURCE_MEM;
+	} else {
+		res[0].start = PEX1_IO_PHYS_BASE - IO_SPACE_REMAP;
+		res[0].end   = PEX1_IO_PHYS_BASE - IO_SPACE_REMAP + PEX1_IO_SIZE - 1;
+		res[0].name  = "PEX1 IO";
+		res[0].flags = IORESOURCE_IO;
+
+		res[1].start = PEX1_MEM_PHYS_BASE;
+		res[1].end   = PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE - 1;
+		res[1].name  = "PEX1 Memory";
+		res[1].flags = IORESOURCE_MEM;
+	}
+
+        if (request_resource(&ioport_resource, &res[0]))
+	{
+		printk ("IO Request resource failed - Pci If %x\n",nr);
+	}
+	if (request_resource(&iomem_resource, &res[1]))
+	{
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+	}
+
+        sys->resource[0] = &res[0];
+        sys->resource[1] = &res[1];
+        sys->resource[2] = NULL;
+        sys->io_offset   = 0x0;
+	sys->mv_controller_num = nr;
+
+        return 1;
+
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops = &mv_pci_ops;
+	struct pci_bus *bus;
+
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+
+	if(sys->mv_controller_num == 0)
+		mvPexLocalBusNumSet(1,
+			bus->number + bus->subordinate - bus->secondary + 1);
+
+        return bus;
+}
+
+/**
+* pex_error_interrupt
+* DESCRIPTION: PCI express error interrupt  routine
+* INPUTS:      @irq: irq number
+               @dev_id: device id - ignored
+* OUTPUTS:     kernel error message
+* RETURNS:     IRQ_HANDLED
+**/
+static irqreturn_t pex_error_interrupt(int irq, void *dev_id)
+{
+	MV_U32  reg_val;
+	MV_U32 ifPexNumber=*(MV_U32 *)dev_id;
+
+	/* get current value of Interrupt Cause Register */
+	reg_val = MV_REG_READ(MV_PCI_IRQ_CAUSE_REG(ifPexNumber));
+	printk(KERN_ERR "PCI express error: irq - %d, Pex number: %d, "
+			"Interrupt Cause Register value: %x  \n", irq, ifPexNumber, reg_val);
+
+	return IRQ_HANDLED;
+}
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+        return IRQ_AURORA_PCIE0;
+}
+
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+        return IRQ_AURORA_PCIE1;
+}
+
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .map_irq                = mv_map_irq_0,
+        .setup                  = mv_pci_setup,
+        .scan                   = mv_pci_scan_bus,
+        .preinit                = mv_pci_preinit,
+};
+
+static int __init mv_pci_init(void)
+{
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Check pex power state */
+	MV_U32 pexPower;
+	pexPower = mvCtrlPwrClckGet(PEX_UNIT_ID,0);
+	if (pexPower == MV_FALSE)
+	{
+		printk("\nWarning PCI-E is Powered Off\n");
+		return 0;
+	}
+#endif
+
+    mv_pci.nr_controllers = mvCtrlPexMaxIfGet();
+    pci_common_init(&mv_pci);
+
+    return 0;
+}
+
+
+subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-armada370/proc_aurora_dbg.c b/arch/arm/mach-armada370/proc_aurora_dbg.c
new file mode 100644
index 0000000..a46b0fe
--- /dev/null
+++ b/arch/arm/mach-armada370/proc_aurora_dbg.c
@@ -0,0 +1,87 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+static struct proc_dir_entry *aurora_dbg;
+
+unsigned int aurora_core_index(void)
+{
+        unsigned int value;
+
+        __asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPU ID reg\n"
+                : "=r" (value) :: "memory");
+        return (value & 0xF);
+}
+
+/********************************************************************/
+int aurora_dbg_read (char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr) {
+
+	char *p = buffer;
+	unsigned int val, len;
+
+#ifdef CONFIG_SMP
+	p += sprintf(p,"CPU %d:\n", aurora_core_index());
+#endif
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 1" : "=r" (val));
+	p += sprintf(p, "c1, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 2" : "=r" (val));
+	p += sprintf(p, "c1, 2 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 0" : "=r" (val));
+	p += sprintf(p, "c2, 0 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 1" : "=r" (val));
+	p += sprintf(p, "c2, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 0" : "=r" (val));
+	p += sprintf(p, "c1, 0 %x \n", val);
+
+#ifdef CONFIG_PERF_EVENTS
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 0" : "=r" (val));
+	p += sprintf(p, "pmon ctrl %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 1" : "=r" (val));
+	p += sprintf(p, "pmon cntrs en %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 3" : "=r" (val));
+	p += sprintf(p, "pmon cntrs oflow %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 5" : "=r" (val));
+	p += sprintf(p, "pmon cntr sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 0" : "=r" (val));
+	p += sprintf(p, "pmon cycle cnt %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 1" : "=r" (val));
+	p += sprintf(p, "pmon evt sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 2" : "=r" (val));
+	p += sprintf(p, "pmon cntr val %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c14, 1" : "=r" (val));
+	p += sprintf(p, "pmon int en %x \n", val);
+#endif
+
+	len = (p - buffer);
+	return len;
+}
+
+/********************************************************************/
+int __init start_aurora_dbg(void)
+{
+        aurora_dbg = create_proc_entry ("aurora_dbg" , 0666 , NULL);
+	aurora_dbg->read_proc = aurora_dbg_read;
+	aurora_dbg->write_proc = NULL;
+	aurora_dbg->nlink = 1;
+	return 0;
+}
+void __exit stop_aurora_dbg(void)
+{
+        remove_proc_entry("aurora_dbg",  NULL);
+        return;
+}
+module_init(start_aurora_dbg);
+module_exit(stop_aurora_dbg);
diff --git a/arch/arm/mach-armada370/sysmap.c b/arch/arm/mach-armada370/sysmap.c
new file mode 100644
index 0000000..cffce27
--- /dev/null
+++ b/arch/arm/mach-armada370/sysmap.c
@@ -0,0 +1,167 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <asm/mach/map.h>
+
+/* for putstr */
+/* #include <asm/arch/uncompress.h> */
+
+MV_CPU_DEC_WIN* mv_sys_map(void);
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan);
+u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+
+struct map_desc  MEM_TABLE[] =	{
+	/* no use for pex mem remap */
+	{ INTER_REGS_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
+	{ PEX0_IO_VIRT_BASE,   		__phys_to_pfn(PEX0_IO_PHYS_BASE),	PEX0_IO_SIZE,  		MT_DEVICE},
+	{ PEX1_IO_VIRT_BASE,   		__phys_to_pfn(PEX1_IO_PHYS_BASE),	PEX1_IO_SIZE,  		MT_DEVICE},
+#ifdef MV_INCLUDE_LEGACY_NAND
+	{ LEGACY_NAND_VIRT_BASE,	__phys_to_pfn(LEGACY_NAND_PHYS_BASE),	LEGACY_NAND_SIZE, 	MT_DEVICE},
+#endif
+	{ SPI_CS0_VIRT_BASE,		__phys_to_pfn(SPI_CS0_PHYS_BASE),	SPI_CS0_SIZE,		MT_DEVICE},
+	{ CRYPT_ENG_VIRT_BASE(0),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(0)),	CRYPT_ENG_SIZE,		MT_DEVICE}
+};
+
+MV_CPU_DEC_WIN SYSMAP_ARMADA_370[] = {
+	/* base low       	     base high        size       		WinNum     	enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS3 */
+        {{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	0x5,		EN},	/* DEVICE_CS0 */
+        {{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS1 */
+        {{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS3 */
+	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0x0,		EN},	/* PEX0_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	0x1,		EN},	/* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	0x2,		EN},	/* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	0x3,		EN},	/* PEX1_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0x6,		EN},	/* SPI_CS0 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS4 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
+        {{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	DEVICE_BOOTCS_SIZE	},	0x6,		DIS},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0x7,		EN},	/* DEV_BOOCS */
+	{{PMU_SCRATCH_PHYS_BASE,	0,	PMU_SCRATCH_SIZE	},	TBL_UNUSED,	DIS},	/* PMU SCRATCHPAD */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0x8,		EN},	/* CRYPT0_ENG */
+	{{TBL_TERM,			TBL_TERM, TBL_TERM		},	TBL_TERM,	TBL_TERM}
+};
+
+
+MV_CPU_DEC_WIN* mv_sys_map(void)
+{
+	switch(mvBoardIdGet()) {
+		case DB_88F6710_BP_ID:
+		case RD_88F6710_ID:
+			return SYSMAP_ARMADA_370;
+		default:
+			printk("ERROR: can't find system address map\n");
+			return NULL;
+        }
+}
+
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan)
+{
+	return CRYPT_ENG_PHYS_BASE(chan);
+}
+u32 mv_crypto_virt_base_get(u8 chan)
+{
+	return CRYPT_ENG_VIRT_BASE(chan);
+}
+#endif
+
+void __init axp_map_io(void)
+{
+        iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+}
+
+#if 0
+static u32 mv_pci_mem_base[] =
+{
+	PEX0_MEM_PHYS_BASE,
+	PEX1_MEM_PHYS_BASE
+};
+
+static u32 mv_pci_mem_size[] =
+{
+	PEX0_MEM_SIZE,
+	PEX1_MEM_SIZE
+};
+
+static u32 mv_pci_io_base[] =
+{
+	PEX0_IO_PHYS_BASE,
+	PEX1_IO_PHYS_BASE
+};
+
+static u32 mv_pci_io_size[] =
+{
+	PEX0_IO_SIZE,
+	PEX1_IO_SIZE
+};
+
+static MV_TARGET mv_pci_io_target[] =
+{
+	PEX0_IO,
+	PEX1_IO
+};
+
+u32 mv_pci_mem_base_get(int ifNum)
+{
+	return mv_pci_mem_base[ifNum];
+}
+
+u32 mv_pci_mem_size_get(int ifNum)
+{
+	return mv_pci_mem_size[ifNum];
+}
+
+u32 mv_pci_io_base_get(int ifNum)
+{
+	return mv_pci_io_base[ifNum];
+}
+
+u32 mv_pci_io_size_get(int ifNum)
+{
+	return mv_pci_io_size[ifNum];
+}
+
+MV_TARGET mv_pci_io_target_get(int ifNum)
+{
+	return mv_pci_io_target[ifNum];
+}
+
+int mv_is_pci_io_mapped(int ifNum)
+{
+	/* PCIe IO windows are enabled for both I/F */
+	return 1;
+}
+#endif
diff --git a/arch/arm/mach-armada370/time.c b/arch/arm/mach-armada370/time.c
new file mode 100644
index 0000000..c251e68
--- /dev/null
+++ b/arch/arm/mach-armada370/time.c
@@ -0,0 +1,244 @@
+/*
+ * arch/arm/mach-armadaxp/time.c
+ *
+ * Marvell Aurora SoC timer handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * Timer 0 is used as free-running clocksource, while timer 1 is
+ * used as clock_event_device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+
+extern void axp_irq_mask(struct irq_data *d);
+extern void axp_irq_unmask(struct irq_data *d);
+
+#define  TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER0_EN		0x0001
+#define  TIMER0_RELOAD_EN	0x0002
+#define  TIMER1_EN		0x0004
+#define  TIMER1_RELOAD_EN	0x0008
+#define  TIMER0_RELOAD		(MV_CNTMR_REGS_OFFSET + 0x0010)
+#define  TIMER0_VAL		(MV_CNTMR_REGS_OFFSET + 0x0014)
+#define  TIMER1_RELOAD		(MV_CNTMR_REGS_OFFSET + 0x0018)
+#define  TIMER1_VAL		(MV_CNTMR_REGS_OFFSET + 0x001c)
+#define  TIMER_WD_RELOAD	(MV_CNTMR_REGS_OFFSET + 0x0020)
+#define  TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
+#define  TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0028)
+#define  INT_TIMER0_CLR 	~(1 << 0)
+#define  INT_TIMER1_CLR 	~(1 << 8)
+
+#define  LCL_TIMER_BASE		(0x21000 | 0x40)
+#define  LCL_TIMER_CTRL		(LCL_TIMER_BASE + 0x0000)
+#define  LCL_TIMER0_EN		0x0001
+#define  LCL_TIMER0_RELOAD_EN	0x0002
+#define  LCL_TIMER1_EN		0x0004
+#define  LCL_TIMER1_RELOAD_EN	0x0008
+#define  LCL_TIMER0_RELOAD	(LCL_TIMER_BASE + 0x0010)
+#define  LCL_TIMER0_VAL		(LCL_TIMER_BASE + 0x0014)
+#define  LCL_TIMER1_RELOAD	(LCL_TIMER_BASE + 0x0018)
+#define  LCL_TIMER1_VAL		(LCL_TIMER_BASE + 0x001c)
+#define  LCL_TIMER_WD_RELOAD	(LCL_TIMER_BASE + 0x0020)
+#define  LCL_TIMER_WD_VAL	(LCL_TIMER_BASE + 0x0024)
+#define  LCL_TIMER_CAUSE	(LCL_TIMER_BASE + 0x0028)
+#define  LCL_INT_TIMER0_CLR 	~(1 << 0)
+#define  LCL_INT_TIMER1_CLR	~(1 << 8)
+
+#define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
+#define BRIDGE_INT_TIMER0	(1 << 24)
+#define BRIDGE_INT_TIMER1	(1 << 25)
+#define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
+
+static DEFINE_CLOCK_DATA(cd);
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
+
+/*
+ * Clocksource handling.
+ */
+static cycle_t axp_clksrc_read(struct clocksource *cs)
+{
+	return (0xffffffff - MV_REG_READ(TIMER0_VAL));
+}
+
+static struct clocksource axp_clksrc = {
+	.name		= "armada370_clocksource",
+	.shift		= 20,
+	.rating		= 300,
+	.read		= axp_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Clockevent handling.
+ */
+int axp_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (delta == 0)
+		return -ETIME;
+
+	local_irq_save(flags);
+
+	/* Clear and enable clockevent timer interrupt */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	/*axp_irq_unmask(IRQ_LOCALTIMER);*/
+	axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	/* Setup new clockevent timer value */
+	MV_REG_WRITE(LCL_TIMER0_VAL, delta);
+
+	/* Enable the timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u = (u & ~LCL_TIMER0_RELOAD_EN) | LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void axp_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	local_irq_save(flags);
+
+	if (mode == CLOCK_EVT_MODE_PERIODIC) {
+		/* Setup timer to fire at 1/HZ intervals */
+		MV_REG_WRITE(LCL_TIMER0_RELOAD, (ticks_per_jiffy - 1));
+		MV_REG_WRITE(LCL_TIMER0_VAL, (ticks_per_jiffy - 1));
+
+		/* Enable timer interrupt */
+		/*axp_irq_unmask(IRQ_LOCALTIMER);*/
+		axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+		/* Enable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN);
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	} else {
+		/* Disable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u &= ~LCL_TIMER0_EN;
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+		/* Disable timer interrupt */
+		axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+		/* ACK pending timer interrupt */
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	}
+
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device axp_clkevt;
+static irqreturn_t axp_timer_interrupt(int irq, void *dev_id)
+{
+	/* ACK timer interrupt and call event handler */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	axp_clkevt.event_handler(&axp_clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction axp_timer_irq = {
+	.name		= "armada370_tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= axp_timer_interrupt
+};
+
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit mv_timer_setup(struct clock_event_device *clk, unsigned int fabric_clk)
+{
+	unsigned int cpu = smp_processor_id();
+
+	clk->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	clk->shift		= 32,
+	clk->rating		= 300,
+	clk->set_next_event	= axp_clkevt_next_event,
+	clk->set_mode		= axp_clkevt_mode,
+	clk->cpumask		= cpumask_of(cpu);
+	clk->mult		= div_sc(fabric_clk, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0x1, clk);
+}
+
+unsigned long long notrace sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER0_VAL);
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void notrace a370_update_sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER0_VAL);
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void __init setup_sched_clock(unsigned long tclk)
+{
+	init_sched_clock(&cd, a370_update_sched_clock, 32, tclk);
+}
+
+void __init axp_time_init(unsigned int fabric_clk)
+{
+	u32 u;
+
+	printk("a370_time_init\n");
+
+	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+
+	setup_sched_clock(fabric_clk);
+
+	/* Setup free-running clocksource timer (interrupts disabled) */
+	MV_REG_WRITE(TIMER0_VAL, 0xffffffff);
+	MV_REG_WRITE(TIMER0_RELOAD, 0xffffffff);
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER0;
+	MV_REG_WRITE(BRIDGE_MASK, u);
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= (TIMER0_EN | TIMER0_RELOAD_EN);
+	MV_REG_WRITE(TIMER_CTRL, u);
+	axp_clksrc.mult = clocksource_hz2mult(fabric_clk, axp_clksrc.shift);
+	clocksource_register(&axp_clksrc);
+
+	/* Setup clockevent timer (interrupt-driven) */
+	axp_clkevt.name = "armada370_tick";
+	axp_clkevt.irq = IRQ_LOCALTIMER;
+	mv_timer_setup(&axp_clkevt, fabric_clk);
+	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
+	clockevents_register_device(&axp_clkevt);
+}
+
+static void axp_timer_init(void)
+{
+	axp_time_init(mvCpuL2ClkGet());
+}
+
+struct sys_timer axp_timer = {
+	.init = axp_timer_init,
+};
diff --git a/arch/arm/mach-armada370/usb.c b/arch/arm/mach-armada370/usb.c
new file mode 100644
index 0000000..7492c3f
--- /dev/null
+++ b/arch/arm/mach-armada370/usb.c
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+//#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysUsbApi.h"
+#include "usb/mvUsbRegs.h"
+#include "usb/mvUsb.h"
+
+u32 mvIsUsbHost = 1;
+
+#define MV_USB_DMA_MASK		0xffffffff
+#define MAX_USB_PORTS		2
+
+static char usb_dev_name[]  = "mv_udc";
+static char usb_host_name[] = "ehci_marvell";
+static char usb_bus_name[]  = "platform";
+
+
+static void mv_usb_release(struct device *dev)
+{
+    struct platform_device  *pdev = to_platform_device(dev);
+
+    /* normally not freed */
+    printk("mv_usb_release\n");
+
+    kfree(pdev->resource);
+    kfree(pdev->dev.dma_mask);
+    kfree(pdev);
+}
+
+
+static int __init   mv_usb_init(void)
+{
+	int                     status, dev, num, isHost;
+	char*                   name_ptr;
+	struct platform_device* mv_usb_dev_ptr;
+	int 			irq_num[2] = {	IRQ_AURORA_USB0,
+						IRQ_AURORA_USB1};
+
+	num = mvCtrlUsbMaxGet();
+	if (num > MAX_USB_PORTS) {
+		printk("WARNING: Limited USB ports number to %d\n", MAX_USB_PORTS);
+		num = MAX_USB_PORTS;
+	}
+
+	for(dev=0; dev<num; dev++)
+	{
+		if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev))
+		{
+			printk("\nWarning Integrated USB %d is Powered Off\n",dev);
+			continue;
+		}
+
+		isHost = mvIsUsbHost & (1 << dev);
+
+		if(isHost)
+			name_ptr = usb_host_name;
+		else
+			name_ptr = usb_dev_name;
+
+		status = mvSysUsbInit(dev, isHost);
+
+		mv_usb_dev_ptr = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if(mv_usb_dev_ptr == NULL)
+		{
+			printk("Can't allocate platform_device structure - %d bytes\n",
+					sizeof(struct platform_device) );
+			return 1;
+		}
+		memset(mv_usb_dev_ptr, 0, sizeof(struct platform_device) );
+
+		mv_usb_dev_ptr->name               = name_ptr;
+		mv_usb_dev_ptr->id                 = dev;
+
+		mv_usb_dev_ptr->num_resources  = 2;
+
+		mv_usb_dev_ptr->resource = (struct resource*)kmalloc(2*sizeof(struct resource), GFP_KERNEL);
+		if(mv_usb_dev_ptr->resource == NULL)
+		{
+			printk("Can't allocate 2 resource structure - %d bytes\n",
+					2*sizeof(struct resource) );
+			kfree(mv_usb_dev_ptr);
+			return 1;
+		}
+		memset(mv_usb_dev_ptr->resource, 0, 2*sizeof(struct resource));
+
+		mv_usb_dev_ptr->resource[0].start =
+			( INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
+		mv_usb_dev_ptr->resource[0].end   =
+			((INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
+		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
+
+		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
+		mv_usb_dev_ptr->resource[1].flags = IORESOURCE_IRQ;
+
+		mv_usb_dev_ptr->dev.dma_mask           = kmalloc(sizeof(u64), GFP_KERNEL);
+		*mv_usb_dev_ptr->dev.dma_mask          = MV_USB_DMA_MASK;
+
+		mv_usb_dev_ptr->dev.coherent_dma_mask  = ~0;
+		mv_usb_dev_ptr->dev.release            = mv_usb_release;
+		dev_set_name(&mv_usb_dev_ptr->dev, "%s", usb_bus_name);
+
+		printk("Marvell USB %s controller #%d: %p\n",
+				isHost ? "EHCI Host" : "Gadget", dev, mv_usb_dev_ptr);
+
+		status = platform_device_register(mv_usb_dev_ptr);
+		if (status)
+		{
+			printk("Can't register Marvell USB EHCI controller #%d, status=%d\n",
+					dev, status);
+			return status;
+		}
+	}
+	return 0;
+}
+
+subsys_initcall(mv_usb_init);
-- 
1.7.5.4

