From 7fc12a0b3ab8a3e19b57f7f787a441d7761b2a33 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Wed, 26 Feb 2014 13:40:01 +0200
Subject: [PATCH 1402/1825] split init to hw and sw functions

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 60812744c764d9f6f64db9b8ae71e42dd658e0d3

Change-Id: I036fde8072bc14706120756a8286c653fba712a3
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5959
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h |    5 +-
 drivers/net/ethernet/marvell/pp3/emac/mv_emac.c    |   11 +-
 drivers/net/ethernet/marvell/pp3/emac/mv_emac.h    |   11 +-
 .../net/ethernet/marvell/pp3/emac/mv_emac_sysfs.c  |   17 +-
 .../net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h   |    6 +-
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |  772 ++++++++++++++------
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.h   |   21 +-
 .../marvell/pp3/net_dev/mv_netdev_structs.h        |   54 +-
 8 files changed, 614 insertions(+), 283 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
index b6c8d94..28e20cc 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
@@ -125,6 +125,9 @@ static INLINE void mv_pp3_hw_reg_write(u32 access_addr, u32 data)
 	writel(data, access_addr);
 }
 
-int mv_hw_silicon_base_addr_get(u32 *siliconBase);
+static INLINE u32 mv_hw_silicon_base_addr_get(void)
+{
+	return 0xb0000000;
+}
 
 #endif /* __mvHwIf_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
index 88f8d60..0ec826c 100644
--- a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
+++ b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
@@ -106,7 +106,13 @@ static void mv_pp3_emac_reg_print(int port, char *reg_name, u32 reg)
 	pr_info("  %-32s: 0x%x = 0x%08x\n", reg_name, reg, mv_pp3_emac_reg_read(port, reg));
 }
 
-void mv_pp3_emac_init(int port, u32 base)
+void mv_pp3_emac_unit_base(int port, u32 base)
+{
+	pp3_emac[port].base = base;
+	pp3_emac[port].flags |= MV_PP3_EMAC_F_ATTACH;
+}
+
+void mv_pp3_emac_init(int port)
 {
 	/* attach to QM */
 	/* TODO config the correct values of qm_q and qm_port */
@@ -114,9 +120,6 @@ void mv_pp3_emac_init(int port, u32 base)
 
 	/* enable MH */
 	mv_pp3_emac_mh_en(port, 1);
-
-	pp3_emac[port].base = base;
-	pp3_emac[port].flags |= MV_PP3_EMAC_F_ATTACH;
 }
 
 /* enable debug flag */
diff --git a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
index bd5d5ee..84f964d 100644
--- a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
+++ b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
@@ -65,6 +65,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __mvEmac_h__
 #define __mvEmac_h__
 
+#include <linux/netdevice.h>
+
 /*--------------------------------------------------------------*/
 /*--------------------- EMAC globals ---------------------------*/
 /*--------------------------------------------------------------*/
@@ -86,12 +88,13 @@ struct mv_pp3_emac_ctrl {
 #define MV_PP3_EMAC_F_DEBUG		(1 << MV_PP3_EMAC_F_DEBUG_BIT)
 #define MV_PP3_EMAC_F_ATTACH		(1 << MV_PP3_EMAC_F_ATTACH_BIT)
 
+void mv_pp3_emac_unit_base(int index, u32 base);
 
 u32  mv_pp3_emac_reg_read(int port, u32 reg);
 
 void mv_pp3_emac_reg_write(int port, u32 reg, u32 data);
 
-void mv_pp3_emac_init(int port, u32 base);
+void mv_pp3_emac_init(int port);
 
 void mv_pp3_emac_qm_mapping(int port, int qm_port, int qm_q);
 
@@ -137,5 +140,11 @@ void mv_pp3_emac_pfc_regs(int port);
 void mv_pp3_emac_wol_regs(int port);
 /* TODO */
 
+/*--------------------------------------------------------------*/
+/*------------------------- SYSFS ------------------------------*/
+/*--------------------------------------------------------------*/
+
+int mv_pp3_emac_sysfs_exit(struct kobject *pp3_kobj);
+int mv_pp3_emac_sysfs_init(struct kobject *pp3_kobj);
 
 #endif /* __mvEmac_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/emac/mv_emac_sysfs.c b/drivers/net/ethernet/marvell/pp3/emac/mv_emac_sysfs.c
index 4f12cf1..63b289b 100644
--- a/drivers/net/ethernet/marvell/pp3/emac/mv_emac_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/emac/mv_emac_sysfs.c
@@ -155,32 +155,27 @@ static struct attribute *mv_emac_attrs[] = {
 };
 
 static struct attribute_group mv_emac_group = {
+	.name = "emac",
 	.attrs = mv_emac_attrs,
 };
 
-static struct kobject *emac_kobj;
 
 int mv_pp3_emac_sysfs_init(struct kobject *pp3_kobj)
 {
 	int err;
 
-	emac_kobj = kobject_create_and_add("emac", pp3_kobj);
-	if (!emac_kobj) {
-		pr_err("%s: cannot create emac kobject\n", __func__);
-		return -ENOMEM;
-	}
-
-	err = sysfs_create_group(emac_kobj, &mv_emac_group);
+	err = sysfs_create_group(pp3_kobj, &mv_emac_group);
 	if (err) {
-		pr_err("sysfs group failed %d\n", err);
+		pr_err("sysfs group %s failed %d\n", mv_emac_group.name, err);
 		return err;
 	}
 
 	return err;
 }
 
-int mv_pp3_emac_sysfs_exit(struct kobject *emac_kobj)
+int mv_pp3_emac_sysfs_exit(struct kobject *pp3_kobj)
 {
-	/*TODO*/
+	sysfs_remove_group(pp3_kobj, &mv_emac_group);
+
 	return 0;
 }
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
index bc57fef..3c034b4 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
@@ -68,9 +68,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* includes */
 
 /* unit offset */
-#define MV_PP3_HMAC_GL_UNIT_OFFSET	0x30000
-#define MV_PP3_HMAC_FR_UNIT_OFFSET	0x200000
-
+#define MV_PP3_HMAC_GL_UNIT_OFFSET	0x0F0000
+#define MV_PP3_HMAC_FR_UNIT_OFFSET	0x100000
+#define MV_PP3_HMAC_FR_INST_OFFSET	0x010000
 /************************** HMAC GLOBAL regs *********************************************************/
 
 /* Hmac_eco */
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index 67d620b..a447747 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -13,24 +13,71 @@
 #include <net/ip.h>
 #include <net/ipv6.h>
 #include <linux/mv_pp3.h>
+#include <linux/dma-mapping.h>
 #include "common/mv_hw_if.h"
 #include "hmac/mv_hmac.h"
 #include "hmac/mv_hmac_bm.h"
+#include "emac/mv_emac.h"
 #include "mv_netdev.h"
 #include "mv_netdev_structs.h"
 
 /* global data */
+struct pp3_group *pp3_groups[CONFIG_NR_CPUS][MAX_ETH_DEVICES];
+struct pp3_frame **pp3_frames;
 struct pp3_pool **pp3_pools;
 struct pp3_dev_priv **pp3_ports;
-struct pp3_group *pp3_groups[CONFIG_NR_CPUS][MAX_ETH_DEVICES];
 struct pp3_cpu **pp3_cpus;
 static int pp3_ports_num;
-static int pp3_initialized;
+static int pp3_hw_initialized;
+static struct  platform_device *pp3_sysfs;
 
 /* functions */
 static int mv_pp3_poll(struct napi_struct *napi, int budget);
+static int mv_pp3_dev_open(struct net_device *dev);
+static int mv_pp3_hw_shared_start(void);
+
+/*---------------------------------------------------------------------------*/
+
+static int pp3_sysfs_init(void)
+{
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp3");
+
+	if (!pd) {
+		pp3_sysfs = platform_device_register_simple("pp3", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp3");
+	}
+
+	if (!pd) {
+		pr_err("%s: cannot find pp3 device\n", __func__);
+		return -1;
+	}
+
+	mv_pp3_emac_sysfs_init(&pd->kobj);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static void pp3_sysfs_exit(void)
+{
+	struct device *pd;
 
-/* Trigger tx done timer in MVNETA_TX_DONE_TIMER_PERIOD msecs */
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp3");
+	if (!pd) {
+		pr_err("%s: cannot find pp3 device\n", __func__);
+		return;
+	}
+
+	mv_pp3_emac_sysfs_exit(&pd->kobj);
+	platform_device_unregister(pp3_sysfs);
+}
+
+/*---------------------------------------------------------------------------*/
+/* Trigger tx done in MV_CPU_TX_DONE_TIMER_PERIOD msecs			     */
+/*---------------------------------------------------------------------------*/
 static void mv_pp3_add_tx_done_timer(struct pp3_cpu *cpu_ctrl)
 {
 	if (test_and_set_bit(MV_CPU_F_TX_DONE_TIMER, &cpu_ctrl->flags) == 0) {
@@ -39,7 +86,8 @@ static void mv_pp3_add_tx_done_timer(struct pp3_cpu *cpu_ctrl)
 		add_timer_on(&cpu_ctrl->tx_done_timer, cpu_ctrl->cpu);
 	}
 }
-/* tx done timer callback */
+
+/*---------------------------------------------------------------------------*/
 static void mv_pp3_tx_done_timer_callback(unsigned long data)
 {
 	struct pp3_cpu *cpu_ctrl = (struct pp3_cpu *)data;
@@ -57,19 +105,17 @@ static void mv_pp3_tx_done_timer_callback(unsigned long data)
 		mv_pp3_add_tx_done_timer(cpu_ctrl);
 }
 
-/****************************************************************
- * mv_pp3_isr							*
- *	rx events , group interrupt handle			*
- ***************************************************************/
-irqreturn_t mv_pp3_isr(int irq, int group_id)
+/*---------------------------------------------------------------------------*/
+/* rx events , group interrupt handle					     */
+/*---------------------------------------------------------------------------*/
+irqreturn_t mv_pp3_isr(void *data)
 {
-	int cpu = smp_processor_id();
-	struct pp3_group *group = pp3_groups[cpu][group_id];
+	struct pp3_group *group = (struct pp3_group *)data;
 	struct napi_struct *napi = group->napi;
 
 	STAT_INFO(group->stats.irq++);
 
-	/* TODO: interrupts Mask */
+	/* TODO: disable group interrupt */
 
 	/* Verify that the device not already on the polling list */
 	if (napi_schedule_prep(napi)) {
@@ -79,15 +125,15 @@ irqreturn_t mv_pp3_isr(int irq, int group_id)
 		STAT_INFO(group->stats.irq_err++);
 	}
 
-	/* TODO: interrupts unMask */
+	/* TODO: enable group interrupt */
 
 	return IRQ_HANDLED;
 }
 
-/****************************************************************
- * mv_pp3_poll							*
- *	napi func - call to mv_pp3_rx for group's rxqs		*
- ***************************************************************/
+/*---------------------------------------------------------------------------*/
+/* call to mv_pp3_rx for group's rxqs					     */
+/*---------------------------------------------------------------------------*/
+
 static int mv_pp3_poll(struct napi_struct *napi, int budget)
 {
 	int rx_done = 0;
@@ -99,16 +145,12 @@ static int mv_pp3_poll(struct napi_struct *napi, int budget)
 		return rx_done;
 	}
 
-
 	STAT_INFO(group->stats.rx_poll++);
 
-	/* TODO */
-
-
 	while (budget > 0) { /* && group rxqs are not empty */
-
-		/* TODO
-			select rx_queue
+		/*
+		for all rxqs in the group
+			example from ppv2
 			call to mv_pp3_rx()
 			update counters and budget
 		*/
@@ -117,18 +159,16 @@ static int mv_pp3_poll(struct napi_struct *napi, int budget)
 	if (budget > 0)
 		napi_complete(napi);
 
-
 	return rx_done;
 }
 
-/****************************************************************
- * mv_pp3_linux_pool_isr					*
- *	linux poll full interrupt handler			*
- ***************************************************************/
-irqreturn_t mv_pp3_done_pool_isr(int irq, int group_id)
+/*---------------------------------------------------------------------------*/
+/* linux pool full interrupt handler					     */
+/*---------------------------------------------------------------------------*/
+
+irqreturn_t pp3_linux_pool_isr(unsigned int data)
 {
-	int cpu = smp_processor_id();
-	struct pp3_cpu *cpu_ctrl = pp3_cpus[cpu];
+	struct pp3_cpu *cpu_ctrl = (struct pp3_cpu *)data;
 
 	STAT_INFO(cpu_ctrl->stats.lnx_pool_irq++);
 
@@ -139,9 +179,10 @@ irqreturn_t mv_pp3_done_pool_isr(int irq, int group_id)
 	/* TODO: interrupts UnMask */
 
 	return IRQ_HANDLED;
-
 }
 
+/*---------------------------------------------------------------------------*/
+
 void mv_pp3_bm_tasklet(unsigned long data)
 {
 	int pool;
@@ -157,28 +198,13 @@ void mv_pp3_bm_tasklet(unsigned long data)
 			dev_kfree_skb_any((struct sk_buff *)(&vr_addr));
 			cpu_ctrl->tx_done_cnt--;
 		}
+		/* talk with yelena ... if we use the same HMAC Q */
 		/* TODO: registration mechanisem */
 		/* TODO: else call calback function */
 	}
 }
 
-static unsigned char *pp3_hwf_buff_alloc(struct pp3_pool *ppool, unsigned long *phys_addr)
-{
-	unsigned char *buf;
-
-	buf = kmalloc(ppool->buf_size, GFP_ATOMIC);
-	if (!buf)
-		return NULL;
-
-	memset(buf, 0, ppool->buf_size);
-
-	/*
-	TODO
-	if (phys_addr != NULL)
-		*phys_addr = mvOsCacheInvalidate(NULL, buff, size);
-	*/
-	return buf;
-}
+/*---------------------------------------------------------------------------*/
 
 static struct sk_buff *pp3_skb_alloc(struct pp3_pool *ppool, unsigned long *phys_addr, gfp_t gfp_mask)
 {
@@ -195,25 +221,46 @@ static struct sk_buff *pp3_skb_alloc(struct pp3_pool *ppool, unsigned long *phys
 	return skb;
 }
 
-static int pp3_pool_create(int pool, int capacity)
+/*---------------------------------------------------------------------------*/
+
+static int pp3_pool_release(int pool)
+{
+	if ((pp3_pools == NULL) | (pp3_pools[pool] == NULL))
+		return 0;
+
+	if (pp3_pools[pool]->buf_num != 0) {
+		pr_err("%s: pool %d is not empty\n", __func__, pool);
+		return -EINVAL;
+	}
+
+	kfree(pp3_pools[pool]->virt_base);
+	kfree(pp3_pools[pool]);
+
+	pr_info("%s: pool %d released\n", __func__, pool);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static struct pp3_pool *pp3_pool_alloc(int pool, int capacity)
 {
 	struct pp3_pool *ppool;
-	unsigned long physAddr;
-	int size, ret_val;
+	int size;
 
 	if (capacity % 16) {
 		pr_err("%s: pool size must be multiple of 16\n", __func__);
-		return -EINVAL;
+		return NULL;
 	}
 
 	if ((pool < 0) || (pool >= MV_PP3_BM_POOLS)) {
 		pr_err("%s: pool=%d is out of range\n", __func__, pool);
-		return -EINVAL;
+		return NULL;
 	}
 
 	if (pp3_pools[pool] != NULL) {
 		pr_err("%s: pool=%d already exist\n", __func__, pool);
-		return -EINVAL;
+		return NULL;
 	}
 
 	/* init group napi */
@@ -221,42 +268,129 @@ static int pp3_pool_create(int pool, int capacity)
 
 	ppool = pp3_pools[pool];
 
-	if (!ppool) {
-		pr_err("%s: out of memory\n", __func__);
-		return -ENOMEM;
-	}
+	if (!ppool)
+		goto oom;
 
 	memset(ppool, 0, sizeof(struct pp3_pool));
 
+	ppool->pool = pool;
 	ppool->capacity = capacity;
 	ppool->flags = POOL_F_FREE;
 
-	size = 2 * sizeof(unsigned int) * capacity;
+	size = sizeof(unsigned int) * capacity;
 /*
-	TODO: example in mainline driver
-	ppool->virt_base = dma_alloc_coherent(pp->dev->dev.parent, size, &ppool->phys_base, GFP_KERNEL);
+	TODO: example in mainline driver, firt param ?
+	ppool->virt_base = dma_alloc_coherent(NULL, size, &ppool->phys_base, GFP_KERNEL);
 */
-	if (!ppool->virt_base) {
-		pr_err("%s: out of memory\n", __func__);
+	if (!ppool->virt_base)
 		goto oom;
+
+	return ppool;
+
+oom:
+	pp3_pool_release(pool);
+
+	pr_err("%s: out of memory\n", __func__);
+
+	return NULL;
+
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int pp3_pool_init_complete(int pool)
+{
+	int count = 0;
+	unsigned int completed;
+
+	do {
+		if (count++ >= MV_PP3_POOL_INIT_TIMEOUT_MSEC) {
+			pr_warn("TIMEOUT for pool #%d init complete\n", pool);
+			return -1;
+		}
+
+		mdelay(1);
+
+		/*bm_pool_quick_init_status_get(pool, &completed);*/
+
+	} while (!completed);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static struct pp3_pool *pp3_pool_gp_create(int pool, int capacity)
+{
+	struct pp3_pool *ppool;
+	unsigned int ret_val;
+
+	ppool = pp3_pool_alloc(pool, 2 * capacity);
+
+	if (ppool == NULL) {
+		pr_err("%s: out of memory\n", __func__);
+		return NULL;
 	}
 
-	/*
-	rev_val = bm_gp_pool_def_basic_init(pool, capacity, 0, ppool->phys_base, 1);
-	*/
+	ppool->type = PP3_POOL_TYPE_GP;
+
+	/*ret_val = bm_gp_pool_def_basic_init(pool, 2 * capacity, 0, ppool->phys_base, 1);*/
 
 	if (!ret_val)
-		return 0;
+		goto out;
 
-oom:
-	kfree(ppool->virt_base);
-	kfree(ppool);
+	if (pp3_pool_init_complete(pool))
+		goto out;
+
+	return ppool;
+out:
+	pp3_pool_release(pool);
+	pr_err("%s: pool %d creation failed\n", __func__, pool);
+	return NULL;
+}
 
-	pr_err("%s: failed\n", __func__);
+/*---------------------------------------------------------------------------*/
 
-	return -ENOMEM;
+static int pp3_pools_gpm_init(int capacity)
+{
+	struct pp3_pool *ppool_0, *ppool_1;
+	int ret_val;
+
+	ppool_0 = pp3_pool_alloc(MV_PP3_GPM_POOL_0, capacity);
+	ppool_1 = pp3_pool_alloc(MV_PP3_GPM_POOL_1, capacity);
+	ppool_0->type = PP3_POOL_TYPE_GPM;
+	ppool_1->type = PP3_POOL_TYPE_GPM;
+
+	/*reg_val = bm_qm_gpm_pools_def_quick_init(capacity, 0, ppool_0->phys_base, 0, ppool_1->phys_base);*/
+
+	if (!ret_val)
+		return ret_val;
+
+	return pp3_pool_init_complete(MV_PP3_GPM_POOL_0) || pp3_pool_init_complete(MV_PP3_GPM_POOL_1);
 }
 
+/*---------------------------------------------------------------------------*/
+
+/* initialize pool 2, 3 */
+static int pp3_pools_dram_init(int capacity)
+{
+	struct pp3_pool *ppool_0, *ppool_1;
+	int ret_val;
+
+	ppool_0 = pp3_pool_alloc(MV_PP3_DRAM_POOL_0, capacity);
+	ppool_1 = pp3_pool_alloc(MV_PP3_DRAM_POOL_1, capacity);
+	ppool_0->type = PP3_POOL_TYPE_DRAM;
+	ppool_1->type = PP3_POOL_TYPE_DRAM;
+
+	/*ret_val = bm_qm_dram_pools_def_quick_init (capacity, 0, ppool_0->phys_base, 0, ppool_1->phys_base);*/
+
+	if (!ret_val)
+		return ret_val;
+
+	return pp3_pool_init_complete(MV_PP3_DRAM_POOL_0) || pp3_pool_init_complete(MV_PP3_DRAM_POOL_1);
+}
+
+/*---------------------------------------------------------------------------*/
 
 static int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 {
@@ -284,10 +418,9 @@ static int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 	}
 
 	for (i = 0; i < buf_num; i++) {
+		/* alloc char * and add skb only in TX func */
+		virt =  (void *)pp3_skb_alloc(ppool, &phys_addr, GFP_KERNEL);
 
-		virt =  (ppool->flags & POOL_F_HWF) ?
-					(void *)pp3_hwf_buff_alloc(ppool, &phys_addr) :
-					(void *)pp3_skb_alloc(ppool, &phys_addr, GFP_KERNEL);
 		if (!virt)
 			break;
 
@@ -296,27 +429,26 @@ static int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 
 	ppool->buf_num += i;
 
-	pr_info("%s %s %s %s pool #%d:  buf_size=%4d - %d of %d buffers added\n",
-		(ppool->flags & POOL_F_HWF) ? "HWF" : "SWF",
+	pr_info("%s %s %s pool #%d:  buf_size=%4d - %d of %d buffers added\n",
 		(ppool->flags & POOL_F_SHORT) ? "short" : "",
 		(ppool->flags & POOL_F_LONG) ? "long" : "",
 		(ppool->flags & POOL_F_LRO) ? "lro" : "",
 		 pool, size, i, buf_num);
-
 }
 
-
-/****************************************************************
- * mv_pp3_chan_callback						*
- *	channel callback function				*
- ***************************************************************/
+/*---------------------------------------------------------------------------*/
+/* channel callback function						     */
+/*---------------------------------------------------------------------------*/
 void pp3_chan_callback(int chan, void *msg, int size)
 {
-	/* TODO: lock release*/
+	/* TODO: lock / release*/
 }
-/*
+
+/*---------------------------------------------------------------------------*/
+
 static const struct net_device_ops mv_pp3_netdev_ops = {
-	.ndo_open            = mv_pp3_open,
+	.ndo_open            = mv_pp3_dev_open,
+/*
 	.ndo_stop            = mv_pp3_stop,
 	.ndo_start_xmit      = mv_pp3_tx,
 	.ndo_set_rx_mode     = mv_pp3_set_rx_mode,
@@ -324,105 +456,182 @@ static const struct net_device_ops mv_pp3_netdev_ops = {
 	.ndo_change_mtu      = mv_pp3_change_mtu,
 	.ndo_tx_timeout      = mv_pp3_tx_timeout,
 	.ndo_get_stats64     = mvneta_get_stats64,
-};
-
 */
-/****************************************************************
- * mv_pp3_netdev_init						*
- *	Allocate and initialize net_device structures		*
- ***************************************************************/
+};
 
-struct net_device *mv_pp3_netdev_init(int mtu, u8 *mac, struct platform_device *pdev)
+/*---------------------------------------------------------------------------*/
+/* Allocate and initialize net_device structures			     */
+/*---------------------------------------------------------------------------*/
+struct net_device *mv_pp3_netdev_init(struct platform_device *pdev)
 {
 	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
-
+	struct pp3_dev_priv *dev_priv;
 	struct net_device *dev;
 	struct resource *res;
+	int rxqs_num = plat_data->group_rx_queue_count * nr_cpu_ids;
+	int txqs_num = plat_data->group_tx_queue_count * nr_cpu_ids;
 
-	dev = alloc_etherdev_mqs(sizeof(struct pp3_dev_priv), plat_data->tx_queue_count, plat_data->tx_queue_count);
+	/* tx_queue_count from core.c */
+	dev = alloc_etherdev_mqs(sizeof(struct pp3_dev_priv), txqs_num, rxqs_num);
 	if (!dev)
 		return NULL;
 
+	/*SET IN CORE.C to BASE*/
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	BUG_ON(!res);
 	dev->irq = res->start;
 
-	dev->mtu = mtu;
-	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
+	dev->mtu = plat_data->mtu;
+	memcpy(dev->dev_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
 
 	dev->tx_queue_len = plat_data->tx_queue_size;
 	dev->watchdog_timeo = 5 * HZ;
 
-	/* TODO: init eth_tools */
-
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
+	dev_priv = MV_PP3_PRIV(dev);
+
+	memset(dev_priv, 0, sizeof(struct pp3_dev_priv));
+
+	dev_priv->dev = dev;
+	dev_priv->index = pdev->id;
+	dev_priv->rxqs_num = rxqs_num;
+	dev_priv->txqs_num = txqs_num;
+
+/*
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
+		pr_warning( "mydev: No suitable DMA available.\n");
+		free_netdev(dev);
+		return NULL;
+	}
+*/
 	return dev;
+}
+
+/*---------------------------------------------------------------------------*/
 
+static struct pp3_rxq *pp3_rxq_priv_init(int emac, int cpu)
+{
+	int logic_q, phys_q, frame, size;
+	struct pp3_rxq *priv_rxq;
+
+	/*pp3_config_mngr_rxq(emac, cpu, &logic_q, &phys_q, &frame, &size);*/
+	priv_rxq = kzalloc(sizeof(struct pp3_rxq), GFP_KERNEL);
+
+	if (priv_rxq) {
+		priv_rxq->frame_num = frame;
+		priv_rxq->logic_q = logic_q;
+		priv_rxq->phys_q = phys_q;
+		priv_rxq->type = PP3_Q_TYPE_QM;
+		priv_rxq->size = size;
+		priv_rxq->pkt_coal = CONFIG_PP3_RX_COAL_PKTS;
+		priv_rxq->time_coal_profile = MV_PP3_RXQ_TIME_COAL_DEF_PROF;
+	}
+	return priv_rxq;
 }
 
-/****************************************************************
- * mv_pp3_priv_init						*
- *	Allocate and initialize net_device private structures	*
- ***************************************************************/
+/*---------------------------------------------------------------------------*/
 
-static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
+static struct pp3_txq *pp3_txq_priv_init(int emac, int cpu)
 {
-	struct pp3_dev_priv *dev_priv;
-	int cpu, num, first, frame, i, size, cfh_size;
+	int logic_q, phys_q, frame, size;
+	struct pp3_txq *priv_txq;
+
+	/*pp3_config_mngr_txq(index, cpu, &logic_q, &phys_q, &frame, &size);*/
+	priv_txq = kmalloc(sizeof(struct pp3_txq), GFP_KERNEL);
+
+	if (priv_txq) {
+		priv_txq->frame_num = frame;
+		priv_txq->logic_q = logic_q;
+		priv_txq->phys_q = phys_q;
+		priv_txq->size = size;
+		priv_txq->type = PP3_Q_TYPE_QM;
+	}
 
-	dev_priv = MV_PP3_PRIV(dev);
+	return priv_txq;
+}
 
-	memset(dev_priv, 0, sizeof(struct pp3_dev_priv));
+/*---------------------------------------------------------------------------*/
+/* Release net_device private structures				     */
+/*---------------------------------------------------------------------------*/
 
-	dev_priv->dev = dev;
-	dev_priv->index = index;
+static void mv_pp3_dev_priv_release(struct pp3_dev_priv *dev_priv)
+{
+	int cpu, i;
+	struct pp3_group *group;
+
+	for_each_possible_cpu(cpu) {
+
+		group = dev_priv->groups[cpu];
+
+		if (!group)
+			continue;
+
+		if (group->rxqs)
+			for (i = 0; i < group->rxqs_num; i++)
+				kfree(group->rxqs[i]);
+
+		if (group->txqs)
+			for (i = 0; i < group->txqs_num; i++)
+				kfree(group->txqs[i]);
+
+		kfree(group->rxqs);
+		kfree(group->txqs);
+		kfree(group->napi);
+		kfree(group);
+	}
+}
+
+/*---------------------------------------------------------------------------*/
+/* Allocate and initialize net_device private structures		     */
+/*---------------------------------------------------------------------------*/
+static int mv_pp3_dev_priv_init(struct pp3_dev_priv *dev_priv)
+{
+	int cpu, i, index;
+	/*int logic_q, phys_q, size, frame;*/
+
+	/* indicate emac number */
+	index = dev_priv->index;
 
 	/* create group per each cpu */
 	for_each_possible_cpu(cpu) {
 		struct pp3_group *group;
 
-		dev_priv->groups[cpu] = kmalloc(sizeof(struct pp3_dev_priv), GFP_KERNEL);
-		memset(dev_priv->groups[cpu], 0, sizeof(struct pp3_dev_priv));
+		dev_priv->groups[cpu] = kzalloc(sizeof(struct pp3_dev_priv), GFP_KERNEL);
 
 		group = dev_priv->groups[cpu];
 
-		/* init group rxqs */
-		/*pp3_config_mngr_rxq(emac_map, cpu, &first, &num, &frame, &size);*/
-		group->rxqs_num = num;
-		group->rxqs = kmalloc(sizeof(struct pp3_rxq *) * num, GFP_KERNEL);
-		memset(group->rxqs, 0, sizeof(struct pp3_rxq *) * num);
-
-		for (i = 0; i < num; i++) {
-			group->rxqs[i] = kmalloc(sizeof(struct pp3_rxq), GFP_KERNEL);
-			memset(group->rxqs[i], 0, sizeof(struct pp3_rxq) * num);
-			group->rxqs[i]->frame_num = frame;
-			group->rxqs[i]->logic_q = i;
-			group->rxqs[i]->phys_q = first + i;
-			group->rxqs[i]->type = PP3_Q_TYPE_QM;
-			mv_pp3_hmac_rxq_init(frame, first + i, size);
+		if (!group)
+			goto oom;
+
+		group->rxqs_num = dev_priv->rxqs_num / nr_cpu_ids;
+		group->rxqs = kzalloc(sizeof(struct pp3_rxq *) * group->rxqs_num, GFP_KERNEL);
+
+		if (!group->rxqs)
+			goto oom;
+
+
+		group->txqs_num = dev_priv->txqs_num / nr_cpu_ids;
+		group->txqs = kzalloc(sizeof(struct pp3_txq *) * group->txqs_num, GFP_KERNEL);
+
+		if (!group->txqs)
+			goto oom;
+
+		for (i = 0; i < group->rxqs_num; i++) {
+			group->rxqs[i] = pp3_rxq_priv_init(index, cpu);
+
+			if (!group->rxqs[i])
+				goto oom;
+
 			group->rxqs[i]->dev_priv = dev_priv;
-			group->rxqs[i]->pkt_coal = CONFIG_PP3_RX_COAL_PKTS;
-			group->rxqs[i]->time_coal = CONFIG_PP3_RX_COAL_USEC;
 		}
 
-		/* get emac bitmap */
-		/*pp3_config_mngr_emac_map(dev_priv->index, &dev_priv->emac_map);*/
-
-		/* init group txqs */
-		/*pp3_config_mngr_txq(dev_priv->index, cpu, &first, &num, &frame, &size, &cfh_size);*/
-		group->txqs_num = num;
-		group->txqs = kmalloc(sizeof(struct pp3_txq *) * num, GFP_KERNEL);
-		memset(group->txqs, 0, sizeof(struct pp3_txq *) * num);
-
-		for (i = 0; i < num; i++) {
-			group->txqs[i] = kmalloc(sizeof(struct pp3_txq) * num, GFP_KERNEL);
-			memset(group->txqs[i], 0, sizeof(struct pp3_txq) * num);
-			group->txqs[i]->frame_num = frame;
-			group->txqs[i]->logic_q = i;
-			group->txqs[i]->phys_q = first + i;
-			group->txqs[i]->type = PP3_Q_TYPE_QM;
-			mv_pp3_hmac_txq_init(frame, first + i, size, cfh_size);
+		for (i = 0; i < group->txqs_num; i++) {
+			group->txqs[i] = pp3_txq_priv_init(index, cpu);
+
+			if (!group->txqs[i])
+				goto oom;
+
 			group->txqs[i]->dev_priv = dev_priv;
 		}
 
@@ -430,15 +639,12 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 		group->cpu_ctrl = pp3_cpus[cpu];
 
 		/* init group napi */
-		group->napi = kmalloc(sizeof(struct napi_struct), GFP_KERNEL);
+		group->napi = kzalloc(sizeof(struct napi_struct), GFP_KERNEL);
 
-		if (!group->napi) {
-			/* TODO: call cleanup function */
-			return -ENOMEM;
-		}
+		if (!group->napi)
+			goto oom;
 
-		memset(group->napi, 0, sizeof(struct napi_struct));
-		netif_napi_add(dev, group->napi, mv_pp3_poll, CONFIG_MV_ETH_RX_POLL_WEIGHT);
+		netif_napi_add(dev_priv->dev, group->napi, mv_pp3_poll, CONFIG_MV_ETH_RX_POLL_WEIGHT);
 
 		pp3_groups[cpu][index] = group;
 		pp3_cpus[cpu]->dev_priv[index] = dev_priv;
@@ -446,60 +652,42 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 	} /* for */
 
 	return 0;
-}
-
-
-static int mv_pp3_config_get(struct platform_device *pdev, unsigned char *mac_addr, int *index)
-{
-	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+oom:
+	mv_pp3_dev_priv_release(dev_priv);
 
-	if (mac_addr)
-		memcpy(mac_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
+	pr_err("%s: out of memory\n", __func__);
 
-	if (index)
-		*index = pdev->id;
+	return -ENOMEM;
 
-	return plat_data->mtu;
 }
 
-static int mv_pp3_load_network_interfaces(struct platform_device *pdev)
+/*---------------------------------------------------------------------------*/
+
+static int mv_pp3_sw_probe(struct platform_device *pdev)
 {
-	int mtu, ret, index;
 	struct net_device *dev;
-	u8 mac[MV_MAC_ADDR_SIZE];
 
-	/* TODO: move function to configure block */
-	mtu = mv_pp3_config_get(pdev, mac, &index);
+	dev = mv_pp3_netdev_init(pdev);
 
-	pr_info("  o Loading network interface(s) for port #%d: mtu=%d\n", pdev->id, mtu);
-
-	dev = mv_pp3_netdev_init(mtu, mac, pdev);
+	pr_info("  o Loading network interface(s) for port #%d: mtu=%d\n", pdev->id, dev->mtu);
 
 	if (dev == NULL) {
 		pr_err("\to %s: can't create netdevice\n", __func__);
 		return -ENOMEM;
 	}
 
-	ret = mv_pp3_dev_priv_init(pdev->id, dev);
-
-	if (ret)
-		return ret;
-
 	pp3_ports[pdev->id] = MV_PP3_PRIV(dev);
 
-	return 0;
-}
+	mv_pp3_emac_unit_base(pdev->id, MV_PP3_EMAC_BASE(pdev->id));
 
-/* Support per port for platform driver */
-static int mv_pp3_probe(struct platform_device *pdev)
-{
-	if (mv_pp3_load_network_interfaces(pdev))
-		return -ENODEV;
+	/* TODO: set GOP BASE */
 
 	pr_info("Probing Marvell PPv3 Network Driver\n");
 	return 0;
 }
 
+/*---------------------------------------------------------------------------*/
+
 #ifdef CONFIG_CPU_IDLE
 int mv_pp3_suspend(struct platform_device *pdev, pm_message_t state)
 {
@@ -514,20 +702,26 @@ int mv_pp3_resume(struct platform_device *pdev)
 }
 #endif	/* CONFIG_CPU_IDLE */
 
-static int mv_pp3_remove(struct platform_device *pdev)
+/*---------------------------------------------------------------------------*/
+
+static int mv_pp3_sw_remove(struct platform_device *pdev)
 {
 	pr_info("Removing Marvell PPv3 Network Driver\n");
 	return 0;
 }
 
+/*---------------------------------------------------------------------------*/
+
 static void mv_pp3_shutdown(struct platform_device *pdev)
 {
 	pr_info("Shutting Down Marvell PPv3 Network Driver\n");
 }
 
+/*---------------------------------------------------------------------------*/
+
 static struct platform_driver mv_pp3_driver = {
-	.probe = mv_pp3_probe,
-	.remove = mv_pp3_remove,
+	.probe = mv_pp3_sw_probe,
+	/*.remove = mv_pp3_remove,*/
 	.shutdown = mv_pp3_shutdown,
 #ifdef CONFIG_CPU_IDLE
 	.suspend = mv_pp3_suspend,
@@ -538,70 +732,76 @@ static struct platform_driver mv_pp3_driver = {
 		.owner	= THIS_MODULE,
 	},
 };
-
-/*
- * Global units (hmac, qm/bm and etc.) init functions
-*/
-static int mv_pp3_shared_probe(struct platform_device *pdev)
+/*---------------------------------------------------------------------------*/
+/* Support per port for platform driver */
+static int mv_pp3_hw_netif_start(struct pp3_dev_priv *dev_priv)
 {
-	int size, ret, cpu, frame, queue;
-	unsigned int frames;
-	struct pp3_cpu *cpu_ctrl;
-	struct mv_pp3_plat_data *plat_data = (struct mv_pp3_plat_data *)pdev->dev.platform_data;
-
-	pp3_ports_num = plat_data->max_port;
-
-	/* TODO:
-		init sysfs
-		init window */
+	int i, cpu, pool;
+	struct pp3_group *group_ctrl;
 
-	/* init dev_priv array */
-	pp3_ports = kzalloc(pp3_ports_num * sizeof(struct pp3_dev_priv *), GFP_KERNEL);
-	if (!pp3_ports)
-		goto out;
+	/* init EMAC */
+	for (i = 0; i < MV_PP3_EMACS; i++)
+		/* TODO: suppot NSS mode */
+		mv_pp3_emac_init(dev_priv->index);
 
-	memset(pp3_ports, 0, size);
-
-	pp3_cpus = kzalloc(nr_cpu_ids * sizeof(struct pp3_cpu *), GFP_KERNEL);
-		if (!pp3_cpus)
-			goto out;
-
-	memset(pp3_cpus, 0, size);
+	/* int HMAC RXQs and TXQs */
+	for_each_possible_cpu(cpu) {
+		struct pp3_rxq *rxq_ctrl;
+		struct pp3_txq *txq_ctrl;
+		group_ctrl = pp3_groups[cpu][dev_priv->index];
+
+		/*pool = pp3_config_mngr_pool(dev_priv->index)*/
+		group_ctrl->long_pool = pp3_pool_gp_create(pool, MV_PP3_LONG_POOL_SIZE);
+		/*pool = pp3_config_mngr_pool(dev_priv->index)*/
+		group_ctrl->short_pool = pp3_pool_gp_create(pool, MV_PP3_SHORT_POOL_SIZE);
+		/*pool = pp3_config_mngr_pool(dev_priv->index)*/
+		group_ctrl->lro_pool = pp3_pool_gp_create(pool, MV_PP3_LRO_POOL_SIZE);
+
+		for (i = 0; i < group_ctrl->rxqs_num; i++) {
+			rxq_ctrl =  group_ctrl->rxqs[i];
+			mv_pp3_hmac_rxq_init(rxq_ctrl->frame_num, rxq_ctrl->phys_q, rxq_ctrl->size);
+		}
 
+		for (i = 0; i < group_ctrl->txqs_num; i++) {
+			txq_ctrl =  group_ctrl->txqs[i];
+			mv_pp3_hmac_txq_init(txq_ctrl->frame_num, txq_ctrl->phys_q, txq_ctrl->size, 0);
+		}
+	}
 
-	pp3_pools =  kzalloc(MV_PP3_BM_POOLS * sizeof(struct pp3_pool *), GFP_KERNEL);
-		if (!pp3_pools)
-			goto out;
+	return 0;
+}
 
-	/* if (mv_eth_bm_pools_init())
-		goto oom;*/
+/*---------------------------------------------------------------------------*/
 
-	/* TODO QM pools init	*/
-	/* QM init		*/
-	/* TODO HMAC unit int	*/
+static int mv_pp3_hw_shared_start(void)
+{
+	struct pp3_cpu *cpu_ctrl;
+	int cpu, pool, frame, queue, size;
+	unsigned int frames_bmp;
 
-	/*mv_pp3_messenger_init();*/
+	/* load fw */
 
+	/* init cpu's structures */
 	for_each_possible_cpu(cpu) {
 		cpu_ctrl = kzalloc(sizeof(struct pp3_cpu), GFP_KERNEL);
 
 		if (!cpu_ctrl)
-			goto out;
+			goto oom;
 
 		pp3_cpus[cpu] = cpu_ctrl;
 
 		/* TODO: call to config manager: get frames bitmap per cpu */
-		/*pp3_config_mngr_frm_num(cpu, &frames);*/
-		cpu_ctrl->frame_bmp = frames;
+		/*pp3_config_mngr_frm_num(cpu, &frames_bmp);*/
+		cpu_ctrl->frame_bmp = frames_bmp;
 
 		/* TODO: call to config manager: get free pool id */
-		/* pp3_config_mngr_bm_pool_get(&pool_id);*/
-		/*cpu_ctrl->tx_done_pool =  bm_pool_init(pool_id);*/
+		/* pool = pp3_config_mngr_bm_pool(pool_id);*/
+		cpu_ctrl->tx_done_pool =  pp3_pool_gp_create(pool, MV_PP3_LINUX_POOL_SIZE);
 
 		/* TODO: call to config manager: get frame and queue num in order to manage bm pool */
 		/* pp3_config_mngr_bm_queue(cpu, &frame, &qeueu)*/
 		mv_pp3_hmac_bm_queue_init(frame, queue, size);
-		cpu_ctrl->bm_msg_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
+		cpu_ctrl->bm_msg_tasklet = kzalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
 		tasklet_init(pp3_cpus[cpu]->bm_msg_tasklet, mv_pp3_bm_tasklet, (unsigned long)pp3_cpus[cpu]);
 
 		/* init timer */
@@ -609,38 +809,131 @@ static int mv_pp3_shared_probe(struct platform_device *pdev)
 		init_timer(&cpu_ctrl->tx_done_timer);
 		clear_bit(MV_CPU_F_TX_DONE_TIMER_BIT, &cpu_ctrl->flags);
 		cpu_ctrl->tx_done_timer.data = (unsigned long)pp3_cpus[cpu];
+	}
 
-		/* Channel create */
-		/*cpu_ctrl->chan_id = mv_pp3_chan_create(int size, 0, pp3_chan_callback);*/
+	/* TODO: QM init		*/
+	/* TODO: HMAC unit int	*/
+
+	pp3_pools_dram_init(BM_DRAM_POOL_CAPACITY);
+	pp3_pools_dram_init(BM_GPM_POOL_CAPACITY);
+	/*bm_enable();*/
+
+	/* TODO: start fw */
+	/* TODO: Channel create */
+	/* TODO: cpu_ctrl->chan_id = mv_pp3_chan_create(int size, 0, pp3_chan_callback);*/
+
+	return 0;
+oom:
+	for_each_possible_cpu(cpu) {
+		if (pp3_cpus[cpu]) {
+			pp3_pool_release(cpu_ctrl->tx_done_pool->pool);
+			kfree(cpu_ctrl->bm_msg_tasklet);
+			kfree(pp3_cpus[cpu]);
+		}
 	}
 
+	return -ENOMEM;
+}
+
+/*---------------------------------------------------------------------------*/
+/* alloc global structure memory					     */
+/*---------------------------------------------------------------------------*/
+static int mv_pp3_sw_shared_probe(struct platform_device *pdev)
+{
+	int i;
+	unsigned int silicon_base = mv_hw_silicon_base_addr_get();
+
+	struct mv_pp3_plat_data *plat_data = (struct mv_pp3_plat_data *)pdev->dev.platform_data;
+
+	pp3_ports_num = plat_data->max_port;
+
+	pp3_sysfs_init();
 
-	/* TODO: set links interrupt */
+	pp3_ports = kzalloc(pp3_ports_num * sizeof(struct pp3_dev_priv *), GFP_KERNEL);
+	if (!pp3_ports)
+		goto oom;
+
+	pp3_cpus = kzalloc(nr_cpu_ids * sizeof(struct pp3_cpu *), GFP_KERNEL);
+	if (!pp3_cpus)
+		goto oom;
+
+	pp3_pools =  kzalloc(MV_PP3_BM_POOLS * sizeof(struct pp3_pool *), GFP_KERNEL);
+	if (!pp3_pools)
+		goto oom;
 
-	pp3_initialized = 1;
+	pp3_frames = kzalloc(MV_PP3_FRAMES * sizeof(struct pp3_frame *), GFP_KERNEL);
 
+	mv_pp3_hmac_gl_unit_base(silicon_base + MV_PP3_HMAC_GL_UNIT_OFFSET);
+	mv_pp3_hmac_frame_unit_base(silicon_base + MV_PP3_HMAC_FR_UNIT_OFFSET, MV_PP3_HMAC_FR_INST_OFFSET);
+
+	for (i = 0; i < MV_PP3_FRAMES; i++) {
+		pp3_frames[i] = kzalloc(sizeof(struct pp3_frame), GFP_KERNEL);
+		pp3_frames[i]->frame = i;
+		pp3_frames[i]->time_coal[0] = MV_PP3_FRM_TIME_COAL_0;
+	}
+
+	/*mv_pp3_bm_unit_base(PP3_BM_BASE);*/
+	/*mv_pp3_qm_unit_base(PP3_QM_BASE);*/
+	/*mv_pp3_messenger_init();*/
 
 	return 0;
 
-out:
-	return ret;
+oom:
+	kfree(pp3_ports);
+	kfree(pp3_cpus);
+	kfree(pp3_pools);
+	pr_err("%s: out of memory\n", __func__);
+	return -ENOMEM;
 }
+/*---------------------------------------------------------------------------*/
+static int mv_pp3_netif_init(struct pp3_dev_priv *dev_priv)
+{
+	if (!pp3_hw_initialized) {
+		mv_pp3_hw_shared_start();
+		pp3_hw_initialized = 1;
+	}
+
+	if (!(dev_priv->flags & MV_ETH_F_INIT)) {
+		mv_pp3_dev_priv_init(dev_priv);
+		mv_pp3_hw_netif_start(dev_priv);
+		dev_priv->flags |= MV_ETH_F_INIT;
+	}
+	/* start seq */
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int mv_pp3_dev_open(struct net_device *dev)
+{
+	struct pp3_dev_priv *dev_priv = MV_PP3_PRIV(dev);
 
-static int mv_pp3_shared_remove(struct platform_device *pdev)
+	mv_pp3_netif_init(dev_priv);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int mv_pp3_sw_shared_remove(struct platform_device *pdev)
 {
 	/* free all shared resources */
 	return 0;
 }
 
+/*---------------------------------------------------------------------------*/
+
 static struct platform_driver mv_pp3_shared_driver = {
-	.probe		= mv_pp3_shared_probe,
-	.remove		= mv_pp3_shared_remove,
+	.probe		= mv_pp3_sw_shared_probe,
+	.remove		= mv_pp3_sw_shared_remove,
 	.driver = {
 		.name	= MV_PP3_SHARED_NAME,
 		.owner	= THIS_MODULE,
 	},
 };
 
+/*---------------------------------------------------------------------------*/
+
 static int __init mv_pp3_init_module(void)
 {
 	int rc;
@@ -656,6 +949,7 @@ static int __init mv_pp3_init_module(void)
 }
 module_init(mv_pp3_init_module);
 
+/*---------------------------------------------------------------------------*/
 static void __exit mv_pp3_cleanup_module(void)
 {
 	platform_driver_unregister(&mv_pp3_driver);
@@ -663,6 +957,8 @@ static void __exit mv_pp3_cleanup_module(void)
 }
 module_exit(mv_pp3_cleanup_module);
 
+/*---------------------------------------------------------------------------*/
+
 
 MODULE_DESCRIPTION("Marvell PPv3 Network Driver - www.marvell.com");
 MODULE_AUTHOR("Dmitri Epshtein <dima@marvell.com>");
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
index 7d4decc..b65cee2 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
@@ -34,8 +34,27 @@ disclaimer.
 #include <linux/mv_pp3.h>
 #include <net/ip.h>
 
-/* TODO remove next line */
+/* TODO remove next lines */
 #define MV_PP3_BM_POOLS 20
+#define MV_PP3_EMACS	5
+#define MV_PP3_FRAMES	4
+
+#define MV_PP3_EMAC_BASE(_emac_) (0x000CA000 + (0x1000 * (_emac_)))
+#define MV_PP3_POOL_INIT_TIMEOUT_MSEC	1000
+#define BM_DRAM_POOL_CAPACITY		1024
+#define BM_GPM_POOL_CAPACITY		1024
+#define MV_PP3_LINUX_POOL_SIZE		1024
+#define MV_PP3_LONG_POOL_SIZE		1024
+#define MV_PP3_SHORT_POOL_SIZE		1024
+#define MV_PP3_LRO_POOL_SIZE		1024
+#define MV_PP3_GPM_POOL_0		0
+#define MV_PP3_GPM_POOL_1		1
+#define MV_PP3_DRAM_POOL_0		2
+#define MV_PP3_DRAM_POOL_1		3
+#define MV_PP3_FRM_TIME_COAL_NUM	2
+#define MV_PP3_FRM_TIME_COAL_0		64
+#define MV_PP3_RXQ_TIME_COAL_DEF_PROF	0
+#define MV_PP3_TXQ_TIME_COAL_DEF_PROF	0
 /******************************************************
  * driver statistics control --                       *
  ******************************************************/
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
index ab68cc1..5396cc4 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
@@ -47,7 +47,10 @@ struct pp3_dev_priv {
 	struct pp3_group	*groups[CONFIG_NR_CPUS];
 	struct net_device	*dev;
 	unsigned long		flags;
-	unsigned char		emac_map;
+	int			rss_id;
+	int			rxqs_num;
+	int			txqs_num;
+
 };
 
 /* Masks used for pp3_dev_priv flags */
@@ -59,7 +62,8 @@ struct pp3_dev_priv {
 #define MV_ETH_F_DBG_DUMP_BIT		6
 #define MV_ETH_F_DBG_ISR_BIT		7
 #define MV_ETH_F_DBG_POLL_BIT		8
-#define MV_ETH_F_DBG_BUFF_HDR_BIT	9
+#define MV_ETH_F_INIT_BIT		9
+
 
 
 #define MV_ETH_F_STARTED                (1 << MV_ETH_F_STARTED_BIT)
@@ -70,7 +74,7 @@ struct pp3_dev_priv {
 #define MV_ETH_F_DBG_DUMP		(1 << MV_ETH_F_DBG_DUMP_BIT)
 #define MV_ETH_F_DBG_ISR		(1 << MV_ETH_F_DBG_ISR_BIT)
 #define MV_ETH_F_DBG_POLL		(1 << MV_ETH_F_DBG_POLL_BIT)
-#define MV_ETH_F_DBG_BUFF_HDR		(1 << MV_ETH_F_DBG_BUFF_HDR_BIT)
+#define MV_ETH_F_INIT			(1 << MV_ETH_F_INIT_BIT)
 
 
 struct pp3_group_stats {
@@ -109,11 +113,6 @@ struct pp3_cpu_stats {
 struct pp3_cpu {
 	int	cpu;
 	int	frame_bmp;
-/*
-	not sure that pp3_frame is necessary
-	meanwhile not defined
-	struct	pp3_frame	**frame_ctrl;
-*/
 	struct	pp3_dev_priv	*dev_priv[MAX_ETH_DEVICES];
 	struct	pp3_pool	*tx_done_pool;
 	struct	pp3_queue	*bm_msg_queue;
@@ -141,30 +140,29 @@ struct pp3_rxq {
 	int	frame_num;
 	int	logic_q;
 	int	phys_q;
+	int	size;
 	enum	pp3_q_type		type;
-	struct	mv_pp3_queue_ctrl	*hmac_queue;
 	struct	pp3_dev_priv		*dev_priv;
 	int	pkt_coal;
-	int	time_coal;
+	int	time_coal_profile;
 	struct	pp3_xq_stats		stats;
-	/*
-	not sure yet about this
-	struct	pp3_frame	*frame_ctrl;
-	*/
 };
 
 struct pp3_txq {
 	int	frame_num;
 	int	logic_q;
 	int	phys_q;
+	int	size;
 	enum	pp3_q_type		type;
-	struct	mv_pp3_queue_ctrl	*hmac_queue;
 	struct	pp3_dev_priv		*dev_priv;
 	struct	pp3_xq_stats		stats;
-	/*
-	not sure yet about this
-	struct	pp3_frame	*frame_ctrl;
-	*/
+};
+
+
+enum  pp3_pool_type {
+	PP3_POOL_TYPE_GP = 0,
+	PP3_POOL_TYPE_DRAM = 1,
+	PP3_POOL_TYPE_GPM = 2
 };
 
 /* pools 8-35, buffers and pool memory in dram */
@@ -176,19 +174,27 @@ struct	pp3_pool {
 	void *virt_base;
 	unsigned long phys_base;
 	unsigned char flags;
+	enum pp3_pool_type type;
 };
 
+/* flags in use only if type is GP */
 #define POOL_F_FREE	0x01
-#define POOL_F_HWF	0x02
-#define POOL_F_LONG	0x04
-#define POOL_F_SHORT	0x08
-#define POOL_F_LRO	0x10
+#define POOL_F_LONG	0x02
+#define POOL_F_SHORT	0x04
+#define POOL_F_LRO	0x18
 
 struct pp3_queue {
 	int frame;
 	struct pp3_rxq rxq;
 	struct pp3_txq txq;
 };
-/* TODO define bm_pool */
+
+struct pp3_frame {
+	int frame;
+	int time_coal[MV_PP3_FRM_TIME_COAL_NUM];
+	/*struct pp3_rxq **rxq;*/
+	/*struct pp3_txq **txq;*/
+};
 
 #endif /* __mv_netdev_structs_h__ */
+
-- 
1.7.5.4

