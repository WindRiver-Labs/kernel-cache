From 05b3530f36f6d027e30bb81cf09835a7b3b36c78 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 23 Jun 2014 00:13:41 -0400
Subject: [PATCH 1744/1825] fix: neta: Set per port TX csum offload limit

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 91112abeea00d8ac8dbef78494e313a90c0e18f8

	A385 has different TX FIFO size for port 0 and ports 1,2
	Add new field "tx_csum_limit" to NETA plat_data structure
	Add new parameter tx-csum-limit to armada-38x.dtsi

Change-Id: I75bdc953667157583d0ea82d5e8fb2f3e0413499
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8688
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada370/core.c                     |    1 +
 .../armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h      |    1 +
 arch/arm/mach-armada38x/core.c                     |    3 +
 arch/arm/mach-armadaxp/core.c                      |    1 +
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |   86 +++++++++----------
 include/linux/mv_neta.h                            |   12 ++-
 6 files changed, 56 insertions(+), 48 deletions(-)

diff --git a/arch/arm/mach-armada370/core.c b/arch/arm/mach-armada370/core.c
index 4b3c89b..595355a 100644
--- a/arch/arm/mach-armada370/core.c
+++ b/arch/arm/mach-armada370/core.c
@@ -625,6 +625,7 @@ static void mv_neta_giga_pdev_register(struct platform_device *pdev)
 	/* Per port parameters */
 	plat_data->cpu_mask  = (1 << nr_cpu_ids) - 1;
 	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE;
 	plat_data->is_sgmii = mvBoardIsPortInSgmii(port);
 	plat_data->is_rgmii = mvBoardIsPortInRgmii(port);
 	plat_data->duplex = DUPLEX_FULL;
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
index d368664..064a775 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -223,6 +223,7 @@ extern "C" {
 #define MV_ETH_MAX_RXQ				8
 #define MV_ETH_MAX_TXQ				8
 #define MV_ETH_TX_CSUM_MAX_SIZE			9800
+#define MV_ETH_TX_CSUM_MAX_SIZE_SMALL		2048
 #define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
 
 /* New GMAC module is used */
diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 4bc66c0..1583c6f 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -670,6 +670,7 @@ static struct resource mv_neta_ge0_resources[] = {
 static struct mv_neta_pdata mv_neta_ge0_pdata = {
 	.mtu = 1500,
 	.phy_addr = 0,
+	.tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE,
 };
 static struct platform_device mv_neta_ge0_plat = {
 	.name           = MV_NETA_PORT_NAME,
@@ -690,6 +691,7 @@ static struct resource mv_neta_ge1_resources[] = {
 static struct mv_neta_pdata mv_neta_ge1_pdata = {
 	.mtu = 1500,
 	.phy_addr = -1,
+	.tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE_SMALL,
 };
 static struct platform_device mv_neta_ge1_plat = {
 	.name           = MV_NETA_PORT_NAME,
@@ -710,6 +712,7 @@ static struct resource mv_neta_ge2_resources[] = {
 static struct mv_neta_pdata mv_neta_ge2_pdata = {
 	.mtu = 1500,
 	.phy_addr = -1,
+	.tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE_SMALL,
 };
 static struct platform_device mv_neta_ge2_plat = {
 	.name           = MV_NETA_PORT_NAME,
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 0362c8f..a15d5cc 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -750,6 +750,7 @@ static void mv_neta_giga_pdev_register(struct platform_device *pdev)
 	/* Per port parameters */
 	plat_data->cpu_mask  = (1 << nr_cpu_ids) - 1;
 	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE;
 	plat_data->is_sgmii = mvBoardIsPortInSgmii(port);
 	plat_data->is_rgmii = mvBoardIsPortInRgmii(port);
 	plat_data->duplex = DUPLEX_FULL;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index 6e5f1a2..178238e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -161,10 +161,8 @@ static int mv_eth_rxq_fill(struct eth_port *pp, int rxq, int num);
 static void mv_eth_config_show(void);
 static int  mv_eth_priv_init(struct eth_port *pp, int port);
 static void mv_eth_priv_cleanup(struct eth_port *pp);
-static int  mv_eth_config_get(struct platform_device *pdev, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
-struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
-					struct platform_device *pdev);
+struct net_device *mv_eth_netdev_init(struct platform_device *pdev);
 static void mv_eth_netdev_init_features(struct net_device *dev);
 
 static MV_STATUS mv_eth_pool_create(int pool, int capacity);
@@ -1055,11 +1053,13 @@ static netdev_features_t mv_eth_netdev_fix_features(struct net_device *dev, netd
 #endif
 {
 #ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
-	if (dev->mtu > MV_ETH_TX_CSUM_MAX_SIZE) {
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	if (dev->mtu > pp->plat_data->tx_csum_limit) {
 		if (features & (NETIF_F_IP_CSUM | NETIF_F_TSO)) {
 			features &= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);
 			printk(KERN_ERR "%s: NETIF_F_IP_CSUM and NETIF_F_TSO not supported for mtu larger %d bytes\n",
-					dev->name, MV_ETH_TX_CSUM_MAX_SIZE);
+					dev->name, pp->plat_data->tx_csum_limit);
 		}
 	}
 #endif /* CONFIG_MV_ETH_TX_CSUM_OFFLOAD */
@@ -3273,19 +3273,18 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 {
 	u32 port;
 	struct eth_port *pp;
-	int mtu, err = 0;
+	int err = 0;
 	struct net_device *dev;
 	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
-	u8 mac[MV_MAC_ADDR_SIZE];
 
 	port = pdev->id;
+	if (plat_data->tx_csum_limit == 0)
+		plat_data->tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE;
 
-	printk(KERN_ERR "  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
-			port, plat_data->cpu_mask, plat_data->mtu);
+	pr_info("  o Loading network interface(s) for port #%d: cpu_mask=0x%x, tx_csum_limit=%d\n",
+			port, plat_data->cpu_mask, plat_data->tx_csum_limit);
 
-	mac_src[port] = "platform";
-	mtu = mv_eth_config_get(pdev, mac);
-	dev = mv_eth_netdev_init(mtu, mac, pdev);
+	dev = mv_eth_netdev_init(pdev);
 
 	if (!dev) {
 		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
@@ -3295,8 +3294,6 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 
 	pp = (struct eth_port *)netdev_priv(dev);
 
-	pp->plat_data = plat_data;
-	pp->cpu_mask = plat_data->cpu_mask;
 	mv_eth_ports[port] = pp;
 
 	/* set port's speed, duplex, fc */
@@ -3340,7 +3337,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 #endif /* CONFIG_MV_ETH_PMT */
 
 	pr_info("\t%s p=%d: mtu=%d, mac=" MV_MACQUAD_FMT " (%s)\n",
-		MV_PON_PORT(port) ? "pon" : "giga", port, mtu, MV_MACQUAD(mac), mac_src[port]);
+		MV_PON_PORT(port) ? "pon" : "giga", port, dev->mtu, MV_MACQUAD(dev->dev_addr), mac_src[port]);
 
 	handle_group_affinity(port);
 
@@ -4020,7 +4017,7 @@ static struct mv_neta_pdata *mv_plat_data_get(struct platform_device *pdev)
 		return NULL;
 	}
 
-	plat_data = kmalloc(sizeof(struct mv_neta_pdata), GFP_KERNEL);
+	plat_data = kzalloc(sizeof(struct mv_neta_pdata), GFP_KERNEL);
 	if (plat_data == NULL) {
 		pr_err("could not allocate memory for plat_data\n");
 		return NULL;
@@ -4078,6 +4075,9 @@ static struct mv_neta_pdata *mv_plat_data_get(struct platform_device *pdev)
 		pr_err("could not get MTU\n");
 		return NULL;
 	}
+	/* Get TX checksum offload limit */
+	if (of_property_read_u32(np, "tx_csum_limit", &plat_data->tx_csum_limit))
+		plat_data->tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE;
 
 	/* Get port PHY mode */
 	phy_mode = of_get_phy_mode(np);
@@ -4131,6 +4131,14 @@ static int mv_eth_probe(struct platform_device *pdev)
 	pdev->dev.platform_data = plat_data;
 #else
 	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		pr_err("could not get IRQ number\n");
+		return -ENODEV;
+	}
+	plat_data->irq = res->start;
 #endif /* CONFIG_OF */
 
 	if (plat_data == NULL)
@@ -4161,16 +4169,6 @@ static int mv_eth_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int mv_eth_config_get(struct platform_device *pdev, MV_U8 *mac_addr)
-{
-	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
-
-	if ((mac_addr) && (is_valid_ether_addr(plat_data->mac_addr)))
-		memcpy(mac_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
-
-	return plat_data->mtu;
-}
-
 /***********************************************************
  * mv_eth_tx_timeout --                                    *
  *   nothing to be done (?)                                *
@@ -4190,17 +4188,14 @@ static void mv_eth_tx_timeout(struct net_device *dev)
  * mv_eth_netdev_init -- Allocate and initialize net_device    *
  *                   structure                                 *
  ***************************************************************/
-struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
-				struct platform_device *pdev)
+struct net_device *mv_eth_netdev_init(struct platform_device *pdev)
 {
 	int cpu, i;
 	struct net_device *dev;
 	struct eth_port *pp;
 	struct cpu_ctrl	*cpuCtrl;
 	int port = pdev->id;
-#ifdef CONFIG_OF
 	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
-#endif
 
 	dev = alloc_etherdev_mq(sizeof(struct eth_port), CONFIG_MV_ETH_TXQ);
 	if (!dev)
@@ -4212,29 +4207,30 @@ struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
 
 	memset(pp, 0, sizeof(struct eth_port));
 	pp->dev = dev;
+	pp->plat_data = plat_data;
+	pp->cpu_mask = plat_data->cpu_mask;
 
-	dev->mtu = mtu;
-#ifdef CONFIG_OF
-	dev->irq = plat_data->irq;
+	dev->mtu = plat_data->mtu;
 
 	if (!is_valid_ether_addr(plat_data->mac_addr)) {
-		mv_eth_get_mac_addr(port, mac);
-		if (is_valid_ether_addr(mac)) {
-			memcpy(plat_data->mac_addr, mac, MV_MAC_ADDR_SIZE);
+		mv_eth_get_mac_addr(port, plat_data->mac_addr);
+		if (is_valid_ether_addr(plat_data->mac_addr)) {
 			memcpy(dev->dev_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
 			mac_src[port] = "hw config";
 		} else {
+#ifdef CONFIG_OF
 			eth_hw_addr_random(dev);
 			mac_src[port] = "random";
+#else
+			memset(dev->dev_addr, 0, MV_MAC_ADDR_SIZE);
+			mac_src[port] = "invalid";
+#endif /* CONFIG_OF */
 		}
 	} else {
 		memcpy(dev->dev_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
 		mac_src[port] = "platform";
 	}
-#else
-	dev->irq = NET_TH_RXTX_IRQ_NUM(port);
-	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
-#endif /* CONFIG_OF */
+	dev->irq = plat_data->irq;
 
 	dev->tx_queue_len = CONFIG_MV_ETH_TXQ_DESC;
 	dev->watchdog_timeo = 5 * HZ;
@@ -6657,11 +6653,11 @@ static void mv_eth_shutdown(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_OF
-static const struct of_device_id mvneta_match[] = {
+static const struct of_device_id mv_neta_match[] = {
 	{ .compatible = "marvell,neta" },
 	{ }
 };
-MODULE_DEVICE_TABLE(of, mvneta_match);
+MODULE_DEVICE_TABLE(of, mv_neta_match);
 
 static int mv_eth_port_num_get(struct platform_device *pdev)
 {
@@ -6669,8 +6665,8 @@ static int mv_eth_port_num_get(struct platform_device *pdev)
 	int tbl_id;
 	struct device_node *np = pdev->dev.of_node;
 
-	for (tbl_id = 0; tbl_id < (sizeof(mvneta_match) / sizeof(struct of_device_id)); tbl_id++) {
-		for_each_compatible_node(np, NULL, mvneta_match[tbl_id].compatible)
+	for (tbl_id = 0; tbl_id < (sizeof(mv_neta_match) / sizeof(struct of_device_id)); tbl_id++) {
+		for_each_compatible_node(np, NULL, mv_neta_match[tbl_id].compatible)
 			port_num++;
 	}
 
@@ -6689,7 +6685,7 @@ static struct platform_driver mv_eth_driver = {
 	.driver = {
 		.name = MV_NETA_PORT_NAME,
 #ifdef CONFIG_OF
-		.of_match_table = mvneta_match,
+		.of_match_table = mv_neta_match,
 #endif /* CONFIG_OF */
 	},
 };
diff --git a/include/linux/mv_neta.h b/include/linux/mv_neta.h
index ddb81b8..a8884ab 100644
--- a/include/linux/mv_neta.h
+++ b/include/linux/mv_neta.h
@@ -91,6 +91,9 @@ struct mv_neta_pdata {
 	/* Whether a PHY is present, and if yes, at which address. */
 	int      phy_addr;
 
+	/* Maximum packet size for L4 checksum generation */
+	int      tx_csum_limit;
+
 	/* Use this MAC address if it is valid */
 	u8       mac_addr[6];
 
@@ -103,9 +106,12 @@ struct mv_neta_pdata {
 	int      duplex;
 
 	/* Port configuration: indicates if this port is LB, and if PCS block is active */
-	int	     lb_enable;
-	int	     is_sgmii;
-	int	     is_rgmii;
+	int      lb_enable;
+	int      is_sgmii;
+	int      is_rgmii;
+
+	/* port interrupt line number */
+	int      irq;
 
 	/*
 	* How many RX/TX queues to use.
-- 
1.7.5.4

