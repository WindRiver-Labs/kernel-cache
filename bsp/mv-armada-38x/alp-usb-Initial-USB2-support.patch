From 20aadd223fde4db4f1cd9de5555a613e5913f9e1 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Tue, 18 Jun 2013 15:40:36 +0300
Subject: [PATCH 0914/1825] alp: usb: Initial USB2 support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 0d2e2a61b649f5c1b45aa85b7c40b45700178e89

	This patch adds initial USB2 support for avanta lp.
	It includes a new PHY initialization routine and a
	code that enables using either legacy USB2 or new
	USB3 IP for supporting devices.

Change-Id: I94549e7b9eedbec7139098c20a4f4c09850acb33
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2904
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Kconfig              |    9 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c |   33 ++++--
 arch/arm/mach-avantalp/usb.c                |   36 +++++-
 arch/arm/plat-armada/mv_hal/usb/mvUsb.c     |  175 +++++++++++++++++++--------
 arch/arm/plat-armada/mv_hal/usb/mvUsb.h     |    1 +
 arch/arm/plat-armada/mv_hal/usb/mvUsbRegs.h |   11 +-
 6 files changed, 199 insertions(+), 66 deletions(-)

diff --git a/arch/arm/mach-avantalp/Kconfig b/arch/arm/mach-avantalp/Kconfig
index 23e04d5..25bcc03 100644
--- a/arch/arm/mach-avantalp/Kconfig
+++ b/arch/arm/mach-avantalp/Kconfig
@@ -88,6 +88,15 @@ config AVANTA_LP_Z1_USB3_LFPS_FREQ_WA
 	  in the integration of USB3. This WA is needed only
 	  for Z1 devices
 
+config AVANTA_LP_USE_LEGACY_USB2
+	bool "Use legacy USB2 IP instead of USB3 IP"
+	default n
+	help
+	 Some Avanta LP flavours contain 2 USB host controllers: A legacy USB2
+	 only controller and a new USB3 controller which also supports USB2.
+	 This flag enables to choose which of the host controllers to use.
+	 It mainly affects the USB2 PHY to host connectivity
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
index 59a8de7..a16e806 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
@@ -87,15 +87,30 @@ MV_STATUS mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
 	MV_USB_HAL_DATA halData;
 	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
 	MV_STATUS status;
-
-	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
-	if (status == MV_OK)
-		status = mvUsbWinInit(dev, addrWinMap);
-
-	if (status == MV_OK) {
-		halData.ctrlModel = mvCtrlModelGet();
-		halData.ctrlRev = mvCtrlRevGet();
-		status = mvUsbHalInit(dev, isHost, &halData);
+	MV_BOOL usb3Init = 0;
+
+#ifndef CONFIG_AVANTA_LP_USE_LEGACY_USB2
+	if (mvCtrlModelGet() == MV_6660_DEV_ID)
+		usb3Init = 1;
+#endif
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+	halData.ctrlRev = mvCtrlRevGet();
+
+	/*
+	 * For USB3 initialize only the UTMI PHY
+	 * For USB2 initialize the PHY and the controller
+	 */
+	if (usb3Init) {
+		status = mvUsbUtmiPhyInit(dev, &halData);
+	} else {
+		status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+		if (status == MV_OK)
+			status = mvUsbWinInit(dev, addrWinMap);
+
+		if (status == MV_OK)
+			status = mvUsbHalInit(dev, isHost, &halData);
 	}
 
 	return status;
diff --git a/arch/arm/mach-avantalp/usb.c b/arch/arm/mach-avantalp/usb.c
index 2521cd3..b3e9899 100644
--- a/arch/arm/mach-avantalp/usb.c
+++ b/arch/arm/mach-avantalp/usb.c
@@ -75,7 +75,7 @@ static int __init mv_usb2_init(void)
 	int status, dev, num, isHost;
 	char*                   name_ptr;
 	struct platform_device* mv_usb_dev_ptr;
-	int irq_num[1] = { IRQ_GLOBAL_USB2_IP };
+	int irq_num[MAX_USB_PORTS] = { IRQ_GLOBAL_USB2_IP };
 
 	num = 1;
 	/*num = mvCtrlUsbMaxGet();
@@ -103,7 +103,10 @@ static int __init mv_usb2_init(void)
 
 		printk("registered dev#%d asa %s\n", dev, name_ptr);
 		status = mvSysUsbInit(dev, isHost);
-
+		if (status != MV_OK) {
+			pr_info("Error: mvSysUsbInit failed with code %d\n", status);
+			continue;
+		}
 		mv_usb_dev_ptr = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
 		if (mv_usb_dev_ptr == NULL) {
 			printk("Can't allocate platform_device structure - %d bytes\n",
@@ -281,7 +284,32 @@ err0:
 void __init mv_usb_init(struct mbus_dram_target_info *dram)
 {
 	/* Select the new USB3 IP */
-	writel(1, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
 
-	mv_usb3_init(dram);
+	int reg;
+	int use_usb3_ip = 0;
+	MV_STATUS status;
+
+	/* Enable USB3 only for 6660 devices */
+#ifndef CONFIG_AVANTA_LP_USE_LEGACY_USB2
+	if (mvCtrlModelGet() == MV_6660_DEV_ID) {
+		use_usb3_ip = 1;
+		/* Initialize the USB2 PHY needed for USB3 functionality */
+		status = mvSysUsbInit(0, 1);
+		if (status != MV_OK) {
+			pr_info("Error: mvSysUsbInit failed with code %d\n", status);
+			return;
+		}
+	}
+#endif
+
+	/* Select USB3 IP (which supports USB2) or legacy USB2 IP*/
+	reg = readl(INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+	reg = (reg & (~0x1)) | use_usb3_ip;
+	writel(reg, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+
+	if (use_usb3_ip)
+		mv_usb3_init(dram);
+	else
+		mv_usb2_init();
 }
+
diff --git a/arch/arm/plat-armada/mv_hal/usb/mvUsb.c b/arch/arm/plat-armada/mv_hal/usb/mvUsb.c
index 521b1e4..4e92b71 100755
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsb.c
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsb.c
@@ -183,27 +183,79 @@ int mvUsbBackVoltageUpdate(int dev, MV_U8 gppNo)
 }
 #endif /* MV_USB_VOLTAGE_FIX */
 
+
+/* USB Phy init specific for 40nm LP (88F6660) */
+MV_STATUS mvUsbPhy40nmLpInit(int dev)
+{
+	MV_U32 regVal;
+
+	/* Set the PLL clocks to 450 MHz. Our ref clock is 25 Mhz so to
+	 * achieve 480 MHz we set divider = 5 multiplier = 96 */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 1));
+	regVal = (regVal & (~0x1FF)) | (96);
+	regVal = (regVal & (~0x1E00)) | (5 << 9);
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 1), regVal);
+
+	/* Turn on the PLL and wait 200 usec */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 2));
+	regVal |= BIT13;
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 2), regVal);
+	mvOsUDelay(200);
+
+	/* Enable the analog part of the PHY */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 13));
+	regVal |= BIT14;
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 13), regVal);
+	mvOsUDelay(200);
+
+	/* Turn on the VCO calibration */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 2));
+	regVal |= BIT2;
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 2), regVal);
+	mvOsUDelay(1000);
+
+	/* Perform Impedance calibration for 40 usec */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 4));
+	regVal |= BIT13;
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 4), regVal);
+	mvOsUDelay(40);
+
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 4));
+	regVal &= ~BIT13;
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 4), regVal);
+	mvOsUDelay(400);
+
+	/* Check if the PHY is ready */
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 2));
+	if ((regVal & BIT15) == 0) {
+		mvOsPrintf("Error: USB2 Phy NOT ready\n");
+		return MV_NOT_READY;
+	}
+
+	return MV_OK;
+}
+
 /* USB Phy init (change from defaults) specific for 40nm (78X30 78X60) */
 static int mvUsbPhy40nmInit(int dev)
 {
 	MV_U32 regVal;
 
-	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 3));
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 19));
 	regVal |= BIT15;
-	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 3), regVal);
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 19), regVal);
 	/*-------------------------------------------------*/
 
 	/******* Assert REG_RCAL_START in Channel REG 1 *******/
-	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 1));
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 17));
 	regVal |= BIT12;
-	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 1), regVal);
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 17), regVal);
 
 	/* Wait 40 usec */
 	mvOsUDelay(40);
 
-	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 1));
+	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 17));
 	regVal &= ~BIT12;
-	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 1), regVal);
+	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 17), regVal);
 	/*-------------------------------------------------*/
 
 /* BTS #231 - for KW40 only */
@@ -707,6 +759,73 @@ MV_STATUS mvUsbPllInit()
 	return 0;
 }
 /*******************************************************************************
+* mvUsbUtmiPhyInit - Initialize USB UTMI PHY
+*
+* DESCRIPTION:
+*       This function initialize USB UTMI PHY.
+*
+* INPUT:
+*       dev - The PHY number to initialize
+*       halData - Pointer to halData structure
+*
+* OUTPUT:
+*       status - status of the init operation
+*
+* RETURN:
+*       MV_ERROR if setting fail.
+*******************************************************************************/
+MV_STATUS mvUsbUtmiPhyInit(int dev, MV_USB_HAL_DATA *usbHalData)
+{
+	MV_STATUS status = MV_OK;
+
+	if ((usbHalData->ctrlModel == MV_78100_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_78200_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_76100_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6281_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6282_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6280_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6192_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6190_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6180_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6321_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6322_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6323_DEV_ID)) {
+
+		mvUsbPhy65nmNewInit(dev);
+
+	} else if ((usbHalData->ctrlModel == MV_78XX0_DEV_ID)) {
+
+		mvUsbPhy65nmInit(dev);
+
+	} else if (usbHalData->ctrlModel == MV_6183_DEV_ID) {
+
+		mvUsbPhy90nmInit(dev);
+
+	} else if ((usbHalData->ctrlModel == MV_6510_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6530_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6550_DEV_ID) ||
+		(usbHalData->ctrlModel == MV_6560_DEV_ID)) {
+
+		mvUsbPhy65nmNewInit(dev);
+
+	} else if ((usbHalData->ctrlFamily == MV_67XX) ||
+		(usbHalData->ctrlFamily == MV_78XX0)) {
+
+		if (mvUsbPhy40nmInit(dev))
+			status = MV_NOT_READY;
+
+	} else if ((usbHalData->ctrlFamily == MV_88F66X0) ||
+		   (usbHalData->ctrlFamily == MV_88F67X0)) {
+
+		status = mvUsbPhy40nmLpInit(dev);
+
+	} else
+		mvUsbPhyInit(dev);
+
+
+	return status;
+}
+/*******************************************************************************
 * mvUsbHalInit - Initialize USB engine
 *
 * DESCRIPTION:
@@ -790,49 +909,9 @@ MV_STATUS mvUsbHalInit(int dev, MV_BOOL isHost, MV_USB_HAL_DATA *halData)
 		MV_REG_WRITE(MV_USB_BRIDGE_IPG_REG(dev), regVal);
 	}
 #ifndef MV_USB_PHY_DONT_OVERRIDE
-
-    /********* Update USB PHY configuration **********/
-	if ((usbHalData.ctrlModel == MV_78100_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_78200_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_76100_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6281_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6282_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6280_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6192_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6190_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6180_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6321_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6322_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6323_DEV_ID)) {
-
-		mvUsbPhy65nmNewInit(dev);
-
-	} else if ((usbHalData.ctrlModel == MV_78XX0_DEV_ID)) {
-
-		mvUsbPhy65nmInit(dev);
-
-	} else if (usbHalData.ctrlModel == MV_6183_DEV_ID) {
-
-		mvUsbPhy90nmInit(dev);
-
-	} else if ((usbHalData.ctrlModel == MV_6510_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6530_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6550_DEV_ID) ||
-		(usbHalData.ctrlModel == MV_6560_DEV_ID)) {
-
-		mvUsbPhy65nmNewInit(dev);
-
-/* 	mvUsbPhyKW6500Init(dev); */
-	} else if ((usbHalData.ctrlFamily==MV_67XX) ||
-		(usbHalData.ctrlFamily==MV_78XX0)) {
-
-		if (mvUsbPhy40nmInit(dev))
-			status = MV_NOT_READY;
-
-	} else
-		mvUsbPhyInit(dev);
-
+	status = mvUsbUtmiPhyInit(dev, &usbHalData);
 #endif
+
 	/* Set Mode register (Stop and Reset USB Core before) */
 	/* Stop the controller */
 	regVal = MV_REG_READ(MV_USB_CORE_CMD_REG(dev));
diff --git a/arch/arm/plat-armada/mv_hal/usb/mvUsb.h b/arch/arm/plat-armada/mv_hal/usb/mvUsb.h
index 6ffb2a2..ecd5d92 100644
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsb.h
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsb.h
@@ -81,6 +81,7 @@ typedef struct {
 /* Functions */
 MV_STATUS	mvUsbPllInit(void);
 MV_STATUS	mvUsbHalInit(int dev, MV_BOOL isHost, MV_USB_HAL_DATA *halData);
+MV_STATUS	mvUsbUtmiPhyInit(int dev, MV_USB_HAL_DATA *halData);
 MV_U32		mvUsbGetCapRegAddr(int devNo);
 MV_U32		mvUsbGetCapRegAddr(int devNo);
 void		mvUsbDevResetComplete(int devNo);
diff --git a/arch/arm/plat-armada/mv_hal/usb/mvUsbRegs.h b/arch/arm/plat-armada/mv_hal/usb/mvUsbRegs.h
index 59d6823..7fd4c4c 100644
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsbRegs.h
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsbRegs.h
@@ -186,11 +186,12 @@ extern "C" {
 #define MV_USB_PHY_TEST_GROUP_CTRL_REG_1(dev)   (MV_USB_REGS_BASE(dev) + 0x454)
 
 /* New design used in 40nm SOC */
-#define MV_USB_X3_REGS_BASE(addr)		(MV_USB_REGS_BASE(0) | BIT11 | (((addr) & 0xF) << 6))
-#define MV_USB_PHY_PLL_REG(reg)			(MV_USB_X3_REGS_BASE(0) | ((reg & 0xF) << 2))
-#define MV_USB_PHY_CHANNEL_REG(dev, reg)	(MV_USB_X3_REGS_BASE(dev + 1) | ((reg & 0xF) << 2))
-
-
+#define MV_USB_PHY_REGS_BASE(unit)		(MV_USB_REGS_BASE(0) | \
+						(unit << 12) | 0x800)
+#define MV_USB_PHY_PLL_REG(reg)			(MV_USB_PHY_REGS_BASE(0) | \
+						((reg & 0xF) << 2))
+#define MV_USB_PHY_CHANNEL_REG(unit, reg)       (MV_USB_PHY_REGS_BASE(unit) | \
+						(reg << 2))
 
 /*******************************************/
 /* USB Windows Registers		   */
-- 
1.7.5.4

