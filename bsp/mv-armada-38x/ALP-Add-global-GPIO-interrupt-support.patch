From 90345e1b1ba7ec423657d3a37a3378e42e3bcba6 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 10 Apr 2013 15:03:05 +0300
Subject: [PATCH 0564/1825] ALP: Add global GPIO interrupt support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 7186e60a2db72a8f481dad2dbcc2afb66c363a24

Global GPIO interrupts are mapped to GIC SPI interrupt lines:
[85:88] and [90:94], serving 67 global GPIO interrupts in total.
Each GIC SPI (for example, GIC SPI 87) serves 8 global GPIO interrupts.

When some global GPIO interrupt is triggered, code enters gic_handle_irq
(first C-code function after entry-armv.S), reads GIC CPU INTACK
register getting some value from [85:88] or [90:94] (let's assume it is 91).

The code enters alp_gpio_cascade_irq_handler(91, desc), finds out
relevant GPIO group register ([0:31], [32:63] or [64:66]), and calls
registered (through request_irq) IRQ handler.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I52111a261a21c9a2c1a3ad79166531e7a9f72fbc
Reviewed-on: http://vgitil04.il.marvell.com:8080/1534
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/irq.c |  155 ++++++++++++++++++++++++++++-------------
 1 files changed, 106 insertions(+), 49 deletions(-)

diff --git a/arch/arm/mach-avantalp/irq.c b/arch/arm/mach-avantalp/irq.c
index af2cfeb..1e6a910 100644
--- a/arch/arm/mach-avantalp/irq.c
+++ b/arch/arm/mach-avantalp/irq.c
@@ -16,6 +16,8 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/irq.h>
 #include "ca9x2.h"
+#include "mvOs.h"
+#include "gpp/mvGppRegs.h"
 
 #define SOC_PPI_CAUSE			0x21880
 #define SOC_PPI_MASK_SET		0x218b8
@@ -24,6 +26,109 @@
 static DEFINE_SPINLOCK(irq_controller_lock);
 
 /*
+ * Global GPIO interrupt handling
+ */
+static void alp_gpio_irq_mask(struct irq_data *d)
+{
+        u32 irq = d->irq, bitmask, reg;
+
+	if (irq <  IRQ_START_GLOBAL_GPIO ||
+	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return; /* wrong  */
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_GLOBAL_GPIO) >> 5;
+	MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
+}
+
+static void alp_gpio_irq_unmask(struct irq_data *d)
+{
+        u32 irq = d->irq, bitmask, reg;
+
+	if (irq <  IRQ_START_GLOBAL_GPIO ||
+	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return; /* wrong  */
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_GLOBAL_GPIO) >> 5;
+	MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
+}
+
+static struct irq_chip alp_irq_chip = {
+	.name		= "alp_gpio_irq",
+	.irq_mask	= alp_gpio_irq_mask,
+	.irq_mask_ack	= alp_gpio_irq_mask,
+	.irq_unmask	= alp_gpio_irq_unmask,
+	.irq_disable	= alp_gpio_irq_mask,
+	.irq_enable	= alp_gpio_irq_unmask,
+};
+
+/*
+ * gpio_cascade_irq is in [85:88] or [90:94]
+ */
+static void alp_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
+					 struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u32 bit, n, gpio_group, irq;
+	unsigned long cause, mask;
+
+	chained_irq_enter(chip, desc);
+
+	gpio_group = (gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7) / 4;
+
+	cause = MV_REG_READ(GPP_INT_CAUSE_REG(gpio_group));
+	mask  = MV_REG_READ(GPP_INT_MASK_REG (gpio_group));
+	cause &= mask;
+
+	/* Ack GPIO interrupts */
+	MV_REG_WRITE(GPP_INT_LVL_REG(gpio_group), cause);
+
+	for_each_set_bit(bit, &cause, 32) {
+		n = gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7;
+
+		if (n >= 5)
+			n -= 1;
+		n = (n * 8) + (bit % 4);
+
+		irq = IRQ_START_GLOBAL_GPIO + n;
+		handle_level_irq(irq, desc);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void __init alp_cascade_irq_gpio_global(void)
+{
+	int irq, irq_base;
+
+	irq_base = irq_alloc_descs(-1, IRQ_START_GLOBAL_GPIO,
+				   NR_IRQS_GLOBAL_GPIO, 0);
+	if (IS_ERR_VALUE(irq_base))
+		BUG();
+
+	for (irq = IRQ_START_GLOBAL_GPIO;
+	     irq < IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO; irq++) {
+		irq_set_chip_and_handler(irq, &alp_irq_chip, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,   alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,  alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66, alp_gpio_cascade_irq_handler);
+}
+
+/*
  * Handle SOC PPI (Private Peripheral Interrupts).
  */
 struct mpic_chip_regs {
@@ -120,57 +225,9 @@ static void __init alp_cascade_irq_mpic(int irq, int nr_irqs)
 	WARN_ON(!mpic->domain);
 }
 
-/*
- * Handle Global GPIO interrupts.
- */
-#define GPIO_VIRT_BASE_0_31	(BRIDGE_PHYS_BASE | 0x18100)
-#define GPIO_VIRT_BASE_32_63	(BRIDGE_PHYS_BASE | 0x18140)
-#define GPIO_VIRT_BASE_64_66	(BRIDGE_PHYS_BASE | 0x18180)
-
-static void __init alp_cascade_irq_gpio_global(void)
-{
-#if 0
-	/* Initialize gpiolib for GPIOs 0-31 */
-	gpio_irq_init(0, 32, GPIO_VIRT_BASE_0_31, 0, IRQ_START_GLOB_GPIO);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_0_7,   gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_8_15,  gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_16_23, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_24_31, gpio_irq_handler);
-
-	/* Initialize gpiolib for GPIOs 32-63 */
-	gpio_irq_init(32, 32, GPIO_VIRT_BASE_32_63, 0, IRQ_START_GLOB_GPIO + 32);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_32_39, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_40_47, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_48_55, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_56_63, gpio_irq_handler);
-
-	/* Initialize gpiolib for GPIOs 64-66 */
-	gpio_irq_init(64, 2, GPIO_VIRT_BASE_64_66, 0, IRQ_START_GLOB_GPIO + 64);
-	irq_set_chained_handler(IRQ_GLOB_GPIO_64_66, gpio_irq_handler);
-#endif
-}
-
 static void __init alp_cascade_irq_gpio_private(void)
 {
-#if 0
-	/* Initialize gpiolib for GPIOs 0-31 */
-	gpio_irq_init(0, 32, GPIO_VIRT_BASE_0_31, 0, IRQ_START_PRIV_GPIO);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_0_7,   gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_8_15,  gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_16_23, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_24_31, gpio_irq_handler);
-
-	/* Initialize gpiolib for GPIOs 32-63 */
-	gpio_irq_init(32, 32, GPIO_VIRT_BASE_32_63, 0, IRQ_START_PRIV_GPIO + 32);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_32_39, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_40_47, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_48_55, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_56_63, gpio_irq_handler);
-
-	/* Initialize gpiolib for GPIOs 64-66 */
-	gpio_irq_init(64, 2, GPIO_VIRT_BASE_64_66, 0, IRQ_START_PRIV_GPIO + 64);
-	irq_set_chained_handler(IRQ_PRIV_GPIO_64_66, gpio_irq_handler);
-#endif
+	/* TBD */
 }
 
 static void __init alp_cascade_irq_msi_global(void)
-- 
1.7.5.4

