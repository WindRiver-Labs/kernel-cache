From ffc74559a5e3d62499cbbe6c1343726b3d01564b Mon Sep 17 00:00:00 2001
From: Piotr Ziecik <kosmo@semihalf.com>
Date: Mon, 27 Jan 2014 15:26:49 +0100
Subject: [PATCH 1379/1825] alp: ipc_dfev: Introduce SMP version of the
 ipc_dfev module.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 65f2a5d4d00df84d43dbb1ea8f763e9debf88c2b

	This commit introduces SMP version of the ipc_dfev module.
	From this point DFEV subsystem may be used in SMP environment.

Change-Id: I901a5e0dcf7be6b096fef128827876c7c0beda1a
Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5836
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-armada/mv_drivers_lsp/mv_phone/Makefile   |    4 +
 .../mv_drivers_lsp/mv_phone/dfev/ipc_dfev_smp.c    |  493 ++++++++++++++++++++
 2 files changed, 497 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev_smp.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
index 85512d9..708e251 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
@@ -33,8 +33,12 @@ EXTRA_CFLAGS += -DMV_KERNEL_SLIC_SUPPORT
 ifeq ($(CONFIG_LANTIQ_DFEV_SLIC_SUPPORT),y)
 	PHONE_OBJS += $(LSP_SLIC_PATH)/sdd_if.o
 	PHONE_OBJS += $(LSP_SLIC_PATH)/dfev_if.o
+ifeq ($(CONFIG_MV_AMP_ENABLE),y)
 	PHONE_OBJS += $(LSP_DFEV_PATH)/ipc_dfev.o
 else
+	PHONE_OBJS += $(LSP_DFEV_PATH)/ipc_dfev_smp.o
+endif
+else
 	PHONE_OBJS += $(LSP_TDM_PATH)/tdm_if.o
 endif
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev_smp.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev_smp.c
new file mode 100644
index 0000000..1a2a07c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev_smp.c
@@ -0,0 +1,493 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <plat/ipc_dfev.h>
+
+#define IPC_DFEV_FIFO_SIZE		16	/* must be power of 2 */
+
+#define IPC_DFEV_MSG_TYPE_COMMAND	0
+#define IPC_DFEV_MSG_TYPE_EVENT		1
+#define IPC_DFEV_MSG_TYPE_RX		2
+#define IPC_DFEV_MSG_TYPE_TX		3
+
+struct ipc_dfev_channel {
+	atomic_t	read_idx;
+	atomic_t	write_idx;
+	void		*fifo[IPC_DFEV_FIFO_SIZE];
+};
+
+static struct ipc_dfev_channel ctrl_dfev2host;
+static struct ipc_dfev_channel ctrl_host2dfev;
+
+static struct ipc_dfev_channel rx_dfev2host;
+static struct ipc_dfev_channel rx_host2dfev;
+
+static struct ipc_dfev_channel tx_dfev2host;
+static struct ipc_dfev_channel tx_host2dfev;
+
+static struct ipc_dfev_channel return_dfev2host;
+static struct ipc_dfev_channel return_host2dfev;
+
+static struct tasklet_struct ipc_dfev_tasklet;
+
+struct ipc_dfev_ctrl_buffer {
+	int				type;
+	struct ipc_dfev_ctrl_msg	msg;
+};
+
+struct ipc_dfev_ctrl_handle {
+	struct ipc_dfev_channel		*ctrl_rx;
+	struct ipc_dfev_channel		*ctrl_tx;
+
+	struct ipc_dfev_ctrl_ops	*ctrl_ops;
+	struct tasklet_struct		*tasklet;
+};
+
+static struct ipc_dfev_ctrl_handle ipc_dfev_ctrl_handle_dfev = {
+	.ctrl_rx	= &ctrl_host2dfev,
+	.ctrl_tx	= &ctrl_dfev2host,
+
+	.tasklet	= &ipc_dfev_tasklet,
+};
+
+static struct ipc_dfev_ctrl_handle ipc_dfev_ctrl_handle_host = {
+	.ctrl_rx	= &ctrl_dfev2host,
+	.ctrl_tx	= &ctrl_host2dfev,
+
+	.tasklet	= NULL,
+};
+
+struct ipc_dfev_data_buffer {
+	int				type;
+	struct ipc_dfev_data_msg	msg;
+};
+
+struct ipc_dfev_data_handle {
+	struct ipc_dfev_channel		*rx_rx;
+	struct ipc_dfev_channel		*rx_tx;
+
+	struct ipc_dfev_channel		*tx_rx;
+	struct ipc_dfev_channel		*tx_tx;
+
+	struct ipc_dfev_channel		*return_rx;
+	struct ipc_dfev_channel		*return_tx;
+
+	struct ipc_dfev_data_ops	*data_ops;
+	struct tasklet_struct		*tasklet;
+};
+
+static struct ipc_dfev_data_handle ipc_dfev_data_handle_dfev = {
+	.rx_rx		= &rx_host2dfev,
+	.rx_tx		= &rx_dfev2host,
+
+	.tx_rx		= &tx_host2dfev,
+	.tx_tx		= &tx_dfev2host,
+
+	.return_rx	= &return_host2dfev,
+	.return_tx	= &return_dfev2host,
+
+	.tasklet	= &ipc_dfev_tasklet,
+};
+
+static struct ipc_dfev_data_handle ipc_dfev_data_handle_host = {
+	.rx_rx		= &rx_dfev2host,
+	.rx_tx		= &rx_host2dfev,
+
+	.tx_rx		= &tx_dfev2host,
+	.tx_tx		= &tx_host2dfev,
+
+	.return_rx	= &return_dfev2host,
+	.return_tx	= &return_host2dfev,
+
+	.tasklet	= NULL,
+};
+
+static int ipc_dfev_channel_is_empty(struct ipc_dfev_channel *ch)
+{
+	return (atomic_read(&ch->write_idx) - atomic_read(&ch->read_idx) == 0);
+}
+
+static int ipc_dfev_channel_is_full(struct ipc_dfev_channel *ch)
+{
+	return (atomic_read(&ch->write_idx) - atomic_read(&ch->read_idx) >=
+						IPC_DFEV_FIFO_SIZE);
+}
+
+static int ipc_dfev_msg_put(struct ipc_dfev_channel *ch, void *msg)
+{
+	unsigned int idx;
+
+	if (ipc_dfev_channel_is_full(ch))
+		return -ENOMEM;
+
+	idx = atomic_read(&ch->write_idx) & (IPC_DFEV_FIFO_SIZE - 1);
+	ch->fifo[idx] = msg;
+	atomic_inc(&ch->write_idx);
+
+	return 0;
+}
+
+static void *ipc_dfev_msg_get(struct ipc_dfev_channel *ch)
+{
+	unsigned int idx;
+	void *msg;
+
+	if (ipc_dfev_channel_is_empty(ch))
+		return NULL;
+
+	idx = atomic_read(&ch->read_idx) & (IPC_DFEV_FIFO_SIZE - 1);
+	msg = ch->fifo[idx];
+	atomic_inc(&ch->read_idx);
+
+	return msg;
+}
+
+static void ipc_dfev_tasklet_func(unsigned long data)
+{
+	int again;
+
+	do {
+		again = 0;
+
+		if (ipc_dfev_ctrl_handle_host.ctrl_ops != NULL)
+			if (ipc_dfev_ctrl_poll(&ipc_dfev_ctrl_handle_host) == 0)
+				again = 1;
+
+		if (ipc_dfev_data_handle_host.data_ops != NULL) {
+			if (ipc_dfev_data_poll_rx(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+
+			if (ipc_dfev_data_poll_tx(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+
+			if (ipc_dfev_data_poll_return(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+		}
+	} while (again);
+}
+
+/*
+ * Control Path API
+ */
+struct ipc_dfev_ctrl_handle *ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_ctrl_ops *ctrl_ops)
+{
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		/* Host side uses INTERRUPT mode */
+		ipc_dfev_ctrl_handle_host.ctrl_ops = ctrl_ops;
+		return &ipc_dfev_ctrl_handle_host;
+	case IPC_DFEV_MODE_POLLING:
+		/* DFEV side uses POLLING mode */
+		ipc_dfev_ctrl_handle_dfev.ctrl_ops = ctrl_ops;
+		return &ipc_dfev_ctrl_handle_dfev;
+	default:
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_init);
+
+void ipc_dfev_ctrl_exit(struct ipc_dfev_ctrl_handle *handle)
+{
+	handle->ctrl_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_exit);
+
+int ipc_dfev_ctrl_poll(struct ipc_dfev_ctrl_handle *handle)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->ctrl_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	switch (buffer->type) {
+	case IPC_DFEV_MSG_TYPE_COMMAND:
+		if (handle->ctrl_ops && handle->ctrl_ops->ipc_dfev_command_callback)
+			handle->ctrl_ops->ipc_dfev_command_callback(msg);
+		else
+			ipc_dfev_ctrl_msg_put(handle, msg);
+		break;
+	case IPC_DFEV_MSG_TYPE_EVENT:
+		if (handle->ctrl_ops && handle->ctrl_ops->ipc_dfev_event_callback)
+			handle->ctrl_ops->ipc_dfev_event_callback(msg);
+		else
+			ipc_dfev_ctrl_msg_put(handle, msg);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown ctrl message type %u!\n", buffer->type);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_poll);
+
+struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(struct ipc_dfev_ctrl_handle *handle)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+
+	buffer = kmalloc(sizeof(struct ipc_dfev_ctrl_buffer), GFP_ATOMIC);
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_get);
+
+void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	kfree(container_of(msg, struct ipc_dfev_ctrl_buffer, msg));
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_put);
+
+int ipc_dfev_send_command(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_COMMAND;
+
+	retval = ipc_dfev_msg_put(handle->ctrl_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_command);
+
+int ipc_dfev_send_event(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_EVENT;
+
+	retval = ipc_dfev_msg_put(handle->ctrl_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+
+}
+EXPORT_SYMBOL(ipc_dfev_send_event);
+
+/*
+ * Data Path API
+ */
+struct ipc_dfev_data_handle *ipc_dfev_data_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_data_ops *data_ops)
+{
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		/* Host side uses INTERRUPT mode */
+		ipc_dfev_data_handle_host.data_ops = data_ops;
+		return &ipc_dfev_data_handle_host;
+	case IPC_DFEV_MODE_POLLING:
+		/* DFEV side uses POLLING mode */
+		ipc_dfev_data_handle_dfev.data_ops = data_ops;
+		return &ipc_dfev_data_handle_dfev;
+	default:
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ipc_dfev_data_init);
+
+void ipc_dfev_data_exit(struct ipc_dfev_data_handle *handle)
+{
+	handle->data_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_data_exit);
+
+struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(struct ipc_dfev_data_handle *handle)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = kmalloc(sizeof(struct ipc_dfev_data_buffer), GFP_ATOMIC);
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_get);
+
+void ipc_dfev_data_msg_put(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	kfree(container_of(msg, struct ipc_dfev_data_buffer, msg));
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_put);
+
+int ipc_dfev_send_tx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_TX;
+
+	retval = ipc_dfev_msg_put(handle->tx_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx);
+
+int ipc_dfev_send_rx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_RX;
+
+	retval = ipc_dfev_msg_put(handle->rx_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx);
+
+int ipc_dfev_send_tx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_TX;
+
+	retval = ipc_dfev_msg_put(handle->return_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx_return);
+
+int ipc_dfev_send_rx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_RX;
+
+	retval = ipc_dfev_msg_put(handle->return_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx_return);
+
+static void ipc_dfev_data_handle_msg(struct ipc_dfev_data_handle *handle,
+						struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	switch (buffer->type) {
+	case IPC_DFEV_MSG_TYPE_RX:
+		if (handle->data_ops && handle->data_ops->ipc_dfev_rx_callback)
+			handle->data_ops->ipc_dfev_rx_callback(msg);
+		else
+			ipc_dfev_data_msg_put(handle, msg);
+		break;
+	case IPC_DFEV_MSG_TYPE_TX:
+		if (handle->data_ops && handle->data_ops->ipc_dfev_tx_callback)
+			handle->data_ops->ipc_dfev_tx_callback(msg);
+		else
+			ipc_dfev_data_msg_put(handle, msg);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown data message type %u!\n", buffer->type);
+	}
+}
+
+int ipc_dfev_data_poll_rx(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->rx_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_rx);
+
+int ipc_dfev_data_poll_tx(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->tx_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_tx);
+
+int ipc_dfev_data_poll_return(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->return_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_return);
+
+static int __init ipc_dfev_init_module(void)
+{
+	tasklet_init(&ipc_dfev_tasklet, ipc_dfev_tasklet_func, 0);
+
+	return 0;
+}
+
+static void __exit ipc_dfev_cleanup_module(void)
+{
+	tasklet_kill(&ipc_dfev_tasklet);
+}
+
+module_init(ipc_dfev_init_module);
+module_exit(ipc_dfev_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter-Processor DFEV Communication Driver");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@semihalf.com>");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

