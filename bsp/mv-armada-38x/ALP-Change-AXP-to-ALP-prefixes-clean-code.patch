From 112ef5a355a285f61c50346edc4318f58b7f3f94 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 14 Apr 2013 14:58:19 +0300
Subject: [PATCH 0582/1825] ALP: Change AXP to ALP prefixes, clean code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 994a9cbbe59b4d02d6a7e7e06e12f1014dd4b267

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: If885a4cc88f2c02640ec767d81f74a0c907c24ee
Reviewed-on: http://vgitil04.il.marvell.com:8080/1556
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/config/mvSysHwConfig.h    |   22 ----
 arch/arm/mach-avantalp/core.c                    |   26 +++--
 arch/arm/mach-avantalp/hwmon.c                   |  121 +++++++++++-----------
 arch/arm/mach-avantalp/include/mach/uncompress.h |   97 +-----------------
 arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c     |    4 -
 arch/arm/mach-avantalp/sysmap.c                  |    4 +-
 arch/arm/mach-avantalp/time.c                    |    3 -
 7 files changed, 76 insertions(+), 201 deletions(-)

diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
index 1acaad0..6eaf530 100755
--- a/arch/arm/mach-avantalp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -199,28 +199,6 @@ disclaimer.
 #define AURORA_IO_CACHE_COHERENCY
 #endif
 
-/* convert Definitions for Errata used in the HAL */
-#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4413
-#define SHEEVA_ERRATA_ARM_CPU_4413
-#endif
-#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_BTS61
-#define SHEEVA_ERRATA_ARM_CPU_BTS61
-#endif
-#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
-#define SHEEVA_ERRATA_ARM_CPU_4611
-#endif
-
-/* convert chip revision definitions */
-#ifdef CONFIG_ARMADA_XP_REV_Z1
-#define MV88F78X60_Z1
-#endif
-#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_A0_WITH_B0)
-#define MV88F78X60_A0
-#endif
-#if defined(CONFIG_ARMADA_XP_REV_B0) && !defined(CONFIG_ARMADA_XP_A0_WITH_B0)
-#define MV88F78X60_B0
-#endif
-
 /****************************************************************/
 /************* General configuration ****************************/
 /****************************************************************/
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 6cc1467..01c8fc6 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -394,7 +394,7 @@ static struct platform_device uart1 = {
 	.num_resources		= ARRAY_SIZE(uart1_resources),
 };
 
-void __init serial_initialize(int port)
+static void __init serial_initialize(int port)
 {
 	if (port == 0) {
 		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
@@ -633,7 +633,7 @@ static struct mv_sata_platform_data alp_sata_data = {
 	.n_ports	= 1,
 };
 
-static struct resource armadaxp_sata_resources[] = {
+static struct resource alp_sata_resources[] = {
 	{
 		.name	= "sata base",
 		.start	= SATA_PHYS_BASE,
@@ -647,31 +647,33 @@ static struct resource armadaxp_sata_resources[] = {
 	},
 };
 
-static struct platform_device armadaxp_sata = {
+static struct platform_device alp_sata = {
 	.name		= "sata_mv",
 	.id		= 0,
 	.dev		= {
 		.coherent_dma_mask	= 0xffffffff,
 	},
-	.num_resources	= ARRAY_SIZE(armadaxp_sata_resources),
-	.resource	= armadaxp_sata_resources,
+	.num_resources	= ARRAY_SIZE(alp_sata_resources),
+	.resource	= alp_sata_resources,
 };
+#endif
 
-void __init armadaxp_sata_init(struct mv_sata_platform_data *sata_data)
+static void __init alp_sata_init(void)
 {
+#ifdef CONFIG_SATA_MV
 	if (mvUnitMapIsMine(SATA) != MV_TRUE)
 		return;
 
-	armadaxp_sata.dev.platform_data = sata_data;
-	platform_device_register(&armadaxp_sata);
-}
+	alp_sata.dev.platform_data = &alp_sata_data;
+	platform_device_register(&alp_sata);
 #endif
+}
 
 /*******************************************************************************
  * Helper Routines
  */
 
-void print_board_info(void)
+static void print_board_info(void)
 {
 	char name_buff[50];
 
@@ -765,6 +767,8 @@ static void __init board_init(void)
 	mvSysEthPhyInit();
 	eth_init();
 #endif
+
+	alp_sata_init();
 	alp_i2c_init();
 }
 
@@ -777,8 +781,6 @@ static void board_restart(char mode, const char *cmd)
 	while (1) ;
 }
 
-extern void __init alp_init_irq(void);
-
 MACHINE_START(AVANTA_LP, "Marvell AvantaLP 88f66xx Board")
 	.atag_offset    = BOOT_PARAMS_OFFSET,
 	.map_io         = alp_map_io,
diff --git a/arch/arm/mach-avantalp/hwmon.c b/arch/arm/mach-avantalp/hwmon.c
index 38ca7083..5d3e62c 100644
--- a/arch/arm/mach-avantalp/hwmon.c
+++ b/arch/arm/mach-avantalp/hwmon.c
@@ -39,14 +39,14 @@
 #define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
 #define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
 
-#define ARMADAXP_OVERHEAT_TEMP	105		/* milidegree Celsius */
-#define ARMADAXP_OVERHEAT_DELAY	0x700
-#define ARMADAXP_OVERCOOL_TEMP	10		/* milidegree Celsius */
-#define	ARMADAXP_OVERCOOL_DELAY	0x700
-#define ARMADAXP_OVERHEAT_MIN	0
-#define ARMADAXP_OVERHEAT_MAX	110000
-#define ARMADAXP_OVERCOOL_MIN	0
-#define ARMADAXP_OVERCOOL_MAX	110000
+#define ALP_OVERHEAT_TEMP	105		/* milidegree Celsius */
+#define ALP_OVERHEAT_DELAY	0x700
+#define ALP_OVERCOOL_TEMP	10		/* milidegree Celsius */
+#define	ALP_OVERCOOL_DELAY	0x700
+#define ALP_OVERHEAT_MIN	0
+#define ALP_OVERHEAT_MAX	110000
+#define ALP_OVERCOOL_MIN	0
+#define ALP_OVERCOOL_MAX	110000
 #define PMU_THERMAL_MNGR_REG	0x184c4
 #define	PMU_INT_MASK_REG        0x1C124
 #define	PMU_INT_CAUSE_REG	0x1c120
@@ -66,13 +66,13 @@
 #define	PMU_TM_COOLING_DLY_REG	0x184c8
 
 /* Junction Temperature */
-#define ARMADAXP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
-#define ARMADAXP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+#define ALP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define ALP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
 
 #define LABEL "T-junction"
 static struct device *hwmon_dev;
-unsigned int temp_min = ARMADAXP_OVERCOOL_TEMP;
-unsigned int temp_max = ARMADAXP_OVERHEAT_TEMP;
+unsigned int temp_min = ALP_OVERCOOL_TEMP;
+unsigned int temp_max = ALP_OVERHEAT_TEMP;
 
 typedef enum {
 	SHOW_TEMP,
@@ -82,7 +82,7 @@ typedef enum {
 	SHOW_TYPE,
 	SHOW_LABEL } SHOW;
 
-static void axptemp_set_thresholds(unsigned int max, unsigned int min)
+static void alp_temp_set_thresholds(unsigned int max, unsigned int min)
 {
 	u32 temp, reg;
 
@@ -91,21 +91,21 @@ static void axptemp_set_thresholds(unsigned int max, unsigned int min)
         writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the overheat threashold & delay */
-	temp = ARMADAXP_TSEN_TEMP2RAW(max);
+	temp = ALP_TSEN_TEMP2RAW(max);
 	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
 	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the cool threshole & delay */
-	temp = ARMADAXP_TSEN_TEMP2RAW(min);
+	temp = ALP_TSEN_TEMP2RAW(min);
 	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_COOL_THRSH_MASK;
 	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 }
 
-static int axptemp_init_sensor(void)
+static int alp_temp_init_sensor(void)
 {
 	u32 reg;
 
@@ -142,11 +142,11 @@ static int axptemp_init_sensor(void)
 
 
 	/* Set thresholds */
-	axptemp_set_thresholds(temp_max, temp_min);
+	alp_temp_set_thresholds(temp_max, temp_min);
 
 	/* Set delays */
-	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
-	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
+	writel(ALP_OVERHEAT_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(ALP_OVERCOOL_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
 
 	/* Clear & unmask cooling/overheat interrupts */
 	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
@@ -155,13 +155,13 @@ static int axptemp_init_sensor(void)
 	return 0;
 }
 
-static int axptemp_read_temp(void)
+static int alp_temp_read_temp(void)
 {
 	int reg;
 
 	reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
 	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
-	return ARMADAXP_TSEN_RAW2TEMP(reg);
+	return ALP_TSEN_RAW2TEMP(reg);
 }
 
 
@@ -171,13 +171,12 @@ static int axptemp_read_temp(void)
 
 static ssize_t show_name(struct device *dev, struct device_attribute
 			  *devattr, char *buf) {
-	return sprintf(buf, "%s\n", "axp-hwmon");
+	return sprintf(buf, "%s\n", "alp-hwmon");
 }
 
 static ssize_t show_alarm(struct device *dev, struct device_attribute
 			  *devattr, char *buf)
 {
-
 	int alarm = 0;
 	u32 reg;
 
@@ -216,7 +215,7 @@ static ssize_t show_temp(struct device *dev,
 	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
 
 	if (attr->index == SHOW_TEMP)
-		ret = sprintf(buf, "%d \n", axptemp_read_temp());
+		ret = sprintf(buf, "%d \n", alp_temp_read_temp());
 	else if (attr->index == TEMP_MAX)
 		ret = sprintf(buf, "%d\n", temp_max);
 	else if (attr->index == TEMP_MIN)
@@ -237,25 +236,25 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 		printk(KERN_WARNING "Invalid input string for temperature!");
 
 	if (attr->index == TEMP_MAX) {
-		if((temp < ARMADAXP_OVERHEAT_MIN) || (temp > ARMADAXP_OVERHEAT_MAX))
+		if((temp < ALP_OVERHEAT_MIN) || (temp > ALP_OVERHEAT_MAX))
 			printk(KERN_WARNING "Invalid max temperature input (out of range: %d-%d)!",
-				ARMADAXP_OVERHEAT_MIN, ARMADAXP_OVERHEAT_MAX);
+				ALP_OVERHEAT_MIN, ALP_OVERHEAT_MAX);
 		else {
 			temp_max = temp;
-			axptemp_set_thresholds(temp_max, temp_min);
+			alp_temp_set_thresholds(temp_max, temp_min);
 		}
 	}
 	else if (attr->index == TEMP_MIN) {
-		if((temp < ARMADAXP_OVERCOOL_MIN) || (temp > ARMADAXP_OVERCOOL_MAX))
+		if((temp < ALP_OVERCOOL_MIN) || (temp > ALP_OVERCOOL_MAX))
 			printk(KERN_WARNING "Invalid min temperature input (out of range: %d-%d)!",
-				ARMADAXP_OVERCOOL_MIN, ARMADAXP_OVERCOOL_MAX);
+				ALP_OVERCOOL_MIN, ALP_OVERCOOL_MAX);
 		else {
 			temp_min = temp;
-			axptemp_set_thresholds(temp_max, temp_min);
+			alp_temp_set_thresholds(temp_max, temp_min);
 		}
 	}
 	else
-		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
+		printk(KERN_ERR "alp-temp: Invalid sensor attribute!");
 
 	/* Clear & unmask cooling/overheat interrupts */
 	writel (0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
@@ -265,7 +264,7 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 	return count;
 }
 
-static irqreturn_t axptemp_irq_handler(int irq, void *data)
+static irqreturn_t alp_temp_irq_handler(int irq, void *data)
 {
 	u32 val, mask;
 	mask = readl(INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG);
@@ -287,8 +286,6 @@ static irqreturn_t axptemp_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-
-
 /* TODO - Add read/write support in order to support setting max/min */
 static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
 			  SHOW_TYPE);
@@ -303,7 +300,7 @@ static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp,
 static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
 static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
 
-static struct attribute *axptemp_attributes[] = {
+static struct attribute *alp_temp_attributes[] = {
 	&sensor_dev_attr_name.dev_attr.attr,
 	&dev_attr_temp1_crit_alarm.attr,
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
@@ -314,19 +311,19 @@ static struct attribute *axptemp_attributes[] = {
 	NULL
 };
 
-static const struct attribute_group axptemp_group = {
-	.attrs = axptemp_attributes,
+static const struct attribute_group alp_temp_group = {
+	.attrs = alp_temp_attributes,
 };
 
-static int __devinit axptemp_probe(struct platform_device *pdev)
+static int __devinit alp_temp_probe(struct platform_device *pdev)
 {
 	int err, irq;
 
-	err = axptemp_init_sensor();
+	err = alp_temp_init_sensor();
 	if (err)
 		goto exit;
 
-	err = sysfs_create_group(&pdev->dev.kobj, &axptemp_group);
+	err = sysfs_create_group(&pdev->dev.kobj, &alp_temp_group);
 	if (err)
 		goto exit;
 
@@ -339,57 +336,57 @@ static int __devinit axptemp_probe(struct platform_device *pdev)
 
 	/* Register cooling/overheat interrupt */
 	irq = IRQ_AURORA_PMU;
-	err = request_irq(irq, axptemp_irq_handler, IRQF_DISABLED ,
-				"axp-temp", NULL);
+	err = request_irq(irq, alp_temp_irq_handler, IRQF_DISABLED ,
+				"alp-temp", NULL);
 	if (err)
-		printk(KERN_INFO "unable to request IRQ%d for axp-temp\n", irq);
-	printk(KERN_INFO "Armada XP hwmon thermal sensor initialized.\n");
+		printk(KERN_INFO "unable to request IRQ%d for alp-temp\n", irq);
+	printk(KERN_INFO "Avanta LP hwmon thermal sensor initialized.\n");
 
 	return 0;
 exit:
-	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	sysfs_remove_group(&pdev->dev.kobj, &alp_temp_group);
 	return err;
 }
 
-static int __devexit axptemp_remove(struct platform_device *pdev)
+static int __devexit alp_temp_remove(struct platform_device *pdev)
 {
-	struct axptemp_data *data = platform_get_drvdata(pdev);
+	struct alp_temp_data *data = platform_get_drvdata(pdev);
 
 	hwmon_device_unregister(hwmon_dev);
-	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	sysfs_remove_group(&pdev->dev.kobj, &alp_temp_group);
 	platform_set_drvdata(pdev, NULL);
 	kfree(data);
 	return 0;
 }
 
-static int axptemp_resume(struct platform_device *dev)
+static int alp_temp_resume(struct platform_device *dev)
 {
-	return axptemp_init_sensor();
+	return alp_temp_init_sensor();
 }
 
-static struct platform_driver axptemp_driver = {
+static struct platform_driver alp_temp_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = "axp-temp",
+		.name = "alp-temp",
 	},
-	.probe = axptemp_probe,
-	.remove = __devexit_p(axptemp_remove),
-	.resume = axptemp_resume,
+	.probe = alp_temp_probe,
+	.remove = __devexit_p(alp_temp_remove),
+	.resume = alp_temp_resume,
 };
 
-static int __init axptemp_init(void)
+static int __init alp_temp_init(void)
 {
-	return platform_driver_register(&axptemp_driver);
+	return platform_driver_register(&alp_temp_driver);
 }
 
-static void __exit axptemp_exit(void)
+static void __exit alp_temp_exit(void)
 {
-	platform_driver_unregister(&axptemp_driver);
+	platform_driver_unregister(&alp_temp_driver);
 }
 
 MODULE_AUTHOR("Marvell Semiconductors");
-MODULE_DESCRIPTION("Marvell Armada XP SoC hwmon driver");
+MODULE_DESCRIPTION("Marvell Avanta LP SoC hwmon driver");
 MODULE_LICENSE("GPL");
 
-module_init(axptemp_init)
-module_exit(axptemp_exit)
+module_init(alp_temp_init)
+module_exit(alp_temp_exit)
diff --git a/arch/arm/mach-avantalp/include/mach/uncompress.h b/arch/arm/mach-avantalp/include/mach/uncompress.h
index 790d28f..743d9ba 100644
--- a/arch/arm/mach-avantalp/include/mach/uncompress.h
+++ b/arch/arm/mach-avantalp/include/mach/uncompress.h
@@ -33,6 +33,7 @@ static void putc(const char c)
 
 static void flush(void)
 {
+	/* empty function */
 }
 
 /*
@@ -40,99 +41,3 @@ static void flush(void)
  */
 #define arch_decomp_setup()
 #define arch_decomp_wdog()
-
-#if 0
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//#include <linux/autoconf.h>
-#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
-#include <linux/serial_reg.h>
-#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
-#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
-
-#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x14))
-#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x0 ))
-#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
-
-#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x40000))
-#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x2011c))
-/*
- * This does not append a newline
- */
-static void putstr(const char *s)
-{
-	unsigned int model;
-
-	/* Get dev ID, make sure pex clk is on */
-	if((CLK_REG & 0x4) == 0)
-	{
-		CLK_REG = CLK_REG | 0x4;
-		model = (DEV_REG >> 16) & 0xffff;
-		CLK_REG = CLK_REG & ~0x4;
-	}
-	else
-		model = (DEV_REG >> 16) & 0xffff;
-
-        while (*s) {
-		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
-		MV_UART0_THR = *s;
-
-                if (*s == '\n') {
-                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
-                        MV_UART0_THR = '\r';
-                }
-                s++;
-        }
-}
-
-#if 0
-static void putc(const char c)
-{
-	unsigned char *base = MV_SERIAL_BASE;
-	int i;
-
-	for (i = 0; i < 0x1000; i++) {
-		if (base[UART_LSR << 2] & UART_LSR_THRE)
-			break;
-		barrier();
-	}
-
-	base[UART_TX << 2] = c;
-}
-#endif
-#if 0
-static void flush(void)
-{
-	unsigned char *base = MV_SERIAL_BASE;
-	unsigned char mask;
-	int i;
-
-	mask = UART_LSR_TEMT | UART_LSR_THRE;
-
-	for (i = 0; i < 0x1000; i++) {
-		if ((base[UART_LSR << 2] & mask) == mask)
-			break;
-		barrier();
-	}
-}
-#endif
-/*
- * nothing to do
- */
-#define arch_decomp_setup()
-#define arch_decomp_wdog()
-#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
index 48cc400..f1afe59 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
@@ -103,11 +103,7 @@ MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle)
 			}
 			halData.sramPhysBase[chan] = (MV_ULONG)mv_crypto_phys_base_get(chan);
 			halData.sramVirtBase[chan] = (MV_U8*)mv_crypto_virt_base_get(chan);
-#ifdef CONFIG_ARMADA_SUPPORT_DEEP_IDLE_FAST_EXIT
-			halData.sramOffset[chan] = 32;
-#else
 			halData.sramOffset[chan] = 0;
-#endif
 		}
 
 		if (status == MV_OK) {
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index f0ea567..72ba05f 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -28,7 +28,7 @@ struct map_desc  MEM_TABLE[] =	{
 	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
 };
 
-MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
+MV_CPU_DEC_WIN SYSMAP_ALP[] = {
 	/* base low       	     base high        size       		WinNum     	enable */
 	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
 	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
@@ -79,7 +79,7 @@ MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
 
 MV_CPU_DEC_WIN* mv_sys_map(void)
 {
-	return SYSMAP_ARMADA_XP;
+	return SYSMAP_ALP;
 }
 
 #if defined(CONFIG_MV_INCLUDE_CESA)
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index 84f68a2..16cac4b 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -30,9 +30,6 @@
 #include "boardEnv/mvBoardEnvLib.h"
 #include "cpu/mvCpu.h"
 
-extern void axp_irq_mask(struct irq_data *d);
-extern void axp_irq_unmask(struct irq_data *d);
-
 /* SoC global timer */
 #define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
 #define  TIMER_EN(x)		(1 << (2 * x))
-- 
1.7.5.4

