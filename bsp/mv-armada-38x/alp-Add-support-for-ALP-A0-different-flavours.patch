From da8813dfeab4d28d71e9c25ed7c78b06a53eb45f Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Sun, 9 Feb 2014 19:42:59 +0200
Subject: [PATCH 1351/1825] alp: Add support for ALP-A0 different flavours

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 32ecd669fe0d30c569fdba65b463bc5eb98b492a

	Support ALP-A0 (MV88f66XX) flavours:
	- update SoC model get function to support A0 SoC's
	- update number of units for every flavour
	Add new rourine: mvBoardLaneSelectorGet
	- aligned board configuration print with new SerDes limitaions
	for new A0 flavours

Change-Id: Ia95a501fb1a65c15801df437d55528cee2b39376
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5500
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   58 ++++++++---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    2 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  113 +++++++++++++------
 arch/arm/plat-armada/common/mvDeviceId.h           |    9 ++-
 4 files changed, 128 insertions(+), 54 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 48971b7..d68955f 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -993,9 +993,8 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 *******************************************************************************/
 MV_VOID mvBoardVerifySerdesCofig(MV_VOID)
 {
-	MV_U32 i, laneConfig, laneSelector, selector = MV_REG_READ(MV_COMMON_PHY_REGS_OFFSET);
+	MV_U32 i, laneConfig, laneSelector;
 	MV_CONFIG_TYPE_ID configID = MV_CONFIG_LANE1;
-	MV_U32 revID = mvCtrlRevGet();
 
 	/* Lane 1 & Lane 3 use the same values for SerDes config and selector,
 	 * Lane2 values  are reversed:
@@ -1009,10 +1008,7 @@ MV_VOID mvBoardVerifySerdesCofig(MV_VOID)
 			laneConfig = mvCtrlSysConfigGet(configID++);
 		/* using different Mask/Offset, since SATA1 option at lane1 was
 		** not supported in Z1, Z2, Z3 */
-		if (revID <= MV_88F66X0_Z3_ID)
-			laneSelector = (selector & SERDES_LANE_MASK_Z_REV(i)) >> SERDES_LANE_OFFS_Z_REV(i);
-		else
-			laneSelector = (selector & SERDES_LANE_MASK(i)) >> SERDES_LANE_OFFS(i);
+		laneSelector = mvBoardLaneSelectorGet(i);
 		if ((i != 2 && laneSelector != laneConfig) || /* lanes 1,3 use the same value */
 			(i == 2 && laneSelector == laneConfig)) { /* lane 2 use opposite values */
 			mvOsPrintf("Error: board configuration conflicts with SerDes configuration\n");
@@ -1633,12 +1629,16 @@ MV_U32 mvBoardFreqModesNumGet()
 
 	switch (mvCtrlModelGet()) {
 	case MV_6610_DEV_ID:
+	case MV_6610F_DEV_ID:
 		freqNum = FREQ_MODES_NUM_6610;
 		break;
 	case MV_6650_DEV_ID:
+	case MV_6650F_DEV_ID:
+	case MV_6658_DEV_ID:
 		freqNum = FREQ_MODES_NUM_6650;
 		break;
 	case MV_6660_DEV_ID:
+	case MV_6665_DEV_ID:
 		freqNum = FREQ_MODES_NUM_6660;
 		break;
 	default:
@@ -1867,9 +1867,10 @@ MV_VOID mvBoardDDRBusWidthCheck(MV_VOID)
 *******************************************************************************/
 MV_VOID mvBoardConfigurationPrint(MV_VOID)
 {
-	char *lane1[] = {"PCIe1", "SGMII-0", "SATA-1", "Invalid Configuration" };
+	char *lane1[] = {"PCIe1", "SGMII-0", "SATA-1", "Unconnected" };
 	char *tdmSlic[] = {"None", "SSI", "ISI", "ZSI", "TDM"};
-	MV_U32 slicDevice, laneSelector, ethConfig = mvBoardEthComplexConfigGet();
+	MV_U32 slicDevice, ethConfig = mvBoardEthComplexConfigGet();
+	MV_U16 modelID = mvCtrlModelGet();
 
 	mvOsOutput("\nBoard configuration:\n");
 
@@ -1941,15 +1942,42 @@ MV_VOID mvBoardConfigurationPrint(MV_VOID)
 	mvOsOutput("\nSERDES configuration:\n");
 	mvOsOutput("\tLane #0: PCIe0\n");	/* Lane 0 is always PCIe0 */
 
-	/* SERDES lanes #1,#2,#3 are relevant only to MV88F6660 SoC*/
-	if (mvCtrlModelGet() != MV_6660_DEV_ID)
+	/* Dynamic config for SerDes lanes is relevant only to MV88F6660/65/58 */
+	if (modelID != MV_6660_DEV_ID && modelID != MV_6665_DEV_ID && modelID != MV_6658_DEV_ID)
 		return;
-
 	/* Read Common Phy selectors to determine SerDes configuration */
-	laneSelector = MV_REG_READ(MV_COMMON_PHY_REGS_OFFSET);
-	mvOsOutput("\tLane #1: %s\n", lane1[(laneSelector & BIT1) >> 1]);
-	mvOsOutput("\tLane #2: %s\n", (laneSelector & BIT2) >> 2 ? "SATA-0" : "SGMII-0");
-	mvOsOutput("\tLane #3: %s\n", (laneSelector & BIT3) >> 3 ? "SGMII-0" : "USB3");
+	mvOsOutput("\tLane #1: %s\n", lane1[mvBoardLaneSelectorGet(1)]);
+	/* SERDES lanes #2,#3 are relevant only to MV88F6660/65 SoC */
+	if (modelID != MV_6660_DEV_ID && modelID != MV_6665_DEV_ID)
+		return;
+	mvOsOutput("\tLane #2: %s\n", (mvBoardLaneSelectorGet(2) ? "SATA-0" : "SGMII-0"));
+	mvOsOutput("\tLane #3: %s\n", (mvBoardLaneSelectorGet(3) ? "SGMII-0" : "USB3"));
+}
+
+/*******************************************************************************
+* mvBoardLaneSelectorGet
+*
+*  DESCRIPTION:
+*       Get Lane Selector
+*
+* INPUT:
+*       Lane number
+*
+* OUTPUT:
+*
+* RETURN:
+*	Lane selector
+*
+*******************************************************************************/
+MV_U32 mvBoardLaneSelectorGet(MV_U32 laneNum)
+{
+	MV_U32 revID = mvCtrlRevGet();
+	MV_U32 laneSelector, selector = MV_REG_READ(MV_COMMON_PHY_REGS_OFFSET);
+	if (revID <= MV_88F66X0_Z3_ID)
+		laneSelector = (selector & SERDES_LANE_MASK_Z_REV(laneNum)) >> SERDES_LANE_OFFS_Z_REV(laneNum);
+	else
+		laneSelector = (selector & SERDES_LANE_MASK(laneNum)) >> SERDES_LANE_OFFS(laneNum);
+	return laneSelector;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 20db55d..9e23e5c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -585,7 +585,7 @@ MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
 MV_STATUS mvBoardConfIdSet(MV_U16 conf);
 MV_U16 mvBoardPexModeGet(MV_VOID);
 MV_STATUS mvBoardPexModeSet(MV_U16 conf);
-
+MV_U32 mvBoardLaneSelectorGet(MV_U32 laneNum);
 #ifdef __cplusplus
 }
 #endif  /* __cplusplus */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 0f62313..e1eb1c4 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -229,9 +229,11 @@ MV_STATUS mvCtrlUpdatePexId(MV_VOID)
 
 /* Avanta LP family linear id */
 #define MV_6660_INDEX		0
-#define MV_6650_INDEX		1
-#define MV_6610_INDEX		2
-#define MV_66xx_INDEX_MAX	3
+#define MV_6650_INDEX		1 /* used also for MV6650F */
+#define MV_6610_INDEX		2 /* used also for MV6610F */
+#define MV_6665_INDEX		3
+#define MV_6658_INDEX		4
+#define MV_66xx_INDEX_MAX	5
 
 static MV_U32 mvCtrlDevIdIndexGet(MV_U32 devId)
 {
@@ -242,11 +244,17 @@ static MV_U32 mvCtrlDevIdIndexGet(MV_U32 devId)
 		index = MV_6660_INDEX;
 		break;
 	case MV_6650_DEV_ID:
+	case MV_6650F_DEV_ID:
 		index = MV_6650_INDEX;
 		break;
 	case MV_6610_DEV_ID:
+	case MV_6610F_DEV_ID:
 		index = MV_6610_INDEX;
 		break;
+	case MV_6665_DEV_ID:
+		index = MV_6665_INDEX;
+	case MV_6658_DEV_ID:
+		index = MV_6658_INDEX;
 	default:
 		index = MV_6650_INDEX;
 	}
@@ -255,26 +263,26 @@ static MV_U32 mvCtrlDevIdIndexGet(MV_U32 devId)
 }
 
 MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_66xx_INDEX_MAX] = {
-/*                           6660               6650            6610 */
-/* DRAM_UNIT_ID         */ { 1,                 1,              1, },
-/* PEX_UNIT_ID          */ { 2,                 1,              0, },
-/* ETH_GIG_UNIT_ID      */ { 2,                 2,              2, },
-/* USB_UNIT_ID          */ { 1,                 1,              0, },
-/* USB3_UNIT_ID         */ { 1,                 0,              0, },
-/* IDMA_UNIT_ID         */ { 0,                 0,              0, },
-/* XOR_UNIT_ID          */ { 2,                 0,              0, },
-/* SATA_UNIT_ID         */ { 2,                 0,              0, },
-/* TDM_UNIT_ID		*/ { 1,                 1,              1, },
-/* UART_UNIT_ID         */ { 2,                 2,              2, },
-/* CESA_UNIT_ID         */ { 1,                 0,              0, },
-/* SPI_UNIT_ID          */ { 2,                 2,              2, },
-/* AUDIO_UNIT_ID        */ { 1,                 0,              0, },
-/* SDIO_UNIT_ID         */ { 1,                 0,              0, },
-/* TS_UNIT_ID           */ { 0,                 0,              0, },
-/* XPON_UNIT_ID         */ { 1,                 1,              1, },
-/* BM_UNIT_ID           */ { 1,                 1,              1, },
-/* PNC_UNIT_ID          */ { 1,                 1,              1, },
-/* I2C_UNIT_ID          */ { 2,                 1,              1, },
+/*                        6660      650/650F 610/610F  6665   6658 */
+/* DRAM_UNIT_ID         */ { 1,		1,	1,	1,	1, },
+/* PEX_UNIT_ID          */ { 2,		1,	0,	2,	2, },
+/* ETH_GIG_UNIT_ID      */ { 2,		2,	2,	2,	2, },
+/* USB_UNIT_ID          */ { 1,		2,	0,	0,	2, },
+/* USB3_UNIT_ID         */ { 1,		0,	0,	1,	0, },
+/* IDMA_UNIT_ID         */ { 0,		0,	0,	0,	0, },
+/* XOR_UNIT_ID          */ { 2,		2,	0,	2,	2, },
+/* SATA_UNIT_ID         */ { 2,		0,	0,	2,	0, },
+/* TDM_UNIT_ID          */ { 1,		1,	1,	1,	1, },
+/* UART_UNIT_ID         */ { 2,		2,	2,	2,	2, },
+/* CESA_UNIT_ID         */ { 2,		0,	0,	2,	0, },
+/* SPI_UNIT_ID          */ { 2,		2,	2,	2,	2, },
+/* AUDIO_UNIT_ID        */ { 1,		0,	0,	1,	0, },
+/* SDIO_UNIT_ID         */ { 1,		1,	1,	1,	1, },
+/* TS_UNIT_ID           */ { 0,		0,	0,	0,	0, },
+/* XPON_UNIT_ID         */ { 1,		1,	1,	1,	1, },
+/* BM_UNIT_ID           */ { 1,		1,	1,	1,	1, },
+/* PNC_UNIT_ID          */ { 1,		1,	1,	1,	1, },
+/* I2C_UNIT_ID          */ { 2,		2,	1,	2,	1, },
 };
 
 MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
@@ -1085,7 +1093,11 @@ MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCtrlUsbMaxGet(void)
 {
-	return mvCtrlSocUnitInfoNumGet(USB_UNIT_ID);
+	MV_U32 usbNums = mvCtrlSocUnitInfoNumGet(USB_UNIT_ID);
+	/* Z1, Z2, and Z3 revisions support 1 USB unit port in 6650 boards */
+	if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID && mvCtrlModelGet() == MV_6650_DEV_ID)
+		return usbNums - 1;
+	return usbNums;
 }
 
 /*******************************************************************************
@@ -1128,11 +1140,11 @@ MV_U32 mvCtrlUsb3MaxGet(void)
 *******************************************************************************/
 MV_U32 mvCtrlSdioSupport(MV_VOID)
 {
-	/* default HW setup is with SDIO only for RD-6660*/
-	if (mvBoardIdGet() == RD_6660_ID)
-		return mvCtrlSocUnitInfoNumGet(SDIO_UNIT_ID) ? MV_TRUE : MV_FALSE;
-	else
+	/* In Z1, Z2, and Z3 default HW setup is with SDIO only for RD-6660*/
+	if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID)
 		return 0;
+	else
+		return mvCtrlSocUnitInfoNumGet(SDIO_UNIT_ID);
 }
 
 #endif
@@ -1382,6 +1394,7 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 {
 	return MV_TDM_IRQ_NUM;
 }
+#endif /* MV_INCLUDE_TDM */
 
 /*******************************************************************************
 * mvCtrlModelGet - Get Marvell controller device model (Id)
@@ -1400,25 +1413,53 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 *       16bit desscribing Marvell controller ID
 *
 *******************************************************************************/
-#endif /* MV_INCLUDE_TDM */
-
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
 	return MV_88F66X0;
 #else
 	MV_U32 ctrlId, satr0;
+	MV_U32 rev = mvCtrlRevGet();
 
 	ctrlId = MV_REG_READ(DEV_ID_REG);
 	ctrlId = (ctrlId & (DEVICE_ID_MASK)) >> DEVICE_ID_OFFS;
-	if (ctrlId == 0x6660)
-		return MV_6660_DEV_ID;
-
 	satr0 = MV_REG_READ(MPP_SAMPLE_AT_RESET(0));
 	satr0 &= SATR_DEVICE_ID_2_0_MASK;
-	if (satr0 == 0)
-		return MV_6650_DEV_ID;
-	return MV_6610_DEV_ID;
+	/* Device ID mapping differs between Z1-Z3 and A0, since new flavors
+	** are added for A0 */
+	if (rev <= MV_88F66X0_Z3_ID) {
+		if (ctrlId == 0x6660)
+			return MV_6660_DEV_ID;
+		if (satr0 == 0)
+			return MV_6650_DEV_ID;
+		return MV_6610_DEV_ID;
+	}
+	switch (satr0) {
+	case 0:
+		if (ctrlId == 0x6660)
+			return  MV_6660_DEV_ID;
+		else if (ctrlId == 0x6610)
+			return  MV_6650_DEV_ID;
+		break;
+	case 1:
+		if (ctrlId == 0x6660)
+			return  MV_6658_DEV_ID;
+		else if (ctrlId == 0x6610)
+			return  MV_6650F_DEV_ID;
+		break;
+	case 2:
+		if (ctrlId == 0x6610)
+			return  MV_6610_DEV_ID;
+		break;
+	case 3:
+		if (ctrlId == 0x6660)
+			return  MV_6665_DEV_ID;
+		else if (ctrlId == 0x6610)
+			return  MV_6610F_DEV_ID;
+		break;
+	}
+	mvOsPrintf("%s: Error: Failed to Ctrl model ID\n", __func__);
+	return MV_6660_DEV_ID;
 #endif
 }
 
diff --git a/arch/arm/plat-armada/common/mvDeviceId.h b/arch/arm/plat-armada/common/mvDeviceId.h
index 29accaa..1acfedc 100644
--- a/arch/arm/plat-armada/common/mvDeviceId.h
+++ b/arch/arm/plat-armada/common/mvDeviceId.h
@@ -351,9 +351,14 @@ extern "C" {
 
 /* Avanta LP Family */
 #define MV_88F66X0		0x6600
-#define MV_6660_DEV_ID		0x6660
-#define MV_6650_DEV_ID		0x6650
 #define MV_6610_DEV_ID		0x6610
+#define MV_6610F_DEV_ID		0x610F
+#define MV_6650_DEV_ID		0x6650
+#define MV_6650F_DEV_ID		0x650F
+#define MV_6658_DEV_ID		0x6658
+#define MV_6660_DEV_ID		0x6660
+#define MV_6665_DEV_ID		0x6665
+
 #define MV_88F66X0_Z1_ID	0x0
 #define MV_88F66X0_Z1_NAME      "Z1"
 #define MV_88F66X0_Z2_ID	0x1
-- 
1.7.5.4

