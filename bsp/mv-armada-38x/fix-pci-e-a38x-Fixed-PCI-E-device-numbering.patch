From 050523d6fff5845f69d7e99b196f7c1ac14a9051 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Thu, 6 Mar 2014 15:46:49 +0200
Subject: [PATCH 1427/1825] fix: pci-e: a38x: Fixed PCI-E device numbering

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit da303d18df0d74608cd6cee14cd459befd776e96

	In the current PCI-E configuration, the PCI-E host
	is assigned a device number of 0. When accesing local bus
	with device number 0 the host answers. This causes problems with
	devices that only answer CFG read when device is 0 since they
	are missed during the scan.

Change-Id: Ibd83634b6d6c7263611986011bb429492af83f4d
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6221
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/pex.c |  147 +++++++++++++++++++++++++++++++++-------
 1 files changed, 121 insertions(+), 26 deletions(-)

diff --git a/arch/arm/mach-armada38x/pex.c b/arch/arm/mach-armada38x/pex.c
index c4f7dfa..ea6853c 100644
--- a/arch/arm/mach-armada38x/pex.c
+++ b/arch/arm/mach-armada38x/pex.c
@@ -107,9 +107,13 @@ void __init mv_pex_preinit(void)
 		/* Assign bus number 0 to first active/available bus */
 		if (pex0flg == 0) {
 			mvPexLocalBusNumSet(pci_if, 0x0);
+			mvPexLocalDevNumSet(pci_if, 0x1);
 			pex0flg = 1;
 		}
 
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pci_if), 0);
+
 		MV_REG_BIT_SET(PEX_MASK_REG(pci_if), MV_PEX_MASK_ABCD);
 
 		if (mv_is_pci_io_mapped(pci_if)) {
@@ -152,19 +156,70 @@ void mv_pex_reinit(void)
 		/* Assign bus number 0 to first active/available bus */
 		if (pex0flg == 0) {
 			mvPexLocalBusNumSet(pci_if, 0x0);
+			mvPexLocalDevNumSet(pci_if, 0x1);
 			pex0flg = 1;
 		}
 
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pci_if), 0);
+
 		MV_REG_BIT_SET(PEX_MASK_REG(pci_if), MV_PEX_MASK_ABCD);
 	}
 }
 
-static int mv_pci_read_config(struct pci_bus *bus, unsigned int devfn,
-			      int where, int size, u32 *val)
+static int  pci_read_cfg(u32 pciIf, u32 bus_num, u32 dev_no,
+		u32 func, u32 where)
+{
+	u32 cfgCmd;
+	u32 regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK
+			| PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	/* Creating PEX address to be passed */
+	cfgCmd  = (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+	/* lgacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+		     PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the
+	 * read transaction we perform a validity check that the address
+	 * was written
+	 * */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf)))
+		return 0xFFFFFFFF;
+
+	/* cleaning Master Abort */
+	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pciIf, PEX_STATUS_AND_COMMAND),
+			PXSAC_MABORT);
+
+	/* Read the Data returned in the PEX Data register */
+	return  MV_REG_READ(PEX_CFG_DATA_REG(pciIf));
+
+}
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci_read_config(struct pci_bus *bus,
+				  unsigned int devfn, int where,
+				  int size, u32 *val)
 {
-	u32 bus_num, func, regOff, dev_no, temp, localBus;
+	u32 bus_num, func, dev_no, temp, localBus;
 	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
 	u32 pciIf = sysdata->mv_controller_num;
+	u32 regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK
+			| PXCAR_REAL_EXT_REG_NUM_MASK);
+
 
 	*val = 0xffffffff;
 
@@ -173,27 +228,24 @@ static int mv_pci_read_config(struct pci_bus *bus, unsigned int devfn,
 	bus_num = bus->number;
 	dev_no = PCI_SLOT(devfn);
 
-	/* don't return for our device */
+	/* Our local bus is PEX so enable reading only device 0 */
 	localBus = mvPexLocalBusNumGet(pciIf);
-	if (dev_no == 0 && bus_num == localBus) {
-		DB(pr_info
-		   ("PCI %d read from our own dev return 0xffffffff\n", pciIf));
+	if ((dev_no !=  0) && (bus_num == localBus)) {
+		DB(pr_info("PCI %d device %d illegal on local bus\n", pciIf,
+					dev_no));
 		return 0xffffffff;
 	}
 
 	func = PCI_FUNC(devfn);
 
-	/* total of 12 bits: 8 legacy + 4 extended */
-	regOff =
-	    (MV_U32) where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK);
+	temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
 
-	temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
 	switch (size) {
 	case 1:
-		temp = (temp >> (8 * (where & 0x3))) & 0xff;
+		temp = (temp >>  (8*(where & 0x3))) & 0xff;
 		break;
 	case 2:
-		temp = (temp >> (8 * (where & 0x2))) & 0xffff;
+		temp = (temp >>  (8*(where & 0x2))) & 0xffff;
 		break;
 	default:
 		break;
@@ -201,19 +253,19 @@ static int mv_pci_read_config(struct pci_bus *bus, unsigned int devfn,
 
 	*val = temp;
 
-	DB(pr_info
-	   ("PCI %2d read : (b.d.f) = (%2d,%2d,%2d); reg = %4d: val = 0x%08x\n",
-	    pciIf, bus_num, dev_no, func, regOff, temp));
+	DB(pr_info("cfg read:  bdf %x:%x:%x reg 0x%x val 0x%x size %d\n", bus_num,
+		dev_no, func, regOff, temp, size));
 
 	return 0;
 }
 
 static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
-			       int where, int size, u32 val)
+		int where, int size, u32 val)
 {
 	u32 bus_num, func, regOff, dev_no, temp, mask, shift;
 	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
 	u32 pciIf = sysdata->mv_controller_num;
+	u32 cfgCmd;
 
 	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
 		return 0xFFFFFFFF;
@@ -221,17 +273,12 @@ static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
 	bus_num = bus->number;
 	dev_no = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
-
 	/* total of 12 bits: 8 legacy + 4 extended */
-	regOff =
-	    (MV_U32) where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK);
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK |
+			PXCAR_REAL_EXT_REG_NUM_MASK);
 
-	DB(pr_info
-	   ("PCI %2d write: (b.d.f) = (%2d,%2d,%2d); reg = %4d: val = 0x%08x\n",
-	    pciIf, bus_num, dev_no, func, regOff, val));
 	if (size != 4)
-		temp =
-		    (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+		temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
 	else
 		temp = val;
 
@@ -247,10 +294,40 @@ static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
 	default:
 		shift = 0;
 		mask = 0xffffffff;
+		break;
 	}
 
 	temp = (temp & (~(mask << shift))) | ((val & mask) << shift);
-	mvPexConfigWrite(pciIf, bus_num, dev_no, func, regOff, temp);
+
+	/* Creating PEX address to be passed */
+	cfgCmd  = (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+	/* lgacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+		     PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the read
+	 * transaction we perform a validity check that the address was written
+	 */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf))) {
+		pr_info("Error: mv_pci_write_config failed to write\n");
+		return 1;
+	}
+
+	/* Write the Data passed to the PEX Data register */
+	MV_REG_WRITE(PEX_CFG_DATA_REG(pciIf), temp);
+
+	DB(pr_info("cfg write: bdf %x:%x:%x reg 0x%x val 0x%x size %d\n", bus_num,
+			dev_no, func, regOff, temp, size));
+
 	return 0;
 }
 
@@ -320,7 +397,25 @@ int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
 struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
 {
 	struct pci_bus *bus;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexNextHWInf, ifnum;
+
 	bus = pci_scan_root_bus(NULL, sys->busnr, &mv_pci_ops, sys, &sys->resources);
+
+	/* Set the bus number in the following controller */
+	for (ifnum = (nr+1); ifnum < boardPexInfo->boardPexIfNum; ifnum++) {
+
+		pexNextHWInf = boardPexInfo->pexMapping[ifnum];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexNextHWInf))
+			continue;
+
+		if (MV_TRUE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexNextHWInf)) {
+			mvPexLocalBusNumSet(pexNextHWInf, (bus->subordinate + 1));
+			mvPexLocalDevNumSet(pexNextHWInf, 0x1);
+			break;
+		}
+	}
 	return bus;
 }
 
-- 
1.7.5.4

