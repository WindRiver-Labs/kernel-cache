From 0c06cf1edc19e8e8cf66b8a77ef3af3326fe192e Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Wed, 10 Jul 2013 19:02:38 +0300
Subject: [PATCH 0775/1825] AMC: Introduce basic set of changes to bring-up
 Avanta MC on v3.4.25

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 8d6b1b1aa394963e89b951e7a59fc2dac91a693b

Change-Id: I4ae8886215b92d0dc59002f160230f8649c71f78
Signed-off-by: Zbigniew Bodek <zbb@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/boot/compressed/head.S                    |  122 +++++++++++++++++++-
 arch/arm/boot/compressed/misc.c                    |    2 +
 arch/arm/include/asm/assembler.h                   |    2 +-
 arch/arm/include/asm/cacheflush.h                  |   44 +++++++-
 arch/arm/include/asm/dma-mapping.h                 |   23 ++++-
 arch/arm/include/asm/irqflags.h                    |   17 +++
 arch/arm/include/asm/setup.h                       |    5 +-
 arch/arm/include/asm/string.h                      |    5 +
 arch/arm/kernel/entry-armv.S                       |   40 +++++++
 arch/arm/kernel/setup.c                            |   48 +++++++-
 arch/arm/kernel/vmlinux.lds.S                      |   10 ++
 arch/arm/mach-feroceon-kw2/flashmap.c              |    2 +-
 arch/arm/mach-feroceon-kw2/include/mach/io.h       |    4 +-
 arch/arm/mm/Kconfig                                |    2 +-
 arch/arm/mm/cache-feroceon-l2.c                    |    5 +
 arch/arm/mm/fault-armv.c                           |   69 +++++++++++-
 arch/arm/mm/flush.c                                |   40 +------
 arch/arm/mm/proc-feroceon.S                        |   47 +++++++-
 .../plat-feroceon/mv_drivers_lsp/mv_neta/Kconfig   |   30 +++---
 arch/arm/tools/mach-types                          |    1 +
 drivers/hwmon/Kconfig                              |    7 +
 drivers/i2c/busses/Kconfig                         |    2 +-
 drivers/mmc/card/queue.c                           |    4 +
 drivers/mmc/host/Kconfig                           |    2 +-
 drivers/mtd/Makefile                               |    4 +
 drivers/mtd/maps/Makefile                          |    2 +-
 drivers/pci/setup-bus.c                            |   22 ++++
 drivers/staging/telephony/Makefile                 |    1 +
 drivers/tty/serial/8250/Kconfig                    |    2 +-
 drivers/watchdog/Kconfig                           |    2 +-
 drivers/watchdog/Makefile                          |    3 +
 include/linux/major.h                              |    3 +
 include/linux/telephony.h                          |   49 ++++++++-
 kernel/printk.c                                    |   49 ++++++++
 kernel/sched/core.c                                |    7 +
 kernel/softirq.c                                   |   12 ++
 mm/vmalloc.c                                       |   36 ++++++
 sound/soc/Makefile                                 |    4 +
 38 files changed, 657 insertions(+), 72 deletions(-)

diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 86f7762..d573d87 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -140,6 +140,7 @@ start:
 		.word	_edata			@ zImage end address
  THUMB(		.thumb			)
 1:
+#if !defined(CONFIG_ARCH_FEROCEON)
 #if defined(CONFIG_ARCH_ARMADA_XP) && !defined(CONFIG_MV_AMP_ENABLE)
 
 /* Disable in AMP since in AMP mode the internal register base must match
@@ -162,6 +163,104 @@ start:
 
 		mov	r7, r1			@ save architecture ID
 		mov	r8, r2			@ save atags pointer
+#else /* CONFIG_ARCH_FEROCEON */
+#ifndef CONFIG_MV_DRAM_DEFAULT_ACCESS_CFG
+		b	2f
+internal_regs:	.word 	0xf1000000
+2:		mov	r0, #0
+		mcr	p15, 0, r0, c7, c5, 0	@ invalidate I-Cache
+		mrc 	p15, 0, r0, c1, c0, 0	@ read cr
+		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
+		orr	r0, r0, #0x4		@ D-cache enable
+		mcr 	p15, 0, r0, c1, c0, 0	@ update cr
+
+		ldr	r0, internal_regs
+		add	r5, r0, #0x18000
+		add	r5, r5, #0x200		@ device and vendor ID register(A-MC)
+
+		ldr	r5, [r5]
+		mov	r5, r5, lsr #16
+		mov	r4, #0x6600
+		add	r4, r4, #0x1
+		cmp	r5, r4			@ check for 88F6601 SoC
+		bne	5f
+
+		add	r1, r0, #0x20000	@ mbus ctrl address register
+		add	r2, r1, #0x4		@ mbus base address register
+		add	r3, r0, #0x1500		@ ddr base address register
+		add	r4, r3, #0x4		@ ddr size address register
+		mov	r0, #0
+		ldr     r5, 6f			@ we must run from I-Cache
+		mcr p15,0,r5,c7,c13,1		@ when DRAM window is disabled,
+		ldr     r5, 7f			@ so preloading 2 consective cache
+		mcr p15,0,r5,c7,c13,1		@ lines will do the job.
+
+#ifdef CONFIG_MV_DRAM_XBAR_ACCESS_CFG
+		ldr	r5, [r1]
+		tst	r5, #1
+		bne	5f			@ test if xbar window already enabled
+
+		ldr	r5, [r3]		@ ddr base register value
+		and	r5, r5, #0xff000000	@ extract window base
+		str	r5, [r2]
+
+		ldr	r5, [r4]
+		mov	r5, r5, lsr #16
+		mov	r5, r5, lsl #16		@ extract window size
+		orr	r5, r5, #0x0e00		@ set target id
+		orr	r5, r5, #1		@ set window enable
+		str	r5, [r1]
+		mcr 	p15, 0, r0, c7, c10, 4	@ drain write-buffer
+
+3:		ldr	r5, [r1]
+		tst	r5, #1
+		beq	3b
+
+		ldr	r5, [r4]
+6:		bic	r5, r5, #1
+		.align 5
+7:		str	r5, [r4]
+
+4:		ldr	r5, [r4]
+		tst	r5, #1
+		bne	4b
+#else
+		ldr	r5, [r4]
+		tst	r5, #1
+		bne	5f			@ test if ddr window already enabled
+
+		ldr	r5, [r2]		@ ddr base register value
+		and	r5, r5, #0xff000000	@ extract window base
+		str	r5, [r3]
+
+		ldr	r5, [r1]
+		mov	r5, r5, lsr #16
+		mov	r5, r5, lsl #16		@ extract window size
+		orr	r5, r5, #1		@ set window enable
+		str	r5, [r4]
+		mcr 	p15, 0, r0, c7, c10, 4	@ drain write-buffer
+
+3:		ldr	r5, [r4]
+		tst	r5, #1
+		beq	3b
+
+		ldr	r5, [r1]
+6:		bic	r5, r5, #1
+		.align 5
+7:		str	r5, [r1]
+
+4:		ldr	r5, [r1]
+		tst	r5, #1
+		bne	4b
+#endif
+5:		mcr 	p15, 0, r0, c7, c10, 4	@ drain write-buffer
+		mrc 	p15, 0, r0, c1, c0, 0	@ read cr
+		bic	r0, r0, #0x5000		@ disable I-cache and RR cache replacement
+		bic	r0, r0, #0x4		@ disable D-cache
+		mcr 	p15, 0, r0, c1, c0, 0	@ update cr
+#endif
+
+#endif /* !CONFIG_ARCH_FEROCEON */
 
 #ifndef __ARM_ARCH_2__
 		/*
@@ -654,6 +753,18 @@ __armv4_mmu_cache_on:
 #ifdef CONFIG_MMU
 		mov	r6, #CB_BITS | 0x12	@ U
 		bl	__setup_mmu
+#ifdef CONFIG_CACHE_FEROCEON_L2
+		/* Cancel L2 prefetch */
+		mrc	p15, 1, r0, c15, c1, 0	@ Read r15 register
+		orr	r0, #0x01000000		@ No prefetching
+		mcr	p15, 1, r0, c15, c1, 0	@ Write r15 register
+/*
+ * In this step, the I/DCaches are closed, but L2 cache might be present
+ * containing valid data (from u-boot). We do not assume u-boot invalidates L2,
+ * so we do it ourselves
+ */
+		mcr	p15, 1, r0, c15, c11, 0	@ Invalidate whole L2
+#endif
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
 		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
@@ -1186,10 +1297,19 @@ no_cache_id:
  THUMB(		add     r1, r1, r11		)
 		teq	r1, r2
 		bne	1b
-
+#ifdef CONFIG_ARCH_FEROCEON
+		/* 4 way cache, load of new cache lines won't be enough. */
+2:		mrc	p15, 0, r15, c7, c14, 3	@ test,clean,invalidate
+		bne	2b
+#endif
 		mcr	p15, 0, r1, c7, c5, 0	@ flush I cache
 		mcr	p15, 0, r1, c7, c6, 0	@ flush D cache
 		mcr	p15, 0, r1, c7, c10, 4	@ drain WB
+#ifdef CONFIG_CACHE_FEROCEON_L2
+		mcr	p15, 1, r1, c15, c9, 0	@ clean entire L2 cache
+		mcr	p15, 1, r1, c15, c11, 0	@ Invalidate entire L2 cache
+		mcr	p15, 0, r1, c7, c10, 4	@ drain WB
+#endif
 		mov	pc, lr
 
 __armv3_mmu_cache_flush:
diff --git a/arch/arm/boot/compressed/misc.c b/arch/arm/boot/compressed/misc.c
index 8e2a8fc..2f6c479 100644
--- a/arch/arm/boot/compressed/misc.c
+++ b/arch/arm/boot/compressed/misc.c
@@ -83,6 +83,7 @@ static void icedcc_putc(int ch)
 #define putc(ch)	icedcc_putc(ch)
 #endif
 
+#ifndef CONFIG_ARCH_FEROCEON
 static void putstr(const char *ptr)
 {
 	char c;
@@ -95,6 +96,7 @@ static void putstr(const char *ptr)
 
 	flush();
 }
+#endif
 
 /*
  * gzip declarations
diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h
index 486d2c8..1881429 100644
--- a/arch/arm/include/asm/assembler.h
+++ b/arch/arm/include/asm/assembler.h
@@ -70,7 +70,7 @@
  *
  * On Feroceon there is much to gain however, regardless of cache mode.
  */
-#ifdef CONFIG_CPU_FEROCEON
+#if defined(CONFIG_CPU_FEROCEON) || defined(CONFIG_ARCH_FEROCEON)
 #define CALGN(code...) code
 #else
 #define CALGN(code...)
diff --git a/arch/arm/include/asm/cacheflush.h b/arch/arm/include/asm/cacheflush.h
index 07ea497..d0b0289 100644
--- a/arch/arm/include/asm/cacheflush.h
+++ b/arch/arm/include/asm/cacheflush.h
@@ -110,6 +110,27 @@ struct cpu_cache_fns {
 	void (*dma_flush_range)(const void *, const void *);
 };
 
+#ifdef CONFIG_MV_XOR_NET_DMA
+/*
+ * Clean and Invalidate L1 cache w/o dsb()
+ * The call is intended for multiple calls and when dsb() on commit endpoint
+ * HW would align addresses. If 'end' was already aligned, put it
+ * one cacheline up.
+ */
+static inline void flush_user_range_fast(unsigned long start,
+					 unsigned long end, unsigned int vmflags)
+{
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	__asm__("mcr p15, 5, %0, c15, c15, 0" : : "r" (start));
+	__asm__("mcr p15, 5, %0, c15, c15, 1" : : "r" (end-1));
+	raw_local_irq_restore(flags);
+
+	/* dsb();*/
+}
+#endif
+
 /*
  * Select the calling method
  */
@@ -319,7 +340,28 @@ static inline void flush_anon_page(struct vm_area_struct *vma,
 }
 
 #define ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
-extern void flush_kernel_dcache_page(struct page *);
+#ifdef CONFIG_ARCH_FEROCEON
+static inline void flush_kernel_dcache_page(struct page *page)
+{
+	/* highmem pages are always flushed upon kunmap already */
+	if ((cache_is_vivt() || cache_is_vipt_aliasing()) && !PageHighMem(page))
+		__cpuc_flush_dcache_area(page_address(page), PAGE_SIZE);
+}
+static inline void flush_kernel_dcache_addr(void *addr)
+{
+	if ((cache_is_vivt() || cache_is_vipt_aliasing()))
+		__cpuc_flush_dcache_area(addr, PAGE_SIZE);
+}
+static inline void invalidate_kernel_dcache_addr(void *addr)
+{
+	if ((cache_is_vivt() || cache_is_vipt_aliasing()))
+		__cpuc_flush_dcache_area(addr, PAGE_SIZE);
+}
+#else
+static inline void flush_kernel_dcache_page(struct page *page)
+{
+}
+#endif
 
 #define flush_dcache_mmap_lock(mapping) \
 	spin_lock_irq(&(mapping)->tree_lock)
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index b5745a8..0842c88 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -216,6 +216,27 @@ extern void __init init_dma_coherent_pool_size(unsigned long size);
  */
 static inline void init_consistent_dma_size(unsigned long size) { }
 
+#ifdef	CONFIG_MV_SP_I_FTCH_DB_INV
+extern void mv_l2_inv_range(const void *start, const void *end);
+static inline void mv_l2_sync(const void *start, size_t size, int direction)
+{
+	const void *end = start + size;
+
+	BUG_ON(!virt_addr_valid(start) || !virt_addr_valid(end - 1));
+
+	switch (direction) {
+	case DMA_FROM_DEVICE:		/*  */
+	case DMA_BIDIRECTIONAL:		/*  */
+		mv_l2_inv_range(start, end);
+		break;
+	case DMA_TO_DEVICE:		/* */
+		break;
+	default:
+		BUG();
+	}
+}
+#endif
+
 /*
  * For SA-1111, IXP425, and ADI systems  the dma-mapping functions are "magic"
  * and utilize bounce buffers as needed to work around limited DMA windows.
@@ -255,8 +276,6 @@ extern int dmabounce_register_dev(struct device *, unsigned long,
  */
 extern void dmabounce_unregister_dev(struct device *);
 
-
-
 /*
  * The scatter list versions of the above methods.
  */
diff --git a/arch/arm/include/asm/irqflags.h b/arch/arm/include/asm/irqflags.h
index 1e6cca5..06375eb 100644
--- a/arch/arm/include/asm/irqflags.h
+++ b/arch/arm/include/asm/irqflags.h
@@ -123,6 +123,23 @@ static inline void arch_local_irq_disable(void)
 #endif
 
 /*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define raw_local_irq_fiq_save(x)			\
+	({						\
+	unsigned long temp;				\
+	(void) (&temp == &x);				\
+	__asm__ __volatile__(					\
+	"	mrs	%0, cpsr	@ local_irq_fiq_save\n"	\
+	"	orr	%1, %0, #0xC0\n"			\
+	"	msr	cpsr_c, %1"				\
+	: "=r" (x), "=r" (temp)				\
+	:						\
+	: "memory", "cc");				\
+	})
+
+
+/*
  * Save the current interrupt enable state.
  */
 static inline unsigned long arch_local_save_flags(void)
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index a574257..69dcefa 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -168,7 +168,10 @@ struct tag_mv_uboot {
 #if defined (CONFIG_ARCH_ARMADA370)
 	__u32 bit_mask_config;
 #endif
-};                     
+#if defined(CONFIG_ARCH_FEROCEON_KW2)
+	__u32 mod_bitmask;
+#endif
+};
 
 struct tag {
 	struct tag_header hdr;
diff --git a/arch/arm/include/asm/string.h b/arch/arm/include/asm/string.h
index cf4f3aa..4b8ddcd 100644
--- a/arch/arm/include/asm/string.h
+++ b/arch/arm/include/asm/string.h
@@ -13,6 +13,11 @@ extern char * strrchr(const char * s, int c);
 extern char * strchr(const char * s, int c);
 
 #define __HAVE_ARCH_MEMCPY
+
+#if defined(CONFIG_MV_XOR_MEMCOPY) || defined(CONFIG_MV_IDMA_MEMCOPY)
+extern void *asm_memcpy(void *, const void *, __kernel_size_t);
+#endif
+
 extern void * memcpy(void *, const void *, __kernel_size_t);
 
 #define __HAVE_ARCH_MEMMOVE
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 69c75b2..f3ee506 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -1170,8 +1170,48 @@ __stubs_start:
  * other mode than FIQ...  Ok you can switch to another mode, but you can't
  * get out of that mode without clobbering one register.
  */
+#ifdef CONFIG_ARCH_FEROCEON
 vector_fiq:
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	/* if no handler installed, bail out */
+	ldr	r9, 1f
+	ldr	r9, [r9]
+	movs	r9, r9
+	beq	fiq_ret
+
+	/* count fiq exceptions */
+	ldr	r11, 2f
+	ldr	r10, [r11]
+	add	r10, r10, #1
+	str	r10, [r11]
+
+	/* call C-language ISR */
+	stmdb	sp!, {r0-r7,r14}
+	mov	lr, pc
+	mov	pc, r9
+	ldmia	sp!, {r0-r7,r14}
+fiq_ret:
+	subs	pc, lr, #4
+
+1:	.long fiq_userptr
+2:	.long fiq_cnt
+
+.section .text
+.globl fiq_userptr
+fiq_userptr:
+	.long 0
+.globl fiq_cnt
+fiq_cnt:
+	.long 0
+.previous
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+	disable_fiq
 	subs	pc, lr, #4
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+#else /* !CONFIG_ARCH_FEROCEON */
+vector_fiq:
+	subs	pc, lr, #4
+#endif
 
 /*=============================================================================
  * Address exception handler
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d870e05..69ed77ff 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -133,6 +133,9 @@ struct stack {
 	u32 irq[3];
 	u32 abt[3];
 	u32 und[3];
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	u32 fiq[4 * 1024];
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 } ____cacheline_aligned;
 
 static struct stack stacks[NR_CPUS];
@@ -385,6 +388,18 @@ void cpu_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct stack *stk = &stacks[cpu];
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	/*
+	 * The add instruction with immediate addressing mode has
+	 * limited offset of 1024 words (2^12-1 bytes):
+	 *	add "r" (stk), "I" (offsetof(struct stack, und[0]))
+	 * Hence, 'mov Rd, Rn' should be used with preloaded Rn.
+	 */
+	unsigned int irq_sp = (unsigned int)&stk->irq[0];
+	unsigned int abt_sp = (unsigned int)&stk->abt[0];
+	unsigned int und_sp = (unsigned int)&stk->und[0];
+	unsigned int fiq_sp = (unsigned int)&stk->fiq[4095];
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 
 	if (cpu >= NR_CPUS) {
 		printk(KERN_CRIT "CPU%u: bad primary CPU number\n", cpu);
@@ -406,6 +421,30 @@ void cpu_init(void)
 	/*
 	 * setup stacks for re-entrant exception handlers
 	 */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	__asm__ (
+	"msr	cpsr_c, %1\n\t"
+	"mov	sp, %2\n\t"
+	"msr	cpsr_c, %3\n\t"
+	"mov	sp, %4\n\t"
+	"msr	cpsr_c, %5\n\t"
+	"mov	sp, %6\n\t"
+	"msr	cpsr_c, %7\n\t"
+	"mov	sp, %8\n\t"
+	"msr	cpsr_c, %9"
+	    :
+	    : "r" (stk),
+	      PLC(PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      "r" (irq_sp),
+	      PLC(PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      "r" (abt_sp),
+	      PLC(PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      "r" (und_sp),
+	      PLC(PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "r" (fiq_sp),
+	      PLC(PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	    : "r14");
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	__asm__ (
 	"msr	cpsr_c, %1\n\t"
 	"add	r14, %0, %2\n\t"
@@ -419,14 +458,15 @@ void cpu_init(void)
 	"msr	cpsr_c, %7"
 	    :
 	    : "r" (stk),
-	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      PLC(PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
 	      "I" (offsetof(struct stack, irq[0])),
-	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      PLC(PSR_F_BIT | PSR_I_BIT | ABT_MODE),
 	      "I" (offsetof(struct stack, abt[0])),
-	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      PLC(PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
-	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	      PLC(PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 }
 
 int __cpu_logical_map[NR_CPUS];
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 43a31fb..3409a12 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -96,6 +96,16 @@ SECTIONS
 			*(.exception.text)
 			__exception_text_end = .;
 			IRQENTRY_TEXT
+#ifdef CONFIG_ARCH_FEROCEON
+			/*
+			 * Then all the functions that are "hot" in profiles,
+			 * to group them onto the same hugetlb entry
+			 */
+
+			#include "functionlist"
+
+			/* Then the rest */
+#endif
 			TEXT_TEXT
 			SCHED_TEXT
 			LOCK_TEXT
diff --git a/arch/arm/mach-feroceon-kw2/flashmap.c b/arch/arm/mach-feroceon-kw2/flashmap.c
index f9c7a66..dc71849 100644
--- a/arch/arm/mach-feroceon-kw2/flashmap.c
+++ b/arch/arm/mach-feroceon-kw2/flashmap.c
@@ -194,7 +194,7 @@ static int flashProbe(char ** mtdDrv, struct map_info * map, struct mtd_info **
 			(*mtd)->owner = THIS_MODULE;
 
 #ifdef CONFIG_MTD_CMDLINE_PARTS
-			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0, "");
+			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0);
 
 			if (mtd_parts_nb > 0)
 			{
diff --git a/arch/arm/mach-feroceon-kw2/include/mach/io.h b/arch/arm/mach-feroceon-kw2/include/mach/io.h
index 8fcc6b3..623da5d 100644
--- a/arch/arm/mach-feroceon-kw2/include/mach/io.h
+++ b/arch/arm/mach-feroceon-kw2/include/mach/io.h
@@ -19,8 +19,10 @@
 /*#define IO_SPACE_LIMIT 0xffffffff*/
 #define IO_SPACE_REMAP 0xf2000000
 
-/*#define __io(a)			(a + IO_SPACE_REMAP)*/
+#define __io(a)			(a + IO_SPACE_REMAP)
 #define __mem_pci(a)		((unsigned long)(a))
 #define __mem_isa(a)		(a)
 
+#define dma_io_sync() do { } while (0)
+
 #endif
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index eae9c6c..5e837f9 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -853,7 +853,7 @@ config OUTER_CACHE_SYNC
 
 config CACHE_FEROCEON_L2
 	bool "Enable the Feroceon L2 cache controller"
-	depends on ARCH_KIRKWOOD || ARCH_MV78XX0
+	depends on ARCH_KIRKWOOD || ARCH_MV78XX0 || ARCH_FEROCEON_KW || ARCH_FEROCEON_KW2
 	default y
 	select OUTER_CACHE
 	help
diff --git a/arch/arm/mm/cache-feroceon-l2.c b/arch/arm/mm/cache-feroceon-l2.c
index b4e2ebb..7e375e0 100644
--- a/arch/arm/mm/cache-feroceon-l2.c
+++ b/arch/arm/mm/cache-feroceon-l2.c
@@ -18,6 +18,11 @@
 #include <asm/cp15.h>
 #include <plat/cache-feroceon-l2.h>
 
+#ifdef CONFIG_ARCH_FEROCEON
+#undef raw_local_irq_save
+#define raw_local_irq_save(flags)	raw_local_irq_fiq_save(flags)
+#endif
+
 /*
  * Low-level cache maintenance operations.
  *
diff --git a/arch/arm/mm/fault-armv.c b/arch/arm/mm/fault-armv.c
index 7599e26..4310728 100644
--- a/arch/arm/mm/fault-armv.c
+++ b/arch/arm/mm/fault-armv.c
@@ -37,8 +37,13 @@ static pteval_t shared_pte_mask = L_PTE_MT_BUFFERABLE;
  * Therefore those configurations which might call adjust_pte (those
  * without CONFIG_CPU_CACHE_VIPT) cannot support split page_table_lock.
  */
+#ifdef CONFIG_ARCH_FEROCEON
+static int do_adjust_pte(struct vm_area_struct *vma, unsigned long address,
+	unsigned long pfn, pte_t *ptep, int update, int only_shared)
+#else
 static int do_adjust_pte(struct vm_area_struct *vma, unsigned long address,
 	unsigned long pfn, pte_t *ptep)
+#endif
 {
 	pte_t entry = *ptep;
 	int ret;
@@ -52,7 +57,12 @@ static int do_adjust_pte(struct vm_area_struct *vma, unsigned long address,
 	 * If this page isn't present, or is already setup to
 	 * fault (ie, is old), we can safely ignore any issues.
 	 */
+#ifdef CONFIG_ARCH_FEROCEON
+	if (ret && (pte_val(entry) & L_PTE_MT_MASK) !=
+	    shared_pte_mask && update) {
+#else
 	if (ret && (pte_val(entry) & L_PTE_MT_MASK) != shared_pte_mask) {
+#endif
 		flush_cache_page(vma, address, pfn);
 		outer_flush_range((pfn << PAGE_SHIFT),
 				  (pfn << PAGE_SHIFT) + PAGE_SIZE);
@@ -61,6 +71,10 @@ static int do_adjust_pte(struct vm_area_struct *vma, unsigned long address,
 		set_pte_at(vma->vm_mm, address, ptep, entry);
 		flush_tlb_page(vma, address);
 	}
+#ifdef CONFIG_ARCH_FEROCEON
+	if (only_shared && (pte_val(entry) & L_PTE_MT_MASK) != shared_pte_mask)
+		ret = 0;
+#endif
 
 	return ret;
 }
@@ -89,8 +103,13 @@ static inline void do_pte_lock(spinlock_t *ptl) {}
 static inline void do_pte_unlock(spinlock_t *ptl) {}
 #endif /* USE_SPLIT_PTLOCKS */
 
+#ifdef CONFIG_ARCH_FEROCEON
+static int adjust_pte(struct vm_area_struct *vma, unsigned long address,
+	unsigned long pfn, int update, int only_shared)
+#else
 static int adjust_pte(struct vm_area_struct *vma, unsigned long address,
 	unsigned long pfn)
+#endif
 {
 	spinlock_t *ptl;
 	pgd_t *pgd;
@@ -119,8 +138,11 @@ static int adjust_pte(struct vm_area_struct *vma, unsigned long address,
 	ptl = pte_lockptr(vma->vm_mm, pmd);
 	pte = pte_offset_map(pmd, address);
 	do_pte_lock(ptl);
-
+#ifdef CONFIG_ARCH_FEROCEON
+	ret = do_adjust_pte(vma, address, pfn, pte, update, only_shared);
+#else
 	ret = do_adjust_pte(vma, address, pfn, pte);
+#endif
 
 	do_pte_unlock(ptl);
 	pte_unmap(pte);
@@ -138,6 +160,9 @@ make_coherent(struct address_space *mapping, struct vm_area_struct *vma,
 	unsigned long offset;
 	pgoff_t pgoff;
 	int aliases = 0;
+#ifdef CONFIG_ARM_ARMV5_L2_CACHE_COHERENCY_FIX
+	int run;
+#endif
 
 	pgoff = vma->vm_pgoff + ((addr - vma->vm_start) >> PAGE_SHIFT);
 
@@ -147,6 +172,39 @@ make_coherent(struct address_space *mapping, struct vm_area_struct *vma,
 	 * cache coherency.
 	 */
 	flush_dcache_mmap_lock(mapping);
+#ifdef CONFIG_ARM_ARMV5_L2_CACHE_COHERENCY_FIX
+	/*
+	 * In the first run we just check if we have to make some
+	 * address space uncacheable because of L1 VIVT. In the second
+	 * we check if there is an uncached map in other processes.  If
+	 * one of the previous condition is true we proceed to make
+	 * *all* (both in current process VMA and that of others) of
+	 * them so. This should solve both cases of multiple shared
+	 * memories attached in the same process but not impact the
+	 * common case of just one mapping per process.
+	 */
+	for (run = 0; run < 3; run++) {
+		vma_prio_tree_foreach(mpnt, &iter, &mapping->i_mmap,
+				pgoff, pgoff) {
+			if ((mpnt->vm_mm != mm || mpnt == vma) && run == 0)
+				continue;
+			if (!(mpnt->vm_flags & VM_MAYSHARE) &&
+				run != 2) /* update all mappings */
+				continue;
+			offset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;
+			aliases += adjust_pte(mpnt, mpnt->vm_start + offset, pfn,
+					/* update only on the last run */
+					run == 2,
+					/*
+					 * on the second run
+					 * catch shared in other procs
+					 */
+					run == 1);
+		}
+		if (aliases == 0 && run == 1)
+			break;
+	}
+#else
 	vma_prio_tree_foreach(mpnt, &iter, &mapping->i_mmap, pgoff, pgoff) {
 		/*
 		 * If this VMA is not in our MM, we can ignore it.
@@ -158,11 +216,20 @@ make_coherent(struct address_space *mapping, struct vm_area_struct *vma,
 		if (!(mpnt->vm_flags & VM_MAYSHARE))
 			continue;
 		offset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;
+#ifdef CONFIG_ARCH_FEROCEON
+		aliases += adjust_pte(mpnt, mpnt->vm_start + offset, pfn, 1, 0);
+#else
 		aliases += adjust_pte(mpnt, mpnt->vm_start + offset, pfn);
+#endif
 	}
+#endif
 	flush_dcache_mmap_unlock(mapping);
 	if (aliases)
+#ifdef CONFIG_ARCH_FEROCEON
+		do_adjust_pte(vma, addr, pfn, ptep, 1, 0);
+#else
 		do_adjust_pte(vma, addr, pfn, ptep);
+#endif
 }
 
 /*
diff --git a/arch/arm/mm/flush.c b/arch/arm/mm/flush.c
index 8f0d285..7b8ed61 100644
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -294,42 +294,16 @@ void flush_dcache_page(struct page *page)
 		else if (mapping)
 			__flush_icache_all();
 		set_bit(PG_dcache_clean, &page->flags);
-	}
-}
-EXPORT_SYMBOL(flush_dcache_page);
-
-/*
- * Ensure cache coherency for the kernel mapping of this page. We can
- * assume that the page is pinned via kmap.
- *
- * If the page only exists in the page cache and there are no user
- * space mappings, this is a no-op since the page was already marked
- * dirty at creation.  Otherwise, we need to flush the dirty kernel
- * cache lines directly.
- */
-void flush_kernel_dcache_page(struct page *page)
-{
-	if (cache_is_vivt() || cache_is_vipt_aliasing()) {
-		struct address_space *mapping;
-
-		mapping = page_mapping(page);
-
-		if (!mapping || mapping_mapped(mapping)) {
-			void *addr;
-
-			addr = page_address(page);
-			/*
-			 * kmap_atomic() doesn't set the page virtual
-			 * address for highmem pages, and
-			 * kunmap_atomic() takes care of cache
-			 * flushing already.
-			 */
-			if (!IS_ENABLED(CONFIG_HIGHMEM) || addr)
-				__cpuc_flush_dcache_area(addr, PAGE_SIZE);
+#ifdef CONFIG_ARM_ARMV5_L2_CACHE_COHERENCY_FIX
+		{
+			unsigned long pfn = page_to_pfn(page);
+			outer_flush_range((pfn << PAGE_SHIFT),
+				(pfn << PAGE_SHIFT) + PAGE_SIZE);
 		}
+#endif
 	}
 }
-EXPORT_SYMBOL(flush_kernel_dcache_page);
+EXPORT_SYMBOL(flush_dcache_page);
 
 /*
  * Flush an anonymous page so that users of get_user_pages()
diff --git a/arch/arm/mm/proc-feroceon.S b/arch/arm/mm/proc-feroceon.S
index 12996f2..8706bbd 100644
--- a/arch/arm/mm/proc-feroceon.S
+++ b/arch/arm/mm/proc-feroceon.S
@@ -29,6 +29,10 @@
 #include <asm/ptrace.h>
 #include "proc-macros.S"
 
+#ifdef CONFIG_ARCH_FEROCEON
+#include <mach/kw_macro.h>
+#endif
+
 /*
  * This is the maximum size of an area which will be invalidated
  * using the single invalidate entry instructions.  Anything larger
@@ -54,6 +58,40 @@ __cache_params:
 	.word	__cache_params_loc
 
 /*
+ *      mv_l2_inv_range(start, end)
+ *
+ *      Invalidate (discard) the specified virtual address range on L2.
+ *      May not write back any entries.  If 'start' or 'end'
+ *      are not cache line aligned, those lines must be written
+ *      back.
+ *
+ *      - start - virtual start address
+ *      - end   - virtual end address
+ *
+ */
+#ifdef CONFIG_CACHE_FEROCEON_L2
+ENTRY(mv_l2_inv_range)
+#ifndef CONFIG_CPU_L2_DCACHE_WRITETHROUGH
+	tst	r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 1, r0, c15, c9, 1		@ clean L2 entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 1, r1, c15, c9, 1		@ clean L2 entry
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+#endif
+	cmp	r1, r0
+	subne	r1, r1, #1			@ Prevent cleaning of top address
+						@ cache line when top is cache line aligned
+	mrs	r2, cpsr
+	orr	r3, r2, #PSR_F_BIT | PSR_I_BIT
+	msr	cpsr_c, r3			@ Disable interrupts
+	mcr	p15, 1, r0, c15, c11, 4		@ L2 invalidation zone start addr
+	mcr	p15, 1, r1, c15, c11, 5		@ L2 invalidation zone end addr and
+						@ invalidate procedure trigger
+	msr	cpsr_c, r2			@ Restore interrupts
+	mov	pc, lr
+#endif
+
+/*
  * cpu_feroceon_proc_init()
  */
 ENTRY(cpu_feroceon_proc_init)
@@ -275,7 +313,7 @@ ENTRY(feroceon_flush_kern_dcache_area)
 ENTRY(feroceon_range_flush_kern_dcache_area)
 	mrs	r2, cpsr
 	add	r1, r0, #PAGE_SZ - CACHE_DLINESIZE	@ top addr is inclusive
-	orr	r3, r2, #PSR_I_BIT
+	orr	r3, r2, #PSR_I_BIT | PSR_F_BIT
 	msr	cpsr_c, r3			@ disable interrupts
 	mcr	p15, 5, r0, c15, c15, 0		@ D clean/inv range start
 	mcr	p15, 5, r1, c15, c15, 1		@ D clean/inv range top
@@ -321,7 +359,7 @@ feroceon_range_dma_inv_range:
 	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
 	cmp	r1, r0
 	subne	r1, r1, #1			@ top address is inclusive
-	orr	r3, r2, #PSR_I_BIT
+	orr	r3, r2, #PSR_I_BIT | PSR_F_BIT
 	msr	cpsr_c, r3			@ disable interrupts
 	mcr	p15, 5, r0, c15, c14, 0		@ D inv range start
 	mcr	p15, 5, r1, c15, c14, 1		@ D inv range top
@@ -353,7 +391,7 @@ feroceon_range_dma_clean_range:
 	mrs	r2, cpsr
 	cmp	r1, r0
 	subne	r1, r1, #1			@ top address is inclusive
-	orr	r3, r2, #PSR_I_BIT
+	orr	r3, r2, #PSR_I_BIT | PSR_F_BIT
 	msr	cpsr_c, r3			@ disable interrupts
 	mcr	p15, 5, r0, c15, c13, 0		@ D clean range start
 	mcr	p15, 5, r1, c15, c13, 1		@ D clean range top
@@ -384,7 +422,8 @@ ENTRY(feroceon_range_dma_flush_range)
 	mrs	r2, cpsr
 	cmp	r1, r0
 	subne	r1, r1, #1			@ top address is inclusive
-	orr	r3, r2, #PSR_I_BIT
+	orr	r3, r2, #PSR_I_BIT | PSR_F_BIT
+	msr	cpsr_c, r3
 	msr	cpsr_c, r3			@ disable interrupts
 	mcr	p15, 5, r0, c15, c15, 0		@ D clean/inv range start
 	mcr	p15, 5, r1, c15, c15, 1		@ D clean/inv range top
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/Kconfig b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/Kconfig
index ccef94c..9aea0de 100644
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/Kconfig
+++ b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/Kconfig
@@ -535,21 +535,21 @@ config  NET_SKB_HEADROOM
         ---help---
           Customize SKB headroom size. Must be power of 2.
 
-config NET_SKB_RECYCLE
-        bool "Skb recycle"
-        default y
-        ---help---
-          Work-in-progress and experimental.
-
-          This option enables skb's to be returned via a callback at kfree to
-          the allocator to make a fastpath for very skb consuming network
-          applications.
-
-config NET_SKB_RECYCLE_DEF
-        depends on NET_SKB_RECYCLE
-        int "Default value for SKB recycle:  0 - disable, 1 - enable"
-        default 1
-        ---help---
+#config NET_SKB_RECYCLE
+#        bool "Skb recycle"
+#        default y
+#        ---help---
+#          Work-in-progress and experimental.
+#
+#          This option enables skb's to be returned via a callback at kfree to
+#          the allocator to make a fastpath for very skb consuming network
+#          applications.
+#
+#config NET_SKB_RECYCLE_DEF
+#        depends on NET_SKB_RECYCLE
+#        int "Default value for SKB recycle:  0 - disable, 1 - enable"
+#        default 1
+#        ---help---
 
 config  MV_ETH_TX_DONE_TIMER_PERIOD
         int "Periodical Tx Done timer period"
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 329a027..afbcda2 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -121,6 +121,7 @@ avila			MACH_AVILA		AVILA			526
 xcat98dx		MACH_XCAT98DX		XCAT98DX		527
 armada_xp_fpga		MACH_ARMADA_XP_FPGA	ARMADA_XP_FPGA		528
 avanta_lp		MACH_AVANTA_LP		AVANTA_LP		529
+feroceon_kw2		ARCH_FEROCEON_KW2	FEROCEON_KW2		529
 edb9302			MACH_EDB9302		EDB9302			538
 husky			MACH_HUSKY		HUSKY			543
 shepherd		MACH_SHEPHERD		SHEPHERD		545
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index e01a71a..1b669d7 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -221,6 +221,13 @@ config SENSORS_ADT7475
 	  This driver can also be build as a module.  If so, the module
 	  will be called adt7475.
 
+config THERMAL_SENSOR_KW2
+	bool "KW2 Thermal Sensor"
+	default y
+	help
+	  This driver provides support for the Marvell Kirkwood 2
+	  Thermal Sensor.
+
 config SENSORS_ALP
 	tristate "Avanta LP SoC Thermal Sensor"
 	depends on ARCH_AVANTA_LP
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 6d228e5..ea4c125 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -492,7 +492,7 @@ config I2C_MPC
 
 config I2C_MV64XXX
 	tristate "Marvell mv64xxx I2C Controller"
-	depends on (MV64X60 || PLAT_ORION || PLAT_ARMADA) && EXPERIMENTAL
+	depends on (MV64X60 || PLAT_ORION || PLAT_ARMADA || MV88F6500) && EXPERIMENTAL
 	help
 	  If you say yes to this option, support will be included for the
 	  built-in I2C interface on the Marvell 64xxx line of host bridges.
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 996f8e3..8ed391a 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -20,7 +20,11 @@
 #include <linux/mmc/host.h>
 #include "queue.h"
 
+#ifdef CONFIG_ARCH_FEROCEON
+#define MMC_QUEUE_BOUNCESZ	(65536 << 2)
+#else
 #define MMC_QUEUE_BOUNCESZ	65536
+#endif
 
 #define MMC_QUEUE_SUSPENDED	(1 << 0)
 
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 13d4ee2..b4a4f3c 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -352,7 +352,7 @@ config MMC_TIFM_SD
 
 config MMC_MVSDIO
 	tristate "Marvell MMC/SD/SDIO host driver"
-	depends on PLAT_ORION || PLAT_ARMADA
+	depends on PLAT_ORION || PLAT_ARMADA || ARCH_FEROCEON
 	---help---
 	  This selects the Marvell SDIO host driver.
 	  SDIO may currently be found on the Kirkwood 88F6281 and 88F6192
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index 8dfb927..3ba2ec4 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -37,3 +37,7 @@ obj-$(CONFIG_MTD_UBI)		+= ubi/
 ifeq ($(CONFIG_PLAT_ARMADA),y)
 obj-$(CONFIG_MTD)		+= ../../arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/
 endif
+
+ifeq ($(CONFIG_ARCH_FEROCEON),y)
+obj-$(CONFIG_MV_FLASH_CTRL)     += ../../arch/arm/plat-feroceon/mv_drivers_lsp/mv_mtd/
+endif
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index e9840b7..38a15a0 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -58,7 +58,7 @@ obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
 obj-$(CONFIG_MTD_LATCH_ADDR)	+= latch-addr-flash.o
 obj-$(CONFIG_MTD_LANTIQ)	+= lantiq-flash.o
 
-ifeq ($(CONFIG_PLAT_ARMADA),y)
+ifeq (,$(filter $(y), $(CONFIG_PLAT_ARMADA) $(CONFIG_ARCH_FEROCEON)))
 ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
 	include $(srctree)/$(MACHINE)/config/mvRules.mk
 	obj-$(CONFIG_MV_INCLUDE_SPI) += ../../../$(MACHINE)/flashmap.o
diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c
index 8fa2d4b..8b15b2d 100644
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -470,6 +470,10 @@ static void pci_setup_bridge_io(struct pci_bus *bus)
 	struct resource *res;
 	struct pci_bus_region region;
 	u32 l, io_upper16;
+#ifdef CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT
+	u16 flags = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
+	u16 cmd, old_cmd;
+#endif
 
 	/* Set up the top and bottom of the PCI I/O segment for this bus. */
 	res = bus->resource[0];
@@ -486,6 +490,9 @@ static void pci_setup_bridge_io(struct pci_bus *bus)
 		/* Clear upper 16 bits of I/O base/limit. */
 		io_upper16 = 0;
 		l = 0x00f0;
+#ifdef CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT
+		flags &= ~PCI_COMMAND_IO;
+#endif
 	}
 	/* Temporarily disable the I/O range before updating PCI_IO_BASE. */
 	pci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, 0x0000ffff);
@@ -511,6 +518,9 @@ static void pci_setup_bridge_mmio(struct pci_bus *bus)
 		dev_info(&bridge->dev, "  bridge window %pR\n", res);
 	} else {
 		l = 0x0000fff0;
+#ifdef CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT
+		flags &= ~PCI_COMMAND_MEMORY;
+#endif
 	}
 	pci_write_config_dword(bridge, PCI_MEMORY_BASE, l);
 }
@@ -566,6 +576,18 @@ static void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)
 		pci_setup_bridge_mmio_pref(bus);
 
 	pci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);
+#ifdef CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT
+	if (flags) {
+		pci_read_config_word(bridge, PCI_COMMAND, &old_cmd);
+		cmd  = old_cmd | (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+		if (cmd != old_cmd) {
+			pr_info("PCI: enabling bridge %s (%04x -> %04x)\n",
+			       pci_name(bridge), old_cmd, cmd);
+			pci_write_config_word(bridge, PCI_COMMAND, cmd);
+		}
+		pci_set_master(bridge);
+	}
+#endif
 }
 
 void pci_setup_bridge(struct pci_bus *bus)
diff --git a/drivers/staging/telephony/Makefile b/drivers/staging/telephony/Makefile
index 1206615..5e45cb5 100644
--- a/drivers/staging/telephony/Makefile
+++ b/drivers/staging/telephony/Makefile
@@ -5,3 +5,4 @@
 obj-$(CONFIG_PHONE) += phonedev.o
 obj-$(CONFIG_PHONE_IXJ) += ixj.o
 obj-$(CONFIG_PHONE_IXJ_PCMCIA) += ixj_pcmcia.o
+obj-$(CONFIG_MV_PHONE) += ../../../arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/
diff --git a/drivers/tty/serial/8250/Kconfig b/drivers/tty/serial/8250/Kconfig
index 2473309..a24f2d7 100644
--- a/drivers/tty/serial/8250/Kconfig
+++ b/drivers/tty/serial/8250/Kconfig
@@ -274,7 +274,7 @@ config SERIAL_8250_FSL
 
 config SERIAL_8250_DW
 	tristate "Support for Synopsys DesignWare 8250 quirks"
-	depends on SERIAL_8250 && (OF || ARMADA_XP || AVANTA_LP)
+	depends on SERIAL_8250 && (OF || ARMADA_XP || AVANTA_LP || MV88F6500)
 	help
 	  Selecting this option will enable handling of the extra features
 	  present in the Synopsys DesignWare APB UART.
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 257acf3..026158b 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -277,7 +277,7 @@ config DAVINCI_WATCHDOG
 
 config ORION_WATCHDOG
 	tristate "Orion watchdog"
-	depends on ARCH_ORION5X || ARCH_KIRKWOOD
+	depends on ARCH_ORION5X || ARCH_KIRKWOOD || ARCH_FEROCEON
 	help
 	  Say Y here if to include support for the watchdog timer
 	  in the Marvell Orion5x and Kirkwood ARM SoCs.
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index e8f479a..d6c95c9 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -48,6 +48,9 @@ obj-$(CONFIG_PNX4008_WATCHDOG) += pnx4008_wdt.o
 obj-$(CONFIG_IOP_WATCHDOG) += iop_wdt.o
 obj-$(CONFIG_DAVINCI_WATCHDOG) += davinci_wdt.o
 obj-$(CONFIG_ORION_WATCHDOG) += orion_wdt.o
+ifeq ($(CONFIG_ARCH_FEROCEON),y)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
 obj-$(CONFIG_COH901327_WATCHDOG) += coh901327_wdt.o
 obj-$(CONFIG_STMP3XXX_WATCHDOG) += stmp3xxx_wdt.o
 obj-$(CONFIG_NUC900_WATCHDOG) += nuc900_wdt.o
diff --git a/include/linux/major.h b/include/linux/major.h
index 8a04370..d909537 100644
--- a/include/linux/major.h
+++ b/include/linux/major.h
@@ -176,4 +176,7 @@
 #define BLOCK_EXT_MAJOR		259
 #define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
 
+#define MV_PON_MAJOR		300
+#define MV_TPM_MAJOR		301
+
 #endif
diff --git a/include/linux/telephony.h b/include/linux/telephony.h
index f63afe3..ddf1639 100644
--- a/include/linux/telephony.h
+++ b/include/linux/telephony.h
@@ -213,6 +213,29 @@ struct phone_codec_data
 ******************************************************************************/
 #define PHONE_VAD			_IOW ('q', 0xA9, int)
 
+/******************************************************************************
+* mv-phone additional commands for Caller-ID support
+******************************************************************************/
+#define PHONE_PSTN_REVERSE_POLARITY  _IO('q', 0xAB) /* Timor */
+#define PHONE_PSTN_SEND_NTT_CRA	     _IO('q', 0xAC)
+
+#define PHONE_SET_LINE_FEED_CONTROL  _IOW('q', 0xAD, char)
+#define LF_OPEN              0
+#define LF_FORWARD_ACTIVE    1
+#define LF_FORWARD_ONHOOK_TX 2
+#define LF_TIP_OPEN          3
+#define LF_RINGING           4
+#define LF_REVERSE_ACTIVE    5
+#define LF_REVERSE_ONHOOK_TX 6
+#define LF_RING_OPEN         7
+
+#define PHONE_SET_CID_STATE	     _IO('q', 0xAE)
+#define CID_OFF			0
+#define CID_ON			1
+
+#define PHONE_SET_REVERSE_POLARITY   _IO('q', 0xAF)
+#define PHONE_SET_DIGITAL_HYBRID     _IO('q', 0xB0)
+#define PHONE_GET_LINE_VOLTAGE	     _IO('q', 0xB1)
 
 /******************************************************************************
 *
@@ -235,6 +258,26 @@ struct phone_codec_data
 ******************************************************************************/
 struct phone_except
 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	unsigned int reserved:15;
+	unsigned int hookstate2:1;
+	unsigned int drop_out:1;
+	unsigned int reverse_polarity:1;
+	unsigned int fc3:1;
+	unsigned int fc2:1;
+	unsigned int fc1:1;
+	unsigned int fc0:1;
+	unsigned int flash:1;
+	unsigned int f3:1;
+	unsigned int f2:1;
+	unsigned int f1:1;
+	unsigned int f0:1;
+	unsigned int pstn_wink:1;
+	unsigned int caller_id:1;
+	unsigned int pstn_ring:1;
+	unsigned int hookstate:1;
+	unsigned int dtmf_ready:1;
+#else
 	unsigned int dtmf_ready:1;
 	unsigned int hookstate:1;
 	unsigned int pstn_ring:1;
@@ -249,7 +292,11 @@ struct phone_except
 	unsigned int fc1:1;
 	unsigned int fc2:1;
 	unsigned int fc3:1;
-	unsigned int reserved:18;
+	unsigned int reverse_polarity:1;
+	unsigned int drop_out:1;
+	unsigned int hookstate2:1;
+	unsigned int reserved:15;
+#endif
 };
 
 union telephony_exception {
diff --git a/kernel/printk.c b/kernel/printk.c
index 1650ff2..33e987c 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -759,10 +759,45 @@ static int have_callable_console(void)
  *
  * See the vsnprintf() documentation for format string extensions over C99.
  */
+#undef MV_PLAIN_PRINT
+#ifdef MV_PLAIN_PRINT
+#define _MV_UART0_LSR    (*(volatile unsigned char*)(0xF1000000 + 0x12000 + 0x14))
+#define _MV_UART0_THR    (*(volatile unsigned char*)(0xF1000000 + 0x12000 + 0x00))
+#define _MV_UART_LSR_THRE   0x20
+static char arr[256];
+/*
+ * This does not append a newline
+ */
+static void _putstr(const char *s)
+{
+	while (*s) {
+		while ((_MV_UART0_LSR & _MV_UART_LSR_THRE) == 0)
+			;
+		_MV_UART0_THR = *s;
+
+		if (*s == '\n') {
+			while ((_MV_UART0_LSR & _MV_UART_LSR_THRE) == 0)
+				;
+			_MV_UART0_THR = '\r';
+		}
+		s++;
+	}
+}
 
 asmlinkage int printk(const char *fmt, ...)
 {
 	va_list args;
+
+	va_start(args, fmt);
+	vsprintf(arr, fmt, args);
+	va_end(args);
+	_putstr(arr);
+	return 0;
+}
+#else
+asmlinkage int printk(const char *fmt, ...)
+{
+	va_list args;
 	int r;
 
 #ifdef CONFIG_KGDB_KDB
@@ -780,6 +815,7 @@ asmlinkage int printk(const char *fmt, ...)
 
 	return r;
 }
+#endif /*  MV_PLAIN_PRINT */
 
 /* cpu currently holding logbuf_lock */
 static volatile unsigned int printk_cpu = UINT_MAX;
@@ -985,7 +1021,13 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 	 * actually gets the semaphore or not.
 	 */
 	if (console_trylock_for_printk(this_cpu))
+#if defined(CONFIG_MV_PRINTK_SLICE_SUPPORT)
+		raw_local_irq_restore(flags);
+		console_unlock();
+		raw_local_irq_save(flags);
+#else
 		console_unlock();
+#endif
 
 	lockdep_on();
 out_restore_irqs:
@@ -1306,7 +1348,14 @@ again:
 			break;			/* Nothing to print */
 		_con_start = con_start;
 		_log_end = log_end;
+#if defined(CONFIG_MV_PRINTK_SLICE_SUPPORT)
+		if ((_log_end - _con_start) > CONFIG_MV_PRINTK_CHUNK_SIZE)
+			_log_end = (_con_start + CONFIG_MV_PRINTK_CHUNK_SIZE);
+
+		con_start = _log_end;
+#else
 		con_start = log_end;		/* Flush */
+#endif
 		raw_spin_unlock(&logbuf_lock);
 		stop_critical_timings();	/* don't trace print latency */
 		call_console_drivers(_con_start, _log_end);
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 8195a6f..51792ba 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4187,6 +4187,13 @@ int can_nice(const struct task_struct *p, const int nice)
 		capable(CAP_SYS_NICE));
 }
 
+#ifdef CONFIG_MV_REAL_TIME
+int mv_task_has_rt_policy(struct task_struct *p)
+{
+	return task_has_rt_policy(p);
+}
+#endif
+
 #ifdef __ARCH_WANT_SYS_NICE
 
 /*
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 74c5e70..a22931e 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -225,7 +225,12 @@ EXPORT_SYMBOL(local_bh_enable_ip);
  * we want to handle softirqs as soon as possible, but they
  * should not be able to lock up the box.
  */
+#ifdef CONFIG_MV_REAL_TIME
+#define MAX_SOFTIRQ_RESTART 2
+extern int mv_task_has_rt_policy(struct task_struct *p);
+#else
 #define MAX_SOFTIRQ_RESTART 10
+#endif
 
 asmlinkage void __do_softirq(void)
 {
@@ -240,6 +245,10 @@ asmlinkage void __do_softirq(void)
 	__local_bh_disable((unsigned long)__builtin_return_address(0),
 				SOFTIRQ_OFFSET);
 	lockdep_softirq_enter();
+#ifdef CONFIG_MV_REAL_TIME
+	if (mv_task_has_rt_policy(current))
+		goto out;
+#endif /* CONFIG_MV_REAL_TIME */
 
 	cpu = smp_processor_id();
 restart:
@@ -281,6 +290,9 @@ restart:
 	if (pending && --max_restart)
 		goto restart;
 
+#ifdef CONFIG_MV_REAL_TIME
+out:
+#endif
 	if (pending)
 		wakeup_softirqd();
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index b9c8593..e5b433b 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -171,6 +171,42 @@ static int vmap_page_range_noflush(unsigned long start, unsigned long end,
 			return err;
 	} while (pgd++, addr = next, addr != end);
 
+	/*
+	 * In order to support installation of a non-trivial FIQ handler, on ARM
+	 * we need to replicate kernel virtual memory to all processes (so it
+	 * can be accessed from fiq state irrespective of what current process is).
+	 * The code comes from do_translation_fault, and is arm-specific.
+	 */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	if (!err) {
+		struct task_struct *p;
+		for_each_process(p) {
+			task_lock(p);
+			if (!p->mm)
+				goto next_process;
+			if (p->mm == &init_mm)
+				goto next_process;
+			for (addr = start;
+			     addr < end; addr += PAGE_SIZE) {
+				/* "+= PMD_SIZE" may be faster... */
+				unsigned int index;
+				pgd_t *pgd, *pgd_k;
+				pmd_t *pmd, *pmd_k;
+				/*  from do_translation_fault() */
+				index = pgd_index(addr);
+				pgd = p->mm->pgd + index;
+				pgd_k = init_mm.pgd + index;
+				if (!pgd_present(*pgd))
+					set_pgd(pgd, *pgd_k);
+				pmd_k = pmd_offset(pgd_k, addr);
+				pmd   = pmd_offset(pgd, addr);
+				copy_pmd(pmd, pmd_k);
+			}
+next_process:
+			task_unlock(p);
+		}
+	}
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 	return nr;
 }
 
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 1248bcf..c98d187 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -32,3 +32,7 @@ obj-$(CONFIG_SND_SOC)	+= txx9/
 ifeq ($(CONFIG_PLAT_ARMADA),y)
 obj-$(CONFIG_SND_MRVL_AUDIO)  += ../../arch/arm/plat-armada/mv_drivers_lsp/mv_audio_soc/
 endif
+
+ifeq ($(CONFIG_ARCH_FEROCEON),y)
+obj-$(CONFIG_SND_MRVL_AUDIO)  += ../../arch/arm/plat-feroceon/mv_drivers_lsp/mv_audio_soc/
+endif
-- 
1.7.5.4

