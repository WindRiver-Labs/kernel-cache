From 0d228e49ad824b9569840b19598463cbea1d14ab Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Tue, 15 Jan 2013 20:27:26 +0200
Subject: [PATCH 0442/1825] Align: armada_suspend.S

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 514be30d69640792b1056e02241b70a934744aae

Change-Id: I65f3cc4ec384961b7e28ab93d2d470946bd89b12

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/armada_suspend.S |  419 ++++++++++++---------------------
 1 files changed, 153 insertions(+), 266 deletions(-)

diff --git a/arch/arm/plat-armada/armada_suspend.S b/arch/arm/plat-armada/armada_suspend.S
index 089c583..0562693 100644
--- a/arch/arm/plat-armada/armada_suspend.S
+++ b/arch/arm/plat-armada/armada_suspend.S
@@ -12,9 +12,24 @@
 #include <asm/assembler.h>
 #include <mach/hardware.h>
 
-#define GPIO_64_66_VALUE_REG		(INTER_REGS_BASE + 0x18180)
-#define GPIO_64_66_CTRL_REG		(INTER_REGS_BASE + 0x18184)
-#define MPP_CTRL_64_66_REG		(INTER_REGS_BASE + 0x18020)
+#if 1  /* B0-GP board GPIO pins*/
+#define MPP_CTRL_PM_REG				(INTER_REGS_BASE + 0x18008)
+#define GPIO_OUT_VALUE_REG			(INTER_REGS_BASE + 0x18100)
+#define GPIO_OUT_CTRL_REG			(INTER_REGS_BASE + 0x18104)
+#define MPP_SET_GPIO_MASK			(0xFFFFF000)
+#define GPIO_PIN_MASK				(0xFFF8FFFF)
+#define GPIO_CMD_VALUE				(0x10000)
+#define GPIO_ACK_VALUE				(0x70000)
+#else /* B0-HE board GPIO pins */
+#define MPP_SET_GPIO_MASK			(0xFFFFF000)
+#define GPIO_PIN_MASK				(0xFFFFFFF8)
+#define GPIO_CMD_VALUE				(0x1)
+#define GPIO_ACK_VALUE				(0x7)
+#define MPP_CTRL_PM_REG				(INTER_REGS_BASE + 0x18020)
+#define GPIO_OUT_VALUE_REG			(INTER_REGS_BASE + 0x18180)
+#define GPIO_OUT_CTRL_REG			(INTER_REGS_BASE + 0x18184)
+#endif
+
 #define MV_COHERENCY_FABRIC_CTRL_REG	(0x20200)
 
 /*
@@ -33,7 +48,13 @@ ENTRY(armadaxp_snoop_dis_virt)
 	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_BASE)
 1:
 	ldrex r3, [r2]
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
 	bic	r3, r3, r4, lsl r5
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
 	strex r0, r3, [r2]
 	cmp	r0, #0
 	bne 1b
@@ -42,9 +63,103 @@ ENTRY(armadaxp_snoop_dis_virt)
 ENDPROC(armadaxp_snoop_dis_virt)
 
 /*
- * armadaxp_cpu_resume_pd: suspend to RAM - resume from cpu deepIdle state
+* armadaxp_cpu_suspend: enter cpu deepIdle state
+* input:
+*/
+ENTRY(armadaxp_cpu_suspend)
+/* Save ARM registers */
+	stmfd	sp!, {r4 - r11, lr}	@ save registers on stack
+
+	bl armadaxp_fabric_prepare_deepIdle
+
+	/*
+	 * Invalidate L1 data cache. Even though only invalidate is
+	 * necessary exported flush API is used here. Doing clean
+	 * on already clean cache would be almost NOP.
+	 */
+	bl v7_flush_dcache_all
+
+	/*
+	 * Clear the SCTLR.C bit to prevent further data cache
+	 * allocation. Clearing SCTLR.C would make all the data accesses
+	 * strongly ordered and would not hit the cache.
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #(1 << 2)	@ Disable the C bit
+	mcr	p15, 0, r0, c1, c0, 0
+	isb
+
+	bl v7_flush_dcache_all
+
+	/* Data memory barrier and Data sync barrier */
+	dsb
+	dmb
+
+	bl armadaxp_snoop_dis_virt
+
+#ifdef CONFIG_ARMADA_DEEP_IDLE_SUPPORT_DRAM_SR
+	ldr	r3, =(INTER_REGS_BASE + 0x1418)
+	ldr	r4, [r3]
+#ifdef CONFIG_BE8_ON_LE
+	rev r4, r4
+#endif
+	orr	r4, r4, #0x7
+#ifdef CONFIG_BE8_ON_LE
+	rev r4, r4
+#endif
+	dsb				@ Data Synchronization Barrier
+
+	.align 5
+	str	r4, [r3]		@ Self refresh command
+#endif
+
+/*
+ * ===================================
+ * == WFI instruction => Enter idle ==
+ * ===================================
+ */
+
+	wfi				@ wait for interrupt
+/*
+ * ===================================
+ * == Resume path for non-OFF modes ==
+ * ===================================
  */
-ENTRY(armadaxp_cpu_resume_pd)
+
+/* Enable SnoopEna - Exclusive */
+	mrc	15, 0, r1, cr0, cr0, 5
+	and	r1, r1, #15
+	mov	r4, #1
+	add	r5, r1, #24
+	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_BASE)
+1:
+	ldrex r3, [r2]
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
+	orr	r3, r3, r4, lsl r5
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
+	strex r0, r3, [r2]
+	cmp	r0, #0
+	bne 1b
+
+/* Re-enable C-bit if needed */
+	mrc	p15, 0, r0, c1, c0, 0
+	tst	r0, #(1 << 2)		@ Check C bit enabled?
+	orreq	r0, r0, #(1 << 2)	@ Enable the C bit if cleared
+	mcreq	p15, 0, r0, c1, c0, 0
+	isb
+
+	ldmfd	sp!, {r4 - r11, pc}	@ restore regs and return
+ENDPROC(armadaxp_cpu_suspend)
+
+/*
+* armadaxp_cpu_resume: exit cpu deepIdle state
+*/
+ENTRY(armadaxp_cpu_resume)
+
 #ifdef CONFIG_CPU_ENDIAN_BE32
 	/* convert CPU to big endian */
 	.word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
@@ -63,7 +178,13 @@ ENTRY(armadaxp_cpu_resume_pd)
 	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_PHYS_BASE)
 1:
 	ldrex r3, [r2]
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
 	orr	r3, r3, r6, lsl r7
+#ifdef CONFIG_BE8_ON_LE
+	rev r3, r3
+#endif
 	strex r0, r3, [r2]
 	cmp	r0, #0
 	bne 1b
@@ -81,42 +202,6 @@ ENTRY(armadaxp_powerdown)
 	stmfd	sp!, {r4-r12, lr}		@ save registers on stack
 
 	/*
-	* Save the CP15 context
-	*/
-	mrc     p15, 0, r2, c1, c0, 0           @ save CP15 - CR
-	mrc     p15, 0, r3, c3, c0, 0           @ save CP15 - DACR
-	mrc     p15, 0, r4, c13, c0, 0          @ save CP15 - FCSE
-	mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
-	mrc     p15, 0, r6, c13, c0, 1          @ save CP15 - context ID
-	mrc     p15, 1, r7, c15, c1, 0          @ save CP15 - extra features
-	mrc     p15, 0, r8, c1, c0, 1           @ save CP15 - Aux CR
-	mov     r9, r13                         @ save resume SP
-	stmfd   sp!, {r2-r9}
-
-	mrc     p15, 0, r2, c2, c0, 1   @ save CP15 - TTBR1
-	mrc	p15, 1, r3, c15, c2, 0	@ save CP15 - Aux Func Modes Ctrl 0
-	mrc	p15, 1, r4, c15, c1, 2	@ save CP15 - Aux Debug Modes Ctrl 2
-	mrc     p15, 1, r5, c15, c1, 1  @ save CP15 - Aux Debug Modes Ctrl 1
-	mrc     p15, 0, r6, c9, c14, 0  @ save CP15 - PMC
-	mrc     p15, 0, r7, c10, c2, 0  @ save CP15 - PRRR
-	mrc     p15, 0, r8, c10, c2, 1  @ save CP15 - NMRR
-	stmfd   sp!, {r2-r8}
-
-	/*
-	* Save the physical address of the resume SP
-	*/
-	mov     r0, sp
-	bl      suspend_phys_addr
-	ldr     r1, =suspend_saved_sp
-#ifdef CONFIG_SMP
-	mrc     p15, 0, r2, c0, c0, 5
-	and     r2, r2, #15
-	str     r0, [r1, r2, lsl #2]
-#else
-	str     r0, [r1]
-#endif
-
-	/*
 	* Flush L1 DCache
 	*/
 	bl v7_flush_kern_cache_all
@@ -162,35 +247,50 @@ ENTRY(armadaxp_powerdown)
 	orr	r0, r0, r3
 
 	/*
-	 * Write 0x1 then 0x7 through MPP 64-67 to PIC that controls power
+	 * Write 0x1 then 0x7 through MPPs to PIC that controls power
 	 * 0x1 - Power off all voltages;  0x7 - Acknowledge command
 	 */
-	ldr r3, =(MPP_CTRL_64_66_REG)
-	ldr r4, =0x2000
-	str r4, [r3]
 
-	ldr r3, =(GPIO_64_66_VALUE_REG)
-	ldr r4, =(GPIO_64_66_CTRL_REG)
+	/* Set MPPs to GPIO */
 
-	ldr r5, =0x1
-	ldr r6, =0x0
+	ldr r3, =(MPP_CTRL_PM_REG)
+	ldr r5, =(MPP_SET_GPIO_MASK)
+	ldr r4, [r3]
+	and r4, r4, r5
+	str r4, [r3]
 
+	/* Set output value */
+	ldr r3, =(GPIO_OUT_VALUE_REG)
+	ldr r6, =(GPIO_PIN_MASK)
+	ldr r7, =(GPIO_CMD_VALUE)
+	ldr r5, [r3]
+	and r5, r5, r6
+	orr r5, r5, r7
 	str r5, [r3]
-	str r6, [r4]
 
-	ldr r1, =200000000
-	ldr r5, =0x7
+	/* Set pins as out */
+	ldr r4, =(GPIO_OUT_CTRL_REG)
+	ldr r5, [r4]
+	and r5, r5, r6
+	str r5, [r4]
+
+	/* Prepare the ACK command */
+	ldr r7, =(GPIO_ACK_VALUE)
+	ldr r5, [r3]
+	and r5, r5, r6
+	orr r5, r5, r7
 
 	/*
 	 * Wait between cmd (0x1) and cmd ack (0x7)
 	 * TODO - Need to reduce this delay
 	 */
+	ldr r1, =2000000000
 1:	subs r1,r1,#1
 	bne 1b
 
 	/*
 	 * Put Dram into self refresh. From here on we can perform
-	 * 8 instructions to ensure executiion from I-Cache
+	 * 8 instructions to ensure execution from I-Cache
 	 */
 	.align 5
 	str	r0, [r2]
@@ -208,216 +308,3 @@ ENTRY(armadaxp_powerdown)
 
 ENDPROC(armadaxp_powerdown)
 
-/*
-* armadaxp_cpu_suspend: enter cpu deepIdle state
-* input:
-*/
-ENTRY(armadaxp_cpu_suspend)
-/* Save ARM registers */
-	stmfd	sp!, {r4-r12, lr}				@ save registers on stack
-
-/*
-* Save the CP15 context
-*/
-	mrc     p15, 0, r2, c1, c0, 0			@ save CP15 - CR
-	mrc     p15, 0, r3, c3, c0, 0			@ save CP15 - DACR
-	mrc     p15, 0, r4, c13, c0, 0			@ save CP15 - FCSE
-        mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
-	mrc     p15, 0, r6, c13, c0, 1			@ save CP15 - context ID
-	mrc     p15, 1, r7, c15, c1, 0			@ save CP15 - extra features
-	mrc     p15, 0, r8, c1, c0, 1			@ save CP15 - Aux CR
-	mov     r9, r13							@ save resume SP
-	stmfd   sp!, {r2-r9}
-	mrc     p15, 0, r2, c2, c0, 1           @ save CP15 - TTBR1
-	mrc	p15, 1, r3, c15, c2, 0				@ save CP15 - Aux Func Modes Ctrl 0
-	mrc	p15, 1, r4, c15, c1, 2				@ save CP15 - Aux Debug Modes Ctrl 2
-	mrc     p15, 1, r5, c15, c1, 1			@ save CP15 - Aux Debug Modes Ctrl 1
-	mrc     p15, 0, r6, c9, c14, 0			@ save CP15 - PMC
-	mrc     p15, 0, r7, c10, c2, 0			@ save CP15 - PRRR
-	mrc     p15, 0, r8, c10, c2, 1			@ save CP15 - NMRR
-	
-        stmfd   sp!, {r2-r8}
-
-/*
-* TODO: Save Debug Registers
-*/
-
-/*
-* Save the physical address of the resume SP
-*/
-        mov     r0, sp
-        bl      suspend_phys_addr
-        ldr     r1, =suspend_saved_sp
-#ifdef CONFIG_SMP
-        mrc     p15, 0, r2, c0, c0, 5
-        and     r2, r2, #15
-        str     r0, [r1, r2, lsl #2]
-#else
-        str     r0, [r1]
-#endif
-
-/*
-* Flush L1 DCache
-*/
-
-#ifdef CONFIG_CPU_V6
-	bl v6_flush_kern_cache_all
-#elif CONFIG_CPU_V7
-	bl v7_flush_kern_cache_all
-#else
-#error "CPU Arch version not defined!\n"
-#endif
-
-/* Prepare Deep Idle Function - Set PMU Configurations*/
-	bl armadaxp_fabric_prepare_deepIdle
-
-/*
-* Issue a Data Synchronization Barrier instruction to ensure that all
-* state saving has been	completed.
-*/
-#ifdef CONFIG_CPU_V6
-	mcr     p15, 0, r0, c7, c10, 4	@ Data Synchronization Barrier
-#elif defined (CONFIG_CPU_V7)
-	dsb				@ Data Synchronization Barrier
-#endif
-
-/* Lock Semaphore */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	ldr	r4, =0xFBB20500
-1:
-	ldr	r2, [r4]
-	and	r2, r2, #0xF
-	cmp	r1, r2
-	bne	1b
-
-/* Disable SnoopEna */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	mov	r6, #1
-	add	r7, r1, #24
-	ldr	r2, =0xFBB20200
-	ldr	r3, [r2]
-	bic	r3, r3, r6, lsl r7
-	str	r3, [r2]
-
-/* Release Semaphore */
-	ldr	r2, =0xFBB20500
-	ldr 	r0, =0xff
-	strb	r0, [r2]
-
-dowfi:
-/* WFI */
-#ifdef CONFIG_CPU_V6
-	mcr     p15, 0, r1, c7, c0, 4	@ wait for interrupt
-#elif defined (CONFIG_CPU_V7)
-	wfi				@ wait for interrupt
-#endif
-
-	/* After disabling the SnoopEna by SW regret is not allowed!! */
-	b dowfi
-
-#if 0
-	/* if we reach this point then deepIdle returned from regret mode and cpu
-	* state retained
-	*/
-	mov	r0, #1
-	ldmfd   sp!, {r3-r8}
-	ldmfd   sp!, {r2-r9}
-	
-	ldmfd   sp!, {r4-r12, pc}
-#endif
-ENDPROC(armadaxp_cpu_suspend)
-
-/*
-* armadaxp_cpu_resume: resume from cpu deepIdle state
-* input:
-*/
-ENTRY(armadaxp_cpu_resume)
-
-#ifdef CONFIG_CPU_ENDIAN_BE32
-	/* convert CPU to big endian */
-	.word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
-	.word 0x800080e3 /* orr r0, r0, #0x80 */
-	.word 0x100f01ee /* mcr p15, 0, r0, c1, c0 */
-#endif
-#ifdef CONFIG_CPU_ENDIAN_BE8
-	setend  be
-#endif
-
-/* Enable SnoopEna - Exclusive */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	mov	r6, #1
-	add	r7, r1, #24
-	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_PHYS_BASE)
-1:
-	ldrex r3, [r2]
-	orr	r3, r3, r6, lsl r7
-	strex r0, r3, [r2]
-	cmp	r0, #0
-	bne 1b
-
-#ifdef CONFIG_SMP
-	adr     r0, suspend_saved_sp
-	mrc     p15, 0, r1, c0, c0, 5
-	and     r1, r1, #15
-	ldr     r0, [r0, r1, lsl #2]    @ stack phys addr
-#else
-	ldr     r0, suspend_saved_sp            @ stack phys addr
-#endif
-
-	ldmfd   r0!, {r2-r8}
-	mcr     p15, 0, r2, c2, c0, 1           @ restore CP15 - TTBR1
-	mcr     p15, 1, r3, c15, c2, 0          @ restore CP15 - Aux Func Modes Ctrl 0
-	mcr     p15, 1, r4, c15, c1, 2          @ restore CP15 - Aux Debug Modes Ctrl 2
-	mcr     p15, 1, r5, c15, c1, 1          @ restore CP15 - Aux Debug Modes Ctrl 1
-	mcr     p15, 0, r6, c9, c14, 0          @ restore CP15 - PMC
-	mcr     p15, 0, r7, c10, c2, 0          @ restore CP15 - PRRR
-	mcr     p15, 0, r8, c10, c2, 1          @ restore CP15 - NMRR
-	ldmfd   r0!, {r2-r9}
-	mcr	p15, 0, r8, c1, c0, 1		@ restore CP15 - Aux CR
-	mcr	p15, 1, r7, c15, c1, 0		@ restore CP15 - extra features
-	mcr	p15, 0, r4, c13, c0, 0		@ restore CP15 - FCSE
-	mcr	p15, 0, r3, c3, c0, 0		@ restore CP15 - DACR
-
-	/* load identity page table */
-	ldr	r3, identity_page_table_phys
-	mcr	p15, 0, r3, c2, c0, 0		@ set CP15 - TTBR
-	mov	r3, #0
-	mcr	p15, 0, r3, c13, c0, 1          @ set 0 in CP15 - context ID
-	mcr	p15, 0, r2, c1, c0, 0		@ restore CP15 - CR  @enable mmu
-	mrc     p15, 0, r3, c0, c0, 0           @ read id reg
-
-	ldr	r3, resume2
-	mov	pc, r3
-ENDPROC(armadaxp_cpu_resume_pd)
-
-	/* stage 2 of the resume function that runs from PAGE_OFFSET virtual space */
-ENTRY(armadaxp_cpu_resume2)	
-	/* restore original page table*/
-
-	mcr	p15, 0, r5, c2, c0, 0		@ restore CP15 - TTBR
-	mcr	p15, 0, r6, c13, c0, 1          @ restore CP15 - context ID
-	mcr     p15, 0, r0, c8, c7, 0           @ TLB invalidate
-	mov	sp, r9				@ restore virtual sp
-	mov	r0, #0
-
-	ldmfd   sp!, {r4-r12, pc}               @ restore SVC registers
-
-ENDPROC(armadaxp_cpu_resume2)
-	
-resume2:
-	.long	armadaxp_cpu_resume2
-
-suspend_saved_sp:
-#ifdef CONFIG_SMP
-	.rept	CONFIG_NR_CPUS
-#endif
-	.long	0	@ physical SP saved here
-#ifdef CONFIG_SMP
-	.endr
-#endif
-	.global identity_page_table_phys
-identity_page_table_phys:
-	.long	0
-- 
1.7.5.4

