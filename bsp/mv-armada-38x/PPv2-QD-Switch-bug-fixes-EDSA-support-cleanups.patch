From 94e227bae694e9acf820292126c3d88d01a8f1be Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Thu, 14 Mar 2013 16:22:34 +0200
Subject: [PATCH 0498/1825] PPv2: QD Switch: bug fixes, EDSA support, cleanups

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit fbfaf06750e63a4d0e017d663ada4a3da899abbb

Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Change-Id: Id54eda4e85ce854893f29d88a09fec31f03bc2b5
Reviewed-on: http://vgitil04.il.marvell.com:8080/1335
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Makefile                    |    1 -
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c  |  726 --------------------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   47 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  218 +------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   27 +-
 .../mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c          |   31 +-
 .../plat-armada/mv_drivers_lsp/mv_switch/Makefile  |    2 +-
 7 files changed, 69 insertions(+), 983 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c

diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 2e24948..46fbef2 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -156,7 +156,6 @@ obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_NET_DEV_DIR)/mv_netdev.o \
 					   $(LSP_NET_DEV_DIR)/mv_eth_pon_sysfs.o \
 					   $(LSP_NET_DEV_DIR)/mv_eth_pme_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_NET_DEV_DIR)/mv_fpga_sysfs.o
-obj-$(CONFIG_MV_ETH_SWITCH)		+= $(LSP_NET_DEV_DIR)/mv_eth_switch.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_BM_DIR)/mv_eth_bm.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PRS_DIR)/prs_sysfs.o
 obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_CLS_DIR)/cls_sysfs.o \
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c
deleted file mode 100644
index 9a8d4b7..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c
+++ /dev/null
@@ -1,726 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-
-#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/pci.h>
-#include <linux/ip.h>
-#include <linux/in.h>
-#include <linux/tcp.h>
-#include <linux/version.h>
-#include <net/ip.h>
-#include <net/xfrm.h>
-
-#include "mvOs.h"
-#include "dbg-trace.h"
-#include "mvSysHwConfig.h"
-#include "boardEnv/mvBoardEnvLib.h"
-#ifdef MV_INCLUDE_ETH_COMPLEX
-#include "ctrlEnv/mvCtrlEthCompLib.h"
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-#include "gbe/mvPp2Gbe.h"
-
-#include "mv_switch.h"
-#include "mv_netdev.h"
-
-extern int mv_net_devs_num;
-
-/* Example: "mv_net_config=4,(00:99:88:88:99:77,0)(00:55:44:55:66:77,1:2:3:4)(00:11:22:33:44:55,),mtu=1500" */
-static char			*net_config_str[CONFIG_MV_ETH_PORTS_NUM] = {NULL};
-struct mv_eth_switch_config     switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
-
-static int                      mv_eth_switch_started = 0;
-unsigned int                    switch_enabled_ports = 0;
-
-/* Required to get the configuration string from the Kernel Command Line */
-int mv_eth0_cmdline_config(char *s);
-__setup("mv_net_config=", mv_eth0_cmdline_config);
-
-int mv_eth0_cmdline_config(char *s)
-{
-	net_config_str[MV_ETH_PORT_0] = s;
-	return 1;
-}
-
-int mv_eth1_cmdline_config(char *s);
-__setup("mv_net_config1=", mv_eth1_cmdline_config);
-
-int mv_eth1_cmdline_config(char *s)
-{
-	net_config_str[MV_ETH_PORT_1] = s;
-	return 1;
-}
-
-
-/* Local function prototypes */
-static int mv_eth_check_open_bracket(char **p_net_config)
-{
-	if (**p_net_config == '(') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find opening bracket\n");
-	return -EINVAL;
-}
-
-static int mv_eth_check_closing_bracket(char **p_net_config)
-{
-	if (**p_net_config == ')') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find closing bracket\n");
-	return -EINVAL;
-}
-
-static int mv_eth_check_comma(char **p_net_config)
-{
-	if (**p_net_config == ',') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find comma\n");
-	return -EINVAL;
-}
-
-static int mv_eth_netconfig_mac_addr_get(char **p_net_config, int idx, int port)
-{
-	int     num;
-	char *config_str = *p_net_config;
-	MV_U32  mac[MV_MAC_ADDR_SIZE];
-
-	/* the MAC address should look like: 00:99:88:88:99:77 */
-	/* that is, 6 two-digit numbers, separated by :        */
-	num = sscanf(config_str, "%2x:%2x:%2x:%2x:%2x:%2x",
-		&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
-	if (num == MV_MAC_ADDR_SIZE) {
-		while (--num >= 0)
-			switch_net_config[port].mac_addr[idx][num] = (mac[num] & 0xFF);
-
-		(*p_net_config) = config_str + 17;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing MAC address from command line\n");
-	return -EINVAL;
-}
-
-static int mv_eth_netconfig_ports_get(char **p_net_config, int idx, int port)
-{
-	char ch;
-	char *config_str = *p_net_config;
-	int  sw_port, mask = 0, status = -EINVAL;
-
-	/* the switch port list should look like this: */
-	/* example 0: )         - no ports */
-	/* example 1: 0)        - single port 0 */
-	/* example 2: 1:2:3:4)  - multiple ports */
-
-	while (1) {
-		ch = *config_str++;
-
-		if (ch == ')') {
-			/* Finished */
-			status = 0;
-			break;
-		}
-		sw_port = mvCharToDigit(ch);
-		if (sw_port < 0)
-			break;
-
-		/* TBD - Check sw_port validity */
-		mask |= (1 << sw_port);
-
-		if (*config_str == ':')
-			config_str++;
-	}
-	*p_net_config = config_str;
-
-	if (status == 0) {
-		switch_net_config[port].board_port_map[idx] = mask;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing switch port mask from command line\n");
-	return -EINVAL;
-}
-
-/* the mtu value is constructed as follows: */
-/* mtu=value                                */
-static int  mv_eth_netconfig_mtu_get(char **p_net_config, int port)
-{
-	unsigned int mtu;
-
-	if (strncmp(*p_net_config, "mtu=", 4) == 0) {
-		*p_net_config += 4;
-		mtu = strtol(*p_net_config, p_net_config, 10);
-		if (mtu > 0) {
-			switch_net_config[port].mtu = mtu;
-			printk(KERN_ERR "      o MTU set to %d.\n", mtu);
-			return 0;
-		}
-		printk(KERN_ERR "Syntax error while parsing mtu value from command line\n");
-		return -EINVAL;
-	}
-
-	switch_net_config[port].mtu = 1500;
-	printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
-	return 0;
-}
-
-static int mv_eth_netconfig_max_get(char **p_net_config, int port)
-{
-	char num = **p_net_config;
-	int netdev_num;
-
-	netdev_num = mvCharToDigit(num);
-	if (netdev_num >= 0) {
-		switch_net_config[port].netdev_max = netdev_num;
-		(*p_net_config) += 1;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing number of netdevs from command line\n");
-	return -EINVAL;
-}
-
-int mv_eth_switch_config_get(int use_existing_config, int port)
-{
-	char *p_net_config;
-	int i = 0;
-
-	if ((port != MV_ETH_PORT_0) && (port != MV_ETH_PORT_1))	{
-		printk(KERN_ERR "%s: invalid port number %d\n", __func__, port);
-		return -EINVAL;
-	}
-
-	if (!use_existing_config) {
-		memset(&(switch_net_config[port]), 0, sizeof((switch_net_config[port])));
-
-		if (net_config_str[port] != NULL) {
-			printk(KERN_ERR "      o Using UBoot netconfig string for port %d\n", port);
-		} else {
-			printk(KERN_ERR "      o Using default netconfig string from Kconfig for port %d\n", port);
-			if (port == MV_ETH_PORT_0)
-				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_0;
-			else if (port == MV_ETH_PORT_1)
-				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_1;
-		}
-		printk(KERN_ERR "        net_config_str[%d]: %s\n", port, net_config_str[port]);
-
-		p_net_config = net_config_str[port];
-		if (mv_eth_netconfig_max_get(&p_net_config, port))
-			return -EINVAL;
-
-		/* check restriction: at least one of the configuration strings must be 0 */
-		if ((net_config_str[MV_ETH_PORT_0] != NULL) &&
-		    (net_config_str[MV_ETH_PORT_1] != NULL) &&
-		    (switch_net_config[MV_ETH_PORT_0].netdev_max != 0) &&
-		    (switch_net_config[MV_ETH_PORT_1].netdev_max != 0)) {
-			printk(KERN_ERR "%s: cannot have both GbE ports using the Gateway driver, change mv_net_config\n", __func__);
-			return -EINVAL;
-		}
-
-		if (switch_net_config[port].netdev_max == 0)
-			return 1;
-
-		if (switch_net_config[port].netdev_max > CONFIG_MV_ETH_SWITCH_NETDEV_NUM) {
-			printk(KERN_ERR "Too large number of netdevs (%d) in command line: cut to %d\n",
-				switch_net_config[port].netdev_max, CONFIG_MV_ETH_SWITCH_NETDEV_NUM);
-			switch_net_config[port].netdev_max = CONFIG_MV_ETH_SWITCH_NETDEV_NUM;
-		}
-
-		if (mv_eth_check_comma(&p_net_config))
-			return -EINVAL;
-
-		for (i = 0; (i < CONFIG_MV_ETH_SWITCH_NETDEV_NUM) && (*p_net_config != '\0'); i++) {
-			if (mv_eth_check_open_bracket(&p_net_config))
-				return -EINVAL;
-
-			if (mv_eth_netconfig_mac_addr_get(&p_net_config, i, port))
-				return -EINVAL;
-
-			if (mv_eth_check_comma(&p_net_config))
-				return -EINVAL;
-
-			if (mv_eth_netconfig_ports_get(&p_net_config, i, port))
-				return -EINVAL;
-
-			switch_net_config[port].netdev_cfg++;
-
-			/* If we have a comma after the closing bracket, then interface */
-			/* definition is done.                                          */
-			if (*p_net_config == ',') {
-				p_net_config++;
-				break;
-			}
-		}
-
-		/* there is a chance the previous loop did not end because a comma was found but because	*/
-		/* the maximum number of interfaces was reached, so check for the comma now.		*/
-		if (i == CONFIG_MV_ETH_SWITCH_NETDEV_NUM)
-			if (mv_eth_check_comma(&p_net_config))
-				return -EINVAL;
-
-		if (*p_net_config != '\0') {
-			if (mv_eth_netconfig_mtu_get(&p_net_config, port))
-				return -EINVAL;
-		} else {
-			switch_net_config[port].mtu = 1500;
-			printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
-		}
-
-		/* at this point, we have parsed up to CONFIG_MV_ETH_SWITCH_NETDEV_NUM, and the mtu value */
-		/* if the net_config string is not finished yet, then its format is invalid */
-		if (*p_net_config != '\0') {
-			printk(KERN_ERR "Switch netconfig string is too long: %s\n", p_net_config);
-			return -EINVAL;
-		}
-	} else {
-		/* leave most of the configuration as-is, but update MAC addresses */
-		/* MTU is saved in mv_eth_switch_change_mtu */
-
-		/* Note: at this point, since this is a re-init, mv_eth_switch_netdev_first */
-		/* and mv_eth_switch_netdev_last, as well as mv_net_devs[], are valid.      */
-		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-			if (mv_net_devs[i] != NULL)
-				memcpy(switch_net_config[port].mac_addr[i - mv_eth_switch_netdev_first],
-					mv_net_devs[i]->dev_addr, MV_MAC_ADDR_SIZE);
-		}
-
-		if (switch_net_config[port].netdev_max == 0)
-			return 1;
-	}
-
-	return 0;
-}
-
-int    mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct sockaddr *addr = (struct sockaddr *)mac;
-
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	/* remove old mac addr from VLAN DB */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 0);
-
-	memcpy(dev->dev_addr, addr->sa_data, MV_MAC_ADDR_SIZE);
-
-	/* add new mac addr to VLAN DB */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 1);
-
-	printk(KERN_ERR "mv_eth_switch: %s change mac address to %02x:%02x:%02x:%02x:%02x:%02x\n",
-		dev->name, *(dev->dev_addr), *(dev->dev_addr+1), *(dev->dev_addr+2),
-		*(dev->dev_addr+3), *(dev->dev_addr+4), *(dev->dev_addr+5));
-
-	return 0;
-}
-
-int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu)
-{
-	int i;
-	struct eth_port *priv = MV_ETH_PRIV(dev);
-
-	/* All gateway interfaces must be down before changing MTU */
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (netif_running(mv_net_devs[i]))) {
-			printk(KERN_ERR "All gateway interfaces must be down before changing MTU. %s is not down\n", mv_net_devs[i]->name);
-			return -EPERM;
-		}
-	}
-
-	if (dev->mtu != mtu) {
-		int old_mtu = dev->mtu;
-
-		mtu = mv_eth_check_mtu_valid(dev, mtu);
-		if (mtu < 0)
-			return -EPERM;
-
-		if (mv_eth_change_mtu_internals(dev, mtu))
-			return -EPERM;
-
-		printk(KERN_NOTICE "%s: change mtu %d (pkt-size %d) to %d (pkt-size %d)\n",
-			dev->name, old_mtu, RX_PKT_SIZE(old_mtu),
-			dev->mtu, RX_PKT_SIZE(dev->mtu));
-	}
-
-	if (switch_net_config[priv->port].mtu != mtu) {
-		mv_switch_jumbo_mode_set(RX_PKT_SIZE(mtu));
-		switch_net_config[priv->port].mtu = mtu;
-	}
-
-	return 0;
-}
-
-int    mv_eth_switch_start(struct net_device *dev)
-{
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	int i;
-	int group;
-
-	/* Check that MTU value is identical for all gateway interfaces */
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i]->mtu != dev->mtu)) {
-			printk(KERN_ERR "All gateway devices must have same MTU\n");
-			return -EPERM;
-		}
-	}
-
-	/* in default link is down */
-	netif_carrier_off(dev);
-
-	/* Stop the TX queue - it will be enabled upon PHY status change after link-up interrupt/timer */
-	netif_tx_stop_all_queues(dev);
-
-	/* start upper layer accordingly with ports_map */
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-	dev_priv->link_map = 0;
-	mv_switch_link_update_event(dev_priv->port_map, 1);
-#else
-	dev_priv->link_map = dev_priv->port_map;
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
-	if (mv_eth_switch_started == 0)	{
-		/* fill rx buffers, start rx/tx activity, set coalescing */
-		if (mv_eth_start_internals(priv, dev->mtu) != 0) {
-			printk(KERN_ERR "%s: start internals failed\n", dev->name);
-			goto error;
-		}
-
-		/* enable polling on the port, must be used after netif_poll_disable */
-		for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-			napi_enable(priv->napiGroup[group]);
-
-		/* connect to port interrupt line */
-		if (request_irq(dev->irq, mv_eth_isr, IRQF_DISABLED|IRQF_SAMPLE_RANDOM, "mv_eth", priv)) {
-			printk(KERN_ERR "cannot request irq %d for %s port %d\n",
-				dev->irq, dev->name, priv->port);
-			for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-				napi_disable(priv->napiGroup[group]);
-			goto error;
-		}
-
-		/* unmask interrupts */
-		mv_eth_interrupts_unmask(priv);
-		smp_call_function_many(cpu_online_mask, mv_eth_interrupts_unmask, (void *)priv, 1);
-	}
-
-	mv_eth_switch_started++;
-
-	/* Add our MAC addr to the VLAN DB at switch level to forward packets with this DA   */
-	/* to CPU port by using the tunneling feature. The device is always in promisc mode. */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 1);
-
-	/* We also need to allow L2 broadcasts comming up for this interface */
-	mv_switch_mac_addr_set(broadcast, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-			(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-
-	printk(KERN_ERR "%s: started (on switch)\n", dev->name);
-	return 0;
-
-error:
-	printk(KERN_ERR "%s: start failed\n", dev->name);
-	return -1;
-}
-
-int     mv_eth_switch_stop(struct net_device *dev)
-{
-	struct eth_port *priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct cpu_ctrl	*cpuCtrl;
-	int group, cpu;
-
-	/* stop upper layer */
-	netif_carrier_off(dev);
-	netif_tx_stop_all_queues(dev);
-
-	/* stop switch from forwarding packets from this VLAN toward CPU port */
-	mv_switch_atu_db_flush(MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id));
-
-	/* It is possible that the interface is in promiscuous mode */
-	/* If so, the CPU port is connected with port based VLAN to the other ports, and */
-	/* we must disconnect it now to stop the Switch from forwarding packets to the CPU */
-	/* when the interface is down. */
-	/* mv_eth_switch_set_multicast_list will be called anyway by Linux when we do ifconfig up */
-	/* and will re-set the promiscuous feature if needed */
-	if (dev->flags & IFF_PROMISC) {
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 0))
-			printk(KERN_ERR "mv_switch_promisc_set to 0 failed\n");
-	}
-	mv_eth_switch_started--;
-	if (mv_eth_switch_started == 0)	{
-		/* first make sure that the port finished its Rx polling - see tg3 */
-		/* otherwise it may cause issue in SMP, one CPU is here and the other is doing the polling */
-		/* and both of it are messing with the descriptors rings!! */
-		for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-			napi_disable(priv->napiGroup[group]);
-
-		/* stop tx/rx activity, mask all interrupts, relese skb in rings,*/
-		mv_eth_stop_internals(priv);
-
-		for_each_possible_cpu(cpu) {
-			cpuCtrl = priv->cpu_config[cpu];
-			del_timer(&cpuCtrl->tx_done_timer);
-			clear_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(priv->flags));
-			del_timer(&cpuCtrl->cleanup_timer);
-			clear_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags));
-		}
-
-		if (dev->irq != 0)
-			free_irq(dev->irq, priv);
-	}
-	printk(KERN_NOTICE "%s: stopped\n", dev->name);
-
-	return 0;
-}
-
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-
-void mv_eth_switch_interrupt_unmask(int qsgmii_module, int gephy_on_port)
-{
-#ifdef MV_INCLUDE_ETH_COMPLEX
-	MV_U32 reg;
-
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_MASK_REG);
-
-	if (qsgmii_module) {
-		reg |= (MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
-
-	if (gephy_on_port >= 0)
-		reg |= MV_ETHCOMP_GEPHY_INT_MASK;
-
-	reg |= MV_ETHCOMP_SWITCH_INT_MASK;
-
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_MASK_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-}
-
-void mv_eth_switch_interrupt_clear(int qsgmii_module, int gephy_on_port)
-{
-#ifdef MV_INCLUDE_ETH_COMPLEX
-	MV_U32 reg;
-
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_CAUSE_REG);
-
-	if (qsgmii_module) {
-		reg &= ~(MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
-
-	if (gephy_on_port >= 0)
-		reg &= ~MV_ETHCOMP_GEPHY_INT_MASK;
-
-	reg &= ~MV_ETHCOMP_SWITCH_INT_MASK;
-
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_CAUSE_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-}
-
-void mv_eth_switch_update_link(unsigned int p, unsigned int link_up)
-{
-	struct eth_netdev *dev_priv = NULL;
-	struct eth_port *priv = NULL;
-	int i = 0;
-	unsigned int prev_ports_link = 0;
-
-	for (i = 0; i < mv_net_devs_num; i++) {
-
-		if (mv_net_devs[i] == NULL)
-			break;
-
-		priv = MV_ETH_PRIV(mv_net_devs[i]);
-		if (priv == NULL)
-			break;
-
-		if (!(priv->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)))
-			continue;
-
-		dev_priv = MV_DEV_PRIV(mv_net_devs[i]);
-		if (dev_priv == NULL)
-			break;
-
-		if ((dev_priv->port_map & (1 << p)) == 0)
-			continue;
-
-		prev_ports_link = dev_priv->link_map;
-
-		if (link_up)
-			dev_priv->link_map |= (1 << p);
-		else
-			dev_priv->link_map &= ~(1 << p);
-
-		if ((prev_ports_link != 0) && (dev_priv->link_map == 0) && netif_running(mv_net_devs[i])) {
-			/* link down */
-			netif_carrier_off(mv_net_devs[i]);
-			netif_tx_stop_all_queues(mv_net_devs[i]);
-			printk(KERN_ERR "%s: link down\n", mv_net_devs[i]->name);
-		} else if ((prev_ports_link == 0) && (dev_priv->link_map != 0) && netif_running(mv_net_devs[i])) {
-			/* link up */
-			if (mv_eth_ctrl_is_tx_enabled(priv) == 1) {
-				netif_carrier_on(mv_net_devs[i]);
-				netif_tx_wake_all_queues(mv_net_devs[i]);
-				printk(KERN_ERR "%s: link up\n", mv_net_devs[i]->name);
-			}
-		}
-	}
-}
-
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
-int     mv_eth_switch_port_add(struct net_device *dev, int port)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	int i, switch_port, err = 0;
-
-	if (dev_priv == NULL) {
-		printk(KERN_ERR "%s is not connected to the switch\n", dev->name);
-		return 1;
-	}
-
-	if (netif_running(dev)) {
-		printk(KERN_ERR "%s must be down to change switch ports map\n", dev->name);
-		return 1;
-	}
-
-	switch_port = mvBoardSwitchPortGet(0, port);
-
-	if (switch_port < 0) {
-		printk(KERN_ERR "Switch port %d can't be added\n", port);
-		return 1;
-	}
-
-	if (MV_BIT_CHECK(switch_enabled_ports, switch_port)) {
-		printk(KERN_ERR "Switch port %d is already enabled\n", port);
-		return 0;
-	}
-
-	/* Update data base */
-	dev_priv->port_map |= (1 << switch_port);
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] |= (1 << switch_port);
-	}
-	switch_enabled_ports |= (1 << switch_port);
-	dev_priv->tx_vlan_mh = cpu_to_be16((MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id) << 12) | dev_priv->port_map);
-
-	err = mv_switch_port_add(switch_port, dev_priv->vlan_grp_id, dev_priv->port_map);
-	if (!err)
-		printk(KERN_ERR "%s: Switch port #%d mapped\n", dev->name, port);
-
-	return err;
-}
-
-int     mv_eth_switch_port_del(struct net_device *dev, int port)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	int i, switch_port, err = 0;
-
-	if (dev_priv == NULL) {
-		printk(KERN_ERR "%s is not connected to the switch\n", dev->name);
-		return 1;
-	}
-
-	if (netif_running(dev)) {
-		printk(KERN_ERR "%s must be down to change switch ports map\n", dev->name);
-		return 1;
-	}
-
-	switch_port = mvBoardSwitchPortGet(0, port);
-
-	if (switch_port < 0) {
-		printk(KERN_ERR "Switch port %d can't be added\n", port);
-		return 1;
-	}
-
-	if (!MV_BIT_CHECK(switch_enabled_ports, switch_port)) {
-		printk(KERN_ERR "Switch port %d is already disabled\n", port);
-		return 0;
-	}
-
-	if (!MV_BIT_CHECK(dev_priv->port_map, switch_port)) {
-		printk(KERN_ERR "Switch port %d is not mapped on %s\n", port, dev->name);
-		return 0;
-	}
-
-	/* Update data base */
-	dev_priv->port_map &= ~(1 << switch_port);
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] &= ~(1 << switch_port);
-	}
-	dev_priv->link_map &= ~(1 << switch_port);
-	switch_enabled_ports &= ~(1 << switch_port);
-	dev_priv->tx_vlan_mh = cpu_to_be16((MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id) << 12) | dev_priv->port_map);
-
-	err = mv_switch_port_del(switch_port, dev_priv->vlan_grp_id, dev_priv->port_map);
-	if (!err)
-		printk(KERN_ERR "%s: Switch port #%d unmapped\n", dev->name, port);
-
-	return err;
-}
-
-void    mv_eth_switch_status_print(int port)
-{
-	int i;
-	struct eth_port *pp = mv_eth_port_by_id(port);
-	struct net_device *dev;
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		printk(KERN_ERR "ethPort=%d: mv_eth_switch status - pp=%p, flags=0x%lx\n", port, pp, pp->flags);
-
-		printk(KERN_ERR "mtu=%d, netdev_max=%d, netdev_cfg=%d, first=%d, last=%d\n",
-			switch_net_config[port].mtu, switch_net_config[port].netdev_max, switch_net_config[port].netdev_cfg,
-			mv_eth_switch_netdev_first, mv_eth_switch_netdev_last);
-
-		for (i = 0; i < switch_net_config[port].netdev_cfg; i++) {
-			printk(KERN_ERR "MAC="MV_MACQUAD_FMT", board_port_map=0x%x\n",
-				MV_MACQUAD(switch_net_config[port].mac_addr[i]), switch_net_config[port].board_port_map[i]);
-		}
-		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-			dev = mv_eth_netdev_by_id(i);
-			if (dev)
-				mv_eth_netdev_print(dev);
-		}
-	} else
-		printk(KERN_ERR "ethPort=%d: switch is not connected - pp=%p, flags=0x%lx\n", port, pp, pp->flags);
-}
-
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 3fbedf2..8f7955f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -44,24 +44,26 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "cd                             bm            - move to BM sysfs directory\n");
-	off += sprintf(buf+off, "cd                             napi          - move to NAPI groups API sysfs directory\n");
-	off += sprintf(buf+off, "cd                             rx            - move to RX sysfs directory\n");
-	off += sprintf(buf+off, "cd                             tx            - move to TX sysfs directory\n");
-	off += sprintf(buf+off, "cd                             tx_sched      - move to TX Scheduler sysfs directory\n");
-	off += sprintf(buf+off, "cd                             pon           - move to PON sysfs directory\n");
-	off += sprintf(buf+off, "cd                             pme           - move to PME sysfs directory\n");
-	off += sprintf(buf+off, "cd                             qos           - move to QoS sysfs directory\n\n");
-
-	off += sprintf(buf+off, "cat                            addrDec       - print address decode registers\n");
-	off += sprintf(buf+off, "echo p {0|1|2|3}             > tag           - None[3], Use Marvell Header[1], use DSA tag[2], Use EDSA tag[3]\n");
-	off += sprintf(buf+off, "echo {0|1}                   > pnc           - enable / disable Parser and Classifier access\n");
-	off += sprintf(buf+off, "echo [p]                     > port          - show a port info\n");
-	off += sprintf(buf+off, "echo [p]                     > cntrs         - show a port MIB counters\n");
-	off += sprintf(buf+off, "echo [p] [hex]               > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump\n");
-	off += sprintf(buf+off, "echo [p]                     > stats         - show port [p] statistics\n");
-	off += sprintf(buf+off, "echo [p]                     > isrRegs       - show ISR registers for port <p> range [0..max]\n");
-	off += sprintf(buf+off, "echo [p]                     > dropCntrs     - show drop counters for port <p> range [0..max]\n");
+	off += sprintf(buf+off, "cd                       bm            - move to BM sysfs directory\n");
+	off += sprintf(buf+off, "cd                       napi          - move to NAPI groups API sysfs directory\n");
+	off += sprintf(buf+off, "cd                       rx            - move to RX sysfs directory\n");
+	off += sprintf(buf+off, "cd                       tx            - move to TX sysfs directory\n");
+	off += sprintf(buf+off, "cd                       tx_sched      - move to TX Scheduler sysfs directory\n");
+	off += sprintf(buf+off, "cd                       pon           - move to PON sysfs directory\n");
+	off += sprintf(buf+off, "cd                       pme           - move to PME sysfs directory\n");
+	off += sprintf(buf+off, "cd                       qos           - move to QoS sysfs directory\n\n");
+
+	off += sprintf(buf+off, "cat                      addrDec       - print address decode registers\n");
+	off += sprintf(buf+off, "echo p {0|1|2|3}       > tag           - None[3], Use Marvell Header[1], use DSA tag[2], Use EDSA tag[3]\n");
+	off += sprintf(buf+off, "echo p {0|1}           > etypeDsaMod   - EtherType DSA[0], EtherType EDSA[1],meaningless if port in DSA/EDSA mode\n");
+	off += sprintf(buf+off, "echo [hex]             > etypeDsa      - Set new DSA etherType value, ,meaningless if all ports in DSA/EDSA mode\n");
+	off += sprintf(buf+off, "echo {0|1}             > pnc           - enable / disable Parser and Classifier access\n");
+	off += sprintf(buf+off, "echo [p]               > port          - show a port info\n");
+	off += sprintf(buf+off, "echo [p]               > cntrs         - show a port MIB counters\n");
+	off += sprintf(buf+off, "echo [p] [hex]         > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump, bit5:buff_hdr\n");
+	off += sprintf(buf+off, "echo [p]               > stats         - show port [p] statistics\n");
+	off += sprintf(buf+off, "echo [p]               > isrRegs       - show ISR registers for port <p> range [0..max]\n");
+	off += sprintf(buf+off, "echo [p]               > dropCntrs     - show drop counters for port <p> range [0..max]\n");
 
 	return off;
 }
@@ -118,6 +120,8 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		mv_eth_ctrl_pnc(p);
 	} else if (!strcmp(name, "tag")) {
 		mvPp2PrsTagModeSet(p, v);
+	} else if (!strcmp(name, "etypeDsaMod")) {
+		mvPp2PrsEtypeDsaModeSet(p, v);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -155,6 +159,7 @@ static ssize_t mv_eth_2_hex_store(struct device *dev,
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_ISR,  v & 0x4);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_POLL, v & 0x8);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_DUMP, v & 0x10);
+		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_BUFF_HDR, v & 0x20);
 	}
 #endif
 
@@ -183,6 +188,8 @@ static ssize_t mv_eth_reg_store(struct device *dev,
 		printk("regRead val: 0x%08x\n", v);
 	}  else if (!strcmp(name, "regWrite")) {
 		mvPp2WrReg(r, v);
+	} else if (!strcmp(name, "etypeDsa")) {
+		mvPp2PrsEtypeDsaSet(r);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -204,6 +211,8 @@ static DEVICE_ATTR(dropCntrs,    S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(stats,        S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(pnc,        S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(tag,        S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(etypeDsaMod,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(etypeDsa,	S_IWUSR, NULL, mv_eth_reg_store);
 static DEVICE_ATTR(port,         S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(cntrs,        S_IWUSR, NULL, mv_eth_port_store);
 
@@ -221,6 +230,8 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_stats.attr,
 	&dev_attr_pnc.attr,
 	&dev_attr_tag.attr,
+	&dev_attr_etypeDsaMod.attr,
+	&dev_attr_etypeDsa.attr,
 	&dev_attr_regRead.attr,
 	&dev_attr_regWrite.attr,
 	NULL
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 6ec7edd..00cfe27 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -53,7 +53,6 @@ disclaimer.
 #include "prs/mvPp2Prs.h"
 #include "prs/mvPp2PrsHw.h"
 #include "cls/mvPp2Classifier.h"
-#include "mv_switch.h"
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
 
@@ -897,98 +896,6 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_select_queue = mv_eth_select_txq,
 };
 
-#ifdef CONFIG_MV_ETH_SWITCH
-static const struct net_device_ops mv_switch_netdev_ops = {
-	.ndo_open = mv_eth_switch_start,
-	.ndo_stop = mv_eth_switch_stop,
-	.ndo_start_xmit = mv_eth_tx,
-	.ndo_set_mac_address = mv_eth_switch_set_mac_addr,
-	.ndo_change_mtu = mv_eth_switch_change_mtu,
-	.ndo_tx_timeout = mv_eth_tx_timeout,
-	.ndo_change_rx_flags = mv_eth_change_rx_flags,
-	.ndo_set_rx_mode = mv_eth_set_rx_mode,
-};
-
-int mv_eth_switch_netdev_first = 0;
-int mv_eth_switch_netdev_last = 0;
-
-static inline struct net_device *mv_eth_switch_netdev_get(struct eth_port *pp, struct eth_pbuf *pkt)
-{
-	MV_U8 *data;
-	int db_num;
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		data = pkt->pBuf + pkt->offset;
-
-		/* bits[4-7] of MSB in Marvell header */
-		db_num = ((*data) >> 4);
-
-		return mv_net_devs[mv_eth_switch_netdev_first + db_num];
-	}
-	return pp->dev;
-}
-
-void mv_eth_switch_priv_update(struct net_device *netdev, int i)
-{
-	struct eth_netdev *dev_priv;
-	struct eth_port *pp = MV_ETH_PRIV(netdev);
-	int print_flag, port, switch_port;
-
-	/* Update dev_priv structure */
-	dev_priv = MV_DEV_PRIV(netdev);
-	dev_priv->port_map = 0;
-	dev_priv->link_map = 0;
-
-	print_flag = 1;
-	for (port = 0; port < BOARD_ETH_SWITCH_PORT_NUM; port++) {
-		if (switch_net_config[pp->port].board_port_map[i] & (1 << port)) {
-			if (print_flag) {
-				printk(KERN_CONT ". Interface ports: ");
-				print_flag = 0;
-			}
-			printk(KERN_CONT "%d ", port);
-			switch_port = mvBoardSwitchPortGet(MV_SWITCH_ID_0, port);
-			if (switch_port >= 0) {
-				dev_priv->port_map |= (1 << switch_port);
-				switch_enabled_ports |= (1 << switch_port);
-			}
-		}
-	}
-	printk(KERN_CONT "\n");
-	dev_priv->group = i;
-	dev_priv->vlan_grp_id = MV_SWITCH_GROUP_VLAN_ID(i);	/* e.g. 0x100, 0x200... */
-	dev_priv->tx_vlan_mh = cpu_to_be16((i << 12) | dev_priv->port_map);
-	dev_priv->cpu_port = mvBoardSwitchCpuPortGet(MV_SWITCH_ID_0);
-
-	mv_eth_switch_vlan_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port);
-}
-
-
-int mv_eth_switch_netdev_init(struct eth_port *pp, int dev_i,
-				struct platform_device *pdev)
-{
-	int i;
-	struct net_device *netdev;
-
-	switch_enabled_ports = 0;
-
-	for (i = 0; i < switch_net_config[pp->port].netdev_max; i++) {
-		netdev = mv_eth_netdev_init(pp, switch_net_config[pp->port].mtu, switch_net_config[pp->port].mac_addr[i],
-						pdev);
-		if (netdev == NULL) {
-			printk(KERN_ERR "mv_eth_switch_netdev_init: can't create netdevice\n");
-			break;
-		}
-		mv_net_devs[dev_i++] = netdev;
-
-		mv_eth_switch_priv_update(netdev, i);
-
-	}
-	return dev_i;
-}
-
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 void mv_eth_link_status_print(int port)
 {
 	MV_ETH_PORT_STATUS link;
@@ -1458,25 +1365,23 @@ inline struct pp2_rx_desc *mv_eth_rx_prefetch(struct eth_port *pp, MV_PP2_PHYS_R
 }
 #endif /* CONFIG_MV_ETH_RX_DESC_PREFETCH */
 
-#define GET_BUFF_FROM_PKT(pkt) 	((MV_U32)((struct eth_pbuf *)pkt)->pBuf)
 static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 {
 	u32 rx_status = rx_desc->status;
 	int mc_id, pool_id;
 	PP2_BUFF_HDR *buff_hdr;
-	MV_U32 buff_phys_addr, buff_virt_addr;
+	MV_U32 buff_phys_addr, buff_virt_addr, buff_phys_addr_next, buff_virt_addr_next;
 
 	pool_id = (rx_status & PP2_RX_BM_POOL_ALL_MASK) >> PP2_RX_BM_POOL_ID_OFFS;
 	buff_phys_addr = rx_desc->bufPhysAddr;
-	/* for SWF we need pkt structure. for HWF we just need the buffer virt address */
-	buff_virt_addr = GET_BUFF_FROM_PKT(rx_desc->bufCookie);
+	buff_virt_addr = rx_desc->bufCookie;
 
 	do {
-		buff_hdr = (PP2_BUFF_HDR *)buff_virt_addr;
+		buff_hdr = (PP2_BUFF_HDR *)(((struct eth_pbuf *)buff_virt_addr)->pBuf);
 		mc_id = PP2_BUFF_HDR_INFO_MC_ID(buff_hdr->info);
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-		if (pp->dbg_flags & MV_ETH_F_DBG_RX) {
+		if (pp->dbg_flags & MV_ETH_F_DBG_BUFF_HDR) {
 			printk(KERN_ERR "buff header #%d:\n", ++count);
 			mvDebugMemDump(buff_hdr, 32, 1);
 
@@ -1486,11 +1391,14 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 		}
 #endif
 
+		buff_phys_addr_next = buff_hdr->nextBuffPhysAddr;
+		buff_virt_addr_next = buff_hdr->nextBuffVirtAddr;
+
 		/* release buffer */
 		mvBmPoolMcPut(pool_id, buff_phys_addr, buff_virt_addr, mc_id, 0);
 
-		buff_phys_addr = buff_hdr->nextBuffPhysAddr;
-		buff_virt_addr = GET_BUFF_FROM_PKT(buff_hdr->nextBuffVirtAddr);
+		buff_phys_addr = buff_phys_addr_next;
+		buff_virt_addr = buff_virt_addr_next;
 	} while (!PP2_BUFF_HDR_INFO_IS_LAST(buff_hdr->info));
 
 #ifdef CONFIG_MV_ETH_STAT_DBG
@@ -1570,11 +1478,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		/* Speculative ICache prefetch WA: should be replaced with dma_unmap_single (invalidate l2) */
 		mvOsCacheMultiLineInv(NULL, pkt->pBuf + pkt->offset, rx_desc->dataSize);
 
-#ifdef CONFIG_MV_ETH_SWITCH
-		dev = mv_eth_switch_netdev_get(pp, pkt);
-#else
 		dev = pp->dev;
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 		STAT_DBG(pp->stats.rxq[rxq]++);
 		dev->stats.rx_packets++;
@@ -2392,7 +2296,7 @@ static int mv_eth_pool_add(int pool, int buf_num)
 	struct bm_pool *bm_pool;
 	struct sk_buff *skb;
 	struct eth_pbuf *pkt;
-	unsigned char *hwf_buff, *hwf_buff_phys;
+	unsigned char *hwf_buff;
 	int i, buff_size;
 	unsigned long flags = 0;
 
@@ -2641,7 +2545,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 	/* Read cause register */
 	causeRxTx = mvPp2GbeIsrCauseRxTxGet(pp->port);
 
-	if (causeRxTx & MV_PP2_CAUSE_MISC_ERR_SUM_MASK) {
+	if (causeRxTx & MV_PP2_CAUSE_MISC_SUM_MASK) {
 		if (causeRxTx & MV_PP2_CAUSE_FCS_ERR_MASK)
 			printk(KERN_ERR "%s: FCS error\n", __func__);
 
@@ -2656,7 +2560,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 			MV_REG_WRITE(MV_PP2_ISR_MISC_CAUSE_REG, 0);
 		}
 
-		causeRxTx &= ~MV_PP2_CAUSE_MISC_ERR_SUM_MASK;
+		causeRxTx &= ~MV_PP2_CAUSE_MISC_SUM_MASK;
 		MV_REG_WRITE(MV_PP2_ISR_RX_TX_CAUSE_REG(MV_PPV2_PORT_PHYS(pp->port)), causeRxTx);
 	}
 	group_id = pp->cpu_config[smp_processor_id()]->napi_group_id;
@@ -2896,35 +2800,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 			return err;
 	}
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-		int status = mv_eth_switch_config_get(mv_eth_initialized, port);
-
-		if (status < 0) {
-			printk(KERN_ERR "\nWarning: port %d - Invalid netconfig string\n", port);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		}
-		if (status == 0) {	/* User selected to work with Gateway driver    */
-			clear_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
-		} else if (status == 1) {
-			/* User selected to work without Gateway driver */
-			clear_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
-			printk(KERN_ERR "  o Working in External, plat_data->mtu Switch mode\n");
-			ext_switch_port_mask = mv_switch_link_detection_init();
-		}
-	}
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
-		mtu = switch_net_config[port].mtu;
-		if (mv_switch_init(RX_PKT_SIZE(mtu), SWITCH_CONNECTED_PORTS_MASK)) {
-			printk(KERN_ERR "\nWarning: port %d - Switch initialization failed\n", port);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		}
-	} else
-#endif /* CONFIG_MV_ETH_SWITCH */
-		mtu = mv_eth_config_get(pdev, mac);
+	mtu = mv_eth_config_get(pdev, mac);
 
 	printk(KERN_ERR "\t%s p=%d: mtu=%d, mac=%p\n", MV_PON_PORT(port) ? "pon" : "giga", port, mtu, mac);
 
@@ -2934,26 +2810,6 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		return -EIO;
 	}
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		int queue = CONFIG_MV_ETH_RXQ_DEF;
-
-		mv_eth_switch_netdev_first = dev_i;
-		dev_i = mv_eth_switch_netdev_init(pp, dev_i, pdev);
-		if (dev_i < (mv_eth_switch_netdev_first + switch_net_config[port].netdev_max)) {
-			printk(KERN_ERR "%s: can't create netdevice for switch\n", __func__);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		}
-		mv_eth_switch_netdev_last = dev_i - 1;
-
-		/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch */
-		mv_eth_port_promisc_set(pp->port, queue);
-		handle_group_affinity(port);
-		return 0;
-	}
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 	mv_net_devs[dev_i] = mv_eth_netdev_init(pp, mtu, mac, pdev);
 	if (!mv_net_devs[dev_i]) {
 		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
@@ -3114,11 +2970,6 @@ static int	mv_eth_shared_probe(void)
 			printk(KERN_ERR "%s: Warning Classifier defauld init failed\n", __func__);
 	}
 
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-	if (mv_switch_load(SWITCH_CONNECTED_PORTS_MASK))
-		printk(KERN_ERR "\nWarning: Switch load failed\n");
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
-
 	mv_eth_initialized = 1;
 	return 0;
 
@@ -3150,10 +3001,6 @@ static int mv_eth_probe(struct platform_device *pdev)
 		mv_eth_ports_num = mvCtrlEthMaxPortGet();
 		mv_net_devs_max = mv_eth_ports_num;
 
-#ifdef CONFIG_MV_ETH_SWITCH
-		mv_net_devs_max += (CONFIG_MV_ETH_SWITCH_NETDEV_NUM - 1);
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 		if (mv_eth_shared_probe())
 			return -ENODEV;
 	}
@@ -3237,29 +3084,7 @@ TODO:change
 	dev->tx_queue_len = CONFIG_MV_ETH_TXQ_DESC;
 	dev->watchdog_timeo = 5 * HZ;
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-
-		if (pp->flags & MV_ETH_F_SWITCH)
-			dev->netdev_ops = &mv_switch_netdev_ops;
-		else
-			dev->netdev_ops = &mv_eth_netdev_ops;
-
-		dev_priv->netdev_p = mvOsMalloc(sizeof(struct eth_netdev));
-		if (!dev_priv->netdev_p) {
-			printk(KERN_ERR "failed to allocate eth_netdev\n");
-			free_netdev(dev);
-			return NULL;
-		}
-		memset(dev_priv->netdev_p, 0, sizeof(struct eth_netdev));
-		/* For correct link information of Linux interface: */
-		if (pp->flags & MV_ETH_F_EXT_SWITCH) {
-			dev_priv->netdev_p->port_map = ext_switch_port_mask;
-			dev_priv->netdev_p->link_map = 0;
-		}
-	} else
-#endif /* CONFIG_MV_ETH_SWITCH */
-		dev->netdev_ops = &mv_eth_netdev_ops;
+	dev->netdev_ops = &mv_eth_netdev_ops;
 
 #ifdef CONFIG_MV_ETH_TOOL
 	SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);
@@ -3282,12 +3107,7 @@ TODO:change
 			return NULL;
 		} else {
 			printk(KERN_ERR "    o %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
-#ifdef CONFIG_MV_ETH_SWITCH
-			if (!(pp->flags & MV_ETH_F_SWITCH))
-				printk(KERN_CONT "\n");
-#else
 			printk(KERN_CONT "\n");
-#endif
 		}
 	}
 	return dev;
@@ -4300,12 +4120,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	pp->rx_csum_offload = 1;
 #endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD_DEF */
 
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-	if (mvBoardSwitchConnectedPortGet(port) != -1) {
-		set_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
-		set_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
-	}
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		memset(&cpuCtrl->tx_done_timer, 0, sizeof(struct timer_list));
@@ -4542,10 +4356,6 @@ void mv_eth_port_status_print(unsigned int port)
 	printk(KERN_CONT "\n");
 
 	mv_eth_napi_groups_print(port);
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & MV_ETH_F_SWITCH)
-		mv_eth_switch_status_print(port);
-#endif /* CONFIG_MV_ETH_SWITCH */
 }
 
 /***********************************************************************************
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 6fdcfda..82a5a9f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -233,12 +233,14 @@ struct port_stats {
 #define MV_ETH_F_DBG_DUMP_BIT       2
 #define MV_ETH_F_DBG_ISR_BIT        3
 #define MV_ETH_F_DBG_POLL_BIT       4
+#define MV_ETH_F_DBG_BUFF_HDR_BIT   5
 
 #define MV_ETH_F_DBG_RX            (1 << MV_ETH_F_DBG_RX_BIT)
 #define MV_ETH_F_DBG_TX            (1 << MV_ETH_F_DBG_TX_BIT)
 #define MV_ETH_F_DBG_DUMP          (1 << MV_ETH_F_DBG_DUMP_BIT)
 #define MV_ETH_F_DBG_ISR           (1 << MV_ETH_F_DBG_ISR_BIT)
 #define MV_ETH_F_DBG_POLL          (1 << MV_ETH_F_DBG_POLL_BIT)
+#define MV_ETH_F_DBG_BUFF_HDR      (1 << MV_ETH_F_DBG_BUFF_HDR_BIT)
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
 /* Masks used for cpu_ctrl->flags */
@@ -692,31 +694,6 @@ static inline void mv_eth_rxq_refill(struct eth_port *pp, int rxq,
 	mvOsCacheLineInv(NULL, rx_desc);
 }
 
-
-#ifdef CONFIG_MV_ETH_SWITCH
-struct mv_eth_switch_config {
-	int             mtu;
-	int             netdev_max;
-	int             netdev_cfg;
-	unsigned char   mac_addr[CONFIG_MV_ETH_SWITCH_NETDEV_NUM][MV_MAC_ADDR_SIZE];
-	u16             board_port_map[CONFIG_MV_ETH_SWITCH_NETDEV_NUM];
-};
-
-extern int  mv_eth_switch_netdev_first, mv_eth_switch_netdev_last;
-extern struct mv_eth_switch_config      switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
-extern struct net_device **mv_net_devs;
-
-int     mv_eth_switch_config_get(int use_existing_config, int port);
-int     mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac);
-int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu);
-int     mv_eth_switch_start(struct net_device *dev);
-int     mv_eth_switch_stop(struct net_device *dev);
-void    mv_eth_switch_status_print(int port);
-int     mv_eth_switch_port_add(struct net_device *dev, int port);
-int     mv_eth_switch_port_del(struct net_device *dev, int port);
-
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 /******************************************************
  * Function prototypes --                             *
  ******************************************************/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
index aee312d..6372515 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
@@ -56,10 +56,6 @@ static ssize_t mv_prs_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_inv      - invalidate parser entry <id> in hw.\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo         > hw_inv_all  - invalidate all parser entries in HW.\n");
 
-	/* TODO- remove next command, only for debug */
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e > hw_flow    - write flow entry to HW\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "                             flowId <a>, result <b>, result mask <c>, port <d>, tcam index <e>.\n");
-
 	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p m     > t_port      - add<m=1> or delete<m=0> port<p> in SW entry.\n");
@@ -78,6 +74,17 @@ static ssize_t mv_prs_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p l m o > hw_frst_itr - set values for first iteration port <p>, lookupid <l>, \n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "				  max loops <m>, init offs <o>.\n");
 
+	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
+
+	/* TODO- remove next command, only for debug */
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e > hw_flow     - write flow entry to HW\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               flowId <a>, result <b>, result mask <c>, port <d>, tcam index <e>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c     > hw_vlan1    - single vlan entry tpid1 <a>, ports bitmap <b>, add/del <c=1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d   > hw_vlan2    - double vlan entry tpid1 <a>, tpid2 <b>, ports bitmap <c>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               add/del <d=1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo a b c d e > hw_vlan3    - double vlan entry tpid1 <a>, tpid2 <b>, tpid3 <c>, ports bitmap <d>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "                               add/del <e=1/0>.\n");
+
 	return off;
 }
 
@@ -184,7 +191,12 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 				mvPp2PrsSwSramFlowidGenClear(&pe);
 	else if (!strcmp(name, "hw_flow"))
 		mvPrsFlowIdGen(e, a, b, c, d);
-
+	else if (!strcmp(name, "hw_vlan1"))
+		mvPp2PrsSingleVlan(a, b, c);
+	else if (!strcmp(name, "hw_vlan2"))
+		mvPp2PrsDoubleVlan(a, b, c, d);
+	else if (!strcmp(name, "hw_vlan3"))
+		mvPp2PrsTripleVlan(a, b, c, d, e);
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -220,9 +232,9 @@ static DEVICE_ATTR(s_lu_done,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(s_fid_gen,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_show, mv_prs_store_signed);
 static DEVICE_ATTR(hw_flow,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
-
-
-
+static DEVICE_ATTR(hw_vlan1,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(hw_vlan2,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(hw_vlan3,		S_IWUSR, mv_prs_show, mv_prs_store_unsigned);
 
 static struct attribute *prs_attrs[] = {
     &dev_attr_hw_dump.attr,
@@ -248,6 +260,9 @@ static struct attribute *prs_attrs[] = {
     &dev_attr_hw_frst_itr.attr,
     &dev_attr_help.attr,
     &dev_attr_hw_flow.attr,
+    &dev_attr_hw_vlan1.attr,
+    &dev_attr_hw_vlan2.attr,
+    &dev_attr_hw_vlan3.attr,
     NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
index d8937ea..e14c7f1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
@@ -5,4 +5,4 @@ ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o mv_switch_sysfs.o
+obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o
-- 
1.7.5.4

