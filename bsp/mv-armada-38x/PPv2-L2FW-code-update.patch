From e05ed16559e149dbea45626f15b59d7f6afa346b Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Mon, 5 Aug 2013 16:42:23 +0300
Subject: [PATCH 0933/1825] PPv2: L2FW code update

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b8e3c63c008893e2dfcf609dc192c187a898a479

	- remove eth_buff
	- remove txdone
	- change sysfs commands
	- new port init/clean functions
	- support up/down
	- support mtu change
	- support mac address change

Change-Id: Ifb4dcdb2b2d9988fa644b7f1914d291606e651af
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2962
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Jonatan Farhadian <yonif@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c        |  116 ++--
 .../mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c       |  702 ++++++++++++--------
 .../mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.h       |   35 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |    8 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  112 ++--
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   15 +-
 6 files changed, 593 insertions(+), 395 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
index 8245eff..50c516c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
@@ -40,26 +40,27 @@ disclaimer.
 #include "linux/inet.h"
 
 
-static ssize_t l2fw_help(char *buf)
+static ssize_t mv_l2fw_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "cat rules_dump      - display L2fw rules DB\n");
-	off += sprintf(buf+off, "cat ports_dump      - display L2fw ports DB\n");
-	off += sprintf(buf+off, "cat stats           - show debug information\n");
-
-	off += sprintf(buf+off, "echo rxp txp mode > l2fw     - set <rxp-->txp,mode> 0-dis,1-as_is,2-swap,3-copy\n");
-	off += sprintf(buf+off, "echo rxp thresh   > l2fw_xor - set for port <rxp> xor threshold ,input in decimal\n");
-	off += sprintf(buf+off, "echo rxp en       > lookup   - set for port <rxp> lookup enable:0 or disable:1\n");
-	off += sprintf(buf+off, "echo 1            > flush    - flush L2fw rules DB\n");
-	off += sprintf(buf+off, "echo sIp dIp txp  > l2fw_ip  - set rule, srcIp and DstIp in ip address format\n");
+	off += sprintf(buf+off, "cat rules_dump      - Display L2fw rules DB\n");
+	off += sprintf(buf+off, "cat ports_dump      - Display L2fw ports DB\n");
+	off += sprintf(buf+off, "cat stats           - Show debug information\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo p [1,0]      > l2fw     - Enable/Disable port <p> l2fw\n");
+	off += sprintf(buf+off, "echo rxp txp mode > bind     - Set <rxp-->txp,mode> 0-as_is,1-swap,2-copy\n");
+	off += sprintf(buf+off, "echo rxp thresh   > xor - Set for port <rxp> xor threshold ,input in decimal\n");
+	off += sprintf(buf+off, "echo rxp en       > lookup   - Set for port <rxp> lookup enable:0 or disable:1\n");
+	off += sprintf(buf+off, "echo 1            > flush    - Flush L2fw rules DB\n");
+	off += sprintf(buf+off, "echo sIp dIp txp  > add_ip   - Set rule, srcIp and DstIp in ip address format\n");
 #ifdef CONFIG_MV_ETH_L2SEC
-	off += sprintf(buf+off, "echo p chan       > cesa_chan- set cesa channel <chan> for port <p>.\n");
+	off += sprintf(buf+off, "echo p chan       > cesa_chan- Set cesa channel <chan> for port <p>.\n");
 #endif
 	return off;
 }
 
-static ssize_t l2fw_show(struct device *dev,
+static ssize_t mv_l2fw_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	int off = 0;
@@ -68,26 +69,24 @@ static ssize_t l2fw_show(struct device *dev,
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	if (!strcmp(name, "help")) {
-		off = l2fw_help(buf);
-		return off;
-	} else if (!strcmp(name, "rules_dump")) {
-		l2fw_rules_dump();
-		return off;
-	} else if (!strcmp(name, "ports_dump")) {
-		l2fw_ports_dump();
-		return off;
-	} else if (!strcmp(name, "stats")) {
-		l2fw_stats();
-		return off;
-	}
+	if (!strcmp(name, "help"))
+		off = mv_l2fw_help(buf);
+
+	else if (!strcmp(name, "rules_dump"))
+		mv_l2fw_rules_dump();
+
+	else if (!strcmp(name, "ports_dump"))
+		mv_l2fw_ports_dump();
+
+	else if (!strcmp(name, "stats"))
+		mv_l2fw_stats();
 
 	return off;
 }
 
 
 
-static ssize_t l2fw_hex_store(struct device *dev, struct device_attribute *attr,
+static ssize_t mv_l2fw_hex_store(struct device *dev, struct device_attribute *attr,
 				const char *buf, size_t len)
 {
 	const char      *name = attr->attr.name;
@@ -103,7 +102,7 @@ static ssize_t l2fw_hex_store(struct device *dev, struct device_attribute *attr,
 	local_irq_save(flags);
 
 	if (!strcmp(name, "flush")) {
-		l2fw_flush();
+		mv_l2fw_flush();
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -114,7 +113,7 @@ static ssize_t l2fw_hex_store(struct device *dev, struct device_attribute *attr,
 	return err ? -EINVAL : len;
 }
 
-static ssize_t l2fw_ip_store(struct device *dev,
+static ssize_t mv_l2fw_ip_store(struct device *dev,
 			 struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char *name = attr->attr.name;
@@ -136,8 +135,8 @@ static ssize_t l2fw_ip_store(struct device *dev,
 	printk(KERN_INFO "0x%x->0x%x in %s\n", srcIp, dstIp, __func__);
 	local_irq_save(flags);
 
-	if (!strcmp(name, "l2fw_add_ip"))
-		l2fw_add(srcIp, dstIp, port);
+	if (!strcmp(name, "add_ip"))
+		mv_l2fw_add(srcIp, dstIp, port);
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -153,7 +152,7 @@ static ssize_t l2fw_ip_store(struct device *dev,
 
 
 
-static ssize_t l2fw_store(struct device *dev,
+static ssize_t mv_l2fw_store(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char	*name = attr->attr.name;
@@ -170,13 +169,17 @@ static ssize_t l2fw_store(struct device *dev,
 
 	local_irq_save(flags);
 	if (!strcmp(name, "lookup"))
-		l2fw_lookupEn(a, b);
+		mv_l2fw_lookupEn(a, b);
 #ifdef CONFIG_MV_INCLUDE_XOR
-	else if (!strcmp(name, "l2fw_xor"))
-		l2fw_xor(a, b);
+	else if (!strcmp(name, "xor"))
+		mv_l2fw_xor(a, b);
 #endif
 	else if (!strcmp(name, "l2fw"))
-		l2fw(c, a, b);
+		err = mv_l2fw_set(a, b);
+
+	else if (!strcmp(name, "bind"))
+		err = mv_l2fw_port(a, b, c);
+
 #ifdef CONFIG_MV_ETH_L2SEC
 	else if (!strcmp(name, "cesa_chan"))
 		err = mv_l2sec_set_cesa_chan(a, b);
@@ -191,32 +194,33 @@ static ssize_t l2fw_store(struct device *dev,
 }
 
 
-static DEVICE_ATTR(l2fw,		S_IWUSR, l2fw_show, l2fw_store);
-#ifdef CONFIG_MV_INCLUDE_XOR
-static DEVICE_ATTR(l2fw_xor,		S_IWUSR, l2fw_show, l2fw_store);
-#endif
-
-static DEVICE_ATTR(lookup,		S_IWUSR, l2fw_show, l2fw_store);
-static DEVICE_ATTR(l2fw_add_ip,		S_IWUSR, l2fw_show, l2fw_ip_store);
-static DEVICE_ATTR(help,		S_IRUSR, l2fw_show,  NULL);
-static DEVICE_ATTR(rules_dump,		S_IRUSR, l2fw_show,  NULL);
-static DEVICE_ATTR(ports_dump,		S_IRUSR, l2fw_show,  NULL);
-static DEVICE_ATTR(flush,		S_IWUSR, NULL,	l2fw_hex_store);
-static DEVICE_ATTR(stats,		S_IRUSR, l2fw_show, NULL);
+static DEVICE_ATTR(l2fw,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
+static DEVICE_ATTR(bind,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
+static DEVICE_ATTR(lookup,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
+static DEVICE_ATTR(add_ip,		S_IWUSR, mv_l2fw_show, mv_l2fw_ip_store);
+static DEVICE_ATTR(help,		S_IRUSR, mv_l2fw_show, NULL);
+static DEVICE_ATTR(rules_dump,		S_IRUSR, mv_l2fw_show, NULL);
+static DEVICE_ATTR(ports_dump,		S_IRUSR, mv_l2fw_show, NULL);
+static DEVICE_ATTR(stats,		S_IRUSR, mv_l2fw_show, NULL);
+static DEVICE_ATTR(flush,		S_IWUSR, NULL,	mv_l2fw_hex_store);
 
 #ifdef CONFIG_MV_ETH_L2SEC
-static DEVICE_ATTR(cesa_chan,		S_IWUSR, NULL,  l2fw_store);
+static DEVICE_ATTR(cesa_chan,		S_IWUSR, NULL,  mv_l2fw_store);
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+static DEVICE_ATTR(xor,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
 #endif
 
 
 
-static struct attribute *l2fw_attrs[] = {
+static struct attribute *mv_l2fw_attrs[] = {
 	&dev_attr_l2fw.attr,
+	&dev_attr_bind.attr,
 #ifdef CONFIG_MV_INCLUDE_XOR
-	&dev_attr_l2fw_xor.attr,
+	&dev_attr_xor.attr,
 #endif
 	&dev_attr_lookup.attr,
-	&dev_attr_l2fw_add_ip.attr,
+	&dev_attr_add_ip.attr,
 	&dev_attr_help.attr,
 	&dev_attr_rules_dump.attr,
 	&dev_attr_ports_dump.attr,
@@ -228,25 +232,25 @@ static struct attribute *l2fw_attrs[] = {
 	NULL
 };
 
-static struct attribute_group l2fw_group = {
+static struct attribute_group mv_l2fw_group = {
 	.name = "l2fw",
-	.attrs = l2fw_attrs,
+	.attrs = mv_l2fw_attrs,
 };
 
 int mv_pp2_l2fw_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err = 0;
 
-	err = sysfs_create_group(pp2_kobj, &l2fw_group);
+	err = sysfs_create_group(pp2_kobj, &mv_l2fw_group);
 	if (err)
-		printk(KERN_INFO "sysfs group %s failed %d\n", l2fw_group.name, err);
+		printk(KERN_INFO "sysfs group %s failed %d\n", mv_l2fw_group.name, err);
 
 	return err;
 }
 
 int mv_pp2_l2fw_sysfs_exit(struct kobject *pp2_kobj)
 {
-	sysfs_remove_group(pp2_kobj, &l2fw_group);
+	sysfs_remove_group(pp2_kobj, &mv_l2fw_group);
 
 	return 0;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
index 5dd8125..a7343ac 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
@@ -26,33 +26,23 @@ DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 
-#include <linux/ctype.h>
-#include <linux/module.h>
-#include  <linux/interrupt.h>
-
 #ifdef CONFIG_MV_INCLUDE_XOR
 #include "xor/mvXor.h"
 #include "xor/mvXorRegs.h"
 #include "mv_hal_if/mvSysXorApi.h"
 #endif
 
-#include "mvOs.h"
 #include "mv_eth_l2fw.h"
 #include "mv_pp2/net_dev/mv_netdev.h"
 #include "gbe/mvPp2Gbe.h"
-#include "gbe/mvPp2GbeRegs.h"
 #include "mvDebug.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
 
 #ifdef CONFIG_MV_ETH_L2SEC
 #include "mv_eth_l2sec.h"
 #endif
 
 static int numHashEntries;
-
-struct eth_pbuf *mv_eth_pool_get(struct bm_pool *pool);
-
-static int mv_eth_ports_l2fw_num;
+static int shared;
 
 static struct l2fw_rule **l2fw_hash;
 
@@ -62,10 +52,16 @@ static MV_U32 l2fw_jhash_iv;
 static MV_XOR_DESC *eth_xor_desc;
 static MV_LONG      eth_xor_desc_phys_addr;
 #endif
+
 struct eth_port_l2fw **mv_eth_ports_l2fw;
-static inline int       mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq);
-static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp,
-					   int withXor, struct pp2_rx_desc *rx_desc);
+inline int mv_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq);
+inline int mv_l2fw_tx(struct sk_buff *skb, struct eth_port *pp, struct pp2_rx_desc *rx_desc);
+inline int mv_l2fw_txq_done(struct eth_port *pp, struct tx_queue *txq_ctrl);
+static int mv_l2fw_port_init(int port);
+static void mv_l2fw_port_free(int port);
+
+static const struct net_device_ops mv_l2fw_netdev_ops;
+static const struct net_device_ops *mv_eth_netdev_ops_ptr;
 
 static struct l2fw_rule *l2fw_lookup(MV_U32 srcIP, MV_U32 dstIP)
 {
@@ -101,18 +97,21 @@ void l2fw_show_numHashEntries(void)
 }
 
 
-void l2fw_flush(void)
+void mv_l2fw_flush(void)
 {
 	MV_U32 i = 0;
 	mvOsPrintf("\nFlushing L2fw Rule Database:\n");
 	mvOsPrintf("*******************************\n");
 	for (i = 0; i < L2FW_HASH_SIZE; i++)
-		l2fw_hash[i] = NULL;
+		if (l2fw_hash[i]) {
+			mvOsFree(l2fw_hash[i]);
+			l2fw_hash[i] = NULL;
+		}
 	numHashEntries = 0;
 }
 
 
-void l2fw_rules_dump(void)
+void mv_l2fw_rules_dump(void)
 {
 	MV_U32 i = 0;
 	struct l2fw_rule *currRule;
@@ -136,24 +135,29 @@ void l2fw_rules_dump(void)
 
 }
 
-void l2fw_ports_dump(void)
+void mv_l2fw_ports_dump(void)
 {
 	MV_U32 rx_port = 0;
 	struct eth_port_l2fw *ppl2fw;
+	int ports = mvCtrlEthMaxPortGet();
 
 	mvOsPrintf("\nPrinting L2fw ports Database:\n");
 	mvOsPrintf("*******************************\n");
 
-	for (rx_port = 0; rx_port < mv_eth_ports_l2fw_num; rx_port++) {
+	if (!mv_eth_ports_l2fw)
+		return;
+
+	for (rx_port = 0; rx_port < ports; rx_port++) {
 		ppl2fw = mv_eth_ports_l2fw[rx_port];
-		mvOsPrintf("rx_port=%d cmd = %d tx_port=%d lookup=%d xor_threshold = %d\n",
-				rx_port, ppl2fw->cmd, ppl2fw->txPort, ppl2fw->lookupEn, ppl2fw->xorThreshold);
+		if (ppl2fw)
+			mvOsPrintf("rx_port=%d cmd = %d tx_port=%d lookup=%d xor_threshold = %d\n",
+					rx_port, ppl2fw->cmd, ppl2fw->txPort, ppl2fw->lookupEn, ppl2fw->xorThreshold);
 
 	}
 }
 
 
-MV_STATUS l2fw_add(MV_U32 srcIP, MV_U32 dstIP, int port)
+int mv_l2fw_add(MV_U32 srcIP, MV_U32 dstIP, int port)
 {
 	struct l2fw_rule *rule;
 	MV_U8	  *srcIPchr, *dstIPchr;
@@ -291,7 +295,7 @@ static int mv_eth_poll_l2fw(struct napi_struct *napi, int budget)
 		if (rx_queue == -1)
 			break;
 
-		count = mv_eth_l2fw_rx(pp, budget, rx_queue);
+		count = mv_l2fw_rx(pp, budget, rx_queue);
 		rx_done += count;
 		budget -= count;
 		if (budget > 0)
@@ -326,80 +330,153 @@ static int mv_eth_poll_l2fw(struct napi_struct *napi, int budget)
 }
 
 
-void mv_eth_set_l2fw(struct eth_port_l2fw *ppl2fw, int cmd, int rx_port, int tx_port)
+static int mv_l2fw_update_napi(struct eth_port *pp, bool l2fw)
 {
-	struct eth_port *pp;
-	struct net_device *dev;
-	struct napi_group_ctrl *napi_group;
 	int group;
+	struct napi_group_ctrl *napi_group;
+
 
+	for (group = 0; group < 1/*MV_ETH_MAX_NAPI_GROUPS*/; group++) {
+		napi_group = pp->napi_group[group];
 /*
-	for multiBuffer validation
-	mvGmacMaxRxSizeSet(rx_port, 9000);
+		if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags)))
+			napi_disable(napi_group->napi);
 */
+		netif_napi_del(napi_group->napi);
 
-	if (cmd == CMD_L2FW_CESA) {
-		mvOsPrintf("Invalid command (%d) - Ipsec is not defined (%s)\n", cmd, __func__);
-		return;
+		if (l2fw)
+			netif_napi_add(pp->dev, napi_group->napi, mv_eth_poll_l2fw, pp->weight);
+		else
+			netif_napi_add(pp->dev, napi_group->napi, mv_eth_poll, pp->weight);
+/*
+		if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags)))
+			napi_enable(napi_group->napi);
+*/
 	}
+	return MV_OK;
+}
 
-	pp = mv_eth_ports[rx_port];
 
-	if (!pp) {
-		mvOsPrintf("pp is NULL in setting L2FW (%s)\n", __func__);
-		return;
+static int mv_l2fw_check(int port, bool l2fw)
+{
+	int max_port = mvCtrlEthMaxPortGet() - 1;
+
+	if ((port > max_port) || (port < 0)) {
+		mvOsPrintf("Error: invalid port %d\n", port);
+		return MV_ERROR;
 	}
 
-	dev = pp->dev;
-	if (dev == NULL) {
-		mvOsPrintf("device is NULL in setting L2FW (%s)\n", __func__);
-		return;
+	if (!l2fw) {
+		/* user try to exit form l2fw */
+		if (!mv_eth_ports_l2fw) {
+			mvOsPrintf("port #%d l2fw already disabled\n", port);
+			return MV_ERROR;
+		}
+
+		if (!mv_eth_ports_l2fw[port]) {
+			mvOsPrintf("port #%d l2fw already disabled\n", port);
+			return MV_ERROR;
+		}
+
+	/* user try to enter into l2fw */
+	} else if (mv_eth_ports_l2fw && mv_eth_ports_l2fw[port]) {
+			mvOsPrintf("port #%d l2fw already enabled\n", port);
+			return MV_ERROR;
 	}
-	if (!test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
-		mvOsPrintf("Device is down for port=%d ; MV_ETH_F_STARTED_BIT is not set in %s\n", rx_port, __func__);
-		mvOsPrintf("Cannot set to L2FW mode in %s\n", __func__);
-		return;
+
+	return MV_OK;
+}
+
+int mv_l2fw_set(int port, bool l2fw)
+{
+	struct eth_port *pp;
+	int status = MV_OK;
+
+	if (mv_l2fw_check(port, l2fw))
+		return MV_ERROR;
+
+	pp = mv_eth_ports[port];
+
+	if (!pp) {
+		mvOsPrintf("pp is NULL in setting L2FW (%s)\n", __func__);
+		return MV_ERROR;
 	}
 
-	if (cmd == ppl2fw->cmd) {
-		ppl2fw->txPort = tx_port;
-		return;
+	if (pp->flags & MV_ETH_F_STARTED) {
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
+		return -EINVAL;
 	}
 
-	if ((cmd != CMD_L2FW_DISABLE) && (ppl2fw->cmd != CMD_L2FW_DISABLE) && (ppl2fw->cmd != CMD_L2FW_LAST)) {
-		ppl2fw->txPort = tx_port;
-		ppl2fw->cmd	= cmd;
-		return;
+	/* for multiBuffer validation */
+	/*mvGmacMaxRxSizeSet(port, 9000);*/
+
+	if (!mv_eth_netdev_ops_ptr)
+		/* enter only once - save eth ops*/
+		mv_eth_netdev_ops_ptr = pp->dev->netdev_ops;
+
+	if (mv_l2fw_update_napi(pp, l2fw))
+		return MV_ERROR;
+
+	if (l2fw) {
+		status = mv_l2fw_port_init(port);
+		pp->dev->netdev_ops  = &mv_l2fw_netdev_ops;
+
+	} else {
+		pp->dev->netdev_ops = mv_eth_netdev_ops_ptr;
+		mv_l2fw_port_free(port);
 	}
 
-	ppl2fw->txPort = tx_port;
-	ppl2fw->cmd	= cmd;
+	return status;
+}
 
+int mv_l2fw_port(int rx_port, int tx_port, int cmd)
+{
+	struct eth_port_l2fw *ppl2fw;
+	int max_port = mvCtrlEthMaxPortGet() - 1;
 
-	for (group = 0; group < 1/*MV_ETH_MAX_NAPI_GROUPS*/; group++) {
-		napi_group = pp->napi_group[group];
-		if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags)))
-			napi_disable(napi_group->napi);
+	if (!mv_eth_ports_l2fw) {
+		mvOsPrintf("%s: ports are not in l2fw mode\n", __func__);
+		return MV_ERROR;
+	}
+	if (rx_port > max_port) {
+		mvOsPrintf("Error: invalid port %d\n", rx_port);
+		return MV_ERROR;
+	}
 
-		netif_napi_del(napi_group->napi);
+	if (tx_port > max_port) {
+		mvOsPrintf("Error: invalid port %d\n", tx_port);
+		return MV_ERROR;
+	}
 
-		if (cmd == CMD_L2FW_DISABLE)
-			netif_napi_add(dev, napi_group->napi, mv_eth_poll, pp->weight);
-		else
-			netif_napi_add(dev, napi_group->napi, mv_eth_poll_l2fw, pp->weight);
+	if (!mv_eth_ports_l2fw[rx_port]) {
+		mvOsPrintf("%s: port #%d is not in l2fw mode\n", __func__, rx_port);
+		return MV_ERROR;
+	}
 
-		if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags)))
-			napi_enable(napi_group->napi);
+	if (!mv_eth_ports_l2fw[tx_port]) {
+		mvOsPrintf("%s: port #%d is not in l2fw mode\n", __func__, tx_port);
+		return MV_ERROR;
 	}
 
+	if (cmd > CMD_L2FW_LAST) {
+		mvOsPrintf("Error: invalid command %d\n", cmd);
+		return MV_ERROR;
+	}
+
+	ppl2fw = mv_eth_ports_l2fw[rx_port];
+	ppl2fw->cmd = cmd;
+	ppl2fw->txPort = tx_port;
+
+	return MV_OK;
+
 }
 
-static inline struct eth_pbuf *l2fw_swap_mac(struct eth_pbuf *pRxPktInfo)
+inline unsigned char *l2fw_swap_mac(unsigned char *buff)
 {
 	MV_U16 *pSrc;
 	int i;
 	MV_U16 swap;
-	pSrc = (MV_U16 *)(pRxPktInfo->pBuf + pRxPktInfo->offset + MV_ETH_MH_SIZE);
+	pSrc = (MV_U16 *)(buff + MV_ETH_MH_SIZE);
 
 	for (i = 0; i < 3; i++) {
 		swap = pSrc[i];
@@ -407,20 +484,19 @@ static inline struct eth_pbuf *l2fw_swap_mac(struct eth_pbuf *pRxPktInfo)
 		pSrc[i+3] = swap;
 		}
 
-	return  pRxPktInfo;
+	return  buff;
 }
 
-static inline void l2fw_copy_mac(struct eth_pbuf *pRxPktInfo,
-					 struct eth_pbuf *pTxPktInfo)
-	{
+inline void l2fw_copy_mac(unsigned char *rx_buff, unsigned char *tx_buff)
+{
 	/* copy 30 bytes (start after MH header) */
 	/* 12 for SA + DA */
 	/* 18 for the rest */
 	MV_U16 *pSrc;
 	MV_U16 *pDst;
 	int i;
-	pSrc = (MV_U16 *)(pRxPktInfo->pBuf + pRxPktInfo->offset + MV_ETH_MH_SIZE);
-	pDst = (MV_U16 *)(pTxPktInfo->pBuf + pTxPktInfo->offset + MV_ETH_MH_SIZE);
+	pSrc = (MV_U16 *)(rx_buff);
+	pDst = (MV_U16 *)(tx_buff);
 
 	/* swap mac SA and DA */
 	for (i = 0; i < 3; i++) {
@@ -431,70 +507,82 @@ static inline void l2fw_copy_mac(struct eth_pbuf *pRxPktInfo,
 		pDst[i] = pSrc[i];
 	}
 
-static inline void l2fw_copy_and_swap_mac(struct eth_pbuf *pRxPktInfo, struct eth_pbuf *pTxPktInfo)
+inline void l2fw_copy_and_swap_mac(unsigned char *rx_buff, unsigned char *tx_buff)
 {
 	MV_U16 *pSrc;
 	MV_U16 *pDst;
 	int i;
 
-	pSrc = (MV_U16 *)(pRxPktInfo->pBuf +  pRxPktInfo->offset + MV_ETH_MH_SIZE);
-	pDst = (MV_U16 *)(pTxPktInfo->pBuf +  pTxPktInfo->offset + MV_ETH_MH_SIZE);
+	pSrc = (MV_U16 *)(rx_buff);
+	pDst = (MV_U16 *)(tx_buff);
 	for (i = 0; i < 3; i++) {
 		pDst[i]   = pSrc[i+3];
 		pDst[i+3] = pSrc[i];
-		}
+	}
 }
 
-static inline
-struct eth_pbuf *eth_l2fw_copy_packet_withOutXor(struct eth_pbuf *pRxPktInfo)
+inline struct sk_buff *eth_l2fw_copy_packet_withOutXor(struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
 {
 	MV_U8 *pSrc;
 	MV_U8 *pDst;
-	struct bm_pool *pool;
-	struct eth_pbuf *pTxPktInfo;
+	int poolId;
+	struct sk_buff *skb_new;
+	int  bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
+	/* 12 for SA + DA */
+	int mac = 2 * MV_MAC_ADDR_SIZE;
+
+	mvOsCacheInvalidate(NULL, skb->data, bytes);
 
-	mvOsCacheInvalidate(NULL, pRxPktInfo->pBuf + pRxPktInfo->offset,
-						pRxPktInfo->bytes);
+	poolId = mvPp2RxBmPoolId(rx_desc);
 
-	pool = &mv_eth_pool[pRxPktInfo->pool];
-	pTxPktInfo = mv_eth_pool_get(pool);
-	if (pTxPktInfo == NULL) {
-		mvOsPrintf("pTxPktInfo == NULL in %s\n", __func__);
+	skb_new = (struct sk_buff *)mv_eth_pool_get(poolId);
+
+	if (!skb_new) {
+		mvOsPrintf("skb == NULL in %s\n", __func__);
 		return NULL;
-		}
-	pSrc = pRxPktInfo->pBuf +  pRxPktInfo->offset + MV_ETH_MH_SIZE;
-	pDst = pTxPktInfo->pBuf +  pTxPktInfo->offset + MV_ETH_MH_SIZE;
+	}
+
+	pSrc = skb->data + MV_ETH_MH_SIZE;
+	pDst = skb_new->data + MV_ETH_MH_SIZE;
 
-	memcpy(pDst+12, pSrc+12, pRxPktInfo->bytes-12);
-	l2fw_copy_and_swap_mac(pRxPktInfo, pTxPktInfo);
-	pTxPktInfo->bytes = pRxPktInfo->bytes;
-	mvOsCacheFlush(NULL, pTxPktInfo->pBuf + pTxPktInfo->offset, pTxPktInfo->bytes);
+	memcpy(pDst + mac, pSrc + mac, bytes - mac);
+	l2fw_copy_and_swap_mac(pSrc, pDst);
+	mvOsCacheFlush(NULL, skb_new->data, bytes);
 
-	return pTxPktInfo;
+	return skb_new;
 }
+
 #ifdef CONFIG_MV_INCLUDE_XOR
-static inline
-struct eth_pbuf *eth_l2fw_copy_packet_withXor(struct eth_pbuf *pRxPktInfo)
+inline struct sk_buff *eth_l2fw_copy_packet_withXor(struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
 {
-	struct bm_pool *pool;
-	struct eth_pbuf *pTxPktInfo;
+	struct sk_buff *skb_new;
+	MV_U8 *pSrc;
+	MV_U8 *pDst;
+	int poolId;
+	unsigned int bufPhysAddr;
+	int  bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
+
+	poolId = mvPp2RxBmPoolId(rx_desc);
 
-	pool = &mv_eth_pool[pRxPktInfo->pool];
-	pTxPktInfo = mv_eth_pool_get(pool);
-	if (pTxPktInfo == NULL) {
-		mvOsPrintf("pTxPktInfo == NULL in %s\n", __func__);
+	skb_new = (struct sk_buff *)mv_eth_pool_get(poolId);
+
+	if (!skb_new) {
+		mvOsPrintf("skb == NULL in %s\n", __func__);
 		return NULL;
-		}
+	}
 
 	/* sync between giga and XOR to avoid errors (like checksum errors in TX)
 	   when working with IOCC */
 
 	mvOsCacheIoSync();
 
-	eth_xor_desc->srcAdd0    = pRxPktInfo->physAddr + pRxPktInfo->offset + MV_ETH_MH_SIZE + 30;
-	eth_xor_desc->phyDestAdd = pTxPktInfo->physAddr + pTxPktInfo->offset + MV_ETH_MH_SIZE + 30;
+	bufPhysAddr =  mvOsCacheFlush(NULL, skb->data, bytes);
+	eth_xor_desc->srcAdd0    = bufPhysAddr + skb_headroom(skb) + MV_ETH_MH_SIZE + 30;
+
+	bufPhysAddr =  mvOsCacheFlush(NULL, skb_new->data, bytes);
+	eth_xor_desc->srcAdd0    = bufPhysAddr + skb_headroom(skb_new) + MV_ETH_MH_SIZE + 30;
 
-	eth_xor_desc->byteCnt    = pRxPktInfo->bytes - 30;
+	eth_xor_desc->byteCnt    = bytes - 30;
 
 	eth_xor_desc->phyNextDescPtr = 0;
 	eth_xor_desc->status         = BIT31;
@@ -505,15 +593,16 @@ struct eth_pbuf *eth_l2fw_copy_packet_withXor(struct eth_pbuf *pRxPktInfo)
 
 	MV_REG_WRITE(XOR_ACTIVATION_REG(1, XOR_CHAN(0)), XEXACTR_XESTART_MASK);
 
-	mvOsCacheLineInv(NULL, pRxPktInfo->pBuf + pRxPktInfo->offset);
-	l2fw_copy_mac(pRxPktInfo, pTxPktInfo);
-	mvOsCacheLineFlush(NULL, pTxPktInfo->pBuf + pTxPktInfo->offset);
+	mvOsCacheLineInv(NULL, skb->data);
 
-	/* Update TxPktInfo */
-	pTxPktInfo->bytes = pRxPktInfo->bytes;
-	return pTxPktInfo;
-}
+	pSrc = skb->data + MV_ETH_MH_SIZE;
+	pDst = skb_new->data + MV_ETH_MH_SIZE;
+
+	l2fw_copy_mac(pSrc, pDst);
+	mvOsCacheLineFlush(NULL, skb_new->data);
 
+	return skb_new;
+}
 
 void setXorDesc(void)
 {
@@ -528,12 +617,12 @@ void setXorDesc(void)
 	mode |= XEXCR_OPERATION_MODE_DMA;
 	MV_REG_WRITE(XOR_CONFIG_REG(1, XOR_CHAN(0)), mode);
 	MV_REG_WRITE(XOR_NEXT_DESC_PTR_REG(1, XOR_CHAN(0)), eth_xor_desc_phys_addr);
-	dump_xor();
+	/*dump_xor();*/
 	/* TODO mask xor intterupts*/
 }
 
 
-static inline int xorReady(void)
+inline int xorReady(void)
 {
 	int timeout = 0;
 
@@ -551,7 +640,7 @@ static inline int xorReady(void)
 	return 1;
 }
 
-void l2fw_xor(int rx_port, int threshold)
+void mv_l2fw_xor(int rx_port, int threshold)
 {
 	int max_port = mvCtrlEthMaxPortGet() - 1;
 
@@ -565,36 +654,7 @@ void l2fw_xor(int rx_port, int threshold)
 }
 #endif /*CONFIG_MV_INCLUDE_XOR*/
 
-void l2fw(int cmd, int rx_port, int tx_port)
-{
-	struct eth_port_l2fw *ppl2fw;
-	int max_port = mvCtrlEthMaxPortGet() - 1;
-
-	ppl2fw = mv_eth_ports_l2fw[rx_port];
-
-	if ((cmd < CMD_L2FW_DISABLE) || (cmd > CMD_L2FW_LAST)) {
-		mvOsPrintf("Error: invalid command %d\n", cmd);
-		return;
-	}
-
-	if ((rx_port > max_port) || (rx_port < 0)) {
-		mvOsPrintf("Error: invalid rx port %d\n", rx_port);
-		return;
-	}
-
-	if ((tx_port > max_port) || (tx_port < 0)) {
-		mvOsPrintf("Error: invalid tx port %d\n", tx_port);
-		return;
-	}
-
-	mvOsPrintf("cmd=%d rx_port=%d tx_port=%d in %s\n", cmd, rx_port, tx_port, __func__);
-
-	mv_eth_set_l2fw(ppl2fw, cmd, rx_port, tx_port);
-}
-
-
-
-void l2fw_lookupEn(int rx_port, int enable)
+void mv_l2fw_lookupEn(int rx_port, int enable)
 {
 	int max_port = mvCtrlEthMaxPortGet() - 1;
 
@@ -606,14 +666,19 @@ void l2fw_lookupEn(int rx_port, int enable)
 	mv_eth_ports_l2fw[rx_port]->lookupEn = enable;
 }
 
-void l2fw_stats(void)
+void mv_l2fw_stats(void)
 {
 	int i;
 	int ports = mvCtrlEthMaxPortGet();
 
+	if (!mv_eth_ports_l2fw)
+		return;
+
 	for (i = 0; i < ports; i++) {
-		mvOsPrintf("number of errors in port[%d]=%d\n", i, mv_eth_ports_l2fw[i]->statErr);
-		mvOsPrintf("number of drops  in port[%d]=%d\n", i, mv_eth_ports_l2fw[i]->statDrop);
+		if (mv_eth_ports_l2fw[i]) {
+			mvOsPrintf("number of errors in port[%d]=%d\n", i, mv_eth_ports_l2fw[i]->statErr);
+			mvOsPrintf("number of drops  in port[%d]=%d\n", i, mv_eth_ports_l2fw[i]->statDrop);
+		}
 	}
 
 #ifdef CONFIG_MV_ETH_L2SEC
@@ -622,8 +687,7 @@ void l2fw_stats(void)
 
 }
 
-static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp, int withXor,
-									   struct pp2_rx_desc *rx_desc)
+inline int mv_l2fw_tx(struct sk_buff *skb, struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 {
 	struct pp2_tx_desc *tx_desc;
 	u32 tx_cmd = 0;
@@ -631,7 +695,7 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 	struct tx_queue *txq_ctrl;
 	struct aggr_tx_queue *aggr_txq_ctrl = NULL;
 	struct txq_cpu_ctrl *txq_cpu_ptr;
-	int cpu = smp_processor_id(), frags = 1;
+	int cpu = smp_processor_id(), poolId, frags = 1;
 	tx_spec_ptr = &pp->tx_spec;
 	tx_spec_ptr->txq = pp->cpu_config[cpu]->txq;
 	aggr_txq_ctrl = &aggr_txqs[cpu];
@@ -639,17 +703,15 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 	txq_ctrl = &pp->txq_ctrl[tx_spec_ptr->txp * CONFIG_MV_ETH_TXQ + tx_spec_ptr->txq];
 	txq_cpu_ptr = &(txq_ctrl->txq_cpu[cpu]);
 
-#ifdef CONFIG_MV_ETH_PP2_1
-	if ((!mv_eth_reserved_desc_num_proc(pp, tx_spec_ptr->txp, tx_spec_ptr->txq, frags)) ||
-		(!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags))) {
+	if (!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags))
+		goto out;
 
-#else
-	if ((!mv_eth_phys_desc_num_check(txq_cpu_ptr, frags)) ||
-		(!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags))) {
-#endif
-		frags = 0;
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* TODO: remove ? */
+	if (!mv_eth_reserved_desc_num_proc(pp, tx_spec_ptr->txp, tx_spec_ptr->txq, frags))
 		goto out;
-	}
+#endif
+
 	/* Get next descriptor for tx, single buffer, so FIRST & LAST */
 	tx_desc = mvPp2AggrTxqNextDescGet(aggr_txq_ctrl->q);
 
@@ -666,18 +728,20 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 	if (tx_spec_ptr->flags & MV_ETH_TX_F_NO_PAD)
 		tx_cmd |= PP2_TX_PADDING_DISABLE_MASK;
 
+	poolId = mvPp2RxBmPoolId(rx_desc);
+
 	/* buffers released by HW */
-	tx_cmd |= (pkt->pool << PP2_TX_POOL_INDEX_OFFS) | PP2_TX_BUF_RELEASE_MODE_MASK |
+	tx_cmd |= (poolId << PP2_TX_POOL_INDEX_OFFS) | PP2_TX_BUF_RELEASE_MODE_MASK |
 			PP2_TX_F_DESC_MASK | PP2_TX_L_DESC_MASK | PP2_TX_L4_CSUM_NOT | PP2_TX_IP_CSUM_DISABLE_MASK;
 
 	tx_desc->command = tx_cmd;
 
 #ifdef CONFIG_MV_ETH_PP2_1
-	tx_desc->hwCmd[1] = (pkt->qset << PP2_TX_MOD_QSET_OFFS) | (pkt->grntd << PP2_TX_MOD_GRNTD_BIT);
+	qset = (rx_desc->bmQset & PP2_RX_BUFF_QSET_NUM_MASK) >> PP2_RX_BUFF_QSET_NUM_OFFS;
+	grntd = (rx_desc->bmQset & PP2_RX_BUFF_TYPE_MASK) >> PP2_RX_BUFF_TYPE_OFFS;
+	tx_desc->hwCmd[1] = (qset << PP2_TX_MOD_QSET_OFFS) | (grntd << PP2_TX_MOD_GRNTD_BIT);
 #endif
 
-	tx_desc->bufCookie = (MV_U32)pkt;
-
 	tx_desc->physTxq = MV_PPV2_TXQ_PHYS(pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq);
 
 	txq_ctrl = &pp->txq_ctrl[tx_spec_ptr->txp * CONFIG_MV_ETH_TXQ + tx_spec_ptr->txq];
@@ -691,15 +755,13 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 
 	txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
 
-	/* use txq_counter in txq_ctrl*/
 	if (txq_cpu_ptr->txq_count >= mv_ctrl_txdone)
-		mv_eth_txq_done(pp, txq_ctrl);
+		mv_l2fw_txq_done(pp, txq_ctrl);
 
-	tx_desc->dataSize  = pkt->bytes;
-	tx_desc->bufPhysAddr = pkt->physAddr;
-	tx_desc->pktOffset = pkt->offset + MV_ETH_MH_SIZE;
-
-	mv_eth_shadow_push(txq_cpu_ptr, ((MV_ULONG) NULL));
+	tx_desc->dataSize = rx_desc->dataSize - MV_ETH_MH_SIZE;
+	tx_desc->bufCookie = (MV_U32)skb;
+	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, skb->head, tx_desc->dataSize);
+	tx_desc->pktOffset = MV_ETH_MH_SIZE + skb_headroom(skb);
 
 	mv_eth_tx_desc_flush(tx_desc);
 
@@ -717,10 +779,9 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 		printk(KERN_ERR "%s - eth_l2fw_tx_%lu: cpu=%d, in_intr=0x%lx, port=%d, txp=%d, txq=%d\n",
 			pp->dev->name, pp->dev->stats.tx_packets, smp_processor_id(), in_interrupt(),
 			pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq);
-		printk(KERN_ERR "\t pkt=%p, pBuf=%p, bytes=%d, physAddr=%lx\n",
-				pkt, pkt->pBuf, pkt->bytes, pkt->physAddr);
+
 		mv_eth_tx_desc_print(tx_desc);
-		mvDebugMemDump(pkt->pBuf + pkt->offset, 64, 1);
+		mvDebugMemDump(skb->data, 64, 1);
 	}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
@@ -729,54 +790,99 @@ static inline MV_STATUS mv_eth_l2fw_tx(struct eth_pbuf *pkt, struct eth_port *pp
 	mvPp2AggrTxqPendDescAdd(frags);
 
 	STAT_DBG(aggr_txq_ctrl->stats.txq_tx++);
-	STAT_DBG(txq_ctrl->stats.txq_tx++);
 	STAT_DBG(txq_ctrl->txq_cpu[cpu].stats.txq_tx++);
 
 	pp->dev->stats.tx_packets++;
-	pp->dev->stats.tx_bytes += pkt->bytes;
+	pp->dev->stats.tx_bytes += rx_desc->dataSize - MV_ETH_MH_SIZE;
 
 out:
 #ifndef CONFIG_MV_ETH_TXDONE_ISR
 	if (txq_cpu_ptr->txq_count >= mv_ctrl_txdone)
-		mv_eth_txq_done(pp, txq_ctrl);
+		mv_l2fw_txq_done(pp, txq_ctrl);
 #endif /* CONFIG_MV_ETH_STAT_DIST */
 
 	return NETDEV_TX_OK;
 }
 
-static inline void mv_eth_l2fw_pool_refill(struct eth_port *pp,
-				     struct eth_pbuf *pkt, struct bm_pool *pool, struct pp2_rx_desc *rx_desc)
+
+inline int mv_l2fw_txq_done(struct eth_port *pp, struct tx_queue *txq_ctrl)
 {
+	struct txq_cpu_ctrl *txq_cpu_ptr = &txq_ctrl->txq_cpu[smp_processor_id()];
+	int tx_done = mvPp2TxqSentDescProc(pp->port, txq_ctrl->txp, txq_ctrl->txq);
 
-	if ((rx_desc->status & PP2_RX_BUF_HDR_MASK) == MV_FALSE)
-		mv_eth_pool_refill(pkt, pool, rx_desc);
-	else
+	if (!tx_done)
+		return tx_done;
+
+	txq_cpu_ptr->txq_count -= tx_done;
+	STAT_DBG(txq_cpu_ptr->stats.txq_txdone += tx_done);
+	return tx_done;
+}
+
+static void mv_l2fw_txq_done_force(struct eth_port *pp, struct tx_queue *txq_ctrl)
+{
+	int cpu;
+	struct txq_cpu_ctrl *txq_cpu_ptr;
+
+	for_each_possible_cpu(cpu) {
+		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
+		txq_cpu_ptr->txq_count = 0;
+	}
+}
+
+static int mv_l2fw_txp_clean(int port, int txp)
+{
+	struct eth_port *pp = mv_eth_port_by_id(port);
+	int queue;
+
+	for (queue = 0; queue < CONFIG_MV_ETH_TXQ; queue++) {
+		struct tx_queue *txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + queue];
+		if (txq_ctrl->q) {
+
+			/* TODO ppv2.1 - add support */
+			/* TODO ppv2.0 - release panding to bm pools */
+
+			mv_l2fw_txq_done(pp, txq_ctrl);
+			mv_l2fw_txq_done_force(pp, txq_ctrl);
+			/*printk (KERN_ERR "panding = %d\n", mvPp2TxqPendDescNumGet(pp->port, txp, queue));*/
+		}
+	}
+
+	mvPp2TxpReset(port, txp);
+
+	return MV_OK;
+}
+
+
+inline void mv_l2fw_pool_refill(struct eth_port *pp,
+				     struct bm_pool *pool, struct pp2_rx_desc *rx_desc)
+{
+	if ((rx_desc->status & PP2_RX_BUF_HDR_MASK) == MV_FALSE) {
+		__u32 bm = mv_eth_bm_cookie_build(rx_desc);
+		mv_eth_pool_refill(pool, bm, rx_desc->bufPhysAddr, rx_desc->bufCookie);
+	} else
 		/* multiBuffer mode */
 		mv_eth_buff_hdr_rx(pp, rx_desc);
 }
 
-static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
+inline int mv_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 {
 	struct eth_port  *new_pp;
 	struct l2fw_rule *rule;
 	MV_PP2_PHYS_RXQ_CTRL *rx_ctrl = pp->rxq_ctrl[rxq].q;
-	int rx_done, rx_filled;
+	int rx_done, rx_filled, poolId, bytes;
 	u32 rx_status;
 	struct pp2_rx_desc *rx_desc;
-	struct eth_pbuf *pkt;
-	struct eth_pbuf *newpkt = NULL;
 	struct bm_pool *pool;
 	MV_STATUS status = MV_OK;
 	struct eth_port_l2fw *ppl2fw = mv_eth_ports_l2fw[pp->port];
 	MV_IP_HEADER *pIph = NULL;
-	MV_U8 *pData;
 	int ipOffset;
-	MV_BOOL withXor = MV_FALSE;
+	struct sk_buff *skb, *skb_new;
+	MV_U32 bufPhysAddr, bm;
 
 	rx_done = mvPp2RxqBusyDescNumGet(pp->port, rxq);
 	mvOsCacheIoSync();
 
-
 	if ((rx_todo > rx_done) || (rx_todo < 0))
 		rx_todo = rx_done;
 
@@ -815,41 +921,30 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 			mv_eth_rx_desc_print(rx_desc);
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
-		pkt = (struct eth_pbuf *)rx_desc->bufCookie;
+		skb = (struct sk_buff *)rx_desc->bufCookie;
 
-		if (!pkt) {
-			printk(KERN_INFO "%s: pkt is NULL, rx_done=%d\n", __func__, rx_done);
+		if (!skb) {
+			printk(KERN_INFO "%s: skb is NULL, rx_done=%d\n", __func__, rx_done);
 			return rx_done;
 		}
 
-		pool = &mv_eth_pool[pkt->pool];
+		poolId = mvPp2RxBmPoolId(rx_desc);
+		pool = &mv_eth_pool[poolId];
 
 		if (rx_status & PP2_RX_ES_MASK) {
 			printk(KERN_ERR "giga #%d: bad rx status 0x%08x\n", pp->port, rx_status);
-			mv_eth_l2fw_pool_refill(pp, pkt, pool, rx_desc);
+			mv_l2fw_pool_refill(pp, pool, rx_desc);
 			continue;
 		}
-#ifdef CONFIG_MV_ETH_PP2_1
-		pkt->qset = (rx_desc->bmQset & PP2_RX_BUFF_QSET_NUM_MASK) >> PP2_RX_BUFF_QSET_NUM_OFFS;
-		pkt->grntd = (rx_desc->bmQset & PP2_RX_BUFF_TYPE_MASK) >> PP2_RX_BUFF_TYPE_OFFS;
-#endif /*CONFIG_MV_ETH_PP2_1*/
-
-		pkt->bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-		if (pp->dbg_flags & MV_ETH_F_DBG_RX) {
-			printk(KERN_ERR "pkt=0x%p, pBuf=0x%p, ksize=%d offset = 0x%x\n",
-						 pkt, pkt->pBuf, ksize(pkt->pBuf), pkt->offset);
-
-			mvDebugMemDump(pkt->pBuf + pkt->offset, 64, 1);
-		}
+		if (pp->dbg_flags & MV_ETH_F_DBG_RX)
+			mvDebugMemDump(skb->data, 64, 1);
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
-		pData = pkt->pBuf + pkt->offset;
-
 		ipOffset = (rx_status & PP2_RX_L3_OFFSET_MASK) >> PP2_RX_L3_OFFSET_OFFS;
 
-		pIph = (MV_IP_HEADER *)(pData + ipOffset);
+		pIph = (MV_IP_HEADER *)(skb->data + ipOffset);
 
 		if (pIph == NULL) {
 			printk(KERN_INFO "pIph==NULL in %s\n", __func__);
@@ -875,16 +970,18 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 		} else
 			new_pp  = mv_eth_ports[ppl2fw->txPort];
 
+		bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
+
 		switch (ppl2fw->cmd) {
 		case CMD_L2FW_AS_IS:
-			status = mv_eth_l2fw_tx(pkt, new_pp, 0, rx_desc);
+			status = mv_l2fw_tx(skb, new_pp, rx_desc);
 			break;
 
 		case CMD_L2FW_SWAP_MAC:
-			mvOsCacheLineInv(NULL, pkt->pBuf + pkt->offset);
-			l2fw_swap_mac(pkt);
-			mvOsCacheLineFlush(NULL, pkt->pBuf + pkt->offset);
-			status = mv_eth_l2fw_tx(pkt, new_pp, 0, rx_desc);
+			mvOsCacheLineInv(NULL, skb->data);
+			l2fw_swap_mac(skb->data);
+			mvOsCacheLineFlush(NULL, skb->data);
+			status = mv_l2fw_tx(skb, new_pp, rx_desc);
 			break;
 
 		case CMD_L2FW_COPY_SWAP:
@@ -893,22 +990,26 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 				status = MV_ERROR;
 				break;
 			}
-
-			if (pkt->bytes >= ppl2fw->xorThreshold) {
-				withXor = MV_TRUE;
+			if (bytes >= ppl2fw->xorThreshold) {
 				printk(KERN_INFO "%s: xor is not supported\n", __func__);
-				/* newpkt = eth_l2fw_copy_packet_withXor(pkt); */
-			} else
-				newpkt = eth_l2fw_copy_packet_withOutXor(pkt);
-
-			if (newpkt) {
-				status = mv_eth_l2fw_tx(newpkt, new_pp, withXor, rx_desc);
-				/* we do not need the pkt */
-				mv_eth_pool_put(pool, pkt);
-				/*for refill function just in case that status != OK */
-				pkt = newpkt;
-			} else
+				skb_new = eth_l2fw_copy_packet_withXor(skb, rx_desc);
+			} else {
+				skb_new = eth_l2fw_copy_packet_withOutXor(skb, rx_desc);
+
+				if (skb_new) {
+					bufPhysAddr = rx_desc->bufPhysAddr;
+
+					bm = mv_eth_bm_cookie_build(rx_desc);
+					status = mv_l2fw_tx(skb_new, new_pp, rx_desc);
+
+					mv_eth_pool_refill(pool, bm, bufPhysAddr, (MV_ULONG)skb);
+
+					/* for refill function */
+					skb = skb_new;
+				} else
+
 				status = MV_ERROR;
+			}
 			break;
 #ifdef CONFIG_MV_ETH_L2SEC
 		case CMD_L2FW_CESA:
@@ -923,7 +1024,7 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 
 		default:
 			printk(KERN_INFO "WARNING:%s invalid mode %d, rx port %d\n", __func__, ppl2fw->cmd, pp->port);
-			mv_eth_pool_refill(pkt, pool, rx_desc);
+			status = MV_DROPPED;
 		} /*switch*/
 
 		if (status == MV_OK) {
@@ -933,7 +1034,7 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 		}
 
 		/* status is not OK */
-		mv_eth_l2fw_pool_refill(pp, pkt, pool, rx_desc);
+		mv_l2fw_pool_refill(pp, pool, rx_desc);
 
 		if (status == MV_DROPPED)
 			ppl2fw->statDrop++;
@@ -950,66 +1051,141 @@ static inline int mv_eth_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 	return rx_done;
 }
 
-#ifdef CONFIG_MV_ETH_L2FW
-int __devinit mv_l2fw_init(void)
+static void mv_l2fw_shared_cleanup(void)
 {
-	int size, port;
-	MV_U32 bytes;
-	MV_U32 regVal;
-	mv_eth_ports_l2fw_num = mvCtrlEthMaxPortGet();
-	mvOsPrintf("in %s: mv_eth_ports_l2fw_num=%d\n", __func__, mv_eth_ports_l2fw_num);
+	if (mv_eth_ports_l2fw)
+		mvOsFree(mv_eth_ports_l2fw);
+
+	if (l2fw_hash) {
+		mv_l2fw_flush();
+		mvOsFree(l2fw_hash);
+	}
+
+	mv_eth_ports_l2fw = NULL;
+	l2fw_hash = NULL;
+}
+
+
+static int mv_l2fw_shared_init(void)
+{
+	int size, bytes;
+	int ports = mvCtrlEthMaxPortGet();
 
-	size = mv_eth_ports_l2fw_num * sizeof(struct eth_port_l2fw *);
+	size = ports * sizeof(struct eth_port_l2fw *);
 	mv_eth_ports_l2fw = mvOsMalloc(size);
+
 	if (!mv_eth_ports_l2fw)
 		goto oom;
+
 	memset(mv_eth_ports_l2fw, 0, size);
-	for (port = 0; port < mv_eth_ports_l2fw_num; port++) {
-		mv_eth_ports_l2fw[port] =
-			mvOsMalloc(sizeof(struct eth_port_l2fw));
-		if (!mv_eth_ports_l2fw[port])
-			goto oom1;
-		mv_eth_ports_l2fw[port]->cmd    = CMD_L2FW_LAST/*CMD_L2FW_DISABLE*/;
-		mv_eth_ports_l2fw[port]->txPort = -1;
-		mv_eth_ports_l2fw[port]->lookupEn = 0;
-		mv_eth_ports_l2fw[port]->xorThreshold = XOR_THRESHOLD_DEF;
-		mv_eth_ports_l2fw[port]->statErr = 0;
-		mv_eth_ports_l2fw[port]->statDrop = 0;
-	}
 
 	bytes = sizeof(struct l2fw_rule *) * L2FW_HASH_SIZE;
 	l2fw_jhash_iv = mvOsRand();
-
 	l2fw_hash = (struct l2fw_rule **)mvOsMalloc(bytes);
+
 	if (l2fw_hash == NULL) {
 		mvOsPrintf("l2fw hash: not enough memory\n");
-		return MV_NO_RESOURCE;
+		goto oom;
 	}
 
 	mvOsMemset(l2fw_hash, 0, bytes);
 
 	mvOsPrintf("L2FW hash init %d entries, %d bytes\n", L2FW_HASH_SIZE, bytes);
-	regVal = 0;
 
 #ifdef CONFIG_MV_ETH_L2SEC
 	mv_l2sec_cesa_init();
 #endif
 
 #ifdef CONFIG_MV_INCLUDE_XOR
-	setXorDesc();
+	/*setXorDesc();*/
 #endif
-	return 0;
+
+
+	return MV_OK;
 oom:
+	mv_l2fw_shared_cleanup();
 	mvOsPrintf("%s: out of memory in L2FW initialization\n", __func__);
-oom1:
-	mvOsFree(mv_eth_ports_l2fw);
+
 	return -ENOMEM;
 
 }
-#endif
 
-module_init(mv_l2fw_init);
+static int mv_l2fw_port_init(int port)
+{
+	int status;
+
+	if (!shared) {
+		status = mv_l2fw_shared_init();
+		if (status)
+			return status;
+	}
+
+	mv_eth_ports_l2fw[port] = mvOsMalloc(sizeof(struct eth_port_l2fw));
+	if (!mv_eth_ports_l2fw[port])
+		goto oom;
+
+	mv_eth_ports_l2fw[port]->cmd    = CMD_L2FW_AS_IS;
+	mv_eth_ports_l2fw[port]->txPort = port;
+	mv_eth_ports_l2fw[port]->lookupEn = 0;
+	mv_eth_ports_l2fw[port]->xorThreshold = XOR_THRESHOLD_DEF;
+	mv_eth_ports_l2fw[port]->statErr = 0;
+	mv_eth_ports_l2fw[port]->statDrop = 0;
+
+	shared++;
+
+	return MV_OK;
+
+oom:
+	if (!shared)
+		mv_l2fw_shared_cleanup();
+
+	return -ENOMEM;
+}
+
+
+static void mv_l2fw_port_free(int port)
+{
+	if (!mv_eth_ports_l2fw) {
+		mvOsPrintf("in %s: l2fw database is NULL\n", __func__);
+		return;
+	}
+
+	if (!mv_eth_ports_l2fw[port]) {
+		mvOsPrintf("in %s: l2fw port #%d database is NULL\n", __func__, port);
+		return;
+	}
+
+	mvOsFree(mv_eth_ports_l2fw[port]);
+	mv_eth_ports_l2fw[port] = NULL;
+
+	shared--;
+
+	if (!shared)
+		mv_l2fw_shared_cleanup();
+}
+
+int mv_l2fw_stop(struct net_device *dev)
+{
+	int txp;
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	for (txp = 0; txp < pp->txp_num; txp++)
+		if (mv_l2fw_txp_clean(pp->port, txp))
+			return MV_ERROR;
+
+	return mv_eth_stop(dev);
+}
+
+static netdev_tx_t mv_l2fw_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	return NETDEV_TX_LOCKED;
+}
 
-MODULE_AUTHOR("Rami Rosen");
-MODULE_DESCRIPTION("l2fw module");
-MODULE_LICENSE("GPL");
+static const struct net_device_ops mv_l2fw_netdev_ops = {
+	.ndo_open = mv_eth_open,
+	.ndo_stop = mv_l2fw_stop,
+	.ndo_start_xmit = mv_l2fw_xmit,
+	.ndo_change_rx_flags = mv_eth_change_rx_flags,
+	.ndo_set_mac_address = mv_eth_set_mac_addr,
+	.ndo_change_mtu = mv_eth_change_mtu,
+};
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.h
index 5f3ae42..dcee8c3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.h
@@ -35,13 +35,19 @@ disclaimer.
 #define	L2FW_HASH_SIZE   (1 << 17)
 #define	L2FW_HASH_MASK   (L2FW_HASH_SIZE - 1)
 
+#define L2FW_PORT_OFFS				0
+#define L2FW_PORT_MASK				0xFF
+#define L2FW_TXP_OFFS				8
+#define L2FW_TXP_MASK				0xFF
+#define L2FW_TXQ_OFFS				16
+#define L2FW_TXQ_MASK				0xFF
+
 /* L2fw defines */
-#define CMD_L2FW_DISABLE			0
-#define CMD_L2FW_AS_IS				1
-#define CMD_L2FW_SWAP_MAC			2
-#define CMD_L2FW_COPY_SWAP			3
-#define CMD_L2FW_CESA				4
-#define CMD_L2FW_LAST				5
+#define CMD_L2FW_AS_IS				0
+#define CMD_L2FW_SWAP_MAC			1
+#define CMD_L2FW_COPY_SWAP			2
+#define CMD_L2FW_CESA				3
+#define CMD_L2FW_LAST				4
 
 #define XOR_CAUSE_DONE_MASK(chan) ((BIT0|BIT1) << (chan * 16))
 #define XOR_THRESHOLD_DEF			2000;
@@ -66,14 +72,15 @@ struct l2fw_rule {
 	struct l2fw_rule *next;
 };
 
-MV_STATUS l2fw_add(MV_U32 srcIP, MV_U32 dstIP, int port);
+int mv_l2fw_add(MV_U32 srcIP, MV_U32 dstIP, int port);
+int mv_l2fw_set(int port, bool l2fw);
+int mv_l2fw_port(int rx_port, int tx_port, int cmd);
+void mv_l2fw_xor(int rx_port, int threshold);
+void mv_l2fw_lookupEn(int rx_port, int enable);
+void mv_l2fw_flush(void);
+void mv_l2fw_rules_dump(void);
+void mv_l2fw_ports_dump(void);
+void mv_l2fw_stats(void);
 
-void l2fw(int cmd, int rx_port, int tx_port);
-void l2fw_xor(int rx_port, int threshold);
-void l2fw_lookupEn(int rx_port, int enable);
-void l2fw_flush(void);
-void l2fw_rules_dump(void);
-void l2fw_ports_dump(void);
-void l2fw_stats(void);
 
 #endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index fdd4970..f04d7e1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -182,7 +182,7 @@ int mv_eth_change_mtu(struct net_device *dev, int mtu)
 	if (mv_eth_check_mtu_internals(dev, mtu))
 		goto error;
 
-	if (mv_eth_stop(dev)) {
+	if (dev->netdev_ops->ndo_stop(dev)) {
 		printk(KERN_ERR "%s: stop interface failed\n", dev->name);
 		goto error;
 	}
@@ -192,7 +192,7 @@ int mv_eth_change_mtu(struct net_device *dev, int mtu)
 		goto error;
 	}
 
-	if (mv_eth_start(dev)) {
+	if (dev->netdev_ops->ndo_open(dev)) {
 		printk(KERN_ERR "%s: start interface failed\n", dev->name);
 		goto error;
 	}
@@ -291,7 +291,7 @@ int     mv_eth_set_mac_addr(struct net_device *dev, void *addr)
 		return 0;
 	}
 
-	if (mv_eth_stop(dev)) {
+	if (dev->netdev_ops->ndo_stop(dev)) {
 		printk(KERN_ERR "%s: stop interface failed\n", dev->name);
 		goto error;
 	}
@@ -299,7 +299,7 @@ int     mv_eth_set_mac_addr(struct net_device *dev, void *addr)
 	if (mv_eth_set_mac_addr_internals(dev, addr) == -1)
 		goto error;
 
-	if (mv_eth_start(dev)) {
+	if (dev->netdev_ops->ndo_open(dev)) {
 		printk(KERN_ERR "%s: start interface failed\n", dev->name);
 		goto error;
 	}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index e519786..5fcbc86 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -136,8 +136,8 @@ static MV_STATUS mv_eth_pool_create(int pool, int capacity);
 static int mv_eth_pool_add(int pool, int buf_num);
 static int mv_eth_pool_free(int pool, int num);
 static int mv_eth_pool_destroy(int pool);
-
 static struct bm_pool *mv_eth_pool_use(int pool, enum mv_eth_bm_type type, int pkt_size);
+
 #ifdef CONFIG_MV_ETH_TSO
 int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_spec *tx_spec,
 			struct tx_queue *txq_ctrl, struct aggr_tx_queue *aggr_txq_ctrl);
@@ -590,6 +590,45 @@ int mv_eth_ctrl_pool_size_set(int pool, int total_size)
 	return 0;
 }
 
+/* detach port from old pool */
+int mv_eth_ctrl_pool_detach(int port, struct bm_pool *pool)
+{
+	unsigned long flags = 0;
+	/*TODO remove struct bm_pool *pool;*/
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	if (pp == NULL) {
+		pr_err("%s: port %d doenst not exist\n" , __func__, port);
+		return -EINVAL;
+	}
+
+	if (pool == NULL) {
+		pr_err("%s: pool is null\n" , __func__);
+		return -EINVAL;
+	}
+
+	if (pp->flags & MV_ETH_F_STARTED) {
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
+		return -EINVAL;
+	}
+
+
+	pool->port_map &= ~(1 << port);
+
+	if (!pool->port_map) {
+		MV_ETH_LOCK(&pool->lock, flags);
+		mv_eth_pool_free(pool->pool, pool->buf_num);
+
+		pool->type = MV_ETH_BM_FREE;
+		pool->pkt_size = 0;
+
+		mvPp2BmPoolBufSizeSet(pool->pool, 0);
+		MV_ETH_UNLOCK(&pool->lock, flags);
+	}
+
+	return MV_OK;
+}
+
 int mv_eth_ctrl_long_pool_set(int port, int pool)
 {
 	unsigned long flags = 0;
@@ -612,21 +651,11 @@ int mv_eth_ctrl_long_pool_set(int port, int pool)
 		if (old_pool->pool == pool)
 			return 0;
 
-		if (pp->hwf_pool_long != pp->pool_long) {
-			/* detach port from old pool */
-			old_pool->port_map &= ~(1 << port);
-			if (!old_pool->port_map) {
-				MV_ETH_LOCK(&old_pool->lock, flags);
-				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
-
-				old_pool->type = MV_ETH_BM_FREE;
-				old_pool->pkt_size = 0;
-
-				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
-				MV_ETH_UNLOCK(&old_pool->lock, flags);
-			}
-		}
+		if (pp->hwf_pool_long != pp->pool_long)
+			if (mv_eth_ctrl_pool_detach(port, old_pool))
+				return -EINVAL;
 	}
+
 	pp->pool_long = mv_eth_pool_use(pool, MV_ETH_BM_SWF_LONG, pkt_size);
 	if (!pp->pool_long)
 		return -EINVAL;
@@ -658,21 +687,11 @@ int mv_eth_ctrl_short_pool_set(int port, int pool)
 		if (old_pool->pool == pool)
 			return 0;
 
-		if (pp->hwf_pool_short != pp->pool_short) {
-			/* detach port from old pool */
-			old_pool->port_map &= ~(1 << port);
-			if (!old_pool->port_map) {
-				MV_ETH_LOCK(&old_pool->lock, flags);
-				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
-
-				old_pool->type = MV_ETH_BM_FREE;
-				old_pool->pkt_size = 0;
-
-				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
-				MV_ETH_UNLOCK(&old_pool->lock, flags);
-			}
-		}
+		if (pp->hwf_pool_short != pp->pool_short)
+			if (mv_eth_ctrl_pool_detach(port, old_pool))
+				return -EINVAL;
 	}
+
 	pp->pool_short = mv_eth_pool_use(pool, MV_ETH_BM_SWF_SHORT, MV_ETH_BM_SHORT_PKT_SIZE);
 	if (!pp->pool_short)
 		return -EINVAL;
@@ -705,21 +724,11 @@ int mv_eth_ctrl_hwf_long_pool_set(int port, int pool)
 		if (old_pool->pool == pool)
 			return 0;
 
-		if (pp->hwf_pool_long != pp->pool_long) {
-			/* detach port from old pool */
-			old_pool->port_map &= ~(1 << port);
-			if (!old_pool->port_map) {
-				MV_ETH_LOCK(&old_pool->lock, flags);
-				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
-
-				old_pool->type = MV_ETH_BM_FREE;
-				old_pool->pkt_size = 0;
-
-				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
-				MV_ETH_UNLOCK(&old_pool->lock, flags);
-			}
-		}
+		if (pp->hwf_pool_long != pp->pool_long)
+			if (mv_eth_ctrl_pool_detach(port, old_pool))
+				return -EINVAL;
 	}
+
 	pp->hwf_pool_long = mv_eth_pool_use(pool, MV_ETH_BM_HWF_LONG, pkt_size);
 	if (!pp->hwf_pool_long)
 		return -EINVAL;
@@ -751,20 +760,9 @@ int mv_eth_ctrl_hwf_short_pool_set(int port, int pool)
 		if (old_pool->pool == pool)
 			return 0;
 
-		if (pp->hwf_pool_short != pp->pool_short) {
-			/* detach port from old pool */
-			old_pool->port_map &= ~(1 << port);
-			if (!old_pool->port_map) {
-				MV_ETH_LOCK(&old_pool->lock, flags);
-				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
-
-				old_pool->type = MV_ETH_BM_FREE;
-				old_pool->pkt_size = 0;
-
-				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
-				MV_ETH_UNLOCK(&old_pool->lock, flags);
-			}
-		}
+		if (pp->hwf_pool_short != pp->pool_short)
+			if (mv_eth_ctrl_pool_detach(port, old_pool))
+				return -EINVAL;
 	}
 	pp->hwf_pool_short = mv_eth_pool_use(pool, MV_ETH_BM_HWF_SHORT, MV_ETH_BM_SHORT_HWF_PKT_SIZE);
 	if (!pp->hwf_pool_short)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 0ce97ca..27af2ba 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -758,6 +758,18 @@ static inline void mv_eth_pool_refill(struct bm_pool *ppool, __u32 bm,
 	MV_ETH_LIGHT_UNLOCK(flags);
 }
 
+static inline MV_U32 mv_eth_pool_get(int pool)
+{
+	MV_U32 bufCookie;
+	unsigned long flags = 0;
+
+	MV_ETH_LIGHT_LOCK(flags);
+	bufCookie = mvBmPoolGet(pool);
+	MV_ETH_LIGHT_UNLOCK(flags);
+	return bufCookie;
+}
+
+
 /******************************************************
  * Function prototypes --                             *
  ******************************************************/
@@ -838,6 +850,7 @@ int	    mv_eth_ctrl_dbg_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_size);
 int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
 int	    mv_eth_ctrl_pool_buf_num_set(int pool, int buf_num);
+int         mv_eth_ctrl_pool_detach(int port, struct bm_pool *ppool);
 int         mv_eth_ctrl_pool_size_set(int pool, int pkt_size);
 int	    mv_eth_ctrl_long_pool_set(int port, int pool);
 int	    mv_eth_ctrl_short_pool_set(int port, int pool);
@@ -914,7 +927,7 @@ struct pp2_rx_desc *mv_eth_rx_prefetch(struct eth_port *pp,
 						MV_PP2_PHYS_RXQ_CTRL *rx_ctrl, int rx_done, int rx_todo);
 #endif /* CONFIG_MV_ETH_RX_DESC_PREFETCH */
 
-void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *physAddr);
+void		*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *physAddr);
 
 #if defined(CONFIG_MV_ETH_HWF) && !defined(CONFIG_MV_ETH_BM_CPU)
 MV_STATUS mv_eth_hwf_bm_create(int port, int mtuPktSize);
-- 
1.7.5.4

