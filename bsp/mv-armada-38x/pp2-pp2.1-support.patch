From dbe5f170363f56768c733dafce81f6fcfc267f2e Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Thu, 14 Nov 2013 11:36:49 +0200
Subject: [PATCH 1082/1825] pp2: pp2.1 support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit cb1f836603656007d923d14459755e318d92d4d3

	- Add ppv2 support to A0, backward compatible to Z1
	- Tested on Z1, Not tested on A0 yet
	- PPv2.1 driver support (up to patch 0064 in ALP FPGA A0)
	- PPv2.1 uboot support
	- Hals update

Change-Id: Ida618dd0058d6b5b150e384fb966dfc6cb8d22bd
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4324
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   10 +
 .../mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c         |  111 ++--
 .../mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c         |  146 +++--
 .../mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c         |  108 ++--
 .../mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c       |   42 +-
 .../mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c          |  229 +++++---
 .../mv_pp2/net_dev/mv_eth_bm_sysfs.c               |  107 +++-
 .../mv_pp2/net_dev/mv_eth_rx_sysfs.c               |   25 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   61 ++-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |   63 +-
 .../mv_pp2/net_dev/mv_eth_tx_sysfs.c               |   41 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |   18 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  636 ++++++++++++++-----
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |  321 ++++++----
 .../mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c        |  102 ++--
 .../mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c     |   49 +-
 .../mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c      |   74 ++-
 arch/arm/plat-armada/mv_hal/eth/mvEth.h            |    1 -
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c          |  674 ++++++++++++++++++--
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h          |   91 +++-
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h      |   88 +++-
 .../plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c   |    2 -
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c  |  192 ++++--
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h  |   34 +-
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c  |  459 +++++++++++--
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h  |  356 +++++++----
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c  |  128 ++++-
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h  |   15 +-
 .../arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h |  191 +++---
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c   |  375 ++++++++++-
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h   |  406 ++++++++----
 .../plat-armada/mv_hal/pp2/common/mvPp2Common.c    |   19 +
 .../plat-armada/mv_hal/pp2/common/mvPp2Common.h    |    5 +-
 .../plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h   |    2 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     |  485 +++++++++++----
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |   99 +++-
 .../arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c |  158 ++++-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h |  484 +++++++++-----
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c |  173 +++---
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h |   60 +-
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c |  105 +++-
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h |  115 +++-
 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c   |    4 +-
 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h   |    4 +-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c     |   21 +-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h     |    1 +
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c   |   53 ++-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h   |   16 +
 48 files changed, 5198 insertions(+), 1761 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index 21d54bc..a68a3fc 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -1,3 +1,13 @@
+config MV_ETH_PP2_1
+	bool "Support PPv2.1 version (A0)"
+	default n
+	---help---
+	PPv2.1 support (Avanta-LP A0)
+	PPv2.1 enable various features such as:
+	* Qsets support
+	* TX descriptors chunks mechanism
+	* See PPv2.1 MAS for more info
+
 config MV_ETH_PP2_CLS2
 	bool
 	default y
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
index 8f858a7..8e89a53 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "cls/mvPp2Cls2Hw.h"
+#include "../../../mv_hal/pp2/cls/mvPp2Cls2Hw.h"
 
 
 static MV_PP2_CLS_C2_QOS_ENTRY		qos_entry;
@@ -46,13 +46,14 @@ static MV_PP2_CLS_C2_ENTRY		act_entry;
 static ssize_t mv_cls_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                qos_sw_dump             - dump QoS table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                prio_hw_dump            - dump all QoS priority tables from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                dscp_hw_dump            - dump all QoS dscp tables from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                act_sw_dump             - dump action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                act_hw_dump             - dump all action table enrties from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                hw_regs                 - dump classifier C2 registers.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat                cnt_dump                - dump all hit counters that are not zeroed.\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  qos_sw_dump  - dump QoS table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  prio_hw_dump - dump all QoS priority tables from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  dscp_hw_dump - dump all QoS dscp tables from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  act_sw_dump  - dump action table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  act_hw_dump  - dump all action table enrties from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  hw_regs      - dump classifier C2 registers.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat  cnt_dump     - dump all hit counters that are not zeroed.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo 1             > qos_sw_clear           - clear QoS table SW entry.\n");
@@ -70,43 +71,54 @@ static ssize_t mv_cls_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo idx           > act_hw_write           - write action table SW entry into HW <idx>.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo idx           > act_hw_read            - read action table entry from HW <idx> into SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx	   > act_hw_inv		    - invalidate C2 entry <idx> in hw.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo        	   > act_hw_inv_all	    - invalidate all C2 entries in HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx           > act_hw_inv             - invalidate C2 entry <idx> in hw.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo               > act_hw_inv_all         - invalidate all C2 entries in HW.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE, "echo o d m         > act_sw_byte            - set byte <d,m> to TCAM offset <o> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo id sel	   > act_sw_qos             - set QoS table <id,sel> to action table SW entry.\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE, "echo id sel        > act_sw_qos             - set QoS table <id,sel> to action table SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd from      > act_sw_color           - set color command <cmd> to action table SW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             <from> - source for color command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              <from> - source for color command.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd prio from > act_sw_prio            - set priority command <cmd> and value <prio> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             table SW entry. <from> - source for priority command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table SW entry. <from> - source for priority command.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd prio from > act_sw_dscp            - set DSCP command <cmd> and value <dscp> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             table SW entry. <from> - source for DSCP command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table SW entry. <from> - source for DSCP command.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd gpid from > act_sw_gpid            - set GemPortID command <cmd> and value <gpid> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             table SW entry. <from> - source for GemPortID command.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from	   > act_sw_qh		   - set queue high command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					     table software entry. <from> -source for Queue High command.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from	   > act_sw_ql		   - set queue low command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					     table software entry. <from> -source for Queue Low command.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from	   > act_sw_queue	   - set full queue command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					     table software entry.  <from> -source for Queue command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table SW entry. <from> - source for GemPortID command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from    > act_sw_qh              - set queue high command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table software entry. <from>-source for Queue High command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from    > act_sw_ql              - set queue low command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table software entry. <from> -source for Queue Low command.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q from    > act_sw_queue           - set full queue command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              table software entry.  <from> -source for Queue command.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd           > act_sw_hwf             - set Forwarding command <cmd> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id        > act_sw_pol             - set PolicerID command <cmd> and number <id> to action.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             table SW entry.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id bank   > act_sw_pol             - set PolicerID command <cmd> bank and number <id> to action table SW entry.\n");
+#else
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id        > act_sw_pol             - set PolicerID command <cmd> and number <id> to action table SW entry.\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE, "echo en            > act_sw_flowid          - set FlowID enable/disable <1/0> to action table SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo d i cs        > act_sw_mdf             - set modification parameters to action table SW entry\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             data pointer <d>, instruction pointrt <i>,\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             <cs> enable L4 checksum generation.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo id cnt        > act_sw_dup              - set packet duplication parameters <id,cnt> to action.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "                                             table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              data pointer <d>, instruction pointrt <i>,\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                              <cs> enable L4 checksum generation.\n");
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx           > act_sw_mtu             - set MTU index to action table SW entry\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo miss id       > act_sw_sq              - set miss bit and instruction ID to action table SW entry\n");
+#endif
+
+/*TODO ppv2.1: ADD sysfs command for mvPp2ClsC2SeqSet */
+	off += scnprintf(buf + off, PAGE_SIZE, "echo id cnt        > act_sw_dup             - set packet duplication parameters <id,cnt> to action table SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo               > cnt_clr_all            - clear all hit counters from action tabe.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo idx           > cnt_read               - show hit counter for action table entry.\n");
-
+	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	return off;
 }
 
 
 static ssize_t mv_cls_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
 	int             off = 0;
@@ -136,7 +148,7 @@ static ssize_t mv_cls_show(struct device *dev,
 
 
 static ssize_t mv_cls_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0, e = 0;
@@ -196,13 +208,23 @@ static ssize_t mv_cls_store(struct device *dev,
 	else if (!strcmp(name, "act_sw_hwf"))
 		mvPp2ClsC2ForwardSet(&act_entry, a);
 	else if (!strcmp(name, "act_sw_pol"))
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2ClsC2PolicerSet(&act_entry, a, b, c);
+#else
 		mvPp2ClsC2PolicerSet(&act_entry, a, b);
+#endif
 	else if (!strcmp(name, "act_sw_mdf"))
 		mvPp2ClsC2ModSet(&act_entry, a, b, c);
+	else if (!strcmp(name, "act_sw_mtu"))/*PPv2.1 new feature MAS 3.7*/
+		mvPp2ClsC2MtuSet(&act_entry, a);
 	else if (!strcmp(name, "act_sw_dup"))
 		mvPp2ClsC2DupSet(&act_entry, a, b);
+	else if (!strcmp(name, "act_sw_sq"))/*PPv2.1 new feature MAS 3.14*/
+		mvPp2ClsC2SeqSet(&act_entry, a, b);
 	else if (!strcmp(name, "cnt_clr_all"))
 		mvPp2ClsC2HitCntrsClearAll();
+	else if (!strcmp(name, "act_sw_flowid"))
+		mvPp2ClsC2FlowIdEn(&act_entry, a);
 	else if (!strcmp(name, "cnt_read"))
 		mvPp2ClsC2HitCntrRead(a, NULL);
 	else {
@@ -227,16 +249,16 @@ static DEVICE_ATTR(cnt_dump,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(hw_regs,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(help,			S_IRUSR, mv_cls_show, NULL);
 
-static DEVICE_ATTR(qos_sw_clear,    		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(qos_hw_write,     		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(qos_hw_read,    	  	S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(qos_sw_prio,    		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(qos_sw_dscp, 		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_sw_clear,		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_hw_write,		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_hw_read,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_sw_prio,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_sw_dscp,			S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(qos_sw_color,		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(qos_sw_gemid,      		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(qos_sw_gemid,		S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(qos_sw_queue,		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(act_hw_inv,    		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(act_hw_inv_all,     		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(act_hw_inv,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(act_hw_inv_all,		S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_sw_clear,		S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_hw_write,		S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_hw_read,			S_IWUSR, mv_cls_show, mv_cls_store);
@@ -251,10 +273,14 @@ static DEVICE_ATTR(act_sw_queue,		S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_sw_hwf,			S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_sw_pol,			S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(act_sw_mdf,			S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(act_sw_dup,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(act_sw_mtu,			S_IWUSR, mv_cls_show, mv_cls_store);/*PPv2.1 new feature MAS 3.7*/
+static DEVICE_ATTR(act_sw_dup,			S_IWUSR, mv_cls_show, mv_cls_store);/*PPv2.1 new feature MAS 3.14*/
+static DEVICE_ATTR(act_sw_sq,			S_IWUSR, mv_cls_show, mv_cls_store);
 static DEVICE_ATTR(cnt_clr_all,			S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(act_sw_qos,  		S_IWUSR, mv_cls_show, mv_cls_store);
-static DEVICE_ATTR(cnt_read,	  		S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(act_sw_qos,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(cnt_read,			S_IWUSR, mv_cls_show, mv_cls_store);
+static DEVICE_ATTR(act_sw_flowid,		S_IWUSR, mv_cls_show, mv_cls_store);
+
 
 static struct attribute *cls2_attrs[] = {
 	&dev_attr_prio_hw_dump.attr,
@@ -289,10 +315,13 @@ static struct attribute *cls2_attrs[] = {
 	&dev_attr_act_sw_hwf.attr,
 	&dev_attr_act_sw_pol.attr,
 	&dev_attr_act_sw_mdf.attr,
+	&dev_attr_act_sw_mtu.attr,/*PPv2.1 new feature MAS 3.7*/
 	&dev_attr_act_sw_dup.attr,
+	&dev_attr_act_sw_sq.attr,/*PPv2.1 new feature MAS 3.14*/
 	&dev_attr_cnt_clr_all.attr,
 	&dev_attr_act_sw_qos.attr,
 	&dev_attr_cnt_read.attr,
+	&dev_attr_act_sw_flowid.attr,
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
index ab5bae2..1a4a9be 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
@@ -42,74 +42,93 @@ static MV_PP2_CLS_C3_ENTRY		c3;
 static ssize_t mv_cls3_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		init_database  - Internal SW database init.\n");/*TODO: remove after debugginig*/
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		hw_dump        - Dump all occupied entries from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		hw_ext_dump    - Dump all occupied extension table entries from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		sw_dump	       - Dump SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		sc_res_dump    - Dump all valid scan results from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		sc_regs        - Dump scan registers.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		hw_query       - Get query for HEK in the SW entry and show result.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat             cnt_read_all   - Dump all hit counters for all changed indices\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             hw_dump        - Dump all occupied entries from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             hw_ext_dump    - Dump all occupied extension table entries from HW.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             hw_ms_dump     - Dump all miss table entires from HW.\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             sw_dump        - Dump SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             sc_res_dump    - Dump all valid scan results from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             sc_regs        - Dump scan registers.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             hw_query       - Get query for HEK in the SW entry and show result.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             cnt_read_all   - Dump all hit counters for all changed indices and miss entries\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo lkp_type   > hw_ms_add    - Write entry from SW into HW miss table <lkp_type>\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE, "echo depth      > hw_query_add - Get query for HEK in the SW entry and Write entry into HW hash entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "				 free entry search depth <depth>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx	> hw_read      - Read entry from HW <idx> into SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx extIdx	> hw_add       - Write entry from SW into HW hash table <idx>\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "				 external table entry index <extIdx> optionally used for long entries.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx	> hw_del       - Delete entry from HW <idx>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> hw_del_all   - Delete all c3 entries from HW. \n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> sw_clear     - Clear SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo val	> sw_init_cnt  - Set initial hit counter value <val> (in units of 64 hits) to SW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo info	> key_sw_l4    - Set L4 information <info> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo type	> key_sw_lkp_type - Set key lookup type to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo id type	> key_sw_port  - Set key port ID <id> and port ID type to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo size	> key_sw_size  - Set key HEK size port ID <id> and port ID type to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo o d	> key_sw_byte  - Set byte of HEK data <d> and offset <o> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo o d	> key_sw_word  - Set byte of HEK data <d> and offset <o> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                 free entry search depth <depth>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx        > hw_read      - Read entry from HW <idx> into SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx extIdx > hw_add       - Write entry from SW into HW hash table <idx>\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                 external table entry index <extIdx> optionally used for long entries.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx        > hw_del       - Delete entry from HW <idx>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1          > hw_del_all   - Delete all c3 entries from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1          > sw_clear     - Clear SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo val        > sw_init_cnt  - Set initial hit counter value <val> (in units of 64 hits) to SW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo info       > key_sw_l4    - Set L4 information <info> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo type       > key_sw_lkp_type - Set key lookup type to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo id type    > key_sw_port  - Set key port ID <id> and port ID type to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo size       > key_sw_size  - Set key HEK size port ID <id> and port ID type to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo o d        > key_sw_byte  - Set byte of HEK data <d> and offset <o> to SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo o d        > key_sw_word  - Set byte of HEK data <d> and offset <o> to SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd	> act_sw_color - Set color command <cmd> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd qh	> act_sw_qh    - Set Queue High command <cmd> and value <qh> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd ql	> act_sw_ql    - Set Queue Low command <cmd> and value <ql> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q	> act_sw_queue - Set full Queue command <cmd> and value <q> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id	> act_sw_fwd   - Set Forwarding command <cmd> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id	> act_sw_pol   - Set PolicerID command <cmd> and number <id> to action table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo d i cs 	> act_sw_modif - Set modification parameters to action table SW entry data pointer <d>\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "				 instruction offset <i>, <cs> enable L4 checksum generation\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo id cnt	> act_sw_dup   - Set packet duplication parameters <id, cnt> to action SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd         > act_sw_color - Set color command <cmd> to action table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd qh      > act_sw_qh    - Set Queue High command <cmd> and value <qh> to action table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd ql      > act_sw_ql    - Set Queue Low command <cmd> and value <ql> to action table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q       > act_sw_queue - Set full Queue command <cmd> and value <q> to action table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd         > act_sw_fwd   - Set Forwarding command <cmd> to action table SW entry.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id bnk  > act_sw_pol   - Set PolicerID command <cmd> bank <bnk> and number <id> to action table SW entry.\n");
+#else
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id      > act_sw_pol   - Set PolicerID command <cmd> and number <id> to action table SW entry.\n");
+#endif
+
+	off += scnprintf(buf + off, PAGE_SIZE, "echo en          > act_sw_flowid- Set FlowID enable/disable <1/0> to action table SW entry.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx         > act_sw_mtu   - Set MTU index to action table SW entry\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE, "echo d i cs      > act_sw_mdf   - Set modification parameters to action table SW entry data pointer <d>\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                  instruction offset <i>, <cs> enable L4 checksum generation\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo id cnt      > act_sw_dup   - Set packet duplication parameters <id, cnt> to action SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo id off bits > act_sw_sq    - Write sequence id <id> to offset <off> (in bits), id bits size <bits>\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                  to action SW entry\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx	> cnt_read     - Show hit counter for action table entry <idx>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> cnt_clr_all  - Clear hit counters for all action table entries.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo t 		> cnt_clr_lkp  - Clear hit counters for all action table entries with lookup type <t>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx         > cnt_read     - Show hit counter for action table entry <idx>.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo lkp_type    > cnt_ms_read  - Show hit counter for action table miss entry <lkp_type>.\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1           > cnt_clr_all  - Clear hit counters for all action table entries.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo t           > cnt_clr_lkp  - Clear hit counters for all action table entries with lookup type <t>.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> sc_start     - Start new multi-hash scanning.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo m t	> sc_thresh    - Set scan threshold <t> and mode to above <m=1> or below <m=0> thresh.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo e 		> sc_clear_before - clear hit counter before scan enable <e=1> or disable<e=0> in HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo t		> sc_lkp       - Set lookup type <t> for scan operation, <t=-1> all entries are scanned\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo idx	> sc_start_idx - Set scan start entry <idx> in HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo time	> sc_delay     - Set scan delay <time> in HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo  idx	> sc_res_read  - Show result entry <idx> form scan result table in HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1           > sc_start     - Start new multi-hash scanning.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo m t         > sc_thresh    - Set scan threshold <t> and mode to above <m=1> or below <m=0> thresh.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo e           > sc_clear_before - clear hit counter before scan enable <e=1> or disable<e=0> in HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo t           > sc_lkp       - Set lookup type <t> for scan operation, <t=-1> all entries are scanned\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo idx         > sc_start_idx - Set scan start entry <idx> in HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo time        > sc_delay     - Set scan delay <time> in HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo  idx        > sc_res_read  - Show result entry <idx> form scan result table in HW.\n");
 
 	return off;
 }
 
 
 static ssize_t mv_cls3_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
 	int             off = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
-	if (!strcmp(name, "init_database"))
-		mvPp2ClsC3ShadowInit();
-	else if (!strcmp(name, "hw_dump"))
+	if (!strcmp(name, "hw_dump"))
 		mvPp2ClsC3HwDump();
+	else if (!strcmp(name, "hw_ms_dump"))
+		mvPp2ClsC3HwMissDump();
 	else if (!strcmp(name, "hw_ext_dump"))
 		mvPp2ClsC3HwExtDump();
 	else if (!strcmp(name, "sw_dump"))
@@ -131,7 +150,7 @@ static ssize_t mv_cls3_show(struct device *dev,
 
 
 static ssize_t mv_cls3_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0;
@@ -150,6 +169,8 @@ static ssize_t mv_cls3_store(struct device *dev,
 		mvPp2ClsC3HwQueryAdd(&c3, a);
 	else if (!strcmp(name, "hw_add"))
 		mvPp2ClsC3HwAdd(&c3, a, b);
+	else if (!strcmp(name, "hw_ms_add"))/*PPv2.1 new feature MAS 3.12*/
+		mvPp2ClsC3HwMissAdd(&c3, a);
 	else if (!strcmp(name, "hw_del"))
 		mvPp2ClsC3HwDel(a);
 	else if (!strcmp(name, "hw_del_all"))
@@ -181,13 +202,25 @@ static ssize_t mv_cls3_store(struct device *dev,
 	else if (!strcmp(name, "act_sw_fwd"))
 		mvPp2ClsC3ForwardSet(&c3, a);
 	else if (!strcmp(name, "act_sw_pol"))
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2ClsC3PolicerSet(&c3, a, b, c);
+#else
 		mvPp2ClsC3PolicerSet(&c3, a, b);
-	else if (!strcmp(name, "act_sw_modif"))
+#endif
+	else if (!strcmp(name, "act_sw_flowid"))
+		mvPp2ClsC3FlowIdEn(&c3, a);
+	else if (!strcmp(name, "act_sw_mdf"))
 		mvPp2ClsC3ModSet(&c3, a, b, c);
+	else if (!strcmp(name, "act_sw_mtu"))/*PPv2.1 new feature MAS 3.7*/
+		mvPp2ClsC3MtuSet(&c3, a);
 	else if (!strcmp(name, "act_sw_dup"))
 		mvPp2ClsC3DupSet(&c3, a, b);
+	else if (!strcmp(name, "act_sw_sq"))/*PPv2.1 new feature MAS 3.4*/
+		mvPp2ClsC3SeqSet(&c3, a, b, c);
 	else if (!strcmp(name, "cnt_read"))
 		mvPp2ClsC3HitCntrsRead(a, NULL);
+	else if (!strcmp(name, "cnt_ms_read"))
+		mvPp2ClsC3HitCntrsMissRead(a, NULL);
 	else if (!strcmp(name, "cnt_clr_all"))
 		mvPp2ClsC3HitCntrsClearAll();
 	else if (!strcmp(name, "cnt_clr_lkp"))
@@ -246,8 +279,8 @@ static ssize_t mv_cls3_signed_store(struct device *dev,
 }
 
 
-static DEVICE_ATTR(init_database,	S_IRUSR, mv_cls3_show, NULL);
 static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_cls3_show, NULL);
+static DEVICE_ATTR(hw_ms_dump,		S_IRUSR, mv_cls3_show, NULL);/*PPv2.1 new feature MAS 3.7*/
 static DEVICE_ATTR(hw_ext_dump,		S_IRUSR, mv_cls3_show, NULL);
 static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_cls3_show, NULL);
 static DEVICE_ATTR(sc_res_dump,		S_IRUSR, mv_cls3_show, NULL);
@@ -259,6 +292,7 @@ static DEVICE_ATTR(help,		S_IRUSR, mv_cls3_show, NULL);
 static DEVICE_ATTR(hw_query_add,	S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(hw_read,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(hw_add,		S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(hw_ms_add,		S_IWUSR, NULL, mv_cls3_store);/*PPv2.1 new feature MAS 3.12*/
 static DEVICE_ATTR(hw_del,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(hw_del_all,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(sw_clear,		S_IWUSR, NULL, mv_cls3_store);
@@ -275,9 +309,13 @@ static DEVICE_ATTR(act_sw_ql,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(act_sw_queue,	S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(act_sw_fwd,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(act_sw_pol,		S_IWUSR, NULL, mv_cls3_store);
-static DEVICE_ATTR(act_sw_modif,	S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(act_sw_mdf,		S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(act_sw_flowid,	S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(act_sw_mtu,		S_IWUSR, NULL, mv_cls3_store);/*PPv2.1 new feature MAS 3.7*/
 static DEVICE_ATTR(act_sw_dup,		S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(act_sw_sq,		S_IWUSR, NULL, mv_cls3_store);/*PPv2.1 new feature MAS 3.14*/
 static DEVICE_ATTR(cnt_read,		S_IWUSR, NULL, mv_cls3_store);
+static DEVICE_ATTR(cnt_ms_read,		S_IWUSR, NULL, mv_cls3_store);/*PPv2.1 new feature MAS 3.12*/
 static DEVICE_ATTR(cnt_clr_all,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(cnt_clr_lkp,		S_IWUSR, NULL, mv_cls3_store);
 static DEVICE_ATTR(sc_start,		S_IWUSR, NULL, mv_cls3_store);
@@ -291,8 +329,8 @@ static DEVICE_ATTR(sc_res_read,		S_IWUSR, NULL, mv_cls3_store);
 
 
 static struct attribute *cls3_attrs[] = {
-	&dev_attr_init_database.attr,
 	&dev_attr_hw_dump.attr,
+	&dev_attr_hw_ms_dump.attr,
 	&dev_attr_hw_ext_dump.attr,
 	&dev_attr_sw_dump.attr,
 	&dev_attr_sc_res_dump.attr,
@@ -303,6 +341,7 @@ static struct attribute *cls3_attrs[] = {
 	&dev_attr_hw_query_add.attr,
 	&dev_attr_hw_read.attr,
 	&dev_attr_hw_add.attr,
+	&dev_attr_hw_ms_add.attr,
 	&dev_attr_hw_del.attr,
 	&dev_attr_hw_del_all.attr,
 	&dev_attr_sw_clear.attr,
@@ -319,11 +358,15 @@ static struct attribute *cls3_attrs[] = {
 	&dev_attr_act_sw_queue.attr,
 	&dev_attr_act_sw_fwd.attr,
 	&dev_attr_act_sw_pol.attr,
-	&dev_attr_act_sw_modif.attr,
+	&dev_attr_act_sw_mdf.attr,
+	&dev_attr_act_sw_mtu.attr,
 	&dev_attr_act_sw_dup.attr,
+	&dev_attr_act_sw_sq.attr,
 	&dev_attr_cnt_read.attr,
+	&dev_attr_cnt_ms_read.attr,
 	&dev_attr_cnt_clr_all.attr,
 	&dev_attr_cnt_clr_lkp.attr,
+	&dev_attr_act_sw_flowid.attr,
 	&dev_attr_sc_start.attr,
 	&dev_attr_sc_thresh.attr,
 	&dev_attr_sc_clear_before.attr,
@@ -334,7 +377,6 @@ static struct attribute *cls3_attrs[] = {
 	NULL
 };
 
-
 static struct attribute_group cls3_group = {
 	.name = "cls3",
 	.attrs = cls3_attrs,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
index 43c0130..c8c424a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "pp2/cls/mvPp2Cls4Hw.h"
+#include "../../../mv_hal/pp2/cls/mvPp2Cls4Hw.h"
 
 
 static MV_PP2_CLS_C4_ENTRY		C4;
@@ -44,45 +44,56 @@ static MV_PP2_CLS_C4_ENTRY		C4;
 static ssize_t mv_cls_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		  sw_dump 		- dump software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		  hw_regs 		- dump hardware registers.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		  hw_dump 		- dump all hardware entries.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat               sw_dump               - Dump software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat               hw_regs               - Dump hardware registers.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat               hw_dump               - Dump all hardware entries.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "cat               hw_hits               - Dump non zeroed hit counters and the associated HW entries\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
-	off += scnprintf(buf + off, PAGE_SIZE, "echo p s r	> hw_port_rules		- set physical port number <p> for rules set <s>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo p s r      > hw_port_rules         - Set physical port number <p> for rules set <s>.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "                                          <rules> - number of rules.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo p s r	> hw_uni_rules		- set uni port number <p> for rules set <s>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo p s r      > hw_uni_rules          - Set uni port number <p> for rules set <s>.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "                                          <rules> - number of rules.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
-	off += scnprintf(buf + off, PAGE_SIZE, "echo s r    	> hw_write		- write software entry into hardware <set=s,rule=r>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo s r	> hw_read 		- read entry <set=s,rule=r> from hardware into software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> sw_clear		- clear software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> hw_clear_all		- clear all C4 rules in hardware.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo f o d	> rule_two_b 		- set two bytes of data <d> in field <f> with offset <o> to\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo f id op	> rule_params 		- set ID <id> and OpCode <op> to filed <f> in software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo mode	> rule_sw_pppoe		- set PPPOE mode to software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo mode	> rule_sw_vlan		- set VLAN mode to software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo mode	> rule_sw_mac		- set mac to me mode to software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo mode	> rule_sw_l4		- set L4 info mode to software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo mode	> rule_sw_l3		- set L3 info mode to software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo s r        > hw_write              - Write software entry into hardware <set=s,rule=r>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo s r        > hw_read               - Read entry <set=s,rule=r> from hardware into software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1          > sw_clear              - Clear software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1          > hw_clear_all          - Clear all C4 rules in hardware.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo f o d      > rule_two_b            - Set two bytes of data <d> in field <f> with offset <o> to\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo f id op    > rule_params           - Set ID <id> and OpCode <op> to filed <f> in software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo mode       > rule_sw_pppoe         - Set PPPOE mode to software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo mode       > rule_sw_vlan          - Set VLAN mode to software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo mode       > rule_sw_mac           - Set mac to me mode to software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo mode       > rule_sw_l4            - Set L4 info mode to software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo mode       > rule_sw_l3            - Set L3 info mode to software entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd	> act_sw_color		- set Color command <cmd> to action table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd prio	> act_sw_prio		- set priority command <cmd> and value <prio> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd dscp	> act_sw_dscp		- set DSCP command <cmd> and value <dscp> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd gpid	> act_sw_gpid		- set GemPortID command <cmd> and value <gpid> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q	> act_sw_qh		- set queue high command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q	> act_sw_ql		- set queue low command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q	> act_sw_queue		- set full queue command <cmd> and value <q> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id	> act_sw_pol		- set PolicerId command <cmd> and numver <id> to action\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "					  table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd        > act_sw_color          - Set Color command <cmd> to action table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd prio   > act_sw_prio           - Set priority command <cmd> and value <prio> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd dscp   > act_sw_dscp           - Set DSCP command <cmd> and value <dscp> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd gpid   > act_sw_gpid           - Set GemPortID command <cmd> and value <gpid> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q      > act_sw_qh             - Set queue high command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q      > act_sw_ql             - Set queue low command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd        > act_sw_fwd            - Set Forwarding command <cmd> to action table software entry\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd q      > act_sw_queue          - Set full queue command <cmd> and value <q> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id bnk > act_sw_pol            - Set PolicerId command <cmd> bank <bnk> and numver <id> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+#else
+	off += scnprintf(buf + off, PAGE_SIZE, "echo cmd id     > act_sw_pol            - Set PolicerId command <cmd> and numver <id> to action\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "                                          table software entry.\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
 	return off;
@@ -90,7 +101,7 @@ static ssize_t mv_cls_help(char *buf)
 
 
 static ssize_t mv_cls_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
 	int             off = 0;
@@ -104,6 +115,9 @@ static ssize_t mv_cls_show(struct device *dev,
 		mvPp2ClsC4RegsDump();
 	else if (!strcmp(name, "hw_dump"))
 		mvPp2ClsC4HwDumpAll();
+	else if (!strcmp(name, "hw_hits"))
+		mvPp2V1ClsC4HwHitsDump();
+
 	else
 		off += mv_cls_help(buf);
 
@@ -112,7 +126,7 @@ static ssize_t mv_cls_show(struct device *dev,
 
 
 static ssize_t mv_cls_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0, e = 0;
@@ -163,10 +177,16 @@ static ssize_t mv_cls_store(struct device *dev,
 		mvPp2ClsC4QueueHighSet(&C4, a, b);
 	else if (!strcmp(name, "act_sw_ql"))
 		mvPp2ClsC4QueueLowSet(&C4, a, b);
+	else if (!strcmp(name, "act_sw_fwd"))
+		mvPp2ClsC4ForwardSet(&C4, a);
 	else if (!strcmp(name, "act_sw_queue"))
 		mvPp2ClsC4QueueSet(&C4, a, b);
 	else if (!strcmp(name, "act_sw_pol"))
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2ClsC4PolicerSet(&C4, a, b, c);
+#else
 		mvPp2ClsC4PolicerSet(&C4, a, b);
+#endif
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -182,16 +202,17 @@ static ssize_t mv_cls_store(struct device *dev,
 static DEVICE_ATTR(hw_dump,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(sw_dump,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(hw_regs,			S_IRUSR, mv_cls_show, NULL);
+static DEVICE_ATTR(hw_hits,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(help,			S_IRUSR, mv_cls_show, NULL);
 
 static DEVICE_ATTR(hw_port_rules,		S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(hw_uni_rules,		S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(hw_read,   	 	  	S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(hw_write,     		S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(sw_clear,     		S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(hw_clear_all,     		S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(rule_two_b,    		S_IWUSR, NULL, mv_cls_store);
-static DEVICE_ATTR(rule_params,    		S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(hw_read,			S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(hw_write,			S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(sw_clear,			S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(hw_clear_all,		S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(rule_two_b,			S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(rule_params,			S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(rule_sw_vlan,		S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(rule_sw_pppoe,		S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(rule_sw_mac,			S_IWUSR, NULL, mv_cls_store);
@@ -203,14 +224,18 @@ static DEVICE_ATTR(act_sw_dscp,			S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(act_sw_gpid,			S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(act_sw_qh,			S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(act_sw_ql,			S_IWUSR, NULL, mv_cls_store);
+static DEVICE_ATTR(act_sw_fwd,			S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(act_sw_queue,		S_IWUSR, NULL, mv_cls_store);
 static DEVICE_ATTR(act_sw_pol,			S_IWUSR, NULL, mv_cls_store);
 
 
+
+
 static struct attribute *cls4_attrs[] = {
 	&dev_attr_sw_dump.attr,
 	&dev_attr_hw_dump.attr,
 	&dev_attr_hw_regs.attr,
+	&dev_attr_hw_hits.attr,
 	&dev_attr_help.attr,
 	&dev_attr_hw_port_rules.attr,
 	&dev_attr_hw_uni_rules.attr,
@@ -231,6 +256,7 @@ static struct attribute *cls4_attrs[] = {
 	&dev_attr_act_sw_gpid.attr,
 	&dev_attr_act_sw_qh.attr,
 	&dev_attr_act_sw_ql.attr,
+	&dev_attr_act_sw_fwd.attr,/*ppv2.1 new feature MAS 3.9*/
 	&dev_attr_act_sw_queue.attr,
 	&dev_attr_act_sw_pol.attr,
 	NULL
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
index 346dfd3..822db04 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
@@ -42,21 +42,21 @@ static MV_PP2_MC_ENTRY		mc;
 static ssize_t mv_mc_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE, "cat	        sw_dump      - Dump software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat	        hw_dump      - Dump all hardware entries.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             sw_dump      - Dump software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat             hw_dump      - Dump all hardware entries.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
-	off += scnprintf(buf + off, PAGE_SIZE, "echo i	      > hw_write     - Write software entry into hardware <i>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo i	      > hw_read      - Read entry <i> from hardware into software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1	      > sw_clear     - Clear software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1	      > hw_clear_all - Clear all multicast table entries in hardware.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo i        > hw_write     - Write software entry into hardware <i>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo i        > hw_read      - Read entry <i> from hardware into software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1        > sw_clear     - Clear software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1        > hw_clear_all - Clear all multicast table entries in hardware.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE, "echo prio en  > mc_sw_prio   - Set priority enable <en> and value <prio> to sw entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo dscp en  > mc_sw_dscp   - Set DSCP enable <en> and value <dscp> to sw entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo gpid en  > mc_sw_gpid   - Set GemPortID enable <en> and value <gpid> to sw entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo d i      > mc_sw_modif  - Set modification data <d> and command <i> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo q	      > mc_sw_queue  - Set Queue <q> value to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo en	      > mc_sw_hwf    - Set HWF enabled <en=1> or disable <en=0> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo q        > mc_sw_queue  - Set Queue <q> value to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo en       > mc_sw_hwf    - Set HWF enabled <en=1> or disable <en=0> to sw entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "echo next     > mc_sw_next   - Set next pointer <next> to sw entry.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
@@ -65,7 +65,7 @@ static ssize_t mv_mc_help(char *buf)
 }
 
 static ssize_t mv_mc_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
 	int             off = 0;
@@ -85,7 +85,7 @@ static ssize_t mv_mc_show(struct device *dev,
 
 
 static ssize_t mv_mc_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0, e = 0;
@@ -136,17 +136,17 @@ static DEVICE_ATTR(hw_dump,			S_IRUSR, mv_mc_show, NULL);
 static DEVICE_ATTR(sw_dump,			S_IRUSR, mv_mc_show, NULL);
 static DEVICE_ATTR(help,			S_IRUSR, mv_mc_show, NULL);
 
-static DEVICE_ATTR(hw_read,   	 	  	S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(hw_write,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(sw_clear,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(hw_clear_all,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_prio,   	  	S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_dscp,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_gpid,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_modif,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_queue,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_hwf,     		S_IWUSR, NULL, mv_mc_store);
-static DEVICE_ATTR(mc_sw_next,     		S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(hw_read,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(hw_write,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(sw_clear,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(hw_clear_all,		S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_prio,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_dscp,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_gpid,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_modif,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_queue,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_hwf,			S_IWUSR, NULL, mv_mc_store);
+static DEVICE_ATTR(mc_sw_next,			S_IWUSR, NULL, mv_mc_store);
 
 
 static struct attribute *mc_attrs[] = {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
index 8327730..8df0801 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "pp2/cls/mvPp2ClsHw.h"
+#include "../../../mv_hal/pp2/cls/mvPp2ClsHw.h"
 
 static MV_PP2_CLS_LKP_ENTRY	lkp_entry;
 static MV_PP2_CLS_FLOW_ENTRY	flow_entry;
@@ -43,53 +43,76 @@ static MV_PP2_CLS_FLOW_ENTRY	flow_entry;
 static ssize_t mv_cls_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		lkp_sw_dump		- dump lookup ID table sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		flow_sw_dump		- dump flow table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		lkp_hw_dump		- dump lookup ID tabel from hardware.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		flow_hw_dump		- dump flow table from hardware.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		len_change_hw_dump	- lkp dump sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "cat		hw_regs			- dump classifier top registers.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             lkp_sw_dump          - dump lookup ID table sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             flow_sw_dump         - dump flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             lkp_hw_dump          - dump lookup ID tabel from hardware.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             flow_hw_hits         - dump non zeroed hit counters  and the associated flow tabel entries from hardware.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             lkp_hw_hits          - dump non zeroed hit counters and the associated lookup ID entires from hardware.\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             flow_hw_dump         - dump flow table from hardware.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             len_change_hw_dump   - lkp dump sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "cat             hw_regs              - dump classifier top registers.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE,  "\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo 1		>lkp_sw_clear		- clear lookup ID table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo 1		>flow_sw_clear	        - clear flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo 1          >lkp_sw_clear        - clear lookup ID table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo 1          >flow_sw_clear       - clear flow table SW entry.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE,  "\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo en         >hw_enable              - classifier enable/disable <en = 1/0>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo p w        >hw_port_way		- set lookup way <w> for physical port <p>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo p mode	>hw_port_spid		- set SPID extraction mode <mode> for physical port <p>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo uni spid	>hw_uni_spid		- set port <uni> for spid <spid>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo virt gpid	>hw_virt_gpid		- set virtual port number <virt> for GemPortId <gpid>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo a b c d	>hw_udf			- set UDF field <a> as: base <b>, offset <c> bits, size<d> bits.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo p txp m	>hw_mtu       		- set MTU value <m> for egress port <p, txp>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo p rxq	>hw_over_rxq		- set  RXQ <rxq> for oversize ingress via port <p>.\n");
-
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo en         >hw_enable           - classifier enable/disable <en = 1/0>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p w        >hw_port_way         - set lookup way <w> for physical port <p>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p mode     >hw_port_spid        - set SPID extraction mode <mode> for physical port <p>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo uni spid   >hw_uni_spid         - set port <uni> for spid <spid>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo virt gpid  >hw_virt_gpid        - set virtual port number <virt> for GemPortId <gpid>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo a b c d    >hw_udf              - set UDF field <a> as: base <b>, offset <c> bits, size<d> bits.\n");
+
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p q        >hw_over_rxq         - set oversize rxq <q> for ingress port <p>.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p from q   >hw_qh               - set rx high queue source <from> and queue <q> for ingress port <p>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx m      >hw_mtu              - set MTU value <m> for index <idx>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p v u mh   >hw_mh               - set port <p> enable/disable port Id generation for.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "                                       virtual <v=0,1> and uni <u=0,1> ports, set default Marvell header <mh>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx size   >hw_sq_size          - set sequence id number <idx> size to flow table software entry\n");
+#else
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo p txp m    >hw_mtu              - set MTU value <m> for egress port <p, txp>.\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE,  "\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx way	>lkp_hw_write		- write lookup ID table SW entry HW <idx,way>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx way	>lkp_hw_read		- read lookup ID table entry from HW <idx,way>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo rxq	>lkp_sw_rxq		- set default RXQ <rxq> to lookup ID table.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo f		>lkp_sw_flow		- set index of firs insruction <f> in flow table\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "					  to lookup ID SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo m		>lkp_sw_mod		- set modification instruction offset <m> to lookup ID SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo e		>lkp_sw_en		- Enable <e=1> or disable <e=0> lookup ID table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx way    >lkp_hw_write        - write lookup ID table SW entry HW <idx,way>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx way    >lkp_hw_read         - read lookup ID table entry from HW <idx,way>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo rxq        >lkp_sw_rxq          - set default RXQ <rxq> to lookup ID table.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo f          >lkp_sw_flow         - set index of firs insruction <f> in flow table\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "                                       to lookup ID SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo m          >lkp_sw_mod          - set modification instruction offset <m> to lookup ID SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo e          >lkp_sw_en           - Enable <e=1> or disable <e=0> lookup ID table SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE,  "\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo id         >flow_hw_write		- write flow table SW entry to HW <id>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo id         >flow_hw_read		- read flow table entry <id> from HW.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo t p        >flow_sw_port		- set port type <t> and number <p> to flow table SW entry\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo e l        >flow_sw_engine		- set engine <e> nember to flow table SW entry.  <l> - last bit.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo l p        >flow_sw_extra		- set lookup type <l> and priority <p> to flow table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx id     >flow_sw_hek		- set HEK field <idx, id> flow table SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo n          >flow_sw_num_of_heks	- set number of HEK fields <n> to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo id         >flow_hw_write       - write flow table SW entry to HW <id>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo id         >flow_hw_read        - read flow table entry <id> from HW.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo t id       >flow_sw_port        - set port type <t> and id <p> to flow table SW entry\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	/*PPv2.1 new feature MAS 3.18*/
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo from       >flow_sw_portid      - set cls to recive portid via packet <from=1>\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "                                       or via user configurration <from=0>  to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo mode       >flow_sw_pppoe       - Set PPPoE lookup skip mode <mode> to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo mode       >flow_sw_vlan        - Set VLAN lookup skip mode <mode> to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo mode       >flow_sw_macme       - Set MAC ME lookup skip mode <mode> to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo mode       >flow_sw_udf7        - Set UDF7 lookup skip mode <mode> to flow table SW entry.\n");
+	/*PPv2.1 new feature MAS 3.14*/
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo mode       >flow_sw_sq          - Set sequence type <mode> to flow table SW entry.\n");
+#endif
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo e l        >flow_sw_engin       - set engine <e> nember to flow table SW entry.  <l> - last bit.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo l p        >flow_sw_extra       - set lookup type <l> and priority <p> to flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo idx id     >flow_sw_hek         - set HEK field <idx, id> flow table SW entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo n          >flow_sw_num_of_heks - set number of HEK fields <n> to flow table SW entry.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE,  "\n");
-	off += scnprintf(buf + off, PAGE_SIZE,  "echo i len      >len_change_hw_set	- set signed length <len> (in decimal) change for modification index <idx> (in hex).\n");
+	off += scnprintf(buf + off, PAGE_SIZE,  "echo i len      >len_change_hw_set   - set signed length <len> (in decimal) change for modification index <idx> (in hex).\n");
 
 	return off;
 }
 
 
 static ssize_t mv_cls_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	const char      *name = attr->attr.name;
 	int             off = 0;
@@ -99,6 +122,10 @@ static ssize_t mv_cls_show(struct device *dev,
 
 	if (!strcmp(name, "lkp_sw_dump"))
 		mvPp2ClsSwLkpDump(&lkp_entry);
+	else if (!strcmp(name, "lkp_hw_hits"))
+		mvPp2V1ClsHwLkpHitsDump();
+	else if (!strcmp(name, "flow_hw_hits"))
+		mvPp2V1ClsHwFlowHitsDump();
 	else if (!strcmp(name, "flow_sw_dump"))
 		mvPp2ClsSwFlowDump(&flow_entry);
 	else if (!strcmp(name, "lkp_hw_dump"))
@@ -118,7 +145,7 @@ static ssize_t mv_cls_show(struct device *dev,
 
 
 static ssize_t mv_prs_store_unsigned(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0, b = 0, c = 0, d = 0;
@@ -153,6 +180,19 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 		mvPp2ClsHwFlowRead(a, &flow_entry);
 	else if (!strcmp(name, "flow_sw_port"))
 		mvPp2ClsSwFlowPortSet(&flow_entry, a, b);
+	else if (!strcmp(name, "flow_sw_portid"))
+		mvPp2ClsSwPortIdSelect(&flow_entry, a);
+	else if (!strcmp(name, "flow_sw_pppoe"))
+		mvPp2ClsSwFlowPppoeSet(&flow_entry, a);
+	else if (!strcmp(name, "flow_sw_vlan"))
+		mvPp2ClsSwFlowVlanSet(&flow_entry, a);
+	else if (!strcmp(name, "flow_sw_macme"))
+		mvPp2ClsSwFlowMacMeSet(&flow_entry, a);
+	else if (!strcmp(name, "flow_sw_udf7"))
+		mvPp2ClsSwFlowUdf7Set(&flow_entry, a);
+	/*PPv2.1 feature changed MAS 3.14*/
+	else if (!strcmp(name, "flow_sw_sq"))
+		mvPp2ClsSwFlowSeqCtrlSet(&flow_entry, a);
 	else if (!strcmp(name, "flow_sw_engine"))
 		mvPp2ClsSwFlowEngineSet(&flow_entry, a, b);
 	else if (!strcmp(name, "flow_sw_extra"))
@@ -173,10 +213,24 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 		mvPp2ClsHwVirtPortSet(a, b);
 	else if (!strcmp(name, "hw_udf"))
 		mvPp2ClsHwUdfSet(a, b, c, d);
+	/*PPv2.1 feature changed MAS 3.7*/
 	else if (!strcmp(name, "hw_mtu"))
-		mvPp2ClsHwMtuSet(a, b, c);
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2V1ClsHwMtuSet(a, b);
+#else
+		mvPp2V0ClsHwMtuSet(a, b, c);
+#endif
 	else if (!strcmp(name, "hw_over_rxq"))
 		mvPp2ClsHwOversizeRxqSet(a, b);
+	/*PPv2.1 new feature MAS 3.5*/
+	else if (!strcmp(name, "hw_qh"))
+		mvPp2ClsHwRxQueueHighSet(a, b, c);
+	/*PPv2.1 new feature MAS 3.18*/
+	else if (!strcmp(name, "hw_mh"))
+		mvPp2ClsHwMhSet(a, b, c, d);
+	/*PPv2.1 new feature MAS 3.18*/
+	else if (!strcmp(name, "hw_sq_size"))
+		mvPp2ClsHwSeqInstrSizeSet(a, b);
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -191,7 +245,7 @@ static ssize_t mv_prs_store_unsigned(struct device *dev,
 
 
 static ssize_t mv_prs_store_signed(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
+				struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0, a = 0;
@@ -220,23 +274,31 @@ static ssize_t mv_prs_store_signed(struct device *dev,
 }
 
 static DEVICE_ATTR(lkp_hw_dump,			S_IRUSR, mv_cls_show, NULL);
+static DEVICE_ATTR(lkp_hw_hits,			S_IRUSR, mv_cls_show, NULL);
+static DEVICE_ATTR(flow_hw_hits,		S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(flow_hw_dump,		S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(lkp_sw_dump,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(flow_sw_dump,		S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(len_change_hw_dump,		S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(help,			S_IRUSR, mv_cls_show, NULL);
 static DEVICE_ATTR(hw_regs,			S_IRUSR, mv_cls_show, NULL);
-static DEVICE_ATTR(lkp_sw_clear,    		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(lkp_hw_write,     		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(lkp_hw_read,      		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(lkp_sw_rxq,    		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(lkp_sw_flow, 		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_sw_clear,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_hw_write,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_hw_read,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_sw_rxq,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_sw_flow,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(lkp_sw_mod,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
-static DEVICE_ATTR(lkp_sw_en,      		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(lkp_sw_en,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_sw_clear,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_hw_write,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_hw_read,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_sw_port,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(flow_sw_portid,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(flow_sw_pppoe,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(flow_sw_macme,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(flow_sw_vlan,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(flow_sw_udf7,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(flow_sw_sq,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);/*PPv2.1 new feature MAS 3.14*/
 static DEVICE_ATTR(flow_sw_engine,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_sw_extra,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(flow_sw_hek,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
@@ -250,40 +312,56 @@ static DEVICE_ATTR(hw_virt_gpid,		S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(hw_udf,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(hw_mtu,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
 static DEVICE_ATTR(hw_over_rxq,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned);
+static DEVICE_ATTR(hw_qh,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned); /*PPv2.1 new feature MAS 3.5*/
+static DEVICE_ATTR(hw_mh,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned); /*PPv2.1 new feature MAS 3.18*/
+static DEVICE_ATTR(hw_sq_size,			S_IWUSR, mv_cls_show, mv_prs_store_unsigned); /*PPv2.1 new feature MAS 3.14*/
+
+
 
 static struct attribute *cls_attrs[] = {
-    &dev_attr_lkp_sw_dump.attr,
-    &dev_attr_flow_sw_dump.attr,
-    &dev_attr_lkp_hw_dump.attr,
-    &dev_attr_flow_hw_dump.attr,
-    &dev_attr_len_change_hw_dump.attr,
-    &dev_attr_hw_regs.attr,
-    &dev_attr_lkp_sw_clear.attr,
-    &dev_attr_lkp_hw_write.attr,
-    &dev_attr_lkp_hw_read.attr,
-    &dev_attr_lkp_sw_rxq.attr,
-    &dev_attr_lkp_sw_flow.attr,
-    &dev_attr_lkp_sw_mod.attr,
-    &dev_attr_lkp_sw_en.attr,
-    &dev_attr_flow_sw_clear.attr,
-    &dev_attr_flow_hw_write.attr,
-    &dev_attr_flow_hw_read.attr,
-    &dev_attr_flow_sw_port.attr,
-    &dev_attr_flow_sw_engine.attr,
-    &dev_attr_flow_sw_extra.attr,
-    &dev_attr_flow_sw_hek.attr,
-    &dev_attr_flow_sw_num_of_heks.attr,
-    &dev_attr_len_change_hw_set.attr,
-    &dev_attr_hw_enable.attr,
-    &dev_attr_hw_port_way.attr,
-    &dev_attr_hw_port_spid.attr,
-    &dev_attr_hw_uni_spid.attr,
-    &dev_attr_hw_virt_gpid.attr,
-    &dev_attr_hw_udf.attr,
-    &dev_attr_hw_mtu.attr,
-    &dev_attr_hw_over_rxq.attr,
-    &dev_attr_help.attr,
-    NULL
+	&dev_attr_lkp_sw_dump.attr,
+	&dev_attr_flow_sw_dump.attr,
+	&dev_attr_lkp_hw_hits.attr,
+	&dev_attr_flow_hw_hits.attr,
+	&dev_attr_lkp_hw_dump.attr,
+	&dev_attr_flow_hw_dump.attr,
+	&dev_attr_len_change_hw_dump.attr,
+	&dev_attr_hw_regs.attr,
+	&dev_attr_lkp_sw_clear.attr,
+	&dev_attr_lkp_hw_write.attr,
+	&dev_attr_lkp_hw_read.attr,
+	&dev_attr_lkp_sw_rxq.attr,
+	&dev_attr_lkp_sw_flow.attr,
+	&dev_attr_lkp_sw_mod.attr,
+	&dev_attr_lkp_sw_en.attr,
+	&dev_attr_flow_sw_clear.attr,
+	&dev_attr_flow_hw_write.attr,
+	&dev_attr_flow_hw_read.attr,
+	&dev_attr_flow_sw_port.attr,
+	&dev_attr_flow_sw_portid.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_flow_sw_engine.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_flow_sw_vlan.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_flow_sw_pppoe.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_flow_sw_macme.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_flow_sw_sq.attr,/*PPv2.1 new feature MAS 3.14*/
+	&dev_attr_flow_sw_udf7.attr,
+	&dev_attr_flow_sw_extra.attr,
+	&dev_attr_flow_sw_hek.attr,
+	&dev_attr_flow_sw_num_of_heks.attr,
+	&dev_attr_len_change_hw_set.attr,
+	&dev_attr_hw_enable.attr,
+	&dev_attr_hw_port_way.attr,
+	&dev_attr_hw_port_spid.attr,
+	&dev_attr_hw_uni_spid.attr,
+	&dev_attr_hw_virt_gpid.attr,
+	&dev_attr_hw_udf.attr,
+	&dev_attr_hw_mtu.attr,/*PPv2.1 feature changed MAS 3.7*/
+	&dev_attr_hw_over_rxq.attr,
+	&dev_attr_hw_qh.attr,/*PPv2.1 new feature MAS 3.5*/
+	&dev_attr_hw_mh.attr,/*PPv2.1 new feature MAS 3.18*/
+	&dev_attr_hw_sq_size.attr,/*PPv2.1 new feature MAS 3.14*/
+	&dev_attr_help.attr,
+	NULL
 };
 
 static struct attribute_group cls_group = {
@@ -308,4 +386,3 @@ int mv_pp2_cls_sysfs_exit(struct kobject *pp2_kobj)
 
 	return 0;
 }
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
index 3540bd4..8b0c40d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
@@ -40,14 +40,29 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "echo [pool]           > poolRegs     - print BM pool registers\n");
-	off += sprintf(buf+off, "echo [pool]           > poolStatus   - print BM pool status\n");
-	off += sprintf(buf+off, "echo [pool] [size]    > poolSize     - set packet size <size> to BM pool <pool>\n");
-	off += sprintf(buf+off, "echo [pool] [buf_num] > poolBufNum   - set buffers num for BM pool\n");
-	off += sprintf(buf+off, "echo [port] [pool]    > longPool     - set port's long BM pool\n");
-	off += sprintf(buf+off, "echo [port] [pool]    > shortPool    - set port's short BM pool\n");
-	off += sprintf(buf+off, "echo [port] [pool]    > hwfLongPool  - set port's HWF long BM pool\n");
-	off += sprintf(buf+off, "echo [port] [pool]    > hwfShortPool - set port's HWF short BM pool\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += sprintf(buf+off, "cat                            queueMappDump   - print BM all rxq/txq to qSet mapp\n");
+	off += sprintf(buf+off, "cat                            qsetConfigDump  - print BM all qSets configuration\n");
+	off += sprintf(buf+off, "echo [qset] [pool]           > qsetCreate      - create qset and attach it to BM [pool]\n");
+	off += sprintf(buf+off, "echo [qset]                  > qsetDelete      - delete an unused qset (not used by RXQ/TXQ)\n");
+	off += sprintf(buf+off, "echo [qset] [grntd] [shared] > qsetMaxSet      - set max buff parameters for [qset]\n");
+	off += sprintf(buf+off, "echo [rxq] [qset]            > rxqQsetLong     - map [rxq] long Qset to [qset]\n");
+	off += sprintf(buf+off, "echo [rxq] [qset]            > rxqQsetShort    - map [rxq] short Qset to [qset]\n");
+	off += sprintf(buf+off, "echo [txq] [qset]            > txqQsetLong     - map [txq] long Qset to [qset]\n");
+	off += sprintf(buf+off, "echo [txq] [qset]            > txqQsetShort    - map [txq] short Qset to [qset]\n");
+	off += sprintf(buf+off, "echo [qset]                  > qsetShow        - show info for Qset [qset]\n");
+
+	off += sprintf(buf+off, "echo [pool]                  > poolDropCnt     - print BM pool drop counters\n");
+#endif
+
+	off += sprintf(buf+off, "echo [pool]                  > poolRegs        - print BM pool registers\n");
+	off += sprintf(buf+off, "echo [pool]                  > poolStatus      - print BM pool status\n");
+	off += sprintf(buf+off, "echo [pool] [size]           > poolSize        - set packet size to BM pool\n");
+	off += sprintf(buf+off, "echo [pool] [buf_num]        > poolBufNum      - set buffers num for BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]           > longPool        - set port's long BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]           > shortPool       - set port's short BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]           > hwfLongPool     - set port's HWF long BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]           > hwfShortPool    - set port's HWF short BM pool\n");
 
 	return off;
 }
@@ -55,12 +70,19 @@ static ssize_t mv_eth_help(char *buf)
 static ssize_t mv_eth_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
+	const char	*name = attr->attr.name;
 	int             off = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	off = mv_eth_help(buf);
+	if (!strcmp(name, "queueMappDump"))
+		mvBmQueueMapDumpAll();
+	else if  (!strcmp(name, "qsetConfigDump"))
+		mvBmQsetConfigDumpAll();
+
+	else
+		off = mv_eth_help(buf);
 
 	return off;
 }
@@ -70,34 +92,52 @@ static ssize_t mv_eth_port_store(struct device *dev,
 {
 	const char      *name = attr->attr.name;
 	int             err;
-	unsigned int    p, v;
+	unsigned int    a, b, c;
 	unsigned long   flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
 	/* Read port and value */
-	err = p = v = 0;
-	sscanf(buf, "%d %d", &p, &v);
+	err = a = b = c = 0;
+	sscanf(buf, "%d %d %d", &a, &b, &c);
 
 	local_irq_save(flags);
 
 	if (!strcmp(name, "poolRegs")) {
-		mvPp2BmPoolRegs(p);
+		mvPp2BmPoolRegs(a);
+	} else if (!strcmp(name, "poolDropCnt")) {
+		mvBmV1PoolDropCntDump(a);
 	} else if (!strcmp(name, "poolStatus")) {
-		mv_eth_pool_status_print(p);
+		mv_eth_pool_status_print(a);
 	} else if (!strcmp(name, "poolSize")) {
-		err = mv_eth_ctrl_pool_size_set(p, v);
+		err = mv_eth_ctrl_pool_size_set(a, b);
 	} else if (!strcmp(name, "poolBufNum")) {
-		err = mv_eth_ctrl_pool_buf_num_set(p, v);
+		err = mv_eth_ctrl_pool_buf_num_set(a, b);
 	} else if (!strcmp(name, "longPool")) {
-		err = mv_eth_ctrl_long_pool_set(p, v);
+		err = mv_eth_ctrl_long_pool_set(a, b);
 	} else if (!strcmp(name, "shortPool")) {
-		err = mv_eth_ctrl_short_pool_set(p, v);
+		err = mv_eth_ctrl_short_pool_set(a, b);
 	} else if (!strcmp(name, "hwfLongPool")) {
-		err = mv_eth_ctrl_hwf_long_pool_set(p, v);
+		err = mv_eth_ctrl_hwf_long_pool_set(a, b);
 	} else if (!strcmp(name, "hwfShortPool")) {
-		err = mv_eth_ctrl_hwf_short_pool_set(p, v);
+		err = mv_eth_ctrl_hwf_short_pool_set(a, b);
+	} else if (!strcmp(name, "qsetCreate")) {
+		mvBmQsetCreate(a, b);
+	} else if (!strcmp(name, "qsetDelete")) {
+		mvBmQsetDelete(a);
+	} else if (!strcmp(name, "rxqQsetLong")) {
+		mvBmRxqToQsetLongSet(a, b);
+	} else if (!strcmp(name, "rxqQsetShort")) {
+		mvBmRxqToQsetShortSet(a, b);
+	} else if (!strcmp(name, "txqQsetLong")) {
+		mvBmTxqToQsetLongSet(a, b);
+	} else if (!strcmp(name, "txqQsetShort")) {
+		mvBmTxqToQsetShortSet(a, b);
+	} else if (!strcmp(name, "qsetMaxSet")) {
+		mvBmQsetBuffMaxSet(a, b, c);
+	} else if (!strcmp(name, "qsetShow")) {
+		mvBmQsetShow(a);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -112,7 +152,10 @@ static ssize_t mv_eth_port_store(struct device *dev,
 }
 
 static DEVICE_ATTR(help,		S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(queueMappDump,	S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(qsetConfigDump,	S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(poolRegs,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(poolDropCnt,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(poolStatus,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(poolSize,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(poolBufNum,		S_IWUSR, NULL, mv_eth_port_store);
@@ -121,9 +164,21 @@ static DEVICE_ATTR(shortPool,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(hwfLongPool,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(hwfShortPool,	S_IWUSR, NULL, mv_eth_port_store);
 
-static struct attribute *mv_eth_bm_attrs[] = {
+static DEVICE_ATTR(qsetCreate,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(qsetDelete,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(rxqQsetLong,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(rxqQsetShort,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(txqQsetLong,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(txqQsetShort,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(qsetMaxSet,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(qsetShow,		S_IWUSR, NULL, mv_eth_port_store);
+
+static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_help.attr,
+	&dev_attr_queueMappDump.attr,
+	&dev_attr_qsetConfigDump.attr,
 	&dev_attr_poolRegs.attr,
+	&dev_attr_poolDropCnt.attr,
 	&dev_attr_poolStatus.attr,
 	&dev_attr_poolSize.attr,
 	&dev_attr_poolBufNum.attr,
@@ -131,12 +186,20 @@ static struct attribute *mv_eth_bm_attrs[] = {
 	&dev_attr_shortPool.attr,
 	&dev_attr_hwfLongPool.attr,
 	&dev_attr_hwfShortPool.attr,
+	&dev_attr_qsetCreate.attr,
+	&dev_attr_qsetDelete.attr,
+	&dev_attr_rxqQsetLong.attr,
+	&dev_attr_rxqQsetShort.attr,
+	&dev_attr_txqQsetLong.attr,
+	&dev_attr_txqQsetShort.attr,
+	&dev_attr_qsetMaxSet.attr,
+	&dev_attr_qsetShow.attr,
 	NULL
 };
 
 static struct attribute_group mv_eth_bm_group = {
 	.name = "bm",
-	.attrs = mv_eth_bm_attrs,
+	.attrs = mv_eth_attrs,
 };
 
 int mv_pp2_bm_sysfs_init(struct kobject *pp2_kobj)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
index 098af1e..da6aaa4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
@@ -41,15 +41,18 @@ static ssize_t mv_eth_help(char *b)
 {
 	int o = 0;
 
-	o += sprintf(b+o, "cat                    rxDmaRegs  - show RX DMA registers\n");
-	o += sprintf(b+o, "echo [p]             > rxFifoRegs - show RX FIFO registers for port <p>\n");
-	o += sprintf(b+o, "echo [rxq]           > gRxqRegs   - show RXQ registers for global <rxq>\n");
-	o += sprintf(b+o, "echo [p] [rxq]       > pRxqRegs   - show RXQ registers for global <rxq>\n");
-	o += sprintf(b+o, "echo [p] [rxq] [0|1] > rxqShow    - show RXQ descriptors ring for <p/rxq>\n");
-	o += sprintf(b+o, "echo [p] [rxq] [v]   > rxqSize    - set number of descriptors <v> for <port/rxq>.\n");
-	o += sprintf(b+o, "echo [p] [hex] [0|1] > mhRxSpec   - set MH value [hex] for RX special packets\n");
-	o += sprintf(b+o, "echo [p] [m]         > prefetch   - set RX prefetch mode for port [p]\n");
-	o += sprintf(b+o, "                                  [m]: 0-disable, 1-descriptor, 2-packet header, 3-both\n");
+	o += sprintf(b+o, "cat                    rxDmaRegs   - show RX DMA registers\n");
+	o += sprintf(b+o, "echo [p]             > rxFifoRegs  - show RX FIFO registers for port <p>\n");
+	o += sprintf(b+o, "echo [rxq]           > gRxqRegs    - show RXQ registers for global <rxq>\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	o += sprintf(b+o, "echo [p] [rxq]       > rxqCounters - show RXQ counters for <p/rxq>.\n");
+#endif
+	o += sprintf(b+o, "echo [p] [rxq]       > pRxqRegs    - show RXQ registers for global <rxq>\n");
+	o += sprintf(b+o, "echo [p] [rxq] [0|1] > rxqShow     - show RXQ descriptors ring for <p/rxq>\n");
+	o += sprintf(b+o, "echo [p] [rxq] [v]   > rxqSize     - set number of descriptors <v> for <port/rxq>.\n");
+	o += sprintf(b+o, "echo [p] [hex] [0|1] > mhRxSpec    - set MH value [hex] for RX special packets\n");
+	o += sprintf(b+o, "echo [p] [m]         > prefetch    - set RX prefetch mode for port [p]\n");
+	o += sprintf(b+o, "                                   [m]: 0-disable, 1-descriptor, 2-packet header, 3-both\n");
 
 	return o;
 }
@@ -98,6 +101,8 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		mvPp2RxFifoRegs(p);
 	} else if (!strcmp(name, "rxqSize")) {
 		mv_eth_ctrl_rxq_size_set(p, v, a);
+	} else if (!strcmp(name, "rxqCounters")) {
+		mvPp2V1RxqDbgCntrs(p, v);
 	} else if (!strcmp(name, "prefetch")) {
 		err |= mv_eth_ctrl_flag(p, MV_ETH_F_RX_DESC_PREFETCH, v & 0x1);
 		err |= mv_eth_ctrl_flag(p, MV_ETH_F_RX_PKT_PREFETCH, v & 0x2);
@@ -148,6 +153,7 @@ static ssize_t mv_eth_rx_hex_store(struct device *dev,
 
 static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(rxDmaRegs,  	S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(rxqCounters, S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(rxqShow,     S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(gRxqRegs,    S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(pRxqRegs,    S_IWUSR, NULL, mv_eth_port_store);
@@ -160,6 +166,7 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_rxDmaRegs.attr,
 	&dev_attr_rxqShow.attr,
+	&dev_attr_rxqCounters.attr,
 	&dev_attr_gRxqRegs.attr,
 	&dev_attr_pRxqRegs.attr,
 	&dev_attr_rxFifoRegs.attr,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index ca272db..310d3a1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -83,6 +83,7 @@ static ssize_t mv_eth_show(struct device *dev,
 		return -EPERM;
 
 	if (!strcmp(name, "addrDec"))
+		/*mvPp2AddressDecodeRegsPrint();*/
 		mvPp2AddrDecodeRegs();
 	else
 		off = mv_eth_help(buf);
@@ -112,14 +113,22 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		mv_eth_port_status_print(p);
 		mvPp2PortStatus(p);
 	} else if (!strcmp(name, "cntrs")) {
-		mvEthMibCountersShow(p);
+		if (!MV_PON_PORT(p))
+			mvGmacMibCountersShow(p);
+		else
+			printk(KERN_ERR "sysfs command %s is not supported for xPON port %d\n",
+				name, p);
 	} else if (!strcmp(name, "isrRegs")) {
 		mvPp2IsrRegs(p);
 	} else if (!strcmp(name, "gmacRegs")) {
 		mvGmacLmsRegs();
 		mvGmacPortRegs(p);
 	} else if (!strcmp(name, "dropCntrs")) {
-		mvPp2DropCntrs(p);
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2V1DropCntrs(p);
+#else
+		mvPp2V0DropCntrs(p);
+#endif
 	} else if (!strcmp(name, "stats")) {
 		mv_eth_port_stats_print(p);
 	} else if (!strcmp(name, "pnc")) {
@@ -201,11 +210,43 @@ static ssize_t mv_eth_netdev_store(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
+static ssize_t mv_eth_reg_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    r, v;
+	unsigned long   flags;
 
-static DEVICE_ATTR(addrDec,	S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(help,	S_IRUSR, mv_eth_show, NULL);
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = r = v = 0;
+	sscanf(buf, "%x %x", &r, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "regRead")) {
+		v = mvPp2RdReg(r);
+		printk(KERN_INFO "regRead val: 0x%08x\n", v);
+	}  else if (!strcmp(name, "regWrite")) {
+		mvPp2WrReg(r, v);
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
 
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
 
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(addrDec,	S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(help,	S_IRUSR, mv_eth_show, NULL);
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 static DEVICE_ATTR(debug,	S_IWUSR, NULL, mv_eth_2_hex_store);
 #endif
@@ -220,10 +261,15 @@ static DEVICE_ATTR(port,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(cntrs,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(netdev,	S_IWUSR, NULL, mv_eth_netdev_store);
 
+static DEVICE_ATTR(regRead,       S_IWUSR, NULL, mv_eth_reg_store);
+static DEVICE_ATTR(regWrite,      S_IWUSR, NULL, mv_eth_reg_store);
 
 static struct attribute *mv_eth_attrs[] = {
-	&dev_attr_help.attr,
 	&dev_attr_addrDec.attr,
+	&dev_attr_help.attr,
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	&dev_attr_debug.attr,
+#endif
 	&dev_attr_port.attr,
 	&dev_attr_cntrs.attr,
 	&dev_attr_netdev.attr,
@@ -233,9 +279,8 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_stats.attr,
 	&dev_attr_pnc.attr,
 	&dev_attr_skb.attr,
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-	&dev_attr_debug.attr,
-#endif
+	&dev_attr_regRead.attr,
+	&dev_attr_regWrite.attr,
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index 19bf7bb..41f4a0d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -89,7 +89,7 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 
 	mv_phy_addr = mvBoardPhyAddrGet(priv->port);
 
-	mvEthLinkStatus(priv->port, &status);
+	mvGmacLinkStatus(priv->port, &status);
 
 	if (status.linkup != MV_TRUE) {
 		/* set to Unknown */
@@ -119,7 +119,7 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 	cmd->phy_address = mv_phy_addr;
 	cmd->transceiver = XCVR_INTERNAL;
 	/* check if speed and duplex are AN */
-	mvEthSpeedDuplexGet(priv->port, &speed, &duplex);
+	mvGmacSpeedDuplexGet(priv->port, &speed, &duplex);
 	if (speed == MV_ETH_SPEED_AN && duplex == MV_ETH_DUPLEX_AN) {
 		cmd->lp_advertising = cmd->advertising = 0;
 		cmd->autoneg = AUTONEG_ENABLE;
@@ -204,7 +204,7 @@ int mv_eth_tool_restore_settings(struct net_device *netdev)
 	}
 
 	if (priv->autoneg_cfg == AUTONEG_ENABLE) {
-		err = mvEthSpeedDuplexSet(priv->port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN);
+		err = mvGmacSpeedDuplexSet(priv->port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN);
 		if (!err)
 			err = mvEthPhyAdvertiseSet(mv_phy_addr, priv->advertise_cfg);
 		/* Restart AN on PHY enables it */
@@ -213,7 +213,7 @@ int mv_eth_tool_restore_settings(struct net_device *netdev)
 			if (err == MV_TIMEOUT) {
 				MV_ETH_PORT_STATUS ps;
 
-				mvEthLinkStatus(priv->port, &ps);
+				mvGmacLinkStatus(priv->port, &ps);
 
 				if (!ps.linkup)
 					err = 0;
@@ -222,7 +222,7 @@ int mv_eth_tool_restore_settings(struct net_device *netdev)
 	} else if (priv->autoneg_cfg == AUTONEG_DISABLE) {
 		err = mvEthPhyDisableAN(mv_phy_addr, mv_phy_speed, mv_phy_duplex);
 		if (!err)
-			err = mvEthSpeedDuplexSet(priv->port, mv_mac_speed, mv_mac_duplex);
+			err = mvGmacSpeedDuplexSet(priv->port, mv_mac_speed, mv_mac_duplex);
 	} else {
 		err = -EINVAL;
 	}
@@ -413,9 +413,10 @@ u32 mv_eth_tool_get_link(struct net_device *netdev)
 
 #ifdef CONFIG_MV_INCLUDE_PON
 	if (MV_PON_PORT(pp->port))
-		return mv_pon_link_status();
-#endif
-	return mvEthPortIsLinkUp(pp->port);
+		return mv_pon_link_status(NULL);
+#endif /* CONFIG_MV_PON */
+
+	return mvGmacPortIsLinkUp(pp->port);
 }
 
 
@@ -562,16 +563,16 @@ int mv_eth_tool_set_ringparam(struct net_device *netdev,
 				 struct ethtool_ringparam *ring)
 {
 	struct eth_port *priv = MV_ETH_PRIV(netdev);
-	int rxq, txp, txq, rxq_size, txq_size, hwf_size, netdev_running = 0;
+	int rxq, txp, txq, rxq_size, txq_size, swf_size, hwf_size, netdev_running = 0;
 
 	if (ring->rx_jumbo_pending || ring->rx_mini_pending)
 		return -EINVAL;
 
 	rxq_size = MV_ALIGN_UP(ring->rx_pending, 16);
+
 	/* Set minimum of 32, to save space for HWF as well */
 	txq_size = MV_ALIGN_UP(ring->tx_pending, 32);
 	/* Set HWF size to half of total TXQ size */
-	hwf_size = txq_size >> 1;
 
 	if (netif_running(netdev))
 		netdev_running = 1;
@@ -582,11 +583,19 @@ int mv_eth_tool_set_ringparam(struct net_device *netdev,
 	if (rxq_size != priv->rxq_ctrl[0].rxq_size)
 		for (rxq = 0; rxq < priv->rxq_num; rxq++)
 			mv_eth_ctrl_rxq_size_set(priv->port, rxq, rxq_size);
+#ifdef CONFIG_MV_ETH_PP2_1
+	hwf_size = txq_size - (nr_cpu_ids * priv->txq_ctrl[0].rsvd_chunk);
+	swf_size = hwf_size - (nr_cpu_ids * priv->txq_ctrl[0].rsvd_chunk);
+#else
+	hwf_size = txq_size/2;
+#endif
 
 	if (txq_size != priv->txq_ctrl[0].txq_size)
 		for (txp = 0; txp < priv->txp_num; txp++)
-			for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
-				mv_eth_ctrl_txq_size_set(priv->port, txp, txq, txq_size, hwf_size);
+			for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++) {
+				mv_eth_ctrl_txq_size_set(priv->port, txp, txq, txq_size);
+				mv_eth_ctrl_txq_limits_set(priv->port, txp, txq, hwf_size, swf_size);
+			}
 
 	if (netdev_running)
 		mv_eth_open(netdev);
@@ -619,13 +628,13 @@ void mv_eth_tool_get_pauseparam(struct net_device *netdev,
 		return;
 	}
 
-	mvEthFlowCtrlGet(port, &flowCtrl);
+	mvGmacFlowCtrlGet(port, &flowCtrl);
 	if ((flowCtrl == MV_ETH_FC_AN_NO) || (flowCtrl == MV_ETH_FC_AN_SYM) || (flowCtrl == MV_ETH_FC_AN_ASYM))
 		pause->autoneg = AUTONEG_ENABLE;
 	else
 		pause->autoneg = AUTONEG_DISABLE;
 
-	mvEthLinkStatus(port, &portStatus);
+	mvGmacLinkStatus(port, &portStatus);
 	if (portStatus.rxFc == MV_ETH_FC_DISABLE)
 		pause->rx_pause = 0;
 	else
@@ -668,15 +677,15 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 
 	if (pause->rx_pause && pause->tx_pause) { /* Enable FC */
 		if (pause->autoneg) { /* autoneg enable */
-			status = mvEthFlowCtrlSet(port, MV_ETH_FC_AN_SYM);
+			status = mvGmacFlowCtrlSet(port, MV_ETH_FC_AN_SYM);
 		} else { /* autoneg disable */
-			status = mvEthFlowCtrlSet(port, MV_ETH_FC_ENABLE);
+			status = mvGmacFlowCtrlSet(port, MV_ETH_FC_ENABLE);
 		}
 	} else if (!pause->rx_pause && !pause->tx_pause) { /* Disable FC */
 		if (pause->autoneg) { /* autoneg enable */
-			status = mvEthFlowCtrlSet(port, MV_ETH_FC_AN_NO);
+			status = mvGmacFlowCtrlSet(port, MV_ETH_FC_AN_NO);
 		} else { /* autoneg disable */
-			status = mvEthFlowCtrlSet(port, MV_ETH_FC_DISABLE);
+			status = mvGmacFlowCtrlSet(port, MV_ETH_FC_DISABLE);
 		}
 	}
 	/* Only symmetric change for RX and TX flow control is allowed */
@@ -728,20 +737,6 @@ int mv_eth_tool_get_stats_count(struct net_device *netdev)
 	return 0;
 }
 
-static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev,
-							struct ethtool_rxfh_indir *indir)
-{
-	/*HW support in PPv2 step 2 */
-	return -EOPNOTSUPP;
-}
-
-static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev,
-							   const struct ethtool_rxfh_indir *indir)
-{
-	/*HW support in PPv2 step 2 */
-	return -EOPNOTSUPP;
-}
-
 static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 									 u32 *rules)
 {
@@ -791,7 +786,7 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_stats_count			= mv_eth_tool_get_stats_count,/*TODO: complete implementation */
 #endif
 	.get_ethtool_stats			= mv_eth_tool_get_ethtool_stats,/*TODO: complete implementation */
-	.get_rxfh_indir				= mv_eth_tool_get_rxfh_indir,
-	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir,
+	/*.get_rxfh_indir			= mv_eth_tool_get_rxfh_indir,
+	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir, */
 	.get_rxnfc                  		= mv_eth_tool_get_rxnfc,/*TODO new implementation*/
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
index e96c513..595d6d6 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
@@ -41,6 +41,10 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
+	off += sprintf(buf+off, "cat                              txRegs          - show global TX registers\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += sprintf(buf+off, "echo [p] [txp] [txq]             > pTxqCounters  - show TXQ Counters for port <p/txp/txq> where <txq> range [0..7]\n");
+#endif
 	off += sprintf(buf+off, "echo [p] [txp] [txq]            > pTxqRegs      - show TXQ registers for port <p/txp/txq> where <txq> range [0..7]\n");
 	off += sprintf(buf+off, "echo [txq]                      > gTxqRegs      - show TXQ registers for global <txq> range [0..255]\n");
 	off += sprintf(buf+off, "echo [cpu]                      > aggrTxqRegs   - show Aggregation TXQ registers for <cpu> range [0..max]\n");
@@ -49,20 +53,30 @@ static ssize_t mv_eth_help(char *buf)
 	off += sprintf(buf+off, "echo [p] [hex]                  > txFlags       - bits: 0-no_pad, 1-mh, 2-hw_cmd\n");
 	off += sprintf(buf+off, "echo [p] [hex]                  > txMH          - set 2 bytes of Marvell Header for transmit\n");
 	off += sprintf(buf+off, "echo [p] [txp] [txq] [cpu]      > txqDef        - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v] [hwf]  > txqSize       - set descriptor Q size <v>, and HWF share <hwf> for <p/txp/txq>. \n");
-
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v] [hwf]  > txqSize       - set descriptor Q size <v>, and HWF share <hwf> for <p/txp/txq>.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf] [swf] > txqLimit      - set HWF <hwf> and SWF <swf> share for <p/txp/txq>.\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]         > txqChunk      - set <txp/txq> SWF request chunk size [v] for port <p>\n");
+
+#else
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf]       > txqLimit       - set HWF share <hwf> for <p/txp/txq>.\n");
+#endif
 	return off;
 }
 
 static ssize_t mv_eth_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
+	const char      *name = attr->attr.name;
 	int             off = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	off = mv_eth_help(buf);
+	if (!strcmp(name, "txRegs"))
+		mvPp2TxRegs();
+	else
+		off = mv_eth_help(buf);
 
 	return off;
 }
@@ -129,10 +143,17 @@ static ssize_t mv_eth_txq_store(struct device *dev,
 		mvPp2PhysTxqRegs(p);
 	} else if (!strcmp(name, "pTxqRegs")) {
 		mvPp2PortTxqRegs(p, v, a);
+	} else if (!strcmp(name, "pTxqCounters")) {
+		mvPp2V1TxqDbgCntrs(p, v, a);
 	} else if (!strcmp(name, "aggrTxqRegs")) {
 		mvPp2AggrTxqRegs(p);
 	} else if (!strcmp(name, "txqSize")) {
-		mv_eth_ctrl_txq_size_set(p, v, a, b, c);
+		mv_eth_ctrl_txq_size_set(p, v, a, b);
+	} else if (!strcmp(name, "txqLimit")) {
+		/* last param is ignored in ppv2.0 */
+		mv_eth_ctrl_txq_limits_set(p, v, a, b, c);
+	} else if (!strcmp(name, "txqChunk")) {
+		mv_eth_ctrl_txq_chunk_set(p, v, a, b);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -147,25 +168,33 @@ static ssize_t mv_eth_txq_store(struct device *dev,
 }
 
 static DEVICE_ATTR(help,         S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(txRegs,       S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(aggrTxqRegs,  S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(pTxqCounters, S_IWUSR, NULL, mv_eth_txq_store);
 static DEVICE_ATTR(txqShow,      S_IWUSR, NULL, mv_eth_txq_store);
 static DEVICE_ATTR(gTxqRegs,     S_IWUSR, NULL, mv_eth_txq_store);
 static DEVICE_ATTR(pTxqRegs,     S_IWUSR, NULL, mv_eth_txq_store);
 static DEVICE_ATTR(aggrTxqShow,  S_IWUSR, NULL, mv_eth_txq_store);
-static DEVICE_ATTR(txqDef,     	 S_IWUSR, NULL, mv_eth_txq_store);
-static DEVICE_ATTR(txqSize,    	 S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqDef,       S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqSize,      S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqLimit,     S_IWUSR, NULL, mv_eth_txq_store);
+static DEVICE_ATTR(txqChunk,     S_IWUSR, NULL, mv_eth_txq_store);
 static DEVICE_ATTR(txFlags,      S_IWUSR, NULL, mv_eth_tx_hex_store);
 static DEVICE_ATTR(txMH,         S_IWUSR, NULL, mv_eth_tx_hex_store);
 
 static struct attribute *mv_eth_tx_attrs[] = {
 	&dev_attr_txqDef.attr,
+	&dev_attr_pTxqCounters.attr,
 	&dev_attr_aggrTxqRegs.attr,
 	&dev_attr_help.attr,
+	&dev_attr_txRegs.attr,
 	&dev_attr_txqShow.attr,
 	&dev_attr_gTxqRegs.attr,
 	&dev_attr_pTxqRegs.attr,
 	&dev_attr_aggrTxqShow.attr,
 	&dev_attr_txqSize.attr,
+	&dev_attr_txqLimit.attr,
+	&dev_attr_txqChunk.attr,
 	&dev_attr_txFlags.attr,
 	&dev_attr_txMH.attr,
 	NULL
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index 8729e69..5500eb8 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -105,19 +105,22 @@ int mv_eth_start(struct net_device *dev)
 		mvPp2GbeCpuInterruptsEnable(priv->port, priv->cpuMask);
 
 		/* Unmask Port link interrupt */
-		mvEthPortIsrUnmask(priv->port);
+		mvGmacPortIsrUnmask(priv->port);
 
 		printk(KERN_NOTICE "%s: started\n", dev->name);
 	}
 
-	/* allow new packets to RXQs */
-	mvPrsMacDropAllSet(priv->port, 0);
+	/* Enable GMAC */
+	if (!MV_PON_PORT(priv->port))
+		mvGmacPortEnable(priv->port);
+
+	mv_eth_link_event(priv, 1);
 
 	return 0;
 
 error:
 	printk(KERN_ERR "%s: start failed\n", dev->name);
-	return -1;
+	return -EINVAL;
 }
 
 /***********************************************************
@@ -132,7 +135,7 @@ int mv_eth_stop(struct net_device *dev)
 	int group, cpu;
 
 	/* stop new packets from arriving to RXQs */
-	mvPrsMacDropAllSet(priv->port, 1);
+	mvPp2PortIngressEnable(priv->port, MV_FALSE);
 
 	mdelay(10);
 
@@ -161,6 +164,11 @@ int mv_eth_stop(struct net_device *dev)
 	if (dev->irq != 0)
 		free_irq(dev->irq, priv);
 
+	mvPp2PortEgressEnable(priv->port, MV_FALSE);
+
+	if (!MV_PON_PORT(priv->port))
+		mvGmacPortDisable(priv->port);
+
 	printk(KERN_NOTICE "%s: stopped\n", dev->name);
 
 	return 0;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 23a486b..11fe2c7 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -61,6 +61,7 @@ disclaimer.
 
 #define MV_ETH_TX_PENDING_TIMEOUT_MSEC     1000
 
+static struct mv_mux_eth_ops mux_eth_ops;
 
 static struct  platform_device *pp2_sysfs;
 
@@ -69,7 +70,10 @@ platform_device used in mv_eth_all_ports_probe only for debug
 */
 struct platform_device *plats[MV_ETH_MAX_PORTS];
 
-static struct mv_mux_eth_ops mux_eth_ops;
+/* Temporary implementation for SWF to HWF transition */
+static void *sync_head;
+static u32   sync_rx_desc;
+
 
 static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb);
 
@@ -93,6 +97,7 @@ int mv_eth_ctrl_recycle(int en)
 struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 struct eth_port **mv_eth_ports;
 struct aggr_tx_queue *aggr_txqs;
+EXPORT_SYMBOL(aggr_txqs);
 
 int mv_ctrl_txdone = CONFIG_MV_ETH_TXDONE_COAL_PKTS;
 EXPORT_SYMBOL(mv_ctrl_txdone);
@@ -631,7 +636,7 @@ int mv_eth_ctrl_long_pool_set(int port, int pool)
 	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct bm_pool *old_pool;
-	int pkt_size = RX_PKT_SIZE(pp->dev->mtu);
+	int rxq, pkt_size = RX_PKT_SIZE(pp->dev->mtu);
 
 	if (pp == NULL) {
 		pr_err("%s: port %d doenst not exist\n" , __func__, port);
@@ -660,6 +665,9 @@ int mv_eth_ctrl_long_pool_set(int port, int pool)
 	pp->pool_long->port_map |= (1 << port);
 	MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
 
+	for (rxq = 0; rxq < pp->rxq_num; rxq++)
+		mvPp2RxqBmLongPoolSet(port, rxq, pp->pool_long->pool);
+
 	return 0;
 }
 
@@ -668,6 +676,7 @@ int mv_eth_ctrl_short_pool_set(int port, int pool)
 	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct bm_pool *old_pool;
+	int rxq;
 
 	if (pp == NULL) {
 		pr_err("%s: port %d doenst not exist\n" , __func__, port);
@@ -696,6 +705,9 @@ int mv_eth_ctrl_short_pool_set(int port, int pool)
 	pp->pool_short->port_map |= (1 << port);
 	MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
 
+	for (rxq = 0; rxq < pp->rxq_num; rxq++)
+		mvPp2RxqBmShortPoolSet(port, rxq, pp->pool_short->pool);
+
 	return 0;
 }
 
@@ -704,7 +716,7 @@ int mv_eth_ctrl_hwf_long_pool_set(int port, int pool)
 	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct bm_pool *old_pool;
-	int pkt_size = RX_PKT_SIZE(pp->dev->mtu);
+	int txp, txq, pkt_size = RX_PKT_SIZE(pp->dev->mtu);
 
 	if (pp == NULL) {
 		pr_err("%s: port %d doenst not exist\n" , __func__, port);
@@ -733,6 +745,14 @@ int mv_eth_ctrl_hwf_long_pool_set(int port, int pool)
 	pp->hwf_pool_long->port_map |= (1 << port);
 	MV_ETH_UNLOCK(&pp->hwf_pool_long->lock, flags);
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (txp = 0; txp < pp->txp_num; txp++)
+		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+			mvPp2TxqBmLongPoolSet(pp->port, txp, txq, pp->hwf_pool_long->pool);
+#else
+	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
+#endif
+
 	return 0;
 }
 
@@ -741,6 +761,7 @@ int mv_eth_ctrl_hwf_short_pool_set(int port, int pool)
 	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct bm_pool *old_pool;
+	int txp, txq;
 
 	if (pp == NULL) {
 		pr_err("%s: port %d doenst not exist\n" , __func__, port);
@@ -768,6 +789,14 @@ int mv_eth_ctrl_hwf_short_pool_set(int port, int pool)
 	pp->hwf_pool_short->port_map |= (1 << port);
 	MV_ETH_UNLOCK(&pp->hwf_pool_short->lock, flags);
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (txp = 0; txp < pp->txp_num; txp++)
+		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+			mvPp2TxqBmShortPoolSet(pp->port, txp, txq, pp->hwf_pool_short->pool);
+#else
+	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
+#endif
+
 	return 0;
 }
 
@@ -813,10 +842,16 @@ int mv_eth_ctrl_rxq_size_set(int port, int rxq, int value)
 		printk(KERN_ERR "Port %d must be stopped before\n", port);
 		return -EINVAL;
 	}
+
+	if (value % 16 != 0) {
+		printk(KERN_ERR "invalid rxq size\n");
+		return -EINVAL;
+	}
+
 	rxq_ctrl = &pp->rxq_ctrl[rxq];
 	if ((rxq_ctrl->q) && (rxq_ctrl->rxq_size != value)) {
 		/* Reset is required when RXQ ring size is changed */
-		mv_eth_rx_reset(pp->port);
+		mvPp2RxqReset(pp->port, rxq);
 		mvPp2RxqDelete(pp->port, rxq);
 		rxq_ctrl->q = NULL;
 	}
@@ -826,7 +861,80 @@ int mv_eth_ctrl_rxq_size_set(int port, int rxq, int value)
 	return 0;
 }
 
-int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_size)
+
+/* set <txp/txq> SWF request chunk size */
+int mv_eth_ctrl_txq_chunk_set(int port, int txp, int txq, int chunk_size)
+{
+	struct tx_queue *txq_ctrl;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+
+	if (pp == NULL) {
+		printk(KERN_INFO "port does not exist (%d) in %s\n" , port, __func__);
+		return -EINVAL;
+	}
+
+	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
+
+	if (!txq_ctrl) {
+		printk(KERN_INFO "queue does not exist (%d) in %s\n" , port, __func__);
+		return -EINVAL;
+	}
+
+	txq_ctrl->rsvd_chunk = chunk_size;
+
+	return MV_OK;
+}
+
+/* swf_size is in use only in ppv2.1, ignored in ppv2.0 */
+int mv_eth_ctrl_txq_limits_set(int port, int txp, int txq, int hwf_size, int swf_size)
+{
+	int txq_size;
+	struct tx_queue *txq_ctrl;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	if (pp == NULL) {
+		printk(KERN_INFO "port does not exist (%d) in %s\n" , port, __func__);
+		return -EINVAL;
+	}
+
+	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
+
+	if (!txq_ctrl) {
+		printk(KERN_INFO "queue is null %s\n", __func__);
+		return -EINVAL;
+	}
+
+	txq_size = txq_ctrl->txq_size;
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	if (hwf_size < swf_size) {
+		printk(KERN_ERR "Invalid size params, swf size must be less than hwf size\n");
+		return -EINVAL;
+	}
+#endif
+
+	if (txq_size < hwf_size) {
+		printk(KERN_ERR "invalid hwf size, must be less or equal to txq size (%d)\n", txq_size);
+		return -EINVAL;
+	}
+
+	if (hwf_size % 16 != 0) {
+		printk(KERN_ERR "invalid hwf size, must be aligned to 16\n");
+		return -EINVAL;
+	}
+
+	txq_ctrl->hwf_size = hwf_size;
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	txq_ctrl->swf_size = swf_size;
+#endif
+	mvPp2TxqHwfSizeSet(port, txp, txq, hwf_size);
+
+	return 0;
+}
+
+int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size)
 {
 	int cpu, cpu_size;
 	struct tx_queue *txq_ctrl;
@@ -834,38 +942,61 @@ int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_s
 	struct eth_port *pp = mv_eth_port_by_id(port);
 
 	if (pp == NULL) {
-		printk(KERN_INFO "port doens not exist (%d) in %s\n" , port, __func__);
+		printk(KERN_INFO "port does not exist (%d) in %s\n" , port, __func__);
 		return -EINVAL;
 	}
 	if (pp->flags & MV_ETH_F_STARTED) {
 		printk(KERN_ERR "Port %d must be stopped before\n", port);
 		return -EINVAL;
 	}
-	if ((txq_size % 16 != 0) || (hwf_size % 16 != 0) || (txq_size < hwf_size)) {
-		printk(KERN_ERR "invalid txq size\n");
+
+	if (txq_size % 16 != 0) {
+		printk(KERN_ERR "invalid txq size, must be aligned to 16\n");
 		return -EINVAL;
 	}
 
 	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
-	if ((txq_ctrl->q) && ((txq_ctrl->txq_size != txq_size) || (txq_ctrl->hwf_size != hwf_size))) {
+
+	if (!txq_ctrl) {
+		printk(KERN_INFO "queue is null %s\n", __func__);
+		return -EINVAL;
+	}
+
+	if ((txq_ctrl->q) && (txq_size < txq_ctrl->hwf_size)) {
+		printk(KERN_INFO "Invalid txq size, must be greater than hwf size (%d)\n", txq_ctrl->hwf_size);
+		return -EINVAL;
+	}
+
+	if ((txq_ctrl->q) && (txq_ctrl->txq_size != txq_size)) {
+		/* Clean and Reset of txq is required when TXQ ring size is changed */
+		mv_eth_txq_clean(port, txp, txq);
+
+		/* TBD: If needed to send dummy packets to reset number of descriptors reserved by all CPUs */
+
+		mvPp2TxqReset(port, txp, txq);
 		mv_eth_txq_delete(pp, txq_ctrl);
-		/* Reset of port/txp is required when TXQ ring size is changed */
-		/* Reset done before as part of stop_internals function */
 	}
 
 	txq_ctrl->txq_size = txq_size;
-	txq_ctrl->hwf_size = hwf_size;
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	for_each_possible_cpu(cpu) {
+		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
+		txq_cpu_ptr->txq_size = txq_size;
+	}
+#else
 	/* right now, all cpus have same size */
-	cpu_size = (txq_size - hwf_size) / nr_cpu_ids;
+	cpu_size = (txq_ctrl->txq_size - txq_ctrl->hwf_size) / CONFIG_NR_CPUS;
+
 	for_each_possible_cpu(cpu) {
 		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
 		txq_cpu_ptr->txq_size = cpu_size;
 	}
+#endif
 	/* New TXQ will be created during mv_eth_start_internals */
 	return 0;
 }
 
+
 /* Set TXQ for CPU originated packets */
 int mv_eth_ctrl_txq_cpu_def(int port, int txp, int txq, int cpu)
 {
@@ -1062,18 +1193,19 @@ void mv_eth_link_status_print(int port)
 {
 	MV_ETH_PORT_STATUS link;
 
-	mvEthLinkStatus(port, &link);
-#ifdef CONFIG_MV_INCLUDE_PON
+#ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(port))
-		link.linkup = mv_pon_link_status();
-#endif
+		mv_pon_link_status(&link);
+	else
+#endif /* CONFIG_MV_PON */
+		mvGmacLinkStatus(port, &link);
 
 	if (link.linkup) {
 		printk(KERN_CONT "link up");
 		printk(KERN_CONT ", %s duplex", (link.duplex == MV_ETH_DUPLEX_FULL) ? "full" : "half");
 		printk(KERN_CONT ", speed ");
 
-		printk(KERN_CONT "%s\n", mvEthSpeedStrGet(link.speed));
+		printk(KERN_CONT "%s\n", mvGmacSpeedStrGet(link.speed));
 	} else
 		printk(KERN_CONT "link down\n");
 
@@ -1347,6 +1479,25 @@ static unsigned char *mv_eth_hwf_buff_alloc(struct bm_pool *pool, MV_ULONG *phys
 	return buff;
 }
 
+static inline void mv_eth_txq_buf_free(struct eth_port *pp, u32 shadow)
+{
+	if (!shadow)
+		return;
+
+	if (shadow & MV_ETH_SHADOW_SKB) {
+		shadow &= ~MV_ETH_SHADOW_SKB;
+		dev_kfree_skb_any((struct sk_buff *)shadow);
+		STAT_DBG(pp->stats.tx_skb_free++);
+	} else if (shadow & MV_ETH_SHADOW_EXT) {
+		shadow &= ~MV_ETH_SHADOW_EXT;
+		mv_eth_extra_pool_put(pp, (void *)shadow);
+	} else {
+		/* TBD - return buffer back to BM */
+		printk(KERN_ERR "%s: unexpected buffer - not skb and not ext\n", __func__);
+	}
+}
+
+
 static inline void mv_eth_txq_bufs_free(struct eth_port *pp, struct txq_cpu_ctrl *txq_cpu, int num)
 {
 	u32 shadow;
@@ -1355,21 +1506,7 @@ static inline void mv_eth_txq_bufs_free(struct eth_port *pp, struct txq_cpu_ctrl
 	/* Free buffers that was not freed automatically by BM */
 	for (i = 0; i < num; i++) {
 		shadow = mv_eth_shadow_get_pop(txq_cpu);
-
-		if (!shadow)
-			continue;
-
-		if (shadow & MV_ETH_SHADOW_SKB) {
-			shadow &= ~MV_ETH_SHADOW_SKB;
-			dev_kfree_skb_any((struct sk_buff *)shadow);
-			STAT_DBG(pp->stats.tx_skb_free++);
-		} else if (shadow & MV_ETH_SHADOW_EXT) {
-			shadow &= ~MV_ETH_SHADOW_EXT;
-			mv_eth_extra_pool_put(pp, (void *)shadow);
-		} else {
-			/* TBD - if NFP is supported then pass packet back to BM */
-			printk(KERN_ERR "%s: unexpected buffer - not skb and not ext\n", __func__);
-		}
+		mv_eth_txq_buf_free(pp, shadow);
 	}
 }
 
@@ -1507,7 +1644,7 @@ void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 				buff_hdr->byteCount, mc_id,
 				PP2_BUFF_HDR_INFO_IS_LAST(buff_hdr->info));
 		}
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+#endif
 
 		count++;
 		buff_phys_addr_next = buff_hdr->nextBuffPhysAddr;
@@ -1533,6 +1670,8 @@ void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 	mvOsCacheLineInv(NULL, rx_desc);
 	STAT_INFO(pp->stats.rx_buf_hdr++);
 }
+EXPORT_SYMBOL(mv_eth_buff_hdr_rx);
+
 
 void mv_eth_buff_hdr_rx_dump(struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 {
@@ -1621,7 +1760,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct na
 		ppool = &mv_eth_pool[pool];
 
 		/* check if buffer header is used */
-		if (rx_status & PP2_RX_BUF_HDR_MASK) {
+		if ((rx_status & (PP2_RX_HWF_SYNC_MASK | PP2_RX_BUF_HDR_MASK)) == PP2_RX_BUF_HDR_MASK) {
 			mv_eth_buff_hdr_rx(pp, rx_desc);
 			continue;
 		}
@@ -1635,6 +1774,15 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct na
 		}
 		skb = (struct sk_buff *)rx_desc->bufCookie;
 
+		if (rx_status & PP2_RX_HWF_SYNC_MASK) {
+			/* Remember sync bit for TX */
+			pr_info("\n%s: port=%d, rxq=%d, cpu=%d, skb=%p - Sync packet received\n",
+			__func__, pp->port, rxq, smp_processor_id(), skb);
+			mv_eth_rx_desc_print(rx_desc);
+			sync_head = skb->head;
+			sync_rx_desc = rx_status;
+		}
+
 		/*dma_unmap_single(NULL, rx_desc->bufPhysAddr, RX_BUF_SIZE(ppool->pkt_size), DMA_FROM_DEVICE);*/
 
 		/* Prefetch two cache lines from beginning of packet */
@@ -1723,7 +1871,7 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 {
 	struct eth_port *pp = MV_ETH_PRIV(dev);
 	int frags = 0, cpu = smp_processor_id();
-	u32 tx_cmd;
+	u32 tx_cmd, bufPhysAddr;
 	struct mv_eth_tx_spec tx_spec, *tx_spec_ptr = NULL;
 	struct tx_queue *txq_ctrl = NULL;
 	struct txq_cpu_ctrl *txq_cpu_ptr = NULL;
@@ -1804,8 +1952,15 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	/* is enough descriptors? */
-	if ((!mv_eth_phys_desc_num_check(txq_cpu_ptr, frags)) ||
-		(!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags))) {
+#ifdef CONFIG_MV_ETH_PP2_1
+	if (mv_eth_reserved_desc_num_proc(pp, tx_spec_ptr->txp, tx_spec_ptr->txq, frags) ||
+		mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags)) {
+#else
+	if (mv_eth_phys_desc_num_check(txq_cpu_ptr, frags) ||
+		mv_eth_aggr_desc_num_check(aggr_txq_ctrl, frags)) {
+
+#endif
+
 		frags = 0;
 		goto out;
 	}
@@ -1824,10 +1979,14 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 		tx_desc->hwCmd[2] = tx_spec_ptr->hw_cmd[2];
 	}
 
+	if (skb->head == sync_head)
+		tx_cmd |= PP2_TX_HWF_SYNC_MASK;
+
 	/* FIXME: beware of nonlinear --BK */
 	tx_desc->dataSize = skb_headlen(skb);
-
-	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, skb->data, tx_desc->dataSize);
+	bufPhysAddr = mvOsCacheFlush(NULL, skb->data, tx_desc->dataSize);
+	tx_desc->pktOffset = bufPhysAddr & MV_ETH_TX_DESC_ALIGN;
+	tx_desc->bufPhysAddr = bufPhysAddr & (~MV_ETH_TX_DESC_ALIGN);
 
 	if (frags == 1) {
 		/*
@@ -1856,9 +2015,23 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 		STAT_DBG(pp->stats.tx_sg++);
 	}
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* PPv2.1 - MAS 3.16, decrease number of reserved descriptors */
+	txq_cpu_ptr->reserved_num -= frags;
+#endif
+
 	txq_cpu_ptr->txq_count += frags;
 	aggr_txq_ctrl->txq_count += frags;
 
+	if (tx_cmd & PP2_TX_HWF_SYNC_MASK) {
+		pr_info("%s: port=%d, txp=%d, txq=%d, cpu=%d, skb=%p, rx_desc=0x%08x - Sync packet transmitted\n",
+			__func__, pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq, smp_processor_id(),
+			skb, sync_rx_desc);
+		mv_eth_tx_desc_print(tx_desc);
+		mvDebugMemDump(skb->data, 64, 1);
+		sync_head = NULL;
+		sync_rx_desc = 0;
+	}
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->dbg_flags & MV_ETH_F_DBG_TX) {
 		printk(KERN_ERR "\n");
@@ -1866,6 +2039,7 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 			dev->name, dev->stats.tx_packets, smp_processor_id(), in_interrupt(),
 			pp->port, tx_spec_ptr->txp, tx_spec_ptr->txq);
 		printk(KERN_ERR "\t skb=%p, head=%p, data=%p, size=%d\n", skb, skb->head, skb->data, skb->len);
+		pr_info("\t sync_head=%p, sync_rx_desc=0x%08x\n", sync_head, sync_rx_desc);
 		mv_eth_tx_desc_print(tx_desc);
 		/*mv_eth_skb_print(skb);*/
 		mvDebugMemDump(skb->data, 64, 1);
@@ -1944,6 +2118,7 @@ static inline int mv_eth_tso_build_hdr_desc(struct pp2_tx_desc *tx_desc, struct
 	struct iphdr *iph;
 	struct tcphdr *tcph;
 	MV_U8 *data, *mac;
+	MV_U32 bufPhysAddr;
 	int mac_hdr_len = skb_network_offset(skb);
 
 	data = mv_eth_extra_pool_get(priv);
@@ -1986,7 +2161,9 @@ static inline int mv_eth_tso_build_hdr_desc(struct pp2_tx_desc *tx_desc, struct
 	tx_desc->command = mvPp2TxqDescCsum(mac_hdr_len, skb->protocol, ((u8 *)tcph - (u8 *)iph) >> 2, IPPROTO_TCP);
 	tx_desc->command |= PP2_TX_F_DESC_MASK;
 
-	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, data, tx_desc->dataSize);
+	bufPhysAddr = mvOsCacheFlush(NULL, skb->data, tx_desc->dataSize);
+	tx_desc->pktOffset = bufPhysAddr & MV_ETH_TX_DESC_ALIGN;
+	tx_desc->bufPhysAddr = bufPhysAddr & (~MV_ETH_TX_DESC_ALIGN);
 
 	mv_eth_shadow_push(txq_ctrl, ((MV_ULONG)data | MV_ETH_SHADOW_EXT));
 
@@ -1999,12 +2176,17 @@ static inline int mv_eth_tso_build_data_desc(struct pp2_tx_desc *tx_desc, struct
 					     struct txq_cpu_ctrl *txq_ctrl, char *frag_ptr,
 					     int frag_size, int data_left, int total_left)
 {
+	MV_U32 bufPhysAddr;
 	int size, val = 0;
 
 	size = MV_MIN(frag_size, data_left);
 
 	tx_desc->dataSize = size;
-	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, frag_ptr, size);
+	bufPhysAddr = mvOsCacheFlush(NULL, frag_ptr, size);
+	tx_desc->pktOffset = bufPhysAddr & MV_ETH_TX_DESC_ALIGN;
+	tx_desc->bufPhysAddr = bufPhysAddr & (~MV_ETH_TX_DESC_ALIGN);
+
+
 	tx_desc->command = 0;
 
 	if (size == data_left) {
@@ -2088,14 +2270,19 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 		 * We also need one descriptor for packet header						  */
 		seg_desc_num = skb_shinfo(skb)->nr_frags - frag + 2;
 
-		if (!mv_eth_aggr_desc_num_check(aggr_txq_ctrl, seg_desc_num)) {
+		if (mv_eth_aggr_desc_num_check(aggr_txq_ctrl, seg_desc_num)) {
 			STAT_DBG(priv->stats.tx_tso_no_resource++);
 			return 0;
 		}
 
-		if (!mv_eth_phys_desc_num_check(txq_cpu_ptr, seg_desc_num)) {
-			/* Try TX done and check resource again */
+		/* Check if there are enough descriptors in physical TXQ */
+#ifdef CONFIG_MV_ETH_PP2_1
+		if (mv_eth_reserved_desc_num_proc(priv, tx_spec->txp, tx_spec->txq, seg_desc_num)) {
+#else
+		if (mv_eth_phys_desc_num_check(txq_cpu_ptr, seg_desc_num)) {
+#endif
 #ifndef CONFIG_MV_ETH_TXDONE_ISR
+			/* Try TX done and check resource again */
 #ifdef CONFIG_MV_ETH_STAT_DIST
 			u32 tx_done = mv_eth_txq_done(priv, txq_ctrl);
 
@@ -2104,7 +2291,11 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 #else
 			mv_eth_txq_done(priv, txq_ctrl);
 #endif /* CONFIG_MV_ETH_STAT_DIST */
-			if (!mv_eth_phys_desc_num_check(txq_cpu_ptr, seg_desc_num)) {
+#ifdef CONFIG_MV_ETH_PP2_1
+		if (mv_eth_reserved_desc_num_proc(priv, tx_spec->txp, tx_spec->txq, seg_desc_num)) {
+#else
+		if (mv_eth_phys_desc_num_check(txq_cpu_ptr, seg_desc_num)) {
+#endif
 				STAT_DBG(priv->stats.tx_tso_no_resource++);
 				return 0;
 			}
@@ -2189,6 +2380,7 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 
 	return total_desc_num;
 }
+
 #endif /* CONFIG_MV_ETH_TSO */
 
 /* Push packets received by the RXQ to BM pool */
@@ -2224,7 +2416,7 @@ static void mv_eth_rxq_drop_pkts(struct eth_port *pp, int rxq)
 	}
 }
 
-static void mv_eth_txq_done_force(struct eth_port *pp, struct tx_queue *txq_ctrl)
+static int mv_eth_txq_done_force(struct eth_port *pp, struct tx_queue *txq_ctrl)
 {
 	int cpu, tx_done;
 	struct txq_cpu_ctrl *txq_cpu_ptr;
@@ -2240,6 +2432,7 @@ static void mv_eth_txq_done_force(struct eth_port *pp, struct tx_queue *txq_ctrl
 		txq_cpu_ptr->shadow_txq_put_i = 0;
 		txq_cpu_ptr->shadow_txq_get_i = 0;
 	}
+	return tx_done;
 }
 
 inline u32 mv_eth_tx_done_pon(struct eth_port *pp, int *tx_todo)
@@ -2321,6 +2514,7 @@ static void mv_eth_tx_frag_process(struct eth_port *pp, struct sk_buff *skb, str
 {
 	int i, cpu = smp_processor_id();
 	struct pp2_tx_desc *tx_desc;
+	MV_U32 bufPhysAddr;
 
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
@@ -2331,9 +2525,13 @@ static void mv_eth_tx_frag_process(struct eth_port *pp, struct sk_buff *skb, str
 		/* NETA_TX_BM_ENABLE_MASK = 0 */
 		/* NETA_TX_PKT_OFFSET_MASK = 0 */
 		tx_desc->dataSize = frag->size;
-		tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, page_address(frag->page.p) + frag->page_offset,
+
+		bufPhysAddr = mvOsCacheFlush(NULL, page_address(frag->page.p) + frag->page_offset,
 						      tx_desc->dataSize);
 
+		tx_desc->pktOffset = bufPhysAddr & MV_ETH_TX_DESC_ALIGN;
+		tx_desc->bufPhysAddr = bufPhysAddr & (~MV_ETH_TX_DESC_ALIGN);
+
 		if (i == (skb_shinfo(skb)->nr_frags - 1)) {
 			/* Last descriptor */
 			if (tx_spec->flags & MV_ETH_TX_F_NO_PAD)
@@ -2398,6 +2596,9 @@ static int mv_eth_pool_free(int pool, int num)
 
 	ppool->buf_num -= num;
 
+	/* Update BM driver with number of buffers removed from pool */
+	mvBmPoolBufNumUpdate(pool, num, 0);
+
 	return i;
 }
 
@@ -2463,7 +2664,6 @@ static int mv_eth_pool_add(int pool, int buf_num)
 
 	bm = mv_eth_bm_cookie_pool_set(bm, pool);
 	for (i = 0; i < buf_num; i++) {
-
 		if (!MV_ETH_BM_POOL_IS_HWF(bm_pool->type)) {
 			/* Allocate skb for pool used for SWF */
 			skb = mv_eth_skb_alloc(bm_pool, &phys_addr);
@@ -2477,13 +2677,17 @@ static int mv_eth_pool_add(int pool, int buf_num)
 			if (!hwf_buff)
 				break;
 
-			memset(hwf_buff, 0, sizeof(buf_size));
+			memset(hwf_buff, 0, buf_size);
 			mv_eth_pool_refill(bm_pool, bm, phys_addr, (MV_ULONG) hwf_buff);
 		}
 	}
+
 	bm_pool->buf_num += i;
 	bm_pool->in_use_thresh = bm_pool->buf_num / 4;
 
+	/* Update BM driver with number of buffers added to pool */
+	mvBmPoolBufNumUpdate(pool, i, 1);
+
 	pr_info("%s %s pool #%d: pkt_size=%4d, buf_size=%4d, total_size=%4d - %d of %d buffers added\n",
 		MV_ETH_BM_POOL_IS_HWF(bm_pool->type) ? "HWF" : "SWF",
 		MV_ETH_BM_POOL_IS_SHORT(bm_pool->type) ? "short" : " long",
@@ -2512,7 +2716,7 @@ void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *pPhysAddr)
 		mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
 		return NULL;
 	}
-	status = mvBmPoolInit(pool, physAddr, capacity);
+	status = mvBmPoolInit(pool, pVirt, physAddr, capacity);
 	if (status != MV_OK) {
 		mvOsPrintf("%s: Can't init #%d BM pool. status=%d\n", __func__, pool, status);
 		mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
@@ -2682,7 +2886,7 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 
 irqreturn_t mv_eth_link_isr(int irq, void *dev_id)
 {
-	mvEthIsrSummaryMask();
+	mvGmacIsrSummaryMask();
 
 	tasklet_schedule(&link_tasklet);
 
@@ -2695,7 +2899,7 @@ void mv_eth_link_tasklet(unsigned long data)
 	MV_U32 regVal, regVal1;
 	struct eth_port *pp;
 
-	regVal = mvEthIsrSummaryCauseGet();
+	regVal = mvGmacIsrSummaryCauseGet();
 	/* check only relevant interrupts - ports0 and 1 */
 	regVal &= (ETH_ISR_SUM_PORT0_MASK | ETH_ISR_SUM_PORT1_MASK);
 
@@ -2704,11 +2908,11 @@ void mv_eth_link_tasklet(unsigned long data)
 		if (!(ETH_ISR_SUM_PORT_MASK(port) & regVal))
 			continue;
 
-		regVal1 = mvEthPortIsrCauseGet(port);
+		regVal1 = mvGmacPortIsrCauseGet(port);
 
 		/* check for link change interrupt */
 		if (!(regVal1 & ETH_PORT_LINK_CHANGE_MASK)) {
-			mvEthPortIsrUnmask(port);
+			mvGmacPortIsrUnmask(port);
 			continue;
 		}
 
@@ -2717,17 +2921,17 @@ void mv_eth_link_tasklet(unsigned long data)
 			mv_eth_link_event(pp, 1);
 	}
 
-	mvEthIsrSummaryUnmask();
+	mvGmacIsrSummaryUnmask();
 }
 
 static bool mv_eth_link_status(struct eth_port *pp)
 {
 #ifdef CONFIG_MV_INCLUDE_PON
 	if (MV_PON_PORT(pp->port))
-		return mv_pon_link_status();
+		return mv_pon_link_status(NULL);
 	else
-#endif
-		return mvEthPortIsLinkUp(pp->port);
+#endif /* CONFIG_MV_PON */
+		return mvGmacPortIsLinkUp(pp->port);
 }
 
 void mv_eth_link_event(struct eth_port *pp, int print)
@@ -2741,7 +2945,8 @@ void mv_eth_link_event(struct eth_port *pp, int print)
 	link_is_up = mv_eth_link_status(pp);
 
 	if (link_is_up) {
-		mvPp2PortUp(pp->port);
+		/* Link Up event */
+		mvPp2PortEgressEnable(pp->port, MV_TRUE);
 		set_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
 
 		if (mv_eth_ctrl_is_tx_enabled(pp)) {
@@ -2750,12 +2955,15 @@ void mv_eth_link_event(struct eth_port *pp, int print)
 				netif_tx_wake_all_queues(dev);
 			}
 		}
+		mvPp2PortIngressEnable(pp->port, MV_TRUE);
 	} else {
+		/* Link Down event */
+		mvPp2PortIngressEnable(pp->port, MV_FALSE);
 		if (dev) {
 			netif_carrier_off(dev);
 			netif_tx_stop_all_queues(dev);
 		}
-		mvPp2PortDown(pp->port);
+		mvPp2PortEgressEnable(pp->port, MV_FALSE);
 		clear_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
 	}
 
@@ -2937,7 +3145,7 @@ static MV_STATUS mv_eth_bm_pools_init(void)
 int mv_eth_swf_bm_pool_init(struct eth_port *pp, int mtu)
 {
 	unsigned long flags = 0;
-	int pkt_size = RX_PKT_SIZE(mtu);
+	int rxq, pkt_size = RX_PKT_SIZE(mtu);
 
 	if (pp->pool_long == NULL) {
 		pp->pool_long = mv_eth_pool_use(MV_ETH_BM_SWF_LONG_POOL(pp->port),
@@ -2948,6 +3156,9 @@ int mv_eth_swf_bm_pool_init(struct eth_port *pp, int mtu)
 		MV_ETH_LOCK(&pp->pool_long->lock, flags);
 		pp->pool_long->port_map |= (1 << pp->port);
 		MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
+
+		for (rxq = 0; rxq < pp->rxq_num; rxq++)
+			mvPp2RxqBmLongPoolSet(pp->port, rxq, pp->pool_long->pool);
 	}
 
 	if (pp->pool_short == NULL) {
@@ -2959,6 +3170,9 @@ int mv_eth_swf_bm_pool_init(struct eth_port *pp, int mtu)
 		MV_ETH_LOCK(&pp->pool_short->lock, flags);
 		pp->pool_short->port_map |= (1 << pp->port);
 		MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
+
+		for (rxq = 0; rxq < pp->rxq_num; rxq++)
+			mvPp2RxqBmShortPoolSet(pp->port, rxq, pp->pool_short->pool);
 	}
 
 	return 0;
@@ -2968,7 +3182,7 @@ int mv_eth_swf_bm_pool_init(struct eth_port *pp, int mtu)
 int mv_eth_hwf_bm_pool_init(struct eth_port *pp, int mtu)
 {
 	unsigned long flags = 0;
-	int pkt_size = RX_PKT_SIZE(mtu);
+	int txp, txq, pkt_size = RX_PKT_SIZE(mtu);
 
 	if (pp->hwf_pool_long == NULL) {
 		pp->hwf_pool_long = mv_eth_pool_use(MV_ETH_BM_HWF_LONG_POOL(pp->port),
@@ -2979,6 +3193,12 @@ int mv_eth_hwf_bm_pool_init(struct eth_port *pp, int mtu)
 		MV_ETH_LOCK(&pp->hwf_pool_long->lock, flags);
 		pp->hwf_pool_long->port_map |= (1 << pp->port);
 		MV_ETH_UNLOCK(&pp->hwf_pool_long->lock, flags);
+
+#ifdef CONFIG_MV_ETH_PP2_1
+		for (txp = 0; txp < pp->txp_num; txp++)
+			for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+				mvPp2TxqBmLongPoolSet(pp->port, txp, txq, pp->hwf_pool_long->pool);
+#endif
 	}
 
 	if (pp->hwf_pool_short == NULL) {
@@ -2990,8 +3210,18 @@ int mv_eth_hwf_bm_pool_init(struct eth_port *pp, int mtu)
 		MV_ETH_LOCK(&pp->hwf_pool_short->lock, flags);
 		pp->hwf_pool_short->port_map |= (1 << pp->port);
 		MV_ETH_UNLOCK(&pp->hwf_pool_short->lock, flags);
+
+#ifdef CONFIG_MV_ETH_PP2_1
+		for (txp = 0; txp < pp->txp_num; txp++)
+			for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+				mvPp2TxqBmShortPoolSet(pp->port, txp, txq, pp->hwf_pool_short->pool);
+#endif
 	}
 
+#ifndef CONFIG_MV_ETH_PP2_1
+	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
+#endif
+
 	return 0;
 }
 #endif /* CONFIG_MV_ETH_HWF */
@@ -2999,33 +3229,32 @@ int mv_eth_hwf_bm_pool_init(struct eth_port *pp, int mtu)
 static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int en_force)
 {
 	if (en_force) {
-		if (mvEthSpeedDuplexSet(port, port_speed, MV_ETH_DUPLEX_FULL)) {
-			printk(KERN_ERR "mvEthSpeedDuplexSet failed\n");
+		if (mvGmacSpeedDuplexSet(port, port_speed, MV_ETH_DUPLEX_FULL)) {
+			printk(KERN_ERR "SpeedDuplexSet failed\n");
 			return -EIO;
 		}
-		if (mvEthFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
-			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
+		if (mvGmacFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
+			printk(KERN_ERR "FlowCtrlSet failed\n");
 			return -EIO;
 		}
-		if (mvEthForceLinkModeSet(port, 1, 0)) {
-			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
+		if (mvGmacForceLinkModeSet(port, 1, 0)) {
+			printk(KERN_ERR "ForceLinkModeSet failed\n");
 			return -EIO;
 		}
 	} else {
-		if (mvEthForceLinkModeSet(port, 0, 0)) {
-			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
+		if (mvGmacForceLinkModeSet(port, 0, 0)) {
+			printk(KERN_ERR "ForceLinkModeSet failed\n");
 			return -EIO;
 		}
-		if (mvEthSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
-			printk(KERN_ERR "mvEthSpeedDuplexSet failed\n");
+		if (mvGmacSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
+			printk(KERN_ERR "SpeedDuplexSet failed\n");
 			return -EIO;
 		}
-		if (mvEthFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
-			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
+		if (mvGmacFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
+			printk(KERN_ERR "FlowCtrlSet failed\n");
 			return -EIO;
 		}
 	}
-
 	return 0;
 }
 
@@ -3108,7 +3337,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 
 	pr_info("\to %s p=%d: phy=%d,  mtu=%d, mac="MV_MACQUAD_FMT", speed=%s %s\n",
 		MV_PON_PORT(port) ? "pon" : "giga", port, plat_data->phy_addr, mtu,
-		MV_MACQUAD(mac), mvEthSpeedStrGet(speed), force_link ? "(force)" : "");
+		MV_MACQUAD(mac), mvGmacSpeedStrGet(speed), force_link ? "(force)" : "");
 
 	if (mv_eth_hal_init(pp)) {
 		pr_err("\to %s: can't init eth hal\n", __func__);
@@ -3133,9 +3362,14 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	}
 
 	if (mv_eth_pnc_ctrl_en) {
+#ifndef CONFIG_MV_ETH_PP2_1
+		int txp;
 		/* Init classifer MTU */
+		/* the same MTU for all Ports/Queues */
+
 		for (txp = 0; txp < pp->txp_num; txp++)
-			mvPp2ClsHwMtuSet(MV_PPV2_PORT_PHYS(pp->port), txp, RX_PKT_SIZE(mtu));
+			mvPp2V0ClsHwMtuSet(MV_PPV2_PORT_PHYS(pp->port), txp, mtu/*TODO fix size*/);
+#endif /* CONFIG_MV_ETH_PP2_1 */
 
 		mvPp2ClsHwOversizeRxqSet(MV_PPV2_PORT_PHYS(pp->port), pp->first_rxq);
 
@@ -3374,14 +3608,14 @@ static int	mv_eth_shared_probe(struct mv_pp2_pdata *plat_data)
 			printk(KERN_ERR "%s: Warning Classifier defauld init failed\n", __func__);
 	}
 
-	/* Initialize tasklet for handlink link events */
+	/* Initialize tasklet for handle link events */
 	tasklet_init(&link_tasklet, mv_eth_link_tasklet, 0);
 
 	/* request IRQ for link interrupts from GOP */
 	if (request_irq(IRQ_GLOBAL_GOP, mv_eth_link_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth_link", NULL))
 		printk(KERN_ERR "%s: Could not request IRQ for GOP interrupts\n", __func__);
 
-	mvEthIsrSummaryUnmask();
+	mvGmacIsrSummaryUnmask();
 
 	mv_eth_initialized = 1;
 	return 0;
@@ -3450,20 +3684,20 @@ static int mv_eth_probe(struct platform_device *pdev)
 
 	if (!MV_PON_PORT(port)) {
 		/* First: Disable Gmac */
-		mvEthPortDisable(port);
+		mvGmacPortDisable(port);
 
 		/* Set the board information regarding PHY address */
 		phyAddr = plat_data->phy_addr;
 		if (phyAddr != -1)
-			mvEthPhyAddrSet(port, phyAddr);
+			mvGmacPhyAddrSet(port, phyAddr);
 
 		is_sgmii = (plat_data->flags & MV_PP2_PDATA_F_SGMII) ? 1 : 0;
 		is_rgmii = (plat_data->flags & MV_PP2_PDATA_F_RGMII) ? 1 : 0;
 
 		if (plat_data->flags & MV_PP2_PDATA_F_LB)
-			mvEthPortLbSet(port, (plat_data->speed == SPEED_1000), is_sgmii);
+			mvGmacPortLbSet(port, (plat_data->speed == SPEED_1000), is_sgmii);
 
-		mvEthPortPowerUp(port, is_sgmii, is_rgmii);
+		mvGmacPortPowerUp(port, is_sgmii, is_rgmii);
 	}
 
 	if (mv_eth_load_network_interfaces(pdev))
@@ -3626,11 +3860,24 @@ int mv_eth_hal_init(struct eth_port *pp)
 			txq_ctrl->txq_size = CONFIG_MV_ETH_TXQ_DESC;
 			txq_ctrl->hwf_size = CONFIG_MV_ETH_TXQ_HWF_DESC;
 
+#ifdef CONFIG_MV_ETH_PP2_1
+			txq_ctrl->rsvd_chunk = MV_ETH_CPU_DESC_CHUNK;
+			txq_ctrl->hwf_size =
+				txq_ctrl->txq_size - (nr_cpu_ids * txq_ctrl->rsvd_chunk);
+			txq_ctrl->swf_size =
+				txq_ctrl->hwf_size - (nr_cpu_ids * txq_ctrl->rsvd_chunk);
+#endif
 			for_each_possible_cpu(cpu) {
 				txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
 				txq_cpu_ptr->shadow_txq = NULL;
+#ifdef CONFIG_MV_ETH_PP2_1
+				/* In default, all CPUs and TXQs have same chunk size */
+				txq_cpu_ptr->txq_size = CONFIG_MV_ETH_TXQ_DESC;
+				txq_cpu_ptr->reserved_num = 0;
+#else
 				txq_cpu_ptr->txq_size =
 					(CONFIG_MV_ETH_TXQ_DESC - CONFIG_MV_ETH_TXQ_HWF_DESC) / nr_cpu_ids;
+#endif
 				txq_cpu_ptr->txq_count = 0;
 				txq_cpu_ptr->shadow_txq_put_i = 0;
 				txq_cpu_ptr->shadow_txq_get_i = 0;
@@ -3712,6 +3959,13 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o GSO supported\n");
 #endif /* CONFIG_MV_ETH_TSO */
 
+#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
+	printk(KERN_ERR "  o Receive checksum offload supported\n");
+#endif
+#if defined(CONFIG_MV_ETH_TX_CSUM_OFFLOAD)
+	printk(KERN_ERR "  o Transmit checksum offload supported\n");
+#endif
+
 #ifdef CONFIG_MV_ETH_STAT_ERR
 	printk(KERN_ERR "  o Driver ERROR statistics enabled\n");
 #endif
@@ -3786,8 +4040,14 @@ static int mv_eth_txq_create(struct eth_port *pp, struct tx_queue *txq_ctrl)
 
 	txq_ctrl->q = mvPp2TxqInit(pp->port, txq_ctrl->txp, txq_ctrl->txq, txq_ctrl->txq_size, txq_ctrl->hwf_size);
 	if (txq_ctrl->q == NULL) {
+#ifdef CONFIG_MV_ETH_PP2_1
+		printk(KERN_ERR "%s: can't create TxQ - port=%d, txp=%d, txq=%d, desc=%d, hwf desc=%d swf desc = %d\n",
+			__func__, pp->port, txq_ctrl->txp, txq_ctrl->txp,
+			txq_ctrl->txq_size, txq_ctrl->hwf_size, txq_ctrl->swf_size);
+#else
 		printk(KERN_ERR "%s: can't create TxQ - port=%d, txp=%d, txq=%d, desc=%d, hwf desc=%d\n",
 		       __func__, pp->port, txq_ctrl->txp, txq_ctrl->txp, txq_ctrl->txq_size, txq_ctrl->hwf_size);
+#endif
 		return -ENODEV;
 	}
 
@@ -3801,7 +4061,6 @@ static int mv_eth_txq_create(struct eth_port *pp, struct tx_queue *txq_ctrl)
 		txq_cpu_ptr->shadow_txq_put_i = 0;
 		txq_cpu_ptr->shadow_txq_get_i = 0;
 	}
-
 	return 0;
 
 no_mem:
@@ -3814,6 +4073,7 @@ static void mv_eth_txq_delete(struct eth_port *pp, struct tx_queue *txq_ctrl)
 {
 	int cpu;
 	struct txq_cpu_ctrl *txq_cpu_ptr;
+
 	for_each_possible_cpu(cpu) {
 		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
 		if (txq_cpu_ptr->shadow_txq) {
@@ -3828,39 +4088,85 @@ static void mv_eth_txq_delete(struct eth_port *pp, struct tx_queue *txq_ctrl)
 	}
 }
 
+int mv_eth_txq_clean(int port, int txp, int txq)
+{
+	struct eth_port *pp;
+	struct tx_queue *txq_ctrl;
+	int msec, pending, tx_done;
+
+	if (mvPp2TxpCheck(port, txp))
+		return -EINVAL;
+
+	pp = mv_eth_port_by_id(port);
+	if ((pp == NULL) || (pp->txq_ctrl == NULL))
+		return -ENODEV;
+
+	if (mvPp2MaxCheck(txq, CONFIG_MV_ETH_TXQ, "txq"))
+		return -EINVAL;
+
+	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
+	if (txq_ctrl->q) {
+		/* Enable TXQ drain */
+		mvPp2TxqDrainSet(port, txp, txq, MV_TRUE);
+
+		/* Wait for all packets to be transmitted */
+		msec = 0;
+		do {
+			if (msec >= MV_ETH_TX_PENDING_TIMEOUT_MSEC) {
+				pr_err("port=%d, txp=%d txq=%d: timeout for transmit pending descriptors\n",
+					port, txp, txq);
+				break;
+			}
+			mdelay(1);
+			msec++;
+
+			pending = mvPp2TxqPendDescNumGet(port, txp, txq);
+		} while (pending);
+
+		/* Disable TXQ Drain */
+		mvPp2TxqDrainSet(port, txp, txq, MV_FALSE);
+
+		/* release all transmitted packets */
+		tx_done = mv_eth_txq_done(pp, txq_ctrl);
+		if (tx_done > 0)
+			mvOsPrintf(KERN_INFO "%s: port=%d, txp=%d txq=%d: Free %d transmitted descriptors\n",
+				__func__, port, txp, txq, tx_done);
+
+		/* release all untransmitted packets */
+		tx_done = mv_eth_txq_done_force(pp, txq_ctrl);
+		if (tx_done > 0)
+			mvOsPrintf(KERN_INFO "%s: port=%d, txp=%d txq=%d: Free %d untransmitted descriptors\n",
+				__func__, port, txp, txq, tx_done);
+	}
+	return 0;
+}
+
 /* Free all packets pending transmit from all TXQs and reset TX port */
 int mv_eth_txp_clean(int port, int txp)
 {
-	struct eth_port *pp = mv_eth_port_by_id(port);
-	int queue, msec, pending;
+	struct eth_port *pp;
+	int txq;
+
+	if (mvPp2TxpCheck(port, txp))
+		return -EINVAL;
+
+	pp = mv_eth_port_by_id(port);
+	if ((pp == NULL) || (pp->txq_ctrl == NULL))
+		return -ENODEV;
 
 	if (pp->flags & MV_ETH_F_STARTED) {
 		printk(KERN_ERR "Port %d must be stopped before\n", port);
 		return -EINVAL;
 	}
 
+	/* Flush TX FIFO */
+	mvPp2TxPortFifoFlush(port, MV_TRUE);
+
 	/* free the skb's in the hal tx ring */
-	for (queue = 0; queue < CONFIG_MV_ETH_TXQ; queue++) {
-		struct tx_queue *txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + queue];
-
-		if (txq_ctrl->q) {
-			/* Wait for all packets to be transmitted */
-			msec = 0;
-			do {
-				if (msec >= MV_ETH_TX_PENDING_TIMEOUT_MSEC) {
-					mvOsPrintf("port=%d, txp=%d txq=%d: timeout for transmit pending descriptors\n",
-						   port, txp, queue);
-					break;
-				}
-				mdelay(1);
-				msec++;
+	for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+		mv_eth_txq_clean(port, txp, txq);
 
-				pending = mvPp2TxqPendDescNumGet(pp->port,  txp, queue);
-			} while (pending);
-			/* release all transmitted packets */
-			mv_eth_txq_done_force(pp, txq_ctrl);
-		}
-	}
+	mvPp2TxPortFifoFlush(port, MV_FALSE);
 
 	mvPp2TxpReset(port, txp);
 
@@ -3915,10 +4221,17 @@ MV_STATUS mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 value)
 }
 
 /***********************************************************
- * mv_eth_start_internals --                               *
- *   fill rx buffers. start rx/tx activity. set coalesing. *
- *   clear and unmask interrupt bits                       *
- ***********************************************************/
+* mv_eth_start_internals --                               *
+*   fill rx buffers. start rx/tx activity. set coalesing. *
+*   clear and unmask interrupt bits                       *
+*   -   RX and TX init
+*   -   HW port enable
+*   -   HW enable port tx
+*   -   Enable NAPI
+*   -   Enable interrupts (RXQ still close .. interrupts will not received)
+*   -   SW start tx (wake_up _all_queues)
+*   -   HW start rx
+***********************************************************/
 int mv_eth_start_internals(struct eth_port *pp, int mtu)
 {
 	unsigned int status;
@@ -3932,7 +4245,7 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	}
 
 	if (!MV_PON_PORT(pp->port))
-		mvEthMaxRxSizeSet(pp->port, RX_PKT_SIZE(mtu));
+		mvGmacMaxRxSizeSet(pp->port, RX_PKT_SIZE(mtu));
 #ifdef CONFIG_MV_INCLUDE_PON
 	else
 		mv_pon_mtu_config(RX_PKT_SIZE(mtu));
@@ -3945,8 +4258,6 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	err = mv_eth_hwf_bm_pool_init(pp, mtu);
 	if (err)
 		goto out;
-
-	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
 #endif /* CONFIG_MV_ETH_HWF */
 
 
@@ -3968,14 +4279,6 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 		mv_eth_rx_ptks_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_pkts_coal);
 		mv_eth_rx_time_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_time_coal);
 
-		if (pp->pool_short->pool == pp->pool_long->pool) {
-			int dummy_short_pool = (pp->pool_short->pool + 1) % MV_BM_POOLS;
-
-			/* To disable short pool we choose unused pool and set pkt size to 0 (buffer size = pkt offset) */
-			mvPp2RxqBmPoolSet(pp->port, rxq, dummy_short_pool, pp->pool_long->pool);
-		} else
-			mvPp2RxqBmPoolSet(pp->port, rxq, pp->pool_short->pool, pp->pool_long->pool);
-
 		if (!(pp->flags & MV_ETH_F_IFCAP_NETMAP)) {
 			if (mvPp2RxqFreeDescNumGet(pp->port, rxq) == 0)
 				mv_eth_rxq_fill(pp, rxq, pp->rxq_ctrl[rxq].rxq_size);
@@ -4013,20 +4316,6 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	}
 	/* TODO: set speed, duplex, fc with ethtool parameres (speed_cfg, etc..) */
 
-	/* start the hal - rx/tx activity */
-
-	clear_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
-
-	status = MV_NOT_READY;
-	if (!MV_PON_PORT(pp->port))
-		status = mvPp2PortEnable(pp->port);
-#ifdef CONFIG_MV_INCLUDE_PON
-	else
-		status = mv_pon_enable();
-#endif
-	if (status == MV_OK)
-		set_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
-
 	set_bit(MV_ETH_F_STARTED_BIT, &(pp->flags));
  out:
 	return err;
@@ -4061,9 +4350,15 @@ int mv_eth_suspend_internals(struct eth_port *pp)
 
 
 /***********************************************************
- * mv_eth_stop_internals --                                *
- *   stop port rx/tx activity. free skb's from rx/tx rings.*
- ***********************************************************/
+* mv_eth_stop_internals --                                *
+*   -   HW stop rx
+*   -   SW stop tx (tx_stop_all_queues)
+*   -   Disable interrupts
+*   -   Disable NAPI
+*   -   HW  disable port tx
+*   -   HW disable port
+*   -   RX and TX cleanups
+***********************************************************/
 int mv_eth_stop_internals(struct eth_port *pp)
 {
 	int queue, txp;
@@ -4081,18 +4376,6 @@ int mv_eth_stop_internals(struct eth_port *pp)
 		mv_eth_txp_clean(pp->port, txp);
 
 
-	if (!MV_PON_PORT(pp->port)) {
-		if (mvPp2PortDisable(pp->port) != MV_OK) {
-			printk(KERN_ERR "GbE port %d: ethPortDisable failed\n", pp->port);
-			goto error;
-		}
-	}
-#ifdef CONFIG_MV_INCLUDE_PON
-	else if (mv_pon_disable() != MV_OK) {
-		printk(KERN_ERR "PON port %d: mv_pon_disable failed\n", pp->port);
-		goto error;
-	}
-#endif
 	/* free the skb's in the hal rx ring */
 	for (queue = 0; queue < pp->rxq_num; queue++)
 		mv_eth_rxq_drop_pkts(pp, queue);
@@ -4156,7 +4439,7 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 {
 	struct bm_pool *port_pool;
 	struct eth_port *pp = MV_ETH_PRIV(dev);
-	int txp, pkt_size = RX_PKT_SIZE(mtu), pkts_num;
+	int pkt_size = RX_PKT_SIZE(mtu), pkts_num, txp;
 	unsigned long flags = 0;
 
 	if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
@@ -4214,13 +4497,16 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 #endif /* CONFIG_MV_ETH_HWF */
 
 	if (!MV_PON_PORT(pp->port))
-		mvEthMaxRxSizeSet(pp->port, pkt_size);
+		mvGmacMaxRxSizeSet(pp->port, pkt_size);
 #ifdef CONFIG_MV_INCLUDE_PON
 	else
 		mv_pon_mtu_config(pkt_size);
 #endif
+
+#ifndef CONFIG_MV_ETH_PP2_1
 	for (txp = 0; txp < pp->txp_num; txp++)
-		mvPp2ClsHwMtuSet(MV_PPV2_PORT_PHYS(pp->port), txp, pkt_size);
+		mvPp2V0ClsHwMtuSet(MV_PPV2_PORT_PHYS(pp->port), txp, pkt_size);
+#endif
 
 mtu_out:
 	dev->mtu = mtu;
@@ -4319,12 +4605,11 @@ int mv_eth_rxq_dscp_map_set(int port, int rxq, unsigned char dscp)
 int mv_eth_txq_dscp_map_set(int port, int txq, unsigned char dscp)
 {
 	MV_U8 old_txq;
-	struct eth_port *pp;
+	struct eth_port *pp = mv_eth_port_by_id(port);
 
 	if (mvPp2PortCheck(port))
 		return -EINVAL;
 
-	pp = mv_eth_port_by_id(port);
 	if ((pp == NULL) || (pp->txq_ctrl == NULL))
 		return -ENODEV;
 
@@ -4435,7 +4720,7 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		pp->txq_dscp_map[i] = MV_ETH_TXQ_INVALID;
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
 	pp->tx_special_check = NULL;
-#endif
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
 
 #ifdef CONFIG_MV_INCLUDE_PON
 	if (MV_PON_PORT(port)) {
@@ -4494,7 +4779,7 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	} else
 		pr_err("\to ethPort #%d: Can't allocate %d bytes for tx_done_dist\n",
 		       pp->port, sizeof(u32) * (pp->txp_num * CONFIG_MV_ETH_TXQ * CONFIG_MV_ETH_TXQ_DESC + 1));
-#endif
+#endif /* CONFIG_MV_ETH_STAT_DIST */
 
 	return 0;
 }
@@ -4933,27 +5218,29 @@ void mv_eth_port_stats_print(unsigned int port)
 		memset(&aggr_txq_ctrl->stats, 0, sizeof(aggr_txq_ctrl->stats));
 	}
 
-	pr_info("\nPhysical TXQs statistics\n");
-	printk(KERN_ERR "TXP-TXQ-CPU:  count        send          done      no_resource\n\n");
+	pr_info("\n");
+	pr_info("TXP-TXQ:  count          send          done      reserved      chunk_alloc      no_resource\n\n");
 
 	for (txp = 0; txp < pp->txp_num; txp++) {
 		for (queue = 0; queue < CONFIG_MV_ETH_TXQ; queue++)
 			for_each_possible_cpu(cpu) {
-				u32 txq_tx = 0, txq_txdone = 0, txq_err = 0;
+				u32 txq_tx = 0, txq_txdone = 0, txq_txreq = 0, txq_err = 0;
 
 				txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + queue];
 				txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
 #ifdef CONFIG_MV_ETH_STAT_DBG
 				txq_tx = txq_cpu_ptr->stats.txq_tx;
 				txq_txdone =  txq_cpu_ptr->stats.txq_txdone;
+				txq_txreq =  txq_cpu_ptr->stats.txq_txreq;
+
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 #ifdef CONFIG_MV_ETH_STAT_ERR
 				txq_err = txq_cpu_ptr->stats.txq_err;
 #endif /* CONFIG_MV_ETH_STAT_ERR */
 
-				printk(KERN_ERR " %d - %d - %d:   %3d   %10u    %10u    %10u\n",
+				printk(KERN_ERR "%d-%d-cpu#%d: %3d    %10u    %10u    %10u    %10u    %10u\n",
 				       txp, queue, cpu, txq_cpu_ptr->txq_count, txq_tx,
-				       txq_txdone, txq_err);
+				       txq_txdone,  txq_cpu_ptr->reserved_num, txq_txreq, txq_err);
 
 				memset(&txq_cpu_ptr->stats, 0, sizeof(txq_cpu_ptr->stats));
 			}
@@ -5202,14 +5489,20 @@ void mv_eth_ext_mac_ops_register(int port_id,
 	mv_pon_callbacks = *ext_mac_ops;
 }
 
-MV_BOOL mv_pon_link_status(void)
+MV_BOOL mv_pon_link_status(MV_ETH_PORT_STATUS *link)
 {
+	MV_BOOL linkup = MV_TRUE;
+
 	if (mv_pon_callbacks && mv_pon_callbacks->link_status_get)
-		return mv_pon_callbacks->link_status_get(MV_PON_LOGIC_PORT_GET());
+		linkup = mv_pon_callbacks->link_status_get(MV_PON_LOGIC_PORT_GET());
 
-	printk(KERN_ERR "pon link_status_get is uninitialized\n");
+	if (link) {
+		link->linkup = linkup;
+		link->speed = MV_ETH_SPEED_1000;
+		link->duplex = MV_ETH_DUPLEX_FULL;
+	}
 
-	return MV_TRUE;
+	return linkup;
 }
 
 MV_STATUS mv_pon_mtu_config(MV_U32 maxEth)
@@ -5252,16 +5545,15 @@ MV_STATUS mv_pon_enable(void)
 	} else
 		printk(KERN_ERR "Warning: pon port_enable is uninitialized\n");
 
-	if (mv_pon_link_status() == MV_TRUE)
-		return mvPp2PortUp(MV_PON_LOGIC_PORT_GET());
+	if (mv_pon_link_status(NULL) == MV_TRUE)
+		return mvPp2PortEgressEnable(MV_PON_LOGIC_PORT_GET(), MV_TRUE);
 
 	return MV_NOT_READY;
 }
 
 MV_STATUS mv_pon_disable(void)
 {
-	mvPp2PortDown(MV_PON_LOGIC_PORT_GET());
-
+	mvPp2PortEgressEnable(MV_PON_LOGIC_PORT_GET(), MV_FALSE);
 	if (mv_pon_callbacks && mv_pon_callbacks->port_disable) {
 		if (mv_pon_callbacks->port_disable(MV_PON_LOGIC_PORT_GET()) != MV_OK) {
 			printk(KERN_ERR "pon port_disable failed\n");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 6dd84f6..c066d8a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -150,6 +150,7 @@ struct txq_stats {
 #endif /* CONFIG_MV_ETH_STAT_ERR */
 #ifdef CONFIG_MV_ETH_STAT_DBG
 	u32 txq_tx;
+	u32 txq_txreq; /*request reserved tx descriptors*/
 	u32 txq_txdone;
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 };
@@ -255,15 +256,18 @@ struct port_stats {
 
 #define TOS_TO_DSCP(tos)	((tos >> 2) & 0x3F)
 
+/* Used in PPv2.1 */
+#define MV_ETH_CPU_DESC_CHUNK	20
+
 /* Masks used for tx_spec->flags */
-#define MV_ETH_TX_F_NO_PAD      0x0001
-#define MV_ETH_TX_F_MH          0x0002
-#define MV_ETH_TX_F_HW_CMD      0x0004
+#define MV_ETH_TX_F_NO_PAD	0x0001
+#define MV_ETH_TX_F_MH		0x0002
+#define MV_ETH_TX_F_HW_CMD	0x0004
 
 struct mv_eth_tx_spec {
 	unsigned long	flags;
-	u32             hw_cmd[3];     /* tx_desc offset = 0x10, 0x14, 0x18 */
-	u16             tx_mh;
+	u32		hw_cmd[3];     /* tx_desc offset = 0x10, 0x14, 0x18 */
+	u16		tx_mh;
 	u8		txp;
 	u8		txq;
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
@@ -272,47 +276,50 @@ struct mv_eth_tx_spec {
 };
 
 struct txq_cpu_ctrl {
-	int 			txq_size;
+	int			txq_size;
 	int			txq_count;
+	int			reserved_num; /* PPv2.1 (MAS 3.16)- number of reserved descriptors for this CPU */
 	u32			*shadow_txq; /* can be MV_ETH_PKT* or struct skbuf* */
 	int			shadow_txq_put_i;
 	int			shadow_txq_get_i;
-	struct txq_stats    	stats;
+	struct txq_stats	stats;
 };
 
 struct tx_queue {
 	MV_PP2_PHYS_TXQ_CTRL	*q;
-	u8                  	txp;
-	u8                  	txq;
-	int                 	txq_size;
-	int                 	hwf_size;
+	u8			txp;
+	u8			txq;
+	int			txq_size;
+	int			hwf_size;
+	int			swf_size;
+	int			rsvd_chunk;
 	struct txq_cpu_ctrl	txq_cpu[CONFIG_NR_CPUS];
-	spinlock_t          	queue_lock;
-	MV_U32              	txq_done_pkts_coal;
-	unsigned long           flags;
+	spinlock_t		queue_lock;
+	MV_U32			txq_done_pkts_coal;
+	unsigned long		flags;
 };
 
 struct aggr_tx_queue {
 	MV_PP2_AGGR_TXQ_CTRL	*q;
-	int                 	txq_size;
-	int                 	txq_count;
-	struct txq_stats        stats;
+	int			txq_size;
+	int			txq_count;
+	struct txq_stats	stats;
 };
 
 struct rx_queue {
 	MV_PP2_PHYS_RXQ_CTRL	*q;
-	int                 	rxq_size;
-	MV_U32	            	rxq_pkts_coal;
-	MV_U32	            	rxq_time_coal;
+	int			rxq_size;
+	MV_U32			rxq_pkts_coal;
+	MV_U32			rxq_time_coal;
 };
 
 struct dist_stats {
-	u32     *rx_dist;
-	int     rx_dist_size;
-	u32     *tx_done_dist;
-	int     tx_done_dist_size;
-	u32     *tx_tso_dist;
-	int     tx_tso_dist_size;
+	u32	*rx_dist;
+	int	rx_dist_size;
+	u32	*tx_done_dist;
+	int	tx_done_dist_size;
+	u32	*tx_tso_dist;
+	int	tx_tso_dist_size;
 };
 
 struct napi_group_ctrl {
@@ -324,74 +331,74 @@ struct napi_group_ctrl {
 };
 
 struct cpu_ctrl {
-	struct eth_port        *pp;
-	struct napi_group_ctrl *napi_group;
-	int	               txq;
-	int                    cpu;
-	struct timer_list      tx_done_timer;
-	unsigned long          flags;
+	struct eth_port		*pp;
+	struct napi_group_ctrl	*napi_group;
+	int			txq;
+	int			cpu;
+	struct timer_list	tx_done_timer;
+	unsigned long		flags;
 };
 
 struct eth_port {
-	int                 port;
-	struct mv_pp2_pdata *plat_data;
-	bool                tagged; /* NONE/MH/DSA/EDSA/VLAN */
-	MV_PP2_PORT_CTRL    *port_ctrl;
-	struct rx_queue     *rxq_ctrl;
-	struct tx_queue     *txq_ctrl;
-	int                 txp_num;
-	int		    first_rxq;
-	int 		    rxq_num;
-	struct net_device   *dev;
-	rwlock_t            rwlock;
-	struct bm_pool      *pool_long;
-	struct bm_pool      *pool_short;
-	struct bm_pool      *hwf_pool_long;
-	struct bm_pool      *hwf_pool_short;
-	struct napi_group_ctrl *napi_group[MV_ETH_MAX_RXQ];
-	unsigned long       flags;	/* MH, TIMER, etc. */
-	u8		    dbg_flags;
-	struct mv_eth_tx_spec tx_spec;
-	struct port_stats   stats;
-	struct dist_stats   dist_stats;
-	int                 weight;
-	MV_STACK            *extArrStack;
-	int                 extBufSize;
-	spinlock_t          extLock;
-	MV_U8  		    txq_dscp_map[64];
+	int			port;
+	struct mv_pp2_pdata	*plat_data;
+	bool			tagged; /* NONE/MH/DSA/EDSA/VLAN */
+	MV_PP2_PORT_CTRL	*port_ctrl;
+	struct rx_queue		*rxq_ctrl;
+	struct tx_queue		*txq_ctrl;
+	int			txp_num;
+	int			first_rxq;
+	int			rxq_num;
+	struct net_device	*dev;
+	rwlock_t		rwlock;
+	struct bm_pool		*pool_long;
+	struct bm_pool		*pool_short;
+	struct bm_pool		*hwf_pool_long;
+	struct bm_pool		*hwf_pool_short;
+	struct napi_group_ctrl	*napi_group[MV_ETH_MAX_RXQ];
+	unsigned long		flags; /* MH, TIMER, etc. */
+	u8			dbg_flags;
+	struct mv_eth_tx_spec	tx_spec;
+	struct port_stats	stats;
+	struct dist_stats	dist_stats;
+	int			weight;
+	MV_STACK		*extArrStack;
+	int			extBufSize;
+	spinlock_t		extLock;
+	MV_U8			txq_dscp_map[64];
 	/* Ethtool parameters */
-	__u16               speed_cfg;
-	__u8                duplex_cfg;
-	__u8                autoneg_cfg;
-	__u16		    advertise_cfg;
-	__u32		    rx_time_coal_cfg;
-	__u32		    rx_pkts_coal_cfg;
-	__u32		    tx_pkts_coal_cfg;
-	__u32		    rx_time_low_coal_cfg;
-	__u32		    rx_time_high_coal_cfg;
-	__u32		    rx_pkts_low_coal_cfg;
-	__u32		    rx_pkts_high_coal_cfg;
-	__u32		    pkt_rate_low_cfg;
-	__u32		    pkt_rate_high_cfg;
-	__u32		    rate_current; /* unknown (0), low (1), normal (2), high (3) */
-	__u32		    rate_sample_cfg;
-	__u32		    rx_adaptive_coal_cfg;
+	__u16			speed_cfg;
+	__u8			duplex_cfg;
+	__u8			autoneg_cfg;
+	__u16			advertise_cfg;
+	__u32			rx_time_coal_cfg;
+	__u32			rx_pkts_coal_cfg;
+	__u32			tx_pkts_coal_cfg;
+	__u32			rx_time_low_coal_cfg;
+	__u32			rx_time_high_coal_cfg;
+	__u32			rx_pkts_low_coal_cfg;
+	__u32			rx_pkts_high_coal_cfg;
+	__u32			pkt_rate_low_cfg;
+	__u32			pkt_rate_high_cfg;
+	__u32			rate_current; /* unknown (0), low (1), normal (2), high (3) */
+	__u32			rate_sample_cfg;
+	__u32			rx_adaptive_coal_cfg;
 	/* Rate calculate */
-	unsigned long	    rx_rate_pkts;
-	unsigned long	    rx_timestamp;
+	unsigned long		rx_rate_pkts;
+	unsigned long		rx_timestamp;
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
-	void    (*rx_special_proc)(int port, int rxq, struct net_device *dev,
-					struct sk_buff *skb, struct pp2_rx_desc *rx_desc);
+	void			(*rx_special_proc)(int port, int rxq, struct net_device *dev,
+						struct sk_buff *skb, struct pp2_rx_desc *rx_desc);
 #endif /* CONFIG_MV_ETH_RX_SPECIAL */
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
-	int     (*tx_special_check)(int port, struct net_device *dev, struct sk_buff *skb,
-					struct mv_eth_tx_spec *tx_spec_out);
+	int			(*tx_special_check)(int port, struct net_device *dev, struct sk_buff *skb,
+						struct mv_eth_tx_spec *tx_spec_out);
 #endif /* CONFIG_MV_ETH_TX_SPECIAL */
-	MV_U32 cpuMask;
-	MV_U32 rx_indir_table[256];
-	struct cpu_ctrl	*cpu_config[CONFIG_NR_CPUS];
-	MV_U32  sgmii_serdes;
-	int	pm_mode;
+	MV_U32			cpuMask;
+	MV_U32			rx_indir_table[256];
+	struct cpu_ctrl		*cpu_config[CONFIG_NR_CPUS];
+	MV_U32			sgmii_serdes;
+	int			pm_mode;
 };
 
 enum eth_pm_mode {
@@ -401,8 +408,8 @@ enum eth_pm_mode {
 	MV_ETH_PM_LAST
 };
 
-#define MV_ETH_PRIV(dev)        ((struct eth_port *)(netdev_priv(dev)))
-#define MV_DEV_STAT(dev)        (&((dev)->stats))
+#define MV_ETH_PRIV(dev)	((struct eth_port *)(netdev_priv(dev)))
+#define MV_DEV_STAT(dev)	(&((dev)->stats))
 
 /* BM specific defines */
 struct pool_stats {
@@ -447,8 +454,8 @@ struct pool_stats {
 #define MV_ETH_BM_HWF_SHORT_POOL(port)		(7)
 #endif
 
-#define MV_ETH_BM_POOLS	        MV_BM_POOLS
-#define mv_eth_pool_bm(p)       (p->bm_pool)
+#define MV_ETH_BM_POOLS		MV_BM_POOLS
+#define mv_eth_pool_bm(p)	(p->bm_pool)
 
 enum mv_eth_bm_type {
 	MV_ETH_BM_FREE,		/* BM pool is not being used by any port		   */
@@ -478,30 +485,40 @@ enum mv_eth_bm_type {
 struct bm_pool {
 	int			pool;
 	enum mv_eth_bm_type	type;
-	int                 capacity;
-	int                 buf_num;
-	int                 pkt_size;
-	u32                 *bm_pool;
-	MV_ULONG            physAddr;
-	spinlock_t          lock;
-	u32                 port_map;
-	atomic_t    in_use;
-	int                 in_use_thresh;
-	struct              pool_stats stats;
+	int			capacity;
+	int			buf_num;
+	int			pkt_size;
+	u32			*bm_pool;
+	MV_ULONG		physAddr;
+	spinlock_t		lock;
+	u32			port_map;
+	atomic_t		in_use;
+	int			in_use_thresh;
+	struct			pool_stats stats;
 };
 
 /* BM cookie (32 bits) definition */
 /* bits[0-7]   - Flags  */
 /*      bit0 - bm_cookie is invalid for SKB recycle */
-#define MV_ETH_BM_COOKIE_F_INVALID            (1 << 0)
+#define MV_ETH_BM_COOKIE_F_INVALID		0
 /*      bit7 - buffer is guaranteed */
-#define MV_ETH_BM_COOKIE_F_BUF_GRNTD          (1 << 7)
+#define MV_ETH_BM_COOKIE_F_GRNTD_OFF		7
 /* bits[8-15]  - PoolId */
-#define MV_ETH_BM_COOKIE_POOL_OFFS            8
+#define MV_ETH_BM_COOKIE_POOL_OFFS		8
 /* bits[16-23] - Qset   */
-#define MV_ETH_BM_COOKIE_QSET_OFFS            16
+#define MV_ETH_BM_COOKIE_QSET_OFFS		16
 /* bits[24-31] - Cpu    */
-#define MV_ETH_BM_COOKIE_CPU_OFFS             24
+#define MV_ETH_BM_COOKIE_CPU_OFFS		24
+
+static inline int mv_eth_bm_cookie_grntd_get(__u32 cookie)
+{
+	return (cookie >> MV_ETH_BM_COOKIE_F_GRNTD_OFF) & 0x1;
+}
+
+static inline int mv_eth_bm_cookie_qset_get(__u32 cookie)
+{
+	return (cookie >> 16) & 0xFF;
+}
 
 static inline int mv_eth_bm_cookie_pool_get(__u32 cookie)
 {
@@ -528,9 +545,14 @@ static inline __u32 mv_eth_bm_cookie_build(struct pp2_rx_desc *rx_desc)
 {
 	int pool = mvPp2RxBmPoolId(rx_desc);
 	int cpu = smp_processor_id();
+	int qset = (rx_desc->bmQset & PP2_RX_BUFF_QSET_NUM_MASK) >> PP2_RX_BUFF_QSET_NUM_OFFS;
+	int grntd = ((rx_desc->bmQset & PP2_RX_BUFF_TYPE_MASK) >> PP2_RX_BUFF_TYPE_OFFS);
 
 	return ((pool & 0xFF) << MV_ETH_BM_COOKIE_POOL_OFFS) |
-		((cpu & 0xFF) << MV_ETH_BM_COOKIE_CPU_OFFS);
+		((cpu & 0xFF) << MV_ETH_BM_COOKIE_CPU_OFFS) |
+		((qset & 0xFF) << MV_ETH_BM_COOKIE_QSET_OFFS) |
+		((grntd & 0x1) << MV_ETH_BM_COOKIE_F_GRNTD_OFF);
+
 }
 
 static inline int mv_eth_bm_in_use_read(struct bm_pool *bm)
@@ -598,26 +620,73 @@ static inline int mv_eth_ctrl_is_tx_enabled(struct eth_port *pp)
 /*
 	Check if there are enough descriptors in physical TXQ.
 
-	return: 0 - not enough descriptors,  1 - enough descriptors
+	return: 1 - not enough descriptors,  0 - enough descriptors
 */
 static inline int mv_eth_phys_desc_num_check(struct txq_cpu_ctrl *txq_ctrl, int num)
 {
+
 	if ((txq_ctrl->txq_count + num) > txq_ctrl->txq_size) {
 		/*
 		printk(KERN_ERR "eth_tx: txq_ctrl->txq=%d - no_resource: txq_count=%d, txq_size=%d, num=%d\n",
 			txq_ctrl->txq, txq_ctrl->txq_count, txq_ctrl->txq_size, num);
 		*/
 		STAT_ERR(txq_ctrl->stats.txq_err++);
-		return 0;
+		return 1;
 	}
-	return 1;
+	return 0;
 }
 
 /*
+	Check if there are enough reserved descriptors for SWF
+	If not enough, then try to reqest chunk of reserved descriptors and check again.
+
+	return: 1 - not enough descriptors,  0 - enough descriptors
+*/
+static inline int mv_eth_reserved_desc_num_proc(struct eth_port *pp, int txp, int txq, int num)
+{
+	struct tx_queue *txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
+	struct txq_cpu_ctrl *txq_cpu_p;
+	struct txq_cpu_ctrl *txq_cpu_ptr =  &txq_ctrl->txq_cpu[smp_processor_id()];
+
+
+	if (txq_cpu_ptr->reserved_num < num) {
+		int req, new_reserved, cpu, txq_count = 0;
+
+		/* new chunk is necessary */
+
+		for_each_possible_cpu(cpu) {
+			/* compute tolat txq used descriptors */
+			txq_cpu_p = &txq_ctrl->txq_cpu[cpu];
+			txq_count += txq_cpu_p->txq_count;
+			txq_count += txq_cpu_p->reserved_num;
+		}
+
+		req = MV_MAX(txq_ctrl->rsvd_chunk, num - txq_cpu_ptr->reserved_num);
+		txq_count += req;
+
+		if (txq_count  > txq_ctrl->swf_size) {
+			STAT_ERR(txq_cpu_ptr->stats.txq_err++);
+			return 1;
+		}
+
+
+		new_reserved = mvPp2TxqAllocReservedDesc(pp->port, txp, txq, req);
+		txq_cpu_ptr->reserved_num += new_reserved;
+
+		if (txq_cpu_ptr->reserved_num < num)
+			/* out of resources - drop packet*/
+			return 1;
+
+		STAT_DBG(txq_cpu_ptr->stats.txq_txreq++);
+	}
+
+	return 0;
+}
+/*
 	Check if there are enough descriptors in aggregated TXQ.
 	If not enough, then try to update number of occupied aggr descriptors and check again.
 
-	return: 0 - not enough descriptors,  1 - enough descriptors
+	return: 1 - not enough descriptors,  0 - enough descriptors
 */
 static inline int mv_eth_aggr_desc_num_check(struct aggr_tx_queue *aggr_txq_ctrl, int num)
 {
@@ -633,9 +702,10 @@ static inline int mv_eth_aggr_desc_num_check(struct aggr_tx_queue *aggr_txq_ctrl
 			txq_ctrl->txq, txq_ctrl->txq_count, txq_ctrl->txq_size, num);
 		*/
 		STAT_ERR(aggr_txq_ctrl->stats.txq_err++);
-		return 0;
+		return 1;
 	}
-	return 1;
+
+	return 0;
 }
 
 static inline void mv_eth_tx_desc_flush(struct pp2_tx_desc *tx_desc)
@@ -740,17 +810,37 @@ static inline void mv_eth_skb_free(struct sk_buff *skb)
 	dev_kfree_skb_any(skb);
 }
 
+/* PPv2.1 new API - pass packet to Qset */
+/*
+static inline void mv_eth_pool_qset_put(int pool, MV_ULONG phys_addr, MV_ULONG cookie, struct pp2_rx_desc *rx_desc)
+{
+	int qset, is_grntd;
+
+	qset = (rx_desc->bmQset & PP2_RX_BUFF_QSET_NUM_MASK) >> PP2_RX_BUFF_QSET_NUM_OFFS;
+	is_grntd = (rx_desc->bmQset & PP2_RX_BUFF_TYPE_MASK) >> PP2_RX_BUFF_TYPE_OFFS;
+
+	mvBmPoolQsetPut(pool, (MV_ULONG) phys_addr, (MV_ULONG) cookie, qset, is_grntd);
+}
+*/
+
 /* Pass pkt to BM Pool or RXQ ring */
 static inline void mv_eth_pool_refill(struct bm_pool *ppool, __u32 bm,
-					MV_ULONG phys_addr, MV_ULONG cookie)
+				MV_ULONG phys_addr, MV_ULONG cookie)
 {
 	int pool = mv_eth_bm_cookie_pool_get(bm);
 	unsigned long flags = 0;
+	int grntd, qset;
 
 	/* Refill BM pool */
 	STAT_DBG(ppool->stats.bm_put++);
 	MV_ETH_LIGHT_LOCK(flags);
+#ifdef CONFIG_MV_ETH_PP2_1
+	grntd =  mv_eth_bm_cookie_grntd_get(bm);
+	qset = mv_eth_bm_cookie_qset_get(bm);
+	mvBmPoolQsetPut(pool, (MV_ULONG) phys_addr, (MV_ULONG) cookie, qset, grntd);
+#else
 	mvBmPoolPut(pool, phys_addr, cookie);
+#endif
 	MV_ETH_LIGHT_UNLOCK(flags);
 }
 
@@ -799,6 +889,7 @@ int         mv_eth_stop_internals(struct eth_port *pp);
 int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
 
 int         mv_eth_rx_reset(int port);
+int         mv_eth_txq_clean(int port, int txp, int txq);
 int         mv_eth_txp_clean(int port, int txp);
 int         mv_eth_all_ports_cleanup(void);
 int         mv_eth_all_ports_probe(void);
@@ -844,7 +935,9 @@ int         mv_eth_ctrl_txq_cpu_def(int port, int txp, int txq, int cpu);
 int         mv_eth_ctrl_flag(int port, u32 flag, u32 val);
 int         mv_eth_ctrl_tx_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_dbg_flag(int port, u32 flag, u32 val);
-int	    mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_size);
+int	    mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size);
+int         mv_eth_ctrl_txq_limits_set(int port, int txp, int txq, int hwf_size, int swf_size);
+int         mv_eth_ctrl_txq_chunk_set(int port, int txp, int txq, int chunk_size);
 int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
 int	    mv_eth_ctrl_pool_buf_num_set(int pool, int buf_num);
 int         mv_eth_ctrl_pool_detach(int port, struct bm_pool *ppool);
@@ -884,7 +977,7 @@ void mv_eth_ext_mac_ops_register(int port_id,
 		struct mv_eth_ext_mac_ops **extern_mac_ops, struct mv_netdev_notify_ops **netdev_ops);
 
 #ifdef CONFIG_MV_INCLUDE_PON
-MV_BOOL mv_pon_link_status(void);
+MV_BOOL mv_pon_link_status(MV_ETH_PORT_STATUS *link);
 MV_STATUS mv_pon_mtu_config(MV_U32 maxEth);
 MV_STATUS mv_pon_set_mac_addr(void *addr);
 MV_STATUS mv_pon_enable(void);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
index d0fccff..04a38e2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
@@ -48,17 +48,25 @@ static ssize_t plcr_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE - off, "cat             regs      - Show PLCR hardware registers\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "cat             dump      - Dump all policers configuration and status\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p        > dump      - Dump policer <p> configuration and status\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p        > v1_tb_dump- Dump policer <p> token bucket counters\n");
+
+
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo period   > period    - Set token update base period\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo 0|1      > rate      - Enable <1> or Disable <0> addition of tokens to token buckets\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo bytes    > min_pkt   - Set minimal packet length\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo 0|1      > edrop     - Enable <1> or Disable <0> early packets drop\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo mode     > mode      - Set policer mode of operation 0-bank01 1-bank10 2-parallal\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p 0|1    > enable    - Enable <1> or Disable <0> policer <p>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p 0|1    > color     - Set color mode for policer <p>: 0-blind, 1-aware\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p u t    > config    - Set token units <u> and update type <t> for policer <p>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p num    > tokens    - Set number of tokens for each update for policer <p>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p c e    > bucket    - Set commit <c> and exceed <e> bucket sizes for policer <p>\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > cpu_tr    - Set value <tr> to CPU (SWF) threshold <i>\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > hwf_tr    - Set value <tr> to HWF threshold <i>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > cpu_v0_tr - Set value <tr> to CPU (SWF) threshold <i>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > hwf_v0_tr - Set value <tr> to HWF threshold <i>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > cpu_v1_tr - Set value <tr> to CPU (SWF) threshold <i>\n");
+	off += scnprintf(buf + off, PAGE_SIZE - off, "echo i tr     > hwf_v1_tr - Set value <tr> to HWF threshold <i>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo rxq i    > rxq_tr    - Set thershold <i> to be used for RXQ <rxq>\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo txq i    > txq_tr    - Set thershold <i> to be used for TXQ <txq>\n");
 
@@ -101,35 +109,44 @@ static ssize_t plcr_dec_store(struct device *dev,
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "dump"))
+	if (!strcmp(name, "dump")) {
 		mvPp2PlcrHwDumpSingle(p);
-	else if (!strcmp(name, "period"))
+	} else if (!strcmp(name, "v1_tb_dump")) {
+		mvPp2V1PlcrTbCntDump(p);
+	} else	if (!strcmp(name, "period")) {
 		mvPp2PlcrHwBasePeriodSet(p);
-	else if (!strcmp(name, "rate"))
+	} else	if (!strcmp(name, "rate")) {
 		mvPp2PlcrHwBaseRateGenEnable(p);
-	else if (!strcmp(name, "min_pkt"))
+	} else	if (!strcmp(name, "min_pkt")) {
 		mvPp2PlcrHwMinPktLen(p);
-	else if (!strcmp(name, "edrop"))
+	} else	if (!strcmp(name, "edrop")) {
 		mvPp2PlcrHwEarlyDropSet(p);
-	else if (!strcmp(name, "enable"))
+	} else	if (!strcmp(name, "enable")) {
 		mvPp2PlcrHwEnable(p, i);
-	else  if (!strcmp(name, "color"))
+	/* only for ppv2.1 */
+	} else	if (!strcmp(name, "mode")) {
+		mvPp2PlcrHwMode(p);
+	} else  if (!strcmp(name, "color")) {
 		mvPp2PlcrHwColorModeSet(p, i);
-	else if (!strcmp(name, "config"))
+	} else	if (!strcmp(name, "config")) {
 		mvPp2PlcrHwTokenConfig(p, i, v);
-	else if (!strcmp(name, "tokens"))
+	} else	if (!strcmp(name, "tokens")) {
 		mvPp2PlcrHwTokenValue(p, i);
-	else if (!strcmp(name, "bucket"))
+	} else	if (!strcmp(name, "bucket")) {
 		mvPp2PlcrHwBucketSizeSet(p, i, v);
-	else if (!strcmp(name, "cpu_tr"))
-		mvPp2PlcrHwCpuThreshSet(p, i);
-	else if (!strcmp(name, "hwf_tr"))
-		mvPp2PlcrHwHwfThreshSet(p, i);
-	else if (!strcmp(name, "rxq_tr"))
+	} else	if (!strcmp(name, "cpu_v0_tr")) {
+		mvPp2V0PlcrHwCpuThreshSet(p, i);
+	} else	if (!strcmp(name, "cpu_v1_tr")) {
+		mvPp2V1PlcrHwCpuThreshSet(p, i);
+	} else	if (!strcmp(name, "hwf_v0_tr")) {
+		mvPp2V0PlcrHwHwfThreshSet(p, i);
+	} else	if (!strcmp(name, "hwf_v1_tr")) {
+		mvPp2V1PlcrHwHwfThreshSet(p, i);
+	} else	if (!strcmp(name, "rxq_tr")) {
 		mvPp2PlcrHwRxqThreshSet(p, i);
-	else if (!strcmp(name, "txq_tr"))
+	} else	if (!strcmp(name, "txq_tr")) {
 		mvPp2PlcrHwTxqThreshSet(p, i);
-	else
+	} else
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
 
 	local_irq_restore(flags);
@@ -141,39 +158,50 @@ static ssize_t plcr_dec_store(struct device *dev,
 }
 
 
-static DEVICE_ATTR(help,	  S_IRUSR, plcr_show, NULL);
-static DEVICE_ATTR(regs,	  S_IRUSR, plcr_show, NULL);
-static DEVICE_ATTR(dump,	  S_IRUSR | S_IWUSR, plcr_show, plcr_dec_store);
-static DEVICE_ATTR(period,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(rate,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(min_pkt,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(edrop,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(enable,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(color,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(config,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(tokens,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(bucket,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(cpu_tr,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(hwf_tr,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(rxq_tr,	  S_IWUSR, NULL,     plcr_dec_store);
-static DEVICE_ATTR(txq_tr,	  S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(help,          S_IRUSR, plcr_show, NULL);
+static DEVICE_ATTR(regs,          S_IRUSR, plcr_show, NULL);
+static DEVICE_ATTR(dump,          S_IRUSR | S_IWUSR, plcr_show, plcr_dec_store);
+
+static DEVICE_ATTR(v1_tb_dump,    S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(period,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(rate,          S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(min_pkt,       S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(edrop,         S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(enable,        S_IWUSR, NULL,     plcr_dec_store);
+/*mode - only for ppv2.1 */
+static DEVICE_ATTR(mode  ,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(color,         S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(config,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(tokens,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(bucket,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(cpu_v0_tr,     S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(hwf_v0_tr,     S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(cpu_v1_tr,     S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(hwf_v1_tr,     S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(rxq_tr,        S_IWUSR, NULL,     plcr_dec_store);
+static DEVICE_ATTR(txq_tr,        S_IWUSR, NULL,     plcr_dec_store);
 
 
 static struct attribute *plcr_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_regs.attr,
 	&dev_attr_dump.attr,
+	&dev_attr_v1_tb_dump.attr,
 	&dev_attr_period.attr,
 	&dev_attr_rate.attr,
 	&dev_attr_min_pkt.attr,
 	&dev_attr_edrop.attr,
 	&dev_attr_enable.attr,
+	/* mode - only for ppv2.1 */
+	&dev_attr_mode.attr,
 	&dev_attr_color.attr,
 	&dev_attr_config.attr,
 	&dev_attr_tokens.attr,
 	&dev_attr_bucket.attr,
-	&dev_attr_cpu_tr.attr,
-	&dev_attr_hwf_tr.attr,
+	&dev_attr_cpu_v0_tr.attr,
+	&dev_attr_hwf_v0_tr.attr,
+	&dev_attr_cpu_v1_tr.attr,
+	&dev_attr_hwf_v1_tr.attr,
 	&dev_attr_rxq_tr.attr,
 	&dev_attr_txq_tr.attr,
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
index 7f488fa..1a45b74 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
@@ -42,29 +42,32 @@ static ssize_t mv_prs_high_help(char *b)
 {
 	int o = 0;
 
-
-	o += scnprintf(b+o, PAGE_SIZE-o, "cat                dump      - Dump all valid HW entries\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c d e   > flow      - Add flow entry to HW\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "                               id <a>, result <b> mask <c>, port <d>, tcam index <e>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b [1|0]   > vlan1     - Add/Delete single vlan: tpid1 <a>, port map <b>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c [1|0] > vlan2     - Add/Delete double vlan: tpid1 <a>, tpid2 <b>, port map <c>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c d e   > vlan3     - Triple vlan entry tpid1 <a>, tpid2 <b>, tpid3 <c>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "                               ports bitmap <d>, add/del <e=1/0>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c d e f > mac_range - Add mac entry to HW\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "                               port map <a>, da <b> mask <c>, ri <d> mask <e>, end <f>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c       > mac_del   - Delete mac entry from HW\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "                               port map <a>, da <b>, da mask <c>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b c d e   > etype_add - Add ethertype entry to HW\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "                               port map <a>, etype <b>, ri <c> mask <d>, end <e>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo a b         > etype_del - Delete etype <b> entry from HW for ports in port map <a>\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo p [0|1|2|3] > tag       - None[0], Marvell Header[1], DSA tag[2], EDSA tag[3]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cd                 debug       - move to parser low level sysfs directory\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat                dump        - dump all valid HW entries\n");
+
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c d e     > flow      - Add flow entry to HW\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "                                 flowId <a>, result <b>, result mask <c>, port <d>, tcam index <e>.\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b [1|0]   > vlan1     - Add/Delete single vlan: tpid1 <a>, port map <b>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c [1|0] > vlan2     - Add/Delete double vlan: tpid1 <a>, tpid2 <b>, port map <c>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c d e   > vlan3     - Triple vlan entry tpid1 <a>, tpid2 <b>, tpid3 <c>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "                               ports bitmap <d>, add/del <e=1/0>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo 1           > vlan_del  - Delete all vlan entries.\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c d e f > mac_range - Add mac entry to HW\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "                               port map <a>, da <b> mask <c>, ri <d> mask <e>, end <f>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c       > mac_del   - Delete mac entry from HW\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "                               port map <a>, da <b>, da mask <c>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b c d e   > etype_add - Add ethertype entry to HW\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "                               port map <a>, etype <b>, ri <c> mask <d>, end <e>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo a b         > etype_del - Delete etype <b> entry from HW for ports in port map <a>\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo p [0|1|2|3] > tag       - None[0], Marvell Header[1], DSA tag[2], EDSA tag[3]\n");
 	/* etypeDsaMod and etypeDsa meaningless if  port in DSA/EDSA mode */
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo p {0|1}     > etypeMod  - Expected EtherType DSA[0]/EDSA[1] if port tag is not DSA/EDSA\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo p {0|1}     > etypeMod  - Expected EtherType DSA[0]/EDSA[1] if port tag is not DSA/EDSA\n");
 	/* typeDsa meaningless if  all ports in DSA/EDSA mode */
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [hex]       > etypeDsa  - Expected DSA/EDSA ethertype [hex]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [hex]       > etypeDsa  - Expected DSA/EDSA ethertype [hex]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
 	return o;
 }
 
@@ -108,6 +111,8 @@ static ssize_t mv_prs_high_store_unsigned(struct device *dev,
 		mvPp2PrsDoubleVlan(a, b, c, d);
 	else if (!strcmp(name, "vlan3"))
 		mvPp2PrsTripleVlan(a, b, c, d, e);
+	else if (!strcmp(name, "vlan_del"))
+		mvPp2PrsVlanAllDel();
 	else if (!strcmp(name, "etype_add"))
 		mvPrsEthTypeSet(a, b, c, d, e);
 	else if (!strcmp(name, "etype_del"))
@@ -172,6 +177,7 @@ static DEVICE_ATTR(flow,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned)
 static DEVICE_ATTR(vlan1,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
 static DEVICE_ATTR(vlan2,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
 static DEVICE_ATTR(vlan3,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
+static DEVICE_ATTR(vlan_del,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
 static DEVICE_ATTR(etype_add,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
 static DEVICE_ATTR(etype_del,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_unsigned);
 static DEVICE_ATTR(mac_range,		S_IWUSR, mv_prs_high_show, mv_prs_high_store_str);
@@ -189,6 +195,7 @@ static struct attribute *prs_high_attrs[] = {
 	&dev_attr_vlan1.attr,
 	&dev_attr_vlan2.attr,
 	&dev_attr_vlan3.attr,
+	&dev_attr_vlan_del.attr,
 	&dev_attr_etype_add.attr,
 	&dev_attr_etype_del.attr,
 	&dev_attr_mac_range.attr,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
index dacbb5f..9ea2845 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
@@ -48,6 +48,9 @@ static ssize_t mv_prs_low_help(char *buf)
 	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          sw_dump       - dump parser SW entry.\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_dump       - dump all valid HW entries\n");
 	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_regs       - dump parser registers.\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_hits       - dump non zeroed hit counters and the associated HW entries\n");
+#endif
 	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_write    - write parser SW entry into HW place <id>.\n");
@@ -93,6 +96,8 @@ static ssize_t mv_prs_low_show(struct device *dev,
 		mvPp2PrsSwDump(&pe);
 	else if (!strcmp(name, "hw_regs"))
 		mvPp2PrsHwRegsDump();
+	else if (!strcmp(name, "hw_hits"))
+		mvPp2V1PrsHwHitsDump();
 	else
 		off += mv_prs_low_help(buf);
 
@@ -174,11 +179,9 @@ static ssize_t mv_prs_low_store_unsigned(struct device *dev,
 	else if (!strcmp(name, "s_next_lu"))
 		mvPp2PrsSwSramNextLuSet(&pe, a);
 	else if (!strcmp(name, "s_lu_done"))
-		(a == 1) ? 	mvPp2PrsSwSramLuDoneSet(&pe) :
-				mvPp2PrsSwSramLuDoneClear(&pe);
+		(a == 1) ? mvPp2PrsSwSramLuDoneSet(&pe) : mvPp2PrsSwSramLuDoneClear(&pe);
 	else if (!strcmp(name, "s_fid_gen"))
-		(a == 1) ?	mvPp2PrsSwSramFlowidGenSet(&pe) :
-				mvPp2PrsSwSramFlowidGenClear(&pe);
+		(a == 1) ? mvPp2PrsSwSramFlowidGenSet(&pe) : mvPp2PrsSwSramFlowidGenClear(&pe);
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -196,13 +199,14 @@ static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_low_show, NULL);
 static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_prs_low_show, NULL);
 static DEVICE_ATTR(help,		S_IRUSR, mv_prs_low_show, NULL);
 static DEVICE_ATTR(hw_regs,		S_IRUSR, mv_prs_low_show, NULL);
-static DEVICE_ATTR(sw_clear,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_write,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_read,     	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_inv,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_inv_all, 		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_hits,		S_IRUSR, mv_prs_low_show, NULL);
+static DEVICE_ATTR(sw_clear,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_write,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_read,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(hw_inv_all,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
 static DEVICE_ATTR(t_byte,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_port,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
+static DEVICE_ATTR(t_port,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
 static DEVICE_ATTR(t_port_map,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
 static DEVICE_ATTR(t_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
 static DEVICE_ATTR(t_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
@@ -218,33 +222,34 @@ static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_sign
 
 
 static struct attribute *prs_low_attrs[] = {
-    &dev_attr_hw_dump.attr,
-    &dev_attr_sw_dump.attr,
-    &dev_attr_hw_regs.attr,
-    &dev_attr_hw_write.attr,
-    &dev_attr_hw_read.attr,
-    &dev_attr_hw_inv.attr,
-    &dev_attr_hw_inv_all.attr,
-    &dev_attr_sw_clear.attr,
-    &dev_attr_t_byte.attr,
-    &dev_attr_t_port.attr,
-    &dev_attr_t_port_map.attr,
-    &dev_attr_t_ai.attr,
-    &dev_attr_t_lu.attr,
-    &dev_attr_s_ri.attr,
-    &dev_attr_s_ai.attr,
-    &dev_attr_s_next_lu.attr,
-    &dev_attr_s_shift.attr,
-    &dev_attr_s_offs.attr,
-    &dev_attr_s_lu_done.attr,
-    &dev_attr_s_fid_gen.attr,
-    &dev_attr_hw_frst_itr.attr,
-    &dev_attr_help.attr,
-    NULL
+	&dev_attr_hw_dump.attr,
+	&dev_attr_sw_dump.attr,
+	&dev_attr_hw_hits.attr,
+	&dev_attr_hw_regs.attr,
+	&dev_attr_hw_write.attr,
+	&dev_attr_hw_read.attr,
+	&dev_attr_hw_inv.attr,
+	&dev_attr_hw_inv_all.attr,
+	&dev_attr_sw_clear.attr,
+	&dev_attr_t_byte.attr,
+	&dev_attr_t_port.attr,
+	&dev_attr_t_port_map.attr,
+	&dev_attr_t_ai.attr,
+	&dev_attr_t_lu.attr,
+	&dev_attr_s_ri.attr,
+	&dev_attr_s_ai.attr,
+	&dev_attr_s_next_lu.attr,
+	&dev_attr_s_shift.attr,
+	&dev_attr_s_offs.attr,
+	&dev_attr_s_lu_done.attr,
+	&dev_attr_s_fid_gen.attr,
+	&dev_attr_hw_frst_itr.attr,
+	&dev_attr_help.attr,
+	NULL
 };
 
 static struct attribute_group prs_low_group = {
-	.name = "prsLow",
+	.name = "debug",
 	.attrs = prs_low_attrs,
 };
 
@@ -266,4 +271,3 @@ int mv_pp2_prs_low_sysfs_exit(struct kobject *pp2_kobj)
 	return 0;
 }
 
-
diff --git a/arch/arm/plat-armada/mv_hal/eth/mvEth.h b/arch/arm/plat-armada/mv_hal/eth/mvEth.h
index f5bee43..787ea7c 100644
--- a/arch/arm/plat-armada/mv_hal/eth/mvEth.h
+++ b/arch/arm/plat-armada/mv_hal/eth/mvEth.h
@@ -165,7 +165,6 @@ extern "C" {
 		MV_ETH_PORT_SPEED speed;
 		MV_ETH_PORT_DUPLEX duplex;
 		MV_ETH_PORT_FC flowControl;
-
 	} MV_ETH_PORT_STATUS;
 
 	typedef enum {
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
index 10de501..db9526e 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
@@ -74,6 +74,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 static MV_BM_POOL	mvBmPools[MV_BM_POOLS];
 
+static MV_BM_QSET	mvBmQsets[MV_BM_QSET_MAX];
+static int		mvBmRxqToQsetLong[MV_BM_QSET_PRIO_MAX];
+static int		mvBmRxqToQsetShort[MV_BM_QSET_PRIO_MAX];
+static int		mvBmTxqToQsetLong[MV_BM_QSET_PRIO_MAX];
+static int		mvBmTxqToQsetShort[MV_BM_QSET_PRIO_MAX];
+
 /* Initialize Hardware Buffer management unit */
 MV_STATUS mvBmInit()
 {
@@ -88,6 +94,24 @@ MV_STATUS mvBmInit()
 
 	memset(mvBmPools, 0, sizeof(mvBmPools));
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Enable BM priority */
+	mvPp2WrReg(MV_BM_PRIO_CTRL_REG, 1);
+
+	/* Initialize Qsets */
+	for (i = 0; i < MV_BM_QSET_MAX; i++) {
+		mvBmQsets[i].id = i;
+		mvBmQsets[i].pool = -1;
+	}
+
+	for (i = 0; i < MV_BM_QSET_PRIO_MAX; i++) {
+		mvBmRxqToQsetLong[i] = -1;
+		mvBmRxqToQsetShort[i] = -1;
+		mvBmTxqToQsetLong[i] = -1;
+		mvBmTxqToQsetShort[i] = -1;
+	}
+#endif
+
 	return MV_OK;
 }
 
@@ -128,40 +152,8 @@ MV_STATE mvBmPoolStateGet(int pool)
 	return state;
 }
 
-void mvBmPoolEnable(int pool)
-{
-	/* validate poolId */
-	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
-		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
-		return;
-	}
-	/* TODO */
-}
-
-void mvBmPoolDisable(int pool)
-{
-	/* validate poolId */
-	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
-		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
-		return;
-	}
-	/* TODO */
-}
-
-MV_BOOL mvBmPoolIsEnabled(int pool)
-{
-	/* validate poolId */
-	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
-		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
-		return MV_FALSE;
-	}
-	/* TODO */
-
-	return MV_TRUE;
-}
-
 /* Configure BM specific pool of "capacity" size. */
-MV_STATUS mvBmPoolInit(int pool, MV_ULONG physPoolBase, int capacity)
+MV_STATUS mvBmPoolInit(int pool, MV_U32 *virtPoolBase, MV_ULONG physPoolBase, int capacity)
 {
 	MV_BM_POOL	*pBmPool;
 
@@ -200,9 +192,37 @@ MV_STATUS mvBmPoolInit(int pool, MV_ULONG physPoolBase, int capacity)
 	pBmPool->pool = pool;
 	pBmPool->capacity = capacity;
 	pBmPool->physAddr = physPoolBase;
+	pBmPool->pVirt = virtPoolBase;
 
 	mvBmPoolControl(pool, MV_STOP);
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Init Qsets list for this pool */
+	pBmPool->qsets = mvListCreate();
+	if (pBmPool->qsets == NULL) {
+		mvOsPrintf("%s: failed to create Qsets list\n", __func__);
+		return MV_FAIL;
+	}
+
+	/* Assign and init default Qset for this pool */
+	pBmPool->defQset = &mvBmQsets[MV_BM_POOL_QSET_BASE + pool];
+
+	mvBmQsetCreate(pBmPool->defQset->id, pool);
+	mvBmQsetBuffMaxSet(pBmPool->defQset->id, 0, 0);
+	mvBmQsetBuffCountersSet(pBmPool->defQset->id, 0, 0);
+
+	/* Assign and init MC Qset for this pool */
+	pBmPool->mcQset = &mvBmQsets[pool];
+
+	mvBmQsetCreate(pBmPool->mcQset->id, pool);
+	mvBmQsetBuffMaxSet(pBmPool->mcQset->id, 0, 0);
+	mvBmQsetBuffCountersSet(pBmPool->mcQset->id, 0, 0);
+
+	/* Init default priority counters for this pool */
+	mvBmPoolBuffNumSet(pool, 0);
+	mvBmPoolBuffCountersSet(pool, 0, 0);
+#endif
+
 	/* Set poolBase address */
 	mvPp2WrReg(MV_BM_POOL_BASE_REG(pool), physPoolBase);
 
@@ -228,7 +248,7 @@ MV_STATUS mvBmPoolBufSizeSet(int pool, int buf_size)
 	return MV_OK;
 }
 
-MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num)
+MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num, int add)
 {
 	MV_BM_POOL *pBmPool;
 
@@ -239,13 +259,502 @@ MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num)
 	}
 
 	pBmPool = &mvBmPools[pool];
-	if (pBmPool->bufSize == 0) {
-		mvOsPrintf("bmPoolId = %d has unknown buf_size  \n", pool);
+
+	if (add)
+		pBmPool->bufNum += buf_num;
+	else
+		pBmPool->bufNum -= buf_num;
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Update max buffers of default Qset, MC Qset and pool shared */
+	if (add) {
+		mvBmQsetBuffMaxSet(pBmPool->defQset->id,
+			pBmPool->defQset->maxGrntd, pBmPool->defQset->maxShared + buf_num);
+		mvBmQsetBuffMaxSet(pBmPool->mcQset->id,
+			pBmPool->mcQset->maxGrntd, pBmPool->mcQset->maxShared + buf_num);
+		mvBmPoolBuffNumSet(pool, pBmPool->maxShared + buf_num);
+	} else {
+		mvBmQsetBuffMaxSet(pBmPool->defQset->id,
+			pBmPool->defQset->maxGrntd, pBmPool->defQset->maxShared - buf_num);
+		mvBmQsetBuffMaxSet(pBmPool->mcQset->id,
+			pBmPool->mcQset->maxGrntd, pBmPool->mcQset->maxShared - buf_num);
+		mvBmPoolBuffNumSet(pool, pBmPool->maxShared - buf_num);
+	}
+#endif
+
+	return MV_OK;
+}
+
+/******************************************************************************/
+/* BM priority API */
+MV_STATUS mvBmQsetCreate(int qset, int pool)
+{
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("%s: bmPoolId = %d is invalid\n", __func__, pool);
+		return MV_BAD_PARAM;
+	}
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+	if (mvBmQsets[qset].pool != -1) {
+		mvOsPrintf("%s: qset %d is already attached to pool %d\n", __func__, qset, mvBmQsets[qset].pool);
+		return MV_FAIL;
+	}
+
+	mvBmQsets[qset].pool = pool;
+	mvBmQsets[qset].refCount = 0;
+	mvBmQsets[qset].maxShared = 0;
+	mvBmQsets[qset].maxGrntd = 0;
+
+	mvListAddHead(mvBmPools[pool].qsets, (MV_ULONG)qset);
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmQsetDelete(int qset)
+{
+	int pool;
+
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+
+	if (mvBmQsets[qset].refCount > 0) {
+		mvOsPrintf("%s: qset number %d has RXQs/TXQs that use it\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	pool = mvBmQsets[qset].pool;
+	if (pool != -1) {
+		MV_LIST_ELEMENT *elm;
+
+		if (qset == mvBmDefaultQsetNumGet(pool)) {
+			mvOsPrintf("%s: Can't delete Bm pool's default Qset (%d)\n", __func__, qset);
+			return MV_BAD_PARAM;
+		}
+
+		elm = mvListFind(mvBmPools[pool].qsets, (MV_ULONG)qset);
+
+		mvListDel(elm);
+	}
+
+	mvBmQsets[qset].pool = -1;
+
+	return MV_OK;
+}
+
+int mvBmDefaultQsetNumGet(int pool)
+{
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("%s: bmPoolId = %d is invalid\n", __func__, pool);
+		return MV_BAD_PARAM;
+	}
+
+	return mvBmPools[pool].defQset->id;
+}
+
+MV_STATUS mvBmRxqToQsetLongClean(int queue)
+{
+	int oldQset;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+
+	oldQset = mvBmRxqToQsetLong[queue];
+	if (oldQset != -1)
+		mvBmQsets[oldQset].refCount--;
+
+	mvBmRxqToQsetLong[queue] = -1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmRxqToQsetShortClean(int queue)
+{
+	int oldQset;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+
+	oldQset = mvBmRxqToQsetShort[queue];
+	if (oldQset != -1)
+		mvBmQsets[oldQset].refCount--;
+
+	mvBmRxqToQsetShort[queue] = -1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmTxqToQsetLongClean(int queue)
+{
+	int oldQset;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+
+	oldQset = mvBmTxqToQsetLong[queue];
+	if (oldQset != -1)
+		mvBmQsets[oldQset].refCount--;
+
+	mvBmTxqToQsetLong[queue] = -1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmTxqToQsetShortClean(int queue)
+{
+	int oldQset;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+
+	oldQset = mvBmTxqToQsetShort[queue];
+	if (oldQset != -1)
+		mvBmQsets[oldQset].refCount--;
+
+	mvBmTxqToQsetShort[queue] = -1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmRxqToQsetLongSet(int queue, int qset)
+{
+	MV_U32 regVal;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+	if (mvBmQsets[qset].pool == -1) {
+		mvOsPrintf("%s: qset %d is not attached to BM pool\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	/* Same Qset */
+	if (mvBmRxqToQsetLong[queue] == qset)
+		return MV_OK;
+
+	/* Remove old Qset */
+	if (mvBmRxqToQsetLong[queue] != -1) {
+		int oldQset = mvBmRxqToQsetLong[queue];
+
+		/* Check that queue is using the same BM pool */
+		if (mvBmQsets[qset].pool != mvBmQsets[oldQset].pool) {
+			mvOsPrintf("%s: queue %d is attached BM pool %d, but new qset %d is attached to BM pool %d\n",
+				__func__, queue, mvBmQsets[oldQset].pool, qset, mvBmQsets[qset].pool);
+			return MV_FAIL;
+		}
+		mvBmQsets[oldQset].refCount--;
+	}
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, queue);
+
+	regVal = mvPp2RdReg(MV_BM_CPU_QSET_REG);
+	regVal &= ~MV_BM_CPU_LONG_QSET_MASK;
+	regVal |= ((qset << MV_BM_CPU_LONG_QSET_OFFS) & MV_BM_CPU_LONG_QSET_MASK);
+
+	mvPp2WrReg(MV_BM_CPU_QSET_REG, regVal);
+
+	mvBmRxqToQsetLong[queue] = qset;
+	mvBmQsets[qset].refCount++;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmRxqToQsetShortSet(int queue, int qset)
+{
+	MV_U32 regVal;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+	if (mvBmQsets[qset].pool == -1) {
+		mvOsPrintf("%s: qset %d is not attached to BM pool\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	/* Same Qset */
+	if (mvBmRxqToQsetShort[queue] == qset)
+		return MV_OK;
+
+	/* Remove old Qset */
+	if (mvBmRxqToQsetShort[queue] != -1) {
+		int oldQset = mvBmRxqToQsetShort[queue];
+
+		/* Check that queue is using the same BM pool */
+		if (mvBmQsets[qset].pool != mvBmQsets[oldQset].pool) {
+			mvOsPrintf("%s: queue %d is attached BM pool %d, but new qset %d is attached to BM pool %d\n",
+				__func__, queue, mvBmQsets[oldQset].pool, qset, mvBmQsets[qset].pool);
+			return MV_FAIL;
+		}
+		mvBmQsets[qset].refCount--;
+	}
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, queue);
+
+	regVal = mvPp2RdReg(MV_BM_CPU_QSET_REG);
+	regVal &= ~MV_BM_CPU_SHORT_QSET_MASK;
+	regVal |= ((qset << MV_BM_CPU_SHORT_QSET_OFFS) & MV_BM_CPU_SHORT_QSET_MASK);
+
+	mvPp2WrReg(MV_BM_CPU_QSET_REG, regVal);
+
+	mvBmRxqToQsetShort[queue] = qset;
+	mvBmQsets[qset].refCount++;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmTxqToQsetLongSet(int queue, int qset)
+{
+	MV_U32 regVal;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+	if (mvBmQsets[qset].pool == -1) {
+		mvOsPrintf("%s: qset %d is not attached to BM pool\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	/* Same Qset */
+	if (mvBmTxqToQsetLong[queue] == qset)
+		return MV_OK;
+
+	/* Remove old Qset */
+	if (mvBmTxqToQsetLong[queue] != -1) {
+		int oldQset = mvBmTxqToQsetLong[queue];
+
+		/* Check that queue is using the same BM pool */
+		if (mvBmQsets[qset].pool != mvBmQsets[oldQset].pool) {
+			mvOsPrintf("%s: queue %d is attached BM pool %d, but new qset %d is attached to BM pool %d\n",
+				__func__, queue, mvBmQsets[oldQset].pool, qset, mvBmQsets[qset].pool);
+			return MV_FAIL;
+		}
+		mvBmQsets[qset].refCount--;
+	}
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, queue);
+
+	regVal = mvPp2RdReg(MV_BM_HWF_QSET_REG);
+	regVal &= ~MV_BM_HWF_LONG_QSET_MASK;
+	regVal |= ((qset << MV_BM_HWF_LONG_QSET_OFFS) & MV_BM_HWF_LONG_QSET_MASK);
+
+	mvPp2WrReg(MV_BM_HWF_QSET_REG, regVal);
+
+	mvBmTxqToQsetLong[queue] = qset;
+	mvBmQsets[qset].refCount++;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmTxqToQsetShortSet(int queue, int qset)
+{
+	MV_U32 regVal;
+
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return MV_BAD_PARAM;
+	}
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+	if (mvBmQsets[qset].pool == -1) {
+		mvOsPrintf("%s: qset %d is not attached to BM pool\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	/* Same Qset */
+	if (mvBmTxqToQsetShort[queue] == qset)
+		return MV_OK;
+
+	/* Remove old Qset */
+	if (mvBmTxqToQsetShort[queue] != -1) {
+		int oldQset = mvBmTxqToQsetShort[queue];
+
+		/* Check that queue is using the same BM pool */
+		if (mvBmQsets[qset].pool != mvBmQsets[oldQset].pool) {
+			mvOsPrintf("%s: queue %d is attached BM pool %d, but new qset %d is attached to BM pool %d\n",
+				__func__, queue, mvBmQsets[oldQset].pool, qset, mvBmQsets[qset].pool);
+			return MV_FAIL;
+		}
+		mvBmQsets[qset].refCount--;
+	}
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, queue);
+
+	regVal = mvPp2RdReg(MV_BM_HWF_QSET_REG);
+	regVal &= ~MV_BM_HWF_SHORT_QSET_MASK;
+	regVal |= ((qset << MV_BM_HWF_SHORT_QSET_OFFS) & MV_BM_HWF_SHORT_QSET_MASK);
+
+	mvPp2WrReg(MV_BM_HWF_QSET_REG, regVal);
+
+	mvBmTxqToQsetShort[queue] = qset;
+	mvBmQsets[qset].refCount++;
+
+	return MV_OK;
+}
+
+int mvBmRxqToQsetLongGet(int queue)
+{
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return -1;
+	}
+
+	return mvBmRxqToQsetLong[queue];
+}
+
+int mvBmRxqToQsetShortGet(int queue)
+{
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return -1;
+	}
+
+	return mvBmRxqToQsetShort[queue];
+}
+
+int mvBmTxqToQsetLongGet(int queue)
+{
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return -1;
+	}
+
+	return mvBmTxqToQsetLong[queue];
+}
+
+int mvBmTxqToQsetShortGet(int queue)
+{
+	if (queue < 0 || queue > MV_BM_PRIO_IDX_MASK) {
+		mvOsPrintf("%s: Bad queue number = %d\n", __func__, queue);
+		return -1;
+	}
+
+	return mvBmTxqToQsetShort[queue];
+}
+
+MV_STATUS mvBmQsetBuffMaxSet(int qset, int maxGrntd, int maxShared)
+{
+	MV_U32 regVal = 0;
+	int pool, delta;
+	MV_BM_POOL *pBmPool;
+	MV_BM_QSET *pQset;
+
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+
+	pQset = &mvBmQsets[qset];
+	pool = pQset->pool;
+	if (pool == -1) {
+		mvOsPrintf("%s: Qset (%d) is not attached to any BM pool\n", __func__, qset);
+		return MV_FAIL;
+	}
+
+	/* number of requested guaranteed buffers from BM pool (after Qset max update) */
+	delta = maxGrntd - pQset->maxGrntd;
+
+	pBmPool = &mvBmPools[pool];
+	if (pBmPool->maxShared < delta) {
+		mvOsPrintf("%s: Not enough buffers (%d) in BM pool %d to guarantee %d buffer for qset %d\n",
+				__func__, pBmPool->maxShared, pool, delta, qset);
+		return MV_FAIL;
+	}
+
+	/* Update BM pool shared buffers num */
+	mvBmPoolBuffNumSet(pool, pBmPool->maxShared + delta);
+
+	pQset->maxShared = maxShared;
+	pQset->maxGrntd = maxGrntd;
+
+	regVal |= maxShared << MV_BM_QSET_MAX_SHARED_OFFS;
+	regVal |= maxGrntd << MV_BM_QSET_MAX_GRNTD_OFFS;
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, qset);
+	mvPp2WrReg(MV_BM_QSET_SET_MAX_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmQsetBuffCountersSet(int qset, int cntrGrntd, int cntrShared)
+{
+	MV_U32 regVal = 0;
+
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
 		return MV_BAD_PARAM;
 	}
-	pBmPool->bufNum += buf_num;
+
+	regVal |= cntrShared << MV_BM_QSET_CNTR_SHARED_OFFS;
+	regVal |= cntrGrntd << MV_BM_QSET_CNTR_GRNTD_OFFS;
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, qset);
+	mvPp2WrReg(MV_BM_QSET_SET_CNTRS_REG, regVal);
+
+	return MV_OK;
+}
+
+/* Set number of SHARED buffers for this pool */
+MV_STATUS mvBmPoolBuffNumSet(int pool, int buffNum)
+{
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid\n", pool);
+		return MV_BAD_PARAM;
+	}
+
+	mvBmPools[pool].maxShared = buffNum;
+
+	mvPp2WrReg(MV_BM_POOL_MAX_SHARED_REG(pool), buffNum);
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmPoolBuffCountersSet(int pool, int cntrGrntd, int cntrShared)
+{
+	MV_U32 regVal = 0;
+
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid\n", pool);
+		return MV_BAD_PARAM;
+	}
+
+
+	regVal |= cntrShared << MV_BM_POOL_CNTR_SHARED_OFFS;
+	regVal |= cntrGrntd << MV_BM_POOL_CNTR_GRNTD_OFFS;
+
+	mvPp2WrReg(MV_BM_POOL_SET_CNTRS_REG(pool), regVal);
+
 	return MV_OK;
 }
+/******************************************************************************/
 
 void mvBmPoolPrint(int pool)
 {
@@ -277,6 +786,12 @@ void mvBmStatus(void)
 	for (i = 0; i < MV_BM_POOLS; i++)
 		mvBmPoolPrint(i);
 }
+/* PPv2.1 MAS 3.20 new counters */
+void mvBmV1PoolDropCntDump(int pool)
+{
+	mvPp2PrintReg2(MV_BM_V1_PKT_DROP_REG(pool), "MV_BM_V1_PKT_DROP_REG", pool);
+	mvPp2PrintReg2(MV_BM_V1_PKT_MC_DROP_REG(pool), "MV_BM_V1_PKT_MC_DROP_REG", pool);
+}
 
 void mvBmPoolDump(int pool, int mode)
 {
@@ -333,4 +848,89 @@ void mvBmPoolDump(int pool, int mode)
 */
 }
 
+/******************************************************************************/
+MV_STATUS mvBmQsetShow(int qset)
+{
+	MV_BM_QSET *pQset;
+	MV_U32 regVal;
+
+	if (qset < 0 || qset >= MV_BM_QSET_MAX) {
+		mvOsPrintf("%s: Bad qset number = %d\n", __func__, qset);
+		return MV_BAD_PARAM;
+	}
+
+	pQset = &mvBmQsets[qset];
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, qset);
+	regVal = mvPp2RdReg(MV_BM_QSET_SET_MAX_REG);
+
+	mvOsPrintf("Qset[%03d]: pool=%d,  refCount=%03d,  maxShared=%04d,  maxGrntd=%04d,  MaxBuff reg(0x%x)=0x%08x\n",
+			qset, pQset->pool, pQset->refCount, pQset->maxShared,
+			pQset->maxGrntd, MV_BM_QSET_SET_MAX_REG, regVal);
+
+	return MV_OK;
+}
+
+static MV_BOOL mvBmPriorityEn(void)
+{
+	return ((mvPp2RdReg(MV_BM_PRIO_CTRL_REG) == 0) ? MV_FALSE : MV_TRUE);
+}
+
+void mvBmQsetConfigDumpAll(void)
+{
+	int qset;
+
+	if (!mvBmPriorityEn())
+		mvOsPrintf("Note: The buffers priority algorithms is disabled.\n");
+
+	for (qset = 0; qset < MV_BM_QSET_MAX; qset++) {
+		/* skip qsets that not attached to any pool */
+		if (mvBmQsets[qset].pool == -1)
+			continue;
+
+		mvBmQsetShow(qset);
+	}
+}
+
+static void mvBmQueueMapDump(int queue)
+{
+	unsigned int regVal, shortQset, longQset;
+
+	mvOsPrintf("-------- queue #%d --------\n", queue);
+
+	mvPp2WrReg(MV_BM_PRIO_IDX_REG, queue);
+	regVal = mvPp2RdReg(MV_BM_CPU_QSET_REG);
+
+	shortQset = ((regVal & (MV_BM_CPU_SHORT_QSET_MASK)) >> MV_BM_CPU_SHORT_QSET_OFFS);
+	longQset = ((regVal & (MV_BM_CPU_LONG_QSET_MASK)) >> MV_BM_CPU_LONG_QSET_OFFS);
+	mvOsPrintf("CPU SHORT QSET = 0x%02x\n", shortQset);
+	mvOsPrintf("CPU LONG QSET  = 0x%02x\n", longQset);
+
+	regVal = mvPp2RdReg(MV_BM_HWF_QSET_REG);
+	shortQset = ((regVal & (MV_BM_HWF_SHORT_QSET_MASK)) >> MV_BM_HWF_SHORT_QSET_OFFS);
+	longQset = ((regVal & (MV_BM_HWF_LONG_QSET_MASK)) >> MV_BM_HWF_LONG_QSET_OFFS);
+	mvOsPrintf("HWF SHORT QSET = 0x%02x\n", shortQset);
+	mvOsPrintf("HWF LONG QSET  = 0x%02x\n", longQset);
+}
+
+void mvBmQueueMapDumpAll(void)
+{
+	int queue;
+
+	if (!mvBmPriorityEn())
+		mvOsPrintf("Note: The buffers priority algorithms is disabled.\n");
+
+	for (queue = 0; queue < 256 /* TODO MAX(RXQ_NUM, TXQ_NUM)*/; queue++)
+		mvBmQueueMapDump(queue);
+}
+
+/*
+void mvBmPoolConfigDumpAll(void)
+
+	regVal = mvPp2RdReg(MV_BM_POOL_MAX_SHARED_REG(pool));
+
+	maxSherd = ((regVal & MV_BM_POOL_MAX_SHARED_MASK) >> MV_BM_POOL_MAX_SHARED_OFFS);
+	mvOsPrintf("POOL MAX SHERD = 0x%04x\n", maxSherd);
+	mvOsPrintf("\n");
+*/
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
index bb01023..33f92c9 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
@@ -69,6 +69,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvTypes.h"
 #include "mvCommon.h"
 #include "mvStack.h"
+#include "mvList.h"
 #include "mv802_3.h"
 #include "pp2/common/mvPp2Common.h"
 #include "mvBmRegs.h"
@@ -87,12 +88,24 @@ typedef struct {
 } MV_BM_CONFIG;
 
 typedef struct {
-	int         pool;
-	int         capacity;
-	int         bufNum;
-	int         bufSize;
-	MV_U32      *pVirt;
-	MV_ULONG    physAddr;
+	int id;
+	int pool;
+	int refCount;
+	int maxShared;
+	int maxGrntd;
+} MV_BM_QSET;
+
+typedef struct {
+	int		pool;
+	int		capacity;
+	int		bufNum;
+	int		bufSize;
+	MV_U32		*pVirt;
+	MV_ULONG	physAddr;
+	int		maxShared;
+	MV_BM_QSET	*defQset; /* default qset */
+	MV_BM_QSET	*mcQset;  /* MC qset */
+	MV_LIST_ELEMENT	*qsets;   /* list of qsets attached to this pool */
 } MV_BM_POOL;
 
 /* defines */
@@ -100,6 +113,11 @@ typedef struct {
 /* bits[8-9] of address define pool 0-3 */
 #define BM_POOL_ACCESS_OFFS     8
 
+/* Qsets 0-7 reserved for MC */
+#define MV_BM_POOL_QSET_BASE		8
+#define MV_BM_QSET_MAX			128
+#define MV_BM_QSET_PRIO_MAX		255
+
 /* INLINE functions */
 static INLINE void mvBmPoolPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAddr)
 {
@@ -119,6 +137,35 @@ static INLINE void mvBmPoolMcPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAdd
 	mvBmPoolPut(pool, bufPhysAddr | MV_BM_PHY_RLS_MC_BUFF_MASK, bufVirtAddr);
 }
 
+static INLINE void mvBmPoolQsetPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAddr, int qset, int isGrntd)
+{
+	MV_U32 regVal, bufPhysAddrPrio;
+
+	regVal = (qset << MV_BM_RLS_QSET_NUM_OFFS) & MV_BM_RLS_QSET_NUM_MASK;
+	mvPp2WrReg(MV_BM_QSET_RLS_REG, qset);
+
+	bufPhysAddrPrio = bufPhysAddr | MV_BM_PHY_RLS_PRIO_EN_MASK;
+	if (isGrntd)
+		bufPhysAddrPrio |= MV_BM_PHY_RLS_GRNTD_MASK;
+
+	mvBmPoolPut(pool, bufPhysAddrPrio, bufVirtAddr);
+}
+
+static INLINE void mvBmPoolQsetMcPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAddr,
+					int qset, int isGrntd, int mcId, int isForce)
+{
+	MV_U32 regVal, bufPhysAddrPrio;
+
+	regVal = (qset << MV_BM_RLS_QSET_NUM_OFFS) & MV_BM_RLS_QSET_NUM_MASK;
+	mvPp2WrReg(MV_BM_QSET_RLS_REG, qset);
+
+	bufPhysAddrPrio = bufPhysAddr | MV_BM_PHY_RLS_PRIO_EN_MASK;
+	if (isGrntd)
+		bufPhysAddrPrio |= MV_BM_PHY_RLS_GRNTD_MASK;
+
+	mvBmPoolMcPut(pool, bufPhysAddrPrio, bufVirtAddr, mcId, isForce);
+}
+
 static INLINE MV_U32 mvBmPoolGet(int pool, MV_U32 *bufPhysAddr)
 {
 	MV_U32 bufVirtAddr, physAddr;
@@ -138,13 +185,41 @@ MV_STATE  mvBmPoolStateGet(int pool);
 void      mvBmPoolEnable(int pool);
 void      mvBmPoolDisable(int pool);
 MV_BOOL   mvBmPoolIsEnabled(int pool);
-MV_STATUS mvBmPoolInit(int pool, MV_ULONG physPoolBase, int capacity);
-MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num);
+MV_STATUS mvBmPoolInit(int pool, MV_U32 *virtPoolBase, MV_ULONG physPoolBase, int capacity);
+MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num, int add);
 MV_STATUS mvBmPoolBufSizeSet(int pool, int buf_size);
 void      mvBmRegs(void);
 void      mvBmStatus(void);
 void      mvBmPoolDump(int pool, int mode);
+void      mvBmV1PoolDropCntDump(int pool);
 void      mvBmPoolPrint(int pool);
 
+/* BM priority API */
+MV_STATUS mvBmQsetCreate(int qset, int pool);
+MV_STATUS mvBmQsetDelete(int qset);
+void mvBmQsetConfigDumpAll(void);
+int mvBmDefaultQsetNumGet(int pool);
+void mvBmQueueMapDumpAll(void);
+MV_STATUS mvBmQsetShow(int qset);
+
+MV_STATUS mvBmRxqToQsetLongClean(int queue);
+MV_STATUS mvBmRxqToQsetShortClean(int queue);
+MV_STATUS mvBmTxqToQsetLongClean(int queue);
+MV_STATUS mvBmTxqToQsetShortClean(int queue);
+
+MV_STATUS mvBmRxqToQsetLongSet(int queue, int qset);
+MV_STATUS mvBmRxqToQsetShortSet(int queue, int qset);
+MV_STATUS mvBmTxqToQsetLongSet(int queue, int qset);
+MV_STATUS mvBmTxqToQsetShortSet(int queue, int qset);
+int mvBmRxqToQsetLongGet(int queue);
+int mvBmRxqToQsetShortGet(int queue);
+int mvBmTxqToQsetLongGet(int queue);
+int mvBmTxqToQsetShortGet(int queue);
+
+MV_STATUS mvBmQsetBuffMaxSet(int qset, int maxGrntd, int maxShared);
+MV_STATUS mvBmQsetBuffCountersSet(int qset, int cntrGrntd, int cntrShared);
+MV_STATUS mvBmPoolBuffNumSet(int pool, int buffNum);
+MV_STATUS mvBmPoolBuffCountersSet(int pool, int cntrGrntd, int cntrShared);
+
 #endif /* __mvBm_h__ */
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
index 2b8f219..1935d30 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
@@ -120,7 +120,7 @@ extern "C" {
 /*-------------------------------------------------------------------------------*/
 
 /* BM Activation Register */
-#define MV_BM_POOL_CTRL_REG(pool)       (MV_PP2_REG_BASE + 0x6200 + 4 * pool)
+#define MV_BM_POOL_CTRL_REG(pool)       (MV_PP2_REG_BASE + 0x6200 + ((pool) * 4))
 
 #define MV_BM_START_BIT                 0
 #define MV_BM_START_MASK                (1 << MV_BM_START_BIT)
@@ -141,7 +141,7 @@ extern "C" {
 /*-------------------------------------------------------------------------------*/
 
 /* BM Interrupt Cause Register */
-#define MV_BM_INTR_CAUSE_REG(pool)      (MV_PP2_REG_BASE + 0x6240 + 4 * pool)
+#define MV_BM_INTR_CAUSE_REG(pool)      (MV_PP2_REG_BASE + 0x6240 + ((pool) * 4))
 
 #define MV_BM_RELEASED_DELAY_BIT        0
 #define MV_BM_RELEASED_DELAY_MASK       (1 << MV_BM_RELEASED_DELAY_BIT)
@@ -160,19 +160,23 @@ extern "C" {
 /*-------------------------------------------------------------------------------*/
 
 /* BM interrupt Mask Register */
-#define MV_BM_INTR_MASK_REG(pool)       (MV_PP2_REG_BASE + 0x6280 + 4 * pool)
+#define MV_BM_INTR_MASK_REG(pool)       (MV_PP2_REG_BASE + 0x6280 + ((pool) * 4))
 /*-------------------------------------------------------------------------------*/
 
 /* BM physical address allocate */
-#define MV_BM_PHY_ALLOC_REG(pool)	(MV_PP2_REG_BASE + 0x6400 + 4 * pool)
+#define MV_BM_PHY_ALLOC_REG(pool)	(MV_PP2_REG_BASE + 0x6400 + ((pool) * 4))
+
+#define MV_BM_PHY_ALLOC_GRNTD_MASK	(0x1)
 
 /* BM virtual address allocate */
 #define MV_BM_VIRT_ALLOC_REG		(MV_PP2_REG_BASE + 0x6440)
 
 /* BM physical address release */
-#define MV_BM_PHY_RLS_REG(pool)		(MV_PP2_REG_BASE + 0x6480 + 4 * pool)
+#define MV_BM_PHY_RLS_REG(pool)		(MV_PP2_REG_BASE + 0x6480 + ((pool) * 4))
 
 #define MV_BM_PHY_RLS_MC_BUFF_MASK	(0x1)
+#define MV_BM_PHY_RLS_PRIO_EN_MASK	(0x2)
+#define MV_BM_PHY_RLS_GRNTD_MASK	(0x4)
 
 /* BM virtual address release */
 #define MV_BM_VIRT_RLS_REG		(MV_PP2_REG_BASE + 0x64c0)
@@ -188,6 +192,80 @@ extern "C" {
 #define MV_BM_FORCE_RELEASE_OFFS	12
 #define MV_BM_FORCE_RELEASE_MASK	(0x1 << MV_BM_FORCE_RELEASE_OFFS)
 
+/*-------------------------------------------------------------------------------*/
+/* BM prio alloc/release */
+#define MV_BM_QSET_ALLOC_REG		(MV_PP2_REG_BASE + 0x63fc)
+
+#define MV_BM_ALLOC_QSET_NUM_OFFS	0
+#define MV_BM_ALLOC_QSET_NUM_MASK	(0x7f << MV_BM_ALLOC_QSET_NUM_OFFS)
+
+#define MV_BM_ALLOC_YELLOW_MASK		(0x1 << 8)
+
+#define MV_BM_ALLOC_PRIO_EN_MASK	(0x1 << 12)
+
+
+#define MV_BM_QSET_RLS_REG		(MV_PP2_REG_BASE + 0x64c8)
+
+#define MV_BM_RLS_QSET_NUM_OFFS		0
+#define MV_BM_RLS_QSET_NUM_MASK		(0x7f << MV_BM_RLS_QSET_NUM_OFFS)
+/*-------------------------------------------------------------------------------*/
+/* BM Priority Configuration Registers */
+
+#define MV_BM_PRIO_CTRL_REG		(MV_PP2_REG_BASE + 0x6800)
+
+
+#define MV_BM_PRIO_IDX_REG		(MV_PP2_REG_BASE + 0x6810)
+#define MV_BM_PRIO_IDX_MASK		0xff
+
+
+#define MV_BM_CPU_QSET_REG		(MV_PP2_REG_BASE + 0x6814)
+
+#define MV_BM_CPU_SHORT_QSET_OFFS	0
+#define MV_BM_CPU_SHORT_QSET_MASK	(0x7f << MV_BM_CPU_SHORT_QSET_OFFS)
+
+#define MV_BM_CPU_LONG_QSET_OFFS	8
+#define MV_BM_CPU_LONG_QSET_MASK	(0x7f << MV_BM_CPU_LONG_QSET_OFFS)
+
+
+#define MV_BM_HWF_QSET_REG		(MV_PP2_REG_BASE + 0x6818)
+
+#define MV_BM_HWF_SHORT_QSET_OFFS	0
+#define MV_BM_HWF_SHORT_QSET_MASK	(0x7f << MV_BM_HWF_SHORT_QSET_OFFS)
+
+#define MV_BM_HWF_LONG_QSET_OFFS	8
+#define MV_BM_HWF_LONG_QSET_MASK	(0x7f << MV_BM_HWF_LONG_QSET_OFFS)
+
+
+#define MV_BM_QSET_SET_MAX_REG		(MV_PP2_REG_BASE + 0x6820)
+
+#define MV_BM_QSET_MAX_SHARED_OFFS	0
+#define MV_BM_QSET_MAX_GRNTD_OFFS	16
+
+#define MV_BM_QSET_MAX_SHARED_MASK	(0xffff << MV_BM_QSET_MAX_SHARED_OFFS)
+#define MV_BM_QSET_MAX_GRNTD_MASK	(0xffff << MV_BM_QSET_MAX_GRNTD_OFFS)
+
+
+#define MV_BM_QSET_SET_CNTRS_REG	(MV_PP2_REG_BASE + 0x6824)
+
+#define MV_BM_QSET_CNTR_SHARED_OFFS	0
+#define MV_BM_QSET_CNTR_GRNTD_OFFS	16
+
+
+#define MV_BM_POOL_MAX_SHARED_REG(pool)	(MV_PP2_REG_BASE + 0x6840 + ((pool) * 4))
+#define MV_BM_POOL_MAX_SHARED_OFFS	0
+#define MV_BM_POOL_MAX_SHARED_MASK	(0xffff << MV_BM_POOL_MAX_SHARED_OFFS)
+
+#define MV_BM_POOL_SET_CNTRS_REG(pool)	(MV_PP2_REG_BASE + 0x6880 + ((pool) * 4))
+
+#define MV_BM_POOL_CNTR_SHARED_OFFS	0
+#define MV_BM_POOL_CNTR_GRNTD_OFFS	16
+
+#define MV_BM_V1_PKT_DROP_REG(pool)		(MV_PP2_REG_BASE + 0x7300 + 4 * (pool))
+#define MV_BM_V1_PKT_MC_DROP_REG(pool)		(MV_PP2_REG_BASE + 0x7340 + 4 * (pool))
+
+
+#define MV_BM_POOL_SHARED_STATUS(pool)		(MV_PP2_REG_BASE + 0x68c0 + ((pool) * 4))
+
 
 #ifdef __cplusplus
 }
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
index 5f959ae..8f93dc9 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
@@ -69,8 +69,6 @@ int mvPp2ClassifierDefInit()
 	if (mvPp2ClsInit())
 		return MV_ERROR;
 
-	/* WorkAround HW bug */
-	/*mvPp2ClsHwLastBitWorkAround();*/
 #ifdef CONFIG_MV_ETH_PP2_CLS2
 	if (mvPp2ClsC2Init())
 		return MV_ERROR;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
index 8cc6eaa..e5e732d 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
@@ -406,7 +406,10 @@ int mvPp2ClsC2HwWrite(int index, MV_PP2_CLS_C2_ENTRY *c2)
 
 	/* write dup_attr 0x1B6C */
 	mvPp2WrReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG, c2->sram.regs.dup_attr);
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* write seq_attr 0x1B70 */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_SEQ_ATTR_REG, c2->sram.regs.seq_attr);
+#endif
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -452,6 +455,11 @@ int mvPp2ClsC2HwRead(int index, MV_PP2_CLS_C2_ENTRY *c2)
 	/* read dup_attr 0x1B6C */
 	c2->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG);
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* read seq_attr 0x1B70 */
+	c2->sram.regs.seq_attr = mvPp2RdReg(MV_PP2_CLS2_ACT_SEQ_ATTR_REG);
+#endif
+
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -536,41 +544,17 @@ int mvPp2ClsC2SwDump(MV_PP2_CLS_C2_ENTRY *c2)
 
 	mvOsPrintf("ACT_CMD:		COLOR	PRIO	DSCP	GEMID	LOW_Q	HIGH_Q	FWD	POLICER	FID\n");
 	mvOsPrintf("			");
-	/* color command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_COLOR_MASK) >> ACT_COLOR);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* pri command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_PRI_MASK) >> ACT_PRI);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* dscp command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_DSCP_MASK) >> ACT_DSCP);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* gemport id command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_GEM_ID_MASK) >> ACT_GEM_ID);
-	mvOsPrintf("%1.1d\t", int32bit);
 
-	/* queue low command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_LOW_Q_MASK) >> ACT_LOW_Q);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* queue high command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_HIGH_Q_MASK) >> ACT_HIGH_Q);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* forwarding command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* policer select command*/
-	int32bit =  ((c2->sram.regs.actions & ACT_POLICER_SELECT_MASK) >> ACT_POLICER_SELECT);
-	mvOsPrintf("%1.1d\t", int32bit);
-
-	/* flow id en */
-	int32bit =  ((c2->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN);
-	mvOsPrintf("%1.1d\t", int32bit);
+	mvOsPrintf("%1.1d\t%1.1d\t%1.1d\t%1.1d\t%1.1d\t%1.1d\t%1.1d\t%1.1d\t%1.1d\t",
+			((c2->sram.regs.actions & ACT_COLOR_MASK) >> ACT_COLOR),
+			((c2->sram.regs.actions & ACT_PRI_MASK) >> ACT_PRI),
+			((c2->sram.regs.actions & ACT_DSCP_MASK) >> ACT_DSCP),
+			((c2->sram.regs.actions & ACT_GEM_ID_MASK) >> ACT_GEM_ID),
+			((c2->sram.regs.actions & ACT_LOW_Q_MASK) >> ACT_LOW_Q),
+			((c2->sram.regs.actions & ACT_HIGH_Q_MASK) >> ACT_HIGH_Q),
+			((c2->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD),
+			((c2->sram.regs.actions & ACT_POLICER_SELECT_MASK) >> ACT_POLICER_SELECT),
+			((c2->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN));
 	mvOsPrintf("\n\n");
 
 
@@ -611,8 +595,11 @@ int mvPp2ClsC2SwDump(MV_PP2_CLS_C2_ENTRY *c2)
 	/*------------------------------*/
 	/*	hwf_attr 0x1B68		*/
 	/*------------------------------*/
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvOsPrintf("HWF_ATTR:		IPTR	DPTR	CHKSM   MTU_IDX\n");
+#else
 	mvOsPrintf("HWF_ATTR:		IPTR	DPTR	CHKSM\n");
+#endif
 	mvOsPrintf("			");
 
 	/* HWF modification instraction pointer */
@@ -625,29 +612,46 @@ int mvPp2ClsC2SwDump(MV_PP2_CLS_C2_ENTRY *c2)
 
 	/* HWF modification instraction pointer */
 	int32bit =  ((c2->sram.regs.hwf_attr & ACT_HWF_ATTR_CHKSM_EN_MASK) >> ACT_HWF_ATTR_CHKSM_EN);
-	mvOsPrintf("%s\t", int32bit ? "ENABLE" : "DISABLE");
+	mvOsPrintf("%s\t", int32bit ? "ENABLE " : "DISABLE");
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* mtu index */
+	int32bit =  ((c2->sram.regs.hwf_attr & ACT_HWF_ATTR_MTU_INX_MASK) >> ACT_HWF_ATTR_MTU_INX);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+#endif
 	mvOsPrintf("\n\n");
 
 	/*------------------------------*/
 	/*	dup_attr 0x1B6C		*/
 	/*------------------------------*/
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvOsPrintf("DUP_ATTR:		FID	COUNT	POLICER [id    bank]\n");
+	mvOsPrintf("			0x%2.2x\t0x%1.1x\t\t[0x%2.2x   0x%1.1x]\n",
+		((c2->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID),
+		((c2->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT),
+		((c2->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID),
+		((c2->sram.regs.dup_attr & ACT_DUP_POLICER_BANK_MASK) >> ACT_DUP_POLICER_BANK_BIT));
+	mvOsPrintf("\n");
+	/*------------------------------*/
+	/*	seq_attr 0x1B70		*/
+	/*------------------------------*/
+	/*PPv2.1 new feature MAS 3.14*/
+	mvOsPrintf("SEQ_ATTR:		ID	MISS\n");
+	mvOsPrintf("			0x%2.2x    0x%2.2x\n",
+			((c2->sram.regs.seq_attr & ACT_SEQ_ATTR_ID_MASK) >> ACT_SEQ_ATTR_ID),
+			((c2->sram.regs.seq_attr & ACT_SEQ_ATTR_MISS_MASK) >> ACT_SEQ_ATTR_MISS));
 
-	mvOsPrintf("DUP_ATTR:		FID	COUNT	POLICER\n");
-	mvOsPrintf("		");
-
-	/* HW duplication fid */
-	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID);
-	mvOsPrintf("	0x%2.2x\t", int32bit);
-
-	/* HW duplication count */
-	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT);
-	mvOsPrintf("0x%1.1x\t", int32bit);
+	mvOsPrintf("\n\n");
 
-	/* policer id */
-	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID);
-	mvOsPrintf("0x%1.1x\t", int32bit);
+#else
+	mvOsPrintf("DUP_ATTR:		FID	COUNT	POLICER\n");
+	mvOsPrintf("	0x%2.2x\t0x%1.1x\t0x%2.2x",
+		((c2->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID),
+		((c2->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT),
+		((c2->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID));
 
 	mvOsPrintf("\n\n");
+#endif
 
 	return MV_OK;
 }
@@ -675,6 +679,7 @@ void 	mvPp2ClsC2HwClearAll()
 int 	mvPp2ClsC2HwDump()
 {
 	int index;
+	unsigned cnt;
 
 	MV_PP2_CLS_C2_ENTRY c2;
 
@@ -684,6 +689,8 @@ int 	mvPp2ClsC2HwDump()
 		mvPp2ClsC2HwRead(index, &c2);
 		if (c2.inv == 0) {
 			mvPp2ClsC2SwDump(&c2);
+			mvPp2ClsC2HitCntrRead(index, &cnt);
+			mvOsPrintf("HITS: %d\n", cnt);
 			mvOsPrintf("-----------------------------------------------------------------\n");
 		}
 	}
@@ -953,7 +960,30 @@ int mvPp2ClsC2ForwardSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd)
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
+#ifdef CONFIG_MV_ETH_PP2_1
+int mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId, int bank)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+	BIT_RANGE_VALIDATE(bank);
+
+	c2->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	c2->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	c2->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+
+	if (bank)
+		c2->sram.regs.dup_attr |= ACT_DUP_POLICER_BANK_MASK;
+	else
+		c2->sram.regs.dup_attr &= ~ACT_DUP_POLICER_BANK_MASK;
+
+	return MV_OK;
 
+}
+
+#else
 int mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId)
 {
 	PTR_VALIDATE(c2);
@@ -967,6 +997,21 @@ int mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId)
 	c2->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
 	return MV_OK;
 }
+#endif /*CONFIG_MV_ETH_PP2_1*/
+ /*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2FlowIdEn(MV_PP2_CLS_C2_ENTRY *c2, int flowid_en)
+{
+	PTR_VALIDATE(c2);
+
+	/*set Flow ID enable or disable*/
+	if (flowid_en)
+		c2->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
+	else
+		c2->sram.regs.actions &= ~(1 << ACT_FLOW_ID_EN);
+
+	return MV_OK;
+}
 /*-------------------------------------------------------------------------------*/
 
 int mvPp2ClsC2ModSet(MV_PP2_CLS_C2_ENTRY *c2, int data_ptr, int instr_offs, int l4_csum)
@@ -986,6 +1031,22 @@ int mvPp2ClsC2ModSet(MV_PP2_CLS_C2_ENTRY *c2, int data_ptr, int instr_offs, int
 
 	return MV_OK;
 }
+
+/*-------------------------------------------------------------------------------*/
+
+/*  PPv2.1 (feature MAS 3.7) new feature - set mtu index */
+
+int mvPp2ClsC2MtuSet(MV_PP2_CLS_C2_ENTRY *c2, int mtu_inx)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(mtu_inx, ACT_HWF_ATTR_MTU_INX_MAX);
+
+	c2->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_MTU_INX_MASK;
+	c2->sram.regs.hwf_attr |= (mtu_inx << ACT_HWF_ATTR_MTU_INX);
+
+	return MV_OK;
+}
+
 /*-------------------------------------------------------------------------------*/
 
 int mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count)
@@ -994,9 +1055,6 @@ int mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count)
 	POS_RANGE_VALIDATE(count, ACT_DUP_COUNT_MAX);
 	POS_RANGE_VALIDATE(dupid, ACT_DUP_FID_MAX);
 
-	/*set Flow ID enable*/
-	c2->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
-
 	/*set flowid and count*/
 	c2->sram.regs.dup_attr &= ~(ACT_DUP_FID_MASK | ACT_DUP_COUNT_MASK);
 	c2->sram.regs.dup_attr |= (dupid << ACT_DUP_FID);
@@ -1004,6 +1062,22 @@ int mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count)
 
 	return MV_OK;
 }
+
+/*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.14) SEQ_ATTR new register in action table
+ */
+int mvPp2ClsC2SeqSet(MV_PP2_CLS_C2_ENTRY *c2, int miss, int id)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(miss, 1);
+	POS_RANGE_VALIDATE(id, ACT_SEQ_ATTR_ID_MAX);
+
+	c2->sram.regs.seq_attr = 0;
+	c2->sram.regs.seq_attr = ((id << ACT_SEQ_ATTR_ID) | (miss << ACT_SEQ_ATTR_MISS));
+
+	return MV_OK;
+}
 /*-------------------------------------------------------------------------------*/
 /*		Classifier C2 engine Hit counters Public APIs		    	 */
 /*-------------------------------------------------------------------------------*/
@@ -1040,17 +1114,11 @@ int mvPp2ClsC2HitCntrsIsBusy(void)
 int mvPp2ClsC2HitCntrRead(int index, MV_U32 *cntr)
 {
 	unsigned int value = 0;
-/*
-	if (cntr == NULL) {
-		mvOsPrintf("mvCls2Hw %s: null pointer.\n", __func__);
-		return MV_CLS2_ERR;
-	}
-*/
+
 	/* write index reg */
 	mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
 
 	value = mvPp2RdReg(MV_PP2_CLS2_HIT_CTR_REG);
-	value &= MV_PP2_CLS2_HIT_CTR_MASK;
 
 	if (cntr)
 		*cntr = value;
@@ -1097,7 +1165,9 @@ int mvPp2ClsC2RegsDump()
 	mvPp2PrintReg(MV_PP2_CLS2_ACT_QOS_ATTR_REG, "MV_PP2_CLS2_ACT_QOS_ATTR_REG");
 	mvPp2PrintReg(MV_PP2_CLS2_ACT_HWF_ATTR_REG, "MV_PP2_CLS2_ACT_HWF_ATTR_REG");
 	mvPp2PrintReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG, "MV_PP2_CLS2_ACT_DUP_ATTR_REG");
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_SEQ_ATTR_REG, "MV_PP2_CLS2_ACT_SEQ_ATTR_REG");
+#endif
 	return MV_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
index 1eb5fce..3e9bee4 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
@@ -110,7 +110,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_PP2_CLS2_HIT_CTR_REG				(MV_PP2_REG_BASE + 0x1B50)
 #define MV_PP2_CLS2_HIT_CTR_OFF				0
+
+#ifdef CONFIG_MV_ETH_PP2_1
+#define MV_PP2_CLS2_HIT_CTR_BITS			32
+#else
 #define MV_PP2_CLS2_HIT_CTR_BITS			24
+#endif
 #define MV_PP2_CLS2_HIT_CTR_MASK			((1  << MV_PP2_CLS2_HIT_CTR_BITS) - 1)
 /*-------------------------------------------------------------------------------*/
 
@@ -135,8 +140,23 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP2_CLS2_ACT_DUP_ATTR_REG			(MV_PP2_REG_BASE + 0x1B6C)
 
 /*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.14) SEQ_ATTR new register in action table
+ */
+#define MV_PP2_CLS2_ACT_SEQ_ATTR_REG			(MV_PP2_REG_BASE + 0x1B70)
+
+#define ACT_SEQ_ATTR_ID					0
+#define ACT_SEQ_ATTR_ID_BITS				8
+#define ACT_SEQ_ATTR_ID_MASK				(((1 << ACT_SEQ_ATTR_ID_BITS) - 1) << ACT_SEQ_ATTR_ID)
+#define ACT_SEQ_ATTR_ID_MAX				((1 << ACT_SEQ_ATTR_ID_BITS) - 1)
+
+#define ACT_SEQ_ATTR_MISS				8
+#define ACT_SEQ_ATTR_MISS_MASK				(1 << ACT_SEQ_ATTR_MISS)
+
+/*-------------------------------------------------------------------------------*/
+
 #define MV_PP2_CLS2_TCAM_CTRL_REG			(MV_PP2_REG_BASE + 0x1B90)
-#define MV_PP2_CLS2_TCAM_CTRL_EN				0
+#define MV_PP2_CLS2_TCAM_CTRL_EN			0
 /*-------------------------------------------------------------------------------*/
 /*		Classifier C2 QOS Table	(DSCP/PRI Table)			 */
 /*-------------------------------------------------------------------------------*/
@@ -229,6 +249,8 @@ typedef struct mvPp2ClsC2Entry {
 			MV_U32 qos_attr;   /* 0x1B64*/
 			MV_U32 hwf_attr;   /* 0x1B68 */
 			MV_U32 dup_attr;   /* 0x1B6C */
+			/* PPv2.1 (feature MAS 3.14) SEQ_ATTR new register in action table */
+			MV_U32 seq_attr;   /* 0x1B70 */
 		} regs;
 	} sram;
 } MV_PP2_CLS_C2_ENTRY;
@@ -257,9 +279,19 @@ int	mvPp2ClsC2QueueHighSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from
 int	mvPp2ClsC2QueueLowSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from);
 int	mvPp2ClsC2QueueSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from);
 int	mvPp2ClsC2ForwardSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd);
+
+#ifdef CONFIG_MV_ETH_PP2_1
+int	mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId, int bank);
+#else
 int	mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId);
+#endif
+
+int     mvPp2ClsC2FlowIdEn(MV_PP2_CLS_C2_ENTRY *c2, int flowid_en);
 int	mvPp2ClsC2ModSet(MV_PP2_CLS_C2_ENTRY *c2, int data_ptr, int instr_offs, int l4_csum);
+int	mvPp2ClsC2MtuSet(MV_PP2_CLS_C2_ENTRY *c2, int mtu_inx);
 int	mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count);
+int	mvPp2ClsC2SeqSet(MV_PP2_CLS_C2_ENTRY *c2, int miss, int id);
+
 
 /*-------------------------------------------------------------------------------*/
 /*		Classifier C2 engine Hit counters Public APIs		    	 */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
index 2cd107b..d3f4c87 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
@@ -65,10 +65,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 CLS3_SHADOW_HASH_ENTRY mvCls3ShadowTbl[MV_PP2_CLS_C3_HASH_TBL_SIZE];
 int mvCls3ShadowExtTbl[MV_PP2_CLS_C3_EXT_TBL_SIZE];
-
 static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3);
 
-static int initHitCounter = 0;
+static int SwInitCntSet;
 
 /******************************************************************************
  * 			Common utilities
@@ -139,10 +138,8 @@ void mvPp2C3ShadowClear(int index)
 }
 /*-------------------------------------------------------------------------------
 retun 1 scan procedure completed
-TODO - ASK RUVEN , i use scane state , is it good enough ?
 -------------------------------------------------------------------------------*/
-/*
-static int mvPp2ClsC3ScanIsCompleate(void)
+static int mvPp2ClsC3ScanIsComplete(void)
 {
 	unsigned int regVal;
 
@@ -152,7 +149,6 @@ static int mvPp2ClsC3ScanIsCompleate(void)
 
 	return regVal;
 }
-*/
 /*-------------------------------------------------------------------------------
 return 1 if that the last CPU access (Query,Add or Delete) was completed
 -------------------------------------------------------------------------------*/
@@ -182,6 +178,7 @@ static int mvPp2ClsC3ScanStateGet(int *state)
 	regVal &= MV_PP2_CLS3_STATE_SC_STATE_MASK;
 	regVal >>= MV_PP2_CLS3_STATE_SC_STATE;
 	*state = regVal;
+
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------
@@ -218,7 +215,10 @@ int mvPp2ClsC3Init()
 --------------------------------------------------------------------------------*/
 static int mvPp2ClsC3IsReservedIndex(int index)
 {
-	if ((index % 512/*MV_PP2_CLS_C3_BANK_SIZE*/) > 1)
+#ifdef CONFIG_MV_ETH_PP2_1
+	return MV_FALSE;
+#endif
+	if ((index % MV_PP2_CLS_C3_BANK_SIZE) > 1)
 		/* not reserved */
 		return MV_FALSE;
 
@@ -229,7 +229,6 @@ static int mvPp2ClsC3IsReservedIndex(int index)
 Add entry to hash table
 ext_index used only if hek size < 12
 -------------------------------------------------------------------------------*/
-
 int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index)
 {
 	int regStartInd, hekSize, iter = 0;
@@ -263,9 +262,15 @@ int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index)
 
 
 	regVal |= (index << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
+	regVal &= ~MV_PP2_CLS3_MISS_PTR_MASK; /*set miss bit to 0, ppv2.1 mas 3.16*/
 	regVal |= (1 << MV_PP2_CLS3_HASH_OP_ADD);
-	regVal |= (initHitCounter << MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL);
 
+	/* set hit counter init value */
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2WrReg(MV_PP2_CLS3_INIT_HIT_CNT_REG, SwInitCntSet << MV_PP2_CLS3_INIT_HIT_CNT_OFFS);
+#else
+	regVal |= (SwInitCntSet << MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL);
+#endif
 	/*trigger ADD operation*/
 	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
 
@@ -281,13 +286,49 @@ int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index)
 	mvPp2WrReg(MV_PP2_CLS3_ACT_QOS_ATTR_REG, c3->sram.regs.qos_attr);
 	mvPp2WrReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG, c3->sram.regs.hwf_attr);
 	mvPp2WrReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG, c3->sram.regs.dup_attr);
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2WrReg(MV_PP2_CLS3_ACT_SEQ_L_ATTR_REG, c3->sram.regs.seq_l_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_SEQ_H_ATTR_REG, c3->sram.regs.seq_h_attr);
+#endif
 	/* set entry as valid, extesion pointer in use only if size > 12*/
 	mvPp2ClsC3ShadowSet(hekSize, index, ext_index);
 
 
 	return MV_OK;
 }
+
+/*-------------------------------------------------------------------------------
+Add entry to miss hash table
+ppv2.1 mas 3.16 relevant only for ppv2.1
+-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HwMissAdd(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(lkp_type, MV_PP2_CLS_C3_MISS_TBL_SIZE - 1);
+
+	c3->index = lkp_type;
+
+	regVal |= (lkp_type << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
+	regVal |= (1 << MV_PP2_CLS3_HASH_OP_ADD);
+	regVal |= MV_PP2_CLS3_MISS_PTR_MASK;/*set miss bit to 1, ppv2.1 mas 3.16*/
+
+	/*index to miss table */
+	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
+
+	/* write action table registers */
+	mvPp2WrReg(MV_PP2_CLS3_ACT_REG, c3->sram.regs.actions);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_QOS_ATTR_REG, c3->sram.regs.qos_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG, c3->sram.regs.hwf_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG, c3->sram.regs.dup_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_SEQ_L_ATTR_REG, c3->sram.regs.seq_l_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_SEQ_H_ATTR_REG, c3->sram.regs.seq_h_attr);
+	/*clear hit counter, clear on read */
+	mvPp2ClsC3HitCntrsMissRead(lkp_type, &regVal);
+
+	return MV_OK;
+}
 /*-------------------------------------------------------------------------------*/
 
 int mvPp2ClsC3HwDel(int index)
@@ -300,6 +341,8 @@ int mvPp2ClsC3HwDel(int index)
 
 	regVal |= (index << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
 	regVal |= (1 << MV_PP2_CLS3_HASH_OP_DEL);
+	regVal &= ~MV_PP2_CLS3_MISS_PTR_MASK;/*set miss bit to 1, ppv2.1 mas 3.16*/
+
 
 	/*trigger del operation*/
 	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
@@ -327,14 +370,13 @@ int mvPp2ClsC3HwDelAll()
 		if (status != MV_OK)
 			return status;
 	}
-
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
 
 void mvPp2ClsC3HwInitCtrSet(int cntVal)
 {
-	initHitCounter = cntVal;
+	SwInitCntSet = cntVal;
 }
 
 /*-------------------------------------------------------------------------------*/
@@ -404,15 +446,8 @@ static int mvPp2ClsC3HwQueryAddRelocate(int new_idx, int max_depth, int cur_dept
 	/* if we reached here, we found a valid free index */
 	index_free = usedIndex[idx];
 
-	/* del is not necessary */
-/*
-	status = mvPp2ClsC3HwDel(new_idx);
+	/* new_idx del is not necessary */
 
-	if (status != MV_OK) {
-		mvOsPrintf("%s:Error - mvPp2ClsC3HwDel failed, depth = %d\n", __func__, cur_depth);
-		return status;
-	}
-*/
 	/*We do not chage extension tabe*/
 	status = mvPp2ClsC3HwAdd(&local_c3, index_free, local_c3.ext_index);
 
@@ -579,6 +614,11 @@ int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index)
 	c3->sram.regs.hwf_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG);
 	c3->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG);
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	c3->sram.regs.seq_l_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_SEQ_L_ATTR_REG);
+	c3->sram.regs.seq_h_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_SEQ_H_ATTR_REG);
+#endif
+
 	/* read hash data*/
 	for (i = 0; i < MV_PP2_CLS3_HASH_DATA_REG_NUM; i++)
 		hashData[i] = mvPp2RdReg(MV_PP2_CLS3_HASH_DATA_REG(i));
@@ -655,13 +695,25 @@ int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index)
 
 		c3->key.key_ctrl |= (((hashData[3] & KEY_PRT_ID_MASK(isExt)) >>
 					(KEY_PRT_ID(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_PRT_ID);
-		/* port ID type */
+
+#ifdef CONFIG_MV_ETH_PP2_1
+		/* PPv2.1 (feature MAS 3.16) LKP_TYPE size and offset changed */
+
+		c3->key.key_ctrl |= (((hashData[3] & KEY_PRT_ID_TYPE_MASK(isExt)) >>
+					(KEY_PRT_ID_TYPE(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_PRT_ID_TYPE);
+
+		c3->key.key_ctrl |= ((((hashData[2] & 0xf8000000) >> 27) |
+					((hashData[3] & 0x1) << 5)) << KEY_CTRL_LKP_TYPE);
+
+#else
 		c3->key.key_ctrl |= ((((hashData[2] & 0x80000000) >> 31) |
 					((hashData[3] & 0x1) << 1)) << KEY_CTRL_PRT_ID_TYPE);
 
 		c3->key.key_ctrl |= (((hashData[2] & KEY_LKP_TYPE_MASK(isExt)) >>
 					(KEY_LKP_TYPE(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_LKP_TYPE);
 
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
 		c3->key.key_ctrl |= (((hashData[2] & KEY_L4_INFO_MASK(isExt)) >>
 					(KEY_L4_INFO(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_L4);
 	}
@@ -673,6 +725,36 @@ int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index)
 }
 
 /*-------------------------------------------------------------------------------*/
+/* ppv2.1 MAS 3.12								*/
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwMissRead(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(lkp_type, MV_PP2_CLS_C3_MISS_TBL_SIZE - 1);
+
+	mvPp2ClsC3SwClear(c3);
+
+	c3->index = lkp_type;
+	c3->ext_index = NOT_IN_USE;
+
+	regVal = (lkp_type << MV_PP2_CLS3_HASH_OP_TBL_ADDR) | MV_PP2_CLS3_MISS_PTR_MASK;
+	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
+
+	/* read action table */
+	c3->sram.regs.actions = mvPp2RdReg(MV_PP2_CLS3_ACT_REG);
+	c3->sram.regs.qos_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_QOS_ATTR_REG);
+	c3->sram.regs.hwf_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG);
+	c3->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG);
+	c3->sram.regs.seq_l_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_SEQ_L_ATTR_REG);
+	c3->sram.regs.seq_h_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_SEQ_H_ATTR_REG);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
 int mvPp2ClsC3SwDump(MV_PP2_CLS_C3_ENTRY *c3)
 {
 	int hekSize;
@@ -722,12 +804,13 @@ static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3)
 	PTR_VALIDATE(c3);
 	mvOsPrintf("\n");
 
+#ifdef CONFIG_MV_ETH_PP2_1
 	/*------------------------------*/
-	/*	actions 0x1B60		*/
+	/*	actions 0x1D40		*/
 	/*------------------------------*/
 
-	mvOsPrintf("ACT_TBL: COLOR   LOW_Q   HIGH_Q    FWD    POLICER   FID\n");
-	mvOsPrintf("CMD:     [%1d]      [%1d]    [%1d]        [%1d]   [%1d]       [%1d]\n",
+	mvOsPrintf("ACT_TBL: COLOR   LOW_Q   HIGH_Q     FWD   POLICER  FID\n");
+	mvOsPrintf("CMD:     [%1d]      [%1d]    [%1d]        [%1d]   [%1d]      [%1d]\n",
 			((c3->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
 			((c3->sram.regs.actions & (ACT_LOW_Q_MASK)) >> ACT_LOW_Q),
 			((c3->sram.regs.actions & (ACT_HIGH_Q_MASK)) >> ACT_HIGH_Q),
@@ -735,16 +818,59 @@ static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3)
 			((c3->sram.regs.actions & (ACT_POLICER_SELECT_MASK)) >> ACT_POLICER_SELECT),
 			((c3->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN));
 
-	/*mvOsPrintf("ACT_TBL:		LOW_Q	HIGH_Q		POLICER\n");*/
+	mvOsPrintf("VAL:              [%1d]    [0x%x]\n",
+			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK)) >> ACT_QOS_ATTR_MDF_LOW_Q),
+			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q));
+
+	mvOsPrintf("\n");
+	/*------------------------------*/
+	/*	hwf_attr 0x1D48		*/
+	/*------------------------------*/
+
+	mvOsPrintf("HWF_ATTR: IPTR	DPTR	 CHKSM     MTU_IDX\n");
+	mvOsPrintf("          0x%1.1x   0x%4.4x   %s   0x%1.1x\n",
+
+			((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_IPTR_MASK) >> ACT_HWF_ATTR_IPTR),
+			((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_DPTR_MASK) >> ACT_HWF_ATTR_DPTR),
+			(((c3->sram.regs.hwf_attr &
+				ACT_HWF_ATTR_CHKSM_EN_MASK) >> ACT_HWF_ATTR_CHKSM_EN) ? "ENABLE" : "DISABLE"),
+			((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_MTU_INX_MASK) >> ACT_HWF_ATTR_MTU_INX));
+	mvOsPrintf("\n");
+	/*------------------------------*/
+	/*	dup_attr 0x1D4C		*/
+	/*------------------------------*/
+	mvOsPrintf("DUP_ATTR:FID	COUNT	POLICER [id    bank]\n");
+	mvOsPrintf("         0x%2.2x\t0x%1.1x\t\t[0x%2.2x   0x%1.1x]\n",
+		((c3->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID),
+		((c3->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT),
+		((c3->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID),
+		((c3->sram.regs.dup_attr & ACT_DUP_POLICER_BANK_MASK) >> ACT_DUP_POLICER_BANK_BIT));
+	mvOsPrintf("\n");
+	mvOsPrintf("SEQ_ATTR: HIGH[32:37] LOW[0:31]\n");
+	mvOsPrintf("          0x%2.2x        0x%8.8x", c3->sram.regs.seq_h_attr, c3->sram.regs.seq_l_attr);
+
+#else
+	/*------------------------------*/
+	/*	actions 0x1D40		*/
+	/*------------------------------*/
+
+	mvOsPrintf("ACT_TBL: COLOR   LOW_Q   HIGH_Q     FWD   POLICER  FID\n");
+	mvOsPrintf("CMD:     [%1d]      [%1d]    [%1d]        [%1d]   [%1d]      [%1d]\n",
+			((c3->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
+			((c3->sram.regs.actions & (ACT_LOW_Q_MASK)) >> ACT_LOW_Q),
+			((c3->sram.regs.actions & (ACT_HIGH_Q_MASK)) >> ACT_HIGH_Q),
+			((c3->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD),
+			((c3->sram.regs.actions & (ACT_POLICER_SELECT_MASK)) >> ACT_POLICER_SELECT),
+			((c3->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN));
 
-	mvOsPrintf("VAL:              [%1d]    [0x%x]            [%1d]\n",
+	mvOsPrintf("VAL:              [%1d]    [0x%x]            [0x%x]\n",
 			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK)) >> ACT_QOS_ATTR_MDF_LOW_Q),
 			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q),
 			((c3->sram.regs.dup_attr & (ACT_DUP_POLICER_MASK)) >> ACT_DUP_POLICER_ID));
-
 	mvOsPrintf("\n");
+
 	/*------------------------------*/
-	/*	hwf_attr 0x1B68		*/
+	/*	hwf_attr 0x1D48		*/
 	/*------------------------------*/
 
 	mvOsPrintf("HWF_ATTR: IPTR    DPTR   CHKSM\n");
@@ -756,14 +882,17 @@ static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3)
 	mvOsPrintf("\n");
 
 	/*------------------------------*/
-	/*	dup_attr 0x1B6C		*/
+	/*	dup_attr 0x1D4C		*/
 	/*------------------------------*/
 
-	mvOsPrintf("DUP_ATTR: FID     COUNT\n");
-	mvOsPrintf("          0x%2.2x      0x%1.1x\t",
+	mvOsPrintf("DUP_ATTR: FID   COUNT\n");
+	mvOsPrintf("          0x%2.2x  0x%1.1x\n",
 			((c3->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID),
 			((c3->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT));
 
+
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
 	mvOsPrintf("\n\n");
 
 	return MV_OK;
@@ -787,6 +916,29 @@ int mvPp2ClsC3HwDump()
 
 	return MV_OK;
 }
+/*-------------------------------------------------------------------------------*/
+/*
+All miss entries are valid,
+the key+heks in miss entries are hot in use and this is the
+reason that we dump onlt action table fields
+*/
+int mvPp2ClsC3HwMissDump()
+{
+	int index;
+	MV_PP2_CLS_C3_ENTRY c3;
+
+	mvPp2ClsC3SwClear(&c3);
+
+	for (index = 0; index < MV_PP2_CLS_C3_MISS_TBL_SIZE; index++) {
+		mvPp2ClsC3HwMissRead(&c3, index);
+		mvOsPrintf("INDEX[0x%3.3X]\n", index);
+		mvPp2ClsC3SwActDump(&c3);
+		mvOsPrintf("----------------------------------------------------------------------\n");
+	}
+
+	return MV_OK;
+}
+
 
 /*-------------------------------------------------------------------------------*/
 int mvPp2ClsC3HwExtDump()
@@ -967,7 +1119,28 @@ int mvPp2ClsC3ForwardSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd)
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
+#ifdef CONFIG_MV_ETH_PP2_1
+int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId, int bank)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+	BIT_RANGE_VALIDATE(bank);
+
+	c3->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	c3->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	c3->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+
+	if (bank)
+		c3->sram.regs.dup_attr |= ACT_DUP_POLICER_BANK_MASK;
+	else
+		c3->sram.regs.dup_attr &= ~ACT_DUP_POLICER_BANK_MASK;
 
+	return MV_OK;
+}
+#else
 int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId)
 {
 	PTR_VALIDATE(c3);
@@ -981,7 +1154,24 @@ int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId)
 	c3->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
 	return MV_OK;
 }
+#endif /*CONFIG_MV_ETH_PP2_1*/
+ /*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3FlowIdEn(MV_PP2_CLS_C3_ENTRY *c3, int flowid_en)
+{
+	PTR_VALIDATE(c3);
+
+	/*set Flow ID enable or disable*/
+	if (flowid_en)
+		c3->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
+	else
+		c3->sram.regs.actions &= ~(1 << ACT_FLOW_ID_EN);
+
+	return MV_OK;
+}
 /*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.7) function changed , get also MTU index as parameter
+ */
 int mvPp2ClsC3ModSet(MV_PP2_CLS_C3_ENTRY *c3, int data_ptr, int instr_offs, int l4_csum)
 {
 	PTR_VALIDATE(c3);
@@ -999,6 +1189,22 @@ int mvPp2ClsC3ModSet(MV_PP2_CLS_C3_ENTRY *c3, int data_ptr, int instr_offs, int
 
 	return MV_OK;
 }
+
+
+/*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.7) mtu - new field at action table
+*/
+
+int mvPp2ClsC3MtuSet(MV_PP2_CLS_C3_ENTRY *c3, int mtu_inx)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(mtu_inx, ACT_HWF_ATTR_MTU_INX_MAX);
+
+	c3->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_MTU_INX_MASK;
+	c3->sram.regs.hwf_attr |= (mtu_inx << ACT_HWF_ATTR_MTU_INX);
+	return MV_OK;
+}
 /*-------------------------------------------------------------------------------*/
 
 int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count)
@@ -1007,9 +1213,6 @@ int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count)
 	POS_RANGE_VALIDATE(count, ACT_DUP_COUNT_MAX);
 	POS_RANGE_VALIDATE(dupid, ACT_DUP_FID_MAX);
 
-	/*set Flow ID enable*/
-	c3->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
-
 	/*set flowid and count*/
 	c3->sram.regs.dup_attr &= ~(ACT_DUP_FID_MASK | ACT_DUP_COUNT_MASK);
 	c3->sram.regs.dup_attr |= (dupid << ACT_DUP_FID);
@@ -1019,6 +1222,49 @@ int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count)
 }
 
 /*-------------------------------------------------------------------------------*/
+/* PPv2.1 (feature MAS 3.14) cls sequence */
+int mvPp2ClsC3SeqSet(MV_PP2_CLS_C3_ENTRY *c3, int id,  int bits_offs,  int bits)
+{
+	unsigned int low_bits, high_bits = 0;
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(bits, MV_PP2_CLS_SEQ_SIZE_MAX);
+	POS_RANGE_VALIDATE(id, (1 << bits) - 1);
+	POS_RANGE_VALIDATE(bits_offs + bits, MV_PP2_CLS3_ACT_SEQ_SIZE);
+
+	if (bits_offs >= DWORD_BITS_LEN)
+		high_bits = bits;
+
+	else if (bits_offs + bits > DWORD_BITS_LEN)
+		high_bits = (bits_offs + bits) % DWORD_BITS_LEN;
+
+	low_bits = bits - high_bits;
+
+	/*
+	high_bits hold the num of bits that we need to write in seq_h_attr
+	low_bits hold the num of bits that we need to write in seq_l_attr
+	*/
+
+	if (low_bits) {
+		/* mask and set new value in seq_l_attr*/
+		c3->sram.regs.seq_l_attr &= ~(((1 << low_bits) - 1)  << bits_offs);
+		c3->sram.regs.seq_l_attr |= (id  << bits_offs);
+	}
+
+	if (high_bits) {
+		int high_id = id >> low_bits;
+		int high_offs = (low_bits == 0) ? (bits_offs % DWORD_BITS_LEN) : 0;
+
+		/* mask and set new value in seq_h_attr*/
+		c3->sram.regs.seq_h_attr &= ~(((1 << high_bits) - 1)  << high_offs);
+		c3->sram.regs.seq_h_attr |= (high_id << high_offs);
+	}
+
+	return MV_OK;
+
+}
+
+/*-------------------------------------------------------------------------------*/
 /*		APIs for Classification C3 Hit counters management	   	 */
 /*-------------------------------------------------------------------------------*/
 
@@ -1045,9 +1291,15 @@ int mvPp2ClsC3HitCntrsClear(int lkpType)
 int mvPp2ClsC3HitCntrsClearAll(void)
 {
 	int iter = 0;
+/*
+  PPv2.1 (feature MAS 3.16)  CLEAR_COUNTERS size changed, clear all code changed from 0x1f to 0x3f
+*/
 
-	mvPp2WrReg(MV_PP2_CLS3_CLEAR_COUNTERS_REG, 0x1F /*clear all*/);
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2WrReg(MV_PP2_CLS3_CLEAR_COUNTERS_REG, MV_PP2_V1_CLS3_CLEAR_ALL);
+#else
+	mvPp2WrReg(MV_PP2_CLS3_CLEAR_COUNTERS_REG, MV_PP2_V0_CLS3_CLEAR_ALL);
+#endif
 	/* wait to clear het counters done bit */
 	while (!mvPp2ClsC3HitCntrClearDone())
 		if (++iter >= RETRIES_EXCEEDED) {
@@ -1069,10 +1321,39 @@ int mvPp2ClsC3HitCntrsRead(int index, MV_U32 *cntr)
 	mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, index);
 
 	/*counter read*/
-	counter = mvPp2RdReg(MV_PP2_CLS3_HIT_COUNTER_REG) & MV_PP2_CLS3_HIT_COUNTER_MASK;
+#ifdef CONFIG_MV_ETH_PP2_1
+	counter = mvPp2RdReg(MV_PP2_CLS3_HIT_COUNTER_REG) & MV_PP2_V1_CLS3_HIT_COUNTER_MASK;
+#else
+	counter = mvPp2RdReg(MV_PP2_CLS3_HIT_COUNTER_REG) & MV_PP2_V0_CLS3_HIT_COUNTER_MASK;
+#endif
 
 	if (!cntr)
-		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, counter);
+		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%6.6x\n", index, counter);
+	else
+		*cntr = counter;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HitCntrsMissRead(int lkp_type, MV_U32 *cntr)
+{
+	unsigned int counter;
+	int index;
+
+	POS_RANGE_VALIDATE(lkp_type, MV_PP2_CLS_C3_MISS_TBL_SIZE - 1);
+
+
+	/*set miss bit to 1, ppv2.1 mas 3.16*/
+	index = (lkp_type | MV_PP2_CLS3_DB_MISS_MASK);
+
+	/*write entry index*/
+	mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, index);
+
+	/*counter read*/
+	counter = mvPp2RdReg(MV_PP2_CLS3_HIT_COUNTER_REG) & MV_PP2_V1_CLS3_HIT_COUNTER_MASK;
+
+	if (!cntr)
+		mvOsPrintf("LKPT:0x%3.3x	COUNTER VAL:0x%6.6x\n", lkp_type, counter);
 	else
 		*cntr = counter;
 	return MV_OK;
@@ -1091,9 +1372,20 @@ int mvPp2ClsC3HitCntrsReadAll(void)
 		if (counter == 0)
 			continue;
 
-		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, counter);
+		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%6.6x\n", index, counter);
 	}
 
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (index = 0; index < MV_PP2_CLS_C3_MISS_TBL_SIZE; index++) {
+		mvPp2ClsC3HitCntrsMissRead(index, &counter);
+
+		/* skip initial counter value */
+		if (counter == 0)
+			continue;
+
+		mvOsPrintf("LKPT:0x%3.3x	COUNTER VAL:0x%6.6x\n", index, counter);
+	}
+#endif
 	return MV_OK;
 }
 
@@ -1102,17 +1394,17 @@ int mvPp2ClsC3HitCntrsReadAll(void)
 /*-------------------------------------------------------------------------------*/
 int mvPp2ClsC3ScanStart()
 {
-	int scState, iter = 0;
+	int complete, iter = 0;
 
 	/* trigger scan operation */
 	mvPp2WrReg(MV_PP2_CLS3_SC_ACT_REG, (1 << MV_PP2_CLS3_SC_ACT));
 
 	do {
-		mvPp2ClsC3ScanStateGet(&scState);
-	} while (scState != 0 && ((iter++) < RETRIES_EXCEEDED));/*scan compleated*/
+		complete = mvPp2ClsC3ScanIsComplete();
+
+	} while ((!complete) && ((iter++) < RETRIES_EXCEEDED));/*scan compleated*/
 
 	if (iter >= RETRIES_EXCEEDED) {
-		mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
 		return MV_CLS3_RETRIES_EXCEEDED;
 	}
 
@@ -1123,10 +1415,14 @@ int mvPp2ClsC3ScanStart()
 int mvPp2ClsC3ScanRegs()
 {
 	unsigned int prop, propVal;
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	unsigned int treshHold;
+	treshHold = mvPp2RdReg(MV_PP2_CLS3_SC_TH_REG);
+#endif
 	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
 	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
 
+
 	mvOsPrintf("%-32s: 0x%x = 0x%08x\n", "MV_PP2_CLS3_SC_PROP_REG", MV_PP2_CLS3_SC_PROP_REG, prop);
 	mvOsPrintf("%-32s: 0x%x = 0x%08x\n", "MV_PP2_CLS3_SC_PROP_VAL_REG", MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
 	mvOsPrintf("\n");
@@ -1141,13 +1437,23 @@ int mvPp2ClsC3ScanRegs()
 
 	/* start index */
 	mvOsPrintf("START     = 0x%x\n", (MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK & prop) >> MV_PP2_CLS3_SC_PROP_START_ENTRY);
-
+#ifdef CONFIG_MV_ETH_PP2_1
 	/* threshold */
-	mvOsPrintf("THRESHOLD = 0x%x\n", (MV_PP2_CLS3_SC_PROP_VAL_TH_MASK & propVal) >> MV_PP2_CLS3_SC_PROP_VAL_TH);
+	mvOsPrintf("THRESHOLD = 0x%x\n", (MV_PP2_CLS3_SC_TH_MASK & treshHold) >> MV_PP2_CLS3_SC_TH);
 
 	/* delay value */
-	mvOsPrintf("DELAY     = 0x%x\n\n", (MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK & propVal) >> MV_PP2_CLS3_SC_PROP_VAL_DELAY);
+	mvOsPrintf("DELAY     = 0x%x\n\n",
+			(MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY_MASK & propVal) >> MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY);
+
+#else
+	/* threshold */
+	mvOsPrintf("THRESHOLD = 0x%x\n",
+			(MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MASK & propVal) >> MV_PP2_V0_CLS3_SC_PROP_VAL_TH);
 
+	/* delay value */
+	mvOsPrintf("DELAY     = 0x%x\n\n",
+			(MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY_MASK & propVal) >> MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY);
+#endif
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -1155,23 +1461,31 @@ int mvPp2ClsC3ScanRegs()
 /*mod = 0 below th . mode = 1 above threshold*/
 int mvPp2ClsC3ScanThreshSet(int mode, int thresh)
 {
-	unsigned int prop, propVal;
+	unsigned int regVal;
 
 	POS_RANGE_VALIDATE(mode, 1); /* one bit */
-	POS_RANGE_VALIDATE(thresh, MV_PP2_CLS3_SC_PROP_VAL_TH_MAX);
-
-	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
-	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
-
-
-	prop &= ~MV_PP2_CLS3_SC_PROP_TH_MODE_MASK;
-	prop |= (mode << MV_PP2_CLS3_SC_PROP_TH_MODE);
-
-	propVal &= ~MV_PP2_CLS3_SC_PROP_VAL_TH_MASK;
-	propVal |= (thresh << MV_PP2_CLS3_SC_PROP_VAL_TH);
+#ifdef CONFIG_MV_ETH_PP2_1
+	POS_RANGE_VALIDATE(thresh, MV_PP2_CLS3_SC_TH_MAX);
+#else
+	POS_RANGE_VALIDATE(thresh, MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MAX);
+#endif
 
-	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, prop);
-	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+	regVal &= ~MV_PP2_CLS3_SC_PROP_TH_MODE_MASK;
+	regVal |= (mode << MV_PP2_CLS3_SC_PROP_TH_MODE);
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, regVal);
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_TH_REG);
+	regVal &= ~MV_PP2_CLS3_SC_TH_MASK;
+	regVal |= (thresh << MV_PP2_CLS3_SC_TH);
+	mvPp2WrReg(MV_PP2_CLS3_SC_TH_REG, regVal);
+#else
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
+	regVal &= ~MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MASK;
+	regVal |= (thresh << MV_PP2_V0_CLS3_SC_PROP_VAL_TH);
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_VAL_REG, regVal);
+#endif
 
 	return MV_OK;
 }
@@ -1240,9 +1554,13 @@ int mvPp2ClsC3ScanDelaySet(int time)
 	POS_RANGE_VALIDATE(time, MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX);
 
 	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
-	propVal &= ~MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK;
-	propVal |= (time << MV_PP2_CLS3_SC_PROP_VAL_DELAY);
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	propVal &= ~MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY_MASK;
+	propVal |= (time << MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY);
+#else
+	propVal &= ~MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY_MASK;
+	propVal |= (time << MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY);
+#endif
 	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
 
 	return MV_OK;
@@ -1271,11 +1589,14 @@ int mvPp2ClsC3ScanResRead(int index, int *addr, int *cnt)
 	/*read date*/
 	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_RES_REG);
 	addres = (regVal & MV_PP2_CLS3_SC_RES_ENTRY_MASK) >> MV_PP2_CLS3_SC_RES_ENTRY;
-	counter = (regVal & MV_PP2_CLS3_SC_RES_CTR_MASK) >> MV_PP2_CLS3_SC_RES_CTR;
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	counter = (regVal & MV_PP2_V1_CLS3_SC_RES_CTR_MASK) >> MV_PP2_V1_CLS3_SC_RES_CTR;
+#else
+	counter = (regVal & MV_PP2_V0_CLS3_SC_RES_CTR_MASK) >> MV_PP2_V0_CLS3_SC_RES_CTR;
+#endif
 	/* if one of parameters is null - func call from sysfs*/
 	if ((!addr) | (!cnt))
-		mvOsPrintf("INDEX:0x%2.2x	ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, addres, counter);
+		mvOsPrintf("INDEX:0x%2.2x	ADDR:0x%3.3x	COUNTER VAL:0x%6.6x\n", index, addres, counter);
 	else {
 		*addr = addres;
 		*cnt = counter;
@@ -1293,7 +1614,7 @@ int mvPp2ClsC3ScanResDump()
 	mvOsPrintf("INDEX	ADDRESS		COUNTER\n");
 	for (index = 0; index < resNum; index++) {
 		mvPp2ClsC3ScanResRead(index, &addr, &cnt);
-		mvOsPrintf("[0x%2.2x]\t[0x%3.3x]\t[0x%4.4x]\n", index, addr, cnt);
+		mvOsPrintf("[0x%2.2x]\t[0x%3.3x]\t[0x%6.6x]\n", index, addr, cnt);
 	}
 
 	return MV_OK;
@@ -1314,7 +1635,7 @@ int mvPp2ClsC3ScanNumOfResGet(int *resNum)
 		return MV_CLS3_RETRIES_EXCEEDED;
 	}
 
-	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_TIMER_REG);
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG);
 	regVal &= MV_PP2_CLS3_STATE_NO_OF_SC_RES_MASK;
 	regVal >>= MV_PP2_CLS3_STATE_NO_OF_SC_RES;
 	*resNum = regVal;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
index 8d68da3..debc164 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
@@ -66,6 +66,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __MV_CLS3_HW_H__
 
 #include "mvPp2ClsActHw.h"
+#include "mvPp2ClsHw.h"
 #include "../common/mvPp2ErrCode.h"
 #include "../common/mvPp2Common.h"
 #include "../gbe/mvPp2GbeRegs.h"
@@ -74,80 +75,104 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /*			Classifier C3 Top Registers	    			 */
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_KEY_CTRL_REG			(MV_PP2_REG_BASE + 0x1C10)
-#define KEY_CTRL_L4					0
-#define KEY_CTRL_L4_BITS				3
-#define KEY_CTRL_L4_MAX					((1 << KEY_CTRL_L4_BITS) - 1)
-#define KEY_CTRL_L4_MASK				(((1 << KEY_CTRL_L4_BITS) - 1) << KEY_CTRL_L4)
+#define MV_PP2_CLS3_KEY_CTRL_REG		(MV_PP2_REG_BASE + 0x1C10)
+#define KEY_CTRL_L4				0
+#define KEY_CTRL_L4_BITS			3
+#define KEY_CTRL_L4_MAX				((1 << KEY_CTRL_L4_BITS) - 1)
+#define KEY_CTRL_L4_MASK			(((1 << KEY_CTRL_L4_BITS) - 1) << KEY_CTRL_L4)
 
+/*
+  PPv2.1 (feature MAS 3.16) LKP_TYPE size and offset changed
+*/
+#ifdef CONFIG_MV_ETH_PP2_1
+#define KEY_CTRL_LKP_TYPE			4
+#define KEY_CTRL_LKP_TYPE_BITS			6
+#else
+#define KEY_CTRL_LKP_TYPE			8
+#define KEY_CTRL_LKP_TYPE_BITS			4
+#endif
 
-#define KEY_CTRL_LKP_TYPE				8
-#define KEY_CTRL_LKP_TYPE_BITS				4
-#define KEY_CTRL_LKP_TYPE_MAX				((1 << KEY_CTRL_LKP_TYPE_BITS) - 1)
-#define KEY_CTRL_LKP_TYPE_MASK				(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << KEY_CTRL_LKP_TYPE)
+#define KEY_CTRL_LKP_TYPE_MAX			((1 << KEY_CTRL_LKP_TYPE_BITS) - 1)
+#define KEY_CTRL_LKP_TYPE_MASK			(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << KEY_CTRL_LKP_TYPE)
 
 
-#define KEY_CTRL_PRT_ID_TYPE				12
-#define KEY_CTRL_PRT_ID_TYPE_BITS			2
-#define KEY_CTRL_PRT_ID_TYPE_MAX			((1<<KEY_CTRL_PRT_ID_TYPE_BITS) - 1)
-#define KEY_CTRL_PRT_ID_TYPE_MASK			(((1<<KEY_CTRL_PRT_ID_TYPE_BITS) - 1) << KEY_CTRL_PRT_ID_TYPE)
+#define KEY_CTRL_PRT_ID_TYPE			12
+#define KEY_CTRL_PRT_ID_TYPE_BITS		2
+#define KEY_CTRL_PRT_ID_TYPE_MAX		((1 << KEY_CTRL_PRT_ID_TYPE_BITS) - 1)
+#define KEY_CTRL_PRT_ID_TYPE_MASK		((KEY_CTRL_PRT_ID_TYPE_MAX) << KEY_CTRL_PRT_ID_TYPE)
 
-#define KEY_CTRL_PRT_ID					16
-#define KEY_CTRL_PRT_ID_BITS				8
-#define KEY_CTRL_PRT_ID_MAX				((1<<KEY_CTRL_PRT_ID_BITS) - 1)
-#define KEY_CTRL_PRT_ID_MASK				(((1<<KEY_CTRL_PRT_ID_BITS) - 1) << KEY_CTRL_PRT_ID)
+#define KEY_CTRL_PRT_ID				16
+#define KEY_CTRL_PRT_ID_BITS			8
+#define KEY_CTRL_PRT_ID_MAX			((1 << KEY_CTRL_PRT_ID_BITS) - 1)
+#define KEY_CTRL_PRT_ID_MASK			(((1 << KEY_CTRL_PRT_ID_BITS) - 1) << KEY_CTRL_PRT_ID)
 
-#define KEY_CTRL_HEK_SIZE				24
-#define KEY_CTRL_HEK_SIZE_BITS				6
-#define KEY_CTRL_HEK_SIZE_MAX				36
-#define KEY_CTRL_HEK_SIZE_MASK				(((1<<KEY_CTRL_HEK_SIZE_BITS) - 1) << KEY_CTRL_HEK_SIZE)
+#define KEY_CTRL_HEK_SIZE			24
+#define KEY_CTRL_HEK_SIZE_BITS			6
+#define KEY_CTRL_HEK_SIZE_MAX			36
+#define KEY_CTRL_HEK_SIZE_MASK			(((1 << KEY_CTRL_HEK_SIZE_BITS) - 1) << KEY_CTRL_HEK_SIZE)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_KEY_HEK_REG(reg_num)		(MV_PP2_REG_BASE + 0x1C34 - 4*(reg_num))
+#define MV_PP2_CLS3_KEY_HEK_REG(reg_num)	(MV_PP2_REG_BASE + 0x1C34 - 4*(reg_num))
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_QRY_ACT_REG				(MV_PP2_REG_BASE + 0x1C40)
-#define MV_PP2_CLS3_QRY_ACT				0
+#define MV_PP2_CLS3_QRY_ACT_REG			(MV_PP2_REG_BASE + 0x1C40)
+#define MV_PP2_CLS3_QRY_ACT			0
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_QRY_RES_HASH_REG(hash)		(MV_PP2_REG_BASE + 0x1C50 + 4*(hash))
-#define MV_PP2_CLS3_HASH_BANKS_NUM			8
+#define MV_PP2_CLS3_QRY_RES_HASH_REG(hash)	(MV_PP2_REG_BASE + 0x1C50 + 4*(hash))
+#define MV_PP2_CLS3_HASH_BANKS_NUM		8
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_HASH_OP_REG				(MV_PP2_REG_BASE + 0x1C84)
+#define MV_PP2_CLS3_INIT_HIT_CNT_REG	(MV_PP2_REG_BASE + 0x1C80)
+#define MV_PP2_CLS3_INIT_HIT_CNT_OFFS	6
+#define MV_PP2_CLS3_INIT_HIT_CNT_BITS	18
+#define MV_PP2_CLS3_INIT_HIT_CNT_MASK	(((1 << MV_PP2_CLS3_INIT_HIT_CNT_BITS) - 1) << MV_PP2_CLS3_INIT_HIT_CNT_OFFS)
+#define MV_PP2_CLS3_INIT_HIT_CNT_MAX	((1 << MV_PP2_CLS3_INIT_HIT_CNT_BITS) - 1)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_HASH_OP_REG			(MV_PP2_REG_BASE + 0x1C84)
+
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR		0
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS	12
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX	((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1)
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MASK	((MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX) << MV_PP2_CLS3_HASH_OP_TBL_ADDR)
 
-#define MV_PP2_CLS3_HASH_OP_TBL_ADDR			0
-#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS		12
-#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MASK		(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_HASH_OP_TBL_ADDR)
-#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX		((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1)
+/*PPv2.1 (feature MAS 3.16) MISS_PTR is new field (one bit) at HASH_OP_REG */
+#define MV_PP2_CLS3_MISS_PTR			12
+#define MV_PP2_CLS3_MISS_PTR_MASK		(1 << MV_PP2_CLS3_MISS_PTR)
 
-#define MV_PP2_CLS3_HASH_OP_DEL				14
-#define MV_PP2_CLS3_HASH_OP_ADD				15
+#define MV_PP2_CLS3_HASH_OP_DEL			14
+#define MV_PP2_CLS3_HASH_OP_ADD			15
 
-#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR		16
-#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS		8
-#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MASK		(((1 << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR)
-#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MAX		((1 << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS) - 1)
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR	16
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS	8
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MAX	((1 << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS) - 1)
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MASK	\
+		((MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MAX) << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR)
 
-#define MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL		24
+/*PPv2.1 (feature MAS 3.16) INIT_CNT_VAL field removed*/
+#define MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL	24
 /*-------------------------------------------------------------------------------*/
-#define MV_PP2_CLS3_STATE_REG				(MV_PP2_REG_BASE + 0x1C8C)
-#define MV_PP2_CLS3_STATE_CPU_DONE			0
-#define MV_PP2_CLS3_STATE_CPU_DONE_MASK			(1 << MV_PP2_CLS3_STATE_CPU_DONE)
 
-#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE		1
-#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE_MASK		(1 << MV_PP2_CLS3_STATE_CLEAR_CTR_DONE)
+#define MV_PP2_CLS3_STATE_REG			(MV_PP2_REG_BASE + 0x1C8C)
+#define MV_PP2_CLS3_STATE_CPU_DONE		0
+#define MV_PP2_CLS3_STATE_CPU_DONE_MASK		(1 << MV_PP2_CLS3_STATE_CPU_DONE)
 
-#define MV_PP2_CLS3_STATE_SC_DONE			2
-#define MV_PP2_CLS3_STATE_SC_DONE_MASK			(1 << MV_PP2_CLS3_STATE_SC_DONE)
+#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE	1
+#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE_MASK	(1 << MV_PP2_CLS3_STATE_CLEAR_CTR_DONE)
 
-#define MV_PP2_CLS3_STATE_OCCIPIED			8
-#define MV_PP2_CLS3_STATE_OCCIPIED_BITS			8
-#define MV_PP2_CLS3_STATE_OCCIPIED_MASK			(((1 << MV_PP2_CLS3_STATE_OCCIPIED_BITS) - 1) << MV_PP2_CLS3_STATE_OCCIPIED)
+#define MV_PP2_CLS3_STATE_SC_DONE		2
+#define MV_PP2_CLS3_STATE_SC_DONE_MASK		(1 << MV_PP2_CLS3_STATE_SC_DONE)
 
-#define MV_PP2_CLS3_STATE_SC_STATE			16
-#define MV_PP2_CLS3_STATE_SC_STATE_BITS			2
-#define MV_PP2_CLS3_STATE_SC_STATE_MASK			(((1 << MV_PP2_CLS3_STATE_SC_STATE_BITS) - 1) << MV_PP2_CLS3_STATE_SC_STATE)
+#define MV_PP2_CLS3_STATE_OCCIPIED		8
+#define MV_PP2_CLS3_STATE_OCCIPIED_BITS		8
+#define MV_PP2_CLS3_STATE_OCCIPIED_MASK		\
+		(((1 << MV_PP2_CLS3_STATE_OCCIPIED_BITS) - 1) << MV_PP2_CLS3_STATE_OCCIPIED)
+
+#define MV_PP2_CLS3_STATE_SC_STATE		16
+#define MV_PP2_CLS3_STATE_SC_STATE_BITS		2
+#define MV_PP2_CLS3_STATE_SC_STATE_MASK		\
+		(((1 << MV_PP2_CLS3_STATE_SC_STATE_BITS) - 1) << MV_PP2_CLS3_STATE_SC_STATE)
 /*
 SCAN STATUS
 0 - scan compleat
@@ -156,120 +181,191 @@ SCAN STATUS
 4 - scan in progress
 */
 
-#define MV_PP2_CLS3_STATE_NO_OF_SC_RES			20
-#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS		9
-#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_MASK		(((1 << MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS) - 1) << MV_PP2_CLS3_STATE_NO_OF_SC_RES)
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES		20
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS	9
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_MASK	\
+		(((1 << MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS) - 1) << MV_PP2_CLS3_STATE_NO_OF_SC_RES)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_DB_INDEX_REG			(MV_PP2_REG_BASE + 0x1C90)
+#define MV_PP2_CLS3_DB_INDEX_REG		(MV_PP2_REG_BASE + 0x1C90)
+#define MV_PP2_CLS3_DB_MISS_OFFS		12
+#define MV_PP2_CLS3_DB_MISS_MASK		(1 << MV_PP2_CLS3_DB_MISS_OFFS)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_HASH_DATA_REG(num)			(MV_PP2_REG_BASE + 0x1CA0 + 4*(num)) /* 0-3 valid val*/
-#define MV_PP2_CLS3_HASH_DATA_REG_NUM			4
-#define MV_PP2_CLS3_HASH_EXT_DATA_REG(num)		(MV_PP2_REG_BASE + 0x1CC0 + 4*(num))
-#define MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM		7
+#define MV_PP2_CLS3_HASH_DATA_REG(num)		(MV_PP2_REG_BASE + 0x1CA0 + 4*(num)) /* 0-3 valid val*/
+#define MV_PP2_CLS3_HASH_DATA_REG_NUM		4
+#define MV_PP2_CLS3_HASH_EXT_DATA_REG(num)	(MV_PP2_REG_BASE + 0x1CC0 + 4*(num))
+#define MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM	7
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_CLEAR_COUNTERS_REG			(MV_PP2_REG_BASE + 0x1D00)
-#define MV_PP2_CLS3_CLEAR_COUNTERS			5
-#define MV_PP2_CLS3_CLEAR_COUNTERS_BITS			5
-#define MV_PP2_CLS3_CLEAR_COUNTERS_MASK			(((1 << MV_PP2_CLS3_CLEAR_COUNTERS_BITS) - 1)  << MV_PP2_CLS3_CLEAR_COUNTERS)
-#define MV_PP2_CLS3_CLEAR_COUNTERS_MAX			0x1F
+#define MV_PP2_CLS3_CLEAR_COUNTERS_REG		(MV_PP2_REG_BASE + 0x1D00)
+#define MV_PP2_CLS3_CLEAR_COUNTERS		0
+/*
+  PPv2.1 (feature MAS 3.16)  CLEAR_COUNTERS size changed, clear all code changed from 0x1f to 0x3f
+*/
+#define MV_PP2_V1_CLS3_CLEAR_COUNTERS_BITS	7
+#define MV_PP2_V1_CLS3_CLEAR_ALL		0x3f
+#define MV_PP2_V1_CLS3_CLEAR_COUNTERS_MAX	0x3F
+#define MV_PP2_V1_CLS3_CLEAR_COUNTERS_MASK	((MV_PP2_V1_CLS3_CLEAR_COUNTERS_MAX) << MV_PP2_V1_CLS3_CLEAR_COUNTERS)
+
+#define MV_PP2_V0_CLS3_CLEAR_COUNTERS_BITS	5
+#define MV_PP2_V0_CLS3_CLEAR_ALL		0x1f
+#define MV_PP2_V0_CLS3_CLEAR_COUNTERS_MAX	0x1F
+#define MV_PP2_V0_CLS3_CLEAR_COUNTERS_MASK	((MV_PP2_V0_CLS3_CLEAR_COUNTERS_MAX)  << MV_PP2_V0_CLS3_CLEAR_COUNTERS)
+
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_HIT_COUNTER_REG			(MV_PP2_REG_BASE + 0x1D08)
-#define MV_PP2_CLS3_HIT_COUNTER				0
-#define MV_PP2_CLS3_HIT_COUNTER_BITS			14
-#define MV_PP2_CLS3_HIT_COUNTER_MASK			(((1 << MV_PP2_CLS3_HIT_COUNTER_BITS) - 1) << MV_PP2_CLS3_HIT_COUNTER)
+#define MV_PP2_CLS3_HIT_COUNTER_REG		(MV_PP2_REG_BASE + 0x1D08)
+#define MV_PP2_CLS3_HIT_COUNTER			0
+/*ppv2.1 his counter field size changed from 14 bits to 24 bits*/
+#define MV_PP2_V0_CLS3_HIT_COUNTER_BITS		14
+#define MV_PP2_V0_CLS3_HIT_COUNTER_MAX		((1 << MV_PP2_V0_CLS3_HIT_COUNTER_BITS) - 1)
+#define MV_PP2_V0_CLS3_HIT_COUNTER_MASK		((MV_PP2_V0_CLS3_HIT_COUNTER_MAX) << MV_PP2_CLS3_HIT_COUNTER)
+
+#define MV_PP2_V1_CLS3_HIT_COUNTER_BITS		24
+#define MV_PP2_V1_CLS3_HIT_COUNTER_MAX		((1 << MV_PP2_V1_CLS3_HIT_COUNTER_BITS) - 1)
+#define MV_PP2_V1_CLS3_HIT_COUNTER_MASK		((MV_PP2_V1_CLS3_HIT_COUNTER_MAX) << MV_PP2_CLS3_HIT_COUNTER)
+
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_SC_PROP_REG				(MV_PP2_REG_BASE + 0x1D10)
+#define MV_PP2_CLS3_SC_PROP_REG			(MV_PP2_REG_BASE + 0x1D10)
+
+#define MV_PP2_CLS3_SC_PROP_TH_MODE		0
+#define MV_PP2_CLS3_SC_PROP_TH_MODE_MASK	(1 << MV_PP2_CLS3_SC_PROP_TH_MODE)
 
-#define MV_PP2_CLS3_SC_PROP_TH_MODE			0
-#define MV_PP2_CLS3_SC_PROP_TH_MODE_MASK		(1 << MV_PP2_CLS3_SC_PROP_TH_MODE)
+#define MV_PP2_CLS3_SC_PROP_CLEAR		1
+#define MV_PP2_CLS3_SC_PROP_CLEAR_MASK		(1 << MV_PP2_CLS3_SC_PROP_CLEAR)
 
-#define MV_PP2_CLS3_SC_PROP_CLEAR			1
-#define MV_PP2_CLS3_SC_PROP_CLEAR_MASK			(1 << MV_PP2_CLS3_SC_PROP_CLEAR)
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN		3
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN_MASK	(1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN)
 
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN			3
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN_MASK		(1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN)
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE		4
+/*
+  PPv2.1 (feature MAS 3.16) LKP_TYPE size and offset changed
+*/
 
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE			4
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS		4
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX		((1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS) - 1)
-#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MASK		(((1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS) - 1) << MV_PP2_CLS3_SC_PROP_LKP_TYPE)
+#ifdef CONFIG_MV_ETH_PP2_1
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS	6
+#else
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS	4
+#endif
 
-#define MV_PP2_CLS3_SC_PROP_START_ENTRY			16
-#define MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK		(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_SC_PROP_START_ENTRY)
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX	((1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS) - 1)
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MASK	((MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX) << MV_PP2_CLS3_SC_PROP_LKP_TYPE)
+
+#define MV_PP2_CLS3_SC_PROP_START_ENTRY		16
+#define MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK	((MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX) << MV_PP2_CLS3_SC_PROP_START_ENTRY)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_SC_PROP_VAL_REG			(MV_PP2_REG_BASE + 0x1D14)
+#define MV_PP2_CLS3_SC_PROP_VAL_REG		(MV_PP2_REG_BASE + 0x1D14)
 
-#define MV_PP2_CLS3_SC_PROP_VAL_TH			0
-#define MV_PP2_CLS3_SC_PROP_VAL_TH_BITS			13
-#define MV_PP2_CLS3_SC_PROP_VAL_TH_MASK			(((1 << MV_PP2_CLS3_SC_PROP_VAL_TH_BITS) - 1) << MV_PP2_CLS3_SC_PROP_VAL_TH)
-#define MV_PP2_CLS3_SC_PROP_VAL_TH_MAX			((1 << MV_PP2_CLS3_SC_PROP_VAL_TH_BITS) - 1)
+/* ppv2.1 field removed from this reg */
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_TH		0
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_TH_BITS	13
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MAX	((1 << MV_PP2_V0_CLS3_SC_PROP_VAL_TH_BITS) - 1)
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MASK	((MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MAX) << MV_PP2_V0_CLS3_SC_PROP_VAL_TH)
+
+/* ppv2.1 field offsett changed */
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY	16
+#define MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY	0
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS	16
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX	((1 << MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS) - 1)
+#define MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY_MASK	(MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX << MV_PP2_V0_CLS3_SC_PROP_VAL_DELAY)
+#define MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY_MASK	(MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX << MV_PP2_V1_CLS3_SC_PROP_VAL_DELAY)
 
-#define MV_PP2_CLS3_SC_PROP_VAL_DELAY			16
-#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS		16
-#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK		(((1 << MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS) - 1) << MV_PP2_CLS3_SC_PROP_VAL_DELAY)
-#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX		((1 << MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS) - 1)
-/*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_SC_TIMER_REG			(MV_PP2_REG_BASE + 0x1D18)
-#define MV_PP2_CLS3_SC_TIMER				0
-#define MV_PP2_CLS3_SC_TIMER_BITS			16
-#define MV_PP2_CLS3_SC_TIMER_MASK			(((1 << MV_PP2_CLS3_SC_TIMER_BITS) - 1) << MV_PP2_CLS3_SC_TIMER)
 /*-------------------------------------------------------------------------------*/
+/* PPv2.1 new reg in cls3 */
+#define MV_PP2_CLS3_SC_TH_REG			(MV_PP2_REG_BASE + 0x1D18)
+#define MV_PP2_CLS3_SC_TH			4
+#define MV_PP2_CLS3_SC_TH_BITS			20
+#define MV_PP2_CLS3_SC_TH_MAX			((1 << MV_PP2_CLS3_SC_TH_BITS) - 1)
+#define MV_PP2_CLS3_SC_TH_MASK			(((1 << MV_PP2_CLS3_SC_TH_BITS) - 1) << MV_PP2_CLS3_SC_TH)
+
+
 
-#define MV_PP2_CLS3_SC_ACT_REG				(MV_PP2_REG_BASE + 0x1D20)
-#define MV_PP2_CLS3_SC_ACT				0
 /*-------------------------------------------------------------------------------*/
+/* ppv2.1 TIMER REG ADDRESS changed */
+#define MV_PP2_V0_CLS3_SC_TIMER_REG		(MV_PP2_REG_BASE + 0x1D18)
+#define MV_PP2_V1_CLS3_SC_TIMER_REG		(MV_PP2_REG_BASE + 0x1D1c)
 
-#define MV_PP2_CLS3_SC_INDEX_REG			(MV_PP2_REG_BASE + 0x1D28)
-#define MV_PP2_CLS3_SC_INDEX				0
+#define MV_PP2_CLS3_SC_TIMER			0
+#define MV_PP2_CLS3_SC_TIMER_BITS		16
+#define MV_PP2_CLS3_SC_TIMER_MASK		(((1 << MV_PP2_CLS3_SC_TIMER_BITS) - 1) << MV_PP2_CLS3_SC_TIMER)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_SC_RES_REG				(MV_PP2_REG_BASE + 0x1D2C)
-#define MV_PP2_CLS3_SC_RES_ENTRY			0
-#define MV_PP2_CLS3_SC_RES_ENTRY_MASK			(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_SC_RES_ENTRY)
+#define MV_PP2_CLS3_SC_ACT_REG			(MV_PP2_REG_BASE + 0x1D20)
+#define MV_PP2_CLS3_SC_ACT			0
+/*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_SC_RES_CTR				16
-#define MV_PP2_CLS3_SC_RES_CTR_MASK			(((1 << MV_PP2_CLS3_HIT_COUNTER_BITS) - 1) << MV_PP2_CLS3_SC_RES_CTR)
+#define MV_PP2_CLS3_SC_INDEX_REG		(MV_PP2_REG_BASE + 0x1D28)
+#define MV_PP2_CLS3_SC_INDEX			0
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_ACT_REG				(MV_PP2_REG_BASE + 0x1D40)
+#define MV_PP2_CLS3_SC_RES_REG			(MV_PP2_REG_BASE + 0x1D2C)
+#define MV_PP2_CLS3_SC_RES_ENTRY		0
+#define MV_PP2_CLS3_SC_RES_ENTRY_MASK		((MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX) << MV_PP2_CLS3_SC_RES_ENTRY)
+
+/*ppv2.1 field offset and size changed */
+#define MV_PP2_V0_CLS3_SC_RES_CTR		16
+#define MV_PP2_V0_CLS3_SC_RES_CTR_MASK		((MV_PP2_V0_CLS3_HIT_COUNTER_MAX) << MV_PP2_V0_CLS3_SC_RES_CTR)
+#define MV_PP2_V1_CLS3_SC_RES_CTR		12
+#define MV_PP2_V1_CLS3_SC_RES_CTR_MASK		((MV_PP2_V1_CLS3_HIT_COUNTER_MAX) << MV_PP2_V1_CLS3_SC_RES_CTR)
+
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_ACT_QOS_ATTR_REG			(MV_PP2_REG_BASE + 0x1D44)
+#define MV_PP2_CLS3_ACT_REG			(MV_PP2_REG_BASE + 0x1D40)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_ACT_HWF_ATTR_REG			(MV_PP2_REG_BASE + 0x1D48)
+#define MV_PP2_CLS3_ACT_QOS_ATTR_REG		(MV_PP2_REG_BASE + 0x1D44)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS3_ACT_DUP_ATTR_REG			(MV_PP2_REG_BASE + 0x1D4C)
+#define MV_PP2_CLS3_ACT_HWF_ATTR_REG		(MV_PP2_REG_BASE + 0x1D48)
 /*-------------------------------------------------------------------------------*/
 
+#define MV_PP2_CLS3_ACT_DUP_ATTR_REG		(MV_PP2_REG_BASE + 0x1D4C)
+/*-------------------------------------------------------------------------------*/
+/*ppv2.1: 0x1D50 0x1D54 are new registers, additional fields for action table*/
+#define MV_PP2_CLS3_ACT_SEQ_L_ATTR_REG		(MV_PP2_REG_BASE + 0x1D50)
+#define MV_PP2_CLS3_ACT_SEQ_H_ATTR_REG		(MV_PP2_REG_BASE + 0x1D54)
+#define MV_PP2_CLS3_ACT_SEQ_SIZE		38
+/*-------------------------------------------------------------------------------*/
 
 /*-------------------------------------------------------------------------------*/
 /*		Classifier C3 offsets in hash table		    		 */
 /*-------------------------------------------------------------------------------*/
+/* PPv2.1 (feature MAS 3.16) LKP_TYPE size and offset changed */
+#ifdef CONFIG_MV_ETH_PP2_1
 
-#define KEY_OCCUPIED					114
-#define KEY_FORMAT					113
-#define KEY_PTR_EXT					105
+#define KEY_OCCUPIED				116
+#define KEY_FORMAT				115
+#define KEY_PTR_EXT				107
 
-#define KEY_PRT_ID(ext_mode)				((ext_mode == 1) ? (97) : (105))
-#define KEY_PRT_ID_MASK(ext_mode)			(((1 << KEY_CTRL_PRT_ID_BITS) - 1) << (KEY_PRT_ID(ext_mode) % 32))
+#define KEY_PRT_ID(ext_mode)			((ext_mode == 1) ? (99) : (107))
+#define KEY_PRT_ID_MASK(ext_mode)		(((1 << KEY_CTRL_PRT_ID_BITS) - 1) << (KEY_PRT_ID(ext_mode) % 32))
 
-#define KEY_PRT_ID_TYPE(ext_mode)			((ext_mode == 1) ? (95) : (103))
-#define KEY_PRT_ID_TYPE_MASK(ext_mode)			(((1 << KEY_CTRL_PRT_ID_TYPE_BITS) - 1) << (KEY_PRT_ID_TYPE(ext_mode) % 32))
+#define KEY_PRT_ID_TYPE(ext_mode)		((ext_mode == 1) ? (97) : (105))
+#define KEY_PRT_ID_TYPE_MASK(ext_mode)		((KEY_CTRL_PRT_ID_TYPE_MAX) << (KEY_PRT_ID_TYPE(ext_mode) % 32))
 
-#define KEY_LKP_TYPE(ext_mode)				((ext_mode == 1) ? (91) : (99))
-#define KEY_LKP_TYPE_MASK(ext_mode)			(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << (KEY_LKP_TYPE(ext_mode) % 32))
+#else
 
-#define KEY_L4_INFO(ext_mode)				((ext_mode == 1) ? (88) : (96))
-#define KEY_L4_INFO_MASK(ext_mode)			(((1 << KEY_CTRL_L4_BITS) - 1) << (KEY_L4_INFO(ext_mode) % 32))
+#define KEY_OCCUPIED				114
+#define KEY_FORMAT				113
+#define KEY_PTR_EXT				105
+
+#define KEY_PRT_ID(ext_mode)			((ext_mode == 1) ? (97) : (105))
+#define KEY_PRT_ID_MASK(ext_mode)		(((1 << KEY_CTRL_PRT_ID_BITS) - 1) << (KEY_PRT_ID(ext_mode) % 32))
+
+#define KEY_PRT_ID_TYPE(ext_mode)		((ext_mode == 1) ? (95) : (103))
+#define KEY_PRT_ID_TYPE_MASK(ext_mode)		((KEY_CTRL_PRT_ID_TYPE_MAX) << (KEY_PRT_ID_TYPE(ext_mode) % 32))
+
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
+#define KEY_LKP_TYPE(ext_mode)			((ext_mode == 1) ? (91) : (99))
+#define KEY_LKP_TYPE_MASK(ext_mode)		(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << (KEY_LKP_TYPE(ext_mode) % 32))
+
+#define KEY_L4_INFO(ext_mode)			((ext_mode == 1) ? (88) : (96))
+#define KEY_L4_INFO_MASK(ext_mode)		(((1 << KEY_CTRL_L4_BITS) - 1) << (KEY_L4_INFO(ext_mode) % 32))
 
 
 /*-------------------------------------------------------------------------------*/
@@ -293,6 +389,7 @@ typedef struct {
 /*			Classifier C3 engine Public APIs	 		 */
 /*-------------------------------------------------------------------------------*/
 #define MV_PP2_CLS_C3_HASH_TBL_SIZE			(4096)
+#define MV_PP2_CLS_C3_MISS_TBL_SIZE			(64)
 #define MV_PP2_CLS_C3_EXT_HEK_WORDS			(9)
 #define MV_PP2_CLS_C3_SRAM_WORDS			(5)
 #define MV_PP2_CLS_C3_EXT_TBL_SIZE			(256)
@@ -305,7 +402,6 @@ typedef struct mvPp2ClsC3Entry {
 	unsigned int 	index;
 	unsigned int 	ext_index;
 
-	/* unsigned int ext_index; internal DB */
 	struct {
 		union {
 			MV_U32	words[MV_PP2_CLS_C3_EXT_HEK_WORDS];
@@ -320,6 +416,9 @@ typedef struct mvPp2ClsC3Entry {
 			MV_U32 qos_attr;/*0x1D44*/
 			MV_U32 hwf_attr;/*0x1D48*/
 			MV_U32 dup_attr;/*0x1D4C*/
+			/*ppv2.1: 0x1D50 0x1D54 are new registers, additional fields for action table*/
+			MV_U32 seq_l_attr;/*0x1D50*/
+			MV_U32 seq_h_attr;/*0x1D54*/
 		} regs;
 	} sram;
 } MV_PP2_CLS_C3_ENTRY;
@@ -340,7 +439,9 @@ void mvPp2C3ShadowClear(int index);
 
 int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index);
 int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index);
+int mvPp2ClsC3HwMissAdd(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type);
 int mvPp2ClsC3HwDump(void);
+int mvPp2ClsC3HwMissDump(void);
 int mvPp2ClsC3HwExtDump(void);
 int mvPp2ClsC3HwDel(int index);
 int mvPp2ClsC3HwDelAll(void);
@@ -349,6 +450,9 @@ void mvPp2ClsC3SwClear(MV_PP2_CLS_C3_ENTRY *c3);
 void mvPp2ClsC3HwInitCtrSet(int cntVal);
 int mvPp2ClsC3HwQuery(MV_PP2_CLS_C3_ENTRY *c3, unsigned char *occupied_bmp, int index[]);
 int mvPp2ClsC3HwQueryAdd(MV_PP2_CLS_C3_ENTRY *c3, int max_search_depth);
+
+int mvPp2ClsC3HwMissRead(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type);
+int mvPp2ClsC3HwMissDump(void);
 /*-------------------------------------------------------------------------------*/
 /*		APIs for Classification C3 key fields			   	 */
 /*-------------------------------------------------------------------------------*/
@@ -367,10 +471,21 @@ int mvPp2ClsC3QueueHighSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int q);
 int mvPp2ClsC3QueueLowSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int q);
 int mvPp2ClsC3QueueSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int queue);
 int mvPp2ClsC3ForwardSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd);
+#ifdef CONFIG_MV_ETH_PP2_1
+int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId, int bank);
+#else
 int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId);
+#endif
+int mvPp2ClsC3FlowIdEn(MV_PP2_CLS_C3_ENTRY *c3, int flowid_en);
+
+/* PPv2.1 (feature MAS 3.7) mtu - new field at action table */
+int mvPp2ClsC3MtuSet(MV_PP2_CLS_C3_ENTRY *c3, int mtu_inx);
 int mvPp2ClsC3ModSet(MV_PP2_CLS_C3_ENTRY *c3, int data_ptr, int instr_offs, int l4_csum);
 int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count);
 
+/* PPv2.1 (feature MAS 3.14) cls sequence */
+int mvPp2ClsC3SeqSet(MV_PP2_CLS_C3_ENTRY *c3, int id,  int bits_offs,  int bits);
+
 /*-------------------------------------------------------------------------------*/
 /*		APIs for Classification C3 Hit counters management	   	 */
 /*-------------------------------------------------------------------------------*/
@@ -378,6 +493,7 @@ int mvPp2ClsC3HitCntrsRead(int index, MV_U32 *cntr);
 int mvPp2ClsC3HitCntrsClearAll(void);
 int mvPp2ClsC3HitCntrsReadAll(void);
 int mvPp2ClsC3HitCntrsClear(int lkpType);
+int mvPp2ClsC3HitCntrsMissRead(int lkp_type, MV_U32 *cntr);
 
 
 /*-------------------------------------------------------------------------------*/
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
index ecbb772..1219951 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
@@ -245,9 +245,42 @@ int mvPp2ClsC4SwDump(MV_PP2_CLS_C4_ENTRY *C4)
 	/*------------------------------*/
 	/*	actions	0x1E80		*/
 	/*------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.9) Add forwarding command to C4
+*/
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvOsPrintf("ACT_TBL:COLOR	PRIO	DSCP	GPID	LOW_Q	HIGH_Q	POLICER		FWD\n");
+	mvOsPrintf("CMD:    [%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]		[%1d]\n",
+			((C4->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
+			((C4->sram.regs.actions & (ACT_PRI_MASK)) >> ACT_PRI),
+			((C4->sram.regs.actions & (ACT_DSCP_MASK)) >> ACT_DSCP),
+			((C4->sram.regs.actions & (ACT_GEM_ID_MASK)) >> ACT_GEM_ID),
+			((C4->sram.regs.actions & (ACT_LOW_Q_MASK)) >> ACT_LOW_Q),
+			((C4->sram.regs.actions & (ACT_HIGH_Q_MASK)) >> ACT_HIGH_Q),
+			((C4->sram.regs.actions & (ACT_POLICER_SELECT_MASK)) >> ACT_POLICER_SELECT),
+			((C4->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD));
+
+
+	/*------------------------------*/
+	/*	qos_attr 0x1E84		*/
+	/*------------------------------*/
+	/*mvOsPrintf("ACT_TBL:COLOR	PRIO	DSCP	GPID	LOW_Q	HIGH_Q	POLICER		FWD\n");*/
+
+	/*mvOsPrintf("VAL:		PRIO	DSCP	GPID	LOW_Q	HIGH_Q	 POLICER\n");*/
+
+	mvOsPrintf("VAL:		[%1d]	[%1d]	[%1d]	[%1d]	[0x%x]	[id 0x%2.2x bank %1.1x]\n",
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_PRI_MASK)) >> ACT_QOS_ATTR_MDF_PRI),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_DSCP_MASK)) >> ACT_QOS_ATTR_MDF_DSCP),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_GEM_ID_MASK)) >> ACT_QOS_ATTR_MDF_GEM_ID),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK)) >> ACT_QOS_ATTR_MDF_LOW_Q),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q),
+			((C4->sram.regs.dup_attr & (ACT_DUP_POLICER_MASK)) >> ACT_DUP_POLICER_ID),
+			((C4->sram.regs.dup_attr & ACT_DUP_POLICER_BANK_MASK) >> ACT_DUP_POLICER_BANK_BIT));
 
-	mvOsPrintf("ACT_TBL:	COLOR	PRIO	DSCP	GPID	LOW_Q	HIGH_Q  POLICER\n");
-	mvOsPrintf("CMD:		[%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]\n",
+#else
+	mvOsPrintf("ACT_TBL:    COLOR   PRIO    DSCP    GPID    LOW_Q   HIGH_Q  POLICER\n");
+	mvOsPrintf("CMD:                [%1d]   [%1d]   [%1d]   [%1d]   [%1d]   [%1d]   [%1d]\n",
 			((C4->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
 			((C4->sram.regs.actions & (ACT_PRI_MASK)) >> ACT_PRI),
 			((C4->sram.regs.actions & (ACT_DSCP_MASK)) >> ACT_DSCP),
@@ -270,6 +303,34 @@ int mvPp2ClsC4SwDump(MV_PP2_CLS_C4_ENTRY *C4)
 			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q),
 			((C4->sram.regs.dup_attr & (ACT_DUP_POLICER_MASK)) >> ACT_DUP_POLICER_ID));
 
+#endif
+
+
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/* PPv2.1 MASS 3.20 new feature */
+static int mvPp2V1ClsC4HwCntDump(int rule, int set, unsigned int *cnt)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(rule, (MV_PP2_CLS_C4_GRP_SIZE-1));
+	POS_RANGE_VALIDATE(set, (MV_PP2_CLS_C4_GRPS_NUM-1));
+
+	/* write index */
+	regVal =  MV_PP2_V1_CNT_IDX_RULE(rule, set);
+	mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, regVal);
+
+	/*read hit counter*/
+	regVal = mvPp2RdReg(MV_PP2_V1_CLS_C4_TBL_HIT_REG);
+
+	if (cnt)
+		*cnt = regVal;
+	else
+		mvOsPrintf("HIT COUNTER: %d\n", regVal);
+
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -282,6 +343,31 @@ int mvPp2ClsC4HwDumpAll()
 		for (rule = 0; rule <  MV_PP2_CLS_C4_GRP_SIZE; rule++) {
 			mvPp2ClsC4HwRead(&C4, rule, set);
 			mvPp2ClsC4SwDump(&C4);
+#ifdef CONFIG_MV_ETH_PP2_1
+			mvPp2V1ClsC4HwCntDump(rule, set, NULL);
+#endif
+			mvOsPrintf("--------------------------------------------------------------------\n");
+		}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/* mvPp2V1ClsC4HwHitsDump - dump all non zeroed hit counters and the associated  HWentries */
+/* PPv2.1 MASS 3.20 new feature */
+int mvPp2V1ClsC4HwHitsDump()
+{
+	int set, rule;
+	unsigned int cnt;
+	MV_PP2_CLS_C4_ENTRY C4;
+
+	for (set = 0; set < MV_PP2_CLS_C4_GRPS_NUM; set++)
+		for (rule = 0; rule <  MV_PP2_CLS_C4_GRP_SIZE; rule++) {
+			mvPp2V1ClsC4HwCntDump(rule, set, &cnt);
+			if (cnt == 0)
+				continue;
+
+			mvPp2ClsC4HwRead(&C4, rule, set);
+			mvPp2ClsC4SwDump(&C4);
+			mvOsPrintf("HITS: %d\n", cnt);
 			mvOsPrintf("--------------------------------------------------------------------\n");
 		}
 	return MV_OK;
@@ -521,6 +607,28 @@ int mvPp2ClsC4GpidSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int gid)
 }
 
 /*-------------------------------------------------------------------------------*/
+#ifdef CONFIG_MV_ETH_PP2_1
+int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId, int bank)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+	BIT_RANGE_VALIDATE(bank);
+
+	C4->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	C4->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	C4->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+
+	if (bank)
+		C4->sram.regs.dup_attr |= ACT_DUP_POLICER_BANK_MASK;
+	else
+		C4->sram.regs.dup_attr &= ~ACT_DUP_POLICER_BANK_MASK;
+
+	return MV_OK;
+}
+#else
 int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId)
 {
 	PTR_VALIDATE(C4);
@@ -534,6 +642,8 @@ int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId)
 	C4->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
 	return MV_OK;
 }
+#endif /*CONFIG_MV_ETH_PP2_1*/
+
 
 /*-------------------------------------------------------------------------------*/
 int mvPp2ClsC4QueueHighSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue)
@@ -595,7 +705,17 @@ int mvPp2ClsC4QueueSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue)
 
 }
 
+/*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.9) Add forwarding command to C4
+*/
+int mvPp2ClsC4ForwardSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, SWF_AND_LOCK);
 
-
-
+	C4->sram.regs.actions &= ~ACT_FWD_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_FWD);
+	return MV_OK;
+}
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
index ede89a4..53dfa58 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
@@ -160,7 +160,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /*-------------------------------------------------------------------------------*/
 #define MV_PP2_CLS4_ACT_DUP_ATTR_REG				(MV_PP2_REG_BASE + 0x1E88)
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new counters MAS 3.20*/
+#define MV_PP2_V1_CNT_IDX_REG				(MV_PP2_REG_BASE + 0x7040)
+#define MV_PP2_V1_CNT_IDX_RULE(rule, set)		((rule) << 3 | (set))
 
+#define MV_PP2_V1_CLS_C4_TBL_HIT_REG			(MV_PP2_REG_BASE + 0x7708)
 
 /*-------------------------------------------------------------------------------*/
 /*			Classifier C4 engine Public APIs			 */
@@ -217,6 +221,7 @@ int mvPp2ClsC4SwDump(MV_PP2_CLS_C4_ENTRY *C4);
 void mvPp2ClsC4SwClear(MV_PP2_CLS_C4_ENTRY *C4);
 void mvPp2ClsC4HwClearAll(void);
 int mvPp2ClsC4RegsDump(void);
+int mvPp2V1ClsC4HwHitsDump(void);
 int mvPp2ClsC4HwDumpAll(void);
 
 
@@ -243,9 +248,17 @@ int mvPp2ClsC4PrioSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int prio);
 int mvPp2ClsC4DscpSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int dscp);
 int mvPp2ClsC4GpidSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int gpid);
 int mvPp2ClsC4ForwardSet(MV_PP2_CLS_C4_ENTRY *c4, int cmd);
-int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId);
+#ifdef CONFIG_MV_ETH_PP2_1
+int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *c2, int cmd, int policerId, int bank);
+#else
+int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *c2, int cmd, int policerId);
+#endif
 int mvPp2ClsC4QueueHighSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
 int mvPp2ClsC4QueueLowSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
 int mvPp2ClsC4QueueSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
+/*
+  PPv2.1 (feature MAS 3.9) Add forwarding command to C4
+*/
+int mvPp2ClsC4ForwardSet(MV_PP2_CLS_C4_ENTRY *c4, int cmd);
 
 #endif /* MV_CLS4_HW */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
index 94a8658..0e5b22b 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
@@ -71,126 +71,145 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /*-------------------------------------------------------------------------------*/
 
 /*action_tbl*/
-#define ACT_TBL_ID						0
-#define ACT_TBL_ID_BITS						6
-#define ACT_TBL_ID_MASK						((1 << ACT_TBL_ID_BITS) - 1)
+#define ACT_TBL_ID			0
+#define ACT_TBL_ID_BITS			6
+#define ACT_TBL_ID_MASK			((1 << ACT_TBL_ID_BITS) - 1)
 
-#define ACT_TBL_SEL						6
-#define ACT_TBL_SEL_MASK					(1 << ACT_TBL_SEL)
+#define ACT_TBL_SEL			6
+#define ACT_TBL_SEL_MASK		(1 << ACT_TBL_SEL)
 
-#define ACT_TBL_PRI_DSCP					7
-#define ACT_TBL_PRI_DSCP_MASK					(1 << ACT_TBL_PRI_DSCP)
+#define ACT_TBL_PRI_DSCP		7
+#define ACT_TBL_PRI_DSCP_MASK		(1 << ACT_TBL_PRI_DSCP)
 
-#define ACT_TBL_GEM_ID						8
-#define ACT_TBL_GEM_ID_MASK					(1 << ACT_TBL_GEM_ID)
+#define ACT_TBL_GEM_ID			8
+#define ACT_TBL_GEM_ID_MASK		(1 << ACT_TBL_GEM_ID)
 
-#define ACT_TBL_LOW_Q						9
-#define ACT_TBL_LOW_Q_MASK					(1 << ACT_TBL_LOW_Q)
+#define ACT_TBL_LOW_Q			9
+#define ACT_TBL_LOW_Q_MASK		(1 << ACT_TBL_LOW_Q)
 
-#define ACT_TBL_HIGH_Q						10
-#define ACT_TBL_HIGH_Q_MASK					(1 << ACT_TBL_HIGH_Q)
+#define ACT_TBL_HIGH_Q			10
+#define ACT_TBL_HIGH_Q_MASK		(1 << ACT_TBL_HIGH_Q)
 
-#define ACT_TBL_COLOR						11
-#define ACT_TBL_COLOR_MASK					(1 << ACT_TBL_COLOR)
+#define ACT_TBL_COLOR			11
+#define ACT_TBL_COLOR_MASK		(1 << ACT_TBL_COLOR)
 
 /*actions*/
-#define ACT_COLOR						0
-#define ACT_COLOR_BITS						3
-#define ACT_COLOR_MASK						(((1 << ACT_COLOR_BITS) - 1) << ACT_COLOR)
+#define ACT_COLOR			0
+#define ACT_COLOR_BITS			3
+#define ACT_COLOR_MASK			(((1 << ACT_COLOR_BITS) - 1) << ACT_COLOR)
 
-#define ACT_PRI							3
-#define ACT_PRI_BITS						2
-#define ACT_PRI_MASK						(((1 << ACT_PRI_BITS) - 1) << ACT_PRI)
-#define ACT_PRI_MAX						((1 << ACT_PRI_BITS) - 1)
+#define ACT_PRI				3
+#define ACT_PRI_BITS			2
+#define ACT_PRI_MASK			(((1 << ACT_PRI_BITS) - 1) << ACT_PRI)
+#define ACT_PRI_MAX			((1 << ACT_PRI_BITS) - 1)
 
 
-#define ACT_DSCP						5
-#define ACT_DSCP_BITS						2
-#define ACT_DSCP_MASK						(((1 << ACT_DSCP_BITS) - 1) << ACT_DSCP)
+#define ACT_DSCP			5
+#define ACT_DSCP_BITS			2
+#define ACT_DSCP_MASK			(((1 << ACT_DSCP_BITS) - 1) << ACT_DSCP)
 
-#define ACT_GEM_ID						7
-#define ACT_GEM_ID_BITS						2
-#define ACT_GEM_ID_MASK						(((1 << ACT_GEM_ID_BITS) - 1) << ACT_GEM_ID)
+#define ACT_GEM_ID			7
+#define ACT_GEM_ID_BITS			2
+#define ACT_GEM_ID_MASK			(((1 << ACT_GEM_ID_BITS) - 1) << ACT_GEM_ID)
 
-#define ACT_LOW_Q						9
-#define ACT_LOW_Q_BITS						2
-#define ACT_LOW_Q_MASK						(((1 << ACT_LOW_Q_BITS) - 1) << ACT_LOW_Q)
+#define ACT_LOW_Q			9
+#define ACT_LOW_Q_BITS			2
+#define ACT_LOW_Q_MASK			(((1 << ACT_LOW_Q_BITS) - 1) << ACT_LOW_Q)
 
 
-#define ACT_HIGH_Q						11
-#define ACT_HIGH_Q_BITS						2
-#define ACT_HIGH_Q_MASK						(((1 << ACT_HIGH_Q_BITS) - 1) << ACT_HIGH_Q)
+#define ACT_HIGH_Q			11
+#define ACT_HIGH_Q_BITS			2
+#define ACT_HIGH_Q_MASK			(((1 << ACT_HIGH_Q_BITS) - 1) << ACT_HIGH_Q)
 
-#define ACT_FWD							13
-#define ACT_FWD_BITS						3
-#define ACT_FWD_MASK						(((1 << ACT_FWD_BITS) - 1) << ACT_FWD)
+#define ACT_FWD				13
+#define ACT_FWD_BITS			3
+#define ACT_FWD_MASK			(((1 << ACT_FWD_BITS) - 1) << ACT_FWD)
 
-#define ACT_POLICER_SELECT					16
-#define ACT_POLICER_SELECT_BITS					2
-#define ACT_POLICER_SELECT_MASK					(((1 << ACT_POLICER_SELECT_BITS) - 1) << ACT_POLICER_SELECT)
+#define ACT_POLICER_SELECT		16
+#define ACT_POLICER_SELECT_BITS		2
+#define ACT_POLICER_SELECT_MASK		(((1 << ACT_POLICER_SELECT_BITS) - 1) << ACT_POLICER_SELECT)
 
-#define ACT_FLOW_ID_EN						18
-#define ACT_FLOW_ID_EN_MASK					(1 << ACT_FLOW_ID_EN)
+#define ACT_FLOW_ID_EN			18
+#define ACT_FLOW_ID_EN_MASK		(1 << ACT_FLOW_ID_EN)
 
 /*qos_attr*/
-#define ACT_QOS_ATTR_MDF_PRI					0
-#define ACT_QOS_ATTR_PRI_BITS					3
-#define ACT_QOS_ATTR_MDF_PRI_MASK				(((1 << ACT_QOS_ATTR_PRI_BITS) - 1) << ACT_QOS_ATTR_MDF_PRI)
-#define ACT_QOS_ATTR_PRI_MAX					((1 << ACT_QOS_ATTR_PRI_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_PRI		0
+#define ACT_QOS_ATTR_PRI_BITS		3
+#define ACT_QOS_ATTR_MDF_PRI_MASK	(((1 << ACT_QOS_ATTR_PRI_BITS) - 1) << ACT_QOS_ATTR_MDF_PRI)
+#define ACT_QOS_ATTR_PRI_MAX		((1 << ACT_QOS_ATTR_PRI_BITS) - 1)
 
-#define ACT_QOS_ATTR_MDF_DSCP					3
-#define ACT_QOS_ATTR_DSCP_BITS					6
-#define ACT_QOS_ATTR_MDF_DSCP_MASK				(((1 << ACT_QOS_ATTR_DSCP_BITS) - 1) << ACT_QOS_ATTR_MDF_DSCP)
-#define ACT_QOS_ATTR_DSCP_MAX					((1 << ACT_QOS_ATTR_DSCP_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_DSCP		3
+#define ACT_QOS_ATTR_DSCP_BITS		6
+#define ACT_QOS_ATTR_MDF_DSCP_MASK	(((1 << ACT_QOS_ATTR_DSCP_BITS) - 1) << ACT_QOS_ATTR_MDF_DSCP)
+#define ACT_QOS_ATTR_DSCP_MAX		((1 << ACT_QOS_ATTR_DSCP_BITS) - 1)
 
-#define ACT_QOS_ATTR_MDF_GEM_ID					9
-#define ACT_QOS_ATTR_GEM_ID_BITS				12
-#define ACT_QOS_ATTR_MDF_GEM_ID_MASK				(((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1) << ACT_QOS_ATTR_MDF_GEM_ID)
-#define ACT_QOS_ATTR_GEM_ID_MAX					((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_GEM_ID		9
+#define ACT_QOS_ATTR_GEM_ID_BITS	12
+#define ACT_QOS_ATTR_MDF_GEM_ID_MASK	(((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1) << ACT_QOS_ATTR_MDF_GEM_ID)
+#define ACT_QOS_ATTR_GEM_ID_MAX		((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1)
 
 
-#define ACT_QOS_ATTR_MDF_LOW_Q					21
-#define ACT_QOS_ATTR_MDF_LOW_Q_BITS				3
-#define ACT_QOS_ATTR_MDF_LOW_Q_MAX				((1 << ACT_QOS_ATTR_MDF_LOW_Q_BITS) - 1)
-#define ACT_QOS_ATTR_MDF_LOW_Q_MASK				(ACT_QOS_ATTR_MDF_LOW_Q_MAX << ACT_QOS_ATTR_MDF_LOW_Q)
+#define ACT_QOS_ATTR_MDF_LOW_Q		21
+#define ACT_QOS_ATTR_MDF_LOW_Q_BITS	3
+#define ACT_QOS_ATTR_MDF_LOW_Q_MAX	((1 << ACT_QOS_ATTR_MDF_LOW_Q_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_LOW_Q_MASK	(ACT_QOS_ATTR_MDF_LOW_Q_MAX << ACT_QOS_ATTR_MDF_LOW_Q)
 
-#define ACT_QOS_ATTR_MDF_HIGH_Q					24
-#define ACT_QOS_ATTR_MDF_HIGH_Q_BITS				5
-#define ACT_QOS_ATTR_MDF_HIGH_Q_MAX				((1 << ACT_QOS_ATTR_MDF_HIGH_Q_BITS) - 1)
-#define ACT_QOS_ATTR_MDF_HIGH_Q_MASK				(ACT_QOS_ATTR_MDF_HIGH_Q_MAX << ACT_QOS_ATTR_MDF_HIGH_Q)
+#define ACT_QOS_ATTR_MDF_HIGH_Q		24
+#define ACT_QOS_ATTR_MDF_HIGH_Q_BITS	5
+#define ACT_QOS_ATTR_MDF_HIGH_Q_MAX	((1 << ACT_QOS_ATTR_MDF_HIGH_Q_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_HIGH_Q_MASK	(ACT_QOS_ATTR_MDF_HIGH_Q_MAX << ACT_QOS_ATTR_MDF_HIGH_Q)
 
-#define ACT_QOS_ATTR_Q_MAX					((1 << (ACT_QOS_ATTR_MDF_HIGH_Q_BITS + ACT_QOS_ATTR_MDF_LOW_Q_BITS)) - 1)
+#define ACT_QOS_ATTR_Q_MAX		((1 << (ACT_QOS_ATTR_MDF_HIGH_Q_BITS + ACT_QOS_ATTR_MDF_LOW_Q_BITS)) - 1)
 /*hwf_attr*/
 
-#define	ACT_HWF_ATTR_DPTR					1
-#define	ACT_HWF_ATTR_DPTR_BITS					14
-#define	ACT_HWF_ATTR_DPTR_MASK					(((1 << ACT_HWF_ATTR_DPTR_BITS) - 1) << ACT_HWF_ATTR_DPTR)
-#define	ACT_HWF_ATTR_DPTR_MAX					((1 << ACT_HWF_ATTR_DPTR_BITS) - 1)
+#define	ACT_HWF_ATTR_DPTR		1
+#define	ACT_HWF_ATTR_DPTR_BITS		15
+#define	ACT_HWF_ATTR_DPTR_MASK		(((1 << ACT_HWF_ATTR_DPTR_BITS) - 1) << ACT_HWF_ATTR_DPTR)
+#define	ACT_HWF_ATTR_DPTR_MAX		((1 << ACT_HWF_ATTR_DPTR_BITS) - 1)
 
-#define	ACT_HWF_ATTR_IPTR					16
-#define	ACT_HWF_ATTR_IPTR_BITS					8
-#define	ACT_HWF_ATTR_IPTR_MASK					(((1 << ACT_HWF_ATTR_IPTR_BITS) - 1) << ACT_HWF_ATTR_IPTR)
-#define	ACT_HWF_ATTR_IPTR_MAX					((1 << ACT_HWF_ATTR_IPTR_BITS) - 1)
+#define	ACT_HWF_ATTR_IPTR		16
+#define	ACT_HWF_ATTR_IPTR_BITS		8
+#define	ACT_HWF_ATTR_IPTR_MASK		(((1 << ACT_HWF_ATTR_IPTR_BITS) - 1) << ACT_HWF_ATTR_IPTR)
+#define	ACT_HWF_ATTR_IPTR_MAX		((1 << ACT_HWF_ATTR_IPTR_BITS) - 1)
+
+#define	ACT_HWF_ATTR_CHKSM_EN		24
+#define	ACT_HWF_ATTR_CHKSM_EN_MASK	(1 << ACT_HWF_ATTR_CHKSM_EN)
+
+/*
+  PPv2.1 (feature MAS 3.7) new field in action table (c2, c3)
+ */
+#define ACT_HWF_ATTR_MTU_INX		25
+#define ACT_HWF_ATTR_MTU_INX_BITS	4
+#define ACT_HWF_ATTR_MTU_INX_MAX	((1 << ACT_HWF_ATTR_MTU_INX_BITS) - 1)
+#define	ACT_HWF_ATTR_MTU_INX_MASK	((ACT_HWF_ATTR_MTU_INX_MAX) << ACT_HWF_ATTR_MTU_INX)
 
-#define	ACT_HWF_ATTR_CHKSM_EN					24
-#define	ACT_HWF_ATTR_CHKSM_EN_MASK				(1 << ACT_HWF_ATTR_CHKSM_EN)
 
 /*MV_U32 dup_attr*/
-#define ACT_DUP_FID						0
-#define ACT_DUP_FID_BITS					8
-#define ACT_DUP_FID_MASK					(((1 << ACT_DUP_FID_BITS) - 1) << ACT_DUP_FID)
-#define ACT_DUP_FID_MAX						((1 << ACT_DUP_FID_BITS) - 1)
+#define ACT_DUP_FID			0
+#define ACT_DUP_FID_BITS		8
+#define ACT_DUP_FID_MASK		(((1 << ACT_DUP_FID_BITS) - 1) << ACT_DUP_FID)
+#define ACT_DUP_FID_MAX			((1 << ACT_DUP_FID_BITS) - 1)
+
+
+#define ACT_DUP_COUNT			8
+#define ACT_DUP_COUNT_BITS		4
+#define ACT_DUP_COUNT_MASK		(((1 << ACT_DUP_COUNT_BITS) - 1) << ACT_DUP_COUNT)
+#define ACT_DUP_COUNT_MAX		14
 
+#ifdef CONFIG_MV_ETH_PP2_1
+#define ACT_DUP_POLICER_ID		24
+#define ACT_DUP_POLICER_ID_BITS		5
+#else
+#define ACT_DUP_POLICER_ID		28
+#define ACT_DUP_POLICER_ID_BITS		4
+#endif
 
-#define ACT_DUP_COUNT						8
-#define ACT_DUP_COUNT_BITS					4
-#define ACT_DUP_COUNT_MASK					(((1 << ACT_DUP_COUNT_BITS) - 1) << ACT_DUP_COUNT)
-#define ACT_DUP_COUNT_MAX					14
+#define ACT_DUP_POLICER_MASK		(((1 << ACT_DUP_POLICER_ID_BITS) - 1) << ACT_DUP_POLICER_ID)
+#define ACT_DUP_POLICER_MAX		((1 << ACT_DUP_POLICER_ID_BITS) - 1)
 
-#define ACT_DUP_POLICER_ID					28
-#define ACT_DUP_POLICER_ID_BITS					4
-#define ACT_DUP_POLICER_MASK					(((1 << ACT_DUP_POLICER_ID_BITS) - 1) << ACT_DUP_POLICER_ID)
-#define ACT_DUP_POLICER_MAX					((1 << ACT_DUP_POLICER_ID_BITS) - 1)
+/*only in ppv2.1*/
+#define ACT_DUP_POLICER_BANK_BIT	29
+#define ACT_DUP_POLICER_BANK_MASK	(1 << ACT_DUP_POLICER_BANK_BIT)
 
 
 /*-------------------------------------------------------------------------------*/
@@ -201,7 +220,9 @@ typedef enum {
 	COLOR_NO_UPDATE = 0,
 	COLOR_NO_UPDATE_AND_LOCK = 1,
 	COLOR_GREEN = 2,
+	COLOR_GREEN_AND_LOCK = 3,
 	COLOR_YELLOW = 4,
+	COLOR_YELLOW_AND_LOCK = 5,
 	COLOR_RED = 6,
 	COLOR_RED_AND_LOCK = 7
 } MV_PP2_CLS_COLOR_CMD;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
index 0f2e7a0..74b8eb0 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
@@ -178,18 +178,16 @@ int mvPp2ClsHwUniPortSet(int uni_port, int spid)
 }
 /*-------------------------------------------------------------------------------*/
 
-int mvPp2ClsHwVirtPortSet(int virt_port, int gem_portid)
+int mvPp2ClsHwVirtPortSet(int index, int gem_portid)
 {
-	unsigned int regVal;
-
-	POS_RANGE_VALIDATE(virt_port, MV_PP2_CLS_GEM_VIRT_REGS_NUM - 1);
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_GEM_VIRT_REGS_NUM - 1);
 	POS_RANGE_VALIDATE(gem_portid, MV_PP2_CLS_GEM_VIRT_MAX);
-
-	regVal = mvPp2RdReg(MV_PP2_CLS_GEM_VIRT_REG(virt_port));
-	regVal &= ~MV_PP2_CLS_GEM_VIRT_MASK;
-	regVal |= gem_portid;
-	mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_REG(virt_port), regVal);
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_INDEX_REG, index);
+	mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_REG, gem_portid);
+#else
+	mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_REG(index), gem_portid);
+#endif /* CONFIG_MV_ETH_PP2_1 */
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -217,23 +215,34 @@ int mvPp2ClsHwUdfSet(int udf_no, int offs_id, int offs_bits, int size_bits)
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
+/*
+PPv2.1 (feature MAS 3.7) feature update
+Note: this function overwrite q_high value that set by mvPp2ClsHwRxQueueHighSet
+*/
 int mvPp2ClsHwOversizeRxqSet(int port, int rxq)
 {
-	unsigned int regVal;
 
 	POS_RANGE_VALIDATE(rxq, MV_PP2_CLS_OVERSIZE_RXQ_MAX);
-
 	/* set oversize rxq */
-	regVal = mvPp2RdReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port));
-	regVal &= ~MV_PP2_CLS_OVERSIZE_RX_MASK;
-	regVal |= (rxq << MV_PP2_CLS_OVERSIZE_RXQ_OFFS);
-	mvPp2WrReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port), regVal);
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2WrReg(MV_PP2_CLS_OVERSIZE_RXQ_LOW_REG(port), rxq);
+
+	mvPp2WrReg(MV_PP2_CLS_SWFWD_P2HQ_REG(port), (rxq >> MV_PP2_CLS_OVERSIZE_RXQ_LOW_BITS));
+#else
+	{
+		unsigned int regVal;
+		regVal = mvPp2RdReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port));
+		regVal &= ~MV_PP2_CLS_OVERSIZE_RX_MASK;
+		regVal |= (rxq << MV_PP2_CLS_OVERSIZE_RXQ_OFFS);
+		mvPp2WrReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port), regVal);
+	}
+#endif /*PPv2_1*/
 
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
-
-int mvPp2ClsHwMtuSet(int port, int txp, int mtu)
+/*PPv2.1 feature changed MAS 3.7*/
+int mvPp2V0ClsHwMtuSet(int port, int txp, int mtu)
 {
 	int eport;
 	unsigned int regVal;
@@ -258,6 +267,94 @@ int mvPp2ClsHwMtuSet(int port, int txp, int mtu)
 
 }
 
+int mvPp2V1ClsHwMtuSet(int index, int mtu)
+{
+	POS_RANGE_VALIDATE(mtu, MV_PP2_CLS_MTU_MAX);
+	POS_RANGE_VALIDATE(index, 15 /* define MAX value */);
+
+	/* set mtu */
+	mvPp2WrReg(MV_PP2_CLS_MTU_REG(index), mtu);
+	return MV_OK;
+
+}
+
+/*-------------------------------------------------------------------------------
+PPv2.1 new feature MAS 3.5
+set high queue -
+	from = 0 : The value of QueueHigh is as defined by the Classifier
+	from = 1 : The value of QueueHigh set to queue
+	None: this function overwite rxq value that set by mvPp2ClsHwOversizeRxSet
+-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwRxQueueHighSet(int port, int from, int queue)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS - 1);
+	POS_RANGE_VALIDATE(from, 1);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_SWFWD_PCTRL_REG);
+
+	if (from) {
+		POS_RANGE_VALIDATE(queue, MV_PP2_CLS_SWFWD_P2HQ_QUEUE_MASK);
+		mvPp2WrReg(MV_PP2_CLS_SWFWD_P2HQ_REG(port), queue);
+		regVal |= MV_PP2_CLS_SWFWD_PCTRL_MASK(port);
+	} else
+		regVal &= ~MV_PP2_CLS_SWFWD_PCTRL_MASK(port);
+
+	mvPp2WrReg(MV_PP2_CLS_SWFWD_PCTRL_REG, regVal);
+
+	return MV_OK;
+
+}
+
+/*-------------------------------------------------------------------------------
+PPv2.1 new feature MAS 3.18
+	virtEn: port support/not support generation of virtual portId, not relevant for PON port.
+	uniEn:  port support/not support generation of UNI portId
+	mh: default Marvell header value, used for For UNI and Virtual Port ID generation
+	    in case that ETH port do not support Marvell header, not relevant for PON port.
+-------------------------------------------------------------------------------*/
+int mvPp2ClsHwMhSet(int port, int virtEn, int uniEn, unsigned short mh)
+{
+	unsigned int regVal = 0;
+	int uniDisable = 1 - uniEn;
+	int VirtDisable = 1 - virtEn;
+
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS - 1);
+	BIT_RANGE_VALIDATE(uniEn);
+	BIT_RANGE_VALIDATE(virtEn);
+	POS_RANGE_VALIDATE(mh, MV_PP2_CLS_PCTRL_MH_MASK);
+
+	if (MV_PON_PORT(port))
+		regVal = uniDisable << MV_PP2_CLS_PCTRL_UNI_EN_OFFS;
+	else
+		regVal = (uniDisable << MV_PP2_CLS_PCTRL_UNI_EN_OFFS) |
+			(VirtDisable << MV_PP2_CLS_PCTRL_VIRT_EN_OFFS) |
+			(mh << MV_PP2_CLS_PCTRL_MH_OFFS);
+
+	mvPp2WrReg(MV_PP2_CLS_PCTRL_REG(port), regVal);
+
+	return MV_OK;
+
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwSeqInstrSizeSet(int index, int size)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_SEQ_INDEX_MAX);
+	POS_RANGE_VALIDATE(size, MV_PP2_CLS_SEQ_SIZE_MAX);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_SEQ_SIZE_REG);
+	regVal &= ~MV_PP2_CLS_SEQ_SIZE_MASK(index);
+	regVal |= MV_PP2_CLS_SEQ_SIZE_VAL(index, size);
+	mvPp2WrReg(MV_PP2_CLS_SEQ_SIZE_REG, regVal);
+
+	return MV_OK;
+}
+
 /******************************************************************************/
 /***************** Classifier Top Public lkpid table APIs ********************/
 /******************************************************************************/
@@ -514,7 +611,19 @@ int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe)
 	mvOsPrintf("0x%2.2x    0x%2.2x", int32bit_1, int32bit_2);
 
 	mvOsPrintf("\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvOsPrintf("\n");
+	mvOsPrintf("       PPPEO   VLAN   MACME   UDF7   SELECT SEQ_CTRL\n");
+	mvOsPrintf("         %1d      %1d      %1d       %1d      %1d      %1d\n",
+			(fe->data[0] & FLOW_PPPOE_MASK) >> FLOW_PPPOE,
+			(fe->data[0] & FLOW_VLAN_MASK) >> FLOW_VLAN,
+			(fe->data[0] & FLOW_MACME_MASK) >> FLOW_MACME,
+			(fe->data[0] & FLOW_UDF7_MASK) >> FLOW_UDF7,
+			(fe->data[0] & FLOW_PORT_ID_SEL_MASK) >> FLOW_PORT_ID_SEL,
+			(fe->data[1] & FLOW_SEQ_CTRL_MASK) >> FLOW_SEQ_CTRL);
+	mvOsPrintf("\n");
 
+#endif
 	return MV_OK;
 }
 
@@ -591,11 +700,74 @@ int mvPp2ClsSwFlowPortSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int portid)
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwPortIdSelect(MV_PP2_CLS_FLOW_ENTRY *fe, int from)
+{
+	PTR_VALIDATE(fe);
+	BIT_RANGE_VALIDATE(from);
+
+	if (from)
+		fe->data[0] |= FLOW_PORT_ID_SEL_MASK;
+	else
+		fe->data[0] &= ~FLOW_PORT_ID_SEL_MASK;
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowPppoeSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(mode, FLOW_PPPOE_MAX);
+
+	fe->data[0] &= ~FLOW_PPPOE_MASK;
+	fe->data[0] |= (mode << FLOW_PPPOE);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowVlanSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(mode, FLOW_VLAN_MAX);
+
+	fe->data[0] &= ~FLOW_VLAN_MASK;
+	fe->data[0] |= (mode << FLOW_VLAN);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowMacMeSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(mode, FLOW_MACME_MAX);
+
+	fe->data[0] &= ~FLOW_MACME_MASK;
+	fe->data[0] |= (mode << FLOW_MACME);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowUdf7Set(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(mode, FLOW_UDF7_MAX);
+
+	fe->data[0] &= ~FLOW_UDF7_MASK;
+	fe->data[0] |= (mode << FLOW_UDF7);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
 int mvPp2ClsSwFlowEngineSet(MV_PP2_CLS_FLOW_ENTRY *fe, int engine, int is_last)
 {
 	PTR_VALIDATE(fe);
 
-	POS_RANGE_VALIDATE(is_last, 1);
+	BIT_RANGE_VALIDATE(is_last);
 	POS_RANGE_VALIDATE(engine, FLOW_ENGINE_MAX);
 
 	fe->data[0] &= ~FLOW_LAST_MASK;
@@ -608,6 +780,17 @@ int mvPp2ClsSwFlowEngineSet(MV_PP2_CLS_FLOW_ENTRY *fe, int engine, int is_last)
 
 }
 /*-------------------------------------------------------------------------------*/
+int mvPp2ClsSwFlowSeqCtrlSet(MV_PP2_CLS_FLOW_ENTRY *fe, int mode)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(mode, FLOW_ENGINE_MAX);
+
+	fe->data[1] &= ~FLOW_SEQ_CTRL_MASK;
+	fe->data[1] |= (mode << FLOW_SEQ_CTRL);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
 
 int mvPp2ClsSwFlowExtraSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int prio)
 {
@@ -690,12 +873,16 @@ int mvPp2ClsPktLenChangeWrite(int index, unsigned int data)
 {
 
 	POS_RANGE_VALIDATE(index, MV_PP2_CLS_LEN_CHANGE_TBL_SIZE);
-
+#ifdef CONFIG_MV_ETH_PP2_1
 	/*write index*/
-	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_INDEX_REG, index);
+	mvPp2WrReg(MV_PP2_V1_CLS_LEN_CHANGE_INDEX_REG, index);
 
-	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_TBL_REG, data);
+	mvPp2WrReg(MV_PP2_V1_CLS_LEN_CHANGE_TBL_REG, data);
+#else
+	mvPp2WrReg(MV_PP2_V0_CLS_LEN_CHANGE_INDEX_REG, index);
 
+	mvPp2WrReg(MV_PP2_V0_CLS_LEN_CHANGE_TBL_REG, data);
+#endif
 	return MV_OK;
 }
 /*-------------------------------------------------------------------------------*/
@@ -705,11 +892,17 @@ int mvPp2ClsPktLenChangeRead(int index, unsigned int *data)
 	PTR_VALIDATE(data);
 
 	POS_RANGE_VALIDATE(index, MV_PP2_CLS_LEN_CHANGE_TBL_SIZE);
+#ifdef CONFIG_MV_ETH_PP2_1
+	/*write index*/
+	mvPp2WrReg(MV_PP2_V1_CLS_LEN_CHANGE_INDEX_REG, index);
 
+	*data = mvPp2RdReg(MV_PP2_V1_CLS_LEN_CHANGE_TBL_REG);
+#else
 	/*write index*/
-	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_INDEX_REG, index);
+	mvPp2WrReg(MV_PP2_V0_CLS_LEN_CHANGE_INDEX_REG, index);
 
-	*data = mvPp2RdReg(MV_PP2_CLS_LEN_CHANGE_TBL_REG);
+	*data = mvPp2RdReg(MV_PP2_V0_CLS_LEN_CHANGE_TBL_REG);
+#endif
 
 	return MV_OK;
 }
@@ -796,26 +989,55 @@ int mvPp2ClsHwRegsDump()
 		mvOsSPrintf(reg_name, "MV_PP2_CLS_SPID_UNI_%d_REG", i);
 		mvPp2PrintReg((MV_PP2_CLS_SPID_UNI_BASE_REG + (4 * i)), reg_name);
 	}
-
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (i = 0; i < MV_PP2_CLS_GEM_VIRT_REGS_NUM; i++) {
+		/* indirect access */
+		mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_INDEX_REG, i);
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_GEM_VIRT_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_GEM_VIRT_REG, reg_name);
+	}
+#else
 	for (i = 0; i < MV_PP2_CLS_GEM_VIRT_REGS_NUM; i++) {
 		mvOsSPrintf(reg_name, "MV_PP2_CLS_GEM_VIRT_%d_REG", i);
 		mvPp2PrintReg(MV_PP2_CLS_GEM_VIRT_REG(i), reg_name);
 	}
-
+#endif
 	for (i = 0; i < MV_PP2_CLS_UDF_BASE_REGS; i++)	{
 		mvOsSPrintf(reg_name, "MV_PP2_CLS_UDF_REG_%d_REG", i);
-		mvPp2PrintReg((MV_PP2_CLS_UDF_BASE_REG + (4 * i)), reg_name);
+		mvPp2PrintReg(MV_PP2_CLS_UDF_REG(i), reg_name);
 	}
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (i = 0; i < 16; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_MTU_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_MTU_REG(i), reg_name);
+	}
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_OVER_RXQ_LOW_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_OVERSIZE_RXQ_LOW_REG(i), reg_name);
+	}
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_SWFWD_P2HQ_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_SWFWD_P2HQ_REG(i), reg_name);
+	}
+
+	mvPp2PrintReg(MV_PP2_CLS_SWFWD_PCTRL_REG, "MV_PP2_CLS_SWFWD_PCTRL_REG");
+	mvPp2PrintReg(MV_PP2_CLS_SEQ_SIZE_REG, "MV_PP2_CLS_SEQ_SIZE_REG");
 
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_PCTRL_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_PCTRL_REG(i), reg_name);
+	}
+#else
 	for (i = 0; i < (MV_ETH_MAX_TCONT + MV_PP2_MAX_PORTS - 1); i++) {
 		mvOsSPrintf(reg_name, "MV_PP2_CLS_MTU_%d_REG", i);
 		mvPp2PrintReg(MV_PP2_CLS_MTU_REG(i), reg_name);
 	}
 
 	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
-		mvOsSPrintf(reg_name, "MV_PP2_CLS_OVERSIZE_RXQ_%d_REG", i);
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_OVER_RXQ_%d_REG", i);
 		mvPp2PrintReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(i), reg_name);
 	}
+#endif
 
 	return MV_OK;
 }
@@ -847,6 +1069,42 @@ void mvPp2ClsHwFlowClearAll()
 
 }
 /*-------------------------------------------------------------------------------*/
+static int mvPp2V1ClsHwFlowHitGet(int index,  unsigned int *cnt)
+{
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	/*set index */
+	mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, MV_PP2_V1_CNT_IDX_FLOW(index));
+
+	if (cnt)
+		*cnt = mvPp2RdReg(MV_PP2_V1_CLS_FLOW_TBL_HIT_REG);
+	else
+		mvOsPrintf("HITS = %d\n", mvPp2RdReg(MV_PP2_V1_CLS_FLOW_TBL_HIT_REG));
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+
+static int mvPp2V1ClsHwLkpHitGet(int lkpid, int way,  unsigned int *cnt)
+{
+
+	BIT_RANGE_VALIDATE(way);
+	POS_RANGE_VALIDATE(lkpid, MV_PP2_CLS_LKP_TBL_SIZE);
+
+	/*set index */
+	mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, MV_PP2_V1_CNT_IDX_LKP(lkpid, way));
+
+	if (cnt)
+		*cnt = mvPp2RdReg(MV_PP2_V1_CLS_LKP_TBL_HIT_REG);
+	else
+		mvOsPrintf("HITS: %d\n", mvPp2RdReg(MV_PP2_V1_CLS_LKP_TBL_HIT_REG));
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
 int mvPp2ClsHwFlowDump()
 {
 	int index;
@@ -857,12 +1115,37 @@ int mvPp2ClsHwFlowDump()
 		if (mvClsFlowShadowTbl[index] == IN_USE) {
 			mvPp2ClsHwFlowRead(index, &fe);
 			mvPp2ClsSwFlowDump(&fe);
+#ifdef CONFIG_MV_ETH_PP2_1
+			mvPp2V1ClsHwFlowHitGet(index, NULL);
+#endif
 			mvOsPrintf("------------------------------------------------------------------\n");
 		}
 	}
 	return MV_OK;
 
 }
+
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new counters MAS 3.20*/
+int mvPp2V1ClsHwFlowHitsDump()
+{
+	int index;
+	unsigned int cnt;
+	MV_PP2_CLS_FLOW_ENTRY fe;
+
+	for (index = 0; index < MV_PP2_CLS_FLOWS_TBL_SIZE ; index++) {
+		if (mvClsFlowShadowTbl[index] == IN_USE) {
+			mvPp2V1ClsHwFlowHitGet(index, &cnt);
+			if (cnt != 0) {
+				mvPp2ClsHwFlowRead(index, &fe);
+				mvPp2ClsSwFlowDump(&fe);
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
 /*-------------------------------------------------------------------------------*/
 void mvPp2ClsHwLkpClearAll()
 {
@@ -881,13 +1164,36 @@ void mvPp2ClsHwLkpClearAll()
 
 }
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new counters MAS 3.20*/
+int mvPp2V1ClsHwLkpHitsDump()
+{
+	int index, way, entryInd;
+	unsigned int cnt;
+
+	mvOsPrintf("< ID  WAY >:	HITS\n");
+	for (index = 0; index < MV_PP2_CLS_LKP_TBL_SIZE ; index++)
+		for (way = 0; way < 2 ; way++)	{
+			entryInd = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | index;
+			if (mvClsLkpShadowTbl[entryInd] == IN_USE) {
+				mvPp2V1ClsHwLkpHitGet(index, way,  &cnt);
+				if (cnt != 0)
+					mvOsPrintf(" 0x%2.2x  %1.1d\t0x%8.8x\n", index, way, cnt);
+			}
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new counters MAS 3.20*/
 int mvPp2ClsHwLkpDump()
 {
 	int index, way, int32bit, ind;
 
 	MV_PP2_CLS_LKP_ENTRY fe;
-
-	mvOsPrintf("< ID  WAY >:	RXQ  	EN	FLOW	MODE_BASE\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvOsPrintf("< ID  WAY >:	RXQ	EN	FLOW	MODE_BASE  HITS\n");
+#else
+	mvOsPrintf("< ID  WAY >:	RXQ	EN	FLOW	MODE_BASE\n");
+#endif
 	for (index = 0; index < MV_PP2_CLS_LKP_TBL_SIZE ; index++)
 		for (way = 0; way < 2 ; way++)	{
 			ind = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | index;
@@ -901,9 +1207,14 @@ int mvPp2ClsHwLkpDump()
 				mvPp2ClsSwLkpFlowGet(&fe, &int32bit);
 				mvOsPrintf("0x%3.3x\t", int32bit);
 				mvPp2ClsSwLkpModGet(&fe, &int32bit);
-				mvOsPrintf(" 0x%2.2x\n", int32bit);
+				mvOsPrintf(" 0x%2.2x\t", int32bit);
+#ifdef CONFIG_MV_ETH_PP2_1
+				mvPp2V1ClsHwLkpHitGet(index, way, &int32bit);
+				mvOsPrintf(" 0x%8.8x\n", int32bit);
+#endif
+				mvOsPrintf("\n");
+
 			}
 		}
-
 	return MV_OK;
 }
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
index 8ae0b2b..b6ed1aa 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
@@ -68,142 +68,229 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "../common/mvPp2ErrCode.h"
 #include "../common/mvPp2Common.h"
 #include "../gbe/mvPp2GbeRegs.h"
+#include "../gbe/mvPp2Gbe.h"
 /*-------------------------------------------------------------------------------*/
 /*			Classifier Top Registers	    			 */
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_MODE_REG                    		(MV_PP2_REG_BASE + 0x1800)
+#define MV_PP2_CLS_MODE_REG			(MV_PP2_REG_BASE + 0x1800)
 
-#define MV_PP2_CLS_MODE_ACTIVE_BIT            	 	0
-#define MV_PP2_CLS_MODE_ACTIVE_MASK          	  	(1 << MV_PP2_CLS_MODE_ACTIVE_BIT)
+#define MV_PP2_CLS_MODE_ACTIVE_BIT		0
+#define MV_PP2_CLS_MODE_ACTIVE_MASK		(1 << MV_PP2_CLS_MODE_ACTIVE_BIT)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_PORT_WAY_REG               	 	(MV_PP2_REG_BASE + 0x1810)
+#define MV_PP2_CLS_PORT_WAY_REG			(MV_PP2_REG_BASE + 0x1810)
 
-#define MV_PP2_CLS_PORT_WAY_OFFS              		 0
-#define MV_PP2_CLS_PORT_WAY_MASK(port)        	 	(1 << ((port) + MV_PP2_CLS_PORT_WAY_OFFS))
-#define WAY_MAX						 1
+#define MV_PP2_CLS_PORT_WAY_OFFS		0
+#define MV_PP2_CLS_PORT_WAY_MASK(port)		(1 << ((port) + MV_PP2_CLS_PORT_WAY_OFFS))
+#define WAY_MAX					1
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_LKP_INDEX_REG            	 	(MV_PP2_REG_BASE + 0x1814)
+#define MV_PP2_CLS_LKP_INDEX_REG		(MV_PP2_REG_BASE + 0x1814)
 
-#define MV_PP2_CLS_LKP_INDEX_LKP_OFFS        		0
-#define MV_PP2_CLS_LKP_INDEX_WAY_OFFS	 		6
-#define MV_PP2_CLS_LKP_INDEX_BITS		 	7
-#define MV_PP2_CLS_LKP_INDEX_MASK			((1 << MV_PP2_CLS_LKP_INDEX_BITS) - 1)
-#define MV_PP2_CLS_LKP_WAY_MASK				(1 << MV_PP2_CLS_LKP_INDEX_WAY_OFFS)
+#define MV_PP2_CLS_LKP_INDEX_LKP_OFFS		0
+#define MV_PP2_CLS_LKP_INDEX_WAY_OFFS		6
+#define MV_PP2_CLS_LKP_INDEX_BITS		7
+#define MV_PP2_CLS_LKP_INDEX_MASK		((1 << MV_PP2_CLS_LKP_INDEX_BITS) - 1)
+#define MV_PP2_CLS_LKP_WAY_MASK			(1 << MV_PP2_CLS_LKP_INDEX_WAY_OFFS)
 
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_LKP_TBL_REG				(MV_PP2_REG_BASE + 0x1818)
+#define MV_PP2_CLS_LKP_TBL_REG			(MV_PP2_REG_BASE + 0x1818)
 
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_FLOW_INDEX_REG              		 (MV_PP2_REG_BASE + 0x1820)
+#define MV_PP2_CLS_FLOW_INDEX_REG		(MV_PP2_REG_BASE + 0x1820)
 
-#define MV_PP2_CLS_FLOW_INDEX_BITS			 9
-#define MV_PP2_CLS_FLOW_INDEX_MASK			 ((1 << MV_PP2_CLS_FLOW_INDEX_BITS) - 1)
+#define MV_PP2_CLS_FLOW_INDEX_BITS		9
+#define MV_PP2_CLS_FLOW_INDEX_MASK		((1 << MV_PP2_CLS_FLOW_INDEX_BITS) - 1)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_FLOW_TBL0_REG			(MV_PP2_REG_BASE + 0x1824)
-#define MV_PP2_CLS_FLOW_TBL1_REG			(MV_PP2_REG_BASE + 0x1828)
-#define MV_PP2_CLS_FLOW_TBL2_REG			(MV_PP2_REG_BASE + 0x182c)
+#define MV_PP2_CLS_FLOW_TBL0_REG		(MV_PP2_REG_BASE + 0x1824)
+#define MV_PP2_CLS_FLOW_TBL1_REG		(MV_PP2_REG_BASE + 0x1828)
+#define MV_PP2_CLS_FLOW_TBL2_REG		(MV_PP2_REG_BASE + 0x182c)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_PORT_SPID_REG                	(MV_PP2_REG_BASE + 0x1830)
+#define MV_PP2_CLS_PORT_SPID_REG		(MV_PP2_REG_BASE + 0x1830)
 
-#define MV_PP2_CLS_PORT_SPID_BITS               	2
-#define MV_PP2_CLS_PORT_SPID_MAX                	((1 << MV_PP2_CLS_PORT_SPID_BITS) - 1)
-#define MV_PP2_CLS_PORT_SPID_MASK(port)         	(((1 << MV_PP2_CLS_PORT_SPID_BITS) - 1) << ((port) * MV_PP2_CLS_PORT_SPID_BITS))
-#define MV_PP2_CLS_PORT_SPID_VAL(port, val)     	((val) << ((port) * MV_PP2_CLS_PORT_SPID_BITS));
+#define MV_PP2_CLS_PORT_SPID_BITS		2
+#define MV_PP2_CLS_PORT_SPID_MAX		((1 << MV_PP2_CLS_PORT_SPID_BITS) - 1)
+#define MV_PP2_CLS_PORT_SPID_MASK(port)		((MV_PP2_CLS_PORT_SPID_MAX) << ((port) * MV_PP2_CLS_PORT_SPID_BITS))
+#define MV_PP2_CLS_PORT_SPID_VAL(port, val)	((val) << ((port) * MV_PP2_CLS_PORT_SPID_BITS));
 
 /* PORT - SPID types */
-#define PORT_SPID_MH					0
-#define PORT_SPID_EXT_SWITCH				1
-#define PORT_SPID_CAS_SWITCH				2
-#define PORT_SPID_PORT_TRUNK				3
+#define PORT_SPID_MH				0
+#define PORT_SPID_EXT_SWITCH			1
+#define PORT_SPID_CAS_SWITCH			2
+#define PORT_SPID_PORT_TRUNK			3
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_SPID_UNI_BASE_REG   	       		(MV_PP2_REG_BASE + 0x1840)
-#define MV_PP2_CLS_SPID_UNI_REG(spid)         		(MV_PP2_CLS_SPID_UNI_BASE_REG + (((spid) >> 3) * 4))
+#define MV_PP2_CLS_SPID_UNI_BASE_REG		(MV_PP2_REG_BASE + 0x1840)
+#define MV_PP2_CLS_SPID_UNI_REG(spid)		(MV_PP2_CLS_SPID_UNI_BASE_REG + (((spid) >> 3) * 4))
+
+#define MV_PP2_CLS_SPID_MAX			31
+#define MV_PP2_CLS_SPID_UNI_REGS		4
+#define MV_PP2_CLS_SPID_UNI_BITS		3
+#define MV_PP2_CLS_SPID_UNI_FIXED_BITS		4
+#define MV_PP2_CLS_SPID_UNI_MAX			((1 << MV_PP2_CLS_SPID_UNI_BITS) - 1)
+#define MV_PP2_CLS_SPID_UNI_OFFS(spid)		(((spid) % 8) * MV_PP2_CLS_SPID_UNI_FIXED_BITS)
+#define MV_PP2_CLS_SPID_UNI_MASK(spid)		((MV_PP2_CLS_SPID_UNI_MAX) << (MV_PP2_CLS_SPID_UNI_OFFS(spid)))
+#define MV_PP2_CLS_SPID_UNI_VAL(spid, val)	((val) << (MV_PP2_CLS_SPID_UNI_OFFS(spid)))
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_GEM_VIRT_INDEX_REG		(MV_PP2_REG_BASE + 0x1A00)
+#define MV_PP2_CLS_GEM_VIRT_INDEX_BITS		(7)
+#define MV_PP2_CLS_GEM_VIRT_INDEX_MAX		(((1 << MV_PP2_CLS_GEM_VIRT_INDEX_BITS) - 1) << 0)
+/*-------------------------------------------------------------------------------*/
+#ifdef CONFIG_MV_ETH_PP2_1
+/* indirect rd/wr via index GEM_VIRT_INDEX */
+#define MV_PP2_CLS_GEM_VIRT_REGS_NUM		128
+#define MV_PP2_CLS_GEM_VIRT_REG			(MV_PP2_REG_BASE + 0x1A04)
+#else
+/* direct rd/wr */
+#define MV_PP2_CLS_GEM_VIRT_REGS_NUM		64
+#define MV_PP2_CLS_GEM_VIRT_BASE_REG		(MV_PP2_REG_BASE + 0x1A00)
+#define MV_PP2_CLS_GEM_VIRT_REG(index)		(MV_PP2_CLS_GEM_VIRT_BASE_REG + ((index) * 4))
+#endif
+
+#define MV_PP2_CLS_GEM_VIRT_BITS		12
+#define MV_PP2_CLS_GEM_VIRT_MAX			((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1)
+#define MV_PP2_CLS_GEM_VIRT_MASK		(((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1) << 0)
 
-#define MV_PP2_CLS_SPID_MAX				31
-#define MV_PP2_CLS_SPID_UNI_REGS   	        	4
-#define MV_PP2_CLS_SPID_UNI_BITS               		3
-#define MV_PP2_CLS_SPID_UNI_FIXED_BITS         		4
-#define MV_PP2_CLS_SPID_UNI_MAX                		((1 << MV_PP2_CLS_SPID_UNI_BITS) - 1)
-#define MV_PP2_CLS_SPID_UNI_MASK(spid)			(((1 << MV_PP2_CLS_SPID_UNI_BITS) - 1) << (((spid) % 8) * MV_PP2_CLS_SPID_UNI_FIXED_BITS))
-#define MV_PP2_CLS_SPID_UNI_VAL(spid, val)		((val) << (((spid) % 8) * MV_PP2_CLS_SPID_UNI_FIXED_BITS))
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_UDF_BASE_REG			(MV_PP2_REG_BASE + 0x1860)
+#define MV_PP2_CLS_UDF_REG(index)		(MV_PP2_CLS_UDF_BASE_REG + ((index) * 4)) /*index <=63*/
+#define MV_PP2_CLS_UDF_REGS_NUM			64
+
+#define MV_PP2_CLS_UDF_BASE_REGS		8
+#define MV_PP2_CLS_UDF_OFFSET_ID_OFFS		0
+#define MV_PP2_CLS_UDF_OFFSET_ID_BITS		4
+#define MV_PP2_CLS_UDF_OFFSET_ID_MAX		((1 << MV_PP2_CLS_UDF_OFFSET_ID_BITS) - 1)
+#define MV_PP2_CLS_UDF_OFFSET_ID_MASK		((MV_PP2_CLS_UDF_OFFSET_ID_MAX) << MV_PP2_CLS_UDF_OFFSET_ID_OFFS)
+
+#define MV_PP2_CLS_UDF_REL_OFFSET_OFFS		4
+#define MV_PP2_CLS_UDF_REL_OFFSET_BITS		11
+#define MV_PP2_CLS_UDF_REL_OFFSET_MAX		((1 << MV_PP2_CLS_UDF_REL_OFFSET_BITS) - 1)
+#define MV_PP2_CLS_UDF_REL_OFFSET_MASK		((MV_PP2_CLS_UDF_REL_OFFSET_MAX) << MV_PP2_CLS_UDF_REL_OFFSET_OFFS)
+
+#define MV_PP2_CLS_UDF_SIZE_OFFS		16
+#define MV_PP2_CLS_UDF_SIZE_BITS		8
+#define MV_PP2_CLS_UDF_SIZE_MAX			((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1)
+#define MV_PP2_CLS_UDF_SIZE_MASK		(((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1) << MV_PP2_CLS_UDF_SIZE_OFFS)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_CLS_GEM_VIRT_BASE_REG			(MV_PP2_REG_BASE + 0x1A00)
-#define MV_PP2_CLS_GEM_VIRT_REG(gem_id)			(MV_PP2_CLS_GEM_VIRT_BASE_REG + (4 * (gem_id)))
-#define MV_PP2_CLS_GEM_VIRT_REGS_NUM			64
-#define MV_PP2_CLS_GEM_VIRT_BITS			12
-#define MV_PP2_CLS_GEM_VIRT_MAX				((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1)
-#define MV_PP2_CLS_GEM_VIRT_MASK			(((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1) << 0)
+#define MV_PP2_CLS_MTU_BASE_REG			(MV_PP2_REG_BASE + 0x1900)
+/*
+  in PPv2.1 (feature MAS 3.7) num indicate an mtu reg index
+  in PPv2.0 num (<=31) indicate eport number , 0-15 pon txq,  16-23 ethernet
+*/
+#define MV_PP2_CLS_MTU_REG(num)			(MV_PP2_CLS_MTU_BASE_REG + ((num) * 4))
+#define MV_PP2_CLS_MTU_OFFS			0
+#define MV_PP2_CLS_MTU_BITS			16
+#define MV_PP2_CLS_MTU_MAX			((1 << MV_PP2_CLS_MTU_BITS) - 1)
+#define MV_PP2_CLS_MTU_MASK			(((1 << MV_PP2_CLS_MTU_BITS) - 1) << MV_PP2_CLS_MTU_OFFS)
 /*-------------------------------------------------------------------------------*/
-#define MV_PP2_CLS_UDF_BASE_REG				(MV_PP2_REG_BASE + 0x1860)
-#define MV_PP2_CLS_UDF_REG(index)			(MV_PP2_CLS_UDF_BASE_REG + ((index) * 4)) /*index <=63*/
-#define MV_PP2_CLS_UDF_REGS_NUM				64
+/*
+  PPv2.1 (feature MAS 3.7) MV_PP2_V0_CLS_OVERSIZE_RXQ_BASE_REG removed
+*/
+#define MV_PP2_V0_CLS_OVERSIZE_RXQ_BASE_REG	(MV_PP2_REG_BASE + 0x1980)
+#define MV_PP2_CLS_OVERSIZE_RXQ_REG(eport)	(MV_PP2_V0_CLS_OVERSIZE_RXQ_BASE_REG + (4 * (eport))) /*eport <=23*/
+#define MV_PP2_CLS_OVERSIZE_RXQ_BITS		8
+#define MV_PP2_CLS_OVERSIZE_RXQ_MAX		((1 << MV_PP2_CLS_OVERSIZE_RXQ_BITS) - 1)
+#define MV_PP2_CLS_OVERSIZE_RXQ_OFFS		0
+#define MV_PP2_CLS_OVERSIZE_RX_MASK		((MV_PP2_CLS_OVERSIZE_RXQ_MAX) << MV_PP2_CLS_OVERSIZE_RXQ_OFFS)
+
+/*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 (feature MAS 3.7) new registers
+*/
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_BASE_REG	(MV_PP2_REG_BASE + 0x1980)
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_REG(port)	(MV_PP2_CLS_OVERSIZE_RXQ_LOW_BASE_REG + ((port) * 4))
 
-#define MV_PP2_CLS_UDF_BASE_REGS			8
-#define MV_PP2_CLS_UDF_OFFSET_ID_OFFS			0
-#define MV_PP2_CLS_UDF_OFFSET_ID_BITS			4
-#define MV_PP2_CLS_UDF_OFFSET_ID_MAX			((1 << MV_PP2_CLS_UDF_OFFSET_ID_BITS) - 1)
-#define MV_PP2_CLS_UDF_OFFSET_ID_MASK			(((1 << MV_PP2_CLS_UDF_OFFSET_ID_BITS) - 1) << MV_PP2_CLS_UDF_OFFSET_ID_OFFS)
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_OFF		0
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_BITS	3
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_MAX		((1 << MV_PP2_CLS_OVERSIZE_RXQ_LOW_BITS) - 1)
+#define MV_PP2_CLS_OVERSIZE_RXQ_LOW_MASK	((MV_PP2_CLS_OVERSIZE_RXQ_LOW_MAX) << MV_PP2_CLS_OVERSIZE_RXQ_LOW_OFF)
 
-#define MV_PP2_CLS_UDF_REL_OFFSET_OFFS			4
-#define MV_PP2_CLS_UDF_REL_OFFSET_BITS			11
-#define MV_PP2_CLS_UDF_REL_OFFSET_MAX			((1 << MV_PP2_CLS_UDF_REL_OFFSET_BITS) - 1)
-#define MV_PP2_CLS_UDF_REL_OFFSET_MASK			(((1 << MV_PP2_CLS_UDF_REL_OFFSET_BITS) - 1) << MV_PP2_CLS_UDF_REL_OFFSET_OFFS)
+/*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 len changed table moved to tx general
+*/
+#define MV_PP2_V0_CLS_LEN_CHANGE_INDEX_REG	(MV_PP2_REG_BASE + 0x19A0)
+#define MV_PP2_V1_CLS_LEN_CHANGE_INDEX_REG	(MV_PP2_REG_BASE + 0x8808)
 
-#define MV_PP2_CLS_UDF_SIZE_OFFS			16
-#define MV_PP2_CLS_UDF_SIZE_BITS			8
-#define MV_PP2_CLS_UDF_SIZE_MAX				((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1)
-#define MV_PP2_CLS_UDF_SIZE_MASK			(((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1) << MV_PP2_CLS_UDF_SIZE_OFFS)
 /*-------------------------------------------------------------------------------*/
+/*
+  PPv2.1 len changed table moved to tx general
+*/
+#define MV_PP2_V0_CLS_LEN_CHANGE_TBL_REG	(MV_PP2_REG_BASE + 0x19A4)
+#define MV_PP2_V1_CLS_LEN_CHANGE_TBL_REG	(MV_PP2_REG_BASE + 0x880c)
+
 
-#define MV_PP2_CLS_MTU_BASE_REG				(MV_PP2_REG_BASE + 0x1900)
-#define MV_PP2_CLS_MTU_REG(eport)			(MV_PP2_CLS_MTU_BASE_REG + ((eport) * 4)) /*eport <=31*/
-/* 0-15 pon txq,  16-23 ethernet */
-#define MV_PP2_CLS_MTU_OFFS				0
-#define MV_PP2_CLS_MTU_BITS				16
-#define MV_PP2_CLS_MTU_MAX				((1 << MV_PP2_CLS_MTU_BITS) - 1)
-#define MV_PP2_CLS_MTU_MASK				(((1 << MV_PP2_CLS_MTU_BITS) - 1) << MV_PP2_CLS_MTU_OFFS)
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.5*/
+#define MV_PP2_CLS_SWFWD_P2HQ_BASE_REG		(MV_PP2_REG_BASE + 0x19B0)
+#define MV_PP2_CLS_SWFWD_P2HQ_REG(eport)	(MV_PP2_CLS_SWFWD_P2HQ_BASE_REG + ((eport) * 4))
+
+#define MV_PP2_CLS_SWFWD_P2HQ_QUEUE_OFF		0
+#define MV_PP2_CLS_SWFWD_P2HQ_QUEUE_BITS	5
+#define MV_PP2_CLS_SWFWD_P2HQ_QUEUE_MAX		((1 << MV_PP2_CLS_SWFWD_P2HQ_QUEUE_BITS) - 1)
+#define MV_PP2_CLS_SWFWD_P2HQ_QUEUE_MASK	((MV_PP2_CLS_SWFWD_P2HQ_QUEUE_MAX) << MV_PP2_CLS_SWFWD_P2HQ_QUEUE_OFF)
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.5*/
+#define MV_PP2_CLS_SWFWD_PCTRL_REG		(MV_PP2_REG_BASE + 0x19D0)
+#define MV_PP2_CLS_SWFWD_PCTRL_OFF		0
+#define MV_PP2_CLS_SWFWD_PCTRL_MASK(port)	(1 << ((port) + MV_PP2_CLS_SWFWD_PCTRL_OFF))
 
-#define MV_PP2_CLS_OVERSIZE_RXQ_BASE_REG		(MV_PP2_REG_BASE + 0x1980)
-#define MV_PP2_CLS_OVERSIZE_RXQ_REG(eport)		(MV_PP2_CLS_OVERSIZE_RXQ_BASE_REG + (4 * (eport))) /*eport <=23*/
-#define MV_PP2_CLS_OVERSIZE_RXQ_BITS			9
-#define MV_PP2_CLS_OVERSIZE_RXQ_MAX			((1 << MV_PP2_CLS_OVERSIZE_RXQ_BITS) - 1)
-#define MV_PP2_CLS_OVERSIZE_RXQ_OFFS			0
-#define MV_PP2_CLS_OVERSIZE_RX_MASK			(((1 << MV_PP2_CLS_OVERSIZE_RXQ_BITS) - 1) << MV_PP2_CLS_OVERSIZE_RXQ_OFFS)
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new feature MAS 3.14*/
+#define MV_PP2_CLS_SEQ_SIZE_REG			(MV_PP2_REG_BASE + 0x19D4)
+#define MV_PP2_CLS_SEQ_SIZE_BITS		4
+#define MV_PP2_CLS_SEQ_INDEX_MAX		7
+#define MV_PP2_CLS_SEQ_SIZE_MAX			8
+#define MV_PP2_CLS_SEQ_SIZE_MASK(index)		\
+		(((1 << MV_PP2_CLS_SEQ_SIZE_BITS) - 1) << (MV_PP2_CLS_SEQ_SIZE_BITS * (index)))
+#define MV_PP2_CLS_SEQ_SIZE_VAL(index, val)	((val) << ((index) * MV_PP2_CLS_SEQ_SIZE_BITS))
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 new register MAS 3.18*/
+#define MV_PP2_CLS_PCTRL_BASE_REG		(MV_PP2_REG_BASE + 0x1880)
+#define MV_PP2_CLS_PCTRL_REG(port)		(MV_PP2_CLS_PCTRL_BASE_REG + 4 * (port))
+#define MV_PP2_CLS_PCTRL_MH_OFFS		0
+#define MV_PP2_CLS_PCTRL_MH_BITS		16
+#define MV_PP2_CLS_PCTRL_MH_MASK		(((1 << MV_PP2_CLS_PCTRL_MH_BITS) - 1) << MV_PP2_CLS_PCTRL_MH_OFFS)
+
+#define MV_PP2_CLS_PCTRL_VIRT_EN_OFFS		16
+#define MV_PP2_CLS_PCTRL_VIRT_EN_MASK		(1 << MV_PP2_CLS_PCTRL_VIRT_EN_OFFS)
+
+#define MV_PP2_CLS_PCTRL_UNI_EN_OFFS		17
+#define MV_PP2_CLS_PCTRL_UNI_EN_MASK		(1 << MV_PP2_CLS_PCTRL_UNI_EN_OFFS)
 
-#define MV_PP2_CLS_LEN_CHANGE_INDEX_REG			(MV_PP2_REG_BASE + 0x19A0)
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 new counters MAS 3.20*/
+#define MV_PP2_V1_CNT_IDX_REG			(MV_PP2_REG_BASE + 0x7040)
+#define MV_PP2_V1_CNT_IDX_LKP(lkp, way)		((way) << 6 | (lkp))
+#define MV_PP2_V1_CNT_IDX_FLOW(index)		(index)
 
-#define MV_PP2_CLS_LEN_CHANGE_TBL_REG			(MV_PP2_REG_BASE + 0x19A4)
+#define MV_PP2_V1_CLS_LKP_TBL_HIT_REG		(MV_PP2_REG_BASE + 0x7700)
+#define MV_PP2_V1_CLS_FLOW_TBL_HIT_REG		(MV_PP2_REG_BASE + 0x7704)
 
 /*-------------------------------------------------------------------------------*/
 /*			 lkpid table structure					 */
 /*-------------------------------------------------------------------------------*/
-#define FLOWID_RXQ					0
-#define FLOWID_RXQ_BITS					8
-#define FLOWID_RXQ_MASK					(((1 << FLOWID_RXQ_BITS) - 1) << FLOWID_RXQ)
+#define FLOWID_RXQ				0
+#define FLOWID_RXQ_BITS				8
+#define FLOWID_RXQ_MASK				(((1 << FLOWID_RXQ_BITS) - 1) << FLOWID_RXQ)
 
-#define FLOWID_MODE					8
-#define FLOWID_MODE_BITS				8
-#define FLOWID_MODE_MASK				(((1 << FLOWID_MODE_BITS) - 1) << FLOWID_MODE)
-#define FLOWID_MODE_MAX					((1 << FLOWID_MODE_BITS) - 1)
+#define FLOWID_MODE				8
+#define FLOWID_MODE_BITS			8
+#define FLOWID_MODE_MASK			(((1 << FLOWID_MODE_BITS) - 1) << FLOWID_MODE)
+#define FLOWID_MODE_MAX				((1 << FLOWID_MODE_BITS) - 1)
 
-#define FLOWID_FLOW					16
-#define FLOWID_FLOW_BITS				9
-#define FLOWID_FLOW_MASK				(((1 << FLOWID_FLOW_BITS) - 1) << FLOWID_FLOW)
+#define FLOWID_FLOW				16
+#define FLOWID_FLOW_BITS			9
+#define FLOWID_FLOW_MASK			(((1 << FLOWID_FLOW_BITS) - 1) << FLOWID_FLOW)
 
-#define FLOWID_EN					25 /*one bit */
-#define FLOWID_EN_MASK					(1 << FLOWID_EN)
+#define FLOWID_EN				25 /*one bit */
+#define FLOWID_EN_MASK				(1 << FLOWID_EN)
 
 
 /*-------------------------------------------------------------------------------*/
@@ -212,62 +299,111 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /*-------------------------------  DWORD 0  ------------------------------------ */
 
-#define FLOW_LAST					0
-#define FLOW_LAST_MASK					1 /*one bit*/
+#define FLOW_LAST				0
+#define FLOW_LAST_MASK				1 /*one bit*/
 
-#define FLOW_ENGINE					1
-#define FLOW_ENGINE_BITS				3
-#define FLOW_ENGINE_MASK				(((1 << FLOW_ENGINE_BITS) - 1) << FLOW_ENGINE)
-#define FLOW_ENGINE_MAX					5 /* valid value 1 - 5 */
+#define FLOW_ENGINE				1
+#define FLOW_ENGINE_BITS			3
+#define FLOW_ENGINE_MASK			(((1 << FLOW_ENGINE_BITS) - 1) << FLOW_ENGINE)
+#define FLOW_ENGINE_MAX				5 /* valid value 1 - 5 */
 
-#define FLOW_PORT_ID					4
-#define FLOW_PORT_ID_BITS				8
-#define FLOW_PORT_ID_MASK				(((1 << FLOW_PORT_ID_BITS) - 1) << FLOW_PORT_ID)
-#define FLOW_PORT_ID_MAX				((1 << FLOW_PORT_ID_BITS) - 1)
+#define FLOW_PORT_ID				4
+#define FLOW_PORT_ID_BITS			8
+#define FLOW_PORT_ID_MASK			(((1 << FLOW_PORT_ID_BITS) - 1) << FLOW_PORT_ID)
+#define FLOW_PORT_ID_MAX			((1 << FLOW_PORT_ID_BITS) - 1)
 
-#define FLOW_PORT_TYPE					12
-#define FLOW_PORT_TYPE_BITS				2
-#define FLOW_PORT_TYPE_MASK				(((1 << FLOW_PORT_TYPE_BITS) - 1) << FLOW_PORT_TYPE)
-#define FLOW_PORT_TYPE_MAX				2 /* valid value 0 - 2 */
+#define FLOW_PORT_TYPE				12
+#define FLOW_PORT_TYPE_BITS			2
+#define FLOW_PORT_TYPE_MASK			(((1 << FLOW_PORT_TYPE_BITS) - 1) << FLOW_PORT_TYPE)
+#define FLOW_PORT_TYPE_MAX			2 /* valid value 0 - 2 */
+
+/*
+  PPv2.1  FLOW_PPPOE new fields in word 0
+*/
+
+#define FLOW_PPPOE				14
+#define FLOW_PPPOE_BITS				2
+#define FLOW_PPPOE_MASK				(((1 << FLOW_PPPOE_BITS) - 1) << FLOW_PPPOE)
+#define FLOW_PPPOE_MAX				2 /* valid value 0 - 2 */
+
+/*
+  PPv2.1  FLOW_VLAN new fields in word 0
+*/
+#define FLOW_VLAN				16
+#define FLOW_VLAN_BITS				3
+#define FLOW_VLAN_MASK				(((1 << FLOW_VLAN_BITS) - 1) << FLOW_VLAN)
+#define FLOW_VLAN_MAX				((1 << FLOW_VLAN_BITS) - 1)
+
+/*
+  PPv2.1  FLOW_MACME new fields in word 0
+*/
+#define FLOW_MACME				19
+#define FLOW_MACME_BITS				2
+#define FLOW_MACME_MASK				(((1 << FLOW_MACME_BITS) - 1) << FLOW_MACME)
+#define FLOW_MACME_MAX				2 /* valid value 0 - 2 */
+
+/*
+  PPv2.1  FLOW_UDF7 new fields in word 0
+*/
+#define FLOW_UDF7				21
+#define FLOW_UDF7_BITS				2
+#define FLOW_UDF7_MASK				(((1 << FLOW_UDF7_BITS) - 1) << FLOW_UDF7)
+#define FLOW_UDF7_MAX				((1 << FLOW_UDF7_BITS) - 1)
+
+/*
+  PPv2.1  FLOW_PORT_ID_SEL new bit in word 0
+*/
+#define FLOW_PORT_ID_SEL			23
+#define FLOW_PORT_ID_SEL_MASK			(1 << FLOW_PORT_ID_SEL)
 
 /*-------------------------------  DWORD 1  ------------------------------------ */
 
-#define FLOW_FIELDS_NUM					0
-#define FLOW_FIELDS_NUM_BITS				3
-#define FLOW_FIELDS_NUM_MASK				(((1 << FLOW_FIELDS_NUM_BITS) - 1) << FLOW_FIELDS_NUM)
-#define FLOW_FIELDS_NUM_MAX				4 /*valid vaue 0 - 4 */
+#define FLOW_FIELDS_NUM				0
+#define FLOW_FIELDS_NUM_BITS			3
+#define FLOW_FIELDS_NUM_MASK			(((1 << FLOW_FIELDS_NUM_BITS) - 1) << FLOW_FIELDS_NUM)
+#define FLOW_FIELDS_NUM_MAX			4 /*valid vaue 0 - 4 */
+
+#define FLOW_LKP_TYPE				3
+#define FLOW_LKP_TYPE_BITS			6
+#define FLOW_LKP_TYPE_MASK			(((1 << FLOW_LKP_TYPE_BITS) - 1) << FLOW_LKP_TYPE)
+#define FLOW_LKP_TYPE_MAX			((1 << FLOW_LKP_TYPE_BITS) - 1)
+
+#define FLOW_FIELED_PRIO			9
+#define FLOW_FIELED_PRIO_BITS			6
+#define FLOW_FIELED_PRIO_MASK			(((1 << FLOW_FIELED_PRIO_BITS) - 1) << FLOW_FIELED_PRIO)
+#define FLOW_FIELED_PRIO_MAX			((1 << FLOW_FIELED_PRIO_BITS) - 1)
+
+/*
+  PPv2.1  FLOW_SEQ_CTRL new fields in word 1
+*/
+#define FLOW_SEQ_CTRL				15
+#define FLOW_SEQ_CTRL_BITS			3
+#define FLOW_SEQ_CTRL_MASK			(((1 << FLOW_SEQ_CTRL_BITS) - 1) << FLOW_SEQ_CTRL)
+#define FLOW_SEQ_CTRL_MAX			4
 
-#define FLOW_LKP_TYPE					3
-#define FLOW_LKP_TYPE_BITS				6
-#define FLOW_LKP_TYPE_MASK				(((1 << FLOW_LKP_TYPE_BITS) - 1) << FLOW_LKP_TYPE)
-#define FLOW_LKP_TYPE_MAX				((1 << FLOW_LKP_TYPE_BITS) - 1)
 
-#define FLOW_FIELED_PRIO				9
-#define FLOW_FIELED_PRIO_BITS				6
-#define FLOW_FIELED_PRIO_MASK				(((1 << FLOW_FIELED_PRIO_BITS) - 1) << FLOW_FIELED_PRIO)
-#define FLOW_FIELED_PRIO_MAX				((1 << FLOW_FIELED_PRIO_BITS) - 1)
 
 /*----------------------------------  DWORD 2  ---------------------------------- */
-#define FLOW_FIELD0_ID					0
-#define FLOW_FIELD1_ID					6
-#define FLOW_FIELD2_ID					12
-#define FLOW_FIELD3_ID					18
+#define FLOW_FIELD0_ID				0
+#define FLOW_FIELD1_ID				6
+#define FLOW_FIELD2_ID				12
+#define FLOW_FIELD3_ID				18
 
-#define FLOW_FIELD_ID_BITS				6
-#define FLOW_FIELED_ID(num)				(FLOW_FIELD0_ID + (FLOW_FIELD_ID_BITS * (num)))
-#define FLOW_FIELED_MASK(num)				(((1 << FLOW_FIELD_ID_BITS) - 1) << (FLOW_FIELD_ID_BITS * (num)))
-#define FLOW_FIELED_MAX					((1 << FLOW_FIELD_ID_BITS) - 1)
+#define FLOW_FIELD_ID_BITS			6
+#define FLOW_FIELED_ID(num)			(FLOW_FIELD0_ID + (FLOW_FIELD_ID_BITS * (num)))
+#define FLOW_FIELED_MASK(num)			(((1 << FLOW_FIELD_ID_BITS) - 1) << (FLOW_FIELD_ID_BITS * (num)))
+#define FLOW_FIELED_MAX				((1 << FLOW_FIELD_ID_BITS) - 1)
 
 /*-------------------------------------------------------------------------------*/
 /*		  change length table structure					 */
 /*-------------------------------------------------------------------------------*/
-#define LEN_CHANGE_LENGTH				0
-#define LEN_CHANGE_LENGTH_BITS				7
-#define LEN_CHANGE_LENGTH_MAX				((1 << LEN_CHANGE_LENGTH_BITS) - 1)
-#define LEN_CHANGE_LENGTH_MASK				(((1 << LEN_CHANGE_LENGTH_BITS) - 1) << LEN_CHANGE_LENGTH)
+#define LEN_CHANGE_LENGTH			0
+#define LEN_CHANGE_LENGTH_BITS			7
+#define LEN_CHANGE_LENGTH_MAX			((1 << LEN_CHANGE_LENGTH_BITS) - 1)
+#define LEN_CHANGE_LENGTH_MASK			(((1 << LEN_CHANGE_LENGTH_BITS) - 1) << LEN_CHANGE_LENGTH)
 
-#define LEN_CHANGE_DEC					7 /*1 dec , 0 inc*/
-#define LEN_CHANGE_DEC_MASK				(1 << LEN_CHANGE_DEC)
+#define LEN_CHANGE_DEC				7 /*1 dec , 0 inc*/
+#define LEN_CHANGE_DEC_MASK			(1 << LEN_CHANGE_DEC)
 /*-------------------------------------------------------------------------------*/
 /*		Classifier Top Public initialization APIs    			 */
 /*-------------------------------------------------------------------------------*/
@@ -282,11 +418,14 @@ int mvPp2ClsHwPortSpidSet(int port, int spid);
 int mvPp2ClsHwUniPortSet(int uni_port, int spid);
 int mvPp2ClsHwVirtPortSet(int virt_port, int gem_portid);
 int mvPp2ClsHwUdfSet(int udf_no, int offs_id, int offs_bits, int size_bits);
-int mvPp2ClsHwMtuSet(int port, int txp, int mtu);
+int mvPp2V0ClsHwMtuSet(int port, int txp, int mtu);/*PPv2.1 feature changed MAS 3.7*/
+int mvPp2V1ClsHwMtuSet(int index, int mtu);/*PPv2.1 feature changed MAS 3.7*/
 int mvPp2ClsHwOversizeRxqSet(int port, int rxq);
+int mvPp2ClsHwRxQueueHighSet(int port, int from, int queue);/*PPv2.1 new feature MAS 3.5*/
+int mvPp2ClsHwMhSet(int port, int virtEn, int uniEn, unsigned short mh);/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsHwSeqInstrSizeSet(int index, int size);/*PPv2.1 new feature MAS 3.14*/
 void mvPp2ClsShadowInit(void);
 
-
 /*-------------------------------------------------------------------------------*/
 /*		Classifier Top Public lkpid table APIs     			 */
 /*-------------------------------------------------------------------------------*/
@@ -302,6 +441,8 @@ int mvPp2ClsHwLkpWrite(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
 int mvPp2ClsHwLkpRead(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
 int mvPp2ClsSwLkpDump(MV_PP2_CLS_LKP_ENTRY *fe);
 int mvPp2ClsHwLkpDump(void);
+/*PPv2.1 new counters MAS 3.20*/
+int mvPp2V1ClsHwLkpHitsDump(void);
 void mvPp2ClsSwLkpClear(MV_PP2_CLS_LKP_ENTRY *fe);
 void mvPp2ClsHwLkpClearAll(void);
 
@@ -330,6 +471,7 @@ int mvPp2ClsHwFlowWrite(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
 int mvPp2ClsHwFlowRead(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
 int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe);
 int mvPp2ClsHwFlowDump(void);
+int mvPp2V1ClsHwFlowHitsDump(void);
 void mvPp2ClsSwFlowClear(MV_PP2_CLS_FLOW_ENTRY *fe);
 void mvPp2ClsHwFlowClearAll(void);
 
@@ -339,7 +481,13 @@ int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields, int field
 int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int field_index, int field_id);
 int mvPp2ClsSwFlowHekNumSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields);
 int mvPp2ClsSwFlowPortSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int portid);
+int mvPp2ClsSwFlowUdf7Set(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode);/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowMacMeSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode);/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowVlanSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode);/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwFlowPppoeSet(MV_PP2_CLS_FLOW_ENTRY *fe,  int mode);/*PPv2.1 new feature MAS 3.18*/
+int mvPp2ClsSwPortIdSelect(MV_PP2_CLS_FLOW_ENTRY *fe, int from);/*PPv2.1 new feature MAS 3.18*/
 int mvPp2ClsSwFlowEngineSet(MV_PP2_CLS_FLOW_ENTRY *fe, int engine, int is_last);
+int mvPp2ClsSwFlowSeqCtrlSet(MV_PP2_CLS_FLOW_ENTRY *fe, int mode);/*PPv2.1 new feature MAS 3.14*/
 int mvPp2ClsSwFlowExtraSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int prio);
 int mvPp2ClsSwFlowHekGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *num_of_fields, int field_ids[]);
 int mvPp2ClsSwFlowPortGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *type, int *portid);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
index 8bd3cc2..c5dc521 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
@@ -103,3 +103,22 @@ void mvPp2PrintReg2(MV_U32 reg_addr, char *reg_name, MV_U32 index)
 	mvOsSPrintf(buf, "%s[%d]", reg_name, index);
 	mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", buf, reg_addr, mvPp2RdReg(reg_addr));
 }
+
+void mvPp2RegPrintNonZero(MV_U32 reg_addr, char *reg_name)
+{
+	unsigned int regVal = MV_REG_READ(reg_addr);
+
+	if (regVal)
+		mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", reg_name, reg_addr, regVal);
+}
+
+void mvPp2RegPrintNonZero2(MV_U32 reg_addr, char *reg_name, MV_U32 index)
+{
+	char buf[64];
+	unsigned int regVal = MV_REG_READ(reg_addr);
+
+	if (regVal) {
+		mvOsSPrintf(buf, "%s[%d]", reg_name, index);
+		mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", buf, reg_addr, regVal);
+	}
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
index ea329f6..fd4a204 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
@@ -116,6 +116,9 @@ void mvPp2PrintReg2(MV_U32 reg_addr, char *reg_name, MV_U32 index);
 
 int mvPp2SPrintReg(char *buf, unsigned int  reg_addr, char *reg_name);
 
+void mvPp2RegPrintNonZero(MV_U32 reg_addr, char *reg_name);
+void mvPp2RegPrintNonZero2(MV_U32 reg_addr, char *reg_name, MV_U32 index);
+
 /*--------------------------------------------------------------------*/
 /*			PP2 COMMON DEFINETIONS			      */
 /*--------------------------------------------------------------------*/
@@ -123,7 +126,7 @@ int mvPp2SPrintReg(char *buf, unsigned int  reg_addr, char *reg_name);
 #define IN_USE						(1)
 #define DWORD_BITS_LEN					32
 #define DWORD_BYTES_LEN                                 4
-#define RETRIES_EXCEEDED				5000
+#define RETRIES_EXCEEDED				15000
 #define ONE_BIT_MAX					1
 #define UNI_MAX						7
 #define ETH_PORTS_NUM					7
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
index 6d7a421..6d19f14 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
@@ -65,7 +65,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __MV_PP2_ERR_CODE_H__
 #define __MV_PP2_ERR_CODE_H__
 
-#define  MV_ERR_CODE_BASE					0x80000000
+#define  MV_ERR_CODE_BASE						0x80000000
 #define  MV_PP2_ERR_CODE_BASE					(MV_ERR_CODE_BASE | 0x00001000)
 
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
index a1b3b91..0cf8729 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -228,12 +228,16 @@ function sets default values to the NETA port.
 *******************************************************************************/
 MV_STATUS mvPp2DefaultsSet(int port)
 {
+	MV_U32 regVal;
 	int txp, queue, txPortNum, i;
 	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
 
 	if (!MV_PON_PORT(port))
 		mvGmacDefaultsSet(port);
 
+	/* avoid unused variable compilation warninig */
+	regVal = 0;
+
 	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
 		/* Disable Legacy WRR, Disable EJP, Release from reset */
 		txPortNum = mvPp2EgressPort(port, txp);
@@ -257,7 +261,14 @@ MV_STATUS mvPp2DefaultsSet(int port)
 	if (mvPp2HalData.iocc) {
 		for (i = 0; i < pPortCtrl->rxqNum; i++) {
 			queue = mvPp2LogicRxqToPhysRxq(port, i);
-			mvPp2WrReg(MV_PP2_RXQ_SNOOP_REG(queue), MV_PP2_SNOOP_PKT_SIZE_MASK | MV_PP2_SNOOP_BUF_HDR_MASK);
+#ifdef CONFIG_MV_ETH_PP2_1
+			regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(queue));
+			regVal |= MV_PP2_SNOOP_PKT_SIZE_MASK | MV_PP2_SNOOP_BUF_HDR_MASK;
+			mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(queue), regVal);
+#else
+			regVal = MV_PP2_V0_SNOOP_PKT_SIZE_MASK | MV_PP2_V0_SNOOP_BUF_HDR_MASK;
+			mvPp2WrReg(MV_PP2_V0_RXQ_SNOOP_REG(queue), regVal);
+#endif
 		}
 	}
 
@@ -378,7 +389,7 @@ static void mvPp2DescRingReset(MV_PP2_QUEUE_CTRL *pQueueCtrl)
 }
 
 /* allocate descriptors */
-static MV_U8 *mvPp2DescrMemoryAlloc(int descSize, MV_ULONG *pPhysAddr, MV_U32 *memHandle)
+MV_U8 *mvPp2DescrMemoryAlloc(int descSize, MV_ULONG *pPhysAddr, MV_U32 *memHandle)
 {
 	MV_U8 *pVirt;
 #ifdef ETH_DESCR_UNCACHED
@@ -392,7 +403,7 @@ static MV_U8 *mvPp2DescrMemoryAlloc(int descSize, MV_ULONG *pPhysAddr, MV_U32 *m
 	return pVirt;
 }
 
-static void mvPp2DescrMemoryFree(int descSize, MV_ULONG *pPhysAddr, MV_U8 *pVirt, MV_U32 *memHandle)
+void mvPp2DescrMemoryFree(int descSize, MV_ULONG *pPhysAddr, MV_U8 *pVirt, MV_U32 *memHandle)
 {
 #ifdef ETH_DESCR_UNCACHED
 	mvOsIoUncachedFree(NULL, descSize, (MV_ULONG)pPhysAddr, pVirt, (MV_U32)memHandle);
@@ -411,6 +422,7 @@ MV_STATUS mvPp2DescrCreate(MV_PP2_QUEUE_CTRL *qCtrl, int descNum)
 	    mvPp2DescrMemoryAlloc(descSize, &qCtrl->descBuf.bufPhysAddr, &qCtrl->descBuf.memHandle);
 
 	qCtrl->descBuf.bufSize = descSize;
+	qCtrl->descSize = MV_PP2_DESC_ALIGNED_SIZE;
 
 	if (qCtrl->descBuf.bufVirtPtr == NULL) {
 		mvOsPrintf("%s: Can't allocate %d bytes for %d descr\n", __func__, descSize, descNum);
@@ -561,27 +573,6 @@ MV_STATUS mvPp2PortRxqsInit(int port, int firstRxq, int numRxqs)
 	return MV_OK;
 }
 
-MV_STATUS mvPp2RxqOffsetSet(int port, int rxq, int offset)
-{
-	MV_U32 regVal;
-	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
-
-	if (offset % 32 != 0) {
-		mvOsPrintf("%s: offset must be in units of 32\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
-	regVal &= ~MV_PP2_RXQ_PACKET_OFFSET_MASK;
-
-	/* Offset is in */
-	regVal |= ((offset << MV_PP2_RXQ_PACKET_OFFSET_OFFS) & MV_PP2_RXQ_PACKET_OFFSET_MASK);
-
-	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
-
-	return MV_OK;
-}
-
 MV_STATUS mvPp2RxqPktsCoalSet(int port, int rxq, MV_U32 pkts)
 {
 	MV_U32 regVal;
@@ -632,6 +623,14 @@ void mvPp2RxReset(int port)
 		mvPp2RxqReset(port, rxq);
 }
 /*-------------------------------------------------------------------------------*/
+void mvPp2TxqHwfSizeSet(int port, int txp, int txq, int hwfNum)
+{
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+	mvPp2WrReg(MV_PP2_TXQ_DESC_HWF_SIZE_REG, hwfNum & MV_PP2_TXQ_DESC_HWF_SIZE_MASK);
+}
+
 /* TXQ */
 /* Allocate and initialize descriptors for TXQ */
 MV_PP2_PHYS_TXQ_CTRL *mvPp2TxqInit(int port, int txp, int txq, int descNum, int hwfNum)
@@ -993,7 +992,10 @@ void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle)
 		return NULL;
 
 	/* Disable port */
-	mvPp2PortDisable(port);
+	mvPp2PortIngressEnable(port, MV_FALSE);
+	mvPp2PortEgressEnable(port, MV_FALSE);
+	mvPp2PortEnable(port, MV_FALSE);
+
 	mvPp2DefaultsSet(port);
 
 	return pCtrl;
@@ -1016,159 +1018,254 @@ void mvPp2PortDestroy(int portNo)
 }
 
 /*******************************************************************************
-* mvPp2PortUp - Start the Ethernet port RX and TX activity.
+* mvPp2PortEgressEnable
 *
 * DESCRIPTION:
-*       This routine start Rx and Tx activity:
+*	Disable fetch descriptors from initialized TXQs
 *
-*       Note: Each Rx and Tx queue descriptor's list must be initialized prior
-*       to calling this function.
+*       Note: Effects TXQs initialized prior to calling this function.
 *
 * INPUT:
-*		int     portNo		- Port number.
+*	int     portNo		- Port number.
 *
 * RETURN:   MV_STATUS
-*           MV_OK - Success, Others - Failure.
+*               MV_OK - Success, Others - Failure.
 *
 *******************************************************************************/
-MV_STATUS mvPp2PortUp(int port)
+MV_STATUS mvPp2PortEgressEnable(int port, MV_BOOL en)
 {
-	int queue, txp, txPortNum;
-	MV_U32 qMap;
+	int	         txp;
 	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
-	MV_PP2_QUEUE_CTRL *pQueueCtrl;
 
-	mvEthMibCountersClear(port);
-
-	/* Enable all initialized TXs. */
+	/* Disable all physical TXQs */
 	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
-		txPortNum = mvPp2EgressPort(port, txp);
+		if (en)
+			mvPp2TxpEnable(port, txp);
+		else
+			mvPp2TxpDisable(port, txp);
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
 
-		qMap = 0;
-		for (queue = 0; queue < pPortCtrl->txqNum; queue++) {
-			pQueueCtrl = &pPortCtrl->pTxQueue[txp * CONFIG_MV_ETH_TXQ + queue]->queueCtrl;
+MV_STATUS mvPp2PortEnable(int port, MV_BOOL en)
+{
+	if (!MV_PON_PORT(port)) {
+		/* Enable port */
+		if (en)
+			mvGmacPortEnable(port);
+		else
+			mvGmacPortDisable(port);
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
 
-			if (pQueueCtrl->pFirst != NULL)
-				qMap |= (1 << queue);
-		}
+/* BM */
+MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize)
+{
+	MV_U32 regVal;
 
-		mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
-		mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, qMap);
-	}
+	mvBmPoolBufSizeSet(pool, bufsize);
+	regVal = MV_ALIGN_UP(bufsize, 1 << MV_PP2_POOL_BUF_SIZE_OFFSET);
+	mvPp2WrReg(MV_PP2_POOL_BUF_SIZE_REG(pool), regVal);
 
 	return MV_OK;
 }
 
+#ifdef CONFIG_MV_ETH_PP2_1
+
 /*******************************************************************************
-* mvPp2PortDown - Stop the Ethernet port activity.
+* mvPp2PortIngressEnable
 *
 * DESCRIPTION:
+*	Enable/Disable receive packets to RXQs for SWF and receive packets to TXQs for HWF.
+*
+*       Note: Effects only Rx and Tx queues initialized prior to calling this function.
 *
 * INPUT:
-*		int     portNo		- Port number.
+*	int     portNo		- Port number.
 *
 * RETURN:   MV_STATUS
-*               MV_OK - Success, Others - Failure.
+*           MV_OK - Success, Others - Failure.
 *
-* NOTE : used for port link down.
 *******************************************************************************/
-MV_STATUS mvPp2PortDown(int port)
+MV_STATUS mvPp2PortIngressEnable(int port, MV_BOOL en)
 {
-	int	          txp, txPortNum;
+	int txp, txq, rxq;
 	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
-	MV_U32 		  regData;
-	int 		  mDelay;
 
-	/* Stop Rx port activity. Check port Rx activity. */
-	/*TBD*/
+	/* Enable all initialized RXQs */
+	for (rxq = 0; rxq < pPortCtrl->rxqNum ; rxq++) {
+		if (pPortCtrl->pRxQueue[rxq] != NULL)
+			mvPp2RxqEnable(port, rxq, en);
+	}
 
-	if (!MV_PON_PORT(port)) {
-		/* Stop Tx port activity. Check port Tx activity. */
-		for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
-			txPortNum = mvPp2EgressPort(port, txp);
-
-			/* Issue stop command for active channels only */
-			mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
-			regData = (mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG)) & MV_PP2_TXP_SCHED_ENQ_MASK;
-			if (regData != 0)
-				mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, (regData << MV_PP2_TXP_SCHED_DISQ_OFFSET));
-
-			/* Wait for all Tx activity to terminate. */
-			mDelay = 0;
-			do {
-				if (mDelay >= TX_DISABLE_TIMEOUT_MSEC) {
-					mvOsPrintf("port=%d, txp=%d: TIMEOUT for TX stopped !!! txQueueCmd - 0x%08x\n",
-						   port, txp, regData);
-					break;
-				}
-				mvOsDelay(1);
-				mDelay++;
-
-				/* Check port TX Command register that all Tx queues are stopped */
-				regData = mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG);
-			} while (regData & 0xFF);
+	/* Enable HWF for all initialized TXQs. */
+	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+		for (txq = 0; txq < pPortCtrl->txqNum; txq++) {
+			if (pPortCtrl->pTxQueue[txp * pPortCtrl->txqNum + txq] != NULL)
+				mvPp2HwfTxqEnable(port, txp, txq, en);
 		}
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqOffsetSet(int port, int rxq, int offset)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
-		/* Double check to Verify that TX FIFO is Empty */
-		/*TBD*/
+	if (offset % 32 != 0) {
+		mvOsPrintf("%s: offset must be in units of 32\n", __func__);
+		return MV_BAD_PARAM;
 	}
-	/* Wait about 200 usec */
-	mvOsUDelay(200);
+
+	/* convert offset from bytes to units of 32 bytes */
+	offset = offset >> 5;
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_RXQ_PACKET_OFFSET_MASK;
+
+	/* Offset is in */
+	regVal |= ((offset << MV_PP2_RXQ_PACKET_OFFSET_OFFS) & MV_PP2_RXQ_PACKET_OFFSET_MASK);
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
 
 	return MV_OK;
 }
 
-MV_STATUS mvPp2PortEnable(int port)
+MV_STATUS mvPp2RxqBmLongPoolSet(int port, int rxq, int longPool)
 {
-	if (!MV_PON_PORT(port)) {
-		/* Enable port */
-		mvEthPortEnable(MV_PPV2_PORT_PHYS(port));
+	MV_U32 regVal = 0;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
-		/* If Link is UP, Start RX and TX traffic */
-		if (mvEthPortIsLinkUp(MV_PPV2_PORT_PHYS(port)))
-			return mvPp2PortUp(port);
-	}
-	return MV_NOT_READY;
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_RXQ_POOL_LONG_MASK;
+	regVal |= ((longPool << MV_PP2_RXQ_POOL_LONG_OFFS) & MV_PP2_RXQ_POOL_LONG_MASK);
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+
+	/* Update default BM priority rule */
+	mvBmRxqToQsetLongClean(prxq);
+	mvBmRxqToQsetLongSet(prxq, mvBmDefaultQsetNumGet(longPool));
+
+	return MV_OK;
 }
 
-MV_STATUS mvPp2PortDisable(int port)
+MV_STATUS mvPp2RxqBmShortPoolSet(int port, int rxq, int shortPool)
 {
-	mvPp2PortDown(port);
+	MV_U32 regVal = 0;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
-	if (!MV_PON_PORT(port)) {
-		/* Reset the Enable bit in the Serial Control Register */
-		mvEthPortDisable(MV_PPV2_PORT_PHYS(port));
-	}
-	/* Wait about 200 usec */
-	mvOsUDelay(200);
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_RXQ_POOL_SHORT_MASK;
+	regVal |= ((shortPool << MV_PP2_RXQ_POOL_SHORT_OFFS) & MV_PP2_RXQ_POOL_SHORT_MASK);
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+
+	/* Update default BM priority rule */
+	mvBmRxqToQsetShortClean(prxq);
+	mvBmRxqToQsetShortSet(prxq, mvBmDefaultQsetNumGet(shortPool));
 
 	return MV_OK;
 }
-/*-------------------------------------------------------------------------------*/
-/* BM */
-MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize)
+
+MV_STATUS mvPp2TxqBmShortPoolSet(int port, int txp, int txq, int shortPool)
+{
+	MV_U32 regVal = 0;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	regVal = mvPp2RdReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq));
+	regVal &= ~MV_PP2_HWF_TXQ_POOL_SHORT_MASK;
+
+	regVal |= ((shortPool << MV_PP2_HWF_TXQ_POOL_SHORT_OFFS) & MV_PP2_HWF_TXQ_POOL_SHORT_MASK);
+
+	mvPp2WrReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq), regVal);
+
+	mvBmTxqToQsetShortClean(ptxq);
+	mvBmTxqToQsetShortSet(ptxq, mvBmDefaultQsetNumGet(shortPool));
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2TxqBmLongPoolSet(int port, int txp, int txq, int longPool)
+{
+	MV_U32 regVal = 0;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	regVal = mvPp2RdReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq));
+	regVal &= ~MV_PP2_HWF_TXQ_POOL_LONG_MASK;
+
+	regVal |= ((longPool << MV_PP2_HWF_TXQ_POOL_LONG_OFFS) & MV_PP2_HWF_TXQ_POOL_LONG_MASK);
+
+	mvPp2WrReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq), regVal);
+
+	mvBmTxqToQsetLongClean(ptxq);
+	mvBmTxqToQsetLongSet(ptxq, mvBmDefaultQsetNumGet(longPool));
+
+	return MV_OK;
+}
+
+#else
+
+MV_STATUS mvPp2PortIngressEnable(int port, MV_BOOL en)
+{
+	if (en)
+		mvPrsMacDropAllSet(port, 0);
+	else
+		mvPrsMacDropAllSet(port, 1);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqOffsetSet(int port, int rxq, int offset)
 {
 	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
-	mvBmPoolBufSizeSet(pool, bufsize);
-	regVal = MV_ALIGN_UP(bufsize, 1 << MV_PP2_POOL_BUF_SIZE_OFFSET);
-	mvPp2WrReg(MV_PP2_POOL_BUF_SIZE_REG(pool), regVal);
+	if (offset % 32 != 0) {
+		mvOsPrintf("%s: offset must be in units of 32\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	/* convert offset from bytes to units of 32 bytes */
+	offset = offset >> 5;
+
+	regVal = mvPp2RdReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq));
+
+	regVal &= ~MV_PP2_V0_RXQ_PACKET_OFFSET_MASK;
+	regVal |= ((offset << MV_PP2_V0_RXQ_PACKET_OFFSET_OFFS) & MV_PP2_V0_RXQ_PACKET_OFFSET_MASK);
+
+	mvPp2WrReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq), regVal);
 
 	return MV_OK;
 }
 
-MV_STATUS mvPp2RxqBmPoolSet(int port, int rxq, int shortPool, int longPool)
+MV_STATUS mvPp2RxqBmLongPoolSet(int port, int rxq, int longPool)
 {
 	MV_U32 regVal = 0;
 	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
-	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
-	regVal &= ~MV_PP2_RXQ_POOL_MASK;
+	regVal = mvPp2RdReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_V0_RXQ_POOL_LONG_MASK;
+	regVal |= ((longPool << MV_PP2_V0_RXQ_POOL_LONG_OFFS) & MV_PP2_V0_RXQ_POOL_LONG_MASK);
 
-	regVal |= ((shortPool << MV_PP2_RXQ_POOL_SHORT_ID_OFFS) & MV_PP2_RXQ_POOL_SHORT_ID_MASK);
-	regVal |= ((longPool << MV_PP2_RXQ_POOL_LONG_ID_OFFS) & MV_PP2_RXQ_POOL_LONG_ID_MASK);
+	mvPp2WrReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq), regVal);
 
-	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqBmShortPoolSet(int port, int rxq, int shortPool)
+{
+	MV_U32 regVal = 0;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = mvPp2RdReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_V0_RXQ_POOL_SHORT_MASK;
+	regVal |= ((shortPool << MV_PP2_V0_RXQ_POOL_SHORT_OFFS) & MV_PP2_V0_RXQ_POOL_SHORT_MASK);
+
+	mvPp2WrReg(MV_PP2_V0_RXQ_CONFIG_REG(prxq), regVal);
 
 	return MV_OK;
 }
@@ -1177,13 +1274,15 @@ MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool)
 {
 	MV_U32 regVal = 0;
 
-	regVal |= ((shortPool << MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS) & MV_PP2_PORT_HWF_POOL_SHORT_ID_MASK);
-	regVal |= ((longPool << MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS) & MV_PP2_PORT_HWF_POOL_LONG_ID_MASK);
+	regVal |= ((shortPool << MV_PP2_V0_PORT_HWF_POOL_SHORT_OFFS) & MV_PP2_V0_PORT_HWF_POOL_SHORT_MASK);
+	regVal |= ((longPool << MV_PP2_V0_PORT_HWF_POOL_LONG_OFFS) & MV_PP2_V0_PORT_HWF_POOL_LONG_MASK);
 
-	mvPp2WrReg(MV_PP2_PORT_HWF_CONFIG_REG(MV_PPV2_PORT_PHYS(port)), regVal);
+	mvPp2WrReg(MV_PP2_V0_PORT_HWF_CONFIG_REG(MV_PPV2_PORT_PHYS(port)), regVal);
 
 	return MV_OK;
 }
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
 /*-------------------------------------------------------------------------------*/
 
 MV_STATUS mvPp2MhSet(int port, MV_TAG_TYPE mh)
@@ -1673,6 +1772,154 @@ MV_STATUS   mvPp2TxpMaxTxSizeSet(int port, int txp, int maxTxSize)
 	return MV_OK;
 }
 
+/* Disable transmit via physical egress queue - HW doesn't take descriptors from DRAM */
+MV_STATUS mvPp2TxpDisable(int port, int txp)
+{
+	MV_U32 regData;
+	int    mDelay;
+	int    txPortNum = mvPp2EgressPort(port, txp);
+
+	/* Issue stop command for active channels only */
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+	regData = (mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG)) & MV_PP2_TXP_SCHED_ENQ_MASK;
+	if (regData != 0)
+		mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, (regData << MV_PP2_TXP_SCHED_DISQ_OFFSET));
+
+	/* Wait for all Tx activity to terminate. */
+	mDelay = 0;
+	do {
+		if (mDelay >= TX_DISABLE_TIMEOUT_MSEC) {
+			mvOsPrintf("port=%d, txp=%d: TIMEOUT for TX stopped !!! txQueueCmd - 0x%08x\n",
+				   port, txp, regData);
+			return MV_TIMEOUT;
+		}
+		mvOsDelay(1);
+		mDelay++;
+
+		/* Check port TX Command register that all Tx queues are stopped */
+		regData = mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG);
+	} while (regData & MV_PP2_TXP_SCHED_ENQ_MASK);
+
+	return MV_OK;
+}
+
+/* Enable transmit via physical egress queue - HW starts take descriptors from DRAM */
+MV_STATUS mvPp2TxpEnable(int port, int txp)
+{
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
+	MV_U32 qMap;
+	int    txq, eport = mvPp2EgressPort(port, txp);
+
+	/* Enable all initialized TXs. */
+	qMap = 0;
+	for (txq = 0; txq < pPortCtrl->txqNum; txq++) {
+		if (pPortCtrl->pTxQueue[txp * CONFIG_MV_ETH_TXQ + txq] != NULL)
+			qMap |= (1 << txq);
+	}
+	/* Indirect access to register */
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, eport);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, qMap);
+
+	return MV_OK;
+}
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/* Functions implemented only for PPv2.1 version (A0 and later) */
+MV_STATUS mvPp2RxqEnable(int port, int rxq, MV_BOOL en)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	if (en)
+		regVal &= ~MV_PP2_RXQ_DISABLE_MASK;
+	else
+		regVal |= MV_PP2_RXQ_DISABLE_MASK;
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2HwfTxqEnable(int port, int txp, int txq, MV_BOOL en)
+{
+	MV_U32 regVal;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	regVal = mvPp2RdReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq));
+
+	if (en)
+		regVal &= ~MV_PP2_HWF_TXQ_DISABLE_MASK;
+	else
+		regVal |= MV_PP2_HWF_TXQ_DISABLE_MASK;
+
+	mvPp2WrReg(MV_PP2_HWF_TXQ_CONFIG_REG(ptxq), regVal);
+
+	return MV_OK;
+}
+
+MV_BOOL mvPp2DisableCmdInProgress(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_RX_STATUS);
+	regVal &= MV_PP2_DISABLE_IN_PROG_MASK;
+
+	return regVal;
+}
+
+
+MV_STATUS mvPp2TxqDrainSet(int port, int txp, int txq, MV_BOOL en)
+{
+	MV_U32 regVal;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+	regVal = mvPp2RdReg(MV_PP2_TXQ_PREF_BUF_REG);
+
+	if (en)
+		regVal |= MV_PP2_HWF_TXQ_DISABLE_MASK;
+	else
+		regVal &= ~MV_PP2_HWF_TXQ_DISABLE_MASK;
+
+	mvPp2WrReg(MV_PP2_TXQ_PREF_BUF_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2TxPortFifoFlush(int port, MV_BOOL en)
+{
+	MV_U32 regVal;
+
+	/* valid only for ethernet ports (not for xPON) */
+	if (MV_PON_PORT(port))
+		return MV_NOT_SUPPORTED;
+
+	regVal = mvPp2RdReg(MV_PP2_TX_PORT_FLUSH_REG);
+
+	if (en)
+		regVal |= MV_PP2_TX_PORT_FLUSH_MASK(port);
+	else
+		regVal &= ~MV_PP2_TX_PORT_FLUSH_MASK(port);
+
+	mvPp2WrReg(MV_PP2_TX_PORT_FLUSH_REG, regVal);
+
+	return MV_OK;
+}
+
+#else /* Stabs for Z1 */
+
+MV_STATUS mvPp2TxqDrainSet(int port, int txp, int txq, MV_BOOL en)
+{
+	return MV_OK;
+}
+
+MV_STATUS mvPp2TxPortFifoFlush(int port, MV_BOOL en)
+{
+	return MV_OK;
+}
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
 /* Function for swithcing SWF to HWF */
 /* txq is physical (global) txq in range 0..MV_PP2_TXQ_TOTAL_NUM */
 /* txq is physical (global) rxq in range 0..MV_ETH_RXQ_TOTAL_NUM */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index 3e8a4a9..a986a51 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -71,6 +71,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvOs.h"
 #include "mvSysEthConfig.h"
 #include "mvPp2GbeRegs.h"
+#include "pp2/bm/mvBm.h"
 #include "pp2/gmac/mvEthGmacApi.h"
 #include "pp2/common/mvPp2Common.h"
 #include "pp2/prs/mvPp2PrsHw.h"
@@ -91,14 +92,16 @@ static inline int mvPp2RxBmPoolId(PP2_RX_DESC *rxDesc)
 
 /************************** PPv2 HW Configuration ***********************/
 typedef struct eth_pbuf {
-	void *osInfo;
+	void	*osInfo;
 	MV_ULONG physAddr;
-	MV_U8 *pBuf;
-	MV_U16 bytes;
-	MV_U16 offset;
-	MV_U8  pool;
-	MV_U8  reserved;
-	MV_U16 vlanId;
+	MV_U8	*pBuf;
+	MV_U16	bytes;
+	MV_U16	offset;
+	MV_U8	pool;
+	MV_U8	qset;
+	MV_U8	grntd;
+	MV_U8	reserved;
+	MV_U16	vlanId;
 } MV_ETH_PKT;
 
 /************************** Port + Queue Control Structures ******************************/
@@ -111,13 +114,13 @@ typedef struct {
 } MV_PP2_QUEUE_CTRL;
 
 #define MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, descIdx)                 \
-    ((pQueueCtrl)->pFirst + ((descIdx) * MV_PP2_DESC_ALIGNED_SIZE))
+	((pQueueCtrl)->pFirst + ((descIdx) * (pQueueCtrl)->descSize))
 
 #define MV_PP2_QUEUE_NEXT_DESC(pQueueCtrl, descIdx)  \
-    (((descIdx) < (pQueueCtrl)->lastDesc) ? ((descIdx) + 1) : 0)
+	(((descIdx) < (pQueueCtrl)->lastDesc) ? ((descIdx) + 1) : 0)
 
 #define MV_PP2_QUEUE_PREV_DESC(pQueueCtrl, descIdx)  \
-    (((descIdx) > 0) ? ((descIdx) - 1) : (pQueueCtrl)->lastDesc)
+	(((descIdx) > 0) ? ((descIdx) - 1) : (pQueueCtrl)->lastDesc)
 
 /*-------------------------------------------------------------------------------*/
 /* TXQ */
@@ -326,7 +329,7 @@ static INLINE int mvPp2RxqBusyDescNumGet(int port, int rxq)
 	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
 	if (prxq < 0)
-		return 0;
+		return prxq;
 
 	regVal = mvPp2RdReg(MV_PP2_RXQ_STATUS_REG(prxq));
 
@@ -340,7 +343,7 @@ static INLINE int mvPp2RxqFreeDescNumGet(int port, int rxq)
 	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
 
 	if (prxq < 0)
-		return 0;
+		return prxq;
 
 	regVal = mvPp2RdReg(MV_PP2_RXQ_STATUS_REG(prxq));
 
@@ -381,6 +384,23 @@ static INLINE void mvPp2RxqOccupDescDec(int port, int rxq, int rx_done)
 }
 
 /*-------------------------------------------------------------------------------*/
+/*
+   PPv2 new feature MAS 3.16
+   reserved TXQ descriptorts allocation request
+*/
+static INLINE int mvPp2TxqAllocReservedDesc(int port, int txp, int txq, int num)
+{
+	MV_U32 regVal, ptxq;
+
+	ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	regVal = (ptxq << MV_PP2_TXQ_RSVD_REQ_Q_OFFSET) || (num << MV_PP2_TXQ_RSVD_REQ_DESC_OFFSET);
+	mvPp2WrReg(MV_PP2_TXQ_RSVD_REQ_REG, regVal);
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_RSVD_RSLT_REG);
+
+	return (regVal & MV_PP2_TXQ_RSVD_REQ_DESC_MASK) >> MV_PP2_TXQ_RSVD_RSLT_OFFSET;
+}
+
 /* Get number of TXQ descriptors waiting to be transmitted by HW */
 static INLINE int mvPp2TxqPendDescNumGet(int port, int txp, int txq)
 {
@@ -394,7 +414,28 @@ static INLINE int mvPp2TxqPendDescNumGet(int port, int txp, int txq)
 	return (regVal & MV_PP2_TXQ_PENDING_MASK) >> MV_PP2_TXQ_PENDING_OFFSET;
 }
 
-/* Get number of TXQ HWF descriptors waiting to be transmitted by HW */
+/*
+   PPv2.1 new feature MAS 3.16
+   Get number of SWF reserved descriptors
+*/
+static INLINE int mvPp2TxqPendRsrvdDescNumGet(int port, int txp, int txq)
+{
+	MV_U32 regVal, ptxq;
+
+	ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_PENDING_REG);
+
+	return (regVal & MV_PP2_TXQ_RSVD_DESC_OFFSET) >> MV_PP2_TXQ_RSVD_DESC_OFFSET;
+}
+
+
+/*
+   PPv2.1 field removed, MAS 3.16
+   Relevant only for ppv2.0
+   Get number of TXQ HWF descriptors waiting to be transmitted by HW
+*/
 static INLINE int mvPp2TxqPendHwfDescNumGet(int port, int txp, int txq)
 {
 	MV_U32 regVal, ptxq;
@@ -511,6 +552,9 @@ static INLINE MV_ULONG pp2DescVirtToPhys(MV_PP2_QUEUE_CTRL *pQueueCtrl, MV_U8 *p
 	return (pQueueCtrl->descBuf.bufPhysAddr + (pDesc - pQueueCtrl->descBuf.bufVirtPtr));
 }
 
+MV_U8 *mvPp2DescrMemoryAlloc(int descSize, MV_ULONG *pPhysAddr, MV_U32 *memHandle);
+void mvPp2DescrMemoryFree(int descSize, MV_ULONG *pPhysAddr, MV_U8 *pVirt, MV_U32 *memHandle);
+
 MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData);
 MV_VOID mvPp2HalDestroy(MV_VOID);
 
@@ -539,6 +583,8 @@ int mvPp2RxqPktsCoalGet(int port, int rxq);
 
 void mvPp2RxReset(int port);
 
+void mvPp2TxqHwfSizeSet(int port, int txp, int txq, int hwfNum);
+
 /* Allocate and initialize descriptors for TXQ */
 MV_PP2_PHYS_TXQ_CTRL *mvPp2TxqInit(int port, int txp, int txq, int descNum, int hwfNum);
 
@@ -577,14 +623,25 @@ MV_VOID mvPp2TxqTempDelete(MV_VOID);
 void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle);
 void mvPp2PortDestroy(int port);
 
-MV_STATUS mvPp2PortUp(int port);
-MV_STATUS mvPp2PortDown(int port);
+/* Low Level APIs */
+MV_STATUS mvPp2RxqEnable(int port, int rxq, MV_BOOL en);
+MV_STATUS mvPp2HwfTxqEnable(int port, int txp, int txq, MV_BOOL en);
+MV_BOOL   mvPp2DisableCmdInProgress(void);
+MV_STATUS mvPp2TxqDrainSet(int port, int txp, int txq, MV_BOOL en);
+MV_STATUS mvPp2TxPortFifoFlush(int port, MV_BOOL en);
+MV_STATUS mvPp2TxpEnable(int port, int txp);
+MV_STATUS mvPp2TxpDisable(int port, int txp);
+MV_STATUS mvPp2PortEnable(int port, MV_BOOL en);
 
-MV_STATUS mvPp2PortEnable(int port);
-MV_STATUS mvPp2PortDisable(int port);
+/* High Level APIs */
+MV_STATUS mvPp2PortIngressEnable(int port, MV_BOOL en);
+MV_STATUS mvPp2PortEgressEnable(int port, MV_BOOL en);
 
 MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize);
-MV_STATUS mvPp2RxqBmPoolSet(int port, int rxq, int shortPool, int longPool);
+MV_STATUS mvPp2RxqBmShortPoolSet(int port, int rxq, int shortPool);
+MV_STATUS mvPp2RxqBmLongPoolSet(int port, int rxq, int longPool);
+MV_STATUS mvPp2TxqBmShortPoolSet(int port, int txp, int txq, int shortPool);
+MV_STATUS mvPp2TxqBmLongPoolSet(int port, int txp, int txq, int longPool);
 MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool);
 
 MV_STATUS mvPp2MhSet(int port, MV_TAG_TYPE mh);
@@ -644,7 +701,11 @@ void mvPp2TxRegs(void);
 void mvPp2AddrDecodeRegs(void);
 void mvPp2TxSchedRegs(int port, int txp);
 void mvPp2BmPoolRegs(int pool);
-void mvPp2DropCntrs(int port);
+void mvPp2V0DropCntrs(int port);
+/* PPv2.1 MAS 3.20 - counters change */
+void mvPp2V1DropCntrs(int port);
+void mvPp2V1TxqDbgCntrs(int port, int txp, int txq);
+void mvPp2V1RxqDbgCntrs(int port, int rxq);
 void mvPp2RxFifoRegs(int port);
 void mvPp2PortStatus(int port);
 #endif /* MV_PP2_GBE_H */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
index 46ebf9e..548eeed 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
@@ -81,8 +81,13 @@ MV_VOID mvPp2RxDmaRegsPrint(void)
 
 	mvOsPrintf("\nRXQs [0..%d] registers\n", MV_ETH_RXQ_TOTAL_NUM);
 	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
-		mvPp2PrintReg2(MV_PP2_RXQ_SNOOP_REG(i),  "MV_PP2_RXQ_SNOOP_REG", i);
+#ifdef CONFIG_MV_ETH_PP2_1
+		mvPp2PrintReg(MV_PP2_RX_STATUS, "MV_PP2_RX_STATUS");
 		mvPp2PrintReg2(MV_PP2_RXQ_CONFIG_REG(i), "MV_PP2_RXQ_CONFIG_REG", i);
+#else
+		mvPp2PrintReg2(MV_PP2_V0_RXQ_SNOOP_REG(i), "MV_PP2_RXQ_SNOOP_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_RXQ_CONFIG_REG(i), "MV_PP2_RXQ_CONFIG_REG", i);
+#endif
 	}
 	mvOsPrintf("\nBM pools [0..%d] registers\n", MV_BM_POOLS);
 	for (i = 0; i < MV_BM_POOLS; i++)
@@ -90,7 +95,9 @@ MV_VOID mvPp2RxDmaRegsPrint(void)
 
 	mvOsPrintf("\nIngress ports [0..%d] registers\n", MV_PP2_MAX_PORTS);
 	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
-		mvPp2PrintReg2(MV_PP2_PORT_HWF_CONFIG_REG(i), "MV_PP2_PORT_HWF_CONFIG_REG", i);
+#ifndef CONFIG_MV_ETH_PP2_1
+		mvPp2PrintReg2(MV_PP2_V0_PORT_HWF_CONFIG_REG(i), "MV_PP2_PORT_HWF_CONFIG_REG", i);
+#endif
 		mvPp2PrintReg2(MV_PP2_RX_CTRL_REG(i), "MV_PP2_RX_CTRL_REG", i);
 	}
 	mvOsPrintf("\n");
@@ -98,9 +105,10 @@ MV_VOID mvPp2RxDmaRegsPrint(void)
 
 static void mvPp2QueueShow(MV_PP2_QUEUE_CTRL *pQueueCtrl, int mode, int isTxq)
 {
-	mvOsPrintf("pFirst=%p (0x%x), numOfDescr=%d\n",
-		   pQueueCtrl->pFirst,
-		   (MV_U32) pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *) pQueueCtrl->pFirst), pQueueCtrl->lastDesc + 1);
+	mvOsPrintf("pFirst=%p (0x%x), descSize=%d, numOfDescr=%d\n",
+			pQueueCtrl->pFirst,
+			(MV_U32) pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *) pQueueCtrl->pFirst),
+			pQueueCtrl->descSize, pQueueCtrl->lastDesc + 1);
 
 	if (mode > 0) {
 		int i;
@@ -275,10 +283,15 @@ void mvPp2PhysRxqRegs(int rxq)
 	mvPp2PrintReg(MV_PP2_RXQ_STATUS_REG(rxq), "MV_PP2_RXQ_STATUS_REG");
 	mvPp2PrintReg(MV_PP2_RXQ_THRESH_REG, "MV_PP2_RXQ_THRESH_REG");
 	mvPp2PrintReg(MV_PP2_RXQ_INDEX_REG, "MV_PP2_RXQ_INDEX_REG");
+#ifdef CONFIG_MV_ETH_PP2_1
 	mvPp2PrintReg(MV_PP2_RXQ_CONFIG_REG(rxq), "MV_PP2_RXQ_CONFIG_REG");
-	mvPp2PrintReg(MV_PP2_RXQ_SNOOP_REG(rxq), "MV_PP2_RXQ_SNOOP_REG");
-	mvPp2PrintReg(MV_PP2_RX_EARLY_DROP_REG(rxq), "MV_PP2_RX_EARLY_DROP_REG");
-	mvPp2PrintReg(MV_PP2_RX_DESC_DROP_REG(rxq), "MV_PP2_RX_DESC_DROP_REG");
+#else
+	mvPp2PrintReg(MV_PP2_V0_RXQ_CONFIG_REG(rxq), "MV_PP2_RXQ_CONFIG_REG");
+	mvPp2PrintReg(MV_PP2_V0_RXQ_SNOOP_REG(rxq), "MV_PP2_RXQ_SNOOP_REG");
+	mvPp2PrintReg(MV_PP2_V0_RX_EARLY_DROP_REG(rxq), "MV_PP2_V0_RX_EARLY_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V0_RX_DESC_DROP_REG(rxq), "MV_PP2_V0_RX_DESC_DROP_REG");
+#endif
+
 }
 
 void mvPp2PortRxqRegs(int port, int rxq)
@@ -417,7 +430,7 @@ void mvPp2BmPoolRegs(int pool)
 	mvPp2PrintReg(MV_BM_INTR_MASK_REG(pool), "MV_BM_INTR_MASK_REG");
 }
 
-void mvPp2DropCntrs(int port)
+void mvPp2V0DropCntrs(int port)
 {
 	int i;
 
@@ -426,23 +439,92 @@ void mvPp2DropCntrs(int port)
 	mvPp2PrintReg(MV_PP2_CLS_DROP_REG(MV_PPV2_PORT_PHYS(port)), "MV_PP2_CLS_DROP_REG");
 
 	if (MV_PON_PORT(port)) {
-#ifdef CONFIG_MV_INCLUDE_PON
 		for (i = 0; i < mvPp2HalData.maxTcont; i++) {
-			mvPp2PrintReg2(MV_PP2_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
-			mvPp2PrintReg2(MV_PP2_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
+			mvPp2PrintReg2(MV_PP2_V0_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
+			mvPp2PrintReg2(MV_PP2_V0_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
 		}
-#endif
 	} else {
 		i = MV_ETH_MAX_TCONT + port;
-		mvPp2PrintReg2(MV_PP2_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
-		mvPp2PrintReg2(MV_PP2_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
 	}
 	for (i = port * CONFIG_MV_ETH_RXQ; i < (port * CONFIG_MV_ETH_RXQ + CONFIG_MV_ETH_RXQ); i++) {
-		mvPp2PrintReg2(MV_PP2_RX_EARLY_DROP_REG(i), "MV_PP2_RX_EARLY_DROP_REG", i);
-		mvPp2PrintReg2(MV_PP2_RX_DESC_DROP_REG(i), "MV_PP2_RX_DESC_DROP_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_RX_EARLY_DROP_REG(i), "MV_PP2_RX_EARLY_DROP_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_RX_DESC_DROP_REG(i), "MV_PP2_RX_DESC_DROP_REG", i);
 	}
 }
 
+void mvPp2V1DropCntrs(int port)
+{
+	int txp, phyRxq, q;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
+	int physPort = MV_PPV2_PORT_PHYS(port);
+
+
+	mvOsPrintf("\n[global drop counters]\n");
+	mvPp2RegPrintNonZero(MV_PP2_V1_OVERFLOW_MC_DROP_REG, "MV_PP2_OVERRUN_DROP_REG");
+
+	mvOsPrintf("\n[Port #%d Drop counters]\n", port);
+	mvPp2RegPrintNonZero(MV_PP2_OVERRUN_DROP_REG(physPort), "MV_PP2_OVERRUN_DROP_REG");
+	mvPp2RegPrintNonZero(MV_PP2_CLS_DROP_REG(physPort), "MV_PP2_CLS_DROP_REG");
+
+	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+		for (q = 0; q < MV_ETH_MAX_TXQ; q++) {
+			mvOsPrintf("\n------ [Port #%d txp #%d txq #%d counters] -----\n", port, txp, q);
+			mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, TX_CNT_IDX(port, txp, q));
+			mvPp2RegPrintNonZero(MV_PP2_V1_TX_PKT_FULLQ_DROP_REG, "MV_PP2_V1_TX_PKT_FULLQ_DROP_REG");
+			mvPp2RegPrintNonZero(MV_PP2_V1_TX_PKT_EARLY_DROP_REG, "MV_PP2_V1_TX_PKT_EARLY_DROP_REG");
+			mvPp2RegPrintNonZero(MV_PP2_V1_TX_PKT_BM_DROP_REG, "MV_PP2_V1_TX_PKT_BM_DROP_REG");
+			mvPp2RegPrintNonZero(MV_PP2_V1_TX_PKT_BM_MC_DROP_REG, "MV_PP2_V1_TX_PKT_BM_MC_DROP_REG");
+		}
+	}
+
+	for (q = 0; q < CONFIG_MV_ETH_RXQ; q++) {
+		mvOsPrintf("\n------ [Port #%d, rxq #%d counters] -----\n", port, q);
+		phyRxq = mvPp2LogicRxqToPhysRxq(port, q);
+		mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, phyRxq);
+		mvPp2RegPrintNonZero(MV_PP2_V1_RX_PKT_FULLQ_DROP_REG, "MV_PP2_V1_RX_PKT_FULLQ_DROP_REG");
+		mvPp2RegPrintNonZero(MV_PP2_V1_RX_PKT_EARLY_DROP_REG, "MV_PP2_V1_RX_PKT_EARLY_DROP_REG");
+		mvPp2RegPrintNonZero(MV_PP2_V1_RX_PKT_BM_DROP_REG, "MV_PP2_V1_RX_PKT_BM_DROP_REG");
+	}
+}
+
+void mvPp2V1TxqDbgCntrs(int port, int txp, int txq)
+{
+	mvOsPrintf("\n------ [Port #%d txp #%d txq #%d counters] -----\n", port, txp, txq);
+	mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, TX_CNT_IDX(port, txp, txq));
+	mvPp2PrintReg(MV_PP2_V1_TX_DESC_ENQ_REG, "MV_PP2_V1_TX_DESC_ENQ_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_DESC_ENQ_TO_DRAM_REG, "MV_PP2_V1_TX_DESC_ENQ_TO_DRAM_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_BUF_ENQ_TO_DRAM_REG, "MV_PP2_V1_TX_BUF_ENQ_TO_DRAM_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_DESC_HWF_ENQ_REG, "MV_PP2_V1_TX_DESC_HWF_ENQ_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_PKT_DQ_REG, "MV_PP2_V1_TX_PKT_DQ_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_PKT_FULLQ_DROP_REG, "MV_PP2_V1_TX_PKT_FULLQ_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_PKT_EARLY_DROP_REG, "MV_PP2_V1_TX_PKT_EARLY_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_PKT_BM_DROP_REG, "MV_PP2_V1_TX_PKT_BM_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_TX_PKT_BM_MC_DROP_REG, "MV_PP2_V1_TX_PKT_BM_MC_DROP_REG");
+}
+
+void mvPp2V1RxqDbgCntrs(int port, int rxq)
+{
+	int phyRxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	mvOsPrintf("\n------ [Port #%d, rxq #%d counters] -----\n", port, rxq);
+	mvPp2WrReg(MV_PP2_V1_CNT_IDX_REG, phyRxq);
+	mvPp2PrintReg(MV_PP2_V1_RX_PKT_FULLQ_DROP_REG, "MV_PP2_V1_RX_PKT_FULLQ_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_RX_PKT_EARLY_DROP_REG, "MV_PP2_V1_RX_PKT_EARLY_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_RX_PKT_BM_DROP_REG, "MV_PP2_V1_RX_PKT_BM_DROP_REG");
+	mvPp2PrintReg(MV_PP2_V1_RX_DESC_ENQ_REG, "MV_PP2_V1_RX_DESC_ENQ_REG");
+}
+
+void mvPp2TxRegs(void)
+{
+	mvOsPrintf("\n[TX general registers]\n");
+
+	mvPp2PrintReg(MV_PP2_TX_SNOOP_REG, "MV_PP2_TX_SNOOP_REG");
+	mvPp2PrintReg(MV_PP2_TX_FIFO_THRESH_REG, "MV_PP2_TX_FIFO_THRESH_REG");
+	mvPp2PrintReg(MV_PP2_TX_PORT_FLUSH_REG, "MV_PP2_TX_PORT_FLUSH_REG");
+}
+
 void mvPp2RxFifoRegs(int port)
 {
 	int p = MV_PPV2_PORT_PHYS(port);
@@ -458,7 +540,7 @@ void mvPp2RxFifoRegs(int port)
 /* Print status of Ethernet port */
 void mvPp2PortStatus(int port)
 {
-	int i;
+	int i, txp, txq;
 	MV_ETH_PORT_STATUS	link;
 	MV_PP2_PORT_CTRL 	*pPortCtrl;
 
@@ -485,13 +567,45 @@ void mvPp2PortStatus(int port)
 		mvOsPrintf("\n");
 	}
 
+	mvOsPrintf("\n[BM queue to Qset mapping]\n");
+	if (pPortCtrl->pRxQueue) {
+		mvOsPrintf("       RXQ: ");
+		for (i = 0; i < pPortCtrl->rxqNum; i++)
+			mvOsPrintf(" %4d", i);
+
+		mvOsPrintf("\n long Qset: ");
+		for (i = 0; i < pPortCtrl->rxqNum; i++)
+			mvOsPrintf(" %4d", mvBmRxqToQsetLongGet(mvPp2LogicRxqToPhysRxq(port, i)));
+
+		mvOsPrintf("\nshort Qset: ");
+		for (i = 0; i < pPortCtrl->rxqNum; i++)
+			mvOsPrintf(" %4d", mvBmRxqToQsetShortGet(mvPp2LogicRxqToPhysRxq(port, i)));
+
+		mvOsPrintf("\n");
+	}
+	if (pPortCtrl->pTxQueue) {
+		for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+			mvOsPrintf("\nTXP %2d, TXQ:", txp);
+			for (txq = 0; txq < pPortCtrl->txqNum; txq++)
+				mvOsPrintf(" %4d", txq);
+
+			mvOsPrintf("\n long Qset: ");
+			for (txq = 0; txq < pPortCtrl->txqNum; txq++)
+				mvOsPrintf(" %4d", mvBmTxqToQsetLongGet(MV_PPV2_TXQ_PHYS(port, txp, txq)));
+
+			mvOsPrintf("\nshort Qset: ");
+			for (txq = 0; txq < pPortCtrl->txqNum; txq++)
+				mvOsPrintf(" %4d", mvBmTxqToQsetShortGet(MV_PPV2_TXQ_PHYS(port, txp, txq)));
+
+			mvOsPrintf("\n");
+		}
+	}
+
 	mvOsPrintf("\n[Link: port=%d, ctrl=%p]\n", port, pPortCtrl);
 
-	if (MV_PON_PORT(port)) {
-		mvOsPrintf("GPON port %d link is up\n", port);
-	} else {
+	if (!MV_PON_PORT(port)) {
 
-		mvEthLinkStatus(port, &link);
+		mvGmacLinkStatus(port, &link);
 
 		if (link.linkup) {
 			mvOsPrintf("link up");
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
index e6fd578..83d7592 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
@@ -72,9 +72,26 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /************************** TX General Registers ******************************/
 #define MV_PP2_TX_SNOOP_REG			(MV_PP2_REG_BASE + 0x8800)
+#define MV_PP2_TX_FIFO_THRESH_REG		(MV_PP2_REG_BASE + 0x8804)
+
+/* Indirect access */
+#define MV_PP2_TX_PKT_LEN_IDX_REG		(MV_PP2_REG_BASE + 0x8808)
+#define MV_PP2_TX_PKT_LEN_CHANGE_REG		(MV_PP2_REG_BASE + 0x880C)
+
+#define MV_PP2_TX_PORT_FLUSH_REG		(MV_PP2_REG_BASE + 0x8810)
+
+#define MV_PP2_TX_PORT_FLUSH_OFFS		0
+#define MV_PP2_TX_PORT_FLUSH_BITS		7
+#define MV_PP2_TX_PORT_FLUSH_ALL_MASK		(((1 << MV_PP2_TX_PORT_FLUSH_BITS) - 1) << MV_PP2_TX_PORT_FLUSH_OFFS)
+#define MV_PP2_TX_PORT_FLUSH_MASK(p)		((1 << (p)) << MV_PP2_TX_PORT_FLUSH_OFFS)
+
+/* Registers per egress port */
+#define MV_PP2_TXP_BAD_CRC_CNTR_REG(txp)	(MV_PP2_REG_BASE + 0x8900)
+#define MV_PP2_TXP_DROP_CNTR_REG(txp)		(MV_PP2_REG_BASE + 0x8980)
+#define MV_PP2_TXP_DEQUEUE_THRESH_REG(txp)	(MV_PP2_REG_BASE + 0x88A0)
 
 /************************** RX Fifo Registers ******************************/
-#define MV_PP2_RX_DATA_FIFO_SIZE_REG(port)	(MV_PP2_REG_BASE + 4 * (port))
+#define MV_PP2_RX_DATA_FIFO_SIZE_REG(port)	(MV_PP2_REG_BASE + 0x00 + 4 * (port))
 #define MV_PP2_RX_ATTR_FIFO_SIZE_REG(port)	(MV_PP2_REG_BASE + 0x20 + 4 * (port))
 #define MV_PP2_RX_MIN_PKT_SIZE_REG		(MV_PP2_REG_BASE + 0x60)
 #define MV_PP2_RX_FIFO_INIT_REG			(MV_PP2_REG_BASE + 0x64)
@@ -92,51 +109,97 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP2_DSA_EXTENDED			(0x2 << MV_PP2_DSA_EN_OFFS)
 
 /************************** RX DMA Top Registers ******************************/
+#define MV_PP2_RX_CTRL_REG(port)		(MV_PP2_REG_BASE + 0x140 + 4 * (port))
+
 #define MV_PP2_POOL_BUF_SIZE_REG(pool)		(MV_PP2_REG_BASE + 0x180 + 4 * (pool))
 
 #define MV_PP2_POOL_BUF_SIZE_OFFSET		5
 #define MV_PP2_POOL_BUF_SIZE_MASK		(0xFFFE)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_RXQ_SNOOP_REG(rxq)		(MV_PP2_REG_BASE + 0x800 + 4 * (rxq))
+#ifdef CONFIG_MV_ETH_PP2_1 /* PPv2.1 - A0 */
 
-#define MV_PP2_SNOOP_PKT_SIZE_OFFS		5
+#define MV_PP2_RX_STATUS			(MV_PP2_REG_BASE + 0x174)
+
+#define MV_PP2_DISABLE_IN_PROG_OFFS		0
+#define MV_PP2_DISABLE_IN_PROG_MASK		(0x1 << MV_PP2_DISABLE_IN_PROG_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_RXQ_CONFIG_REG(rxq)		(MV_PP2_REG_BASE + 0x800 + 4 * (rxq))
+
+#define MV_PP2_SNOOP_PKT_SIZE_OFFS		0
 #define MV_PP2_SNOOP_PKT_SIZE_MASK		(0x1FF << MV_PP2_SNOOP_PKT_SIZE_OFFS)
 
-#define MV_PP2_SNOOP_BUF_HDR_OFFS		14
+#define MV_PP2_SNOOP_BUF_HDR_OFFS		9
 #define MV_PP2_SNOOP_BUF_HDR_MASK		(0x1 << MV_PP2_SNOOP_BUF_HDR_OFFS)
 
-#define MV_PP2_L2_DEPOSIT_PKT_SIZE_OFFS		21
+#define MV_PP2_L2_DEPOSIT_PKT_SIZE_OFFS		12
 #define MV_PP2_L2_DEPOSIT_PKT_SIZE_MASK		(0xF << MV_PP2_L2_DEPOSIT_PKT_SIZE_OFFS)
 
-#define MV_PP2_L2_DEPOSIT_BUF_HDR_OFFS		25
+#define MV_PP2_L2_DEPOSIT_BUF_HDR_OFFS		16
 #define MV_PP2_L2_DEPOSIT_BUF_HDR_MASK		(0x1 << MV_PP2_L2_DEPOSIT_BUF_HDR_OFFS)
+
+#define MV_PP2_RXQ_POOL_SHORT_OFFS		20
+#define MV_PP2_RXQ_POOL_SHORT_MASK		(0x7 << MV_PP2_RXQ_POOL_SHORT_OFFS)
+
+#define MV_PP2_RXQ_POOL_LONG_OFFS		24
+#define MV_PP2_RXQ_POOL_LONG_MASK		(0x7 << MV_PP2_RXQ_POOL_LONG_OFFS)
+
+#define MV_PP2_RXQ_PACKET_OFFSET_OFFS		28
+#define MV_PP2_RXQ_PACKET_OFFSET_MASK		(0x7 << MV_PP2_RXQ_PACKET_OFFSET_OFFS)
+
+#define MV_PP2_RXQ_DISABLE_BIT			31
+#define MV_PP2_RXQ_DISABLE_MASK			(0x1 << MV_PP2_RXQ_DISABLE_BIT)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_HWF_TXQ_CONFIG_REG(txq)		(MV_PP2_REG_BASE + 0xc00 + 4 * (txq))
+
+#define MV_PP2_HWF_TXQ_POOL_SHORT_OFFS		0
+#define MV_PP2_HWF_TXQ_POOL_SHORT_MASK		(0x7 << MV_PP2_HWF_TXQ_POOL_SHORT_OFFS)
+
+#define MV_PP2_HWF_TXQ_POOL_LONG_OFFS		4
+#define MV_PP2_HWF_TXQ_POOL_LONG_MASK		(0x7 << MV_PP2_HWF_TXQ_POOL_LONG_OFFS)
+
+#define MV_PP2_HWF_TXQ_DISABLE_BIT              31
+#define MV_PP2_HWF_TXQ_DISABLE_MASK             (0x1 << MV_PP2_HWF_TXQ_DISABLE_BIT)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_RXQ_CONFIG_REG(rxq)		(MV_PP2_REG_BASE + 0xc00 + 4 * (rxq))
+#else /* PPv2 - Z1 */
+
+#define MV_PP2_V0_RXQ_SNOOP_REG(rxq)		(MV_PP2_REG_BASE + 0x800 + 4 * (rxq))
+
+#define MV_PP2_V0_SNOOP_PKT_SIZE_OFFS		5
+#define MV_PP2_V0_SNOOP_PKT_SIZE_MASK		(0x1FF << MV_PP2_V0_SNOOP_PKT_SIZE_OFFS)
 
-#define MV_PP2_RXQ_PACKET_OFFSET_ALL_MASK	(0xE0707)
-#define MV_PP2_RXQ_POOL_MASK			(0x707)
+#define MV_PP2_V0_SNOOP_BUF_HDR_OFFS		14
+#define MV_PP2_V0_SNOOP_BUF_HDR_MASK		(0x1 << MV_PP2_V0_SNOOP_BUF_HDR_OFFS)
 
-#define MV_PP2_RXQ_POOL_SHORT_ID_OFFS		0
-#define MV_PP2_RXQ_POOL_SHORT_ID_MASK		(0x7 << MV_PP2_RXQ_POOL_SHORT_ID_OFFS)
-#define MV_PP2_RXQ_POOL_LONG_ID_OFFS		8
-#define MV_PP2_RXQ_POOL_LONG_ID_MASK		(0x7 << MV_PP2_RXQ_POOL_LONG_ID_OFFS)
-#define MV_PP2_RXQ_PACKET_OFFSET_OFFS		12
-#define MV_PP2_RXQ_PACKET_OFFSET_MASK		(0xFF << MV_PP2_RXQ_PACKET_OFFSET_OFFS)
+#define MV_PP2_V0_L2_DEPOSIT_PKT_SIZE_OFFS	21
+#define MV_PP2_V0_L2_DEPOSIT_PKT_SIZE_MASK	(0xF << MV_PP2_V0_L2_DEPOSIT_PKT_SIZE_OFFS)
+
+#define MV_PP2_V0_L2_DEPOSIT_BUF_HDR_OFFS	25
+#define MV_PP2_V0_L2_DEPOSIT_BUF_HDR_MASK	(0x1 << MV_PP2_V0_L2_DEPOSIT_BUF_HDR_OFFS)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_PORT_HWF_CONFIG_REG(port)	(MV_PP2_REG_BASE + 0x120 + 4 * (port))
+#define MV_PP2_V0_RXQ_CONFIG_REG(rxq)		(MV_PP2_REG_BASE + 0xc00 + 4 * (rxq))
+
+#define MV_PP2_V0_RXQ_POOL_SHORT_OFFS		0
+#define MV_PP2_V0_RXQ_POOL_SHORT_MASK		(0x7 << MV_PP2_V0_RXQ_POOL_SHORT_OFFS)
+#define MV_PP2_V0_RXQ_POOL_LONG_OFFS		8
+#define MV_PP2_V0_RXQ_POOL_LONG_MASK		(0x7 << MV_PP2_V0_RXQ_POOL_LONG_OFFS)
+#define MV_PP2_V0_RXQ_PACKET_OFFSET_OFFS	17
+#define MV_PP2_V0_RXQ_PACKET_OFFSET_MASK	(0xFF << MV_PP2_V0_RXQ_PACKET_OFFSET_OFFS)
+/*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_PORT_HWF_PKT_OFFSET_ALL_MASK	(0x707)
+#define MV_PP2_V0_PORT_HWF_CONFIG_REG(port)	(MV_PP2_REG_BASE + 0x120 + 4 * (port))
 
-#define MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS	0
-#define MV_PP2_PORT_HWF_POOL_SHORT_ID_MASK	(0x7 << MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS)
-#define MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS	8
-#define MV_PP2_PORT_HWF_POOL_LONG_ID_MASK	(0x7 << MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS)
+#define MV_PP2_V0_PORT_HWF_POOL_SHORT_OFFS	0
+#define MV_PP2_V0_PORT_HWF_POOL_SHORT_MASK	(0x7 << MV_PP2_V0_PORT_HWF_POOL_SHORT_OFFS)
+#define MV_PP2_V0_PORT_HWF_POOL_LONG_OFFS	8
+#define MV_PP2_V0_PORT_HWF_POOL_LONG_MASK	(0x7 << MV_PP2_V0_PORT_HWF_POOL_LONG_OFFS)
 /*-------------------------------------------------------------------------------*/
 
-#define MV_PP2_RX_CTRL_REG(port)		(MV_PP2_REG_BASE + 0x140 + 4 * (port))
+#endif /* PPv2 - Z1 / PPv2.1 - A0 */
 
 #define MV_PP2_RX_GEMPID_SRC_OFFS		8
 #define MV_PP2_RX_GEMPID_SRC_MASK		(0x7 << MV_PP2_RX_GEMPID_SRC_OFFS)
@@ -232,24 +295,28 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_PP2_TXQ_PREF_BUF_REG			(MV_PP2_REG_BASE + 0x209c)
 
-#define MV_PP2_PREF_BUF_PTR_OFFSET		0
-#define MV_PP2_PREF_BUF_PTR_MASK		(0xFFF << MV_PP2_PREF_BUF_PTR_OFFSET)
-#define MV_PP2_PREF_BUF_PTR(desc)		((desc) << MV_PP2_PREF_BUF_PTR_OFFSET)
-
-#define MV_PP2_PREF_BUF_SIZE_OFFSET		12
-#define MV_PP2_PREF_BUF_SIZE_MASK		(0x7 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_NONE		(0 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_1			(1 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_2			(2 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_4			(3 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_8			(4 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_16			(5 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_32			(6 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-#define MV_PP2_PREF_BUF_SIZE_64			(7 << MV_PP2_PREF_BUF_SIZE_OFFSET)
-
-#define MV_PP2_PREF_BUF_THRESH_OFFSET		17
-#define MV_PP2_PREF_BUF_THRESH_MASK		(0xF << MV_PP2_PREF_BUF_THRESH_OFFSET)
-#define MV_PP2_PREF_BUF_THRESH(val)		((val) << MV_PP2_PREF_BUF_THRESH_OFFSET)
+#define MV_PP2_PREF_BUF_PTR_OFFS		0
+#define MV_PP2_PREF_BUF_PTR_MASK		(0xFFFF << MV_PP2_PREF_BUF_PTR_OFFS)
+#define MV_PP2_PREF_BUF_PTR(desc)		(((desc) << MV_PP2_PREF_BUF_PTR_OFFS) & MV_PP2_PREF_BUF_PTR_MASK)
+
+#define MV_PP2_PREF_BUF_SIZE_OFFS		12
+#define MV_PP2_PREF_BUF_SIZE_MASK		(0x7 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_NONE		(0 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_1			(1 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_2			(2 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_4			(3 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_8			(4 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_16			(5 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_32			(6 << MV_PP2_PREF_BUF_SIZE_OFFS)
+#define MV_PP2_PREF_BUF_SIZE_64			(7 << MV_PP2_PREF_BUF_SIZE_OFFS)
+
+#define MV_PP2_PREF_BUF_THRESH_OFFS		17
+#define MV_PP2_PREF_BUF_THRESH_MASK		(0xF << MV_PP2_PREF_BUF_THRESH_OFFS)
+#define MV_PP2_PREF_BUF_THRESH(val)		((val) << MV_PP2_PREF_BUF_THRESH_OFFS)
+
+/* new field for PPV2.1 - A0 only */
+#define MV_PP2_TXQ_DRAIN_EN_BIT			31
+#define MV_PP2_TXQ_DRAIN_EN_MASK		(1 << MV_PP2_TXQ_DRAIN_EN_BIT)
 /*-------------------------------------------------------------------------------*/
 
 #define MV_PP2_TXQ_PENDING_REG			(MV_PP2_REG_BASE + 0x20a0)
@@ -257,12 +324,51 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP2_TXQ_PENDING_OFFSET		0
 #define MV_PP2_TXQ_PENDING_MASK			(0x3FFF << MV_PP2_TXQ_PENDING_OFFSET)
 
+/*
+   ppv2.1 field MV_PP2_TXQ_HWF_PENDING_OFFSET changed to MV_PP2_TXQ_RESERVED_DESC_OFFSET
+   MAS 3.16
+*/
 #define MV_PP2_TXQ_HWF_PENDING_OFFSET		16
 #define MV_PP2_TXQ_HWF_PENDING_MASK		(0x3FFF << MV_PP2_TXQ_HWF_PENDING_OFFSET)
+
+#define MV_PP2_TXQ_RSVD_DESC_OFFSET		16
+#define MV_PP2_TXQ_RSVD_DESC_MASK		(0x3FFF << MV_PP2_TXQ_RSVD_DESC_MASK)
+
 /*-------------------------------------------------------------------------------*/
 
 #define MV_PP2_TXQ_INT_STATUS_REG		(MV_PP2_REG_BASE + 0x20a4)
 /*-------------------------------------------------------------------------------*/
+/*
+   ppv2.1- new register 0x20b0, not exist ip ppv2.0
+   MAS 3.16
+*/
+#define MV_PP2_TXQ_RSVD_REQ_REG			(MV_PP2_REG_BASE + 0x20b0)
+
+#define MV_PP2_TXQ_RSVD_REQ_DESC_OFFSET		0
+#define MV_PP2_TXQ_RSVD_REQ_DESC_MASK		(0x3FFF << MV_PP2_TXQ_RSVD_REQ_DESC_OFFSET)
+
+#define MV_PP2_TXQ_RSVD_REQ_Q_OFFSET		16
+#define MV_PP2_TXQ_RSVD_REQ_Q_MASK		(0xFF << MV_PP2_TXQ_RSVD_REQ_Q_OFFSET)
+/*-------------------------------------------------------------------------------*/
+/*
+   ppv2.1- new register 0x20b4, not exist ip ppv2.0
+   MAS 3.16
+*/
+#define MV_PP2_TXQ_RSVD_RSLT_REG		(MV_PP2_REG_BASE + 0x20b4)
+
+#define MV_PP2_TXQ_RSVD_RSLT_OFFSET		0
+#define MV_PP2_TXQ_RSVD_RSLT_MASK		(0x3FFF << MV_PP2_TXQ_RSVD_RSLT_OFFSET)
+
+/*-------------------------------------------------------------------------------*/
+/*
+   ppv2.1- new register 0x20b8, not exist ip ppv2.0
+   MAS 3.22
+*/
+#define MV_PP2_TXQ_RSVD_CLR_REG			(MV_PP2_REG_BASE + 0x20b8)
+
+#define MV_PP2_TXQ_RSVD_CLR_OFFSET		16
+#define MV_PP2_TXQ_RSVD_CLR_MASK		(0xFF << MV_PP2_TXQ_RSVD_CLR_OFFSET)
+/*-------------------------------------------------------------------------------*/
 
 /* Direct access - per TXQ, per CPU */
 #define MV_PP2_TXQ_SENT_REG(txq)		(MV_PP2_REG_BASE + 0x3c00 + 4 * (txq))
@@ -434,14 +540,47 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP2_ISR_MISC_MASK_REG			(MV_PP2_REG_BASE + 0x55b4)
 /*-------------------------------------------------------------------------------*/
 
-/******************************** Port Drop counters *****************************/
 #define MV_PP2_OVERRUN_DROP_REG(port)		(MV_PP2_REG_BASE + 0x7000 + 4 * (port))
 #define MV_PP2_CLS_DROP_REG(port)			(MV_PP2_REG_BASE + 0x7020 + 4 * (port))
-#define MV_PP2_POLICER_DROP_REG(plcr)		(MV_PP2_REG_BASE + 0x7040 + 4 * (plcr))
-#define MV_PP2_TX_EARLY_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7080 + 4 * (eport))
-#define MV_PP2_TX_DESC_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7100 + 4 * (eport))
-#define MV_PP2_RX_EARLY_DROP_REG(rxq)		(MV_PP2_REG_BASE + 0x7200 + 4 * (rxq))
-#define MV_PP2_RX_DESC_DROP_REG(rxq)		(MV_PP2_REG_BASE + 0x7400 + 4 * (rxq))
+
+/******************************** Port Drop counters ppv2.0*****************************/
+
+#define MV_PP2_V0_POLICER_DROP_REG(plcr)		(MV_PP2_REG_BASE + 0x7040 + 4 * (plcr))
+#define MV_PP2_V0_TX_EARLY_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7080 + 4 * (eport))
+#define MV_PP2_V0_TX_DESC_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7100 + 4 * (eport))
+#define MV_PP2_V0_RX_EARLY_DROP_REG(rxq)		(MV_PP2_REG_BASE + 0x7200 + 4 * (rxq))
+#define MV_PP2_V0_RX_DESC_DROP_REG(rxq)			(MV_PP2_REG_BASE + 0x7400 + 4 * (rxq))
+
+/************************************ counters ppv2.1 **********************************/
+
+
+#define MV_PP2_V1_CNT_IDX_REG				(MV_PP2_REG_BASE + 0x7040)
+/* TX counters index */
+#define TX_CNT_IDX_TXP					3
+#define TX_CNT_IDX_TXQ					0
+
+#define TX_CNT_IDX(port, txp, txq)			((MV_PPV2_TXP_PHYS(port, txp) << 3) | (txq))
+
+#define MV_PP2_V1_TX_DESC_ENQ_REG			(MV_PP2_REG_BASE + 0x7100)
+#define MV_PP2_V1_TX_DESC_ENQ_TO_DRAM_REG		(MV_PP2_REG_BASE + 0x7104)
+#define MV_PP2_V1_TX_BUF_ENQ_TO_DRAM_REG		(MV_PP2_REG_BASE + 0x7108)
+#define MV_PP2_V1_TX_DESC_HWF_ENQ_REG			(MV_PP2_REG_BASE + 0x710c)
+#define MV_PP2_V1_TX_PKT_DQ_REG				(MV_PP2_REG_BASE + 0x7130)
+#define MV_PP2_V1_TX_PKT_FULLQ_DROP_REG			(MV_PP2_REG_BASE + 0x7200)
+#define MV_PP2_V1_TX_PKT_EARLY_DROP_REG			(MV_PP2_REG_BASE + 0x7204)
+#define MV_PP2_V1_TX_PKT_BM_DROP_REG			(MV_PP2_REG_BASE + 0x7208)
+#define MV_PP2_V1_TX_PKT_BM_MC_DROP_REG			(MV_PP2_REG_BASE + 0x720c)
+
+#define MV_PP2_V1_RX_PKT_FULLQ_DROP_REG			(MV_PP2_REG_BASE + 0x7220)
+#define MV_PP2_V1_RX_PKT_EARLY_DROP_REG			(MV_PP2_REG_BASE + 0x7224)
+#define MV_PP2_V1_RX_PKT_BM_DROP_REG			(MV_PP2_REG_BASE + 0x7228)
+#define MV_PP2_V1_RX_DESC_ENQ_REG			(MV_PP2_REG_BASE + 0x7120)
+
+#define MV_PP2_V1_OVERFLOW_MC_DROP_REG			(MV_PP2_REG_BASE + 0x770c)
+
+
+
+
 /*-------------------------------------------------------------------------------*/
 
 
@@ -459,13 +598,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_PP2_TXP_SCHED_CMD_1_REG		(MV_PP2_REG_BASE + 0x8010)
 
-#define MV_PP2_TXP_SCHED_RESET_BIT          	0
-#define MV_PP2_TXP_SCHED_RESET_MASK         	(1 << MV_PP2_TXP_SCHED_RESET_BIT)
+#define MV_PP2_TXP_SCHED_RESET_BIT		0
+#define MV_PP2_TXP_SCHED_RESET_MASK		(1 << MV_PP2_TXP_SCHED_RESET_BIT)
 
 #define MV_PP2_TXP_SCHED_PTP_SYNC_BIT		1
 #define MV_PP2_TXP_SCHED_PTP_SYNC_MASK		(1 << MV_PP2_TXP_SCHED_PTP_SYNC_BIT)
 
-#define MV_PP2_TXP_SCHED_EJP_ENABLE_BIT     	2
+#define MV_PP2_TXP_SCHED_EJP_ENABLE_BIT		2
 #define MV_PP2_TXP_SCHED_EJP_ENABLE_MASK	(1 << MV_PP2_TXP_SCHED_EJP_ENABLE_BIT)
 /*-----------------------------------------------------------------------------------------------*/
 
@@ -486,7 +625,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Port Maximum Transmit Unit (PMTU) */
 #define MV_PP2_TXP_SCHED_MTU_REG		(MV_PP2_REG_BASE + 0x801c)
-
 #define MV_PP2_TXP_MTU_OFFS			0
 #define MV_PP2_TXP_MTU_MAX			0x7FFFF
 #define MV_PP2_TXP_MTU_ALL_MASK			(MV_PP2_TXP_MTU_MAX << MV_PP2_TXP_MTU_OFFS)
@@ -495,11 +633,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Port Bucket Refill (PRefill) */
 #define MV_PP2_TXP_SCHED_REFILL_REG		(MV_PP2_REG_BASE + 0x8020)
-
-#define MV_PP2_TXP_REFILL_TOKENS_OFFS       	0
-#define MV_PP2_TXP_REFILL_TOKENS_MAX        	0x7FFFF
-#define MV_PP2_TXP_REFILL_TOKENS_ALL_MASK   	(MV_PP2_TXP_REFILL_TOKENS_MAX << MV_PP2_TXP_REFILL_TOKENS_OFFS)
-#define MV_PP2_TXP_REFILL_TOKENS_MASK(val)  	((val) << MV_PP2_TXP_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXP_REFILL_TOKENS_OFFS		0
+#define MV_PP2_TXP_REFILL_TOKENS_MAX		0x7FFFF
+#define MV_PP2_TXP_REFILL_TOKENS_ALL_MASK	(MV_PP2_TXP_REFILL_TOKENS_MAX << MV_PP2_TXP_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXP_REFILL_TOKENS_MASK(val)	((val) << MV_PP2_TXP_REFILL_TOKENS_OFFS)
 
 #define MV_PP2_TXP_REFILL_PERIOD_OFFS       	20
 #define MV_PP2_TXP_REFILL_PERIOD_MAX        	0x3FF
@@ -520,53 +657,37 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Queue Bucket Refill (QRefill) */
 #define MV_PP2_TXQ_SCHED_REFILL_REG(q)		(MV_PP2_REG_BASE + 0x8040 + ((q) << 2))
 
-#define MV_PP2_TXQ_REFILL_TOKENS_OFFS       	0
-#define MV_PP2_TXQ_REFILL_TOKENS_MAX        	0x7FFFF
-#define MV_PP2_TXQ_REFILL_TOKENS_ALL_MASK   	(MV_PP2_TXQ_REFILL_TOKENS_MAX << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
-#define MV_PP2_TXQ_REFILL_TOKENS_MASK(val)  	((val) << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXQ_REFILL_TOKENS_OFFS		0
+#define MV_PP2_TXQ_REFILL_TOKENS_MAX		0x7FFFF
+#define MV_PP2_TXQ_REFILL_TOKENS_ALL_MASK	(MV_PP2_TXQ_REFILL_TOKENS_MAX << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXQ_REFILL_TOKENS_MASK(val)	((val) << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
 
-#define MV_PP2_TXQ_REFILL_PERIOD_OFFS       	20
-#define MV_PP2_TXQ_REFILL_PERIOD_MAX        	0x3FF
-#define MV_PP2_TXQ_REFILL_PERIOD_ALL_MASK   	(MV_PP2_TXQ_REFILL_PERIOD_MAX << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
-#define MV_PP2_TXQ_REFILL_PERIOD_MASK(val)  	((val) << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
+#define MV_PP2_TXQ_REFILL_PERIOD_OFFS		20
+#define MV_PP2_TXQ_REFILL_PERIOD_MAX		0x3FF
+#define MV_PP2_TXQ_REFILL_PERIOD_ALL_MASK	(MV_PP2_TXQ_REFILL_PERIOD_MAX << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
+#define MV_PP2_TXQ_REFILL_PERIOD_MASK(val)	((val) << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
 /*-----------------------------------------------------------------------------------------------*/
 
 /* Queue Maximum Token Bucket Size (QMTBS) */
 #define MV_PP2_TXQ_SCHED_TOKEN_SIZE_REG(q)	(MV_PP2_REG_BASE + 0x8060 + ((q) << 2))
-#define MV_PP2_TXQ_TOKEN_SIZE_MAX           	0x7FFFFFFF
+#define MV_PP2_TXQ_TOKEN_SIZE_MAX		0x7FFFFFFF
 /*-----------------------------------------------------------------------------------------------*/
 
 /* Queue Token Bucket Counter (PMTBS) */
 #define MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG(q)	(MV_PP2_REG_BASE + 0x8080 + ((q) << 2))
-#define MV_PP2_TXQ_TOKEN_CNTR_MAX           	0xFFFFFFFF
+#define MV_PP2_TXQ_TOKEN_CNTR_MAX		0xFFFFFFFF
 /*-----------------------------------------------------------------------------------------------*/
 
 /* Transmit Queue Arbiter Configuration (TQxAC) */
 #define MV_PP2_TXQ_SCHED_WRR_REG(q)		(MV_PP2_REG_BASE + 0x80A0 + ((q) << 2))
 
-#define MV_PP2_TXQ_WRR_WEIGHT_OFFS          	0
-#define MV_PP2_TXQ_WRR_WEIGHT_MAX           	0xFF
-#define MV_PP2_TXQ_WRR_WEIGHT_ALL_MASK      	(MV_PP2_TXQ_WRR_WEIGHT_MAX << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
-#define MV_PP2_TXQ_WRR_WEIGHT_MASK(weigth)  	((weigth) << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
-
-#define MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS      	8
-#define MV_PP2_TXQ_WRR_BYTE_COUNT_MASK      	(0x3FFFF << MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS)
-/*-----------------------------------------------------------------------------------------------*/
-
-#if 0 /* TBD - set EJP registers */
-/* Transmission Queue IPG (TQxIPG) */
-#define MV_PP2_TXQ_EJP_IPG_REG(q)		(MV_PP2_REG_BASE + 0x80C0 + ((q) >> 2))
+#define MV_PP2_TXQ_WRR_WEIGHT_OFFS		0
+#define MV_PP2_TXQ_WRR_WEIGHT_MAX		0xFF
+#define MV_PP2_TXQ_WRR_WEIGHT_ALL_MASK		(MV_PP2_TXQ_WRR_WEIGHT_MAX << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
+#define MV_PP2_TXQ_WRR_WEIGHT_MASK(weigth)	((weigth) << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
 
-#define MV_PP2_TXQ_EJP_IPG_OFFS             	0
-#define MV_PP2_TXQ_EJP_IPG_MASK             	(0x3FFF << MV_PP2_TXQ_EJP_IPG_OFFS)
-/*-----------------------------------------------------------------------------------------------*/
-
-#define MV_PP2_TXP_EJP_HI_LO_REG		(MV_PP2_REG_BASE + 0x80D0)
-#define MV_PP2_TXP_EJP_HI_ASYNC_REG		(MV_PP2_REG_BASE + 0x80D4)
-#define MV_PP2_TXP_EJP_LO_ASYNC_REG		(MV_PP2_REG_BASE + 0x80D8)
-#define MV_PP2_TXP_EJP_SPEED_REG		(MV_PP2_REG_BASE + 0x80DC)
-#endif /* 0 */
-/*-----------------------------------------------------------------------------------------------*/
+#define MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS		8
+#define MV_PP2_TXQ_WRR_BYTE_COUNT_MASK		(0x3FFFF << MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS)
 
 /************************** PPv2 HW defines ******************************/
 #define MV_PP2_RX_FIFO_PORT_DATA_SIZE		0x2000
@@ -588,7 +709,8 @@ typedef struct pp2_rx_desc {
 	MV_U32 bufCookie;
 	MV_U16 gemPortIdPktColor;
 	MV_U16 csumL4;
-	MV_U16 reserved;
+	MV_U8  bmQset;
+	MV_U8  reserved;
 	MV_U16 classifyInfo;
 	MV_U32 flowId;
 	MV_U32 reserved2;
@@ -651,35 +773,42 @@ typedef struct pp2_rx_desc {
 #define PP2_RX_L3_IS_IP4_OTHER(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4_OTHER)
 #define PP2_RX_L3_IS_IP6(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP6)
 #define PP2_RX_L3_IS_IP6_EXT(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP6_EXT)
-#define PP2_RX_L4_IS_UDP(status)      		(((status) & PP2_RX_L4_MASK) == PP2_RX_L4_UDP)
+#define PP2_RX_L4_IS_UDP(status)		(((status) & PP2_RX_L4_MASK) == PP2_RX_L4_UDP)
 #define PP2_RX_L4_IS_TCP(status)		(((status) & PP2_RX_L4_MASK) == PP2_RX_L4_TCP)
 #define PP2_RX_IP4_HDR_ERR(status)		((status) & PP2_RX_IP4_HEADER_ERR_MASK)
 #define PP2_RX_IP4_FRG(status)			((status) & PP2_RX_IP_FRAG_MASK)
 #define PP2_RX_L4_CHK_OK(status)		((status) & PP2_RX_L4_CHK_OK_MASK)
 
 /* Sub fields of "parserInfo" field */
-#define PP2_RX_LKP_ID_OFFS              	0
+#define PP2_RX_LKP_ID_OFFS			0
 #define PP2_RX_LKP_ID_BITS			6
-#define PP2_RX_LKP_ID_MASK              	(((1 << PP2_RX_LKP_ID_BITS) - 1) << PP2_RX_LKP_ID_OFFS)
+#define PP2_RX_LKP_ID_MASK			(((1 << PP2_RX_LKP_ID_BITS) - 1) << PP2_RX_LKP_ID_OFFS)
 
 #define PP2_RX_CPU_CODE_OFFS			6
 #define PP2_RX_CPU_CODE_BITS			3
 #define PP2_RX_CPU_CODE_MASK			(((1 << PP2_RX_CPU_CODE_BITS) - 1) << PP2_RX_CPU_CODE_OFFS)
 
-#define PP2_RX_PPPOE_BIT                        9
-#define PP2_RX_PPPOE_MASK                       (1 << PP2_RX_PPPOE_BIT)
+#define PP2_RX_PPPOE_BIT			9
+#define PP2_RX_PPPOE_MASK			(1 << PP2_RX_PPPOE_BIT)
+
+#define PP2_RX_L3_CAST_OFFS			10
+#define PP2_RX_L3_CAST_BITS			2
+#define PP2_RX_L3_CAST_MASK			(((1 << PP2_RX_L3_CAST_BITS) - 1) << PP2_RX_L3_CAST_OFFS)
 
-#define PP2_RX_L3_CAST_OFFS                     10
-#define PP2_RX_L3_CAST_BITS                     2
-#define PP2_RX_L3_CAST_MASK                     (((1 << PP2_RX_L3_CAST_BITS) - 1) << PP2_RX_L3_CAST_OFFS)
+#define PP2_RX_L2_CAST_OFFS			12
+#define PP2_RX_L2_CAST_BITS			2
+#define PP2_RX_L2_CAST_MASK			(((1 << PP2_RX_L2_CAST_BITS) - 1) << PP2_RX_L2_CAST_OFFS)
 
-#define PP2_RX_L2_CAST_OFFS                     12
-#define PP2_RX_L2_CAST_BITS                     2
-#define PP2_RX_L2_CAST_MASK                     (((1 << PP2_RX_L2_CAST_BITS) - 1) << PP2_RX_L2_CAST_OFFS)
+#define PP2_RX_VLAN_INFO_OFFS			14
+#define PP2_RX_VLAN_INFO_BITS			2
+#define PP2_RX_VLAN_INFO_MASK			(((1 << PP2_RX_VLAN_INFO_BITS) - 1) << PP2_RX_VLAN_INFO_OFFS)
 
-#define PP2_RX_VLAN_INFO_OFFS                   14
-#define PP2_RX_VLAN_INFO_BITS                   2
-#define PP2_RX_VLAN_INFO_MASK                   (((1 << PP2_RX_VLAN_INFO_BITS) - 1) << PP2_RX_VLAN_INFO_OFFS)
+/* Bits of "bmQset" field */
+#define PP2_RX_BUFF_QSET_NUM_OFFS		0
+#define PP2_RX_BUFF_QSET_NUM_MASK		(0x7f << PP2_RX_BUFF_QSET_NUM_OFFS)
+
+#define PP2_RX_BUFF_TYPE_OFFS			7
+#define PP2_RX_BUFF_TYPE_MASK			(0x1 << PP2_RX_BUFF_TYPE_OFFS)
 /*-------------------------------------------------------------------------------*/
 
 /* TXQ */
@@ -722,11 +851,11 @@ typedef struct pp2_tx_desc {
 #define PP2_TX_PKT_OFFS_9_BIT			20
 #define PP2_TX_PKT_OFFS_9_MASK			(1 << PP2_TX__PKT_OFFS_9_BIT)
 
-#define PP2_TX_HWF_SYNC_BIT                     21
-#define PP2_TX_HWF_SYNC_MASK	                (1 << PP2_TX_HWF_SYNC_BIT)
+#define PP2_TX_HWF_SYNC_BIT			21
+#define PP2_TX_HWF_SYNC_MASK			(1 << PP2_TX_HWF_SYNC_BIT)
 
-#define PP2_TX_HWF_BIT                          22
-#define PP2_TX_HWF_MASK	                        (1 << PP2_TX_HWF_BIT)
+#define PP2_TX_HWF_BIT				22
+#define PP2_TX_HWF_MASK				(1 << PP2_TX_HWF_BIT)
 
 #define PP2_TX_PADDING_DISABLE_BIT		23
 #define PP2_TX_PADDING_DISABLE_MASK		(1 << PP2_TX_PADDING_DISABLE_BIT)
@@ -754,69 +883,77 @@ typedef struct pp2_tx_desc {
 #define PP2_TX_BUF_HDR_MASK			(1 << PP2_TX_BUF_HDR_BIT)
 
 /* Bits of "hwCmd[0]" field - offset 0x10 */
-#define PP2_TX_GEMPID_OFFS                      0
-#define PP2_TX_GEMPID_BITS                      12
-#define PP2_TX_GEMPID_ALL_MASK                  (((1 << PP2_TX_GEMPID_BITS) - 1) << PP2_TX_GEMPID_OFFS)
-#define PP2_TX_GEMPID_MASK(gpid)                (((gpid) & PP2_TX_GEMPID_ALL_MASK) << PP2_TX_GEMPID_OFFS)
-
-#define PP2_TX_COLOR_OFFS                       12
-#define PP2_TX_COLOR_ALL_MASK                   (0x3 << PP2_TX_COLOR_OFFS)
-#define PP2_TX_COLOR_GREEN                      0
-#define PP2_TX_COLOR_YELLOW                     1
-#define PP2_TX_COLOR_MASK(col)                  (((col) & PP2_TX_COLOR_ALL_MASK) << PP2_TX_COLOR_OFFS)
-
-#define PP2_TX_DSA_OFFS                         14
-#define PP2_TX_DSA_ALL_MASK                     (0x3 << PP2_TX_DSA_OFFS)
-#define PP2_TX_DSA_NONE                         0
-#define PP2_TX_DSA_TAG                          1
-#define PP2_TX_EDSA_TAG                         2
-#define PP2_TX_DSA_MASK(dsa)                    (((dsa) & PP2_TX_DSA_ALL_MASK) << PP2_TX_DSA_OFFS)
-
-#define PP2_TX_L4_CSUM_INIT_OFFS                16
-#define PP2_TX_L4_CSUM_INIT_MASK                (0xffff << PP2_TX_L4_CSUM_INIT_OFFS)
+#define PP2_TX_GEMPID_OFFS			0
+#define PP2_TX_GEMPID_BITS			12
+#define PP2_TX_GEMPID_ALL_MASK			(((1 << PP2_TX_GEMPID_BITS) - 1) << PP2_TX_GEMPID_OFFS)
+#define PP2_TX_GEMPID_MASK(gpid)		(((gpid) & PP2_TX_GEMPID_ALL_MASK) << PP2_TX_GEMPID_OFFS)
+
+#define PP2_TX_COLOR_OFFS			12
+#define PP2_TX_COLOR_ALL_MASK			(0x3 << PP2_TX_COLOR_OFFS)
+#define PP2_TX_COLOR_GREEN			0
+#define PP2_TX_COLOR_YELLOW			1
+#define PP2_TX_COLOR_MASK(col)			(((col) & PP2_TX_COLOR_ALL_MASK) << PP2_TX_COLOR_OFFS)
+
+#define PP2_TX_DSA_OFFS				14
+#define PP2_TX_DSA_ALL_MASK			(0x3 << PP2_TX_DSA_OFFS)
+#define PP2_TX_DSA_NONE				0
+#define PP2_TX_DSA_TAG				1
+#define PP2_TX_EDSA_TAG				2
+#define PP2_TX_DSA_MASK(dsa)			(((dsa) & PP2_TX_DSA_ALL_MASK) << PP2_TX_DSA_OFFS)
+
+#define PP2_TX_L4_CSUM_INIT_OFFS		16
+#define PP2_TX_L4_CSUM_INIT_MASK		(0xffff << PP2_TX_L4_CSUM_INIT_OFFS)
 
 /* Bits of "hwCmd[1]" field - offset 0x14 */
 
-/* bits 0..15 are reserved */
-#define PP2_TX_MOD_DSCP_OFFS                    16
-#define PP2_TX_MOD_DSCP_BITS                    6
-#define PP2_TX_MOD_DSCP_MASK                    (((1 << PP2_TX_MOD_DSCP_BITS) - 1) << PP2_TX_MOD_DSCP_OFFS)
+#define PP2_TX_MOD_QSET_OFFS			0
+#define PP2_TX_MOD_QSET_BITS			7
+#define PP2_TX_MOD_QSET_MASK			(((1 << PP2_TX_MOD_QSET_BITS) - 1) << PP2_TX_MOD_QSET_OFFS)
+
+#define PP2_TX_MOD_GRNTD_BIT			7
+#define PP2_TX_MOD_GRNTD_MASK			(1 <<  PP2_TX_MOD_GRNTD_BIT)
+
+/* bits 8..15 are reserved */
+
+#define PP2_TX_MOD_DSCP_OFFS			16
+#define PP2_TX_MOD_DSCP_BITS			6
+#define PP2_TX_MOD_DSCP_MASK			(((1 << PP2_TX_MOD_DSCP_BITS) - 1) << PP2_TX_MOD_DSCP_OFFS)
 
-#define PP2_TX_MOD_PRIO_OFFS                    22
-#define PP2_TX_MOD_PRIO_BITS                    3
-#define PP2_TX_MOD_PRIO_MASK                    (((1 << PP2_TX_MOD_PRIO_BITS) - 1) << PP2_TX_MOD_PRIO_OFFS)
+#define PP2_TX_MOD_PRIO_OFFS			22
+#define PP2_TX_MOD_PRIO_BITS			3
+#define PP2_TX_MOD_PRIO_MASK			(((1 << PP2_TX_MOD_PRIO_BITS) - 1) << PP2_TX_MOD_PRIO_OFFS)
 
-#define PP2_TX_MOD_DSCP_EN_BIT                  25
-#define PP2_TX_MOD_DSCP_EN_MASK                 (1 << PP2_TX_MOD_DSCP_EN_BIT)
+#define PP2_TX_MOD_DSCP_EN_BIT			25
+#define PP2_TX_MOD_DSCP_EN_MASK			(1 << PP2_TX_MOD_DSCP_EN_BIT)
 
-#define PP2_TX_MOD_PRIO_EN_BIT                  26
-#define PP2_TX_MOD_PRIO_EN_MASK                 (1 << PP2_TX_MOD_PRIO_EN_BIT)
+#define PP2_TX_MOD_PRIO_EN_BIT			26
+#define PP2_TX_MOD_PRIO_EN_MASK			(1 << PP2_TX_MOD_PRIO_EN_BIT)
 
-#define PP2_TX_MOD_GEMPID_EN_BIT                27
-#define PP2_TX_MOD_GEMPID_EN_MASK               (1 << PP2_TX_MOD_GEMPID_EN_BIT)
+#define PP2_TX_MOD_GEMPID_EN_BIT		27
+#define PP2_TX_MOD_GEMPID_EN_MASK		(1 << PP2_TX_MOD_GEMPID_EN_BIT)
 
 /* Bits of "hwCmd[2]" field - offset 0x18 */
-#define PP2_TX_PME_DPTR_OFFS                    0
-#define PP2_TX_PME_DPTR_ALL_MASK                (0xffff << PP2_TX_PME_DPTR_OFFS)
-#define PP2_TX_PME_DPTR_MASK(val)               (((val) & PP2_TX_PME_DPTR_ALL_MASK) << PP2_TX_PME_DPTR_OFFS)
+#define PP2_TX_PME_DPTR_OFFS			0
+#define PP2_TX_PME_DPTR_ALL_MASK		(0xffff << PP2_TX_PME_DPTR_OFFS)
+#define PP2_TX_PME_DPTR_MASK(val)		(((val) & PP2_TX_PME_DPTR_ALL_MASK) << PP2_TX_PME_DPTR_OFFS)
 
-#define PP2_TX_PME_IPTR_OFFS                    16
-#define PP2_TX_PME_IPTR_ALL_MASK                (0xff << PP2_TX_PME_IPTR_OFFS)
-#define PP2_TX_PME_IPTR_MASK(val)               (((val) & PP2_TX_PME_IPTR_ALL_MASK) << PP2_TX_PME_IPTR_OFFS)
+#define PP2_TX_PME_IPTR_OFFS			16
+#define PP2_TX_PME_IPTR_ALL_MASK		(0xff << PP2_TX_PME_IPTR_OFFS)
+#define PP2_TX_PME_IPTR_MASK(val)		(((val) & PP2_TX_PME_IPTR_ALL_MASK) << PP2_TX_PME_IPTR_OFFS)
 
 /* Bit 24 - HWF_IDB is for HWF usage only */
 
-#define PP2_TX_GEM_OEM_BIT                      25
-#define PP2_TX_GEM_OEM_MASK                     (1 << PP2_TX_GEM_OEM_BIT)
+#define PP2_TX_GEM_OEM_BIT			25
+#define PP2_TX_GEM_OEM_MASK			(1 << PP2_TX_GEM_OEM_BIT)
 
 /* Bit 26 - ERROR_SUM is for HWF usage only */
 
-#define PP2_TX_PON_FEC_BIT                      27
-#define PP2_TX_PON_FEC_MASK                     (1 << PP2_TX_PON_FEC_BIT)
+#define PP2_TX_PON_FEC_BIT			27
+#define PP2_TX_PON_FEC_MASK			(1 << PP2_TX_PON_FEC_BIT)
 
-#define PP2_TX_CPU_MAP_OFFS                     28
-#define PP2_TX_CPU_MAP_BITS                     4
-#define PP2_TX_CPU_MAP_MASK                     (((1 << PP2_TX_CPU_MAP_BITS) - 1) << PP2_TX_CPU_MAP_OFFS)
+#define PP2_TX_CPU_MAP_OFFS			28
+#define PP2_TX_CPU_MAP_BITS			4
+#define PP2_TX_CPU_MAP_MASK			(((1 << PP2_TX_CPU_MAP_BITS) - 1) << PP2_TX_CPU_MAP_OFFS)
 
 
 /************************** Buffer Header defines ******************************/
@@ -825,8 +962,12 @@ typedef struct pp2_buff_hdr {
 	MV_U32 nextBuffVirtAddr;
 	MV_U16 byteCount;
 	MV_U16 info;
+	MV_U8  bmQset;
 } PP2_BUFF_HDR;
 
+
+
+/* info bits */
 #define PP2_BUFF_HDR_INFO_MC_ID_OFFS		0
 #define PP2_BUFF_HDR_INFO_MC_ID_MASK		(0xfff << PP2_BUFF_HDR_INFO_MC_ID_OFFS)
 #define PP2_BUFF_HDR_INFO_MC_ID(info)		((info & PP2_BUFF_HDR_INFO_MC_ID_MASK) >> PP2_BUFF_HDR_INFO_MC_ID_OFFS)
@@ -835,35 +976,42 @@ typedef struct pp2_buff_hdr {
 #define PP2_BUFF_HDR_INFO_LAST_MASK		(0x1 << PP2_BUFF_HDR_INFO_LAST_OFFS)
 #define PP2_BUFF_HDR_INFO_IS_LAST(info)		((info & PP2_BUFF_HDR_INFO_LAST_MASK) >> PP2_BUFF_HDR_INFO_LAST_OFFS)
 
+/* bmQset bits */
+#define PP2_BUFF_HDR_BM_QSET_NUM_OFFS		0
+#define PP2_BUFF_HDR_BM_QSET_NUM_MASK		(0x7f << PP2_BUFF_HDR_BM_QSET_NUM_OFFS)
+
+#define PP2_BUFF_HDR_BM_QSET_TYPE_OFFS		7
+#define PP2_BUFF_HDR_BM_QSET_TYPE_MASK		(0x1 << PP2_BUFF_HDR_BM_QSET_TYPE_OFFS)
+
 /************************** Ethernet misc ******************************/
 
-#define ETH_MAX_DECODE_WIN              	6
-#define ETH_MAX_HIGH_ADDR_REMAP_WIN     	4
+#define ETH_MAX_DECODE_WIN			6
+#define ETH_MAX_HIGH_ADDR_REMAP_WIN		4
 
 /**** Address decode registers ****/
 
-#define ETH_WIN_BASE_REG(win)         		(MV_PP2_REG_BASE + 0x4000 + ((win) << 2))
-#define ETH_WIN_SIZE_REG(win)         		(MV_PP2_REG_BASE + 0x4020 + ((win) << 2))
-#define ETH_WIN_REMAP_REG(win)        		(MV_PP2_REG_BASE + 0x4040 + ((win) << 2))
-#define ETH_BASE_ADDR_ENABLE_REG      		(MV_PP2_REG_BASE + 0x4060)
+#define ETH_WIN_BASE_REG(win)			(MV_PP2_REG_BASE + 0x4000 + ((win) << 2))
+#define ETH_WIN_SIZE_REG(win)			(MV_PP2_REG_BASE + 0x4020 + ((win) << 2))
+#define ETH_WIN_REMAP_REG(win)			(MV_PP2_REG_BASE + 0x4040 + ((win) << 2))
+#define ETH_BASE_ADDR_ENABLE_REG		(MV_PP2_REG_BASE + 0x4060)
 
 /* The target associated with this window*/
-#define ETH_WIN_TARGET_OFFS                 	0
-#define ETH_WIN_TARGET_MASK                 	(0xf << ETH_WIN_TARGET_OFFS)
+#define ETH_WIN_TARGET_OFFS			0
+#define ETH_WIN_TARGET_MASK			(0xf << ETH_WIN_TARGET_OFFS)
 /* The target attributes associated with window */
-#define ETH_WIN_ATTR_OFFS                   	8
-#define ETH_WIN_ATTR_MASK                   	(0xff << ETH_WIN_ATTR_OFFS)
+#define ETH_WIN_ATTR_OFFS			8
+#define ETH_WIN_ATTR_MASK			(0xff << ETH_WIN_ATTR_OFFS)
 
 /* The Base address associated with window */
-#define ETH_WIN_BASE_OFFS		        16
-#define ETH_WIN_BASE_MASK		        (0xFFFF << ETH_WIN_BASE_OFFS)
+#define ETH_WIN_BASE_OFFS			16
+#define ETH_WIN_BASE_MASK			(0xFFFF << ETH_WIN_BASE_OFFS)
 
-#define ETH_WIN_SIZE_OFFS		        16
-#define ETH_WIN_SIZE_MASK		        (0xFFFF << ETH_WIN_SIZE_OFFS)
+#define ETH_WIN_SIZE_OFFS			16
+#define ETH_WIN_SIZE_MASK			(0xFFFF << ETH_WIN_SIZE_OFFS)
 /*-----------------------------------------------------------------------------------------------*/
 
-#define ETH_TARGET_DEF_ADDR_REG      		(MV_PP2_REG_BASE + 0x4064)
-#define ETH_TARGET_DEF_ID_REG      			(MV_PP2_REG_BASE + 0x4068)
+#define ETH_TARGET_DEF_ADDR_REG			(MV_PP2_REG_BASE + 0x4064)
+#define ETH_TARGET_DEF_ID_REG			(MV_PP2_REG_BASE + 0x4068)
 /*-----------------------------------------------------------------------------------------------*/
 
 #endif /* __MV_PP2_GBE_REGS_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
index 29f9aab..8157601 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
@@ -64,7 +64,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvEthGmacApi.h"
 #include "pp2/gbe/mvPp2Gbe.h"
 
-void mvEthPortEnable(int port)
+void mvGmacPortEnable(int port)
 {
 	MV_U32 regVal;
 
@@ -75,16 +75,16 @@ void mvEthPortEnable(int port)
 	MV_REG_WRITE(ETH_GMAC_CTRL_0_REG(port), regVal);
 }
 
-void mvEthPortDisable(int port)
+void mvGmacPortDisable(int port)
 {
 	MV_U32 regVal;
 
 	regVal = MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
-	regVal &= ~ETH_GMAC_PORT_EN_MASK;
+	regVal &= ~(ETH_GMAC_PORT_EN_MASK);
 	MV_REG_WRITE(ETH_GMAC_CTRL_0_REG(port), regVal);
 }
 
-void mvEthPortRgmiiSet(int port, int enable)
+static void mvGmacPortRgmiiSet(int port, int enable)
 {
 	MV_U32  regVal;
 
@@ -97,7 +97,7 @@ void mvEthPortRgmiiSet(int port, int enable)
 	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), regVal);
 }
 
-void mvEthPortSgmiiSet(int port, int enable)
+static void mvGmacPortSgmiiSet(int port, int enable)
 {
 	MV_U32 regVal;
 
@@ -111,7 +111,7 @@ void mvEthPortSgmiiSet(int port, int enable)
 	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), regVal);
 }
 
-void mvEthPortPeriodicXonSet(int port, int enable)
+void mvGmacPortPeriodicXonSet(int port, int enable)
 {
 	MV_U32 regVal;
 
@@ -125,7 +125,7 @@ void mvEthPortPeriodicXonSet(int port, int enable)
 	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), regVal);
 }
 
-void mvEthPortLbSet(int port, int isGmii, int isPcsEn)
+void mvGmacPortLbSet(int port, int isGmii, int isPcsEn)
 {
 	MV_U32 regVal;
 
@@ -144,7 +144,7 @@ void mvEthPortLbSet(int port, int isGmii, int isPcsEn)
 	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), regVal);
 }
 
-void mvEthPortResetSet(int port, MV_BOOL setReset)
+void mvGmacPortResetSet(int port, MV_BOOL setReset)
 {
 	MV_U32 regVal;
 
@@ -160,16 +160,15 @@ void mvEthPortResetSet(int port, MV_BOOL setReset)
 
 	if (setReset == MV_FALSE)
 		while (MV_REG_READ(ETH_GMAC_CTRL_2_REG(port) &
-		       ETH_GMAC_PORT_RESET_MASK))
-				;
+		       ETH_GMAC_PORT_RESET_MASK));
 }
 
-void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
+void mvGmacPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
 {
-	mvEthPortSgmiiSet(port, isSgmii);
-	mvEthPortRgmiiSet(port, isRgmii);
-	mvEthPortPeriodicXonSet(port, MV_FALSE);
-	mvEthPortResetSet(port, MV_FALSE);
+	mvGmacPortSgmiiSet(port, isSgmii);
+	mvGmacPortRgmiiSet(port, isRgmii);
+	mvGmacPortPeriodicXonSet(port, MV_FALSE);
+	mvGmacPortResetSet(port, MV_FALSE);
 }
 
 void mvGmacDefaultsSet(int port)
@@ -184,19 +183,22 @@ void mvGmacDefaultsSet(int port)
 	MV_REG_WRITE(GMAC_PORT_FIFO_CFG_1_REG(port), regVal);
 }
 
-void mvEthPortPowerDown(int port)
+void mvGmacPortPowerDown(int port)
 {
-	mvEthPortDisable(port);
-	mvEthMibCountersClear(port);
-	mvEthPortResetSet(port, MV_TRUE);
+	return;
+/*
+	mvGmacPortDisable(port);
+	mvGmacMibCountersClear(port);
+	mvGmacPortResetSet(port, MV_TRUE);
+*/
 }
 
-MV_BOOL mvEthPortIsLinkUp(int port)
+MV_BOOL mvGmacPortIsLinkUp(int port)
 {
 	return (MV_REG_READ(ETH_GMAC_STATUS_REG(port)) & ETH_GMAC_LINK_UP_MASK);
 }
 
-MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus)
+MV_STATUS mvGmacLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus)
 {
 	MV_U32 regVal;
 
@@ -245,7 +247,7 @@ MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus)
 	return MV_OK;
 }
 
-char *mvEthSpeedStrGet(MV_ETH_PORT_SPEED speed)
+char *mvGmacSpeedStrGet(MV_ETH_PORT_SPEED speed)
 {
 	char *str;
 
@@ -286,21 +288,22 @@ char *mvEthSpeedStrGet(MV_ETH_PORT_SPEED speed)
 *
 * RETURN:
 *******************************************************************************/
-void mvEthMaxRxSizeSet(int port, int maxRxSize)
+MV_STATUS mvGmacMaxRxSizeSet(int port, int maxRxSize)
 {
 	MV_U32		regVal;
 
 	if (MV_PON_PORT(port))
-		return;
+		return MV_ERROR;
 
 	regVal =  MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
 	regVal &= ~ETH_GMAC_MAX_RX_SIZE_MASK;
 	regVal |= (((maxRxSize - MV_ETH_MH_SIZE) / 2) << ETH_GMAC_MAX_RX_SIZE_OFFS);
 	MV_REG_WRITE(ETH_GMAC_CTRL_0_REG(port), regVal);
+	return MV_OK;
 }
 
 /*******************************************************************************
-* mvEthForceLinkModeSet -
+* mvGmacForceLinkModeSet -
 *
 * DESCRIPTION:
 *       Sets "Force Link Pass" and "Do Not Force Link Fail" bits.
@@ -315,12 +318,12 @@ void mvEthMaxRxSizeSet(int port, int maxRxSize)
 *
 * RETURN:
 *******************************************************************************/
-MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down)
+MV_STATUS mvGmacForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down)
 {
 	MV_U32 regVal;
 
 	/* Can't force link pass and link fail at the same time */
-	if (force_link_up && force_link_down)
+	if ((force_link_up) && (force_link_down))
 		return MV_BAD_PARAM;
 
 	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
@@ -341,7 +344,7 @@ MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force
 }
 
 /*******************************************************************************
-* mvEthSpeedDuplexSet -
+* mvGmacSpeedDuplexSet -
 *
 * DESCRIPTION:
 *       Sets port speed to Auto Negotiation / 1000 / 100 / 10 Mbps.
@@ -354,12 +357,12 @@ MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force
 *
 * RETURN:
 *******************************************************************************/
-MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex)
+MV_STATUS mvGmacSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex)
 {
 	MV_U32 regVal;
 
 	/* Check validity */
-	if (speed == MV_ETH_SPEED_1000 && duplex == MV_ETH_DUPLEX_HALF)
+	if ((speed == MV_ETH_SPEED_1000) && (duplex == MV_ETH_DUPLEX_HALF))
 		return MV_BAD_PARAM;
 
 	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
@@ -412,7 +415,7 @@ MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_D
 }
 
 /*******************************************************************************
-* mvEthSpeedDuplexGet -
+* mvGmacSpeedDuplexGet -
 *
 * DESCRIPTION:
 *       Gets port speed
@@ -426,7 +429,7 @@ MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_D
 *
 * RETURN:
 *******************************************************************************/
-MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex)
+MV_STATUS mvGmacSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex)
 {
 	MV_U32 regVal;
 
@@ -455,7 +458,7 @@ MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_
 }
 
 /*******************************************************************************
-* mvEthFlowCtrlSet - Set Flow Control of the port.
+* mvGmacFlowCtrlSet - Set Flow Control of the port.
 *
 * DESCRIPTION:
 *       This function configures the port's Flow Control properties.
@@ -470,7 +473,7 @@ MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_
 *       MV_BAD_VALUE    - Value flowControl parameters is not valid
 *
 *******************************************************************************/
-MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl)
+MV_STATUS mvGmacFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl)
 {
 	MV_U32 regVal;
 
@@ -516,7 +519,7 @@ MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl)
 }
 
 /*******************************************************************************
-* mvEthFlowCtrlGet - Get Flow Control configuration of the port.
+* mvGmacFlowCtrlGet - Get Flow Control configuration of the port.
 *
 * DESCRIPTION:
 *       This function returns the port's Flow Control properties.
@@ -532,7 +535,7 @@ MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl)
 *       MV_OUT_OF_RANGE - Failed. Port is out of valid range
 *
 *******************************************************************************/
-MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl)
+MV_STATUS mvGmacFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl)
 {
 	MV_U32 regVal;
 
@@ -557,33 +560,33 @@ MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl)
 	return MV_OK;
 }
 
-MV_STATUS mvEthPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
+MV_STATUS mvGmacPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
 				     int forceLinkUp)
 {
 	if (forceLinkUp) {
-		if (mvEthSpeedDuplexSet(port, speed, MV_ETH_DUPLEX_FULL)) {
-			mvOsPrintf("mvEthSpeedDuplexSet failed\n");
+		if (mvGmacSpeedDuplexSet(port, speed, MV_ETH_DUPLEX_FULL)) {
+			mvOsPrintf("mvGmacSpeedDuplexSet failed\n");
 			return MV_FAIL;
 		}
-		if (mvEthFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
-			mvOsPrintf("mvEthFlowCtrlSet failed\n");
+		if (mvGmacFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
+			mvOsPrintf("mvGmacFlowCtrlSet failed\n");
 			return MV_FAIL;
 		}
-		if (mvEthForceLinkModeSet(port, 1, 0)) {
-			mvOsPrintf("mvEthForceLinkModeSet failed\n");
+		if (mvGmacForceLinkModeSet(port, 1, 0)) {
+			mvOsPrintf("mvGmacForceLinkModeSet failed\n");
 			return MV_FAIL;
 		}
 	} else {
-		if (mvEthForceLinkModeSet(port, 0, 0)) {
-			mvOsPrintf("mvEthForceLinkModeSet failed\n");
+		if (mvGmacForceLinkModeSet(port, 0, 0)) {
+			mvOsPrintf("mvGmacForceLinkModeSet failed\n");
 			return MV_FAIL;
 		}
-		if (mvEthSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
-			mvOsPrintf("mvEthSpeedDuplexSet failed\n");
+		if (mvGmacSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
+			mvOsPrintf("mvGmacSpeedDuplexSet failed\n");
 			return MV_FAIL;
 		}
-		if (mvEthFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
-			mvOsPrintf("mvEthFlowCtrlSet failed\n");
+		if (mvGmacFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
+			mvOsPrintf("mvGmacFlowCtrlSet failed\n");
 			return MV_FAIL;
 		}
 	}
@@ -594,7 +597,7 @@ MV_STATUS mvEthPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
 /******************************************************************************/
 /*                         PHY Control Functions                              */
 /******************************************************************************/
-void mvEthPhyAddrSet(int port, int phyAddr)
+void mvGmacPhyAddrSet(int port, int phyAddr)
 {
 	unsigned int regData;
 
@@ -608,7 +611,7 @@ void mvEthPhyAddrSet(int port, int phyAddr)
 	return;
 }
 
-int mvEthPhyAddrGet(int port)
+int mvGmacPhyAddrGet(int port)
 {
 	unsigned int 	regData;
 
@@ -664,7 +667,7 @@ void mvGmacPortRegs(int port)
 /******************************************************************************/
 
 /*******************************************************************************
-* mvEthMibCounterRead - Read a MIB counter
+* mvGmacMibCounterRead - Read a MIB counter
 *
 * DESCRIPTION:
 *       This function reads a MIB counter of a specific ethernet port.
@@ -684,7 +687,7 @@ void mvGmacPortRegs(int port)
 *       32 low sgnificant bits of MIB counter value.
 *
 *******************************************************************************/
-MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
+MV_U32 mvGmacMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
 {
 	MV_U32 valLow32, valHigh32;
 
@@ -701,7 +704,7 @@ MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
 }
 
 /*******************************************************************************
-* mvEthMibCountersClear - Clear all MIB counters
+* mvGmacMibCountersClear - Clear all MIB counters
 *
 * DESCRIPTION:
 *       This function clears all MIB counters
@@ -712,7 +715,7 @@ MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
 * RETURN:   void
 *
 *******************************************************************************/
-void mvEthMibCountersClear(int port)
+void mvGmacMibCountersClear(int port)
 {
 	int i;
 
@@ -725,11 +728,11 @@ void mvEthMibCountersClear(int port)
 		MV_REG_READ((ETH_MIB_COUNTERS_BASE(port) + i));
 }
 
-static void mvEthMibPrint(int port, MV_U32 offset, char *mib_name)
+static void mvGmacMibPrint(int port, MV_U32 offset, char *mib_name)
 {
 	MV_U32 regVaLo, regValHi = 0;
 
-	regVaLo = mvEthMibCounterRead(port, offset, &regValHi);
+	regVaLo = mvGmacMibCounterRead(port, offset, &regValHi);
 
 	if (!regValHi)
 		mvOsPrintf("  %-32s: 0x%02x = %u\n", mib_name, offset, regVaLo);
@@ -738,7 +741,7 @@ static void mvEthMibPrint(int port, MV_U32 offset, char *mib_name)
 }
 
 /* Print MIB counters of the Ethernet port */
-void mvEthMibCountersShow(int port)
+void mvGmacMibCountersShow(int port)
 {
 	if (mvPp2PortCheck(port))
 		return;
@@ -751,40 +754,40 @@ void mvEthMibCountersShow(int port)
 	mvOsPrintf("\nMIBs: port=%d, base=0x%x\n", port, ETH_MIB_COUNTERS_BASE(port));
 
 	mvOsPrintf("\n[Rx]\n");
-	mvEthMibPrint(port, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW, "GOOD_OCTETS_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_BAD_OCTETS_RECEIVED, "BAD_OCTETS_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_UNICAST_FRAMES_RECEIVED, "UNCAST_FRAMES_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_BROADCAST_FRAMES_RECEIVED, "BROADCAST_FRAMES_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_MULTICAST_FRAMES_RECEIVED, "MULTICAST_FRAMES_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW, "GOOD_OCTETS_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_BAD_OCTETS_RECEIVED, "BAD_OCTETS_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_UNICAST_FRAMES_RECEIVED, "UNCAST_FRAMES_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_BROADCAST_FRAMES_RECEIVED, "BROADCAST_FRAMES_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_MULTICAST_FRAMES_RECEIVED, "MULTICAST_FRAMES_RECEIVED");
 
 	mvOsPrintf("\n[RMON]\n");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_64_OCTETS, "FRAMES_64_OCTETS");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_65_TO_127_OCTETS, "FRAMES_65_TO_127_OCTETS");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_128_TO_255_OCTETS, "FRAMES_128_TO_255_OCTETS");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_256_TO_511_OCTETS, "FRAMES_256_TO_511_OCTETS");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_512_TO_1023_OCTETS, "FRAMES_512_TO_1023_OCTETS");
-	mvEthMibPrint(port, ETH_MIB_FRAMES_1024_TO_MAX_OCTETS, "FRAMES_1024_TO_MAX_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_64_OCTETS, "FRAMES_64_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_65_TO_127_OCTETS, "FRAMES_65_TO_127_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_128_TO_255_OCTETS, "FRAMES_128_TO_255_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_256_TO_511_OCTETS, "FRAMES_256_TO_511_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_512_TO_1023_OCTETS, "FRAMES_512_TO_1023_OCTETS");
+	mvGmacMibPrint(port, ETH_MIB_FRAMES_1024_TO_MAX_OCTETS, "FRAMES_1024_TO_MAX_OCTETS");
 
 	mvOsPrintf("\n[Tx]\n");
-	mvEthMibPrint(port, ETH_MIB_GOOD_OCTETS_SENT_LOW, "GOOD_OCTETS_SENT");
-	mvEthMibPrint(port, ETH_MIB_UNICAST_FRAMES_SENT, "UNICAST_FRAMES_SENT");
-	mvEthMibPrint(port, ETH_MIB_MULTICAST_FRAMES_SENT, "MULTICAST_FRAMES_SENT");
-	mvEthMibPrint(port, ETH_MIB_BROADCAST_FRAMES_SENT, "BROADCAST_FRAMES_SENT");
-	mvEthMibPrint(port, ETH_MIB_CRC_ERRORS_SENT, "CRC_ERRORS_SENT");
+	mvGmacMibPrint(port, ETH_MIB_GOOD_OCTETS_SENT_LOW, "GOOD_OCTETS_SENT");
+	mvGmacMibPrint(port, ETH_MIB_UNICAST_FRAMES_SENT, "UNICAST_FRAMES_SENT");
+	mvGmacMibPrint(port, ETH_MIB_MULTICAST_FRAMES_SENT, "MULTICAST_FRAMES_SENT");
+	mvGmacMibPrint(port, ETH_MIB_BROADCAST_FRAMES_SENT, "BROADCAST_FRAMES_SENT");
+	mvGmacMibPrint(port, ETH_MIB_CRC_ERRORS_SENT, "CRC_ERRORS_SENT");
 
 	mvOsPrintf("\n[FC control]\n");
-	mvEthMibPrint(port, ETH_MIB_FC_RECEIVED, "FC_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_FC_SENT, "FC_SENT");
+	mvGmacMibPrint(port, ETH_MIB_FC_RECEIVED, "FC_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_FC_SENT, "FC_SENT");
 
 	mvOsPrintf("\n[Errors]\n");
-	mvEthMibPrint(port, ETH_MIB_RX_FIFO_OVERRUN, "ETH_MIB_RX_FIFO_OVERRUN");
-	mvEthMibPrint(port, ETH_MIB_UNDERSIZE_RECEIVED, "UNDERSIZE_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_FRAGMENTS_RECEIVED, "FRAGMENTS_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_OVERSIZE_RECEIVED, "OVERSIZE_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_JABBER_RECEIVED, "JABBER_RECEIVED");
-	mvEthMibPrint(port, ETH_MIB_MAC_RECEIVE_ERROR, "MAC_RECEIVE_ERROR");
-	mvEthMibPrint(port, ETH_MIB_BAD_CRC_EVENT, "BAD_CRC_EVENT");
-	mvEthMibPrint(port, ETH_MIB_COLLISION, "COLLISION");
+	mvGmacMibPrint(port, ETH_MIB_RX_FIFO_OVERRUN, "ETH_MIB_RX_FIFO_OVERRUN");
+	mvGmacMibPrint(port, ETH_MIB_UNDERSIZE_RECEIVED, "UNDERSIZE_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_FRAGMENTS_RECEIVED, "FRAGMENTS_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_OVERSIZE_RECEIVED, "OVERSIZE_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_JABBER_RECEIVED, "JABBER_RECEIVED");
+	mvGmacMibPrint(port, ETH_MIB_MAC_RECEIVE_ERROR, "MAC_RECEIVE_ERROR");
+	mvGmacMibPrint(port, ETH_MIB_BAD_CRC_EVENT, "BAD_CRC_EVENT");
+	mvGmacMibPrint(port, ETH_MIB_COLLISION, "COLLISION");
 	/* This counter must be read last. Read it clear all the counters */
-	mvEthMibPrint(port, ETH_MIB_LATE_COLLISION, "LATE_COLLISION");
+	mvGmacMibPrint(port, ETH_MIB_LATE_COLLISION, "LATE_COLLISION");
 }
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
index 44021c6..f296e07 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
@@ -106,76 +106,74 @@ typedef struct eth_link_status {
 /***************************************************************************/
 /*                          Inline functions                               */
 /***************************************************************************/
-static INLINE void mvEthIsrSummaryMask(MV_VOID)
+static INLINE void mvGmacIsrSummaryMask(MV_VOID)
 {
 	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, 0);
 }
 
-static INLINE void mvEthIsrSummaryUnmask(MV_VOID)
+static INLINE void mvGmacIsrSummaryUnmask(MV_VOID)
 {
 	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, ETH_ISR_SUM_PORT0_MASK |
 		     ETH_ISR_SUM_PORT1_MASK | 0x20 /* magic bit */);
 }
 
-static INLINE MV_U32 mvEthIsrSummaryCauseGet(MV_VOID)
+static INLINE MV_U32 mvGmacIsrSummaryCauseGet(MV_VOID)
 {
 	return MV_REG_READ(ETH_ISR_SUM_CAUSE_REG);
 }
 
-static INLINE MV_U32 mvEthPortIsrCauseGet(int port)
+static INLINE MV_U32 mvGmacPortIsrCauseGet(int port)
 {
 	return MV_REG_READ(ETH_PORT_ISR_CAUSE_REG(port));
 }
 
-static INLINE MV_VOID mvEthPortIsrMask(int port)
+static INLINE MV_VOID mvGmacPortIsrMask(int port)
 {
 	MV_REG_WRITE(ETH_PORT_ISR_MASK_REG(port), 0);
 }
 
-static INLINE MV_VOID mvEthPortIsrUnmask(int port)
+static INLINE MV_VOID mvGmacPortIsrUnmask(int port)
 {
 	MV_REG_WRITE(ETH_PORT_ISR_MASK_REG(port), ETH_PORT_LINK_CHANGE_MASK);
 }
 
 void mvGmacDefaultsSet(int port);
-void mvEthPortEnable(int port);
-void mvEthPortDisable(int port);
-void mvEthPortRgmiiSet(int port, int enable);
-void mvEthPortSgmiiSet(int port, int enable);
-void mvEthPortPeriodicXonSet(int port, int enable);
-MV_BOOL mvEthPortIsLinkUp(int port);
-MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus);
-void mvEthPortLbSet(int port, int isGmii, int isPcsEn);
-void mvEthPortResetSet(int port, MV_BOOL setReset);
-void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii);
-void mvEthPortPowerDown(int port);
-char *mvEthSpeedStrGet(MV_ETH_PORT_SPEED speed);
+void mvGmacPortEnable(int port);
+void mvGmacPortDisable(int port);
+void mvGmacPortPeriodicXonSet(int port, int enable);
+MV_BOOL mvGmacPortIsLinkUp(int port);
+MV_STATUS mvGmacLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus);
+void mvGmacPortLbSet(int port, int isGmii, int isPcsEn);
+void mvGmacPortResetSet(int port, MV_BOOL setReset);
+void mvGmacPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii);
+void mvGmacPortPowerDown(int port);
+char *mvGmacSpeedStrGet(MV_ETH_PORT_SPEED speed);
 
 /******************************************************************************/
 /*                          Port Configuration functions                      */
 /******************************************************************************/
-void mvEthMaxRxSizeSet(int port, int maxRxSize);
-MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down);
-MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex);
-MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex);
-MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl);
-MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl);
-MV_STATUS mvEthPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
+MV_STATUS mvGmacMaxRxSizeSet(int port, int maxRxSize);
+MV_STATUS mvGmacForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down);
+MV_STATUS mvGmacSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex);
+MV_STATUS mvGmacSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex);
+MV_STATUS mvGmacFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl);
+MV_STATUS mvGmacFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl);
+MV_STATUS mvGmacPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
 				     int forceLinkUp);
 
 /******************************************************************************/
 /*                         PHY Control Functions                              */
 /******************************************************************************/
-void mvEthPhyAddrSet(int port, int phyAddr);
-int mvEthPhyAddrGet(int port);
+void mvGmacPhyAddrSet(int port, int phyAddr);
+int mvGmacPhyAddrGet(int port);
 
 /****************************************/
 /*        MIB counters		       	*/
 /****************************************/
-MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32);
-void mvEthMibCountersClear(int port);
-void mvEthMibCountersShow(int port);
+MV_U32 mvGmacMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32);
+void mvGmacMibCountersClear(int port);
+void mvGmacMibCountersShow(int port);
 void mvGmacPortRegs(int port);
 void mvGmacLmsRegs(void);
 
-#endif /* __mvEthGmac_h__ */
+#endif /* __mvGmacGmac_h__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
index cfd615d..0b2a3e3 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
@@ -79,10 +79,14 @@ void        mvPp2PlcrHwRegs(void)
 
 	mvOsPrintf("\n[PLCR registers: %d policers]\n", MV_PP2_PLCR_NUM);
 
-	mvPp2PrintReg(MV_PP2_PLCR_ENABLE_REG,      "MV_PP2_PLCR_ENABLE_REG");
-	mvPp2PrintReg(MV_PP2_PLCR_BASE_PERIOD_REG, "MV_PP2_PLCR_BASE_PERIOD_REG");
-	mvPp2PrintReg(MV_PP2_PLCR_MIN_PKT_LEN_REG,   "MV_PP2_PLCR_MIN_PKT_LEN_REG");
-	mvPp2PrintReg(MV_PP2_PLCR_EDROP_EN_REG,      "MV_PP2_PLCR_EDROP_EN_REG");
+#ifdef CONFIG_MV_ETH_PP2_1
+	mvPp2PrintReg(MV_PP2_PLCR_MODE_REG,	"MV_PP2_PLCR_MODE_REG");
+#else
+	mvPp2PrintReg(MV_PP2_PLCR_ENABLE_REG,	"MV_PP2_PLCR_ENABLE_REG");
+#endif
+	mvPp2PrintReg(MV_PP2_PLCR_BASE_PERIOD_REG,	"MV_PP2_PLCR_BASE_PERIOD_REG");
+	mvPp2PrintReg(MV_PP2_PLCR_MIN_PKT_LEN_REG,	"MV_PP2_PLCR_MIN_PKT_LEN_REG");
+	mvPp2PrintReg(MV_PP2_PLCR_EDROP_EN_REG,		"MV_PP2_PLCR_EDROP_EN_REG");
 
 	for (i = 0; i < MV_PP2_PLCR_NUM; i++) {
 		mvOsPrintf("\n[Policer %d registers]\n", i);
@@ -95,10 +99,18 @@ void        mvPp2PlcrHwRegs(void)
 	}
 
 	mvOsPrintf("\nEarly Drop Thresholds for SW and HW forwarding\n");
-	for (i = 0; i < MV_PP2_PLCR_EDROP_THRESH_NUM; i += 2) {
-		mvPp2PrintReg2(MV_PP2_PLCR_EDROP_CPU_TR_REG(i),   "MV_PP2_PLCR_EDROP_CPU_TR_REG", i);
-		mvPp2PrintReg2(MV_PP2_PLCR_EDROP_HWF_TR_REG(i),   "MV_PP2_PLCR_EDROP_HWF_TR_REG", i);
+#ifdef CONFIG_MV_ETH_PP2_1
+	for (i = 0; i < MV_PP2_V1_PLCR_EDROP_THRESH_NUM; i++) {
+		mvPp2PrintReg2(MV_PP2_V1_PLCR_EDROP_CPU_TR_REG(i),   "MV_PP2_V1_PLCR_EDROP_CPU_TR_REG", i);
+		mvPp2PrintReg2(MV_PP2_V1_PLCR_EDROP_HWF_TR_REG(i),   "MV_PP2_V1_PLCR_EDROP_HWF_TR_REG", i);
 	}
+#else
+
+	for (i = 0; i < MV_PP2_V0_PLCR_EDROP_THRESH_NUM; i++) {
+		mvPp2PrintReg2(MV_PP2_V0_PLCR_EDROP_CPU_TR_REG(i),   "MV_PP2_V0_PLCR_EDROP_CPU_TR_REG", i);
+		mvPp2PrintReg2(MV_PP2_V0_PLCR_EDROP_HWF_TR_REG(i),   "MV_PP2_V0_PLCR_EDROP_HWF_TR_REG", i);
+	}
+#endif
 	mvOsPrintf("\nPer RXQ: Non zero early drop thresholds\n");
 	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
 		mvPp2WrReg(MV_PP2_PLCR_EDROP_RXQ_REG, i);
@@ -135,25 +147,32 @@ static void        mvPp2PlcrHwDumpTitle(void)
 
 static void        mvPp2PlcrHwDump(int plcr)
 {
-	int units, type, tokens, color;
+	int units, type, tokens, color, enable;
 	MV_U32 regVal;
 
 	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
 	mvOsPrintf("%3d:  ", plcr);
-	regVal = mvPp2RdReg(MV_PP2_PLCR_ENABLE_REG);
-	mvOsPrintf("%4s", MV_BIT_CHECK(regVal, plcr) ? "Yes" : "No");
 
-	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
-	mvOsPrintf("  %6d", regVal & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK);
+#ifndef CONFIG_MV_ETH_PP2_1
+	enable = mvPp2RdReg(MV_PP2_PLCR_ENABLE_REG);
+	mvOsPrintf("%4s", MV_BIT_CHECK(enable, plcr) ? "Yes" : "No");
+#endif
 
 	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
 	units = regVal & MV_PP2_PLCR_TOKEN_UNIT_MASK;
 	color = regVal & MV_PP2_PLCR_COLOR_MODE_MASK;
 	type = (regVal & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_TYPE_OFFS;
 	tokens =  (regVal & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_VALUE_OFFS;
+#ifdef CONFIG_MV_ETH_PP2_1
+	enable = regVal & MV_PP2_PLCR_ENABLE_MASK;
+	mvOsPrintf("%4s", enable ? "Yes" : "No");
+#endif
 	mvOsPrintf("   %-5s  %2d   %5d", units ? "pkts" : "bytes", type, tokens);
 	mvOsPrintf("  %-5s", color ? "aware" : "blind");
 
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
+	mvOsPrintf("  %6d", regVal & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK);
+
 	regVal = mvPp2RdReg(MV_PP2_PLCR_BUCKET_SIZE_REG);
 	mvOsPrintf("    %04x    %04x",
 			(regVal & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK) >> MV_PP2_PLCR_COMMIT_SIZE_OFFS,
@@ -210,17 +229,25 @@ MV_STATUS   mvPp2PlcrHwBasePeriodSet(int period)
 	return MV_OK;
 }
 
+MV_STATUS   mvPp2PlcrHwMode(int mode)
+{
+	mvPp2WrReg(MV_PP2_PLCR_MODE_REG, mode);
+	return MV_OK;
+}
+
 MV_STATUS   mvPp2PlcrHwEnable(int plcr, int enable)
 {
 	MV_U32 regVal;
 
-	regVal = mvPp2RdReg(MV_PP2_PLCR_ENABLE_REG);
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
 	if (enable)
-		regVal |= MV_PP2_PLCR_EN_MASK(plcr);
+		regVal |= MV_PP2_PLCR_ENABLE_MASK;
 	else
-		regVal &= ~MV_PP2_PLCR_EN_MASK(plcr);
+		regVal &= ~MV_PP2_PLCR_ENABLE_MASK;
 
-	mvPp2WrReg(MV_PP2_PLCR_ENABLE_REG, regVal);
+	mvPp2WrReg(MV_PP2_PLCR_TOKEN_CFG_REG, regVal);
 
 	return MV_OK;
 }
@@ -312,27 +339,43 @@ MV_STATUS   mvPp2PlcrHwBucketSizeSet(int plcr, int commit, int excess)
 
 	return MV_OK;
 }
-
-MV_STATUS   mvPp2PlcrHwCpuThreshSet(int idx, int threshold)
+/*ppv2.1 policer early drop threshold mechanism changed*/
+MV_STATUS   mvPp2V0PlcrHwCpuThreshSet(int idx, int threshold)
 {
 	MV_U32 regVal;
 
-	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_CPU_TR_REG(idx));
-	regVal &= ~MV_PP2_PLCR_EDROP_TR_ALL_MASK(idx);
-	regVal |= MV_PP2_PLCR_EDROP_TR_MASK(idx, threshold);
-	mvPp2WrReg(MV_PP2_PLCR_EDROP_CPU_TR_REG(idx), regVal);
+	regVal = mvPp2RdReg(MV_PP2_V0_PLCR_EDROP_CPU_TR_REG(idx));
+	regVal &= ~MV_PP2_V0_PLCR_EDROP_TR_ALL_MASK(idx);
+	regVal |= MV_PP2_V0_PLCR_EDROP_TR_MASK(idx, threshold);
+	mvPp2WrReg(MV_PP2_V0_PLCR_EDROP_CPU_TR_REG(idx), regVal);
 
 	return MV_OK;
 }
+/*ppv2.1 policer early drop threshold mechanism changed*/
+MV_STATUS   mvPp2V1PlcrHwCpuThreshSet(int idx, int threshold)
+{
+	mvPp2WrReg(MV_PP2_V1_PLCR_EDROP_CPU_TR_REG(idx), threshold);
 
-MV_STATUS   mvPp2PlcrHwHwfThreshSet(int idx, int threshold)
+	return MV_OK;
+}
+
+/*ppv2.1 policer early drop threshold mechanism changed*/
+MV_STATUS   mvPp2V0PlcrHwHwfThreshSet(int idx, int threshold)
 {
 	MV_U32 regVal;
 
-	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_HWF_TR_REG(idx));
-	regVal &= ~MV_PP2_PLCR_EDROP_TR_ALL_MASK(idx);
-	regVal |= MV_PP2_PLCR_EDROP_TR_MASK(idx, threshold);
-	mvPp2WrReg(MV_PP2_PLCR_EDROP_HWF_TR_REG(idx), regVal);
+	regVal = mvPp2RdReg(MV_PP2_V0_PLCR_EDROP_HWF_TR_REG(idx));
+	regVal &= ~MV_PP2_V0_PLCR_EDROP_TR_ALL_MASK(idx);
+	regVal |= MV_PP2_V0_PLCR_EDROP_TR_MASK(idx, threshold);
+	mvPp2WrReg(MV_PP2_V0_PLCR_EDROP_HWF_TR_REG(idx), regVal);
+
+	return MV_OK;
+}
+
+/*ppv2.1 policer early drop threshold mechanism changed*/
+MV_STATUS   mvPp2V1PlcrHwHwfThreshSet(int idx, int threshold)
+{
+	mvPp2WrReg(MV_PP2_V1_PLCR_EDROP_HWF_TR_REG(idx), threshold);
 
 	return MV_OK;
 }
@@ -352,3 +395,11 @@ MV_STATUS   mvPp2PlcrHwTxqThreshSet(int txq, int idx)
 
 	return MV_OK;
 }
+
+void mvPp2V1PlcrTbCntDump(int plcr)
+{
+	mvPp2PrintReg2(MV_PP2_V1_PLCR_PKT_GREEN_REG(plcr), "MV_PP2_V1_PLCR_PKT_GREEN_REG", plcr);
+	mvPp2PrintReg2(MV_PP2_V1_PLCR_PKT_YELLOW_REG(plcr), "MV_PP2_V1_PLCR_PKT_YELLOW_REG", plcr);
+	mvPp2PrintReg2(MV_PP2_V1_PLCR_PKT_RED_REG(plcr), "MV_PP2_V1_PLCR_PKT_RED_REG", plcr);
+
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
index 0d31a3a..3bd6536 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
@@ -69,27 +69,40 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 extern "C" {
 #endif /* __cplusplus */
 
+
+#ifdef CONFIG_MV_ETH_PP2_1
+#define MV_PP2_PLCR_NUM		48
+#else
 #define MV_PP2_PLCR_NUM		16
+#endif
 
 /*********************************** RX Policer Registers *******************/
-#define MV_PP2_PLCR_ENABLE_REG                  (MV_PP2_REG_BASE + 0x1300)
+/* exist only in ppv2.0 */
+#define MV_PP2_PLCR_ENABLE_REG			(MV_PP2_REG_BASE + 0x1300)
 
-#define MV_PP2_PLCR_EN_OFFS                     0
-#define MV_PP2_PLCR_EN_ALL_MASK                 (((1 << MV_PP2_PLCR_NUM) - 1) << MV_PP2_PLCR_EN_OFFS)
-#define MV_PP2_PLCR_EN_MASK(plcr)               ((1 << (plcr)) << MV_PP2_PLCR_EN_OFFS)
+#define MV_PP2_PLCR_EN_OFFS			0
+#define MV_PP2_PLCR_EN_ALL_MASK			(((1 << MV_PP2_PLCR_NUM) - 1) << MV_PP2_PLCR_EN_OFFS)
+#define MV_PP2_PLCR_EN_MASK(plcr)		((1 << (plcr)) << MV_PP2_PLCR_EN_OFFS)
 /*---------------------------------------------------------------------------------------------*/
 
-#define MV_PP2_PLCR_BASE_PERIOD_REG             (MV_PP2_REG_BASE + 0x1304)
+#define MV_PP2_PLCR_BASE_PERIOD_REG		(MV_PP2_REG_BASE + 0x1304)
 
-#define MV_PP2_PLCR_BASE_PERIOD_OFFS            0
-#define MV_PP2_PLCR_BASE_PERIOD_BITS            16
-#define MV_PP2_PLCR_BASE_PERIOD_ALL_MASK        (((1 << MV_PP2_PLCR_BASE_PERIOD_BITS) - 1) << MV_PP2_PLCR_BASE_PERIOD_OFFS)
-#define MV_PP2_PLCR_BASE_PERIOD_MASK(p)         (((p) << MV_PP2_PLCR_BASE_PERIOD_OFFS) & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK)
+#define MV_PP2_PLCR_BASE_PERIOD_OFFS		0
+#define MV_PP2_PLCR_BASE_PERIOD_BITS		16
+#define MV_PP2_PLCR_BASE_PERIOD_ALL_MASK	\
+		(((1 << MV_PP2_PLCR_BASE_PERIOD_BITS) - 1) << MV_PP2_PLCR_BASE_PERIOD_OFFS)
+#define MV_PP2_PLCR_BASE_PERIOD_MASK(p)		\
+		(((p) << MV_PP2_PLCR_BASE_PERIOD_OFFS) & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK)
 
-#define MV_PP2_PLCR_ADD_TOKENS_EN_BIT           16
-#define MV_PP2_PLCR_ADD_TOKENS_EN_MASK          (1 << MV_PP2_PLCR_ADD_TOKENS_EN_BIT)
+#define MV_PP2_PLCR_ADD_TOKENS_EN_BIT		16
+#define MV_PP2_PLCR_ADD_TOKENS_EN_MASK		(1 << MV_PP2_PLCR_ADD_TOKENS_EN_BIT)
 /*---------------------------------------------------------------------------------------------*/
+#define MV_PP2_PLCR_MODE_REG			(MV_PP2_REG_BASE + 0x1308)
+#define MV_PP2_PLCR_MODE_BITS			(3)
+#define MV_PP2_PLCR_MODE_MASK			(((1 << MV_PP2_PLCR_MODE_BITS) - 1) << 0)
 
+/*---------------------------------------------------------------------------------------------*/
+/* exist only in ppv2.1*/
 #define MV_PP2_PLCR_TABLE_INDEX_REG		(MV_PP2_REG_BASE + 0x130c)
 #define MV_PP2_PLCR_COMMIT_TOKENS_REG		(MV_PP2_REG_BASE + 0x1310)
 #define MV_PP2_PLCR_EXCESS_TOKENS_REG		(MV_PP2_REG_BASE + 0x1314)
@@ -99,26 +112,34 @@ extern "C" {
 
 #define MV_PP2_PLCR_COMMIT_SIZE_OFFS		0
 #define MV_PP2_PLCR_COMMIT_SIZE_BITS		16
-#define MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_COMMIT_SIZE_BITS) - 1) << MV_PP2_PLCR_COMMIT_SIZE_OFFS)
-#define MV_PP2_PLCR_COMMIT_SIZE_MASK(size)      (((size) << MV_PP2_PLCR_COMMIT_SIZE_OFFS) & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK)
+#define MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK	\
+		(((1 << MV_PP2_PLCR_COMMIT_SIZE_BITS) - 1) << MV_PP2_PLCR_COMMIT_SIZE_OFFS)
+#define MV_PP2_PLCR_COMMIT_SIZE_MASK(size)	\
+		(((size) << MV_PP2_PLCR_COMMIT_SIZE_OFFS) & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK)
 
 #define MV_PP2_PLCR_EXCESS_SIZE_OFFS		16
 #define MV_PP2_PLCR_EXCESS_SIZE_BITS		16
-#define MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_EXCESS_SIZE_BITS) - 1) << MV_PP2_PLCR_EXCESS_SIZE_OFFS)
-#define MV_PP2_PLCR_EXCESS_SIZE_MASK(size)      (((size) << MV_PP2_PLCR_EXCESS_SIZE_OFFS) & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK)
+#define MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK	\
+		(((1 << MV_PP2_PLCR_EXCESS_SIZE_BITS) - 1) << MV_PP2_PLCR_EXCESS_SIZE_OFFS)
+#define MV_PP2_PLCR_EXCESS_SIZE_MASK(size)	\
+		(((size) << MV_PP2_PLCR_EXCESS_SIZE_OFFS) & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK)
 /*---------------------------------------------------------------------------------------------*/
 
 #define MV_PP2_PLCR_TOKEN_CFG_REG		(MV_PP2_REG_BASE + 0x131c)
 
 #define MV_PP2_PLCR_TOKEN_VALUE_OFFS		0
 #define MV_PP2_PLCR_TOKEN_VALUE_BITS		10
-#define MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK	(((1 << MV_PP2_PLCR_TOKEN_VALUE_BITS) - 1) << MV_PP2_PLCR_TOKEN_VALUE_OFFS)
-#define MV_PP2_PLCR_TOKEN_VALUE_MASK(val)	(((val) << MV_PP2_PLCR_TOKEN_VALUE_OFFS) & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK)
+#define MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK	\
+		(((1 << MV_PP2_PLCR_TOKEN_VALUE_BITS) - 1) << MV_PP2_PLCR_TOKEN_VALUE_OFFS)
+#define MV_PP2_PLCR_TOKEN_VALUE_MASK(val)	\
+		(((val) << MV_PP2_PLCR_TOKEN_VALUE_OFFS) & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK)
 
 #define MV_PP2_PLCR_TOKEN_TYPE_OFFS		12
 #define MV_PP2_PLCR_TOKEN_TYPE_BITS		3
-#define MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK		(((1 << MV_PP2_PLCR_TOKEN_TYPE_BITS) - 1) << MV_PP2_PLCR_TOKEN_TYPE_OFFS)
-#define MV_PP2_PLCR_TOKEN_TYPE_MASK(type)	(((type) << MV_PP2_PLCR_TOKEN_TYPE_OFFS) & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK)
+#define MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK		\
+		(((1 << MV_PP2_PLCR_TOKEN_TYPE_BITS) - 1) << MV_PP2_PLCR_TOKEN_TYPE_OFFS)
+#define MV_PP2_PLCR_TOKEN_TYPE_MASK(type)	\
+		(((type) << MV_PP2_PLCR_TOKEN_TYPE_OFFS) & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK)
 
 #define MV_PP2_PLCR_TOKEN_UNIT_BIT		31
 #define MV_PP2_PLCR_TOKEN_UNIT_MASK		(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
@@ -127,16 +148,21 @@ extern "C" {
 
 #define MV_PP2_PLCR_COLOR_MODE_BIT		30
 #define MV_PP2_PLCR_COLOR_MODE_MASK		(1 << MV_PP2_PLCR_COLOR_MODE_BIT)
-#define MV_PP2_PLCR_COLOR_MODE_BLIND            (0 << MV_PP2_PLCR_COLOR_MODE_BIT)
-#define MV_PP2_PLCR_COLOR_MODE_AWARE            (1 << MV_PP2_PLCR_COLOR_MODE_BIT)
+#define MV_PP2_PLCR_COLOR_MODE_BLIND		(0 << MV_PP2_PLCR_COLOR_MODE_BIT)
+#define MV_PP2_PLCR_COLOR_MODE_AWARE		(1 << MV_PP2_PLCR_COLOR_MODE_BIT)
+
+#define MV_PP2_PLCR_ENABLE_BIT			29
+#define MV_PP2_PLCR_ENABLE_MASK			(1 << MV_PP2_PLCR_ENABLE_BIT)
 /*---------------------------------------------------------------------------------------------*/
 
 #define MV_PP2_PLCR_MIN_PKT_LEN_REG		(MV_PP2_REG_BASE + 0x1320)
 
 #define MV_PP2_PLCR_MIN_PKT_LEN_OFFS		0
 #define MV_PP2_PLCR_MIN_PKT_LEN_BITS		8
-#define MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK	(((1 << MV_PP2_PLCR_MIN_PKT_LEN_BITS) - 1) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS)
-#define MV_PP2_PLCR_MIN_PKT_LEN_MASK(len)	(((len) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS) & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK)
+#define MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK	\
+		(((1 << MV_PP2_PLCR_MIN_PKT_LEN_BITS) - 1) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS)
+#define MV_PP2_PLCR_MIN_PKT_LEN_MASK(len)	\
+		(((len) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS) & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK)
 /*---------------------------------------------------------------------------------------------*/
 
 #define MV_PP2_PLCR_EDROP_EN_REG		(MV_PP2_REG_BASE + 0x1330)
@@ -144,16 +170,31 @@ extern "C" {
 #define MV_PP2_PLCR_EDROP_EN_BIT		0
 #define MV_PP2_PLCR_EDROP_EN_MASK		(1 << MV_PP2_PLCR_EDROP_EN_BIT)
 /*---------------------------------------------------------------------------------------------*/
+/*ppv2.1 policer early drop threshold mechanism changed*/
+#define MV_PP2_V0_PLCR_EDROP_THRESH_NUM		4
+
+#define MV_PP2_V0_PLCR_EDROP_TR_OFFS(i)		((i % 2) ? 16 : 0)
+#define MV_PP2_V0_PLCR_EDROP_TR_BITS		14
+#define MV_PP2_V0_PLCR_EDROP_TR_ALL_MASK(i)	\
+		(((1 << MV_PP2_V0_PLCR_EDROP_TR_BITS) - 1) << MV_PP2_V0_PLCR_EDROP_TR_OFFS(i))
+#define MV_PP2_V0_PLCR_EDROP_TR_MASK(i, tr)	\
+		(((tr) << MV_PP2_V0_PLCR_EDROP_TR_OFFS(i)) & MV_PP2_V0_PLCR_EDROP_TR_ALL_MASK(i))
+
+#define MV_PP2_V0_PLCR_EDROP_CPU_TR_REG(i)	(MV_PP2_REG_BASE + 0x1340 + (((i) / 2) << 2))
+#define MV_PP2_V0_PLCR_EDROP_HWF_TR_REG(i)	(MV_PP2_REG_BASE + 0x1350 + (((i) / 2) << 2))
+/*---------------------------------------------------------------------------------------------*/
+/*ppv2.1 policer early drop threshold new mechanism*/
+#define MV_PP2_V1_PLCR_EDROP_THRESH_NUM		16
 
-#define MV_PP2_PLCR_EDROP_THRESH_NUM		4
+#define MV_PP2_V1_PLCR_EDROP_TR_OFFS		0
+#define MV_PP2_V1_PLCR_EDROP_TR_BITS		14
 
-#define MV_PP2_PLCR_EDROP_TR_OFFS(i)		((i % 2) ? 16 : 0)
-#define MV_PP2_PLCR_EDROP_TR_BITS		14
-#define MV_PP2_PLCR_EDROP_TR_ALL_MASK(i)	(((1 << MV_PP2_PLCR_EDROP_TR_BITS) - 1) << MV_PP2_PLCR_EDROP_TR_OFFS(i))
-#define MV_PP2_PLCR_EDROP_TR_MASK(i, tr)	(((tr) << MV_PP2_PLCR_EDROP_TR_OFFS(i)) & MV_PP2_PLCR_EDROP_TR_ALL_MASK(i))
+#define MV_PP2_V1_PLCR_EDROP_TR_MASK(i)		\
+		(((1 << MV_PP2_V1_PLCR_EDROP_TR_BITS) - 1) << MV_PP2_V1_PLCR_EDROP_TR_OFFS)
+
+#define MV_PP2_V1_PLCR_EDROP_CPU_TR_REG(i)	(MV_PP2_REG_BASE + 0x1380 + ((i) * 4))
+#define MV_PP2_V1_PLCR_EDROP_HWF_TR_REG(i)	(MV_PP2_REG_BASE + 0x13c0 + ((i) * 4))
 
-#define MV_PP2_PLCR_EDROP_CPU_TR_REG(i)		(MV_PP2_REG_BASE + 0x1340 + (((i) / 2) << 2))
-#define MV_PP2_PLCR_EDROP_HWF_TR_REG(i)		(MV_PP2_REG_BASE + 0x1350 + (((i) / 2) << 2))
 /*---------------------------------------------------------------------------------------------*/
 
 #define MV_PP2_PLCR_EDROP_RXQ_REG		(MV_PP2_REG_BASE + 0x1348)
@@ -163,22 +204,32 @@ extern "C" {
 #define MV_PP2_PLCR_EDROP_TXQ_REG		(MV_PP2_REG_BASE + 0x1358)
 #define MV_PP2_PLCR_EDROP_TXQ_TR_REG		(MV_PP2_REG_BASE + 0x135c)
 /*---------------------------------------------------------------------------------------------*/
+#define MV_PP2_V1_PLCR_PKT_GREEN_REG(pol)	(MV_PP2_REG_BASE + 0x7400 + 4 * (pol))
+#define MV_PP2_V1_PLCR_PKT_YELLOW_REG(pol)	(MV_PP2_REG_BASE + 0x7500 + 4 * (pol))
+#define MV_PP2_V1_PLCR_PKT_RED_REG(pol)		(MV_PP2_REG_BASE + 0x7600 + 4 * (pol))
+/*---------------------------------------------------------------------------------------------*/
 
 /* Policer APIs */
 void        mvPp2PlcrHwRegs(void);
 void        mvPp2PlcrHwDumpAll(void);
 void        mvPp2PlcrHwDumpSingle(int plcr);
+void        mvPp2V1PlcrTbCntDump(int plcr);
 MV_STATUS   mvPp2PlcrHwBasePeriodSet(int period);
 MV_STATUS   mvPp2PlcrHwBaseRateGenEnable(int enable);
 MV_STATUS   mvPp2PlcrHwEnable(int plcr, int enable);
+MV_STATUS   mvPp2PlcrHwMode(int mode);
 MV_STATUS   mvPp2PlcrHwMinPktLen(int bytes);
 MV_STATUS   mvPp2PlcrHwEarlyDropSet(int enable);
 MV_STATUS   mvPp2PlcrHwTokenConfig(int plcr, int unit, int type);
 MV_STATUS   mvPp2PlcrHwTokenValue(int plcr, int value);
 MV_STATUS   mvPp2PlcrHwColorModeSet(int plcr, int enable);
 MV_STATUS   mvPp2PlcrHwBucketSizeSet(int plcr, int commit, int excess);
-MV_STATUS   mvPp2PlcrHwCpuThreshSet(int idx, int threshold);
-MV_STATUS   mvPp2PlcrHwHwfThreshSet(int idx, int threshold);
+
+/*ppv2.1 policer early drop threshold mechanism changed*/
+MV_STATUS   mvPp2V0PlcrHwCpuThreshSet(int idx, int threshold);
+MV_STATUS   mvPp2V0PlcrHwHwfThreshSet(int idx, int threshold);
+MV_STATUS   mvPp2V1PlcrHwCpuThreshSet(int idx, int threshold);
+MV_STATUS   mvPp2V1PlcrHwHwfThreshSet(int idx, int threshold);
 MV_STATUS   mvPp2PlcrHwRxqThreshSet(int rxq, int idx);
 MV_STATUS   mvPp2PlcrHwTxqThreshSet(int txq, int idx);
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
index 8f0460f..386a6ab 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
@@ -107,8 +107,8 @@ static char *mvPp2PmeCmdName(enum MV_PP2_PME_CMD_E cmd)
 	case MV_PP2_PME_CMD_REPLACE_MID: return "REPLACE_MID";
 	case MV_PP2_PME_CMD_ADD_MULT:	return "ADD_MULT";
 	case MV_PP2_PME_CMD_REPLACE_MULT: return "REPLACE_MULT";
-	case MV_PP2_PME_CMD_RESERVED_1:
-	case MV_PP2_PME_CMD_RESERVED_2:	return "RESERVED";
+	case MV_PP2_PME_CMD_REPLACE_REM_2B: return "REPLACE_REM_2B"; /* For PPv2.1 - A0 only, MAS 3.3 */
+	case MV_PP2_PME_CMD_ADD_IP6_HDR: return "ADD_IP6_HDR";       /* For PPv2.1 - A0 only, MAS 3.15 */
 	case MV_PP2_PME_CMD_DROP_PKT:	return "DROP";
 	default:
 		return "UNKNOWN";
diff --git a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
index e1c2791..4074cce 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
@@ -216,8 +216,8 @@ enum MV_PP2_PME_CMD_E {
 	MV_PP2_PME_CMD_REPLACE_MID,
 	MV_PP2_PME_CMD_ADD_MULT,
 	MV_PP2_PME_CMD_REPLACE_MULT,
-	MV_PP2_PME_CMD_RESERVED_1,
-	MV_PP2_PME_CMD_RESERVED_2,
+	MV_PP2_PME_CMD_REPLACE_REM_2B, /* 0x1d - added on PPv2.1 (A0), MAS 3.3 */
+	MV_PP2_PME_CMD_ADD_IP6_HDR,    /* 0x1e - added on PPv2.1 (A0), MAS 3.15 */
 	MV_PP2_PME_CMD_DROP_PKT = 0x1f,
 	MV_PP2_TMP_CMD_LAST
 };
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
index cdaf528..06d030c 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
@@ -222,7 +222,8 @@ static MV_BOOL mvPrsMacInRange(MV_PP2_PRS_ENTRY *pe, MV_U8* da, MV_U8* mask)
 static MV_PP2_PRS_ENTRY *mvPrsMacDaRangeFind(int portMap, unsigned char *da, unsigned char *mask, int udfType)
 {
 	MV_PP2_PRS_ENTRY *pe;
-	unsigned int tid, entryPmap;
+	int tid;
+	unsigned int entryPmap;
 
 	pe = mvPp2PrsSwAlloc(PRS_LU_MAC);
 
@@ -867,7 +868,7 @@ static int mvPp2PrsDsaTagSet(int port, int add, int tagged, int extend)
 		/* set tagged bit in DSA tag */
 		/* TODO use define */
 		if (tagged) {
-			mvPp2PrsSwTcamByteSet(&pe, 3, 0x20, 0x20);
+			mvPp2PrsSwTcamByteSet(&pe, 0, 0x20, 0x20);
 
 			/* Clear all AI bits for next iteration */
 			mvPp2PrsSwSramAiUpdate(&pe, 0, SRAM_AI_MASK);
@@ -1494,7 +1495,23 @@ static int mvPp2PrsVlanInit(void)
 	return MV_OK;
 }
 
+/* remove all vlan entries */
+int mvPp2PrsVlanAllDel(void)
+{
+	int tid;
+
+	/* clear doublr Vlan shadow */
+	mvPrsDblVlanAiShadowClearAll();
+
+	for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++) {
+		if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) == PRS_LU_VLAN)) {
+			mvPp2PrsHwInv(tid);
+			mvPp2PrsShadowClear(tid);
+		}
+	}
 
+	return MV_OK;
+}
 /******************************************************************************
  *
  * Ethertype Section
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
index ae9b790..890d043 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
@@ -169,6 +169,7 @@ int mvPrsEthTypeDel(int portMap, unsigned short eth_type);
 int mvPp2PrsTripleVlan(unsigned short tpid1, unsigned short tpid2, unsigned short tpid3, unsigned int portBmp, int add);
 int mvPp2PrsDoubleVlan(unsigned short tpid1, unsigned short tpid2, unsigned int portBmp, int add);
 int mvPp2PrsSingleVlan(unsigned short tpid, unsigned int portBmp, int add);
+int mvPp2PrsVlanAllDel(void);
 char *mvPrsVlanInfoStr(unsigned int vlan_info);
 char *mvPrsL2InfoStr(unsigned int l2_info);
 /*
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
index 5b4417a..6e8a33d 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
@@ -387,6 +387,55 @@ int mvPp2PrsHwWrite(MV_PP2_PRS_ENTRY *pe)
 	return MV_OK;
 }
 
+/* Read tcam hit counter*/
+/* PPv2.1 MASS 3.20 new feature */
+/* return tcam entry (tid) hits counter or error if tid is out of range */
+static int mvPp2V1PrsHwTcamCntDump(int tid, unsigned int *cnt)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_TCAM_HIT_IDX_REG, tid);
+
+	regVal = mvPp2RdReg(MV_PP2_PRS_TCAM_HIT_CNT_REG);
+	regVal &= MV_PP2_PRS_TCAM_HIT_CNT_MASK;
+
+	if (cnt)
+		*cnt = regVal;
+	else
+		mvOsPrintf("HIT COUNTER: %d\n", regVal);
+
+	return MV_OK;
+}
+/* mvPp2PrsHwHitsDump - dump all non zeroed hit counters and the associated TCAM entries */
+/* PPv2.1 MASS 3.20 new feature */
+int mvPp2V1PrsHwHitsDump()
+{
+	int index;
+	unsigned int cnt;
+	MV_PP2_PRS_ENTRY pe;
+
+	for (index = 0; index < MV_PP2_PRS_TCAM_SIZE; index++) {
+		pe.index = index;
+		mvPp2PrsHwRead(&pe);
+		if ((pe.tcam.word[TCAM_INV_WORD] & TCAM_INV_MASK) == TCAM_VALID) {
+			mvPp2V1PrsHwTcamCntDump(index, &cnt);
+
+			if (cnt == 0)
+				continue;
+
+			mvOsPrintf("%s\n", mvPrsShadowTbl[index].text);
+			mvPp2PrsSwDump(&pe);
+			mvOsPrintf("       HITS: %d\n", cnt);
+			mvOsPrintf("-------------------------------------------------------------------------\n");
+		}
+	}
+
+	return MV_OK;
+}
+
 /* delete hw entry (set as invalid) */
 int mvPp2PrsHwInv(int tid)
 {
@@ -439,6 +488,9 @@ int mvPp2PrsHwDump()
 		if ((pe.tcam.word[TCAM_INV_WORD] & TCAM_INV_MASK) == TCAM_VALID) {
 			mvOsPrintf("%s\n", mvPrsShadowTbl[index].text);
 			mvPp2PrsSwDump(&pe);
+#ifdef MV_ETH_PPV2_1
+			mvPp2V1PrsHwTcamCntDump(index);
+#endif
 			mvOsPrintf("-------------------------------------------------------------------------\n");
 		}
 	}
@@ -446,7 +498,6 @@ int mvPp2PrsHwDump()
 	return MV_OK;
 }
 
-
 int mvPp2PrsSwDump(MV_PP2_PRS_ENTRY *pe)
 {
 	MV_U32	op, type, lu, done, flowid;
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
index a8b6250..5c783c2 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
@@ -156,6 +156,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_PP2_PRS_TCAM_CTRL_EN			0
 
 /*-------------------------------------------------------------------------------*/
+/*PPv2.1 MASS 3.20 new feature */
+#define MV_PP2_PRS_TCAM_HIT_IDX_REG		(MV_PP2_REG_BASE + 0x1240)
+/*-------------------------------------------------------------------------------*/
+/*PPv2.1 MASS 3.20 new feature */
+#define MV_PP2_PRS_TCAM_HIT_CNT_REG		(MV_PP2_REG_BASE + 0x1244)
+#define MV_PP2_PRS_TCAM_HIT_CNT_BITS		16
+#define MV_PP2_PRS_TCAM_HIT_CNT_OFFS		0
+#define MV_PP2_PRS_TCAM_HIT_CNT_MASK		\
+	(((1 << MV_PP2_PRS_TCAM_HIT_CNT_BITS) - 1) << MV_PP2_PRS_TCAM_HIT_CNT_OFFS)
+
+/*-------------------------------------------------------------------------------*/
 /*				TCAM 						*/
 /*-------------------------------------------------------------------------------*/
 #define AI_BITS  				8
@@ -565,6 +576,11 @@ void mvPp2PrsSwClear(MV_PP2_PRS_ENTRY *pe);
 int mvPp2PrsHwDump(void);
 
 /*
+	mvPp2V1PrsHwHitsDump - dump all entries with non zeroed hit counters
+*/
+int mvPp2V1PrsHwHitsDump(void);
+
+/*
 	enable - Tcam Ebable/Disable
 */
 
-- 
1.7.5.4

