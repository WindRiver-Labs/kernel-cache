From ad2e1d7e1a2411447e6ca1d164bf83717a3b432a Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 22 Jul 2013 14:16:10 -0400
Subject: [PATCH 0868/1825] neta: Add adaptive RX coalescing mechanism

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 313196713ccdaa3690180839107626aaf6d73c82

	Default: disable
	Default high rate 50000 pps
	Default low rate 1000 pps
	Default normal coalescing: 32 pkts, 100 usec
	Default high coalescing: 100 * 4 = 400 usec
	Default low coalescing: 100 /4 = 25 usec

Change-Id: I3dd5031b2179421f3ca1c4e28e1e986e7cc17b6f
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig |    5 -
 .../mv_drivers_lsp/mv_neta/net_dev/Makefile        |    3 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c  |    4 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c   |   50 +++++++++--
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |   95 ++++++++++++++++----
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |   22 ++++-
 6 files changed, 143 insertions(+), 36 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
index ab472b9..21ef6c6 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
@@ -530,11 +530,6 @@ config  MV_LINUX_COUNTERS_DISABLE
 	---help---
 	Disable collection of SNMP statistics and Netfilter Contract statistics to improve performance.
 
-config  MV_ETH_TOOL
-	bool "Support ethtool controls"
-	default y
-	---help---
-	Support kernel's SIOCETHTOOL for ethtool utility
 endmenu
 
 menu "Advanced Features"
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
index 9c090ff..184f2d2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
@@ -7,8 +7,7 @@ include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_ETH_NFP) += mv_eth_nfp.o
-obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o mv_eth_sysfs.o
+obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o mv_eth_sysfs.o mv_eth_tool.o
 obj-$(CONFIG_MV_PON)      += mv_pon_sysfs.o
 obj-$(CONFIG_MV_ETH_SWITCH) +=  mv_eth_switch.o
-obj-$(CONFIG_MV_ETH_TOOL) += mv_eth_tool.o
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
index 15dcc94..3c9111f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
@@ -357,7 +357,7 @@ static ssize_t mv_eth_3_store(struct device *dev,
 	} else if (!strcmp(name, "rxq_size")) {
 		err = mv_eth_ctrl_rxq_size_set(p, i, v);
 	} else if (!strcmp(name, "rxq_pkts_coal")) {
-		err = mv_eth_rx_ptks_coal_set(p, i, v);
+		err = mv_eth_rx_pkts_coal_set(p, i, v);
 	} else if (!strcmp(name, "rxq_time_coal")) {
 		err = mv_eth_rx_time_coal_set(p, i, v);
 	} else if (!strcmp(name, "rxq")) {
@@ -456,7 +456,7 @@ static ssize_t mv_eth_4_store(struct device *dev,
 	} else if (!strcmp(name, "txq_size")) {
 		err = mv_eth_ctrl_txq_size_set(p, txp, txq, v);
 	} else if (!strcmp(name, "txq_coal")) {
-		mv_eth_tx_done_ptks_coal_set(p, txp, txq, v);
+		mv_eth_tx_done_pkts_coal_set(p, txp, txq, v);
 	} else if (!strcmp(name, "txq")) {
 		mvNetaTxqShow(p, txp, txq, v);
 	} else if (!strcmp(name, "txq_regs")) {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
index 9b673bb..9098ea6 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
@@ -472,9 +472,20 @@ int mv_eth_tool_get_coalesce(struct net_device *netdev,
 	struct eth_port *pp = MV_ETH_PRIV(netdev);
 	/* get coal parameters only for rxq=0, txp=txq=0 !!!
 	   notice that if you use ethtool to set coal, then all queues have the same value */
-	cmd->rx_coalesce_usecs = mvNetaRxqTimeCoalGet(pp->port, 0);
-	cmd->rx_max_coalesced_frames = mvNetaRxqPktsCoalGet(pp->port, 0);
-	cmd->tx_max_coalesced_frames = mvNetaTxDonePktsCoalGet(pp->port, 0, 0);
+	cmd->rx_coalesce_usecs = pp->rx_time_coal_cfg;
+	cmd->rx_max_coalesced_frames = pp->rx_pkts_coal_cfg;
+	cmd->tx_max_coalesced_frames = pp->tx_pkts_coal_cfg;
+
+	/* Adaptive RX coalescing parameters */
+	cmd->rx_coalesce_usecs_low = pp->rx_time_low_coal_cfg;
+	cmd->rx_coalesce_usecs_high = pp->rx_time_high_coal_cfg;
+	cmd->rx_max_coalesced_frames_low = pp->rx_pkts_low_coal_cfg;
+	cmd->rx_max_coalesced_frames_high = pp->rx_pkts_high_coal_cfg;
+	cmd->pkt_rate_low = pp->pkt_rate_low_cfg;
+	cmd->pkt_rate_high = pp->pkt_rate_high_cfg;
+	cmd->rate_sample_interval = pp->rate_sample_cfg;
+	cmd->use_adaptive_rx_coalesce = pp->rx_adaptive_coal_cfg;
+
 	return 0;
 }
 
@@ -501,13 +512,38 @@ int mv_eth_tool_set_coalesce(struct net_device *netdev,
 	if ((!cmd->rx_coalesce_usecs && !cmd->rx_max_coalesced_frames) || (!cmd->tx_max_coalesced_frames))
 		return -EPERM;
 
-	for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++) {
-		mv_eth_rx_ptks_coal_set(pp->port, rxq, cmd->rx_max_coalesced_frames);
-		mv_eth_rx_time_coal_set(pp->port, rxq, cmd->rx_coalesce_usecs);
+	if (!cmd->use_adaptive_rx_coalesce) {
+		for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++) {
+			mv_eth_rx_pkts_coal_set(pp->port, rxq, cmd->rx_max_coalesced_frames);
+			mv_eth_rx_time_coal_set(pp->port, rxq, cmd->rx_coalesce_usecs);
+		}
 	}
+
+	pp->rx_time_coal_cfg = cmd->rx_coalesce_usecs;
+	pp->rx_pkts_coal_cfg = cmd->rx_max_coalesced_frames;
 	for (txp = 0; txp < pp->txp_num; txp++)
 		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
-			mv_eth_tx_done_ptks_coal_set(pp->port, txp, txq, cmd->tx_max_coalesced_frames);
+			mv_eth_tx_done_pkts_coal_set(pp->port, txp, txq, cmd->tx_max_coalesced_frames);
+	pp->tx_pkts_coal_cfg = cmd->tx_max_coalesced_frames;
+
+	/* Adaptive RX coalescing parameters */
+	pp->rx_time_low_coal_cfg = cmd->rx_coalesce_usecs_low;
+	pp->rx_time_high_coal_cfg = cmd->rx_coalesce_usecs_high;
+	pp->rx_pkts_low_coal_cfg = cmd->rx_max_coalesced_frames_low;
+	pp->rx_pkts_high_coal_cfg = cmd->rx_max_coalesced_frames_high;
+	pp->pkt_rate_low_cfg = cmd->pkt_rate_low;
+	pp->pkt_rate_high_cfg = cmd->pkt_rate_high;
+
+	if (cmd->rate_sample_interval > 0)
+		pp->rate_sample_cfg = cmd->rate_sample_interval;
+
+	/* check if adaptive rx is on - reset rate calculation parameters */
+	if (!pp->rx_adaptive_coal_cfg && cmd->use_adaptive_rx_coalesce) {
+		pp->rx_timestamp = jiffies;
+		pp->rx_rate_pkts = 0;
+	}
+	pp->rx_adaptive_coal_cfg = cmd->use_adaptive_rx_coalesce;
+	pp->rate_current = 0; /* Unknown */
 
 	return 0;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index 5fbe6e6..cd4ece6d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -221,6 +221,47 @@ void mv_eth_stack_print(int port, MV_BOOL isPrintElements)
 }
 
 
+/*****************************************
+ *          Adaptive coalescing          *
+ *****************************************/
+static void mv_eth_adaptive_rx_update(struct eth_port *pp)
+{
+	unsigned long period = jiffies - pp->rx_timestamp;
+
+	if (period >= (pp->rate_sample_cfg * HZ)) {
+		int i;
+		unsigned long rate = pp->rx_rate_pkts * HZ / period;
+
+		if (rate < pp->pkt_rate_low_cfg) {
+			if (pp->rate_current != 1) {
+				pp->rate_current = 1;
+				for (i = 0; i < CONFIG_MV_ETH_RXQ; i++) {
+					mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_low_coal_cfg);
+					mv_eth_rx_pkts_coal_set(pp->port, i, pp->rx_pkts_low_coal_cfg);
+				}
+			}
+		} else if (rate > pp->pkt_rate_high_cfg) {
+			if (pp->rate_current != 3) {
+				pp->rate_current = 3;
+				for (i = 0; i < CONFIG_MV_ETH_RXQ; i++)
+					mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_high_coal_cfg);
+					mv_eth_rx_pkts_coal_set(pp->port, i, pp->rx_pkts_high_coal_cfg);
+			}
+		} else {
+			if (pp->rate_current != 2) {
+				pp->rate_current = 2;
+				for (i = 0; i < CONFIG_MV_ETH_RXQ; i++) {
+					mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_coal_cfg);
+					mv_eth_rx_pkts_coal_set(pp->port, i, pp->rx_pkts_coal_cfg);
+				}
+			}
+		}
+
+		pp->rx_rate_pkts = 0;
+		pp->rx_timestamp = jiffies;
+	}
+}
+
 void set_cpu_affinity(struct eth_port *pp, MV_U32 cpuAffinity, int group)
 {
 	int cpu;
@@ -2871,6 +2912,10 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 	budget -= rx_done;
 #endif /* (CONFIG_MV_ETH_RXQ > 1) */
 
+	/* Maintain RX packets rate if adaptive RX coalescing is enabled */
+	if (pp->rx_adaptive_coal_cfg)
+		pp->rx_rate_pkts += rx_done;
+
 	STAT_DIST((rx_done < pp->dist_stats.rx_dist_size) ? pp->dist_stats.rx_dist[rx_done]++ : 0);
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
@@ -2889,6 +2934,10 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 
 		STAT_INFO(pp->stats.poll_exit[smp_processor_id()]++);
 
+		/* adapt RX coalescing according to packets rate */
+		if (pp->rx_adaptive_coal_cfg)
+			mv_eth_adaptive_rx_update(pp);
+
 		local_irq_save(flags);
 		MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port),
 			     (MV_ETH_MISC_SUM_INTR_MASK | MV_ETH_TXDONE_INTR_MASK | MV_ETH_RX_INTR_MASK));
@@ -3275,7 +3324,7 @@ static int mv_eth_resume_rxq_txq(struct eth_port *pp, int mtu)
 			mvNetaRxqOffsetSet(pp->port, rxq, NET_SKB_PAD);
 
 			/* Set coalescing pkts and time */
-			mv_eth_rx_ptks_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_pkts_coal);
+			mv_eth_rx_pkts_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_pkts_coal);
 			mv_eth_rx_time_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_time_coal);
 
 
@@ -3307,7 +3356,7 @@ static int mv_eth_resume_rxq_txq(struct eth_port *pp, int mtu)
 
 			if (txq_ctrl->q != NULL) {
 				mvNetaTxqAddrSet(pp->port, txq_ctrl->txp, txq_ctrl->txq, txq_ctrl->txq_size);
-				mv_eth_tx_done_ptks_coal_set(pp->port, txp, txq,
+				mv_eth_tx_done_pkts_coal_set(pp->port, txp, txq,
 							pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq].txq_done_pkts_coal);
 			}
 			mvNetaTxqBandwidthSet(pp->port, txp, txq);
@@ -3811,9 +3860,7 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 #endif /* CONFIG_MV_ETH_SWITCH */
 		dev->netdev_ops = &mv_eth_netdev_ops;
 
-#ifdef CONFIG_MV_ETH_TOOL
 	SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);
-#endif
 
 	/* Default NAPI initialization */
 	for (i = 0; i < CONFIG_MV_ETH_NAPI_GROUPS; i++) {
@@ -3979,15 +4026,24 @@ int mv_eth_hal_init(struct eth_port *pp)
 	if (pp->flags & MV_ETH_F_MH)
 		mvNetaMhSet(pp->port, MV_NETA_MH);
 
-#ifdef CONFIG_MV_ETH_TOOL
 	/* Configure defaults */
 	pp->autoneg_cfg  = AUTONEG_ENABLE;
 	pp->speed_cfg    = SPEED_1000;
 	pp->duplex_cfg  = DUPLEX_FULL;
 	pp->advertise_cfg = 0x2f;
-#endif /* CONFIG_MV_ETH_TOOL */
+	pp->rx_time_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC;
+	pp->rx_pkts_coal_cfg = CONFIG_MV_ETH_RX_COAL_PKTS;
+	pp->tx_pkts_coal_cfg = mv_ctrl_txdone;
+	pp->rx_time_low_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC >> 2;
+	pp->rx_time_high_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC << 2;
+	pp->rx_pkts_low_coal_cfg = CONFIG_MV_ETH_RX_COAL_PKTS;
+	pp->rx_pkts_high_coal_cfg = CONFIG_MV_ETH_RX_COAL_PKTS;
+	pp->pkt_rate_low_cfg = 1000;
+	pp->pkt_rate_high_cfg = 50000;
+	pp->rate_sample_cfg = 5;
+	pp->rate_current = 0; /* Unknown */
 
-	return MV_OK;
+	return 0;
 oom:
 	printk(KERN_ERR "%s: port=%d: out of memory\n", __func__, pp->port);
 	return -ENODEV;
@@ -4418,7 +4474,8 @@ int mv_eth_txp_reset(int port, int txp)
 			mv_eth_txq_done_force(pp, txq_ctrl);
 	}
 	mvNetaTxpReset(port, txp);
-	return MV_OK;
+
+	return 0;
 }
 
 /* Free received packets from all RXQs and reset RX of the port */
@@ -4464,16 +4521,18 @@ int mv_eth_rx_reset(int port)
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
 	mvNetaRxReset(port);
-	return MV_OK;
+	return 0;
 }
 
 /***********************************************************
  * coal set functions		                           *
  ***********************************************************/
-MV_STATUS mv_eth_rx_ptks_coal_set(int port, int rxq, MV_U32 value)
+MV_STATUS mv_eth_rx_pkts_coal_set(int port, int rxq, MV_U32 value)
 {
-	MV_STATUS status = mvNetaRxqPktsCoalSet(port, rxq, value);
+	MV_STATUS status;
 	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	status = mvNetaRxqPktsCoalSet(port, rxq, value);
 	if (status == MV_OK)
 		pp->rxq_ctrl[rxq].rxq_pkts_coal = value;
 	return status;
@@ -4481,17 +4540,21 @@ MV_STATUS mv_eth_rx_ptks_coal_set(int port, int rxq, MV_U32 value)
 
 MV_STATUS mv_eth_rx_time_coal_set(int port, int rxq, MV_U32 value)
 {
-	MV_STATUS status = mvNetaRxqTimeCoalSet(port, rxq, value);
+	MV_STATUS status;
 	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	status = mvNetaRxqTimeCoalSet(port, rxq, value);
 	if (status == MV_OK)
 		pp->rxq_ctrl[rxq].rxq_time_coal = value;
 	return status;
 }
 
-MV_STATUS mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 value)
+MV_STATUS mv_eth_tx_done_pkts_coal_set(int port, int txp, int txq, MV_U32 value)
 {
-	MV_STATUS status = mvNetaTxDonePktsCoalSet(port, txp, txq, value);
+	MV_STATUS status;
 	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	status = mvNetaTxDonePktsCoalSet(port, txp, txq, value);
 	if (status == MV_OK)
 		pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq].txq_done_pkts_coal = value;
 	return status;
@@ -4627,7 +4690,7 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 		mvNetaRxqOffsetSet(pp->port, rxq, NET_SKB_PAD);
 
 		/* Set coalescing pkts and time */
-		mv_eth_rx_ptks_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_pkts_coal);
+		mv_eth_rx_pkts_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_pkts_coal);
 		mv_eth_rx_time_coal_set(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_time_coal);
 
 #if defined(CONFIG_MV_ETH_BM_CPU)
@@ -4659,7 +4722,7 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 					goto out;
 				spin_lock_init(&txq_ctrl->queue_lock);
 			}
-			mv_eth_tx_done_ptks_coal_set(pp->port, txp, txq,
+			mv_eth_tx_done_pkts_coal_set(pp->port, txp, txq,
 					pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq].txq_done_pkts_coal);
 		}
 		mvNetaTxpMaxTxSizeSet(pp->port, txp, RX_PKT_SIZE(mtu));
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 3e6c35c..6369f66 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -378,12 +378,26 @@ struct eth_port {
 	MV_STACK            *extArrStack;
 	int                 extBufSize;
 	spinlock_t          extLock;
-#ifdef CONFIG_MV_ETH_TOOL
+	/* Ethtool parameters */
 	__u16               speed_cfg;
 	__u8                duplex_cfg;
 	__u8                autoneg_cfg;
 	__u16		        advertise_cfg;
-#endif/* CONFIG_MV_ETH_TOOL */
+	__u32               rx_time_coal_cfg;
+	__u32               rx_pkts_coal_cfg;
+	__u32               tx_pkts_coal_cfg;
+	__u32               rx_time_low_coal_cfg;
+	__u32               rx_time_high_coal_cfg;
+	__u32               rx_pkts_low_coal_cfg;
+	__u32               rx_pkts_high_coal_cfg;
+	__u32               pkt_rate_low_cfg;
+	__u32               pkt_rate_high_cfg;
+	__u32               rate_current; /* unknown (0), low (1), normal (2), high (3) */
+	__u32               rate_sample_cfg;
+	__u32               rx_adaptive_coal_cfg;
+	/* Rate calculate */
+	unsigned long	    rx_rate_pkts;
+	unsigned long	    rx_timestamp;
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	void    (*rx_special_proc)(int port, int rxq, struct net_device *dev,
 					struct sk_buff *skb, struct neta_rx_desc *rx_desc);
@@ -744,9 +758,9 @@ int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
 int         mv_eth_rx_reset(int port);
 int         mv_eth_txp_reset(int port, int txp);
 
-MV_STATUS   mv_eth_rx_ptks_coal_set(int port, int rxq, MV_U32 value);
+MV_STATUS   mv_eth_rx_pkts_coal_set(int port, int rxq, MV_U32 value);
 MV_STATUS   mv_eth_rx_time_coal_set(int port, int rxq, MV_U32 value);
-MV_STATUS   mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 value);
+MV_STATUS   mv_eth_tx_done_pkts_coal_set(int port, int txp, int txq, MV_U32 value);
 
 struct eth_port     *mv_eth_port_by_id(unsigned int port);
 struct net_device   *mv_eth_netdev_by_id(unsigned int idx);
-- 
1.7.5.4

