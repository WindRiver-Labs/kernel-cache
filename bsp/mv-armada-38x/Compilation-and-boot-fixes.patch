From 0cc6553fccb1b12df80e45008d07fd8bab756c5e Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 16 Jan 2013 11:30:53 +0200
Subject: [PATCH 0405/1825] Compilation and boot fixes

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit fe335ecd693591613adbe1ddd254cee8915dc599

Change-Id: I0fabf42aa35e23d9392d6da591f89cc774dd3669
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                           |    1 +
 arch/arm/configs/armada_xp_v7smp_defconfig |   20 ++---
 arch/arm/include/asm/tlbflush.h            |   52 ++++++-----
 arch/arm/kernel/smp.c                      |    4 +-
 arch/arm/mach-armadaxp/time.c              |  134 +++++++++++++++-------------
 5 files changed, 112 insertions(+), 99 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b78f5e0..dcf90ad 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -643,6 +643,7 @@ config ARCH_ARMADA_XP
 	select GENERIC_GPIO
 	select GENERIC_TIME
 	select GENERIC_CLOCKEVENTS
+	select HAVE_SMP
 	select PLAT_ARMADA
 #	select PLAT_ORION
 	select HAVE_REGS_AND_STACK_ACCESS_API
diff --git a/arch/arm/configs/armada_xp_v7smp_defconfig b/arch/arm/configs/armada_xp_v7smp_defconfig
index a000cbe..5cc0d8b 100644
--- a/arch/arm/configs/armada_xp_v7smp_defconfig
+++ b/arch/arm/configs/armada_xp_v7smp_defconfig
@@ -16,18 +16,21 @@ CONFIG_KPROBES=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
 CONFIG_ARCH_ARMADA_XP=y
+# CONFIG_MV_INCLUDE_SWITCH is not set
+CONFIG_MV_ETH_PORTS_NUM=4
+CONFIG_MV_ETH_RXQ=8
+CONFIG_MV_ETH_TXQ=8
+CONFIG_NET_SKB_HEADROOM=96
+CONFIG_MV_CESA_TOOL=y
 CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE=y
 CONFIG_MV_INCLUDE_PCI=y
 # CONFIG_MV_INCLUDE_LEGACY_NAND is not set
-# CONFIG_MV_INCLUDE_SWITCH is not set
 CONFIG_MTD_NAND_NFC_INIT_RESET=y
 CONFIG_MV_PMU_PROC=y
 CONFIG_MV_ETH_NETA=y
-CONFIG_MV_ETH_PORTS_NUM=4
-CONFIG_MV_ETH_RXQ=8
-CONFIG_MV_ETH_TXQ=8
-CONFIG_NET_SKB_HEADROOM=96
 # CONFIG_MV_ETH_BM is not set
 # CONFIG_MV_ETH_PNC is not set
 CONFIG_MV_ETH_GRO_DEF=y
@@ -36,10 +39,8 @@ CONFIG_MV_ETH_TSO_DEF=y
 CONFIG_MV_ETH_RX_DESC_PREFETCH=y
 CONFIG_MV_ETH_RX_PKT_PREFETCH=y
 # CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA is not set
-CONFIG_MV_CESA_TOOL=y
 CONFIG_MV_CESA_CHANNELS=2
 CONFIG_MV_CESA_CHAIN_MODE=y
-CONFIG_CPU_SHEEVA_PJ4B_V7=y
 # CONFIG_SWP_EMULATE is not set
 CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
 CONFIG_SHEEVA_DEEP_IDLE=y
@@ -162,9 +163,6 @@ CONFIG_NEW_LEDS=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_DRV_MV=y
 CONFIG_DMADEVICES=y
-CONFIG_MV_XOR=y
-CONFIG_NET_DMA=y
-CONFIG_ASYNC_TX_DMA=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT3_FS=y
 # CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
@@ -183,8 +181,6 @@ CONFIG_UBIFS_FS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 CONFIG_ROOT_NFS=y
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_EFI_PARTITION=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_CODEPAGE_850=y
 CONFIG_NLS_ISO8859_1=y
diff --git a/arch/arm/include/asm/tlbflush.h b/arch/arm/include/asm/tlbflush.h
index 27ffb84..39d5171 100644
--- a/arch/arm/include/asm/tlbflush.h
+++ b/arch/arm/include/asm/tlbflush.h
@@ -337,22 +337,7 @@ extern struct cpu_tlb_fns cpu_tlb;
 			    : "cc");					\
 	} while (0)
 
-static inline void tlb_op(int op, const char *regs, int arg)
-{
-#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
-	if (op == TLB_DCLEAN && tlb_flag(op)) {
-		unsigned long flags;
-		raw_local_irq_save(flags);
-		dmb();
-		__tlb_op(op, regs, arg);
-		raw_local_irq_restore(flags);
-	}
-#else
-	/* __tlb_op(op, regs, arg); */
-#endif
-
-}
-
+#define tlb_op(f, regs, arg)	__tlb_op(f, "p15, 0, %0, " regs, arg)
 #define tlb_l2_op(f, regs, arg)	__tlb_op(f, "p15, 1, %0, " regs, arg)
 
 static inline void local_flush_tlb_all(void)
@@ -486,19 +471,29 @@ static inline void flush_pmd_entry(void *pmd)
 {
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
 
+	if (tlb_flag(TLB_DCLEAN))
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	{
+		unsigned long flags;
+		raw_local_irq_save(flags);
+		dmb();
+#endif
 #if defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6043) || defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6124)
-		asm("mcr	p15, 0, %0, c7, c14, 1  @ flush_pmd"
-			: : "r" (pmd) : "cc");
+	tlb_op(TLB_DCLEAN, "c7, c14, 1	@ flush_pmd", pmd);
 #else
 	tlb_op(TLB_DCLEAN, "c7, c10, 1	@ flush_pmd", pmd);
 #endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+		raw_local_irq_restore(flags);
+	}
+#endif
 
 #ifdef CONFIG_CACHE_AURORA_L2
-	l2_clean_pa(__pa((unsigned long)pmd));
+	if (tlb_flag(TLB_L2CLEAN_FR)) 
+		l2_clean_pa(__pa((unsigned long)pmd));
 #else
 	tlb_l2_op(TLB_L2CLEAN_FR, "c15, c9, 1  @ L2 flush_pmd", pmd);
 #endif
-
 	if (tlb_flag(TLB_WB))
 		dsb();
 }
@@ -507,15 +502,26 @@ static inline void clean_pmd_entry(void *pmd)
 {
 	const unsigned int __tlb_flag = __cpu_tlb_flags;
 
+	if (tlb_flag(TLB_DCLEAN))
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	{
+		unsigned long flags;
+                raw_local_irq_save(flags);
+                dmb();
+#endif
 #if defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6043) || defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6124)
-		asm("mcr	p15, 0, %0, c7, c14, 1  @ flush_pmd"
-			: : "r" (pmd) : "cc");
+	tlb_op(TLB_DCLEAN, "c7, c14, 1	@ flush_pmd", pmd);
 #else
 	tlb_op(TLB_DCLEAN, "c7, c10, 1	@ flush_pmd", pmd);
 #endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+		raw_local_irq_restore(flags);
+	}
+#endif
 
 #ifdef CONFIG_CACHE_AURORA_L2
-	l2_clean_pa(__pa((unsigned long)pmd));
+	if (tlb_flag(TLB_L2CLEAN_FR))
+		l2_clean_pa(__pa((unsigned long)pmd));
 #else
 	tlb_l2_op(TLB_L2CLEAN_FR, "c15, c9, 1  @ L2 flush_pmd", pmd);
 #endif
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index ad47bf70..1c99d49 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -308,7 +308,7 @@ static void __cpuinit smp_store_cpu_info(unsigned int cpuid)
 	store_cpu_topology(cpuid);
 }
 
-static void percpu_timer_setup(void);
+void percpu_timer_setup(void);
 
 /*
  * This is the secondary CPU boot entry.  We're using this CPUs
@@ -560,7 +560,7 @@ int local_timer_register(struct local_timer_ops *ops)
 }
 #endif
 
-static void __cpuinit percpu_timer_setup(void)
+void __cpuinit percpu_timer_setup(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
diff --git a/arch/arm/mach-armadaxp/time.c b/arch/arm/mach-armadaxp/time.c
index dbcaba4..bd5126b 100644
--- a/arch/arm/mach-armadaxp/time.c
+++ b/arch/arm/mach-armadaxp/time.c
@@ -33,6 +33,7 @@
 #include "cpu/mvCpu.h"
 
 #ifdef CONFIG_SMP
+extern void __cpuinit percpu_timer_setup(void);
 static struct clock_event_device __percpu ** axp_local_clockevent;
 #endif
 
@@ -243,67 +244,6 @@ void axp_timer_resume(void)
 	MV_REG_WRITE(TIMER_CTRL, u);
 }
 
-void __init axp_time_init(unsigned int fabric_clk)
-{
-	u32 u;
-
-#ifdef CONFIG_MV_AMP_ENABLE
-	soc_timer_id = (master_cpu_id == 0 ? 0 : 3);
-#else
-	soc_timer_id = 0;
-#endif
-
-	printk("Initializing ArmadaXP SOC Timer %d\n", soc_timer_id);
-
-	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
-	
-	axp_setup_sched_clock(fabric_clk);
-
-	/* Setup free-running clocksource timer (interrupts disabled) */
-	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
-	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
-	u = MV_REG_READ(BRIDGE_MASK);
-	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
-	MV_REG_WRITE(BRIDGE_MASK, u);
-	u = MV_REG_READ(TIMER_CTRL);
-#if !defined (CONFIG_ARMADA_XP_REV_Z1) && !defined (CONFIG_MACH_ARMADA_XP_FPGA)
-	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
-#else
-	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id));
-#endif
-	MV_REG_WRITE(TIMER_CTRL, u);
-	axp_clksrc.mult = clocksource_hz2mult(fabric_clk, axp_clksrc.shift);
-	clocksource_register(&axp_clksrc);
-
-#ifdef CONFIG_SMP
-	{
-		percpu_timer_setup();
-	        return;
-	}
-#endif
-	/* Setup clockevent timer (interrupt-driven) */
-	axp_clkevt.name = "axp_tick";
-	axp_clkevt.irq = IRQ_LOCALTIMER;
-	mv_timer_setup(&axp_clkevt, fabric_clk);
-	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
-	clockevents_register_device(&axp_clkevt);
-}
-
-static void axp_timer_init(void)
-{
-#if !defined (CONFIG_ARMADA_XP_REV_Z1) || defined (CONFIG_MACH_ARMADA_XP_FPGA)
-	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
-	axp_time_init(25000000);
-#else
-	axp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
-#endif
-}
-
-struct sys_timer axp_timer = {
-	.init = axp_timer_init,
-};
-
-
 #if defined (CONFIG_SMP) && defined (CONFIG_LOCAL_TIMERS)
 /*
  * Used on SMP for either the local timer or IPI_TIMER
@@ -396,7 +336,7 @@ int __cpuinit axp_local_timer_setup(struct clock_event_device *clk)
 /*
  * take a local timer down
  */
-void  __cpuexit local_timer_stop(struct clock_event_device * evt)
+void  __cpuexit axp_local_timer_stop(struct clock_event_device * evt)
 {
 	unsigned long flags;
 	u32 u;
@@ -414,4 +354,74 @@ void  __cpuexit local_timer_stop(struct clock_event_device * evt)
 	local_irq_restore(flags);
 }
 #endif
+
+static struct local_timer_ops axp_local_timer_ops __cpuinitdata = {
+	.setup	= axp_local_timer_setup,
+#ifdef CONFIG_HOTPLUG_CPU
+	.stop	= axp_local_timer_stop,
+#endif
+};
 #endif	/* CONFIG_LOCAL_TIMERS && CONFIG_SMP */
+
+void __init axp_time_init(unsigned int fabric_clk)
+{
+	u32 u;
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	soc_timer_id = (master_cpu_id == 0 ? 0 : 3);
+#else
+	soc_timer_id = 0;
+#endif
+
+	printk("Initializing ArmadaXP SOC Timer %d\n", soc_timer_id);
+
+	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+	
+	axp_setup_sched_clock(fabric_clk);
+
+	/* Setup free-running clocksource timer (interrupts disabled) */
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+	u = MV_REG_READ(TIMER_CTRL);
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) && !defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
+#else
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id));
+#endif
+	MV_REG_WRITE(TIMER_CTRL, u);
+	axp_clksrc.mult = clocksource_hz2mult(fabric_clk, axp_clksrc.shift);
+	clocksource_register(&axp_clksrc);
+
+#ifdef CONFIG_SMP
+	{
+#ifdef CONFIG_LOCAL_TIMERS
+		local_timer_register(&axp_local_timer_ops);
+#endif
+		percpu_timer_setup();
+	        return;
+	}
+#endif
+	/* Setup clockevent timer (interrupt-driven) */
+	axp_clkevt.name = "axp_tick";
+	axp_clkevt.irq = IRQ_LOCALTIMER;
+	mv_timer_setup(&axp_clkevt, fabric_clk);
+	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
+	clockevents_register_device(&axp_clkevt);
+}
+
+static void __init axp_timer_init(void)
+{
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) || defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
+	axp_time_init(25000000);
+#else
+	axp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
+#endif
+}
+
+struct sys_timer axp_timer = {
+	.init = axp_timer_init,
+};
-- 
1.7.5.4

