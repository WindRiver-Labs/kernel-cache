From 90194f6d53ecb381ec983905fa946b8412729fb9 Mon Sep 17 00:00:00 2001
From: Igor Patrik <igorp@marvell.com>
Date: Tue, 9 Jul 2013 10:55:36 +0200
Subject: [PATCH 0768/1825] axp: added initial family source

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e4e4e109d2feb0b97499d6dae59e7f48a2ae2925

Change-Id: Id7f6d4997b7fb6c17db07ca9be2ea3a736a5b98d
Signed-off-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_xp_family/boardEnv/mvBoardEnvLib.c      | 2677 ++++++++++++++++++++
 .../armada_xp_family/boardEnv/mvBoardEnvLib.h      |  457 ++++
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.c     | 1431 +++++++++++
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.h     |  575 +++++
 .../arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c |  323 +++
 .../arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h |  112 +
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c    |  377 +++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h    |  194 ++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h        |   97 +
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.c        | 2167 ++++++++++++++++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.h        |  279 ++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h       |  569 +++++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h       |  494 ++++
 .../armada_xp_family/ctrlEnv/mvSemaphore.c         |  124 +
 .../armada_xp_family/ctrlEnv/mvSemaphore.h         |  106 +
 .../armada_xp_family/ctrlEnv/mvUnitMap.c           |  266 ++
 .../armada_xp_family/ctrlEnv/mvUnitMap.h           |  158 ++
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c     |  750 ++++++
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h     |   96 +
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h |  143 ++
 .../armada_xp_family/ctrlEnv/sys/mvCpuIf.c         |  966 +++++++
 .../armada_xp_family/ctrlEnv/sys/mvCpuIf.h         |  122 +
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S     |  167 ++
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h     |  363 +++
 .../armada_xp_family/device/mvDevice.c             |  291 +++
 .../armada_xp_family/device/mvDevice.h             |   99 +
 .../armada_xp_family/device/mvDeviceRegs.h         |  270 ++
 .../mach-armadaxp/armada_xp_family/star_test.txt   |    1 +
 .../arm/mach-armadaxp/armada_xp_family/version.txt |    1 +
 29 files changed, 13675 insertions(+), 0 deletions(-)
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/star_test.txt
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/version.txt

diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
new file mode 100755
index 0000000..555bc9a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,2677 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPex.h"
+#include "device/mvDevice.h"
+#include "neta/gbe/mvEthRegs.h"
+#include "gpp/mvGppRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#define DB1(x)	x
+#else
+#define DB(x)
+#define DB1(x)
+#endif
+
+#define CODE_IN_ROM		MV_FALSE
+#define CODE_IN_RAM		MV_TRUE
+
+extern MV_BOARD_INFO *boardInfoTbl[];
+#define BOARD_INFO(boardId)	boardInfoTbl[boardId - BOARD_ID_BASE]
+
+/* Locals */
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+
+MV_U32 tClkRate = -1;
+extern MV_U8 mvDbDisableModuleDetection;
+
+MV_U32 gSerdesZ1AMode = 0;
+
+/*******************************************************************************
+* mvBoardEnvInit - Init board
+*
+* DESCRIPTION:
+*		In this function the board environment take care of device bank
+*		initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_U32 nandDev;
+	MV_U32 norDev;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardEnvInit:Board unknown.\n");
+		return;
+	}
+
+	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+	if (nandDev != 0xFFFFFFFF) {
+		/* Set NAND interface access parameters */
+		nandDev = BOOT_CS;
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), BOARD_INFO(boardId)->nandFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), BOARD_INFO(boardId)->nandFlashWriteParams);
+		MV_REG_WRITE(DEV_NAND_CTRL_REG, BOARD_INFO(boardId)->nandFlashControl);
+	}
+
+	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+	if (norDev != 0xFFFFFFFF) {
+		/* Set NOR interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), BOARD_INFO(boardId)->norFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), BOARD_INFO(boardId)->norFlashWriteParams);
+		MV_REG_WRITE(DEV_BUS_SYNC_CTRL, 0x11);
+	}
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), BOARD_INFO(boardId)->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), BOARD_INFO(boardId)->gppOutValMid);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(2), BOARD_INFO(boardId)->gppOutValHigh);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValMid);
+	mvGppPolaritySet(2, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValHigh);
+
+	/* Set GPP Out Enable */
+	mvGppTypeSet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValMid);
+	mvGppTypeSet(2, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValHigh);
+}
+/*******************************************************************************
+* mvBoardModelGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns 16bit describing board model.
+*       Board model is constructed of one byte major and minor numbers in the
+*       following manner:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardModelGet(MV_VOID)
+{
+	return (mvBoardIdGet() >> 16);
+}
+/*******************************************************************************
+* mbBoardRevlGet - Get Board revision
+*
+* DESCRIPTION:
+*       This function returns a 32bit describing the board revision.
+*       Board revision is constructed of 4bytes. 2bytes describes major number
+*       and the other 2bytes describes minor munber.
+*       For example for board revision 3.4 the function will return
+*       0x00030004.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardRevGet(MV_VOID)
+{
+	return (mvBoardIdGet() & 0xFFFF);
+}
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsSPrintf(pNameBuff, "Board unknown.\n");
+		return MV_ERROR;
+	}
+	if (mvCtrlModelRevGet() ==  MV_6710_Z1_ID)
+		mvOsSPrintf(pNameBuff, "%s", "DB-6710-Z1");
+	else
+		mvOsSPrintf(pNameBuff, "%s", BOARD_INFO(boardId)->boardName);
+
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	switch (boardId) {
+	case DB_88F78XX0_BP_REV2_ID:
+	case DB_88F78XX0_BP_ID:  /* need to update since Gunit0 can be SGMII */
+		if (ethPortNum > 1)
+			return MV_TRUE;
+		break;
+	case DB_78X60_AMC_ID:
+		if (ethPortNum > 0)
+			return MV_TRUE;
+		break;
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+		if (ethPortNum > 0)
+			return MV_TRUE;
+		break;
+	case DB_78X60_PCAC_ID:
+	case DB_784MP_GP_ID:
+	case RD_78460_NAS_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_PCAC_REV2_ID:
+		return MV_TRUE;
+		break;
+
+	default:
+		DB(mvOsPrintf("mvBoardSerdesCfgGet: Unsupported board!\n"));
+		return MV_FALSE;
+	}
+
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
+{
+	if (mvBoardIsGMIIModuleConnected() && (ethPortNum ==0))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+
+/*******************************************************************************
+* mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
+*
+* DESCRIPTION:
+*       This routine returns the Switch CPU port.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the Switch CPU port, -1 if the switch is not connected.
+*
+*******************************************************************************/
+MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardSwitchCpuPortGet: Board unknown.\n");
+		return -1;
+	}
+	if ((BOARD_INFO(boardId)->switchInfoNum == 0) || (switchIdx >= BOARD_INFO(boardId)->switchInfoNum))
+		return -1;
+
+	return BOARD_INFO(boardId)->pSwitchInfo[switchIdx].cpuPort;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+/*******************************************************************************
+* mvBoardQuadPhyAddr0Get - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardQuadPhyAddr0Get: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr0;
+}
+
+/*******************************************************************************
+* mvBoardPhyLinkCryptPortAddrGet - Get the phy gbe address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyLinkCryptPortAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].LinkCryptPortAddr;
+}
+
+MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum)
+{
+	return !mvBoardIsPortInGmii(ethPortNum);
+}
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMacSpeedGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (boardId == RD_78460_NAS_ID) {
+		if (mvBoardIsSwitchModuleConnected())
+			return BOARD_MAC_SPEED_1000M;
+	}
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardSpecInitGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: Return MV_TRUE and parameters in case board need spesific phy init,
+*	  otherwise return MV_FALSE.
+*
+*
+*******************************************************************************/
+MV_BOOL mvBoardSpecInitGet(MV_U32 *regOff, MV_U32 *data)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTclkGet - Get the board Tclk (Controller clock)
+*
+* DESCRIPTION:
+*       This routine extract the controller core clock.
+*       This function uses the controller counters to make identification.
+*		Note: In order to avoid interference, make sure task context switch
+*		and interrupts will not occure during this function operation
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardTclkGet(MV_VOID)
+{
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	if ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_TCLK_MASK) != 0)
+		return MV_BOARD_TCLK_200MHZ;
+	else
+		return MV_BOARD_TCLK_250MHZ;
+}
+
+/*******************************************************************************
+* mvBoardSysClkGet - Get the board SysClk (CPU bus clock , i.e. DDR clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU bus clock.
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardSysClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 cpuFreqMhz, ddrFreqMhz;
+	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)),
+									MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	if (clockRatioTbl[idx].vco2cpu != 0) {	/* valid ratio ? */
+		cpuFreqMhz = mvCpuPclkGet() / 1000000;	/* obtain CPU freq */
+		cpuFreqMhz *= clockRatioTbl[idx].vco2cpu;	/* compute VCO freq */
+		ddrFreqMhz = cpuFreqMhz / clockRatioTbl[idx].vco2ddr;
+		/* round up to integer MHz */
+		if (((cpuFreqMhz % clockRatioTbl[idx].vco2ddr) * 10 / clockRatioTbl[idx].vco2ddr) >= 5)
+			ddrFreqMhz++;
+
+		return ddrFreqMhz * 1000000;
+	} else
+		return 0;
+}
+
+/*******************************************************************************
+* mvBoardDebugLedNumGet - Get number of debug Leds
+*
+* DESCRIPTION:
+* INPUT:
+*       boardId
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId)
+{
+	return BOARD_INFO(boardId)->activeLedsNumber;
+}
+
+/*******************************************************************************
+* mvBoardDebugLeg - Set the board debug Leds
+*
+* DESCRIPTION: turn on/off status leds.
+* 	       Note: assume MPP leds are part of group 0 only.
+*
+* INPUT:
+*       hexNum - Number to be displied in hex by Leds.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardDebugLed(MV_U32 hexNum)
+{
+	MV_U32 val[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 mask[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 digitMask;
+	MV_U32 i, pinNum, gppGroup;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (BOARD_INFO(boardId)->pLedGppPin == NULL)
+		return;
+
+	hexNum &= (1 << BOARD_INFO(boardId)->activeLedsNumber) - 1;
+
+	for (i = 0, digitMask = 1; i < BOARD_INFO(boardId)->activeLedsNumber; i++, digitMask <<= 1) {
+			pinNum = BOARD_INFO(boardId)->pLedGppPin[i];
+			gppGroup = pinNum / 32;
+			if (hexNum & digitMask)
+				val[gppGroup]  |= (1 << (pinNum - gppGroup * 32));
+			mask[gppGroup] |= (1 << (pinNum - gppGroup * 32));
+	}
+
+	for (gppGroup = 0; gppGroup < MV_GPP_MAX_GROUP; gppGroup++) {
+		/* If at least one bit is set in the mask, update the whole GPP group */
+		if (mask[gppGroup])
+			mvGppValueSet(gppGroup, mask[gppGroup], BOARD_INFO(boardId)->ledsPolarity == 0 ?
+					val[gppGroup] : ~val[gppGroup]);
+	}
+}
+
+/*******************************************************************************
+* mvBoarGpioPinGet - mvBoarGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		gppClass - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
+{
+	MV_U32 boardId, i;
+	MV_U32 indexFound = 0;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardRTCGpioPinGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == gppClass) {
+			if (indexFound == index)
+				return (MV_U32) BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+		}
+	}
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardReset - mvBoardReset
+*
+* DESCRIPTION:
+*			Reset the board
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvBoardReset(MV_VOID)
+{
+	MV_32 resetPin;
+
+	/* Get gpp reset pin if define */
+	resetPin = mvBoardResetGpioPinGet();
+	if (resetPin != MV_ERROR)
+		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
+	else
+	{
+		/* No gpp reset pin was found, try to reset using system reset out */
+		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
+		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
+	}
+}
+
+/*******************************************************************************
+* mvBoardResetGpioPinGet - mvBoardResetGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardResetGpioPinGet(MV_VOID)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_RESET, 0);
+}
+
+/*******************************************************************************
+* mvBoardSDIOGpioPinGet - mvBoardSDIOGpioPinGet
+*
+* DESCRIPTION:
+*	used for hotswap detection
+* INPUT:
+*	type - Type of SDIO GPP to get.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type)
+{
+	if ((type != BOARD_GPP_SDIO_POWER) && (type != BOARD_GPP_SDIO_DETECT) && (type != BOARD_GPP_SDIO_WP))
+		return MV_FAIL;
+
+	return mvBoarGpioPinNumGet(type, 0);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusGpioPinGet - return Vbus input GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS, devId);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusEnGpioPinGet - return Vbus Enable output GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS_EN, devId);
+}
+
+/*******************************************************************************
+* mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
+*
+* DESCRIPTION:
+*		This function returns a 32-bit mask of GPP pins that connected to
+*		interrupt generating sources on board.
+*		For example if UART channel A is hardwired to GPP pin 8 and
+*		UART channel B is hardwired to GPP pin 4 the fuinction will return
+*		the value 0x000000110
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		See description. The function return -1 if board is not identified.
+*
+*******************************************************************************/
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGpioIntMaskGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	switch (gppGrp) {
+	case (0):
+		return BOARD_INFO(boardId)->intsGppMaskLow;
+		break;
+	case (1):
+		return BOARD_INFO(boardId)->intsGppMaskMid;
+		break;
+	case (2):
+		return BOARD_INFO(boardId)->intsGppMaskHigh;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*	MPP settings are derived from board design.
+*	MPP group consist of 8 MPPs. An MPP group represents MPP
+*	control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	MV_U32 boardId;
+	MV_U32 mppMod;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	mppMod = BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod;
+	if (mppMod >= BOARD_INFO(boardId)->numBoardMppConfigValue)
+		mppMod = 0; /* default */
+
+	return BOARD_INFO(boardId)->pBoardMppConfigValue[mppMod].mppGroup[mppGroupNum];
+}
+
+/*******************************************************************************
+* mvBoardGppConfigGet
+*
+* DESCRIPTION:
+*	Get board configuration according to the input configuration GPP's.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The value of the board configuration GPP's.
+*
+*******************************************************************************/
+MV_U32 mvBoardGppConfigGet(void)
+{
+	MV_U32 boardId, i;
+	MV_U32 result = 0;
+	MV_U32 gpp;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGppConfigGet: Board unknown.\n");
+		return 0;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
+			gpp = BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			result <<= 1;
+			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
+		}
+	}
+	return result;
+
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiModeGet - return SLIC/DAA connection
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_32 mvBoardTdmSpiModeGet(MV_VOID)
+{
+	return DUAL_CHIP_SELECT_MODE;
+}
+
+/*******************************************************************************
+* mvBoardTdmDevicesCountGet
+*
+* DESCRIPTION:
+*	Return the number of TDM devices on board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	Number of devices.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmDevicesCountGet(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_16 index;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardTdmDevicesCountGet: Board unknown.\n");
+		return 0;
+	}
+
+	index = BOARD_INFO(boardId)->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	return BOARD_INFO(boardId)->numBoardTdmInfo[index];
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiCsGet
+*
+* DESCRIPTION:
+*	Return the SPI Chip-select number for a given device.
+*
+* INPUT:
+*	devId	- The Slic device ID to get the SPI CS for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The SPI CS if found, -1 otherwise.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_16 index;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardTdmDevicesCountGet: Board unknown.\n");
+		return -1;
+	}
+
+	index = BOARD_INFO(boardId)->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	if (devId >= BOARD_INFO(boardId)->numBoardTdmInfo[index])
+		return -1;
+
+	return BOARD_INFO(boardId)->pBoardTdmInt2CsInfo[index][devId].spiCs;
+}
+
+/*******************************************************************************
+* mvBoardModuleTypePrint
+*
+* DESCRIPTION:
+*	Print on-board detected modules.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
+{
+	mvOsOutput("Modules Detected:\n");
+
+	/* TDM */
+	if (mvBoardTdmDevicesCountGet() > 0)
+		mvOsOutput("       TDM module.\n");
+
+	/* LCD DVI Module */
+	if (mvBoardIsLcdDviModuleConnected())
+		mvOsOutput("       LCD DVI module.\n");
+
+	/* Switch Module */
+	if (mvBoardIsSwitchModuleConnected())
+		mvOsOutput("       Switch module.\n");
+
+	/* GMII Module */
+	if (mvBoardIsGMIIModuleConnected())
+		mvOsOutput("       GMII module.\n");
+
+	return;
+}
+
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
+{
+	/* Pex Module */
+	if (mvBoardIsPexModuleConnected())
+		mvOsOutput("       PEX module.\n");
+	/* SETM Module */
+	if (mvBoardIsSetmModuleConnected())
+		mvOsOutput("       SETM module.\n");
+	/* LVDS Module */
+	if (mvBoardIsLvdsModuleConnected())
+		mvOsOutput("       LVDS module.\n");
+
+	return;
+}
+
+/*******************************************************************************
+* mvBoardIsGbEPortConnected
+*
+* DESCRIPTION:
+*	Checks if a given GbE port is actually connected to the GE-PHY, internal Switch or any RGMII module.
+*
+* INPUT:
+*	port - GbE port number (0 or 1).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_TRUE if port is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum)
+{
+	switch (ethPortNum) {
+	case 0:
+		if (mvBoardIsLcdDviModuleConnected())
+			return MV_FALSE;
+		break;
+	case 1:
+		if (mvBoardIsLcdDviModuleConnected())
+			return MV_FALSE;
+		else if (mvBoardIsGMIIModuleConnected())
+			return MV_FALSE;
+		break;
+	case 2:
+		if (mvBoardIsSetmModuleConnected())
+			return MV_FALSE;
+		if (mvBoardIsPexModuleConnected()) {
+			MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+			if (boardPexInfo->pexUnitCfg[1].pexCfg == PEX_BUS_MODE_X1)
+				return MV_TRUE;
+			return MV_FALSE;
+		}
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+
+	return MV_TRUE;
+}
+
+/* Board devices API managments */
+
+/*******************************************************************************
+* mvBoardGetDeviceNumber - Get number of device of some type on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		number of those devices else the function returns 0
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devNum;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGetDeviceNumber:Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devNum].devClass == devClass)
+			foundIndex++;
+	}
+
+	return foundIndex;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBaseAddr - Get base address of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*	Base address else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinBaseLowGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBusWidth - Get Bus width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		Bus width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->busWidth;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWidth - Get dev width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		dev width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->devWidth;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWinSize - Get the window size of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		window size else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinSizeGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* boardGetDevEntry - returns the entry pointer of a device on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devIndex;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("boardGetDevEntry: Board unknown.\n");
+		return NULL;
+	}
+
+	for (devIndex = START_DEV_CS; devIndex < BOARD_INFO(boardId)->numBoardDeviceIf; devIndex++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devIndex].devClass == devClass) {
+			if (foundIndex == devNum)
+				return &(BOARD_INFO(boardId)->pDevCsInfo[devIndex]);
+			foundIndex++;
+		}
+	}
+
+	/* device not found */
+	return NULL;
+}
+
+/*******************************************************************************
+* boardGetDevCSNum
+*
+* DESCRIPTION:
+*	Return the device's chip-select number.
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->deviceCS;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrTypeGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address type for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address type.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+	}
+	return (MV_ERROR);
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+	}
+	return (0xFF);
+}
+
+/*******************************************************************************
+* mvBoardNandWidthGet -
+*
+* DESCRIPTION: Get the width of the first NAND device in bytes
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: 1, 2, 4 or MV_ERROR
+*
+*
+*******************************************************************************/
+MV_32 mvBoardNandWidthGet(void)
+{
+	MV_U32 devNum;
+	MV_U32 devWidth;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		devWidth = mvBoardGetDeviceWidth(devNum, BOARD_DEV_NAND_FLASH);
+		if (devWidth != MV_ERROR)
+			return (devWidth / 8);
+	}
+
+	/* NAND wasn't found */
+	return MV_ERROR;
+}
+
+MV_U32 gBoardId = -1;
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       This function sets the board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       void
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_VOID)
+{
+	if (gBoardId == -1) {
+#if defined(DB_88F78X60)
+		gBoardId = DB_88F78XX0_BP_ID;
+#elif defined(RD_88F78460_SERVER)
+		gBoardId = RD_78460_SERVER_ID;
+#elif defined(RD_78460_SERVER_REV2)
+		gBoardId = RD_78460_SERVER_REV2_ID;
+#elif defined(DB_78X60_PCAC)
+		gBoardId = DB_78X60_PCAC_ID;
+#elif defined(DB_88F78X60_REV2)
+		gBoardId = DB_88F78XX0_BP_REV2_ID;
+#elif defined(RD_78460_NAS)
+		gBoardId = RD_78460_NAS_ID;
+#elif defined(DB_78X60_AMC)
+		gBoardId = DB_78X60_AMC_ID;
+#elif defined(DB_78X60_PCAC_REV2)
+		gBoardId = DB_78X60_PCAC_REV2_ID;
+#elif defined(DB_784MP_GP)
+		gBoardId = DB_784MP_GP_ID;
+#elif defined(RD_78460_CUSTOMER)
+		gBoardId = RD_78460_CUSTOMER_ID;
+#else
+		mvOsPrintf("mvBoardIdSet: Board ID must be defined!\n");
+		while (1) {
+			continue;
+		}
+#endif
+	}
+}
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	if (gBoardId == -1) {
+		mvOsWarning();
+		return INVALID_BAORD_ID;
+	}
+
+	return gBoardId;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U8 data;
+
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.validOffset = MV_TRUE;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, &data, 1)) {
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+
+	return data;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB1(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* SatR Configuration functions
+*******************************************************************************/
+MV_U8 mvBoardFabFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+	MV_U8 sar1;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	if (DB_784MP_GP_ID == boardId)
+		return (sar0 & 0x1f);
+
+	sar1 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar1)
+		return MV_ERROR;
+
+	return ( ((sar1 & 0x1) << 4) | ((sar0 & 0x1E) >> 1) );
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+	if (DB_784MP_GP_ID == boardId) {
+		sar0 &= ~(0x1F);
+		sar0 |= (freqVal & 0x1F);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+			DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+			return MV_ERROR;
+		}
+		return MV_OK;
+	}
+
+	sar0 &= ~(0xF << 1);
+	sar0 |= (freqVal & 0xF) << 1;
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	sar0 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0x1);
+	sar0 |= ( (freqVal >> 4) & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuFreqGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U8 sarMsb;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (DB_784MP_GP_ID == boardId) {
+		return (sar & 0x0f);
+	}
+
+	sarMsb = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (  ((sarMsb & 0x1) << 3) | ((sar & 0x1C) >> 2));
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	if (DB_784MP_GP_ID == boardId) {
+		sar &= ~0x0f;
+		sar |= (freqVal & 0x0f);
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+	}
+	else{
+		sar &= ~(0x7 << 2);
+		sar |= (freqVal & 0x7) << 2;
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+		sar = mvBoardTwsiSatRGet(2, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &= ~(0x1);
+		sar |= ( (freqVal >> 3) & 0x1);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+
+		sar = mvBoardTwsiSatRGet(2, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+
+		sar &= ~(0x1);
+		sar |= ( (freqVal >> 3) & 0x1);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+	}
+
+	DB(mvOsPrintf("Board: Write CpuFreq S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardBootDevGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		sar = (sar >> 1);
+
+	return (sar & 0x7);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardBootDevSet(MV_U8 val)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	if (DB_784MP_GP_ID == boardId) {
+		sar &= ~(0x7 << 1);
+		sar |= ((val & 0x7) << 1);
+	}
+	else {
+		sar &= ~(0x7);
+		sar |= (val & 0x7);
+	}
+	if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write BootDev S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDev S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardBootDevWidthGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (DB_784MP_GP_ID == boardId) 
+		return (sar & 1);
+
+	return (sar & 0x18) >> 3;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (DB_784MP_GP_ID == boardId) {
+		sar &= ~(1);
+		sar |= (val & 0x1);
+	}
+	else {
+		sar &= ~(0x3 << 3);
+		sar |= ((val & 0x3) << 3);
+	}
+
+	if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write BootDevWidth S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDevWidth S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID)
+{
+	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return 0;
+
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	return (sar & 0x08) >> 3;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val)
+{
+	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return MV_OK;
+
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	sar &= ~(0x1 << 3);
+	sar |= ((val & 0x1) << 3);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write Cpu0CoreMode S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write Cpu0CoreMode S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardL2SizeGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+	if (DB_784MP_GP_ID == boardId) {
+		sar = mvBoardTwsiSatRGet(0, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		return (((sar & 0x10)>>3)+ 1);
+	}
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x3);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardL2SizeSet(MV_U8 val)
+{
+	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(0, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &= ~(0x1 << 4);
+		sar |= ((val & 0x2) << 3);
+		if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write L2Size S@R fail\n"));
+			return MV_ERROR;
+		}
+		return MV_OK;
+	}
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3);
+	sar |= (val & 0x3);
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write L2Size S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write L2Size S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(1, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &=0x10;
+		return (1+(sar >>3));
+	}
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar = (sar & 0x6) >> 1;
+	if (sar == 1)
+		sar = 2;
+	else if (sar == 2)
+		sar =1;
+	return sar;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val)
+{
+	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(1, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &=~0x10;
+		val &= 2;
+		sar |= (val<<3);
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuCoreNum S@R fail\n"));
+			return MV_ERROR;
+		}
+		DB(mvOsPrintf("Board: Write CpuCoreNum S@R succeeded\n"));
+		return MV_OK;
+	}
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	/* MSB and LSB are swapped on DB board */
+	if (val == 1)
+		val = 2;
+	else if (val == 2)
+		val =1;
+
+	sar &= ~(0x3 << 1);
+	sar |= ((val & 0x3) << 1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write CpuCoreNum S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write CpuCoreNum S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardConfIdSet(MV_U16 conf)
+{
+	if (MV_OK != mvBoardTwsiSatRSet(0, 1, conf)) {
+		DB1(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardConfIdGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0xFF);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= (conf & 0x1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(1, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U16 gPexCap = 0;
+MV_U16 mvBoardPexCapabilityGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId;
+
+	if (gPexCap)
+		return gPexCap;
+
+	boardId = mvBoardIdGet();
+	switch (boardId) {
+	case DB_78X60_PCAC_ID:
+	case RD_78460_NAS_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_AMC_ID:
+	case DB_78X60_PCAC_REV2_ID:
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+		sar = 0x1; /* Gen2 */
+		break;
+	case DB_784MP_GP_ID:
+	case DB_88F78XX0_BP_ID:
+	case FPGA_88F78XX0_ID:
+	case DB_88F78XX0_BP_REV2_ID:
+	default:
+		sar = mvBoardTwsiSatRGet(1, 1);
+		break;
+	}
+	gPexCap = sar & 0x1;
+	
+	return (gPexCap);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardPexModeSet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3 << 1);
+	sar |= ((conf & 0x3) << 1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(1, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U16 mvBoardPexModeGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x6) >> 1;
+
+}
+/*******************************************************************************/
+MV_STATUS mvBoardDramEccSet(MV_U16 ecc)
+{
+	MV_U8 sar;
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x2);
+	sar |= ((ecc & 0x1) << 1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(devNum, 1, sar)) {
+		DB(mvOsPrintf("Board: Write eccID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write eccID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardDramEccGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
+	return ((sar & 0x2) >> 1);
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 dramBusWidth)
+{
+	MV_U8 sar;
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= (dramBusWidth & 0x1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(devNum, 1, sar)) {
+		DB(mvOsPrintf("Board: Write dramBusWidthID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write dramBusWidthID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardDramBusWidthGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
+	return (sar & 0x1);
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardAltFabFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return 5;
+
+	sar0 = mvBoardTwsiSatRGet(2, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	return (sar0 & 0x1F);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal)
+{
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return MV_OK;
+
+	if (MV_OK != mvBoardTwsiSatRSet(2, 1, freqVal)) {
+		DB1(mvOsPrintf("Board: Write Alt FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write Alt FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************
+* End of SatR Configuration functions
+*******************************************************************************/
+
+/*******************************************************************************
+* mvBoardMppModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through MPP lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardMppModulesScan(void)
+{
+	MV_U8 regVal;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* Perform scan only for DB board */
+	if ( (boardId == DB_88F78XX0_BP_ID) || (boardId == DB_88F78XX0_BP_REV2_ID) ) {
+		twsiSlave.slaveAddr.address = MV_BOARD_MPP_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_MPP_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			switch (regVal) {
+			case MV_BOARD_LCD_DVI_MODULE_ID:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_LCD_DVI;
+				return MV_OK;
+
+			case MV_BOARD_MII_GMII_MODULE_ID:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_MII_GMII;
+			    BOARD_INFO(boardId)->pBoardMacInfo[0].boardEthSmiAddr = 0x8;
+
+				return MV_OK;
+
+			case MV_BOARD_TDM_MODULE_ID:
+				/*
+				   TODO - how to distinguish between SLIC types?
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_3215;
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_880;
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_792;
+				   return MV_OK;
+				 */
+				BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_OTHER;
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_TDM_32CH;
+				return MV_OK;
+
+			default:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_OTHER;
+				DB1(mvOsPrintf("mvBoardMppModulesScan: Unsupported module!\n"));
+				break;
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardOtherModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through SERDES/LVDS/... lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardOtherModulesScan(void)
+{
+	MV_U8 regVal;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* Perform scan only for DB board */
+	if ( (boardId == DB_88F78XX0_BP_ID) || (boardId == DB_88F78XX0_BP_REV2_ID) ) {
+		/* reset modules flags */
+		BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_NONE;
+
+        /* TWSI init */
+        slave.type = ADDR7_BIT;
+        slave.address = 0;
+        mvTwsiInit(0, TWSI_SPEED , mvBoardTclkGet(), &slave, 0);
+
+ 		/* SERDES module (PEX module and SETM module are supported now) */
+		twsiSlave.slaveAddr.address = MV_BOARD_PEX_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_PEX_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_PEX_MODULE_ID) {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "PEX module DETECTED!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_PEX;
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ PEX module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+
+		/* SERDES module (PEX module and SETM module are supported now) */
+		twsiSlave.slaveAddr.address = MV_BOARD_SETM_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_SETM_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_SETM_MODULE_ID) {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "SETM module DETECTED!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_SETM;
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ PEX module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+
+		/* LVDS (LCD) module */
+		twsiSlave.slaveAddr.address = MV_BOARD_LVDS_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_LVDS_MODULE_ADDR_TYPE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_LVDS_MODULE_ID) {
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_LVDS;
+				mvCpuIfLvdsPadsEnable(MV_TRUE);
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ LVDS module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+	} else if (boardId == RD_78460_NAS_ID) {
+		if ((MV_REG_READ(GPP_DATA_IN_REG(2)) & MV_GPP66) == 0x0) {
+			DB(mvOsPrintf("mvBoardOtherModulesScan: SWITCH module DETECTED!\n"));
+			BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_SWITCH;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPexModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsPexModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_PEX)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsSetmModuleConnected
+*
+* DESCRIPTION:
+*	Check if SETM module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSetmModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsSetmModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_SETM)
+		return MV_TRUE;
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSwitchModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (boardId != RD_78460_NAS_ID)
+		DB(mvOsPrintf("mvBoardIsSwitchModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_SWITCH)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLvdsModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLvdsModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsLvdsModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_LVDS)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLcdDviModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLcdDviModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsLcdDviModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod == MV_BOARD_LCD_DVI)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+
+/*******************************************************************************
+* mvBoardIsGMIIModuleConnected
+*
+* DESCRIPTION:
+*	Check if GMII module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGMIIModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsGMIIModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod == MV_BOARD_MII_GMII)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTwsiMuxChannelSet
+*
+* DESCRIPTION:
+*	Set the channel number of the on-board TWSI mux.
+*
+* INPUT:
+*	chNum	- The channel number to set.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum)
+{
+	static MV_U8 currChNum = 0xFF;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	if (currChNum == muxChNum)
+		return MV_OK;
+
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_TWSI_MUX, 0);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_TWSI_MUX, 0);
+	twsiSlave.validOffset = 0;
+	twsiSlave.offset = 0;
+	twsiSlave.moreThen256 = MV_FALSE;
+	muxChNum += 4;
+	return mvTwsiWrite(0, &twsiSlave, &muxChNum, 1);
+}
+
+/*******************************************************************************
+* mvBoardTwsiReadByteThruMux
+*
+* DESCRIPTION:
+*	Read a single byte from a TWSI device through the TWSI Mux.
+*
+* INPUT:
+*	muxChNum	- The Twsi Mux channel number to read through.
+*	chNum		- The TWSI channel number.
+*	pTwsiSlave	- The TWSI slave address.
+*	data		- Buffer to read into (1 byte).
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data)
+{
+	MV_STATUS res;
+
+	/* Set Mux channel */
+	res = mvBoardTwsiMuxChannelSet(muxChNum);
+	if (res == MV_OK)
+		res = mvTwsiRead(chNum, pTwsiSlave, data, 1);
+
+	return res;
+}
+
+/*******************************************************************************
+* mvBoardSerdesZ1ASupport - Support Z1A silicon serdes configuration
+*
+* DESCRIPTION:
+* 	Default is fixed silicone Z1B. This routine should be called before
+*       calling the serdes initialization in ctrlEnvinit
+*
+* INPUT:
+*	None.
+* OUTPUT:
+*       None.
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_VOID mvBoardSerdesZ1ASupport(void)
+{
+	gSerdesZ1AMode = 1;
+}
+
+/*******************************************************************************
+* mvBoardSmiScanModeGet - Get Switch SMI scan mode
+*
+* DESCRIPTION:
+*       This routine returns Switch SMI scan mode.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 for SMI_MANUAL_MODE, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardSmiScanModeGet: Board unknown.\n");
+		return -1;
+	}
+
+	return BOARD_INFO(boardId)->pSwitchInfo[switchIdx].smiScanMode;
+}
+/*******************************************************************************
+* mvBoardSledCpuNumGet - Get board SERDES configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_U32 mvBoardSledCpuNumGet(MV_VOID)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(GPP_DATA_IN_REG(0));
+
+	return ((reg & 0xF0000) >> 16);
+}
+
+/*******************************************************************************
+* mvBoardPexInfoGet - Get board PEX Info
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*******************************************************************************/
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	switch (boardId) {
+	case DB_88F78XX0_BP_ID:
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+	case DB_78X60_PCAC_ID:
+	case FPGA_88F78XX0_ID:
+	case DB_88F78XX0_BP_REV2_ID:
+	case RD_78460_NAS_ID:
+	case DB_784MP_GP_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_AMC_ID:
+	case DB_78X60_PCAC_REV2_ID:
+		return &BOARD_INFO(boardId)->boardPexInfo;
+		break;
+	default:
+		DB(mvOsPrintf("mvBoardSerdesCfgGet: Unsupported board!\n"));
+		return NULL;
+	}
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
new file mode 100755
index 0000000..6fba9f0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,457 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+/* DUART stuff for Tclk detection only */
+#define DUART_BAUD_RATE			115200
+#define MAX_CLOCK_MARGINE		5000000	/* Maximum detected clock margine */
+
+/* Voice devices assembly modes */
+#define DAISY_CHAIN_MODE		1
+#define DUAL_CHIP_SELECT_MODE	0
+#define INTERRUPT_TO_MPP		1
+#define INTERRUPT_TO_TDM		0
+
+/*
+#define BOARD_ETH_PORT_NUM		MV_ETH_MAX_PORTS
+*/
+#define BOARD_ETH_SWITCH_PORT_NUM	5
+#define	MV_BOARD_MAX_USB_IF		3
+#define MV_BOARD_MAX_MPP		9	/* number of MPP conf registers */
+#define MV_BOARD_NAME_LEN  		0x20
+
+/* EPPROM Modules detection information */
+
+#define MV_BOARD_EEPROM_MODULE_ADDR		0x50
+#define MV_BOARD_EEPROM_MODULE_ADDR_TYPE	ADDR7_BIT
+
+#define MV_BOARD_PEX_MODULE_ADDR		0x23
+#define MV_BOARD_PEX_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_PEX_MODULE_ID			0
+
+#define MV_BOARD_LVDS_MODULE_ADDR		0x21
+#define MV_BOARD_LVDS_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LVDS_MODULE_ID			0
+
+#define MV_BOARD_SETM_MODULE_ADDR		0x23
+#define MV_BOARD_SETM_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_SETM_MODULE_ID			1
+
+#define MV_BOARD_MPP_MODULE_ADDR		0x20
+#define MV_BOARD_MPP_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LCD_DVI_MODULE_ID		0
+#define MV_BOARD_TDM_MODULE_ID			1
+#define MV_BOARD_MII_GMII_MODULE_ID		4
+
+typedef enum {
+	BOARD_EPON_CONFIG,
+	BOARD_GPON_CONFIG,
+	BOARD_PON_NONE,
+	BOARD_PON_AUTO
+} MV_BOARD_PON_CONFIG;
+
+typedef struct _boardData {
+	MV_U32 magic;
+	MV_U16 boardId;
+	MV_U8 boardVer;
+	MV_U8 boardRev;
+	MV_U32 reserved1;
+	MV_U32 reserved2;
+} BOARD_DATA;
+
+typedef enum _devBoardMppGroupClass {
+	MV_BOARD_MPP_GROUP_1,
+	MV_BOARD_MPP_GROUP_2,
+	MV_BOARD_MPP_GROUP_3,
+	MV_BOARD_MAX_MPP_GROUP
+} MV_BOARD_MPP_GROUP_CLASS;
+
+typedef enum _devBoardMppTypeClass {
+	MV_BOARD_AUTO = 0,
+	MV_BOARD_TDM_32CH,
+	MV_BOARD_LCD_DVI,
+	MV_BOARD_MII_GMII,
+	MV_BOARD_OTHER
+} MV_BOARD_MPP_TYPE_CLASS;
+
+typedef enum _devBoardOtherTypeClass {
+	MV_BOARD_NONE    = 0x00000000,
+	MV_BOARD_LVDS    = 0x00000001,
+	MV_BOARD_PEX     = 0x00000002,
+	MV_BOARD_SWITCH  = 0x00000004,
+	MV_BOARD_SETM 	 = 0x00000008,
+	MV_BOARD_UNKNOWN = 0x80000000
+} MV_BOARD_OTHER_TYPE_CLASS;
+
+
+#define MV_BOARD_TDM	MV_BOARD_TDM_32CH
+
+typedef struct _boardModuleTypeInfo {
+	MV_BOARD_MPP_TYPE_CLASS boardMppMod;
+	MV_BOARD_OTHER_TYPE_CLASS boardOtherMod;
+} MV_BOARD_MODULE_TYPE_INFO;
+
+typedef enum _devBoardClass {
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER
+} MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass {
+	BOARD_TWSI_RTC,
+	BOARD_DEV_TWSI_EXP,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_TWSI_MUX,
+	BOARD_TWSI_OTHER
+} MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass {
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+	BOARD_GPP_SDIO_POWER,
+	BOARD_GPP_SDIO_DETECT,
+	BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_CONF,
+	BOARD_GPP_OTHER
+} MV_BOARD_GPP_CLASS;
+
+typedef struct _devCsInfo {
+	MV_U8 deviceCS;
+	MV_U32 params;
+	MV_U32 devClass;	/* MV_BOARD_DEV_CLASS */
+	MV_U8 devWidth;
+	MV_U8 busWidth;
+} MV_DEV_CS_INFO;
+
+typedef struct _boardSwitchInfo {
+	MV_32 switchIrq;
+	MV_32 switchPort[BOARD_ETH_SWITCH_PORT_NUM];
+	MV_32 cpuPort;
+	MV_32 connectedPort[MV_ETH_MAX_PORTS];
+	MV_32 smiScanMode;
+	MV_32 quadPhyAddr;
+	MV_U32 forceLinkMask; /* Bitmask of switch ports to have force link (1Gbps) */
+} MV_BOARD_SWITCH_INFO;
+typedef struct _boardLedInfo {
+	MV_U8 activeLedsNumber;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+	MV_U8 *gppPinNum;	/* Pointer to GPP values */
+} MV_BOARD_LED_INFO;
+
+typedef struct _boardGppInfo {
+	MV_BOARD_GPP_CLASS devClass;
+	MV_U8 gppPinNum;
+} MV_BOARD_GPP_INFO;
+
+typedef struct _boardTwsiInfo {
+	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 twsiDevAddr;
+	MV_U8 twsiDevAddrType;
+} MV_BOARD_TWSI_INFO;
+
+typedef enum _boardMacSpeed {
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO
+} MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo {
+	MV_BOARD_MAC_SPEED boardMacSpeed;
+	MV_U8	boardEthSmiAddr;
+	MV_U16	LinkCryptPortAddr;
+	MV_U8	boardEthSmiAddr0;
+} MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo {
+	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
+} MV_BOARD_MPP_INFO;
+
+typedef struct {
+	MV_U8 spiCs;
+} MV_BOARD_TDM_INFO;
+
+typedef struct _boardPexUnitCfg {
+	MV_PEX_UNIT_CFG 	pexCfg;
+	MV_U8			pexLaneStat[4];	/* 1: enabled, 2: disabled */
+} MV_BOARD_PEX_UNIT_CFG;
+
+typedef struct _boardPexInfo {
+	MV_PEXIF_INDX 		pexMapping[MV_PEX_MAX_IF];
+	MV_BOARD_PEX_UNIT_CFG 	pexUnitCfg[MV_PEX_MAX_UNIT];
+	MV_U32			boardPexIfNum;
+} MV_BOARD_PEX_INFO;
+
+typedef enum {
+	BOARD_TDM_SLIC_880 = 0,
+	BOARD_TDM_SLIC_792,
+	BOARD_TDM_SLIC_3215,
+	BOARD_TDM_SLIC_OTHER,
+	BOARD_TDM_SLIC_COUNT
+} MV_BOARD_TDM_SLIC_TYPE;
+
+typedef struct _boardInfo {
+	char boardName[MV_BOARD_NAME_LEN];
+	MV_U8 numBoardMppTypeValue;
+	MV_BOARD_MODULE_TYPE_INFO *pBoardModTypeValue;
+	MV_U8 numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO *pBoardMppConfigValue;
+	MV_U32 intsGppMaskLow;
+	MV_U32 intsGppMaskMid;
+	MV_U32 intsGppMaskHigh;
+	MV_U8 numBoardDeviceIf;
+	MV_DEV_CS_INFO *pDevCsInfo;
+	MV_U8 numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
+	MV_U8 numBoardMacInfo;
+	MV_BOARD_MAC_INFO *pBoardMacInfo;
+	MV_U8 numBoardGppInfo;
+	MV_BOARD_GPP_INFO *pBoardGppInfo;
+	MV_U8 activeLedsNumber;
+	MV_U8 *pLedGppPin;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+
+	MV_U8	pmuPwrUpPolarity;
+	MV_U32	pmuPwrUpDelay;
+	/* GPP values */
+	MV_U32 gppOutEnValLow;
+	MV_U32 gppOutEnValMid;
+	MV_U32 gppOutEnValHigh;
+	MV_U32 gppOutValLow;
+	MV_U32 gppOutValMid;
+	MV_U32 gppOutValHigh;
+	MV_U32 gppPolarityValLow;
+	MV_U32 gppPolarityValMid;
+	MV_U32 gppPolarityValHigh;
+
+	/* External Switch Configuration */
+	MV_BOARD_SWITCH_INFO *pSwitchInfo;
+	MV_U32 switchInfoNum;
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	 */
+	MV_U8 numBoardTdmInfo[BOARD_TDM_SLIC_COUNT];
+	MV_BOARD_TDM_INFO *pBoardTdmInt2CsInfo[BOARD_TDM_SLIC_COUNT];
+	MV_16 boardTdmInfoIndex;
+
+	/* NAND init params */
+	MV_U32 nandFlashReadParams;
+	MV_U32 nandFlashWriteParams;
+	MV_U32 nandFlashControl;
+	MV_BOARD_PEX_INFO	boardPexInfo;	/* filled in runtime */
+	MV_U32 norFlashReadParams;
+	MV_U32 norFlashWriteParams;
+
+} MV_BOARD_INFO;
+
+/* For backward compatability with Legacy mode */
+#define mvBoardSwitchConnectedPortGet(port)	(-1)
+#define mvBoardIsSwitchConnected(port)  	(mvBoardSwitchConnectedPortGet(port) != -1)
+/*#define mvBoardLinkStatusIrqGet(port)		mvBoardSwitchIrqGet()*/
+
+MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U16 mvBoardModelGet(MV_VOID);
+MV_U16 mvBoardRevGet(MV_VOID);
+MV_STATUS mvBoardNameGet(char *pNameBuff);
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum);
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+
+MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum);
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
+MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
+MV_BOOL mvBoardSpecInitGet(MV_U32 *regOff, MV_U32 *data);
+MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardSysClkGet(MV_VOID);
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
+MV_VOID mvBoardDebugLed(MV_U32 hexNum);
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+MV_VOID mvBoardReset(MV_VOID);
+MV_32 mvBoardResetGpioPinGet(MV_VOID);
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type);
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId);
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId);
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
+MV_U32 mvBoardGppConfigGet(void);
+MV_32 mvBoardTdmSpiModeGet(MV_VOID);
+MV_U8 mvBoardTdmDevicesCountGet(void);
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_32 mvBoardNandWidthGet(void);
+MV_U32 mvBoardIdGet(MV_VOID);
+MV_VOID mvBoardIdSet(MV_VOID);
+MV_U32 mvBoardSledCpuNumGet(MV_VOID);
+
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum);
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U8 mvBoardFabFreqGet(MV_VOID);
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
+MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal);
+MV_U8 mvBoardBootDevGet(MV_VOID);
+MV_STATUS mvBoardBootDevSet(MV_U8 val);
+MV_U8 mvBoardBootDevWidthGet(MV_VOID);
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val);
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID);
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val);
+MV_U8 mvBoardL2SizeGet(MV_VOID);
+MV_STATUS mvBoardL2SizeSet(MV_U8 val);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
+MV_STATUS mvBoardConIdSet(MV_U16 conf);
+MV_U16 mvBoardConfIdGet(MV_VOID);
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf);
+MV_U16 mvBoardPexCapabilityGet(MV_VOID);
+MV_STATUS mvBoardDramEccSet(MV_U16 conf);
+MV_U16 mvBoardDramEccGet(MV_VOID);
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf);
+MV_U16 mvBoardDramBusWidthGet(MV_VOID);
+MV_U8 mvBoardAltFabFreqGet(MV_VOID);
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal);
+MV_STATUS mvBoardMppModulesScan(void);
+MV_STATUS mvBoardOtherModulesScan(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_BOOL mvBoardIsSwitchModuleConnected(void);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_BOOL mvBoardIsGMIIModuleConnected(void);
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_VOID mvBoardSerdesZ1ASupport(void);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
+MV_STATUS mvBoardConfIdSet(MV_U16 conf);
+MV_U16 mvBoardPexModeGet(MV_VOID);
+MV_STATUS mvBoardPexModeSet(MV_U16 conf);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
new file mode 100755
index 0000000..126240d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,1431 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPexRegs.h"
+
+#define ARRSZ(x)	(sizeof(x)/sizeof(x[0]))
+
+/**********************/
+/* ARMADA-XP DB BOARD */
+/**********************/
+#define DB_88F78XX0_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_88F78XX0_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_88F78XX0_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_88F78XX0_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F78XX0_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_U8 mvDbDisableModuleDetection = 0;
+
+MV_U8	db88f6781InfoBoardDebugLedIf[] = {26, 27, 48};
+
+MV_BOARD_TWSI_INFO	db88f78XX0InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db88f78XX0InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0, 0x0,},
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0, 0x1,},
+	{BOARD_MAC_SPEED_AUTO, 0x19,0x800 , 0x18},  /* Port 1 */
+	{BOARD_MAC_SPEED_AUTO, 0x1B,0x1800, 0x18}  /* Port 3 */
+};
+
+MV_BOARD_MODULE_TYPE_INFO db88f78XX0InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db88f78XX0InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24}, /* from MPP map */
+	{BOARD_GPP_RESET,       47},
+};
+
+MV_DEV_CS_INFO db88f78XX0InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db88f78XX0InfoBoardMppConfigValue[] = {
+	{ {
+	DB_88F78XX0_MPP0_7,
+	DB_88F78XX0_MPP8_15,
+	DB_88F78XX0_MPP16_23,
+	DB_88F78XX0_MPP24_31,
+	DB_88F78XX0_MPP32_39,
+	DB_88F78XX0_MPP40_47,
+	DB_88F78XX0_MPP48_55,
+	DB_88F78XX0_MPP56_63,
+	DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_TDM_32CH */
+		DB_88F78XX0_MPP0_7,
+		DB_88F78XX0_MPP8_15,
+		DB_88F78XX0_MPP16_23,
+		(DB_88F78XX0_MPP24_31 & 0x00000000) | 0x33333333,
+		(DB_88F78XX0_MPP32_39 & 0xFFFF0000) | 0x00003333,
+		(DB_88F78XX0_MPP40_47 & 0xFFFFF0FF) | 0x00000300,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_LCD_DVI */
+		(DB_88F78XX0_MPP0_7   & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP8_15  & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP16_23 & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP24_31 & 0xFFFF0000) | 0x00004444,
+		DB_88F78XX0_MPP32_39,
+		(DB_88F78XX0_MPP40_47 & 0xFFFFFF00) | 0x00000044,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_MII_GMII */
+		(DB_88F78XX0_MPP0_7 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_MPP8_15 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_MPP16_23 & 0x000000FF) | 0x11111100,
+		DB_88F78XX0_MPP24_31,
+		DB_88F78XX0_MPP32_39,
+		DB_88F78XX0_MPP40_47,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_OTHER */
+		DB_88F78XX0_MPP0_7,
+		DB_88F78XX0_MPP8_15,
+		DB_88F78XX0_MPP16_23,
+		DB_88F78XX0_MPP24_31,
+		DB_88F78XX0_MPP32_39,
+		DB_88F78XX0_MPP40_47,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+};
+
+MV_BOARD_TDM_INFO	db88f78XX0Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	db88f78XX0Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db88f78XX0Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO db88f78XX0Info = {
+	.boardName			= "DB-78460-BP",
+	.numBoardMppTypeValue		= ARRSZ(db88f78XX0InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f78XX0InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db88f78XX0InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db88f78XX0InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db88f78XX0InfoBoardDeCsInfo),
+	.pDevCsInfo			= db88f78XX0InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f78XX0InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f78XX0InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f78XX0InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f78XX0InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db88f78XX0InfoBoardGppInfo),
+	.pBoardGppInfo			= db88f78XX0InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db88f6781InfoBoardDebugLedIf),
+	.pLedGppPin			= db88f6781InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_88F78XX0_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F78XX0_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F78XX0_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F78XX0_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F78XX0_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F78XX0_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F78XX0_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F78XX0_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F78XX0_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db88f78XX0Tdm880,
+					   db88f78XX0Tdm792,
+					   db88f78XX0Tdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_88F78XX0_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F78XX0_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_88F78XX0_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= DB_88F78XX0_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_88F78XX0_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP DB REV2 BOARD */
+/***************************/
+#define DB_88F78XX0_REV2_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_88F78XX0_REV2_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_88F78XX0_REV2_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_88F78XX0_REV2_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F78XX0_REV2_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_U8 mvDbDisableModuleDetection_rev2 = 0;
+
+MV_U8	db88f6781InfoBoardDebugLedIf_rev2[] = {26, 27, 48};
+
+MV_BOARD_TWSI_INFO	db88f78XX0rev2InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db88f78XX0rev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0 	  , 0x0 },
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0	  , 0x1 },
+	{BOARD_MAC_SPEED_AUTO, 0x19,0x800 , 0x18},  /* Port 1 */
+	{BOARD_MAC_SPEED_AUTO, 0x1B,0x1800, 0x18}  /* Port 3 */
+};
+
+MV_BOARD_MODULE_TYPE_INFO db88f78XX0rev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db88f78XX0rev2InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+	/*{BOARD_GPP_RESET,       47},*/
+};
+
+MV_DEV_CS_INFO db88f78XX0rev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db88f78XX0rev2InfoBoardMppConfigValue[] = {
+	{ {
+	DB_88F78XX0_REV2_MPP0_7,
+	DB_88F78XX0_REV2_MPP8_15,
+	DB_88F78XX0_REV2_MPP16_23,
+	DB_88F78XX0_REV2_MPP24_31,
+	DB_88F78XX0_REV2_MPP32_39,
+	DB_88F78XX0_REV2_MPP40_47,
+	DB_88F78XX0_REV2_MPP48_55,
+	DB_88F78XX0_REV2_MPP56_63,
+	DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_TDM_32CH */
+		DB_88F78XX0_REV2_MPP0_7,
+		DB_88F78XX0_REV2_MPP8_15,
+		DB_88F78XX0_REV2_MPP16_23,
+		(DB_88F78XX0_REV2_MPP24_31 & 0x00000000) | 0x33333333,
+		(DB_88F78XX0_REV2_MPP32_39 & 0xFFFF0000) | 0x00003333,
+		(DB_88F78XX0_REV2_MPP40_47 & 0xFFFFF0FF) | 0x00000300,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_LCD_DVI */
+		(DB_88F78XX0_REV2_MPP0_7   & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP8_15  & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP16_23 & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP24_31 & 0xFFFF0000) | 0x00004444,
+		DB_88F78XX0_REV2_MPP32_39,
+		(DB_88F78XX0_REV2_MPP40_47 & 0xFFFFFF00) | 0x00000044,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_MII_GMII */
+		(DB_88F78XX0_REV2_MPP0_7 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_REV2_MPP8_15 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_REV2_MPP16_23 & 0x000000FF) | 0x11111100,
+		DB_88F78XX0_REV2_MPP24_31,
+		DB_88F78XX0_REV2_MPP32_39,
+		DB_88F78XX0_REV2_MPP40_47,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_OTHER */
+		DB_88F78XX0_REV2_MPP0_7,
+		DB_88F78XX0_REV2_MPP8_15,
+		DB_88F78XX0_REV2_MPP16_23,
+		DB_88F78XX0_REV2_MPP24_31,
+		DB_88F78XX0_REV2_MPP32_39,
+		DB_88F78XX0_REV2_MPP40_47,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+};
+
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO db88f78XX0rev2Info = {
+	.boardName			= "DB-78460-BP rev 2.0",
+	.numBoardMppTypeValue		= ARRSZ(db88f78XX0rev2InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f78XX0rev2InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db88f78XX0rev2InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db88f78XX0rev2InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db88f78XX0rev2InfoBoardDeCsInfo),
+	.pDevCsInfo			= db88f78XX0rev2InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f78XX0rev2InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f78XX0rev2InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f78XX0rev2InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f78XX0rev2InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db88f78XX0rev2InfoBoardGppInfo),
+	.pBoardGppInfo			= db88f78XX0rev2InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db88f6781InfoBoardDebugLedIf),
+	.pLedGppPin			= db88f6781InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_88F78XX0_REV2_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F78XX0_REV2_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F78XX0_REV2_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F78XX0_REV2_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F78XX0_REV2_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F78XX0_REV2_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F78XX0_REV2_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F78XX0_REV2_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F78XX0_REV2_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db88f78XX0rev2Tdm880,
+					   db88f78XX0rev2Tdm792,
+					   db88f78XX0rev2Tdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_88F78XX0_REV2_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F78XX0_REV2_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_88F78XX0_REV2_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= DB_88F78XX0_REV2_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_88F78XX0_REV2_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP RD NAS  BOARD */
+/***************************/
+#define RD_78460_NAS_BOARD_NAND_READ_PARAMS	0x000C0282
+#define RD_78460_NAS_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_NAS_BOARD_NAND_CONTROL		0x01c00543
+
+#define RD_78460_NAS_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define RD_78460_NAS_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_MAC_INFO rd78460nasInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+        /* speed will toggle to force link 1000 when SW module detected */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x0, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x0, 0x10}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460nasInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO rd78460nasInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460nasInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460nasInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_NAS_MPP0_7,
+	RD_78460_NAS_MPP8_15,
+	RD_78460_NAS_MPP16_23,
+	RD_78460_NAS_MPP24_31,
+	RD_78460_NAS_MPP32_39,
+	RD_78460_NAS_MPP40_47,
+	RD_78460_NAS_MPP48_55,
+	RD_78460_NAS_MPP56_63,
+	RD_78460_NAS_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO rd78460nasInfo = {
+	.boardName			= "RD-AXP-NAS rev 1.0",
+	.numBoardMppTypeValue		= ARRSZ(rd78460nasInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460nasInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460nasInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460nasInfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460nasInfoBoardDeCsInfo),
+	.pDevCsInfo			= rd78460nasInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(rd78460nasInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460nasInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460nasInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460nasInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_NAS_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_NAS_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_NAS_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_NAS_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_NAS_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_NAS_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_NAS_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_NAS_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_NAS_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_NAS_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_NAS_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_NAS_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_NAS_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_NAS_BOARD_NOR_WRITE_PARAMS
+};
+
+/*****************************/
+/* ARMADA-XP RD SERVER BOARD */
+/*****************************/
+#define RD_78460_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_BOARD_NAND_CONTROL			0x01c00543
+
+MV_BOARD_MAC_INFO rd78460InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_1000M, 0x1, 0x0, 0x1},
+	{BOARD_MAC_SPEED_1000M, 0x2, 0x0, 0x2},
+	{BOARD_MAC_SPEED_AUTO,  0x0, 0x0, 0x0},
+	{BOARD_MAC_SPEED_1000M, 0x1B,0x0,0x18}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_DEV_CS_INFO rd78460InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460InfoBoardMppConfigValue[] = {
+	{ {
+		RD_78460_MPP0_7,
+		RD_78460_MPP8_15,
+		RD_78460_MPP16_23,
+		RD_78460_MPP24_31,
+		RD_78460_MPP32_39,
+		RD_78460_MPP40_47,
+		RD_78460_MPP48_55,
+		RD_78460_MPP56_63,
+		RD_78460_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO rd78460Info = {
+ .boardName				= "RD-78460-SERVER",
+ .numBoardMppTypeValue			= ARRSZ(rd78460InfoBoardModTypeInfo),
+ .pBoardModTypeValue			= rd78460InfoBoardModTypeInfo,
+ .numBoardMppConfigValue		= ARRSZ(rd78460InfoBoardMppConfigValue),
+ .pBoardMppConfigValue			= rd78460InfoBoardMppConfigValue,
+ .intsGppMaskLow			= 0,
+ .intsGppMaskMid			= 0,
+ .intsGppMaskHigh			= 0,
+ .numBoardDeviceIf			= ARRSZ(rd78460InfoBoardDeCsInfo),
+ .pDevCsInfo				= rd78460InfoBoardDeCsInfo,
+ .numBoardTwsiDev			= 0,
+ .pBoardTwsiDev				= NULL,
+ .numBoardMacInfo			= ARRSZ(rd78460InfoBoardMacInfo),
+ .pBoardMacInfo				= rd78460InfoBoardMacInfo,
+ .numBoardGppInfo			= 0,
+ .pBoardGppInfo				= NULL,
+ .activeLedsNumber			= 0,
+ .pLedGppPin				= NULL,
+ .ledsPolarity				= 0,
+
+ /* GPP values */
+ .gppOutEnValLow			= RD_78460_GPP_OUT_ENA_LOW,
+ .gppOutEnValMid			= RD_78460_GPP_OUT_ENA_MID,
+ .gppOutEnValHigh			= RD_78460_GPP_OUT_ENA_HIGH,
+ .gppOutValLow				= RD_78460_GPP_OUT_VAL_LOW,
+ .gppOutValMid				= RD_78460_GPP_OUT_VAL_MID,
+ .gppOutValHigh				= RD_78460_GPP_OUT_VAL_HIGH,
+ .gppPolarityValLow			= RD_78460_GPP_POL_LOW,
+ .gppPolarityValMid			= RD_78460_GPP_POL_MID,
+ .gppPolarityValHigh			= RD_78460_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+ /* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+ ** can be connected to board.
+ ** When modules are scanned, then we select the index of the relevant
+ ** slic's information array.
+ ** For RD and Customers boards we only need to initialize a single
+ ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+ .numBoardTdmInfo			= {},
+ .pBoardTdmInt2CsInfo			= {},
+ .boardTdmInfoIndex			= -1,
+
+ /* NAND init params */
+ .nandFlashReadParams			= RD_78460_BOARD_NAND_READ_PARAMS,
+ .nandFlashWriteParams			= RD_78460_BOARD_NAND_WRITE_PARAMS,
+ .nandFlashControl			= RD_78460_BOARD_NAND_CONTROL
+};
+
+
+/*****************************/
+/* ARMADA-XP RD SERVER REV2 BOARD */
+/*****************************/
+#define RD_78460_SERVER_REV2_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_SERVER_REV2_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_SERVER_REV2_BOARD_NAND_CONTROL			0x01c00543
+
+MV_BOARD_MAC_INFO rd78460ServerRev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_1000M, 0x1,0x0, 0x1},
+	{BOARD_MAC_SPEED_1000M, 0x2,0x0, 0x1},
+	{BOARD_MAC_SPEED_AUTO,  0x0,0x0, 0x1},
+	{BOARD_MAC_SPEED_1000M, 0x1B,0x0,0x18}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460ServerRev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_DEV_CS_INFO rd78460ServerRev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460ServerRev2InfoBoardMppConfigValue[] = {
+	{ {
+		RD_78460_SERVER_REV2_MPP0_7,
+		RD_78460_SERVER_REV2_MPP8_15,
+		RD_78460_SERVER_REV2_MPP16_23,
+		RD_78460_SERVER_REV2_MPP24_31,
+		RD_78460_SERVER_REV2_MPP32_39,
+		RD_78460_SERVER_REV2_MPP40_47,
+		RD_78460_SERVER_REV2_MPP48_55,
+		RD_78460_SERVER_REV2_MPP56_63,
+		RD_78460_SERVER_REV2_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO rd78460ServerRev2Info = {
+ .boardName				= "RD-78460-SERVER-REV2",
+ .numBoardMppTypeValue			= ARRSZ(rd78460ServerRev2InfoBoardModTypeInfo),
+ .pBoardModTypeValue			= rd78460ServerRev2InfoBoardModTypeInfo,
+ .numBoardMppConfigValue		= ARRSZ(rd78460ServerRev2InfoBoardMppConfigValue),
+ .pBoardMppConfigValue			= rd78460ServerRev2InfoBoardMppConfigValue,
+ .intsGppMaskLow			= 0,
+ .intsGppMaskMid			= 0,
+ .intsGppMaskHigh			= 0,
+ .numBoardDeviceIf			= ARRSZ(rd78460ServerRev2InfoBoardDeCsInfo),
+ .pDevCsInfo				= rd78460ServerRev2InfoBoardDeCsInfo,
+ .numBoardTwsiDev			= 0,
+ .pBoardTwsiDev				= NULL,
+ .numBoardMacInfo			= ARRSZ(rd78460ServerRev2InfoBoardMacInfo),
+ .pBoardMacInfo				= rd78460ServerRev2InfoBoardMacInfo,
+ .numBoardGppInfo			= 0,
+ .pBoardGppInfo				= NULL,
+ .activeLedsNumber			= 0,
+ .pLedGppPin				= NULL,
+ .ledsPolarity				= 0,
+
+ /* GPP values */
+ .gppOutEnValLow			= RD_78460_SERVER_REV2_GPP_OUT_ENA_LOW,
+ .gppOutEnValMid			= RD_78460_SERVER_REV2_GPP_OUT_ENA_MID,
+ .gppOutEnValHigh			= RD_78460_SERVER_REV2_GPP_OUT_ENA_HIGH,
+ .gppOutValLow				= RD_78460_SERVER_REV2_GPP_OUT_VAL_LOW,
+ .gppOutValMid				= RD_78460_SERVER_REV2_GPP_OUT_VAL_MID,
+ .gppOutValHigh				= RD_78460_SERVER_REV2_GPP_OUT_VAL_HIGH,
+ .gppPolarityValLow			= RD_78460_SERVER_REV2_GPP_POL_LOW,
+ .gppPolarityValMid			= RD_78460_SERVER_REV2_GPP_POL_MID,
+ .gppPolarityValHigh			= RD_78460_SERVER_REV2_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+ /* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+ ** can be connected to board.
+ ** When modules are scanned, then we select the index of the relevant
+ ** slic's information array.
+ ** For RD and Customers boards we only need to initialize a single
+ ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+ .numBoardTdmInfo			= {},
+ .pBoardTdmInt2CsInfo			= {},
+ .boardTdmInfoIndex			= -1,
+
+ /* NAND init params */
+ .nandFlashReadParams			= RD_78460_SERVER_REV2_BOARD_NAND_READ_PARAMS,
+ .nandFlashWriteParams			= RD_78460_SERVER_REV2_BOARD_NAND_WRITE_PARAMS,
+ .nandFlashControl			= RD_78460_SERVER_REV2_BOARD_NAND_CONTROL
+};
+/***************************/
+/* ARMADA-XP DB PCAC BOARD */
+/***************************/
+#define DB_78X60_PCAC_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_PCAC_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_PCAC_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60pcacInfoBoardDebugLedIf[] = {53, 54, 55, 56};
+
+MV_BOARD_TWSI_INFO	db78X60pcacInfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db78X60pcacInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0,0x0}		/* Dummy */
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60pcacInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod	= MV_BOARD_AUTO,
+		.boardOtherMod	= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db78X60pcacInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    23} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60pcacInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60pcacInfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_PCAC_MPP0_7,
+		DB_78X60_PCAC_MPP8_15,
+		DB_78X60_PCAC_MPP16_23,
+		DB_78X60_PCAC_MPP24_31,
+		DB_78X60_PCAC_MPP32_39,
+		DB_78X60_PCAC_MPP40_47,
+		DB_78X60_PCAC_MPP48_55,
+		DB_78X60_PCAC_MPP56_63,
+		DB_78X60_PCAC_MPP64_67,
+	} }
+};
+
+MV_BOARD_TDM_INFO	db78X60pcacTdm880[]		= { {1}, {2} };
+MV_BOARD_TDM_INFO	db78X60pcacTdm792[]		= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db78X60pcacTdm3215[]	= { {1} };
+
+MV_BOARD_INFO db78X60pcacInfo = {
+	.boardName			= "DB-78460-PCAC",
+	.numBoardMppTypeValue		= ARRSZ(db78X60pcacInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60pcacInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60pcacInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60pcacInfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60pcacInfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60pcacInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db78X60pcacInfoBoardTwsiDev),
+	.pBoardTwsiDev			= db78X60pcacInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db78X60pcacInfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60pcacInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60pcacInfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60pcacInfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60pcacInfoBoardDebugLedIf),
+	.pLedGppPin			= db78X60pcacInfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_PCAC_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_PCAC_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_PCAC_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_PCAC_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_PCAC_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_PCAC_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_PCAC_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_PCAC_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_PCAC_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db78X60pcacTdm880,
+					   db78X60pcacTdm792,
+					   db78X60pcacTdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_PCAC_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_PCAC_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_PCAC_BOARD_NAND_CONTROL
+};
+
+/********************************/
+/* ARMADA-XP DB PCAC REV2 BOARD */
+/********************************/
+#define DB_78X60_PCAC_REV2_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_PCAC_REV2_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_PCAC_REV2_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60pcacrev2InfoBoardDebugLedIf[] = {53, 54, 55, 56};
+
+MV_BOARD_MAC_INFO db78X60pcacrev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0,0x0}		/* Dummy */
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60pcacrev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod	= MV_BOARD_AUTO,
+		.boardOtherMod	= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db78X60pcacrev2InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    23} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60pcacrev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60pcacrev2InfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_PCAC_REV2_MPP0_7,
+		DB_78X60_PCAC_REV2_MPP8_15,
+		DB_78X60_PCAC_REV2_MPP16_23,
+		DB_78X60_PCAC_REV2_MPP24_31,
+		DB_78X60_PCAC_REV2_MPP32_39,
+		DB_78X60_PCAC_REV2_MPP40_47,
+		DB_78X60_PCAC_REV2_MPP48_55,
+		DB_78X60_PCAC_REV2_MPP56_63,
+		DB_78X60_PCAC_REV2_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO db78X60pcacrev2Info = {
+	.boardName			= "DB-78460-PCAC-REV2",
+	.numBoardMppTypeValue		= ARRSZ(db78X60pcacrev2InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60pcacrev2InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60pcacrev2InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60pcacrev2InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60pcacrev2InfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60pcacrev2InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(db78X60pcacrev2InfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60pcacrev2InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60pcacrev2InfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60pcacrev2InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60pcacrev2InfoBoardDebugLedIf),
+	.pLedGppPin				= db78X60pcacrev2InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_PCAC_REV2_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_PCAC_REV2_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_PCAC_REV2_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_PCAC_REV2_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_PCAC_REV2_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_PCAC_REV2_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_PCAC_REV2_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_PCAC_REV2_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_PCAC_REV2_BOARD_NAND_CONTROL
+};
+
+/************************/
+/* ARMADA-XP FPGA BOARD */
+/************************/
+#define FPGA_88F78XX0_BOARD_NAND_READ_PARAMS	0x000C0282
+#define FPGA_88F78XX0_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define FPGA_88F78XX0_BOARD_NAND_CONTROL	0x01c00543
+
+MV_BOARD_TWSI_INFO	fpga88f78XX0InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO fpga88f78XX0InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x4,0x0,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO fpga88f78XX0InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO fpga88f78XX0InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+};
+
+MV_DEV_CS_INFO fpga88f78XX0InfoBoardDeCsInfo[] = {
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO fpga88f78XX0InfoBoardMppConfigValue[] = {
+	{ {
+	FPGA_88F78XX0_MPP0_7,
+	FPGA_88F78XX0_MPP8_15,
+	FPGA_88F78XX0_MPP16_23,
+	FPGA_88F78XX0_MPP24_31,
+	FPGA_88F78XX0_MPP32_39,
+	FPGA_88F78XX0_MPP40_47,
+	FPGA_88F78XX0_MPP48_55,
+	FPGA_88F78XX0_MPP56_63,
+	FPGA_88F78XX0_MPP64_67,
+	} }
+};
+
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO fpga88f78XX0Info = {
+	.boardName			= "FPGA-88F78XX0",
+	.numBoardMppTypeValue		= ARRSZ(fpga88f78XX0InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= fpga88f78XX0InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(fpga88f78XX0InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= fpga88f78XX0InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(fpga88f78XX0InfoBoardDeCsInfo),
+	.pDevCsInfo			= fpga88f78XX0InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(fpga88f78XX0InfoBoardTwsiDev),
+	.pBoardTwsiDev			= fpga88f78XX0InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(fpga88f78XX0InfoBoardMacInfo),
+	.pBoardMacInfo			= fpga88f78XX0InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(fpga88f78XX0InfoBoardGppInfo),
+	.pBoardGppInfo			= fpga88f78XX0InfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= FPGA_88F78XX0_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= FPGA_88F78XX0_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= FPGA_88F78XX0_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= FPGA_88F78XX0_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= FPGA_88F78XX0_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= FPGA_88F78XX0_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= FPGA_88F78XX0_GPP_POL_LOW,
+	.gppPolarityValMid		= FPGA_88F78XX0_GPP_POL_MID,
+	.gppPolarityValHigh		= FPGA_88F78XX0_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= { 2, 6, 1 },
+	.pBoardTdmInt2CsInfo		= { fpga88f78XX0Tdm880,
+					    fpga88f78XX0Tdm792,
+					    fpga88f78XX0Tdm3215
+					  },
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= FPGA_88F78XX0_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= FPGA_88F78XX0_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= FPGA_88F78XX0_BOARD_NAND_CONTROL
+};
+
+/***************************/
+/* ARMADA-XP AMC BOARD     */
+/***************************/
+#define DB_78X60_AMC_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_AMC_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_AMC_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60amcInfoBoardDebugLedIf[] = {53, 54, 55, 56}; /* 7 segment MPPs*/
+
+MV_BOARD_TWSI_INFO	db78X60amcInfoBoardTwsiDev[] = {
+	/* No TWSI devices on board*/
+};
+
+MV_BOARD_MAC_INFO db78X60amcInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0xF,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0xE,0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0,0x0}
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60amcInfoBoardModTypeInfo[] = {
+	/* No Modules */
+};
+
+MV_BOARD_GPP_INFO db78X60amcInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    46} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60amcInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60amcInfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_AMC_MPP0_7,
+		DB_78X60_AMC_MPP8_15,
+		DB_78X60_AMC_MPP16_23,
+		DB_78X60_AMC_MPP24_31,
+		DB_78X60_AMC_MPP32_39,
+		DB_78X60_AMC_MPP40_47,
+		DB_78X60_AMC_MPP48_55,
+		DB_78X60_AMC_MPP56_63,
+		DB_78X60_AMC_MPP64_67,
+	} }
+};
+
+MV_BOARD_TDM_INFO	db78X60amcTdm880[]	= {};
+MV_BOARD_TDM_INFO	db78X60amcTdm792[]	= {};
+MV_BOARD_TDM_INFO	db78X60amcTdm3215[]	= {};
+
+MV_BOARD_INFO db78X60amcInfo = {
+	.boardName			= "DB-78460-AMC",
+	.numBoardMppTypeValue		= ARRSZ(db78X60amcInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60amcInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60amcInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60amcInfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60amcInfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60amcInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db78X60amcInfoBoardTwsiDev),
+	.pBoardTwsiDev			= db78X60amcInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db78X60amcInfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60amcInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60amcInfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60amcInfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60amcInfoBoardDebugLedIf),
+	.pLedGppPin			= db78X60amcInfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_AMC_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_AMC_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_AMC_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_AMC_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_AMC_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_AMC_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_AMC_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_AMC_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_AMC_GPP_POL_HIGH,
+	
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,	
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {},
+	.pBoardTdmInt2CsInfo		= {},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_AMC_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_AMC_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_AMC_BOARD_NAND_CONTROL
+};
+
+/*********************************************************************************/
+
+/***************************/
+/* ARMADA-XP RD GP  BOARD */
+/***************************/
+#define RD_78460_GP_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_GP_BOARD_NAND_WRITE_PARAMS		0x00010305
+
+#define RD_78460_GP_BOARD_NAND_CONTROL			0x01c00543
+
+#define RD_78460_GP_BOARD_NOR_READ_PARAMS		0x403E07CF
+#define RD_78460_GP_BOARD_NOR_WRITE_PARAMS		0x000F0F0F
+
+
+MV_BOARD_TWSI_INFO   rd78460gpInfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO rd78460gpInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+        /* speed will toggle to force link 1000 when SW module detected */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0000, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0800, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x1000, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x1800, 0x10}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460gpInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO rd78460gpInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460gpInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460gpInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_GP_MPP0_7,
+	RD_78460_GP_MPP8_15,
+	RD_78460_GP_MPP16_23,
+	RD_78460_GP_MPP24_31,
+	RD_78460_GP_MPP32_39,
+	RD_78460_GP_MPP40_47,
+	RD_78460_GP_MPP48_55,
+	RD_78460_GP_MPP56_63,
+	RD_78460_GP_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO rd78460gpInfo = {
+	.boardName			= "RD-AXP-GP rev 1.0",
+	.numBoardMppTypeValue		= ARRSZ(rd78460gpInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460gpInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460gpInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460gpInfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460gpInfoBoardDeCsInfo),
+	.pDevCsInfo				= rd78460gpInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(rd78460gpInfoBoardTwsiDev),
+	.pBoardTwsiDev			= rd78460gpInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(rd78460gpInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460gpInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460gpInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460gpInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_GP_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_GP_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_GP_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_GP_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_GP_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_GP_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_GP_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_GP_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_GP_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_GP_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_GP_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_GP_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_GP_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_GP_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP CUSTOMER BOARD */
+/***************************/
+#define RD_78460_CUSTOMER_BOARD_NAND_READ_PARAMS	0x000C0282
+#define RD_78460_CUSTOMER_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_CUSTOMER_BOARD_NAND_CONTROL		0x01c00543
+
+#define RD_78460_CUSTOMER_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define RD_78460_CUSTOMER_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_MAC_INFO rd78460customerInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0000, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0800, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x1000, 0x10},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x1800, 0x10}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460customerInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+/*********************************************************************************/
+
+
+MV_BOARD_GPP_INFO rd78460customerInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460customerInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460customerInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_CUSTOMER_MPP0_7,
+	RD_78460_CUSTOMER_MPP8_15,
+	RD_78460_CUSTOMER_MPP16_23,
+	RD_78460_CUSTOMER_MPP24_31,
+	RD_78460_CUSTOMER_MPP32_39,
+	RD_78460_CUSTOMER_MPP40_47,
+	RD_78460_CUSTOMER_MPP48_55,
+	RD_78460_CUSTOMER_MPP56_63,
+	RD_78460_CUSTOMER_MPP64_67,
+	} }
+};
+
+MV_BOARD_INFO rd78460customerInfo = {
+	.boardName			= "RD-AXP-CUSTOMER",
+	.numBoardMppTypeValue		= ARRSZ(rd78460customerInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460customerInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460customerInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460customerInfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460customerInfoBoardDeCsInfo),
+	.pDevCsInfo			= rd78460customerInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(rd78460customerInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460customerInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460customerInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460customerInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_CUSTOMER_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_CUSTOMER_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_CUSTOMER_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_CUSTOMER_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_CUSTOMER_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_CUSTOMER_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_CUSTOMER_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_CUSTOMER_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_CUSTOMER_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+	
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_CUSTOMER_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_CUSTOMER_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_CUSTOMER_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_CUSTOMER_BOARD_NOR_WRITE_PARAMS
+};
+/*********************************************************************************/
+
+MV_BOARD_INFO *boardInfoTbl[] = {
+	&db88f78XX0Info,
+	&rd78460Info,
+	&db78X60pcacInfo,
+	&fpga88f78XX0Info,
+	&db88f78XX0rev2Info,
+	&rd78460nasInfo,
+	&db78X60amcInfo,
+	&db78X60pcacrev2Info,
+	&rd78460ServerRev2Info,
+	&rd78460gpInfo,
+	&rd78460customerInfo
+};
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..81a7910
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,575 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+/* For future use */
+#define BD_ID_DATA_START_OFFS			0x0
+#define BD_DETECT_SEQ_OFFS			0x0
+#define BD_SYS_NUM_OFFS				0x4
+#define BD_NAME_OFFS				0x8
+
+/* I2C bus addresses TODO - take from board design */
+#define MV_BOARD_DIMM0_I2C_ADDR			0x56
+#define MV_BOARD_DIMM0_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM1_I2C_ADDR			0x57
+#define MV_BOARD_DIMM1_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM_I2C_CHANNEL		0x0
+
+
+/* Board specific configuration */
+/* ============================ */
+
+/* boards ID numbers */
+#define BOARD_ID_BASE				0x0
+
+/* New board ID numbers */
+#define DB_88F78XX0_BP_ID			(BOARD_ID_BASE)
+#define RD_78460_SERVER_ID			(DB_88F78XX0_BP_ID + 1)
+#define DB_78X60_PCAC_ID			(RD_78460_SERVER_ID + 1)
+#define FPGA_88F78XX0_ID			(DB_78X60_PCAC_ID + 1)
+#define DB_88F78XX0_BP_REV2_ID		(FPGA_88F78XX0_ID + 1)
+#define RD_78460_NAS_ID				(DB_88F78XX0_BP_REV2_ID + 1)
+#define DB_78X60_AMC_ID				(RD_78460_NAS_ID + 1)
+#define DB_78X60_PCAC_REV2_ID		(DB_78X60_AMC_ID + 1)
+#define RD_78460_SERVER_REV2_ID		(DB_78X60_PCAC_REV2_ID + 1)
+#define DB_784MP_GP_ID				(RD_78460_SERVER_REV2_ID + 1)
+#define RD_78460_CUSTOMER_ID		(DB_784MP_GP_ID+ 1)
+#define MV_MAX_BOARD_ID				(RD_78460_CUSTOMER_ID + 1)
+#define INVALID_BAORD_ID			0xFFFFFFFF
+
+/******************/
+/* DB-88F78XX0-BP */
+/******************/
+#define DB_88F78XX0_MPP0_7			0x11111111
+#define DB_88F78XX0_MPP8_15			0x22221111
+#define DB_88F78XX0_MPP16_23			0x22222222
+/* TODO Kostap - change MPP29 (CPU0 Vdd) back to default value 5
+   when PM configuration changed to have it as active "high"
+   Otherwise setting it to default value will shut down CPU0 */
+#define DB_88F78XX0_MPP24_31			0x11040000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define DB_88F78XX0_MPP32_39			0x11111111
+#define DB_88F78XX0_MPP40_47			0x04221130 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define DB_88F78XX0_MPP48_55			0x11111110
+#define DB_88F78XX0_MPP56_63			0x11111101 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define DB_88F78XX0_MPP64_67			0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define DB_88F78XX0_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_88F78XX0_GPP_OUT_ENA_MID		(~(BIT16 | BIT15))
+#define DB_88F78XX0_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_88F78XX0_GPP_OUT_VAL_LOW		0x0
+#define DB_88F78XX0_GPP_OUT_VAL_MID		BIT15
+#define DB_88F78XX0_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_88F78XX0_GPP_POL_LOW			0x0
+#define DB_88F78XX0_GPP_POL_MID			0x0
+#define DB_88F78XX0_GPP_POL_HIGH		0x0
+
+/**********************/
+/* DB-88F78XX0-BP Rev2*/
+/**********************/
+#define DB_88F78XX0_REV2_MPP0_7			0x11111111
+#define DB_88F78XX0_REV2_MPP8_15		0x22221111
+#define DB_88F78XX0_REV2_MPP16_23		0x22222222
+/* TODO Kostap - change MPP29 (CPU0 Vdd) back to default value 5
+   when PM configuration changed to have it as active "high"
+   Otherwise setting it to default value will shut down CPU0 */
+#define DB_88F78XX0_REV2_MPP24_31		0x11040000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define DB_88F78XX0_REV2_MPP32_39		0x11111111
+#define DB_88F78XX0_REV2_MPP40_47		0x04221130 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define DB_88F78XX0_REV2_MPP48_55		0x11111113
+#define DB_88F78XX0_REV2_MPP56_63		0x11111101 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define DB_88F78XX0_REV2_MPP64_67		0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_LOW	(~(BIT26 | BIT27))
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_MID	(~(BIT16 | BIT15))
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_LOW	0x0
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_MID	BIT15
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_HIGH	0x0
+
+#define DB_88F78XX0_REV2_GPP_POL_LOW		0x0
+#define DB_88F78XX0_REV2_GPP_POL_MID		0x0
+#define DB_88F78XX0_REV2_GPP_POL_HIGH		0x0
+
+/**********************/
+/* DB-AXP-NAS         */
+/**********************/
+
+#define RD_78460_NAS_MPP0_7             0x00000000
+#define RD_78460_NAS_MPP8_15		0x00000000
+#define RD_78460_NAS_MPP16_23		0x33000000
+#define RD_78460_NAS_MPP24_31		0x11000000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define RD_78460_NAS_MPP32_39		0x11111111
+#define RD_78460_NAS_MPP40_47		0x00221100 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define RD_78460_NAS_MPP48_55		0x00000003
+#define RD_78460_NAS_MPP56_63		0x00000000 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define RD_78460_NAS_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_NAS_GPP_OUT_ENA_LOW	(~(BIT21))
+#define RD_78460_NAS_GPP_OUT_ENA_MID	(~(0x0))
+#define RD_78460_NAS_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_NAS_GPP_OUT_VAL_LOW	(BIT21)
+#define RD_78460_NAS_GPP_OUT_VAL_MID	0x0
+#define RD_78460_NAS_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_NAS_GPP_POL_LOW		0x0
+#define RD_78460_NAS_GPP_POL_MID		0x0
+#define RD_78460_NAS_GPP_POL_HIGH		0x0
+
+
+/*******************/
+/* RD-78460-SERVER */
+/*******************/
+#define RD_78460_MPP0_7				0x00000000
+#define RD_78460_MPP8_15			0x00000000
+#define RD_78460_MPP16_23			0x00000000
+#define RD_78460_MPP24_31			0x00000000
+#define RD_78460_MPP32_39			0x11110000
+#define RD_78460_MPP40_47			0x00000000
+#define RD_78460_MPP48_55			0x00000000
+#define RD_78460_MPP56_63			0x00000000
+#define RD_78460_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16		CPU ID		IN
+17		CPU ID		IN
+18		CPU ID		IN
+19		CPU ID		IN
+23		USER LED	OUT
+25		Touch SG/ MII Int#	IN
+28		RESET GPIO FOR OTHER DEVICES
+29		RESET GPIO FOR OTHER DEVICES
+30		RESET GPIO FOR OTHER DEVICES
+31		RESET GPIO FOR OTHER DEVICES
+32		RESET GPIO FOR OTHER DEVICES
+33		RESET GPIO FOR OTHER DEVICES
+
+40		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+41		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+42		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+43		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+44		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+
+*/
+
+#define RD_78460_GPP_OUT_ENA_LOW		(~(BIT23 | BIT28 | BIT29 | BIT30 | BIT31))
+#define RD_78460_GPP_OUT_ENA_MID		(~(BIT0 | BIT1 | BIT2 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12))
+#define RD_78460_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define RD_78460_GPP_OUT_VAL_LOW		(BIT28 | BIT29 | BIT30 | BIT31)
+#define RD_78460_GPP_OUT_VAL_MID		(BIT0)
+#define RD_78460_GPP_OUT_VAL_HIGH		0x0
+
+#define RD_78460_GPP_POL_LOW			0x0
+/* (BIT16 | BIT17 | BIT18 | BIT19) */
+#define RD_78460_GPP_POL_MID			0x0
+#define RD_78460_GPP_POL_HIGH			0x0
+
+/************************/
+/* RD-78460-SERVER-REV2 */
+/************************/
+#define RD_78460_SERVER_REV2_MPP0_7				0x00000000
+#define RD_78460_SERVER_REV2_MPP8_15			0x00000000
+#define RD_78460_SERVER_REV2_MPP16_23			0x00000000
+#define RD_78460_SERVER_REV2_MPP24_31			0x00000000
+#define RD_78460_SERVER_REV2_MPP32_39			0x11110000
+#define RD_78460_SERVER_REV2_MPP40_47			0x00000000
+#define RD_78460_SERVER_REV2_MPP48_55			0x00000000
+#define RD_78460_SERVER_REV2_MPP56_63			0x00000000
+#define RD_78460_SERVER_REV2_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16		CPU ID		IN
+17		CPU ID		IN
+18		CPU ID		IN
+19		CPU ID		IN
+23		USER LED	OUT
+25		Touch SG/ MII Int#	IN
+28		RESET GPIO FOR OTHER DEVICES
+29		RESET GPIO FOR OTHER DEVICES
+30		RESET GPIO FOR OTHER DEVICES
+31		RESET GPIO FOR OTHER DEVICES
+32		RESET GPIO FOR OTHER DEVICES
+33		RESET GPIO FOR OTHER DEVICES
+
+40		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+41		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+42		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+43		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+44		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+
+*/
+
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_LOW		(~(BIT23 | BIT28 | BIT29 | BIT30 | BIT31))
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_MID		(~(BIT0 | BIT1 | BIT2 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12))
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_LOW		(BIT28 | BIT29 | BIT30 | BIT31)
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_MID		(BIT0)
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_HIGH		0x0
+
+#define RD_78460_SERVER_REV2_GPP_POL_LOW			0x0
+/* (BIT16 | BIT17 | BIT18 | BIT19) */
+#define RD_78460_SERVER_REV2_GPP_POL_MID			0x0
+#define RD_78460_SERVER_REV2_GPP_POL_HIGH			0x0
+
+
+/********************/
+/* DB-88F78XX0-PCAC */
+/********************/
+
+#define DB_78X60_PCAC_MPP0_7			0x00000000
+#define DB_78X60_PCAC_MPP8_15			0x00000000
+#define DB_78X60_PCAC_MPP16_23			0x00000000
+#define DB_78X60_PCAC_MPP24_31			0x11000000
+#define DB_78X60_PCAC_MPP32_39			0x11111111
+#define DB_78X60_PCAC_MPP40_47			0x00221105
+#define DB_78X60_PCAC_MPP48_55			0x00000000
+#define DB_78X60_PCAC_MPP56_63			0x00000000
+#define DB_78X60_PCAC_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+16	Jumper 1 			IN
+17	Jumper 2 			IN
+18	Jumper 3 			IN
+19	Jumper 4 			IN
+20	Jumper 5 			IN
+21	GP				OUT
+23	UsbDevice_Vbus			IN
+53	7seg bit0			OUT
+54	7seg bit1			OUT
+55	7seg bit2			OUT
+56	7seg bit3			OUT
+*/
+
+#define DB_78X60_PCAC_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_78X60_PCAC_GPP_OUT_ENA_MID		(~(BIT16 | BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_PCAC_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_PCAC_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_PCAC_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_PCAC_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_PCAC_GPP_POL_LOW		0x0
+#define DB_78X60_PCAC_GPP_POL_MID		0x0
+#define DB_78X60_PCAC_GPP_POL_HIGH		0x0
+
+/*************************/
+/* DB-88F78XX0-PCAC-REV2 */
+/*************************/
+
+#define DB_78X60_PCAC_REV2_MPP0_7			0x00000000
+#define DB_78X60_PCAC_REV2_MPP8_15			0x00000000
+#define DB_78X60_PCAC_REV2_MPP16_23			0x00000000
+#define DB_78X60_PCAC_REV2_MPP24_31			0x11000000
+#define DB_78X60_PCAC_REV2_MPP32_39			0x11111111
+#define DB_78X60_PCAC_REV2_MPP40_47			0x00221105
+#define DB_78X60_PCAC_REV2_MPP48_55			0x00000000
+#define DB_78X60_PCAC_REV2_MPP56_63			0x00000000
+#define DB_78X60_PCAC_REV2_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+16	Jumper 1 			IN
+17	Jumper 2 			IN
+18	Jumper 3 			IN
+19	Jumper 4 			IN
+20	Jumper 5 			IN
+21	GP				OUT
+23	UsbDevice_Vbus			IN
+53	7seg bit0			OUT
+54	7seg bit1			OUT
+55	7seg bit2			OUT
+56	7seg bit3			OUT
+*/
+
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_MID		(~(BIT16 | BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_PCAC_REV2_GPP_POL_LOW		0x0
+#define DB_78X60_PCAC_REV2_GPP_POL_MID		0x0
+#define DB_78X60_PCAC_REV2_GPP_POL_HIGH		0x0
+
+/********************/
+/* FPGA-88F78XX0-BP */
+/********************/
+#define FPGA_88F78XX0_MPP0_7			0x11111111
+#define FPGA_88F78XX0_MPP8_15			0x22221111
+#define FPGA_88F78XX0_MPP16_23			0x22222222
+#define FPGA_88F78XX0_MPP24_31			0x11500000
+#define FPGA_88F78XX0_MPP32_39			0x11111111
+#define FPGA_88F78XX0_MPP40_47			0x44221133
+#define FPGA_88F78XX0_MPP48_55			0x11111111
+#define FPGA_88F78XX0_MPP56_63			0x11111111
+#define FPGA_88F78XX0_MPP64_67			0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define FPGA_88F78XX0_GPP_OUT_ENA_LOW		(BIT26 | BIT27)
+#define FPGA_88F78XX0_GPP_OUT_ENA_MID		(BIT16)
+#define FPGA_88F78XX0_GPP_OUT_ENA_HIGH		0x0
+
+#define FPGA_88F78XX0_GPP_OUT_VAL_LOW		0x0
+#define FPGA_88F78XX0_GPP_OUT_VAL_MID		0x0
+#define FPGA_88F78XX0_GPP_OUT_VAL_HIGH		0x0
+
+#define FPGA_88F78XX0_GPP_POL_LOW		0x0
+#define FPGA_88F78XX0_GPP_POL_MID		0x0
+#define FPGA_88F78XX0_GPP_POL_HIGH		0x0
+
+
+
+/********************/
+/* DB-78460-AMC     */
+/********************/
+
+#define DB_78X60_AMC_MPP0_7			0x11111111
+#define DB_78X60_AMC_MPP8_15			0x00001111
+#define DB_78X60_AMC_MPP16_23			0x00000000
+#define DB_78X60_AMC_MPP24_31			0x00000000
+#define DB_78X60_AMC_MPP32_39			0x11110000
+#define DB_78X60_AMC_MPP40_47			0x00004000
+#define DB_78X60_AMC_MPP48_55			0x00001113
+#define DB_78X60_AMC_MPP56_63			0x11111110
+#define DB_78X60_AMC_MPP64_67			0x00000111
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16	MB_INT#		IN
+17	Phy1_INT#	IN
+18	Phy2_INT#	IN
+19	Brd_Led_0	IN (for next board)
+21	Brd_Led_1	OUT
+23	Brd_Led_2	OUT
+29	Brd_Led_3	OUT
+30	Brd_Led_4	OUT
+34	Dbg_JP0		IN
+35	Dbg_JP1		IN
+40	Dbg_JP2		IN
+41	Dbg_JP3		IN
+42	Dbg_JP4		IN
+53	7 Segment 0	OUT
+54	7 Segment 1	OUT
+55	7 Segment 2	OUT
+56	7 Segment 3	OUT
+*/
+
+#define DB_78X60_AMC_GPP_OUT_ENA_LOW		(~(BIT19 | BIT21 | BIT22 | BIT23 | BIT29 | BIT30))
+#define DB_78X60_AMC_GPP_OUT_ENA_MID		(~(BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_AMC_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_AMC_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_AMC_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_AMC_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_AMC_GPP_POL_LOW		0x0
+#define DB_78X60_AMC_GPP_POL_MID		0x0
+#define DB_78X60_AMC_GPP_POL_HIGH		0x0
+
+
+
+
+/*********************/
+/* DB-AXP-GP         */
+/*********************/
+
+#define RD_78460_GP_MPP0_7			0x00000000
+#define RD_78460_GP_MPP8_15			0x00000000
+#define RD_78460_GP_MPP16_23		0x33000000
+#define RD_78460_GP_MPP24_31		0x11000000
+#define RD_78460_GP_MPP32_39		0x11111111
+#define RD_78460_GP_MPP40_47		0x00221100
+#define RD_78460_GP_MPP48_55		0x00000003
+#define RD_78460_GP_MPP56_63		0x00000000
+#define RD_78460_GP_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_GP_GPP_OUT_ENA_LOW	(~(BIT21 | BIT20))
+#define RD_78460_GP_GPP_OUT_ENA_MID (~(BIT26 | BIT27))
+#define RD_78460_GP_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_GP_GPP_OUT_VAL_LOW	(BIT21 | BIT20)
+#define RD_78460_GP_GPP_OUT_VAL_MID	(BIT26 | BIT27)
+#define RD_78460_GP_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_GP_GPP_POL_LOW		0x0
+#define RD_78460_GP_GPP_POL_MID		0x0
+#define RD_78460_GP_GPP_POL_HIGH	0x0
+
+
+
+
+/**********************/
+/* DB-AXP-CUSTOMER         */
+/**********************/
+
+#define RD_78460_CUSTOMER_MPP0_7             0x00000000
+#define RD_78460_CUSTOMER_MPP8_15		0x00000000
+#define RD_78460_CUSTOMER_MPP16_23		0x33000000
+#define RD_78460_CUSTOMER_MPP24_31		0x11000000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define RD_78460_CUSTOMER_MPP32_39		0x11111111
+#define RD_78460_CUSTOMER_MPP40_47		0x00221100 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define RD_78460_CUSTOMER_MPP48_55		0x00000003
+#define RD_78460_CUSTOMER_MPP56_63		0x00000000 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define RD_78460_CUSTOMER_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_LOW	(~(BIT21))
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_MID	(~(0x0))
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_LOW	(BIT21)
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_MID	0x0
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_CUSTOMER_GPP_POL_LOW		0x0
+#define RD_78460_CUSTOMER_GPP_POL_MID		0x0
+#define RD_78460_CUSTOMER_GPP_POL_HIGH		0x0
+
+
+
+#endif /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
new file mode 100644
index 0000000..699062c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
@@ -0,0 +1,323 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals */
+
+/*******************************************************************************
+* mvCpuPclkGet - Get the CPU pClk (pipe clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU core clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in MHertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 cpuClk[] = MV_CPU_CLK_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_CPU_CLK_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	return cpuClk[idx] * 1000000;
+}
+
+/*******************************************************************************
+* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU L2 clock.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuL2ClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz, l2FreqMhz;
+	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	if (clockRatioTbl[idx].vco2cpu != 0) {
+		freqMhz = mvCpuPclkGet() / 1000000;	/* CPU freq */
+		freqMhz *= clockRatioTbl[idx].vco2cpu;	/* VCO freq */
+		l2FreqMhz = freqMhz / clockRatioTbl[idx].vco2l2c;
+		/* round up to integer MHz */
+		if (((freqMhz % clockRatioTbl[idx].vco2l2c) * 10 / clockRatioTbl[idx].vco2l2c) >= 5)
+			l2FreqMhz++;
+
+		return l2FreqMhz * 1000000;
+	} else
+		return (MV_U32)-1;
+}
+
+/*******************************************************************************
+* mvCpuNameGet - Get CPU name
+*
+* DESCRIPTION:
+*       This function returns a string describing the CPU model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*       None.
+*******************************************************************************/
+MV_VOID mvCpuNameGet(char *pNameBuff)
+{
+	MV_U32 cpuModel;
+	MV_U32 archType;
+
+	cpuModel = mvOsCpuPartGet();
+	archType = mvOsCpuThumbEEGet();
+	/* The CPU module is indicated in the Processor Version Register (PVR) */
+	switch (cpuModel & 0xfff) {
+	case CPU_PART_ARM_V6UP:
+	case CPU_PART_ARM_V7UP:
+	case CPU_PART_MRVLPJ4B_UP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_MRVLPJ4B_MP:
+	case CPU_PART_ARM_V6MP:
+			if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v6", mvOsCpuRevGet());
+		break;
+	default:
+		mvOsSPrintf(pNameBuff, "??? (0x%04x) (Rev %d)", cpuModel, mvOsCpuRevGet());
+		break;
+	}			/* switch  */
+
+	return;
+}
+
+#define MV_PROC_STR_SIZE 50
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_ECC_MASK) == CL2ACR_ECC_EN)
+		mvOsSPrintf(buf, "L2 ECC Enabled");
+	else
+		mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2ParityMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PARITY_MASK) == CL2ACR_PARITY_EN)
+		mvOsSPrintf(buf, "L2 Parity Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Parity Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	if (regVal & CL2CR_L2_EN_MASK)
+		mvOsSPrintf(buf, "L2 Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PFU_MASK) == CL2ACR_PFU_DIS)
+		mvOsSPrintf(buf, "L2 Prefetch Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_FORCE_WA_MASK) == CL2ACR_FORCE_NO_WA)
+		mvOsSPrintf(buf, "L2 Write Allocate Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Write Allocate Enabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = 0;
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register */
+	if (regVal & BIT29)
+		mvOsSPrintf(buf, "CPU Streaming Enabled");
+	else
+		mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+	MV_U32 regVal = 0;
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register0 */
+	mvOsPrintf("Extra Features Reg[0] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (regVal));	/* Read Marvell extra features register1 */
+	mvOsPrintf("Extra Features Reg[1] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal));	/* Read Control register */
+	mvOsPrintf("Control Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal));	/* Read Main ID register */
+	mvOsPrintf("Main ID Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal));	/* Read Cache Type register */
+	mvOsPrintf("Cache Type Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	mvOsPrintf("L2 Control Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	mvOsPrintf("L2 Auxilary Control Reg = 0x%x\n", regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+	MV_U32 count = 0;
+
+	MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+	MV_8 L2_En_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+	MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+	MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Parity_str[MV_PROC_STR_SIZE];
+
+	mvCpuIfGetL2Mode(L2_En_str);
+	mvCpuIfGetL2EccMode(L2_ECC_str);
+	mvCpuIfGetL2ParityMode(L2_Parity_str);
+	mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+	mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+	mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+	mvCpuIfPrintCpuRegs();
+
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Parity_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+	return count;
+}
+
+/*******************************************************************************
+* whoAmI - Get the CPU ID
+*
+* DESCRIPTION:
+*       This function returns CPU ID in multiprocessor system
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       none.
+*
+* RETURN:
+*       CPU ID.
+*******************************************************************************/
+unsigned int whoAmI(void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPUID reg\n" : "=r"(value) : : "memory");
+	return (value & 0x7);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
new file mode 100644
index 0000000..c4e38d6
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#ifndef MV_ASMLANGUAGE
+#include "mvOs.h"
+#endif
+
+#define MASTER_CPU 0
+/* defines */
+#define CPU_PART_MRVL131                0x131
+#define CPU_PART_ARM926                 0x926
+#define CPU_PART_ARM946                 0x946
+#define CPU_PART_MRVL_A9                0xC09
+#define CPU_PART_MRVL571                0x571
+#define CPU_PART_MRVL521                0x521
+
+#define CPU_PART_ARM_V6UP               0xb76
+#define CPU_PART_ARM_V7UP               0xc08
+#define CPU_PART_ARM_V6MP               0xb02
+
+#define CPU_PART_MRVLPJ4B_UP               0x581
+#define CPU_PART_MRVLPJ4B_MP               0x584
+
+#define MV_CPU_ARM_CLK_ELM_SIZE	    12
+#define MV_CPU_ARM_CLK_RATIO_OFF    8
+#define MV_CPU_ARM_CLK_DDR_OFF	    4
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClkRatio {
+	MV_U32	vco2cpu;	/* VCO:PCLK0(CPU) clock ratio */
+	MV_U32	vco2l2c;	/* VCO:NB(L2 cache) clock ratio */
+	MV_U32	vco2hcl;	/* VCO:HCLK(DDR controller) clock ratio */
+	MV_U32	vco2ddr;	/* VCO:DDR(DDR memory) clock ratio */
+
+} MV_CPU_ARM_CLK_RATIO;
+
+MV_U32  mvCpuPclkGet(MV_VOID);
+MV_VOID mvCpuNameGet(char *pNameBuff);
+MV_U32  mvCpuL2ClkGet(MV_VOID);
+MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+MV_U32  whoAmI(MV_VOID);
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
new file mode 100644
index 0000000..0712428
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -0,0 +1,377 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvCtrlEnvAddrDec.h - Marvell controller address decode library
+*
+* DESCRIPTION:
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "sys/mvCpuIf.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* Default Attributes array */
+MV_TARGET_ATTRIB mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
+extern MV_TARGET sampleAtResetTargetArray[];
+
+/*******************************************************************************
+* mvCtrlAttribGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	targetAttrib->attrib = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib;
+	targetAttrib->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib  = targetAttrib->attrib;
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId= targetAttrib->targetId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlGetAttrib -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == targetAttrib->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == targetAttrib->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlTargetByWinInfoGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == unitWinInfo->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == unitWinInfo->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlAddrWinMapBuild
+*
+* DESCRIPTION:
+*	Build the windows address decoding table, to be used for initializing
+*	the unit's address decoding windows.
+*
+* INPUT:
+*	pAddrWinMap: An array to hold the address decoding windows parameters.
+*	len: Number of entries in pAddrWinMap.
+*
+* OUTPUT:
+*	pAddrWinMap: Address window information.
+*
+* RETURN:
+*	MV_BAD_PARAM: input array is smaller than needed to store all window
+*	addresses.
+*	MV_ERROR: Otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i, j;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+	MV_U64 startAddr, endAddr;
+	MV_UNIT_WIN_INFO ioDdrWin[MV_DRAM_MAX_CS];
+	MV_U32 base;
+	MV_U64 size;
+
+	/* Check size of CPU address win table */
+	if (len <= MAX_TARGETS) {
+		mvOsPrintf("mvCtrlAddrWinMapBuild() - Table size too small.\n");
+		return MV_BAD_PARAM;
+	}
+
+	/* Prepare an array of DRAM info */
+	base = 0x0;
+	j = 0;
+	for (i = SDRAM_CS0; i <= SDRAM_CS3; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK) {
+			if (status == MV_NO_SUCH) {
+				ioDdrWin[i].enable = MV_FALSE;
+				continue;
+			} else {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCpuIfTargetWinGet() failed.\n");
+				return MV_ERROR;
+			}
+		}
+
+		/* As all IO address decode windows support only 32-bit
+		** addresses, limit the DRAM base / size to 4GB max.
+		*/
+		startAddr = (MV_U64)((((MV_U64)cpuAddrDecWin.addrWin.baseHigh << 32ll)) +
+				(MV_U64)cpuAddrDecWin.addrWin.baseLow);
+		endAddr = (MV_U64)(startAddr + (MV_U64)cpuAddrDecWin.addrWin.size) - 1;
+		if (endAddr > 0xFFFFFFFFll) {
+			if (startAddr <= 0xFFFFFFFFll)
+				cpuAddrDecWin.addrWin.size = (0x100000000ll -
+						cpuAddrDecWin.addrWin.baseLow);
+			else
+				cpuAddrDecWin.enable = MV_FALSE;
+		}
+
+		if (cpuAddrDecWin.enable == MV_FALSE)
+			continue;
+
+		/* If the endAddr passes minBase, then we need to split
+		** this window to several windows up to minBase.
+		** For example: minBase=0xE0000000, and CS0=2, CS1=2G,
+		** Then we need to split the windwos as follows:
+		** Win0: CS-0, 2GB (Base 0x0)
+		** win1: CS-1, 1GB (Base 0x80000000)
+		** Win2: CS-1, 0.5GB (Base 0xC0000000)
+		*/
+		if (endAddr > MV_DRAM_IO_RESERVE_BASE)
+			/* Need to cut down this CS to IO reserve base
+			** address.
+			*/
+			size = MV_DRAM_IO_RESERVE_BASE -
+				cpuAddrDecWin.addrWin.baseLow;
+		else
+			size = cpuAddrDecWin.addrWin.size;
+
+		if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+			mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+					"mvCtrlAttribGet() failed.\n");
+			return MV_ERROR;
+		}
+		/* Now, spread the last CS into several windows, and make sure
+		** that each of has a power-of-2 size.
+		*/
+		while (size != 0) {
+			ioDdrWin[j].enable = MV_TRUE;
+			ioDdrWin[j].attrib = targetAttrib.attrib;
+			ioDdrWin[j].targetId = targetAttrib.targetId;
+			ioDdrWin[j].addrWin.baseHigh = 0;
+			if (MV_IS_POWER_OF_2(size))
+				ioDdrWin[j].addrWin.size = size;
+			else
+				ioDdrWin[j].addrWin.size = (MV_U64)(1ll << (MV_U64)mvLog2(size));
+			size -= ioDdrWin[j].addrWin.size;
+			ioDdrWin[j].addrWin.baseLow = base;
+			base += ioDdrWin[j].addrWin.size;
+			j++;
+		}
+		/* Support only up to 4 DRAM address decode windows in the
+		** units. */
+		if (j == MV_DRAM_MAX_CS)
+			break;
+	}
+
+	for (; j < MV_DRAM_MAX_CS; j++)
+		ioDdrWin[j].enable = MV_FALSE;
+
+	/* Fill in the pAddrWinMap fields       */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (MV_TARGET_IS_DRAM(i)) {
+			pAddrWinMap[i].addrWin.baseLow = ioDdrWin[i].addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh = ioDdrWin[i].addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size = ioDdrWin[i].addrWin.size;
+			pAddrWinMap[i].enable = ioDdrWin[i].enable;
+			pAddrWinMap[i].attrib = ioDdrWin[i].attrib;
+			pAddrWinMap[i].targetId = ioDdrWin[i].targetId;
+		} else {
+			status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+			if (status != MV_OK) {
+				if (status == MV_NO_SUCH) {
+					pAddrWinMap[i].enable = MV_FALSE;
+					continue;
+				} else {
+					mvOsPrintf("mvCtrlAddrWinMapBuild()"
+					" - mvCpuIfTargetWinGet() failed.\n");
+					return MV_ERROR;
+				}
+			}
+
+			pAddrWinMap[i].addrWin.baseLow =
+				cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh =
+				cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size =
+				cpuAddrDecWin.addrWin.size;
+			pAddrWinMap[i].enable = cpuAddrDecWin.enable;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+						"mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinMap[i].attrib = targetAttrib.attrib;
+			pAddrWinMap[i].targetId = targetAttrib.targetId;
+		}
+	}
+	pAddrWinMap[i].addrWin.baseLow = TBL_TERM;
+	pAddrWinMap[i].addrWin.baseHigh = TBL_TERM;
+	pAddrWinMap[i].addrWin.size = TBL_TERM;
+	pAddrWinMap[i].enable = TBL_TERM;
+	pAddrWinMap[i].attrib = TBL_TERM;
+	pAddrWinMap[i].targetId = TBL_TERM;
+
+	return MV_OK;
+}
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK)
+			continue;
+
+		if ((physAddr >= cpuAddrDecWin.addrWin.baseLow) &&
+		    (physAddr < cpuAddrDecWin.addrWin.baseLow + cpuAddrDecWin.addrWin.size)) {
+			/* Found */
+			pAddrWinInfo->addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinInfo->addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinInfo->addrWin.size = cpuAddrDecWin.addrWin.size;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinInfo->attrib = targetAttrib.attrib;
+			pAddrWinInfo->targetId = targetAttrib.targetId;
+			return MV_OK;
+		}
+	}
+	/* not found */
+	return MV_NOT_FOUND;
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
new file mode 100644
index 0000000..dcecd06
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAddrDech
+#define __INCmvCtrlEnvAddrDech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+
+/* defines  */
+/* DUnit attributes */
+#define ATMWCR_WIN_DUNIT_CS0_OFFS		0
+#define ATMWCR_WIN_DUNIT_CS0_MASK		BIT0
+#define ATMWCR_WIN_DUNIT_CS0_REQ		(0 << ATMWCR_WIN_DUNIT_CS0_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS1_OFFS		1
+#define ATMWCR_WIN_DUNIT_CS1_MASK		BIT1
+#define ATMWCR_WIN_DUNIT_CS1_REQ 		(0 << ATMWCR_WIN_DUNIT_CS1_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS2_OFFS		2
+#define ATMWCR_WIN_DUNIT_CS2_MASK		BIT2
+#define ATMWCR_WIN_DUNIT_CS2_REQ 		(0 << ATMWCR_WIN_DUNIT_CS2_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS3_OFFS		3
+#define ATMWCR_WIN_DUNIT_CS3_MASK		BIT3
+#define ATMWCR_WIN_DUNIT_CS3_REQ 		(0 << ATMWCR_WIN_DUNIT_CS3_OFFS)
+
+/* RUnit (Device)  attributes */
+#define ATMWCR_WIN_RUNIT_DEVCS0_OFFS		0
+#define ATMWCR_WIN_RUNIT_DEVCS0_MASK		BIT0
+#define ATMWCR_WIN_RUNIT_DEVCS0_REQ		(0 << ATMWCR_WIN_RUNIT_DEVCS0_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS1_OFFS		1
+#define ATMWCR_WIN_RUNIT_DEVCS1_MASK		BIT1
+#define ATMWCR_WIN_RUNIT_DEVCS1_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS1_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS2_OFFS		2
+#define ATMWCR_WIN_RUNIT_DEVCS2_MASK		BIT2
+#define ATMWCR_WIN_RUNIT_DEVCS2_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS2_OFFS)
+
+#define ATMWCR_WIN_RUNIT_BOOTCS_OFFS		4
+#define ATMWCR_WIN_RUNIT_BOOTCS_MASK		BIT4
+#define ATMWCR_WIN_RUNIT_BOOTCS_REQ 		(0 << ATMWCR_WIN_RUNIT_BOOTCS_OFFS)
+
+/* LMaster (PCI)  attributes */
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS		0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_MASK		BIT0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP		(0 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_BYTE_NO_SWP		(1 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+
+
+#define ATMWCR_WIN_LUNIT_WORD_SWP_OFFS		1
+#define ATMWCR_WIN_LUNIT_WORD_SWP_MASK		BIT1
+#define ATMWCR_WIN_LUNIT_WORD_SWP		(0 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_WORD_NO_SWP		(1 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+
+#define ATMWCR_WIN_LUNIT_NO_SNOOP		BIT2
+
+#define ATMWCR_WIN_LUNIT_TYPE_OFFS		3
+#define ATMWCR_WIN_LUNIT_TYPE_MASK		BIT3
+#define ATMWCR_WIN_LUNIT_TYPE_IO		(0 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+#define ATMWCR_WIN_LUNIT_TYPE_MEM		(1 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+
+#define ATMWCR_WIN_LUNIT_FORCE64_OFFS		4
+#define ATMWCR_WIN_LUNIT_FORCE64_MASK		BIT4
+#define ATMWCR_WIN_LUNIT_FORCE64		(0 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+#define ATMWCR_WIN_LUNIT_ORDERING_OFFS		6
+#define ATMWCR_WIN_LUNIT_ORDERING_MASK		BIT6
+#define ATMWCR_WIN_LUNIT_ORDERING		(1 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+/* PEX Attributes */
+#define ATMWCR_WIN_PEX_TYPE_OFFS		3
+#define ATMWCR_WIN_PEX_TYPE_MASK		BIT3
+#define ATMWCR_WIN_PEX_TYPE_IO			(0 << ATMWCR_WIN_PEX_TYPE_OFFS)
+#define ATMWCR_WIN_PEX_TYPE_MEM			(1 << ATMWCR_WIN_PEX_TYPE_OFFS)
+
+/* typedefs */
+
+/* Unsupported attributes for address decode:                               */
+/* 2) PCI0/1_REQ64n control                                                 */
+
+typedef struct _mvTargetAttrib {
+	MV_U8			attrib;			/* chip select attributes */
+	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
+} MV_TARGET_ATTRIB;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin {
+    MV_TARGET	target;         /* Target for addr decode window        */
+    MV_ADDR_WIN	addrWin;        /* Address window of target             */
+    MV_BOOL	enable;         /* Window enable/disable                */
+} MV_DEC_WIN;
+
+typedef struct _mvDecWinParams {
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+} MV_DEC_WIN_PARAMS;
+
+
+/* mvCtrlEnvAddrDec API list */
+
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo);
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, MV_DEC_WIN_PARAMS *pWinParam);
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, MV_DEC_WIN *pAddrDecWin);
+
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len);
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvCtrlEnvAddrDech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
new file mode 100644
index 0000000..1a14a79
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAsmh
+#define __INCmvCtrlEnvAsmh
+#include "pex/mvPexRegs.h"
+
+#define CHIP_BOND_REG			0x18238
+#define PCKG_OPT_MASK_AS 		#3
+#define PXCCARI_REVID_MASK_AS		#PXCCARI_REVID_MASK
+
+/* Read device ID into toReg bits 15:0 from 0xd0000000 */
+/* defines  */
+#define MV_DV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_DV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read device ID into toReg bits 15:0 from 0xf1000000*/
+#define MV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read Revision into toReg bits 7:0 0xd0000000*/
+#define MV_DV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_DV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+/* Read Revision into toReg bits 7:0 0xf1000000*/
+#define MV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+#endif /* __INCmvCtrlEnvAsmh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100755
index 0000000..0703e8a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,2167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvSysEthConfig.h"
+
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+#include "eth/mvEth.h"
+#else
+#include "neta/gbe/mvNeta.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA */
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+#include "xor/mvXor.h"
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+#include "sata/CoreDriver/mvSata.h"
+#endif
+#if defined(MV_INCLUDE_USB)
+#include "usb/mvUsb.h"
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+#include "mvSysTdmConfig.h"
+#endif
+
+#include "ddr2_3/mvDramIfRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+MV_U32 dummyFlavour = 0;
+MV_BIOS_MODE bios_modes[BIOS_MODES_NUM] = {
+/*DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq  Altfabricfreq     FabricFreqMode CPU1/2/3Enable cpuEndianess dramBusWidth BootSRC BootWidth */
+/*	                       0x4d/[1:0]  0x4d/[4:2]  0x4e[0]      0x4e/[4:1]  	0x4f[0]   0x4f/[2:1]      0x4f/[3]   	  */
+{"78230",0x13, 0x7823, 0x1,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x1,	    0x0,	0x1, 	     0x3,	0x1},
+{"78260",0x14, 0x7826, 0x1,  0x3,      0x0,	 0x1a,		0x5,		0x1,	     0x1,	    0x0,	0x0, 	     0x3,	0x1},
+{"78460",0x15, 0x7846, 0x3,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x3,	    0x0,	0x0, 	     0x3,	0x1},
+{"78480",0x16, 0x7846, 0x3,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x3,	    0x0,	0x0, 	     0x3,	0x1}
+
+/*	{"6710" ,0x11, 0x6710,	0x0,	   0x3,		0x0,	      0x5, 		0x0,		0x0,		0x1,		0x0},     */
+};
+
+MV_BIOS_MODE bios_modes_b0[BIOS_MODES_NUM] = {
+/*DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq  Altfabricfreq  FabricFreqMode CPUEna  cpuEndianess dramBusWidth BootSRC BootWidth */
+/*	                       0x4d/[1:0]  0x4d/[4:2]  0x4e[0]      0x4e/[4:1]  	0x4f[0]   0x4f/[2:1]      0x4f/[3]   	  */
+{"78230",0x13, 0x7823, 0x1,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x1,	    0x0,		0x1, 	   0x3,		0x1},
+{"78260",0x14, 0x7826, 0x1,  0x3,      0x0,	 		0x5,		0x5,			0x1,	     0x1,	    0x0,		0x0, 	   0x3,		0x1},
+{"78460",0x15, 0x7846, 0x3,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x3,	    0x1,		0x0, 	   0x3,		0x1},
+{"78480",0x16, 0x7846, 0x3,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x3,	    0x1,		0x0, 	   0x3,		0x1}
+};
+
+MV_U32 mvCtrlGetCpuNum(MV_VOID)
+{
+	return ((MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET);
+}
+MV_U32 mvCtrlGetQuadNum(MV_VOID)
+{
+	return ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_L2_SIZE_MASK) >> SAR0_L2_SIZE_OFFSET);
+}
+MV_BOOL mvCtrlIsValidSatR(MV_VOID)
+{
+	int i = 0;
+	MV_U32 tmpSocCores;
+	MV_U8 cpuEna = 0;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 fabricFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreqMode;
+	MV_BIOS_MODE * pBbiosModes;
+
+#if defined(RD_88F78460_SERVER) || defined(DB_78X60_AMC)
+	MV_U32 confId = 0x15;
+#else
+	MV_U32 confId = mvBoardConfIdGet();
+#endif
+	l2size = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_L2_SIZE_MASK) >> SAR0_L2_SIZE_OFFSET;
+	cpuFreq = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_CPU_FREQ_MASK) >> SAR0_CPU_FREQ_OFFSET;
+	fabricFreq = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_FABRIC_FREQ_MASK) >> SAR0_FABRIC_FREQ_OFFSET;
+	tmpSocCores = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET;
+	cpuFreqMode = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_MODE_MASK) >> SAR1_CPU_MODE_OFFSET;
+	fabricFreqMode = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_FABRIC_MODE_MASK) >> SAR1_FABRIC_MODE_OFFSET;
+	/* Bug fix in HW, bit0 & bit1 are swapped */
+	cpuEna |= (tmpSocCores & 0x2) >> 1;
+	cpuEna |= (tmpSocCores & 0x1) << 1;
+	if (mvCtrlRevGet() == 2)
+		pBbiosModes = bios_modes_b0;
+	else
+		pBbiosModes = bios_modes;
+
+	/* Find out what is programmed in SAR and change device ID accordingly */
+	for (i = 0; i < BIOS_MODES_NUM; i++) {
+		if (pBbiosModes->confId == confId) {
+			DB(mvOsPrintf("confId = 0x%x\n", confId));
+			DB(mvOsPrintf("cpuFreq [0x%x] = 0x%x\n", cpuFreq, pBbiosModes->cpuFreq));
+			DB(mvOsPrintf("fabricFreq [0x%x] = 0x%x\n", fabricFreq, pBbiosModes->fabricFreq));
+			DB(mvOsPrintf("cpuEna [0x%x] = 0x%x\n", cpuEna, pBbiosModes->cpuEna));
+			DB(mvOsPrintf("cpuFreqMode [0x%x] = 0x%x\n", cpuFreqMode, pBbiosModes->cpuFreqMode));
+			DB(mvOsPrintf("fabricFreqMode [0x%x] = 0x%x\n", fabricFreqMode, pBbiosModes->fabricFreqMode));
+			DB(mvOsPrintf("l2size [0x%x] = 0x%x\n", l2size, pBbiosModes->l2size));
+			if ((cpuFreq == pBbiosModes->cpuFreq) &&
+				(fabricFreq ==  pBbiosModes->fabricFreq) &&
+				(cpuEna == pBbiosModes->cpuEna) &&
+				(cpuFreqMode == pBbiosModes->cpuFreqMode) &&
+				(fabricFreqMode == pBbiosModes->fabricFreqMode) &&
+				(l2size == pBbiosModes->l2size)) {
+				return MV_TRUE;
+			} else {
+				return MV_FALSE;
+			}
+		}
+		pBbiosModes++;
+	}
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+	MV_U32 mppGroup;
+	MV_U32 mppVal;
+	MV_U32 i, gppMask;
+
+
+	/* Disable MBus Error Propagation */
+	MV_REG_BIT_RESET(SOC_COHERENCY_FABRIC_CTRL_REG, BIT8);
+
+	/* Use Background sync barrier (polling) for I/O cache coherency */
+	MV_REG_BIT_SET(SOC_CIB_CTRL_CFG_REG, BIT8);
+
+	/* MPP Init - scan which modeule is connected */
+	mvBoardMppModulesScan();
+
+	/* Read MPP config values from board level and write MPP options to HW */
+	for (mppGroup = 0; mppGroup < MV_MPP_MAX_GROUP; mppGroup++) {
+		mppVal = mvBoardMppGet(mppGroup);	/* get pre-defined values */
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+	/* disable all GPIO interrupts */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+	}
+
+	/* clear all int */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++)
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+
+	/* Set gpp interrupts as needed */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		gppMask = mvBoardGpioIntMaskGet(i);
+		mvGppTypeSet(i, gppMask , (MV_GPP_IN & gppMask));
+		mvGppPolaritySet(i, gppMask , (MV_GPP_IN_INVERT & gppMask));
+	}
+
+	/* Scan for other modules (SERDES/LVDS/...) */
+	mvBoardOtherModulesScan();
+
+	/* Update interfaces configuration based on above scan */
+	if (MV_OK != mvCtrlSerdesPhyConfig())
+		mvOsPrintf("mvCtrlEnvInit: Can't init some or all SERDES lanes\n");
+
+	MV_REG_BIT_SET(PUP_EN_REG,0x17); /* Enable GBE0, GBE1, LCD and NFC PUP */
+
+	mvOsDelay(100);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+	MV_U32 ret;
+
+	if (mppGroup >= MV_MPP_MAX_GROUP)
+		mppGroup = 0;
+
+	ret = MPP_CONTROL_REG(mppGroup);
+
+	return ret;
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 7;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_PEX_MAX_IF;
+
+	default:
+		return 0;
+	}
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlPexMaxUnitGet - Get Marvell controller number of PEX units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxUnitGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 2;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+		return 3;
+
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_PEX_MAX_UNIT;
+
+	default:
+		return 0;
+	}
+}
+
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPciMaxIfGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_FPGA_DEV_ID:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+	switch (devId) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return MV_78130_ETH_MAX_PORT;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_78460_ETH_MAX_PORT;
+
+	default:
+		return 0;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlEthMaxCPUsGet - Get Marvell controller number of CPUs.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of CPUs.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of CPUs.
+*
+*******************************************************************************/
+MV_U8 mvCtrlEthMaxCPUsGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+
+	/* FIXME - assuming MV_78460_DEV_ID */
+	devId = MV_78460_DEV_ID;
+
+	switch (devId) {
+	case MV_78130_DEV_ID:
+	case MV_78230_DEV_ID:
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+		return 4;
+
+	default:
+		return 0;
+	}
+}
+
+
+#if defined(MV_INCLUDE_SATA)
+/*******************************************************************************
+* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of Sata ports.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of Sata ports.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_SATA_MAX_CHAN;
+		break;
+	}
+	return res;
+}
+#endif
+
+#if defined(MV_INCLUDE_IDMA)
+/*******************************************************************************
+* mvCtrlIdmaMaxChanGet - Get Marvell controller number of IDMA channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of IDMA channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of IDMA channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_IDMA_MAX_CHAN;
+		break;
+	}
+	return res;
+}
+
+/*******************************************************************************
+* mvCtrlIdmaMaxUnitGet - Get Marvell controller number of IDMA units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of IDMA units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of IDMA units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_IDMA_MAX_UNIT;
+		break;
+	}
+	return res;
+}
+#endif /* MV_INCLUDE_IDMA */
+
+#if defined(MV_INCLUDE_XOR)
+/*******************************************************************************
+* mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_XOR_MAX_CHAN;
+		break;
+	}
+	return res;
+}
+
+/*******************************************************************************
+* mvCtrlXorMaxUnitGet - Get Marvell controller number of XOR units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_XOR_MAX_UNIT;
+		break;
+	}
+	return res;
+}
+
+#endif
+
+#if defined(MV_INCLUDE_USB)
+/*******************************************************************************
+* mvCtrlUsbHostMaxGet - Get number of Marvell Usb  controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB  controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsbMaxGet(void)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	case MV_FPGA_DEV_ID:
+		res = 0;
+		break;
+
+	default:
+		res = ARMADA_XP_MAX_USB_PORTS;
+		break;
+	}
+
+	return res;
+}
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND)
+/*******************************************************************************
+* mvCtrlNandSupport - Return if this controller has integrated NAND flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if NAND is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlNandSupport(MV_VOID)
+{
+	return ARMADA_XP_NAND;
+}
+#endif
+
+#if defined(MV_INCLUDE_SDIO)
+/*******************************************************************************
+* mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SDIO is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlSdioSupport(MV_VOID)
+{
+	return ARMADA_XP_SDIO;
+}
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmSupport(MV_VOID)
+{
+	return ARMADA_XP_TDM;
+}
+
+/*******************************************************************************
+* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       The number of TDM ports in device.
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmMaxGet(MV_VOID)
+{
+	return ARMADA_XP_MAX_TDM_PORTS;
+}
+
+/*******************************************************************************
+* mvCtrlTdmTypeGet
+*
+* DESCRIPTION:
+*	Return the TDM unit type being compiled in.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TDM unit type.
+*
+*******************************************************************************/
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID)
+{
+	return TDM_UNIT_32CH;
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitIrqGet
+*
+* DESCRIPTION:
+*	Return the TDM unit IRQ number depending on the TDM unit compilation
+*	options.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+******************************************************************************/
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
+{
+	return MV_TDM_IRQ_NUM;
+}
+
+#endif /* if defined(MV_INCLUDE_TDM) */
+
+/*******************************************************************************
+* mvCtrlModelGet - Get Marvell controller device model (Id)
+*
+* DESCRIPTION:
+*       This function returns 16bit describing the device model (ID) as defined
+*       in PCI Device and Vendor ID configuration register offset 0x0.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit desscribing Marvell controller ID
+*
+*******************************************************************************/
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U16 model = 0;
+	MV_U32 reg, reg2;
+
+	/* if PEX0 clocks are disabled - enabled it to read */
+	reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
+		reg2 = ((reg & ~PMC_PEXSTOPCLOCK_MASK(0)) | PMC_PEXSTOPCLOCK_EN(0));
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg2);
+	}
+
+	devId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+
+	/* Reset the original value of the PEX0 clock */
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg);
+
+
+	model = (MV_U16) ((devId >> 16) & 0xFFFF);
+
+	return model;
+}
+
+/*******************************************************************************
+* mvCtrlRevGet - Get Marvell controller device revision number
+*
+* DESCRIPTION:
+*       This function returns 8bit describing the device revision as defined
+*       in PCI Express Class Code and Revision ID Register.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit desscribing Marvell controller revision number
+*
+*******************************************************************************/
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	MV_U8 revNum;
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Check pex power state */
+	MV_U32 pexPower;
+	pexPower = mvCtrlPwrClckGet(PEX_UNIT_ID, 0);
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_TRUE);
+#endif
+	revNum = (MV_U8) MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PCI_CLASS_CODE_AND_REVISION_ID));
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Return to power off state */
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_FALSE);
+#endif
+	return ((revNum & PCCRIR_REVID_MASK) >> PCCRIR_REVID_OFFS);
+}
+
+/*******************************************************************************
+* mvCtrlNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlNameGet(char *pNameBuff)
+{
+	if (mvCtrlModelGet() == 0x7800)
+		mvOsSPrintf(pNameBuff, "%s78XX", SOC_NAME_PREFIX);
+	else
+		mvOsSPrintf(pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX, mvCtrlModelGet(), mvCtrlRevGet());
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlModelRevGet - Get Controller Model (Device ID) and Revision
+*
+* DESCRIPTION:
+*       This function returns 32bit value describing both Device ID and Revision
+*       as defined in PCI Express Device and Vendor ID Register and device revision
+*	    as defined in PCI Express Class Code and Revision ID Register.
+
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing both controller device ID and revision number
+*
+*******************************************************************************/
+MV_U32 mvCtrlModelRevGet(MV_VOID)
+{
+	return ((mvCtrlModelGet() << 16) | mvCtrlRevGet());
+}
+
+/*******************************************************************************
+* mvCtrlModelRevNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
+{
+	switch (mvCtrlModelRevGet()) {
+	case MV_78130_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78130_Z1_NAME);
+		break;
+
+	case MV_6710_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_6710_Z1_NAME);
+		break;
+
+	case MV_78230_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78230_Z1_NAME);
+		break;
+	case MV_78160_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78160_Z1_NAME);
+		break;
+	case MV_78260_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78260_Z1_NAME);
+		break;
+	case MV_78460_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78460_Z1_NAME);
+		break;
+
+	 case MV_78130_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78130_A0_NAME);
+               break;
+       case MV_78230_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78230_A0_NAME);
+               break;
+       case MV_78160_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78160_A0_NAME);
+               break;
+       case MV_78260_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78260_A0_NAME);
+               break;
+       case MV_78460_A0_ID:
+              mvOsSPrintf(pNameBuff, "%s", MV_78460_A0_NAME);
+               break;
+	case MV_78130_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78130_B0_NAME);
+			  break;
+	  case MV_78230_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78230_B0_NAME);
+			  break;
+	  case MV_78160_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78160_B0_NAME);
+			  break;
+	  case MV_78260_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78260_B0_NAME);
+			  break;
+	  case MV_78460_B0_ID:
+			 mvOsSPrintf(pNameBuff, "%s", MV_78460_B0_NAME);
+			  break;
+
+	default:
+		mvCtrlNameGet(pNameBuff);
+		break;
+	}
+
+	return MV_OK;
+}
+
+MV_U32 gDevId = -1;
+/*******************************************************************************
+* mvCtrlDevFamilyIdGet - Get Device ID
+*
+* DESCRIPTION:
+*       This function returns Device ID.
+*
+* INPUT:
+*       ctrlModel.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board Device ID number, '-1' if Device ID is undefined.
+*
+*******************************************************************************/
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
+{
+	if (gDevId == -1)
+	{
+		switch (ctrlModel) {
+		case MV_78130_DEV_ID:
+		case MV_78160_DEV_ID:
+		case MV_78230_DEV_ID:
+		case MV_78260_DEV_ID:
+		case MV_78460_DEV_ID:
+		case MV_78000_DEV_ID:
+			gDevId=MV_78XX0;
+			return gDevId;
+			break;
+		default:
+			return MV_ERROR;
+		}
+	}
+	else
+		return gDevId;
+}
+
+static const char *cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
+{
+	if (target >= MAX_TARGETS)
+		return "target unknown";
+
+	return cntrlName[target];
+}
+
+/*******************************************************************************
+* mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
+*
+* DESCRIPTION:
+*		This function print the PEX address decode map (BARs and windows).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
+{
+	MV_PEX_BAR pexBar;
+	MV_PEX_DEC_WIN win;
+	MV_U32 pexIf;
+	MV_U32 bar, winNum;
+	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pexIf = 0; pexIf < boardPexInfo->boardPexIfNum; pexIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pexIf];
+
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("PEX%d:\n", pexHWInf);
+		mvOsOutput("-----\n");
+
+		mvOsOutput("\nPex Bars \n\n");
+
+		for (bar = 0; bar < PEX_MAX_BARS; bar++) {
+			memset(&pexBar, 0, sizeof(MV_PEX_BAR));
+
+			mvOsOutput("%s ", pexBarNameGet(bar));
+
+			if (mvPexBarGet(pexHWInf, bar, &pexBar) == MV_OK) {
+				if (pexBar.enable) {
+					mvOsOutput("base %08x, ", pexBar.addrWin.baseLow);
+					if (pexBar.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(pexBar.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+		mvOsOutput("\nPex Decode Windows\n\n");
+
+		for (winNum = 0; winNum < PEX_MAX_TARGET_WIN - 2; winNum++) {
+			memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+			mvOsOutput("win%d - ", winNum);
+
+			if (mvPexTargetWinRead(pexHWInf, winNum, &win) == MV_OK) {
+				if (win.winInfo.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win.winInfo)),
+						   win.winInfo.addrWin.baseLow);
+					mvOsOutput("....");
+					mvSizePrint(win.winInfo.addrWin.size);
+
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("default win - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_DEFAULT, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("Expansion ROM - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_EXP_ROM, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvUnitAddrDecShow - Print the Unit's address decode map.
+*
+* DESCRIPTION:
+*       This is a generic function for printing the different unit's address
+*	decode map.
+*
+* INPUT:
+*       unit	- The unit to print the address decode for.
+*	name	- The unit's name.
+*	winGetFuncPtr - A pointer to the HAL's window get function.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId, const char *name, MV_WIN_GET_FUNC_PTR winGetFuncPtr)
+{
+	MV_UNIT_WIN_INFO win;
+	MV_U32 unit, i;
+
+	for (unit = 0; unit < numUnits; unit++) {
+
+		if (MV_FALSE == mvCtrlPwrClckGet(unitId, unit))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("%s %d:\n", name, unit);
+		mvOsOutput("----\n");
+
+		for (i = 0; i < 16; i++) {
+			memset(&win, 0, sizeof(MV_UNIT_WIN_INFO));
+
+			mvOsOutput("win%d - ", i);
+
+			if (winGetFuncPtr(unit, i, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win)),
+						   win.addrWin.baseLow);
+					mvOsOutput("....");
+					if (win.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* mvCtrlAddrDecShow - Print the Controller units address decode map.
+*
+* DESCRIPTION:
+*		This function the Controller units address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlAddrDecShow(MV_VOID)
+{
+	mvCpuIfAddDecShow();
+	mvAhbToMbusAddDecShow();
+#if defined(MV_INCLUDE_PEX)
+	mvCtrlPexAddrDecShow();
+#endif
+#if defined(MV_INCLUDE_USB)
+	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
+#endif
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#else
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
+#endif /* MV_ETH_LEGACY */
+#endif /* MV_INCLUDE_GIG_ETH */
+
+#if defined(MV_INCLUDE_XOR)
+	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
+#endif
+#if defined(MV_INCLUDE_SATA)
+	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
+#endif
+}
+
+/*******************************************************************************
+* ctrlSizeToReg - Extract size value for register assignment.
+*
+* DESCRIPTION:
+*       Address decode size parameter must be programed from LSB to MSB as
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
+*       value of 0x00ff specifies 256x64k = 16 MB).
+*       This function extract the size value from the size parameter according
+*       to given aligment paramter. For example for size 0x1000000 (16MB) and
+*       aligment 0x10000 (64KB) the function will return 0x00FF.
+*
+* INPUT:
+*       size - Size.
+*       alignment - Size alignment. Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size register value correspond to size parameter.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 retVal;
+
+	/* Check size parameter alignment               */
+	if ((0 == size) || (MV_IS_NOT_ALIGN(size, alignment))) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
+		return -1;
+	}
+
+	/* Take out the "alignment" portion out of the size parameter */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+	/* and size is 0x1000000 (16MB) for example     */
+	while (alignment & 1) {	/* Check that alignmet LSB is set       */
+		size = (size >> 1);	/* If LSB is set, move 'size' one bit to right      */
+		alignment = (alignment >> 1);
+	}
+
+	/* If after the alignment first '0' was met we still have '1' in                */
+	/* it then aligment is invalid (not power of 2)                                 */
+	if (alignment) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", (MV_U32) alignment));
+		return -1;
+	}
+
+	/* Now the size is shifted right according to aligment: 0x0100                  */
+	size--;			/* Now the size is a sequance of '1': 0x00ff                    */
+	retVal = size;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	while (size & 1)	/* Check that LSB is set    */
+		size = (size >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (size) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", size));
+		return -1;
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+* ctrlRegToSize - Extract size value from register value.
+*
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*       according to given aligment paramter. For example for register size
+*       value 0xff and aligment 0x10000 the function will return 0x01000000.
+*
+* INPUT:
+*       regSize   - Size as in register format.	See ctrlSizeToReg.
+*       alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
+{
+	MV_U32 temp;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff            */
+
+	while (temp & 1)	/* Check that LSB is set                                    */
+		temp = (temp >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (temp) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n", regSize));
+		return -1;
+	}
+
+	/* Check that aligment is a power of two                                        */
+	temp = alignment - 1;	/* Now the alignmet is a sequance of '1' (0xffff)          */
+
+	while (temp & 1)	/* Check that alignmet LSB is set                           */
+		temp = (temp >> 1);	/* If LSB is set, move 'size' one bit to right      */
+
+	/* If after the 'temp' first '0' was met we still have '1' in 'temp'            */
+	/* then 'temp' is invalid (not power of 2)                                      */
+	if (temp) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", alignment));
+		return -1;
+	}
+
+	regSize++;		/* Now the size is 0x0100                                       */
+
+	/* Add in the "alignment" portion to the register size parameter                */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+
+	while (alignment & 1) {	/* Check that alignmet LSB is set                       */
+		regSize = (regSize << 1);	/* LSB is set, move 'size' one bit left     */
+		alignment = (alignment >> 1);
+	}
+
+	return regSize;
+}
+
+/*******************************************************************************
+* ctrlSizeRegRoundUp - Round up given size
+*
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
+*       restrictions of size format given an aligment parameter.
+*		to given aligment paramter. For example for size parameter 0xa1000 and
+*		aligment 0x1000 the function will return 0xFF000.
+*
+* INPUT:
+*       size - Size.
+*		alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size value correspond to size in register.
+*******************************************************************************/
+MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 msbBit = 0;
+	MV_U32 retSize;
+
+	/* Check if size parameter is already comply with restriction   */
+	if (!(-1 == ctrlSizeToReg(size, alignment)))
+		return size;
+
+	while (size) {
+		size = (size >> 1);
+		msbBit++;
+	}
+
+	retSize = (1 << msbBit);
+
+	if (retSize < alignment)
+		return alignment;
+	else
+		return retSize;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNOR
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from NOR flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if (satr == MSAR_BOOT_NOR)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromSPI
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from SPI flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if (satr == MSAR_BOOT_SPI)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNAND
+*
+* DESCRIPTION:
+*       Check if device is confiogured to boot from NAND flash according to the SAR
+*	registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from NAND.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if ((satr == MSAR_BOOT_DOVE_NAND) || (satr == MSAR_BOOT_LEGACY_NAND))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckSet - Set Power State for specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+
+		break;
+#endif
+	case TDM_32CH_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrClckGet - Get Power State of specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	MV_BOOL state = MV_TRUE;
+
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if ((reg & PMC_PEXSTOPCLOCK_MASK(index)) == PMC_PEXSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if ((reg & PMC_GESTOPCLOCK_MASK(index)) == PMC_GESTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		if ((reg & PMC_SATASTOPCLOCK_MASK(index)) == PMC_SATASTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((reg & PMC_CESASTOPCLOCK_MASK) == PMC_CESASTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if ((reg & PMC_USBSTOPCLOCK_MASK(index)) == PMC_USBSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if ((reg & PMC_SDIOSTOPCLOCK_MASK) == PMC_SDIOSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TDM)
+	case TDM_32CH_UNIT_ID:
+		if ((reg & PMC_TDMSTOPCLOCK_MASK) == PMC_TDMSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemSet - Set Power State for memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_MASK);
+
+		break;
+#endif
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemGet - Get Power State of memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg;
+	MV_BOOL state = MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX));
+		if ((reg & PMC_PEXSTOPMEM_MASK(index)) == PMC_PEXSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE));
+		if ((reg & PMC_GESTOPMEM_MASK(index)) == PMC_GESTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA));
+		if ((reg & PMC_SATASTOPMEM_MASK(index)) == PMC_SATASTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA));
+		if ((reg & PMC_CESASTOPMEM_MASK) == PMC_CESASTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB));
+		if ((reg & PMC_USBSTOPMEM_MASK(index)) == PMC_USBSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR));
+		if ((reg & PMC_XORSTOPMEM_MASK(index)) == PMC_XORSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM));
+		if ((reg & PMC_BMSTOPMEM_MASK) == PMC_BMSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC));
+		if ((reg & PMC_PNCSTOPMEM_MASK) == PMC_PNCSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+#else
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	return;
+}
+
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	return MV_TRUE;
+}
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+/*******************************************************************************
+* mvCtrlSerdesMaxLinesGet - Get Marvell controller number of SERDES lines.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 7;
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+		return 12;
+		break;
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return 16;
+	default:
+		return 0;
+	}
+}
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x1400);
+
+	return (reg & 0x8000) ? 64 : 32;
+}
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x20184);
+
+	return (reg & 0x1) ? MV_FALSE : MV_TRUE;
+}
+
+MV_BOOL mvCtrlDDRECC(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_ECC_OFFS)) ? MV_TRUE : MV_FALSE;
+}
+
+static const MV_U8 serdesCfg[][8] = SERDES_CFG;
+
+/*******************************************************************************
+* mvCtrlSerdesPhyConfig
+*
+* DESCRIPTION:
+*	Configure Serdes MUX and init PHYs connected to SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Status
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
+{
+	MV_U32		socCtrlReg, RegX4, serdesLine0_7;
+	MV_U32		serdesLineCfg;
+	MV_U8		serdesLineNum;
+	MV_U8		pexIf;
+	MV_U8		pexUnit;
+	MV_STATUS	status = MV_OK;
+	MV_U32 		pexIfNum = mvCtrlPexMaxIfGet();
+	MV_U8		maxSerdesLines = mvCtrlSerdesMaxLinesGet();
+	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
+
+/* this is a mapping of the final power management clock gating control register value @ 0x18220.*/
+	MV_U32	powermngmntctrlregmap = 0x0;
+	MV_U32	tmpcounter = 0;
+
+	/* Check if no SERDESs available - FPGA */
+	if (maxSerdesLines == 0)
+		return MV_OK;
+
+	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
+	socCtrlReg = MV_REG_READ(SOC_CTRL_REG);
+	RegX4 = MV_REG_READ(GEN_PURP_RES_2_REG);
+	boardPexInfo->pexUnitCfg[0].pexCfg = ((RegX4 & 0x0F) == 0x0F) ? PEX_BUS_MODE_X4: PEX_BUS_MODE_X1;
+	boardPexInfo->pexUnitCfg[1].pexCfg = ((RegX4 & 0x0F0) == 0x0F0) ? PEX_BUS_MODE_X4: PEX_BUS_MODE_X1;
+	boardPexInfo->pexUnitCfg[2].pexCfg = ((RegX4 & 0x0F00) == 0x0F00) ? PEX_BUS_MODE_X4: PEX_BUS_MODE_X1;
+	boardPexInfo->pexUnitCfg[3].pexCfg = ((RegX4 & 0x0F000) == 0x0F000) ? PEX_BUS_MODE_X4: PEX_BUS_MODE_X1;
+
+	serdesLine0_7 = MV_REG_READ(SERDES_LINE_MUX_REG_0_7);
+	/* Prepare PHY parameters for each step according to  MUX selection */
+	for (pexIf = 0; pexIf < pexIfNum; pexIf++) {
+		/* for each serdes lane*/
+		pexUnit    = (pexIf<9)? (pexIf >> 2) : 3;
+		if ((socCtrlReg & (1 << pexUnit)) == 0) {
+			boardPexInfo->pexUnitCfg[pexUnit].pexCfg = PEX_BUS_DISABLED;
+			continue;
+		}
+		if (pexIf < 8) {
+			serdesLineCfg = (serdesLine0_7 >> (pexIf << 2)) & 0xF;
+			if (serdesLineCfg != serdesCfg[pexIf][SERDES_UNIT_PEX])
+				continue;
+		}
+		boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = pexIf;
+		boardPexInfo->boardPexIfNum++;
+		boardPexInfo->pexUnitCfg[pexUnit].pexLaneStat[pexIf] = 0x1;
+		powermngmntctrlregmap = powermngmntctrlregmap | (0x1<<(pexIf+5));
+		if (pexIf < 8) {
+			if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_MODE_X4) {
+				powermngmntctrlregmap |= (0xf<<(pexIf+5));
+				pexIf += 3;
+			} else
+				powermngmntctrlregmap |= (0x1<<(pexIf+5));
+		} else
+			powermngmntctrlregmap |= (0x1<<(18+pexIf));
+	}
+
+	for (serdesLineNum = 0; serdesLineNum < 8; serdesLineNum++) {
+		serdesLineCfg =(serdesLine0_7 >> (serdesLineNum << 2)) & 0xF;
+		if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SATA]) {
+			if ((serdesLineNum == 4) || (serdesLineNum == 6))
+				powermngmntctrlregmap |= PMC_SATASTOPCLOCK_MASK(0);
+			else if (serdesLineNum == 5)
+				powermngmntctrlregmap |= PMC_SATASTOPCLOCK_MASK(1);
+			else
+				goto err_cfg;		
+
+		} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII0])
+				powermngmntctrlregmap |= PMC_GESTOPCLOCK_MASK(0);
+			else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII1])
+				powermngmntctrlregmap |=  PMC_GESTOPCLOCK_MASK(1);
+			else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII2])
+				powermngmntctrlregmap |= PMC_GESTOPCLOCK_MASK(2);
+			else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII3])
+				powermngmntctrlregmap |= PMC_GESTOPCLOCK_MASK(3);
+			else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_QSGMII])
+				powermngmntctrlregmap |= PMC_GESTOPCLOCK_MASK(0) | PMC_GESTOPCLOCK_MASK(1) | PMC_GESTOPCLOCK_MASK(2) | PMC_GESTOPCLOCK_MASK(3);
+	}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	powermngmntctrlregmap = powermngmntctrlregmap | BIT4; /* Enabling port GE0 always since we need SMI 0 to access other PHYs*/
+	/*check if GE1 is not enabled via MPPs and not Serdes - if yes you have to enable the clock*/
+		if (MV_TRUE ==  mvBoardIsGbEPortConnected(1))
+			powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(1);
+
+
+	/* Hard core enable DDR, USB, SDIO, LCD, XOR, IDMA, CESA cause we don't support this at this momemt*/
+	powermngmntctrlregmap = powermngmntctrlregmap | (BIT0  | BIT13 | (0x1FF<<16) | BIT24 | BIT25 | BIT28 | BIT31);
+	DB(mvOsPrintf("%s:Shutting down unused interfaces:\n", __func__));
+	/*now report everything to the screen*/
+	if (!(powermngmntctrlregmap & PMC_SATASTOPCLOCK_MASK(0))) {
+		DB(mvOsPrintf("%s:       SATA0\n", __func__));
+		mvCtrlPwrClckSet(SATA_UNIT_ID, 0, MV_FALSE);
+	}
+	if (!(powermngmntctrlregmap & PMC_SATASTOPCLOCK_MASK(1))) {
+		DB(mvOsPrintf("%s:       SATA1\n", __func__));
+		mvCtrlPwrClckSet(SATA_UNIT_ID, 1, MV_FALSE);
+	}
+	for (tmpcounter = 0; tmpcounter < 4; tmpcounter++) {
+		if (!(powermngmntctrlregmap & (1 << (4 - tmpcounter)))) {
+			/*mvOsOutput("       GBE%d\n", tmpcounter );*/
+			DB(mvOsPrintf("%s:       GBE%d\n", __func__, tmpcounter));
+			mvCtrlPwrClckSet(ETH_GIG_UNIT_ID, tmpcounter, MV_FALSE);
+		}
+	}
+	for (tmpcounter = 0; tmpcounter < 8; tmpcounter++) {
+		if (!(powermngmntctrlregmap & (1 << (5 + tmpcounter)))) {
+			DB(mvOsPrintf("%s:       PEX%d.%d\n", __func__, tmpcounter>>2, tmpcounter % 4));
+			mvCtrlPwrClckSet(PEX_UNIT_ID, tmpcounter, MV_FALSE);
+		}
+	}
+	if (!(powermngmntctrlregmap & BIT26)) {
+		DB(mvOsPrintf("%s:       PEX2\n", __func__));
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 8, MV_FALSE);
+	}
+	if (!(powermngmntctrlregmap & BIT27)) {
+		DB(mvOsPrintf("%s:       PEX3\n", __func__));
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 9, MV_FALSE);
+	}
+
+
+/*this code is valid for all devices after Z1*/
+	if(!(powermngmntctrlregmap & BIT25)) {
+		DB(mvOsPrintf("%s:       TDM\n", __func__));
+		mvCtrlPwrClckSet(TDM_32CH_UNIT_ID, 0, MV_FALSE);
+	}
+	/*apply clock gatting*/
+	MV_REG_WRITE(POWER_MNG_CTRL_REG, MV_REG_READ(POWER_MNG_CTRL_REG) & powermngmntctrlregmap);
+	/*the Sata driver doesn't support clock gating at this point so we enable the logic to the block*/
+	MV_REG_WRITE(POWER_MNG_CTRL_REG, MV_REG_READ(POWER_MNG_CTRL_REG) | (BIT15 | BIT30));
+#endif /* defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+
+	return status;
+err_cfg:
+	DB(mvOsPrintf("%s: Wrong CFG (%#x) for SERDES line %d.\n",
+		__func__, serdesLineCfg, serdesLineNum));
+	return MV_ERROR;
+
+}
+
+/*******************************************************************************
+* mvCtrlGetJuncTemp
+*
+* DESCRIPTION:
+*       Read temperature, calibrate at first time the TSEN
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Tj value.
+*******************************************************************************/
+MV_U32 mvCtrlGetJuncTemp(MV_VOID)
+{
+	MV_32 reg = 0;
+
+	/* init the TSEN sensor once */
+	if ((MV_REG_READ(TSEN_CONF_REG) & TSEN_CONF_OTF_CALIB_MASK) == 0) {
+		MV_REG_BIT_SET(TSEN_CONF_REG, TSEN_CONF_OTF_CALIB_MASK);
+
+		reg = MV_REG_READ(TSEN_CONF_REG);
+		reg &= ~(TSEN_CONF_REF_CAL_MASK);
+		reg |= (0xf1 << 11);
+		MV_REG_WRITE(TSEN_CONF_REG, reg);
+
+		/* Do not start calibration sequence */
+		MV_REG_BIT_RESET(TSEN_CONF_REG, TSEN_CONF_START_CALIB_MASK);
+
+		/* Initiate Soft Reset*/
+		MV_REG_BIT_SET(TSEN_CONF_REG, TSEN_CONF_SOFT_RESET_MASK);
+		mvOsDelay(1);
+
+		/* Exit from Soft Reset*/
+		MV_REG_BIT_RESET(TSEN_CONF_REG, TSEN_CONF_SOFT_RESET_MASK);
+		mvOsDelay(10);
+	}
+
+	reg = MV_REG_READ(TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+#ifdef ERRATA_FE_982377
+	{ /* Internal CPU Temperature Read Out Stability */
+		int reg1, reg2, reg3, i;
+		for (i = 0; i < 20; i++) {
+			reg1 = MV_REG_READ(TSEN_STATUS_REG);
+			reg1 = (reg1 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			reg2 = MV_REG_READ(TSEN_STATUS_REG);
+			reg2 = (reg2 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			reg3 = MV_REG_READ(TSEN_STATUS_REG);
+			reg3 = (reg3 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			if ((reg1 == reg2) && (reg1 == reg3)) {
+				reg = reg1;
+				break;
+			}
+		}
+	}
+#endif
+	return (3153000 - (10000 * reg)) / 13825;
+}
+
+
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100755
index 0000000..65c7fc0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,279 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+/* includes */
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+/*#include "boardEnv/mvBoardEnvLib.h"*/
+
+/* 0 for Auto scan mode, 1 for manual. */
+#define MV_INTERNAL_SWITCH_SMI_SCAN_MODE	0
+
+/* typedefs */
+typedef MV_STATUS(*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+/* This enumerator describes the possible HW cache coherency policies the   */
+/* controllers supports.                                                    */
+typedef enum _mvCachePolicy {
+    NO_COHERENCY,   /* No HW cache coherency support                        */
+    WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
+    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
+} MV_CACHE_POLICY;
+
+
+/* The swapping is referred to a 64-bit words (as this is the controller    */
+/* internal data path width). This enumerator describes the possible        */
+/* data swap types. Below is an example of the data 0x0011223344556677      */
+typedef enum _mvSwapType {
+    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */
+    MV_NO_SWAP,         /* No swapping              00 11 22 33 44 55 66 77 */
+    MV_BYTE_WORD_SWAP,  /* Both byte and word swap  33 22 11 00 77 66 55 44 */
+    MV_WORD_SWAP,       /* Word swap                44 55 66 77 00 11 22 33 */
+    SWAP_TYPE_MAX	/* Delimiter for this enumerator                    */
+} MV_SWAP_TYPE;
+
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7,
+	SERDES_UNIT_LAST
+} MV_SERDES_UNIT_INDX;
+
+typedef enum {
+	PEX_BUS_DISABLED	= 0,
+	PEX_BUS_MODE_X1		= 1,
+	PEX_BUS_MODE_X4		= 2,
+	PEX_BUS_MODE_X8		= 3
+} MV_PEX_UNIT_CFG;
+
+/* Configuration per SERDES line.
+   Each nibble is MV_SERDES_LINE_TYPE */
+typedef struct _boardSerdesConf {
+	MV_U32 enableSerdesConfiguration; /*This will determine if mvCtrlSerdesPhyConfig will configure the serdes*/
+	MV_U32	serdesLine0_7;	/* Lines 0 to 7 SERDES MUX one nibble per line */
+	MV_U32	serdesLine8_15;	/* Lines 8 to 15 SERDES MUX one nibble per line */
+	MV_PEX_UNIT_CFG		pex0Mod;
+	MV_PEX_UNIT_CFG		pex1Mod;
+	MV_PEX_UNIT_CFG		pex2Mod;
+	MV_PEX_UNIT_CFG		pex3Mod;
+	MV_U32	busSpeed;	/* Bus speed - one bit per SERDES line:
+	Low speed (0)		High speed (1)
+	PEX	2.5 G (10 bit)		5 G (20 bit)
+	SATA	1.5 G			3 G
+	SGMII 	1.25 Gbps		3.125 Gbps	*/
+} MV_SERDES_CFG;
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG					0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+
+
+/* BIOS Modes related defines */
+
+#define SAR0_BOOTWIDTH_OFFSET	3
+#define SAR0_BOOTWIDTH_MASK		(0x3 << SAR0_BOOTWIDTH_OFFSET)
+#define SAR0_BOOTSRC_OFFSET		5
+#define SAR0_BOOTSRC_MASK		(0xF << SAR0_BOOTSRC_OFFSET)
+
+#define SAR0_L2_SIZE_OFFSET		19
+#define SAR0_L2_SIZE_MASK		(0x3 << SAR0_L2_SIZE_OFFSET)
+#define SAR0_CPU_FREQ_OFFSET	21
+#define SAR0_CPU_FREQ_MASK		(0x7 << SAR0_CPU_FREQ_OFFSET)
+#define SAR0_FABRIC_FREQ_OFFSET	24
+#define SAR0_FABRIC_FREQ_MASK	(0xF << SAR0_FABRIC_FREQ_OFFSET)
+#define SAR0_CPU0CORE_OFFSET	31
+#define SAR0_CPU0CORE_MASK		(0x1 << SAR0_CPU0CORE_OFFSET)
+#define SAR1_CPU0CORE_OFFSET	0
+#define SAR1_CPU0CORE_MASK		(0x1 << SAR1_CPU0CORE_OFFSET)
+
+#define PEX_CLK_100MHZ_OFFSET	2
+#define PEX_CLK_100MHZ_MASK     (0x1 << PEX_CLK_100MHZ_OFFSET)
+
+#define SAR1_CPU_CORE_OFFSET	3
+#define SAR1_CPU_CORE_MASK		(0x3 << SAR1_CPU_CORE_OFFSET)
+#define SAR1_FABRIC_MODE_OFFSET	19
+#define SAR1_FABRIC_MODE_MASK	(0x1 << SAR1_FABRIC_MODE_OFFSET)
+#define SAR1_CPU_MODE_OFFSET	20
+#define SAR1_CPU_MODE_MASK		(0x1 << SAR1_CPU_MODE_OFFSET)
+
+#define SAR_CPU_FAB_GET(cpu, fab)	(((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+#define BIOS_MODES_NUM			4
+
+typedef struct {
+	char *name;
+	MV_U16 confId;
+	MV_U16 code;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreq;
+	MV_U8 AltfabricFreq;
+	MV_U8 fabricFreqMode;
+	MV_U8 cpuEna;
+	MV_U8 cpuEndianess;
+	MV_U8 dramBusWidth;
+	MV_U8 bootSource;
+	MV_U8 bootWidth;
+} MV_BIOS_MODE;
+
+extern MV_BIOS_MODE bios_modes[];
+extern MV_BIOS_MODE bios_modes_b0[];
+
+/* mcspLib.h API list */
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_U32 mvCtrlGetQuadNum(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32	mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32	mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPexMaxIfGet()	(0)
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+MV_U32	mvCtrlPciMaxIfGet(MV_VOID);
+#else
+#define mvCtrlPciIfMaxIfGet()	(mvCtrlPexMaxIfGet())
+#endif
+
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
+#if defined(MV_INCLUDE_IDMA)
+MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID);
+MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+MV_U32	  mvCtrlNandSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32	  mvCtrlSdioSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
+#endif
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID   mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32	  ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32	  ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32	  ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32	  mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_VOID   mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_BOOL	  mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index);
+
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID);
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID);
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+MV_U32 mvCtrlGetJuncTemp(MV_VOID);
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100755
index 0000000..67dd2de
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,569 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0 	PEX0_MEM
+#define PCI0_MEM0	PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID		0x008
+#define PCCRIR_REVID_OFFS			0		/* Revision ID */
+#define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM				56
+
+
+/* Coherent Fabric Control and Status */
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/* PMU_NFABRIC PMU_NFABRIC PMU_UNIT_SERVICE Units */
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_REG		(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x4)
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_PWR_DOWN	(1 << 20)
+
+#define MV_L2C_NFABRIC_PWR_DOWN_FLOW_CTRL_REG	(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x8)
+
+#define PM_CONTROL_AND_CONFIG_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x4)
+#define PM_CONTROL_AND_CONFIG_DFS_REQ		(1 << 18)
+#define PM_CONTROL_AND_CONFIG_PWDDN_REQ		(1 << 16)
+#define PM_CONTROL_AND_CONFIG_L2_PWDDN		(1 << 20)
+
+#define PM_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0xc)
+#define PM_STATUS_AND_MASK_CPU_IDLE_WAIT	(1 << 16)
+#define PM_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT	(1 << 17)
+#define PM_STATUS_AND_MASK_IRQ_WAKEUP		(1 << 20)
+#define PM_STATUS_AND_MASK_FIQ_WAKEUP		(1 << 21)
+#define PM_STATUS_AND_MASK_DBG_WAKEUP		(1 << 22)
+#define PM_STATUS_AND_MASK_IRQ_MASK		(1 << 24)
+#define PM_STATUS_AND_MASK_FIQ_MASK		(1 << 25)
+
+#define PM_EVENT_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x20)
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_OFFS			1
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_MASK_OFFS		17
+
+#define PM_CPU_BOOT_ADDR_REDIRECT(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x24)
+
+/* Power Management Memory Power Down Registers 1 - 6 */
+#define POWER_MNG_MEM_CTRL_REG(num)		((num) < 6 ? 0x1820C + (num) * 4 : 0x18228)
+#define PMC_MCR_NUM_COMM			6
+#define PMC_MCR_NUM_PEX				2
+#define PMC_MCR_NUM_USB				4
+#define PMC_MCR_NUM_DUNIT			3
+#define PMC_MCR_NUM_DEVB			4
+#define PMC_MCR_NUM_NF				4
+#define PMC_MCR_NUM_XOR				4
+#define PMC_MCR_NUM_SATA			5
+#define PMC_MCR_NUM_CESA			4
+#define PMC_MCR_NUM_GE				5
+#define PMC_MCR_NUM_PNC				5
+#define PMC_MCR_NUM_BM				5
+#define PMC_MCR_NUM_PDMA			1
+#define PMC_MCR_NUM_NCS				3
+#define PMC_MCR_NUM_CFU				3
+#define PMC_MCR_NUM_L2				3
+#define PMC_MCR_NUM_CIB				3
+#define PMC_MCR_NUM_CPU				3
+#define PMC_MCR_NUM_IDMA			4
+#define PMC_MCR_NUM_LCD				4
+#define PMC_MCR_NUM_PMU				6
+
+#define PMC_COMMSTOPMEM_OFFS			4
+#define PMC_COMMSTOPMEM_MASK			(7 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_EN			(0 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_STOP			(1 << PMC_COMMSTOPMEM_OFFS)
+
+#define PMC_PEXSTOPMEM_OFFS(port)		((port) < 10 ? ((port) * 3) : 0)
+#define PMC_PEXSTOPMEM_MASK(port)		(7 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_EN(port)			(0 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_STOP(port)		(1 << PMC_PEXSTOPMEM_OFFS(port))
+
+#define PMC_USBSTOPMEM_OFFS(port)		((port) < 3 ? (3 + (port) * 3) : 0)
+#define PMC_USBSTOPMEM_MASK(port)		(7 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_EN(port)			(0 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_STOP(port)		(1 << PMC_USBSTOPMEM_OFFS(port))
+
+#define PMC_DUNITSTOPMEM_OFFS			12
+#define PMC_DUNITSTOPMEM_MASK			(7 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_EN			(0 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_STOP			(1 << PMC_DUNITSTOPMEM_OFFS)
+
+#define PMC_NFSTOPMEM_OFFS			27
+#define PMC_NFSTOPMEM_MASK			(7 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_EN			(0 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_STOP			(1 << PMC_NFSTOPMEM_OFFS)
+
+#define PMC_DEVBSTOPMEM_OFFS			21
+#define PMC_DEVBSTOPMEM_MASK			(7 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_EN			(0 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_STOP			(1 << PMC_DEVBSTOPMEM_OFFS)
+
+#define PMC_XORSTOPMEM_OFFS(port)		((port) == 0 ? 15 : 24)
+#define PMC_XORSTOPMEM_MASK(port)		(7 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_EN(port)			(0 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_STOP(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+
+#define PMC_SATASTOPMEM_OFFS(port)		((port) == 0 ? 18 : 24)
+#define PMC_SATASTOPMEM_MASK(port)		(0x3F << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_EN(port)		(0 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_STOP(port)		(9 << PMC_SATASTOPMEM_OFFS(port))
+
+#define PMC_CESASTOPMEM_OFFS			18
+#define PMC_CESASTOPMEM_MASK			(7 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_EN			(0 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_STOP			(1 << PMC_CESASTOPMEM_OFFS)
+
+#define PMC_GESTOPMEM_OFFS(port)		((port) < 4 ? (9 - (port) * 3) : 0)
+#define PMC_GESTOPMEM_MASK(port)		(7 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_EN(port)			(0 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_STOP(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+
+#define PMC_PNCSTOPMEM_OFFS			12
+#define PMC_PNCSTOPMEM_MASK			(7 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_EN			(0 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_STOP			(1 << PMC_PNCSTOPMEM_OFFS)
+
+#define PMC_BMSTOPMEM_OFFS			15
+#define PMC_BMSTOPMEM_MASK			(7 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_EN			(0 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_STOP			(1 << PMC_BMSTOPMEM_OFFS)
+
+#define PMC_PDMASTOPMEM_OFFS			0
+#define PMC_PDMATOPMEM_MASK			(7 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_EN			(0 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_STOP			(1 << PMC_PDMASTOPMEM_OFFS)
+
+#define PMC_NCSSTOPMEM_OFFS			24
+#define PMC_NCSSTOPMEM_MASK			(7 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_EN			(0 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_STOP			(1 << PMC_NCSSTOPMEM_OFFS)
+
+#define PMC_CFUSTOPMEM_OFFS			21
+#define PMC_CFUSTOPMEM_MASK			(7 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_EN			(0 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_STOP			(1 << PMC_CFUSTOPMEM_OFFS)
+
+#define PMC_L2STOPMEM_OFFS			18
+#define PMC_L2STOPMEM_MASK			(7 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_EN			(0 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_STOP			(1 << PMC_L2STOPMEM_OFFS)
+
+#define PMC_CIBSTOPMEM_OFFS			15
+#define PMC_CIBSTOPMEM_MASK			(7 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_EN			(0 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_STOP			(1 << PMC_CIBSTOPMEM_OFFS)
+
+/* TODO - verify, the manual has no description */
+#define PMC_CPUSTOPMEM_OFFS(id)			((id) < 4 ? (id) * 3 : 0)
+#define PMC_CPUSTOPMEM_MASK(id)			(7 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
+
+#define PMC_IDMASTOPMEM_OFFS			12
+#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
+
+#define PMC_LCDSTOPMEM_OFFS			0
+#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
+
+#define PMC_PMUSTOPMEM_OFFS			0
+#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
+
+
+/*  Power Management Clock Gating Control Register	*/
+#define POWER_MNG_CTRL_REG			0x18220
+#define L2C_MTCMOS_CONTROL_0_REG    0x22F00
+#define L2C_MTCMOS_CONTROL_1_REG    0x22F04
+
+#define PMU_DFS_CTRL_REG(cpu)			(MV_RUNIT_PMU_REGS_OFFSET + 0x54 + ((cpu) * 0x4))
+#define PMU_DFS_CTRL_INIT_RATIO_OFFS	24
+#define PMU_DFS_CTRL_INIT_RATIO_MASK	0x3F
+#define PMU_DFS_CTRL_RATIO_OFFS			16
+#define PMU_DFS_CTRL_RATIO_MASK			0x3F
+
+#define PMC_TDMSTOPCLOCK_OFFS			25
+#define PMC_TDMSTOPCLOCK_MASK			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_EN			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_STOP			(0 << PMC_TDMSTOPCLOCK_OFFS)
+
+#define PMC_PEXSTOPCLOCK_OFFS(port)		((port) < 8 ? (5 + (port)) : (18 + (port)))
+#define PMC_PEXSTOPCLOCK_MASK(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_EN(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_STOP(port)		(0 << PMC_PEXSTOPCLOCK_OFFS(port))
+
+#define PMC_USBSTOPCLOCK_OFFS(port)		((port) < 3 ? (18 + (port)) : 0)
+#define PMC_USBSTOPCLOCK_MASK(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_EN(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_STOP(port)		(0 << PMC_USBSTOPCLOCK_OFFS(port))
+
+#define PMC_SDIOSTOPCLOCK_OFFS			17
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_RUNITSTOPCLOCK_OFFS			24
+#define PMC_RUNITSTOPCLOCK_MASK			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_EN			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_STOP			(0 << PMC_RUNITSTOPCLOCK_OFFS)
+
+#define PMC_XORSTOPCLOCK_OFFS			22
+#define PMC_XORSTOPCLOCK_MASK			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_EN			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_STOP			(0 << PMC_XORSTOPCLOCK_OFFS)
+
+#define PMC_SATASTOPCLOCK_OFFS(ch)		(ch == 0 ? 14 : 29)
+#define PMC_SATASTOPCLOCK_MASK(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_EN(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_STOP(ch)		(0 << PMC_SATASTOPCLOCK_OFFS(ch))
+
+#define PMC_CESASTOPCLOCK_OFFS			23
+#define PMC_CESASTOPCLOCK_MASK			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_EN			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_STOP			(0 << PMC_CESASTOPCLOCK_OFFS)
+
+#define PMC_GESTOPCLOCK_OFFS(port)		((port) < 4 ? (4 - (port)) : 0)
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+#define PMC_NETASTOPCLOCK_OFFS			13
+#define PMC_NETASTOPCLOCK_MASK			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_EN			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_STOP			(0 << PMC_NETASTOPCLOCK_OFFS)
+
+#define PMC_LCDSTOPCLOCK_OFFS			16
+#define PMC_LCDSTOPCLOCK_MASK			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_EN			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_STOP			(0 << PMC_LCDSTOPCLOCK_OFFS)
+
+#define PMC_IDMASTOPCLOCK_OFFS			21
+#define PMC_IDMASTOPCLOCK_MASK			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_EN			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_STOP			(0 << PMC_IDMASTOPCLOCK_OFFS)
+
+#define PMC_DDRSTOPCLOCK_OFFS			28
+#define PMC_DDRSTOPCLOCK_MASK			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_EN			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_STOP			(0 << PMC_DDRSTOPCLOCK_OFFS)
+
+#define SATA_IMP_TX_SSC_CTRL_REG(port)		(0xA2810 + (port)*0x2000)
+#define SATA_GEN_1_SET_0_REG(port)			(0xA2834 + (port)*0x2000)
+#define SATA_GEN_1_SET_1_REG(port)			(0xA2838 + (port)*0x2000)
+#define SATA_GEN_2_SET_0_REG(port)			(0xA283C + (port)*0x2000)
+#define SATA_GEN_2_SET_1_REG(port)			(0xA2840 + (port)*0x2000)
+
+#define SATA_PWR_PLL_CTRL_REG(port)			(0xA2804 + (port)*0x2000)
+#define SATA_DIG_LP_ENA_REG(port)			(0xA288C + (port)*0x2000)
+#define SATA_REF_CLK_SEL_REG(port)			(0xA2918 + (port)*0x2000)
+#define SATA_COMPHY_CTRL_REG(port)			(0xA2920 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_CTRL_REG(port)		(0xA2058 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_STAT_REG(port)		(0xA205C + (port)*0x2000)
+
+#define SGMII_PWR_PLL_CTRL_REG(port)		(0x72E04 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_DIG_LP_ENA_REG(port)		(0x72E8C + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_REF_CLK_SEL_REG(port)		(0x72F18 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_CFG_REG(port)		(0x724A0 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_STAT_REG(port)		(0x724A4 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_COMPHY_CTRL_REG(port)		(0x72F20 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define QSGMII_GEN_1_SETTING_REG(port)		(0x72E38 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+
+#define SERDES_LINE_MUX_REG_0_7			0x18270
+#define SERDES_LINE_MUX_REG_8_15		0x18274
+#define QSGMII_CONTROL_1_REG                    0x18404
+/* Controler environment registers offsets */
+#define GEN_PURP_RES_1_REG			0x182F4
+#define GEN_PURP_RES_2_REG			0x182F8
+
+#define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
+
+/* Sample at Reset */
+#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
+
+/* SYSRSTn Length Counter */
+#define SYSRST_LENGTH_COUNTER_REG		0x18250
+#define SLCR_COUNT_OFFS				0
+#define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS				31
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
+
+/* Device ID */
+#define CHIP_BOND_REG				0x18238
+#define PCKG_OPT_MASK				0x3
+
+#define MPP_OUTPUT_DRIVE_REG			0x184E4
+#define MPP_GE_A_OUTPUT_DRIVE_OFFS		6
+#define MPP_GE_A_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_A_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_OUTPUT_DRIVE_OFFS		14
+#define MPP_GE_B_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+
+#define MSAR_BOOT_MODE_OFFS			5
+#define MSAR_BOOT_MODE_MASK			(0xF << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_NOR				(0x0 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI				(0x3 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_DOVE_NAND			(0x1 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_LEGACY_NAND			(0x6 << MSAR_BOOT_MODE_OFFS)
+
+#define MSAR_TCLK_OFFS				28
+#define MSAR_TCLK_MASK				(0x1 << MSAR_TCLK_OFFS)
+
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG				0x1864C
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+#define MSAR_CPU_CLK_IDX(sar0, sar1)		((((sar0) >> 21) & 0x7) + ((((sar1) >> 20) & 1) << 3))
+#define MSAR_CPU_CLK_TWSI(sar0, sar1)		((((sar0) >> 2)  & 0x7) + (((sar1) & 1) << 3))
+#define MSAR_DDR_L2_CLK_RATIO_IDX(sar0, sar1)	((((sar0) >> 24) & 0xF) + ((((sar1) >> 19) & 1) << 4))
+#define MSAR_DDR_L2_CLK_RATIO_TWSI(sar0)	(((sar0) >> 1)  & 0xF)
+
+#ifndef MV_ASMLANGUAGE
+
+#define MV_CPU_CLK_TBL { 1000, 1066, 1200, 1333, 1500, 1666, 1800, 2000,\
+			  600,  667,  800, 1600, 2133, 2200, 2400, 0 }
+
+/*		cpu	l2c	hclk	ddr	*/
+#define MV_DDR_L2_CLK_RATIO_TBL    { \
+/*00*/	{	1,	1,	4,	2	},\
+/*01*/	{	1,	2,	2,	2	},\
+/*02*/	{	2,	2,	6,	3	},\
+/*03*/	{	2,	2,	3,	3	},\
+/*04*/	{	1,	2,	3,	3	},\
+/*05*/	{	1,	2,	4,	2	},\
+/*06*/	{	1,	1,	2,	2	},\
+/*07*/	{	2,	3,	6,	6	},\
+/*08*/	{	2,	3,	5,	5	},\
+/*09*/	{	1,	2,	6,	3	},\
+/*10*/	{	2,	4,	10,	5	},\
+/*11*/	{	1,	3,	6,	6	},\
+/*12*/	{	1,	2,	4,	4	},\
+/*13*/	{	1,	3,	6,	3	},\
+/*14*/	{	1,	2,	5,	5	},\
+/*15*/	{	2,	2,	5,	5	},\
+/*16*/	{	1,	1,	3,	3	},\
+/*17*/	{	2,	5,	10,	10	},\
+/*18*/	{	1,	3,	8,	4	},\
+/*19*/	{	1,	1,	2,	1	},\
+/*20*/	{	2,	3,	6,	3	},\
+/*21*/	{	1,	2,	8,	4	},\
+/*22*/	{	2,	5,	10,	5	} \
+}
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+		((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+		((target >= PEX0_MEM) && (target <= PEX0_IO))
+#define MV_TARGET_IS_PEX1(target)   \
+		((target >= PEX1_MEM) && (target <= PEX1_IO))
+#define MV_TARGET_IS_PEX2(target)   \
+		((target >= PEX2_MEM) && (target <= PEX2_IO))
+#define MV_TARGET_IS_PEX3(target)   \
+		((target >= PEX3_MEM) && (target <= PEX3_IO))
+#define MV_TARGET_IS_PEX4(target)   \
+		((target >= PEX4_MEM) && (target <= PEX4_IO))
+#define MV_TARGET_IS_PEX5(target)   \
+		((target >= PEX5_MEM) && (target <= PEX5_IO))
+#define MV_TARGET_IS_PEX6(target)   \
+		((target >= PEX6_MEM) && (target <= PEX6_IO))
+#define MV_TARGET_IS_PEX7(target)   \
+		((target >= PEX7_MEM) && (target <= PEX7_IO))
+#define MV_TARGET_IS_PEX8(target)   \
+		((target >= PEX8_MEM) && (target <= PEX8_IO))
+#define MV_TARGET_IS_PEX9(target)   \
+		((target >= PEX9_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_PEX(target)	((target >= PEX0_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_DEVICE(target)	((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_PCI_DRAM_BAR_TO_DRAM_TARGET(bar)   0
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
+
+
+#define BOOT_TARGETS_NAME_ARRAY {	\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	TBL_TERM, 			\
+	TBL_TERM, 			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	BOOT_ROM_CS			\
+}
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0		PEX0_MEM
+#define PCI_IF0_IO		PEX0_IO
+
+/* This enumerator defines the Marvell controller target ID  (see Address map) */
+typedef enum _mvTargetId {
+    DRAM_TARGET_ID	= 0,	/* Port 0 -> DRAM interface		*/
+    DEV_TARGET_ID	= 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+    PEX0_2_TARGET_ID	= 4,	/* Port 4 -> PCI Express 0 and 2	*/
+    PEX1_3_TARGET_ID	= 8,	/* Port 4 -> PCI Express 1 and 3	*/
+    CRYPT_TARGET_ID	= 9,	/* Port 9 --> Crypto Engine SRAM	*/
+    PNC_BM_TARGET_ID	= 12,  	/* Port 12 -> PNC + BM Unit		*/
+    MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+/*
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7
+} MV_SERDES_UNIT_INDX;
+*/
+
+/*
+	This structure refrect registers:
+	Serdes 0-7 selectors		0x18270
+	and Serdes 8-15 selectors  	0x18274
+*/
+
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1,  3}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1,  2 ,  4, -1,  3, -1, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 8 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+
+
+/*
+	This enum should reflect the units numbers in register
+	space which we will need when accessing the HW
+*/
+
+typedef enum {
+	PEX0_0x4	= 0,
+	PEX0_1x4	= 1,
+	PEX0_2x4	= 2,
+	PEX0_3x4	= 3,
+	PEX1_0x4	= 4,
+	PEX1_1x4	= 5,
+	PEX1_2x4	= 6,
+	PEX1_3x4	= 7,
+	PEX2_0x4	= 8,
+	PEX3_0x4	= 9,
+	PEXIF_MAX	= 10
+} MV_PEXIF_INDX;
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100755
index 0000000..ec29890
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,494 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX				"MV88F"
+
+/*
+ * Armada-XP Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET			(0x0)
+#define MV_AURORA_L2_REGS_OFFSET		(0x8000)
+#define MV_RTC_REGS_OFFSET			(0x10300)
+#define MV_DEV_BUS_REGS_OFFSET			(0x10400)
+#define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
+#define MV_UART_REGS_OFFSET(chanNum)		(0x12000 + (chanNum * 0x100))
+#define MV_RUNIT_PMU_REGS_OFFSET		(0x1C000)
+#define MV_MPP_REGS_OFFSET			(0x18000)
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x40))
+#define MV_MISC_REGS_OFFSET			(0x18200)
+#define MV_CLK_CMPLX_REGS_OFFSET	(0x18700)
+#define MV_MBUS_REGS_OFFSET			(0x20000)
+#define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
+#define MV_CNTMR_REGS_OFFSET			(0x20300)
+#define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)		(0x21800 + (cpu) * 0x100)
+#define MV_PMU_NFABRIC_UNIT_SERV_OFFSET		(0x22000)
+#define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
+#define MV_CPU_HW_SEM_OFFSET			(0x20500)
+
+#if defined(MV_ETH_LEGACY)
+	#define MV_ETH_BASE_ADDR		(0x72000)
+#else
+	#define MV_ETH_BASE_ADDR		(0x70000)
+#endif
+#define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000) \
+											 : (0x42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)       		(0x50000 + (dev * 0x1000))
+#define MV_XOR_REGS_OFFSET(unit)		(unit ? 0xF0900 : 0x60900)
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_REGS_OFFSET			(0x60800)
+#endif
+#define MV_CESA_TDMA_REGS_OFFSET(chanNum)	(0x90000 + (chanNum * 0x2000))
+#define MV_CESA_REGS_OFFSET(chanNum)		(0x9D000 + (chanNum * 0x2000))
+#define MV_SATA_REGS_OFFSET			(0xA0000)
+#define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
+#define MV_NFC_REGS_OFFSET			(0xD0000)
+#define MV_BM_REGS_OFFSET			(0xC0000)
+#define MV_PNC_REGS_OFFSET			(0xC8000)
+#define MV_SDMMC_REGS_OFFSET			(0xD4000)
+
+
+#ifdef CONFIG_ARMADA_XP_ERRATA_SMI_1
+	#define MV_ETH_SMI_PORT   1
+#else
+    #define MV_ETH_SMI_PORT   0
+#endif
+
+#define MV_SERDES_NUM_TO_PEX_NUM(sernum)	((sernum < 8) ? (sernum) : (8 + (sernum/12)))
+/*
+ * Miscellanuous Controller Configurations
+ */
+
+#define AVS_CONTROL2_REG			0x20868
+#define AVS_LOW_VDD_LIMIT			0x20860
+
+#define INTER_REGS_SIZE				_1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)		((ch) + 3)
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS				68
+#define MV_GPP_MAX_GROUP    			3 /* group == configuration register? */
+#define MV_CNTMR_MAX_COUNTER 		8 /* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
+
+/*
+	MV88F78X60_Z1								MV88F78X60_A0
+	-------------------------------             -------------------------------
+	Global Counters 0-3  : 0-3         		    Global Counters 0-3  		: 0-3
+	Global WD            : 4                    Global WD            		: 4
+
+	CPU 0 Counter 0-1    : 5-6					Private CPU Counter 0-1    : 5-6
+	CPU 0 WD             : 7                    Private CPU WD             : 7
+	CPU 1 Counter 0-1    : 8-9
+	CPU 1 WD             : 10
+	CPU 2 Counter 0-1    : 11-12
+	CPU 2 WD             : 13
+	CPU 3 Counter 0-1    : 14-15
+	CPU 3 WD             : 16
+*/
+
+#define MV_UART_MAX_CHAN			4
+
+#define MV_XOR_MAX_UNIT				2 /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN         		4 /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
+
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_MAX_UNIT			1 /* IDMA unit == IDMA engine */
+#define MV_IDMA_MAX_CHAN			4 /* total channels for all units together */
+#endif
+
+#define MV_SATA_MAX_CHAN			2
+
+#define MV_MPP_MAX_GROUP			9
+
+#define MV_DRAM_MAX_CS				4
+#define MV_SPI_MAX_CS				8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+ #define MV_PCI_MAX_IF				1
+ #define MV_PCI_START_IF			0
+ #define PCI_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PCI_HOST_DEV_NUM(pciIf)               0
+#else
+ #define MV_PCI_MAX_IF				0
+ #define MV_PCI_START_IF			0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF				10
+#define MV_PEX_MAX_UNIT				4
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF				MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces 	*/
+#define MV_IDMA_MAX_CHAN			4
+#define ARMADA_XP_MAX_USB_PORTS			3
+#define ARMADA_XP_NAND				1
+#define ARMADA_XP_SDIO				1
+#define ARMADA_XP_MAX_TDM_PORTS			32
+#define ARMADA_XP_TDM				1
+#define MV_DEVICE_MAX_CS      			4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS (ARMADA_XP_MAX_USB_PORTS)
+#endif
+
+
+/* CESA version #3: One channel, 2KB SRAM, TDMA, CHAIN Mode support */
+#define MV_CESA_VERSION				3 /*TODO verify */
+#define MV_CESA_SRAM_SIZE               	(2 * 1024)
+
+
+/* This define describes the maximum number of supported Ethernet ports */
+/* TODO - verify all these numbers */
+#define MV_ETH_VERSION 				4 /* for Legacy mode */
+#define MV_NETA_VERSION				1 /* for NETA mode */
+#define MV_ETH_MAX_PORTS			4
+#define MV_ETH_MAX_RXQ              		8
+#define MV_ETH_MAX_TXQ              		8
+#define MV_ETH_TX_CSUM_MAX_SIZE 		9800
+#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
+
+/* New GMAC module is used */
+#define MV_ETH_GMAC_NEW
+/* New WRR/EJP module is used */
+#define MV_ETH_WRR_NEW
+/* IPv6 parsing support for Legacy parser */
+#define MV_ETH_LEGACY_PARSER_IPV6
+/* New PNC module - extra fields */
+#define MV_ETH_PNC_NEW
+/* PNC Load Balancing support */
+#define MV_ETH_PNC_LB
+
+#define MV_78130_ETH_MAX_PORT			3
+#define MV_78460_ETH_MAX_PORT			4
+
+/* This define describes the the support of USB */
+#define MV_USB_VERSION  			1
+
+#define MV_SPI_VERSION				2
+
+#define MV_INCLUDE_SDRAM_CS0
+#define MV_INCLUDE_SDRAM_CS1
+#define MV_INCLUDE_SDRAM_CS2
+#define MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED	0	/* Used to mark unused entry */
+
+typedef enum {
+	TDM_UNIT_32CH
+} MV_TDM_UNIT_TYPE;
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_32CH_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	SDIO_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,        /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*0 SDRAM chip select 0		*/
+	SDRAM_CS1,	/*1 SDRAM chip select 1		*/
+	SDRAM_CS2,	/*2 SDRAM chip select 2		*/
+	SDRAM_CS3,	/*3 SDRAM chip select 3		*/
+	DEVICE_CS0,	/*4 Device chip select 0		*/
+	DEVICE_CS1,	/*5 Device chip select 1		*/
+	DEVICE_CS2,	/*6 Device chip select 2		*/
+	DEVICE_CS3,	/*7 Device chip select 3		*/
+	PEX0_MEM,	/*8 PCI Express 0 Memory		*/
+	PEX0_IO,	/*9 PCI Express 0 IO		*/
+	PEX1_MEM,	/*10 PCI Express 1 Memory		*/
+	PEX1_IO,	/*11 PCI Express 1 IO		*/
+	PEX2_MEM,	/*12 PCI Express 2 Memory		*/
+	PEX2_IO,	/*13 PCI Express 2 IO		*/
+	PEX3_MEM,	/*14 PCI Express 3 Memory		*/
+	PEX3_IO,	/*15 PCI Express 3 IO		*/
+	PEX4_MEM,	/*16 PCI Express 4 Memory		*/
+	PEX4_IO,	/*17 PCI Express 4 IO		*/
+	PEX5_MEM,	/*18 PCI Express 5 Memory		*/
+	PEX5_IO,	/*19 PCI Express 5 IO		*/
+	PEX6_MEM,	/*20 PCI Express 6 Memory		*/
+	PEX6_IO,	/*21 PCI Express 6 IO		*/
+	PEX7_MEM,	/*22 PCI Express 7 Memory		*/
+	PEX7_IO,	/*23 PCI Express 7 IO		*/
+	PEX8_MEM,	/*24 PCI Express 8 Memory		*/
+	PEX8_IO,	/*25 PCI Express 8 IO		*/
+	PEX9_MEM,	/*26 PCI Express 9 Memory		*/
+	PEX9_IO,	/*27 PCI Express 9 IO		*/
+	INTER_REGS,	/*28 Internal registers		*/
+	DMA_UART,	/*29 DMA based UART request	*/
+	SPI_CS0,	/*30 SPI_CS0			*/
+	SPI_CS1,	/*31 SPI_CS1			*/
+	SPI_CS2,	/*32 SPI_CS2			*/
+	SPI_CS3,	/*33 SPI_CS3			*/
+	SPI_CS4,	/*34 SPI_CS4			*/
+	SPI_CS5,	/*35 SPI_CS5			*/
+	SPI_CS6,	/*36 SPI_CS6			*/
+	SPI_CS7,	/*37 SPI_CS7			*/
+	BOOT_ROM_CS, /*38 BOOT_ROM_CS			*/
+	DEV_BOOCS,	/*39 DEV_BOOCS			*/
+	PMU_SCRATCHPAD,	/*40 PMU Scratchpad		*/
+	CRYPT0_ENG,	/* 41 Crypto0 Engine		*/
+	CRYPT1_ENG,	/* 42 Crypto1 Engine		*/
+	PNC_BM,		/* 43 PNC + BM 		        */
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR		0x1E
+#define DRAM_CS1_ATTR		0x1D
+#define DRAM_CS2_ATTR		0x1B
+#define DRAM_CS3_ATTR		0x17
+#else
+#define DRAM_CS0_ATTR		0x0E
+#define DRAM_CS1_ATTR		0x0D
+#define DRAM_CS2_ATTR		0x0B
+#define DRAM_CS3_ATTR		0x07
+#endif
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define MAIN_BOOT_ATTR		0x2F	/* Boot Device CS - NOR */
+ #define SEC_BOOT_ATTR		0x1D	/* BootROM - Dummy */
+#else
+ #define MAIN_BOOT_ATTR		0x1D	/* BootROM */
+ #define SEC_BOOT_ATTR		0x2F	/* Boot Device CS */
+#endif
+
+#define TARGETS_DEF_ARRAY	{			\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID    }, /* DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID    }, /* DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID    }, /* DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID    }, /* DEVICE_CS3 */	\
+	{0xE8, PEX0_2_TARGET_ID }, /* PEX0_LANE0_MEM */	\
+	{0xE0, PEX0_2_TARGET_ID }, /* PEX0_LANE0_IO */	\
+	{0xD8, PEX0_2_TARGET_ID }, /* PEX0_LANE1_MEM */	\
+	{0xD0, PEX0_2_TARGET_ID }, /* PEX0_LANE1_IO */	\
+	{0xB8, PEX0_2_TARGET_ID }, /* PEX0_LANE2_MEM */	\
+	{0xB0, PEX0_2_TARGET_ID }, /* PEX0_LANE2_IO */	\
+	{0x78, PEX0_2_TARGET_ID }, /* PEX0_LANE3_MEM */	\
+	{0x70, PEX0_2_TARGET_ID }, /* PEX0_LANE3_IO */	\
+	{0xE8, PEX1_3_TARGET_ID }, /* PEX1_LANE0_MEM */	\
+	{0xE0, PEX1_3_TARGET_ID }, /* PEX1_LANE0_IO */	\
+	{0xD8, PEX1_3_TARGET_ID }, /* PEX1_LANE1_MEM */	\
+	{0xD0, PEX1_3_TARGET_ID }, /* PEX1_LANE1_IO */	\
+	{0xB8, PEX1_3_TARGET_ID }, /* PEX1_LANE2_MEM */	\
+	{0xB0, PEX1_3_TARGET_ID }, /* PEX1_LANE2_IO */	\
+	{0x78, PEX1_3_TARGET_ID }, /* PEX1_LANE3_MEM */	\
+	{0x70, PEX1_3_TARGET_ID }, /* PEX1_LANE3_IO */	\
+	{0xF8, PEX0_2_TARGET_ID }, /* PEX2_LANE0_MEM */	\
+	{0xF0, PEX0_2_TARGET_ID }, /* PEX2_LANE0_IO */	\
+	{0xF8, PEX1_3_TARGET_ID }, /* PEX3_LANE0_MEM */	\
+	{0xF0, PEX1_3_TARGET_ID }, /* PEX3_LANE0_IO */	\
+	{0xFF, 0xFF             }, /* INTER_REGS */	\
+	{0x01, DEV_TARGET_ID    }, /* DMA_UART */	\
+	{0x1E, DEV_TARGET_ID    }, /* SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID    }, /* SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID    }, /* SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID    }, /* SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID    }, /* SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID    }, /* SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID    }, /* SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID    }, /* SPI_CS7 */	\
+	{MAIN_BOOT_ATTR, DEV_TARGET_ID    }, /* Main Boot device */	\
+	{SEC_BOOT_ATTR, DEV_TARGET_ID    }, /* Secondary Boot device, */	\
+	{0x2D, DEV_TARGET_ID    }, /* PMU_SCRATCHPAD */	\
+	{0x01, CRYPT_TARGET_ID  }, /* CRYPT_ENG0 */	\
+	{0x05, CRYPT_TARGET_ID  }, /* CRYPT_ENG1 */     \
+	{0x00, PNC_BM_TARGET_ID }, /* PNC_BM */		\
+}
+
+#define CESA_TARGET_NAME_DEF	("CRYPT_ENG0", "CRYPT_ENG1")
+#define TARGETS_NAME_ARRAY	{		\
+	"SDRAM_CS0",    /* SDRAM_CS0 */		\
+	"SDRAM_CS1",    /* SDRAM_CS1 */		\
+	"SDRAM_CS2",    /* SDRAM_CS1 */		\
+	"SDRAM_CS3",    /* SDRAM_CS1 */		\
+	"DEVICE_CS0",	/* DEVICE_CS0 */	\
+	"DEVICE_CS1",	/* DEVICE_CS1 */	\
+	"DEVICE_CS2",	/* DEVICE_CS2 */	\
+	"DEVICE_CS3",	/* DEVICE_CS3 */	\
+	"PEX0_MEM",	/* PEX0_MEM */		\
+	"PEX0_IO",	/* PEX0_IO */		\
+	"PEX1_MEM",	/* PEX1_MEM */		\
+	"PEX1_IO",	/* PEX1_IO */		\
+	"PEX2_MEM",	/* PEX2_MEM */		\
+	"PEX2_IO",	/* PEX2_IO */		\
+	"PEX3_MEM",	/* PEX3_MEM */		\
+	"PEX3_IO",	/* PEX3_IO */		\
+	"PEX4_MEM",	/* PEX4_MEM */		\
+	"PEX4_IO",	/* PEX4_IO */		\
+	"PEX5_MEM",	/* PEX5_MEM */		\
+	"PEX5_IO",	/* PEX5_IO */		\
+	"PEX6_MEM",	/* PEX6_MEM */		\
+	"PEX6_IO",	/* PEX6_IO */		\
+	"PEX7_MEM",	/* PEX7_MEM */		\
+	"PEX7_IO",	/* PEX7_IO */		\
+	"PEX8_MEM",	/* PEX8_MEM */		\
+	"PEX8_IO",	/* PEX8_IO */		\
+	"PEX9_MEM",	/* PEX9_MEM */		\
+	"PEX9_IO",	/* PEX9_IO */		\
+	"INTER_REGS",	/* INTER_REGS */	\
+	"DMA_UART",	/* DMA_UART */		\
+	"SPI_CS0",	/* SPI_CS0 */		\
+	"SPI_CS1",	/* SPI_CS1 */		\
+	"SPI_CS2",	/* SPI_CS2 */		\
+	"SPI_CS3",	/* SPI_CS3 */		\
+	"SPI_CS4",	/* SPI_CS4 */		\
+	"SPI_CS5",	/* SPI_CS5 */		\
+	"SPI_CS6",	/* SPI_CS6 */		\
+	"SPI_CS7",	/* SPI_CS7 */		\
+	"BOOT_ROM_CS",	/* BOOT_ROM_CS */	\
+	"DEV_BOOTCS",	/* DEV_BOOCS */		\
+	"PMU_SCRATCHPAD",/* PMU_SCRATCHPAD */	\
+	"CRYPT1_ENG",	/* CRYPT1_ENG */	\
+	"CRYPT2_ENG",	/* CRYPT2_ENG */	\
+	"PNC_BM"	/* PNC_BM */		\
+}
+
+
+
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
new file mode 100755
index 0000000..45c824a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
@@ -0,0 +1,124 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+
+MV_BOOL mvSemaLock(MV_32 num)
+{
+	MV_U32 tmp;
+	MV_U32 cpuId;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	cpuId = whoAmI();
+	do
+	{
+		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	} while ((tmp & 0xFF) != cpuId);
+	return MV_TRUE;
+}
+
+MV_BOOL mvSemaTryLock(MV_32 num)
+{
+	MV_U32 tmp;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	if ((tmp & 0xFF) != whoAmI())
+	{
+		return MV_FALSE;
+	}
+	else
+		return MV_TRUE;
+}
+
+MV_BOOL mvSemaUnlock(MV_32 num)
+{
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+	return MV_TRUE;
+}
+
+MV_32 mvReadAmpReg(int regId)
+{
+	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+}
+
+MV_32 mvWriteAmpReg(int regId, MV_32 value)
+{
+	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
new file mode 100644
index 0000000..2cd75a8
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvsemaphore_h
+#define mvsemaphore_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+#define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
+#define ADR_WIN_EN_REG			0
+
+#define MV_SEMA_REG_BASE	(0x20500)
+#define MV_MAX_SEMA 	    	128
+#define MV_SEMA_SMI 		50
+#define MV_SEMA_RTC 		51
+#define MV_SEMA_NOR_FLASH 	0
+#define MV_SEMA_BOOT 		1
+#define MV_SEMA_PEX0 		2
+#define MV_SEMA_BRIDGE 		3
+#define MV_SEMA_IRQ 		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_L2		6
+#define MV_SEMA_TWSI		7
+#define MV_SEMA_ADR_WIN		8
+
+#define MV_SEMA_BARRIER(cpu)	(50 + cpu)
+
+
+MV_BOOL mvSemaLock(MV_32 num);
+MV_BOOL mvSemaTryLock(MV_32 num);
+MV_BOOL mvSemaUnlock(MV_32 num);
+MV_32   mvReadAmpReg(int regId);
+MV_32 	mvWriteAmpReg(int regId, MV_32 value);
+
+/* Turn on HW semapores only if AMP is enabled */
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock
+#define mvSemaTryLock
+#define mvSemaUnlock
+#define mvHwBarrier
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvsemaphore_h */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
new file mode 100755
index 0000000..c53332d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
@@ -0,0 +1,266 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+static MV_BOOL mv_rsrc_limited = MV_FALSE;
+static MV_RES_MAP mv_res_table[] = {
+	/* Dividable units */
+	{0, "uart0"},
+	{0, "uart1"},
+	{0, "pex0"},
+	{0, "pex1"},
+	{0, "pex2"},
+	{0, "pex3"},
+	{0, "eth0"},
+	{0, "eth1"},
+	{0, "eth2"},
+	{0, "eth3"},
+	{0, "xor0"},
+	{0, "xor1"},
+	{0, "usb0"},
+	{0, "usb1"},
+	{0, "usb2"},
+	{0, "i2c0"},
+	{0, "i2c1"},
+	/* Single Allocation units */
+	{0, "sata"},
+	{0, "cesa"},
+	{0, "nor"},
+	{0, "nand"},
+	{0, "spi"},
+	{0, "tdm"},
+	{0, "sdio"},
+	{0, "lcd"},
+	{0, "hwmon"},
+	{0, "rtc"},
+	{0, "gpio"},
+	{0, "mstr"},
+	{-1, "last"}
+};
+
+MV_BOOL mvUnitMapIsRsrcLimited(void)
+{
+	return mv_rsrc_limited;
+}
+
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited)
+{
+	mv_rsrc_limited = isLimited;
+}
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx)
+{
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_BOOL mvUnitMapIsPexMine(int pciIf)
+{
+	MV_SOC_UNIT unitIdx;
+
+	/* Map line Number to PEX unit number */
+	/* This is compatible to mvCtrlSerdesPhyConfig in BoardEnvLib.c */
+	if(pciIf < PEX1_0x4)
+		unitIdx = PEX0;
+	else if(pciIf < PEX2_0x4)
+		unitIdx = PEX1;
+	else if(pciIf < PEX3_0x4)
+		unitIdx = PEX2;
+	else
+		unitIdx = PEX3;	
+
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx)
+{
+	if (MV_TRUE == mv_res_table[unitIdx].isMine)
+		return;
+
+	mv_res_table[unitIdx].isMine = 1;
+}
+
+MV_BOOL mvUnitMapSetup(char* cmdLine, STRSTR_FUNCPTR strstr_func)
+{
+	int unitIdx;
+	char* match;
+
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		char *unitName = mv_res_table[unitIdx].unitName;
+		int len;
+		match = strstr_func(cmdLine, unitName);
+		if (!match) continue;
+		/*Look for start delimiter*/
+		if (match > cmdLine) {
+			if (match[-1] != ' ' && match[-1] != ':') {
+				continue;
+			}
+		}
+		/* Calc string length without using strlen() */
+		while (*unitName++ != '\0');
+		len = unitName - mv_res_table[unitIdx].unitName - 1;		
+		/*Look for end delimiter*/
+		if (match[len] != ' ' && match[len] != ':' && match[len] != '\0') {
+			continue;
+		}
+		mvUnitMapSetMine(unitIdx);
+	}
+	return MV_TRUE;
+}
+
+/*MV_BOOL mvSocUnitMapFillTableFormBitMap(MV_U32 flag)
+{
+	int i,bit,cpuId;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++) 
+	{
+		switch (i)
+		{
+		case UART0:  bit=UART0_T0_CPU1;   break;        
+		case UART1:  bit=UART1_TO_CPU1;   break;       
+		case PEX00:  bit=PEX0_TO_CPU1;    break;       
+		case PEX10:  bit=PEX1_TO_CPU1;    break;       
+		case GIGA0:  bit=GIGA0_TO_CPU1;   break;       
+		case GIGA1:  bit=GIGA1_TO_CPU1;   break;       
+		case GIGA2:  bit=GIGA2_TO_CPU1;   break;       
+		case GIGA3:  bit=GIGA3_TO_CPU1;   break;       
+		case SATA:   bit=SATA_TO_CPU1;    break;        
+		case XOR:    bit=XOR_TO_CPU1;  	  break;         
+		case IDMA:   bit=IDMA_TO_CPU1;    break;        
+		case USB0:   bit=USB0_TO_CPU1;    break;        
+		case USB1:   bit=USB1_TO_CPU1;    break;        
+		case USB2:   bit=USB2_TO_CPU1;    break;        
+		case CESA:   bit=CESA_TO_CPU1;    break;        
+		case NOR_FLASH:	bit=NOR_TO_CPU1;    break;        
+		case NAND_FLASH: bit=NAND_TO_CPU1;    break; 
+		case SPI_FLASH:bit=SPI_TO_CPU1;    break;     
+		case TDM: bit=TDM_TO_CPU1;    break;     
+		default: bit=0;
+			break;
+		}
+		//cpuId = (flag & bit) ? SLAVE_CPU:MASTER_CPU;
+		mvSocUnitMapSet(i, cpuId);
+	}
+	return MV_TRUE;
+}
+
+MV_U32 mvSocUnitMapFillFlagFormTable(void)
+{
+	int i;
+	MV_U32 flag = 0;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++) 
+	{
+	    if (mvSocUnitMapGet(i) == 0)//SLAVE_CPU)
+	    {
+		switch (i)
+		{
+		case UART0:  flag |= UART0_T0_CPU1;   	break;        
+		case UART1:  flag |= UART1_TO_CPU1;   	break;       
+		case PEX00:  flag |= PEX0_TO_CPU1;    	break;       
+		case PEX10:  flag |= PEX1_TO_CPU1;    	break;       
+		case GIGA0:  flag |= GIGA0_TO_CPU1;   	break;       
+		case GIGA1:  flag |= GIGA1_TO_CPU1;   	break;       
+		case GIGA2:  flag |= GIGA2_TO_CPU1;   	break;       
+		case GIGA3:  flag |= GIGA3_TO_CPU1;   	break;       
+		case SATA:   flag |= SATA_TO_CPU1;    	break;        
+		case XOR:    flag |= XOR_TO_CPU1;	break;         
+		case IDMA:   flag |= IDMA_TO_CPU1;    	break;        
+		case USB0:   flag |= USB0_TO_CPU1;    	break;        
+		case USB1:   flag |= USB1_TO_CPU1;    	break;        
+		case USB2:   flag |= USB2_TO_CPU1;    	break;        
+		case CESA:   flag |= CESA_TO_CPU1;    	break;        
+		case NOR_FLASH: flag |= NOR_TO_CPU1;   break;
+		case NAND_FLASH: flag |= NAND_TO_CPU1;   break;
+		case SPI_FLASH: flag |= SPI_TO_CPU1;   break;
+		case TDM: flag |= TDM_TO_CPU1;   break;
+		default: 				
+			break;
+		}
+	    }
+	}
+
+	return flag;
+}*/
+MV_VOID mvUnitMapSetAllMine()
+{
+	int unitIdx;
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		mvUnitMapSetMine(unitIdx);
+	}
+}
+
+MV_VOID mvUnitMapPrint()
+{
+	int unitIdx;
+	mvOsPrintf("  AMP: Resources ");
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != -1; unitIdx++) {
+		if (mv_res_table[unitIdx].isMine) {
+			mvOsPrintf("- %s ", mv_res_table[unitIdx].unitName);
+		}
+	}
+	mvOsPrintf("\n");
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
new file mode 100644
index 0000000..63b51fa
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvUnitMap_h
+#define mvUnitMap_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+typedef enum
+{
+	UART0=0,
+	UART1,
+	PEX0,
+	PEX1,
+	PEX2,
+	PEX3,
+	ETH0,
+	ETH1,
+	ETH2,
+	ETH3,
+	XOR0,
+	XOR1,
+	USB0,
+	USB1,
+	USB2,
+	I2C0,
+ 	I2C1,
+	SATA,
+	CESA,
+	NOR,
+	NAND,
+	SPI,
+	TDM,
+	SDIO,
+	LCD,
+	HWMON,
+	RTC,
+	GPIO,
+	MSTR,
+	MAX_UNITS
+} MV_SOC_UNIT;
+
+/* binary flags for mvSocUnitMapFillTableFormBitMap */
+/*#define UART0_T0_CPU1	0x0001
+#define UART1_TO_CPU1	0x0002
+#define PEX0_TO_CPU1	0x0004
+#define PEX1_TO_CPU1	0x0008
+#define GIGA0_TO_CPU1	0x0010
+#define GIGA1_TO_CPU1	0x0020
+#define GIGA2_TO_CPU1	0x0040
+#define GIGA3_TO_CPU1	0x0080
+#define SATA_TO_CPU1	0x0100
+#define XOR_TO_CPU1		0x0200
+#define IDMA_TO_CPU1	0x0400
+#define USB0_TO_CPU1	0x0800
+#define USB1_TO_CPU1    0x1000
+#define USB2_TO_CPU1    0x2000
+#define CESA_TO_CPU1	0x4000
+#define NOR_TO_CPU1		0x8000
+#define NAND_TO_CPU1	0x10000
+#define SPI_TO_CPU1		0x20000
+#define TDM_TO_CPU1		0x40000
+  
+#define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
+															 
+typedef struct __MV_RES_MAP 
+{
+	int	isMine;
+	char*	unitName;
+} MV_RES_MAP;
+
+typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapIsPexMine(int pciIf);
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
+MV_VOID mvUnitMapSetAllMine(void);
+MV_VOID mvUnitMapPrint(void);
+MV_BOOL mvUnitMapIsRsrcLimited(void);
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
+#else /* CONFIG_MV_AMP_ENABLE */
+#define mvUnitMapIsMine(rsrc) 		MV_TRUE
+#define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
+#define mvUnitMapIsRsrcLimited 	  	MV_TRUE
+#define mvUnitMapSetRsrcLimited(limit) 
+#define mvUnitMapSetMine(rsrc)
+#define mvUnitMapSetAllMine
+#define mvUnitMapPrint
+#define mvUnitMapSetup(str, strstr_func) MV_TRUE
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
new file mode 100644
index 0000000..1cc1aa3
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -0,0 +1,750 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvCpuIfRegs.h"
+
+#undef MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* typedefs */
+
+/* CPU address remap registers offsets are inconsecutive. This struct		*/
+/* describes address remap register offsets					*/
+typedef struct _ahbToMbusRemapRegOffs {
+	MV_U32 lowRegOffs;	/* Low 32-bit remap register offset             */
+	MV_U32 highRegOffs;	/* High 32 bit remap register offset            */
+} AHB_TO_MBUS_REMAP_REG_OFFS;
+
+/* locals   */
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs);
+
+/*******************************************************************************
+* mvAhbToMbusInit - Initialize Ahb To Mbus Address Map !
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK laways.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusInit(void)
+{
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinSet - Set CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*       This function sets
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified winNum address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the winNum window, allowing CPU to access
+*       the winNum window.
+*
+* INPUT:
+*       winNum      - Windows number.
+*       pAddrDecWin - CPU winNum window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU winNum window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU winNum window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the winNum is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 sizeToReg;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinSet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvAhbToMbusWinSet:Error setting AHB to MBUS window %d to "
+			   "target %s.\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			   winNum,
+			   mvCtrlTargetNameGet(pAddrDecWin->target),
+			   pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	/* Size parameter validity check.                       */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.size, ATMWCR_WIN_SIZE_ALIGNMENT)) {
+		mvOsPrintf("mvAhbToMbusWinSet: Failed, size not aligned to 0x%x.\n", ATMWCR_WIN_SIZE_ALIGNMENT);
+		return MV_BAD_PARAM;
+	}
+
+	/* Write to address decode Base Address Register        */
+	decRegs.baseReg = (pAddrDecWin->addrWin.baseLow & ATMWBR_BASE_MASK);
+
+	/* Get size register value according to window size     */
+	sizeToReg = (pAddrDecWin->addrWin.size / ATMWCR_WIN_SIZE_ALIGNMENT) - 1;
+
+	/* set size                                             */
+	decRegs.ctrlReg = (sizeToReg << ATMWCR_WIN_SIZE_OFFS);
+
+	/* enable\Disable */
+	if (MV_TRUE == pAddrDecWin->enable)
+		decRegs.ctrlReg |= ATMWCR_WIN_ENABLE;
+	else
+		decRegs.ctrlReg &= ~ATMWCR_WIN_ENABLE;
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* set attributes */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_ATTR_MASK;
+	decRegs.ctrlReg |= targetAttribs.attrib << ATMWCR_WIN_ATTR_OFFS;
+	/* set target ID */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_TARGET_MASK;
+	decRegs.ctrlReg |= targetAttribs.targetId << ATMWCR_WIN_TARGET_OFFS;
+
+#if !defined(MV_RUN_FROM_FLASH)
+	/* To be on the safe side we disable the window before writing the  */
+	/* new values.                                                      */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		mvAhbToMbusWinEnable(winNum, MV_FALSE);
+#endif
+
+	/* 3) Write to address decode Base Address Register                   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), decRegs.baseReg);
+	else
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
+
+
+	/* Internal register space have no size */
+	/* register. Do not perform size register assigment for those targets   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
+		/* Write to address decode Size Register                                */
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), decRegs.ctrlReg);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinGet - Get CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral winNum address window.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU winNum window information data structure.
+*
+* RETURN:
+*       MV_OK if winNum exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_U32 sizeRegVal;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal register space size have no size register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+	else
+		decRegs.ctrlReg = 0;
+
+	/* Read base and size   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	else
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_INTEREG_REG);
+
+	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseLow = decRegs.baseReg & ATMWBR_BASE_MASK;
+	sizeRegVal = (decRegs.ctrlReg & ATMWCR_WIN_SIZE_MASK) >> ATMWCR_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * ATMWCR_WIN_SIZE_ALIGNMENT;
+
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN) {
+		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
+		pAddrDecWin->target = INTER_REGS;
+		pAddrDecWin->enable = MV_TRUE;
+
+		return MV_OK;
+	}
+
+	if (decRegs.ctrlReg & ATMWCR_WIN_ENABLE)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	if (-1 == pAddrDecWin->addrWin.size)
+		return MV_ERROR;
+
+	/* attrib and targetId */
+	targetAttrib.attrib = (decRegs.ctrlReg & ATMWCR_WIN_ATTR_MASK) >> ATMWCR_WIN_ATTR_OFFS;
+	targetAttrib.targetId = (decRegs.ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetGet - Get Window number associated with target
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	if (INTER_REGS == target)
+		return MV_AHB_TO_MBUS_INTREG_WIN;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_TRUE) {
+			if (decWin.target == target)
+				return winNum;
+		}
+	}
+
+	return 0xFFFFFFFF;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinAvailGet - Get First Available window number.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinAvailGet(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_FALSE)
+			return winNum;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other winNum window.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinEnable: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal registers bar can't be disable or enabled */
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+		return (enable ? MV_OK : MV_ERROR);
+
+
+	if (enable == MV_TRUE) {
+		/* enable the window */
+		MV_REG_BIT_SET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	} else {
+		/* Disable address decode winNum window                             */
+		MV_REG_BIT_RESET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*       After a CPU address hits one of PCI address decode windows there is an
+*       option to remap the address to a different one. For example, CPU
+*       executes a read from PCI winNum window address 0x1200.0000. This
+*       can be modified so the address on the PCI bus would be 0x1400.0000
+*       Using the PCI address remap mechanism.
+*
+* INPUT:
+*       winNum      - Peripheral winNum enumerator. Must be a PCI winNum.
+*       pAddrDecWin - CPU winNum window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if winNum is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddr;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegOffs;
+	MV_U32 effectiveBaseAddress = 0, baseAddrValue = 0, windowSizeValue = 0;
+
+	/* Get registers offsets of given winNum                */
+	if (MV_NO_SUCH == ahbToMbusRemapRegOffsGet(winNum, &remapRegOffs))
+		return 0xffffffff;
+
+	/* 1) Set address remap low */
+	baseAddr = pAddrWin->baseLow;
+
+	/* Check base address aligment                                  */
+	/*
+	   if (MV_IS_NOT_ALIGN(baseAddr, ATMWRLR_REMAP_LOW_ALIGNMENT))
+	   {
+	   mvOsPrintf("mvAhbToMbusPciRemap: Warning. Target base 0x%x unaligned\n",
+	   baseAddr);
+	   return MV_ERROR;
+	   }
+	 */
+
+	/* BaseLow[31:16] => base register [31:16]              */
+	baseAddr = baseAddr & ATMWRLR_REMAP_LOW_MASK;
+
+	MV_REG_WRITE(remapRegOffs.lowRegOffs, baseAddr);
+	MV_REG_WRITE(remapRegOffs.highRegOffs, pAddrWin->baseHigh);
+
+	baseAddrValue = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	windowSizeValue = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+
+	baseAddrValue &= ATMWBR_BASE_MASK;
+	windowSizeValue &= ATMWCR_WIN_SIZE_MASK;
+
+	/* Start calculating the effective Base Address */
+	effectiveBaseAddress = baseAddrValue;
+
+	/* The effective base address will be combined from the chopped (if any)
+	   remap value (according to the size value and remap mechanism) and the
+	   window's base address */
+	effectiveBaseAddress |= (((windowSizeValue) | 0xffff) & pAddrWin->baseLow);
+	/* If the effectiveBaseAddress exceed the window boundaries return an
+	   invalid value. */
+
+	if (effectiveBaseAddress > (baseAddrValue + (windowSizeValue | 0xffff))) {
+		mvOsPrintf("mvAhbToMbusPciRemap: Error\n");
+		return 0xffffffff;
+	}
+
+	return effectiveBaseAddress;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetSwap - Swap AhbToMbus windows between targets
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       target1      - CPU Interface target 1
+*       target2      - CPU Interface target 2
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if targets are illigal, or if one of the targets is not
+*	    associated to a valid window .
+*       MV_OK otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2)
+{
+	MV_U32 winNum1, winNum2;
+	MV_AHB_TO_MBUS_DEC_WIN winDec1, winDec2, winDecTemp;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegs1, remapRegs2;
+	MV_U32 remapBaseLow1 = 0, remapBaseLow2 = 0;
+	MV_U32 remapBaseHigh1 = 0, remapBaseHigh2 = 0;
+
+	/* Check parameters */
+	if (target1 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	if (target2 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum1 = mvAhbToMbusWinTargetGet(target1);
+
+	if (winNum1 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target1, winNum1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum2 = mvAhbToMbusWinTargetGet(target2);
+	if (winNum2 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target2, winNum2);
+		return MV_ERROR;
+	}
+
+	/* now Get original values of both Windows */
+	if (MV_OK != mvAhbToMbusWinGet(winNum1, &winDec1)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinGet(winNum2, &winDec2)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* disable both windows */
+	if (MV_OK != mvAhbToMbusWinEnable(winNum1, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable window %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinEnable(winNum2, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable windo %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* now swap targets */
+
+	/* first save winDec2 values */
+	winDecTemp.addrWin.baseHigh = winDec2.addrWin.baseHigh;
+	winDecTemp.addrWin.baseLow = winDec2.addrWin.baseLow;
+	winDecTemp.addrWin.size = winDec2.addrWin.size;
+	winDecTemp.enable = winDec2.enable;
+	winDecTemp.target = winDec2.target;
+
+	/* winDec2 = winDec1 */
+	winDec2.addrWin.baseHigh = winDec1.addrWin.baseHigh;
+	winDec2.addrWin.baseLow = winDec1.addrWin.baseLow;
+	winDec2.addrWin.size = winDec1.addrWin.size;
+	winDec2.enable = winDec1.enable;
+	winDec2.target = winDec1.target;
+
+	/* winDec1 = winDecTemp */
+	winDec1.addrWin.baseHigh = winDecTemp.addrWin.baseHigh;
+	winDec1.addrWin.baseLow = winDecTemp.addrWin.baseLow;
+	winDec1.addrWin.size = winDecTemp.addrWin.size;
+	winDec1.enable = winDecTemp.enable;
+	winDec1.target = winDecTemp.target;
+
+	/* now set the new values */
+	mvAhbToMbusWinSet(winNum1, &winDec1);
+	mvAhbToMbusWinSet(winNum2, &winDec2);
+
+	/* now we will treat the remap windows if exist */
+
+	/* now check if one or both windows has a remap window
+	   as well after the swap ! */
+
+	/* if a window had a remap value differnt than the base value
+	   before the swap , then after the swap the remap value will be
+	   equal to the base value unless both windows has a remap windows */
+
+	/* first get old values */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		remapBaseLow1 = MV_REG_READ(remapRegs1.lowRegOffs);
+		remapBaseHigh1 = MV_REG_READ(remapRegs1.highRegOffs);
+	}
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		remapBaseLow2 = MV_REG_READ(remapRegs2.lowRegOffs);
+		remapBaseHigh2 = MV_REG_READ(remapRegs2.highRegOffs);
+	}
+
+	/* now do the swap */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+			/* Two windows has a remap !!! so swap */
+
+			MV_REG_WRITE(remapRegs2.highRegOffs, remapBaseHigh1);
+			MV_REG_WRITE(remapRegs2.lowRegOffs, remapBaseLow1);
+
+			MV_REG_WRITE(remapRegs1.highRegOffs, remapBaseHigh2);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, remapBaseLow2);
+		} else {
+			/* remap == base */
+			MV_REG_WRITE(remapRegs1.highRegOffs, winDec1.addrWin.baseHigh);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, winDec1.addrWin.baseLow);
+		}
+	} else if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		/* remap == base */
+		MV_REG_WRITE(remapRegs2.highRegOffs, winDec2.addrWin.baseHigh);
+		MV_REG_WRITE(remapRegs2.lowRegOffs, winDec2.addrWin.baseLow);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ahbToMbusRemapRegOffsGet - Get CPU address remap register offsets
+*
+* DESCRIPTION:
+* 		CPU to PCI address remap registers offsets are inconsecutive.
+*		This function returns PCI address remap registers offsets.
+*
+* INPUT:
+*       winNum - Address decode window number. See MV_U32 enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*		MV_ERROR if winNum is not a PCI one.
+*
+*******************************************************************************/
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs)
+{
+	switch (winNum) {
+	case 0:
+	case 1:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 2:
+	case 3:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	default:
+		pRemapRegs->lowRegOffs = 0;
+		pRemapRegs->highRegOffs = 0;
+
+		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		return MV_NO_SUCH;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusAddDecShow - Print the AHB to MBus bridge address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN win;
+	MV_U32 winNum;
+	mvOsOutput("\n");
+	mvOsOutput("AHB To MBUS Bridge:\n");
+	mvOsOutput("-------------------\n");
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		memset(&win, 0, sizeof(MV_AHB_TO_MBUS_DEC_WIN));
+
+		mvOsOutput("win%d - ", winNum);
+
+		if (mvAhbToMbusWinGet(winNum, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("%s base %08x, ", mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+				mvOsOutput("....");
+				mvSizePrint(win.addrWin.size);
+
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		}
+	}
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
new file mode 100644
index 0000000..f91ee59
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -0,0 +1,96 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbush
+#define __INCmvAhbToMbush
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* defines  */
+
+typedef struct _mvAhbtoMbusDecWin {
+	MV_TARGET	target;
+	MV_ADDR_WIN	addrWin;    /* An address window*/
+	MV_BOOL		enable;     /* Address decode window is enabled/disabled    */
+
+} MV_AHB_TO_MBUS_DEC_WIN;
+
+/* mvAhbToMbus.h API list */
+
+MV_STATUS mvAhbToMbusInit(MV_VOID);
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
+MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
+MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
+
+MV_VOID   mvAhbToMbusAddDecShow(MV_VOID);
+
+#endif /* __INCmvAhbToMbush */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
new file mode 100644
index 0000000..50fd816
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -0,0 +1,143 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbusRegsh
+#define __INCmvAhbToMbusRegsh
+
+#define MAX_AHB_TO_MBUS_WINS			21
+#define MAX_AHB_TO_MBUS_REMAP_WINS		8
+#define MV_AHB_TO_MBUS_INTREG_WIN		20
+
+/***********************/
+/* AHB TO MBUS WINDOWS */
+/***********************/
+/* Window-X Control Registers */
+#define AHB_TO_MBUS_WIN_CTRL_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + winNum * 0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x90 + (winNum-8)*0x08))
+#define ATMWCR_WIN_ENABLE			BIT0
+#define ATMWCR_WIN_TARGET_OFFS			4
+#define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
+#define ATMWCR_WIN_ATTR_OFFS			8
+#define ATMWCR_WIN_ATTR_MASK			(0xff << ATMWCR_WIN_ATTR_OFFS)
+#define ATMWCR_WIN_SIZE_OFFS			16
+#define ATMWCR_WIN_SIZE_MASK			(0xffff << ATMWCR_WIN_SIZE_OFFS)
+#define ATMWCR_WIN_SIZE_ALIGNMENT		0x10000
+
+/* Window-X Base Register */
+#define AHB_TO_MBUS_WIN_BASE_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x4 + winNum*0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x94 + (winNum-8)*0x08))
+#define ATMWBR_BASE_OFFS			16
+#define ATMWBR_BASE_MASK			(0xffff << 	ATMWBR_BASE_OFFS)
+#define ATMWBR_BASE_ALIGNMENT			0x10000
+
+/* Window-X Remap Low Register */
+#define AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x8 + winNum*0x10) : \
+						 (0))
+#define ATMWRLR_REMAP_LOW_OFFS			16
+#define ATMWRLR_REMAP_LOW_MASK			(0xffff << ATMWRLR_REMAP_LOW_OFFS)
+#define ATMWRLR_REMAP_LOW_ALIGNMENT		0x10000
+
+/* Window-X Remap Hi Register */
+#define AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0xC + winNum*0x10) : \
+						 (0))
+#define ATMWRHR_REMAP_HIGH_OFFS			0
+#define ATMWRHR_REMAP_HIGH_MASK			(0xffffffff << ATMWRHR_REMAP_HIGH_OFFS)
+
+/*****************************/
+/* INTERNAL REGISTERS WINDOW */
+/*****************************/
+/* Internal Registers Base Address in set to be window 20 */
+#define AHB_TO_MBUS_WIN_INTEREG_REG		(MV_MBUS_REGS_OFFSET + 0x80)
+
+/************************/
+/* SDRAM DECODE WINDOWS */
+/************************/
+/* All DRAM Window definitions are declared under the ddr2_3 HAL */
+
+/****************************/
+/* SRAM (L2) DECODE WINDOWS */
+/****************************/
+#define SRAM_WIN_CTRL_REG(winNum)		(MV_MBUS_REGS_OFFSET + 0x240 + winNum * 0x4)
+#define SRAMWCR_ENABLE				BIT0
+#define SRAMWCR_SIZE_OFFS			8
+#define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
+#define SRAMWCR_BASE_OFFS			16
+#define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+
+/**********************/
+/* MBUS BRIDGE WINDOW */
+/**********************/
+#define MBUS_BRIDGE_WIN_CTRL_REG		(MV_MBUS_REGS_OFFSET + 0x250)
+#define BRIDGWCR_ENABLE				BIT0
+#define BRIDGWCR_SIZE_OFFS			16
+#define BRIDGWCR_SIZE_MASK			(0xFFFF << BRIDGWCR_SIZE_OFFS)
+#define MBUS_BRIDGE_WIN_BASE_REG		(MV_MBUS_REGS_OFFSET + 0x254)
+
+#endif /* __INCmvAhbToMbusRegsh */
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
new file mode 100755
index 0000000..dbd355b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
@@ -0,0 +1,966 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+/*#include "cpu/mvCpu.h" *//* whoAmI() */
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "ddr2_3/mvDramIf.h"
+#include "ddr2_3/mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+
+/*#define MV_DEBUG*/
+/* defines  */
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals   */
+/* static functions */
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
+
+MV_TARGET sampleAtResetTargetArray[] = BOOT_TARGETS_NAME_ARRAY;
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+	MV_32 diff;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		if(win.enable == cpuAddrWinMap->enable)
+		{
+			if(win.enable)
+			{
+				diff  = (win.addrWin.baseLow  - cpuAddrWinMap->addrWin.baseLow);
+				diff |= (win.addrWin.baseHigh - cpuAddrWinMap->addrWin.baseHigh);
+				diff |= (win.addrWin.size     - cpuAddrWinMap->addrWin.size);
+				/*TODO - Need to compare the window attributes as well */
+
+				if(diff)
+				{
+					mvOsOutput("mvCpuIfVerify: Mismatched window size in target %d\n", target);
+					return MV_ERROR;
+				}
+			}
+		}
+		else
+		{
+			mvOsOutput("mvCpuIfVerify: Mismatched enable field in target %d\n", target);
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCpuIfInitForCpu - Initialize Controller CPU interface
+*
+* DESCRIPTION:
+*       This function initialize Controller CPU interface:
+*       1. Set CPU interface configuration registers.
+*       2. Set CPU master Pizza arbiter control according to static
+*          configuration described in configuration file.
+*       3. Opens CPU address decode windows. DRAM windows are assumed to be
+*		   already set (auto detection).
+*
+* INPUT:
+*       cpu      	- CPU id.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_U32 regVal, i;
+	MV_TARGET target;
+	MV_ADDR_WIN addrWin;
+	MV_U32 minBase = 0xFFFFFFFF;
+	MV_U32 minSize;
+
+	if (cpuAddrWinMap == NULL) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. cpuAddrWinMap == NULL\n"));
+		return MV_ERROR;
+	}
+
+	/* Set IO Bypass base address and size according to the cpuAddrWinMap */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (DIS == cpuAddrWinMap[target].enable) ||
+		    (target == INTER_REGS))
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow == 0)
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow < minBase)
+			minBase = cpuAddrWinMap[target].addrWin.baseLow;
+	}
+	if (minBase != 0x0) {
+		minSize = 0xFFFFFFFF - minBase + 1;
+		if (!MV_IS_POWER_OF_2(minSize)) {
+			/* Round up to next power of 2. */
+			minSize = (1 << (mvLog2(minSize) + 1));
+			minBase = 0xFFFFFFFF - minSize + 1;
+		}
+
+		/* Now write the base and size */
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_BASE_REG, minBase);
+		/* Align window size to 64KB */
+		regVal = (minSize / SDRAMWBR_BASE_ALIGNMENT) - 1;
+		regVal = (regVal << 16) | 0x1;
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_CTRL_REG, regVal);
+	}
+
+	/* Set CPU Configuration register */
+	regVal = MV_REG_READ(CPU_CONFIG_REG(cpu));
+	regVal &= ~CPU_CONFIG_DEFAULT_MASK;
+	regVal |= CPU_CONFIG_DEFAULT;
+	MV_REG_WRITE(CPU_CONFIG_REG(cpu), regVal);
+
+	for (i = 0; i < MAX_AHB_TO_MBUS_WINS-2; i++)
+		mvAhbToMbusWinEnable(i, MV_FALSE);
+
+	/* Disable all SRAM windows  */
+	mvCpuIfSramWinDisable();
+
+	/* First disable all CPU target windows  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
+			continue;
+#ifdef CONFIG_MV_AMP_ENABLE
+		if(target == BOOT_ROM_CS)
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+#if defined(MV_RUN_FROM_FLASH)
+		/* Don't disable the boot device.                               */
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+		mvCpuIfTargetWinEnable(MV_CHANGE_BOOT_CS(target), MV_FALSE);
+	}
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
+	target = DEV_BOOCS;
+
+	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+		return MV_ERROR;
+	}
+
+	addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+	addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+	if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+		DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+			      cpuAddrWinMap[target].winNum));
+	}
+#endif /* MV_RUN_FROM_FLASH */
+
+	/* Go through all targets in user table until table terminator                  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+
+#if defined(MV_RUN_FROM_FLASH)
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+
+		/* if DRAM auto sizing is used do not initialized DRAM target windows,  */
+		/* assuming this already has been done earlier.                         */
+#ifdef	MV_DRAM_AUTO_SIZE
+		if (MV_TARGET_IS_DRAM(target))
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		else {
+			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+				return MV_ERROR;
+			}
+			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+				DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+					      cpuAddrWinMap[target].winNum));
+			}
+		}
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	return mvCpuIfInitForCpu(whoAmI(), cpuAddrWinMap);
+}
+
+
+/*******************************************************************************
+* mvCpuIfDramInit - Initialize Controller DRAM Fastpath windows
+*
+* DESCRIPTION:
+*       This function initialize Controller DRAM Fastpath windows
+*		It takes the CS size information from the 0x1500 scratch registers
+*		and sets the correct windows sizes and base addresses accordingly
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfDramInit()
+{
+	MV_U64 base = 0;
+	MV_U32 size, cs, temp;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+/*		if (size > 0 && base < SDRAM_MAX_ADDR) { */
+		if (size != 0) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Set Base Address */
+			temp = (base & 0xFF000000ll) | ((base >> 32) & 0xF);
+			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
+
+			/* Check if out of max window size and resize the window */
+#if 0
+			if (base+size > SDRAM_MAX_ADDR) {
+				size = SDRAM_MAX_ADDR - base - 1;
+				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
+			}
+#endif
+			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
+			temp |= (size & SDRAM_ADDR_MASK);
+
+			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
+			base += ((MV_U64)size + 1);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSet - Set CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI0_MEM0)
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing CPU to access
+*       the target window.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - CPU target window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU target window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU target window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the target is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 existingWinNum;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		/* copy relevant data to MV_DRAM_DEC_WIN structure */
+		addrDecWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		addrDecWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		addrDecWin.addrWin.size = pAddrDecWin->addrWin.size;
+		addrDecWin.enable = pAddrDecWin->enable;
+
+		if (mvDramIfWinSet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvDramIfWinSet Failed\n");
+			return MV_ERROR;
+		}
+	} else {
+		/* copy relevant data to MV_AHB_TO_MBUS_DEC_WIN structure */
+		decWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		decWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		decWin.addrWin.size = pAddrDecWin->addrWin.size;
+		decWin.enable = pAddrDecWin->enable;
+		decWin.target = target;
+
+		existingWinNum = mvAhbToMbusWinTargetGet(target);
+
+		/* check if there is already another Window configured
+		   for this target */
+		if ((existingWinNum < MAX_AHB_TO_MBUS_WINS) && (existingWinNum != pAddrDecWin->winNum)) {
+			/* if we want to enable the new window number
+			   passed by the user , then the old one should
+			   be disabled */
+			if (MV_TRUE == pAddrDecWin->enable) {
+				/* be sure it is disabled */
+				mvAhbToMbusWinEnable(existingWinNum, MV_FALSE);
+			}
+		}
+
+		if (mvAhbToMbusWinSet(pAddrDecWin->winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvAhbToMbusWinSet Failed\n");
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinGet - Get CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral target address window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU target window information data structure.
+*
+* RETURN:
+*       MV_OK if target exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_U32 winNum = 0xffffffff;
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinGet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinGet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to get window target %d\n", target);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = addrDecWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = (MV_U64)addrDecWin.addrWin.size;
+		pAddrDecWin->enable = addrDecWin.enable;
+		pAddrDecWin->winNum = target;
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return MV_NO_SUCH;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: mvAhbToMbusWinGet Failed at winNum = %d\n", __func__, winNum);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = decWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = decWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = decWin.addrWin.size;
+		pAddrDecWin->enable = decWin.enable;
+		pAddrDecWin->winNum = winNum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       target - Peripheral target enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other target window.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable)
+{
+	MV_U32 winNum, temp;
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinEnable: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* get the window and check if it exist */
+	temp = mvCpuIfTargetWinGet(target, &addrDecWin);
+	if (MV_NO_SUCH == temp) {
+		return (enable ? MV_ERROR : MV_OK);
+	} else if (MV_OK != temp) {
+		mvOsPrintf("%s: ERR. Getting target %d failed.\n", __func__, target);
+		return MV_ERROR;
+	}
+
+	/* check overlap */
+	if (MV_TRUE == enable) {
+		if (MV_TRUE == cpuTargetWinOverlap(target, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("%s: ERR. Target %d overlap\n", __func__, target));
+			return MV_ERROR;
+		}
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinEnable(target, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: mvDramIfWinEnable Failed at \n");
+			return MV_ERROR;
+		}
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return (enable ? MV_ERROR : MV_OK);
+
+		if (mvAhbToMbusWinEnable(winNum, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to enable window = %d\n", winNum);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSizeGet - Get CPU target address window size
+*
+* DESCRIPTION:
+*		Get the size of CPU-to-peripheral target window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit size. Function also returns '0' if window is closed.
+*		Function returns 0xFFFFFFFF in case of an error.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinSizeGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet: target %d is illegal\n", target);
+		return 0;
+	}
+
+	/* Get the winNum window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet:ERR. Getting target %d failed.\n", target);
+		return 0;
+	}
+
+	/* Check if window is enabled   */
+	if (addrDecWin.enable == MV_TRUE)
+		return (addrDecWin.addrWin.size);
+	else
+		return 0;	/* Window disabled. return 0 */
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseLowGet - Get CPU target address window base low
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target low base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit low base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseLowGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0xffffffff;
+
+	return (addrDecWin.addrWin.baseLow);
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseHighGet - Get CPU target address window base high
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target high base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit high base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseHighGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseHighGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0;
+
+	return (addrDecWin.addrWin.baseHigh);
+}
+
+
+/*******************************************************************************
+* mvCpuIfSramWinDisable
+*
+* DESCRIPTION:
+*	Disable the SRAM windows.
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID)
+{
+	MV_U32 i;
+
+	for (i = 0; i < 4; i++)
+		MV_REG_WRITE(SRAM_WIN_CTRL_REG(i), SRAM_WIN_CTRL_DEFAULT_VAL);
+
+	return MV_OK;
+}
+
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfPexRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pexTarget   - Peripheral target enumerator. Must be a PEX target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PEX one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (mvCtrlPexMaxIfGet() > 1) {
+		if ((!MV_TARGET_IS_PEX0(pexTarget)) &&
+			(!MV_TARGET_IS_PEX1(pexTarget)) &&
+			(!MV_TARGET_IS_PEX2(pexTarget)) &&
+			(!MV_TARGET_IS_PEX3(pexTarget)) &&
+			(!MV_TARGET_IS_PEX4(pexTarget)) &&
+			(!MV_TARGET_IS_PEX5(pexTarget)) &&
+			(!MV_TARGET_IS_PEX6(pexTarget)) &&
+			(!MV_TARGET_IS_PEX7(pexTarget)) &&
+			(!MV_TARGET_IS_PEX8(pexTarget)) &&
+			(!MV_TARGET_IS_PEX9(pexTarget))) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	} else {
+		if (!MV_TARGET_IS_PEX0(pexTarget)) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	}
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pexTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCpuIfPciRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pciTarget   - Peripheral target enumerator. Must be a PCI target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPciRemap(MV_TARGET pciIfTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pciIfTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+/*******************************************************************************
+* mvCpuIfTargetOfBaseAddressGet - Get the target according to base address
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       baseAddress -  base address to be checked
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the target number that baseAddress belongs to or MAX_TARGETS is not
+*       found
+*
+*******************************************************************************/
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				if ((baseAddress >= win.addrWin.baseLow) &&
+				    (baseAddress < win.addrWin.baseLow + win.addrWin.size))
+					break;
+			}
+		} else
+			return MAX_TARGETS;
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* cpuTargetWinOverlap - Detect CPU address decode windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case CPU address decode
+*       windows overlapps.
+*       This function detects CPU address decode windows overlapping of a
+*       specified target. The function does not check the target itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlaps current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 targetNum;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_STATUS status;
+
+	for (targetNum = 0; targetNum < MAX_TARGETS; targetNum++) {
+		/* don't check our target or illegal targets */
+		if (targetNum == target)
+			continue;
+
+		/* Get window parameters        */
+		status = mvCpuIfTargetWinGet(targetNum, &addrDecWin);
+		if (MV_NO_SUCH == status)
+			continue;
+
+		if (MV_OK != status) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: ERR. TargetWinGet failed\n"));
+			return MV_TRUE;
+		}
+
+		/* Do not check disabled windows        */
+		if (MV_FALSE == addrDecWin.enable)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: Required target %d overlap current %d\n",
+				      target, targetNum));
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCpuIfAddDecShow - Print the CPU address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfAddDecShow(MV_VOID)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	mvOsOutput("\n");
+	mvOsOutput("CPU Interface\n");
+	mvOsOutput("-------------\n");
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		mvOsOutput("%s ", mvCtrlTargetNameGet(target));
+		mvOsOutput("....");
+
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("base %01x%08x, ", win.addrWin.baseHigh, win.addrWin.baseLow);
+				mvSizePrint(win.addrWin.size);
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		} else if (mvCpuIfTargetWinGet(target, &win) == MV_NO_SUCH) {
+			mvOsOutput("no such\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCpuIfLvdsPadsEnable
+*
+* DESCRIPTION:
+*	Enable / Disable the LVDS pads.
+*
+* INPUT:
+*	enable - MV_TRUE to enable the pads, MV_FALSE to disable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable)
+{
+	MV_U32 reg;
+	MV_U32 i;
+
+	reg = MV_REG_READ(LVDS_PADS_CTRL_REG);
+
+	for (i = 0; i < 5; i++) {
+		reg &= ~LVDS_PADS_CONF_PD_MASK(i);
+		reg |= LVDS_PADS_CONF_PD_EN(i, enable);
+	}
+
+	MV_REG_WRITE(LVDS_PADS_CTRL_REG, reg);
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
new file mode 100755
index 0000000..f5ed71f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..655d01b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvCommon.h"
+#include "mvOsAsm.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+	mov     r11, LR     		/* Save link register */
+	b       done
+#if 0
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+	/* goto calcConfigReg if device is 6281/6282 */
+	ldr     r5, =MV88F6281_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* goto calcConfigReg if device is 6192/6190 */
+	ldr     r5, =MV88F6192_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* Else 6180 */
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_CPUCLCK_MASK_6180
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3_1
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4_1
+	beq    setConfigReg
+	b    setConfigReg
+
+calcConfigReg:
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4
+	beq    setConfigReg
+
+	/* Else */
+	ldr    r4, =0
+
+setConfigReg:
+	/* Read CPU Config register */
+	MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+	ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+	and    r7, r7, r5       /* Clear register fields */
+	orr    r7, r7, r4       /* Set the values according to the findings */
+	MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+#endif
+
+done:
+	mov     PC, r11         /* r11 is saved link register */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
new file mode 100755
index 0000000..5a3fd8d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -0,0 +1,363 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE		(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
+#define CPU_RESET_REG(cpu)			(MV_CPUIF_SHARED_REGS_BASE + (0x800+(cpu)*8))
+#define CPU_RESUME_CTRL_REG			(MV_CPUIF_SHARED_REGS_BASE + (0x988))
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+#define CFU_CFG_REG				(MV_COHERENCY_FABRIC_REGS_BASE + 0x28)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
+#define CL2_DUAL_EVICTION		(0x1 << 4)
+#define CL2_PARITY_ENABLE		(0x1 << 21)
+#define CL2_InvalEvicLineUCErr          (0x1 << 22)
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)			(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)			(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_IRQ_OFFS		28 
+#define CPU_INT_SOURCE_CONTROL_IRQ_MASK		(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS )
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG	(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_SNOOP_FILTER_CTRL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x20)
+
+#define MV_IRQ_NR							116
+
+
+/*******************************************/
+/* ARM Doorbell Registers Map		   */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ						(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG					(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/*******************************************/
+/* CLOCK Complex Registers Map			   */
+/*******************************************/
+
+#define CPU_DIV_CLK_CTRL0_REG				(MV_CLK_CMPLX_REGS_OFFSET)
+#define CPU_DIV_CLK_CTRL0_RESET_MASK_OFFS	8
+#define CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0x8)
+#define CPU_DIV_CLK_CTRL2_NB_RATIO_OFFS		16
+#define CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0xC)
+#define CPU_DIV_CLK_CTRL3_CPU_RATIO_OFFS	8
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+
+#endif /* __INCmvCpuIfRegsh */
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
new file mode 100644
index 0000000..74c7f27
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "device/mvDevice.h"
+
+/* defines  */
+#ifdef DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvDevPramSet - Set device interface bank parameters
+*
+* DESCRIPTION:
+*       This function sets a device bank parameters to a given device.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*       *pDevParams - Device bank parameter struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+	if (pDevParams->turnOff > MAX_DBP_TURNOFF) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->turnOff out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2First > MAX_DBP_ACC2FIRST) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2First out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2Next > MAX_DBP_ACC2NEXT) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2Next out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->ale2Wr > MAX_DBP_ALE2WR) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrLow > MAX_DBP_WRLOW) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrHigh > MAX_DBP_WRHIGH) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->badrSkew << DBP_BADRSKEW_OFFS) > DBP_BADRSKEW_2CYCLE) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->badrSkew out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->deviceWidth != 8) && (pDevParams->deviceWidth != 16) && (pDevParams->deviceWidth != 32)) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth out of range\n"));
+		return MV_ERROR;
+	}
+
+	/* devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device)); */
+	/* setting values */
+	devParam |= DBP_TURNOFF_SET(pDevParams->turnOff);
+	devParam |= DBP_ACC2FIRST_SET(pDevParams->acc2First);
+	devParam |= DBP_ACC2NEXT_SET(pDevParams->acc2Next);
+	devParam |= ((pDevParams->badrSkew & DBP_BADRSKEW_MASK) << DBP_BADRSKEW_OFFS);
+
+	switch (pDevParams->deviceWidth) {
+	case 8:
+		devParam |= DBP_DEVWIDTH_8BIT;
+		break;
+	case 16:
+		devParam |= DBP_DEVWIDTH_16BIT;
+		break;
+	case 32:
+		devParam |= DBP_DEVWIDTH_32BIT;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	MV_REG_WRITE(DEV_BANK_PARAM_REG(device), devParam);
+
+	devParam = 0;
+	devParam |= DBP_ALE2WR_SET(pDevParams->ale2Wr);
+	devParam |= DBP_WRLOW_SET(pDevParams->wrLow);
+	devParam |= DBP_WRHIGH_SET(pDevParams->wrHigh);
+	MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(device), devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevPramget - Get device interface bank parameters
+*
+* DESCRIPTION:
+*       This function retrieves a device bank parameter settings.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       *pDevParams - Device bank parameter struct.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	pDevParams->turnOff = DBP_TURNOFF_GET(devParam);
+	pDevParams->acc2First = DBP_ACC2FIRST_GET(devParam);
+	pDevParams->acc2Next = DBP_ACC2NEXT_GET(devParam);
+	pDevParams->badrSkew = (devParam & DBP_BADRSKEW_MASK) >> DBP_BADRSKEW_OFFS;
+
+	switch (devParam & DBP_DEVWIDTH_MASK) {
+	case DBP_DEVWIDTH_8BIT:
+		pDevParams->deviceWidth = 8;
+		break;
+	case DBP_DEVWIDTH_16BIT:
+		pDevParams->deviceWidth = 16;
+		break;
+	case DBP_DEVWIDTH_32BIT:
+		pDevParams->deviceWidth = 32;
+		break;
+	default:
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth non valid value\n"));
+		return MV_ERROR;
+		break;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG_WR(device));
+	pDevParams->ale2Wr = DBP_ALE2WR_GET(devParam);
+	pDevParams->wrLow = DBP_WRLOW_GET(devParam);
+	pDevParams->wrHigh = DBP_WRHIGH_GET(devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevWidthGet - Get device width parameter
+*
+* DESCRIPTION:
+*       This function gets width parameter of a given device.
+*
+* INPUT:
+*       device - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Device width in bits (8,16,32...).
+*
+*******************************************************************************/
+MV_U32 mvDevWidthGet(MV_DEVICE device)
+{
+	MV_U32 devParam;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	devParam = (devParam & DBP_DEVWIDTH_MASK) >> DBP_DEVWIDTH_OFFS;
+
+	return (MV_U32) (0x8 << devParam);
+
+}
+
+/*******************************************************************************
+* mvDevNandDevCsSet - Set NAND chip-select, care mode and init sequence
+*
+* DESCRIPTION:
+*       This function set the NAND flash controller registers with NAND
+*       device chip-select.
+*
+* INPUT:
+*       devNum   - Device number. See MV_DEVICE enumerator.
+*       careMode - NAND device care mode (0 = Don't care, '1' = care).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode)
+{
+	MV_U32 nfCtrlReg;	/* NAND Flash Control Register */
+
+	/* Set chip select */
+	nfCtrlReg = MV_REG_READ(DEV_NAND_CTRL_REG);
+
+	nfCtrlReg |= (DINFCR_NF_CS_MASK(device));
+
+	if (careMode)
+		nfCtrlReg |= (DINFCR_NF_ACT_CE_MASK(device));
+	else
+		nfCtrlReg &= ~(DINFCR_NF_ACT_CE_MASK(device));
+
+	MV_REG_WRITE(DEV_NAND_CTRL_REG, nfCtrlReg);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
new file mode 100644
index 0000000..2f7d33f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceH
+#define __INCmvDeviceH
+
+#include "device/mvDeviceRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* This structure describes device interface parameters to be assigned to   */
+/* device bank parameter                                                    */
+typedef struct _mvDeviceParam {
+				/* boundary values */
+    MV_U32       turnOff;	/* 0x0 - 0xf       */
+    MV_U32       acc2First;	/* 0x0 - 0x1f      */
+    MV_U32       acc2Next;	/* 0x0 - 0x1f      */
+    MV_U32       ale2Wr;	/* 0x0 - 0xf       */
+    MV_U32       wrLow;		/* 0x0 - 0xf       */
+    MV_U32       wrHigh;	/* 0x0 - 0xf       */
+    MV_U32       badrSkew;	/* 0x0 - 0x2       */
+    MV_U32       deviceWidth;	/* in Bytes        */
+} MV_DEVICE_PARAM;
+
+
+/* mvDevPramSet - Set device interface bank parameters */
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevPramget - Get device interface bank parameters */
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevWidthGet - Get device width parameter*/
+MV_U32 mvDevWidthGet(MV_DEVICE device);
+
+/* mvDevNandDevCsSet - Set the NAND flash control registers with NAND device- */
+/* select and care mode */
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode);
+
+#endif /* #ifndef __INCmvDeviceH */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
new file mode 100644
index 0000000..25fea91
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
@@ -0,0 +1,270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceRegsH
+#define __INCmvDeviceRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_DEVICE_MAX_XBAR_TIMEOUT  0x0FFF
+/* TODO - usage of DEV_BANK_PARAM_REG_DV is unclear */
+/* #define DEV_BANK_PARAM_REG_DV	    0x80000000 */
+/* registers offsets */
+
+static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
+{
+	switch (num) {
+	case (DEV_BOOCS):
+		return MV_DEV_BUS_REGS_OFFSET + 0x00;
+	case (DEVICE_CS0):
+		return MV_DEV_BUS_REGS_OFFSET + 0x08;
+	case (DEVICE_CS1):
+		return MV_DEV_BUS_REGS_OFFSET + 0x10;
+#ifdef MV_INCLUDE_DEVICE_CS2
+	case (DEVICE_CS2):
+		return MV_DEV_BUS_REGS_OFFSET + 0x18;
+#endif
+#ifdef MV_INCLUDE_DEVICE_CS3
+	case (DEVICE_CS3):
+		return MV_DEV_BUS_REGS_OFFSET + 0x20;
+#endif
+	default:
+		return 0xFFFFFFFF;
+	}
+}
+
+#define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
+
+/* Device Bank Parameters register fields (DBP_REG)*/
+/* Boot Device Bank Parameters (DBP) register fields (DEV_BOOT_BANK_PARAM_REG)*/
+/* DBP_XXX_MASK_HIGH is the offset of the extend bit from the msb of the input value */
+
+#define DBP_TURNOFF_OFFS_LOW		0
+#define DBP_TURNOFF_MASK_LOW		0x3F
+#define MAX_DBP_TURNOFF			0xf
+
+
+#define DBP_TURNOFF_SET(value)			\
+((value & DBP_TURNOFF_MASK_LOW) << DBP_TURNOFF_OFFS_LOW)
+
+#define DBP_TURNOFF_GET(value)			\
+((value >> DBP_TURNOFF_OFFS_LOW) & DBP_TURNOFF_MASK_LOW)
+
+#define DBP_ACC2FIRST_OFFS_LOW		6
+#define DBP_ACC2FIRST_MASK_LOW		0x3f
+#define MAX_DBP_ACC2FIRST		0x3f
+
+#define DBP_ACC2FIRST_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2FIRST_GET(value)			\
+((value >> DBP_ACC2FIRST_OFFS_LOW) & DBP_ACC2FIRST_MASK_LOW)
+
+#define DBP_ACC2NEXT_OFFS_LOW		17
+#define DBP_ACC2NEXT_MASK_LOW		0x3f
+#define MAX_DBP_ACC2NEXT		0x3f
+
+#define DBP_ACC2NEXT_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2NEXT_GET(value)			\
+((value >> DBP_ACC2NEXT_OFFS_LOW) & DBP_ACC2NEXT_MASK_LOW)
+
+#define DBP_DEVWIDTH_OFFS		30 /* Device Width */
+#define DBP_DEVWIDTH_MASK		(0x3 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_8BIT		(0x0 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_16BIT		(0x1 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_32BIT		(0x2 << DBP_DEVWIDTH_OFFS)
+
+#define DBP_BADRSKEW_OFFS		28
+#define DBP_BADRSKEW_MASK		(0x3 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_NOGAP		(0x0 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_1CYCLE		(0x1 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_2CYCLE		(0x2 << DBP_BADRSKEW_OFFS)
+
+
+#define DBP_ALE2WR_OFFS_LOW		0
+#define DBP_ALE2WR_MASK_LOW		0x3f
+#define MAX_DBP_ALE2WR			0x3F
+
+#define DBP_ALE2WR_SET(value)			\
+((value & DBP_ALE2WR_MASK_LOW) << DBP_ALE2WR_OFFS_LOW)
+
+#define DBP_ALE2WR_GET(value)			\
+((value >> DBP_ALE2WR_OFFS_LOW) & DBP_ALE2WR_MASK_LOW)
+
+#define DBP_WRLOW_OFFS_LOW		8
+#define DBP_WRLOW_MASK_LOW		0x3F
+#define MAX_DBP_WRLOW			0x3F
+
+#define DBP_WRLOW_SET(value)			\
+((value & DBP_WRLOW_MASK_LOW) << DBP_WRLOW_OFFS_LOW)
+
+#define DBP_WRLOW_GET(value)			\
+((value >> DBP_WRLOW_OFFS_LOW) & DBP_WRLOW_MASK_LOW)
+
+#define DBP_WRHIGH_OFFS_LOW		16
+#define DBP_WRHIGH_MASK_LOW		0x3F
+#define MAX_DBP_WRHIGH			0x3F
+
+#define DBP_WRHIGH_SET(value)			\
+((value & DBP_WRHIGH_MASK_LOW) << DBP_WRHIGH_OFFS_LOW)
+
+#define DBP_WRHIGH_GET(value)			\
+((value >> DBP_WRHIGH_OFFS_LOW) & DBP_WRHIGH_MASK_LOW)
+
+
+/* Device Interface Control register fields (DIC) (DIC_REG)*/
+#define DIC_TIMEOUT_OFFS 	0 /* Timeout Timer Preset Value. */
+#define DIC_TIMEOUT_MASK 	(0xffff << DIC_TIMEOUT_OFFS)
+#define MAX_DIC_TIMEOUT		0xffff
+
+/* NAND Flash Control register fields (NF) (NF_REG)*/
+#define NF_BOOTCS_OFFS			0 /* Define if BOOTCS is connected to NAND Flash */
+#define NF_BOOT_MASK			(1 << NF_BOOTCS_OFFS)
+#define NF_BOOT_NC			(0 << NF_BOOTCS_OFFS)
+#define NF_BOOT_C			(1 << NF_BOOTCS_OFFS)
+
+#define NF_BOOTCS_CE_ACT_OFFS		1 /* Define if NAND Flash on BOOTCS is CE care or CE don't care */
+#define NF_BOOTCS_CE_ACT_MASK 		(1 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_NCARE		(0 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_CARE		(1 << NF_BOOTCS_CE_ACT_OFFS)
+
+#define NF_CS0_OFFS			2 /* Define if CS0 is connected to NAND Flash */
+#define NF_CS0_MASK			(1 << NF_CS0_OFFS)
+#define NF_CS0_NC			(0 << NF_CS0_OFFS)
+#define NF_CS0_C			(1 << NF_CS0_OFFS)
+
+#define NF_CS0_CE_ACT_OFFS		3 /* Define if NAND Flash on CS0 is CE care or CE don't care */
+#define NF_CS0_CE_ACT_MASK 		(1 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_NCARE		(0 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_CARE		(1 << NF_CS0_CE_ACT_OFFS)
+
+#define NF_CS1_OFFS			4 /* Define if CS1 is connected to NAND Flash */
+#define NF_CS1_MASK			(1 << NF_CS1_OFFS)
+#define NF_CS1_NC			(0 << NF_CS1_OFFS)
+#define NF_CS1_C			(1 << NF_CS1_OFFS)
+
+#define NF_CS1_CE_ACT_OFFS		5 /* Define if NAND Flash on CS1 is CE care or CE don't care */
+#define NF_CS1_CE_ACT_MASK		(1 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_NCARE		(0 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_CARE		(1 << NF_CS1_CE_ACT_OFFS)
+
+#define NF_CS2_OFFS			6 /* Define if CS2 is connected to NAND Flash */
+#define NF_CS2_MASK			(1 << NF_CS2_OFFS)
+#define NF_CS2_NC			(0 << NF_CS2_OFFS)
+#define NF_CS2_C			(1 << NF_CS2_OFFS)
+
+#define NF_CS2_CE_ACT_OFFS		7 /* Define if NAND Flash on CS2 is CE care or CE don't care */
+#define NF_CS2_CE_ACT_MASK		(1 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_NCARE		(0 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_CARE		(1 << NF_CS2_CE_ACT_OFFS)
+
+#define NF_INIT_SEQ_OFFS		8 /* NAND Flash initialization sequence */
+#define NF_INIT_SEQ_MASK		(1 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_EN			(0 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_DIS			(1 << NF_INIT_SEQ_OFFS)
+
+#define NF_OE_HIGHW_OFFS		9 /* NAND Flash OE high width in core clocks units (value + 1) */
+#define NF_OE_HIGHW_MASK		(0x1f << NF_OE_HIGHW_OFFS)
+#define MAX_OE_HIGHW			(0x1f << NF_OE_HIGHW_OFFS)
+
+#define NF_TREADY_OFFS			14 /* NAND Flash time ready in core clocks units (value + 1) */
+#define NF_TREADY_MASK			(0x1f << NF_TREADY_OFFS)
+#define MAX_TREADY			(0x1f << NF_TREADY_OFFS)
+
+#define NF_OE_TCTRL_OFFS		19 /* NAND Flash OE toggle control */
+#define NF_OE_TCTRL_MASK		(1 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_1_CYC_AFT		(0 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_SAME_CYC		(1 << NF_OE_TCTRL_OFFS)
+
+#define NF_CS3_OFFS			20 /* Define if CS3 is connected to NAND Flash */
+#define NF_CS3_MASK			(1 << NF_CS3_OFFS)
+#define NF_CS3_NC			(0 << NF_CS3_OFFS)
+#define NF_CS3_C			(1 << NF_CS3_OFFS)
+
+#define NF_CS3_CE_ACT_OFFS		21 /* Define if NAND Flash on CS3 is CE care or CE don't care */
+#define NF_CS3_CE_ACT_MASK		(1 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_NCARE		(0 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_CARE		(1 << NF_CS3_CE_ACT_OFFS)
+
+
+/* Device Interface NAND Flash Control Register (DINFCR) */
+#define DINFCR_NF_CS_MASK(csNum)         \
+(csNum == BOOT_CS) ?  0x1 : ((csNum == DEV_CS3) ? (0x1 << 20) : (0x1 << (((csNum+1) % MV_DEV_MAX_CS) * 2)))
+
+
+#define DINFCR_NF_ACT_CE_MASK(csNum)     \
+(csNum == DEV_CS3) ? (0x2 << 20) : (0x2 << (((csNum+1) % MV_DEV_MAX_CS) * 2))
+
+#define NAND_ACTCEBOOT_BIT	BIT1
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCmvDeviceRegsH */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/star_test.txt b/arch/arm/mach-armadaxp/armada_xp_family/star_test.txt
new file mode 100644
index 0000000..9daeafb
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/star_test.txt
@@ -0,0 +1 @@
+test
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/version.txt b/arch/arm/mach-armadaxp/armada_xp_family/version.txt
new file mode 100644
index 0000000..0509b3d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/version.txt
@@ -0,0 +1 @@
+2013_Q1.0p1
-- 
1.7.5.4

