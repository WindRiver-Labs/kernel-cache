From 53ab29097f2032391dfb5809c09b29ab35e19550 Mon Sep 17 00:00:00 2001
From: Yelena <yelena@marvell.com>
Date: Mon, 16 Dec 2013 11:59:24 +0200
Subject: [PATCH 1229/1825] pp3: netdev draft definition

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 79f5ecf03283ca5438feacfc1e28ea1077a0c10a

Change-Id: I7421caa9ecbe6f37b7e9983b50814d6d810fae5d
Signed-off-by: Yelena <yelena@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4741
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h |    3 +
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c    |    9 +
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |  199 ++++++++++++++-
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.h   |  269 ++++++++++++++++++++
 4 files changed, 476 insertions(+), 4 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h

diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
index 95d7f21..1d0bb64 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
@@ -72,6 +72,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define INLINE inline
 #define MV_PPV3_BASE_ADDR 0
 
+#define	MV_MAC_ADDR_SIZE	(6)
+#define MV_MAC_STR_SIZE		(20)
+
 struct pp3_unit_info {
 	u32 base_addr; /* unit base address = silicon addr + unit offset */
 	u32 ins_offs;  /* unit instance offset - for multiple units */
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
index a462cbc..77ed194 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
@@ -175,3 +175,12 @@ static int mv_pp3_hmac_queue_create(struct mv_pp3_queue_ctrl *q_ctrl, int desc_n
 	q_ctrl->last = q_ctrl->first + size;
 	return 0;
 }
+
+u32 mv_pp3_hmac_txq_init(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl)
+{
+	return 0;
+}
+
+void mv_pp3_hmac_txq_send(int frame, int queue, int size)
+{
+}
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index e22f7a7..4119982 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -9,16 +9,110 @@
 #include <linux/module.h>
 #include <linux/inetdevice.h>
 #include <linux/interrupt.h>
-/*#include <linux/mv_pp3.h>*/
 #include <asm/setup.h>
 #include <net/ip.h>
 #include <net/ipv6.h>
+#include <linux/mv_pp3.h>
+#include "common/mv_hw_if.h"
+#include "hmac/mv_hmac.h"
+#include "hmac/mv_hmac_bm.h"
+#include "mv_netdev.h"
 
-#define MV_PP3_PORT_NAME        "mv_pp3_port"
+/* global data */
+static int mv_eth_initialized;
+static int mv_eth_ports_num;
 
-/* Support for platform driver */
+struct eth_port **mv_eth_ports;
+
+static int mv_eth_config_get(struct platform_device *pdev, u8 *mac_addr)
+{
+	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+
+	if (mac_addr)
+		memcpy(mac_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
+
+	return plat_data->mtu;
+}
+
+/***************************************************************
+ * mv_eth_netdev_init -- Allocate and initialize net_device    *
+ *                   structure                                 *
+ ***************************************************************/
+struct net_device *mv_eth_netdev_init(int mtu, u8 *mac, struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct eth_port *dev_priv;
+	struct resource *res;
+
+	dev = alloc_etherdev_mq(sizeof(struct eth_port), CONFIG_MV_ETH_TXQ);
+	if (!dev)
+		return NULL;
+
+	dev_priv = (struct eth_port *)netdev_priv(dev);
+	if (!dev_priv)
+		return NULL;
+
+	memset(dev_priv, 0, sizeof(struct eth_port));
+
+	dev_priv->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	BUG_ON(!res);
+	dev->irq = res->start;
+
+	dev->mtu = mtu;
+	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
+	dev->tx_queue_len = CONFIG_MV_ETH_TXQ_DESC;
+	dev->watchdog_timeo = 5 * HZ;
+
+	/*dev->netdev_ops = &mv_eth_netdev_ops;*/
+
+	/*SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);*/
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	return dev;
+
+}
+
+static int mv_eth_load_network_interfaces(struct platform_device *pdev)
+{
+	u32 port, phys_port;
+	int mtu;
+	struct eth_port *pp;
+	struct net_device *dev;
+	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+	u8 mac[MV_MAC_ADDR_SIZE];
+
+	port = pdev->id;
+	phys_port = port; /*MV_PPV3_PORT_PHYS(port);*/
+	pr_info("  o Loading network interface(s) for port #%d: mtu=%d\n", port, plat_data->mtu);
+
+	mtu = mv_eth_config_get(pdev, mac);
+
+	dev = mv_eth_netdev_init(mtu, mac, pdev);
+
+	if (dev == NULL) {
+		pr_err("\to %s: can't create netdevice\n", __func__);
+		return -EIO;
+	}
+
+	pp = (struct eth_port *)netdev_priv(dev);
+	pp->plat_data = plat_data;
+
+	mv_eth_ports[port] = pp;
+
+	return 0;
+}
+
+/* Support per port for platform driver */
 static int mv_pp3_probe(struct platform_device *pdev)
 {
+	struct mv_pp3_port_data *plat_data = (struct mv_pp3_port_data *)pdev->dev.platform_data;
+
+	if (mv_eth_load_network_interfaces(pdev))
+		return -ENODEV;
+
 	pr_info("Probing Marvell PPv3 Network Driver\n");
 	return 0;
 }
@@ -58,18 +152,112 @@ static struct platform_driver mv_pp3_driver = {
 #endif /* CONFIG_CPU_IDLE */
 	.driver = {
 		.name = MV_PP3_PORT_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+/*
+ * Global units (hmac, qm/bm and etc.) init functions
+*/
+static int mv_pp3_shared_probe(struct platform_device *pdev)
+{
+	struct mv_pp3_plat_data *plat_data = (struct mv_pp3_plat_data *)pdev->dev.platform_data;
+	struct resource *res;
+	int size;
+
+	int ret;
+
+	ret = -EINVAL;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		goto out;
+/*
+	ret = -ENOMEM;
+	msp = kzalloc(sizeof(*msp), GFP_KERNEL);
+	if (msp == NULL)
+		goto out;
+*/
+	/*
+	 * Check whether the error interrupt is hooked up.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+/*	if (res != NULL) {
+		int err;
+
+		err = request_irq(res->start, mv643xx_eth_err_irq,
+				  IRQF_SHARED, "mv643xx_eth", msp);
+		if (!err) {
+			writel(ERR_INT_SMI_DONE, msp->base + ERR_INT_MASK);
+			msp->err_interrupt = res->start;
+		}
+	}*/
+
+	mv_eth_ports_num = plat_data->max_port;
+	/*mv_eth_sysfs_init();*/
+	/*mv_eth_win_init();*/
+	/*mv_eth_config_show();*/
+
+	size = mv_eth_ports_num * sizeof(struct eth_port *);
+	mv_eth_ports = kzalloc(size, GFP_KERNEL);
+	if (!mv_eth_ports)
+		goto out;
+
+	memset(mv_eth_ports, 0, size);
+
+	/*if (mv_eth_bm_pools_init())
+		goto oom;*/
+
+	/* Initialize tasklet for handle link events */
+	/*tasklet_init(&link_tasklet, mv_eth_link_tasklet, 0);*/
+
+	/* request IRQ for link interrupts from GOP */
+	/*if (request_irq(IRQ_GLOBAL_GOP, mv_eth_link_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth_link", NULL))
+		printk(KERN_ERR "%s: Could not request IRQ for GOP interrupts\n", __func__);*/
+
+	mv_eth_initialized = 1;
+
+	/*platform_set_drvdata(pdev, msp);*/
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static int mv_pp3_shared_remove(struct platform_device *pdev)
+{
+	/* free all shared resources */
+	return 0;
+}
+
+static struct platform_driver mv_pp3_shared_driver = {
+	.probe		= mv_pp3_shared_probe,
+	.remove		= mv_pp3_shared_remove,
+	.driver = {
+		.name	= MV_PP3_SHARED_NAME,
+		.owner	= THIS_MODULE,
 	},
 };
 
 static int __init mv_pp3_init_module(void)
 {
-	return platform_driver_register(&mv_pp3_driver);
+	int rc;
+
+	rc = platform_driver_register(&mv_pp3_shared_driver);
+	if (!rc) {
+		rc = platform_driver_register(&mv_pp3_driver);
+		if (rc)
+			platform_driver_unregister(&mv_pp3_shared_driver);
+	}
+
+	return rc;
 }
 module_init(mv_pp3_init_module);
 
 static void __exit mv_pp3_cleanup_module(void)
 {
 	platform_driver_unregister(&mv_pp3_driver);
+	platform_driver_unregister(&mv_pp3_shared_driver);
 }
 module_exit(mv_pp3_cleanup_module);
 
@@ -77,3 +265,6 @@ module_exit(mv_pp3_cleanup_module);
 MODULE_DESCRIPTION("Marvell PPv3 Network Driver - www.marvell.com");
 MODULE_AUTHOR("Dmitri Epshtein <dima@marvell.com>");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MV_PP3_SHARED_NAME);
+MODULE_ALIAS("platform:" MV_PP3_PORT_NAME);
+
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
new file mode 100644
index 0000000..77c7fcb
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
@@ -0,0 +1,269 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_netdev_h__
+#define __mv_netdev_h__
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mv_pp3.h>
+#include <net/ip.h>
+
+/*
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "mv802_3.h"
+#include "mvStack.h"*/
+/*
+#include "gbe/mvPp2Gbe.h"
+#include "bm/mvBmRegs.h"
+#include "bm/mvBm.h"
+*/
+
+/******************************************************
+ * driver statistics control --                       *
+ ******************************************************/
+#ifdef CONFIG_MV_ETH_STAT_ERR
+#define STAT_ERR(c) c
+#else
+#define STAT_ERR(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_INF
+#define STAT_INFO(c) c
+#else
+#define STAT_INFO(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_DBG
+#define STAT_DBG(c) c
+#else
+#define STAT_DBG(c)
+#endif
+
+#ifdef CONFIG_MV_ETH_STAT_DIST
+#define STAT_DIST(c) c
+#else
+#define STAT_DIST(c)
+#endif
+
+
+/****************************************************************************
+ * Rx buffer size: MTU + 2(Marvell Header) + 4(VLAN) + 14(MAC hdr) + 4(CRC) *
+ ****************************************************************************/
+#define MV_ETH_SKB_SHINFO_SIZE		SKB_DATA_ALIGN(sizeof(struct skb_shared_info))
+
+#define RX_PKT_SIZE(mtu) \
+		MV_ALIGN_UP((mtu) + 2 + 4 + ETH_HLEN + 4, CPU_D_CACHE_LINE_SIZE)
+
+#define RX_BUF_SIZE(pkt_size)		((pkt_size) + NET_SKB_PAD)
+#define RX_TOTAL_SIZE(buf_size)		((buf_size) + MV_ETH_SKB_SHINFO_SIZE)
+#define RX_MAX_PKT_SIZE(total_size)	((total_size) - NET_SKB_PAD - MV_ETH_SKB_SHINFO_SIZE)
+
+#define RX_HWF_PKT_OFFS			32
+#define RX_HWF_BUF_SIZE(pkt_size)	((pkt_size) + RX_HWF_PKT_OFFS)
+#define RX_HWF_TOTAL_SIZE(buf_size)	(buf_size)
+#define RX_HWF_MAX_PKT_SIZE(total_size)	((total_size) - RX_HWF_PKT_OFFS)
+
+#define RX_TRUE_SIZE(total_size)	roundup_pow_of_two(total_size)
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+extern int mv_ctrl_recycle;
+
+#define mv_eth_is_recycle()     (mv_ctrl_recycle)
+int mv_eth_skb_recycle(struct sk_buff *skb);
+#else
+#define mv_eth_is_recycle()     0
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
+/******************************************************
+ * rx / tx queues --                                  *
+ ******************************************************/
+/*
+ * Debug statistics
+ */
+
+struct txq_stats {
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	u32 txq_err;
+#endif /* CONFIG_MV_ETH_STAT_ERR */
+#ifdef CONFIG_MV_ETH_STAT_DBG
+	u32 txq_tx;
+	u32 txq_txreq; /*request reserved tx descriptors*/
+	u32 txq_txdone;
+#endif /* CONFIG_MV_ETH_STAT_DBG */
+};
+
+struct port_stats {
+
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	u32 rx_error;
+	u32 tx_timeout;
+	u32 ext_stack_empty;
+	u32 ext_stack_full;
+	u32 state_err;
+#endif /* CONFIG_MV_ETH_STAT_ERR */
+
+#ifdef CONFIG_MV_ETH_STAT_INF
+	u32 irq[CONFIG_NR_CPUS];
+	u32 irq_err[CONFIG_NR_CPUS];
+	u32 poll[CONFIG_NR_CPUS];
+	u32 poll_exit[CONFIG_NR_CPUS];
+	u32 tx_done_timer_event[CONFIG_NR_CPUS];
+	u32 tx_done_timer_add[CONFIG_NR_CPUS];
+	u32 tx_done;
+	u32 link;
+	u32 netdev_stop;
+	u32 rx_buf_hdr;
+
+#ifdef CONFIG_MV_ETH_RX_SPECIAL
+	u32 rx_special;
+#endif /* CONFIG_MV_ETH_RX_SPECIAL */
+
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+	u32 tx_special;
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
+
+#endif /* CONFIG_MV_ETH_STAT_INF */
+
+#ifdef CONFIG_MV_ETH_STAT_DBG
+	u32 rxq[CONFIG_MV_ETH_RXQ];
+	u32 rx_tagged;
+	u32 rx_netif;
+	u32 rx_gro;
+	u32 rx_gro_bytes;
+	u32 rx_drop_sw;
+	u32 rx_csum_hw;
+	u32 rx_csum_sw;
+	u32 tx_csum_hw;
+	u32 tx_csum_sw;
+	u32 tx_skb_free;
+	u32 tx_sg;
+	u32 tx_tso;
+	u32 tx_tso_no_resource;
+	u32 tx_tso_bytes;
+	u32 ext_stack_put;
+	u32 ext_stack_get;
+#endif /* CONFIG_MV_ETH_STAT_DBG */
+};
+
+#define MV_ETH_TX_DESC_ALIGN		0x1f
+
+/* Masks used for pp->flags */
+#define MV_ETH_F_STARTED_BIT            0
+#define MV_ETH_F_RX_DESC_PREFETCH_BIT   1
+#define MV_ETH_F_RX_PKT_PREFETCH_BIT    2
+#define MV_ETH_F_CONNECT_LINUX_BIT      5 /* port is connected to Linux netdevice */
+#define MV_ETH_F_LINK_UP_BIT            6
+#define MV_ETH_F_IFCAP_NETMAP_BIT       15
+
+#define MV_ETH_F_STARTED                (1 << MV_ETH_F_STARTED_BIT)
+#define MV_ETH_F_RX_DESC_PREFETCH       (1 << MV_ETH_F_RX_DESC_PREFETCH_BIT)
+#define MV_ETH_F_RX_PKT_PREFETCH        (1 << MV_ETH_F_RX_PKT_PREFETCH_BIT)
+#define MV_ETH_F_CONNECT_LINUX          (1 << MV_ETH_F_CONNECT_LINUX_BIT)
+#define MV_ETH_F_LINK_UP                (1 << MV_ETH_F_LINK_UP_BIT)
+#define MV_ETH_F_IFCAP_NETMAP           (1 << MV_ETH_F_IFCAP_NETMAP_BIT)
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+/* Masks used for pp->dbg_flags */
+#define MV_ETH_F_DBG_RX_BIT         0
+#define MV_ETH_F_DBG_TX_BIT         1
+#define MV_ETH_F_DBG_DUMP_BIT       2
+#define MV_ETH_F_DBG_ISR_BIT        3
+#define MV_ETH_F_DBG_POLL_BIT       4
+#define MV_ETH_F_DBG_BUFF_HDR_BIT   5
+
+#define MV_ETH_F_DBG_RX            (1 << MV_ETH_F_DBG_RX_BIT)
+#define MV_ETH_F_DBG_TX            (1 << MV_ETH_F_DBG_TX_BIT)
+#define MV_ETH_F_DBG_DUMP          (1 << MV_ETH_F_DBG_DUMP_BIT)
+#define MV_ETH_F_DBG_ISR           (1 << MV_ETH_F_DBG_ISR_BIT)
+#define MV_ETH_F_DBG_POLL          (1 << MV_ETH_F_DBG_POLL_BIT)
+#define MV_ETH_F_DBG_BUFF_HDR      (1 << MV_ETH_F_DBG_BUFF_HDR_BIT)
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+/* Masks used for cpu_ctrl->flags */
+#define MV_ETH_F_TX_DONE_TIMER_BIT  0
+
+#define MV_ETH_F_TX_DONE_TIMER		(1 << MV_ETH_F_TX_DONE_TIMER_BIT)	/* 0x01 */
+
+struct tx_queue {
+	struct mv_pp3_queue_ctrl	queue_ctrl;
+	int			port;
+	u8			txp;
+	u8			txq;
+	int			txq_size;
+	int			hwf_size;
+/*	struct txq_cpu_ctrl	txq_cpu[CONFIG_NR_CPUS];
+	spinlock_t		queue_lock;
+	MV_U32			txq_done_pkts_coal;
+	unsigned long		flags;*/
+};
+
+struct rx_queue {
+	struct mv_pp3_queue_ctrl	queue_ctrl;
+	int					port;
+	int					logic_queue;
+	int					frame_num;
+	int					queue_num;
+	int                 rxq_size;
+	unsigned int        rxq_pkts_coal;
+	unsigned int        rxq_time_coal;
+};
+
+struct eth_port {
+	int                      port;
+	struct mv_pp3_port_data *plat_data;
+	bool                     tagged; /* NONE/MH/DSA/EDSA/VLAN */
+	/*MV_PP3_PORT_CTRL    *port_ctrl;*/
+	struct rx_queue          *rxq_ctrl; /* array of logical queues */
+	int                       rxq_num;
+	struct tx_queue          *txq_ctrl;
+	/*int                       txp_num;*/
+	struct net_device      *dev;
+};
+
+struct napi_group_ctrl {
+	int			id;
+	u8			cpu_mask;
+	u16			rxq_mask;
+	u32			cause_rx_tx;
+	struct napi_struct	*napi;
+};
+
+struct cpu_ctrl {
+	struct eth_port		*pp;
+	struct napi_group_ctrl	*napi_group;
+	int			txq;
+	int			cpu;
+	struct timer_list	tx_done_timer;
+	unsigned long		flags;
+};
+
+#define MV_ETH_PRIV(dev)	((struct eth_port *)(netdev_priv(dev)))
+
+#endif /* __mv_netdev_h__ */
-- 
1.7.5.4

