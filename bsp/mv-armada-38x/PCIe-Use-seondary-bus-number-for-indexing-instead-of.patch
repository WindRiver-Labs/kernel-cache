From 35c9c8b0f1d430daa7dec4c3050178bbe46e5d0d Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Thu, 10 Jan 2013 12:21:32 +0200
Subject: [PATCH 0426/1825] PCIe: Use seondary bus number for indexing instead
 of local bus number. This enables the virtual
 bridge support for EP devices working with device
 number zero only. Local bus number is hard coded
 to 0xFF (Last Bus number)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4625b0c91605caf08b39400e019607c9df3d459c

Change-Id: I4af5f7fce5df76cfe49450f3824114f38a2e89af
Signed-off-by: Eli Nidam <elini@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h   |    2 +-
 .../mv_hal/pci-if/pci_util/mvPciUtils.c            |    7 +-
 arch/arm/plat-armada/mv_hal/pex/mvPex.c            |  186 ++++++++++---------
 arch/arm/plat-armada/mv_hal/pex/mvPex.h            |    6 +
 arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h        |   24 ++-
 arch/arm/plat-armada/mv_hal/pex/mvVrtBrgPex.c      |    4 +-
 6 files changed, 129 insertions(+), 100 deletions(-)
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h

diff --git a/arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h
old mode 100644
new mode 100755
index 668d75b..1c96628
--- a/arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h
@@ -66,7 +66,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __INCPCIIFREGSH
 
 /* defines */
-#define MAX_PCI_DEVICES         32
+#define MAX_PCI_DEVICES         1
 #define MAX_PCI_FUNCS           8
 #define MAX_PCI_BUSSES          128
 
diff --git a/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
index 88424e49..9596daf 100644
--- a/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
+++ b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
@@ -140,14 +140,17 @@ MV_STATUS mvPciScan(MV_U32 pciIf, MV_PCI_DEVICE *pPciAgents, MV_U32 * pPciAgents
 	DB(mvOsPrintf("mvPciScan: PCI interface num scan%d\n", pciIf));
 	
 	/* go through all busses */
-	for (busIndex = localBus; busIndex < MAX_PCI_BUSSES; busIndex++) {
+	for (busIndex = localBus; busIndex <= MAX_PCI_BUSSES; busIndex++) {
 		/* go through all possible devices on the local bus */
 		for (devIndex = 0; devIndex < MAX_PCI_DEVICES; devIndex++) {
 			/* always start with function equal to zero */
 			funcIndex = 0;
+			/* We need to scan the local bus 0xFF as well */
+			if (busIndex == MAX_PCI_BUSSES)
+				busIndex = 0xFF;
 
 			pPciDevice = &pPciAgents[detectedDevNum];
-			DB(mvOsPrintf("mvPciScan: PCI interface num scan%d:%d\n", busIndex, devIndex));
+			DB(mvOsPrintf("mvPciScan: PCI%d interface num scan %d:%d\n", pciIf, busIndex, devIndex));
 
 			if (MV_ERROR == pciDetectDevice(pciIf, busIndex, devIndex, funcIndex, pPciDevice)) {
 				/* no device detected , try the next address */
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPex.c b/arch/arm/plat-armada/mv_hal/pex/mvPex.c
index 82629fa..c1257c1 100755
--- a/arch/arm/plat-armada/mv_hal/pex/mvPex.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPex.c
@@ -70,6 +70,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvPexRegs.h"
 /* #include "pci-if/mvPciIf.h" */
 #include "mvPex.h"
+#include "mvVrtBrgPex.h"
 
 /* #define MV_DEBUG */
 /* defines  */
@@ -86,16 +87,13 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType, MV_PEX_HAL_DATA *halData)
 	MV_PEX_MODE pexMode;
 	MV_U32 regVal;
 	MV_U32 status;
-	MV_U32 ctrlFamily;
 
 	mvOsMemcpy(&pexHalData[pexIf], halData, sizeof(MV_PEX_HAL_DATA));
-	ctrlFamily=pexHalData[pexIf].ctrlFamily;
 
 	if (mvPexModeGet(pexIf, &pexMode) != MV_OK) {
 		mvOsPrintf("PEX init ERR. mvPexModeGet failed (pexType=%d)\n", pexMode.pexType);
 		return MV_ERROR;
 	}
-
 	if (pexMode.pexLinkUp == MV_FALSE) {
 		/*  interface detected no Link. */
 		return MV_NO_SUCH;
@@ -117,20 +115,24 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType, MV_PEX_HAL_DATA *halData)
 		mvPexMasterEnable(pexIf, MV_TRUE);
 
 		/* Local device slave Enable */
-		mvPexSlaveEnable(pexIf, mvPexLocalBusNumGet(pexIf), mvPexLocalDevNumGet(pexIf), MV_TRUE);
+		mvPexSlaveEnable(pexIf, 0xFF, mvPexLocalDevNumGet(pexIf), MV_TRUE);
 		/* Interrupt disable */
 		status = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_STATUS_AND_COMMAND));
 		status |= PXSAC_INT_DIS;
 		MV_REG_WRITE(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_STATUS_AND_COMMAND), status);
-	} else {
+	} else { /* if (MV_PEX_ROOT_COMPLEX != pexType) */
 			regVal = MV_REG_READ(PEX_DBG_CTRL_REG(pexIf));
 			regVal &= ~(BIT16 | BIT19);
 			MV_REG_WRITE(PEX_DBG_CTRL_REG(pexIf), regVal);
+	}
 
+	/* Check if we have link */
+	if (pexMode.pexLinkUp == MV_FALSE) {
+		/*  interface detected no Link. */
+		return MV_NO_SUCH;
 	}
-#ifdef PCIE_VIRTUAL_BRIDGE_SUPPORT
+
 	mvPexVrtBrgInit(pexIf);
-#endif
 	return MV_OK;
 }
 
@@ -218,16 +220,12 @@ MV_U32 mvPexModeGet(MV_U32 pexIf, MV_PEX_MODE *pexMode)
 *******************************************************************************/
 MV_U32 mvPexConfigRead(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff)
 {
-#if defined(PCIE_VIRTUAL_BRIDGE_SUPPORT)
 	return mvPexVrtBrgConfigRead(pexIf, bus, dev, func, regOff);
 }
 
 MV_U32 mvPexHwConfigRead(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff)
 {
-#endif
 	MV_U32 pexData = 0;
-	MV_U32 localDev, localBus;
-
 	if (pexIf >= MV_PEX_MAX_IF)
 		return 0xFFFFFFFF;
 
@@ -257,35 +255,9 @@ MV_U32 mvPexHwConfigRead(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U
 	DB(mvOsPrintf("mvPexConfigRead: pexIf %d, bus %d, dev %d, func %d, regOff 0x%x\n",
 		      pexIf, bus, dev, func, regOff));
 
-	localDev = mvPexLocalDevNumGet(pexIf);
-	localBus = mvPexLocalBusNumGet(pexIf);
-
-	/* Speed up the process. In case on no link, return MV_ERROR */
-	if ((dev != localDev) || (bus != localBus)) {
-		pexData = MV_REG_READ(PEX_STATUS_REG(pexIf));
-
-		if ((pexData & PXSR_DL_DOWN))
-			return MV_ERROR;
-	}
-
-	/* in PCI Express we have only one device number */
-	/* and this number is the first number we encounter
-	   else that the localDev */
-	/* spec pex define return on config read/write on any device */
-	if (bus == localBus) {
-		if (localDev == 0) {
-			/* if local dev is 0 then the first number we encounter
-			   after 0 is 1 */
-			if ((dev != 1) && (dev != localDev))
+	if (dev != 0)
 				return MV_ERROR;
-		} else {
-			/* if local dev is not 0 then the first number we encounter
-			   is 0 */
 
-			if ((dev != 0) && (dev != localDev))
-				return MV_ERROR;
-		}
-	}
 	/* Creating PEX address to be passed */
 	pexData = (bus << PXCAR_BUS_NUM_OFFS);
 	pexData |= (dev << PXCAR_DEVICE_NUM_OFFS);
@@ -344,15 +316,12 @@ MV_U32 mvPexHwConfigRead(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U
 *******************************************************************************/
 MV_STATUS mvPexConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
-#if defined(PCIE_VIRTUAL_BRIDGE_SUPPORT)
 	return mvPexVrtBrgConfigWrite(pexIf, bus, dev, func, regOff, data);
 }
 
 MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
-#endif
 	MV_U32 pexData = 0;
-	MV_U32 localDev, localBus;
 
 	if (pexIf >= MV_PEX_MAX_IF)
 		return MV_BAD_PARAM;
@@ -360,60 +329,29 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 	/* Parameter checking   */
 	if (PEX_DEFAULT_IF != pexIf) {
 		if (pexIf >= pexHalData[pexIf].maxPexIf) {
-			mvOsPrintf("mvPexConfigWrite: ERR. Invalid PEX interface %d\n", pexIf);
+			DB(mvOsPrintf("mvPexConfigWrite: ERR. Invalid PEX interface %d\n", pexIf);)
 			return MV_ERROR;
 		}
 	}
 
 	if (dev >= MAX_PEX_DEVICES) {
-		mvOsPrintf("mvPexConfigWrite: ERR. device number illigal %d\n", dev);
+		DB(mvOsPrintf("mvPexConfigWrite: ERR. device number illigal %d\n", dev);)
 		return MV_BAD_PARAM;
 	}
 
 	if (func >= MAX_PEX_FUNCS) {
-		mvOsPrintf("mvPexConfigWrite: ERR. function number illigal %d\n", func);
+		DB(mvOsPrintf("mvPexConfigWrite: ERR. function number illigal %d\n", func);)
 		return MV_ERROR;
 	}
 
 	if (bus >= MAX_PEX_BUSSES) {
-		mvOsPrintf("mvPexConfigWrite: ERR. bus number illigal %d\n", bus);
+		DB(mvOsPrintf("mvPexConfigWrite: ERR. bus number illigal %d\n", bus);)
 		return MV_ERROR;
 	}
 
-	localDev = mvPexLocalDevNumGet(pexIf);
-	localBus = mvPexLocalBusNumGet(pexIf);
-
-	/* in PCI Express we have only one device number other than ourselves */
-	/* and this number is the first number we encounter
-	   else than the localDev that can be any valid dev number */
-	/* pex spec define return on config read/write on any device */
-	if (bus == localBus) {
-		if (localDev == 0) {
-			/* if local dev is 0 then the first number we encounter
-			   after 0 is 1 */
-			if ((dev != 1) && (dev != localDev))
-				return MV_ERROR;
-		} else {
-			/* if local dev is not 0 then the first number we encounter
-			   is 0 */
-
-			if ((dev != 0) && (dev != localDev))
-				return MV_ERROR;
-		}
-
-	}
-
 	/* if we are not accessing ourselves , then check the link */
-	if ((dev != localDev) || (bus != localBus)) {
-		/* workarround */
-		/* when no link return MV_ERROR */
-
-		pexData = MV_REG_READ(PEX_STATUS_REG(pexIf));
-
-		if ((pexData & PXSR_DL_DOWN))
+	if (dev != 0)
 			return MV_ERROR;
-	}
-
 	pexData = 0;
 
 	/* Creating PEX address to be passed */
@@ -521,7 +459,7 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 		return MV_BAD_PARAM;
 	}
 	if (dev >= MAX_PEX_DEVICES) {
-		mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n", dev);
+		DB(mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n", dev));
 		return MV_BAD_PARAM;
 
 	}
@@ -540,8 +478,85 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 	return MV_OK;
 
 }
+/*******************************************************************************
+* mvPexSecondaryBusNumGet - Get PEX interface local bus number.
+*
+* DESCRIPTION:
+*       This function gets the secondary bus number of a given PEX interface.
+*
+* INPUT:
+*       pexIf  - PEX interface number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Local bus number.0xffffffff on Error
+*
+*******************************************************************************/
+MV_U32 mvPexSecondaryBusNumGet(MV_U32 pexIf)
+{
+	MV_U32 pexSecondary;
+
+	if (pexIf >= MV_PEX_MAX_IF)
+		return 0xFFFFFFFF;
+
+	/* Parameter checking   */
+	if (PEX_DEFAULT_IF != pexIf) {
+		if (pexIf >= pexHalData[pexIf].maxPexIf) {
+			mvOsPrintf("mvPexLocalBusNumGet: ERR. Invalid PEX interface %d\n", pexIf);
+			return 0xFFFFFFFF;
+		}
+	}
+
+	pexSecondary = MV_REG_READ(PEX_SECONDARY_BUS_REG(pexIf));
+
+	pexSecondary &= SECONDARY_BUS_NUMBER_MASK;
+
+	return (pexSecondary >> SECONDARY_BUS_NUMBER_OFFS);
+}
 
 /*******************************************************************************
+* mvPexSecondaryBusNumSet - Set PEX interface secondary bus number.
+*
+* DESCRIPTION:
+*       This function sets given PEX interface its secondary bus number.
+*       Note: In case the PEX interface is PEX-X, the information is read-only.
+*
+* INPUT:
+*       pexIf  - PEX interface number.
+*       busNum - secondary bus number.
+*
+* OUTPUT:
+*       None.
+
+* RETURN:
+*       MV_NOT_ALLOWED in case PEX interface is PEX-X.
+*		MV_BAD_PARAM on bad parameters ,
+*       otherwise MV_OK
+*
+********************************************************************************/
+MV_STATUS mvPexSecondaryBusNumSet(MV_U32 pexIf, MV_U32 busNum)
+{
+	MV_U32 secondaryBus = 0;
+
+	/* Parameter checking   */
+	if (pexIf >= pexHalData[pexIf].maxPexIf) {
+		mvOsPrintf("mvPexSecondaryBusNumSet: ERR. Invalid PEX interface %d\n", pexIf);
+		return MV_BAD_PARAM;
+	}
+	if (busNum >= MAX_PEX_BUSSES) {
+		mvOsPrintf("mvPexSecondaryBusNumSet: ERR. bus number illigal %d\n", busNum);
+		return MV_ERROR;
+	}
+
+	secondaryBus = 0x100 | busNum;
+
+	MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pexIf), secondaryBus);
+
+	return MV_OK;
+}
+/*******************************************************************************
 * mvPexLocalBusNumSet - Set PEX interface local bus number.
 *
 * DESCRIPTION:
@@ -561,6 +576,7 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 *       otherwise MV_OK
 *
 *******************************************************************************/
+
 MV_STATUS mvPexLocalBusNumSet(MV_U32 pexIf, MV_U32 busNum)
 {
 	MV_U32 pexStatus;
@@ -579,11 +595,11 @@ MV_STATUS mvPexLocalBusNumSet(MV_U32 pexIf, MV_U32 busNum)
 
 	pexStatus &= ~PXSR_PEX_BUS_NUM_MASK;
 
-	pexStatus |= (busNum << PXSR_PEX_BUS_NUM_OFFS) & PXSR_PEX_BUS_NUM_MASK;
+	pexStatus |= (0xFF << PXSR_PEX_BUS_NUM_OFFS) & PXSR_PEX_BUS_NUM_MASK;
 
 	MV_REG_WRITE(PEX_STATUS_REG(pexIf), pexStatus);
 
-	return MV_OK;
+	return mvPexSecondaryBusNumSet(pexIf, busNum);
 }
 
 /*******************************************************************************
@@ -604,8 +620,6 @@ MV_STATUS mvPexLocalBusNumSet(MV_U32 pexIf, MV_U32 busNum)
 *******************************************************************************/
 MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf)
 {
-	MV_U32 pexStatus;
-
 	if (pexIf >= MV_PEX_MAX_IF)
 		return 0xFFFFFFFF;
 
@@ -617,11 +631,7 @@ MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf)
 		}
 	}
 
-	pexStatus = MV_REG_READ(PEX_STATUS_REG(pexIf));
-
-	pexStatus &= PXSR_PEX_BUS_NUM_MASK;
-
-	return (pexStatus >> PXSR_PEX_BUS_NUM_OFFS);
+	return mvPexSecondaryBusNumGet(pexIf);
 }
 
 /*******************************************************************************
@@ -657,7 +667,7 @@ MV_STATUS mvPexLocalDevNumSet(MV_U32 pexIf, MV_U32 devNum)
 		return MV_BAD_PARAM;
 	}
 	if (devNum >= MAX_PEX_DEVICES) {
-		mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n", devNum);
+		DB(mvOsPrintf("mvPexLocalDevNumSet: ERR. device number illigal %d\n", devNum));
 		return MV_BAD_PARAM;
 	}
 
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPex.h b/arch/arm/plat-armada/mv_hal/pex/mvPex.h
index fbc2051..1b6b0dd 100644
--- a/arch/arm/plat-armada/mv_hal/pex/mvPex.h
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPex.h
@@ -177,6 +177,12 @@ extern "C" {
 	/* mvPexLocalBusNumGet - Get PEX interface local bus number. */
 	MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf);
 
+	/* mvPexSecondaryBusNumGet - Get the secondary bus number used in Virtual Bridge */
+	MV_U32 mvPexSecondaryBusNumGet(MV_U32 pexIf);
+
+	/* mvPexSecondaryBusNumSet - Set the secondary bus number used in the Virtual Bridge */
+	MV_STATUS mvPexSecondaryBusNumSet(MV_U32 pexIf, MV_U32 busNum);
+
 	/* mvPexLocalDevNumSet - Set PEX interface local device number. */
 	MV_STATUS mvPexLocalDevNumSet(MV_U32 pexIf, MV_U32 devNum);
 
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h b/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
index 040c9dd..70ab4c5 100755
--- a/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
@@ -72,7 +72,7 @@ extern "C" {
 #include "mvSysPexConfig.h"
 
 /* defines */
-#define MAX_PEX_DEVICES         32
+#define MAX_PEX_DEVICES         1
 #define MAX_PEX_FUNCS           8
 #define MAX_PEX_BUSSES          256
 
@@ -172,18 +172,19 @@ extern "C" {
 /********************************************/
 /* PCI Express Control and Status Registers */
 /********************************************/
-#define PEX_CTRL_REG(pexIf)				((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A00)
-#define PEX_LINK_CAPABILITIES_REG(pexIf)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x6C)
+#define PEX_CTRL_REG(pexIf)					((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A00)
+#define PEX_LINK_CAPABILITIES_REG(pexIf)	((MV_PEX_IF_REGS_BASE(pexIf)) + 0x6C)
 #define PEX_CAPABILITIES_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x60)
 #define PEX_STATUS_REG(pexIf)				((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A04)
-#define PEX_COMPLT_TMEOUT_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A10)
+#define PEX_SECONDARY_BUS_REG(pexIf)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A2C)
+#define PEX_COMPLT_TMEOUT_REG(pexIf)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A10)
 #define PEX_PWR_MNG_EXT_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A18)
 #define PEX_FLOW_CTRL_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A20)
-#define PEX_DYNMC_WIDTH_MNG_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A30)
-#define PEX_ROOT_CMPLX_SSPL_REG(pexif)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A0C)
+#define PEX_DYNMC_WIDTH_MNG_REG(pexIf)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A30)
+#define PEX_ROOT_CMPLX_SSPL_REG(pexif)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A0C)
 #define PEX_ACK_TMR_1X_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A40)
-#define PEX_TL_CTRL_REG(pexIf)				(MV_PEX_IF_REGS_BASE(pexIf) - (pexIf)*0x10000)
-#define PEX_RAM_PARITY_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A50)
+#define PEX_TL_CTRL_REG(pexIf)				((MV_PEX_IF_REGS_BASE(pexIf)) - ((pexIf)*0x10000))
+#define PEX_RAM_PARITY_CTRL_REG(pexIf)		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A50)
 #define PEX_DBG_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A60)
 #define PEX_DBG_STATUS_REG(pexIf)           ((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A64)
 
@@ -223,6 +224,13 @@ extern "C" {
 #define PXCR_CONF_MSTR_DIS_SCRMB		BIT27	/* Master Disable Scrambling */
 #define PXCR_CONF_DIRECT_DIS_SCRMB		BIT28	/* Direct Disable Scrambling */
 
+/* PCI Ecpress Secondary Bus register */
+/* PEX_SECONDARY_BUS_REG */
+#define SECONDARY_BUS_NUMBER_ENABLE				BIT8
+#define SECONDARY_BUS_NUMBER_OFFS				0
+#define SECONDARY_BUS_NUMBER_MASK				0xFF
+
+
 /* PCI Express Status Register */
 /* PEX_STATUS_REG (PXSR) */
 
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvVrtBrgPex.c b/arch/arm/plat-armada/mv_hal/pex/mvVrtBrgPex.c
index 08b8eaf..e5e2232 100644
--- a/arch/arm/plat-armada/mv_hal/pex/mvVrtBrgPex.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvVrtBrgPex.c
@@ -63,6 +63,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 
 #include "mvPex.h"
+#include "mvVrtBrgPex.h"
 
 /* #define MV_DEBUG */
 /* defines  */
@@ -167,7 +168,8 @@ MV_U32 mvPexVrtBrgConfigRead(MV_U32 pexIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 		}
 	} else if (bus == (localBus + 1)) {
 		/* access the device behind the virtual bridge */
-		if ((dev == localDev) || (dev > 1)) {
+/*		if ((dev == localDev) || (dev > 1)) { */
+		if (dev > 1) {
 			return 0xffffffff;
 		} else {
 			/* access the device behind the virtual bridge, in this case
-- 
1.7.5.4

