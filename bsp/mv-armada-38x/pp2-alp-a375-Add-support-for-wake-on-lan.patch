From a6a6bf6cf3bc695b76cd63294007fc64b500d665 Mon Sep 17 00:00:00 2001
From: Evan <xswang@marvell.com>
Date: Wed, 11 Jun 2014 15:23:28 +0800
Subject: [PATCH 1724/1825] pp2: alp,a375: Add support for wake-on-lan

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 139a04135438ab98b46d7f384ddf719f0bde6c0a

	1. Implement suspend/resume for pp2
	2. update wol API and sysfs command for pp2
	3. implement wol set/get API for ethtool

Signed-off-by: Evan <xswang@marvell.com>

Change-Id: Iffc27764f66568ab41d6d48784ae76a94eb84788
Reviewed-on: http://vgitil04.il.marvell.com:8080/8477
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hua Jing <jinghua@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   14 ++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |  105 +++++++++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  162 ++++++++++++++++++--
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    6 +
 .../mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c          |   35 ++---
 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c     |   50 +++++--
 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h     |    9 +-
 7 files changed, 337 insertions(+), 44 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index cbd6d45..3f4af3d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -70,6 +70,10 @@ static ssize_t mv_eth_help(char *buf)
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	off += sprintf(buf+off, "echo [p] [hex]   > debug       - b0:rx, b1:tx, b2:isr, b3:poll, b4:dump, b5:b_hdr\n");
 #endif
+#ifdef CONFIG_CPU_IDLE
+	off += sprintf(buf+off, "echo [p] [hex]   > pm_mode     - set port <p> pm mode. 0 wol, 1 suspend.\n");
+#endif
+
 	return off;
 }
 
@@ -176,6 +180,10 @@ static ssize_t mv_eth_2_hex_store(struct device *dev,
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_DUMP, v & 0x10);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_BUFF_HDR, v & 0x20);
 #endif
+	} else if (!strcmp(name, "pm_mode")) {
+#ifdef CONFIG_CPU_IDLE
+		err = mv_eth_pm_mode_set(p, v);
+#endif
 	}
 
 	return err ? -EINVAL : len;
@@ -266,6 +274,9 @@ static DEVICE_ATTR(netdev,	S_IWUSR, NULL, mv_eth_netdev_store);
 
 static DEVICE_ATTR(regRead,       S_IWUSR, NULL, mv_eth_reg_store);
 static DEVICE_ATTR(regWrite,      S_IWUSR, NULL, mv_eth_reg_store);
+#ifdef CONFIG_CPU_IDLE
+static DEVICE_ATTR(pm_mode,	S_IWUSR, NULL, mv_eth_2_hex_store);
+#endif
 
 static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_addrDec.attr,
@@ -285,6 +296,9 @@ static struct attribute *mv_eth_attrs[] = {
 	&dev_attr_skb.attr,
 	&dev_attr_regRead.attr,
 	&dev_attr_regWrite.attr,
+#ifdef CONFIG_CPU_IDLE
+	&dev_attr_pm_mode.attr,
+#endif
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index 1e50d36..4c71e4b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -54,6 +54,9 @@ disclaimer.
 
 #include "prs/mvPp2Prs.h"
 
+#include "wol/mvPp2Wol.h"
+
+
 #define MV_ETH_TOOL_AN_TIMEOUT	5000
 
 struct mv_eth_tool_stats {
@@ -380,6 +383,106 @@ int mv_eth_tool_get_regs_len(struct net_device *netdev)
 	return (MV_ETH_TOOL_REGS_LEN * sizeof(uint32_t));
 }
 
+/******************************************************************************
+* mv_eth_tool_get_wol
+* Description:
+*	ethtool get WOL information
+* INPUT:
+*	netdev		Network device structure pointer
+* OUTPUT
+*	wolinfo		WOL info
+* RETURN:
+*	0 on success
+*
+*******************************************************************************/
+void mv_eth_tool_get_wol(struct net_device *netdev,
+			 struct ethtool_wolinfo *wolinfo)
+{
+	struct eth_port	*priv = MV_ETH_PRIV(netdev);
+
+	if (priv == NULL) {
+		pr_err("%s is not supported on %s\n", __func__, netdev->name);
+		return;
+	}
+
+	wolinfo->supported = WAKE_ARP | WAKE_UCAST | WAKE_MAGIC;
+	wolinfo->wolopts = 0;
+
+	if (priv->wol & (MV_PP2_WOL_ARP_IP_MASK(0) | MV_PP2_WOL_ARP_IP_MASK(1)))
+		wolinfo->wolopts |= WAKE_ARP;
+
+	if (priv->wol & MV_PP2_WOL_UCAST_MASK)
+		wolinfo->wolopts |= WAKE_UCAST;
+	if (priv->wol & MV_PP2_WOL_MAGIC_PTRN_MASK)
+		wolinfo->wolopts |= WAKE_MAGIC;
+}
+
+/******************************************************************************
+* mv_eth_tool_set_wol
+* Description:
+*	ethtool set WOL
+* INPUT:
+*	netdev		Network device structure pointer
+*	wolinfo		WOL settings
+* OUTPUT
+*	None
+* RETURN:
+*	None
+*
+*******************************************************************************/
+int mv_eth_tool_set_wol(struct net_device *netdev,
+			 struct ethtool_wolinfo *wolinfo)
+{
+	int ret;
+	struct eth_port	*priv = MV_ETH_PRIV(netdev);
+
+	if (priv == NULL) {
+		pr_err("%s is not supported on %s\n", __func__, netdev->name);
+		return -EOPNOTSUPP;
+	}
+
+	if (wolinfo->wolopts & (WAKE_PHY | WAKE_MCAST | WAKE_BCAST | WAKE_MAGICSECURE))
+		return -EOPNOTSUPP;
+
+	/* these settings will always override what we currently have */
+	priv->wol = 0;
+	/* Clearn all settings before if have */
+	ret = mvPp2WolWakeup();
+	if (ret)
+		return ret;
+
+	if (wolinfo->wolopts & WAKE_UCAST) {
+		priv->wol |= MV_PP2_WOL_UCAST_MASK;
+		/* Enable WoL Ucast event */
+		ret = mvPp2WolUcastEventSet(WOL_EVENT_EN);
+		if (ret)
+			return ret;
+	}
+
+	if (wolinfo->wolopts & WAKE_ARP) {
+		/* Even port num use ARP0; Odd port num use ARP1 */
+		priv->wol |= MV_PP2_WOL_ARP_IP_MASK((priv->port) % MV_PP2_WOL_ARP_IP_NUM);
+		/* Set WoL ARP Address; TODO */
+		/* Enable WoL ARP event */
+		ret = mvPp2WolArpEventSet((priv->port) % MV_PP2_WOL_ARP_IP_NUM, WOL_EVENT_EN);
+		if (ret)
+			return ret;
+	}
+
+	if (wolinfo->wolopts & WAKE_MAGIC) {
+		priv->wol |= MV_PP2_WOL_MAGIC_PTRN_MASK;
+		/* Set Magic MAC, the MAC of the last port configured by ethtool will be the Magic MAC */
+		ret = mvPp2WolMagicDaSet(netdev->dev_addr);
+		if (ret)
+			return ret;
+		/* Enable WoL Magic event */
+		ret = mvPp2WolMagicEventSet(WOL_EVENT_EN);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
 
 /******************************************************************************
 * mv_eth_tool_get_drvinfo
@@ -1048,6 +1151,8 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_drvinfo				= mv_eth_tool_get_drvinfo,
 	.get_regs_len				= mv_eth_tool_get_regs_len,
 	.get_regs				= mv_eth_tool_get_regs,
+	.get_wol				= mv_eth_tool_get_wol,
+	.set_wol				= mv_eth_tool_set_wol,
 	.nway_reset				= mv_eth_tool_nway_reset,
 	.get_link				= mv_eth_tool_get_link,
 	.get_coalesce				= mv_eth_tool_get_coalesce,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 26e9ebc..6e192fc 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -50,6 +50,8 @@ disclaimer.
 #include "prs/mvPp2PrsHw.h"
 #include "cls/mvPp2Classifier.h"
 #include "dpi/mvPp2DpiHw.h"
+#include "wol/mvPp2Wol.h"
+
 
 #include "mv_mux_netdev.h"
 #include "mv_netdev.h"
@@ -3037,6 +3039,19 @@ irqreturn_t mv_eth_link_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_CPU_IDLE
+/* wol_isr_register, guarantee the wol irq register once */
+static int wol_isr_register;
+
+irqreturn_t mv_wol_isr(int irq, void *dev_id)
+{
+	mvPp2WolWakeup();
+	machine_restart(NULL);
+
+	return IRQ_HANDLED;
+}
+#endif
+
 void mv_eth_link_tasklet(unsigned long data)
 {
 	int port;
@@ -3543,8 +3558,31 @@ int mv_eth_resume_network_interfaces(struct eth_port *pp)
 
 int mv_eth_port_resume(int port)
 {
-/* TBD */
-	return 0;
+	struct eth_port *pp;
+
+	pp = mv_eth_port_by_id(port);
+
+	if (pp == NULL) {
+		pr_err("%s: pp == NULL, port=%d\n", __func__, port);
+		return  MV_ERROR;
+	}
+
+	if (!(pp->flags & MV_ETH_F_SUSPEND)) {
+		pr_err("%s: port %d is not suspend.\n", __func__, port);
+		return MV_ERROR;
+	}
+	if (pp->pm_mode == MV_ETH_PM_WOL) {
+		mv_eth_start_internals(pp, pp->dev->mtu);
+		mvGmacPortIsrUnmask(port);
+		mvGmacPortSumIsrUnmask(port);
+	}
+
+	clear_bit(MV_ETH_F_SUSPEND_BIT, &(pp->flags));
+	set_bit(MV_ETH_F_STARTED_BIT, &(pp->flags));
+
+	pr_info("Exit suspend mode on port #%d\n", port);
+
+	return MV_OK;
 }
 
 void    mv_eth_hal_shared_init(struct mv_pp2_pdata *plat_data)
@@ -3652,18 +3690,55 @@ void mv_eth_win_init(void)
  ***********************************************************/
 int mv_eth_port_suspend(int port)
 {
-/* TBD */
-	return 0;
+	struct eth_port *pp;
+
+	pp = mv_eth_port_by_id(port);
+	if (!pp)
+		return MV_OK;
+
+	if (pp->flags & MV_ETH_F_SUSPEND) {
+		pr_err("%s: port %d is allready suspend.\n", __func__, port);
+		return MV_ERROR;
+	}
+
+	if (pp->flags & MV_ETH_F_STARTED) {
+		if (pp->pm_mode == MV_ETH_PM_WOL) {
+			/* Clean up and disable all interrupts */
+			mv_eth_stop_internals(pp);
+			mvGmacPortIsrMask(port);
+			mvGmacPortSumIsrMask(port);
+		}
+		clear_bit(MV_ETH_F_STARTED_BIT, &(pp->flags));
+	} else
+		clear_bit(MV_ETH_F_STARTED_OLD_BIT, &(pp->flags));
+
+	set_bit(MV_ETH_F_SUSPEND_BIT, &(pp->flags));
+
+	pr_info("Enter suspend mode on port #%d\n", port);
+	return MV_OK;
 }
 
 /***********************************************************
  * mv_eth_pm_mode_set --                                   *
  *   set pm_mode. (power menegment mod)			   *
  ***********************************************************/
-int	mv_eth_pm_mode_set(int port, int mode)
+int mv_eth_pm_mode_set(int port, int mode)
 {
-/* TBD */
-	return 0;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	if (pp == NULL) {
+		pr_err("%s: pp == NULL, port=%d\n", __func__, port);
+		return -EINVAL;
+	}
+
+	if (pp->flags & MV_ETH_F_SUSPEND) {
+		pr_err("Port %d must resumed before\n", port);
+		return -EINVAL;
+	}
+
+	pp->pm_mode = mode;
+
+	return MV_OK;
 }
 
 static void mv_eth_sysfs_exit(void)
@@ -3893,6 +3968,15 @@ static int mv_eth_probe(struct platform_device *pdev)
 	if (mv_eth_load_network_interfaces(pdev))
 		return -ENODEV;
 
+#ifdef CONFIG_CPU_IDLE
+	/* Register WoL interrupt */
+	if (!wol_isr_register) {
+		if (request_irq(IRQ_GLOBAL_NET_WAKE_UP, mv_wol_isr, (IRQF_DISABLED), "wol", NULL))
+			pr_err("cannot request irq %d for Wake-on-Lan\n", IRQ_GLOBAL_NET_WAKE_UP);
+		else
+			wol_isr_register++;
+	}
+#endif
 	/* used in mv_eth_all_ports_probe */
 	plats[port] = pdev;
 
@@ -4530,7 +4614,6 @@ int mv_eth_resume_internals(struct eth_port *pp, int mtu)
 {
 /* TBD */
 	return 0;
-
 }
 
 
@@ -5803,13 +5886,44 @@ int mv_eth_suspend_clock(int port)
 	return 0;
 }
 
+/* mv_eth_suspend_common - common port suspend, can be called anyplace */
+int mv_eth_suspend_common(int port)
+{
+	struct eth_port *pp;
+
+	pp = mv_eth_port_by_id(port);
+	if (!pp)
+		return MV_OK;
+
+	if (mv_eth_port_suspend(port)) {
+		pr_err("%s: port #%d suspend failed.\n", __func__, port);
+		return MV_ERROR;
+	}
+
+	/* PM mode: WoL Mode*/
+	if (pp->pm_mode == 0) {
+		/* Insert port to WoL mode */
+		if (mvPp2WolSleep(port)) {
+			pr_err("%s: port #%d suspend failed.\n", __func__, port);
+			return MV_ERROR;
+		}
+	}
+	/* PM mode: Suspend to RAM Mode, TODO list*/
+
+	return MV_OK;
+}
 
 int mv_eth_suspend(struct platform_device *pdev, pm_message_t state)
 {
-/* TBD */
-	return 0;
-}
+	int port = pdev->id;
 
+	if (mv_eth_suspend_common(port)) {
+		pr_err("%s: port #%d suspend failed.\n", __func__, port);
+		return MV_ERROR;
+	}
+
+	return MV_OK;
+}
 
 int mv_eth_resume_clock(int port)
 {
@@ -5820,9 +5934,22 @@ int mv_eth_resume_clock(int port)
 
 int mv_eth_resume(struct platform_device *pdev)
 {
-/* TBD */
-	return 0;
+	struct eth_port *pp;
+	int port = pdev->id;
 
+	pp = mv_eth_port_by_id(port);
+	if (!pp)
+		return MV_OK;
+
+	/* PM mode: WoL Mode*/
+	if (pp->pm_mode == 0) {
+		if (mv_eth_port_resume(port)) {
+			pr_err("%s: port #%d resume failed.\n", __func__, port);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
 }
 
 #endif	/* CONFIG_CPU_IDLE */
@@ -5844,6 +5971,15 @@ static int mv_eth_remove(struct platform_device *pdev)
 
 static void mv_eth_shutdown(struct platform_device *pdev)
 {
+
+#ifdef CONFIG_CPU_IDLE
+	int port = pdev->id;
+		struct eth_port *pp = mv_eth_port_by_id(port);
+
+	if (pp->flags & MV_ETH_F_STARTED)
+		mv_eth_suspend_common(port);
+#endif
+
 	printk(KERN_INFO "Shutting Down Marvell Ethernet Driver\n");
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index ec7f65c..8e5ebed 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -221,6 +221,8 @@ struct port_stats {
 #define MV_ETH_F_RX_PKT_PREFETCH_BIT    2
 #define MV_ETH_F_CONNECT_LINUX_BIT      5 /* port is connected to Linux netdevice */
 #define MV_ETH_F_LINK_UP_BIT            6
+#define MV_ETH_F_SUSPEND_BIT            12
+#define MV_ETH_F_STARTED_OLD_BIT        13 /*STARTED_BIT value before suspend */
 #define MV_ETH_F_IFCAP_NETMAP_BIT       15
 
 #define MV_ETH_F_STARTED                (1 << MV_ETH_F_STARTED_BIT)
@@ -228,6 +230,8 @@ struct port_stats {
 #define MV_ETH_F_RX_PKT_PREFETCH        (1 << MV_ETH_F_RX_PKT_PREFETCH_BIT)
 #define MV_ETH_F_CONNECT_LINUX          (1 << MV_ETH_F_CONNECT_LINUX_BIT)
 #define MV_ETH_F_LINK_UP                (1 << MV_ETH_F_LINK_UP_BIT)
+#define MV_ETH_F_SUSPEND                (1 << MV_ETH_F_SUSPEND_BIT)
+#define MV_ETH_F_STARTED_OLD            (1 << MV_ETH_F_STARTED_OLD_BIT)
 #define MV_ETH_F_IFCAP_NETMAP           (1 << MV_ETH_F_IFCAP_NETMAP_BIT)
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
@@ -384,6 +388,7 @@ struct eth_port {
 	__u32			rate_current; /* unknown (0), low (1), normal (2), high (3) */
 	__u32			rate_sample_cfg;
 	__u32			rx_adaptive_coal_cfg;
+	__u32			wol;
 	/* Rate calculate */
 	unsigned long		rx_rate_pkts;
 	unsigned long		rx_timestamp;
@@ -404,6 +409,7 @@ struct eth_port {
 
 enum eth_pm_mode {
 	MV_ETH_PM_WOL = 0,
+	MV_ETH_PM_SUSPEND,
 	MV_ETH_PM_CLOCK,
 	MV_ETH_PM_DISABLE,
 	MV_ETH_PM_LAST
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
index 0215007..abaf7be 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
@@ -53,8 +53,10 @@ static ssize_t wol_help(char *buf)
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo 1       > wakeup    - Force wakeup\n");
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo mac     > magic_mac - Set MAC [a:b:c:d:e:f] for magic pattern\n");
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i ip    > arp_ip    - Set IP [a.b.c.d] for ARP IP[i] event\n");
-	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i s str > ptrn      - Set pattern [i] with [str] of [s] bytes\n");
-	of += scnprintf(buf + of, PAGE_SIZE - of, "                           [str] in format: b0:b1::b3:::b6\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i o d m > ptrn      - Set pattern [i] with data [d] and mask [m] from  header offset [o]\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "                           [o] header offset: 0-127\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "                           [d] str, in format: b0:b1::b3:::b6\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "                           [m] str, in format: ff:ff::ff:::ff\n");
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > magic_en  - On/Off wakeup by magic packet\n");
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > ucast_en  - On/Off wakeup by Unicast packet\n");
 	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > mcast_en  - On/Off wakeup by Multicast packet\n");
@@ -186,10 +188,10 @@ static ssize_t wol_ip_store(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
-static int wol_ptrn_get(char *ptrnStr, MV_U8 *data, MV_U8 *mask, int max_size)
+static int wol_ptrn_get(char *ptrnStr, char *maskStr, MV_U8 *data, MV_U8 *mask, int max_size)
 {
 	int i, j, size;
-	char tmp[3];
+	char tmp[3], mask_tmp[3];
 
 	size = strlen(ptrnStr);
 	i = 0;
@@ -219,8 +221,11 @@ static int wol_ptrn_get(char *ptrnStr, MV_U8 *data, MV_U8 *mask, int max_size)
 		tmp[0] = ptrnStr[i];
 		tmp[1] = ptrnStr[i + 1];
 		tmp[2] = '\0';
+		mask_tmp[0] = maskStr[i];
+		mask_tmp[1] = maskStr[i + 1];
+		mask_tmp[2] = '\0';
 		data[j] = (MV_U8) (strtol(tmp, NULL, 16));
-		mask[j] = 0xff;
+		mask[j] = (MV_U8) (strtol(mask_tmp, NULL, 16));
 		i += 3;
 		j++;
 	}
@@ -232,8 +237,9 @@ static ssize_t wol_ptrn_store(struct device *dev,
 {
 	const char    *name = attr->attr.name;
 	unsigned int  err = 0;
-	int           size, i = 0;
+	int           size, i = 0, off = 0;
 	char          ptrnStr[MV_PP2_WOL_PTRN_BYTES*3];
+	char          maskStr[MV_PP2_WOL_PTRN_BYTES*3];
 	char          data[MV_PP2_WOL_PTRN_BYTES];
 	char          mask[MV_PP2_WOL_PTRN_BYTES];
 	unsigned long flags;
@@ -241,14 +247,14 @@ static ssize_t wol_ptrn_store(struct device *dev,
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	sscanf(buf, "%d %s", &i, ptrnStr);
+	sscanf(buf, "%d %d %s %s", &i, &off, ptrnStr, maskStr);
 
 	local_irq_save(flags);
 
 	if (!strcmp(name, "ptrn")) {
-		size = wol_ptrn_get(ptrnStr, data, mask, MV_PP2_WOL_PTRN_BYTES);
+		size = wol_ptrn_get(ptrnStr, maskStr, data, mask, MV_PP2_WOL_PTRN_BYTES);
 		if (size != -1)
-			err = mvPp2WolPtrnSet(i, size, data, mask);
+			err = mvPp2WolPtrnSet(i, off, size, data, mask);
 		else
 			err = 1;
 	} else
@@ -262,17 +268,6 @@ static ssize_t wol_ptrn_store(struct device *dev,
 	return err ? -EINVAL : len;
 }
 
-irqreturn_t mv_wol_isr(int irq, void *dev_id)
-{
-	MV_U32 regVal;
-
-	regVal = mvPp2RdReg(MV_PP2_WOL_INTR_CAUSE_REG);
-	pr_info("WoL interrupt: irq=%d, cause=0x%x\n", irq, regVal);
-	mvPp2WolWakeup();
-
-	return IRQ_HANDLED;
-}
-
 static DEVICE_ATTR(help,      S_IRUSR, wol_show, NULL);
 static DEVICE_ATTR(regs,      S_IRUSR, wol_show, NULL);
 static DEVICE_ATTR(status,    S_IRUSR, wol_show, NULL);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
index b3302bd..0be2185 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
@@ -169,15 +169,18 @@ MV_STATUS mvPp2WolArpIpSet(int idx, MV_U32 ip)
 	return MV_OK;
 }
 
-MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask)
+MV_STATUS mvPp2WolPtrnSet(int idx, int off, int size, MV_U8 *data, MV_U8 *mask)
 {
 	MV_U32 regVal, regData, regMask;
-	int i, j, reg;
+	int i, j, reg, new_size;
+	MV_U8 *new_data;
+	MV_U8 *new_mask;
+	int aligned_size = 0;
 
 	if (mvPp2MaxCheck(idx, MV_PP2_WOL_PTRN_NUM, "PTRN index"))
 		return MV_BAD_PARAM;
 
-	if (mvPp2MaxCheck(size, MV_PP2_WOL_PTRN_BYTES, "PTRN size"))
+	if (mvPp2MaxCheck((off + size), MV_PP2_WOL_PTRN_BYTES, "PTRN size"))
 		return MV_BAD_PARAM;
 /*
 	mvOsPrintf("WoL set pattern #%d: size=%d\n", idx, size);
@@ -191,19 +194,44 @@ MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask)
 	mvPp2WrReg(MV_PP2_WOL_PTRN_SIZE_REG, regVal);
 
 	mvPp2WrReg(MV_PP2_WOL_PTRN_IDX_REG, idx);
-	for (i = 0; i < size; i += 4) {
-		reg = i / 4;
+	if (off % 4) {
+		aligned_size = size + 4 - (off % 4);
+		new_data = kmalloc(sizeof(MV_U8) * aligned_size, GFP_KERNEL);
+		if (!new_data) {
+			mvOsPrintf("CPU memory allocation fail\n");
+			return MV_OUT_OF_CPU_MEM;
+		}
+
+		new_mask = kmalloc(sizeof(MV_U8) * aligned_size, GFP_KERNEL);
+		if (!new_mask) {
+			kfree(new_data);
+			mvOsPrintf("CPU memory allocation fail\n");
+			return MV_OUT_OF_CPU_MEM;
+		}
+
+		memset(new_data, 0, sizeof(MV_U8) * aligned_size);
+		memset(new_mask, 0, sizeof(MV_U8) * aligned_size);
+
+		memcpy(&new_data[off % 4], data, size);
+		memcpy(&new_mask[off % 4], mask, size);
+	} else {
+		new_data = data;
+		new_mask = mask;
+	}
+	new_size = size + (off % 4);
+	for (i = 0; i < new_size; i += 4) {
+		reg = (off + i) / 4;
 		regData = mvPp2RdReg(MV_PP2_WOL_PTRN_DATA_REG(reg));
 		regMask = mvPp2RdReg(MV_PP2_WOL_PTRN_MASK_REG(reg));
 		for (j = 0; j < 4; j++) {
 
-			if ((i + j) >= size)
+			if ((i + j) >= new_size)
 				break;
 
 			regData &= ~MV_PP2_WOL_PTRN_DATA_BYTE_MASK(3 - j);
-			regData |= MV_PP2_WOL_PTRN_DATA_BYTE(3 - j, data[i + j]);
+			regData |= MV_PP2_WOL_PTRN_DATA_BYTE(3 - j, new_data[i + j]);
 			/* mask on byte level */
-			if (mask[i + j] == 0)
+			if (new_mask[i + j] == 0)
 				regMask &= ~MV_PP2_WOL_PTRN_MASK_BIT(3 - j);
 			else
 				regMask |= MV_PP2_WOL_PTRN_MASK_BIT(3 - j);
@@ -211,6 +239,10 @@ MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask)
 		mvPp2WrReg(MV_PP2_WOL_PTRN_DATA_REG(reg), regData);
 		mvPp2WrReg(MV_PP2_WOL_PTRN_MASK_REG(reg), regMask);
 	}
+	if (off % 4) {
+		kfree(new_data);
+		kfree(new_mask);
+	}
 	return MV_OK;
 }
 
@@ -256,8 +288,6 @@ MV_STATUS mvPp2WolUcastEventSet(int enable)
 
 	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
 
-	mvOsPrintf("%s: enable=%d, regOffset=0x%x, regVal=0x%x\n",
-			__func__, enable, MV_PP2_WOL_WAKEUP_EN_REG, regVal);
 	return MV_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h
index 6f439aa..b15fb27 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h
@@ -142,6 +142,13 @@ extern "C" {
 #define MV_PP2_WOL_PTRN_MASK_BIT(i)         (1    << ((i) * 8))
 /*---------------------------------------------------------------------------------------------*/
 
+/*********************************** ENUMERATIONS *******************/
+
+enum wol_event_enable_t {
+	WOL_EVENT_DIS = 0,
+	WOL_EVENT_EN,
+};
+
 /* WoL APIs */
 void      mvPp2WolRegs(void);
 void      mvPp2WolStatus(void);
@@ -150,7 +157,7 @@ MV_STATUS mvPp2WolWakeup(void);
 int       mvPp2WolIsSleep(int *port);
 MV_STATUS mvPp2WolMagicDaSet(MV_U8 *mac_da);
 MV_STATUS mvPp2WolArpIpSet(int idx, MV_U32 ip);
-MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask);
+MV_STATUS mvPp2WolPtrnSet(int idx, int off, int size, MV_U8 *data, MV_U8 *mask);
 MV_STATUS mvPp2WolArpEventSet(int idx, int enable);
 MV_STATUS mvPp2WolMcastEventSet(int enable);
 MV_STATUS mvPp2WolUcastEventSet(int enable);
-- 
1.7.5.4

