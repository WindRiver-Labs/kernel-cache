From a244ba59ce7eb98150c5d2f9d98e357b1078f1b3 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Tue, 29 Apr 2014 18:48:36 +0300
Subject: [PATCH 1602/1825] pp3: BM add alloc and release support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit a8d8e3bc7cf7062d8fc3a75ceaee463a34a42618

	- BM integration with low level driver
	- add high level BM sysfs function

Change-Id: Icba563c49ceedc9691fc77439b947330caa8b6ae
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7769
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Makefile          |    2 +-
 .../ethernet/marvell/pp3/common/mv_pp3_config.c    |    4 +-
 .../ethernet/marvell/pp3/net_dev/mv_dev_bm_sysfs.c |  141 ++++++++++++++
 .../net/ethernet/marvell/pp3/net_dev/mv_dev_dbg.c  |  167 +++++++++++++++++
 .../ethernet/marvell/pp3/net_dev/mv_dev_sysfs.c    |   37 +++--
 .../ethernet/marvell/pp3/net_dev/mv_dev_sysfs.h    |   34 ++++
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |  197 ++++++++++++++------
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.h   |   14 ++-
 8 files changed, 517 insertions(+), 79 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_bm_sysfs.c
 create mode 100644 drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_dbg.c
 create mode 100644 drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.h

diff --git a/drivers/net/ethernet/marvell/pp3/Makefile b/drivers/net/ethernet/marvell/pp3/Makefile
index 516a228..87c08fb 100644
--- a/drivers/net/ethernet/marvell/pp3/Makefile
+++ b/drivers/net/ethernet/marvell/pp3/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_MV_PP3) += mv_pp3.o
 ccflags-y       += -Idrivers/net/ethernet/marvell/pp3
 
 mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o emac/mv_emac.o
-mv_pp3-objs += emac/mv_emac_sysfs.o hmac/mv_hmac_sysfs.o net_dev/mv_dev_sysfs.o
+mv_pp3-objs += emac/mv_emac_sysfs.o hmac/mv_hmac_sysfs.o net_dev/mv_dev_sysfs.o net_dev/mv_dev_bm_sysfs.o net_dev/mv_dev_dbg.o
 mv_pp3-objs += gmac/mv_gmac.o fw/mv_channel_if.o fw/mv_channel_sysfs.o common/mv_stack.o common/mv_pp3_config.o
 mv_pp3-objs += fw/mv_fw.o fw/mv_fw_sysfs.o
 mv_pp3-objs += bm/mv_bm.o bm/mv_bm_sysfs.o bm/mv_bm_regs.o
diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_pp3_config.c b/drivers/net/ethernet/marvell/pp3/common/mv_pp3_config.c
index e896a30..a6e1419 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_pp3_config.c
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_pp3_config.c
@@ -248,12 +248,12 @@ int mv_pp3_cfg_dp_bmq_params_get(int cpu, int *frame, int *queue, int *group)
 	switch (cpu) {
 	case 0:
 		*frame = 2;
-		*queue = 8;
+		*queue = 9;
 		*group = 4;
 	break;
 	case 1:
 		*frame = 2;
-		*queue = 9;
+		*queue = 10;
 		*group = 5;
 	break;
 	default:
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_bm_sysfs.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_bm_sysfs.c
new file mode 100644
index 0000000..243cf86
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_bm_sysfs.c
@@ -0,0 +1,141 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_netdev.h"
+#include "common/mv_hw_if.h"
+
+static ssize_t pp3_dev_bm_help(char *b)
+{
+	int o = 0;
+	o += sprintf(b+o, "echo [pool]             > poolStatus   - Print BM pool status\n");
+	o += sprintf(b+o, "echo [pool]  [0|1]      > dramDump     - Print pool dram\n");
+	o += sprintf(b+o, "echo [pool]  [num]      > bufPop       - Release buffers from BM pool\n");
+	o += sprintf(b+o, "echo [pool]  [num]      > bufPush      - Alloc buffers to BM pool\n");
+	o += sprintf(b+o, "\nAll inputs in decimal\n\n");
+	return o;
+}
+
+static ssize_t pp3_dev_bm_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	/*const char	*name = attr->attr.name;*/
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = pp3_dev_bm_help(buf);
+
+	return off;
+}
+
+
+
+static ssize_t pp3_dev_bm_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    a, b, c;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = a = b = c = 0;
+	sscanf(buf, "%d %d %d", &a, &b, &c);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "poolStatus")) {
+		pp3_pool_status_print(a);
+	} else if (!strcmp(name, "dramDump")) {
+		pp3_pool_dbg_dump(a, b);
+	} else if (!strcmp(name, "bufPop")) {
+		pp3_pool_dbg_pop(a, b);
+	} else if (!strcmp(name, "bufPush")) {
+		pp3_pool_dbg_push(a, b);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(dramDump,		S_IWUSR, NULL, pp3_dev_bm_store);
+static DEVICE_ATTR(poolStatus,		S_IWUSR, NULL, pp3_dev_bm_store);
+static DEVICE_ATTR(bufPop,		S_IWUSR, NULL, pp3_dev_bm_store);
+static DEVICE_ATTR(bufPush,		S_IWUSR, NULL, pp3_dev_bm_store);
+static DEVICE_ATTR(help,		S_IRUSR, pp3_dev_bm_show, NULL);
+
+static struct attribute *pp3_dev_bm_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_poolStatus.attr,
+	&dev_attr_bufPush.attr,
+	&dev_attr_bufPop.attr,
+	&dev_attr_dramDump.attr,
+	NULL
+};
+
+static struct attribute_group pp3_dev_bm_group = {
+	.name = "bm",
+	.attrs = pp3_dev_bm_attrs,
+};
+
+int pp3_dev_bm_sysfs_init(struct kobject *dev_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(dev_kobj, &pp3_dev_bm_group);
+	if (err) {
+		pr_err("sysfs group %s failed %d\n", pp3_dev_bm_group.name, err);
+		return err;
+	}
+
+	return err;
+}
+
+int pp3_dev_bm_sysfs_exit(struct kobject *dev_kobj)
+{
+	sysfs_remove_group(dev_kobj, &pp3_dev_bm_group);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_dbg.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_dbg.c
new file mode 100644
index 0000000..1c322be
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_dbg.c
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mv_netdev.h"
+#include "bm/mv_bm.h"
+#include "hmac/mv_hmac.h"
+#include "hmac/mv_hmac_bm.h"
+#include "mv_netdev_structs.h"
+
+/*---------------------------------------------------------------------------*/
+
+int pp3_pool_dbg_dump(int pool, int v)
+{
+	int i;
+	struct pp3_pool *ppool;
+	u32 rd_ptr, wr_ptr, fill_level, *arr;
+
+	if ((pool < 0) || (pool >= MV_PP3_BM_POOLS)) {
+		pr_err("%s: pool=%d is out of range\n", __func__, pool);
+		return -EINVAL;
+	}
+
+	if ((pp3_pools == NULL) || (pp3_pools[pool] == NULL)) {
+		pr_err("%s: pool=%d is not initialized\n", __func__, pool);
+		return -EINVAL;
+	}
+
+	ppool = pp3_pools[pool];
+
+	arr = (u32 *)ppool->virt_base;
+
+	if (v) {
+		for (i = 0; i < ppool->capacity; i = i + 2)
+			pr_info("%d	virt = 0x%08x	phys = 0x%08x\n", i/2, arr[i+1], arr[i]);
+	}
+/*
+	bm_pool_pointer_get(pool, &rd_ptr, &wr_ptr);
+	pr_info("pool %d dram read pointer %d write pointer %d\n", pool, rd_ptr, wr_ptr);
+*/
+	bm_pool_fill_level_get(pool, &fill_level);
+	pr_info("\npool %d dram fill level %d PE's\n", pool, fill_level);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+/* function for sysfs command, free buffers from pool */
+int pp3_pool_dbg_pop(int pool, int buf_num)
+{
+	int occ = 0, counter = 0, err = 0, occ_old = 0;
+
+	unsigned int  ph_addr, vr_addr, pool_id;
+
+	if (!pp3_cpus || !pp3_cpus[0]) {
+		pr_err("hw is not init\n");
+		return -1;
+	}
+
+	if ((pool < 0) || (pool >= MV_PP3_BM_POOLS)) {
+		pr_err("%s: pool=%d is out of range\n", __func__, pool);
+		return -EINVAL;
+	}
+
+	if ((pp3_pools == NULL) || (pp3_pools[pool] == NULL)) {
+		pr_err("%s: pool=%d is not initialized\n", __func__, pool);
+		return -EINVAL;
+	}
+
+	mv_pp3_hmac_bm_buff_request(pp3_cpus[0]->bm_msg_frame, pp3_cpus[0]->bm_msg_q, pool, buf_num - 1);
+
+	while (counter < buf_num) {
+
+		occ_old = mv_pp3_hmac_rxq_occ_get(pp3_cpus[0]->bm_msg_frame, pp3_cpus[0]->bm_msg_q);
+		occ = occ_old;
+
+		while (occ--) {
+			mv_pp3_hmac_bm_buff_get(pp3_cpus[0]->bm_msg_frame, pp3_cpus[0]->bm_msg_q,
+						&pool_id, &ph_addr, &vr_addr);
+
+			pr_info("#%d:	pool = %d	phys = 0x%08x	virt = 0x%08x\n",
+					counter, pool_id, ph_addr, vr_addr);
+
+			counter++;
+		}
+
+		mv_pp3_hmac_rxq_occ_set(pp3_cpus[0]->bm_msg_frame, pp3_cpus[0]->bm_msg_q, occ_old);
+	}
+
+	pp3_pools[pool]->buf_num -= counter;
+
+	return err;
+}
+
+/*---------------------------------------------------------------------------*/
+
+/* function for sysfs command, add buffers to pool */
+int pp3_pool_dbg_push(int pool, int buf_num)
+{
+	if (!pp3_cpus || !pp3_cpus[0]) {
+		pr_err("hw is not init\n");
+		return -1;
+	}
+
+	return pp3_pool_add(pool, buf_num, pp3_cpus[0]->bm_msg_frame, pp3_cpus[0]->bm_msg_q);
+}
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.c
index 38d2fba..86d1bed 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.c
@@ -34,18 +34,19 @@ disclaimer.
 
 #include "mv_netdev.h"
 #include "common/mv_hw_if.h"
-
+#include "mv_dev_sysfs.h"
 static ssize_t pp3_dev_help(char *b)
 {
 	int o = 0;
-	o += sprintf(b+o, "echo [netif]                > ifStatus         - print net interface status\n");
-	o += sprintf(b+o, "echo [netif] [cpu]          > groupStatus      - print group status\n");
-	o += sprintf(b+o, "echo [pool]                 > poolStatus       - print BM pool status\n");
-	o += sprintf(b+o, "echo [cpu]                  > cpuStatus        - print cpu status\n");
-	o += sprintf(b+o, "echo [netif] [cpu] [q]      > rxqStatus        - print rxq status\n");
-	o += sprintf(b+o, "echo [netif] [cpu] [q]      > txqStatus        - print rxq status\n");
-	o += sprintf(b+o, "echo [addr] [val] [c]       > reg_write        - write value to absolute address\n");
-	o += sprintf(b+o, "echo [addr] [c]             > reg_read         - read number of words from absolute address\n");
+	o += sprintf(b+o, "cd                        bm            - Move to BM sysfs directory\n");
+	o += sprintf(b+o, "\n");
+	o += sprintf(b+o, "echo [netif]            > ifStatus      - Print net interface status\n");
+	o += sprintf(b+o, "echo [netif] [cpu]      > groupStatus   - Print group status\n");
+	o += sprintf(b+o, "echo [cpu]              > cpuStatus     - Print cpu status\n");
+	o += sprintf(b+o, "echo [netif] [cpu] [q]  > rxqStatus     - Print rxq status\n");
+	o += sprintf(b+o, "echo [netif] [cpu] [q]  > txqStatus     - Print rxq status\n");
+	o += sprintf(b+o, "echo [addr]  [val] [c]  > reg_write     - Write value to absolute address\n");
+	o += sprintf(b+o, "echo [addr]  [c]        > reg_read      - Read number of words from absolute address\n");
 
 	o += sprintf(b+o, "\nAll inputs in decimal\n");
 
@@ -87,8 +88,6 @@ static ssize_t pp3_dev_store(struct device *dev,
 		pp3_netdev_dev_status_print(a);
 	} else if (!strcmp(name, "groupStatus")) {
 		pp3_netdev_group_status_print(a, b);
-	} else if (!strcmp(name, "poolStatus")) {
-		pp3_netdev_pool_status_print(a);
 	} else if (!strcmp(name, "cpuStatus")) {
 		pp3_netdev_cpu_status_print(a);
 	} else if (!strcmp(name, "rxqStatus")) {
@@ -153,7 +152,6 @@ static ssize_t pp3_hex_dev_store(struct device *dev,
 
 static DEVICE_ATTR(ifStatus,		S_IWUSR, NULL, pp3_dev_store);
 static DEVICE_ATTR(groupStatus,		S_IWUSR, NULL, pp3_dev_store);
-static DEVICE_ATTR(poolStatus,		S_IWUSR, NULL, pp3_dev_store);
 static DEVICE_ATTR(cpuStatus,		S_IWUSR, NULL, pp3_dev_store);
 static DEVICE_ATTR(rxqStatus,		S_IWUSR, NULL, pp3_dev_store);
 static DEVICE_ATTR(txqStatus,		S_IWUSR, NULL, pp3_dev_store);
@@ -165,7 +163,6 @@ static struct attribute *pp3_dev_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_ifStatus.attr,
 	&dev_attr_groupStatus.attr,
-	&dev_attr_poolStatus.attr,
 	&dev_attr_cpuStatus.attr,
 	&dev_attr_rxqStatus.attr,
 	&dev_attr_txqStatus.attr,
@@ -175,23 +172,33 @@ static struct attribute *pp3_dev_attrs[] = {
 };
 
 static struct attribute_group pp3_dev_group = {
-	.name = "dev",
 	.attrs = pp3_dev_attrs,
 };
 
+static struct kobject *dev_kobj;
+
 int pp3_dev_sysfs_init(struct kobject *pp3_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp3_kobj, &pp3_dev_group);
+	dev_kobj = kobject_create_and_add("dev", pp3_kobj);
+	if (!dev_kobj) {
+		printk(KERN_ERR"%s: cannot create dev kobject\n", __func__);
+		return -ENOMEM;
+	}
+
+	err = sysfs_update_group(dev_kobj, &pp3_dev_group);
 	if (err) {
 		pr_err("sysfs group %s failed %d\n", pp3_dev_group.name, err);
 		return err;
 	}
 
+	pp3_dev_bm_sysfs_init(dev_kobj);
+
 	return err;
 }
 
+
 int pp3_dev_sysfs_exit(struct kobject *pp3_kobj)
 {
 	sysfs_remove_group(pp3_kobj, &pp3_dev_group);
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.h
new file mode 100644
index 0000000..7a23883
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_sysfs.h
@@ -0,0 +1,34 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_eth_sysfs_h__
+#define __mv_eth_sysfs_h__
+
+int pp3_dev_bm_sysfs_init(struct kobject *dev_kobj);
+int pp3_dev_bm_sysfs_exit(struct kobject *dev_kobj);
+
+#endif /* __mv_eth_sysfs_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index 1a0f7df..4d292c7 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -351,7 +351,7 @@ static int pp3_pool_init_complete(int pool)
 
 	do {
 		if (count++ >= MV_PP3_POOL_INIT_TIMEOUT_MSEC) {
-			pr_warn("TIMEOUT for pool #%d init complete\n", pool);
+			pr_err("TIMEOUT for pool #%d init complete\n", pool);
 			return -1;
 		}
 
@@ -370,6 +370,7 @@ static struct pp3_pool *pp3_pool_gp_create(int pool, int capacity)
 {
 	struct pp3_pool *ppool;
 	unsigned int ret_val;
+	struct mv_a40 pool_addr;
 
 	if (pp3_pools[pool]) {
 		if (pp3_pools[pool]->capacity != capacity) {
@@ -395,21 +396,15 @@ static struct pp3_pool *pp3_pool_gp_create(int pool, int capacity)
 
 	ppool->type = PP3_POOL_TYPE_GP;
 
-	/*TODO create address structure */
-	/* struct mv_addr_64 pool_addr  */
-	/* pool_addr->high = 0, low =  pool_addr->phys_base*/
-	/* last param - pool pair = 1*/
+	pool_addr.virt_lsb = (u32)ppool->virt_base;
+	pool_addr.virt_msb = 0;
+	pool_addr.dma_lsb = (u32)ppool->phys_base;
+	pool_addr.dma_msb = 0;
 
-	/*ret_val = bm_gp_pool_def_basic_init(pool, 2 * capacity, &pool_addr, 1, 1);*/
-
-	if (!ret_val)
-		goto out;
-
-	if (pp3_pool_init_complete(pool))
+	bm_gp_pool_def_basic_init(pool, 2 * capacity, &pool_addr, 1, 1);
+	if (ret_val)
 		goto out;
 
-	pr_info("%s: pool %d creation successed\n", __func__, pool);
-
 	return ppool;
 out:
 	pp3_pool_release(pool);
@@ -422,17 +417,23 @@ out:
 static int pp3_pools_gpm_init(int capacity)
 {
 	struct pp3_pool *ppool_0, *ppool_1;
+	struct mv_a40 pool_0_addr, pool_1_addr;
 	int ret_val;
 
 	ppool_0 = pp3_pool_alloc(MV_PP3_GPM_POOL_0, capacity);
 	ppool_1 = pp3_pool_alloc(MV_PP3_GPM_POOL_1, capacity);
 	ppool_0->type = PP3_POOL_TYPE_GPM;
 	ppool_1->type = PP3_POOL_TYPE_GPM;
+	pool_0_addr.virt_lsb = (u32)ppool_0->virt_base;
+	pool_0_addr.dma_lsb = (u32)ppool_0->phys_base;
+	pool_1_addr.virt_lsb = (u32)ppool_1->virt_base;
+	pool_1_addr.dma_lsb = (u32)ppool_1->phys_base;
+	pool_0_addr.virt_msb = 0;
+	pool_0_addr.dma_lsb = 0;
+	pool_1_addr.virt_msb = 0;
+	pool_1_addr.dma_lsb = 0;
 
-	/*TODO create address structure */
-	/* struct mv_addr_64 pool_addr  */
-	/* pool_addr->high = 0, low =  pool_addr->phys_base*/
-	/*reg_val = bm_qm_gpm_pools_def_quick_init(capacity, 0, &pool_addr, ppool_1->phys_base);*/
+	ret_val = bm_qm_gpm_pools_def_quick_init(capacity, &pool_0_addr, &pool_1_addr);
 
 	if (!ret_val)
 		return ret_val;
@@ -453,6 +454,7 @@ static int pp3_pools_gpm_init(int capacity)
 static int pp3_pools_dram_init(int capacity)
 {
 	struct pp3_pool *ppool_0, *ppool_1;
+	struct mv_a40 pool_0_addr, pool_1_addr;
 	int ret_val;
 
 	ppool_0 = pp3_pool_alloc(MV_PP3_DRAM_POOL_0, capacity);
@@ -460,10 +462,12 @@ static int pp3_pools_dram_init(int capacity)
 	ppool_0->type = PP3_POOL_TYPE_DRAM;
 	ppool_1->type = PP3_POOL_TYPE_DRAM;
 
-	/*TODO create address structure */
-	/* struct mv_addr_64 pool_addr  */
-	/* pool_addr->high = 0, low =  pool_addr->phys_base*/
-	/*ret_val = bm_qm_dram_pools_def_quick_init (capacity, 0, &pool_addr, ppool_1->phys_base);*/
+	pool_0_addr.virt_lsb = (u32)ppool_0->virt_base;
+	pool_0_addr.dma_lsb = (u32)ppool_0->phys_base;
+	pool_1_addr.virt_lsb = (u32)ppool_1->virt_base;
+	pool_1_addr.dma_lsb = (u32)ppool_1->phys_base;
+
+	ret_val = bm_qm_dram_pools_def_quick_init(capacity, &pool_0_addr, &pool_1_addr);
 
 	if (!ret_val)
 		return ret_val;
@@ -477,10 +481,9 @@ static int pp3_pools_dram_init(int capacity)
 
 	return ret_val;
 }
-
 /*---------------------------------------------------------------------------*/
 
-static int pp3_pool_add(int pool, int buf_num, int frame, int queue)
+int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 {
 	struct pp3_pool *ppool;
 	unsigned long phys_addr;
@@ -513,16 +516,20 @@ static int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 			break;
 
 		mv_pp3_hmac_bm_buff_put(frame, queue, pool, (unsigned int)virt, phys_addr);
+		mv_pp3_hmac_txq_send(frame, queue, 1);
 	}
 
 	ppool->buf_num += i;
 
 	pr_info("%s %s %s pool #%d:  buf_size=%4d - %d of %d buffers added\n",
 		(ppool->flags & POOL_F_SHORT) ? "short" : "",
-		(ppool->flags & POOL_F_LONG) ? "long" : "",
-		(ppool->flags & POOL_F_LRO) ? "lro" : "",
+		(ppool->flags & POOL_F_LONG) ? "long " : "",
+		(ppool->flags & POOL_F_LRO) ? "lro  " : "",
 		 pool, size, i, buf_num);
+
+	return 0;
 }
+
 /*---------------------------------------------------------------------------*/
 /* channel callback function						     */
 /*---------------------------------------------------------------------------*/
@@ -594,13 +601,6 @@ struct net_device *mv_pp3_netdev_init(struct platform_device *pdev)
 		goto err_free_netdev;
 	}
 
-/*
-	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
-		pr_warning( "mydev: No suitable DMA available.\n");
-		free_netdev(dev);
-		return NULL;
-	}
-*/
 	return dev;
 
 err_free_netdev:
@@ -615,15 +615,15 @@ static struct pp3_rxq *pp3_rxq_priv_init(int emac, int cpu)
 	int swq, hwq_base, hwq_num, frame, irq_group;
 	struct pp3_rxq *priv_rxq;
 
-	/*mv_pp3_cfg_dp_nic_rxq_params_get(emac, cpu, &frame, &swq, &hwq_base, &hwq_num, &irq_group);*/
+	mv_pp3_cfg_dp_nic_rxq_params_get(emac, cpu, &frame, &swq, &hwq_base, &hwq_num, &irq_group);
 	priv_rxq = kzalloc(sizeof(struct pp3_rxq), GFP_KERNEL);
 
 	if (priv_rxq) {
 		priv_rxq->frame_num = frame;
 		priv_rxq->swq = swq;
 		priv_rxq->irq_group = irq_group;
-		/*priv_rxq->hwq_base = hwq;*/
-		/*priv_rxq->hwq_num = hwq_num;*/
+		priv_rxq->hwq_base = hwq_base;
+		priv_rxq->hwq_num = hwq_num;
 		priv_rxq->type = PP3_Q_TYPE_QM;
 		priv_rxq->size = MV_PP3_DP_RXQ_SIZE;
 		priv_rxq->pkt_coal = CONFIG_PP3_RX_COAL_PKTS;
@@ -639,7 +639,7 @@ static struct pp3_txq *pp3_txq_priv_init(int emac, int cpu)
 	int swq, hwq, frame;
 	struct pp3_txq *priv_txq;
 
-	/*mv_pp3_cfg_dp_nic_txq_params_get(emac, cpu, &frame, &swq, &hwq)*/
+	mv_pp3_cfg_dp_nic_txq_params_get(emac, cpu, &frame, &swq, &hwq);
 	priv_txq = kmalloc(sizeof(struct pp3_txq), GFP_KERNEL);
 
 	if (priv_txq) {
@@ -850,20 +850,33 @@ static int mv_pp3_hw_netif_start(struct pp3_dev_priv *dev_priv)
 		struct pp3_txq *txq_ctrl;
 		group_ctrl = pp3_groups[cpu][dev_priv->index];
 
-		/*mv_pp3_cfg_dp_gen_pool_id(&pool)*/
+
+		mv_pp3_cfg_dp_gen_pool_id(&pool);
 		group_ctrl->long_pool = pp3_pool_gp_create(pool, MV_PP3_LONG_POOL_SIZE);
 		group_ctrl->long_pool->flags = POOL_F_LONG;
+		/* TODO: init pool buf size, example in neta */
+		group_ctrl->long_pool->buf_size	= 1600;
 
-		/*mv_pp3_cfg_dp_gen_pool_id(&pool)*/
+		mv_pp3_cfg_dp_gen_pool_id(&pool);
 		group_ctrl->short_pool = pp3_pool_gp_create(pool, MV_PP3_SHORT_POOL_SIZE);
 		group_ctrl->short_pool->flags = POOL_F_SHORT;
+		group_ctrl->short_pool->buf_size = 160;
 
-		/*mv_pp3_cfg_dp_gen_pool_id(&pool)*/
+		mv_pp3_cfg_dp_gen_pool_id(&pool);
 		group_ctrl->lro_pool = pp3_pool_gp_create(pool, MV_PP3_LRO_POOL_SIZE);
 		group_ctrl->lro_pool->flags = POOL_F_LRO;
+		group_ctrl->lro_pool->buf_size = 320;
+
+		/* TODO - remove after debug */
+		pr_info("group_ctrl->rxqs_num = %d, group_ctrl->txqs_num = %d\n",
+				group_ctrl->rxqs_num,  group_ctrl->txqs_num);
 
+		/* TODO: one loop, same num of rx and tx queues */
 		for (i = 0; i < group_ctrl->rxqs_num; i++) {
 			rxq_ctrl =  group_ctrl->rxqs[i];
+			/* TODO - remove after debug */
+			pr_err("rxq_num #%d: frame_num = %d, swq = %d, size = %d, group = %d\n", i,
+					rxq_ctrl->frame_num, rxq_ctrl->swq, rxq_ctrl->size, rxq_ctrl->irq_group);
 			mv_pp3_hmac_rxq_init(rxq_ctrl->frame_num, rxq_ctrl->swq, rxq_ctrl->size);
 			mv_pp3_hmac_rxq_event_cfg(rxq_ctrl->frame_num, rxq_ctrl->swq, 0, rxq_ctrl->irq_group);
 			mv_pp3_hmac_rxq_enable(rxq_ctrl->frame_num, rxq_ctrl->swq);
@@ -873,7 +886,12 @@ static int mv_pp3_hw_netif_start(struct pp3_dev_priv *dev_priv)
 			txq_ctrl =  group_ctrl->txqs[i];
 			mv_pp3_hmac_txq_init(txq_ctrl->frame_num, txq_ctrl->swq, txq_ctrl->size, 0);
 			mv_pp3_hmac_txq_enable(txq_ctrl->frame_num, txq_ctrl->swq);
+			/*
+			TODO: init qmq
+			void mv_pp3_hmac_queue_qm_mode_cfg(int frame, int queue, int qm_num);
+			*/
 		}
+
 	}
 
 	return 0;
@@ -883,6 +901,7 @@ static int mv_pp3_hw_netif_start(struct pp3_dev_priv *dev_priv)
 /* Init BM and QM HW*/
 static void mv_pp3_hw_bm_qm_start(void)
 {
+
 	/* init all bm api structures */
 	bm_open();
 
@@ -897,8 +916,9 @@ static void mv_pp3_hw_bm_qm_start(void)
 	bm_enable();
 
 	/* QM HW int */
-	/*qm_default_set();*/
-	/*qm_dma_gpm_pools_def_enable();*/
+	qm_default_set();
+	qm_dma_gpm_pools_def_enable();
+
 	/*Dram pools init relevant only for A0*/
 	/*qm_dma_dram_pools_def_enable();*/
 }
@@ -907,16 +927,24 @@ static void mv_pp3_hw_bm_qm_start(void)
 static int mv_pp3_hw_shared_start(void)
 {
 	struct pp3_cpu *cpu_ctrl;
-	int cpu, pool, frame, queue, q_size, group, irq;
+	int cpu, pool, frame, queue, group;
 	unsigned int frames_bmp;
 
 	/*TODO load fw */
 
 	mv_pp3_hw_bm_qm_start();
 
+	/* TODO: start fw */
+
 	/*configutator init */
 	/* call to mv_pp3_cfg_hwq_info_set */
 
+
+	/* Z1 - set frames vmid to 0 */
+	for (frame = 0; frame <= MV_PP3_HMAC_MAX_FRAME; frame++)
+		mv_pp3_hmac_frame_cfg(frame, 0);
+
+
 	/* init cpu's structures */
 	for_each_possible_cpu(cpu) {
 		cpu_ctrl = kzalloc(sizeof(struct pp3_cpu), GFP_KERNEL);
@@ -926,16 +954,13 @@ static int mv_pp3_hw_shared_start(void)
 
 		pp3_cpus[cpu] = cpu_ctrl;
 
-		/* TODO: call to config manager: get frames bitmap per cpu */
-		/*mv_pp3_cfg_dp_frames_bitmap(int cpu, &frames_bmp);*/
+		mv_pp3_cfg_dp_frames_bitmap(cpu, &frames_bmp);
 		cpu_ctrl->frame_bmp = frames_bmp;
 
-		/* TODO: call to config manager: get free pool id */
-		/* mv_pp3_cfg_dp_gen_pool_id(&pool);*/
+		mv_pp3_cfg_dp_gen_pool_id(&pool);
 		cpu_ctrl->tx_done_pool =  pp3_pool_gp_create(pool, MV_PP3_LINUX_POOL_SIZE);
 
-		/* TODO: call to config manager: get frame and queue num in order to manage bm pool */
-		/*mv_pp3_cfg_dp_bmq_params_get(cpu, &frame, &queue, &group);*/
+		mv_pp3_cfg_dp_bmq_params_get(cpu, &frame, &queue, &group);
 
 		cpu_ctrl->bm_msg_group = group;
 		cpu_ctrl->bm_msg_frame = frame;
@@ -944,6 +969,7 @@ static int mv_pp3_hw_shared_start(void)
 		mv_pp3_hmac_bm_queue_init(frame, queue, MV_PP3_HMAC_BM_Q_SIZE);
 		mv_pp3_hmac_rxq_enable(cpu_ctrl->bm_msg_frame, cpu_ctrl->bm_msg_q);
 		mv_pp3_hmac_txq_enable(cpu_ctrl->bm_msg_frame, cpu_ctrl->bm_msg_q);
+
 		cpu_ctrl->bm_msg_tasklet = kzalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
 		tasklet_init(pp3_cpus[cpu]->bm_msg_tasklet, mv_pp3_bm_tasklet, (unsigned long)pp3_cpus[cpu]);
 
@@ -952,15 +978,15 @@ static int mv_pp3_hw_shared_start(void)
 		init_timer(&cpu_ctrl->tx_done_timer);
 		clear_bit(MV_CPU_F_TX_DONE_TIMER_BIT, &cpu_ctrl->flags);
 		cpu_ctrl->tx_done_timer.data = (unsigned long)pp3_cpus[cpu];
-	}
 
-	/* TODO: HMAC HW unit int */
+		/*
+		cpu_ctrl->chan_id = mv_pp3_chan_create(cpu, MV_PP3_CHAN_SIZE, 0, pp3_chan_callback);
+		pr_info("cpu #%d: chan_id = %d\n", cpu, cpu_ctrl->chan_id);
+		*/
+		/*lock*/
 
-	/* TODO: start fw */
-	/* TODO: Channel create */
+	}
 
-	/*cpu_ctrl->chan_id = mv_pp3_chan_create(MV_PP3_CHAN_SIZE, 0, pp3_chan_callback);*/
-	/*lock*/
 	return 0;
 oom:
 	for_each_possible_cpu(cpu) {
@@ -983,6 +1009,18 @@ static int mv_pp3_sw_shared_probe(struct platform_device *pdev)
 
 	struct mv_pp3_plat_data *plat_data = (struct mv_pp3_plat_data *)pdev->dev.platform_data;
 
+	/* Temporary */
+	struct mv_pp3_hwq_cfg system_hw_config[PP3_CLIENTS_NUM] = {
+		{0,  0,  0,  0,   0,   128}, /* PP3_PPC0_DP */
+		{3,  6,  12, 48,  192, 32}, /* PP3_EMAC0 */
+		{4,  7,  14, 56,  224, 32}, /* PP3_EMAC1 */
+		{5,  8,  16, 64,  256, 32}, /* PP3_EMAC2 */
+		{6,  9,  18, 72,  288, 32}, /* PP3_EMAC3 */
+		{0,  0,  0,  0,   0,   32}, /* PP3_CMAC_IN */
+		{0,  0,  0,  0,   0,   32}, /* PP3_CMAC_LA */
+		{10, 13, 26, 104, 416, 64}, /* PP3_HMAC_RX */
+	};
+
 	shared_pdev = pdev;
 
 	pp3_ports_num = plat_data->max_port;
@@ -1011,8 +1049,11 @@ static int mv_pp3_sw_shared_probe(struct platform_device *pdev)
 		pp3_frames[i]->time_coal[0] = MV_PP3_FRM_TIME_COAL_0;
 	}
 
-	/*mv_pp3_messenger_init();*/
-	/*on_each_cpu(mv_pp3_def_chan_create, &size, 1);*/
+	/* init configurator */
+	for (i = 0; i < PP3_CLIENTS_NUM; i++)
+		mv_pp3_cfg_hwq_info_set(i, &system_hw_config[i]);
+
+	mv_pp3_messenger_init();
 
 	return 0;
 
@@ -1046,12 +1087,50 @@ static int mv_pp3_netif_init(struct pp3_dev_priv *dev_priv)
 }
 
 /*---------------------------------------------------------------------------*/
+static int mv_pp3_netif_pools_fill(struct pp3_dev_priv *dev_priv)
+{
+	int cpu;
+	struct pp3_cpu *cpu_ctrl;
+	struct pp3_group *group;
+	struct pp3_pool *ppool;
 
+	for_each_possible_cpu(cpu) {
+		group = dev_priv->groups[cpu];
+
+		if (!group)
+			continue;
+
+
+		cpu_ctrl = group->cpu_ctrl;
+		ppool = group->long_pool;
+
+		if (group->long_pool)
+			pp3_pool_add(ppool->pool, ppool->capacity-10,
+					cpu_ctrl->bm_msg_frame, cpu_ctrl->bm_msg_q);
+
+		ppool = group->short_pool;
+
+		if (group->short_pool)
+			pp3_pool_add(ppool->pool, ppool->capacity-10,
+						cpu_ctrl->bm_msg_frame, cpu_ctrl->bm_msg_q);
+
+		ppool = group->lro_pool;
+
+		if (group->lro_pool)
+			pp3_pool_add(ppool->pool, ppool->capacity-10,
+						cpu_ctrl->bm_msg_frame, cpu_ctrl->bm_msg_q);
+	}
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
 static int mv_pp3_dev_open(struct net_device *dev)
 {
 	struct pp3_dev_priv *dev_priv = MV_PP3_PRIV(dev);
 
 	mv_pp3_netif_init(dev_priv);
+	mv_pp3_netif_pools_fill(dev_priv);
 
 	return 0;
 }
@@ -1170,7 +1249,7 @@ module_exit(mv_pp3_cleanup_module);
 /*				dump functions				     */
 /*---------------------------------------------------------------------------*/
 
-void pp3_netdev_pool_status_print(int pool)
+void pp3_pool_status_print(int pool)
 {
 	const char *str;
 	struct pp3_pool *ppool;
@@ -1202,10 +1281,10 @@ void pp3_netdev_pool_status_print(int pool)
 		str = "UNKNOWN";
 
 	pr_info("/n");
-	pr_info("pool #%d : ppool = 0x%p, pool type = %s, buffers num = %d, buffer size = %d, capacity = %d\n",
+	pr_info("pool #%d : ppool = 0x08%p, pool type = %s, buffers num = %d, buffer size = %d, capacity = %d\n",
 			pool, ppool, str, ppool->buf_num, ppool->buf_size, ppool->capacity);
 
-	pr_info("virt_base = 0x%p, phys_base = 0x%lu\n", ppool->virt_base, ppool->phys_base);
+	pr_info("virt_base = 0x%08x, phys_base = 0x%08x\n", ppool->virt_base, ppool->phys_base);
 
 	return;
 }
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
index 22af62b..6000b8a 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
@@ -65,14 +65,24 @@ disclaimer.
 int pp3_dev_sysfs_init(struct kobject *pp3_kobj);
 int pp3_dev_sysfs_exit(struct kobject *pp3_kobj);
 /*---------------------------------------------------------------------------*/
-/*				dump functions				     */
+/*				debug functions				     */
 /*---------------------------------------------------------------------------*/
-void pp3_netdev_pool_status_print(int pool);
+void pp3_pool_status_print(int pool);
 void pp3_netdev_cpu_status_print(int cpu);
 void pp3_netdev_dev_status_print(int index);
 void pp3_netdev_group_status_print(int index, int cpu);
 void pp3_netdev_rxq_status_print(int index, int cpu, int queue);
 void pp3_netdev_txq_status_print(int index, int cpu, int queue);
+int pp3_pool_dbg_pop(int pool, int buf_num);
+int pp3_pool_dbg_push(int pool, int buf_num);
+int pp3_pool_dbg_dump(int pool, int v);
+int pp3_pool_add(int pool, int buf_num, int frame, int queue);
+
+/*---------------------------------------------------------------------------*/
+/*				extern parameters			     */
+/*---------------------------------------------------------------------------*/
+extern struct pp3_pool **pp3_pools;
+extern struct pp3_cpu **pp3_cpus;
 
 /****************************************************************************
  * Rx buffer size: MTU + 2(Marvell Header) + 4(VLAN) + 14(MAC hdr) + 4(CRC) *
-- 
1.7.5.4

