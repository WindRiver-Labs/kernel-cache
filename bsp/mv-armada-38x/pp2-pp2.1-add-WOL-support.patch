From 2e486d22ac82e79d5f8a2c4388adbb898579348a Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Sun, 10 Nov 2013 12:59:51 +0200
Subject: [PATCH 1083/1825] pp2: pp2.1 add WOL support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ce036bffd527a1ca8779f4d8ed52d80d37efbbd9

	- add wol support to ppv2.1 (A0)

Change-Id: I04310b31db06da40fc71eef50b2633e5357985bd
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4341
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    3 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h   |    3 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |    2 +
 .../mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c          |  332 ++++++++++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c     |  292 +++++++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h     |  164 ++++++++++
 6 files changed, 796 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index d5a7dc7..e4feff2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -14,6 +14,7 @@ PP2_PRS_DIR   = ../../mv_hal/pp2/prs
 PP2_CLS_DIR   = ../../mv_hal/pp2/cls
 PP2_PME_DIR   = ../../mv_hal/pp2/pme
 PP2_PLCR_DIR  = ../../mv_hal/pp2/plcr
+PP2_WOL_DIR   = ../../mv_hal/pp2/wol
 PP2_COMMON_DIR= ../../mv_hal/pp2/common
 
 mv_pp2-objs +=	$(PP2_GMAC_DIR)/mvEthGmacApi.o
@@ -27,6 +28,7 @@ mv_pp2-objs += 	$(PP2_CLS_DIR)/mvPp2ClsHw.o $(PP2_CLS_DIR)/mvPp2Cls2Hw.o \
 mv_pp2-objs += 	$(PP2_PME_DIR)/mvPp2PmeHw.o
 mv_pp2-objs += 	$(PP2_PLCR_DIR)/mvPp2PlcrHw.o
 mv_pp2-objs +=	$(PP2_BM_DIR)/mvBm.o
+mv_pp2-objs +=  $(PP2_WOL_DIR)/mvPp2Wol.o
 mv_pp2-objs +=  $(PP2_COMMON_DIR)/mvPp2Common.o
 
 mv_pp2-objs += net_dev/mv_netdev.o net_dev/mv_ethernet.o net_dev/mv_eth_sysfs.o net_dev/mv_eth_tool.o
@@ -42,6 +44,7 @@ mv_pp2-objs += prs/prs_low_sysfs.o prs/prs_high_sysfs.o
 mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.o cls/cls_mc_sysfs.o
 mv_pp2-objs += pme/pme_sysfs.o
 mv_pp2-objs += plcr/plcr_sysfs.o
+mv_pp2-objs += wol/wol_sysfs.o
 
 ifeq ($(CONFIG_MV_ETH_L2FW),y)
 mv_pp2-objs += l2fw/l2fw_sysfs.o l2fw/mv_eth_l2fw.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
index ee18514..1bd0968 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
@@ -94,6 +94,9 @@ int mv_pp2_gbe_hwf_sysfs_exit(struct kobject *gbe_kobj);
 int mv_pp2_dbg_sysfs_init(struct kobject *pp2_kobj);
 int mv_pp2_dbg_sysfs_exit(struct kobject *pp2_kobj);
 
+int mv_pp2_wol_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_wol_sysfs_exit(struct kobject *pp2_kobj);
+
 #ifdef CONFIG_MV_ETH_L2FW
 int mv_pp2_l2fw_sysfs_init(struct kobject *pp2_kobj);
 int mv_pp2_l2fw_sysfs_exit(struct kobject *pp2_kobj);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 11fe2c7..5821ae2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -3506,6 +3506,7 @@ static void mv_eth_sysfs_exit(void)
 #ifdef CONFIG_MV_ETH_L2FW
 	mv_pp2_l2fw_sysfs_exit(&pd->kobj);
 #endif
+	mv_pp2_wol_sysfs_exit(&pd->kobj);
 	mv_pp2_pme_sysfs_exit(&pd->kobj);
 	mv_pp2_plcr_sysfs_exit(&pd->kobj);
 	mv_pp2_mc_sysfs_exit(&pd->kobj);
@@ -3548,6 +3549,7 @@ static int mv_eth_sysfs_init(void)
 	mv_pp2_plcr_sysfs_init(&pd->kobj);
 	mv_pp2_pme_sysfs_init(&pd->kobj);
 	mv_pp2_dbg_sysfs_init(&pd->kobj);
+	mv_pp2_wol_sysfs_init(&pd->kobj);
 #ifdef CONFIG_MV_ETH_L2FW
 	mv_pp2_l2fw_sysfs_init(&pd->kobj);
 #endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
new file mode 100644
index 0000000..0215007
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/wol/wol_sysfs.c
@@ -0,0 +1,332 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "wol/mvPp2Wol.h"
+
+
+static ssize_t wol_help(char *buf)
+{
+	int of = 0;
+
+	of += scnprintf(buf + of, PAGE_SIZE - of, "t, i, a, b, c, l, s - are dec numbers\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "v, m, e             - are hex numbers\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "\n");
+
+	of += scnprintf(buf + of, PAGE_SIZE - of, "cat            help      - Show this help\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "cat            regs      - Show WOL registers\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "cat            status    - Show WOL status\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo port    > sleep     - Enter sleep mode for [port]\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo 1       > wakeup    - Force wakeup\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo mac     > magic_mac - Set MAC [a:b:c:d:e:f] for magic pattern\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i ip    > arp_ip    - Set IP [a.b.c.d] for ARP IP[i] event\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i s str > ptrn      - Set pattern [i] with [str] of [s] bytes\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "                           [str] in format: b0:b1::b3:::b6\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > magic_en  - On/Off wakeup by magic packet\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > ucast_en  - On/Off wakeup by Unicast packet\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo [0|1]   > mcast_en  - On/Off wakeup by Multicast packet\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i [0|1] > arp_ip_en - On/Off wakeup by ARP IP [i] packet\n");
+	of += scnprintf(buf + of, PAGE_SIZE - of, "echo i [0|1] > ptrn_en   - On/Off wakeup by pattern [i] packet\n");
+
+	return of;
+}
+
+static ssize_t wol_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	const char  *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "help"))
+		return wol_help(buf);
+
+	if (!strcmp(name, "regs")) {
+		mvPp2WolRegs();
+	} else if (!strcmp(name, "status")) {
+		mvPp2WolStatus();
+	} else {
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static ssize_t wol_dec_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, t = 0, i = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d", &i, &t);
+
+	local_irq_save(flags);
+	if (!strcmp(name, "sleep"))
+		err = mvPp2WolSleep(i);
+	else if (!strcmp(name, "wakeup")) {
+		if (i == 1)
+			err = mvPp2WolWakeup();
+	} else if (!strcmp(name, "magic_en")) {
+		mvPp2WolMagicEventSet(i);
+	} else if (!strcmp(name, "arp_ip_en")) {
+		mvPp2WolArpEventSet(i, t);
+	} else if (!strcmp(name, "ptrn_en")) {
+		mvPp2WolPtrnEventSet(i, t);
+	} else if (!strcmp(name, "mcast_en")) {
+		mvPp2WolMcastEventSet(i);
+	} else if (!strcmp(name, "ucast_en")) {
+		mvPp2WolUcastEventSet(i);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t wol_mac_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0;
+	char          macStr[MV_MAC_STR_SIZE];
+	MV_U8         mac[MV_MAC_ADDR_SIZE];
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%s", macStr);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "magic_mac")) {
+		mvMacStrToHex(macStr, mac);
+		err = mvPp2WolMagicDaSet(mac);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t wol_ip_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0;
+	int           i = 0;
+	unsigned char ip[4];
+	__be32        ipaddr;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %hhu.%hhu.%hhu.%hhu", &i, ip, ip + 1, ip + 2, ip + 3);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "arp_ip")) {
+		ipaddr = *(__be32 *)ip;
+		err = mvPp2WolArpIpSet(i, ipaddr);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static int wol_ptrn_get(char *ptrnStr, MV_U8 *data, MV_U8 *mask, int max_size)
+{
+	int i, j, size;
+	char tmp[3];
+
+	size = strlen(ptrnStr);
+	i = 0;
+	j = 0;
+	while (i < size) {
+		if (j >= max_size) {
+			pr_err("pattern string is too long (max = %d): %s\n",
+				max_size, ptrnStr);
+			return j;
+		}
+
+		if (ptrnStr[i] == ':') {
+			data[j] = 0;
+			mask[j] = 0;
+			j++;
+			i++;
+			continue;
+		}
+		if ((mvCharToHex(ptrnStr[i]) == -1) ||
+		    (mvCharToHex(ptrnStr[i + 1]) == -1) ||
+		    (((i + 2) > size) && (ptrnStr[i + 2] != ':'))) {
+			pr_err("Wrong pattern string format size=%d, i=%d, j=%d: %s\n",
+				size, i, j, &ptrnStr[i]);
+			return -1;
+		}
+
+		tmp[0] = ptrnStr[i];
+		tmp[1] = ptrnStr[i + 1];
+		tmp[2] = '\0';
+		data[j] = (MV_U8) (strtol(tmp, NULL, 16));
+		mask[j] = 0xff;
+		i += 3;
+		j++;
+	}
+	return j;
+}
+
+static ssize_t wol_ptrn_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0;
+	int           size, i = 0;
+	char          ptrnStr[MV_PP2_WOL_PTRN_BYTES*3];
+	char          data[MV_PP2_WOL_PTRN_BYTES];
+	char          mask[MV_PP2_WOL_PTRN_BYTES];
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %s", &i, ptrnStr);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "ptrn")) {
+		size = wol_ptrn_get(ptrnStr, data, mask, MV_PP2_WOL_PTRN_BYTES);
+		if (size != -1)
+			err = mvPp2WolPtrnSet(i, size, data, mask);
+		else
+			err = 1;
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+irqreturn_t mv_wol_isr(int irq, void *dev_id)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_INTR_CAUSE_REG);
+	pr_info("WoL interrupt: irq=%d, cause=0x%x\n", irq, regVal);
+	mvPp2WolWakeup();
+
+	return IRQ_HANDLED;
+}
+
+static DEVICE_ATTR(help,      S_IRUSR, wol_show, NULL);
+static DEVICE_ATTR(regs,      S_IRUSR, wol_show, NULL);
+static DEVICE_ATTR(status,    S_IRUSR, wol_show, NULL);
+static DEVICE_ATTR(sleep,     S_IWUSR, NULL,     wol_dec_store);
+static DEVICE_ATTR(wakeup,    S_IWUSR, NULL,     wol_dec_store);
+static DEVICE_ATTR(magic_mac, S_IWUSR, NULL,     wol_mac_store);
+static DEVICE_ATTR(arp_ip,    S_IWUSR, NULL,     wol_ip_store);
+static DEVICE_ATTR(ptrn,      S_IWUSR, NULL,     wol_ptrn_store);
+static DEVICE_ATTR(magic_en,  S_IWUSR, NULL,     wol_dec_store);
+static DEVICE_ATTR(arp_ip_en, S_IWUSR, NULL,     wol_dec_store);
+static DEVICE_ATTR(ptrn_en,   S_IWUSR, NULL,     wol_dec_store);
+static DEVICE_ATTR(ucast_en,   S_IWUSR, NULL,    wol_dec_store);
+static DEVICE_ATTR(mcast_en,   S_IWUSR, NULL,    wol_dec_store);
+
+
+static struct attribute *wol_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_regs.attr,
+	&dev_attr_status.attr,
+	&dev_attr_sleep.attr,
+	&dev_attr_wakeup.attr,
+	&dev_attr_magic_mac.attr,
+	&dev_attr_arp_ip.attr,
+	&dev_attr_ptrn.attr,
+	&dev_attr_magic_en.attr,
+	&dev_attr_arp_ip_en.attr,
+	&dev_attr_ptrn_en.attr,
+	&dev_attr_ucast_en.attr,
+	&dev_attr_mcast_en.attr,
+
+	NULL
+};
+
+static struct attribute_group mv_wol_group = {
+	.name = "wol",
+	.attrs = wol_attrs,
+};
+
+#define MV_PP2_WOL_IRQ	110
+
+int mv_pp2_wol_sysfs_init(struct kobject *pp2_kobj)
+{
+	int err = 0;
+
+	err = sysfs_create_group(pp2_kobj, &mv_wol_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", mv_wol_group.name, err);
+
+	return err;
+}
+
+int mv_pp2_wol_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &mv_wol_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
new file mode 100644
index 0000000..2eb3cfe
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.c
@@ -0,0 +1,292 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "pp2/common/mvPp2Common.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+#include "mvPp2Wol.h"
+
+
+void        mvPp2WolRegs(void)
+{
+	int    i, reg;
+
+	mvOsPrintf("\n[WoL registers]\n");
+
+	mvPp2PrintReg(MV_PP2_WOL_MODE_REG,       "MV_PP2_WOL_MODE_REG");
+	mvPp2PrintReg(MV_PP2_WOL_MAC_HIGH_REG,   "MV_PP2_WOL_MAC_HIGH_REG");
+	mvPp2PrintReg(MV_PP2_WOL_MAC_LOW_REG,    "MV_PP2_WOL_MAC_LOW_REG");
+	mvPp2PrintReg(MV_PP2_WOL_ARP_IP0_REG,    "MV_PP2_WOL_ARP_IP0_REG");
+	mvPp2PrintReg(MV_PP2_WOL_ARP_IP1_REG,    "MV_PP2_WOL_ARP_IP1_REG");
+	mvPp2PrintReg(MV_PP2_WOL_WAKEUP_EN_REG,  "MV_PP2_WOL_WAKEUP_EN_REG");
+	mvPp2PrintReg(MV_PP2_WOL_INTR_CAUSE_REG, "MV_PP2_WOL_INTR_CAUSE_REG");
+	mvPp2PrintReg(MV_PP2_WOL_INTR_MASK_REG,  "MV_PP2_WOL_INTR_MASK_REG");
+	mvPp2PrintReg(MV_PP2_WOL_PTRN_SIZE_REG,  "MV_PP2_WOL_PTRN_SIZE_REG");
+
+
+	for (i = 0; i < MV_PP2_WOL_PTRN_NUM; i++) {
+		mvOsPrintf("\nWoL Wakeup Frame pattern #%d\n", i);
+
+		mvPp2WrReg(MV_PP2_WOL_PTRN_IDX_REG, i);
+		for (reg = 0; reg < MV_PP2_WOL_PTRN_REGS; reg++) {
+			mvPp2RegPrintNonZero2(MV_PP2_WOL_PTRN_DATA_REG(reg), "MV_PP2_WOL_PTRN_DATA_REG", reg);
+			mvPp2RegPrintNonZero2(MV_PP2_WOL_PTRN_MASK_REG(reg), "MV_PP2_WOL_PTRN_MASK_REG", reg);
+		}
+	}
+}
+
+void      mvPp2WolStatus(void)
+{
+}
+
+MV_STATUS mvPp2WolSleep(int port)
+{
+	MV_U32 regVal;
+
+	if (mvPp2PortCheck(port))
+		return MV_BAD_PARAM;
+
+	/* Clear cause register and unmask enabled WoL events */
+	mvPp2WrReg(MV_PP2_WOL_INTR_CAUSE_REG, 0);
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	mvPp2WrReg(MV_PP2_WOL_INTR_MASK_REG, regVal);
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_MODE_REG);
+	if (regVal & MV_PP2_WOL_IS_SLEEP_MASK) {
+		mvOsPrintf("WoL is already activated on port #%d\n",
+			(regVal >> MV_PP2_WOL_SLEEP_PORT_OFFS) & MV_PP2_WOL_SLEEP_PORT_MAX);
+		return MV_BUSY;
+	}
+	regVal = MV_PP2_WOL_SLEEP_PORT_MASK(port) | MV_PP2_WOL_GO_SLEEP_MASK;
+	mvPp2WrReg(MV_PP2_WOL_MODE_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolWakeup(void)
+{
+	MV_U32 regVal;
+
+	/* Clear cause register and mask all WoL events */
+	mvPp2WrReg(MV_PP2_WOL_INTR_CAUSE_REG, 0);
+	mvPp2WrReg(MV_PP2_WOL_INTR_MASK_REG, 0);
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_MODE_REG);
+	regVal &= ~MV_PP2_WOL_GO_SLEEP_MASK;
+	mvPp2WrReg(MV_PP2_WOL_MODE_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolMagicDaSet(MV_U8 *mac_da)
+{
+	MV_U32 regVal;
+
+	regVal = (mac_da[0] << 24) | (mac_da[1] << 16) | (mac_da[2] << 8) | (mac_da[3] << 0);
+	mvPp2WrReg(MV_PP2_WOL_MAC_HIGH_REG, regVal);
+
+	regVal = (mac_da[4] << 8) | (mac_da[5]);
+	mvPp2WrReg(MV_PP2_WOL_MAC_LOW_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolArpIpSet(int idx, MV_U32 ip)
+{
+	MV_U32 regVal;
+
+	if (mvPp2MaxCheck(idx, MV_PP2_WOL_ARP_IP_NUM, "ARP IP index"))
+		return MV_BAD_PARAM;
+
+	regVal = MV_32BIT_BE(ip);
+	mvPp2WrReg(MV_PP2_WOL_ARP_IP_REG(idx), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask)
+{
+	MV_U32 regVal, regData, regMask;
+	int i, j, reg;
+
+	if (mvPp2MaxCheck(idx, MV_PP2_WOL_PTRN_NUM, "PTRN index"))
+		return MV_BAD_PARAM;
+
+	if (mvPp2MaxCheck(size, MV_PP2_WOL_PTRN_BYTES, "PTRN size"))
+		return MV_BAD_PARAM;
+/*
+	mvOsPrintf("WoL set pattern #%d: size=%d\n", idx, size);
+	mvDebugMemDump(data, size, 1);
+	mvDebugMemDump(mask, size, 1);
+*/
+	regVal = mvPp2RdReg(MV_PP2_WOL_PTRN_SIZE_REG);
+	regVal &= ~MV_PP2_WOL_PTRN_SIZE_MAX_MASK(idx);
+	regVal |= MV_PP2_WOL_PTRN_SIZE_MASK(idx, size);
+
+	mvPp2WrReg(MV_PP2_WOL_PTRN_SIZE_REG, regVal);
+
+	mvPp2WrReg(MV_PP2_WOL_PTRN_IDX_REG, idx);
+	for (i = 0; i < size; i += 4) {
+		reg = i / 4;
+		regData = mvPp2RdReg(MV_PP2_WOL_PTRN_DATA_REG(reg));
+		regMask = mvPp2RdReg(MV_PP2_WOL_PTRN_MASK_REG(reg));
+		for (j = 0; j < 4; j++) {
+
+			if ((i + j) >= size)
+				break;
+
+			regData &= ~MV_PP2_WOL_PTRN_DATA_BYTE_MASK(3 - j);
+			regData |= MV_PP2_WOL_PTRN_DATA_BYTE(3 - j, data[i + j]);
+			/* mask on byte level */
+			if (mask[i + j] == 0)
+				regMask &= ~MV_PP2_WOL_PTRN_MASK_BIT(3 - j);
+			else
+				regMask |= MV_PP2_WOL_PTRN_MASK_BIT(3 - j);
+		}
+		mvPp2WrReg(MV_PP2_WOL_PTRN_DATA_REG(reg), regData);
+		mvPp2WrReg(MV_PP2_WOL_PTRN_MASK_REG(reg), regMask);
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolArpEventSet(int idx, int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_WOL_ARP_IP_MASK(idx);
+	else
+		regVal &= ~MV_PP2_WOL_ARP_IP_MASK(idx);
+
+	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolMcastEventSet(int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_WOL_MCAST_MASK;
+	else
+		regVal &= ~MV_PP2_WOL_MCAST_MASK;
+
+	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolUcastEventSet(int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_WOL_UCAST_MASK;
+	else
+		regVal &= ~MV_PP2_WOL_UCAST_MASK;
+
+	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+
+	mvOsPrintf("%s: enable=%d, regOffset=0x%x, regVal=0x%x\n",
+			__func__, enable, MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolMagicEventSet(int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_WOL_MAGIC_PTRN_MASK;
+	else
+		regVal &= ~MV_PP2_WOL_MAGIC_PTRN_MASK;
+
+	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2WolPtrnEventSet(int idx, int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_WOL_WAKEUP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_WOL_PTRN_IDX_MASK(idx);
+	else
+		regVal &= ~MV_PP2_WOL_PTRN_IDX_MASK(idx);
+
+	mvPp2WrReg(MV_PP2_WOL_WAKEUP_EN_REG, regVal);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h
new file mode 100644
index 0000000..a82315b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/wol/mvPp2Wol.h
@@ -0,0 +1,164 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvPp2Wol_h__
+#define __mvPp2Wol_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "pp2/gbe/mvPp2Gbe.h"
+
+/*********************************** RX Policer Registers *******************/
+
+#define MV_PP2_WOL_MODE_REG                 (MV_PP2_REG_BASE + 0x400)
+
+#define MV_PP2_WOL_GO_SLEEP_BIT             0
+#define MV_PP2_WOL_GO_SLEEP_MASK            (1 << MV_PP2_WOL_GO_SLEEP_BIT)
+
+#define MV_PP2_WOL_IS_SLEEP_BIT             1
+#define MV_PP2_WOL_IS_SLEEP_MASK            (1 << MV_PP2_WOL_IS_SLEEP_BIT)
+
+#define MV_PP2_WOL_SLEEP_PORT_OFFS          4
+#define MV_PP2_WOL_SLEEP_PORT_BITS          3
+#define MV_PP2_WOL_SLEEP_PORT_MAX           ((1 << MV_PP2_WOL_SLEEP_PORT_BITS) - 1)
+#define MV_PP2_WOL_SLEEP_PORT_ALL_MASK      (MV_PP2_WOL_SLEEP_PORT_MAX << MV_PP2_WOL_SLEEP_PORT_OFFS)
+#define MV_PP2_WOL_SLEEP_PORT_MASK(p)       (((p) & MV_PP2_WOL_SLEEP_PORT_MAX) << MV_PP2_WOL_SLEEP_PORT_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_WOL_MAC_HIGH_REG             (MV_PP2_REG_BASE + 0x410)
+#define MV_PP2_WOL_MAC_LOW_REG              (MV_PP2_REG_BASE + 0x414)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_WOL_ARP_IP_NUM               2
+
+#define MV_PP2_WOL_ARP_IP0_REG              (MV_PP2_REG_BASE + 0x418)
+#define MV_PP2_WOL_ARP_IP1_REG              (MV_PP2_REG_BASE + 0x41C)
+#define MV_PP2_WOL_ARP_IP_REG(idx)          (MV_PP2_WOL_ARP_IP0_REG + ((idx) << 2))
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_WOL_PTRN_NUM                 4
+#define MV_PP2_WOL_PTRN_BYTES               128
+#define MV_PP2_WOL_PTRN_REGS                (MV_PP2_WOL_PTRN_BYTES / 4)
+
+#define MV_PP2_WOL_WAKEUP_EN_REG            (MV_PP2_REG_BASE + 0x420)
+#define MV_PP2_WOL_INTR_CAUSE_REG           (MV_PP2_REG_BASE + 0x424)
+#define MV_PP2_WOL_INTR_MASK_REG            (MV_PP2_REG_BASE + 0x428)
+
+/* Bits are the same for all three registers above */
+#define MV_PP2_WOL_PTRN_IDX_BIT(idx)        (0 + (idx))
+#define MV_PP2_WOL_PTRN_IDX_MASK(idx)       (1 << MV_PP2_WOL_PTRN_IDX_BIT(idx))
+
+#define MV_PP2_WOL_MAGIC_PTRN_BIT           4
+#define MV_PP2_WOL_MAGIC_PTRN_MASK          (1 << MV_PP2_WOL_MAGIC_PTRN_BIT)
+
+#define MV_PP2_WOL_ARP_IP0_BIT              5
+#define MV_PP2_WOL_ARP_IP1_BIT              6
+#define MV_PP2_WOL_ARP_IP_MASK(idx)         (1 << (MV_PP2_WOL_ARP_IP0_BIT + (idx)))
+
+#define MV_PP2_WOL_UCAST_BIT                7
+#define MV_PP2_WOL_UCAST_MASK               (1 << MV_PP2_WOL_UCAST_BIT)
+
+#define MV_PP2_WOL_MCAST_BIT                8
+#define MV_PP2_WOL_MCAST_MASK               (1 << MV_PP2_WOL_MCAST_BIT)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_WOL_PTRN_SIZE_REG            (MV_PP2_REG_BASE + 0x430)
+
+#define MV_PP2_WOL_PTRN_SIZE_BITS           8
+#define MV_PP2_WOL_PTRN_SIZE_MAX            ((1 << MV_PP2_WOL_PTRN_SIZE_BITS) - 1)
+#define MV_PP2_WOL_PTRN_SIZE_MAX_MASK(i)    (MV_PP2_WOL_PTRN_SIZE_MAX << ((i) << MV_PP2_WOL_PTRN_SIZE_BITS))
+#define MV_PP2_WOL_PTRN_SIZE_MASK(i, s)     ((s) << ((i) * MV_PP2_WOL_PTRN_SIZE_BITS))
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_WOL_PTRN_IDX_REG             (MV_PP2_REG_BASE + 0x434)
+#define MV_PP2_WOL_PTRN_DATA_REG(i)         (MV_PP2_REG_BASE + 0x500 + ((i) << 2))
+#define MV_PP2_WOL_PTRN_MASK_REG(i)         (MV_PP2_REG_BASE + 0x580 + ((i) << 2))
+
+#define MV_PP2_WOL_PTRN_DATA_BYTE_MASK(i)   (0xFF << ((i) * 8))
+#define MV_PP2_WOL_PTRN_DATA_BYTE(i, b)     ((b)  << ((i) * 8))
+#define MV_PP2_WOL_PTRN_MASK_BIT(i)         (1    << ((i) * 8))
+/*---------------------------------------------------------------------------------------------*/
+
+/* WoL APIs */
+void      mvPp2WolRegs(void);
+void      mvPp2WolStatus(void);
+MV_STATUS mvPp2WolSleep(int port);
+MV_STATUS mvPp2WolWakeup(void);
+int       mvPp2WolIsSleep(int *port);
+MV_STATUS mvPp2WolMagicDaSet(MV_U8 *mac_da);
+MV_STATUS mvPp2WolArpIpSet(int idx, MV_U32 ip);
+MV_STATUS mvPp2WolPtrnSet(int idx, int size, MV_U8 *data, MV_U8 *mask);
+MV_STATUS mvPp2WolArpEventSet(int idx, int enable);
+MV_STATUS mvPp2WolMcastEventSet(int enable);
+MV_STATUS mvPp2WolUcastEventSet(int enable);
+MV_STATUS mvPp2WolMagicEventSet(int enable);
+MV_STATUS mvPp2WolPtrnEventSet(int idx, int enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __mvPp2Wol_h__ */
-- 
1.7.5.4

