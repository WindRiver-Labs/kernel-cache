From dd3f46af95f6349b413d8c7eef1352fbb6d7b590 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Sun, 9 Jun 2013 14:47:49 +0300
Subject: [PATCH 0710/1825] PPv2: delete unnecessary CONFIGs, enable GRO and
 RXCHKSUM via ethtool

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b49ec8b69fbe97e1d0724dcd0f8a31d411dad688

Change-Id: I244cd46187dd4e783979ea39231b76db6853873f
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2182
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Star_Automation <star@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   46 ---------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |  106 --------------------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c  |    2 -
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   40 +-------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    7 +-
 5 files changed, 5 insertions(+), 196 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index ec25e36..5002cd3 100755
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -471,58 +471,12 @@ endmenu
 
 menu "IP/TCP/UDP Offloading"
 
-config  MV_ETH_TX_CSUM_OFFLOAD
-        bool "L3/L4 TX checksum offload support for Marvell network interface"
-        default y
-        ---help---
-	Marvell network driver compiled with TCP/UDP over IPv4/IPv6 TX checksum offload support.
-
-config MV_ETH_TX_CSUM_OFFLOAD_DEF
-	depends on MV_ETH_TX_CSUM_OFFLOAD
-        bool "Default value for L3/L4 TX checksum offload: enable/disable"
-        default y
-        ---help---
-	Can be changed in run-time using ethtool
-
-config  MV_ETH_RX_CSUM_OFFLOAD
-        bool "L3/L4 RX checksum offload support for Marvell network interface"
-        default y
-        ---help---
-        Marvell network driver compiled with TCP/UDP over IPv4/IPv6 RX checksum offload support.
-
-config MV_ETH_RX_CSUM_OFFLOAD_DEF
-	depends on MV_ETH_RX_CSUM_OFFLOAD
-        bool "Default value for L3/L4 RX checksum offload: enable/disable"
-        default y
-        ---help---
-	Can be changed in run-time using ethtool
-
-config  MV_ETH_GRO
-        bool "GRO Support for Marvell network interface"
-	default y
-        ---help---
-        Marvell network driver compiled with GRO (Generic Receive Offload) support.
-
-config  MV_ETH_GRO_DEF
-	depends on MV_ETH_GRO
-        bool "Default value for GRO feature: enable/disable"
-	default n
-        ---help---
-        Can be changed in run-time using ethtool
-
 config  MV_ETH_TSO
         bool "TSO Support for Marvell network interface"
 	default y
         ---help---
         Marvell network driver compiled with TSO (TCP Segmentation Offload) support.
 
-config  MV_ETH_TSO_DEF
-	depends on MV_ETH_TSO
-        bool "Default value for TSO feature: enable/disable"
-	default n
-        ---help---
-	Can be changed in run-time using ethtool
-
 endmenu
 
 menu "Control and Statistics"
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index ae2b4c1..0372049 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -636,112 +636,6 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 }
 
 /******************************************************************************
-* mv_eth_tool_get_rx_csum
-* Description:
-*	ethtool get RX checksum offloading status
-* INPUT:
-*	netdev		Network device structure pointer
-* OUTPUT
-*	None
-* RETURN:
-*	RX checksum
-*
-*******************************************************************************/
-u32 mv_eth_tool_get_rx_csum(struct net_device *netdev)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	return (priv->rx_csum_offload != 0);
-#else
-	return 0;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_rx_csum
-* Description:
-*	ethtool enable/disable RX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_rx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	priv->rx_csum_offload = data;
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tx_csum
-* Description:
-*	ethtool enable/disable TX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
-	if (data) {
-		if (netdev->mtu > MV_ETH_TX_CSUM_MAX_SIZE) {
-			printk(KERN_ERR "Cannot set TX checksum when MTU > %d\n", MV_ETH_TX_CSUM_MAX_SIZE);
-			return -EOPNOTSUPP;
-		}
-		netdev->features |= NETIF_F_IP_CSUM;
-	} else {
-		netdev->features &= ~NETIF_F_IP_CSUM;
-	}
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif /* TX_CSUM_OFFLOAD */
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tso
-* Description:
-*	ethtool enable/disable TCP segmentation offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tso(struct net_device *netdev, uint32_t data)
-{
-#if defined(CONFIG_MV_ETH_TSO)
-	if (data)
-		netdev->features |= NETIF_F_TSO;
-	else
-		netdev->features &= ~NETIF_F_TSO;
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-/******************************************************************************
 * mv_eth_tool_get_strings
 * Description:
 *	ethtool get strings (used for statistics and self-test descriptions)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
index 54ed3cd..ce5f0360 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
@@ -100,7 +100,6 @@ int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev)
 
 	skb->protocol = eth_type_trans(skb, dev);
 
-#ifdef CONFIG_MV_ETH_GRO
 	if (dev->features & NETIF_F_GRO) {
 		int group = pp->cpu_config[smp_processor_id()]->napi_group_id;
 
@@ -109,7 +108,6 @@ int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev)
 		STAT_DBG(pp->stats.rx_gro_bytes += skb->len);
 		return napi_gro_receive(pp->napi_group[group]->napi, skb);
 	}
-#endif /*CONFIG_MV_ETH_GRO*/
 
 	return netif_receive_skb(skb);
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 0cef5c5..f9ce1f1d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -1345,7 +1345,6 @@ EXPORT_SYMBOL(mv_eth_refill);
 
 static inline MV_U32 mv_eth_skb_tx_csum(struct eth_port *pp, struct sk_buff *skb)
 {
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		int   ip_hdr_len = 0;
 		MV_U8 l4_proto;
@@ -1372,7 +1371,6 @@ static inline MV_U32 mv_eth_skb_tx_csum(struct eth_port *pp, struct sk_buff *skb
 
 		return mvPp2TxqDescCsum(skb_network_offset(skb), skb->protocol, ip_hdr_len, l4_proto);
 	}
-#endif /* CONFIG_MV_ETH_TX_CSUM_OFFLOAD */
 
 	STAT_DBG(pp->stats.tx_csum_sw++);
 	return PP2_TX_L4_CSUM_NOT | PP2_TX_IP_CSUM_DISABLE_MASK;
@@ -3280,11 +3278,6 @@ oom:
 /* Show network driver configuration */
 void mv_eth_config_show(void)
 {
-	/* Check restrictions */
-#if defined(CONFIG_MV_ETH_TSO) && !defined(CONFIG_MV_ETH_TX_CSUM_OFFLOAD)
-#   error "If GSO enabled - TX checksum offload must be enabled too"
-#endif
-
 	printk(KERN_ERR "  o %d Giga ports supported\n", mv_eth_ports_num);
 
 #ifdef CONFIG_MV_PON
@@ -3296,10 +3289,6 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o SKB recycle supported (%s)\n", mv_ctrl_recycle ? "Enabled" : "Disabled");
 #endif
 
-#ifdef CONFIG_MV_ETH_NETA
-	printk(KERN_ERR "  o NETA acceleration mode %d\n", mvNetaAccMode());
-#endif
-
 	printk(KERN_ERR "  o BM supported for CPU: %d BM pools\n", MV_ETH_BM_POOLS);
 
 #ifdef CONFIG_MV_ETH_HWF
@@ -3318,13 +3307,6 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o GSO supported\n");
 #endif /* CONFIG_MV_ETH_TSO */
 
-#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
-	printk(KERN_ERR "  o Receive checksum offload supported\n");
-#endif
-#if defined(CONFIG_MV_ETH_TX_CSUM_OFFLOAD)
-	printk(KERN_ERR "  o Transmit checksum offload supported\n");
-#endif
-
 #ifdef CONFIG_MV_ETH_STAT_ERR
 	printk(KERN_ERR "  o Driver ERROR statistics enabled\n");
 #endif
@@ -3352,34 +3334,24 @@ void mv_eth_config_show(void)
 /* Set network device features on initialization. Take into account default compile time configuration. */
 void mv_eth_netdev_init_features(struct net_device *dev)
 {
-	dev->features |= NETIF_F_SG | NETIF_F_LLTX;
-	dev->hw_features |= NETIF_F_SG;
-
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
-	dev->hw_features |= NETIF_F_IP_CSUM;
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD_DEF
-	dev->features |= NETIF_F_IP_CSUM;
-#endif
-#endif
+	dev->features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_LLTX;
+	dev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG;
 
 #ifdef CONFIG_MV_ETH_TSO
-	dev->hw_features |= NETIF_F_TSO;
-#ifdef CONFIG_MV_ETH_TSO_DEF
 	dev->features |= NETIF_F_TSO;
-#endif
+	dev->hw_features |= NETIF_F_TSO;
 #endif
 }
 
 static netdev_features_t mv_eth_netdev_fix_features(struct net_device *dev, netdev_features_t features)
 {
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
 	if (dev->mtu > MV_ETH_TX_CSUM_MAX_SIZE)
 		if (features & (NETIF_F_IP_CSUM | NETIF_F_TSO)) {
 			features &= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);
 			printk(KERN_ERR "%s: NETIF_F_IP_CSUM and NETIF_F_TSO not supported for mtu larger %d bytes\n",
 				dev->name, MV_ETH_TX_CSUM_MAX_SIZE);
 		}
-#endif /* CONFIG_MV_ETH_TX_CSUM_OFFLOAD */
+
 	return features;
 }
 
@@ -4201,10 +4173,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	}
 #endif /* CONFIG_MV_PON */
 
-#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD_DEF)
-	pp->rx_csum_offload = 1;
-#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD_DEF */
-
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		memset(&cpuCtrl->tx_done_timer, 0, sizeof(struct timer_list));
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 38afbc6..f3398d5 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -369,9 +369,6 @@ struct eth_port {
 	__u8                duplex_cfg;
 	__u8                autoneg_cfg;
 	__u16		    advertise_cfg;
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	MV_U32              rx_csum_offload;
-#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	void    (*rx_special_proc)(int port, int rxq, struct net_device *dev,
 					struct sk_buff *skb, struct pp2_rx_desc *rx_desc);
@@ -468,8 +465,7 @@ extern struct eth_port **mv_eth_ports;
 
 static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_desc, struct sk_buff *skb)
 {
-#if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
-	if (pp->rx_csum_offload) {
+	if (pp->dev->features & NETIF_F_RXCSUM) {
 		if ((PP2_RX_L3_IS_IP4(rx_desc->status) && !PP2_RX_IP4_HDR_ERR(rx_desc->status)) ||
 			(PP2_RX_L3_IS_IP6(rx_desc->status))) {
 			if ((PP2_RX_L4_IS_UDP(rx_desc->status) || PP2_RX_L4_IS_TCP(rx_desc->status)) &&
@@ -481,7 +477,6 @@ static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_de
 			}
 		}
 	}
-#endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
 
 	skb->ip_summed = CHECKSUM_NONE;
 	STAT_DBG(pp->stats.rx_csum_sw++);
-- 
1.7.5.4

