From 8eb7c88962fe58ebf48d6e1d5e62e8f789af4318 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Sun, 4 May 2014 11:45:43 +0300
Subject: [PATCH 1635/1825] pp3: add host fw functions

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit d829da1a73c99f501183aff60143a68708074226

	- Add new file mv_dev_fw_if.c
	- Implement host to fw interface
	- Update few fileds in netdev structures that necessary for config
	- Messages sync mechanisem is not implement yet

Change-Id: Ic09f0476fdded7f4fc20913c042253809c9191ad
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7822
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Makefile          |    2 +-
 .../net/ethernet/marvell/pp3/fw/mv_host_fw_if.h    |   73 ++++--
 .../ethernet/marvell/pp3/net_dev/mv_dev_fw_if.c    |  317 ++++++++++++++++++++
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |   21 +-
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.h   |   11 +-
 .../marvell/pp3/net_dev/mv_netdev_structs.h        |    5 +-
 6 files changed, 389 insertions(+), 40 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_fw_if.c

diff --git a/drivers/net/ethernet/marvell/pp3/Makefile b/drivers/net/ethernet/marvell/pp3/Makefile
index 87c08fb..4ad7484 100644
--- a/drivers/net/ethernet/marvell/pp3/Makefile
+++ b/drivers/net/ethernet/marvell/pp3/Makefile
@@ -9,6 +9,6 @@ ccflags-y       += -Idrivers/net/ethernet/marvell/pp3
 mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o emac/mv_emac.o
 mv_pp3-objs += emac/mv_emac_sysfs.o hmac/mv_hmac_sysfs.o net_dev/mv_dev_sysfs.o net_dev/mv_dev_bm_sysfs.o net_dev/mv_dev_dbg.o
 mv_pp3-objs += gmac/mv_gmac.o fw/mv_channel_if.o fw/mv_channel_sysfs.o common/mv_stack.o common/mv_pp3_config.o
-mv_pp3-objs += fw/mv_fw.o fw/mv_fw_sysfs.o
+mv_pp3-objs += fw/mv_fw.o fw/mv_fw_sysfs.o net_dev/mv_dev_fw_if.o
 mv_pp3-objs += bm/mv_bm.o bm/mv_bm_sysfs.o bm/mv_bm_regs.o
 mv_pp3-objs += qm/mv_qm.o qm/mv_qm_regs.o qm/mv_qm_sysfs.o
diff --git a/drivers/net/ethernet/marvell/pp3/fw/mv_host_fw_if.h b/drivers/net/ethernet/marvell/pp3/fw/mv_host_fw_if.h
index 61e55f6..a2fad8f 100644
--- a/drivers/net/ethernet/marvell/pp3/fw/mv_host_fw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/fw/mv_host_fw_if.h
@@ -1,10 +1,11 @@
-/*#include "mvCopyright.h"*/
 
 #ifndef __mvFwIf_h__
 #define __mvFwIf_h__
 
-#define MV_CFH_MSG_OFFS (32)  /* bytes */
-#define MV_CFH_MSG_DG_OFFS (MV_CFH_MSG_OFFS/MV_PP3_HMAC_DG_SIZE)  /* datagramm */
+#define MV_CFH_MSG_OFFS		(32)  /* bytes */
+#define MV_CFH_MSG_DG_OFFS	(2)	/* bytes */
+
+#define MV_PHYS_SWQ_NUM(_queue_, _frame_)	(_queue_ + 16 * _frame_)
 
 /* CFH modes */
 enum mv_pp3_cfh_mode {
@@ -75,12 +76,12 @@ enum mv_pp3_fw_nic_msg_opcode {
 	MV_FW_L2_FILTER_SET
 };
 
-
-enum mv_pp3_fw_l2_fltr_mode {
-	L2_FLTR_DROP_ALL = 0,
-	L2_FLTR_NON_PROMISC,
-	L2_FLTR_ALL_MC,
-	L2_FLTR_PROMISC
+/* l2 filter mode types */
+enum mv_pp3_fw_l2_filter_mode {
+	L2_FILTER_DROP_ALL = 0,
+	L2_FILTER_NON_PROMISC,
+	L2_FILTER_ALL_MC,
+	L2_FILTER_PROMISC
 };
 
 /* Create communication channel between Host and Firmware - MV_FW_MSG_CHAN_CFG - 8 bytes */
@@ -89,21 +90,21 @@ struct mv_pp3_msg_chan_cfg {
 	unsigned char	hmac_sw_rxq;
 	unsigned short	hmac_hw_rxq;
 	unsigned char	bm_pool_id;
-	unsigned short	pool_buf_size;
 	unsigned char	buf_headroom;
+	unsigned short	pool_buf_size;
 };
 
 /* Create virtual port for all EMACs - MV_FW_EMAC_VPORT_ADD - 26 bytes */
 struct mv_pp3_fw_vp_create {
-	unsigned char		emac_vport_id;
-	unsigned char		rss_profile_id;   /* 0 - RSS disable, 1-4 - RSS profle ID */
-	unsigned char		qos_profile_id;   /* 0 - QOS disable, 1-4 - QOS profle ID */
-	unsigned char		hmac_sw_rxq_base; /* HMAC_SW_RXQ base when no RSS applied */
-	unsigned short		hmac_hw_rxq_base;
-	unsigned short		emac_hw_rxq;
+	unsigned char		vport_id;
+	unsigned char		hmac_sw_rxq_base[CONFIG_NR_CPUS];	/* HMAC_SW_RXQ base for each cpu */
+	unsigned char		hmac_sw_rxq_num[CONFIG_NR_CPUS];	/* HMAC_SW_RXQ num for each cpu */
+	unsigned char		rss_profile_id;				/* 0 - RSS disable, 1-4 - RSS profle ID */
+	unsigned char		qos_profile_id;				/* 0 - QOS disable, 1-4 - QOS profle ID */
 	unsigned char		ucast_mac[6];
-	unsigned char		l2_filter_mode;   /* one from enum mv_pp3_fw_l2_fltr_mode */
+	unsigned char		l2_filter_mode;				/* one from enum mv_pp3_fw_l2_filter_mode */
 	unsigned char		reserved;
+	unsigned short		emac_hw_rxq;				/* QM queue from EMAC to PPC */
 	unsigned short		tpid_first[2];
 	unsigned short		tpid_second[2];
 	unsigned short		mtu;
@@ -112,15 +113,22 @@ struct mv_pp3_fw_vp_create {
 /* HMAC out queue configuration message definition - MV_FW_HMAC_SW_RXQ_SET - 4 bytes */
 struct mv_pp3_fw_hmac_rxq_cfg {
 	unsigned char	hmac_sw_rxq;
-	char		bm_pool_short;  /* -1 - short pool is not exist */
+	unsigned char	hmac_hw_rxq_num;
+	unsigned short	hmac_hw_rxq_base;	/*PPC to HMAC HWQ base to be used when relevant SWQ chosen */
+	char		reserved;
+	char		bm_short_pool;		/* -1 - short pool is not exist */
+	char		bm_lro_pool;		/* -1 - LRO pool is not exist, LRO can't be enabled */
 	unsigned char	bm_long_pool;
-	char		bm_lro_pool;    /* -1 - LRO pool is not exist, LRO can't be enabled */
+
+
 };
 
 /* BM pool configuration - MV_FW_BM_POOL_SET - 4 bytes */
-struct mv_pp3_fw_bmp_cfg {
+struct mv_pp3_fw_bm_pool_cfg {
 	unsigned char bm_pool_num;
 	unsigned char buf_headroom;
+	unsigned char pe_size; /* 0 = one pool element, 1 = two pool elements */
+	char	      reserved;
 	unsigned short buf_size;
 };
 
@@ -135,9 +143,10 @@ struct mv_pp3_fw_rss_cfg {
 	unsigned char rss_profile;
 	unsigned char hash_type;		/* one from mv_pp3_fw_rss_hash_types */
 	unsigned char hmac_sw_rxq_base[16];	/* HMAC RXQ base for each HASH value */
+	char	      reserved;
 };
 
-/* QoS profile configuration - MV_FW_QOS_PROFILE_SET - 90 bytes */
+/* QoS profile configuration - MV_FW_QOS_PROFILE_SET */
 enum mv_pp3_fw_qos_modes {
 	MV_PP3_QOS_MODE_DISABLED = 0,
 	MV_PP3_QOS_DSCP_VPRIO,
@@ -154,5 +163,27 @@ struct mv_pp3_fw_qos_cfg {
 	unsigned char prio_swq_update[8];	/* value to be added to HMAC_SW_RXQ base per packet prio */
 };
 
+struct mv_pp3_mgmt_type_add {
+	unsigned char vport;
+	unsigned char type;
+	unsigned char hwq_base;
+	unsigned char swq_base;
+};
+
+/* Add/Delete multicast mac address
+	MV_FW_MCAST_MAC_ADD
+	MV_FW_MCAST_MAC_DEL
+*/
+
+struct mv_pp3_mcast {
+	unsigned char vport;
+	unsigned char mcast_mac[MV_MAC_ADDR_SIZE];
+};
+
+/* Set l2 filter mode */
+struct mv_pp3_l2_filter {
+	unsigned char vport;
+	unsigned char mode;   /* one from enum mv_pp3_fw_l2_filter_mode */
+};
 
 #endif /* __mvFwIf_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_fw_if.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_fw_if.c
new file mode 100644
index 0000000..7642e93
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_dev_fw_if.c
@@ -0,0 +1,317 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "common/mv_sw_if.h"
+#include "net_dev/mv_netdev_structs.h"
+#include "fw/mv_host_fw_if.h"
+#include "fw/mv_channel_if.h"
+
+
+static int pp3_chan_id[CONFIG_NR_CPUS];
+
+/*---------------------------------------------------------------------------
+description:
+	Set chanel id
+---------------------------------------------------------------------------*/
+
+void pp3_set_chan_id(int cpu, int chan_id)
+{
+	pp3_chan_id[cpu] = chan_id;
+}
+
+/*---------------------------------------------------------------------------
+description:
+	Create virtual port for all EMACs
+	Send MV_FW_EMAC_VPORT_ADD message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_emac_port_set(struct pp3_dev_priv *dev_priv)
+{
+	struct mv_pp3_fw_vp_create msg;
+	int ret_val, cpu, chan_id = pp3_chan_id[smp_processor_id()];
+	struct pp3_group *grp_ctrl;
+
+	msg.vport_id = (unsigned char)dev_priv->index;
+	msg.emac_hw_rxq = (unsigned char)dev_priv->qm_q;
+
+	/*Disable RSS  and QOS*/
+	msg.rss_profile_id = 0;
+	msg.qos_profile_id = 0;
+
+	msg.l2_filter_mode = L2_FILTER_PROMISC;
+	msg.mtu = dev_priv->dev->mtu;
+	memcpy(msg.ucast_mac, dev_priv->dev->dev_addr, MV_MAC_ADDR_SIZE);
+
+	for_each_possible_cpu(cpu) {
+		grp_ctrl = dev_priv->groups[cpu];
+
+		msg.hmac_sw_rxq_base[cpu] = MV_PHYS_SWQ_NUM(grp_ctrl->rxqs[0]->swq, grp_ctrl->rxqs[0]->frame_num);
+
+		msg.hmac_sw_rxq_num[cpu] = grp_ctrl->rxqs_num;
+	}
+
+	/* set default vlan 0x8100 0x88A8 */
+	msg.tpid_first[0] = 0x00;
+	msg.tpid_first[1] = 0x81;
+	msg.tpid_second[0] = 0xA8;
+	msg.tpid_second[1] = 0x88;
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, MV_FW_EMAC_VPORT_ADD);
+
+	return ret_val;
+}
+
+/*---------------------------------------------------------------------------
+description:
+	HMAC out queue configuration
+	Send MV_FW_HMAC_SW_RXQ_SET message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+
+int pp3_fw_swq_set(int logic_rxq, struct pp3_group *group_ctrl)
+{
+	struct mv_pp3_fw_hmac_rxq_cfg msg;
+	int ret_val, rxq;
+	int chan_id = pp3_chan_id[smp_processor_id()];
+
+	rxq = MV_PHYS_SWQ_NUM(group_ctrl->rxqs[logic_rxq]->swq, group_ctrl->rxqs[logic_rxq]->frame_num);
+	msg.hmac_sw_rxq = (unsigned char)rxq;
+
+	msg.hmac_hw_rxq_base = (unsigned short)group_ctrl->rxqs[logic_rxq]->hwq_base;
+	msg.hmac_hw_rxq_num = (unsigned char)group_ctrl->rxqs[logic_rxq]->hwq_num;
+	msg.bm_long_pool = (unsigned char)group_ctrl->long_pool->pool;
+/*
+	Disable lro and short pool
+	msg.bm_pool_lro =  (char)(group_ctrl->lro_pool ? group_ctrl->lro_pool->pool : -1);
+	msg.bm_pool_short = (char)(group_ctrl->short_pool ? group_ctrl->short_pool->pool : -1);
+*/
+
+	msg.bm_lro_pool = -1;
+	msg.bm_short_pool = -1;
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, MV_FW_HMAC_SW_RXQ_SET);
+	return ret_val;
+
+}
+
+/*---------------------------------------------------------------------------
+description:
+	BM pool configurationn
+	Send MV_FW_BM_POOL_SET message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_bm_pool_set(struct pp3_pool *pool)
+{
+	struct mv_pp3_fw_bm_pool_cfg msg;
+	int ret_val, chan_id = pp3_chan_id[smp_processor_id()];
+
+	msg.bm_pool_num = pool->pool;
+	msg.buf_headroom = pool->headroom;
+	msg.buf_size = pool->buf_size;
+	/* pair mode */
+	msg.pe_size = 1;
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, MV_FW_BM_POOL_SET);
+	return ret_val;
+
+}
+
+/*---------------------------------------------------------------------------
+description:
+	RSS profile configuration
+	Send MV_FW_RSS_PROFILE_SET message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_rss_profile(int id, int hash_type, unsigned char swq_base[16])
+{
+	struct mv_pp3_fw_rss_cfg msg;
+	int ret_val, chan_id = pp3_chan_id[smp_processor_id()];
+
+	msg.rss_profile = (unsigned char)id;
+	msg.hash_type = (unsigned char)hash_type;
+
+	memcpy(msg.hmac_sw_rxq_base, swq_base, sizeof(swq_base));
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, MV_FW_RSS_PROFILE_SET);
+	return ret_val;
+}
+
+/*---------------------------------------------------------------------------
+description:
+	Add/Delete multicast MAC addres
+	Send MV_FW_MCAST_MAC_ADD or MV_FW_MCAST_MAC_DEL message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_port_mcast_addr(unsigned char *addr, int add, struct pp3_dev_priv *dev_priv)
+{
+	struct mv_pp3_mcast msg;
+	int opcode;
+	int ret_val, chan_id = pp3_chan_id[smp_processor_id()];
+
+	msg.vport = (unsigned char)dev_priv->index;
+	memcpy(msg.mcast_mac, addr, MV_MAC_ADDR_SIZE);
+
+	opcode = add ? MV_FW_MCAST_MAC_ADD : MV_FW_MCAST_MAC_DEL;
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, opcode);
+	return ret_val;
+
+}
+
+/*---------------------------------------------------------------------------
+description:
+	Add/Delete multicast MAC addres
+	Send MV_FW_L2_FILTER_SET message
+
+return values:
+		success: sequence id number
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_port_l2_filter_mode(int mode, struct pp3_dev_priv *dev_priv)
+{
+	struct mv_pp3_l2_filter msg;
+	int ret_val, chan_id = pp3_chan_id[smp_processor_id()];
+
+	msg.vport = (unsigned char)dev_priv->index;
+	msg.mode = (unsigned char)mode;
+
+	ret_val = mv_pp3_msg_send(chan_id, (void *)&msg, sizeof(msg), 0, MV_FW_L2_FILTER_SET);
+	return ret_val;
+}
+
+/*---------------------------------------------------------------------------
+description:
+	Update FW according to port sw structure
+
+return values:
+		success: 0
+		fail: -1
+---------------------------------------------------------------------------*/
+
+int pp3_fw_port_update(struct pp3_dev_priv *dev_priv)
+{
+	int cpu, rxq;
+
+	struct pp3_group *grp_ctrl;
+	struct	pp3_cpu	*cpu_ctrl;
+
+	for_each_possible_cpu(cpu) {
+
+		grp_ctrl = dev_priv->groups[cpu];
+		cpu_ctrl = grp_ctrl->cpu_ctrl;
+
+		/* set rss profile*/
+		/* set qos profile*/
+
+		pp3_chan_id[smp_processor_id()] = grp_ctrl->cpu_ctrl->chan_id;
+
+		/* init only long pool, lro and short pools are not in used */
+		pp3_fw_bm_pool_set(grp_ctrl->long_pool);
+
+		/*
+		   in case of SMP the same tx_done_pool can be init more than once,
+		   it is not suppose to do any damage
+		*/
+		pp3_fw_bm_pool_set(cpu_ctrl->tx_done_pool);
+
+		for (rxq = 0; rxq < grp_ctrl->rxqs_num; rxq++)
+			pp3_fw_swq_set(rxq, grp_ctrl);
+	}
+
+	pp3_fw_emac_port_set(dev_priv);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+description:
+	Channel callback function
+
+---------------------------------------------------------------------------*/
+void pp3_chan_callback(int chan, void *msg, int size)
+{
+	/* TODO: lock / release*/
+}
+/*---------------------------------------------------------------------------*/
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index 3512eae..2fab4da 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -531,13 +531,6 @@ int pp3_pool_add(int pool, int buf_num, int frame, int queue)
 }
 
 /*---------------------------------------------------------------------------*/
-/* channel callback function						     */
-/*---------------------------------------------------------------------------*/
-void pp3_chan_callback(int chan, void *msg, int size)
-{
-	/* TODO: lock / release*/
-}
-/*---------------------------------------------------------------------------*/
 
 static const struct net_device_ops mv_pp3_netdev_ops = {
 	.ndo_open            = mv_pp3_dev_open,
@@ -591,9 +584,6 @@ struct net_device *mv_pp3_netdev_init(struct platform_device *pdev)
 
 	dev_priv->dev = dev;
 	dev_priv->index = pdev->id;
-	dev_priv->rxqs_num = rxqs_num;
-	dev_priv->txqs_num = txqs_num;
-
 
 	/*mv_eth_netdev_init_features*/
 	if (register_netdev(dev) < 0) {
@@ -706,14 +696,15 @@ static int mv_pp3_dev_priv_init(struct pp3_dev_priv *dev_priv)
 		if (!group)
 			goto oom;
 
-		group->rxqs_num = dev_priv->rxqs_num / nr_cpu_ids;
+		/* TODO: take rxq num from plat data*/
+		group->rxqs_num = nr_cpu_ids;
 		group->rxqs = kzalloc(sizeof(struct pp3_rxq *) * group->rxqs_num, GFP_KERNEL);
 
 		if (!group->rxqs)
 			goto oom;
 
-
-		group->txqs_num = dev_priv->txqs_num / nr_cpu_ids;
+		/* TODO: take txq num from plat data*/
+		group->txqs_num = nr_cpu_ids;
 		group->txqs = kzalloc(sizeof(struct pp3_txq *) * group->txqs_num, GFP_KERNEL);
 
 		if (!group->txqs)
@@ -1333,8 +1324,8 @@ void pp3_netdev_dev_status_print(int index)
 	dev_priv = pp3_ports[index];
 
 	pr_info("/n");
-	pr_info("interface #%d: dev = 0x%p, flags = 0x%lu, rss_id = %d, rxqs_num= %d, txqs_num = %d\n",
-		index, dev_priv->dev, dev_priv->flags, dev_priv->rss_id, dev_priv->rxqs_num,  dev_priv->txqs_num);
+	pr_info("interface #%d: dev = 0x%p, flags = 0x%lu, rss_id = %d\n",
+		index, dev_priv->dev, dev_priv->flags, dev_priv->rss_id);
 	return;
 }
 /*---------------------------------------------------------------------------*/
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
index 6000b8a..5661b99 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.h
@@ -47,12 +47,12 @@ disclaimer.
 #define MV_PP3_LONG_POOL_SIZE		1024
 #define MV_PP3_SHORT_POOL_SIZE		1024
 #define MV_PP3_LRO_POOL_SIZE		1024
+#define MV_PP3_POOL_HEADROOM_SIZE	96
 #define MV_PP3_HMAC_BM_Q_SIZE		1024
 #define MV_PP3_GPM_POOL_0		0
 #define MV_PP3_GPM_POOL_1		1
 #define MV_PP3_DRAM_POOL_0		2
 #define MV_PP3_DRAM_POOL_1		3
-#define MV_PP3_FRM_TIME_COAL_NUM	2
 #define MV_PP3_FRM_TIME_COAL_0		64
 #define MV_PP3_RXQ_TIME_COAL_DEF_PROF	0
 #define MV_PP3_TXQ_TIME_COAL_DEF_PROF	0
@@ -78,6 +78,15 @@ int pp3_pool_dbg_push(int pool, int buf_num);
 int pp3_pool_dbg_dump(int pool, int v);
 int pp3_pool_add(int pool, int buf_num, int frame, int queue);
 
+/*------------------------------------------------------------------------------*/
+/*				Host FW API					*/
+/*------------------------------------------------------------------------------*/
+
+int  pp3_fw_port_update(struct pp3_dev_priv *dev_priv);
+int  pp3_fw_port_l2_filter_mode(int mode, struct pp3_dev_priv *dev_priv);
+int  pp3_fw_port_mcast_addr(unsigned char *addr, int add, struct pp3_dev_priv *dev_priv);
+int  pp3_fw_rss_profile(int id, int hash_type, unsigned char swq_base[16]);
+void pp3_chan_callback(int chan, void *msg, int size);
 /*---------------------------------------------------------------------------*/
 /*				extern parameters			     */
 /*---------------------------------------------------------------------------*/
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
index ff1de7e..631976b 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
@@ -34,6 +34,7 @@ disclaimer.
 #define CONFIG_MV_ETH_RX_POLL_WEIGHT 64
 #define CONFIG_PP3_RX_COAL_USEC 10
 #define CONFIG_PP3_RX_COAL_PKTS 100
+#define MV_PP3_FRM_TIME_COAL_NUM 2
 
 /* Timer */
 #define MV_CPU_TX_DONE_TIMER_PERIOD 10
@@ -48,8 +49,7 @@ struct pp3_dev_priv {
 	struct net_device	*dev;
 	unsigned long		flags;
 	int			rss_id;
-	int			rxqs_num;
-	int			txqs_num;
+	int			qm_q;
 
 };
 
@@ -177,6 +177,7 @@ struct	pp3_pool {
 	int pool;
 	int capacity;
 	int buf_num;
+	int headroom;
 	int buf_size;
 	void *virt_base;
 	unsigned long phys_base;
-- 
1.7.5.4

