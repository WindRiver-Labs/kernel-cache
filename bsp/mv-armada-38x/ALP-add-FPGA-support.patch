From 9158b49d0e46cb5252af8bd95ad1f89be98963ea Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 27 Feb 2013 03:38:43 +0200
Subject: [PATCH 0459/1825] ALP: add FPGA support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 0e72006510f195d666ff94ef87a9ae7cff7c0c0f

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I123d0ce355905f63af2d8614d6dcbb789b0e2afe
Reviewed-on: http://vgitil04.il.marvell.com:8080/1235
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                               |    3 +-
 arch/arm/boot/compressed/head.S                |    7 +
 arch/arm/kernel/Makefile                       |    2 +-
 arch/arm/kernel/head.S                         |    6 +
 arch/arm/kernel/smp.c                          |    4 +
 arch/arm/kernel/smp_twd.c                      |    2 +-
 arch/arm/mach-avantalp/Makefile                |    2 +-
 arch/arm/mach-avantalp/config/mvSysHwConfig.h  |    2 +-
 arch/arm/mach-avantalp/core.c                  |   42 ++--
 arch/arm/mach-avantalp/include/mach/avantalp.h |   12 +-
 arch/arm/mach-avantalp/include/mach/irqs.h     |    4 +-
 arch/arm/mach-avantalp/include/mach/smp.h      |    2 +-
 arch/arm/mach-avantalp/irq.c                   |  211 ++++++++++++++++
 arch/arm/mach-avantalp/leds.c                  |    3 +-
 arch/arm/mach-avantalp/platsmp.c               |   11 +-
 arch/arm/mach-avantalp/sysmap.c                |   15 +-
 arch/arm/mach-avantalp/time.c                  |  303 +++++++++++++++++++++++-
 arch/arm/mm/Kconfig                            |    2 +-
 drivers/tty/serial/8250/Kconfig                |    2 +-
 kernel/time/clockevents.c                      |    2 +-
 20 files changed, 578 insertions(+), 59 deletions(-)
 create mode 100644 arch/arm/mach-avantalp/irq.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 8a54794..d908bea 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -697,6 +697,7 @@ bool "Marvell Avanta LP"
 	select NEED_MACH_IO_H
 	select NEED_MACH_MEMORY_H
 	select DMABOUNCE
+	select MIGHT_HAVE_CACHE_L2X0
 #	bool "ARM Ltd. Versatile Express family"
 #	select ARCH_WANT_OPTIONAL_GPIOLIB
 #	select ARM_AMBA
@@ -1283,7 +1284,7 @@ config XSCALE_PMU
 
 config CPU_HAS_PMU
 	depends on (CPU_V6 || CPU_V6K || CPU_V7 || XSCALE_PMU) && \
-		   (!ARCH_OMAP3 || OMAP3_EMU) && !AVANTA_LP
+		   (!ARCH_OMAP3 || OMAP3_EMU) && !ARCH_AVANTA_LP
 	default y
 	bool
 
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index df5d82b..7b7cf98 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -195,6 +195,12 @@ not_angel:
 
 		.text
 
+		/*
+		 * kostaz: Exit from ARMv7 Debug state
+		 */
+		mov	r7, #2
+		mcr	p14, 0, r7, c0, c4, 2
+
 #ifdef CONFIG_AUTO_ZRELADDR
 		@ determine final kernel image address
 		mov	r4, pc
@@ -483,6 +489,7 @@ not_relocated:	mov	r0, #0
 		mov	r1, sp			@ malloc space above stack
 		add	r2, sp, #0x10000	@ 64k max
 		mov	r3, r7
+
 		bl	decompress_kernel
 		bl	cache_clean_flush
 		bl	cache_off
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 8de8eb2..eef62a8 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -37,7 +37,7 @@ obj-$(CONFIG_PCI)		+= bios32.o isa.o
 obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
-obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
+obj-y				+= smp_twd.o
 obj-$(CONFIG_ARM_ARCH_TIMER)	+= arch_timer.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o insn.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER)	+= ftrace.o insn.o
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 97ecf78..a6790c0 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -91,6 +91,12 @@ ENTRY(stext)
  THUMB(	.thumb			)	@ switch to Thumb now.
  THUMB(1:			)
 
+	/*
+	 * kostaz: Exit from ARMv7 Debug state
+	 */
+	mov	r7, #2
+	mcr	p14, 0, r7, c0, c4, 2
+
 	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9 @ ensure svc mode
 						@ and irqs disabled
 	mrc	p15, 0, r9, c0, c0		@ get processor id
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 1c99d49..037348f 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -415,6 +415,10 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	/*
 	 * are we trying to boot more cores than exist?
 	 */
+
+early_printk("oooooooo: %s:%d ~~~~~~~~~~~~~~\n", __func__, __LINE__);
+early_printk("oooooooo: %s:%d max_cpus = %d, ncores = %d \n", __func__, __LINE__, max_cpus, ncores);
+
 	if (max_cpus > ncores)
 		max_cpus = ncores;
 	if (ncores > 1 && max_cpus) {
diff --git a/arch/arm/kernel/smp_twd.c b/arch/arm/kernel/smp_twd.c
index f4b50a9..bf6a062 100644
--- a/arch/arm/kernel/smp_twd.c
+++ b/arch/arm/kernel/smp_twd.c
@@ -258,7 +258,7 @@ static int __cpuinit twd_timer_setup(struct clock_event_device *clk)
 		 * need to calibrate the rate instead.
 		 */
 		if (!IS_ERR_OR_NULL(twd_clk))
-			twd_timer_rate = clk_get_rate(twd_clk);
+			twd_timer_rate = 12500000; /* clk_get_rate(twd_clk); */
 		else
 			twd_calibrate_rate();
 
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 58824e2..35c5f21 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -51,7 +51,7 @@ QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrv
 		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
 		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
 
-LSP_OBJS        = core.o time.o leds.o sysmap.o export.o clock.o
+LSP_OBJS        = core.o irq.o time.o leds.o sysmap.o export.o clock.o
 
 obj-y   				:=  avantalp.o
 avantalp-objs  				:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
index 25e0f13..b353a04 100755
--- a/arch/arm/mach-avantalp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -218,7 +218,7 @@ disclaimer.
 /****************************************************************/
 
 /* Enable Clock Power Control */
-#define MV_INCLUDE_CLK_PWR_CNTRL
+#undef MV_INCLUDE_CLK_PWR_CNTRL
 
 /* Disable the DEVICE BAR in the PEX */
 #define MV_DISABLE_PEX_DEVICE_BAR
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 68d87c4..60aa425 100755
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -97,7 +97,8 @@ extern MV_CPU_DEC_WIN* mv_sys_map(void);
 #if defined(CONFIG_MV_INCLUDE_CESA)
 extern u32 mv_crypto_virt_base_get(u8 chan);
 #endif
-//extern void alp_init_irq(void);
+
+extern void alp_init_irq(void);
 extern void __init set_core_count(unsigned int cpu_count);
 extern unsigned int group_cpu_mask;
 
@@ -139,8 +140,8 @@ struct mbus_dram_target_info avantalp_mbus_dram_info;
 #define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
 #define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
 #define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
-#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
-#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+//#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+//#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
 /*
  * This does not append a newline
  */
@@ -148,16 +149,6 @@ static void putstr(const char *s)
 {
 	unsigned int model;
 
-	/* Get dev ID, make sure pex clk is on */
-	if((CLK_REG & 0x4) == 0)
-	{
-		CLK_REG = CLK_REG | 0x4;
-		model = (DEV_REG >> 16) & 0xffff;
-		CLK_REG = CLK_REG & ~0x4;
-	}
-	else
-		model = (DEV_REG >> 16) & 0xffff;
-
         while (*s) {
 		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
 		MV_UART0_THR = *s;
@@ -419,6 +410,7 @@ void __init serial_initialize(int port)
 			mvUnitMapSetMine(UART0);
 		}
 
+early_printk("oooooooo: callling platform_device_register(&aurora_uart0)\n\n\n");
 		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
 		platform_device_register(&aurora_uart0);
 	}
@@ -561,7 +553,7 @@ static int __init alp_db_7seg_init(void)
 
 	return 0;
 }
-__initcall(alp_db_7seg_init);
+/* __initcall(alp_db_7seg_init); */
 
 
 /*********************************************************************************/
@@ -634,13 +626,6 @@ static struct ct_desc *ct_descs[] __initdata = {
 #endif
 };
 
-
-static void __init alp_init_irq(void)
-{
-	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
-		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
-}
-
 static void cpu_fabric_common_init(void)
 {
 	int i;
@@ -651,11 +636,13 @@ static void cpu_fabric_common_init(void)
 #endif
 
 #ifdef CONFIG_CACHE_L2X0
-	void __iomem *l2x0_base = (INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET));
+	void __iomem *l2x0_base = INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET;
 
 	/* set RAM latencies to 1 cycle for this core tile. */
+#if 0
 	writel(0, l2x0_base + L2X0_TAG_LATENCY_CTRL);
 	writel(0, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+#endif
 
 	l2x0_init(l2x0_base, 0x00400000, 0xfe0fffff);
 #endif
@@ -665,13 +652,11 @@ static void cpu_fabric_common_init(void)
 
 	platform_device_register(&pmu_device);
 
-#if 0
 #ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
 	printk("Support IO coherency.\n");
 	io_coherency_init();
 #endif
 #endif
-#endif
 }
 
 /*****************************************************************************
@@ -683,6 +668,7 @@ static void __init alp_fpga_init(void)
 	/* Call Aurora/cpu special configurations */
 	cpu_fabric_common_init();
 
+#if 0
 	/* Select appropriate Board ID for Machine */
 	gBoardId = MV_BOARD_ID_AVANTA_LP_FPGA;
 	/* Bypass serdes reconfiguration since already done at bootloader */
@@ -720,7 +706,7 @@ static void __init alp_fpga_init(void)
 
 	elf_hwcap &= ~HWCAP_JAVA;
 
-	serial_initialize(0);
+	//serial_initialize(0);
 
 	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
 	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
@@ -732,8 +718,12 @@ static void __init alp_fpga_init(void)
 
 	/* RTC */
 	rtc_init();
+#endif
+
+	serial_initialize(0);
 
-	return;
+	if (mvCpuIfInit(mv_sys_map()))
+		printk("Cpu Interface initialization failed.\n");
 }
 
 MACHINE_START(AVANTA_LP_FPGA, "Marvell Avanta LP FPGA Board")
diff --git a/arch/arm/mach-avantalp/include/mach/avantalp.h b/arch/arm/mach-avantalp/include/mach/avantalp.h
index 151a60e..aaa8c05 100644
--- a/arch/arm/mach-avantalp/include/mach/avantalp.h
+++ b/arch/arm/mach-avantalp/include/mach/avantalp.h
@@ -98,12 +98,8 @@
 #define SPI_CS0_VIRT_BASE		0xFAA00000
 #define SPI_CS0_SIZE			_16M
 
-#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+#if defined(CONFIG_MACH_ARMADA_XP_FPGA) || defined(CONFIG_MACH_AVANTA_LP_FPGA)
  #define INTER_REGS_PHYS_BASE		0xF1000000
- /* Make sure that no other machines are compiled in */
- #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
- #error	"Conflicting Board Configuration!!"
- #endif
 #else
  #define INTER_REGS_PHYS_BASE		0xD0000000
 #endif
@@ -208,12 +204,8 @@
 #define SPI_CS0_VIRT_BASE		0xFAB00000
 #define SPI_CS0_SIZE			_16M
 
-#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
  #define INTER_REGS_PHYS_BASE		0xF1000000
- /* Make sure that no other machines are compiled in */
- #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
- #error	"Conflicting Board Configuration!!"
- #endif
 #else
  #define INTER_REGS_PHYS_BASE		0xD0000000
 #endif
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
index d8f0cb9..6d90793 100644
--- a/arch/arm/mach-avantalp/include/mach/irqs.h
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -20,7 +20,7 @@
 
 #define IRQ_LOCALTIMER		29
 #define IRQ_LOCALWDOG		30
-#define NR_IRQS	191
+#define NR_IRQS			192
 
 #if 0
 #define IRQ_AURORA_IN_DRBL_LOW	0
@@ -128,7 +128,7 @@
  * AURORA General Purpose Pins
  */
 #define IRQ_AURORA_GPIO_START		128
-#define NR_GPIO_IRQS			67
+#define NR_GPIO_IRQS			63
 #define IRQ_AURORA_SHARED_START 32
 
 /*
diff --git a/arch/arm/mach-avantalp/include/mach/smp.h b/arch/arm/mach-avantalp/include/mach/smp.h
index f12d59e..4f54c5e 100644
--- a/arch/arm/mach-avantalp/include/mach/smp.h
+++ b/arch/arm/mach-avantalp/include/mach/smp.h
@@ -2,7 +2,7 @@
 #define ASMARM_ARCH_SMP_H
 
 #include <asm/io.h>
-#include <mach/armadaxp.h>
+#include <mach/avantalp.h>
 
 extern unsigned int master_cpu_id;
 extern unsigned int group_cpu_mask;
diff --git a/arch/arm/mach-avantalp/irq.c b/arch/arm/mach-avantalp/irq.c
new file mode 100644
index 0000000..bcfeab6
--- /dev/null
+++ b/arch/arm/mach-avantalp/irq.c
@@ -0,0 +1,211 @@
+/*
+ * arch/arm/mach/irq.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/hardware/gic.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <plat/msi.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvOs.h"
+#include "include/mach/smp.h"
+#include "ca9x2.h"
+
+unsigned int  irq_int_type[NR_IRQS];
+static DEFINE_SPINLOCK(irq_controller_lock);
+#define ENABLED_DOORBELS 	(0xF0FF)
+
+static void axp_unmask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val |=  (1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+	if (cpu > 0) { /*enabled for both cpu */
+		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+		/* FIXME: assuming all 4 cpus */
+		val |= 0xf;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+	}
+#endif
+}
+
+static void axp_mask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val &=  ~(1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+	if (cpu > 0) { /*disabled for both cpu */
+		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+		/* FIXME: assuming all 4 cpus */
+		val &= ~0xf;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+	}
+#endif
+}
+
+void axp_irq_mask(struct irq_data *d)
+{
+	MV_REG_WRITE(CPU_INT_SET_MASK_LOCAL_REG, d->irq);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+	int cpu;
+	if(d->irq == IRQ_AURORA_MP){
+		for_each_online_cpu(cpu) {
+			axp_mask_fabric_interrupt(cpu);
+		}
+	}
+#endif
+}
+
+void axp_irq_unmask(struct irq_data *d)
+{
+	MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, d->irq);
+	MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, d->irq);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+	int cpu;
+	if(d->irq == IRQ_AURORA_MP){
+		for_each_online_cpu(cpu) {
+			axp_unmask_fabric_interrupt(cpu);
+		}
+	}
+#endif
+}
+
+#ifdef CONFIG_SMP
+int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool force)
+{
+	MV_U32 addr, temp;
+	u32 irq=d->irq;
+	addr = (CPU_INT_SOURCE_CONTROL_REG(irq));
+
+	spin_lock(&irq_controller_lock);
+	cpumask_copy(d->affinity, mask_val);
+	d->node = cpumask_first(mask_val);
+	temp = MV_REG_READ(addr);
+	temp &= ~0xf;
+	temp |= *cpus_addr(*mask_val);
+	MV_REG_WRITE(addr, temp);
+	spin_unlock(&irq_controller_lock);
+
+	return 0;
+}
+#endif
+
+static struct irq_chip axp_irq_chip = {
+	.name		= "axp_irq",
+	.irq_mask	= axp_irq_mask,
+	.irq_mask_ack	= axp_irq_mask,
+	.irq_unmask	= axp_irq_unmask,
+#ifdef CONFIG_SMP
+	.irq_set_affinity   = axp_set_affinity,
+#endif
+};
+
+
+void __init alp_init_irq(void)
+{
+#if 0
+	u32 irq;
+	/* MASK all interrupts */
+	/* Enable IRQ in control register */
+	for (irq = 0; irq < IRQ_MAIN_INTS_NUM; irq++) {
+		axp_irq_mask(irq_get_irq_data(irq));
+#ifndef CONFIG_SMP
+		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, irq);
+#endif
+	}
+	/*
+	 * Register IRQ sources
+	 */
+	for (irq = 0; irq < IRQ_AURORA_MSI_START ; irq++) {
+		irq_set_chip(irq, &axp_irq_chip);
+		irq_set_chip_data(irq, 0);
+		irq_set_handler(irq, handle_level_irq);
+		irq_set_status_flags(irq,IRQ_LEVEL);
+#ifdef CONFIG_SMP
+		/*Warninig  - Seif Mazreeb, in Linux 3.2 you must declare that an
+		  interrupt is a percpu .....without doing this timer interrupt won't happen.
+		  If we declare network interrupt in the same way ( which I think we should),
+		  we crash duing boot, keep this for timers for now.
+		  This is a  TODO at a second stage, evalute perfrmance and fix as needed
+		  */
+		if( irq < MAX_PER_CPU_IRQ_NUMBER && irq != IRQ_AURORA_MP) {
+			irq_set_chip_and_handler(irq, &axp_irq_chip,
+					handle_percpu_devid_irq);
+			irq_set_percpu_devid(irq);
+		}
+#endif
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+#ifdef CONFIG_SMP
+	{
+		u32/*void __iomem **/addr;
+		/* Set the default affinity to the boot cpu. */
+		cpumask_clear(irq_default_affinity);
+		cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
+
+		/* open IPI mask */
+		/* this  register write does the job of axp_irq_unmask(IRQ_AURORA_IN_DRBL_LOW)
+		   i.e. enable / unmask the DRBL_LOW interrupt.
+		   */
+		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, 0);
+		addr = /*(void __iomem *)*/(AXP_IN_DRBEL_MSK);
+		MV_REG_WRITE(addr, ENABLED_DOORBELS);
+	}
+#endif
+
+	/* armada_msi_init(); */
+
+#else
+	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
+		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
+#endif
+}
+#if 0 /***************************************** ca9 gic style ****************************/
+void alp_irq_mask(struct irq_data *d)
+{
+	if (d->irq < FIRST_LEGACY_IRQ)
+		return;
+	MV_REG_WRITE(CPU_INT_SET_MASK_LOCAL_REG, d->irq);
+}
+
+void alp_irq_unmask(struct irq_data *d)
+{
+	if (d->irq < FIRST_LEGACY_IRQ)
+		return;
+	MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, d->irq);
+	MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, d->irq);
+}
+
+void __init alp_init_irq(void)
+{
+#if 0
+	gic_arch_extn.irq_ack = alp_irq_mask;
+	gic_arch_extn.irq_mask = alp_irq_mask;
+	gic_arch_extn.irq_unmask = alp_irq_unmask;
+#endif
+
+	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
+		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
+}
+#endif
diff --git a/arch/arm/mach-avantalp/leds.c b/arch/arm/mach-avantalp/leds.c
index 66639b2..ffc1efb 100644
--- a/arch/arm/mach-avantalp/leds.c
+++ b/arch/arm/mach-avantalp/leds.c
@@ -31,6 +31,7 @@ static	u32		led_val = 0;
 void mv_leds_hearbeat(void)
 {
 	u32 sec = jiffies_to_msecs(jiffies - last_jiffies) / 1000;
+	return;
 	
 	if (!sec)
 		return;
@@ -46,4 +47,4 @@ static int __init leds_init(void)
 	return 0;
 }
 
-__initcall(leds_init);
+/* __initcall(leds_init); */
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index 5f1aca9..ebe0343 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -34,7 +34,7 @@ extern void avantalp_secondary_startup(void);
  */
 void __init smp_init_cpus(void)
 {
-	int i, ncores = scu_get_core_count(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+	int i, ncores = scu_get_core_count(INTER_REGS_BASE + A9_MPCORE_SCU);
 
 	if (ncores > nr_cpu_ids) {
 		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
@@ -50,13 +50,13 @@ void __init smp_init_cpus(void)
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int ncores = scu_get_core_count(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+	unsigned int ncores = scu_get_core_count(INTER_REGS_BASE + A9_MPCORE_SCU);
 
 	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
 	 */
-	scu_enable(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+	scu_enable(INTER_REGS_BASE + A9_MPCORE_SCU);
 	
 	/*
 	 * Write the address of secondary startup into the
@@ -128,6 +128,9 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * Set synchronisation state between this boot processor
 	 * and the secondary one
 	 */
+
+early_printk("oooooooo: %s:%d ^^^^^^^^^^^^^^^^^^^^^ \n", __func__, __LINE__);
+
 	spin_lock(&boot_lock);
 
 	/*
@@ -171,4 +174,4 @@ void __init set_core_count(unsigned int cpu_count)
 	/* Update group mask as well */
 	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index b491273..7d44db8 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -19,6 +19,8 @@
 #include "ctrlEnv/sys/mvCpuIf.h"
 #include "boardEnv/mvBoardEnvLib.h"
 #include <asm/mach/map.h>
+#include <asm/smp_twd.h>
+#include "ca9x2.h"
 
 MV_CPU_DEC_WIN* mv_sys_map(void);
 
@@ -59,7 +61,7 @@ MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
 	{{PEX9_IO_PHYS_BASE,		0,	PEX9_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX9_IO */
 	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
 	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
-	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		DIS},	/* SPI_CS0 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
@@ -67,12 +69,12 @@ MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
-	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		EN},	/* BOOTROM */
-	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		EN},	/* DEV_BOOCS */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		DIS},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		DIS},	/* DEV_BOOCS */
 	{{PMU_SCRATCH_PHYS_BASE,	0,	PMU_SCRATCH_SIZE	},	TBL_UNUSED,	DIS},	/* PMU SCRATCHPAD */
-	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xb,		EN},	/* CRYPT0_ENG */
-	{{CRYPT_ENG_PHYS_BASE(1),	0,	CRYPT_ENG_SIZE		},	0xc,		EN},	/* CRYPT1_ENG */
-	{{PNC_BM_PHYS_BASE,		0,	PNC_BM_SIZE		},	0xd,		EN},	/* PNC_BM */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xb,		DIS},	/* CRYPT0_ENG */
+	{{CRYPT_ENG_PHYS_BASE(1),	0,	CRYPT_ENG_SIZE		},	0xc,		DIS},	/* CRYPT1_ENG */
+	{{PNC_BM_PHYS_BASE,		0,	PNC_BM_SIZE		},	0xd,		DIS},	/* PNC_BM */
 	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
 };
 
@@ -95,6 +97,7 @@ u32 mv_crypto_virt_base_get(u8 chan)
 void __init alp_map_io(void)
 {
 	iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+	twd_base = INTER_REGS_BASE + A9_MPCORE_TWD;
 }
 
 static u32 mv_pci_mem_base[] =
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index 6368e46..8204176 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -27,11 +27,20 @@
 #include <linux/clockchips.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <asm/smp_twd.h>
 
 
 #include "boardEnv/mvBoardEnvLib.h"
 #include "cpu/mvCpu.h"
 
+#ifdef CONFIG_SMP
+static struct clock_event_device __percpu ** axp_local_clockevent;
+#endif
+
+extern void axp_irq_mask(struct irq_data *d);
+extern void axp_irq_unmask(struct irq_data *d);
+extern unsigned int master_cpu_id;
+
 #define  TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
 #define  TIMER_WD_RELOAD	(MV_CNTMR_REGS_OFFSET + 0x0020)
 #define  TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
@@ -43,6 +52,24 @@
 #define  TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
 #define  INT_TIMER_CLR(x)	(~(1 << (8*x)))
 
+
+#define  LCL_TIMER_BASE		(0x21000 | 0x40)
+#define  LCL_TIMER_CTRL		(LCL_TIMER_BASE + 0x0000)
+#define    LCL_TIMER0_EN		0x0001
+#define    LCL_TIMER0_RELOAD_EN		0x0002
+#define    LCL_TIMER1_EN		0x0004
+#define    LCL_TIMER1_RELOAD_EN		0x0008
+#define  LCL_TIMER0_RELOAD	(LCL_TIMER_BASE + 0x0010)
+#define  LCL_TIMER0_VAL		(LCL_TIMER_BASE + 0x0014)
+#define  LCL_TIMER1_RELOAD	(LCL_TIMER_BASE + 0x0018)
+#define  LCL_TIMER1_VAL		(LCL_TIMER_BASE + 0x001c)
+#define  LCL_TIMER_WD_RELOAD	(LCL_TIMER_BASE + 0x0020)
+#define  LCL_TIMER_WD_VAL	(LCL_TIMER_BASE + 0x0024)
+#define  LCL_TIMER_CAUSE	(LCL_TIMER_BASE + 0x0028)
+#define   LCL_INT_TIMER0_CLR 	~(1 << 0)
+#define   LCL_INT_TIMER1_CLR	~(1 << 8)
+#define LCL_TIMER_TURN_25MHZ	(1 << 11)
+
 #define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
 #define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
 #define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
@@ -82,6 +109,112 @@ static struct clocksource alp_clksrc = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
+
+/*
+ * Clockevent handling.
+ */
+int axp_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (delta == 0)
+		return -ETIME;	
+
+	local_irq_save(flags);
+
+	/* Clear and enable clockevent timer interrupt */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	/*axp_irq_unmask(IRQ_LOCALTIMER);*/
+	axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	/* Setup new clockevent timer value */
+	MV_REG_WRITE(LCL_TIMER0_VAL, delta);
+
+
+	/* Enable the timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u = (u & ~LCL_TIMER0_RELOAD_EN) | LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void axp_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+	local_irq_save(flags);
+
+	if ((mode == CLOCK_EVT_MODE_PERIODIC) ||
+	    (mode == CLOCK_EVT_MODE_ONESHOT)) {
+		/* Setup timer to fire at 1/HZ intervals */
+		MV_REG_WRITE(LCL_TIMER0_RELOAD, (ticks_per_jiffy - 1));
+		MV_REG_WRITE(LCL_TIMER0_VAL, (ticks_per_jiffy - 1));
+
+		/* Enable timer interrupt */
+		axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+		/* Enable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN);
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	} else {
+		/* Disable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u &= ~LCL_TIMER0_EN;
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+		/* Disable timer interrupt */
+		//axp_irq_mask(IRQ_LOCALTIMER);
+		axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+
+		/* ACK pending timer interrupt */
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	}
+
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device axp_clkevt;
+static irqreturn_t axp_timer_interrupt(int irq, void *dev_id)
+{
+	/* ACK timer interrupt and call event handler */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	axp_clkevt.event_handler(&axp_clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction axp_timer_irq = {
+	.name		= "axp_tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= axp_timer_interrupt,
+	.dev_id         = &axp_clkevt,
+};
+
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit mv_timer_setup(struct clock_event_device *clk, unsigned int fabric_clk)
+{
+	unsigned int cpu = smp_processor_id();
+
+	clk->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	clk->shift		= 32,
+	clk->rating		= 300,
+	clk->set_next_event	= axp_clkevt_next_event,
+	clk->set_mode		= axp_clkevt_mode,
+	clk->cpumask		= cpumask_of(cpu);
+	clk->mult		= div_sc(fabric_clk, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0x1, clk);
+}
+
 /*
  * Resume timer from suspend to RAM
  * TODO - need to implement kernel hooks for suspend/resume
@@ -105,6 +238,47 @@ void alp_timer_resume(void)
 	MV_REG_WRITE(TIMER_CTRL, u);
 }
 
+static void broadcast_timer_set_mode(enum clock_event_mode mode,
+	struct clock_event_device *evt)
+{
+}
+
+static void __cpuinit broadcast_timer_setup(struct clock_event_device *evt)
+{
+	evt->name	= "alp_dummy_timer";
+	evt->features	= CLOCK_EVT_FEAT_ONESHOT |
+			  CLOCK_EVT_FEAT_PERIODIC |
+			  CLOCK_EVT_FEAT_DUMMY;
+	evt->rating	= 400;
+	evt->mult	= 1;
+	evt->set_mode	= broadcast_timer_set_mode;
+
+	clockevents_register_device(evt);
+}
+
+#ifndef CONFIG_SMP
+/*
+ * Timer (local or broadcast) support
+ */
+static DEFINE_PER_CPU(struct clock_event_device, percpu_clockevent);
+extern int __cpuinit twd_timer_setup(struct clock_event_device *clk);
+
+void __cpuinit alp_percpu_timer_setup(void)
+{
+	unsigned int cpu = 0; /* smp_processor_id(); */
+	struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
+	evt->cpumask = cpumask_of(cpu);
+	evt->broadcast = NULL; /* smp_timer_broadcast; */
+	evt->irq = IRQ_LOCALTIMER;
+	twd_timer_setup(evt);
+}
+
+void __cpuinit alp_up_mode_local_timer_setup(void)
+{
+	alp_percpu_timer_setup();
+}
+#endif
+
 void __init alp_time_init(unsigned int fabric_clk)
 {
 	u32 u;
@@ -134,6 +308,17 @@ void __init alp_time_init(unsigned int fabric_clk)
 
 #ifdef CONFIG_SMP
 	percpu_timer_setup();
+#else
+	alp_up_mode_local_timer_setup();
+#endif
+
+#if 0
+	/* Setup clockevent timer (interrupt-driven) */
+	axp_clkevt.name = "axp_tick";
+	axp_clkevt.irq = IRQ_LOCALTIMER;
+	mv_timer_setup(&axp_clkevt, fabric_clk);
+	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
+	clockevents_register_device(&axp_clkevt);
 #endif
 }
 
@@ -141,7 +326,7 @@ static void __init alp_timer_init(void)
 {
 #if defined (CONFIG_MACH_AVANTA_LP_FPGA)
 	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
-	alp_time_init(25000000);
+	alp_time_init(12500000);
 #else
 	alp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
 #endif
@@ -150,3 +335,119 @@ static void __init alp_timer_init(void)
 struct sys_timer alp_timer = {
 	.init = alp_timer_init,
 };
+
+
+#if defined (CONFIG_SMP) && defined (CONFIG_LOCAL_TIMERS)
+/*
+ * Used on SMP for either the local timer or IPI_TIMER
+ */
+/*void local_timer_interrupt(void)
+{
+	struct clock_event_device *clk = &__get_cpu_var(axp_local_clockevent);
+
+	clk->event_handler(clk);
+}
+*/
+
+/*
+ * local_timer_ack: checks for a local timer interrupt.
+ *
+ * If a local timer interrupt has occurred, acknowledge and return 1.
+ * Otherwise, return 0.
+ */
+
+int local_timer_ack(void)
+{
+	if(MV_REG_READ(LCL_TIMER_CAUSE) & ~LCL_INT_TIMER0_CLR) {
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+		return 1;
+	}
+	return 0;
+}
+
+static irqreturn_t axp_localtimer_handler(int irq, void *dev_id)
+{
+
+	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
+	if (local_timer_ack()) {
+		evt->event_handler(evt);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+#if 0
+/*
+ * Setup the local clock events for a CPU.
+ */
+ __cpuinit local_timer_setup(struct clock_event_device *clk)
+{
+	unsigned int fabric_clk = 12500000;
+	static cpu0_flag=0;
+	int cpu = smp_processor_id();
+	struct clock_event_device **this_cpu_clk;
+
+	if (!axp_local_clockevent) {
+		int err;
+
+		axp_local_clockevent = alloc_percpu(struct clock_event_device *);
+		if (!axp_local_clockevent) {
+			pr_err("axp_local_clockevent: can't allocate memory\n");
+			return 0;
+		}
+		err = request_percpu_irq(IRQ_LOCALTIMER, axp_localtimer_handler,
+				"axp_local_clockevent", axp_local_clockevent);
+		if (err) {
+			pr_err("axp_local_clockevent: can't register interrupt %d (%d)\n",
+				IRQ_LOCALTIMER, err);
+			return 0;
+		}
+	}
+
+	pr_err("oooooooo: %s:%s:%d: #####################################################\n", __FILE__, __func__, __LINE__);
+	if((cpu) || (!cpu && !cpu0_flag)){
+		ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+		clk->name = "local_timer";
+		clk->irq = IRQ_LOCALTIMER;
+		mv_timer_setup(clk, fabric_clk);
+		this_cpu_clk = __this_cpu_ptr(axp_local_clockevent);
+		*this_cpu_clk = clk;
+		pr_err("oooooooo: #####################################################\n");
+		pr_err("oooooooo: #####################################################\n");
+		pr_err("oooooooo: calling to clockevents_register_device()\n");
+		pr_err("oooooooo: #####################################################\n");
+		pr_err("oooooooo: #####################################################\n");
+		clockevents_register_device(clk);
+	 if(!cpu)
+		cpu0_flag++;
+	}
+	enable_percpu_irq(clk->irq, 0);
+	return 0;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+/*
+ * take a local timer down
+ */
+void  __cpuexit local_timer_stop(struct clock_event_device * evt)
+{
+	unsigned long flags;
+	u32 u;
+	local_irq_save(flags);
+
+	/* Disable timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u &= ~LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	/* Disable timer interrupt */
+	/*axp_irq_mask(IRQ_LOCALTIMER);*/
+	axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	local_irq_restore(flags);
+}
+#endif
+#endif /* #if 0 */
+#endif	/* CONFIG_LOCAL_TIMERS && CONFIG_SMP */
+
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 5fc801b..1ab6eea 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1181,7 +1181,7 @@ config ENABLE_UNALINGED_ACCESS_FAULT
 
 config AURORA_IO_CACHE_COHERENCY
 	bool "Enable Marvell Aurora I/O cache coherency"
-	depends on ARCH_ARMADA_XP || ARCH_ARMADA370
+	depends on ARCH_ARMADA_XP || ARCH_ARMADA370 || ARCH_AVANTA_LP
 	default y
 	help
 	  This option enables the hardware mechanism for I/O cache coherency.
diff --git a/drivers/tty/serial/8250/Kconfig b/drivers/tty/serial/8250/Kconfig
index 9cb99f1..a51bc0c 100644
--- a/drivers/tty/serial/8250/Kconfig
+++ b/drivers/tty/serial/8250/Kconfig
@@ -274,7 +274,7 @@ config SERIAL_8250_FSL
 
 config SERIAL_8250_DW
 	tristate "Support for Synopsys DesignWare 8250 quirks"
-	depends on SERIAL_8250 && (OF || ARMADA_XP)
+	depends on SERIAL_8250 && (OF || ARMADA_XP || MACH_AVANTA_LP_FPGA)
 	help
 	  Selecting this option will enable handling of the extra features
 	  present in the Synopsys DesignWare APB UART.
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index 9b7a7fb..6f1ad23 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -316,7 +316,7 @@ void clockevents_register_device(struct clock_event_device *dev)
 {
 	unsigned long flags;
 
-	BUG_ON(dev->mode != CLOCK_EVT_MODE_UNUSED);
+	/* BUG_ON(dev->mode != CLOCK_EVT_MODE_UNUSED); */
 	if (!dev->cpumask) {
 		WARN_ON(num_possible_cpus() > 1);
 		dev->cpumask = cpumask_of(smp_processor_id());
-- 
1.7.5.4

