From 15936c05730d6c62c7bafb0b98da7798af5b7837 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 23 Jan 2013 16:44:41 +0200
Subject: [PATCH 0445/1825] AXP: fix boot by disabling CPU Idle support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 98e186b9b415604a46c71f5f73a2854158c28cc8

Change-Id: I99b5757e9119e7e642d59811b3e9810b7034e951

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/armada_xp_v7smp_defconfig |    5 -
 arch/arm/plat-armada/cpuidle.c             |   42 +---------
 arch/arm/plat-armada/cpuidle.h             |    4 +
 arch/arm/plat-armada/hotplug.c             |    7 +-
 arch/arm/plat-armada/suspend.c             |  130 ++++-----------------------
 5 files changed, 28 insertions(+), 160 deletions(-)

diff --git a/arch/arm/configs/armada_xp_v7smp_defconfig b/arch/arm/configs/armada_xp_v7smp_defconfig
index 2d727c2..f08c996 100644
--- a/arch/arm/configs/armada_xp_v7smp_defconfig
+++ b/arch/arm/configs/armada_xp_v7smp_defconfig
@@ -24,7 +24,6 @@ CONFIG_MV_ETH_PORTS_NUM=4
 CONFIG_MV_ETH_RXQ=8
 CONFIG_MV_ETH_TXQ=8
 CONFIG_NET_SKB_HEADROOM=96
-CONFIG_MV_CESA_TOOL=y
 CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE=y
 CONFIG_MV_INCLUDE_PCI=y
 # CONFIG_MV_INCLUDE_LEGACY_NAND is not set
@@ -39,11 +38,8 @@ CONFIG_MV_ETH_TSO_DEF=y
 CONFIG_MV_ETH_RX_DESC_PREFETCH=y
 CONFIG_MV_ETH_RX_PKT_PREFETCH=y
 # CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA is not set
-CONFIG_MV_CESA_OCF=y
 # CONFIG_SWP_EMULATE is not set
 CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
-CONFIG_SHEEVA_DEEP_IDLE=y
-CONFIG_STANDBY_UART_WAKE=y
 CONFIG_PCI_DEBUG=y
 CONFIG_NO_HZ=y
 CONFIG_SMP=y
@@ -54,7 +50,6 @@ CONFIG_HIGHMEM=y
 CONFIG_UACCESS_WITH_MEMCPY=y
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CPU_IDLE=y
 CONFIG_VFP=y
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
 CONFIG_NET=y
diff --git a/arch/arm/plat-armada/cpuidle.c b/arch/arm/plat-armada/cpuidle.c
index 2bae093..69fbf93 100644
--- a/arch/arm/plat-armada/cpuidle.c
+++ b/arch/arm/plat-armada/cpuidle.c
@@ -18,9 +18,6 @@
 #include <asm/sections.h>
 #include <asm/suspend.h>
 #include <asm/vfp.h>
-#include <asm/pgalloc.h>
-#include <asm/idmap.h>
-
 #include <plat/cache-aurora-l2.h>
 #include <mach/smp.h>
 #include "ctrlEnv/sys/mvCpuIfRegs.h"
@@ -29,10 +26,6 @@
 #include "cpuidle.h"
 #include "mvOs.h"
 
-extern int armadaxp_cpu_resume(void);
-extern int armadaxp_cpu_suspend(unsigned long);
-extern int axp_secondary_startup(void);
-
 #ifdef CONFIG_CPU_IDLE
 #if defined CONFIG_ARMADA_DEEP_IDLE_SAVE_WINDOWS_STATE
 static MV_AHB_TO_MBUS_DEC_WIN ahbAddrDecWin[MAX_AHB_TO_MBUS_WINS];
@@ -41,34 +34,6 @@ static MV_ADDR_WIN ahbAddrWinRemap[MAX_AHB_TO_MBUS_WINS];
 
 static int device_registered;
 
-extern u32 identity_page_table_phys;
-
-unsigned long suspend_phys_addr(void * physaddr)
-{
-        return virt_to_phys(physaddr);
-}
-
-/*
- * Allocate initial page tables to allow the CPU to
- * enable the MMU safely.  This essentially means a set
- * of our "standard" page tables, with the addition of
- * a 1:1 mapping for the physical address of the kernel.
- */
-
-static int build_identity_page_table(void)
-{
-	pgd_t *pgd = pgd_alloc(&init_mm);
-	if (!pgd)
-		return -ENOMEM;
-
-	if (PHYS_OFFSET != PAGE_OFFSET) {
-		identity_mapping_add(pgd, __pa(_stext), __pa(_etext));
-		identity_mapping_add(pgd, __pa(_sdata), __pa(_edata)); /* is this needed?*/
-	}
-	identity_page_table_phys = virt_to_phys(*pgd);
-	return 0;
-}
-
 int pm_mode = DISABLED;
 int pm_support = WFI;
 
@@ -156,7 +121,7 @@ void mv_cpuidle_reset_cpu_win_state(void)
 #endif
 
 #ifdef CONFIG_HOTPLUG_CPU
-void __init armadaxp_fabric_prepare_hotplug(void)
+void armadaxp_fabric_prepare_hotplug(void)
 {
 	unsigned int processor_id = hard_smp_processor_id();
 	MV_U32  reg;
@@ -416,11 +381,6 @@ int armadaxp_init_cpuidle(void)
 
 	printk("Initializing Armada-XP CPU power management ");
 
-	if (build_identity_page_table()) {
-		printk(KERN_ERR "armadaxp_init_cpuidle: Failed to build identity page table\n");
-                return -ENOMEM;
-	}
-
 	armadaxp_fabric_setup_deepIdle();
 
 	driver->safe_state_index = -1;
diff --git a/arch/arm/plat-armada/cpuidle.h b/arch/arm/plat-armada/cpuidle.h
index 50f3e29..160ded5 100644
--- a/arch/arm/plat-armada/cpuidle.h
+++ b/arch/arm/plat-armada/cpuidle.h
@@ -13,6 +13,8 @@
 
 int armadaxp_snoop_dis_virt(void);
 int armadaxp_cpu_suspend(unsigned long);
+int armadaxp_powerdown(unsigned long);
+void armadaxp_cpu_resume(void);
 void armadaxp_fabric_setup_deepIdle(void);
 void armadaxp_fabric_prepare_deepIdle(void);
 void armadaxp_fabric_prepare_hotplug(void);
@@ -21,6 +23,8 @@ void armadaxp_deepidle(int power_state);
 void armadaxp_smp_prepare_idle(unsigned int processor_id);
 void armadaxp_smp_restore_idle(unsigned int processor_id);
 
+extern int axp_secondary_startup(void);
+
 typedef enum  {
 	DISABLED,
 	WFI,
diff --git a/arch/arm/plat-armada/hotplug.c b/arch/arm/plat-armada/hotplug.c
index 8f9241d..49b0416 100644
--- a/arch/arm/plat-armada/hotplug.c
+++ b/arch/arm/plat-armada/hotplug.c
@@ -93,19 +93,18 @@ void __ref platform_cpu_die(unsigned int cpu)
 	armadaxp_fabric_prepare_deepIdle();
 	armadaxp_fabric_prepare_hotplug();
 #endif
-#if defined CONFIG_AURORA_IO_CACHE_COHERENCY
+
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY) && defined(CONFIG_SHEEVA_DEEP_IDLE)
 	armadaxp_snoop_dis_virt();
 #endif
-	/* none zero means deepIdle wasn't entered and regret event happened */
 
 	platform_do_lowpower(cpu);
 
 	/*
 	 * bring this CPU back into the world of cache
 	 * coherency, and then restore interrupts - will never get here it.
-	   We will do it as part of the secondary boot flow
+	 * We will do it as part of the secondary boot flow
 	 */
-
 }
 
 int platform_cpu_disable(unsigned int cpu)
diff --git a/arch/arm/plat-armada/suspend.c b/arch/arm/plat-armada/suspend.c
index 2795b31..ee2ce18 100644
--- a/arch/arm/plat-armada/suspend.c
+++ b/arch/arm/plat-armada/suspend.c
@@ -25,6 +25,7 @@
 #include <asm/sections.h>
 #include <linux/export.h>
 #include <asm/sections.h>
+#include <asm/suspend.h>
 
 #include <../cpuidle.h>
 #include "ctrlEnv/sys/mvCpuIfRegs.h"
@@ -32,123 +33,22 @@
 #include "ctrlEnv/sys/mvCpuIf.h"
 #include "mvOs.h"
 
-void armadaxp_powerdown(void);
-void armadaxp_cpu_resume_pd(void);
 void smp_resume(void);
 
-static char *saved_training_space;
-
 /*
  * Store boot information used by bin header
  */
 #define  BOOT_INFO_ADDR		(0x3000)
 #define  BOOT_MAGIC_WORD	(0xDEADB002)
 #define  REG_LIST_END		(0xFFFFFFFF)
+#define  BOOTROM_INTER_REGS_PHYS_BASE	(0xD0000000)
 
 #define SDRAM_WIN_BASE_REG(x)	(0x20180 + (0x8*x))
 #define SDRAM_WIN_CTRL_REG(x)	(0x20184 + (0x8*x))
 #define MAX_CS_COUNT		4
 
-#define TRAINING_SPACE 		(10*1024)
-
 /*#define DEBUG_DDR_SELF_REFRESH*/
 
-/* Store/Restore 10KB in beginning of each DDR Chip Select 
- * since the DDR3 Training will overwrite this space
- */
-void armadaxp_save_training_space(void)
-{
-	char *store_addr;
-	int i, cs, ctrl,  base;
-	char *start[MAX_CS_COUNT];
-	char *last = (char*)0xFFFFFFFF;
-
-	pr_info("Storing training space\n");
-
-	/* Create a list of memory areas to save */
-	for (cs = 0; cs < MAX_CS_COUNT; cs++) {
-		ctrl = MV_REG_READ(SDRAM_WIN_CTRL_REG(cs));
-		base = MV_REG_READ(SDRAM_WIN_BASE_REG(cs));
-
-		if(ctrl & 0x1)
-			start[cs] = (char*) phys_to_virt(base);
-		else
-			start[cs] = last;
-	}
-
-	/* 
-	 * Allocate a buffer to store the memory 
-	 * Check that it deosnt overlap the store areas
-	 * */ 	
-
-	for (i = 0; i < 4; i++) {
-		store_addr = kmalloc(MAX_CS_COUNT * TRAINING_SPACE, GFP_KERNEL);
-
-		/* 
-		 * Make sure that the allocated buffer deosn't overlap
-		 * The DDR training space 
-		 */
-		for (cs = 0; cs < MAX_CS_COUNT; cs++) {
-			if ((start[cs] != last) &&
-			    (store_addr > start[cs])  &&
-			    (store_addr < (start[cs] + TRAINING_SPACE))) {
-				kfree(store_addr);
-				store_addr = 0;
-				break;
-			}
-		}	
-		if(store_addr)
-			break;
-	}
-
-	if(store_addr == 0) {
-		pr_info("Could not allocate space to store ddr trainig space\n");
-		return;
-	}
-
-	saved_training_space = store_addr;
-
-	/* Create a list of memory areas to save */
-	for(cs = 0; cs < MAX_CS_COUNT; cs++) {
-		if(start[cs] != last) {
-			memcpy(store_addr, start[cs],TRAINING_SPACE);
-			store_addr += TRAINING_SPACE;
-		}
-	}
-}
-
-void armadaxp_restore_training_space(void)
-{
-	char *store_addr;
-	int  cs, ctrl,  base;
-	char *start[MAX_CS_COUNT];
-	char *last = (char*)0xFFFFFFFF;
-
-	pr_info("Restoring training space\n");
-	
-	/* Create a list of memory areas to restore */
-	for (cs = 0; cs < MAX_CS_COUNT; cs++) {
-		ctrl = MV_REG_READ(SDRAM_WIN_CTRL_REG(cs));
-		base = MV_REG_READ(SDRAM_WIN_BASE_REG(cs));
-
-		if(ctrl & 0x1)
-			start[cs] = (char*) phys_to_virt(base);
-		else
-			start[cs] = last;
-	}
-
-	store_addr = saved_training_space;
-
-	/* Restore memory from buffer */
-	for (cs = 0; cs < MAX_CS_COUNT; cs++)
-	{
-		if (start[cs] != last) {
-			memcpy(start[cs], store_addr, TRAINING_SPACE);
-			store_addr += TRAINING_SPACE;
-		}
-	}
-}
-
 #ifdef DEBUG_DDR_SELF_REFRESH
 /* 
  * Write a pattern to memory and check it after resume
@@ -164,7 +64,8 @@ void write_pattern(void)
 	
 	ptr = ioremap(BASE_PATTERN,SIZE_PATTERN);
 	pattern_ptr = ptr;
-	pr_info("Writing pattern to %p(%p) + %x\n", ptr, (void*)virt_to_phys(ptr), SIZE_PATTERN);
+	pr_info("Writing pattern to %p(%p) + %x\n", ptr,
+		(void *)virt_to_phys(ptr), SIZE_PATTERN);
 
 	if(ptr == 0)
 	{
@@ -189,7 +90,8 @@ void test_pattern(void)
 	if(pattern_ptr == 0)
 		return;
 
-	pr_info("Testing pattern from %p (%p) + %x\n", ptr, (void*)virt_to_phys(ptr), SIZE_PATTERN);
+	pr_info("Testing pattern from %p (%p) + %x\n", ptr,
+		(void *)virt_to_phys(ptr), SIZE_PATTERN);
 
 	__asm__("b .");
 
@@ -210,8 +112,8 @@ void armadaxp_store_boot_info(void)
 	int *store_addr = (int *)BOOT_INFO_ADDR;
 	int *resume_pc, win;
 
-	store_addr = (int*)phys_to_virt((int)store_addr);
-	resume_pc = (int*)virt_to_phys(armadaxp_cpu_resume_pd);
+	store_addr = (int *)phys_to_virt((int)store_addr);
+	resume_pc = (int *)virt_to_phys(armadaxp_cpu_resume);
 
 	/*
 	 * Store magic word indicating suspend to ram
@@ -224,6 +126,17 @@ void armadaxp_store_boot_info(void)
 	 * Now store registers that need to be proggrammed before
 	 * comming back to linux. format is addr->value
 	 */
+	/* Disable X-Bar window 12 which is opend in the bootROM
+	 * by default to 0xF0000000 */
+	*store_addr++ = BOOTROM_INTER_REGS_PHYS_BASE + 0x200B0;
+	*store_addr++ = 0x0;
+
+	/* Update Internal Regs offset in case UBoot is configured
+	* to use a different base address.	*/
+	*store_addr++ = BOOTROM_INTER_REGS_PHYS_BASE + 0x20080;
+	*store_addr++ = INTER_REGS_PHYS_BASE;
+
+	/* Save AXI windows data */
 	for (win = 0; win < 4; win++) {
 		*store_addr++ = INTER_REGS_PHYS_BASE + SDRAM_WIN_BASE_REG(win);
 		*store_addr++ = MV_REG_READ(SDRAM_WIN_BASE_REG(win));
@@ -244,20 +157,17 @@ void armadaxp_suspend(void)
 	vfp_save();
 #endif
 	aurora_l2_pm_enter();
-	armadaxp_save_training_space();
 	armadaxp_store_boot_info();
 #ifdef DEBUG_DDR_SELF_REFRESH
 	write_pattern();
 #endif
 	/* This call will shut down the board */
-	armadaxp_powerdown();
+	cpu_suspend(0, armadaxp_powerdown);
 #ifdef DEBUG_DDR_SELF_REFRESH
 	test_pattern();
 #endif
-
 	cpu_init();
 	armadaxp_fabric_restore_deepIdle();
-	armadaxp_restore_training_space();
 	aurora_l2_pm_exit();
 #ifdef CONFIG_SMP
 	smp_resume();
-- 
1.7.5.4

