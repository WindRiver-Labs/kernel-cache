From 500f490fda7c4049a06856b9764f8ad9e0de0ab0 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 6 Jan 2013 10:30:42 +0200
Subject: [PATCH 0008/1825] AXP initial support: add video and fixes

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b19baace676121b81f72e1f02c99958c115b2b91

Change-Id: I1fec83a24a436636e380770f1907cf63dab32996

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/mv_xor.c                   |   21 +-
 drivers/mtd/maps/Makefile              |    5 +
 drivers/usb/host/ehci_marvell.c        |  213 ++++
 drivers/video/Kconfig                  |    1 +
 drivers/video/backlight/dove_bl.c      |  381 +++++++
 drivers/video/display/ths_8200.c       |   85 ++
 drivers/video/marvell/Kconfig          |  228 ++++
 drivers/video/marvell/Makefile         |    9 +
 drivers/video/marvell/dovedcon.c       |  651 +++++++++++
 drivers/video/marvell/dovefb_base.c    | 1377 +++++++++++++++++++++++
 drivers/video/marvell/dovefb_display.c |  203 ++++
 drivers/video/marvell/dovefb_gfx.c     | 1907 ++++++++++++++++++++++++++++++++
 drivers/video/marvell/dovefb_gpio.c    |  201 ++++
 drivers/video/marvell/dovefb_if.h      |   40 +
 drivers/video/marvell/dovefb_ovly.c    | 1262 +++++++++++++++++++++
 include/linux/miscdevice.h             |    2 +
 include/linux/skbuff.h                 |    4 +
 include/video/dovefb.h                 |  507 +++++++++
 include/video/dovefbreg.h              |  695 ++++++++++++
 net/core/skbuff.c                      |    6 +-
 20 files changed, 7784 insertions(+), 14 deletions(-)
 create mode 100644 drivers/usb/host/ehci_marvell.c
 create mode 100644 drivers/video/backlight/dove_bl.c
 create mode 100644 drivers/video/display/ths_8200.c
 create mode 100644 drivers/video/marvell/Kconfig
 create mode 100644 drivers/video/marvell/Makefile
 create mode 100644 drivers/video/marvell/dovedcon.c
 create mode 100644 drivers/video/marvell/dovefb_base.c
 create mode 100644 drivers/video/marvell/dovefb_display.c
 create mode 100644 drivers/video/marvell/dovefb_gfx.c
 create mode 100644 drivers/video/marvell/dovefb_gpio.c
 create mode 100644 drivers/video/marvell/dovefb_if.h
 create mode 100644 drivers/video/marvell/dovefb_ovly.c
 create mode 100644 include/video/dovefb.h
 create mode 100644 include/video/dovefbreg.h

diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index 200d8c3..1a3b3ad 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -496,38 +496,35 @@ mv_xor_tx_submit(struct dma_async_tx_descriptor *tx)
 {
 	struct mv_xor_desc_slot *sw_desc = to_mv_xor_slot(tx);
 	struct mv_xor_chan *mv_chan = to_mv_xor_chan(tx->chan);
-	struct mv_xor_desc_slot *grp_start, *old_chain_tail;
+	struct mv_xor_desc_slot *old_chain_tail;
 	dma_cookie_t cookie;
 	int new_hw_chain = 1;
 
 	dev_dbg(mv_chan->device->common.dev,
-		"%s sw_desc %p: async_tx %p\n",
-		__func__, sw_desc, &sw_desc->async_tx);
-
-	grp_start = sw_desc->group_head;
+		"%s sw_desc %p: async_tx %p, hw desc %x\n",
+		__func__, sw_desc, &sw_desc->async_tx, sw_desc->async_tx.phys);
 
 	spin_lock_bh(&mv_chan->lock);
 	cookie = dma_cookie_assign(tx);
 
 	if (list_empty(&mv_chan->chain))
-		list_splice_init(&sw_desc->tx_list, &mv_chan->chain);
+		list_add_tail(&sw_desc->chain_node, &mv_chan->chain);
 	else {
 		new_hw_chain = 0;
 
 		old_chain_tail = list_entry(mv_chan->chain.prev,
 					    struct mv_xor_desc_slot,
 					    chain_node);
-		list_splice_init(&grp_start->tx_list,
-				 &old_chain_tail->chain_node);
+		list_add_tail(&sw_desc->chain_node, &mv_chan->chain);
 
-		if (!mv_can_chain(grp_start))
+		if (!mv_can_chain(sw_desc))
 			goto submit_done;
 
-		dev_dbg(mv_chan->device->common.dev, "Append to last desc %x\n",
-			old_chain_tail->async_tx.phys);
+		dev_dbg(mv_chan->device->common.dev, "Append to last desc %p hw %x\n",
+			old_chain_tail, old_chain_tail->async_tx.phys);
 
 		/* fix up the hardware chain */
-		mv_desc_set_next_desc(old_chain_tail, grp_start->async_tx.phys);
+		mv_desc_set_next_desc(old_chain_tail, sw_desc->async_tx.phys);
 
 		/* if the channel is not busy */
 		if (!mv_chan_is_busy(mv_chan)) {
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 68a9a91..6d4c957 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -57,3 +57,8 @@ obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
 obj-$(CONFIG_MTD_LATCH_ADDR)	+= latch-addr-flash.o
 obj-$(CONFIG_MTD_LANTIQ)	+= lantiq-flash.o
+
+ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
+	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+	obj-$(CONFIG_MV_INCLUDE_SPI) += ../../../arch/arm/mach-armadaxp/flashmap.o
+endif
diff --git a/drivers/usb/host/ehci_marvell.c b/drivers/usb/host/ehci_marvell.c
new file mode 100644
index 0000000..bad4a76
--- /dev/null
+++ b/drivers/usb/host/ehci_marvell.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2000-2002 by Dima Epshtein
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* #define DRIVER_AUTHOR "Dima Epshtein" */
+
+
+#ifdef CONFIG_USB_DEBUG
+    #define DEBUG
+#else
+    #undef DEBUG
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "ehci.h"
+
+/* Special bits in Port status regsiter */
+#define PORT_SPEED_OFFS		26
+#define PORT_SPEED_MASK		0x3
+#define PORT_SPEED_FULL		0
+#define PORT_SPEED_LOW		1
+#define PORT_SPEED_HIGH		2
+
+static int ehci_marvell_setup(struct usb_hcd *hcd);
+
+
+void 	ehci_marvell_port_status_changed(struct ehci_hcd *ehci)
+{
+	/* GL USB-19:USB Configuration for LS Eye Pattern Test - DD and KW */
+#if defined(CONFIG_ARCH_FEROCEON_KW2) || defined(CONFIG_ARCH_FEROCEON_KW) || defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+	u32 __iomem 	*reg_ptr;
+	u32 		port_status, phy_val;
+
+	/* Change PHY Tx Control Register: offset 0x420 = 0x140 + 0x2e0 */
+    	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + 0x2e0);
+    	phy_val = ehci_readl(ehci, reg_ptr);
+
+	port_status = ehci_readl(ehci, &ehci->regs->port_status[0]); 	
+	if( (port_status & PORT_CONNECT) && 
+            (((port_status >> PORT_SPEED_OFFS) & PORT_SPEED_MASK) == PORT_SPEED_LOW) )
+	{
+		/* If Low speed device is connected - disable autocalibration */
+		/* bits[27-30] = 0, bit[26] = 1 */
+		phy_val &= ~(0xF << 27);
+		phy_val |= (1 << 26);	
+	}
+	else
+	{
+		/* Nothing connected or FS/HS devices connected - enable autocalibration */
+		phy_val &= ~(1 << 26);
+	}
+	ehci_writel(ehci, phy_val, reg_ptr);
+#endif /* CONFIG_ARCH_FEROCEON_KW2 || CONFIG_ARCH_FEROCEON_KW || CONFIG_ARCH_FEROCEON_MV78XX0 */
+}
+
+static const struct hc_driver ehci_marvell_hc_driver = {
+        .description = hcd_name,
+        .product_desc = "Marvell Orion EHCI",
+        .hcd_priv_size = sizeof(struct ehci_hcd),
+
+        /*
+         * generic hardware linkage
+         */
+        .irq = ehci_irq,
+        .flags = HCD_USB2,
+
+        /*
+         * basic lifecycle operations
+         */
+        .reset = ehci_marvell_setup,
+        .start = ehci_run,
+#ifdef CONFIG_PM
+        .bus_suspend = ehci_bus_suspend,
+        .bus_resume = ehci_bus_resume,
+#endif
+        .stop = ehci_stop,
+        .shutdown = ehci_shutdown,
+
+        /*
+         * managing i/o requests and associated device resources
+         */
+        .urb_enqueue = ehci_urb_enqueue,
+        .urb_dequeue = ehci_urb_dequeue,
+        .endpoint_disable = ehci_endpoint_disable,
+
+        /*
+         * scheduling support
+         */
+        .get_frame_number = ehci_get_frame,
+
+        /*
+         * root hub support
+         */
+        .hub_status_data = ehci_hub_status_data,
+        .hub_control = ehci_hub_control,
+        .bus_suspend = ehci_bus_suspend,
+        .bus_resume = ehci_bus_resume,
+};
+
+static int ehci_marvell_setup(struct usb_hcd *hcd)
+{
+        struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+        int retval;
+
+        /*
+         * registers start at offset
+         */
+        ehci->caps = hcd->regs;
+        ehci->regs = hcd->regs +
+                HC_LENGTH(ehci,ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+        /*
+         * cache this readonly data; minimize chip reads
+         */
+        ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+        retval = ehci_halt(ehci);
+        if (retval)
+                return retval;
+
+        /*
+         * data structure init
+         */
+        retval = ehci_init(hcd);
+        if (retval)
+                return retval;
+
+	hcd->has_tt = 1;
+
+        ehci->sbrn = 0x20;
+
+        ehci_reset(ehci);
+
+        ehci_port_power(ehci, 0);
+
+        return retval;
+}
+
+static int ehci_marvell_probe(struct platform_device *pdev)
+{ 
+    int                     i, retval; 
+    struct usb_hcd          *hcd = NULL; 
+ 
+    hcd = usb_create_hcd (&ehci_marvell_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+    if (hcd == NULL) 
+    { 
+        printk("%s: hcd_alloc failed\n", __FUNCTION__); 
+        return -ENOMEM; 
+    } 
+ 
+    for(i=0; i<pdev->num_resources; i++)
+    {
+        if(pdev->resource[i].flags == IORESOURCE_IRQ)
+        {
+            hcd->irq = pdev->resource[i].start; 
+        }
+        else if(pdev->resource[i].flags == IORESOURCE_DMA)
+        {
+            hcd->regs = (void *)pdev->resource[i].start; 
+    	    hcd->rsrc_start = pdev->resource[i].start;
+    	    hcd->rsrc_len = pdev->resource[i].end - hcd->rsrc_start + 1;
+        }
+    }     
+
+    retval = usb_add_hcd (hcd, hcd->irq, IRQF_SHARED);
+	if (retval != 0)
+    {
+        printk("%s: usb_add_hcd failed, retval=0x%x\n", __FUNCTION__, retval); 
+        return -ENOMEM; 
+    }    
+ 
+    return 0; 
+} 
+
+static int ehci_marvell_remove(struct platform_device *pdev)
+{ 
+    struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+    printk("USB: ehci_marvell_remove\n"); 
+   
+    usb_remove_hcd (hcd); 
+    usb_put_hcd (hcd);
+
+   return 0;
+} 
+ 
+ 
+static struct platform_driver ehci_marvell_driver =  
+{ 
+    .driver.name = "ehci_marvell", 
+    .probe = ehci_marvell_probe, 
+    .remove = ehci_marvell_remove,
+    .shutdown = usb_hcd_platform_shutdown, 
+};  
+
+
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 2d1811a..c9dcc65 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2490,6 +2490,7 @@ config FB_PUV3_UNIGFX
 	  Choose this option if you want to use the Unigfx device as a
 	  framebuffer device. Without the support of PCI & AGP.
 
+source "drivers/video/marvell/Kconfig"
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
diff --git a/drivers/video/backlight/dove_bl.c b/drivers/video/backlight/dove_bl.c
new file mode 100644
index 0000000..5e0bb17
--- /dev/null
+++ b/drivers/video/backlight/dove_bl.c
@@ -0,0 +1,381 @@
+/*
+ * linux/drivers/backlight/dove_bl.c -- Marvell DOVE LCD Backlight driver.
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Shadi Ammouri <shadi@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/lcd.h>
+#include <linux/clk.h>
+#include <video/dovefbreg.h>
+#include <mach/dove_bl.h>
+
+
+
+#define DOVEBL_BL_DIV	     0x146	/* 100Hz */
+
+struct dove_backlight {
+	int powermode;          /* blacklight */
+	int lcd_powermode;      /* lcd panel */
+	int current_intensity;
+
+	struct clk *clk;
+	void *lcdpwr_reg;
+	void *blpwr_reg;
+	void *btn_reg;
+	struct device *dev;
+	struct dovebl_platform_data platform_data;
+
+	unsigned long lcd_mask;		/* mask */
+	unsigned long lcd_on;		/* value to enable lcd power */
+	unsigned long lcd_off;		/* value to disable lcd power */
+
+	unsigned long blpwr_mask;	/* mask */
+	unsigned long blpwr_on;		/* value to enable bl power */
+	unsigned long blpwr_off;	/* value to disable bl power */
+
+	unsigned long btn_mask;	/* mask */
+	unsigned long btn_level;	/* how many level can be configured. */
+	unsigned long btn_min;	/* min value */
+	unsigned long btn_max;	/* max value */
+	unsigned long btn_inc;	/* increment */
+
+};
+
+void dovebl_config_reg(unsigned long *reg, unsigned long mask, unsigned long value)
+{
+	unsigned int x;
+	volatile unsigned long* addr;
+
+	addr = reg;
+	x = *addr;
+	x &= ~(mask);	/* clear */
+	x |= value;
+	*addr = x;
+}
+
+static int dovebl_update_status(struct backlight_device *dev)
+{
+	struct dove_backlight *bl = dev_get_drvdata(&dev->dev);
+	u32 brightness = dev->props.brightness;
+
+	if ((dev->props.power != FB_BLANK_UNBLANK) ||
+		(dev->props.fb_blank != FB_BLANK_UNBLANK) ||
+		(bl->powermode == FB_BLANK_POWERDOWN)) {
+		brightness = 0;
+	} else {
+		/*
+		 * brightness = 0 is 1 in the duty cycle in order not to
+		 * fully shutdown the backlight. framework check max
+		 * automatically.
+		 */
+		if (bl->btn_min > brightness) {
+			brightness = bl->btn_min;
+			printk(KERN_WARNING "brightness level is too small, "
+				"use min value\n");
+		}
+	}
+	
+	if (bl->current_intensity != brightness) {
+		dovebl_config_reg(bl->btn_reg,
+			bl->btn_mask,
+			(bl->btn_inc*brightness*0x10000000)); 
+		bl->current_intensity = brightness;
+
+		if (brightness != 0) {
+			/* Set backlight power on. */
+			dovebl_config_reg(bl->blpwr_reg,
+			    bl->blpwr_mask,
+			    bl->blpwr_on);
+			printk( KERN_INFO "backlight power on\n");
+		} else {
+			/* Set backlight power down. */
+			dovebl_config_reg(bl->blpwr_reg,
+			    bl->blpwr_mask,
+			    bl->blpwr_off);
+			printk( KERN_INFO "backlight power down\n");
+		}
+	}
+
+	return 0;
+}
+
+static int dovebl_get_brightness(struct backlight_device *dev)
+{
+	struct dove_backlight *bl = dev_get_drvdata(&dev->dev);
+
+	return bl->current_intensity;
+}
+
+
+static struct backlight_ops dovebl_ops = {
+	.get_brightness = dovebl_get_brightness,
+	.update_status  = dovebl_update_status,
+};
+
+#ifdef CONFIG_PM
+static int dovebl_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+	struct dove_backlight *bl = bl_get_data(bd);
+
+	bl->powermode = FB_BLANK_POWERDOWN;
+	backlight_update_status(bd);
+	clk_disable(bl->clk);
+
+	return 0;
+}
+
+static int dovebl_resume(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+	struct dove_backlight *bl = bl_get_data(bd);
+
+
+	clk_enable(bl->clk);
+
+	bl->powermode = FB_BLANK_UNBLANK;
+	backlight_update_status(bd);
+
+	return 0;
+}
+#endif
+
+static int dove_lcd_get_power(struct lcd_device *ld)
+{
+	struct dove_backlight *bl = lcd_get_data(ld);
+
+	return bl->lcd_powermode;
+}
+
+/* Enable or disable power to the LCD (0: on; 4: off, see FB_BLANK_XXX) */
+static int dove_lcd_set_power(struct lcd_device *ld, int power)
+{
+	struct dove_backlight *bl = lcd_get_data(ld);
+
+	switch (power) {
+	case FB_BLANK_UNBLANK:          /* 0 */
+		/* Set LCD panel power on. */
+		dovebl_config_reg(bl->lcdpwr_reg, bl->lcd_mask, bl->lcd_on);
+		printk(KERN_INFO "panel power on(FB_BLANK_UNBLANK)\n");
+		break;
+	case FB_BLANK_POWERDOWN:        /* 4 */
+		/* Set LCD panel power down. */
+		dovebl_config_reg(bl->lcdpwr_reg, bl->lcd_mask, bl->lcd_off);
+		printk(KERN_INFO "panel power down(FB_BLANK_POWERDOWN)\n");
+		break;
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* Set LCD panel power down. */
+		dovebl_config_reg(bl->lcdpwr_reg,
+			bl->lcd_mask,
+			bl->lcd_off);
+
+		printk(KERN_INFO "panel power down(FB_BLANK_NORMAL)\n");
+		break;
+
+	default:
+		return -EIO;
+	}
+
+	bl->lcd_powermode = power;
+
+	return 0;
+}
+
+static struct lcd_ops dove_lcd_ops = {
+	.get_power      = dove_lcd_get_power,
+	.set_power      = dove_lcd_set_power,
+};
+
+static int  dovebl_probe(struct platform_device *pdev)
+{
+	struct backlight_device *dev;
+	struct dove_backlight *bl;
+	struct lcd_device *ldp;
+	struct dovebl_platform_data *dbm = pdev->dev.platform_data;
+	struct resource *res;
+	struct backlight_properties props;
+
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+	if (!dbm)
+		return -ENXIO;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	bl = kzalloc(sizeof(struct dove_backlight), GFP_KERNEL);
+	if (bl == NULL)
+		return -ENOMEM;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		kfree(bl);
+		return -EINVAL;
+	}
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	/* Get lcd power control reg. */
+	if (0 == dbm->lcd_mapped) 
+		bl->lcdpwr_reg = ioremap_nocache(dbm->lcd_start,
+			dbm->lcd_end - dbm->lcd_start);
+	else
+		bl->lcdpwr_reg = (void *)dbm->lcd_start;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	if (bl->lcdpwr_reg == NULL) {
+		printk(KERN_ERR "Can't map lcd power control reg\n");
+		kfree(bl);
+		return -ENOMEM;
+	}
+	bl->lcdpwr_reg += dbm->lcd_offset;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	/* Get backlight power control reg. */
+	if (0 == dbm->blpwr_mapped) 
+		bl->blpwr_reg = ioremap_nocache(dbm->blpwr_start,
+			dbm->blpwr_end - dbm->blpwr_start);
+	else
+		bl->blpwr_reg = (void*)dbm->blpwr_start;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+	
+	if (bl->blpwr_reg == NULL) {
+		kfree(bl);
+		return -ENOMEM;
+	}
+	bl->blpwr_reg += dbm->blpwr_offset;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	/* Get brightness control reg. */
+	if (0 == dbm->btn_mapped) 
+		bl->btn_reg = ioremap_nocache(dbm->btn_start,
+			dbm->btn_end - dbm->btn_start);
+	else
+		bl->btn_reg = (void*)dbm->btn_start;
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	if (bl->btn_reg == NULL) {
+		kfree(bl);
+		return -ENOMEM;
+	}
+	bl->btn_reg += dbm->btn_offset;
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = dbm->btn_max;
+	dev = backlight_device_register("dove-bl", &pdev->dev, bl, &dovebl_ops, &props);
+	if (IS_ERR(dev)) {
+		iounmap(bl->btn_reg);
+		iounmap(bl->blpwr_reg);
+		iounmap(bl->lcdpwr_reg);
+		kfree(bl);
+		return PTR_ERR(dev);
+	}
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	if (dbm->gpio_pm_control) {
+		ldp = lcd_device_register("dove-lcd", &pdev->dev, bl,
+					  &dove_lcd_ops);
+		if (IS_ERR(ldp))
+			return PTR_ERR(ldp);
+	}
+
+	bl->powermode = FB_BLANK_UNBLANK;
+	bl->lcd_powermode = FB_BLANK_UNBLANK;
+	bl->platform_data = *dbm;
+	bl->dev = &pdev->dev;
+
+        bl->lcd_mask	= dbm->lcd_mask;
+	bl->lcd_on	= dbm->lcd_on;
+        bl->lcd_off	= dbm->lcd_off;
+
+	bl->blpwr_mask	= dbm->blpwr_mask;
+	bl->blpwr_on	= dbm->blpwr_on;
+	bl->blpwr_off	= dbm->blpwr_off;
+
+	bl->btn_mask	= dbm->btn_mask;
+	bl->btn_level	= dbm->btn_level;
+	bl->btn_min	= dbm->btn_min;
+	bl->btn_max	= dbm->btn_max;
+	bl->btn_inc	= dbm->btn_inc;
+
+	platform_set_drvdata(pdev, dev);
+
+	/* Get LCD clock information. */
+	bl->clk = clk_get(&pdev->dev, "LCDCLK");
+
+	dev->props.fb_blank = FB_BLANK_UNBLANK;
+	dev->props.max_brightness = dbm->btn_max;
+	dev->props.brightness = dbm->default_intensity;
+
+	/* set default PWN to 100Hz. */
+	dovebl_config_reg(bl->btn_reg,
+			0x0FFF0000,
+			(DOVEBL_BL_DIV << 16)); 
+
+	printk(KERN_INFO "Dove Backlight Driver start power on sequence.\n");
+	/* power on backlight and set default brightness */
+	dovebl_update_status(dev);
+	printk(KERN_ERR "%s - %d.\n", __func__, __LINE__);
+
+	/* power on LCD panel. */
+	printk(KERN_INFO "first time to"
+		"panel power on(FB_BLANK_UNBLANK)\n");
+	dovebl_config_reg(bl->lcdpwr_reg, bl->lcd_mask, bl->lcd_on);
+
+	printk(KERN_INFO "Dove Backlight Driver Initialized.\n");
+	return 0;
+}
+
+static int dovebl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *dev = platform_get_drvdata(pdev);
+	struct dove_backlight *bl = dev_get_drvdata(&dev->dev);
+
+	backlight_device_unregister(dev);
+	kfree(bl);
+
+	printk(KERN_INFO "Dove Backlight Driver Unloaded\n");
+	return 0;
+}
+
+static struct platform_driver dovebl_driver = {
+	.probe		= dovebl_probe,
+	.remove		= dovebl_remove,
+#ifdef CONFIG_PM
+	.suspend	= dovebl_suspend,
+	.resume		= dovebl_resume,
+#endif
+	.driver		= {
+		.name	= "dove-bl",
+	},
+};
+
+static int __init dovebl_init(void)
+{
+	return platform_driver_register(&dovebl_driver);
+}
+
+static void __exit dovebl_exit(void)
+{
+	platform_driver_unregister(&dovebl_driver);
+}
+
+module_init(dovebl_init);
+module_exit(dovebl_exit);
+
+MODULE_AUTHOR("Shadi Ammouri <shadi@marvell.com>");
+MODULE_DESCRIPTION("Dove Backlight Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/display/ths_8200.c b/drivers/video/display/ths_8200.c
new file mode 100644
index 0000000..7d61f84
--- /dev/null
+++ b/drivers/video/display/ths_8200.c
@@ -0,0 +1,85 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+//#define DEBUG
+
+#ifdef DEBUG
+#include <linux/debugfs.h>
+#include <asm/uaccess.h>
+#endif
+
+static const struct i2c_device_id ths8200_register_id[] = {
+	{ "ths8200_i2c", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ths8200_register_id);
+
+
+static int ths8200_i2c_remove(struct i2c_client *client)
+{
+        return 0;
+}
+
+static int ths8200_i2c_probe(struct i2c_client *client,
+                        const struct i2c_device_id *id)
+{
+        int rc;
+
+	printk ("Probing in %s, name %s, addr 0x%x\n",__FUNCTION__,client->name,client->addr);
+
+        if (!i2c_check_functionality(client->adapter,
+                                     I2C_FUNC_SMBUS_I2C_BLOCK)) {
+                dev_err(&client->dev, "i2c bus does not support the THS8200.\n");
+                rc = -ENODEV;
+                goto exit;
+        }
+
+	i2c_smbus_write_byte_data(client, 0x1C, 0x30);
+	i2c_smbus_write_byte_data(client, 0x82, 0x5C);
+
+        return 0;
+
+ exit:
+        return rc;
+}
+
+static struct i2c_driver ths8200_driver = {
+     .driver = {
+          .name   = "ths8200_i2c",
+          .owner  = THIS_MODULE,
+     },
+     .probe          = ths8200_i2c_probe,
+     .remove         = ths8200_i2c_remove,
+     .id_table       = ths8200_register_id,
+};
+
+static int __init ths8200_init(void)
+{
+        int ret;
+
+	printk ("Initializing %s\n",__FUNCTION__);
+
+        if ((ret = i2c_add_driver(&ths8200_driver)) < 0)
+        {
+                return ret;
+        }
+        return ret;
+}
+
+static void __exit ths8200_exit(void)
+{
+	i2c_del_driver(&ths8200_driver);
+}
+
+module_init(ths8200_init);
+module_exit(ths8200_exit);
+
+MODULE_AUTHOR("shadi@marvell.com");
+MODULE_DESCRIPTION("THS8200 D2A converter.");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/video/marvell/Kconfig b/drivers/video/marvell/Kconfig
new file mode 100644
index 0000000..d507dd6
--- /dev/null
+++ b/drivers/video/marvell/Kconfig
@@ -0,0 +1,228 @@
+config FB_DOVE
+	bool "Marvell LCD controller"
+	depends on FB && (ARCH_DOVE || ARCH_FEROCEON_KW || ARCH_ARMADA_XP)
+	help
+	  Support for Marvell Dove SoC LCD controller.
+
+config FB_DOVE_CONSISTENT_DMA_SIZE
+	int "Consistent DMA memory size (MB)"
+	depends on FB_DOVE && (FB_DOVE_CLCD || FB_DOVE_CLCD1)
+	range 2 46
+	default 46
+	help
+	  Increase the DMA consistent memory size according to your video
+	  memory needs.
+	  The size must be 2MB aligned.
+
+config FB_DOVE_CLCD
+	tristate "Marvell DOVE Color LCD support"
+	depends on FB && ARM && FB_DOVE
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	Marvell DOVE Color LCD. If not sure, say N. If want to config 
+	resolution, please use bootargs, e.g. dovefb:640x480-16@60.
+
+menu "LCD0 I2C setting"
+	depends on FB_DOVE && FB_DOVE_CLCD && ARCH_DOVE
+
+config FB_DOVE_CLCD0_I2C_DEFAULT_SETTING
+	bool "Use LCD0 I2C default setting"
+	default y
+	---help---
+	LCD0 I2C default setting: use I2C channel 1 and I2C address 0x3F
+	to get EDID data.
+
+config FB_DOVE_CLCD0_I2C_CHANNEL
+	int "Set I2C Channel"
+	depends on !FB_DOVE_CLCD0_I2C_DEFAULT_SETTING
+	range 0 2
+	default 1
+	---help---
+	You can set I2C channel number between 0~2.
+
+config FB_DOVE_CLCD0_I2C_ADDRESS
+	hex "Set I2C Address"
+	depends on !FB_DOVE_CLCD0_I2C_DEFAULT_SETTING
+	range 0x0 0x7f
+	default 0x3f
+	---help---
+	You can set I2C address number between 0~0x7f
+
+endmenu
+
+config FB_DOVE_CLCD1
+	tristate "Marvell DOVE Secondary Color LCD support"
+	depends on FB && ARM && FB_DOVE && ARCH_DOVE
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_DOVE_DCON
+	---help---
+	Say Y here if your Secondary LCD panel is VGA. Default is N.
+
+menu "LCD1 I2C setting"
+	depends on FB_DOVE && FB_DOVE_CLCD1 && ARCH_DOVE
+
+config FB_DOVE_CLCD1_I2C_DEFAULT_SETTING
+	bool "Use LCD1 I2C default setting"
+	default y
+	---help---
+	LCD1 I2C default setting: use I2C channel 1 and I2C address 0x50
+	to get EDID data.
+
+config FB_DOVE_CLCD1_I2C_CHANNEL
+	int "Set I2C Channel"
+	depends on !FB_DOVE_CLCD1_I2C_DEFAULT_SETTING
+	range 0 2
+	default 1
+	---help---
+	You can set I2C channel number between 0~2.
+
+config FB_DOVE_CLCD1_I2C_ADDRESS
+	hex "Set I2C Address"
+	depends on !FB_DOVE_CLCD1_I2C_DEFAULT_SETTING
+	range 0x0 0x7f
+	default 0x50
+	---help---
+	You can set I2C address number between 0~0x7f
+
+endmenu
+
+config FB_DOVE_CLCD_EDID
+	bool "Marvell DOVE read EDID utility"
+	depends on FB_DOVE
+	select I2C
+	select I2C_MV64XXX
+	select FB_DDC
+	select FB_MODE_HELPERS
+	---help---
+	Enable reading the EDID information of the screen. Default is N.
+
+config DOVEFB_FORCE_EDID_RES
+	bool "Change resolution to match EDID info"
+	depends on FB_DOVE_CLCD_EDID
+	---help---
+	Perform a check on configured resolutions to match screen's EDID information.
+
+config FB_DOVE_DCON
+	tristate "Marvell DOVE DCON support"
+	depends on ARM && FB_DOVE && ARCH_DOVE
+	---help---
+	Say Y here if want to enable DCON. (HW default bypass.)
+
+choice
+	depends on FB_DOVE && FB_DOVE_DCON
+	prompt "DOVE DCON Panel PortA" 
+	default FB_DOVE_CLCD_DCONA_BYPASS
+
+config FB_DOVE_CLCD_DCONA_BYPASS
+	bool "LCD0 Bypass"
+	help
+	  Marvell DOVE DCON LCD0 Bypass mode. Default is Y.
+
+config FB_DOVE_CLCD_DCONA_OLPC
+	bool "OLPC DCON Mode(Not support now)"
+	help
+	  Say Y here if your DCON is OLPC mode. Default is N.
+
+config FB_DOVE_CLCD_DCONA_DUALVIEW
+	bool "LCD0/1 dual view Mode(Not support now)"
+	help
+	  Say Y here if you have two LCD panel. Default is N.
+
+config FB_DOVE_CLCD_DCONA_MODE
+	bool "DCON Mode, LCD0 data (Not support now)"
+	help
+	  Say Y here if your DCON is DCON mode. Default is N.
+
+endchoice
+
+choice
+	depends on FB_DOVE && FB_DOVE_DCON && ARCH_DOVE
+	prompt "DOVE DCON Panel PortB"
+	default FB_DOVE_CLCD_DCONB_BYPASS1
+
+config FB_DOVE_CLCD_DCONB_BYPASS1
+	bool "LCD1 Bypass"
+	help
+	  Marvell DOVE DCON LCD1 Bypass mode. Default is Y.
+
+config FB_DOVE_CLCD_DCONB_BYPASS0
+	bool "LCD0 Bypass"
+	help
+	  Say Y here if your DCON is bypass LCD0. Default is N.
+
+endchoice
+
+menu "PLL clock speed when under inaccurate mode"
+	depends on FB_DOVE && (FB_DOVE_CLCD || FB_DOVE_CLCD1)
+
+config FB_DOVE_CLCD_SCLK_VALUE
+	int "PLL clock speed"
+	default "1000"
+	depends on (FB_DOVE_CLCD || FB_DOVE_CLCD1)
+	---help---
+	This paramter (in MHz) determines the source clock rate.
+	The default is 1000MHz(PLL). This value only is applied
+	when system is under inaccurate mode and two lcds use
+	PLL as refclk at the same time. The real frquency depends
+	on HW setting. Change this if you know how to set it.
+
+endmenu
+
+config FB_DOVE_OPTIMIZED_FB_MEM_ALLOC
+	bool "Use performance optimized memory allocations"
+	depends on FB_DOVE
+	default false
+	---help---
+	Enable performance optimized memory allocations for LCD frame-buffers.
+	This option will reserve the last DRAM Chip-Select for LCD usage.
+
+config FB_DOVE_CLCD_DEFAULT_OPTION
+	string "Default Dove FB kernel parameter"
+	depends on FB_DOVE && (FB_DOVE_CLCD || FB_DOVE_CLCD1)
+	default "lcd0:1280x768-24@60,lcd1:1024x768-16@60"
+
+config DOVEFB_DISPLAY_MODE
+	tristate "Support display configuration."
+	depends on FB_DOVE && FB_DOVE_CLCD && FB_DOVE_CLCD1
+	default n if (ARCH_DOVE || ARCH_FEROCEON_KW)
+	---help---
+	Say Y here if you want to build driver into kernel. Default is N.
+
+config FB_DOVE_CLCD_FLAREON_GV
+	tristate "Marvell DOVE Color LCD - Flareon GV"
+	depends on FB_DOVE && (FB_DOVE_CLCD || FB_DOVE_CLCD1) && ARCH_DOVE
+	default y if ARCH_REALVIEW
+	---help---
+	Say Y here if your LCD version is on Flareon GV. Default is N.
+
+## Following is for MUSTANG LCD config
+config FB_MUSTANG_CLCD
+    tristate "Marvell Mustang Color LCD support"
+    default n
+    depends on FB_DOVE && ARCH_DOVE
+    select FB_CFB_FILLRECT
+    select FB_CFB_COPYAREA
+    select FB_CFB_IMAGEBLIT
+    ---help---
+    Marvell Mustang Color LCD. If not sure, say N.
+
+config FB_MUSTANG_QVGA
+    bool "Marvell Mustang Color LCD - QVGA"
+    default n
+    depends on FB_MUSTANG_CLCD
+    ---help---
+       Say Y here if your LCD panel is QVGA. Default is N.
+config FB_MUSTANG_LOW_REFLESH_RATE
+	bool "Lower Reflesh Rate of LCD DMA"
+	default n
+	depends on FB_MUSTANG_CLCD
+	help
+	  Say Y if you are using Tahoe FPGA System
+	  It will slow down to 1/2 original LCD  refresh rate
+## End of MUSTANG LCD config
+
+
diff --git a/drivers/video/marvell/Makefile b/drivers/video/marvell/Makefile
new file mode 100644
index 0000000..2c8ae74
--- /dev/null
+++ b/drivers/video/marvell/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for Marvell's framebuffer device driver
+#
+
+obj-$(CONFIG_FB_DOVE)          += dovefb_base.o dovefb_gfx.o dovefb_ovly.o dovefb_gpio.o
+
+obj-$(CONFIG_FB_DOVE_DCON)     += dovedcon.o
+
+obj-$(CONFIG_DOVEFB_DISPLAY_MODE)	+=	dovefb_display.o
diff --git a/drivers/video/marvell/dovedcon.c b/drivers/video/marvell/dovedcon.c
new file mode 100644
index 0000000..1f3fa24
--- /dev/null
+++ b/drivers/video/marvell/dovedcon.c
@@ -0,0 +1,651 @@
+/*
+ * linux/drivers/video/dovedcon.c -- Marvell DCON driver for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by:
+ *	Green Wan <gwan@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+#include <video/dovedcon.h>
+
+#define VGA_CHANNEL_DEFAULT	0x90C78
+static int dovedcon_enable(struct dovedcon_info *ddi)
+{
+	unsigned int channel_ctrl;
+	unsigned int ctrl0;
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+#ifdef CONFIG_FB_DOVE_CLCD_DCONB_BYPASS0
+	/* enable lcd0 pass to PortB */
+	ctrl0 &= ~(0x3 << 8);
+	ctrl0 |= (0x1 << 8);
+	ddi->port_b = 1;
+#endif
+	
+	/*
+	 * Enable VGA clock, clear it to enable.
+	 */
+	ctrl0 &= ~(ddi->port_b << 25);	
+		
+	/*
+	 * Enable LCD clock, clear it to enable
+	 */
+	ctrl0 &= ~(ddi->port_a << 24);	
+
+	/*
+	 * Enable LCD Parallel Interface, clear it to enable
+	 */
+	ctrl0 &= ~(0x1 << 17);	
+
+	writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+
+	/*
+	 * Configure VGA data channel and power on them.
+	 */
+	if (ddi->port_b) {
+		channel_ctrl = VGA_CHANNEL_DEFAULT;
+		writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_A_CTRL);
+		writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_B_CTRL);
+		writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_C_CTRL);
+	}
+
+	return 0;
+}
+
+static int dovedcon_disable(struct dovedcon_info *ddi)
+{
+	unsigned int channel_ctrl;
+	unsigned int ctrl0;
+
+	/*
+	 * Power down VGA data channel.
+	 */
+	channel_ctrl = (0x1 << 22);
+	writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_A_CTRL);
+	writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_B_CTRL);
+	writel(channel_ctrl, ddi->reg_base+DCON_VGA_DAC_CHANNEL_C_CTRL);
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	/*
+	 * Disable LCD Parallel Interface, set to 1 to disable it.
+	 */
+	ctrl0 |= (0x1 << 17);	
+
+	/*
+	 * Disable LCD clock, set to 1 to disable it.
+	 */
+	ctrl0 |= (0x1 << 24);	
+
+	/*
+	 * Disable VGA clock, set to 1 to disable it.
+	 */
+	ctrl0 |= (0x1 << 25);	
+		
+	writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+	
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+/* suspend and resume support */
+static int dovedcon_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct dovedcon_info *ddi = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "dovedcon_suspend().\n");
+
+	dovedcon_disable(ddi);
+	clk_disable(ddi->clk);
+
+	return 0;
+}
+
+static int dovedcon_resume(struct platform_device *pdev)
+{
+	struct dovedcon_info *ddi = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "dovedcon_resume().\n");
+	clk_enable(ddi->clk);
+	dovedcon_enable(ddi);
+
+	return 0;
+}
+
+#endif
+
+static int dovedcon_fb_event_callback(struct notifier_block *self,
+				unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	struct dovedcon_info *ddi;
+
+	/* If we aren't interested in this event, skip it immediately ... */
+	if (event != FB_EVENT_BLANK && event != FB_EVENT_CONBLANK)
+		return 0;
+
+	ddi = container_of(self, struct dovedcon_info, fb_notif);
+
+	if (*(int *)evdata->data == FB_BLANK_UNBLANK) {
+		printk(KERN_NOTICE "DCON fb callback: unblanking...\n");
+		dovedcon_enable(ddi);
+	}
+	else {
+		printk(KERN_NOTICE "DCON fb callback: blank...\n");
+		dovedcon_disable(ddi);
+	}
+
+	return 0;
+}
+
+static int dovedcon_hook_fb_event(struct dovedcon_info *ddi)
+{
+	memset(&ddi->fb_notif, 0, sizeof(ddi->fb_notif));
+	ddi->fb_notif.notifier_call = dovedcon_fb_event_callback;
+	return fb_register_client(&ddi->fb_notif);
+}
+
+/*
+ * dcon sysfs interface implementation
+ */
+static ssize_t dcon_show_pa_clk(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+
+	ddi = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", ddi->port_a);
+}
+
+static ssize_t dcon_ena_pa_clk(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long ena_clk;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &ena_clk);
+	if (rc)
+		return rc;
+
+	rc = -ENXIO;
+	
+	if (ddi->port_a != ena_clk) {
+		unsigned int ctrl0;
+
+		ddi->port_a = ena_clk;
+
+		/*
+		 * Get current configuration of CTRL0
+		 */
+		ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+		/* enable or disable LCD clk. */
+		if (0 == ddi->port_a)
+			ctrl0 |= (0x1 << 24);
+		else
+			ctrl0 &= ~(0x1 << 24);
+
+		/* Apply setting. */
+		writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+	}
+
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_show_pb_clk(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+
+	ddi = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", ddi->port_b);
+}
+
+static ssize_t dcon_ena_pb_clk(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long ena_clk;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &ena_clk);
+	if (rc)
+		return rc;
+
+	if (ddi->port_b != ena_clk) {
+		unsigned int ctrl0;
+
+		ddi->port_b = ena_clk;
+
+		/*
+		 * Get current configuration of CTRL0
+		 */
+		ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+		/* enable or disable LCD clk. */
+		if (0 == ddi->port_b)
+			ctrl0 |= (0x1 << 25);
+		else
+			ctrl0 &= ~(0x1 << 25);
+
+		/* Apply setting. */
+		writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+	}
+
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_show_pa_mode(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	return sprintf(buf, "%d\n", (ctrl0 & (0x3 << 6)) >> 6 );
+}
+
+static ssize_t dcon_cfg_pa_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long value;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &value);
+	if (rc)
+		return rc;
+
+	rc = -ENXIO;
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	if (value <= 3) {
+		ctrl0 &= ~(0x3 << 6);
+		ctrl0 |= (value << 6);
+
+		/* Apply setting. */
+		writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+		rc = count;
+	}
+
+	return rc;
+}
+
+static ssize_t dcon_show_pb_mode(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	return sprintf(buf, "%d\n", (ctrl0 & (0x3 << 8)) >> 8 );
+}
+
+static ssize_t dcon_cfg_pb_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long value;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &value);
+	if (rc)
+		return rc;
+
+	rc = -ENXIO;
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	if (value <= 3) {
+		ctrl0 &= ~(0x3 << 8);
+		ctrl0 |= (value << 8);
+
+		/* Apply setting. */
+		writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+		rc = count;
+	}
+
+	return rc;
+}
+
+static ssize_t dcon_show_parallel_ena(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	return sprintf(buf, "%d\n", (ctrl0 & (0x1 << 17)) ? 0x0:0x1 );
+}
+
+static ssize_t dcon_ena_parallel(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long value;
+	unsigned int ctrl0;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &value);
+	if (rc)
+		return rc;
+
+	rc = -ENXIO;
+
+	/*
+	 * Get current configuration of CTRL0
+	 */
+	ctrl0 = readl(ddi->reg_base+DCON_CTRL0);
+
+	if (value <= 1) {
+		if (0 == value)
+			ctrl0 |= (0x1 << 17);
+		else
+			ctrl0 &= ~(0x1 << 17);
+
+		/* Apply setting. */
+		writel(ctrl0, ddi->reg_base+DCON_CTRL0);
+		rc = count;
+	}
+
+	return rc;
+}
+
+static ssize_t dcon_show_vga_pwr(struct device *dev,
+		struct device_attribute *attr,char *buf)
+{
+	struct dovedcon_info *ddi;
+	unsigned int channel;
+	unsigned int result;
+
+	result = 0;
+	ddi = dev_get_drvdata(dev);
+
+	/*
+	 * Get channel A power status
+	 */
+	channel = readl(ddi->reg_base+DCON_VGA_DAC_CHANNEL_A_CTRL);
+	result |= (channel & (0x1 << 22)) ? 0x0:0x1;
+	
+	/*
+	 * Get channel B power status
+	 */
+	channel = readl(ddi->reg_base+DCON_VGA_DAC_CHANNEL_B_CTRL);
+	result |= (channel & (0x1 << 22)) ? 0x0:0x2;
+	
+	/*
+	 * Get channel C power status
+	 */
+	channel = readl(ddi->reg_base+DCON_VGA_DAC_CHANNEL_C_CTRL);
+	result |= (channel & (0x1 << 22)) ? 0x0:0x4;
+
+	return sprintf(buf, "%d\n", result);
+}
+
+static ssize_t dcon_ena_vga_pwr(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct dovedcon_info *ddi;
+	unsigned long value;
+	unsigned int channel;
+
+	ddi = dev_get_drvdata(dev);
+	rc = strict_strtoul(buf, 0, &value);
+	if (rc)
+		return rc;
+
+	rc = -ENXIO;
+	channel = 0;
+
+	/*
+	 * bit[0] for channel A power status.
+	 * bit[1] for channel B power status.
+	 * bit[2] for channel C power status.
+	 */
+	if (value <= 0x7) {
+		/* config channel A */
+		if (value & 0x1)
+			channel = VGA_CHANNEL_DEFAULT;
+		else
+			channel |= (0x1 << 22);
+
+		/* Apply setting. */
+		writel(channel, ddi->reg_base+DCON_VGA_DAC_CHANNEL_A_CTRL);
+
+		/* config channel B */
+		if (value & 0x2)
+			channel = VGA_CHANNEL_DEFAULT;
+		else
+			channel |= (0x1 << 22);
+
+		/* Apply setting. */
+		writel(channel, ddi->reg_base+DCON_VGA_DAC_CHANNEL_B_CTRL);
+
+		/* config channel C */
+		if (value & 0x4)
+			channel = VGA_CHANNEL_DEFAULT;
+		else
+			channel |= (0x1 << 22);
+
+		/* Apply setting. */
+		writel(channel, ddi->reg_base+DCON_VGA_DAC_CHANNEL_C_CTRL);
+
+		rc = count;
+	}
+
+	return rc;
+}
+
+/* Using sysfs to configure DCON function. */
+static struct class *dcon_class;
+#define DCON_ATTR_NUM 6
+static struct device_attribute dcon_device_attributes[DCON_ATTR_NUM+1] = {
+	__ATTR(pa_clk_ena, 0644, dcon_show_pa_clk, dcon_ena_pa_clk),
+	__ATTR(pb_clk_ena, 0644, dcon_show_pb_clk, dcon_ena_pb_clk),
+	__ATTR(pa_mode, 0644, dcon_show_pa_mode, dcon_cfg_pa_mode),
+	__ATTR(pb_mode, 0644, dcon_show_pb_mode, dcon_cfg_pb_mode),
+	__ATTR(parallel_ena, 0644, dcon_show_parallel_ena, dcon_ena_parallel),
+	__ATTR(vga_ch_pwr, 0644, dcon_show_vga_pwr, dcon_ena_vga_pwr),
+	__ATTR_NULL,
+};
+
+static int __init dcon_class_init(void)
+{
+	dcon_class = class_create(THIS_MODULE, "dcon");
+	if (IS_ERR(dcon_class)) {
+		printk(KERN_WARNING "Unable to create dcon class; errno = %ld\n",
+				PTR_ERR(dcon_class));
+		return PTR_ERR(dcon_class);
+	}
+
+	dcon_class->dev_attrs = dcon_device_attributes;
+	dcon_class->suspend = NULL;
+	dcon_class->resume = NULL;
+	return 0;
+}
+
+static void dcon_device_release(struct device *dev)
+{
+	struct dovedcon_info *ddi;
+
+	ddi = dev_get_drvdata(dev);
+	kfree(ddi);
+}
+
+/* Initialization */
+static int __init dovedcon_probe(struct platform_device *pdev)
+{
+	struct dovedcon_mach_info *ddmi;
+	struct dovedcon_info *ddi;
+	struct resource *res;
+
+	ddmi = pdev->dev.platform_data;
+	if (!ddmi)
+		return -EINVAL;
+
+	ddi = kzalloc(sizeof(struct dovedcon_info), GFP_KERNEL);
+	if (ddi == NULL)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		kfree(ddi);
+		return -EINVAL;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start,
+	    "MRVL DCON Regs")) {
+		printk(KERN_INFO "Cannot reserve DCON memory mapped"
+			" area 0x%lx @ 0x%lx\n",
+			(unsigned long)res->start,
+			(unsigned long)res->end - res->start);
+		kfree(ddi);
+		return -ENXIO;
+	}
+
+	ddi->reg_base = ioremap_nocache(res->start, res->end - res->start);
+
+	if (!ddi->reg_base) {
+		kfree(ddi);
+		return -EINVAL;
+	}
+
+	platform_set_drvdata(pdev, ddi);
+//	dev_set_drvdata(&pdev->dev, ddi);
+
+	//printk(KERN_INFO "DCON: pdev->dev.class=<0x%x>\n", pdev->dev.class);
+	//printk(KERN_INFO "DCON: pdev->dev.parent=<0x%x>\n", pdev->dev.parent);
+	//printk(KERN_INFO "DCON: pdev->dev.release=<0x%x>\n", pdev->dev.release);
+	ddi->clk = clk_get(&pdev->dev, "LCDCLK");
+	if (!IS_ERR(ddi->clk))
+		clk_enable(ddi->clk);
+
+	ddi->port_a = ddmi->port_a;
+	ddi->port_b = ddmi->port_b;
+
+	/* Initialize DCON hardware */
+	dovedcon_enable(ddi);
+
+	/*
+	 * Register to receive fb blank event.
+	 */
+	dovedcon_hook_fb_event(ddi);
+
+	dcon_class_init();
+	pdev->dev.class = dcon_class;
+	pdev->dev.release = dcon_device_release;
+
+	{
+		int i;
+
+		for(i = 0; i < DCON_ATTR_NUM; i++)
+			if (device_create_file(&pdev->dev,
+			    &dcon_device_attributes[i]))
+				printk(KERN_ERR
+				    "dcon register <%d> sysfs failed\n", i);
+	}
+
+	printk(KERN_INFO "dovedcon has been initialized.\n");
+
+	return 0;
+}
+
+/*
+ *  Cleanup
+ */
+static int dovedcon_remove(struct platform_device *pdev)
+{
+	struct dovedcon_info *ddi = platform_get_drvdata(pdev);
+
+	clk_disable(ddi->clk);
+	clk_put(ddi->clk);
+	iounmap(ddi->reg_base);
+	kfree(ddi);
+
+	return 0;
+}
+
+static struct platform_driver dovedcon_pdriver = {
+	.probe		= dovedcon_probe,
+	.remove		= dovedcon_remove,
+#ifdef CONFIG_PM
+	.suspend	= dovedcon_suspend,
+	.resume		= dovedcon_resume,
+#endif /* CONFIG_PM */
+	.driver		=	{
+		.name	=	"dovedcon",
+		.owner	=	THIS_MODULE,
+	},
+};
+static int __init dovedcon_init(void)
+{
+	return platform_driver_register(&dovedcon_pdriver);
+}
+
+static void __exit dovedcon_exit(void)
+{
+	platform_driver_unregister(&dovedcon_pdriver);
+}
+
+module_init(dovedcon_init);
+module_exit(dovedcon_exit);
+
+MODULE_AUTHOR("Green Wan <gwan@marvell.com>");
+MODULE_DESCRIPTION("DCON driver for Dove LCD unit");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/marvell/dovefb_base.c b/drivers/video/marvell/dovefb_base.c
new file mode 100644
index 0000000..0e4677e
--- /dev/null
+++ b/drivers/video/marvell/dovefb_base.c
@@ -0,0 +1,1377 @@
+/*
+ * linux/drivers/video/marvell/marvell_base.c -- Marvell DOVE LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by:
+ *	Green Wan <gwan@marvell.com>
+ *	Shadi Ammouri <shadi@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+/*
+ * 1. Adapted from:  linux/drivers/video/skeletonfb.c
+ * 2. Merged code base from: linux/drivers/video/dovefb.c (Lennert Buytenhek)
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+//#include <asm/hardware.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <linux/proc_fs.h>
+#include <linux/mbus.h>
+
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+#include "dovefb_if.h"
+
+#define MAX_HWC_SIZE		(64*64*2)
+#define DEFAULT_REFRESH		60	/* Hz */
+
+#define DOVEFB_INT_MASK  (DOVEFB_VSYNC_INT_MASK |\
+			  DOVEFB_GFX_INT_MASK |\
+			  DOVEFB_VID_INT_MASK)
+
+#define USING_SAME_BUFF
+#ifdef USING_SAME_BUFF
+void *gfx_fb_start = 0;
+dma_addr_t gfx_fb_start_dma = 0;
+void *vid_fb_start = 0;
+dma_addr_t vid_fb_start_dma = 0;
+#endif
+
+static int dovefb_init_layer(struct platform_device *pdev,
+		enum dovefb_type type, struct dovefb_info *info,
+		struct resource *res);
+static int dovefb_enable_lcd0(struct platform_device *pdev);
+
+struct lcd_debug_data {
+	int id;			/* lcd0 or lcd1 */
+	struct fb_info *fi;	/* fb info data */
+};
+static int
+proc_lcd_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char *request;
+	unsigned int offset = 0, value = 0;
+	struct lcd_debug_data *db_data = data;
+	struct fb_info *fi;
+	struct dovefb_layer_info *dfli;
+
+	db_data = data;
+	fi = db_data->fi;
+	dfli = fi->par;
+
+	/*
+	 * Get configuration
+	 */
+	request = kmalloc(count, GFP_KERNEL);
+	if (copy_from_user(request, buffer, count))
+		return 0;
+	request[count-1] = '\0';
+
+	/*
+	 * Parse configuration
+	 */
+	offset = simple_strtoul( request, &request, 16);
+	request++;
+	value = simple_strtoul(request, &request, 16);
+
+	/*
+	 * Check offset range.
+	 */
+	if (offset >= 0 && offset <= 0x1C4) {
+		printk(KERN_ERR "write value <0x%08x> to LCD reg offset <0x%08x>\n", value, offset);
+		writel(value, dfli->reg_base + offset);
+	} else {
+		printk(KERN_ERR "usage: echo \"reg_offset value\" > /proc/mv_lcdx\n");
+	}
+
+	kfree(request);
+
+	return count;
+}
+
+static int
+proc_lcd_read(char *page, char **start, off_t off, int count, int *eof,
+			void *data)
+{
+	char *p = page;
+	int len;
+	struct lcd_debug_data *db_data = data;
+	u32 i;
+	u32 reg;
+	u32 x, bit0to15, bit16to31, total_v, total_h, active_h, active_v;
+	u32 orig_buff_x, orig_buff_y, zoomed_x, zoomed_y;
+	struct fb_info *fi;
+	struct dovefb_layer_info *dfli;
+
+	db_data = data;
+	fi = db_data->fi;
+	dfli = fi->par;
+
+	p += sprintf(p, "Inside LCD%d\n", db_data->id);
+	p += sprintf(p, "Physical addr: 0x%08x\n", (unsigned int)fi->fix.mmio_start);
+	p += sprintf(p, "Virtual addr: 0x%08x\n", (unsigned int)dfli->reg_base);
+
+	/*
+	 * Get resolution
+	 */
+	x = readl(dfli->reg_base+0x118);
+	active_h = x & 0x0000ffff;
+	active_v = (x & 0xffff0000) >> 16;
+	p += sprintf(p, "Resolution is: <%dx%d>\n", active_h, active_v);
+
+	/*
+	 * Get total line
+	 */
+	x = readl(dfli->reg_base+0x114);
+	total_h = x & 0x0000ffff;
+	total_v = (x & 0xffff0000) >> 16;
+	p += sprintf(p, "----total--------------------------<%4dx%4d>-------------------------\n", total_h, total_v);
+
+	p += sprintf(p, "----active--------------|");
+	/*
+	 * Get H Timings
+	 */
+	x = readl(dfli->reg_base+0x11c);
+	bit0to15 = x & 0x0000ffff;
+	bit16to31 = (x & 0xffff0000) >> 16;
+	p += sprintf(p, "->front porch(%d)->hsync(%d)->back porch(%d)\n",
+		bit0to15, total_h-bit0to15-bit16to31-active_h, bit16to31);
+
+	p += sprintf(p, "|\t\t\t|\n");
+	p += sprintf(p, "|\t\t\t|\n");
+	p += sprintf(p, "|\t<%4dx%4d>\t|\n", active_h, active_v);
+	p += sprintf(p, "|\t\t\t|\n");
+	p += sprintf(p, "|\t\t\t|\n");
+	p += sprintf(p, "------------------------|\n");
+	/*
+	 * Get V Timings
+	 */
+	x = readl(dfli->reg_base+0x120);
+	bit0to15 = x & 0x0000ffff;
+	bit16to31 = (x & 0xffff0000) >> 16;
+	p += sprintf(p, "|\n|front porch(%d)\n|vsync(%d)\n|back porch(%d)\n",
+		bit0to15, total_v-bit0to15-bit16to31-active_v, bit16to31);
+	p += sprintf(p, "---------------------------------------------------------------------\n");
+	/*
+	 * Get Line Pitch
+	 */
+	x = readl(dfli->reg_base+0xfc);
+	bit0to15 = x & 0x0000ffff;
+	p += sprintf(p, "gfx line pitch in memory is <%d>\n",
+		bit0to15);
+
+	/*
+	 * Get scaling info
+	 */
+	x = readl(dfli->reg_base+0x104);
+	orig_buff_x = x & 0x0000ffff;
+	orig_buff_y = (x & 0xffff0000) >> 16;
+	x = readl(dfli->reg_base+0x108);
+	zoomed_x = x & 0x0000ffff;
+	zoomed_y = (x & 0xffff0000) >> 16;
+	
+	p += sprintf(p, "Scaled from <%dx%d> to <%dx%d>\n",
+		orig_buff_x, orig_buff_y, zoomed_x, zoomed_y);
+
+	p += sprintf(p, "============================================\n");
+
+	for (i = 0x0; i <= 0x01C4; i += 4) {
+		reg = readl(dfli->reg_base + i);
+		p += sprintf(p, "0x%08x "
+			"0x%08x\n", i, reg);
+	}
+
+
+	p += sprintf(p, "-------<End>-------\n");
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+	
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+__init int
+dump_lcd_init_module( int id, struct fb_info *fi)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	struct lcd_debug_data *db_data;
+	char dump_entry[30];
+
+	printk(KERN_INFO "Initialize /proc/mv_dump_lcd%d\n", id);
+	printk(KERN_INFO "use cat /proc/mv_dump_lcd%d to see reg settings\n",
+		id);
+	sprintf( dump_entry, "mv_lcd%d", id);
+	res = create_proc_entry(dump_entry, S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+
+	/*
+	 * Prepare private data.
+	 */
+	db_data = kzalloc(sizeof(struct lcd_debug_data), GFP_KERNEL);
+	db_data->id = id;
+	db_data->fi = fi;
+	res->read_proc = proc_lcd_read;
+	res->write_proc = proc_lcd_write;
+	res->data = db_data;
+#endif
+
+	return 0;
+}
+
+
+
+int dovefb_determine_best_pix_fmt(struct fb_var_screeninfo *var,
+		struct dovefb_layer_info *dfli)
+{
+	/*
+	 * Pseudocolor mode?
+	 */
+	if (var->bits_per_pixel == 8)
+		return PIX_FMT_PSEUDOCOLOR;
+
+	/* YUV for video layer only. */
+	if (dfli->type == DOVEFB_OVLY_PLANE) {
+		/*
+		 * Check for YUV422PACK.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 16 &&
+		    var->green.length == 16 && var->blue.length == 16) {
+			if (var->red.offset >= var->blue.offset) {
+				if (var->red.offset == 4)
+					return PIX_FMT_UYVY422PACK;
+				else
+					return PIX_FMT_YUV422PACK;
+			} else
+				return PIX_FMT_YVU422PACK;
+		}
+
+		/*
+		 * Check for YUV422PLANAR.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 8 &&
+		    var->green.length == 4 && var->blue.length == 4) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_YUV422PLANAR;
+			else
+				return PIX_FMT_YVU422PLANAR;
+		}
+
+		/*
+		 * Check for YUV420PLANAR.
+		 */
+		if (var->bits_per_pixel == 12 && var->red.length == 8 &&
+		    var->green.length == 2 && var->blue.length == 2) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_YUV420PLANAR;
+			else
+				return PIX_FMT_YVU420PLANAR;
+		}
+	}
+
+	/*
+	 * Check for 565/1555.
+	 */
+	if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
+	    var->green.length <= 6 && var->blue.length <= 5) {
+		if (var->transp.length == 0) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_RGB565;
+			else
+				return PIX_FMT_BGR565;
+		}
+
+		if (var->transp.length == 1 && var->green.length <= 5) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_RGB1555;
+			else
+				return PIX_FMT_BGR1555;
+		}
+
+		/* fall through */
+	}
+
+	/*
+	 * Check for 888/A888.
+	 */
+	if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
+	    var->green.length <= 8 && var->blue.length <= 8) {
+		if (var->bits_per_pixel == 24 && var->transp.length == 0) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_RGB888PACK;
+			else
+				return PIX_FMT_BGR888PACK;
+		}
+
+		if (var->bits_per_pixel == 32 && var->transp.length == 8) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_RGBA888;
+			else
+				return PIX_FMT_BGRA888;
+		} else {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_RGB888UNPACK;
+			else
+				return PIX_FMT_BGR888UNPACK;
+		}
+
+
+		/* fall through */
+	}
+
+	return -EINVAL;
+}
+
+
+void dovefb_set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+{
+	switch (pix_fmt) {
+	case PIX_FMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_BGR565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 11;   var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_RGB1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 10;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		break;
+	case PIX_FMT_BGR1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 10;   var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		break;
+	case PIX_FMT_RGB888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_BGR888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_RGB888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_BGR888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_RGBA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		break;
+	case PIX_FMT_BGRA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		break;
+	case PIX_FMT_PSEUDOCOLOR:
+		var->bits_per_pixel = 8;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 0;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+
+	/* Video layer only */
+	case PIX_FMT_YUV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;	 var->red.length = 16;
+		var->green.offset = 4;   var->green.length = 16;
+		var->blue.offset = 0;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YVU422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;	 var->red.length = 16;
+		var->green.offset = 8;   var->green.length = 16;
+		var->blue.offset = 12;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YUV422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;	 var->red.length = 8;
+		var->green.offset = 4;   var->green.length = 4;
+		var->blue.offset = 0;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YVU422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 4;
+		var->blue.offset = 12;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YUV420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 4;	 var->red.length = 8;
+		var->green.offset = 2;   var->green.length = 2;
+		var->blue.offset = 0;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YVU420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 2;
+		var->blue.offset = 10;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_UYVY422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 4;     var->red.length = 16;
+		var->green.offset = 12;   var->green.length = 16;
+		var->blue.offset = 0;    var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	default:
+	     printk(KERN_ERR "Unknown pixel format (%d).\n", pix_fmt);
+	     dump_stack();
+	}
+}
+
+void dovefb_set_mode(struct dovefb_layer_info *dfli,
+		struct fb_var_screeninfo *var, struct fb_videomode *mode,
+		int pix_fmt, int ystretch)
+{
+	dovefb_set_pix_fmt(var, pix_fmt);
+
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->xres_virtual = max(var->xres, var->xres_virtual);
+	if (ystretch)
+		var->yres_virtual = dfli->fb_size /
+			(var->xres_virtual * (var->bits_per_pixel >> 3));
+	else
+		var->yres_virtual = max(var->yres, var->yres_virtual);
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->pixclock = mode->pixclock;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->rotate = FB_ROTATE_UR;
+}
+
+int dovefb_check_var(struct fb_var_screeninfo *var, struct fb_info *fi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+	if (var->xoffset + var->xres > var->xres_virtual ||
+	    var->yoffset + var->yres > var->yres_virtual) {
+		printk(KERN_ERR "Visible area is not fully"
+			" inside virtual buffer.\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (var->xres_virtual * var->yres_virtual *
+	    (var->bits_per_pixel >> 3) > dfli->fb_size) {
+		printk(KERN_ERR "Requested FB size is too big.\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_DOVEFB_FORCE_EDID_RES
+	if ((dfli->type == DOVEFB_GFX_PLANE) && (dfli->info->edid_en)) {
+		int mode_valid = 0;
+
+		if (!mode_valid && fi->monspecs.gtf && 
+		    !fb_get_mode(FB_MAXTIMINGS, 0, var, fi))
+			mode_valid = 1;
+
+		if (!mode_valid && fi->monspecs.modedb_len) {
+			const struct fb_videomode *mode;
+
+			mode = fb_find_best_mode(var, &fi->modelist);
+			if (mode) {
+				fb_videomode_to_var(var, mode);
+				mode_valid = 1;
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+
+static u32 to_rgb(u16 red, u16 green, u16 blue)
+{
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+
+	return (red << 16) | (green << 8) | blue;
+}
+
+int dovefb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		unsigned int blue, unsigned int trans, struct fb_info *fi)
+{
+	struct dovefb_layer_info *dlfi = fi->par;
+	u32 val;
+
+	if (fi->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		val =  chan_to_field(red,   &fi->var.red);
+		val |= chan_to_field(green, &fi->var.green);
+		val |= chan_to_field(blue , &fi->var.blue);
+		dlfi->pseudo_palette[regno] = val;
+	}
+
+	if (fi->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
+		val = to_rgb(red, green, blue);
+		writel(val, dlfi->reg_base + LCD_SPU_SRAM_WRDAT);
+		writel(0x8300 | regno, dlfi->reg_base + LCD_SPU_SRAM_CTRL);
+	}
+
+	return 0;
+}
+
+/*
+ *  dovefb_handle_irq (two lcd controllers)
+ */
+static irqreturn_t dovefb_handle_irq(int irq, void *dev_id)
+{
+	struct dovefb_info *dfi = (struct dovefb_info *)dev_id;
+	u32     isr;
+	u32	ret = 0;
+
+	isr = readl(dfi->reg_base + SPU_IRQ_ISR);
+
+	/*
+	 * Fix me:
+	 * Currently, hardware won't generate video layer IRQ to
+	 * bit31 while setting reg, IOPAD_CONTROL, bit [19:18]
+	 * to 0x3. We check vsync to make a workaround version. 
+	 */
+	if (isr & (DOVEFB_VID_INT_MASK|DOVEFB_VSYNC_INT_MASK)) {
+		ret += dovefb_ovly_handle_irq(isr, dfi->vid_plane);
+		isr &= ~DOVEFB_VID_INT_MASK;
+	}
+	
+	if (isr & (DOVEFB_GFX_INT_MASK|DOVEFB_VSYNC_INT_MASK)) {
+		ret += dovefb_gfx_handle_irq(isr, dfi->gfx_plane);
+		isr &= ~DOVEFB_GFX_INT_MASK;
+	}
+
+	if (isr & DOVEFB_VSYNC_INT_MASK)
+		isr &= ~DOVEFB_VSYNC_INT_MASK;
+
+	writel(isr, dfi->reg_base + SPU_IRQ_ISR);
+
+	return IRQ_RETVAL(ret);
+}
+
+
+unsigned int dovefb_dump_regs(struct dovefb_info *dfi)
+{
+	u32 i;
+	u32 reg;
+	printk(KERN_INFO "Inside dovefb_lcd_dump:\n");
+
+	for (i = 0xC0; i <= 0x01C4; i += 4) {
+		reg = readl(dfi->reg_base + i);
+		printk(KERN_INFO "Dumping LCD: offset=0x%08x, "
+			"reg=0x%08x\n", i, reg);
+	}
+
+	return 0;
+}
+
+
+#ifndef MODULE
+int __init dovefb_parse_options(char *options, struct dovefb_info *info,
+		struct dovefb_mach_info *dmi, int id)
+{
+	char *name;
+	unsigned int namelen;
+	unsigned int xres = 0, yres = 0, bpp = 16, refresh = 0;
+	char devname[8];
+
+	info->mode_option = NULL;
+
+	if (!options)
+		return -1;
+
+	sprintf(devname, "lcd%d:", id);
+	name = strstr(options, devname);
+	if (name == NULL)
+		return -1;
+	name += strlen(devname);
+
+	info->edid_en = 0;
+
+	namelen = strlen(name);
+	info->mode_option = options;
+
+	xres = simple_strtoul(name, &name, 10);
+	if (xres == 0)
+		goto bad_options;
+	if ((name[0] != 'x') && (name[0] != 'X'))
+		goto bad_options;
+	name++;
+
+	yres = simple_strtoul(name, &name, 10);
+	if (yres == 0)
+		goto bad_options;
+	if (name[0] != '-')
+		goto bad_options;
+	name++;
+
+	bpp = simple_strtoul(name, &name, 10);
+	if (bpp == 0)
+		goto bad_options;
+	if (name[0] != '@')
+		goto bad_options;
+	name++;
+
+	refresh = simple_strtoul(name, &name, 10);
+	if (refresh == 0)
+		goto bad_options;
+
+	if (name[0] == '-') {
+		/* This can be either "edid" or the fixed output resolution */
+		if (strncmp("-edid", name, 5) == 0) {
+			info->edid_en = 1;
+			name += 5;
+		}
+
+		if (name[0] == '-') {
+			/* Get the fixed output resolution */
+			name++;
+			info->out_vmode.xres = simple_strtoul(name, &name, 10);
+			if (info->out_vmode.xres == 0)
+				goto bad_options;
+			if ((name[0] != 'x') && (name[0] != 'X'))
+				goto bad_options;
+			name++;
+
+			info->out_vmode.yres = simple_strtoul(name, &name, 10);
+			if (info->out_vmode.yres == 0)
+				goto bad_options;
+			info->fixed_output = 1;
+		}
+	}
+	printk(KERN_INFO "  o Kernel parameter: %dx%d-%d@%d.\n", xres, yres,
+			bpp, refresh);
+	if (info->fixed_output)
+		printk(KERN_INFO "  o Fixed output resolution %dx%d.\n",
+				info->out_vmode.xres, info->out_vmode.yres);
+	info->dft_vmode.xres = xres;
+	info->dft_vmode.yres = yres;
+	info->dft_vmode.refresh = refresh;
+	info->gfx_plane->fb_info->var.bits_per_pixel = bpp;
+	switch (bpp) {
+	case (8):
+		dmi->pix_fmt = PIX_FMT_PSEUDOCOLOR;
+		break;
+	case(16):
+		dmi->pix_fmt = PIX_FMT_RGB565;
+		break;
+	case (24):
+		dmi->pix_fmt = PIX_FMT_RGB888PACK;
+		break;
+	case (32):
+		dmi->pix_fmt = PIX_FMT_RGBA888;
+		break;
+	default:
+		goto bad_options;
+	}
+
+	return 0;
+
+bad_options:
+	if (!info->edid_en) {
+		printk(KERN_INFO "  o Bad FB driver option %s , \
+			use <xres>x<yres>-<bpp>@<refresh>[-edid][-out res]"
+			"[-<outx>x<outy>].\n", options);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+static int dovefb_init_layer(struct platform_device *pdev,
+		enum dovefb_type type, struct dovefb_info *info,
+		struct resource *res)
+{
+	struct dovefb_mach_info *dmi = pdev->dev.platform_data;
+	struct fb_info *fi = 0;
+	struct dovefb_layer_info *dfli = 0;
+	int ret;
+
+	fi = framebuffer_alloc(sizeof(struct dovefb_layer_info), &pdev->dev);
+	if (fi == NULL) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/* Initialize private data */
+	dfli = fi->par;
+	dfli->fb_info = fi;
+	dfli->dev = &pdev->dev;
+	dfli->is_blanked = 0;
+	dfli->active = dmi->active;
+	dfli->enabled = 1;
+	dfli->type = type;
+	dfli->info = info;
+	dfli->reg_base = info->reg_base;
+	dfli->cur_fbid = 0;
+	dfli->src_mode = SHM_NORMAL;
+	dfli->checkbuf_timer_exist = 0;
+
+	if (type == DOVEFB_GFX_PLANE) {
+		dfli->cursor_enabled = 0;
+		dfli->cursor_cfg = 1;
+		dfli->hwc_buf = (u8 *)__get_free_pages(GFP_DMA|GFP_KERNEL,
+						get_order(MAX_HWC_SIZE));
+		strcpy(fi->fix.id, dmi->id_gfx);
+	} else {
+		strcpy(fi->fix.id, dmi->id_ovly);
+	}
+
+	/*
+	 * Initialise static fb parameters.
+	 */
+	fi->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
+		    FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	fi->node = -1;
+	fi->fix.type = FB_TYPE_PACKED_PIXELS;
+	fi->fix.type_aux = 0;
+	fi->fix.xpanstep = 1;
+	fi->fix.ypanstep = 1;
+	fi->fix.ywrapstep = 0;
+	fi->fix.mmio_start = res->start;
+	fi->fix.mmio_len = res->end - res->start + 1;
+	fi->fix.accel = FB_ACCEL_NONE;
+	fi->fbops = ((type == DOVEFB_GFX_PLANE) ?
+			&dovefb_gfx_ops : &dovefb_ovly_ops);
+	fi->pseudo_palette = dfli->pseudo_palette;
+
+	/*
+	 * Allocate framebuffer memory.
+	 */
+	dfli->fb_size = PAGE_ALIGN(DEFAULT_FB_SIZE*4);
+
+	dfli->fb_start = NULL;
+	dfli->fb_start_dma = 0;
+	if ((dmi->fb_mem_size[type]) && (dmi->fb_mem_size[type] >= dfli->fb_size)) {
+		dfli->new_addr = 0;
+		dfli->mem_status = 1;
+		dfli->fb_start_dma = (dma_addr_t)dmi->fb_mem[type];
+#ifdef CONFIG_CACHE_FEROCEON_L2_WRITETHROUGH
+		dfli->fb_start = (void *)ioremap_cached((unsigned long)dfli->fb_start_dma, dfli->fb_size);
+#else
+		dfli->fb_start = (void *)ioremap_wc((unsigned long)dfli->fb_start_dma, dfli->fb_size);
+#endif
+	}
+#ifdef USING_SAME_BUFF
+	if ((gfx_fb_start == 0) || (vid_fb_start == 0) ) {
+#endif
+//#ifdef CONFIG_ARCH_DOVE
+#if 1
+	if (!dfli->fb_start || !dfli->fb_start_dma)
+		dfli->fb_start = dma_alloc_writecombine(dfli->dev, dfli->fb_size,
+							&dfli->fb_start_dma,
+							GFP_KERNEL);
+	if (!dfli->fb_start || !dfli->fb_start_dma) {
+#else
+	{
+#endif
+		dfli->new_addr = 0;
+		dfli->mem_status = 1;
+		dfli->fb_start = (void *)__get_free_pages(GFP_DMA | GFP_KERNEL,
+					get_order(dfli->fb_size));
+		dfli->fb_start_dma = (dma_addr_t)__virt_to_phys(dfli->fb_start);
+	}
+
+	if (dfli->fb_start == NULL) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+#ifdef USING_SAME_BUFF
+		if(strstr(fi->fix.id, "GFX")) {
+			gfx_fb_start = dfli->fb_start;
+			gfx_fb_start_dma = dfli->fb_start_dma;
+		} else {
+			vid_fb_start = dfli->fb_start;
+			vid_fb_start_dma = dfli->fb_start_dma;
+		}
+		memset(dfli->fb_start, 0, dfli->fb_size);
+	} else {
+		if(strstr(fi->fix.id, "GFX")) {
+			dfli->fb_start = gfx_fb_start;
+			dfli->fb_start_dma = gfx_fb_start_dma;
+		} else {
+			dfli->fb_start = vid_fb_start;
+			dfli->fb_start_dma = vid_fb_start_dma;
+		}
+	}
+#else
+	memset(dfli->fb_start, 0, dfli->fb_size);
+#endif
+	fi->fix.smem_start = dfli->fb_start_dma;
+	fi->fix.smem_len = dfli->fb_size;
+	fi->screen_base = dfli->fb_start;
+	fi->screen_size = dfli->fb_size;
+
+	/*
+	 * Set video mode according to platform data.
+	 */
+	dovefb_set_mode(dfli, &fi->var, dmi->modes, dmi->pix_fmt, 0);
+
+	/*
+	 * Allocate color map.
+	 */
+	if (fb_alloc_cmap(&fi->cmap, 256, 0) < 0) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	if (type == DOVEFB_GFX_PLANE) {
+		info->gfx_plane = dfli;
+ 		dump_lcd_init_module( strstr(fi->fix.id, "1") ? 1:0,
+			fi);
+	} else
+		info->vid_plane = dfli;
+
+	return 0;
+
+failed:
+	printk(KERN_INFO "DoveFB: dovefb_init_layer() failed (%d).\n", ret);
+	fb_dealloc_cmap(&fi->cmap);
+
+	if (dfli->fb_start != NULL) {
+		if (dfli->mem_status)
+			free_pages((unsigned long)dfli->fb_start,
+				get_order(dfli->fb_size));
+//#ifdef CONFIG_ARCH_DOVE
+#if 0
+		else
+			dma_free_writecombine(dfli->dev, dfli->fb_size,
+				dfli->fb_start, dfli->fb_start_dma);
+#endif
+	}
+
+	if (type == DOVEFB_GFX_PLANE)
+		free_pages((unsigned long)dfli->hwc_buf,
+				get_order(MAX_HWC_SIZE));
+
+	if (fi != NULL)
+		framebuffer_release(fi);
+
+	return ret;
+}
+
+/*
+ * Enable LCD0 output, this is a needed till the issue is fixed in future
+ * revisions.
+ */
+static int dovefb_enable_lcd0(struct platform_device *pdev)
+{
+	struct dovefb_mach_info *dmi;
+	struct resource *res;
+	void *lcd0_base;
+
+	dmi = pdev->dev.platform_data;
+	if (dmi == NULL)
+		return -EINVAL;
+
+	if (dmi->enable_lcd0) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (res == NULL)
+			return -EINVAL;
+		lcd0_base = ioremap_nocache(res->start,
+				res->end - res->start);
+		if (lcd0_base == NULL)
+			return -ENOMEM;
+		writel(0x01, lcd0_base + LCD_CFG_SCLK_DIV);
+		iounmap(lcd0_base);
+	}
+
+	return 0;
+}
+
+static void dovefb_config_vga_calibration(struct dovefb_info *info)
+{
+#if 0 //KW-LCD
+	if (info->id == 1) {
+//		u32 portB_config = readl(DOVE_LCD1_CONFIG_VIRT);
+		writel(0, DOVE_LCD1_CONFIG_VIRT);
+	}
+#endif
+}
+
+//#include <video/dovefb_gpio.h>
+
+void dovefb_conf_mbus_windows(struct dovefb_info *info,
+		struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	for (i = 0; i < LCD_WIN_NUM; i++) {
+		writel(0x0, info->reg_base + LCD_WIN_CTRL(i));
+		writel(0x0, info->reg_base + LCD_WIN_BASE(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
+
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			info->reg_base + LCD_WIN_CTRL(i));
+		writel(cs->base, info->reg_base + LCD_WIN_BASE(i));
+	}
+}
+
+static void dovefb_conf_lvds(struct dovefb_info *info, struct dovefb_mach_info *dmi)
+{
+	uint32_t reg;
+
+	reg = readl(info->reg_base + LCD_LVDS_CLK_CFG);
+
+	/* Enable LVDS clock. */
+	reg &= ~LCD_LVDS_CFG_SER_MASK;
+	reg |= LCD_LVDS_CFG_SER_EN(1);
+
+	/* Set LVDS Pin count & 24-bit option. */
+	reg &= ~LCD_LVDS_CFG_PIN_CNT_MASK;
+	if (dmi->io_pin_allocation == IOPAD_DUMB24) {
+		reg |= LCD_LVDS_CFG_PIN_CNT_24;
+		reg &= ~LCD_LVDS_CFG_24BIT_MODE_MASK;
+		if (dmi->lvds_info.lvds_24b_option == 1)
+			reg |= LCD_LVDS_CFG_24BIT_OPT1;
+		else
+			reg |= LCD_LVDS_CFG_24BIT_OPT2;
+	} else {
+		reg |= LCD_LVDS_CFG_PIN_CNT_18;
+	}
+
+	/* Set data delay. */
+	reg &= ~LCD_LVDS_CFG_TICK_DRV_MASK;
+	reg |= LCD_LVDS_CFG_TICK_DRV(dmi->lvds_info.lvds_tick_drv);
+	writel(reg, info->reg_base + LCD_LVDS_CLK_CFG);
+	return;
+}
+
+static int __devinit dovefb_probe(struct platform_device *pdev)
+{
+	struct dovefb_mach_info *dmi;
+	struct dovefb_info *info = NULL;
+	struct resource *res;
+	int ret;
+	char *option = NULL;
+
+	dmi = pdev->dev.platform_data;
+	if (dmi == NULL)
+		return -EINVAL;
+
+	printk(KERN_INFO "Dove FB driver:\n");
+	ret = dovefb_enable_lcd0(pdev);
+	if (ret)
+		return -EINVAL;
+
+	info = kzalloc(sizeof(struct dovefb_info), GFP_KERNEL);
+	if (info == NULL) {
+		printk(KERN_ERR "DoveFB: Failed to allocate mem.\n");
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/*
+	 * Map LCD controller registers.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		printk(KERN_ERR "DoveFB: Failed to retrieve resources.\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	info->reg_base = ioremap_nocache(res->start, res->end - res->start);
+	if (info->reg_base == NULL) {
+		printk(KERN_ERR "DoveFB: Failed to map regs memory.\n");
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/*
+	 * Program MBUS remapping windows if we are asked to.
+	 */
+	if (dmi->dram != NULL)
+		dovefb_conf_mbus_windows(info, dmi->dram);
+
+#if 0 //KW-LCD
+	/*
+	* initialize lcd gpio access interface
+	*/
+	dovefb_save_regbase(info->reg_base, pdev->id);
+#endif
+	if (dovefb_init_layer(pdev, DOVEFB_GFX_PLANE, info, res)) {
+		printk(KERN_ERR "dovefb_init_layer() for GFX layer failed.\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	if (dovefb_init_layer(pdev, DOVEFB_OVLY_PLANE, info, res)) {
+		printk(KERN_ERR "dovefb_init_layer() for VID layer failed.\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	/* Initialize private data */
+	platform_set_drvdata(pdev, info);
+	info->dev = &pdev->dev;
+
+	/* General FB info */
+	info->id = pdev->id;
+	info->edid = 0;
+	info->io_pin_allocation = dmi->io_pin_allocation;
+	info->pix_fmt = dmi->pix_fmt;
+	info->panel_rbswap = dmi->panel_rbswap;
+	info->fixed_full_div = dmi->fixed_full_div;
+	info->full_div_val = dmi->full_div_val;
+#if 0 //KW-LCD
+	/* get LCD clock information. */
+	info->clk = clk_get(&pdev->dev, "LCDCLK");
+	if (IS_ERR(info->clk))
+		dev_notice(&pdev->dev, "cannot get clkdev\n");
+	else
+		clk_enable(info->clk);
+#endif
+#ifndef MODULE
+	/*
+	 * Get video option from boot args
+	 */
+	if (fb_get_options("dovefb", &option))
+		return -ENODEV;
+
+	if (!option) {
+		printk(KERN_WARNING "DoveFB: No kernel parameters provided, "
+				"using default.\n");
+		option = CONFIG_FB_DOVE_CLCD_DEFAULT_OPTION;
+	}
+	/*
+	 * Parse video mode out and save into var&par.
+	 */
+	ret = dovefb_parse_options(option, info, dmi, pdev->id);
+#endif
+	dovefb_config_vga_calibration(info);
+
+	ret = dovefb_gfx_init(info, dmi);
+	if (ret) {
+		printk(KERN_ERR "DoveFB: dovefb_gfx_init() "
+				"returned %d.\n", ret);
+		goto failed;
+	}
+
+	ret = dovefb_ovly_init(info, dmi);
+	if (ret) {
+		printk(KERN_ERR "DoveFB: dovefb_ovly_init() "
+				"returned %d.\n", ret);
+		goto failed;
+	}
+
+	/*
+	 * Get IRQ number.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	/*
+	 * Register irq handler.
+	 */
+	ret = request_irq(res->start, dovefb_handle_irq, IRQF_SHARED,
+			pdev->name, info);
+	if (ret < 0) {
+		printk(KERN_ERR "DoveFB: Failed to register IRQ.\n");
+		goto failed_irq;
+	}
+
+	/*
+	 * Disable interrupts in default.
+	 */
+	writel( 0x0, info->reg_base + SPU_IRQ_ENA);
+
+	/*
+	 * Setup LVDS parameters if needed.
+	 */
+	if (dmi->lvds_info.enabled)
+		dovefb_conf_lvds(info, dmi);
+
+	/*
+	 * Register framebuffers.
+	 */
+	ret = register_framebuffer(info->gfx_plane->fb_info);
+	if (ret < 0) {
+		printk(KERN_ERR "DoveFB: Failed to register GFX FB.\n");
+		goto failed_irq;
+	}
+
+
+	ret = register_framebuffer(info->vid_plane->fb_info);
+	if (ret < 0) {
+		printk(KERN_ERR "doveFB: Failed to register VID FB.\n");
+		ret = -ENXIO;
+		goto failed_fb;
+	}
+
+	printk(KERN_INFO "  o dovefb: frame buffer device was successfully "
+			"loaded.\n");
+	return 0;
+
+
+failed_fb:
+	unregister_framebuffer(info->vid_plane->fb_info);
+failed_irq:
+	free_irq(res->start, info);
+failed:
+
+#if 0 //KW-LCD
+	if (info && !IS_ERR(info->clk)) {
+		clk_disable(info->clk);
+		clk_put(info->clk);
+	}
+#endif
+	platform_set_drvdata(pdev, NULL);
+
+	if (info && info->reg_base)
+		iounmap(info->reg_base);
+
+	kfree(info);
+
+	printk(KERN_INFO "dovefb: frame buffer device init failed (%d)\n", ret);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int dovefb_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct dovefb_info *dfi = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "dovefb_suspend(): state = %d.\n", mesg.event);	
+
+	/* Disable all interrupts */
+	writel( 0x0, dfi->reg_base+SPU_IRQ_ENA);
+
+	/* Save cursor related registers */
+	dfi->LCD_SPU_HWC_HPXL_VLN_saved_value =
+		readl(dfi->reg_base + LCD_SPU_HWC_HPXL_VLN);
+	dfi->LCD_SPU_ALPHA_COLOR1_saved_value =
+		readl(dfi->reg_base + LCD_SPU_ALPHA_COLOR1);
+	dfi->LCD_SPU_ALPHA_COLOR2_saved_value =
+		readl(dfi->reg_base + LCD_SPU_ALPHA_COLOR2);
+
+	/* Save colorkey related regiters */
+	dfi->LCD_SPU_COLORKEY_Y_saved_value =
+		readl(dfi->reg_base + LCD_SPU_COLORKEY_Y);
+	dfi->LCD_SPU_COLORKEY_U_saved_value =
+		readl(dfi->reg_base + LCD_SPU_COLORKEY_U);
+	dfi->LCD_SPU_COLORKEY_V_saved_value =
+		readl(dfi->reg_base + LCD_SPU_COLORKEY_V);
+	dfi->LCD_SPU_DMA_CTRL1_saved_value =
+		readl(dfi->reg_base + LCD_SPU_DMA_CTRL1);
+	dfi->LCD_SPU_ADV_REG_saved_value =
+		readl(dfi->reg_base + LCD_SPU_ADV_REG);
+	
+	console_lock();
+//	acquire_console_sem();
+
+	if (dovefb_gfx_suspend(dfi->gfx_plane, mesg)) {
+		printk(KERN_INFO "dovefb_suspend(): "
+				"dovefb_gfx_suspend() failed.\n");
+//		release_console_sem();
+		console_unlock();
+		return -1;
+	}
+
+	if (dovefb_ovly_suspend(dfi->vid_plane, mesg)) {
+		printk(KERN_INFO "dovefb_suspend(): "
+				"dovefb_ovly_suspend() failed.\n");
+		console_unlock();
+		//release_console_sem();
+		return -1;
+	}
+
+	pdev->dev.power.power_state = mesg;
+	if (!IS_ERR(dfi->clk))
+		clk_disable(dfi->clk);
+	console_unlock();
+	//release_console_sem();
+
+	return 0;
+}
+int lcd_set_clock(struct clk *clk, unsigned long rate);
+static int dovefb_resume(struct platform_device *pdev)
+{
+	struct dovefb_info *dfi = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "dovefb_resume().\n");
+
+	 console_lock();
+	//acquire_console_sem();
+	if (!IS_ERR(dfi->clk))
+		clk_enable(dfi->clk);
+
+	if (dovefb_enable_lcd0(pdev)) {
+		printk(KERN_INFO "dovefb_resume(): "
+				"dovefb_enable_lcd0() failed.\n");
+		return -1;
+	}
+
+	dovefb_config_vga_calibration(dfi);
+
+	if (dovefb_gfx_resume(dfi->gfx_plane)) {
+		printk(KERN_INFO "dovefb_resume(): "
+				"dovefb_gfx_resume() failed.\n");
+		return -1;
+	}
+
+	if (dovefb_ovly_resume(dfi->vid_plane)) {
+		printk(KERN_INFO "dovefb_resume(): "
+				"dovefb_ovly_resume() failed.\n");
+		return -1;
+	}
+
+	/* Restore cursor related registers */
+	writel(dfi->LCD_SPU_HWC_HPXL_VLN_saved_value,
+		dfi->reg_base + LCD_SPU_HWC_HPXL_VLN);
+	writel(dfi->LCD_SPU_ALPHA_COLOR1_saved_value,
+		dfi->reg_base + LCD_SPU_ALPHA_COLOR1);
+	writel(dfi->LCD_SPU_ALPHA_COLOR2_saved_value,
+		dfi->reg_base + LCD_SPU_ALPHA_COLOR2);
+
+	/* Restore colorkey related regiters */
+	writel(dfi->LCD_SPU_COLORKEY_Y_saved_value,
+		dfi->reg_base + LCD_SPU_COLORKEY_Y);
+	writel(dfi->LCD_SPU_COLORKEY_U_saved_value,
+		dfi->reg_base + LCD_SPU_COLORKEY_U);
+	writel(dfi->LCD_SPU_COLORKEY_V_saved_value,
+		dfi->reg_base + LCD_SPU_COLORKEY_V);
+	writel(dfi->LCD_SPU_DMA_CTRL1_saved_value,
+		dfi->reg_base + LCD_SPU_DMA_CTRL1);
+	writel(dfi->LCD_SPU_ADV_REG_saved_value,
+		dfi->reg_base + LCD_SPU_ADV_REG);
+
+	/* Disable all interrupts */
+	writel( 0x0, dfi->reg_base + SPU_IRQ_ENA);
+
+	 console_unlock();
+	//release_console_sem();
+
+	return 0;
+}
+#endif
+
+static struct platform_driver dovefb_driver = {
+	.probe		= dovefb_probe,
+#ifdef CONFIG_PM
+	.suspend	= dovefb_suspend,
+	.resume		= dovefb_resume,
+#endif
+	.driver		= {
+		.name	= "dovefb",
+		.owner	= THIS_MODULE,
+	},
+};
+#ifdef CONFIG_SPI_MV
+extern int __devinit mv_spi_init(void);
+#endif
+static int __devinit dovefb_init(void)
+{
+	int rc;
+	rc = platform_driver_register(&dovefb_driver);
+	if (rc)
+		return rc;
+#ifdef CONFIG_SPI_MV
+	return mv_spi_init();
+#else
+	return rc;
+#endif
+}
+
+late_initcall(dovefb_init);
+
+MODULE_AUTHOR("Green Wan <gwan@marvell.com>");
+MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com>");
+MODULE_AUTHOR("Shadi Ammouri <shadi@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for Dove");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/marvell/dovefb_display.c b/drivers/video/marvell/dovefb_display.c
new file mode 100644
index 0000000..aa8d278
--- /dev/null
+++ b/drivers/video/marvell/dovefb_display.c
@@ -0,0 +1,203 @@
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/smp_lock.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/vt.h>
+#include <linux/init.h>
+#include <linux/linux_logo.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/console.h>
+#include <linux/kmod.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/efi.h>
+#include <linux/fb.h>
+
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+#include <video/dovedcon.h>
+#include <video/dovefb_display.h>
+
+/*
+ * LCD controll register physical address
+ */
+static unsigned int lcd_regbase;
+//module_param(lcd_regbase, uint, 0xf1810000);
+module_param(lcd_regbase, uint, 0);
+MODULE_PARM_DESC(lcd_regbase, "DCON register base");
+
+/*
+ * 0 means lcd0 = regbase + 0x0, lcd1 = regbase + 0x10000;
+ * 1 means lcd0 = regbase + 0x10000, lcd1 = regbase + 0x0;
+ */
+static unsigned int lcdseq;
+module_param(lcdseq, uint, 1);
+MODULE_PARM_DESC(lcdseq, "LCD sequence");
+
+extern struct class *fb_class;
+static void *lcd0_regbase;
+static void *lcd1_regbase;
+static void *dcon_regbase;
+
+static int config_dcon(unsigned int settings)
+{
+	writel(settings, dcon_regbase+DCON_CTRL0);
+	return 0;
+}
+
+static int config_porta(unsigned int settings)
+{
+	unsigned int ctrl0;
+
+	ctrl0 = readl(dcon_regbase+DCON_CTRL0);
+	ctrl0 &= ~(0x3 << 6);
+	ctrl0 |= (settings << 6);
+	writel(ctrl0, dcon_regbase+DCON_CTRL0);
+
+	return 0;
+}
+
+static int config_portb(unsigned int settings)
+{
+	unsigned int ctrl0;
+
+	ctrl0 = readl(dcon_regbase+DCON_CTRL0);
+	ctrl0 &= ~(0x3 << 8);
+	ctrl0 |= (settings << 8);
+	writel(ctrl0, dcon_regbase+DCON_CTRL0);
+
+	return 0;
+}
+
+/*
+ * #define FBIO_SET_DISPLAY_MODE   0
+ * #define FBIO_GET_DISPLAY_MODE   1
+ * #define FBIO_CONFIG_DCON        2
+ * #define FBIO_CONFIG_PORTA       3
+ * #define FBIO_CONFIG_PORTB       4
+ * #define FBIO_GET_DCON_STATUS    5
+ */
+static long display_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case FBIO_SET_DISPLAY_MODE:
+		/* configure display mode. */
+		printk(KERN_INFO "Reserved!! Not implement yet.\n");
+		break;
+	case FBIO_GET_DISPLAY_MODE:
+		/* get display configuration. */
+		printk(KERN_INFO "Reserved!! Not implement yet.\n");
+		break;
+	case FBIO_CONFIG_DCON:
+	{
+		unsigned int settings;
+		/* Get data from user space. */
+		if (copy_from_user(&settings, (void *)arg, sizeof(unsigned int)))
+			return -EFAULT;
+		config_dcon(settings);
+		break;
+	}
+	case FBIO_CONFIG_PORTA:
+	{
+		unsigned int settings;
+		/* Get data from user space. */
+		if (copy_from_user(&settings, (void *)arg, sizeof(unsigned int)))
+			return -EFAULT;
+
+		config_porta(settings);
+		break;
+	}
+	case FBIO_CONFIG_PORTB:
+	{
+		unsigned int settings;
+
+		/* Get data from user space. */
+		if (copy_from_user(&settings, (void *)arg, sizeof(unsigned int)))
+			return -EFAULT;
+
+		config_portb(settings);
+		break;
+	}
+	case FBIO_GET_DCON_STATUS:
+	{
+		unsigned int dc_status;
+
+		/* get dcon configuration. */
+		dc_status = readl(dcon_regbase+DCON_CTRL0);
+
+		printk(KERN_INFO "get dcon config.\n");
+		if (copy_to_user((void *)arg, &dc_status, sizeof(unsigned int)))
+			return -EFAULT;
+		break;
+	}
+	default:
+		printk(KERN_ERR "Unknown command\n");
+	}
+
+	return 0;
+}
+
+static const struct file_operations display_fops = {
+	.owner =	THIS_MODULE,
+	.unlocked_ioctl = display_ioctl,
+};
+
+
+static int __init
+dovefb_display_init(void)
+{
+#ifdef MTL_DEBUG
+	uint x;
+
+	printk(KERN_INFO "lcd_regbase = 0x%08x\n", lcd_regbase);
+	printk(KERN_INFO "lcdseq = %d, 1^lcdseq = %d\n", lcdseq, 1^lcdseq);
+	printk(KERN_INFO "lcdseq = %d, 0^lcdseq = %d\n", lcdseq, 0^lcdseq);
+#endif
+	printk(KERN_WARNING "dovefb_display_init\n");
+
+	/* register character. */
+	if (register_chrdev(30, "display tools", &display_fops))
+		printk("unable to get major %d for fb devs\n", 30);
+
+	if (lcd_regbase) {
+		/* remap to ctrl registers. */
+		lcd0_regbase = ioremap_nocache( lcd_regbase + (0x10000*(0^lcdseq)), (0x10000 - 1));
+		lcd1_regbase = ioremap_nocache( lcd_regbase + (0x10000*(1^lcdseq)), (0x10000 - 1));
+		dcon_regbase = ioremap_nocache( lcd_regbase + 0x20000,		    (0x10000 - 1));
+#ifdef MTL_DEBUG
+		x = readl( lcd0_regbase + 0x104 );
+		printk(KERN_INFO "debug lcd0 reg 0x104 = 0x%08x\n", x);
+		x = readl( lcd1_regbase + 0x108 );
+		printk(KERN_INFO "debug lcd0 reg 0x104 = 0x%08x\n", x);
+		x = readl( dcon_regbase + 0x000 );
+		printk(KERN_INFO "debug dcon reg 0x000 = 0x%08x\n", x);
+#endif
+	}
+
+	printk(KERN_WARNING "dovefb_display driver init ok.\n");
+	return 0;
+}
+
+static void __exit
+dovefb_display_exit(void)
+{
+	iounmap(lcd0_regbase);
+	iounmap(lcd1_regbase);
+	iounmap(dcon_regbase);
+	unregister_chrdev(30, "display tools");
+	printk(KERN_WARNING "dovefb_display driver unload OK.\n");
+}
+
+module_init(dovefb_display_init);
+module_exit(dovefb_display_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Display mode driver");
+
diff --git a/drivers/video/marvell/dovefb_gfx.c b/drivers/video/marvell/dovefb_gfx.c
new file mode 100644
index 0000000..e5e0db7
--- /dev/null
+++ b/drivers/video/marvell/dovefb_gfx.c
@@ -0,0 +1,1907 @@
+/*
+ * linux/drivers/video/dovefb.c -- Marvell DOVE LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by:
+ *	Green Wan <gwan@marvell.com>
+ *	Shadi Ammouri <shadi@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+/*
+ * 1. Adapted from:  linux/drivers/video/skeletonfb.c
+ * 2. Merged code base from: linux/drivers/video/dovefb.c (Lennert Buytenhek)
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+//#include <asm/hardware.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <linux/log2.h>
+
+#include "../edid.h"
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+
+#include "dovefb_if.h"
+#define MAX_HWC_SIZE		(64*64*2)
+#define DEFAULT_REFRESH		60	/* Hz */
+#define DEFAULT_EDID_INTERVAL   30	/* seconds */
+
+static int dovefb_fill_edid(struct fb_info *fi,
+				struct dovefb_mach_info *dmi);
+static int wait_for_vsync(struct dovefb_layer_info *dfli);
+static void dovefb_set_defaults(struct dovefb_layer_info *dfli);
+static const u8 edid_header[] = {
+        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
+};
+
+static u32 get_lcd_k_div_by_n_m(u32 f_in, u32 n_div, u32 m_div)
+{
+	u32 k = 1;
+	u64 f_vco;
+
+	/* Calculate K according to Fvco. */
+	f_vco = f_in * n_div;
+	do_div(f_vco, m_div);
+	do_div(f_vco, 1000000);
+
+	/* K is calculated according to (f_in * N / M). */
+	if((f_vco >= 600) && (f_vco <= 2400))
+		k = 1;
+	else if((f_vco >= 300) && (f_vco < 600))
+		k = 2;
+	else if((f_vco >= 150) && (f_vco < 300))
+		k = 4;
+	else if((f_vco >= 75) && (f_vco < 150))
+		k = 8;
+	else if(/*(f_vco >= 37) &&*/ (f_vco < 75))
+		k = 16;
+
+	return k;
+}
+
+static void set_lcd_clock_dividers(struct dovefb_layer_info *dfli, u32 f_in, 
+		u32 m_div, u32 n_div, u32 k_div, u32 full_div, u32 is_half_div)
+{
+//	u32 k;
+	u64 f_vco;
+	u32 reg;
+	u32 pll_vco;
+	u32 apll_lpf;
+
+	/* Calculate K according to Fvco. */
+	f_vco = f_in * n_div;
+	do_div(f_vco, m_div);
+	do_div(f_vco, 1000000);
+#if 0
+	/* K is calculated according to (f_in * N / M). */
+	if((f_vco >= 600) && (f_vco <= 2400))
+		k = 1;
+	else if((f_vco >= 300) && (f_vco < 600))
+		k = 2;
+	else if((f_vco >= 150) && (f_vco < 300))
+		k = 4;
+	else if((f_vco >= 75) && (f_vco < 150))
+		k = 8;
+	else if(/*(f_vco >= 37) &&*/ (f_vco < 75))
+		k = 16;
+
+	k = 1;
+#endif
+	pll_vco = f_vco; //f_in * n_div;
+	if(/*(pll_vco >= 600) &&*/ (pll_vco <= 720))
+		pll_vco = 1;
+	else if((pll_vco > 720) && (pll_vco <= 840))
+		pll_vco = 2;
+	else if((pll_vco > 840) && (pll_vco <= 960))
+		pll_vco = 3;
+	else if((pll_vco > 960) && (pll_vco <= 1080))
+		pll_vco = 4;
+	else if((pll_vco > 1080) && (pll_vco <= 1200))
+		pll_vco = 5;
+	else if((pll_vco > 1200) && (pll_vco <= 1320))
+		pll_vco = 6;
+	else
+		pll_vco = 7;
+
+	/* Set APLL LPF */
+	if (n_div <= 4)
+		apll_lpf = 12;
+	else if (n_div <= 22)
+		apll_lpf = 7;
+	else if (n_div <= 117)
+		apll_lpf = 4;
+	else
+		apll_lpf = 1;
+
+	printk(KERN_INFO "N = %d, M = %d, K = %d, full_div = %d, half = %d, pll_vco = %d, pll_lpf = %d.\n",
+			n_div, m_div, k_div, full_div, is_half_div, pll_vco, apll_lpf);
+
+	/* Clear SMPN */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG1_REG);
+	reg &= ~LCD_SMPN_EN_MASK;
+	reg |= LCD_SMPN_EN(0);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG1_REG);
+
+	/* Set PLL Power Down */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG0_REG);
+	reg &= ~LCD_PLL_PWR_DOWN_MASK;
+	reg |= LCD_PLL_PWR_DOWN(1);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG0_REG);
+
+	/* Set N, M, K */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG0_REG);
+	reg &= ~(LCD_PLL_NDIV_MASK | LCD_PLL_MDIV_MASK | LCD_PLL_KDIV_MASK | LCD_PLL_LPF_MASK | LCD_PLL_VCO_BAND_MASK);
+	reg |= LCD_PLL_NDIV(n_div - 1);
+	reg |= LCD_PLL_MDIV(m_div - 1);
+	reg |= LCD_PLL_KDIV((ilog2(k_div) + 1));
+	reg |= LCD_PLL_VCO_BAND(pll_vco);
+	reg |= LCD_PLL_LPF(apll_lpf);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG0_REG);
+
+	/* Set half divider */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG1_REG);
+	reg &= ~(LCD_FULL_DIV_MASK | LCD_HALF_DIV_MASK);
+	reg |= LCD_FULL_DIV(full_div);
+	reg |= LCD_HALF_DIV(is_half_div);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG1_REG);
+
+	/* Clear PLL Power Down */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG0_REG);
+	reg &= ~LCD_PLL_PWR_DOWN_MASK;
+	reg |= LCD_PLL_PWR_DOWN(0);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG0_REG);
+
+	/* Wait 0.5mSec */
+	mdelay(10);
+
+	/* Set SMPN */
+	reg = readl(dfli->reg_base + LCD_CLK_CFG1_REG);
+	reg &= ~LCD_SMPN_EN_MASK;
+	reg |= LCD_SMPN_EN(1);
+	writel(reg, dfli->reg_base + LCD_CLK_CFG1_REG);
+
+	return;
+}
+
+static inline u64 calc_diff(u64 a, u64 b)
+{
+	if (a > b)
+		return a - b;
+	else
+		return b - a;
+}
+
+
+/*
+** Calculate the best PLL parameters to get the closest output frequency.
+** out_freq = (Fin * N / M) / X;
+**  OR
+** out_freq = (Fin * N / M) / (X + 0.5)
+*/
+static void calc_best_clock_div(struct dovefb_info *info,  u32 tar_freq, u32 f_in,
+		u32 *m_div, u32 *n_div, u32 *k_div, u32 *x_div, u32 *is_half_div, u32 *lcd_div)
+{
+	u64 best_rem = 0xFFFFFFFFFFFFFFFFll;
+	u32 best_m = 0;
+	u32 best_n = 0;
+	u32 best_x = 0;
+	u32 best_k = 0;
+	u32 best_lcd_div = 0;
+	u32 half_div = 0;
+	u64 rem;
+	u64 temp;
+	u32 n, m, x, k, ld;
+	int override = 0; 	/* Used to mark special cases where the LCD */
+	u32 n_max;
+	u32 x_start, x_end;
+	u32 ld_end;
+
+	if (info->fixed_full_div) {
+		x_start = info->full_div_val;
+		x_end = x_start + 1;
+		ld_end = (64 << 10) + 1;
+	} else {
+		x_start = 1;
+		x_end = 64;
+		ld_end = 2;
+	}
+
+	n_max = /*2400000000ul / f_in;*/480;
+
+	/* Look for the best N & M values assuming that we will NOT use the
+	** HALF divider.
+	*/
+	for (n = 1; n < n_max; n++) {
+		for(m = 1; m < 4; m++) {
+			/* N * K must be smaller than 480 */
+			k = get_lcd_k_div_by_n_m(f_in, n, m);
+			if((n * k) > 480)
+				continue;
+			for(x = x_start; x < x_end; x++) {
+				for(ld = 1; ld < ld_end; ld++) {
+					temp = (u64)f_in * (u64)n;
+					do_div(temp, m);
+					/* Fin * N / M Must be < 1500MHz */
+					if(temp > 1500000000)
+						continue;
+					do_div(temp, k);
+					do_div(temp, x);
+					do_div(temp, ld);
+					rem = calc_diff(tar_freq, temp);
+					if ((rem < best_rem) ||
+					    ((override == 1) && (rem == best_rem)) ||
+					    ((rem == best_rem) && (k < best_k))) {
+						best_rem = rem;
+						best_m = m;
+						best_n = n;
+						best_x = x;
+						best_k = k;
+						best_lcd_div = ld;
+					}
+					if ((best_rem == 0) && (override == 0))
+						break;
+				}
+			}
+		}
+	}
+
+	/* Look for the best N & M values assuming that we will use the
+	** HALF divider.
+	*/
+	if ((info->fixed_full_div == 0) && (best_rem != 0)) {
+		for (n = 1; n < n_max; n++) {
+			for(m = 1; m < 4; m++) {
+				k = get_lcd_k_div_by_n_m(f_in, n, m);
+				if((n * k) > 480)
+					continue;
+				/* Half div can be between 5.5 & 31.5 */
+				for (x = 55; x <= 315; x += 10) {
+					for(ld = 1; ld < ld_end; ld++) {
+						temp = (u64)f_in * (u64)n * 10;
+						do_div(temp, m);
+						/* Fin * N / M Must be < 1500MHz */
+						if(temp > 15000000000ll)
+							continue;
+						do_div(temp, x);
+						do_div(temp, k);
+						do_div(temp, ld);
+						rem = calc_diff(tar_freq, temp);
+						if ((rem < best_rem) ||
+						    ((override == 1) && (rem == best_rem)) ||
+						    ((rem == best_rem) && (k < best_k))) {
+							half_div = 1;
+							best_rem = rem;
+							best_m = m;
+							best_n = n;
+							best_x = x / 10;
+							best_k = k;
+							best_lcd_div = ld;
+							half_div = 1;
+						}
+						if ((best_rem == 0) && (override == 0))
+							break;
+					}
+				}
+			}
+		}
+	}
+
+	*is_half_div = half_div;
+	*m_div = best_m;
+	*n_div = best_n;
+	*x_div = best_x;
+	*k_div = best_k;
+	*lcd_div = best_lcd_div;
+
+	return;
+}
+
+
+/*
+ * The hardware clock divider has an integer and a fractional
+ * stage:
+ *
+ *	clk2 = clk_in / integer_divider
+ *	clk_out = clk2 * (1 - (fractional_divider >> 12))
+ *
+ * Calculate integer and fractional divider for given clk_in
+ * and clk_out.
+ */
+#ifdef CONFIG_PM
+static int init_ext_divider = 0;
+#endif
+
+static void set_clock_divider(struct dovefb_layer_info *dfli,
+	const struct fb_videomode *m)
+{
+	int needed_pixclk;
+	u64 div_result;
+	u32 x = 0, x_bk;
+	struct dovefb_info *info = dfli->info;
+	u32 full_div;
+	struct dovefb_mach_info *dmi = dfli->dev->platform_data;
+	u32 m_div;
+	u32 n_div;
+	u32 k_div;
+	u32 is_half_div;
+	u32 lcd_div;
+
+	/*
+	 * Notice: The field pixclock is used by linux fb
+	 * is in pixel second. E.g. struct fb_videomode &
+	 * struct fb_var_screeninfo
+	 */
+
+	/*
+	 * Check input values.
+	 */
+	if (!m || !m->pixclock || !m->refresh) {
+		printk(KERN_ERR "Input refresh or pixclock is wrong.\n");
+		return;
+	}
+
+	/*
+	 * Using PLL/AXI clock.
+	 */
+#ifdef CONFIG_FB_DOVE_CLCD_USE_PLL_CLK
+	x = 0x80000000;
+#endif
+
+	/*
+	 * Calc divider according to refresh rate.
+	 */
+	div_result = 1000000000000ll;
+
+	if(info->fixed_output)
+		m = &info->out_vmode;
+
+	do_div(div_result, m->pixclock);
+	needed_pixclk = (u32)div_result;
+
+
+	calc_best_clock_div(info, needed_pixclk, dmi->lcd_ref_clk, &m_div, &n_div,
+			&k_div, &full_div, &is_half_div, &lcd_div);
+
+	printk(KERN_INFO "needed_pixclk = %d.\n", needed_pixclk);
+	set_lcd_clock_dividers(dfli, dmi->lcd_ref_clk, m_div, n_div, k_div, full_div, is_half_div);
+	printk(KERN_INFO "LCD-Div = %d.\n", lcd_div);
+
+	/*
+	 * Set setting to reg.
+	 */
+	x_bk = readl(dfli->reg_base + LCD_CFG_SCLK_DIV);
+	x &= ~0xFFFF;
+	x |= 0x80000000;
+	x |= lcd_div;
+
+	if (x != x_bk)
+		writel(x, dfli->reg_base + LCD_CFG_SCLK_DIV);
+}
+
+static void set_dma_control0(struct dovefb_layer_info *dfli)
+{
+	u32 x, x_bk;
+	struct fb_var_screeninfo *var = &dfli->fb_info->var;
+
+	/*
+	 * Set bit to enable graphics DMA.
+	 */
+	x_bk = x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0);
+	//x |= (dfli->active && dfli->enabled) ? CFG_GRA_ENA_MASK : 0;
+	x |= CFG_GRA_ENA_MASK;
+	dfli->active = 0;
+
+	/*
+	 * If we are in a pseudo-color mode, we need to enable
+	 * palette lookup.
+	 */
+	if (dfli->pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		x |= 0x10000000;
+	else
+		x &= ~0x10000000;
+
+	/*
+	 * enable horizontal smooth scaling.
+	 */
+	x |= 0x1 << 14;
+
+	/*
+	 * Cursor enabled?
+	 */
+	if (dfli->cursor_enabled)
+		x |= 0x01000000;
+
+	/*
+	 * Configure hardware pixel format.
+	 */
+	x &= ~(0xF << 16);
+	x |= (dfli->pix_fmt >> 1) << 16;
+
+	/*
+	 * Check red and blue pixel swap.
+	 * 1. source data swap
+	 * 2. panel output data swap
+	 */
+	x &= ~(1 << 12);
+	x |= ((dfli->pix_fmt & 1) ^ (dfli->info->panel_rbswap)) << 12;
+
+	/*
+	 * Enable toogle to generate interlace mode.
+	 */
+	if (FB_VMODE_INTERLACED & var->vmode) {
+		x |= CFG_GRA_FTOGGLE_MASK;
+		dfli->reserved |= 0x1;
+	} else {
+		x &= ~CFG_GRA_FTOGGLE_MASK;
+		dfli->reserved &= ~0x1;
+	}
+
+	if (x != x_bk)
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+}
+
+static void set_dma_control1(struct dovefb_layer_info *dfli, int sync)
+{
+	u32 x, x_bk;
+
+	/*
+	 * Configure default bits: vsync triggers DMA, gated clock
+	 * enable, power save enable, configure alpha registers to
+	 * display 100% graphics, and set pixel command.
+	 */
+	x_bk = x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL1);
+
+	/*
+	 * We trigger DMA on the falling edge of vsync if vsync is
+	 * active low, or on the rising edge if vsync is active high.
+	 */
+	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
+		x |= 0x08000000;
+
+	if (x != x_bk)
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL1);
+}
+
+static int wait_for_vsync(struct dovefb_layer_info *dfli)
+{
+	if (dfli) {
+		u32 irq_ena = readl(dfli->reg_base + SPU_IRQ_ENA);
+		int rc = 0;
+		unsigned int mask = DOVEFB_GFX_INT_MASK | DOVEFB_VSYNC_INT_MASK;
+
+		writel(irq_ena | mask, dfli->reg_base + SPU_IRQ_ENA);
+
+		rc = wait_event_interruptible_timeout(dfli->w_intr_wq,
+						      atomic_read(&dfli->w_intr), 4);
+		if ( rc < 0) {
+			u32 irq_isr = readl(dfli->reg_base + SPU_IRQ_ISR);
+			if ((irq_isr & mask) != 0)
+				printk(KERN_WARNING "%s: gfx wait for vsync"
+				" timed out, rc %d\n",
+				__func__, rc);
+		}
+
+		writel(irq_ena,
+		       dfli->reg_base + SPU_IRQ_ENA);
+		atomic_set(&dfli->w_intr, 0);
+		return 0;
+	}
+
+	return 0;
+}
+
+static void set_dumb_panel_control(struct fb_info *fi, int gpio_only)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct dovefb_mach_info *dmi = dfli->dev->platform_data;
+	u32	mask = 0x1;
+	u32 x, x_bk;
+
+	/*
+	 * Preserve enable flag.
+	 */
+	if (gpio_only)
+		mask |= ~(0xffff << 12);
+	x_bk = readl(dfli->reg_base + LCD_SPU_DUMB_CTRL) & mask;
+	x = dfli->is_blanked ? 0x0:0x1;
+
+	x |= dmi->gpio_output_data << 20;
+	x |= dmi->gpio_output_mask << 12;
+	if (!gpio_only) {
+		if (dfli->is_blanked &&
+			(dmi->panel_rgb_type == DUMB24_RGB888_0))
+			x |= 0x7 << 28;
+		else
+			/*
+			 * When dumb interface isn't under 24bit
+			 * It might be under SPI or GPIO. If set
+			 * to 0x7 will force LCD_D[23:0] output
+			 * blank color and damage GPIO and SPI
+			 * behavior.
+			 */
+			x |= dmi->panel_rgb_type << 28;
+		x |= dmi->panel_rgb_reverse_lanes ? 0x00000080 : 0;
+		x |= dmi->invert_composite_blank ? 0x00000040 : 0;
+		x |= (fi->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;
+		x |= dmi->invert_pix_val_ena ? 0x00000010 : 0;
+		x |= (fi->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;
+		x |= (fi->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;
+		x |= dmi->invert_pixclock ? 0x00000002 : 0;
+	}
+
+	if (x != x_bk)
+		writel(x, dfli->reg_base + LCD_SPU_DUMB_CTRL);
+}
+
+static void set_graphics_start(struct fb_info *fi, int xoffset, int yoffset)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int pixel_offset0, pixel_offset1;
+	unsigned long addr0, addr1, x;
+
+	pixel_offset0 = (yoffset * var->xres_virtual) + xoffset;
+	addr0 = dfli->fb_start_dma +
+		(pixel_offset0 * (var->bits_per_pixel >> 3));
+	/*
+	 * Configure interlace mode.
+	 */
+	if ( FB_VMODE_INTERLACED & var->vmode) {
+		/*
+		 * Calc offset. (double offset).
+		 * frame0 point to odd line,
+		 * frame1 point to even line.
+		 */
+		pixel_offset1 = pixel_offset0 + var->xres_virtual;
+		addr1 = dfli->fb_start_dma +
+			(pixel_offset1 * (var->bits_per_pixel >> 3));
+
+		/*
+		 * Calc Pitch. (double pitch length)
+		 */
+		x = readl(dfli->reg_base + LCD_CFG_GRA_PITCH);
+		x = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 2);
+
+	} else {
+		/*
+		 * Calc offset.
+		 */
+		addr1 = addr0;
+
+		/*
+		 * Calc Pitch.
+		 */
+		x = readl(dfli->reg_base + LCD_CFG_GRA_PITCH);
+		x = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);
+	}
+
+	writel(addr0, dfli->reg_base + LCD_CFG_GRA_START_ADDR0);
+	writel(addr1, dfli->reg_base + LCD_CFG_GRA_START_ADDR1);
+	writel(x, dfli->reg_base + LCD_CFG_GRA_PITCH);
+}
+
+static int set_frame_timings(const struct dovefb_layer_info *dfli,
+	const struct fb_var_screeninfo *var)
+{
+	struct dovefb_info *info = dfli->info;
+	unsigned int active_w, active_h;
+	unsigned int ow, oh;
+	unsigned int zoomed_w, zoomed_h;
+	unsigned int lem, rim, lom, upm, hs, vs;
+	unsigned int x;
+	int total_w, total_h;
+	unsigned int reg, reg_bk;
+
+	/*
+	 * Calc active size, zoomed size, porch.
+	 */
+	if (info->fixed_output) {
+		active_w = info->out_vmode.xres;
+		active_h = info->out_vmode.yres;
+		zoomed_w = info->out_vmode.xres;
+		zoomed_h = info->out_vmode.yres;
+		lem = info->out_vmode.left_margin;
+		rim = info->out_vmode.right_margin;
+		upm = info->out_vmode.upper_margin;
+		lom = info->out_vmode.lower_margin;
+		hs = info->out_vmode.hsync_len;
+		vs = info->out_vmode.vsync_len;
+	} else {
+		active_w = var->xres;
+		active_h = var->yres;
+		zoomed_w = var->xres;
+		zoomed_h = var->yres;
+		lem = var->left_margin;
+		rim = var->right_margin;
+		upm = var->upper_margin;
+		lom = var->lower_margin;
+		hs = var->hsync_len;
+		vs = var->vsync_len;
+	}
+
+	/*
+	 * Calc original size.
+	 */
+	ow = var->xres;
+	oh = var->yres;
+
+	/* interlaced workaround */
+	if (FB_VMODE_INTERLACED & var->vmode) {
+		active_h /= 2;
+		zoomed_h /= 2;
+		oh /= 2;
+	}
+
+	/* calc total width and height.*/
+	total_w = active_w + rim + hs + lem;
+	total_h = active_h + lom + vs + upm;
+
+	/*
+	 * Apply setting to registers.
+	 */
+	writel((active_h << 16) | active_w,
+		dfli->reg_base + LCD_SPU_V_H_ACTIVE);
+
+	writel((oh << 16) | ow,
+		dfli->reg_base + LCD_SPU_GRA_HPXL_VLN);
+
+	writel((zoomed_h << 16) | zoomed_w,
+		dfli->reg_base + LCD_SPU_GZM_HPXL_VLN);
+
+	writel((lem << 16) | rim, dfli->reg_base + LCD_SPU_H_PORCH);
+	writel((upm << 16) | lom, dfli->reg_base + LCD_SPU_V_PORCH);
+
+	reg_bk = readl(dfli->reg_base + LCD_SPUT_V_H_TOTAL);
+	reg = (total_h << 16)|total_w;
+
+	if (reg != reg_bk)
+		writel(reg, dfli->reg_base + LCD_SPUT_V_H_TOTAL);
+	/*
+	 * Configure vsync adjust logic
+	 */
+	x = readl(dfli->reg_base+LCD_SPU_ADV_REG);
+	x &= ~((0x1 << 12) | (0xfff << 20) | 0xfff);
+	x |=	(0x1 << 12) | (active_w+rim) << 20 | (active_w+rim);
+	writel( x, dfli->reg_base+LCD_SPU_ADV_REG);
+
+	return 0;
+}
+
+/*
+ * fake edid is for all LCD default support modes.
+ * [Supported Mode]                     [from which spec]
+ * ------------------------------------------------------
+ * 1. Supported established timings:
+ *     640x480  @60Hz                   (Industry Standard)
+ *     800x600  @56Hz                   (VESA Guidlines)
+ *     800x600  @60Hz                   (VESA Guidlines)
+ *     1024x768 @60Hz                   (VESA Guidlines)
+ *     1280x1024@75Hz                   (VESA Standard)
+ * 2. Supported standard timings:
+ *     1600x1200@60Hz                   (VESA Standard)
+ *     1280x1024@60Hz                   (VESA Standard)
+ *     1280x960 @60Hz                   (VESA Standard)
+ *     1280x800 @60Hz                   (Reduced Blanking)
+ *     1280x720 @60Hz                   (CEA-861)
+ *     1680x1050@60Hz                   (Reduced Blanking)
+ *     1152x864 @60Hz                   (Reduced Blanking)
+ *     1440x900 @60Hz                   (Reduced Blanking)
+ * 3. Supported detailed timing:
+ *     1920x1200@60Hz pixclk 154.0MHz   (Reduced Blanking)
+ *     1920x1080@60Hz pixclk 148.5MHz   (CEA-861)
+ *     1366x768 @60Hz pixclk  85.8MHz   (VESA standard)
+ *     1280x768 @60Hz pixclk  68.2MHz   (Reduced Blanking)
+ * 4. Detailed timing from extension:
+ *     1024x600 @60Hz pixclk  44.64MHz  (MRVL specified)
+ */
+static u8 fake_edid[] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x36, 0xCC, 0x10, 0x05, 0x01, 0x00, 0x00, 0x00,
+	0x1E, 0x14, 0x01, 0x03, 0x80, 0x34, 0x20, 0x78, 0x22, 0xFE, 0x25, 0xA8, 0x53, 0x37, 0xAE, 0x24,
+	0x11, 0x50, 0x54, 0x23, 0x09, 0x00, 0xA9, 0x40, 0x81, 0x80, 0x81, 0x40, 0x81, 0x00, 0x81, 0xC0,
+	0xB3, 0x00, 0x71, 0x40, 0x95, 0x00, 0x28, 0x3C, 0x80, 0xA0, 0x70, 0xB0, 0x23, 0x40, 0x30, 0x20,
+	0x36, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
+	0x58, 0x2C, 0x45, 0x00, 0x06, 0x24, 0x21, 0x00, 0x00, 0x1A, 0x7F, 0x21, 0x56, 0xAA, 0x51, 0x00,
+	0x1E, 0x30, 0x46, 0x8F, 0x33, 0x00, 0x71, 0xD0, 0x10, 0x00, 0x00, 0x1A, 0xA9, 0x1A, 0x00, 0xA0,
+	0x50, 0x00, 0x16, 0x30, 0x30, 0x20, 0x37, 0x00, 0x5A, 0xD0, 0x10, 0x00, 0x00, 0x1A, 0x01, 0x2B,
+	/* extended block 1. */
+	0x02, 0x01, 0x04, 0x00, 0x70, 0x11, 0x00, 0xB0, 0x40, 0x58, 0x14, 0x20, 0x26, 0x64, 0x84, 0x00,
+	0x2C, 0xDE, 0x10, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5,
+};
+
+static u8 *make_fake_edid(void)
+{
+	u8 *edid_block;
+	u32 edid_size;
+
+	edid_size = EDID_LENGTH * (1 + fake_edid[0x7e]);
+	edid_block = kmalloc(edid_size, GFP_KERNEL);
+
+	if (!edid_block)
+		return edid_block;
+
+	memcpy(edid_block, fake_edid, edid_size);
+
+	return edid_block;
+}
+
+static u8 *make_analog_fake_edid(void)
+{
+	u8 *edid_block;
+
+	edid_block = make_fake_edid();
+
+	/* change analog input field.*/
+	if (edid_block) {
+		edid_block[20] = 0x06; /* Analog signal features. */
+		edid_block[127] = 0xA5; /* Checksum */
+	}
+
+	return edid_block;
+}
+
+static int dovefb_gfx_set_par(struct fb_info *fi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	const struct fb_videomode *m = 0;
+	struct fb_videomode mode;
+	int pix_fmt;
+	u32 x;
+	struct dovefb_mach_info *dmi;
+
+	dmi = dfli->info->dev->platform_data;
+
+	/*
+	 * Determine which pixel format we're going to use.
+	 */
+	pix_fmt = dovefb_determine_best_pix_fmt(&fi->var, dfli);
+	if (pix_fmt < 0) {
+		printk(KERN_ERR "Unsupported pixel format\n");
+		return pix_fmt;
+	}
+
+	dfli->pix_fmt = pix_fmt;
+
+	/*
+	 * Set RGB bit field info.
+	 */
+	dovefb_set_pix_fmt(var, pix_fmt);
+
+	/*
+	 * Set additional mode info.
+	 */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		fi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fi->fix.visual = FB_VISUAL_TRUECOLOR;
+	fi->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	x = readl(dfli->reg_base + SPU_IRQ_ENA);
+	if (x & DOVEFB_GFX_INT_MASK)
+		wait_for_vsync(dfli);
+
+	/*
+	 * Configure frame timings.
+	 */
+	set_frame_timings(dfli, var);
+
+	/*
+	 * convet var to video mode
+	 */
+	fb_var_to_videomode(&mode, &fi->var);
+	m = &mode;
+
+	/* Calculate clock divisor. */
+	set_clock_divider(dfli, &mode);
+
+	/* Configure dma ctrl regs. */
+	set_dma_control0(dfli);
+	set_dma_control1(dfli, fi->var.sync);
+
+	/*
+	 * Configure graphics DMA parameters.
+	 */
+	set_graphics_start(fi, fi->var.xoffset, fi->var.yoffset);
+
+	/*
+	 * Configure dumb panel ctrl regs & timings.
+	 */
+	set_dumb_panel_control(fi, 0);
+
+	/*
+	 * Re-enable panel output.
+	 */
+	x = readl(dfli->reg_base + LCD_SPU_DUMB_CTRL);
+	if ((x & 0x1) == 0)
+		writel(x | 1, dfli->reg_base + LCD_SPU_DUMB_CTRL);
+#ifdef CONFIG_CH7025_COMPOSITE
+	{
+		struct input_stream_info info;
+		if (strstr(fi->fix.id, "GFX Layer 0")) {
+			info.xres = var->xres;
+			info.yres = var->yres;
+			info.iformat = CH7025_RGB888;
+			info.oformat = CH7025_NTSC_M;
+			info.swap = CH7025_RGB_ORDER;
+
+			//printk(KERN_INFO "video ch7025 enable.......\n");
+			ch7025_set_input_stream(&info);
+			ch7025_enable(1);
+		}
+	}
+#endif
+#ifdef CONFIG_KG2_ANX7150
+	{
+		AVC_CMD_TIMING_PARAM kg2_timing_param;
+
+		if (strstr(fi->fix.id, "GFX Layer 0"))
+		{
+			//printk(KERN_INFO "dovefb_gfx: Change kg2 input timing\n");
+
+			kg2_timing_param.HTotal = var->left_margin + var->xres + var->right_margin + var->hsync_len;
+			kg2_timing_param.HActive = var->xres;
+			kg2_timing_param.HFrontPorch = var->right_margin;
+			kg2_timing_param.HSyncWidth = var->hsync_len;
+			kg2_timing_param.HPolarity = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 0: 1;
+			kg2_timing_param.VTotal = var->upper_margin + var->yres + var->lower_margin + var->vsync_len;
+			kg2_timing_param.VActive = var->yres;
+			kg2_timing_param.VFrontPorch = var->lower_margin;
+			kg2_timing_param.VSyncWidth = var->vsync_len;
+			kg2_timing_param.VPolarity = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 0: 1;
+			kg2_timing_param.AspRatio = (var->xres * 100 / var->yres >= 160) ? AVC_CMD_ASP_RATIO_16_9: AVC_CMD_ASP_RATIO_4_3;
+			kg2_timing_param.IsProgressive = 1;
+			kg2_timing_param.RefRate = mode.refresh;
+
+			kg2_set_input_timing(&kg2_timing_param);
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int dovefb_pan_display(struct fb_var_screeninfo *var,
+    struct fb_info *fi)
+{
+	wait_for_vsync(fi->par);
+	set_graphics_start(fi, var->xoffset, var->yoffset);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int dovefb_pwr_off_sram(struct dovefb_layer_info *dfli)
+{
+	unsigned int x;
+
+	if (dfli) {
+		x = readl(dfli->reg_base + LCD_SPU_SRAM_PARA1);
+		x |=	CFG_PDWN256x32_MASK |
+			CFG_PDWN256x24_MASK |
+			CFG_PDWN256x8_MASK;
+		writel(x, dfli->reg_base + LCD_SPU_SRAM_PARA1);
+	}
+
+	return 0;
+}
+
+static int dovefb_pwr_on_sram(struct dovefb_layer_info *dfli)
+{
+	unsigned int x;
+
+	if (dfli) {
+		x = readl(dfli->reg_base + LCD_SPU_SRAM_PARA1);
+		x &=	~(CFG_PDWN256x32_MASK |
+			CFG_PDWN256x24_MASK |
+			CFG_PDWN256x8_MASK);
+		writel(x, dfli->reg_base + LCD_SPU_SRAM_PARA1);
+	}
+
+	return 0;
+}
+#endif
+
+static int dovefb_blank(int blank, struct fb_info *fi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	u32 reg;
+
+	dfli->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;
+	set_dumb_panel_control(fi, 0);
+
+	/*
+	 * Fix me: Currently, hardware won't generate video layer
+	 * IRQ or VSync IRQ if diable dumb LCD panel. However, if
+	 * we are playing movies and enter blank mode, video player
+	 * still decode frame to video driver and we can't handle
+	 * those frame data without IRQ events.
+	 * We create a timer to check video buffer and handle those
+	 * frame data to make a workaround version.
+	 */
+	reg = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) & 0x01;
+	if (reg && dfli->is_blanked && !dfli->checkbuf_timer_exist) {
+		add_timer(&checkbuf_timer);
+		dfli->checkbuf_timer_exist = 1;
+	}
+	if (!dfli->is_blanked && dfli->checkbuf_timer_exist) {
+		del_timer_sync(&checkbuf_timer);
+		dfli->checkbuf_timer_exist = 0;
+	}
+
+	if (dfli->is_blanked)
+		clk_disable(dfli->info->clk);
+	else
+		clk_enable(dfli->info->clk);
+
+	return 0;
+}
+
+#ifdef DOVE_USING_HWC
+static int dovefb_cursor(struct fb_info *fi, struct fb_cursor *cursor)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	unsigned int x;
+
+	/*
+	 * in some case we don't want to anyone access hwc.
+	 */
+	if (dfli->cursor_cfg == 0)
+		return 0;
+
+	/* Too large of a cursor :-(*/
+	if (cursor->image.width > 64 || cursor->image.height > 64) {
+		printk(KERN_INFO "Error: cursor->image.width = %d"
+				", cursor->image.height = %d\n",
+				cursor->image.width, cursor->image.height);
+		return -ENXIO;
+	}
+
+	/* 1. Disable cursor for updating anything. */
+	if (!cursor->enable) {
+		/* Disable cursor */
+		x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) &
+				~CFG_HWC_ENA_MASK;
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+		dfli->cursor_enabled = 0;
+	}
+
+	/* 2. Set Cursor Image */
+	if (cursor->set & FB_CUR_SETIMAGE) {
+		/*
+		 * Not supported
+		 */
+	}
+
+	/* 3. Set Cursor position */
+	if (cursor->set & FB_CUR_SETPOS) {
+		/* set position */
+		x =  ((CFG_HWC_OVSA_VLN((cursor->image.dy - fi->var.yoffset)))|
+			(cursor->image.dx - fi->var.xoffset));
+		writel(x, dfli->reg_base + LCD_SPU_HWC_OVSA_HPXL_VLN);
+	}
+
+	/* 4. Set Cursor Hot spot */
+	if (cursor->set & FB_CUR_SETHOT);
+	/* set input value to HW register */
+
+	/* 5. set Cursor color, Hermon2 support 2 cursor color. */
+	if (cursor->set & FB_CUR_SETCMAP) {
+		u32 bg_col_idx;
+		u32 fg_col_idx;
+		u32 fg_col, bg_col;
+
+		bg_col_idx = cursor->image.bg_color;
+		fg_col_idx = cursor->image.fg_color;
+		fg_col = (((u32)fi->cmap.red[fg_col_idx] & 0xff00) << 8) |
+			 (((u32)fi->cmap.green[fg_col_idx] & 0xff00) << 0) |
+			 (((u32)fi->cmap.blue[fg_col_idx] & 0xff00) >> 8);
+		bg_col = (((u32)fi->cmap.red[bg_col_idx] & 0xff00) << 8) |
+			 (((u32)fi->cmap.green[bg_col_idx] & 0xff00) << 0) |
+			 (((u32)fi->cmap.blue[bg_col_idx] & 0xff00) >> 8);
+
+		/* set color1. */
+		writel(fg_col, dfli->reg_base + LCD_SPU_ALPHA_COLOR1);
+
+		/* set color2. */
+		writel(bg_col, dfli->reg_base + LCD_SPU_ALPHA_COLOR2);
+	}
+
+	/* don't know how to set bitmask yet. */
+	if (cursor->set & FB_CUR_SETSHAPE);
+
+	if (cursor->set & FB_CUR_SETSIZE) {
+		int i;
+		int data_len;
+		u32 data_tmp;
+		u32 addr = 0;
+		int width;
+		int height;
+
+		width = cursor->image.width;
+		height = cursor->image.height;
+
+		data_len = ((width*height*2) + 31) >> 5;
+
+		/* 2. prepare cursor data */
+		for (i = 0; i < data_len; i++) {
+			/* Prepare data */
+			writel(0xffffffff, dfli->reg_base+LCD_SPU_SRAM_WRDAT);
+
+			/* write hwc sram */
+			data_tmp = CFG_SRAM_INIT_WR_RD(SRAMID_INIT_WRITE)|
+					CFG_SRAM_ADDR_LCDID(SRAMID_hwc)|
+					addr;
+			writel(data_tmp, dfli->reg_base+LCD_SPU_SRAM_CTRL);
+
+			/* increasing address */
+			addr++;
+		}
+
+		/* set size to register */
+		x = CFG_HWC_VLN(cursor->image.height)|cursor->image.width;
+		writel(x, dfli->reg_base + LCD_SPU_HWC_HPXL_VLN);
+	}
+
+	if (cursor->set & FB_CUR_SETALL);
+	/* We have set all the flag above. Enable H/W Cursor. */
+
+	/* if needed, enable cursor again */
+	if (cursor->enable) {
+		/* Enable cursor. */
+		x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) |
+			CFG_HWC_ENA(0x1);
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+		dfli->cursor_enabled = 1;
+	}
+	return 0;
+}
+#endif
+
+static int dovefb_fb_sync(struct fb_info *info)
+{
+	/*struct dovefb_layer_info *dfli = info->par;*/
+
+	return 0; /*wait_for_vsync(dfli);*/
+}
+
+
+/*
+ *  dovefb_handle_irq(two lcd controllers)
+ */
+int dovefb_gfx_handle_irq(u32 isr, struct dovefb_layer_info *dfli)
+{
+	if (0x1 & dfli->reserved) {
+		unsigned int vs_adj, x;
+		unsigned int active_w, h_fp;
+
+		active_w = 0xffff & readl(dfli->reg_base + LCD_SPU_V_H_ACTIVE);
+		h_fp = 0xffff & readl(dfli->reg_base + LCD_SPU_H_PORCH);
+
+		/* interlace mode workaround. */
+		if (GRA_FRAME_IRQ0_ENA_MASK & isr) {
+			vs_adj = active_w + h_fp;
+		} else {
+			vs_adj = (active_w/2) + h_fp;
+		}
+
+		x = readl(dfli->reg_base+LCD_SPU_ADV_REG);
+		x &= ~((0x1 << 12) | (0xfff << 20) | 0xfff);
+		x |= (0x1 << 12) | (vs_adj << 20) | vs_adj;
+		writel( x, dfli->reg_base+LCD_SPU_ADV_REG);
+	}
+
+	/* wake up queue. */
+	atomic_set(&dfli->w_intr, 1);
+	wake_up(&dfli->w_intr_wq);
+	return 1;
+}
+
+
+static u32 dovefb_moveHWC2SRAM(struct dovefb_layer_info *dfli, u32 size)
+{
+	u32 i, addr, count, sramCtrl, data_length, count_mod;
+	u32 *tmpData = 0;
+	u8 *pBuffer = dfli->hwc_buf;
+
+	/* Initializing value. */
+	addr = 0;
+	sramCtrl = 0;
+	data_length = size ; /* in byte. */
+	count = data_length / 4;
+	count_mod = data_length % 4;
+	tmpData  = (u32 *)pBuffer;
+
+	/* move new cursor bitmap to SRAM */
+	/* printk(KERN_INFO "\n-------< cursor binary data >--------\n\n"); */
+	for (i = 0; i < count; i++) {
+		/* Prepare data */
+		writel(*tmpData, dfli->reg_base + LCD_SPU_SRAM_WRDAT);
+
+		/* printk(KERN_INFO "%d %8x\n\n", i, tmpData); */
+		/* write hwc sram */
+		sramCtrl = CFG_SRAM_INIT_WR_RD(SRAMID_INIT_WRITE)|
+				CFG_SRAM_ADDR_LCDID(SRAMID_hwc)|
+				addr;
+		writel(sramCtrl, dfli->reg_base + LCD_SPU_SRAM_CTRL);
+
+		/* increasing address */
+		addr++;
+		tmpData++;
+	}
+	/* printk(KERN_INFO "\n---< end of cursor binary data >---\n\n");
+	*/
+
+	/* not multiple of 4 bytes. */
+	if (count_mod != 0) {
+		printk(KERN_INFO "Error: move_count_mod != 0 \n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+
+static u32 dovefb_set_cursor(struct fb_info *info,
+			      struct _sCursorConfig *cursor_cfg)
+{
+	u16 w;
+	u16 h;
+	unsigned int x;
+	struct dovefb_layer_info *dfli = info->par;
+
+	/* Disable cursor */
+	dfli->cursor_enabled = 0;
+	dfli->cursor_cfg = 0;
+	x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) &
+		~(CFG_HWC_ENA_MASK|CFG_HWC_1BITENA_MASK|CFG_HWC_1BITMOD_MASK);
+	writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+
+	if (cursor_cfg->enable) {
+		dfli->cursor_enabled = 1;
+		dfli->cursor_cfg = 1;
+		w  = cursor_cfg->width;
+		h = cursor_cfg->height;
+
+		/* set cursor display mode */
+		if (DOVEFB_HWCMODE_1BITMODE == cursor_cfg->mode) {
+			/* set to 1bit mode */
+			x |= CFG_HWC_1BITENA(0x1);
+
+			/* copy HWC buffer */
+			if (cursor_cfg->pBuffer) {
+				memcpy(dfli->hwc_buf, cursor_cfg->pBuffer,
+					(w*h)>>3);
+				dovefb_moveHWC2SRAM(dfli, (w*h)>>3);
+			}
+		} else if (DOVEFB_HWCMODE_2BITMODE == cursor_cfg->mode) {
+			/* set to 2bit mode */
+			/* do nothing, clear to 0 is 2bit mode. */
+
+			/* copy HWC buffer */
+			if (cursor_cfg->pBuffer) {
+				memcpy(dfli->hwc_buf, cursor_cfg->pBuffer,
+					(w*h*2)>>3) ;
+				dovefb_moveHWC2SRAM(dfli, (w*h*2)>>3);
+			}
+		} else {
+			printk(KERN_INFO "dovefb: Unsupported HWC mode\n");
+			return -ENXIO;
+		}
+
+		/* set color1 & color2 */
+		writel(cursor_cfg->color1,
+			dfli->reg_base + LCD_SPU_ALPHA_COLOR1);
+		writel(cursor_cfg->color2,
+			dfli->reg_base + LCD_SPU_ALPHA_COLOR2);
+
+		/* set position on screen */
+		writel((CFG_HWC_OVSA_VLN(cursor_cfg->yoffset))|
+			(cursor_cfg->xoffset),
+			dfli->reg_base + LCD_SPU_HWC_OVSA_HPXL_VLN);
+
+		/* set cursor size */
+		writel(CFG_HWC_VLN(cursor_cfg->height)|cursor_cfg->width,
+			dfli->reg_base + LCD_SPU_HWC_HPXL_VLN);
+
+		/* Enable cursor */
+		x |= CFG_HWC_ENA(0x1);
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+	} else {
+		/* do nothing, we disabled it already. */
+	}
+
+	return 0;
+}
+
+
+static int dovefb_gfx_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct dovefb_layer_info *dfli = info->par;
+
+	switch (cmd) {
+	case DOVEFB_IOCTL_WAIT_VSYNC:
+		wait_for_vsync(dfli);
+		break;
+	case DOVEFB_IOCTL_CONFIG_CURSOR:
+	{
+		struct _sCursorConfig cursor_cfg;
+
+		if (copy_from_user(&cursor_cfg, argp, sizeof(cursor_cfg)))
+			return -EFAULT;
+
+		return dovefb_set_cursor(info, &cursor_cfg);
+	}
+	case DOVEFB_IOCTL_DUMP_REGS:
+		dovefb_dump_regs(dfli->info);
+		break;
+	case DOVEFB_IOCTL_GET_EDID_INFO:
+		if (copy_to_user(argp, &dfli->edid_info,
+					sizeof(struct _sEdidInfo)))
+			return -EFAULT;
+		dfli->edid_info.change = 0;
+		break;
+	case DOVEFB_IOCTL_GET_EDID_DATA:
+		if (dfli->raw_edid != NULL) {
+			if (copy_to_user(argp, dfli->raw_edid, EDID_LENGTH *
+					 (dfli->edid_info.extension + 1)))
+				return -EFAULT;
+		}
+		break;
+	case DOVEFB_IOCTL_SET_EDID_INTERVAL:
+		if (!dfli->ddc_polling_disable) {
+			dfli->edid_info.interval = (arg > 0) ? arg :
+				DEFAULT_EDID_INTERVAL;
+			mod_timer(&dfli->get_edid_timer, jiffies +
+				  dfli->edid_info.interval * HZ);
+		}
+		break;
+
+	default:
+		;
+	}
+
+	return 0;
+}
+
+static bool dovefb_edid_block_valid(u8 *raw_edid)
+{
+        int i;
+
+	if (raw_edid[0] == 0x00)
+		for (i = 0; i < sizeof(edid_header); i++)
+			if (raw_edid[i] != edid_header[i])
+				return 0;
+
+	return 1;
+}
+
+static int dovefb_do_probe_ddc_edid(struct i2c_adapter *adapter, int address,
+			unsigned char *buf, int block, int len)
+{
+        unsigned char start = block * EDID_LENGTH;
+        struct i2c_msg msgs[] = {
+                {
+                        .addr   = address,
+                        .flags  = 0,
+                        .len    = 1,
+                        .buf    = &start,
+                }, {
+                        .addr   = address,
+                        .flags  = I2C_M_RD,
+                        .len    = len,
+                        .buf    = buf + start,
+                }
+        };
+
+	if (adapter->algo->master_xfer) {
+		if (i2c_transfer(adapter, msgs, 2) == 2)
+			return 0;
+	} else {
+		int i;
+		if (0 != i2c_smbus_xfer(adapter, msgs[0].addr, msgs[0].flags,
+					I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE_DATA,
+					(union i2c_smbus_data *)buf)) {
+			printk(KERN_WARNING "%s: failed for address 0\n",
+			       __func__);
+			return -1;
+		}
+		for (i = 0; i < EDID_LENGTH; i++) {
+			if (0 != i2c_smbus_xfer(adapter, msgs[1].addr, 0,
+					I2C_SMBUS_READ, i, I2C_SMBUS_BYTE_DATA,
+					(union i2c_smbus_data *)(buf + i))) {
+				printk(KERN_WARNING "%s: failed for address %d\n",
+				       __func__, i);
+				return -1;
+			}
+
+		}
+		return 0;
+	}
+
+        return -1;
+}
+
+static u8 *dovefb_get_edid(struct i2c_adapter *adapter, int address)
+{
+        int i, j = 0;
+        u8 *block, *new;
+
+        if ((block = kmalloc(EDID_LENGTH, GFP_KERNEL)) == NULL)
+                return NULL;
+
+        /* base block fetch */
+        for (i = 0; i < 4; i++) {
+                if (dovefb_do_probe_ddc_edid(adapter, address, block, 0, EDID_LENGTH))
+                        goto out;
+                if (dovefb_edid_block_valid(block))
+                        break;
+        }
+        if (i == 4)
+                goto carp;
+
+        /* if there's no extensions, we're done */
+        if (block[0x7e] == 0)
+                return block;
+
+        new = krealloc(block, (block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);
+        if (!new)
+                goto out;
+        block = new;
+
+        for (j = 1; j <= block[0x7e]; j++) {
+                for (i = 0; i < 4; i++) {
+                        if (dovefb_do_probe_ddc_edid(adapter, address, block, j,
+                                                  EDID_LENGTH))
+                                goto out;
+                        if (dovefb_edid_block_valid(block + j * EDID_LENGTH))
+                                break;
+                }
+                if (i == 4)
+                        goto carp;
+        }
+
+        return block;
+
+carp:
+	//printk(KERN_ERR " EDID block %d invalid.\n", j);
+
+out:
+        kfree(block);
+        return NULL;
+}
+
+static u8 *dove_read_edid(struct fb_info *fi, struct dovefb_mach_info *dmi)
+{
+#ifdef CONFIG_FB_DOVE_CLCD_EDID
+	struct i2c_adapter *dove_i2c;
+#endif
+	char *edid_data = NULL;
+	if (-1 == dmi->ddc_i2c_adapter)
+		return edid_data;
+
+#ifdef CONFIG_FB_DOVE_CLCD_EDID
+	dove_i2c = i2c_get_adapter(dmi->ddc_i2c_adapter);
+	/*
+	 * Check match or not.
+	 */
+	if (dove_i2c){
+		//printk(KERN_INFO "  o Found i2c adapter for EDID detection\n");
+	} else {
+		printk(KERN_WARNING "Couldn't find any I2C bus for EDID"
+		       " provider\n");
+		return NULL;
+	}
+	/* Look for EDID data on the selected bus */
+	edid_data = dovefb_get_edid(dove_i2c,dmi->ddc_i2c_address);
+#endif
+	return edid_data;
+}
+
+static int dovefb_fill_edid(struct fb_info *fi,
+				struct dovefb_mach_info *dmi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct dovefb_info *info = dfli->info;
+	int ret = 0;
+	char *edid;
+
+	/*
+	 * check edid is ready.
+	 */
+	if (info->edid)
+		return ret;
+
+	if (!info->edid_en)
+		return -3;
+
+	/*
+	 * Try to read EDID
+	 */
+	edid = dove_read_edid(fi, dmi);
+	if (edid == NULL) {
+		printk(KERN_INFO "  o Failed to read EDID information,"
+		    "using driver resolutions table.\n");
+		ret = -1;
+	} else {
+		/*
+		 * parse and store edid.
+		 */
+		struct fb_monspecs *specs = &fi->monspecs;
+
+		fb_edid_to_monspecs(edid, specs);
+
+		if (specs->modedb) {
+			fb_videomode_to_modelist(specs->modedb,
+						specs->modedb_len,
+						&fi->modelist);
+			info->edid = 1;
+		} else {
+			ret = -2;
+		}
+		if (dfli->raw_edid) kfree(dfli->raw_edid);
+		dfli->raw_edid = edid;
+	}
+
+	return ret;
+}
+
+
+static void dovefb_set_defaults(struct dovefb_layer_info *dfli)
+{
+	unsigned int x;
+
+	writel(0x80000001, dfli->reg_base + LCD_CFG_SCLK_DIV);
+	writel(0x00000000, dfli->reg_base + LCD_SPU_BLANKCOLOR);
+	/* known h/w issue. The bit [18:19] might
+	 * 1. make h/w irq not workable. */
+	/* 2. make h/w output skew data. */
+	writel(dfli->info->io_pin_allocation,
+			dfli->reg_base + SPU_IOPAD_CONTROL);
+	writel(0x00000000, dfli->reg_base + LCD_CFG_GRA_START_ADDR1);
+	writel(0x00000000, dfli->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);
+	writel(0x0, dfli->reg_base + LCD_SPU_SRAM_PARA0);
+	writel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),
+		dfli->reg_base + LCD_SPU_SRAM_PARA1);
+	writel(0x2032FF81, dfli->reg_base + LCD_SPU_DMA_CTRL1);
+
+	/*
+	 * Fix me: to avoid jiggling issue for high resolution in
+	 * dual display, we set watermark to affect LCD AXI read
+	 * from MC (default 0x80). Lower watermark means LCD will
+	 * do DMA read more often.
+	 */
+	x = readl(dfli->reg_base + LCD_CFG_RDREG4F);
+	/* watermark */
+	x &= ~0xFF;
+	x |= 0x20;
+	/* Disable LCD SRAM Read Wait State to resolve HWC32 make
+	 * system hang while use external clock.
+	 */
+	x &= ~(1<<11);
+	writel(x, dfli->reg_base + LCD_CFG_RDREG4F);
+
+#if defined(CONFIG_ARCH_FEROCEON_KW) || defined(CONFIG_ARCH_ARMADA_XP)
+	x = readl(dfli->reg_base + SPU_IOPAD_CONTROL);
+	x &= ~CFG_AXICTRL_MASK;
+	x |= CFG_AXICTRL(12);
+	writel(x, dfli->reg_base + SPU_IOPAD_CONTROL);
+#endif
+
+	return;
+}
+
+const struct fb_videomode *dovefb_find_nearest_mode(const struct fb_videomode *mode,
+					        struct list_head *head)
+{
+	struct list_head *pos;
+	struct fb_modelist *modelist;
+	struct fb_videomode *cmode, *best = NULL;
+	u32 diff = -1, diff_refresh = -1;
+	u32 idx = 0;
+
+	list_for_each(pos, head) {
+		u32 d;
+
+		modelist = list_entry(pos, struct fb_modelist, list);
+		cmode = &modelist->mode;
+		d = abs(cmode->xres - mode->xres) +
+			abs(cmode->yres - mode->yres);
+		if (diff > d) {
+			diff = d;
+			best = cmode;
+			diff_refresh = -1;
+
+			d = abs(cmode->refresh - mode->refresh);
+			if (diff_refresh > d) {
+				diff_refresh = d;
+			}
+		} else if (diff == d) {
+			d = abs(cmode->refresh - mode->refresh);
+			if (diff_refresh > d) {
+				diff_refresh = d;
+				best = cmode;
+			}
+		}
+
+		idx++;
+	}
+
+	return best;
+}
+
+static void dovefb_list_vmode(const char *id, struct list_head *head)
+{
+	struct list_head *pos;
+	struct fb_modelist *modelist;
+	struct fb_videomode *m = NULL;
+	u32 idx = 0;
+
+	printk(KERN_INFO "------------<%s video mode database>-----------\n", id);
+	list_for_each(pos, head) {
+
+		modelist = list_entry(pos, struct fb_modelist, list);
+		m = &modelist->mode;
+
+		if (m)
+			printk(KERN_INFO "mode %d: <%4dx%4d@%d> pico=%d\n"
+				"\tfb timings   %4d %4d %4d %4d %4d %4d\n"
+				"\txorg timings %4d %4d %4d %4d %4d %4d %4d %4d\n",
+				idx++, m->xres, m->yres, m->refresh, m->pixclock,
+				m->left_margin, m->right_margin, m->upper_margin, m->lower_margin, m->hsync_len, m->vsync_len,
+				m->xres,
+				m->xres + m->right_margin,
+				m->xres + m->right_margin + m->hsync_len,
+				m->xres + m->right_margin + m->hsync_len + m->left_margin,
+				m->yres,
+				m->yres + m->lower_margin,
+				m->yres + m->lower_margin + m->vsync_len,
+				m->yres + m->lower_margin + m->vsync_len + m->upper_margin);
+
+	}
+}
+
+static int dovefb_init_mode(struct fb_info *fi,
+				struct dovefb_mach_info *dmi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct dovefb_info *info = dfli->info;
+	struct fb_var_screeninfo *var = &fi->var;
+	int ret = 0;
+	u32 total_w, total_h, refresh;
+	u64 div_result;
+	const struct fb_videomode *m;
+
+	/*
+	 * Set default value
+	 */
+	refresh = DEFAULT_REFRESH;
+
+	/*
+	 * Fill up mode data to modelist.
+	 */
+	dfli->raw_edid = NULL;
+	if (dovefb_fill_edid(fi, dmi)) {
+		fb_videomode_to_modelist(dmi->modes,
+					dmi->num_modes,
+					&fi->modelist);
+		dfli->raw_edid = make_fake_edid();
+	}
+	/*
+	 * Print all video mode in current mode list.
+	 */
+	dovefb_list_vmode(fi->fix.id, &fi->modelist);
+
+	/*
+	 * Check if we are in fixed output mode.
+	 */
+	if (info->fixed_output) {
+		var->xres = info->out_vmode.xres;
+		var->yres = info->out_vmode.yres;
+		m = dovefb_find_nearest_mode(&info->out_vmode, &fi->modelist);
+		if (m)
+			info->out_vmode = *m;
+		else {
+			info->fixed_output = 0;
+			printk(KERN_WARNING "DoveFB: Unsupported "
+					"output resolution.\n");
+		}
+	}
+
+	/*
+	 * If has bootargs, apply it first.
+	 */
+	if (info->dft_vmode.xres && info->dft_vmode.yres &&
+	    info->dft_vmode.refresh) {
+		/* set data according bootargs */
+		var->xres = info->dft_vmode.xres;
+		var->yres = info->dft_vmode.yres;
+		refresh = info->dft_vmode.refresh;
+	}
+
+	/* try to find best video mode. */
+	m = dovefb_find_nearest_mode(&info->dft_vmode, &fi->modelist);
+	if (m) {
+		printk(KERN_INFO "found <%dx%d@%d>, pixclock=%d\n", m->xres, m->yres, m->refresh, m->pixclock);
+		fb_videomode_to_var(&fi->var, m);
+	} else {
+		printk("Video mode list doesn't contain %dx%d, "
+			"Please check display's edid support this mode "
+			"or add built-in Mode\n"
+			"Now we try 1024x768 mode.",
+			var->xres, var->yres);
+		fi->var.xres = 1024;
+		fi->var.yres = 768;
+
+		m = fb_find_best_mode(&fi->var, &fi->modelist);
+		if (!m) {
+			printk("Can't find 1024x768 either!!!\n");
+			return -1;
+		}
+		fb_videomode_to_var(&fi->var, m);
+	}
+
+	/*
+	 * if not using fixed output mode, fixed output mode should be
+	 * equal to current video mode.
+	 */
+	if(!info->fixed_output)
+		info->out_vmode = *m;
+
+	/* Init settings. */
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+
+	/* correct pixclock. */
+	total_w = var->xres + var->left_margin + var->right_margin +
+		  var->hsync_len;
+	total_h = var->yres + var->upper_margin + var->lower_margin +
+		  var->vsync_len;
+
+	div_result = 1000000000000ll;
+	do_div(div_result, total_w * total_h * refresh);
+	var->pixclock = (u32)div_result;
+
+	return ret;
+}
+
+
+#ifdef CONFIG_PM
+int dovefb_gfx_suspend(struct dovefb_layer_info *dfli, pm_message_t mesg)
+{
+	struct fb_info *fi = dfli->fb_info;
+	struct fb_var_screeninfo *var = &fi->var;
+
+	printk(KERN_INFO "dovefb_gfx: dovefb_gfx_suspend(): state = %d.\n",
+		mesg.event);
+	printk(KERN_INFO "dovefb_gfx: suspend lcd %s\n", fi->fix.id);
+	printk(KERN_INFO "dovefb_gfx: save resolution: <%dx%d>\n",
+		var->xres, var->yres);
+
+	if (mesg.event & PM_EVENT_SLEEP) {
+		fb_set_suspend(fi, 1);
+		dovefb_blank(FB_BLANK_POWERDOWN, fi);
+		dovefb_pwr_off_sram(dfli);
+	}
+
+	return 0;
+}
+
+int dovefb_gfx_resume(struct dovefb_layer_info *dfli)
+{
+	struct fb_info *fi = dfli->fb_info;
+	struct fb_var_screeninfo *var = &fi->var;
+
+	printk(KERN_INFO "dovefb_gfx: dovefb_gfx_resume().\n");
+	printk(KERN_INFO "dovefb_gfx: resume lcd %s\n", fi->fix.id);
+	printk(KERN_INFO "dovefb_gfx: restore resolution: <%dx%d>\n",
+		var->xres, var->yres);
+
+	dovefb_set_defaults(dfli);
+	dfli->active = 1;
+
+	dovefb_pwr_on_sram(dfli);
+	if (dovefb_gfx_set_par(fi) != 0) {
+		printk(KERN_INFO "dovefb_gfx_resume(): Failed in "
+				"dovefb_gfx_set_par().\n");
+		return -1;
+	}
+
+	fb_set_suspend(fi, 0);
+	dovefb_blank(FB_BLANK_UNBLANK, fi);
+
+	return 0;
+}
+#endif
+
+static void dynamic_get_edid(unsigned long data)
+{
+	struct dovefb_layer_info *dfli = (struct dovefb_layer_info *) data;
+
+	mod_timer(&dfli->get_edid_timer, jiffies + dfli->edid_info.interval * HZ);
+	schedule_work(&dfli->work_queue);
+}
+
+static bool is_new_edid(u8* new_edid, struct dovefb_layer_info *dfli)
+{
+	/*
+	 * check if EDID menufactor information is the same.
+	 */
+	int i;
+	if (!dfli->raw_edid) return true;
+
+	for (i = ID_MANUFACTURER_NAME; i < EDID_STRUCT_REVISION; i++) {
+		if ( *(new_edid + i) != *(dfli->raw_edid + i)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+static void get_edid_work(struct work_struct *work)
+{
+	struct dovefb_layer_info *dfli =
+		container_of(work, struct dovefb_layer_info, work_queue);
+	struct fb_info *fi = dfli->fb_info;
+	struct dovefb_mach_info *dmi = dfli->dev->platform_data;
+	char* edid_data = NULL;
+
+	edid_data = dove_read_edid(fi, dmi);
+
+	if (edid_data) {
+		if (is_new_edid(edid_data, dfli)) {
+			if (dfli->raw_edid) kfree(dfli->raw_edid);
+			dfli->raw_edid = edid_data;
+			dfli->edid_info.connect = 1;
+			dfli->edid_info.change = 1;
+			dfli->edid_info.extension = dfli->raw_edid[0x7e];
+		} else {
+			if (!dfli->edid_info.connect) {
+				dfli->edid_info.connect = 1;
+				dfli->edid_info.change = 1;
+				dfli->edid_info.extension = dfli->raw_edid[0x7e];
+			}
+			kfree(edid_data);
+		}
+	} else {
+		if (strstr(fi->fix.id, "GFX Layer 0")) {
+			if (dfli->edid_info.connect != 2){
+				if (!dfli->raw_edid) kfree(dfli->raw_edid);
+				dfli->raw_edid = make_fake_edid();
+				dfli->edid_info.connect = 2;
+				dfli->edid_info.change = 1;
+				dfli->edid_info.extension =
+					dfli->raw_edid[0x7e];
+			}
+		} else if (strstr(fi->fix.id, "GFX Layer 1")) {
+			if (dfli->edid_info.connect != 2) {
+				if (!dfli->raw_edid)
+					kfree(dfli->raw_edid);
+				dfli->raw_edid = make_analog_fake_edid();
+				dfli->edid_info.connect = 2;
+				dfli->edid_info.change = 1;
+				dfli->edid_info.extension =
+					dfli->raw_edid[0x7e];
+			}
+		}
+	}
+}
+
+int dovefb_gfx_init(struct dovefb_info *info, struct dovefb_mach_info *dmi)
+{
+	int ret;
+	struct dovefb_layer_info *dfli = info->gfx_plane;
+	struct fb_info *fi = dfli->fb_info;
+
+	init_waitqueue_head(&dfli->w_intr_wq);
+
+	/*
+	 * Configure default register values.
+	 */
+	dovefb_set_defaults(dfli);
+
+	/*
+	 * init video mode data.
+	 */
+	dovefb_set_mode(dfli, &fi->var, dmi->modes, dmi->pix_fmt, 0);
+
+	/*
+	 * configure GPIO's in order to enable the LCD panel to be ready for
+	 * reading the edid data
+	 */
+	set_dumb_panel_control(fi, 1);
+	ret = dovefb_init_mode(fi, dmi);
+	if (ret)
+		goto failed;
+
+	/*
+	 * Fill in sane defaults.
+	 */
+	ret = dovefb_gfx_set_par(fi);
+	if (ret)
+		goto failed;
+
+	/*
+	 * init EDID information
+	 */
+	dfli->edid_info.connect = 0;
+	dfli->edid_info.change = 0;
+	dfli->edid_info.extension = 0;
+	dfli->edid_info.interval = DEFAULT_EDID_INTERVAL;
+
+	/*
+	 * Initialize dynamic get edid timer
+	 */
+	dfli->ddc_polling_disable = dmi->ddc_polling_disable;
+	if(!dmi->ddc_polling_disable) {
+		init_timer(&dfli->get_edid_timer);
+		dfli->get_edid_timer.expires = jiffies + HZ;
+		dfli->get_edid_timer.data = (unsigned long)dfli;
+		dfli->get_edid_timer.function = dynamic_get_edid;
+		add_timer(&dfli->get_edid_timer);
+
+		INIT_WORK(&dfli->work_queue, get_edid_work);
+	} else {
+		dfli->edid_info.connect = 1;
+		dfli->edid_info.change = 1;
+		dfli->edid_info.extension = dfli->raw_edid[0x7e];
+	}
+
+	return 0;
+failed:
+	printk(KERN_ERR "dovefb_gfx_init() returned %d.\n", ret);
+	return ret;
+}
+
+struct fb_ops dovefb_gfx_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= dovefb_check_var,
+	.fb_set_par	= dovefb_gfx_set_par,
+	.fb_setcolreg	= dovefb_setcolreg,
+	.fb_blank	= dovefb_blank,
+	.fb_pan_display	= dovefb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+#ifdef DOVE_USING_HWC
+	.fb_cursor	= dovefb_cursor,
+#endif
+	.fb_sync	= dovefb_fb_sync,
+	.fb_ioctl	= dovefb_gfx_ioctl,
+};
+
+MODULE_AUTHOR("Green Wan <gwan@marvell.com>");
+MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com>");
+MODULE_AUTHOR("Shadi Ammouri <shadi@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for Dove");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/marvell/dovefb_gpio.c b/drivers/video/marvell/dovefb_gpio.c
new file mode 100644
index 0000000..852c97b
--- /dev/null
+++ b/drivers/video/marvell/dovefb_gpio.c
@@ -0,0 +1,201 @@
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <video/dovefbreg.h>
+
+static unsigned int *lcd0_regbase;
+static unsigned int *lcd1_regbase;
+
+/*
+ * Initialize lcd reg base address.
+ * If success, return 0.
+ * If failed, return -1.
+ */
+int dovefb_save_regbase(void *reg_base, unsigned int id)
+{
+	if (!reg_base)
+		return -1;
+
+	switch (id) {
+	case 0:
+		lcd0_regbase = reg_base;
+		break;
+	case 1:
+		lcd1_regbase = reg_base;
+		break;
+	default:
+		printk(KERN_WARNING "Unknown lcd id\n");
+		return -2;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dovefb_save_regbase);
+
+/*
+ * Get base addr by lcd id
+ * if success, return addr;
+ * if failed, return 0;
+ */
+void *dovefb_get_addr_by_id(unsigned int lcd_id)
+{
+	switch (lcd_id) {
+	case 0:
+		return lcd0_regbase;
+	case 1:
+		return lcd1_regbase;
+	default:
+		printk(KERN_WARNING "Unknown lcd id\n");
+	}
+
+	return 0;
+}
+
+/*
+ * Get current dumb panel io pad mode.
+ * if success, return current mode.
+ * if failed, return -1.
+ */
+int dovefb_get_cur_mode(void *reg_base)
+{
+	if (!reg_base)
+		return -1;
+
+	return readl(reg_base+SPU_IOPAD_CONTROL) & 0x0000000F;
+}
+
+/*
+ * Get total gpio mask length
+ * if success, return gpio mask.
+ * if failed, return 0.
+ */
+unsigned int dovefb_get_gpio_mask(unsigned int mode)
+{
+	unsigned int gpio_mask = 0;
+
+	switch (mode) {
+	case 0x2:
+		gpio_mask = 0x1F; /* 0~4 */
+		break;
+	case 0x3:
+		gpio_mask = 0x3;  /* 0~1 */
+		break;
+	case 0x4:
+		gpio_mask = 0x7F; /* 0~6 */
+		break;
+	case 0x5:
+		gpio_mask = 0x3F; /* 0~5 */
+		break;
+	case 0x8:
+		gpio_mask = 0xFF; /* 0~7 */
+		break;
+	default:
+		printk(KERN_WARNING "Current IO PAD mode"
+			"doesn't has GPIO output\n");
+	}
+
+	return 0;
+}
+
+/*
+ * Get current mask & output gpio settings
+ * if success, return 0.
+ * if failed, return -1.
+ */
+int dovefb_get_current_setting(unsigned int lcd_id,
+	unsigned int *mask,
+	unsigned int *output)
+{
+	void *reg_base;
+	unsigned int reg_val;
+
+	reg_base = dovefb_get_addr_by_id(lcd_id);
+
+	if (!reg_base || !mask || !output)
+		return -1;
+
+	reg_val	= readl(reg_base+LCD_SPU_DUMB_CTRL);
+	*mask	= (reg_val & 0x000FF000) >> 12;
+	*output	= (reg_val & 0x0FF00000) >> 20;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dovefb_get_current_setting);
+
+/*
+ * set LCD GPIO data.
+ * mask, is the bit mask you want to set. bit 0 = lcd gpio mask 0
+ * data, is the output data you want to set. bit 0 = lcd gpio 0
+ * if success, return 0.
+ * if failed, return -1.
+ */
+int dovefb_set_gpio(unsigned int lcd_id, unsigned int mask, unsigned int output)
+{
+	unsigned int cur_mode;
+	unsigned int gpio_mask;
+	unsigned int reg_val;
+	void *reg_base;
+
+	reg_base = dovefb_get_addr_by_id(lcd_id);
+
+	if (!reg_base) {
+		printk(KERN_WARNING "Must init lcd reg base first!!\n");
+		return -1;
+	}
+
+	/* check current mode. */
+	cur_mode = dovefb_get_cur_mode(reg_base);
+
+	/* get total mask */
+	gpio_mask = dovefb_get_gpio_mask(cur_mode);
+
+	/* check mask length. */
+	if ((gpio_mask == 0) || (mask > gpio_mask))
+		return -2;
+
+	/* get current output data */
+	reg_val	= readl(reg_base+LCD_SPU_DUMB_CTRL);
+
+	/* clear all settings. */
+	reg_val &= ~0x0ffff000;
+
+	/* apply new setting. */
+	reg_val |= (mask & 0x000000FF) << 12;
+	reg_val |= (output & 0x000000FF) << 20;
+
+	/* write new setting back. */
+	writel(reg_val, reg_base+LCD_SPU_DUMB_CTRL);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dovefb_set_gpio);
+
+/*
+ * set specific gpio pin state.
+ * pin, is gpio number. 0~7
+ * state, is gpio state. 0 or 1.
+ * if success, return 0.
+ * if failed, return -1.
+ */
+int dovefb_set_pin_state(unsigned int lcd_id,
+	unsigned int pin, unsigned int state)
+{
+	unsigned int mask;
+	unsigned int output;
+
+	dovefb_get_current_setting(lcd_id, &mask, &output);
+
+	/* clear old setting */
+	mask &= ~(0x1 << pin);
+	output &= ~(0x1 << pin);
+
+	/* calc new setting */
+	mask |= 0x1 << pin;
+	output |= state << pin;
+
+	/* apply it */
+	dovefb_set_gpio(lcd_id, mask, output);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dovefb_set_pin_state);
diff --git a/drivers/video/marvell/dovefb_if.h b/drivers/video/marvell/dovefb_if.h
new file mode 100644
index 0000000..0e4e683
--- /dev/null
+++ b/drivers/video/marvell/dovefb_if.h
@@ -0,0 +1,40 @@
+/*
+ * linux/drivers/video/marvell/dovefb_if.h -- Interface functions for Marvell
+ * GFX & Overlay FB drivers.
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+
+int dovefb_gfx_handle_irq(u32 isr, struct dovefb_layer_info *dfli);
+int dovefb_gfx_init(struct dovefb_info *info, struct dovefb_mach_info *dmi);
+int dovefb_gfx_suspend(struct dovefb_layer_info *dfli, pm_message_t mesg);
+int dovefb_gfx_resume(struct dovefb_layer_info *dfli);
+
+int dovefb_ovly_handle_irq(u32 isr, struct dovefb_layer_info *dfli);
+int dovefb_ovly_init(struct dovefb_info *info, struct dovefb_mach_info *dmi);
+int dovefb_ovly_suspend(struct dovefb_layer_info *dfli, pm_message_t mesg);
+int dovefb_ovly_resume(struct dovefb_layer_info *dfli);
+
+int dovefb_determine_best_pix_fmt(struct fb_var_screeninfo *var,
+		struct dovefb_layer_info *dfli);
+unsigned int dovefb_dump_regs(struct dovefb_info *dfi);
+int dovefb_check_var(struct fb_var_screeninfo *var, struct fb_info *fi);
+int dovefb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		unsigned int blue, unsigned int trans, struct fb_info *fi);
+void dovefb_set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt);
+void dovefb_set_mode(struct dovefb_layer_info *dfli,
+		struct fb_var_screeninfo *var, struct fb_videomode *mode,
+		int pix_fmt, int ystretch);
+
+
+extern struct fb_ops dovefb_gfx_ops;
+extern struct fb_ops dovefb_ovly_ops;
+extern struct timer_list checkbuf_timer;
+
+
diff --git a/drivers/video/marvell/dovefb_ovly.c b/drivers/video/marvell/dovefb_ovly.c
new file mode 100644
index 0000000..fae6f028
--- /dev/null
+++ b/drivers/video/marvell/dovefb_ovly.c
@@ -0,0 +1,1262 @@
+/*
+ * linux/drivers/video/dovefb.c -- Marvell DOVE LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by:
+ *	Green Wan <gwan@marvell.com>
+ *	Shadi Ammouri <shadi@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+/*
+ * 1. Adapted from:  linux/drivers/video/skeletonfb.c
+ * 2. Merged from: linux/drivers/video/dovefb.c (Lennert Buytenhek)
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+#include "dovefb_if.h"
+
+#define MAX_QUEUE_NUM	60
+#define RESET_BUF	0x1
+#define FREE_ENTRY	0x2
+#define CHECKBUF_TIMER_DELAY	33 // check video buffer 30 timers per second
+
+static int dovefb_ovly_set_par(struct fb_info *fi);
+static void set_graphics_start(struct fb_info *fi, int xoffset, int yoffset);
+static void set_dma_control0(struct dovefb_layer_info *dfli);
+static int wait_for_vsync(struct dovefb_layer_info *dfli);
+static void dovefb_do_tasklet(unsigned long data);
+
+static int addFreeBuf(u8 **bufList, u8 *freeBuf);
+static void clearFreeBuf(u8 **bufList, int iFlag);
+static int dovefb_switch_buff(struct fb_info *fi);
+static void collectFreeBuf(u8 **filterList, u8 **freeList, int count);
+static u8 *filterBufList[MAX_QUEUE_NUM];
+static u8 *freeBufList[MAX_QUEUE_NUM];
+
+struct timer_list checkbuf_timer;
+
+static struct _sViewPortInfo gViewPortInfo = {
+	.srcWidth = 640,	/* video source size */
+	.srcHeight = 480,
+	.zoomXSize = 640,	/* size after zooming */
+	.zoomYSize = 480,
+};
+
+static struct _sViewPortOffset gViewPortOffset = {
+	.xOffset = 0,	/* position on screen */
+	.yOffset = 0
+};
+
+
+static void dovefb_do_tasklet(unsigned long data)
+{
+	struct fb_info *fi;
+
+	fi = (struct fb_info *)data;
+	dovefb_switch_buff(fi);
+}
+
+static int convert_pix_fmt(u32 vmode)
+{
+	switch (vmode) {
+	case DOVEFB_VMODE_YUV422PACKED:
+		return PIX_FMT_YUV422PACK;
+	case DOVEFB_VMODE_YUV422PACKED_SWAPUV:
+		return PIX_FMT_YVU422PACK;
+	case DOVEFB_VMODE_YUV422PLANAR:
+		return PIX_FMT_YUV422PLANAR;
+	case DOVEFB_VMODE_YUV422PLANAR_SWAPUV:
+		return PIX_FMT_YVU422PLANAR;
+	case DOVEFB_VMODE_YUV420PLANAR:
+		return PIX_FMT_YUV420PLANAR;
+	case DOVEFB_VMODE_YUV420PLANAR_SWAPUV:
+		return PIX_FMT_YVU420PLANAR;
+	case DOVEFB_VMODE_YUV422PACKED_SWAPYUorV:
+		return PIX_FMT_UYVY422PACK;
+	case DOVEFB_VMODE_RGB565:
+		return PIX_FMT_RGB565;
+	case DOVEFB_VMODE_BGR565:
+		return PIX_FMT_BGR565;
+	case DOVEFB_VMODE_RGB1555:
+		return PIX_FMT_RGB1555;
+	case DOVEFB_VMODE_BGR1555:
+		return PIX_FMT_BGR1555;
+	case DOVEFB_VMODE_RGB888PACK:
+		return PIX_FMT_RGB888PACK;
+	case DOVEFB_VMODE_BGR888PACK:
+		return PIX_FMT_BGR888PACK;
+	case DOVEFB_VMODE_RGBA888:
+		return PIX_FMT_RGBA888;
+	case DOVEFB_VMODE_BGRA888:
+		return PIX_FMT_BGRA888;
+	case DOVEFB_VMODE_RGB888UNPACK:
+	case DOVEFB_VMODE_BGR888UNPACK:
+	case DOVEFB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case DOVEFB_VMODE_YUV420PLANAR_SWAPYUorV:
+	default:
+		printk(KERN_ERR "%s: Unknown vmode (%d).\n", __func__, vmode);
+		return -1;
+	}
+}
+
+static u32 dovefb_ovly_create_surface(struct _sOvlySurface *pOvlySurface)
+{
+	u16 surfaceWidth;
+	u16 surfaceHeight;
+	u32 surfaceSize;
+	DOVEFBVideoMode vmode;
+	u8 *surfVABase;
+	u8 *surfPABase;
+
+	surfaceWidth = pOvlySurface->viewPortInfo.srcWidth;
+	surfaceHeight = pOvlySurface->viewPortInfo.srcHeight;
+	vmode	= pOvlySurface->videoMode;
+
+	/* calculate video surface size */
+	switch (vmode) {
+	case DOVEFB_VMODE_YUV422PACKED:
+	case DOVEFB_VMODE_YUV422PACKED_SWAPUV:
+	case DOVEFB_VMODE_YUV422PACKED_SWAPYUorV:
+	case DOVEFB_VMODE_YUV422PLANAR:
+	case DOVEFB_VMODE_YUV422PLANAR_SWAPUV:
+	case DOVEFB_VMODE_YUV422PLANAR_SWAPYUorV:
+		surfaceSize = surfaceWidth * surfaceHeight * 2;
+		break;
+	case DOVEFB_VMODE_YUV420PLANAR:
+	case DOVEFB_VMODE_YUV420PLANAR_SWAPUV:
+	case DOVEFB_VMODE_YUV420PLANAR_SWAPYUorV:
+		surfaceSize = surfaceWidth * surfaceHeight * 3/2;
+		break;
+	default:
+		printk(KERN_INFO "Unknown video mode.\n");
+		return -ENXIO;
+	}
+
+	/* get new video buffer */
+	surfVABase = (u_char *)__get_free_pages(GFP_ATOMIC | GFP_DMA,
+				get_order(surfaceSize*2));
+
+	if (surfVABase == NULL) {
+		printk(KERN_INFO "Unable to allocate surface memory\n");
+		return -ENOMEM;
+	}
+
+	/* printk(KERN_INFO "\n create surface buffer"
+		" = 0x%08x \n", (u32)surfVABase); */
+
+	surfPABase = (u8 *)__pa(surfVABase);
+
+	memset(surfVABase, 0x0, surfaceSize);
+
+	pOvlySurface->videoBufferAddr.startAddr = surfPABase;
+	return 0;
+}
+
+static u32 dovefb_ovly_set_colorkeyalpha(struct dovefb_layer_info *dfli)
+{
+	unsigned int rb;
+	unsigned int temp;
+	unsigned int x, x_ckey;
+	struct _sColorKeyNAlpha *color_a = &dfli->ckey_alpha;
+
+	/* reset to 0x0 to disable color key. */
+	x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL1) &
+		~(CFG_COLOR_KEY_MASK | CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+
+	/* switch to color key mode */
+	switch (color_a->mode) {
+	case DOVEFB_DISABLE_COLORKEY_MODE:
+		/* do nothing */
+		break;
+	case DOVEFB_ENABLE_Y_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		break;
+	case DOVEFB_ENABLE_U_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x2);
+		break;
+	case DOVEFB_ENABLE_V_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x4);
+		break;
+	case DOVEFB_ENABLE_RGB_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x3);
+
+                /* check whether h/w turn on RB swap. */
+                rb = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0);
+                if (rb & CFG_DMA_SWAPRB_MASK) {
+                        /* exchange r b fields. */
+                        temp = color_a->Y_ColorAlpha;
+                        color_a->Y_ColorAlpha = color_a->V_ColorAlpha;
+                        color_a->V_ColorAlpha = temp;
+                }
+
+		break;
+	case DOVEFB_ENABLE_R_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x5);
+		break;
+	case DOVEFB_ENABLE_G_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x6);
+	break;
+	case DOVEFB_ENABLE_B_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x7);
+		break;
+	default:
+		printk(KERN_INFO "unknown mode");
+		return -1;
+	}
+
+	/* switch to alpha path selection */
+	switch (color_a->alphapath) {
+	case DOVEFB_VID_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x0);
+		break;
+	case DOVEFB_GRA_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x1);
+		break;
+	case DOVEFB_CONFIG_ALPHA:
+		x |= CFG_ALPHA_MODE(0x2);
+		break;
+	default:
+		printk(KERN_INFO "unknown alpha path");
+		return -1;
+	}
+
+	/* configure alpha */
+	x |= CFG_ALPHA((color_a->config & 0xff));
+
+	/* Have to program new regs to enable color key for new chip. */
+	x_ckey = readl(dfli->reg_base + LCD_SPU_ADV_REG);
+	writel( x_ckey | (0x1 << 19), dfli->reg_base + LCD_SPU_ADV_REG);
+
+	writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL1);
+	writel(color_a->Y_ColorAlpha, dfli->reg_base + LCD_SPU_COLORKEY_Y);
+	writel(color_a->U_ColorAlpha, dfli->reg_base + LCD_SPU_COLORKEY_U);
+	writel(color_a->V_ColorAlpha, dfli->reg_base + LCD_SPU_COLORKEY_V);
+
+	return 0;
+}
+
+static int check_surface(struct fb_info *fi,
+			DOVEFBVideoMode new_mode,
+			struct _sViewPortInfo *new_info,
+			struct _sViewPortOffset *new_offset,
+			struct _sVideoBufferAddr *new_addr)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int changed = 0;
+	/*
+	 * check mode
+	 */
+	if (new_mode >= 0 && dfli->surface.videoMode != new_mode) {
+		dfli->surface.videoMode = new_mode;
+		dfli->pix_fmt = convert_pix_fmt(new_mode);
+		dovefb_set_pix_fmt(var, dfli->pix_fmt);
+		changed = 1;
+	}
+
+	/*
+	 * check view port settings.
+	 */
+	if (new_info &&
+	    (dfli->surface.viewPortInfo.srcWidth != new_info->srcWidth ||
+	    dfli->surface.viewPortInfo.srcHeight != new_info->srcHeight ||
+	    dfli->surface.viewPortInfo.zoomXSize != new_info->zoomXSize ||
+	    dfli->surface.viewPortInfo.zoomYSize != new_info->zoomYSize)) {
+		var->xres = new_info->srcWidth;
+		var->yres = new_info->srcHeight;
+		var->xres_virtual = new_info->srcWidth;
+		var->yres_virtual = new_info->srcHeight;
+		dfli->surface.viewPortInfo = *new_info;
+		dovefb_set_pix_fmt(var, dfli->pix_fmt);
+		changed = 1;
+	}
+
+	/*
+	 * Check offset
+	 */
+	if (new_offset &&
+	    (dfli->surface.viewPortOffset.xOffset != new_offset->xOffset ||
+	    dfli->surface.viewPortOffset.yOffset != new_offset->yOffset)) {
+		dfli->surface.viewPortOffset.xOffset = new_offset->xOffset;
+		dfli->surface.viewPortOffset.yOffset = new_offset->yOffset;
+		changed = 1;
+	}
+
+	/*
+	 * Check buffer address
+	 */
+	if (new_addr && new_addr->startAddr &&
+	    dfli->new_addr != (unsigned long)new_addr->startAddr) {
+		dfli->new_addr = (unsigned long)new_addr->startAddr;
+		changed = 1;
+	}
+
+	return changed;
+}
+
+static int dovefb_ovly_ioctl(struct fb_info *fi, unsigned int cmd,
+		unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct dovefb_layer_info *dfli = fi->par;
+	u32 x;
+	int vmode = 0;
+	int gfx_on = 1;
+	int vid_on = 1;
+
+	switch (cmd) {
+	case DOVEFB_IOCTL_WAIT_VSYNC:
+		wait_for_vsync(dfli);
+		break;
+	case DOVEFB_IOCTL_GET_VIEWPORT_INFO:
+		return copy_to_user(argp, &dfli->surface.viewPortInfo,
+			sizeof(struct _sViewPortInfo)) ? -EFAULT : 0;
+	case DOVEFB_IOCTL_SET_VIEWPORT_INFO:
+		mutex_lock(&dfli->access_ok);
+		if (copy_from_user(&gViewPortInfo, argp,
+				sizeof(gViewPortInfo))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+
+		if (check_surface(fi, -1, &gViewPortInfo, 0, 0))
+			dovefb_ovly_set_par(fi);
+
+		mutex_unlock(&dfli->access_ok);
+		break;
+	case DOVEFB_IOCTL_SET_VIDEO_MODE:
+		/*
+		 * Get data from user space.
+		 */
+		if (copy_from_user(&vmode, argp, sizeof(vmode)))
+			return -EFAULT;
+
+		if (check_surface(fi, vmode, 0, 0, 0))
+			dovefb_ovly_set_par(fi);
+		break;
+	case DOVEFB_IOCTL_GET_VIDEO_MODE:
+		return copy_to_user(argp, &dfli->surface.videoMode,
+			sizeof(u32)) ? -EFAULT : 0;
+	case DOVEFB_IOCTL_CREATE_VID_BUFFER:
+	{
+		struct _sOvlySurface OvlySurface;
+
+		mutex_lock(&dfli->access_ok);
+		if (copy_from_user(&OvlySurface, argp,
+				sizeof(struct _sOvlySurface))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+
+		/* Request a video buffer. */
+		dovefb_ovly_create_surface(&OvlySurface);
+
+		if (copy_to_user(argp, &OvlySurface,
+				sizeof(struct _sOvlySurface))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+
+		mutex_unlock(&dfli->access_ok);
+
+		break;
+	}
+	case DOVEFB_IOCTL_FLIP_VID_BUFFER:
+	{
+		struct _sOvlySurface *surface = 0;
+		u8 *start_addr, *input_data, *dst_addr;
+		u32 length;
+		surface = kmalloc(sizeof(struct _sOvlySurface),
+				GFP_KERNEL);
+
+		/* Get user-mode data. */
+		if (copy_from_user(surface, argp,
+		    sizeof(struct _sOvlySurface))) {
+			kfree(surface);
+			return -EFAULT;
+		}
+		mutex_lock(&dfli->access_ok);
+		length = surface->videoBufferAddr.length;
+		dst_addr = dfli->surface.videoBufferAddr.startAddr;
+		start_addr = surface->videoBufferAddr.startAddr;
+		input_data = surface->videoBufferAddr.inputData;
+
+		/*
+		 * Has DMA addr?
+		 */
+		if (start_addr &&
+		    (!input_data)) {
+			if (0 != addFreeBuf(freeBufList, (u8 *)surface)) {
+				printk(KERN_INFO "Error: addFreeBuf()\n");
+				mutex_unlock(&dfli->access_ok);
+				kfree(surface);
+				return -EFAULT;
+			} else {
+				/* printk(KERN_INFO "addFreeBuf(0x%08x) ok.\n",
+					start_addr); */
+			}
+		} else {
+			if (check_surface(fi, surface->videoMode,
+					&surface->viewPortInfo,
+					&surface->viewPortOffset,
+					&surface->videoBufferAddr))
+				dovefb_ovly_set_par(fi);
+
+			/* copy buffer */
+			if (input_data) {
+				wait_for_vsync(dfli);
+				/* if support hw DMA, replace this. */
+				if (copy_from_user(dfli->fb_start,
+						   input_data, length)) {
+					mutex_unlock(&dfli->access_ok);
+					kfree(surface);
+					return -EFAULT;
+				}
+				mutex_unlock(&dfli->access_ok);
+				kfree(surface);
+				return 0;
+			}
+
+			kfree(surface);
+#if 0
+			/*
+			 * Fix me: Currently not implemented yet.
+			 * Application allocate a physical contiguous
+			 * buffer and pass it into driver. Here is to
+			 * update fb's info to new buffer and free
+			 * old buffer.
+			 */
+			if (start_addr) {
+				if (dfli->mem_status)
+					free_pages(
+					    (unsigned long)dfli->fb_start,
+					    get_order(dfli->fb_size));
+				else
+					dma_free_writecombine(dfli->dev,
+					    dfli->fb_size,
+					    dfli->fb_start,
+					    dfli->fb_start_dma);
+
+				dfli->fb_start = __va(start_addr);
+				dfli->fb_size = length;
+				dfli->fb_start_dma =
+				    (dma_addr_t)__pa(dfli->fb_start);
+				dfli->mem_status = 1;
+				fi->fix.smem_start = dfli->fb_start_dma;
+				fi->fix.smem_len = dfli->fb_size;
+				fi->screen_base = dfli->fb_start;
+				fi->screen_size = dfli->fb_size;
+			}
+#endif
+		}
+		mutex_unlock(&dfli->access_ok);
+		return 0;
+	}
+	case DOVEFB_IOCTL_GET_FREELIST:
+	{
+		mutex_lock(&dfli->access_ok);
+
+		if (copy_to_user(argp, filterBufList,
+				MAX_QUEUE_NUM*sizeof(u8 *))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+
+		clearFreeBuf(filterBufList, RESET_BUF);
+
+		mutex_unlock(&dfli->access_ok);
+		return 0;
+	}
+	case DOVEFB_IOCTL_GET_BUFF_ADDR:
+	{
+		return copy_to_user(argp, &dfli->surface.videoBufferAddr,
+			sizeof(struct _sVideoBufferAddr)) ? -EFAULT : 0;
+	}
+	case DOVEFB_IOCTL_SET_VID_OFFSET:
+		mutex_lock(&dfli->access_ok);
+		if (copy_from_user(&gViewPortOffset, argp,
+				sizeof(gViewPortOffset))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+
+		if (check_surface(fi, -1, 0, &gViewPortOffset, 0))
+			dovefb_ovly_set_par(fi);
+		mutex_unlock(&dfli->access_ok);
+		break;
+	case DOVEFB_IOCTL_GET_VID_OFFSET:
+		return copy_to_user(argp, &dfli->surface.viewPortOffset,
+			sizeof(struct _sViewPortOffset)) ? -EFAULT : 0;
+	case DOVEFB_IOCTL_SET_MEMORY_TOGGLE:
+		break;
+	case DOVEFB_IOCTL_SET_COLORKEYnALPHA:
+		if (copy_from_user(&dfli->ckey_alpha, argp,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+
+		dovefb_ovly_set_colorkeyalpha(dfli);
+		break;
+	case DOVEFB_IOCTL_GET_COLORKEYnALPHA:
+		if (copy_to_user(argp, &dfli->ckey_alpha,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+		break;
+	case DOVEFB_IOCTL_SWITCH_VID_OVLY:
+		if (copy_from_user(&vid_on, argp, sizeof(int)))
+			return -EFAULT;
+		if (0 == vid_on) {
+			x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) &
+				~CFG_DMA_ENA_MASK;
+			writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+		} else {
+			x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) |
+				CFG_DMA_ENA(0x1);
+			writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+			/* Enable VID & VSync. */
+			x = readl(dfli->reg_base + SPU_IRQ_ENA) |
+				DOVEFB_VID_INT_MASK | DOVEFB_VSYNC_INT_MASK;
+			writel( x, dfli->reg_base + SPU_IRQ_ENA);
+		}
+		break;
+	case DOVEFB_IOCTL_SWITCH_GRA_OVLY:
+		if (copy_from_user(&gfx_on, argp, sizeof(int)))
+			return -EFAULT;
+		if (0 == gfx_on) {
+			x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) &
+				~CFG_GRA_ENA_MASK;
+			writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+		} else {
+			x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0) |
+				CFG_GRA_ENA(0x1);
+			writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+		}
+		break;
+	case DOVEFB_IOCTL_GET_FBID:
+		mutex_lock(&dfli->access_ok);
+		if (copy_to_user(argp, &dfli->cur_fbid, sizeof(unsigned int))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+		mutex_unlock(&dfli->access_ok);
+		break;
+	case DOVEFB_IOCTL_GET_SRC_MODE:
+		mutex_lock(&dfli->access_ok);
+		if (copy_to_user(argp, &dfli->src_mode, sizeof(int))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+		mutex_unlock(&dfli->access_ok);
+		break;
+	case DOVEFB_IOCTL_SET_SRC_MODE:
+		mutex_lock(&dfli->access_ok);
+		if (copy_from_user(&dfli->src_mode, argp, sizeof(int))) {
+			mutex_unlock(&dfli->access_ok);
+			return -EFAULT;
+		}
+		mutex_unlock(&dfli->access_ok);
+		break;
+	case DOVEFB_IOCTL_GET_FBPA:
+		{
+		struct shm_private_info info;
+		int index;
+
+		if (copy_from_user(&info, argp,
+		    sizeof(struct shm_private_info)))
+			return -EFAULT;
+
+		/* which frame want to find. */
+		index = info.fbid;
+
+		/* calc physical address. */
+		info.fb_pa = (unsigned long)(dfli->fb_start_dma+
+				(index*info.width*info.height*MAX_YUV_PIXEL));
+		if (copy_to_user(argp, &info, sizeof(struct shm_private_info)))
+			return -EFAULT;
+
+		break;
+		}
+	default:
+		printk(KERN_INFO "ioctl_ovly(0x%x) No match.\n", cmd);
+		break;
+	}
+
+	return 0;
+}
+
+static void collectFreeBuf(u8 **filterList, u8 **freeList, int count)
+{
+	int i = 0, j = 0;
+	struct _sOvlySurface *srf = 0;
+	u8 *ptr;
+
+	if ((count < 1) || !filterList || !freeList)
+		return;
+
+	for (i = 0, j = 0; i < count; i++) {
+
+		ptr = freeList[i];
+
+		/* Check freeList's content. */
+		if (ptr) {
+			for (; j < MAX_QUEUE_NUM; j++) {
+				if (!(filterList[j])) {
+					/* get surface's ptr. */
+					srf = (struct _sOvlySurface *)ptr;
+
+					/*
+					 * save ptrs which need
+					 * to be freed.
+					 */
+					filterList[j] =
+					    srf->videoBufferAddr.startAddr;
+
+					break;
+				}
+			}
+
+			if (j >= MAX_QUEUE_NUM)
+				break;
+
+			kfree(freeList[i]);
+			freeList[i] = 0;
+		} else {
+			/* till content is null. */
+			break;
+		}
+	}
+
+	freeList[0] = freeList[count];
+	freeList[count] = 0;
+}
+
+static int addFreeBuf(u8 **ppBufList, u8 *pFreeBuf)
+{
+	int i = 0 ;
+	struct _sOvlySurface *srf0 = (struct _sOvlySurface *)(pFreeBuf);
+	struct _sOvlySurface *srf1 = 0;
+
+	/* Error checking */
+	if (!srf0)
+		return -1;
+
+	for (; i < MAX_QUEUE_NUM; i++) {
+		srf1 = (struct _sOvlySurface *)ppBufList[i];
+
+		if (!srf1) {
+			/* printk(KERN_INFO "Set pFreeBuf "
+				"into %d entry.\n", i);
+			*/
+			ppBufList[i] = pFreeBuf;
+			return 0;
+		}
+
+		if (srf1->videoBufferAddr.startAddr ==
+		     srf0->videoBufferAddr.startAddr) {
+			/* same address, free this request. */
+			kfree(pFreeBuf);
+			return 0;
+		}
+	}
+
+
+	if (i >= MAX_QUEUE_NUM)
+	    printk(KERN_INFO "buffer overflow\n");
+
+	return -3;
+}
+
+static void clearFreeBuf(u8 **ppBufList, int iFlag)
+{
+	int i = 0;
+
+	/* Check null pointer. */
+	if (!ppBufList)
+		return;
+
+	/* free */
+	if (FREE_ENTRY & iFlag) {
+		for (i = 0; i < MAX_QUEUE_NUM; i++) {
+			if (ppBufList && ppBufList[i])
+				kfree(ppBufList[i]);
+		}
+	}
+
+	if (RESET_BUF & iFlag)
+		memset(ppBufList, 0, MAX_QUEUE_NUM * sizeof(u8 *));
+}
+
+static int dovefb_ovly_open(struct fb_info *fi, int user)
+{
+	struct dovefb_mach_info *dmi;
+	struct dovefb_layer_info *dfli = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+
+	dmi = dfli->dev->platform_data;
+	dfli->new_addr = 0;
+	dfli->cur_fbid = 0;
+	fi->fix.smem_start = dfli->fb_start_dma;
+	fi->fix.smem_len = dfli->fb_size;
+	fi->screen_base = dfli->fb_start;
+	fi->screen_size = dfli->fb_size;
+	memset(dfli->fb_start, 0, dfli->fb_size);
+
+	dfli->pix_fmt = dmi->pix_fmt;
+	dfli->surface.videoMode = -1;
+	dfli->surface.viewPortInfo.srcWidth = var->xres;
+	dfli->surface.viewPortInfo.srcHeight = var->yres;
+	dfli->surface.viewPortInfo.zoomXSize = var->xres;
+	dfli->surface.viewPortInfo.zoomYSize = var->yres;
+	dfli->surface.videoBufferAddr.startAddr = (unsigned char *)fi->fix.smem_start;
+	dovefb_set_pix_fmt(var, dfli->pix_fmt);
+	dovefb_ovly_set_par(fi);
+
+	if (mutex_is_locked(&dfli->access_ok))
+		mutex_unlock(&dfli->access_ok);
+
+	/* clear buffer list. */
+	mutex_lock(&dfli->access_ok);
+	clearFreeBuf(filterBufList, RESET_BUF);
+	clearFreeBuf(freeBufList, RESET_BUF|FREE_ENTRY);
+	mutex_unlock(&dfli->access_ok);
+
+	return 0;
+}
+
+static int dovefb_release(struct fb_info *fi, int user)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+
+	/* Disable all interrupts. */
+	writel( 0x0, dfli->reg_base + SPU_IRQ_ENA);
+
+	/* clear buffer list. */
+	mutex_lock(&dfli->access_ok);
+	clearFreeBuf(filterBufList, RESET_BUF);
+	clearFreeBuf(freeBufList, RESET_BUF|FREE_ENTRY);
+	mutex_unlock(&dfli->access_ok);
+	return 0;
+}
+
+static int dovefb_switch_buff(struct fb_info *fi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	int i = 0;
+	struct _sOvlySurface *pOvlySurface = 0;
+	unsigned long startaddr;
+	int fbid;
+
+	/*
+	 * Find the latest frame.
+	 */
+	for (i = (MAX_QUEUE_NUM-1); i >= 0; i--) {
+		if (freeBufList[i]) {
+			pOvlySurface = (struct _sOvlySurface *)freeBufList[i];
+			break;
+		}
+	}
+
+	if (!pOvlySurface) {
+		/*printk(KERN_INFO "********Oops: pOvlySurface"
+			" is NULL!!!!\n\n");*/
+		return -1;
+	}
+
+	startaddr = (unsigned long)pOvlySurface->videoBufferAddr.startAddr;
+	fbid = (int)pOvlySurface->videoBufferAddr.frameID;
+	/*
+	 * Got new frame?
+	 */
+	if (dfli->new_addr != startaddr) {
+		/*
+		 * Collect expired frame to list.
+		 */
+		collectFreeBuf(filterBufList, freeBufList, (i));
+
+		/*
+		 * Update new surface.
+		 */
+		if (check_surface(fi, pOvlySurface->videoMode,
+				&pOvlySurface->viewPortInfo,
+				&pOvlySurface->viewPortOffset,
+				&pOvlySurface->videoBufferAddr)) {
+			dovefb_ovly_set_par(fi);
+			dfli->cur_fbid = fbid;
+		}
+	}
+
+	return 0;
+}
+
+
+
+static void set_dma_control0(struct dovefb_layer_info *dfli)
+{
+	u32 x, x_bk;
+	int pix_fmt;
+
+	pix_fmt = dfli->pix_fmt;
+
+	/*
+	 * Get reg's current value
+	 */
+	x_bk = x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL0);
+	/*
+	 * clear video layer's field
+	 */
+	x &= 0xef0fff01;
+
+	/*
+	 * enable horizontal smooth scaling.
+	 */
+	x |= 0x1 << 6;
+
+	/*
+	 * If we are in a pseudo-color mode, we need to enable
+	 * palette lookup.
+	 */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		x |= 0x10000000;
+
+	/*
+	 * Configure hardware pixel format.
+	 */
+	x |= ((pix_fmt & ~0x1000) >> 1) << 20;
+
+	/*
+	 * configure video format into HW.
+	 * HW default use UYVY as YUV422Packed format
+	 *            use YUV as planar format
+	 */
+	if ((pix_fmt & 0x1000)) {	/* UYVY. */
+		x |= 0x00000002;
+	} else if ((pix_fmt == 10) || (pix_fmt == 11)) { /* YUYV, YVYU */
+		x |= 1				<< 1;
+		x |= 1				<< 2;
+		x |= (pix_fmt & 1) 		<< 3;
+		x |= (dfli->info->panel_rbswap) << 4;
+	} else if (pix_fmt >= 12) {	/* YUV Planar */
+		x |= 1				<< 1;
+		x |= ((pix_fmt & 1) ^ 1)	<< 3;
+		x |= dfli->info->panel_rbswap	<< 4;
+	} else {	/* RGB, BGR format */
+		x |= ((pix_fmt & 1)^(dfli->info->panel_rbswap)) << 4;
+	}
+
+	if (x_bk != x)
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL0);
+}
+
+static void set_dma_control1(struct dovefb_layer_info *dfli, int sync)
+{
+	u32 x, x_bk;
+
+	/*
+	 * Get current settings.
+	 */
+	x_bk = x = readl(dfli->reg_base + LCD_SPU_DMA_CTRL1);
+
+	/*
+	 * We trigger DMA on the falling edge of vsync if vsync is
+	 * active low, or on the rising edge if vsync is active high.
+	 */
+	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
+		x |= 0x08000000;
+
+	if (x_bk != x)
+		writel(x, dfli->reg_base + LCD_SPU_DMA_CTRL1);
+}
+
+static int wait_for_vsync(struct dovefb_layer_info *dfli)
+{
+	if (dfli) {
+		u32 irq_ena = readl(dfli->reg_base + SPU_IRQ_ENA);
+		int rc = 0;
+
+		writel(irq_ena | DOVEFB_VID_INT_MASK | DOVEFB_VSYNC_INT_MASK,
+		       dfli->reg_base + SPU_IRQ_ENA);
+
+		rc = wait_event_interruptible_timeout(dfli->w_intr_wq,
+						      atomic_read(&dfli->w_intr), 40);
+
+		if ( rc <= 0)
+			printk(KERN_ERR "%s: vid wait for vsync timed out, rc %d\n",
+			       __func__, rc);
+
+		writel(irq_ena,
+		       dfli->reg_base + SPU_IRQ_ENA);
+		atomic_set(&dfli->w_intr, 0);
+		return 0;
+	}
+
+	return 0;
+}
+
+static void set_graphics_start(struct fb_info *fi, int xoffset, int yoffset)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int pixel_offset;
+	unsigned long addr;
+
+	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+
+	if (dfli->new_addr) {
+		addr = dfli->new_addr +
+			(pixel_offset * (var->bits_per_pixel >> 3));
+	} else {
+		addr = dfli->fb_start_dma +
+			(pixel_offset * (var->bits_per_pixel >> 3));
+	}
+
+	writel(addr, dfli->reg_base + LCD_SPU_DMA_START_ADDR_Y0);
+
+	if (dfli->pix_fmt >= 12 && dfli->pix_fmt <= 15)
+		addr += var->xres * var->yres;
+	writel(addr, dfli->reg_base + LCD_SPU_DMA_START_ADDR_U0);
+
+	if ((dfli->pix_fmt>>1) == 6)
+		addr += var->xres * var->yres/2;
+	else if ((dfli->pix_fmt>>1) == 7)
+		addr += var->xres * var->yres/4;
+	writel(addr, dfli->reg_base + LCD_SPU_DMA_START_ADDR_V0);
+}
+
+static int dovefb_ovly_pan_display(struct fb_var_screeninfo *var,
+    struct fb_info *fi)
+{
+	set_graphics_start(fi, var->xoffset, var->yoffset);
+
+	return 0;
+}
+
+static int set_pitch(struct dovefb_layer_info *dfli,
+	struct fb_var_screeninfo *var)
+{
+	int ycp, uvp;
+
+	ycp =	dfli->surface.viewPortInfo.ycPitch;
+	uvp =	dfli->surface.viewPortInfo.uvPitch;
+	if (ycp <= 0) {
+		printk(KERN_WARNING "YC pitch is 0."
+			"User program needs refine\n");
+		if ((dfli->pix_fmt >= 0) && (dfli->pix_fmt < 10)) {
+			writel((var->xres_virtual * var->bits_per_pixel) >> 3,
+				dfli->reg_base + LCD_SPU_DMA_PITCH_YC);
+		} else {
+			if (((dfli->pix_fmt & ~0x1000) >> 1) == 5) {
+				writel((var->xres*2),
+					dfli->reg_base + LCD_SPU_DMA_PITCH_YC);
+			} else {
+				writel((var->xres),
+					dfli->reg_base + LCD_SPU_DMA_PITCH_YC);
+			}
+		}
+	} else {
+		writel(ycp, dfli->reg_base + LCD_SPU_DMA_PITCH_YC);
+	}
+
+	if (uvp <= 0) {
+		if ((dfli->pix_fmt >= 0) && (dfli->pix_fmt < 10)) {
+			;
+		} else {
+			if (((dfli->pix_fmt & ~0x1000) >> 1) == 5) {
+				writel(((var->xres) << 16) | (var->xres) ,
+					dfli->reg_base + LCD_SPU_DMA_PITCH_UV);
+			} else {
+				writel((var->xres >> 1) << 16 |
+					(var->xres >> 1) ,
+					dfli->reg_base + LCD_SPU_DMA_PITCH_UV);
+			}
+		}
+	} else {
+		writel((uvp << 16) | uvp,
+			dfli->reg_base + LCD_SPU_DMA_PITCH_UV);
+	}
+
+	return 0;
+}
+
+static int dovefb_ovly_set_par(struct fb_info *fi)
+{
+	struct dovefb_layer_info *dfli = fi->par;
+	struct dovefb_info *info = dfli->info;
+	struct dovefb_layer_info *gfxli = info->gfx_plane;
+	struct fb_var_screeninfo *var = &fi->var;
+	int pix_fmt;
+	int xzoom, yzoom;
+
+	/*
+	 * Determine which pixel format we're going to use.
+	 */
+	pix_fmt = dovefb_determine_best_pix_fmt(&fi->var, dfli);
+	if (pix_fmt < 0)
+		return pix_fmt;
+	dfli->pix_fmt = pix_fmt;
+
+	/*
+	 * Set RGB bit field info.
+	 */
+	dovefb_set_pix_fmt(var, pix_fmt);
+
+	/*
+	 * Set additional mode info.
+	 */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		fi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fi->fix.visual = FB_VISUAL_TRUECOLOR;
+	fi->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	/*
+	 * Configure global panel parameters.
+	 */
+	set_dma_control0(dfli);
+	set_dma_control1(dfli, fi->var.sync);
+
+	/*
+	 * Configure graphics DMA parameters.
+	 */
+	set_graphics_start(fi, fi->var.xoffset, fi->var.yoffset);
+
+	/*
+	 * Configure yuv pitch.
+	 */
+	set_pitch(dfli, var);
+
+	/*
+	 * program original size.
+	 */
+	writel((var->yres << 16) | (var->xres),
+		dfli->reg_base + LCD_SPU_DMA_HPXL_VLN);
+
+	/*
+	 * program size after scaling.
+	 */
+	if (info->fixed_output == 0) {
+		yzoom = dfli->surface.viewPortInfo.zoomYSize;
+		xzoom = dfli->surface.viewPortInfo.zoomXSize;
+	} else {
+		yzoom = dfli->surface.viewPortInfo.zoomYSize *
+			info->out_vmode.yres / gfxli->fb_info->var.yres;
+		xzoom = dfli->surface.viewPortInfo.zoomXSize *
+			info->out_vmode.xres / gfxli->fb_info->var.xres;
+	}
+	writel((yzoom << 16) | xzoom,
+		dfli->reg_base + LCD_SPU_DZM_HPXL_VLN);
+
+	/* update video position offset */
+	writel(CFG_DMA_OVSA_VLN(dfli->surface.viewPortOffset.yOffset)|
+		dfli->surface.viewPortOffset.xOffset,
+		dfli->reg_base + LCD_SPUT_DMA_OVSA_HPXL_VLN);
+
+	return 0;
+}
+
+
+static int dovefb_ovly_fb_sync(struct fb_info *info)
+{
+	struct dovefb_layer_info *dfli = info->par;
+
+	return wait_for_vsync(dfli);
+}
+
+static void checkbuf_func(unsigned long data){
+
+	struct dovefb_layer_info *dfli = (struct dovefb_layer_info *) data;
+
+	/* wake up queue. */
+	atomic_set(&dfli->w_intr, 1);
+	wake_up(&dfli->w_intr_wq);
+
+	/* add a tasklet. */
+	tasklet_schedule(&dfli->tasklet);
+
+	/* kick off timer */
+	add_timer(&checkbuf_timer);
+}
+/*
+ *  dovefb_handle_irq(two lcd controllers)
+ */
+int dovefb_ovly_handle_irq(u32 isr, struct dovefb_layer_info *dfli)
+{
+	/* wake up queue. */
+	atomic_set(&dfli->w_intr, 1);
+	wake_up(&dfli->w_intr_wq);
+
+	/* add a tasklet. */
+	tasklet_schedule(&dfli->tasklet);
+
+	return 1;
+}
+
+
+#ifdef CONFIG_PM
+int dovefb_ovly_suspend(struct dovefb_layer_info *dfli, pm_message_t mesg)
+{
+	struct fb_info *fi = dfli->fb_info;
+
+	if (mesg.event & PM_EVENT_SLEEP)
+		fb_set_suspend(fi, 1);
+
+	return 0;
+}
+
+int dovefb_ovly_resume(struct dovefb_layer_info *dfli)
+{
+	struct fb_info *fi = dfli->fb_info;
+
+	dfli->active = 1;
+
+	if (dovefb_ovly_set_par(fi) != 0) {
+		printk(KERN_INFO "dovefb_ovly_resume(): Failed in "
+				"dovefb_ovly_set_par().\n");
+		return -1;
+	}
+
+	fb_set_suspend(fi, 0);
+
+	return 0;
+}
+#endif
+
+int dovefb_ovly_init(struct dovefb_info *info, struct dovefb_mach_info *dmi)
+{
+	struct dovefb_layer_info *dfli = info->vid_plane;
+	struct fb_info *fi = dfli->fb_info;
+
+	dfli->tasklet.next = NULL;
+	dfli->tasklet.state = 0;
+	atomic_set(&dfli->tasklet.count, 0);
+	dfli->tasklet.func = dovefb_do_tasklet;
+	dfli->tasklet.data = (unsigned long)fi;
+	dfli->surface.videoBufferAddr.startAddr = (unsigned char *)fi->fix.smem_start; 
+
+	init_waitqueue_head(&dfli->w_intr_wq);
+	mutex_init(&dfli->access_ok);
+
+	/*
+	 * Initialize check buffer timer
+	 */
+	init_timer(&checkbuf_timer);
+	checkbuf_timer.expires = jiffies + msecs_to_jiffies(CHECKBUF_TIMER_DELAY);
+	checkbuf_timer.data = (unsigned long)dfli;
+	checkbuf_timer.function = checkbuf_func;
+
+	/*
+	 * Fill in sane defaults.
+	 */
+	dovefb_set_mode(dfli, &fi->var, dmi->modes, dmi->pix_fmt, 0);
+	dovefb_ovly_set_par(fi);
+
+	/*
+	 * Configure default register values.
+	 */
+	writel(0x00000000, dfli->reg_base + LCD_SPU_DMA_START_ADDR_Y1);
+	writel(0x00000000, dfli->reg_base + LCD_SPU_DMA_START_ADDR_U1);
+	writel(0x00000000, dfli->reg_base + LCD_SPU_DMA_START_ADDR_V1);
+	writel(0x00000000, dfli->reg_base + LCD_SPUT_DMA_OVSA_HPXL_VLN);
+
+	return 0;
+}
+
+
+/* Fix me: Currently, bufferable property can't be enabled correctly. It has
+ * to be enabled cacheable. Or write buffer won't act properly. Here
+ * we override the attribute when any program wants to map to this
+ * buffer. When HW is ready, this function could simply be removed.
+ */
+static int dovefb_ovly_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	unsigned long off;
+	unsigned long start;
+	u32 len;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	//lock_kernel();
+
+	/* frame buffer memory */
+	start = info->fix.smem_start;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
+	if (off >= len) {
+		/* memory mapped io */
+		off -= len;
+		if (info->var.accel_flags) {
+			//unlock_kernel();
+			return -EINVAL;
+		}
+		start = info->fix.mmio_start;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
+	}
+	//unlock_kernel();
+	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+
+	/* io control needs non-cacheable attribute. */
+	if (start == info->fix.mmio_start)
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+			     vma->vm_end - vma->vm_start, vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+struct fb_ops dovefb_ovly_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= dovefb_ovly_open,
+	.fb_release	= dovefb_release,
+	.fb_mmap	= dovefb_ovly_mmap,
+	.fb_check_var	= dovefb_check_var,
+	.fb_set_par	= dovefb_ovly_set_par,
+/*	.fb_setcolreg	= dovefb_setcolreg,*/
+	.fb_pan_display	= dovefb_ovly_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_sync	= dovefb_ovly_fb_sync,
+	.fb_ioctl	= dovefb_ovly_ioctl,
+};
+
+
+MODULE_AUTHOR("Green Wan <gwan@marvell.com>");
+MODULE_AUTHOR("Shadi Ammouri <shadi@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for Dove");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index cb3d810..787edab 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -40,12 +40,14 @@
 #define MPT_MINOR		220
 #define MPT2SAS_MINOR		221
 #define UINPUT_MINOR		223
+#define UINPUT_MINOR		223
 #define HPET_MINOR		228
 #define FUSE_MINOR		229
 #define KVM_MINOR		232
 #define BTRFS_MINOR		234
 #define AUTOFS_MINOR		235
 #define MAPPER_CTRL_MINOR	236
+#define MAPPER_CTRL_MINOR	236
 #define LOOP_CTRL_MINOR		237
 #define VHOST_NET_MINOR		238
 #define MISC_DYNAMIC_MINOR	255
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index bea039c..05d8f45 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -33,6 +33,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/netdev_features.h>
 
+#if defined(CONFIG_NET_SKB_HEADROOM)
+#define NET_SKB_PAD CONFIG_NET_SKB_HEADROOM
+#endif
+
 /* Don't change this without changing skb_csum_unnecessary! */
 #define CHECKSUM_NONE 0
 #define CHECKSUM_UNNECESSARY 1
diff --git a/include/video/dovefb.h b/include/video/dovefb.h
new file mode 100644
index 0000000..665eba5
--- /dev/null
+++ b/include/video/dovefb.h
@@ -0,0 +1,507 @@
+/*
+ * linux/include/video/dovefb.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _DOVEFB_H_
+#define _DOVEFB_H_
+
+/* ---------------------------------------------- */
+/*              Header Files                      */
+/* ---------------------------------------------- */
+#include <linux/fb.h>
+
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define DOVEFB_IOC_MAGIC			'm'
+#define DOVEFB_IOCTL_CONFIG_CURSOR		_IO(DOVEFB_IOC_MAGIC, 0)
+#define DOVEFB_IOCTL_DUMP_REGS			_IO(DOVEFB_IOC_MAGIC, 1)
+#define DOVEFB_IOCTL_CLEAR_IRQ			_IO(DOVEFB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define DOVEFB_IOCTL_SET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 3)
+#define DOVEFB_IOCTL_GET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define DOVEFB_IOCTL_CREATE_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define DOVEFB_IOCTL_SET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 6)
+#define DOVEFB_IOCTL_GET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    DOVEFB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define DOVEFB_IOCTL_FLIP_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 8)
+
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use DOVEFB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define DOVEFB_IOCTL_GET_BUFF_ADDR		_IO(DOVEFB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define DOVEFB_IOCTL_SET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 10)
+#define DOVEFB_IOCTL_GET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_MEMORY_TOGGLE		_IO(DOVEFB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 13)
+#define DOVEFB_IOCTL_GET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 14)
+#define DOVEFB_IOCTL_SWITCH_GRA_OVLY		_IO(DOVEFB_IOC_MAGIC, 15)
+#define DOVEFB_IOCTL_SWITCH_VID_OVLY		_IO(DOVEFB_IOC_MAGIC, 16)
+
+/* For Vmeta integration */
+#define DOVEFB_IOCTL_GET_FREELIST		_IO(DOVEFB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define DOVEFB_IOCTL_WAIT_VSYNC			_IO(DOVEFB_IOC_MAGIC, 18)
+
+/* for xv+vmeta/sw decoder w/o memory move. */
+#define DOVEFB_IOCTL_GET_FBPA			_IO(DOVEFB_IOC_MAGIC, 19)
+#define DOVEFB_IOCTL_GET_FBID			_IO(DOVEFB_IOC_MAGIC, 20)
+#define DOVEFB_IOCTL_SET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 21)
+#define DOVEFB_IOCTL_GET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 22)
+
+/* Dynamic get EDID data */
+#define DOVEFB_IOCTL_GET_EDID_INFO		_IO(DOVEFB_IOC_MAGIC, 23)
+#define DOVEFB_IOCTL_GET_EDID_DATA		_IO(DOVEFB_IOC_MAGIC, 24)
+#define DOVEFB_IOCTL_SET_EDID_INTERVAL		_IO(DOVEFB_IOC_MAGIC, 25)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FBIO_CLEAR_FRAMEBUFFER			_IO(FB_IOC_MAGIC, 19)
+
+/* Global alpha blend controls - Maintaining compatibility with existing
+   user programs. */
+#define FBIOPUT_VIDEO_ALPHABLEND            0xeb
+#define FBIOPUT_GLOBAL_ALPHABLEND           0xe1
+#define FBIOPUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FBIOPUT_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FBIOPUT_SWAP_GRAPHIC_U_V            0xe4
+#define FBIOPUT_SWAP_GRAPHIC_Y_UV           0xe5
+#define FBIOPUT_SWAP_VIDEO_RED_BLUE         0xe6
+#define FBIOPUT_SWAP_VIDEO_U_V              0xe7
+#define FBIOPUT_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FBIOGET_CHROMAKEYS                  0xe9
+#define FBIOPUT_CHROMAKEYS                  0xea
+
+#define DOVEFB_VMODE_RGB565			0x100
+#define DOVEFB_VMODE_BGR565			0x101
+#define DOVEFB_VMODE_RGB1555			0x102
+#define DOVEFB_VMODE_BGR1555			0x103
+#define DOVEFB_VMODE_RGB888PACK			0x104
+#define DOVEFB_VMODE_BGR888PACK			0x105
+#define DOVEFB_VMODE_RGB888UNPACK		0x106
+#define DOVEFB_VMODE_BGR888UNPACK		0x107
+#define DOVEFB_VMODE_RGBA888			0x108
+#define DOVEFB_VMODE_BGRA888			0x109
+
+#define	DOVEFB_VMODE_YUV422PACKED		0x0
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPUV	0x1
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPYUorV	0x2
+#define	DOVEFB_VMODE_YUV422PLANAR		0x3
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPUV	0x4
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPYUorV	0x5
+#define	DOVEFB_VMODE_YUV420PLANAR		0x6
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPUV	0x7
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPYUorV	0x8
+
+#define	DOVEFB_HWCMODE_1BITMODE			0x0
+#define	DOVEFB_HWCMODE_2BITMODE			0x1
+
+#define	DOVEFB_DISABLE_COLORKEY_MODE		0x0
+#define	DOVEFB_ENABLE_Y_COLORKEY_MODE		0x1
+#define	DOVEFB_ENABLE_U_COLORKEY_MODE		0x2
+#define	DOVEFB_ENABLE_V_COLORKEY_MODE		0x4
+#define	DOVEFB_ENABLE_RGB_COLORKEY_MODE		0x3
+#define	DOVEFB_ENABLE_R_COLORKEY_MODE		0x5
+#define	DOVEFB_ENABLE_G_COLORKEY_MODE		0x6
+#define	DOVEFB_ENABLE_B_COLORKEY_MODE		0x7
+
+#define DOVEFB_VID_PATH_ALPHA               0x0
+#define DOVEFB_GRA_PATH_ALPHA               0x1
+#define DOVEFB_CONFIG_ALPHA                 0x2
+
+#define DOVEFB_SYNC_COLORKEY_TO_CHROMA          1
+#define DOVEFB_SYNC_CHROMA_TO_COLORKEY          2
+
+/* Compatible to pxa168. */
+#define FB_IOCTL_SET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 14)
+#define FB_VID_PATH_ALPHA               0x0
+#define FB_GRA_PATH_ALPHA               0x1
+#define FB_CONFIG_ALPHA                 0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define DOVEFB_FB_NUM		2
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+struct _sEdidInfo {
+	int connect;			/* is monitor connected */
+	int change;			/* is edid data changed */
+	int extension;			/* the number of extension edid block */
+	int interval;			/* the interval to check edid */
+};
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define DOVEFBVideoMode signed int
+
+struct _sViewPortInfo {
+	unsigned short srcWidth;	/* video source size */
+	unsigned short srcHeight;
+	unsigned short zoomXSize;	/* size after zooming */
+	unsigned short zoomYSize;
+	unsigned short ycPitch;
+	unsigned short uvPitch;
+};
+
+struct _sViewPortOffset {
+	unsigned short xOffset;		/* position on screen */
+	unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+	unsigned char	frameID;	/* which frame wants */
+	unsigned char *startAddr;	/* new buffer (PA) */
+	unsigned char *inputData;	/* input buf address (VA) */
+	unsigned int length;		/* input data's length */
+};
+
+struct dovefb_chroma {
+        u_char     mode;
+        u_char     y_alpha;
+        u_char     y;
+        u_char     y1;
+        u_char     y2;
+        u_char     u_alpha;
+        u_char     u;
+        u_char     u1;
+        u_char     u2;
+        u_char     v_alpha;
+        u_char     v;
+        u_char     v1;
+        u_char     v2;
+};
+
+struct _sColorKeyNAlpha {
+        unsigned int mode;
+        unsigned int alphapath;
+        unsigned int config;
+        unsigned int Y_ColorAlpha;
+        unsigned int U_ColorAlpha;
+        unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+	DOVEFBVideoMode videoMode;
+	struct _sViewPortInfo viewPortInfo;
+	struct _sViewPortOffset viewPortOffset;
+	struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct _sCursorConfig {
+	unsigned char	enable;		/* enable cursor or not */
+	unsigned char	mode;		/* 1bit or 2bit mode */
+	unsigned int color1;		/* foreground color */
+	unsigned int color2;		/* background color */
+	unsigned short xoffset;
+	unsigned short yoffset;
+	unsigned short	width;
+	unsigned short height;
+	unsigned char *pBuffer;		/* cursor data */
+};
+
+#define SHM_NORMAL		0x01
+#define SHM_VMETA		0x02
+#define SHM_SOFTWARE_MAP	0x04
+
+struct shm_private_info {
+	unsigned int method;
+	unsigned int fbid;
+	unsigned int format;
+	unsigned int width;
+	unsigned int height;
+	unsigned long fb_pa;
+};
+
+/* MAX bytes per yuv pixel. */
+#define MAX_YUV_PIXEL	2
+
+/* Dumb interface */
+#define DOVEFB_PINS_DUMB_24		0
+#define DOVEFB_PINS_DUMB_18_SPI		1
+#define DOVEFB_PINS_DUMB_18_GPIO	2
+#define DOVEFB_PINS_DUMB_16_SPI		3
+#define DOVEFB_PINS_DUMB_16_GPIO	4
+#define DOVEFB_PINS_DUMB_12_SPI_GPIO	5
+#define DOVEFB_PINS_SMART_18_SPI	6
+#define DOVEFB_PINS_SMART_16_SPI	7
+#define DOVEFB_PINS_SMART_8_SPI_GPIO	8
+
+/* Dumb interface pin allocation */
+#define DOVEFB_DUMB_PANEL_RGB565	0
+#define DOVEFB_DUMB_PANEL_RGB565_UPPER	1
+#define DOVEFB_DUMB_PANEL_RGB666	2
+#define DOVEFB_DUMB_PANEL_RGB666_UPPER	3
+#define DOVEFB_DUMB_PANEL_RGB444	4
+#define DOVEFB_DUMB_PANEL_RGB444_UPPER	5
+#define DOVEFB_DUMB_PANEL_RGB888	6
+
+/* Max fb buffer. 1048x2048-32bits */
+#define DEFAULT_FB_SIZE	(1024 * 2048 * 4)
+
+/*
+ * Buffer pixel format
+ * bit0 is for rb swap.
+ * bit12 is for Y UorV swap
+ */
+#define PIX_FMT_RGB565		0
+#define PIX_FMT_BGR565		1
+#define PIX_FMT_RGB1555		2
+#define PIX_FMT_BGR1555		3
+#define PIX_FMT_RGB888PACK	4
+#define PIX_FMT_BGR888PACK	5
+#define PIX_FMT_RGB888UNPACK	6
+#define PIX_FMT_BGR888UNPACK	7
+#define PIX_FMT_RGBA888		8
+#define PIX_FMT_BGRA888		9
+#define PIX_FMT_YUV422PACK	10
+#define PIX_FMT_YVU422PACK	11
+#define PIX_FMT_YUV422PLANAR	12
+#define PIX_FMT_YVU422PLANAR	13
+#define PIX_FMT_YUV420PLANAR	14
+#define PIX_FMT_YVU420PLANAR	15
+#define PIX_FMT_PSEUDOCOLOR	20
+#define PIX_FMT_UYVY422PACK	(0x1000|PIX_FMT_YUV422PACK)
+
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+
+enum dovefb_type {
+	DOVEFB_GFX_PLANE,
+	DOVEFB_OVLY_PLANE
+};
+
+#define MRVL_AXI_CLK		0
+#define MRVL_EXT_CLK0	1
+#define MRVL_PLL_CLK		2
+#define MRVL_EXT_CLK1	3
+
+struct dovefb_layer_info {
+	struct device		*dev;
+	enum dovefb_type	type;
+	struct dovefb_info	*info;
+	struct fb_info		*fb_info;
+
+	void			*reg_base;
+
+	unsigned long		new_addr;
+	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	atomic_t		w_intr;
+	wait_queue_head_t	w_intr_wq;
+	struct mutex		access_ok;
+	struct _sOvlySurface	surface;
+	struct _sColorKeyNAlpha ckey_alpha;
+
+	unsigned char		*hwc_buf;
+	unsigned int		pseudo_palette[16];
+	struct tasklet_struct	tasklet;
+	char			*mode_option;
+
+	int			ddc_polling_disable;
+	struct timer_list	get_edid_timer;
+	unsigned char*		raw_edid;
+	struct _sEdidInfo	edid_info;
+	struct work_struct      work_queue;
+
+	int			pix_fmt;
+	unsigned		is_blanked:1;
+	unsigned		cursor_enabled:1;
+	unsigned		cursor_cfg:1;
+	unsigned		active:1;
+	unsigned		enabled:1;
+	unsigned                checkbuf_timer_exist:1;
+
+	/*
+	 * 0: DMA mem is from DMA region.
+	 * 1: DMA mem is from normal region.
+	 */
+	unsigned		mem_status:1;
+
+	/*
+	 * current frame id for mapping to user.
+	 */
+	int			cur_fbid;
+	int			src_mode;
+
+	unsigned int		reserved;
+};
+
+/*
+ * Dove LCD controller private state.
+ */
+struct dovefb_info {
+	struct device			*dev;
+	int				id;
+
+	void				*reg_base;
+	struct dovefb_layer_info	*gfx_plane;
+	struct dovefb_layer_info	*vid_plane;
+
+	struct fb_videomode		dft_vmode;
+	struct fb_videomode		out_vmode;
+	int				fixed_output;
+
+	char				*mode_option;
+	struct clk			*clk;
+	int				clk_src;
+	int				io_pin_allocation;
+
+	int			pix_fmt;
+	unsigned		edid:1;
+	unsigned		panel_rbswap:1;
+	unsigned		edid_en:1;
+	unsigned		fixed_full_div:1;
+	unsigned		full_div_val;
+
+        /* Hardware cursor related registers */
+	unsigned int LCD_SPU_HWC_HPXL_VLN_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR1_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR2_saved_value;
+
+	/* Colorkey related registers */
+	unsigned int LCD_SPU_COLORKEY_Y_saved_value;
+	unsigned int LCD_SPU_COLORKEY_U_saved_value;
+	unsigned int LCD_SPU_COLORKEY_V_saved_value;
+	unsigned int LCD_SPU_DMA_CTRL1_saved_value;
+	unsigned int LCD_SPU_ADV_REG_saved_value;
+};
+
+/*
+ * Dove fb machine information
+ */
+struct dovefb_mach_info {
+	char		id_gfx[16];
+	char		id_ovly[16];
+//KW	unsigned int	sclk_clock;
+
+	int		num_modes;
+	struct fb_videomode *modes;
+	struct mbus_dram_target_info *dram;
+ 
+	/* LCD reference clock value.	*/
+	unsigned int	lcd_ref_clk;
+
+	/* KW
+	** FrameBuffer memory.
+	*/
+	void		*fb_mem[2];
+	unsigned int	fb_mem_size[2];
+
+	/*
+	 * Pix_fmt
+	 */
+	unsigned	pix_fmt;
+
+	/*
+	 * I/O pin allocation.
+	 */
+	unsigned	io_pin_allocation:4;
+	/* 
+	 * auto poll EDID data periodically
+	 */
+	unsigned ddc_polling_disable:1;
+	
+	/*
+	 * I2C bus and address to read DDC data through. -1 not available
+	 */
+	int		ddc_i2c_adapter;
+	int		ddc_i2c_address;
+
+
+	/*
+	 * Dumb panel -- assignment of R/G/B component info to the 24
+	 * available external data lanes.
+	 */
+	unsigned	panel_rgb_type:4;
+	unsigned	panel_rgb_reverse_lanes:1;
+
+	/*
+	 * Dumb panel -- GPIO output data.
+	 */
+	unsigned	gpio_output_mask:8;
+	unsigned	gpio_output_data:8;
+
+	/*
+	 * Dumb panel -- configurable output signal polarity.
+	 */
+	unsigned	invert_composite_blank:1;
+	unsigned	invert_pix_val_ena:1;
+	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
+	unsigned	panel_rbswap:1;
+	unsigned	active:1;
+	unsigned	enable_lcd0:1;
+	unsigned	fixed_full_div:1;
+	unsigned	full_div_val;
+
+	struct {
+		unsigned enabled;
+		unsigned lvds_24b_option;
+		unsigned lvds_tick_drv;
+	} lvds_info;
+};
+
+struct dovebl_platform_data;
+
+int clcd_platform_init(struct dovefb_mach_info *lcd0_dmi_data,
+		       struct dovefb_mach_info *lcd0_vid_dmi_data,
+		       struct dovebl_platform_data *backlight_data);
+
+#endif /* _KERNEL_ */
+#endif /* _DOVEFB_H_ */
diff --git a/include/video/dovefbreg.h b/include/video/dovefbreg.h
new file mode 100644
index 0000000..5f10ec1
--- /dev/null
+++ b/include/video/dovefbreg.h
@@ -0,0 +1,695 @@
+/*
+ * linux/include/video/dovefbreg.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _DOVEFB_REG_H_
+#define	_DOVEFB_REG_H_
+
+/* ------------< LCD register >------------ */
+/* Video Frame 0&1 start address registers */
+#define	LCD_SPU_ADV_REG				0x0084
+
+/* Video Frame 0&1 start address registers */
+#define	LCD_SPU_DMA_START_ADDR_Y0		0x00C0
+#define	LCD_SPU_DMA_START_ADDR_U0		0x00C4
+#define	LCD_SPU_DMA_START_ADDR_V0		0x00C8
+#define LCD_CFG_DMA_START_ADDR_0		0x00CC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y1		0x00D0
+#define	LCD_SPU_DMA_START_ADDR_U1		0x00D4
+#define	LCD_SPU_DMA_START_ADDR_V1		0x00D8
+#define LCD_CFG_DMA_START_ADDR_1		0x00DC /* Cmd address */
+
+/* YC & UV Pitch */
+#define LCD_SPU_DMA_PITCH_YC			0x00E0
+#define     SPU_DMA_PITCH_C(c)			(c<<16)
+#define     SPU_DMA_PITCH_Y(y)			(y)
+#define LCD_SPU_DMA_PITCH_UV			0x00E4
+#define     SPU_DMA_PITCH_V(v)			(v<<16)
+#define     SPU_DMA_PITCH_U(u)			(u)
+
+/* Video Starting Point on Screen Register */
+#define LCD_SPUT_DMA_OVSA_HPXL_VLN		0x00E8
+#define     CFG_DMA_OVSA_VLN(y)			(y<<16) /* 0~0xfff */
+#define     CFG_DMA_OVSA_HPXL(x)		(x)     /* 0~0xfff */
+
+/* Video Size Register */
+#define LCD_SPU_DMA_HPXL_VLN			0x00EC
+#define     CFG_DMA_VLN(y)			(y<<16)
+#define     CFG_DMA_HPXL(x)			(x)
+
+/* Video Size After zooming Register */
+#define LCD_SPU_DZM_HPXL_VLN			0x00F0
+#define     CFG_DZM_VLN(y)			(y<<16)
+#define     CFG_DZM_HPXL(x)			(x)
+
+/* Graphic Frame 0&1 Starting Address Register */
+#define LCD_CFG_GRA_START_ADDR0			0x00F4
+#define LCD_CFG_GRA_START_ADDR1			0x00F8
+
+/* Graphic Frame Pitch */
+#define LCD_CFG_GRA_PITCH			0x00FC
+
+/* Graphic Starting Point on Screen Register */
+#define LCD_SPU_GRA_OVSA_HPXL_VLN		0x0100
+#define     CFG_GRA_OVSA_VLN(y)			(y<<16)
+#define     CFG_GRA_OVSA_HPXL(x)		(x)
+
+/* Graphic Size Register */
+#define LCD_SPU_GRA_HPXL_VLN			0x0104
+#define     CFG_GRA_VLN(y)			(y<<16)
+#define     CFG_GRA_HPXL(x)			(x)
+
+/* Graphic Size after Zooming Register */
+#define LCD_SPU_GZM_HPXL_VLN			0x0108
+#define     CFG_GZM_VLN(y)			(y<<16)
+#define     CFG_GZM_HPXL(x)			(x)
+
+/* HW Cursor Starting Point on Screen Register */
+#define LCD_SPU_HWC_OVSA_HPXL_VLN		0x010C
+#define     CFG_HWC_OVSA_VLN(y)			(y<<16)
+#define     CFG_HWC_OVSA_HPXL(x)		(x)
+
+/* HW Cursor Size */
+#define LCD_SPU_HWC_HPXL_VLN			0x0110
+#define     CFG_HWC_VLN(y)			(y<<16)
+#define     CFG_HWC_HPXL(x)			(x)
+
+/* Total Screen Size Register */
+#define LCD_SPUT_V_H_TOTAL			0x0114
+#define     CFG_V_TOTAL(y)			((y)<<16)
+#define     CFG_H_TOTAL(x)			(x)
+
+/* Total Screen Active Size Register */
+#define LCD_SPU_V_H_ACTIVE			0x0118
+#define     CFG_V_ACTIVE(y)			((y)<<16)
+#define     CFG_H_ACTIVE(x)			(x)
+
+/* Screen H&V Porch Register */
+#define LCD_SPU_H_PORCH				0x011C
+#define     CFG_H_BACK_PORCH(b)			(b<<16)
+#define     CFG_H_FRONT_PORCH(f)		(f)
+#define LCD_SPU_V_PORCH				0x0120
+#define     CFG_V_BACK_PORCH(b)			(b<<16)
+#define     CFG_V_FRONT_PORCH(f)		(f)
+
+/* Screen Blank Color Register */
+#define LCD_SPU_BLANKCOLOR			0x0124
+#define     CFG_BLANKCOLOR_MASK			0x00FFFFFF
+#define     CFG_BLANKCOLOR_R_MASK		0x000000FF
+#define     CFG_BLANKCOLOR_G_MASK		0x0000FF00
+#define     CFG_BLANKCOLOR_B_MASK		0x00FF0000
+
+/* HW Cursor Color 1&2 Register */
+#define LCD_SPU_ALPHA_COLOR1			0x0128
+#define     CFG_HWC_COLOR1			0x00FFFFFF
+#define     CFG_HWC_COLOR1_R(red)		(red<<16)
+#define     CFG_HWC_COLOR1_G(green)		(green<<8)
+#define     CFG_HWC_COLOR1_B(blue)		(blue)
+#define     CFG_HWC_COLOR1_R_MASK		0x000000FF
+#define     CFG_HWC_COLOR1_G_MASK		0x0000FF00
+#define     CFG_HWC_COLOR1_B_MASK		0x00FF0000
+#define LCD_SPU_ALPHA_COLOR2			0x012C
+#define     CFG_HWC_COLOR2			0x00FFFFFF
+#define     CFG_HWC_COLOR2_R_MASK		0x000000FF
+#define     CFG_HWC_COLOR2_G_MASK		0x0000FF00
+#define     CFG_HWC_COLOR2_B_MASK		0x00FF0000
+
+/* Video YUV Color Key Control */
+#define LCD_SPU_COLORKEY_Y			0x0130
+#define     CFG_CKEY_Y2(y2)			((y2)<<24)
+#define     CFG_CKEY_Y2_MASK			0xFF000000
+#define     CFG_CKEY_Y1(y1)			((y1)<<16)
+#define     CFG_CKEY_Y1_MASK			0x00FF0000
+#define     CFG_CKEY_Y(y)			((y)<<8)
+#define     CFG_CKEY_Y_MASK			0x0000FF00
+#define     CFG_ALPHA_Y(y)			(y)
+#define     CFG_ALPHA_Y_MASK			0x000000FF
+#define LCD_SPU_COLORKEY_U			0x0134
+#define     CFG_CKEY_U2(u2)			((u2)<<24)
+#define     CFG_CKEY_U2_MASK			0xFF000000
+#define     CFG_CKEY_U1(u1)			((u1)<<16)
+#define     CFG_CKEY_U1_MASK			0x00FF0000
+#define     CFG_CKEY_U(u)			((u)<<8)
+#define     CFG_CKEY_U_MASK			0x0000FF00
+#define     CFG_ALPHA_U(u)			(u)
+#define     CFG_ALPHA_U_MASK			0x000000FF
+#define LCD_SPU_COLORKEY_V			0x0138
+#define     CFG_CKEY_V2(v2)			((v2)<<24)
+#define     CFG_CKEY_V2_MASK			0xFF000000
+#define     CFG_CKEY_V1(v1)			((v1)<<16)
+#define     CFG_CKEY_V1_MASK			0x00FF0000
+#define     CFG_CKEY_V(v)			((v)<<8)
+#define     CFG_CKEY_V_MASK			0x0000FF00
+#define     CFG_ALPHA_V(v)			(v)
+#define     CFG_ALPHA_V_MASK			0x000000FF
+
+/* LCD General Configuration Register */
+#define LCD_CFG_RDREG4F				0x013C
+
+/* SPI Read Data Register */
+#define LCD_SPU_SPI_RXDATA			0x0140
+
+/* Smart Panel Read Data Register */
+#define LCD_SPU_ISA_RSDATA			0x0144
+#define     ISA_RXDATA_16BIT_1_DATA_MASK	0x000000FF
+#define     ISA_RXDATA_16BIT_2_DATA_MASK	0x0000FF00
+#define     ISA_RXDATA_16BIT_3_DATA_MASK	0x00FF0000
+#define     ISA_RXDATA_16BIT_4_DATA_MASK	0xFF000000
+#define     ISA_RXDATA_32BIT_1_DATA_MASK	0x00FFFFFF
+
+/* HWC SRAM Read Data Register */
+#define LCD_SPU_HWC_RDDAT			0x0158
+
+/* Gamma Table SRAM Read Data Register */
+#define LCD_SPU_GAMMA_RDDAT			0x015c
+#define     CFG_GAMMA_RDDAT_MASK		0x000000FF
+
+/* Palette Table SRAM Read Data Register */
+#define LCD_SPU_PALETTE_RDDAT			0x0160
+#define     CFG_PALETTE_RDDAT_MASK		0x00FFFFFF
+
+/* I/O Pads Input Read Only Register */
+#define LCD_SPU_IOPAD_IN			0x0178
+#define     CFG_IOPAD_IN_MASK			0x0FFFFFFF
+
+/* Reserved Read Only Registers */
+#define LCD_CFG_RDREG5F				0x017C
+#define     IRE_FRAME_CNT_MASK			0x000000C0
+#define     IPE_FRAME_CNT_MASK			0x00000030
+#define     GRA_FRAME_CNT_MASK			0x0000000C  /* Graphic */
+#define     DMA_FRAME_CNT_MASK			0x00000003  /* Video */
+
+/* SPI Control Register. */
+#define LCD_SPU_SPI_CTRL			0x0180
+#define     CFG_SCLKCNT(div)			(div<<24)  /* 0xFF~0x2 */
+#define     CFG_SCLKCNT_MASK			0xFF000000
+#define     CFG_RXBITS(rx)			(rx<<16)   /* 0x1F~0x1 */
+#define     CFG_RXBITS_MASK			0x00FF0000
+#define     CFG_TXBITS(tx)			(tx<<8)    /* 0x1F~0x1 */
+#define     CFG_TXBITS_MASK			0x0000FF00
+#define     CFG_CLKINV(clk)			(clk<<7)
+#define     CFG_CLKINV_MASK			0x00000080
+#define     CFG_KEEPXFER(transfer)		(transfer<<6)
+#define     CFG_KEEPXFER_MASK			0x00000040
+#define     CFG_RXBITSTO0(rx)			(rx<<5)
+#define     CFG_RXBITSTO0_MASK			0x00000020
+#define     CFG_TXBITSTO0(tx)			(tx<<4)
+#define     CFG_TXBITSTO0_MASK			0x00000010
+#define     CFG_SPI_ENA(spi)			(spi<<3)
+#define     CFG_SPI_ENA_MASK			0x00000008
+#define     CFG_SPI_SEL(spi)			(spi<<2)
+#define     CFG_SPI_SEL_MASK			0x00000004
+#define     CFG_SPI_3W4WB(wire)			(wire<<1)
+#define     CFG_SPI_3W4WB_MASK			0x00000002
+#define     CFG_SPI_START(start)		(start)
+#define     CFG_SPI_START_MASK			0x00000001
+
+/* SPI Tx Data Register */
+#define LCD_SPU_SPI_TXDATA			0x0184
+
+/*
+   1. Smart Pannel 8-bit Bus Control Register.
+   2. AHB Slave Path Data Port Register
+*/
+#define LCD_SPU_SMPN_CTRL			0x0188
+
+/* DMA Control 0 Register */
+#define LCD_SPU_DMA_CTRL0			0x0190
+#define     CFG_NOBLENDING(nb)			(nb<<31)
+#define     CFG_NOBLENDING_MASK			0x80000000
+#define     CFG_GAMMA_ENA(gn)			(gn<<30)
+#define     CFG_GAMMA_ENA_MASK			0x40000000
+#define     CFG_CBSH_ENA(cn)			(cn<<29)
+#define     CFG_CBSH_ENA_MASK			0x20000000
+#define     CFG_PALETTE_ENA(pn)			(pn<<28)
+#define     CFG_PALETTE_ENA_MASK		0x10000000
+#define     CFG_ARBFAST_ENA(an)			(an<<27)
+#define     CFG_ARBFAST_ENA_MASK		0x08000000
+#define     CFG_HWC_1BITMOD(mode)		(mode<<26)
+#define     CFG_HWC_1BITMOD_MASK		0x04000000
+#define     CFG_HWC_1BITENA(mn)			(mn<<25)
+#define     CFG_HWC_1BITENA_MASK		0x02000000
+#define     CFG_HWC_ENA(cn)		        (cn<<24)
+#define     CFG_HWC_ENA_MASK			0x01000000
+#define     CFG_DMAFORMAT(dmaformat)		(dmaformat<<20)
+#define     CFG_DMAFORMAT_MASK			0x00F00000
+#define     CFG_GRAFORMAT(graformat)		(graformat<<16)
+#define     CFG_GRAFORMAT_MASK			0x000F0000
+/* for graphic part */
+#define     CFG_GRA_FTOGGLE(toggle)		(toggle<<15)
+#define     CFG_GRA_FTOGGLE_MASK		0x00008000
+#define     CFG_GRA_HSMOOTH(smooth)		(smooth<<14)
+#define     CFG_GRA_HSMOOTH_MASK		0x00004000
+#define     CFG_GRA_TSTMODE(test)		(test<<13)
+#define     CFG_GRA_TSTMODE_MASK		0x00002000
+#define     CFG_GRA_SWAPRB(swap)		(swap<<12)
+#define     CFG_GRA_SWAPRB_MASK			0x00001000
+#define     CFG_GRA_SWAPUV(swap)		(swap<<11)
+#define     CFG_GRA_SWAPUV_MASK			0x00000800
+#define     CFG_GRA_SWAPYU(swap)		(swap<<10)
+#define     CFG_GRA_SWAPYU_MASK			0x00000400
+#define     CFG_YUV2RGB_GRA(cvrt)		(cvrt<<9)
+#define     CFG_YUV2RGB_GRA_MASK		0x00000200
+#define     CFG_GRA_ENA(gra)			(gra<<8)
+#define     CFG_GRA_ENA_MASK			0x00000100
+/* for video part */
+#define     CFG_DMA_FTOGGLE(toggle)		(toggle<<7)
+#define     CFG_DMA_FTOGGLE_MASK		0x00000080
+#define     CFG_DMA_HSMOOTH(smooth)		(smooth<<6)
+#define     CFG_DMA_HSMOOTH_MASK		0x00000040
+#define     CFG_DMA_TSTMODE(test)		(test<<5)
+#define     CFG_DMA_TSTMODE_MASK		0x00000020
+#define     CFG_DMA_SWAPRB(swap)		(swap<<4)
+#define     CFG_DMA_SWAPRB_MASK			0x00000010
+#define     CFG_DMA_SWAPUV(swap)		(swap<<3)
+#define     CFG_DMA_SWAPUV_MASK			0x00000008
+#define     CFG_DMA_SWAPYU(swap)		(swap<<2)
+#define     CFG_DMA_SWAPYU_MASK			0x00000004
+#define     CFG_DMA_SWAP_MASK			0x0000001C
+#define     CFG_YUV2RGB_DMA(cvrt)		(cvrt<<1)
+#define     CFG_YUV2RGB_DMA_MASK		0x00000002
+#define     CFG_DMA_ENA(video)			(video)
+#define     CFG_DMA_ENA_MASK			0x00000001
+
+/* DMA Control 1 Register */
+#define LCD_SPU_DMA_CTRL1			0x0194
+#define     CFG_FRAME_TRIG(trig)		(trig<<31)
+#define     CFG_FRAME_TRIG_MASK			0x80000000
+#define     CFG_VSYNC_TRIG(trig)		(trig<<28)
+#define     CFG_VSYNC_TRIG_MASK			0x70000000
+#define     CFG_VSYNC_INV(inv)			(inv<<27)
+#define     CFG_VSYNC_INV_MASK			0x08000000
+#define     CFG_COLOR_KEY_MODE(cmode)		(cmode<<24)
+#define     CFG_COLOR_KEY_MASK			0x07000000
+#define     CFG_CARRY(carry)			(carry<<23)
+#define     CFG_CARRY_MASK			0x00800000
+#define     CFG_LNBUF_ENA(lnbuf)		(lnbuf<<22)
+#define     CFG_LNBUF_ENA_MASK			0x00400000
+#define     CFG_GATED_ENA(gated)		(gated<<21)
+#define     CFG_GATED_ENA_MASK			0x00200000
+#define     CFG_PWRDN_ENA(power)		(power<<20)
+#define     CFG_PWRDN_ENA_MASK			0x00100000
+#define     CFG_DSCALE(dscale)			(dscale<<18)
+#define     CFG_DSCALE_MASK			0x000C0000
+#define     CFG_ALPHA_MODE(amode)		(amode<<16)
+#define     CFG_ALPHA_MODE_MASK			0x00030000
+#define     CFG_ALPHA(alpha)			(alpha<<8)
+#define     CFG_ALPHA_MASK			0x0000FF00
+#define     CFG_PXLCMD(pxlcmd)			(pxlcmd)
+#define     CFG_PXLCMD_MASK			0x000000FF
+
+/* SRAM Control Register */
+#define LCD_SPU_SRAM_CTRL			0x0198
+#define     CFG_SRAM_INIT_WR_RD(mode)		(mode<<14)
+#define     CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
+#define     CFG_SRAM_ADDR_LCDID(id)		(id<<8)
+#define     CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
+#define     CFG_SRAM_ADDR(addr)			(addr)
+#define     CFG_SRAM_ADDR_MASK			0x000000FF
+
+/* SRAM Write Data Register */
+#define LCD_SPU_SRAM_WRDAT			0x019C
+
+/* SRAM RTC/WTC Control Register */
+#define LCD_SPU_SRAM_PARA0			0x01A0
+
+/* SRAM Power Down Control Register */
+#define LCD_SPU_SRAM_PARA1			0x01A4
+#define     CFG_CSB_256x32(hwc)			(hwc<<15)	/* HWC */
+#define     CFG_CSB_256x32_MASK			0x00008000
+#define     CFG_CSB_256x24(palette)		(palette<<14)	/* Palette */
+#define     CFG_CSB_256x24_MASK			0x00004000
+#define     CFG_CSB_256x8(gamma)		(gamma<<13)	/* Gamma */
+#define     CFG_CSB_256x8_MASK			0x00002000
+#define     CFG_PDWN256x32(pdwn)		(pdwn<<7)	/* HWC */
+#define     CFG_PDWN256x32_MASK			0x00000080
+#define     CFG_PDWN256x24(pdwn)		(pdwn<<6)	/* Palette */
+#define     CFG_PDWN256x24_MASK			0x00000040
+#define     CFG_PDWN256x8(pdwn)			(pdwn<<5)	/* Gamma */
+#define     CFG_PDWN256x8_MASK			0x00000020
+#define     CFG_PDWN32x32(pdwn)			(pdwn<<3)
+#define     CFG_PDWN32x32_MASK			0x00000008
+#define     CFG_PDWN16x66(pdwn)			(pdwn<<2)
+#define     CFG_PDWN16x66_MASK			0x00000004
+#define     CFG_PDWN32x66(pdwn)			(pdwn<<1)
+#define     CFG_PDWN32x66_MASK			0x00000002
+#define     CFG_PDWN64x66(pdwn)			(pdwn)
+#define     CFG_PDWN64x66_MASK			0x00000001
+
+/* Smart or Dumb Panel Clock Divider */
+#define LCD_CFG_SCLK_DIV			0x01A8
+#define     SCLK_SOURCE_SELECT(src)		(src<<31)
+#define     SCLK_SOURCE_SELECT_MASK		0x80000000
+#define     CLK_FRACDIV(frac)			(frac<<16)
+#define     CLK_FRACDIV_MASK			0x0FFF0000
+#define     CLK_INT_DIV(div)			(div)
+#define     CLK_INT_DIV_MASK			0x0000FFFF
+
+/* Video Contrast Register */
+#define LCD_SPU_CONTRAST			0x01AC
+#define     CFG_BRIGHTNESS(bright)		(bright<<16)
+#define     CFG_BRIGHTNESS_MASK			0xFFFF0000
+#define     CFG_CONTRAST(contrast)		(contrast)
+#define     CFG_CONTRAST_MASK			0x0000FFFF
+
+/* Video Saturation Register */
+#define LCD_SPU_SATURATION			0x01B0
+#define     CFG_C_MULTS(mult)			(mult<<16)
+#define     CFG_C_MULTS_MASK			0xFFFF0000
+#define     CFG_SATURATION(sat)			(sat)
+#define     CFG_SATURATION_MASK			0x0000FFFF
+
+/* Video Hue Adjust Register */
+#define LCD_SPU_CBSH_HUE			0x01B4
+#define     CFG_SIN0(sin0)			(sin0<<16)
+#define     CFG_SIN0_MASK			0xFFFF0000
+#define     CFG_COS0(con0)			(con0)
+#define     CFG_COS0_MASK			0x0000FFFF
+
+/* Dump LCD Panel Control Register */
+#define LCD_SPU_DUMB_CTRL			0x01B8
+#define     CFG_DUMBMODE(mode)			(mode<<28)
+#define     CFG_DUMBMODE_MASK			0xF0000000
+#define     CFG_LCDGPIO_O(data)			(data<<20)
+#define     CFG_LCDGPIO_O_MASK			0x0FF00000
+#define     CFG_LCDGPIO_ENA(gpio)		(gpio<<12)
+#define     CFG_LCDGPIO_ENA_MASK		0x000FF000
+#define     CFG_BIAS_OUT(bias)			(bias<<8)
+#define     CFG_BIAS_OUT_MASK			0x00000100
+#define     CFG_REVERSE_RGB(rRGB)		(rRGB<<7)
+#define     CFG_REVERSE_RGB_MASK		0x00000080
+#define     CFG_INV_COMPBLANK(blank)		(blank<<6)
+#define     CFG_INV_COMPBLANK_MASK		0x00000040
+#define     CFG_INV_COMPSYNC(sync)		(sync<<5)
+#define     CFG_INV_COMPSYNC_MASK		0x00000020
+#define     CFG_INV_HENA(hena)			(hena<<4)
+#define     CFG_INV_HENA_MASK			0x00000010
+#define     CFG_INV_VSYNC(vsync)		(vsync<<3)
+#define     CFG_INV_VSYNC_MASK			0x00000008
+#define     CFG_INV_HSYNC(hsync)		(hsync<<2)
+#define     CFG_INV_HSYNC_MASK			0x00000004
+#define     CFG_INV_PCLK(pclk)			(pclk<<1)
+#define     CFG_INV_PCLK_MASK			0x00000002
+#define     CFG_DUMB_ENA(dumb)			(dumb)
+#define     CFG_DUMB_ENA_MASK			0x00000001
+
+/* LCD I/O Pads Control Register */
+#define SPU_IOPAD_CONTROL			0x01BC
+#define     CFG_GRA_VM_ENA(vm)			(vm<<15)        /* gfx */
+#define     CFG_GRA_VM_ENA_MASK			0x00008000
+#define     CFG_DMA_VM_ENA(vm)			(vm<<13)	/* video */
+#define     CFG_DMA_VM_ENA_MASK			0x00002000
+#define     CFG_CMD_VM_ENA(vm)			(vm<<13)
+#define     CFG_CMD_VM_ENA_MASK			0x00000800
+#define     CFG_CSC(csc)			(csc<<8)	/* csc */
+#define     CFG_CSC_MASK			0x00000300
+#define     CFG_AXICTRL(axi)			(axi<<4)
+#define     CFG_AXICTRL_MASK			0x000000F0
+#define     CFG_IOPADMODE(iopad)		(iopad)
+#define     CFG_IOPADMODE_MASK			0x0000000F
+
+/* LCD Interrupt Control Register */
+#define SPU_IRQ_ENA				0x01C0
+#define     DMA_FRAME_IRQ0_ENA(irq)		(irq<<31)
+#define     DMA_FRAME_IRQ0_ENA_MASK		0x80000000
+#define     DMA_FRAME_IRQ1_ENA(irq)		(irq<<30)
+#define     DMA_FRAME_IRQ1_ENA_MASK		0x40000000
+#define     DMA_FF_UNDERFLOW_ENA(ff)		(ff<<29)
+#define     DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
+#define     GRA_FRAME_IRQ0_ENA(irq)		(irq<<27)
+#define     GRA_FRAME_IRQ0_ENA_MASK		0x08000000
+#define     GRA_FRAME_IRQ1_ENA(irq)		(irq<<26)
+#define     GRA_FRAME_IRQ1_ENA_MASK		0x04000000
+#define     GRA_FF_UNDERFLOW_ENA(ff)		(ff<<25)
+#define     GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
+#define     VSYNC_IRQ_ENA(vsync_irq)		(vsync_irq<<23)
+#define     VSYNC_IRQ_ENA_MASK			0x00800000
+#define     DUMB_FRAMEDONE_ENA(fdone)		(fdone<<22)
+#define     DUMB_FRAMEDONE_ENA_MASK		0x00400000
+#define     TWC_FRAMEDONE_ENA(fdone)		(fdone<<21)
+#define     TWC_FRAMEDONE_ENA_MASK		0x00200000
+#define     HWC_FRAMEDONE_ENA(fdone)		(fdone<<20)
+#define     HWC_FRAMEDONE_ENA_MASK		0x00100000
+#define     SLV_IRQ_ENA(irq)			(irq<<19)
+#define     SLV_IRQ_ENA_MASK			0x00080000
+#define     SPI_IRQ_ENA(irq)			(irq<<18)
+#define     SPI_IRQ_ENA_MASK			0x00040000
+#define     PWRDN_IRQ_ENA(irq)			(irq<<17)
+#define     PWRDN_IRQ_ENA_MASK			0x00020000
+#define     ERR_IRQ_ENA(irq)			(irq<<16)
+#define     ERR_IRQ_ENA_MASK			0x00010000
+#define     CLEAN_SPU_IRQ_ISR(irq)		(irq)
+#define     CLEAN_SPU_IRQ_ISR_MASK		0x0000FFFF
+
+/* LCD Interrupt Status Register */
+#define SPU_IRQ_ISR				0x01C4
+#define     DMA_FRAME_IRQ0(irq)			(irq<<31)
+#define     DMA_FRAME_IRQ0_MASK			0x80000000
+#define     DMA_FRAME_IRQ1(irq)			(irq<<30)
+#define     DMA_FRAME_IRQ1_MASK			0x40000000
+#define     DMA_FF_UNDERFLOW(ff)		(ff<<29)
+#define     DMA_FF_UNDERFLOW_MASK		0x20000000
+#define     GRA_FRAME_IRQ0(irq)			(irq<<27)
+#define     GRA_FRAME_IRQ0_MASK			0x08000000
+#define     GRA_FRAME_IRQ1(irq)			(irq<<26)
+#define     GRA_FRAME_IRQ1_MASK			0x04000000
+#define     GRA_FF_UNDERFLOW(ff)		(ff<<25)
+#define     GRA_FF_UNDERFLOW_MASK		0x02000000
+#define     VSYNC_IRQ(vsync_irq)		(vsync_irq<<23)
+#define     VSYNC_IRQ_MASK			0x00800000
+#define     DUMB_FRAMEDONE(fdone)		(fdone<<22)
+#define     DUMB_FRAMEDONE_MASK			0x00400000
+#define     TWC_FRAMEDONE(fdone)		(fdone<<21)
+#define     TWC_FRAMEDONE_MASK			0x00200000
+#define     HWC_FRAMEDONE(fdone)		(fdone<<20)
+#define     HWC_FRAMEDONE_MASK			0x00100000
+#define     SLV_IRQ(irq)			(irq<<19)
+#define     SLV_IRQ_MASK			0x00080000
+#if 0 //KW-LCD
+#define     SPI_IRQ(irq)			(irq<<18)
+#define     SPI_IRQ_MASK			0x00040000
+#endif
+
+#define     PWRDN_IRQ(irq)			(irq<<17)
+#define     PWRDN_IRQ_MASK			0x00020000
+#define     ERR_IRQ(irq)			(irq<<16)
+#define     ERR_IRQ_MASK			0x00010000
+/* read-only */
+#define     DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
+#define     DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
+#define     DMA_FRAME_CNT_ISR_MASK		0x00003000
+#define     GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
+#define     GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
+#define     GRA_FRAME_CNT_ISR_MASK		0x00000300
+#define     VSYNC_IRQ_LEVEL_MASK		0x00000080
+#define     DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
+#define     TWC_FRAMEDONE_LEVEL_MASK		0x00000020
+#define     HWC_FRAMEDONE_LEVEL_MASK		0x00000010
+#define     SLV_FF_EMPTY_MASK			0x00000008
+#define     DMA_FF_ALLEMPTY_MASK		0x00000004
+#define     GRA_FF_ALLEMPTY_MASK		0x00000002
+#define     PWRDN_IRQ_LEVEL_MASK		0x00000001
+
+/*
+ * interrupt definition.
+ */
+#define DOVEFB_VSYNC_INT_MASK	(VSYNC_IRQ_ENA_MASK)
+#define DOVEFB_VID_INT_MASK	(DMA_FRAME_IRQ0_ENA_MASK |\
+				DMA_FRAME_IRQ1_ENA_MASK)
+#define DOVEFB_GFX_INT_MASK	(GRA_FRAME_IRQ0_ENA_MASK |\
+				GRA_FRAME_IRQ1_ENA_MASK)
+
+/*
+ * defined Video Memory Color format for DMA control 0 register
+ * DMA0 bit[23:20]
+ */
+#define VMODE_RGB565                    0x0
+#define VMODE_RGB1555                   0x1
+#define VMODE_RGB888PACKED              0x2
+#define VMODE_RGB888UNPACKED            0x3
+#define VMODE_RGBA888                   0x4
+#define VMODE_YUV422PACKED              0x5
+#define VMODE_YUV422PLANAR              0x6
+#define VMODE_YUV420PLANAR              0x7
+#define VMODE_SMPNCMD                   0x8
+#define VMODE_PALETTE4BIT               0x9
+#define VMODE_PALETTE8BIT               0xa
+#define VMODE_RESERVED                  0xb
+
+/*
+ * defined Graphic Memory Color format for DMA control 0 register
+ * DMA0 bit[19:16]
+ */
+#define GMODE_RGB565                    0x0
+#define GMODE_RGB1555                   0x1
+#define GMODE_RGB888PACKED              0x2
+#define GMODE_RGB888UNPACKED            0x3
+#define GMODE_RGBA888                   0x4
+#define GMODE_YUV422PACKED              0x5
+#define GMODE_YUV422PLANAR              0x6
+#define GMODE_YUV420PLANAR              0x7
+#define GMODE_SMPNCMD                   0x8
+#define GMODE_PALETTE4BIT               0x9
+#define GMODE_PALETTE8BIT               0xa
+#define GMODE_RESERVED                  0xb
+
+/*
+ * define for DMA control 1 register
+ */
+#define DMA1_FRAME_TRIG             31      /* bit location */
+#define DMA1_VSYNC_MODE             28
+#define DMA1_VSYNC_INV              27
+#define DMA1_CKEY                   24
+#define DMA1_CARRY                  23
+#define DMA1_LNBUF_ENA              22
+#define DMA1_GATED_ENA              21
+#define DMA1_PWRDN_ENA              20
+#define DMA1_DSCALE                 18
+#define DMA1_ALPHA_MODE             16
+#define DMA1_ALPHA                  08
+#define DMA1_PXLCMD                 00
+
+/*
+ * defined for Configure Dumb Mode
+ * DUMB LCD Panel bit[31:28]
+ */
+#define DUMB16_RGB565_0             0x0
+#define DUMB16_RGB565_1             0x1
+#define DUMB18_RGB666_0             0x2
+#define DUMB18_RGB666_1             0x3
+#define DUMB12_RGB444_0             0x4
+#define DUMB12_RGB444_1             0x5
+#define DUMB24_RGB888_0             0x6
+#define DUMB_BLANK                  0x7
+
+/*
+ * defined for Configure I/O Pin Allocation Mode
+ * LCD LCD I/O Pads control register bit[3:0]
+ */
+#define IOPAD_DUMB24                0x0
+#define IOPAD_DUMB18SPI             0x1
+#define IOPAD_DUMB18GPIO            0x2
+#define IOPAD_DUMB16SPI             0x3
+#define IOPAD_DUMB16GPIO            0x4
+#define IOPAD_DUMB12                0x5
+#define IOPAD_SMART18SPI            0x6
+#define IOPAD_SMART16SPI            0x7
+#define IOPAD_SMART8BOTH            0x8
+
+/*
+ * defined Dumb Panel Clock Divider register
+ * SCLK_Source bit[31]
+ */
+#define AXI_BUS_SEL                 0x80000000 /* 0: PLL clock select*/
+#define CCD_CLK_SEL                 0x40000000
+#define DCON_CLK_SEL                0x20000000
+#define ENA_CLK_INT_DIV             CONFIG_FB_DOVE_CLCD_SCLK_DIV
+#define IDLE_CLK_INT_DIV            0x1      /* idle Integer Divider */
+#define DIS_CLK_INT_DIV             0x0      /* Disable Integer Divider */
+
+/* SRAM ID */
+#define SRAMID_gamma_yr             0x0
+#define SRAMID_gamma_ug             0x1
+#define SRAMID_gamma_vb             0x2
+#define SRAMID_palette              0x3
+#define SRAMID_hwc                  0xf
+
+/* SRAM INIT Read/Write */
+#define SRAMID_INIT_READ			0x0
+#define SRAMID_INIT_WRITE			0x2
+#define SRAMID_INIT_DEFAULT			0x3
+
+/*
+ * defined VSYNC selection mode for DMA control 1 register
+ * DMA1 bit[30:28]
+ */
+#define VMODE_SMPN                  0x0
+#define VMODE_SMPNIRQ               0x1
+#define VMODE_DUMB                  0x2
+#define VMODE_IPE                   0x3
+#define VMODE_IRE                   0x4
+
+/*
+ * defined Configure Alpha and Alpha mode for DMA control 1 register
+ * DMA1 bit[15:08](alpha) / bit[17:16](alpha mode)
+ */
+/* ALPHA mode */
+#define MODE_ALPHA_DMA              0x0
+#define MODE_ALPHA_GRA              0x1
+#define MODE_ALPHA_CFG              0x2
+
+/* alpha value */
+#define ALPHA_NOGRAPHIC		0xFF      /* all video, no graphic */
+#define ALPHA_NOVIDEO		0x00      /* all graphic, no video */
+#define ALPHA_GRAPHnVIDEO	0x0F      /* Selects graphic & video */
+
+/*
+ * defined Pixel Command for DMA control 1 register
+ * DMA1 bit[07:00]
+ */
+#define PIXEL_CMD                  0x81
+
+
+/* KW / DSMP specific registers. */
+#define LCD_CLK_CFG0_REG		0xF0A0
+#define LCD_PLL_LPF_MASK		(0xF << 0)
+#define LCD_PLL_LPF(x)			(x << 0)
+#define LCD_PLL_NDIV_MASK		(0x1FF << 4)
+#define LCD_PLL_NDIV(x)			((x) << 4)
+#define LCD_PLL_VCO_BAND_MASK		(0xF << 13)
+#define LCD_PLL_VCO_BAND(x)		(x << 13)
+#define LCD_PLL_MDIV_MASK		(0x1FF << 17)
+#define LCD_PLL_MDIV(x)			((x) << 17)
+#define LCD_PLL_KDIV_MASK		(0x3 << 26)
+#define LCD_PLL_KDIV(x)			((x) << 26)
+#define LCD_PLL_PWR_DOWN_MASK		(1 << 31)
+#define LCD_PLL_PWR_DOWN(en)		((en) << 31)
+
+
+#define LCD_CLK_CFG1_REG		0xF0A4
+#ifdef CONFIG_ARCH_ARMADA_XP
+#define LCD_FULL_DIV_MASK		(0x1FFF)
+#define LCD_FULL_DIV(x)			(x)
+#define LCD_HALF_DIV_MASK		(1 << 15)
+#define LCD_HALF_DIV(x)			(x << 15)
+#else
+#define LCD_FULL_DIV_MASK		(0x7F)
+#define LCD_FULL_DIV(x)			(x)
+#define LCD_HALF_DIV_MASK		(1 << 8)
+#define LCD_HALF_DIV(x)			(x << 8)
+#endif /* CONFIG_ARCH_ARMADA_XP */
+#define LCD_REF_CLK_MASK		(1 << 16)
+#define LCD_REF_CLK(x)			(x << 16)
+#define LCD_SMPN_EN_MASK		(1 << 17)
+#define LCD_SMPN_EN(x)			(x << 17)
+
+#define LCD_WIN_NUM			6
+#define LCD_WIN_CTRL(n)			(0xF000 + (n * 0x10))
+#define LCD_WIN_BASE(n)			(0xF004 + (n * 0x10))
+
+/* LVDS related registers. */
+#define LCD_LVDS_CLK_CFG		0xF0AC
+#define LCD_LVDS_CFG_SER_MASK		(1 << 30)
+#define LCD_LVDS_CFG_SER_EN(x)		(x << 30)
+#define LCD_LVDS_CFG_TICK_DRV_MASK	(0x7 << 8)
+#define LCD_LVDS_CFG_TICK_DRV(x)	(x << 8)
+#define LCD_LVDS_CFG_24BIT_MODE_MASK	(1 << 1)
+#define LCD_LVDS_CFG_24BIT_OPT1		(0 << 1)
+#define LCD_LVDS_CFG_24BIT_OPT2		(1 << 1)
+#define LCD_LVDS_CFG_PIN_CNT_MASK	(1 << 0)
+#define LCD_LVDS_CFG_PIN_CNT_18		(0 << 0)
+#define LCD_LVDS_CFG_PIN_CNT_24		(1 << 0)
+
+
+#endif
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 902ddc7..080d96d 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -462,10 +462,12 @@ static inline void skb_release_head_state(struct sk_buff *skb)
 		skb->destructor(skb);
 	}
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
-	nf_conntrack_put(skb->nfct);
+	if(skb->nfct)
+		nf_conntrack_put(skb->nfct);
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	nf_conntrack_put_reasm(skb->nfct_reasm);
+	if(skb->nfct_reasm)
+		nf_conntrack_put_reasm(skb->nfct_reasm);
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	nf_bridge_put(skb->nf_bridge);
-- 
1.7.5.4

