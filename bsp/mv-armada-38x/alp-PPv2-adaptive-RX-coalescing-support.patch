From 4a1082f50daef6638e940e088559e3646e65e2a1 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Tue, 16 Jul 2013 14:36:08 +0300
Subject: [PATCH 0830/1825] alp: PPv2: adaptive RX coalescing support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5675cc7b412abb1b97d1bf5be91222f720f182e9

	Support adaptive RX coalescing via ethtool

Change-Id: Ic60b2a09661874d03dbe0c4d1f72679a7527f0f2
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2673
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |   61 ++++++++++++++++---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   43 ++++++++++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   12 ++++
 3 files changed, 106 insertions(+), 10 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index 7860893..74b69cb 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -437,9 +437,20 @@ int mv_eth_tool_get_coalesce(struct net_device *netdev,
 	struct eth_port *pp = MV_ETH_PRIV(netdev);
 	/* get coal parameters only for rxq=0, txp=txq=0 !!!
 	   notice that if you use ethtool to set coal, then all queues have the same value */
-	cmd->rx_coalesce_usecs = mvPp2RxqTimeCoalGet(pp->port, 0);
-	cmd->rx_max_coalesced_frames = mvPp2RxqPktsCoalGet(pp->port, 0);
-	cmd->tx_max_coalesced_frames = mvPp2TxDonePktsCoalGet(pp->port, 0, 0);
+	cmd->rx_coalesce_usecs = pp->rx_time_coal_cfg;
+	cmd->rx_max_coalesced_frames = pp->rx_pkts_coal_cfg;
+#ifdef CONFIG_MV_ETH_TXDONE_ISR
+	cmd->tx_max_coalesced_frames = pp->tx_pkts_coal_cfg;
+#endif
+
+	/* Adaptive RX coalescing parameters */
+	cmd->rx_coalesce_usecs_low = pp->rx_time_low_coal_cfg;
+	cmd->rx_coalesce_usecs_high = pp->rx_time_high_coal_cfg;
+	cmd->pkt_rate_low = pp->pkt_rate_low_cfg;
+	cmd->pkt_rate_high = pp->pkt_rate_high_cfg;
+	cmd->rate_sample_interval = pp->rate_sample_cfg;
+	cmd->use_adaptive_rx_coalesce = pp->rx_adaptive_coal_cfg;
+
 	return 0;
 }
 
@@ -460,19 +471,49 @@ int mv_eth_tool_set_coalesce(struct net_device *netdev,
 			     struct ethtool_coalesce *cmd)
 {
 	struct eth_port *pp = MV_ETH_PRIV(netdev);
-	int rxq, txp, txq;
+	int rxq;
 
 	/* can't set rx coalesce with both 0 pkts and 0 usecs,  tx coalesce supports only pkts */
-	if ((!cmd->rx_coalesce_usecs && !cmd->rx_max_coalesced_frames) || (!cmd->tx_max_coalesced_frames))
+	if (!cmd->rx_coalesce_usecs && !cmd->rx_max_coalesced_frames)
+		return -EPERM;
+#ifdef CONFIG_MV_ETH_TXDONE_ISR
+	if (!cmd->tx_max_coalesced_frames)
 		return -EPERM;
+#endif
 
 	for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++) {
-		mvPp2RxqPktsCoalSet(pp->port, rxq, cmd->rx_max_coalesced_frames);
-		mvPp2RxqTimeCoalSet(pp->port, rxq, cmd->rx_coalesce_usecs);
+		mv_eth_rx_ptks_coal_set(pp->port, rxq, cmd->rx_max_coalesced_frames);
+		mv_eth_rx_time_coal_set(pp->port, rxq, cmd->rx_coalesce_usecs);
+	}
+
+	pp->rx_time_coal_cfg = cmd->rx_coalesce_usecs;
+	pp->rx_pkts_coal_cfg = cmd->rx_max_coalesced_frames;
+#ifdef CONFIG_MV_ETH_TXDONE_ISR
+	{
+		int txp, txq;
+
+		for (txp = 0; txp < pp->txp_num; txp++)
+			for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+				mv_eth_tx_done_ptks_coal_set(pp->port, txp, txq, cmd->tx_max_coalesced_frames);
+	}
+#endif
+	pp->tx_pkts_coal_cfg = cmd->tx_max_coalesced_frames;
+
+	/* Adaptive RX coalescing parameters */
+	pp->rx_time_low_coal_cfg = cmd->rx_coalesce_usecs_low;
+	pp->rx_time_high_coal_cfg = cmd->rx_coalesce_usecs_high;
+	pp->pkt_rate_low_cfg = cmd->pkt_rate_low;
+	pp->pkt_rate_high_cfg = cmd->pkt_rate_high;
+
+	if (cmd->rate_sample_interval > 0)
+		pp->rate_sample_cfg = cmd->rate_sample_interval;
+
+	/* check if adaptive rx is on - reset rate calculation parameters */
+	if (!pp->rx_adaptive_coal_cfg && cmd->use_adaptive_rx_coalesce) {
+		pp->rx_timestamp = jiffies;
+		pp->rx_rate_pkts = 0;
 	}
-	for (txp = 0; txp < pp->txp_num; txp++)
-		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
-			mvPp2TxDonePktsCoalSet(pp->port, txp, txq, cmd->tx_max_coalesced_frames);
+	pp->rx_adaptive_coal_cfg = cmd->use_adaptive_rx_coalesce;
 
 	return 0;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 11ce592..5a60687 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -204,6 +204,32 @@ void mv_eth_ctrl_pnc(int en)
 }
 
 /*****************************************
+ *          Adaptive coalescing          *
+ *****************************************/
+static void mv_eth_adaptive_rx_update(struct eth_port *pp)
+{
+	unsigned long period = jiffies - pp->rx_timestamp;
+
+	if (period >= (pp->rate_sample_cfg * HZ)) {
+		int i;
+		unsigned long rate = pp->rx_rate_pkts * HZ / period;
+
+		if (rate < pp->pkt_rate_low_cfg)
+			for (i = 0; i < CONFIG_MV_ETH_RXQ; i++)
+				mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_low_coal_cfg);
+		else if (rate > pp->pkt_rate_high_cfg)
+			for (i = 0; i < CONFIG_MV_ETH_RXQ; i++)
+				mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_high_coal_cfg);
+		else
+			for (i = 0; i < CONFIG_MV_ETH_RXQ; i++)
+				mv_eth_rx_time_coal_set(pp->port, i, pp->rx_time_coal_cfg);
+
+		pp->rx_rate_pkts = 0;
+		pp->rx_timestamp = jiffies;
+	}
+}
+
+/*****************************************
  *            MUX function                *
  *****************************************/
 static int mv_eth_tag_type_set(int port, int type)
@@ -2732,6 +2758,7 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 		printk(KERN_ERR "mv_eth_isr ERROR: port=%d, cpu=%d\n", pp->port, smp_processor_id());
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 	}
+
 	return IRQ_HANDLED;
 }
 
@@ -2910,6 +2937,10 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 			causeRxTx &= ~((1 << rx_queue) << MV_PP2_CAUSE_RXQ_OCCUP_DESC_OFFS);
 	}
 
+	/* Maintain RX packets rate if adaptive RX coalescing is enabled */
+	if (pp->rx_adaptive_coal_cfg)
+		pp->rx_rate_pkts += rx_done;
+
 	STAT_DIST((rx_done < pp->dist_stats.rx_dist_size) ? pp->dist_stats.rx_dist[rx_done]++ : 0);
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
@@ -2928,6 +2959,10 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 
 		STAT_INFO(pp->stats.poll_exit[smp_processor_id()]++);
 
+		/* adapt RX coalescing according to packets rate */
+		if (pp->rx_adaptive_coal_cfg)
+			mv_eth_adaptive_rx_update(pp);
+
 		/* TODO: do we need irq_save */
 		local_irq_save(flags);
 		/* Enable interrupts for all cpus belong to this group */
@@ -3647,6 +3682,14 @@ int mv_eth_hal_init(struct eth_port *pp)
 	pp->speed_cfg = SPEED_1000;
 	pp->duplex_cfg = DUPLEX_FULL;
 	pp->advertise_cfg = 0x2f;
+	pp->rx_time_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC;
+	pp->rx_pkts_coal_cfg = CONFIG_MV_ETH_RX_COAL_PKTS;
+	pp->tx_pkts_coal_cfg = mv_ctrl_txdone;
+	pp->rx_time_low_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC >> 2;
+	pp->rx_time_high_coal_cfg = CONFIG_MV_ETH_RX_COAL_USEC << 2;
+	pp->pkt_rate_low_cfg = 50;
+	pp->pkt_rate_high_cfg = 10000;
+	pp->rate_sample_cfg = 1;
 
 	return 0;
 oom:
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 2df3283..2b1a590 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -373,6 +373,18 @@ struct eth_port {
 	__u8                duplex_cfg;
 	__u8                autoneg_cfg;
 	__u16		    advertise_cfg;
+	__u32		    rx_time_coal_cfg;
+	__u32		    rx_pkts_coal_cfg;
+	__u32		    tx_pkts_coal_cfg;
+	__u32		    rx_time_low_coal_cfg;
+	__u32		    rx_time_high_coal_cfg;
+	__u32		    pkt_rate_low_cfg;
+	__u32		    pkt_rate_high_cfg;
+	__u32		    rate_sample_cfg;
+	__u32		    rx_adaptive_coal_cfg;
+	/* Rate calculate */
+	unsigned long	    rx_rate_pkts;
+	unsigned long	    rx_timestamp;
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	void    (*rx_special_proc)(int port, int rxq, struct net_device *dev,
 					struct sk_buff *skb, struct pp2_rx_desc *rx_desc);
-- 
1.7.5.4

