From 28692ad532833c5d1eb2a8d568c487c5c4417a50 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 12 Feb 2013 16:28:19 +0200
Subject: [PATCH 0465/1825] Avanta FPGA Cortex A9 1st bringup

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 536c084df72f9cd451a6ef72eb60a4c1dc6be151

Change-Id: I3c5874fc4a6a8e8416db74e6f954da09ee067de0

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      | 2001 ++++++++++++++++++++
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |  441 +++++
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |  256 +++
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.h     |  110 ++
 .../arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c |  326 ++++
 .../arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.h |  112 ++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.c    |  363 ++++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.h    |  194 ++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvAsm.h        |   97 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        | 1564 +++++++++++++++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |  279 +++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h       |  589 ++++++
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |  502 +++++
 .../avanta_lp_family/ctrlEnv/mvSemaphore.c         |  123 ++
 .../avanta_lp_family/ctrlEnv/mvSemaphore.h         |  106 +
 .../avanta_lp_family/ctrlEnv/mvUnitMap.c           |  231 +++
 .../avanta_lp_family/ctrlEnv/mvUnitMap.h           |  158 ++
 .../avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c     |  738 ++++++++
 .../avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h     |   92 +
 .../avanta_lp_family/ctrlEnv/sys/mvAhbToMbusRegs.h |  143 ++
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIf.c         | 1027 ++++++++++
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIf.h         |  121 ++
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIfInit.S     |  167 ++
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h     |  358 ++++
 .../avanta_lp_family/device/mvDevice.c             |  291 +++
 .../avanta_lp_family/device/mvDevice.h             |   99 +
 .../avanta_lp_family/device/mvDeviceRegs.h         |  270 +++
 arch/arm/plat-armada/common/mvDeviceId.h           |    3 +-
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c      |    4 +
 .../plat-armada/mv_hal/ddr2_3/mvDramIfBasicInit.S  |  280 +++
 .../arm/plat-armada/mv_hal/ddr2_3/mvDramIfConfig.h |  161 ++
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h  |    8 +
 arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c       |   34 +
 .../mv_hal/pci-if/pci_util/mvPciUtils.c            |    9 +-
 34 files changed, 11255 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAsm.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.c
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.h
 create mode 100644 arch/arm/mach-avantalp/avanta_lp_family/device/mvDeviceRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfBasicInit.S
 create mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfConfig.h

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
new file mode 100644
index 0000000..14277ad
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,2001 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPex.h"
+#include "pci/mvPci.h"
+#include "device/mvDevice.h"
+#include "neta/gbe/mvEthRegs.h"
+#include "gpp/mvGppRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+extern MV_BOARD_INFO *boardInfoTbl[];
+
+/* Locals */
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+static MV_U32 gBoardId = MV_INVALID_BOARD_ID;
+static MV_BOARD_INFO *board = NULL;
+
+/*******************************************************************************
+* mvBoardEnvInit
+*
+* DESCRIPTION:
+*	In this function the board environment take care of device bank
+*	initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	/*
+	 * FPGA board doesn't use MPP neither GPIO.
+	 */
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA_FPGA)
+	MV_U32 nandDev;
+	MV_U32 norDev;
+
+	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+	if (nandDev != 0xFFFFFFFF) {
+		/* Set NAND interface access parameters */
+		nandDev = BOOT_CS;
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), board->nandFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), board->nandFlashWriteParams);
+		MV_REG_WRITE(DEV_NAND_CTRL_REG, board->nandFlashControl);
+	}
+
+	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+	if (norDev != 0xFFFFFFFF) {
+		/* Set NOR interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), board->norFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), board->norFlashWriteParams);
+		MV_REG_WRITE(DEV_BUS_SYNC_CTRL, 0x11);
+	}
+
+	MV_REG_WRITE(MV_RUNIT_PMU_REGS_OFFSET + 0x4, board->pmuPwrUpPolarity);
+	MV_REG_WRITE(MV_RUNIT_PMU_REGS_OFFSET + 0x14, board->pmuPwrUpDelay);
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), board->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), board->gppOutValMid);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(2), board->gppOutValHigh);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, board->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, board->gppPolarityValMid);
+	mvGppPolaritySet(2, 0xFFFFFFFF, board->gppPolarityValHigh);
+
+	/* Set GPP Out Enable */
+	mvGppTypeSet(0, 0xFFFFFFFF, board->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, board->gppOutEnValMid);
+	mvGppTypeSet(2, 0xFFFFFFFF, board->gppOutEnValHigh);
+#endif
+}
+
+/*******************************************************************************
+* mvBoardModelGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns 16bit describing board model.
+*       Board model is constructed of one byte major and minor numbers in the
+*       following manner:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardModelGet(MV_VOID)
+{
+	return (mvBoardIdGet() >> 16);
+}
+
+/*******************************************************************************
+* mbBoardRevlGet - Get Board revision
+*
+* DESCRIPTION:
+*       This function returns a 32bit describing the board revision.
+*       Board revision is constructed of 4bytes. 2bytes describes major number
+*       and the other 2bytes describes minor munber.
+*       For example for board revision 3.4 the function will return
+*       0x00030004.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardRevGet(MV_VOID)
+{
+	return (mvBoardIdGet() & 0xFFFF);
+}
+
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff)
+{
+	mvOsSPrintf(pNameBuff, "%s", board->boardName);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsPortInGmii
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	if (ethPortNum >= board->numBoardMacInfo)
+		return MV_ERROR;
+
+	return board->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+
+/*******************************************************************************
+* mvBoardQuadPhyAddr0Get - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardQuadPhyAddr0Get: Board unknown.\n");
+		return MV_ERROR;
+	}
+#if !defined(CONFIG_MACH_GENERAL_FPGA)
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr0;
+#else
+	return 0;
+#endif
+
+}
+
+/*******************************************************************************
+* mvBoardPhyLinkCryptPortAddrGet
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum)
+{
+	if (ethPortNum >= board->numBoardMacInfo)
+		return MV_ERROR;
+
+	return board->pBoardMacInfo[ethPortNum].LinkCryptPortAddr;
+}
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	if (ethPortNum >= board->numBoardMacInfo)
+		return MV_ERROR;
+
+	return board->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardTclkGet
+*
+* DESCRIPTION:
+*       This routine extract the controller core clock.
+*       This function uses the controller counters to make identification.
+*		Note: In order to avoid interference, make sure task context switch
+*		and interrupts will not occure during this function operation
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardTclkGet(MV_VOID)
+{
+#ifdef CONFIG_MACH_GENERAL_FPGA
+	/* FPGA is limited to 25Mhz */
+	return MV_FPGA_CORE_CLK;
+#else
+#error "Code must be added"
+#endif
+}
+
+/*******************************************************************************
+* mvBoardSysClkGet - Get the board SysClk (CPU bus clock , i.e. DDR clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU bus clock.
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardSysClkGet(MV_VOID)
+{
+#ifdef CONFIG_MACH_GENERAL_FPGA
+	/* FPGA is limited to 25Mhz */
+	return MV_FPGA_SYS_CLK;
+#else
+#error "Code must be added"
+#endif
+}
+
+/*******************************************************************************
+* mvBoardDebugLedNumGet - Get number of debug Leds
+*
+* DESCRIPTION:
+* INPUT:
+*       boardId
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId)
+{
+	return board->activeLedsNumber;
+}
+
+/*******************************************************************************
+* mvBoardDebugLed - Set the board debug Leds
+*
+* DESCRIPTION: turn on/off status leds.
+* 	       Note: assume MPP leds are part of group 0 only.
+*
+* INPUT:
+*       hexNum - Number to be displied in hex by Leds.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardDebugLed(MV_U32 hexNum)
+{
+	/* empty */
+}
+
+/*******************************************************************************
+* mvBoarGpioPinNumGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	gppClass - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
+{
+	MV_U32 i, indexFound = 0;
+
+	for (i = 0; i < board->numBoardGppInfo; i++) {
+		if (board->pBoardGppInfo[i].devClass == gppClass) {
+			if (indexFound == index)
+				return (MV_U32)board->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardReset
+*
+* DESCRIPTION:
+*	Reset the board
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvBoardReset(MV_VOID)
+{
+	/* empty */
+}
+
+/*******************************************************************************
+* mvBoardResetGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardResetGpioPinGet(MV_VOID)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_RESET, 0);
+}
+
+/*******************************************************************************
+* mvBoardSDIOGpioPinGet
+*
+* DESCRIPTION:
+*	used for hotswap detection
+* INPUT:
+*	type - Type of SDIO GPP to get.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type)
+{
+	if (type != BOARD_GPP_SDIO_POWER &&
+	    type != BOARD_GPP_SDIO_DETECT &&
+	    type != BOARD_GPP_SDIO_WP)
+		return MV_FAIL;
+
+	return mvBoarGpioPinNumGet(type, 0);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusGpioPinGet - return Vbus input GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS, devId);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusEnGpioPinGet - return Vbus Enable output GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS_EN, devId);
+}
+
+MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum)
+{
+	MV_U32 localBusNum = mvPciLocalBusNumGet(PCI_DEFAULT_IF);
+
+	/* Our device number */
+	if (slotNum == mvPciLocalDevNumGet(PCI_DEFAULT_IF))
+		return MV_TRUE;
+
+	if (localBusNum != busNum) {
+		DB(mvOsPrintf("%s:: localBusNum %x != busNum %x.\n",
+					__func__, localBusNum, busNum));
+		return MV_FALSE;
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
+*
+* DESCRIPTION:
+*		This function returns a 32-bit mask of GPP pins that connected to
+*		interrupt generating sources on board.
+*		For example if UART channel A is hardwired to GPP pin 8 and
+*		UART channel B is hardwired to GPP pin 4 the fuinction will return
+*		the value 0x000000110
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		See description. The function return -1 if board is not identified.
+*
+*******************************************************************************/
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
+{
+	switch (gppGrp) {
+	case 0:
+		return board->intsGppMaskLow;
+		break;
+	case 1:
+		return board->intsGppMaskMid;
+		break;
+	case 2:
+		return board->intsGppMaskHigh;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*	MPP settings are derived from board design.
+*	MPP group consist of 8 MPPs. An MPP group represents MPP
+*	control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	MV_U32 mppMod;
+
+	mppMod = board->pBoardModTypeValue->boardMppMod;
+	if (mppMod >= board->numBoardMppConfigValue)
+		mppMod = 0; /* default */
+
+	return board->pBoardMppConfigValue[mppMod].mppGroup[mppGroupNum];
+}
+
+/*******************************************************************************
+* mvBoardGppConfigGet
+*
+* DESCRIPTION:
+*	Get board configuration according to the input configuration GPP's.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The value of the board configuration GPP's.
+*
+*******************************************************************************/
+MV_U32 mvBoardGppConfigGet(void)
+{
+	MV_U32 gpp, i, result = 0;
+
+	for (i = 0; i < board->numBoardGppInfo; i++) {
+		if (board->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
+			gpp = board->pBoardGppInfo[i].gppPinNum;
+			result <<= 1;
+			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
+		}
+	}
+
+	return result;
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiModeGet - return SLIC/DAA connection
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_32 mvBoardTdmSpiModeGet(MV_VOID)
+{
+	return DUAL_CHIP_SELECT_MODE;
+}
+
+/*******************************************************************************
+* mvBoardTdmDevicesCountGet
+*
+* DESCRIPTION:
+*	Return the number of TDM devices on board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	Number of devices.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmDevicesCountGet(void)
+{
+	MV_16 index = board->boardTdmInfoIndex;
+
+	if (index == -1)
+		return 0;
+
+	return board->numBoardTdmInfo[index];
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiCsGet
+*
+* DESCRIPTION:
+*	Return the SPI Chip-select number for a given device.
+*
+* INPUT:
+*	devId	- The Slic device ID to get the SPI CS for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The SPI CS if found, -1 otherwise.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
+{
+	MV_16 index;
+
+	index = board->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	if (devId >= board->numBoardTdmInfo[index])
+		return -1;
+
+	return board->pBoardTdmInt2CsInfo[index][devId].spiCs;
+}
+
+/*******************************************************************************
+* mvBoardMppModuleTypePrint
+*
+* DESCRIPTION:
+*	Print on-board detected modules.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
+{
+	mvOsOutput("Modules Detected:\n");
+
+	/* TDM */
+	if (mvBoardTdmDevicesCountGet() > 0)
+		mvOsOutput("       TDM module.\n");
+
+	/* LCD DVI Module */
+	if (mvBoardIsLcdDviModuleConnected())
+		mvOsOutput("       LCD DVI module.\n");
+
+	/* Switch Module */
+	if (mvBoardIsSwitchModuleConnected())
+		mvOsOutput("       Switch module.\n");
+
+	/* GMII Module */
+	if (mvBoardIsGMIIModuleConnected())
+		mvOsOutput("       GMII module.\n");
+}
+
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
+{
+	/* Pex Module */
+	if (mvBoardIsPexModuleConnected())
+		mvOsOutput("       PEX module.\n");
+	/* SETM Module */
+	if (mvBoardIsSetmModuleConnected())
+		mvOsOutput("       SETM module.\n");
+	/* LVDS Module */
+	if (mvBoardIsLvdsModuleConnected())
+		mvOsOutput("       LVDS module.\n");
+}
+
+/*******************************************************************************
+* mvBoardIsGbEPortConnected
+*
+* DESCRIPTION:
+*	Checks if a given GbE port is actually connected to the GE-PHY, internal Switch or any RGMII module.
+*
+* INPUT:
+*	port - GbE port number (0 or 1).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_TRUE if port is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/* Board devices API managments */
+
+/*******************************************************************************
+* mvBoardGetDeviceNumber - Get number of device of some type on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		number of those devices else the function returns 0
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devNum;
+
+	for (devNum = START_DEV_CS; devNum < board->numBoardDeviceIf; devNum++) {
+		if (board->pDevCsInfo[devNum].devClass == devClass)
+			foundIndex++;
+	}
+
+	return foundIndex;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBaseAddr - Get base address of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*	Base address else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return mvCpuIfTargetWinBaseLowGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBusWidth - Get Bus width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		Bus width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->busWidth;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWidth - Get dev width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		dev width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->devWidth;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWinSize - Get the window size of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		window size else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return mvCpuIfTargetWinSizeGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* boardGetDevEntry - returns the entry pointer of a device on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devIndex;
+
+	for (devIndex = START_DEV_CS; devIndex < board->numBoardDeviceIf; devIndex++) {
+		if (board->pDevCsInfo[devIndex].devClass == devClass) {
+			if (foundIndex == devNum)
+				return &(board->pDevCsInfo[devIndex]);
+			foundIndex++;
+		}
+	}
+
+	/* device not found */
+	return NULL;
+}
+
+/*******************************************************************************
+* boardGetDevCSNum
+*
+* DESCRIPTION:
+*	Return the device's chip-select number.
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->deviceCS;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrTypeGet
+*
+* DESCRIPTION:
+*	Return the TWSI address type for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address type.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+
+	for (i = 0; i < board->numBoardTwsiDev; i++) {
+		if (board->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return board->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrGet
+*
+* DESCRIPTION:
+*	Return the TWSI address for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+
+	for (i = 0; i < board->numBoardTwsiDev; i++) {
+		if (board->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return board->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+	}
+
+	return 0xFF;
+}
+
+/*******************************************************************************
+* mvBoardNandWidthGet -
+*
+* DESCRIPTION: Get the width of the first NAND device in bytes
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: 1, 2, 4 or MV_ERROR
+*
+*
+*******************************************************************************/
+MV_32 mvBoardNandWidthGet(void)
+{
+	MV_U32 devNum;
+	MV_U32 devWidth;
+
+	for (devNum = START_DEV_CS; devNum < board->numBoardDeviceIf; devNum++) {
+		devWidth = mvBoardGetDeviceWidth(devNum, BOARD_DEV_NAND_FLASH);
+		if (devWidth != MV_ERROR)
+			return devWidth / 8;
+	}
+
+	/* NAND wasn't found */
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       This function sets the board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       void
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_VOID)
+{
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+	gBoardId = MV_BOARD_ID_AVANTA_LP_FPGA;
+#endif
+	board = boardInfoTbl[gBoardId];
+}
+
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	if (gBoardId == MV_INVALID_BOARD_ID)
+		mvOsWarning();
+	return gBoardId;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U8 data;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+
+	twsiSlave.validOffset = MV_TRUE;
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, &data, 1)) {
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+
+	return data;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+ * SatR Configuration functions
+ */
+MV_U8 mvBoardFabFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+	MV_U8 sar1;
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar1 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar1)
+		return MV_ERROR;
+
+	return (((sar1 & 0x1) << 4) | ((sar0 & 0x1E) >> 1));
+}
+
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0xF << 1);
+	sar0 |= (freqVal & 0xF) << 1;
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+		DB(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	sar0 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0x1);
+	sar0 |= ( (freqVal >> 4) & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar0)) {
+		DB(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardCpuFreqGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U8 sarMsb;
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sarMsb = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (((sarMsb & 0x1) << 3) | ((sar & 0x1C) >> 2));
+}
+
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x7 << 2);
+	sar |= (freqVal & 0x7) << 2;
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+		DB(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+		return MV_ERROR;
+	}
+	sar = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	sar &= ~(0x1);
+	sar |= ( (freqVal >> 3) & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+		DB(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	sar = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= ( (freqVal >> 3) & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+		DB(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write CpuFreq S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardBootDevGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x7);
+}
+
+MV_STATUS mvBoardBootDevSet(MV_U8 val)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x7);
+	sar |= (val & 0x7);
+
+	if (mvBoardTwsiSatRSet(0, 0, sar) != MV_OK) {
+		DB(mvOsPrintf("Board: Write BootDev S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDev S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardBootDevWidthGet(MV_VOID)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(0, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x18) >> 3;
+}
+
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(0, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3 << 3);
+	sar |= ((val & 0x3) << 3);
+
+	if (mvBoardTwsiSatRSet(0, 0, sar) != MV_OK) {
+		DB(mvOsPrintf("Board: Write BootDevWidth S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDevWidth S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(3, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x08) >> 3;
+}
+
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(3, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	sar &= ~(0x1 << 3);
+	sar |= ((val & 0x1) << 3);
+
+	if (mvBoardTwsiSatRSet(3, 0, sar) != MV_OK) {
+		DB(mvOsPrintf("Board: Write Cpu0CoreMode S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write Cpu0CoreMode S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardL2SizeGet(MV_VOID)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(1, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x3);
+}
+
+MV_STATUS mvBoardL2SizeSet(MV_U8 val)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(1, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3);
+	sar |= (val & 0x3);
+
+	if (mvBoardTwsiSatRSet(1, 0, sar) != MV_OK) {
+		DB(mvOsPrintf("Board: Write L2Size S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write L2Size S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(3, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar = (sar & 0x6) >> 1;
+	if (sar == 1)
+		sar = 2;
+	else if (sar == 2)
+		sar =1;
+	return sar;
+}
+
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val)
+{
+	MV_U8 sar = mvBoardTwsiSatRGet(3, 0);
+
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	/* MSB and LSB are swapped on DB board */
+	if (val == 1)
+		val = 2;
+	else if (val == 2)
+		val =1;
+
+	sar &= ~(0x3 << 1);
+	sar |= ((val & 0x3) << 1);
+
+	if (mvBoardTwsiSatRSet(3, 0, sar) != MV_OK) {
+		DB(mvOsPrintf("Board: Write CpuCoreNum S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write CpuCoreNum S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_STATUS mvBoardConfIdSet(MV_U16 conf)
+{
+	if (MV_OK != mvBoardTwsiSatRSet(0, 1, conf)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U16 mvBoardConfIdGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0xFF);
+}
+
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= (conf & 0x1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(1, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+MV_U16 mvBoardPexCapabilityGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_STATUS mvBoardPexModeSet(MV_U16 conf)
+{
+	return MV_ERROR;
+}
+
+MV_U16 mvBoardPexModeGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_STATUS mvBoardDramEccSet(MV_U16 ecc)
+{
+	return MV_ERROR;
+}
+
+MV_U16 mvBoardDramEccGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 dramBusWidth)
+{
+	return MV_ERROR;
+}
+
+MV_U16 mvBoardDramBusWidthGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_U8 mvBoardAltFabFreqGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal)
+{
+	return MV_ERROR;
+}
+/*******************************************************************************
+* End of SatR Configuration functions
+*******************************************************************************/
+
+/*******************************************************************************
+* mvBoardMppModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through MPP lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardMppModulesScan(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardOtherModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through SERDES/LVDS/... lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardOtherModulesScan(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPexModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsSetmModuleConnected
+*
+* DESCRIPTION:
+*	Check if SETM module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSetmModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsSwitchModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSwitchModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLvdsModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLvdsModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLcdDviModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLcdDviModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsGMIIModuleConnected
+*
+* DESCRIPTION:
+*	Check if GMII module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGMIIModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTwsiMuxChannelSet
+*
+* DESCRIPTION:
+*	Set the channel number of the on-board TWSI mux.
+*
+* INPUT:
+*	chNum	- The channel number to set.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum)
+{
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardTwsiReadByteThruMux
+*
+* DESCRIPTION:
+*	Read a single byte from a TWSI device through the TWSI Mux.
+*
+* INPUT:
+*	muxChNum	- The Twsi Mux channel number to read through.
+*	chNum		- The TWSI channel number.
+*	pTwsiSlave	- The TWSI slave address.
+*	data		- Buffer to read into (1 byte).
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum,
+				     MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data)
+{
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSmiScanModeGet - Get Switch SMI scan mode
+*
+* DESCRIPTION:
+*       This routine returns Switch SMI scan mode.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 for SMI_MANUAL_MODE, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
+{
+	return NULL;
+}
+
+/*******************************************************************************
+* mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
+*
+* DESCRIPTION:
+*       This routine returns the Switch CPU port.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the Switch CPU port, -1 if the switch is not connected.
+*
+*******************************************************************************/
+MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
+{
+	return 0;
+}
+
+
+/*******************************************************************************
+* mvBoardIsSerdesConfigurationEnabled
+*
+* DESCRIPTION:
+*       Check if Serdes configuration is enabled on this board.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSerdesConfigurationEnabled(void)
+{
+	if (board->pBoardSerdesConfigValue)
+		return (board->pBoardSerdesConfigValue->enableSerdesConfiguration);
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardSerdesConfigurationEnableSet
+*
+* DESCRIPTION:
+*	Check if Serdes configuration is enabled on this board.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardSerdesConfigurationEnableSet(MV_BOOL enableSerdesConfiguration)
+{
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSerdesCfgGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_SERDES_CFG *mvBoardSerdesCfgGet(void)
+{
+	return NULL;
+}
+
+/*******************************************************************************
+* mvBoardPexInfoGet - Get board PEX Info
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*******************************************************************************/
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
+{
+	return NULL;
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
new file mode 100644
index 0000000..5de51cc
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,441 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+/* DUART stuff for Tclk detection only */
+#define DUART_BAUD_RATE			115200
+#define MAX_CLOCK_MARGINE		5000000	/* Maximum detected clock margin */
+
+/* Voice devices assembly modes */
+#define DAISY_CHAIN_MODE		1
+#define DUAL_CHIP_SELECT_MODE		0
+#define INTERRUPT_TO_MPP		1
+#define INTERRUPT_TO_TDM		0
+
+#define	MV_BOARD_MAX_USB_IF		3
+#define MV_BOARD_MAX_MPP		9	/* number of MPP conf registers */
+#define MV_BOARD_NAME_LEN  		0x20
+
+/* EPPROM Modules detection information */
+
+#define MV_BOARD_EEPROM_MODULE_ADDR		0x50
+#define MV_BOARD_EEPROM_MODULE_ADDR_TYPE	ADDR7_BIT
+
+#define MV_BOARD_PEX_MODULE_ADDR		0x23
+#define MV_BOARD_PEX_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_PEX_MODULE_ID			0
+
+#define MV_BOARD_LVDS_MODULE_ADDR		0x21
+#define MV_BOARD_LVDS_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LVDS_MODULE_ID			0
+
+#define MV_BOARD_SETM_MODULE_ADDR		0x23
+#define MV_BOARD_SETM_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_SETM_MODULE_ID			1
+
+#define MV_BOARD_MPP_MODULE_ADDR		0x20
+#define MV_BOARD_MPP_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LCD_DVI_MODULE_ID		0
+#define MV_BOARD_TDM_MODULE_ID			1
+#define MV_BOARD_MII_GMII_MODULE_ID		4
+
+typedef enum {
+	BOARD_EPON_CONFIG,
+	BOARD_GPON_CONFIG,
+	BOARD_PON_NONE,
+	BOARD_PON_AUTO
+} MV_BOARD_PON_CONFIG;
+
+typedef struct _boardData {
+	MV_U32 magic;
+	MV_U16 boardId;
+	MV_U8 boardVer;
+	MV_U8 boardRev;
+	MV_U32 reserved1;
+	MV_U32 reserved2;
+} BOARD_DATA;
+
+typedef enum _devBoardMppGroupClass {
+	MV_BOARD_MPP_GROUP_1,
+	MV_BOARD_MPP_GROUP_2,
+	MV_BOARD_MPP_GROUP_3,
+	MV_BOARD_MAX_MPP_GROUP
+} MV_BOARD_MPP_GROUP_CLASS;
+
+typedef enum _devBoardMppTypeClass {
+	MV_BOARD_AUTO = 0,
+	MV_BOARD_TDM_32CH,
+	MV_BOARD_LCD_DVI,
+	MV_BOARD_MII_GMII,
+	MV_BOARD_OTHER
+} MV_BOARD_MPP_TYPE_CLASS;
+
+typedef enum _devBoardOtherTypeClass {
+	MV_BOARD_NONE    = 0x00000000,
+	MV_BOARD_LVDS    = 0x00000001,
+	MV_BOARD_PEX     = 0x00000002,
+	MV_BOARD_SWITCH  = 0x00000004,
+	MV_BOARD_SETM 	 = 0x00000008,
+	MV_BOARD_UNKNOWN = 0x80000000
+} MV_BOARD_OTHER_TYPE_CLASS;
+
+
+#define MV_BOARD_TDM	MV_BOARD_TDM_32CH
+
+typedef struct _boardModuleTypeInfo {
+	MV_BOARD_MPP_TYPE_CLASS boardMppMod;
+	MV_BOARD_OTHER_TYPE_CLASS boardOtherMod;
+} MV_BOARD_MODULE_TYPE_INFO;
+
+typedef enum _devBoardClass {
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER
+} MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass {
+	BOARD_TWSI_RTC,
+	BOARD_DEV_TWSI_EXP,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_TWSI_MUX,
+	BOARD_TWSI_OTHER
+} MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass {
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+	BOARD_GPP_SDIO_POWER,
+	BOARD_GPP_SDIO_DETECT,
+	BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_CONF,
+	BOARD_GPP_OTHER
+} MV_BOARD_GPP_CLASS;
+
+typedef struct _devCsInfo {
+	MV_U8 deviceCS;
+	MV_U32 params;
+	MV_U32 devClass;	/* MV_BOARD_DEV_CLASS */
+	MV_U8 devWidth;
+	MV_U8 busWidth;
+} MV_DEV_CS_INFO;
+
+typedef struct _boardLedInfo {
+	MV_U8 activeLedsNumber;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+	MV_U8 *gppPinNum;	/* Pointer to GPP values */
+} MV_BOARD_LED_INFO;
+
+typedef struct _boardGppInfo {
+	MV_BOARD_GPP_CLASS devClass;
+	MV_U8 gppPinNum;
+} MV_BOARD_GPP_INFO;
+
+typedef struct _boardTwsiInfo {
+	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 twsiDevAddr;
+	MV_U8 twsiDevAddrType;
+} MV_BOARD_TWSI_INFO;
+
+typedef enum _boardMacSpeed {
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO
+} MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo {
+	MV_BOARD_MAC_SPEED boardMacSpeed;
+	MV_U8 boardEthSmiAddr;
+	MV_U16 LinkCryptPortAddr;
+	MV_U8	boardEthSmiAddr0;
+} MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo {
+	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
+} MV_BOARD_MPP_INFO;
+
+typedef struct {
+	MV_U8 spiCs;
+} MV_BOARD_TDM_INFO;
+
+typedef struct _boardPexUnitCfg {
+	MV_PEX_UNIT_CFG 	pexCfg;
+	MV_U8			pexLaneStat[4];	/* 1: enabled, 2: disabled */
+} MV_BOARD_PEX_UNIT_CFG;
+
+typedef struct _boardPexInfo {
+	MV_PEXIF_INDX 		pexMapping[MV_PEX_MAX_IF];
+	MV_BOARD_PEX_UNIT_CFG 	pexUnitCfg[MV_PEX_MAX_UNIT];
+	MV_U32			boardPexIfNum;
+} MV_BOARD_PEX_INFO;
+
+typedef enum {
+	BOARD_TDM_SLIC_880 = 0,
+	BOARD_TDM_SLIC_792,
+	BOARD_TDM_SLIC_3215,
+	BOARD_TDM_SLIC_OTHER,
+	BOARD_TDM_SLIC_COUNT
+} MV_BOARD_TDM_SLIC_TYPE;
+
+typedef struct _boardInfo {
+	char boardName[MV_BOARD_NAME_LEN];
+	MV_U8 numBoardMppTypeValue;
+	MV_BOARD_MODULE_TYPE_INFO *pBoardModTypeValue;
+	MV_U8 numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO *pBoardMppConfigValue;
+	MV_U8 numBoardSerdesConfigValue;
+	MV_SERDES_CFG *pBoardSerdesConfigValue;
+	MV_U32 intsGppMaskLow;
+	MV_U32 intsGppMaskMid;
+	MV_U32 intsGppMaskHigh;
+	MV_U8 numBoardDeviceIf;
+	MV_DEV_CS_INFO *pDevCsInfo;
+	MV_U8 numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
+	MV_U8 numBoardMacInfo;
+	MV_BOARD_MAC_INFO *pBoardMacInfo;
+	MV_U8 numBoardGppInfo;
+	MV_BOARD_GPP_INFO *pBoardGppInfo;
+	MV_U8 activeLedsNumber;
+	MV_U8 *pLedGppPin;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+
+	MV_U8	pmuPwrUpPolarity;
+	MV_U32	pmuPwrUpDelay;
+	/* GPP values */
+	MV_U32 gppOutEnValLow;
+	MV_U32 gppOutEnValMid;
+	MV_U32 gppOutEnValHigh;
+	MV_U32 gppOutValLow;
+	MV_U32 gppOutValMid;
+	MV_U32 gppOutValHigh;
+	MV_U32 gppPolarityValLow;
+	MV_U32 gppPolarityValMid;
+	MV_U32 gppPolarityValHigh;
+
+	/*
+	 * TDM configuration:
+	 * We hold a different configuration array for each possible slic that
+	 * can be connected to board.
+	 * When modules are scanned, then we select the index of the relevant
+	 * slic's information array.
+	 * For RD and Customers boards we only need to initialize a single
+	 * entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	 */
+	MV_U8 numBoardTdmInfo[BOARD_TDM_SLIC_COUNT];
+	MV_BOARD_TDM_INFO *pBoardTdmInt2CsInfo[BOARD_TDM_SLIC_COUNT];
+	MV_16 boardTdmInfoIndex;
+
+	/* NAND init params */
+	MV_U32 nandFlashReadParams;
+	MV_U32 nandFlashWriteParams;
+	MV_U32 nandFlashControl;
+	MV_BOARD_PEX_INFO	boardPexInfo;	/* filled in runtime */
+	MV_U32 norFlashReadParams;
+	MV_U32 norFlashWriteParams;
+
+} MV_BOARD_INFO;
+
+/* For backward compatability with Legacy mode */
+#define mvBoardSwitchConnectedPortGet(port)	(-1)
+#define mvBoardIsSwitchConnected(port)  	(mvBoardSwitchConnectedPortGet(port) != -1)
+/*#define mvBoardLinkStatusIrqGet(port)		mvBoardSwitchIrqGet()*/
+
+MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U16 mvBoardModelGet(MV_VOID);
+MV_U16 mvBoardRevGet(MV_VOID);
+MV_STATUS mvBoardNameGet(char *pNameBuff);
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
+
+MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardSysClkGet(MV_VOID);
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
+MV_VOID mvBoardDebugLed(MV_U32 hexNum);
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+MV_VOID mvBoardReset(MV_VOID);
+MV_32 mvBoardResetGpioPinGet(MV_VOID);
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type);
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId);
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId);
+MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum);
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
+MV_U32 mvBoardGppConfigGet(void);
+MV_32 mvBoardTdmSpiModeGet(MV_VOID);
+MV_U8 mvBoardTdmDevicesCountGet(void);
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_32 mvBoardNandWidthGet(void);
+MV_U32 mvBoardIdGet(MV_VOID);
+MV_VOID mvBoardIdSet(MV_VOID);
+MV_U32 mvBoardSledCpuNumGet(MV_VOID);
+
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum);
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U8 mvBoardFabFreqGet(MV_VOID);
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
+MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal);
+MV_U8 mvBoardBootDevGet(MV_VOID);
+MV_STATUS mvBoardBootDevSet(MV_U8 val);
+MV_U8 mvBoardBootDevWidthGet(MV_VOID);
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val);
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID);
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val);
+MV_U8 mvBoardL2SizeGet(MV_VOID);
+MV_STATUS mvBoardL2SizeSet(MV_U8 val);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
+MV_STATUS mvBoardConIdSet(MV_U16 conf);
+MV_U16 mvBoardConfIdGet(MV_VOID);
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf);
+MV_U16 mvBoardPexCapabilityGet(MV_VOID);
+MV_STATUS mvBoardDramEccSet(MV_U16 conf);
+MV_U16 mvBoardDramEccGet(MV_VOID);
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf);
+MV_U16 mvBoardDramBusWidthGet(MV_VOID);
+MV_U8 mvBoardAltFabFreqGet(MV_VOID);
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal);
+MV_STATUS mvBoardMppModulesScan(void);
+MV_STATUS mvBoardOtherModulesScan(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_BOOL mvBoardIsSwitchModuleConnected(void);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_BOOL mvBoardIsGMIIModuleConnected(void);
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsSerdesConfigurationEnabled(void);
+MV_STATUS  mvBoardSerdesConfigurationEnableSet(MV_BOOL enableSerdesconfig);
+MV_SERDES_CFG *mvBoardSerdesCfgGet(void);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
+MV_STATUS mvBoardConfIdSet(MV_U16 conf);
+MV_U16 mvBoardPexModeGet(MV_VOID);
+MV_STATUS mvBoardPexModeSet(MV_U16 conf);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
new file mode 100644
index 0000000..e35cd55
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,256 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPexRegs.h"
+
+#define ARRSZ(x)		(sizeof(x) / sizeof(x[0]))
+
+/*******************************************************************************
+ * AvantaLP FPGA board
+ */
+MV_BOARD_INFO avanta_lp_fpga_board_info = {
+	.boardName			= "CortexA9-FPGA",
+	.numBoardMppTypeValue		= 0,
+	.pBoardModTypeValue		= NULL,
+	.numBoardMppConfigValue		= 0,
+	.pBoardMppConfigValue		= NULL,
+	.numBoardSerdesConfigValue	= 0,
+	.pBoardSerdesConfigValue	= NULL,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= 0,
+	.pDevCsInfo			= NULL,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= 0,
+	.pBoardMacInfo			= NULL,
+	.numBoardGppInfo		= 0,
+	.pBoardGppInfo			= NULL,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= 0,
+	.gppOutEnValMid			= 0,
+	.gppOutEnValHigh		= 0,
+	.gppOutValLow			= 0,
+	.gppOutValMid			= 0,
+	.gppOutValHigh			= 0,
+	.gppPolarityValLow		= 0,
+	.gppPolarityValMid		= 0,
+	.gppPolarityValHigh		= 0,
+
+	/* TDM */
+	.numBoardTdmInfo		= {},
+	.pBoardTdmInt2CsInfo		= {},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= 0,
+	.nandFlashWriteParams		= 0,
+	.nandFlashControl		= 0,
+};
+
+/*******************************************************************************
+ * AvanataLP customer board
+ */
+#define AVANTA_LP_CUSTOMER_BOARD_NAND_READ_PARAMS	0x000C0282
+#define AVANTA_LP_CUSTOMER_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define AVANTA_LP_CUSTOMER_BOARD_NAND_CONTROL		0x01c00543
+
+#define AVANTA_LP_CUSTOMER_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define AVANTA_LP_CUSTOMER_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_MAC_INFO avanta_lp_customerInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO avanta_lp_customerInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO avanta_lp_customerInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO avanta_lp_customerInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO avanta_lp_customerInfoBoardMppConfigValue[] = {
+	{ {
+	AVANTA_LP_CUSTOMER_MPP0_7,
+	AVANTA_LP_CUSTOMER_MPP8_15,
+	AVANTA_LP_CUSTOMER_MPP16_23,
+	AVANTA_LP_CUSTOMER_MPP24_31,
+	AVANTA_LP_CUSTOMER_MPP32_39,
+	AVANTA_LP_CUSTOMER_MPP40_47,
+	AVANTA_LP_CUSTOMER_MPP48_55,
+	AVANTA_LP_CUSTOMER_MPP56_63,
+	AVANTA_LP_CUSTOMER_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG avanta_lp_customerInfoBoardSerdesConfigValue[] = {
+	{ /* default */
+		MV_TRUE,
+		0x00223001,
+		0x11111111,
+		PEX_BUS_MODE_X1,
+		PEX_BUS_DISABLED,
+		PEX_BUS_MODE_X4,
+		PEX_BUS_MODE_X4,
+		0x00000030
+	},
+	{ /* Switch module */
+		MV_TRUE,
+		0x33320201,
+		0x11111111,
+		PEX_BUS_MODE_X1,
+		PEX_BUS_DISABLED,
+		PEX_BUS_MODE_X4,
+		PEX_BUS_MODE_X4,
+		0x00000030
+	},
+};
+
+MV_BOARD_INFO avanta_lp_customer_board_info = {
+	.boardName			= "AvantaLP-CUSTOMER",
+	.numBoardMppTypeValue		= ARRSZ(avanta_lp_customerInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= avanta_lp_customerInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(avanta_lp_customerInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= avanta_lp_customerInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(avanta_lp_customerInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= avanta_lp_customerInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(avanta_lp_customerInfoBoardDeCsInfo),
+	.pDevCsInfo			= avanta_lp_customerInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(avanta_lp_customerInfoBoardMacInfo),
+	.pBoardMacInfo			= avanta_lp_customerInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(avanta_lp_customerInfoBoardGppInfo),
+	.pBoardGppInfo			= avanta_lp_customerInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= AVANTA_LP_CUSTOMER_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= AVANTA_LP_CUSTOMER_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= AVANTA_LP_CUSTOMER_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= AVANTA_LP_CUSTOMER_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= AVANTA_LP_CUSTOMER_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= AVANTA_LP_CUSTOMER_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= AVANTA_LP_CUSTOMER_GPP_POL_LOW,
+	.gppPolarityValMid		= AVANTA_LP_CUSTOMER_GPP_POL_MID,
+	.gppPolarityValHigh		= AVANTA_LP_CUSTOMER_GPP_POL_HIGH,
+
+	/* TDM */
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= AVANTA_LP_CUSTOMER_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= AVANTA_LP_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= AVANTA_LP_CUSTOMER_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= AVANTA_LP_CUSTOMER_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= AVANTA_LP_CUSTOMER_BOARD_NOR_WRITE_PARAMS
+};
+
+/*
+ * All supported avanta boards
+ */
+MV_BOARD_INFO *boardInfoTbl[] = {
+	&avanta_lp_fpga_board_info,
+};
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..8c57cf3
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,110 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+/* I2C bus addresses TODO - take from board design */
+#define MV_BOARD_DIMM0_I2C_ADDR			0x56
+#define MV_BOARD_DIMM0_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM1_I2C_ADDR			0x57
+#define MV_BOARD_DIMM1_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM_I2C_CHANNEL		0x0
+
+/* Board specific configuration */
+/* ============================ */
+
+/*******************************************************************************
+ * AvanataLP customer board
+ */
+#define AVANTA_LP_CUSTOMER_MPP0_7		0x00000000
+#define AVANTA_LP_CUSTOMER_MPP8_15		0x00000000
+#define AVANTA_LP_CUSTOMER_MPP16_23		0x33000000
+#define AVANTA_LP_CUSTOMER_MPP24_31		0x11000000
+#define AVANTA_LP_CUSTOMER_MPP32_39		0x11111111
+#define AVANTA_LP_CUSTOMER_MPP40_47		0x00221100
+#define AVANTA_LP_CUSTOMER_MPP48_55		0x00000003
+#define AVANTA_LP_CUSTOMER_MPP56_63		0x00000000
+#define AVANTA_LP_CUSTOMER_MPP64_67		0x00000000
+
+#define AVANTA_LP_CUSTOMER_GPP_OUT_ENA_LOW	0x0
+#define AVANTA_LP_CUSTOMER_GPP_OUT_ENA_MID	0x0
+#define AVANTA_LP_CUSTOMER_GPP_OUT_ENA_HIGH	0x0
+#define AVANTA_LP_CUSTOMER_GPP_OUT_VAL_LOW	0x0
+#define AVANTA_LP_CUSTOMER_GPP_OUT_VAL_MID	0x0
+#define AVANTA_LP_CUSTOMER_GPP_OUT_VAL_HIGH	0x0
+#define AVANTA_LP_CUSTOMER_GPP_POL_LOW		0x0
+#define AVANTA_LP_CUSTOMER_GPP_POL_MID		0x0
+#define AVANTA_LP_CUSTOMER_GPP_POL_HIGH		0x0
+
+/* New board ID numbers */
+#define BOARD_ID_BASE				0x0
+#define MV_BOARD_ID_AVANTA_LP_FPGA		BOARD_ID_BASE
+#define MV_MAX_BOARD_ID				(MV_BOARD_ID_AVANTA_LP_FPGA+1)
+#define MV_INVALID_BOARD_ID			0xFFFFFFFF
+
+
+#endif /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
new file mode 100644
index 0000000..f3adf50
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.c
@@ -0,0 +1,326 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals */
+
+/*******************************************************************************
+* mvCpuPclkGet - Get the CPU pClk (pipe clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU core clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in MHertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 cpuClk[] = MV_CPU_CLK_TBL;
+
+	if (mvBoardIdGet() == MV_BOARD_ID_AVANTA_LP_FPGA)
+		return MV_FPGA_CORE_CLK; /* FPGA is limited to 12.5Mhz */
+
+	idx = MSAR_CPU_CLK_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	return cpuClk[idx] * 1000000;
+}
+
+/*******************************************************************************
+* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU L2 clock.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuL2ClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz, l2FreqMhz;
+	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
+
+	if (mvBoardIdGet() == MV_BOARD_ID_AVANTA_LP_FPGA)
+		return MV_FPGA_CORE_CLK; /* FPGA is limited to 12.5Mhz */
+
+	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	if (clockRatioTbl[idx].vco2cpu != 0) {
+		freqMhz = mvCpuPclkGet() / 1000000;	/* CPU freq */
+		freqMhz *= clockRatioTbl[idx].vco2cpu;	/* VCO freq */
+		l2FreqMhz = freqMhz / clockRatioTbl[idx].vco2l2c;
+		/* round up to integer MHz */
+		if (((freqMhz % clockRatioTbl[idx].vco2l2c) * 10 / clockRatioTbl[idx].vco2l2c) >= 5)
+			l2FreqMhz++;
+
+		return l2FreqMhz * 1000000;
+	} else
+		return (MV_U32)-1;
+}
+
+/*******************************************************************************
+* mvCpuNameGet - Get CPU name
+*
+* DESCRIPTION:
+*       This function returns a string describing the CPU model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*       None.
+*******************************************************************************/
+MV_VOID mvCpuNameGet(char *pNameBuff)
+{
+	MV_U32 cpuModel;
+	MV_U32 archType;
+
+	cpuModel = mvOsCpuPartGet();
+	archType = mvOsCpuThumbEEGet();
+
+	/* The CPU module is indicated in the Processor Version Register (PVR) */
+	switch (cpuModel & 0xfff) {
+	case CPU_PART_ARM_V6UP:
+	case CPU_PART_ARM_V7UP:
+	case CPU_PART_MRVLPJ4B_UP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_MRVLPJ4B_MP:
+	case CPU_PART_ARM_V6MP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_ARM_CA9:
+		mvOsSPrintf(pNameBuff, "%s (Rev %d)", "ARM Cortex A9 MPCore", mvOsCpuRevGet());
+		break;
+
+	default:
+		mvOsSPrintf(pNameBuff, "??? (0x%04x) (Rev %d)", cpuModel, mvOsCpuRevGet());
+		break;
+	}
+}
+
+#define MV_PROC_STR_SIZE 50
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_ECC_MASK) == CL2ACR_ECC_EN)
+		mvOsSPrintf(buf, "L2 ECC Enabled");
+	else
+		mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2ParityMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PARITY_MASK) == CL2ACR_PARITY_EN)
+		mvOsSPrintf(buf, "L2 Parity Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Parity Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	if (regVal & CL2CR_L2_EN_MASK)
+		mvOsSPrintf(buf, "L2 Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PFU_MASK) == CL2ACR_PFU_DIS)
+		mvOsSPrintf(buf, "L2 Prefetch Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_FORCE_WA_MASK) == CL2ACR_FORCE_NO_WA)
+		mvOsSPrintf(buf, "L2 Write Allocate Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Write Allocate Enabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = 0;
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register */
+	if (regVal & BIT29)
+		mvOsSPrintf(buf, "CPU Streaming Enabled");
+	else
+		mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+	MV_U32 regVal = 0;
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register0 */
+	mvOsPrintf("Extra Features Reg[0] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (regVal));	/* Read Marvell extra features register1 */
+	mvOsPrintf("Extra Features Reg[1] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal));	/* Read Control register */
+	mvOsPrintf("Control Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal));	/* Read Main ID register */
+	mvOsPrintf("Main ID Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal));	/* Read Cache Type register */
+	mvOsPrintf("Cache Type Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	mvOsPrintf("L2 Control Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	mvOsPrintf("L2 Auxilary Control Reg = 0x%x\n", regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+	MV_U32 count = 0;
+
+	MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+	MV_8 L2_En_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+	MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+	MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Parity_str[MV_PROC_STR_SIZE];
+
+	mvCpuIfGetL2Mode(L2_En_str);
+	mvCpuIfGetL2EccMode(L2_ECC_str);
+	mvCpuIfGetL2ParityMode(L2_Parity_str);
+	mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+	mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+	mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+	mvCpuIfPrintCpuRegs();
+
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Parity_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+	return count;
+}
+
+/*******************************************************************************
+* whoAmI - Get the CPU ID
+*
+* DESCRIPTION:
+*       This function returns CPU ID in multiprocessor system
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       none.
+*
+* RETURN:
+*       CPU ID.
+*******************************************************************************/
+unsigned int whoAmI(void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPUID reg\n" : "=r"(value) : : "memory");
+	return (value & 0x7);
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.h b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.h
new file mode 100644
index 0000000..8eafae0
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/cpu/mvCpu.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#ifndef MV_ASMLANGUAGE
+#include "mvOs.h"
+#endif
+
+#define MASTER_CPU 0
+/* defines */
+#define CPU_PART_MRVL131                0x131
+#define CPU_PART_ARM926                 0x926
+#define CPU_PART_ARM946                 0x946
+#define CPU_PART_MRVL_A9                0xC09
+#define CPU_PART_MRVL571                0x571
+#define CPU_PART_MRVL521                0x521
+
+#define CPU_PART_ARM_V6UP               0xb76
+#define CPU_PART_ARM_V7UP               0xc08
+#define CPU_PART_ARM_CA9                0xc09
+#define CPU_PART_ARM_V6MP               0xb02
+
+#define CPU_PART_MRVLPJ4B_UP               0x581
+#define CPU_PART_MRVLPJ4B_MP               0x584
+
+#define MV_CPU_ARM_CLK_ELM_SIZE	    12
+#define MV_CPU_ARM_CLK_RATIO_OFF    8
+#define MV_CPU_ARM_CLK_DDR_OFF	    4
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClkRatio {
+	MV_U32	vco2cpu;	/* VCO:PCLK0(CPU) clock ratio */
+	MV_U32	vco2l2c;	/* VCO:NB(L2 cache) clock ratio */
+	MV_U32	vco2hcl;	/* VCO:HCLK(DDR controller) clock ratio */
+	MV_U32	vco2ddr;	/* VCO:DDR(DDR memory) clock ratio */
+
+} MV_CPU_ARM_CLK_RATIO;
+
+MV_U32  mvCpuPclkGet(MV_VOID);
+MV_VOID mvCpuNameGet(char *pNameBuff);
+MV_U32  mvCpuL2ClkGet(MV_VOID);
+MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+MV_U32  whoAmI(MV_VOID);
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.c
new file mode 100644
index 0000000..3c167fe
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -0,0 +1,363 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "sys/mvCpuIf.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* Default Attributes array */
+MV_TARGET_ATTRIB mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
+extern MV_TARGET sampleAtResetTargetArray[];
+
+/*******************************************************************************
+* mvCtrlAttribGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	targetAttrib->attrib = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib;
+	targetAttrib->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib  = targetAttrib->attrib;
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId= targetAttrib->targetId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlGetAttrib
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == targetAttrib->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == targetAttrib->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlTargetByWinInfoGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == unitWinInfo->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == unitWinInfo->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlAddrWinMapBuild
+*
+* DESCRIPTION:
+*	Build the windows address decoding table, to be used for initializing
+*	the unit's address decoding windows.
+*
+* INPUT:
+*	pAddrWinMap: An array to hold the address decoding windows parameters.
+*	len: Number of entries in pAddrWinMap.
+*
+* OUTPUT:
+*	pAddrWinMap: Address window information.
+*
+* RETURN:
+*	MV_BAD_PARAM: input array is smaller than needed to store all window
+*	addresses.
+*	MV_ERROR: Otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i, j;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+	MV_U64 startAddr, endAddr;
+	MV_UNIT_WIN_INFO ioDdrWin[4];
+	MV_U32 base;
+	MV_U64 size;
+
+	/* Check size of CPU address win table */
+	if (len <= MAX_TARGETS) {
+		mvOsPrintf("%s: Table size is too small.\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	/* Prepare an array of DRAM info */
+	base = 0x0;
+	j = 0;
+	for (i = SDRAM_CS0; i <= SDRAM_CS3; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK) {
+			if (status == MV_NO_SUCH) {
+				ioDdrWin[i].enable = MV_FALSE;
+				continue;
+			} else {
+				mvOsPrintf("%s: mvCpuIfTargetWinGet() failed.\n", __func__);
+				return MV_ERROR;
+			}
+		}
+
+		/* As all IO address decode windows support only 32-bit
+		** addresses, limit the DRAM base / size to 4GB max.
+		*/
+		startAddr = (MV_U64)((((MV_U64)cpuAddrDecWin.addrWin.baseHigh << 32ll)) +
+				(MV_U64)cpuAddrDecWin.addrWin.baseLow);
+		endAddr = (MV_U64)(startAddr + (MV_U64)cpuAddrDecWin.addrWin.size) - 1;
+		if (endAddr > 0xFFFFFFFFll) {
+			if (startAddr <= 0xFFFFFFFFll)
+				cpuAddrDecWin.addrWin.size = (0x100000000ll -
+						cpuAddrDecWin.addrWin.baseLow);
+			else
+				cpuAddrDecWin.enable = MV_FALSE;
+		}
+
+		if (cpuAddrDecWin.enable == MV_FALSE)
+			continue;
+
+		/* If the endAddr passes minBase, then we need to split
+		 * this window to several windows up to minBase.
+		 * For example: minBase=0xE0000000, and CS0=2, CS1=2G,
+		 * Then we need to split the windwos as follows:
+		 * Win0: CS-0, 2GB (Base 0x0)
+		 * win1: CS-1, 1GB (Base 0x80000000)
+		 * Win2: CS-1, 0.5GB (Base 0xC0000000)
+		 */
+		if (endAddr > MV_DRAM_IO_RESERVE_BASE)
+			/* Need to cut down this CS to IO reserve base
+			** address.
+			*/
+			size = MV_DRAM_IO_RESERVE_BASE -
+				cpuAddrDecWin.addrWin.baseLow;
+		else
+			size = cpuAddrDecWin.addrWin.size;
+
+		if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+			mvOsPrintf("%s: mvCtrlAttribGet() failed.\n", __func__);
+			return MV_ERROR;
+		}
+		/* Now, spread the last CS into several windows, and make sure
+		** that each of has a power-of-2 size.
+		*/
+		while (size != 0) {
+			ioDdrWin[j].enable = MV_TRUE;
+			ioDdrWin[j].attrib = targetAttrib.attrib;
+			ioDdrWin[j].targetId = targetAttrib.targetId;
+			ioDdrWin[j].addrWin.baseHigh = 0;
+			if (MV_IS_POWER_OF_2(size))
+				ioDdrWin[j].addrWin.size = size;
+			else
+				ioDdrWin[j].addrWin.size = (MV_U64)(1ll << (MV_U64)mvLog2(size));
+			size -= ioDdrWin[j].addrWin.size;
+			ioDdrWin[j].addrWin.baseLow = base;
+			base += ioDdrWin[j].addrWin.size;
+			j++;
+		}
+	}
+	
+	for (; j < 4; j++)
+		ioDdrWin[j].enable = MV_FALSE;
+
+	/* Fill in the pAddrWinMap fields       */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (MV_TARGET_IS_DRAM(i)) {
+			pAddrWinMap[i].addrWin.baseLow = ioDdrWin[i].addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh = ioDdrWin[i].addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size = ioDdrWin[i].addrWin.size;
+			pAddrWinMap[i].enable = ioDdrWin[i].enable;
+			pAddrWinMap[i].attrib = ioDdrWin[i].attrib;
+			pAddrWinMap[i].targetId = ioDdrWin[i].targetId;
+		} else {
+			status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+			if (status != MV_OK) {
+				if (status == MV_NO_SUCH) {
+					pAddrWinMap[i].enable = MV_FALSE;
+					continue;
+				} else {
+					mvOsPrintf("mvCtrlAddrWinMapBuild()"
+					" - mvCpuIfTargetWinGet() failed.\n");
+					return MV_ERROR;
+				}
+			}
+
+			pAddrWinMap[i].addrWin.baseLow =
+				cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh =
+				cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size =
+				cpuAddrDecWin.addrWin.size;
+			pAddrWinMap[i].enable = cpuAddrDecWin.enable;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+						"mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinMap[i].attrib = targetAttrib.attrib;
+			pAddrWinMap[i].targetId = targetAttrib.targetId;
+		}
+	}
+	pAddrWinMap[i].addrWin.baseLow = TBL_TERM;
+	pAddrWinMap[i].addrWin.baseHigh = TBL_TERM;
+	pAddrWinMap[i].addrWin.size = TBL_TERM;
+	pAddrWinMap[i].enable = TBL_TERM;
+	pAddrWinMap[i].attrib = TBL_TERM;
+	pAddrWinMap[i].targetId = TBL_TERM;
+
+	return MV_OK;
+}
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK)
+			continue;
+
+		if ((physAddr >= cpuAddrDecWin.addrWin.baseLow) &&
+		    (physAddr < cpuAddrDecWin.addrWin.baseLow + cpuAddrDecWin.addrWin.size)) {
+			/* Found */
+			pAddrWinInfo->addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinInfo->addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinInfo->addrWin.size = cpuAddrDecWin.addrWin.size;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinInfo->attrib = targetAttrib.attrib;
+			pAddrWinInfo->targetId = targetAttrib.targetId;
+			return MV_OK;
+		}
+	}
+
+	/* not found */
+	return MV_NOT_FOUND;
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.h
new file mode 100644
index 0000000..dcecd06
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAddrDech
+#define __INCmvCtrlEnvAddrDech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+
+/* defines  */
+/* DUnit attributes */
+#define ATMWCR_WIN_DUNIT_CS0_OFFS		0
+#define ATMWCR_WIN_DUNIT_CS0_MASK		BIT0
+#define ATMWCR_WIN_DUNIT_CS0_REQ		(0 << ATMWCR_WIN_DUNIT_CS0_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS1_OFFS		1
+#define ATMWCR_WIN_DUNIT_CS1_MASK		BIT1
+#define ATMWCR_WIN_DUNIT_CS1_REQ 		(0 << ATMWCR_WIN_DUNIT_CS1_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS2_OFFS		2
+#define ATMWCR_WIN_DUNIT_CS2_MASK		BIT2
+#define ATMWCR_WIN_DUNIT_CS2_REQ 		(0 << ATMWCR_WIN_DUNIT_CS2_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS3_OFFS		3
+#define ATMWCR_WIN_DUNIT_CS3_MASK		BIT3
+#define ATMWCR_WIN_DUNIT_CS3_REQ 		(0 << ATMWCR_WIN_DUNIT_CS3_OFFS)
+
+/* RUnit (Device)  attributes */
+#define ATMWCR_WIN_RUNIT_DEVCS0_OFFS		0
+#define ATMWCR_WIN_RUNIT_DEVCS0_MASK		BIT0
+#define ATMWCR_WIN_RUNIT_DEVCS0_REQ		(0 << ATMWCR_WIN_RUNIT_DEVCS0_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS1_OFFS		1
+#define ATMWCR_WIN_RUNIT_DEVCS1_MASK		BIT1
+#define ATMWCR_WIN_RUNIT_DEVCS1_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS1_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS2_OFFS		2
+#define ATMWCR_WIN_RUNIT_DEVCS2_MASK		BIT2
+#define ATMWCR_WIN_RUNIT_DEVCS2_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS2_OFFS)
+
+#define ATMWCR_WIN_RUNIT_BOOTCS_OFFS		4
+#define ATMWCR_WIN_RUNIT_BOOTCS_MASK		BIT4
+#define ATMWCR_WIN_RUNIT_BOOTCS_REQ 		(0 << ATMWCR_WIN_RUNIT_BOOTCS_OFFS)
+
+/* LMaster (PCI)  attributes */
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS		0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_MASK		BIT0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP		(0 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_BYTE_NO_SWP		(1 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+
+
+#define ATMWCR_WIN_LUNIT_WORD_SWP_OFFS		1
+#define ATMWCR_WIN_LUNIT_WORD_SWP_MASK		BIT1
+#define ATMWCR_WIN_LUNIT_WORD_SWP		(0 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_WORD_NO_SWP		(1 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+
+#define ATMWCR_WIN_LUNIT_NO_SNOOP		BIT2
+
+#define ATMWCR_WIN_LUNIT_TYPE_OFFS		3
+#define ATMWCR_WIN_LUNIT_TYPE_MASK		BIT3
+#define ATMWCR_WIN_LUNIT_TYPE_IO		(0 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+#define ATMWCR_WIN_LUNIT_TYPE_MEM		(1 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+
+#define ATMWCR_WIN_LUNIT_FORCE64_OFFS		4
+#define ATMWCR_WIN_LUNIT_FORCE64_MASK		BIT4
+#define ATMWCR_WIN_LUNIT_FORCE64		(0 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+#define ATMWCR_WIN_LUNIT_ORDERING_OFFS		6
+#define ATMWCR_WIN_LUNIT_ORDERING_MASK		BIT6
+#define ATMWCR_WIN_LUNIT_ORDERING		(1 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+/* PEX Attributes */
+#define ATMWCR_WIN_PEX_TYPE_OFFS		3
+#define ATMWCR_WIN_PEX_TYPE_MASK		BIT3
+#define ATMWCR_WIN_PEX_TYPE_IO			(0 << ATMWCR_WIN_PEX_TYPE_OFFS)
+#define ATMWCR_WIN_PEX_TYPE_MEM			(1 << ATMWCR_WIN_PEX_TYPE_OFFS)
+
+/* typedefs */
+
+/* Unsupported attributes for address decode:                               */
+/* 2) PCI0/1_REQ64n control                                                 */
+
+typedef struct _mvTargetAttrib {
+	MV_U8			attrib;			/* chip select attributes */
+	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
+} MV_TARGET_ATTRIB;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin {
+    MV_TARGET	target;         /* Target for addr decode window        */
+    MV_ADDR_WIN	addrWin;        /* Address window of target             */
+    MV_BOOL	enable;         /* Window enable/disable                */
+} MV_DEC_WIN;
+
+typedef struct _mvDecWinParams {
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+} MV_DEC_WIN_PARAMS;
+
+
+/* mvCtrlEnvAddrDec API list */
+
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo);
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, MV_DEC_WIN_PARAMS *pWinParam);
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, MV_DEC_WIN *pAddrDecWin);
+
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len);
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvCtrlEnvAddrDech */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAsm.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAsm.h
new file mode 100644
index 0000000..1a14a79
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAsmh
+#define __INCmvCtrlEnvAsmh
+#include "pex/mvPexRegs.h"
+
+#define CHIP_BOND_REG			0x18238
+#define PCKG_OPT_MASK_AS 		#3
+#define PXCCARI_REVID_MASK_AS		#PXCCARI_REVID_MASK
+
+/* Read device ID into toReg bits 15:0 from 0xd0000000 */
+/* defines  */
+#define MV_DV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_DV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read device ID into toReg bits 15:0 from 0xf1000000*/
+#define MV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read Revision into toReg bits 7:0 0xd0000000*/
+#define MV_DV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_DV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+/* Read Revision into toReg bits 7:0 0xf1000000*/
+#define MV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+#endif /* __INCmvCtrlEnvAsmh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100644
index 0000000..dc4959b
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,1564 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvSysEthConfig.h"
+
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+#include "eth/mvEth.h"
+#else
+#include "neta/gbe/mvNeta.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA */
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+#include "xor/mvXor.h"
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+#include "sata/CoreDriver/mvSata.h"
+#endif
+#if defined(MV_INCLUDE_USB)
+#include "usb/mvUsb.h"
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+#include "mvSysTdmConfig.h"
+#endif
+
+#include "ddr2_3/mvDramIfRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*
+ * Control Environment internal data structure
+ * Note: it should be initialized dynamically only once.
+ */
+#define MV_INVALID_CTRL_REV	0xff
+
+typedef struct _ctrlEnvInfo {
+	MV_U16	ctrlModel;
+	MV_U8	ctrlRev;
+} CTRL_ENV_INFO;
+
+CTRL_ENV_INFO ctrlEnvInfo = {};
+
+MV_U32 mvCtrlGetCpuNum(MV_VOID)
+{
+	return 0; /* kostaz: fix from cider */
+}
+
+MV_U32 mvCtrlGetQuadNum(MV_VOID)
+{
+	return 0; /* kostaz: fix */
+}
+
+MV_BOOL mvCtrlIsValidSatR(MV_VOID)
+{
+	return MV_FALSE;
+}
+
+#ifdef MV_INCLUDE_PEX
+MV_STATUS mvCtrlUpdatePexId(MV_VOID)
+{
+	return MV_ERROR;
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA_FPGA)
+	MV_U32 mppGroup;
+	MV_U32 mppVal;
+	MV_U32 i, gppMask;
+
+	/* Disable MBus Error Propagation */
+	MV_REG_BIT_RESET(SOC_COHERENCY_FABRIC_CTRL_REG, BIT8);
+
+	/* Use Background sync barrier (polling) for I/O cache coherency */
+	MV_REG_BIT_SET(SOC_CIB_CTRL_CFG_REG, BIT8);
+
+	/* MPP Init - scan which modeule is connected */
+	mvBoardMppModulesScan();
+
+	/* Read MPP config values from board level and write MPP options to HW */
+	for (mppGroup = 0; mppGroup < MV_MPP_MAX_GROUP; mppGroup++) {
+		mppVal = mvBoardMppGet(mppGroup);	/* get pre-defined values */
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+	/* disable all GPIO interrupts */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+	}
+
+	/* clear all int */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++)
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+
+	/* Set gpp interrupts as needed */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		gppMask = mvBoardGpioIntMaskGet(i);
+		mvGppTypeSet(i, gppMask , (MV_GPP_IN & gppMask));
+		mvGppPolaritySet(i, gppMask , (MV_GPP_IN_INVERT & gppMask));
+	}
+
+	/* Scan for other modules (SERDES/LVDS/...) */
+	mvBoardOtherModulesScan();
+
+	/* Update interfaces configuration based on above scan */
+	if (MV_OK != mvCtrlSerdesPhyConfig())
+		mvOsPrintf("%s: Can't init some or all SERDES lanes\n", __func__);
+
+	mvOsDelay(100);
+#endif
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+	MV_U32 ret;
+
+	if (mppGroup >= MV_MPP_MAX_GROUP)
+		mppGroup = 0;
+
+	ret = MPP_CONTROL_REG(mppGroup);
+
+	return ret;
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
+{
+	return 1;
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlPexMaxUnitGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxUnitGet(MV_VOID)
+{
+	return 1;
+}
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCtrlPciMaxIfGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+#ifndef mvCtrlPciMaxIfGet
+MV_U32 mvCtrlPciMaxIfGet(MV_VOID)
+{
+	return 1;
+}
+#endif
+#endif
+
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+	switch (devId) {
+	case MV_FPGA_DEV_ID:
+		return MV_FPGA_ETH_MAX_PORT;
+	default:
+		return 0;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlEthMaxCPUsGet - Get Marvell controller number of CPUs.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of CPUs.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of CPUs.
+*
+*******************************************************************************/
+MV_U8 mvCtrlEthMaxCPUsGet(MV_VOID)
+{
+	return 1;
+}
+
+#if defined(MV_INCLUDE_SATA)
+/*******************************************************************************
+* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of Sata ports.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of Sata ports.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
+{
+	return 0;
+}
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+/*******************************************************************************
+* mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
+{
+	return 0;
+}
+
+/*******************************************************************************
+* mvCtrlXorMaxUnitGet - Get Marvell controller number of XOR units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
+{
+	return 0;
+}
+
+#endif
+
+#if defined(MV_INCLUDE_USB)
+/*******************************************************************************
+* mvCtrlUsbHostMaxGet - Get number of Marvell Usb  controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB  controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsbMaxGet(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND)
+/*******************************************************************************
+* mvCtrlNandSupport - Return if this controller has integrated NAND flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if NAND is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlNandSupport(MV_VOID)
+{
+	return 0; /* kostaz: what's that ??? */
+}
+#endif
+
+#if defined(MV_INCLUDE_SDIO)
+/*******************************************************************************
+* mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SDIO is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlSdioSupport(MV_VOID)
+{
+	return 0; /* kostaz: what's that ??? */
+}
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmSupport(MV_VOID)
+{
+	return 0; /* kostaz: what's that ??? */
+}
+
+/*******************************************************************************
+* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       The number of TDM ports in device.
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmMaxGet(MV_VOID)
+{
+	return 0; /* kostaz: what's that ??? */
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitTypeGet
+*
+* DESCRIPTION:
+*	Return the TDM unit type being compiled in.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TDM unit type.
+*
+*******************************************************************************/
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID)
+{
+	return TDM_UNIT_32CH; /* kostaz: FIXME */
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitIrqGet
+*
+* DESCRIPTION:
+*	Return the TDM unit IRQ number depending on the TDM unit compilation
+*	options.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+******************************************************************************/
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
+{
+	return MV_TDM_IRQ_NUM;
+}
+#endif /* MV_INCLUDE_TDM */
+
+/*******************************************************************************
+* mvCtrlModelGet - Get Marvell controller device model (Id)
+*
+* DESCRIPTION:
+*       This function returns 16bit describing the device model (ID) as defined
+*       in PCI Device and Vendor ID configuration register offset 0x0.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit desscribing Marvell controller ID
+*
+*******************************************************************************/
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	MV_U32 devId, reg, reg2;
+	CTRL_ENV_INFO *ci = &ctrlEnvInfo;
+
+	if (ci->ctrlModel != MV_INVALID_DEV_ID)
+		return ci->ctrlModel;
+
+	/* If PEX0 clock is disabled - enable it to read */
+	reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
+		reg2 = ((reg & ~PMC_PEXSTOPCLOCK_MASK(0)) | PMC_PEXSTOPCLOCK_EN(0));
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg2);
+	}
+
+	devId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+
+	/* Set PEX0 clock to original state */
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg);
+
+	ci->ctrlModel = (MV_U16) ((devId >> 16) & 0xFFFF);
+	return ci->ctrlModel;
+}
+
+/*******************************************************************************
+* mvCtrlRevGet - Get Marvell controller device revision number
+*
+* DESCRIPTION:
+*       This function returns 8bit describing the device revision as defined
+*       in PCI Express Class Code and Revision ID Register.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit desscribing Marvell controller revision number
+*
+*******************************************************************************/
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	CTRL_ENV_INFO *ci = &ctrlEnvInfo;
+	MV_U8 revNum;
+
+	if (ci->ctrlRev != MV_INVALID_CTRL_REV)
+		return ci->ctrlRev;
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Check pex power state */
+	MV_U32 pexPower;
+	pexPower = mvCtrlPwrClckGet(PEX_UNIT_ID, 0);
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_TRUE);
+#endif
+
+	revNum = (MV_U8)MV_REG_READ(PEX_CFG_DIRECT_ACCESS(
+				0, PCI_CLASS_CODE_AND_REVISION_ID));
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Return to power off state */
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_FALSE);
+#endif
+
+	ci->ctrlRev = ((revNum & PCCRIR_REVID_MASK) >> PCCRIR_REVID_OFFS);
+	return ci->ctrlRev;
+}
+
+/*******************************************************************************
+* mvCtrlNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlNameGet(char *pNameBuff)
+{
+	if (mvCtrlModelGet() == 0x7800)
+		mvOsSPrintf(pNameBuff, "%s78XX", SOC_NAME_PREFIX);
+	else
+		mvOsSPrintf(pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX, mvCtrlModelGet(), mvCtrlRevGet());
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlModelRevGet - Get Controller Model (Device ID) and Revision
+*
+* DESCRIPTION:
+*       This function returns 32bit value describing both Device ID and Revision
+*       as defined in PCI Express Device and Vendor ID Register and device revision
+*	    as defined in PCI Express Class Code and Revision ID Register.
+
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing both controller device ID and revision number
+*
+*******************************************************************************/
+MV_U32 mvCtrlModelRevGet(MV_VOID)
+{
+	return ((mvCtrlModelGet() << 16) | mvCtrlRevGet());
+}
+
+/*******************************************************************************
+* mvCtrlModelRevNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
+{
+	switch (mvCtrlModelRevGet()) {
+	case MV_78130_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78130_Z1_NAME);
+		break;
+	default:
+		mvCtrlNameGet(pNameBuff);
+	}
+
+	return MV_OK;
+}
+
+static const char *cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
+{
+	if (target >= MAX_TARGETS)
+		return "target unknown";
+
+	return cntrlName[target];
+}
+
+/*******************************************************************************
+* mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
+*
+* DESCRIPTION:
+*		This function print the PEX address decode map (BARs and windows).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+#if defined(MV_INCLUDE_PEX)
+static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
+{
+	/* kostaz: FIXME: will be filled for AvantaLP */
+}
+#endif
+
+/*******************************************************************************
+* mvUnitAddrDecShow - Print the Unit's address decode map.
+*
+* DESCRIPTION:
+*       This is a generic function for printing the different unit's address
+*	decode map.
+*
+* INPUT:
+*       unit	- The unit to print the address decode for.
+*	name	- The unit's name.
+*	winGetFuncPtr - A pointer to the HAL's window get function.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId,
+			      const char *name, MV_WIN_GET_FUNC_PTR winGetFuncPtr)
+{
+	MV_UNIT_WIN_INFO win;
+	MV_U32 unit, i;
+
+	for (unit = 0; unit < numUnits; unit++) {
+
+		if (MV_FALSE == mvCtrlPwrClckGet(unitId, unit))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("%s %d:\n", name, unit);
+		mvOsOutput("----\n");
+
+		for (i = 0; i < 16; i++) {
+			memset(&win, 0, sizeof(MV_UNIT_WIN_INFO));
+
+			mvOsOutput("win%d - ", i);
+
+			if (winGetFuncPtr(unit, i, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win)),
+						   win.addrWin.baseLow);
+					mvOsOutput("....");
+					if (win.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCtrlAddrDecShow - Print the Controller units address decode map.
+*
+* DESCRIPTION:
+*		This function the Controller units address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlAddrDecShow(MV_VOID)
+{
+	mvCpuIfAddDecShow();
+	mvAhbToMbusAddDecShow();
+#if defined(MV_INCLUDE_PEX)
+	mvCtrlPexAddrDecShow();
+#endif
+#if defined(MV_INCLUDE_USB)
+	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
+#endif
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#else
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
+#endif /* MV_ETH_LEGACY */
+#endif /* MV_INCLUDE_GIG_ETH */
+
+#if defined(MV_INCLUDE_XOR)
+	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
+#endif
+#if defined(MV_INCLUDE_SATA)
+	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
+#endif
+}
+
+/*******************************************************************************
+* ctrlSizeToReg - Extract size value for register assignment.
+*
+* DESCRIPTION:
+*       Address decode size parameter must be programed from LSB to MSB as
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
+*       value of 0x00ff specifies 256x64k = 16 MB).
+*       This function extract the size value from the size parameter according
+*       to given aligment paramter. For example for size 0x1000000 (16MB) and
+*       aligment 0x10000 (64KB) the function will return 0x00FF.
+*
+* INPUT:
+*       size - Size.
+*       alignment - Size alignment. Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size register value correspond to size parameter.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 retVal;
+
+	/* Check size parameter alignment               */
+	if ((0 == size) || (MV_IS_NOT_ALIGN(size, alignment))) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
+		return -1;
+	}
+
+	/* Take out the "alignment" portion out of the size parameter */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+	/* and size is 0x1000000 (16MB) for example     */
+	while (alignment & 1) {	/* Check that alignmet LSB is set       */
+		size = (size >> 1);	/* If LSB is set, move 'size' one bit to right      */
+		alignment = (alignment >> 1);
+	}
+
+	/* If after the alignment first '0' was met we still have '1' in                */
+	/* it then aligment is invalid (not power of 2)                                 */
+	if (alignment) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", (MV_U32) alignment));
+		return -1;
+	}
+
+	/* Now the size is shifted right according to aligment: 0x0100                  */
+	size--;			/* Now the size is a sequance of '1': 0x00ff                    */
+	retVal = size;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	while (size & 1)	/* Check that LSB is set    */
+		size = (size >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (size) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", size));
+		return -1;
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+* ctrlRegToSize - Extract size value from register value.
+*
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*       according to given aligment paramter. For example for register size
+*       value 0xff and aligment 0x10000 the function will return 0x01000000.
+*
+* INPUT:
+*       regSize   - Size as in register format.	See ctrlSizeToReg.
+*       alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
+{
+	MV_U32 temp;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff            */
+
+	while (temp & 1)	/* Check that LSB is set                                    */
+		temp = (temp >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (temp) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("%s: ERR: Size parameter 0x%x invalid.\n", __func__, regSize));
+		return -1;
+	}
+
+	/* Check that aligment is a power of two                                        */
+	temp = alignment - 1;	/* Now the alignmet is a sequance of '1' (0xffff)          */
+
+	while (temp & 1)	/* Check that alignmet LSB is set                           */
+		temp = (temp >> 1);	/* If LSB is set, move 'size' one bit to right      */
+
+	/* If after the 'temp' first '0' was met we still have '1' in 'temp'            */
+	/* then 'temp' is invalid (not power of 2)                                      */
+	if (temp) {
+		DB(mvOsPrintf("%s: ERR: Alignment parameter 0x%x invalid.\n", __func__, alignment));
+		return -1;
+	}
+
+	regSize++;		/* Now the size is 0x0100                                       */
+
+	/* Add in the "alignment" portion to the register size parameter                */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+
+	while (alignment & 1) {	/* Check that alignmet LSB is set                       */
+		regSize = (regSize << 1);	/* LSB is set, move 'size' one bit left     */
+		alignment = (alignment >> 1);
+	}
+
+	return regSize;
+}
+
+/*******************************************************************************
+* ctrlSizeRegRoundUp - Round up given size
+*
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
+*       restrictions of size format given an aligment parameter.
+*		to given aligment paramter. For example for size parameter 0xa1000 and
+*		aligment 0x1000 the function will return 0xFF000.
+*
+* INPUT:
+*       size - Size.
+*		alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size value correspond to size in register.
+*******************************************************************************/
+MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment) /* kostaz: FIXME: remove unused */
+{
+	MV_U32 msbBit = 0;
+	MV_U32 retSize;
+
+	/* Check if size parameter is already comply with restriction   */
+	if (!(-1 == ctrlSizeToReg(size, alignment)))
+		return size;
+
+	while (size) {
+		size = (size >> 1);
+		msbBit++;
+	}
+
+	retSize = (1 << msbBit);
+
+	if (retSize < alignment)
+		return alignment;
+	else
+		return retSize;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNOR
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from NOR flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID)
+{
+	return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromSPI
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from SPI flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNAND
+*
+* DESCRIPTION:
+*       Check if device is confiogured to boot from NAND flash according to the SAR
+*	registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from NAND.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID)
+{
+	return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckSet - Set Power State for specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	/* kostaz: FIXME: verify 0x18220 is not changed */
+
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+
+		break;
+#endif
+	case TDM_32CH_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrClckGet - Get Power State of specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	MV_BOOL state = MV_TRUE;
+
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if ((reg & PMC_PEXSTOPCLOCK_MASK(index)) == PMC_PEXSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if ((reg & PMC_GESTOPCLOCK_MASK(index)) == PMC_GESTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		if ((reg & PMC_SATASTOPCLOCK_MASK(index)) == PMC_SATASTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((reg & PMC_CESASTOPCLOCK_MASK) == PMC_CESASTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if ((reg & PMC_USBSTOPCLOCK_MASK(index)) == PMC_USBSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if ((reg & PMC_SDIOSTOPCLOCK_MASK) == PMC_SDIOSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TDM)
+	case TDM_32CH_UNIT_ID:
+		if ((reg & PMC_TDMSTOPCLOCK_MASK) == PMC_TDMSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemSet - Set Power State for memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_MASK);
+
+		break;
+#endif
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemGet - Get Power State of memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg;
+	MV_BOOL state = MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX));
+		if ((reg & PMC_PEXSTOPMEM_MASK(index)) == PMC_PEXSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE));
+		if ((reg & PMC_GESTOPMEM_MASK(index)) == PMC_GESTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA));
+		if ((reg & PMC_SATASTOPMEM_MASK(index)) == PMC_SATASTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA));
+		if ((reg & PMC_CESASTOPMEM_MASK) == PMC_CESASTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB));
+		if ((reg & PMC_USBSTOPMEM_MASK(index)) == PMC_USBSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR));
+		if ((reg & PMC_XORSTOPMEM_MASK(index)) == PMC_XORSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM));
+		if ((reg & PMC_BMSTOPMEM_MASK) == PMC_BMSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC));
+		if ((reg & PMC_PNCSTOPMEM_MASK) == PMC_PNCSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+#else
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	return;
+}
+
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	return MV_TRUE;
+}
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+/*******************************************************************************
+* mvCtrlSerdesMaxLinesGet - Get Marvell controller number of SERDES lines.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID)
+{
+	return 0;
+}
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x1400);
+
+	return (reg & 0x8000) ? 64 : 32;
+}
+
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x20184);
+
+	return (reg & 0x1) ? MV_FALSE : MV_TRUE;
+}
+
+MV_BOOL mvCtrlDDRECC(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_ECC_OFFS)) ? MV_TRUE : MV_FALSE;
+}
+
+static const MV_U8 serdesCfg[][8] = SERDES_CFG;
+
+/*******************************************************************************
+* mvCtrlSerdesPhyConfig
+*
+* DESCRIPTION:
+*	Configure Serdes MUX and init PHYs connected to SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Status
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
+{
+	return MV_ERROR;
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100644
index 0000000..b9493e0
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,279 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+/* includes */
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* 0 for Auto scan mode, 1 for manual. */
+#define MV_INTERNAL_SWITCH_SMI_SCAN_MODE	0
+
+/* typedefs */
+typedef MV_STATUS(*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+/* This enumerator describes the possible HW cache coherency policies the   */
+/* controllers supports.                                                    */
+typedef enum _mvCachePolicy {
+    NO_COHERENCY,   /* No HW cache coherency support                        */
+    WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
+    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
+} MV_CACHE_POLICY;
+
+
+/* The swapping is referred to a 64-bit words (as this is the controller    */
+/* internal data path width). This enumerator describes the possible        */
+/* data swap types. Below is an example of the data 0x0011223344556677      */
+typedef enum _mvSwapType {
+    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */
+    MV_NO_SWAP,         /* No swapping              00 11 22 33 44 55 66 77 */
+    MV_BYTE_WORD_SWAP,  /* Both byte and word swap  33 22 11 00 77 66 55 44 */
+    MV_WORD_SWAP,       /* Word swap                44 55 66 77 00 11 22 33 */
+    SWAP_TYPE_MAX	/* Delimiter for this enumerator                    */
+} MV_SWAP_TYPE;
+
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7,
+	SERDES_UNIT_LAST
+} MV_SERDES_UNIT_INDX;
+
+typedef enum {
+	PEX_BUS_DISABLED	= 0,
+	PEX_BUS_MODE_X1		= 1,
+	PEX_BUS_MODE_X4		= 2,
+	PEX_BUS_MODE_X8		= 3
+} MV_PEX_UNIT_CFG;
+
+/* Configuration per SERDES line.
+   Each nibble is MV_SERDES_LINE_TYPE */
+typedef struct _boardSerdesConf {
+	MV_U32 enableSerdesConfiguration; /*This will determine if mvCtrlSerdesPhyConfig will configure the serdes*/
+	MV_U32	serdesLine0_7;	/* Lines 0 to 7 SERDES MUX one nibble per line */
+	MV_U32	serdesLine8_15;	/* Lines 8 to 15 SERDES MUX one nibble per line */
+	MV_PEX_UNIT_CFG		pex0Mod;
+	MV_PEX_UNIT_CFG		pex1Mod;
+	MV_PEX_UNIT_CFG		pex2Mod;
+	MV_PEX_UNIT_CFG		pex3Mod;
+	MV_U32	busSpeed;	/* Bus speed - one bit per SERDES line:
+	Low speed (0)		High speed (1)
+	PEX	2.5 G (10 bit)		5 G (20 bit)
+	SATA	1.5 G			3 G
+	SGMII 	1.25 Gbps		3.125 Gbps	*/
+} MV_SERDES_CFG;
+
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG					0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+
+/* BIOS Modes related defines */
+#define SAR0_CPU_FREQ_MASK	0x00E00000
+#define SAR0_CPU_FREQ_OFFSET	21
+#define SAR0_FABRIC_FREQ_MASK	0x0F000000
+#define SAR0_FABRIC_FREQ_OFFSET	24
+#define SAR0_L2_SIZE_MASK	0x00180000
+#define SAR0_L2_SIZE_OFFSET	19
+#define SAR0_BOOTSRC_MASK	0X1E0
+#define SAR0_BOOTSRC_OFFSET	5
+#define SAR0_BOOTWIDTH_MASK	0X18
+#define SAR0_BOOTWIDTH_OFFSET	3
+#define SAR0_CPU0CORE_MASK	0X80000000
+#define SAR0_CPU0CORE_OFFSET	31
+#define PEX_CLK_100MHZ_MASK    0x00000004
+#define PEX_CLK_100MHZ_OFFSET  2
+#define SAR1_CPU0CORE_MASK	0x1
+#define SAR1_CPU0CORE_OFFSET	0
+#define SAR1_CPU_CORE_MASK	0x00000018
+#define SAR1_CPU_CORE_OFFSET	3
+#define SAR1_CPU_MODE_MASK	0x00100000
+#define SAR1_CPU_MODE_OFFSET	20
+#define SAR1_FABRIC_MODE_MASK	0x00080000
+#define SAR1_FABRIC_MODE_OFFSET	19
+
+#define SAR_CPU_FAB_GET(cpu, fab)	(((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+#ifdef MV88F78X60_Z1
+#define BIOS_MODES_NUM			7
+#else
+#define BIOS_MODES_NUM			6
+#endif
+
+typedef struct {
+	char *name;
+	MV_U16 confId;
+	MV_U16 code;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreq;
+#ifndef MV88F78X60_Z1
+	MV_U8 AltfabricFreq;
+#endif
+	MV_U8 fabricFreqMode;
+	MV_U8 cpuEna;
+#ifdef MV88F78X60_Z1
+	MV_U8 cpuMode;
+#else
+	MV_U8 cpuEndianess;
+#endif
+	MV_U8 dramBusWidth;
+	MV_U8 bootSource;
+	MV_U8 bootWidth;
+} MV_BIOS_MODE;
+
+extern MV_BIOS_MODE bios_modes[];
+extern MV_BIOS_MODE bios_modes_b0[];
+
+/* mcspLib.h API list */
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_U32 mvCtrlGetQuadNum(MV_VOID);
+MV_STATUS mvCtrlUpdatePexId(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32	mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32	mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPciMaxIfGet()		1
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+#define mvCtrlPciIfMaxIfGet()		1
+#else
+#define mvCtrlPciIfMaxIfGet()		0
+#endif
+
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+MV_U32	  mvCtrlNandSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32	  mvCtrlSdioSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
+#endif
+
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID   mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32	  ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32	  ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32	  ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32	  mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_VOID   mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_BOOL	  mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index);
+
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID);
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID);
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100644
index 0000000..cdf83ec
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,589 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0 	PEX0_MEM
+#define PCI0_MEM0	PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID		0x008
+#define PCCRIR_REVID_OFFS			0		/* Revision ID */
+#define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM				56
+
+
+/* Coherent Fabric Control and Status */
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/* PMU_NFABRIC PMU_NFABRIC PMU_UNIT_SERVICE Units */
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_REG		(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x4)
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_PWR_DOWN	(1 << 20)
+
+#define MV_L2C_NFABRIC_PWR_DOWN_FLOW_CTRL_REG	(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x8)
+
+#define PM_CONTROL_AND_CONFIG_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x4)
+#define PM_CONTROL_AND_CONFIG_DFS_REQ		(1 << 18)
+#define PM_CONTROL_AND_CONFIG_PWDDN_REQ		(1 << 16)
+#define PM_CONTROL_AND_CONFIG_L2_PWDDN		(1 << 20)
+
+#define PM_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0xc)
+#define PM_STATUS_AND_MASK_CPU_IDLE_WAIT	(1 << 16)
+#define PM_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT	(1 << 17)
+#define PM_STATUS_AND_MASK_IRQ_WAKEUP		(1 << 20)
+#define PM_STATUS_AND_MASK_FIQ_WAKEUP		(1 << 21)
+#define PM_STATUS_AND_MASK_DBG_WAKEUP		(1 << 22)
+#define PM_STATUS_AND_MASK_IRQ_MASK		(1 << 24)
+#define PM_STATUS_AND_MASK_FIQ_MASK		(1 << 25)
+
+#define PM_EVENT_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x20)
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_OFFS			1
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_MASK_OFFS		17
+
+#define PM_CPU_BOOT_ADDR_REDIRECT(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x24)
+
+/* Power Management Memory Power Down Registers 1 - 6 */
+#define POWER_MNG_MEM_CTRL_REG(num)		((num) < 6 ? 0x1820C + (num) * 4 : 0x18228)
+#define PMC_MCR_NUM_COMM			6
+#define PMC_MCR_NUM_PEX				2
+#define PMC_MCR_NUM_USB				4
+#define PMC_MCR_NUM_DUNIT			3
+#define PMC_MCR_NUM_DEVB			4
+#define PMC_MCR_NUM_NF				4
+#define PMC_MCR_NUM_XOR				4
+#define PMC_MCR_NUM_SATA			5
+#define PMC_MCR_NUM_CESA			4
+#define PMC_MCR_NUM_GE				5
+#define PMC_MCR_NUM_PNC				5
+#define PMC_MCR_NUM_BM				5
+#define PMC_MCR_NUM_PDMA			1
+#define PMC_MCR_NUM_NCS				3
+#define PMC_MCR_NUM_CFU				3
+#define PMC_MCR_NUM_L2				3
+#define PMC_MCR_NUM_CIB				3
+#define PMC_MCR_NUM_CPU				3
+#define PMC_MCR_NUM_IDMA			4
+#define PMC_MCR_NUM_LCD				4
+#define PMC_MCR_NUM_PMU				6
+
+#define PMC_COMMSTOPMEM_OFFS			4
+#define PMC_COMMSTOPMEM_MASK			(7 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_EN			(0 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_STOP			(1 << PMC_COMMSTOPMEM_OFFS)
+
+#define PMC_PEXSTOPMEM_OFFS(port)		((port) < 10 ? ((port) * 3) : 0)
+#define PMC_PEXSTOPMEM_MASK(port)		(7 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_EN(port)			(0 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_STOP(port)		(1 << PMC_PEXSTOPMEM_OFFS(port))
+
+#define PMC_USBSTOPMEM_OFFS(port)		((port) < 3 ? (3 + (port) * 3) : 0)
+#define PMC_USBSTOPMEM_MASK(port)		(7 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_EN(port)			(0 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_STOP(port)		(1 << PMC_USBSTOPMEM_OFFS(port))
+
+#define PMC_DUNITSTOPMEM_OFFS			12
+#define PMC_DUNITSTOPMEM_MASK			(7 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_EN			(0 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_STOP			(1 << PMC_DUNITSTOPMEM_OFFS)
+
+#define PMC_NFSTOPMEM_OFFS			27
+#define PMC_NFSTOPMEM_MASK			(7 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_EN			(0 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_STOP			(1 << PMC_NFSTOPMEM_OFFS)
+
+#define PMC_DEVBSTOPMEM_OFFS			21
+#define PMC_DEVBSTOPMEM_MASK			(7 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_EN			(0 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_STOP			(1 << PMC_DEVBSTOPMEM_OFFS)
+
+#define PMC_XORSTOPMEM_OFFS(port)		((port) == 0 ? 15 : 24)
+#define PMC_XORSTOPMEM_MASK(port)		(7 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_EN(port)			(0 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_STOP(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+
+#define PMC_SATASTOPMEM_OFFS(port)		((port) == 0 ? 18 : 24)
+#define PMC_SATASTOPMEM_MASK(port)		(0x3F << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_EN(port)		(0 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_STOP(port)		(9 << PMC_SATASTOPMEM_OFFS(port))
+
+#define PMC_CESASTOPMEM_OFFS			18
+#define PMC_CESASTOPMEM_MASK			(7 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_EN			(0 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_STOP			(1 << PMC_CESASTOPMEM_OFFS)
+
+#define PMC_GESTOPMEM_OFFS(port)		((port) < 4 ? (9 - (port) * 3) : 0)
+#define PMC_GESTOPMEM_MASK(port)		(7 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_EN(port)			(0 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_STOP(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+
+#define PMC_PNCSTOPMEM_OFFS			12
+#define PMC_PNCSTOPMEM_MASK			(7 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_EN			(0 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_STOP			(1 << PMC_PNCSTOPMEM_OFFS)
+
+#define PMC_BMSTOPMEM_OFFS			15
+#define PMC_BMSTOPMEM_MASK			(7 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_EN			(0 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_STOP			(1 << PMC_BMSTOPMEM_OFFS)
+
+#define PMC_PDMASTOPMEM_OFFS			0
+#define PMC_PDMATOPMEM_MASK			(7 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_EN			(0 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_STOP			(1 << PMC_PDMASTOPMEM_OFFS)
+
+#define PMC_NCSSTOPMEM_OFFS			24
+#define PMC_NCSSTOPMEM_MASK			(7 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_EN			(0 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_STOP			(1 << PMC_NCSSTOPMEM_OFFS)
+
+#define PMC_CFUSTOPMEM_OFFS			21
+#define PMC_CFUSTOPMEM_MASK			(7 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_EN			(0 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_STOP			(1 << PMC_CFUSTOPMEM_OFFS)
+
+#define PMC_L2STOPMEM_OFFS			18
+#define PMC_L2STOPMEM_MASK			(7 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_EN			(0 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_STOP			(1 << PMC_L2STOPMEM_OFFS)
+
+#define PMC_CIBSTOPMEM_OFFS			15
+#define PMC_CIBSTOPMEM_MASK			(7 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_EN			(0 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_STOP			(1 << PMC_CIBSTOPMEM_OFFS)
+
+/* TODO - verify, the manual has no description */
+#define PMC_CPUSTOPMEM_OFFS(id)			((id) < 4 ? (id) * 3 : 0)
+#define PMC_CPUSTOPMEM_MASK(id)			(7 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
+
+#define PMC_IDMASTOPMEM_OFFS			12
+#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
+
+#define PMC_LCDSTOPMEM_OFFS			0
+#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
+
+#define PMC_PMUSTOPMEM_OFFS			0
+#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
+
+
+/*  Power Management Clock Gating Control Register	*/
+#define POWER_MNG_CTRL_REG			0x18220
+#define L2C_MTCMOS_CONTROL_0_REG    0x22F00
+#define L2C_MTCMOS_CONTROL_1_REG    0x22F04
+
+#define PMU_DFS_CTRL_REG(cpu)			(MV_RUNIT_PMU_REGS_OFFSET + 0x54 + ((cpu) * 0x4))
+#define PMU_DFS_CTRL_INIT_RATIO_OFFS	24
+#define PMU_DFS_CTRL_INIT_RATIO_MASK	0x3F
+#define PMU_DFS_CTRL_RATIO_OFFS			16
+#define PMU_DFS_CTRL_RATIO_MASK			0x3F
+
+#define PMC_TDMSTOPCLOCK_OFFS			25
+#define PMC_TDMSTOPCLOCK_MASK			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_EN			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_STOP			(0 << PMC_TDMSTOPCLOCK_OFFS)
+
+#define PMC_PEXSTOPCLOCK_OFFS(port)		((port) < 8 ? (5 + (port)) : (18 + (port)))
+#define PMC_PEXSTOPCLOCK_MASK(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_EN(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_STOP(port)		(0 << PMC_PEXSTOPCLOCK_OFFS(port))
+
+#define PMC_USBSTOPCLOCK_OFFS(port)		((port) < 3 ? (18 + (port)) : 0)
+#define PMC_USBSTOPCLOCK_MASK(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_EN(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_STOP(port)		(0 << PMC_USBSTOPCLOCK_OFFS(port))
+
+#define PMC_SDIOSTOPCLOCK_OFFS			17
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_RUNITSTOPCLOCK_OFFS			24
+#define PMC_RUNITSTOPCLOCK_MASK			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_EN			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_STOP			(0 << PMC_RUNITSTOPCLOCK_OFFS)
+
+#define PMC_XORSTOPCLOCK_OFFS			22
+#define PMC_XORSTOPCLOCK_MASK			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_EN			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_STOP			(0 << PMC_XORSTOPCLOCK_OFFS)
+
+#define PMC_SATASTOPCLOCK_OFFS(ch)		(ch == 0 ? 14 : 29)
+#define PMC_SATASTOPCLOCK_MASK(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_EN(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_STOP(ch)		(0 << PMC_SATASTOPCLOCK_OFFS(ch))
+
+#define PMC_CESASTOPCLOCK_OFFS			23
+#define PMC_CESASTOPCLOCK_MASK			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_EN			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_STOP			(0 << PMC_CESASTOPCLOCK_OFFS)
+
+#define PMC_GESTOPCLOCK_OFFS(port)		((port) < 4 ? (4 - (port)) : 0)
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+#define PMC_NETASTOPCLOCK_OFFS			13
+#define PMC_NETASTOPCLOCK_MASK			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_EN			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_STOP			(0 << PMC_NETASTOPCLOCK_OFFS)
+
+#define PMC_LCDSTOPCLOCK_OFFS			16
+#define PMC_LCDSTOPCLOCK_MASK			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_EN			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_STOP			(0 << PMC_LCDSTOPCLOCK_OFFS)
+
+#define PMC_IDMASTOPCLOCK_OFFS			21
+#define PMC_IDMASTOPCLOCK_MASK			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_EN			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_STOP			(0 << PMC_IDMASTOPCLOCK_OFFS)
+
+#define PMC_DDRSTOPCLOCK_OFFS			28
+#define PMC_DDRSTOPCLOCK_MASK			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_EN			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_STOP			(0 << PMC_DDRSTOPCLOCK_OFFS)
+
+#define SATA_IMP_TX_SSC_CTRL_REG(port)		(0xA2810 + (port)*0x2000)
+#define SATA_GEN_1_SET_0_REG(port)			(0xA2834 + (port)*0x2000)
+#define SATA_GEN_1_SET_1_REG(port)			(0xA2838 + (port)*0x2000)
+#define SATA_GEN_2_SET_0_REG(port)			(0xA283C + (port)*0x2000)
+#define SATA_GEN_2_SET_1_REG(port)			(0xA2840 + (port)*0x2000)
+
+#define SATA_PWR_PLL_CTRL_REG(port)			(0xA2804 + (port)*0x2000)
+#define SATA_DIG_LP_ENA_REG(port)			(0xA288C + (port)*0x2000)
+#define SATA_REF_CLK_SEL_REG(port)			(0xA2918 + (port)*0x2000)
+#define SATA_COMPHY_CTRL_REG(port)			(0xA2920 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_CTRL_REG(port)		(0xA2058 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_STAT_REG(port)		(0xA205C + (port)*0x2000)
+
+#define SGMII_PWR_PLL_CTRL_REG(port)		(0x72E04 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_DIG_LP_ENA_REG(port)		(0x72E8C + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_REF_CLK_SEL_REG(port)		(0x72F18 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_CFG_REG(port)		(0x724A0 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_STAT_REG(port)		(0x724A4 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_COMPHY_CTRL_REG(port)		(0x72F20 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define QSGMII_GEN_1_SETTING_REG(port)		(0x72E38 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+
+#define SERDES_LINE_MUX_REG_0_7			0x18270
+#define SERDES_LINE_MUX_REG_8_15		0x18274
+#define QSGMII_CONTROL_1_REG                    0x18404
+/* Controler environment registers offsets */
+#define GEN_PURP_RES_1_REG			0x182F4
+#define GEN_PURP_RES_2_REG			0x182F8
+
+#define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
+
+/* Sample at Reset */
+#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
+
+/* SYSRSTn Length Counter */
+#define SYSRST_LENGTH_COUNTER_REG		0x18250
+#define SLCR_COUNT_OFFS				0
+#define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS				31
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
+
+/* Device ID */
+#define CHIP_BOND_REG				0x18238
+#define PCKG_OPT_MASK				0x3
+
+#define MPP_OUTPUT_DRIVE_REG			0x184E4
+#define MPP_GE_A_OUTPUT_DRIVE_OFFS		6
+#define MPP_GE_A_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_A_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_OUTPUT_DRIVE_OFFS		14
+#define MPP_GE_B_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+
+#define MSAR_BOOT_MODE_OFFS			5
+#define MSAR_BOOT_MODE_MASK			(0xF << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_NOR				(0x0 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI				(0x3 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_DOVE_NAND			(0x1 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_LEGACY_NAND			(0x6 << MSAR_BOOT_MODE_OFFS)
+
+#define MSAR_TCLK_OFFS				28
+#define MSAR_TCLK_MASK				(0x1 << MSAR_TCLK_OFFS)
+
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG				0x1864C
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+#define MSAR_CPU_CLK_IDX(sar0, sar1)		((((sar0) >> 21) & 0x7) + ((((sar1) >> 20) & 1) << 3))
+#define MSAR_CPU_CLK_TWSI(sar0, sar1)		((((sar0) >> 2)  & 0x7) + (((sar1) & 1) << 3))
+#define MSAR_DDR_L2_CLK_RATIO_IDX(sar0, sar1)	((((sar0) >> 24) & 0xF) + ((((sar1) >> 19) & 1) << 4))
+#define MSAR_DDR_L2_CLK_RATIO_TWSI(sar0)	(((sar0) >> 1)  & 0xF)
+
+#ifndef MV_ASMLANGUAGE
+
+#define MV_CPU_CLK_TBL { 1000, 1066, 1200, 1333, 1500, 1666, 1800, 2000,\
+			  600,  667,  800, 1600, 2133, 2200, 2400, 0 }
+
+/*		cpu	l2c	hclk	ddr	*/
+#define MV_DDR_L2_CLK_RATIO_TBL    { \
+/*00*/	{	1,	1,	4,	2	},\
+/*01*/	{	1,	2,	2,	2	},\
+/*02*/	{	2,	2,	6,	3	},\
+/*03*/	{	2,	2,	3,	3	},\
+/*04*/	{	1,	2,	3,	3	},\
+/*05*/	{	1,	2,	4,	2	},\
+/*06*/	{	1,	1,	2,	2	},\
+/*07*/	{	2,	3,	6,	6	},\
+/*08*/	{	2,	3,	5,	5	},\
+/*09*/	{	1,	2,	6,	3	},\
+/*10*/	{	2,	4,	10,	5	},\
+/*11*/	{	1,	3,	6,	6	},\
+/*12*/	{	1,	2,	4,	4	},\
+/*13*/	{	1,	3,	6,	3	},\
+/*14*/	{	1,	2,	5,	5	},\
+/*15*/	{	2,	2,	5,	5	},\
+/*16*/	{	1,	1,	3,	3	},\
+/*17*/	{	2,	5,	10,	10	},\
+/*18*/	{	1,	3,	8,	4	},\
+/*19*/	{	1,	1,	2,	1	},\
+/*20*/	{	2,	3,	6,	3	},\
+/*21*/	{	1,	2,	8,	4	},\
+/*22*/	{	2,	5,	10,	5	} \
+}
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+		((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+		((target >= PEX0_MEM) && (target <= PEX0_IO))
+#define MV_TARGET_IS_PEX1(target)   \
+		((target >= PEX1_MEM) && (target <= PEX1_IO))
+#define MV_TARGET_IS_PEX2(target)   \
+		((target >= PEX2_MEM) && (target <= PEX2_IO))
+#define MV_TARGET_IS_PEX3(target)   \
+		((target >= PEX3_MEM) && (target <= PEX3_IO))
+#define MV_TARGET_IS_PEX4(target)   \
+		((target >= PEX4_MEM) && (target <= PEX4_IO))
+#define MV_TARGET_IS_PEX5(target)   \
+		((target >= PEX5_MEM) && (target <= PEX5_IO))
+#define MV_TARGET_IS_PEX6(target)   \
+		((target >= PEX6_MEM) && (target <= PEX6_IO))
+#define MV_TARGET_IS_PEX7(target)   \
+		((target >= PEX7_MEM) && (target <= PEX7_IO))
+#define MV_TARGET_IS_PEX8(target)   \
+		((target >= PEX8_MEM) && (target <= PEX8_IO))
+#define MV_TARGET_IS_PEX9(target)   \
+		((target >= PEX9_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_PEX(target)	((target >= PEX0_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_DEVICE(target)	((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_PCI_DRAM_BAR_TO_DRAM_TARGET(bar)   0
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
+
+
+#define BOOT_TARGETS_NAME_ARRAY {	\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	TBL_TERM, 			\
+	TBL_TERM, 			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	BOOT_ROM_CS			\
+}
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0		PEX0_MEM
+#define PCI_IF0_IO		PEX0_IO
+
+/* This enumerator defines the Marvell controller target ID  (see Address map) */
+typedef enum _mvTargetId {
+    DRAM_TARGET_ID	= 0,	/* Port 0 -> DRAM interface		*/
+    DEV_TARGET_ID	= 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+    PEX0_2_TARGET_ID	= 4,	/* Port 4 -> PCI Express 0 and 2	*/
+    PEX1_3_TARGET_ID	= 8,	/* Port 4 -> PCI Express 1 and 3	*/
+    CRYPT_TARGET_ID	= 9,	/* Port 9 --> Crypto Engine SRAM	*/
+    PNC_BM_TARGET_ID	= 12,  	/* Port 12 -> PNC + BM Unit		*/
+    MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+/*
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7
+} MV_SERDES_UNIT_INDX;
+*/
+
+/*
+	This structure refrect registers:
+	Serdes 0-7 selectors		0x18270
+	and Serdes 8-15 selectors  	0x18274
+*/
+#ifndef MV88F78X60_Z1
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1,  3}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1,  2 ,  4, -1,  3, -1, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 8 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+
+#else
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1, -1}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1, -1 , -1, -1,  2,  3, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1,  2 , -1, -1, -1,  3,  4}, /* Lane 8 */	\
+	{0, 1,  2 ,  3, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+#endif
+
+/*
+	This enum should reflect the units numbers in register
+	space which we will need when accessing the HW
+*/
+
+typedef enum {
+	PEX0_0x4	= 0,
+	PEX0_1x4	= 1,
+	PEX0_2x4	= 2,
+	PEX0_3x4	= 3,
+	PEX1_0x4	= 4,
+	PEX1_1x4	= 5,
+	PEX1_2x4	= 6,
+	PEX1_3x4	= 7,
+	PEX2_0x4	= 8,
+	PEX3_0x4	= 9,
+	PEXIF_MAX	= 10
+} MV_PEXIF_INDX;
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100644
index 0000000..f5e9da0
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,502 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX				"MV88F"
+
+/*
+ * Armada-XP Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET			(0x0)
+#define MV_AURORA_L2_REGS_OFFSET		(0x8000)
+#define MV_RTC_REGS_OFFSET			(0x10300)
+#define MV_DEV_BUS_REGS_OFFSET			(0x10400)
+#ifdef MV88F78X60_Z1
+#define MV_SPI_REGS_OFFSET(unit)               (0x10600)
+#else
+#define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
+#endif
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
+#define MV_UART_REGS_OFFSET(chanNum)		(0x12000 + (chanNum * 0x100))
+#define MV_RUNIT_PMU_REGS_OFFSET		(0x1C000)
+#define MV_MPP_REGS_OFFSET			(0x18000)
+#ifdef MV88F78X60_Z1
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x20))
+#else
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x40))
+#endif
+#define MV_MISC_REGS_OFFSET			(0x18200)
+#define MV_CLK_CMPLX_REGS_OFFSET	(0x18700)
+#define MV_MBUS_REGS_OFFSET			(0x20000)
+#define CPU_GLOBAL_BASE				(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
+#define MV_CNTMR_REGS_OFFSET			(0x20300)
+#define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)		(0x21800 + (cpu) * 0x100)
+#define MV_PMU_NFABRIC_UNIT_SERV_OFFSET		(0x22000)
+#define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
+#define MV_CPU_HW_SEM_OFFSET			(0x20500)
+
+#if defined(MV_ETH_LEGACY)
+	#define MV_ETH_BASE_ADDR		(0x72000)
+#else
+	#define MV_ETH_BASE_ADDR		(0x70000)
+#endif
+#define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
+
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000) \
+											 : (0x42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)       		(0x50000 + (dev * 0x1000))
+#define MV_XOR_REGS_OFFSET(unit)		(unit ? 0xF0900 : 0x60900)
+#define MV_CESA_TDMA_REGS_OFFSET(chanNum)	(0x90000 + (chanNum * 0x2000))
+#define MV_CESA_REGS_OFFSET(chanNum)		(0x9D000 + (chanNum * 0x2000))
+#define MV_SATA_REGS_OFFSET			(0xA0000)
+#define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
+#define MV_NFC_REGS_OFFSET			(0xD0000)
+#define MV_BM_REGS_OFFSET			(0xC0000)
+#define MV_PNC_REGS_OFFSET			(0xC8000)
+#define MV_SDMMC_REGS_OFFSET			(0xD4000)
+
+
+#ifdef CONFIG_ARMADA_XP_ERRATA_SMI_1
+	#define MV_ETH_SMI_PORT   1
+#else
+    #define MV_ETH_SMI_PORT   0
+#endif
+
+#define MV_SERDES_NUM_TO_PEX_NUM(sernum)	((sernum < 8) ? (sernum) : (8 + (sernum/12)))
+/*
+ * Miscellanuous Controller Configurations
+ */
+
+#define AVS_CONTROL2_REG			0x20868
+#define AVS_LOW_VDD_LIMIT			0x20860
+
+#define INTER_REGS_SIZE				_1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)		((ch) + 3)
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS				68
+#define MV_GPP_MAX_GROUP    			3 /* group == configuration register? */
+#ifndef MV88F78X60_Z1
+#define MV_CNTMR_MAX_COUNTER 		8 /* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
+#else
+#define MV_CNTMR_MAX_COUNTER 		17/* 4 global + 1 global WD + 2 per CPU + 4 CPU WD*/
+#endif
+/*
+	MV88F78X60_Z1								MV88F78X60_A0
+	-------------------------------             -------------------------------
+	Global Counters 0-3  : 0-3         		    Global Counters 0-3  		: 0-3
+	Global WD            : 4                    Global WD            		: 4
+
+	CPU 0 Counter 0-1    : 5-6					Private CPU Counter 0-1    : 5-6
+	CPU 0 WD             : 7                    Private CPU WD             : 7
+	CPU 1 Counter 0-1    : 8-9
+	CPU 1 WD             : 10
+	CPU 2 Counter 0-1    : 11-12
+	CPU 2 WD             : 13
+	CPU 3 Counter 0-1    : 14-15
+	CPU 3 WD             : 16
+*/
+
+#define MV_UART_MAX_CHAN			4
+
+#define MV_XOR_MAX_UNIT				2 /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN         		4 /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
+
+#define MV_SATA_MAX_CHAN			2
+
+#define MV_MPP_MAX_GROUP			9
+
+#define MV_DRAM_MAX_CS				4
+#define MV_SPI_MAX_CS				8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+	#define MV_PCI_MAX_IF			1
+	#define MV_PCI_START_IF			0
+	#define PCI_HOST_BUS_NUM(pciIf)		(pciIf)
+	#define PCI_HOST_DEV_NUM(pciIf)		0
+#else
+	#define MV_PCI_MAX_IF			0
+	#define MV_PCI_START_IF			0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF				10
+#define MV_PEX_MAX_UNIT				4
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF				MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces 	*/
+#define MV_IDMA_MAX_CHAN			4
+#define ARMADA_XP_MAX_USB_PORTS			3
+#define ARMADA_XP_NAND				1
+#define ARMADA_XP_SDIO				1
+#define ARMADA_XP_MAX_TDM_PORTS			32
+#define ARMADA_XP_TDM				1
+#define MV_DEVICE_MAX_CS      			4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS (ARMADA_XP_MAX_USB_PORTS)
+#endif
+
+
+/* CESA version #3: One channel, 2KB SRAM, TDMA, CHAIN Mode support */
+#define MV_CESA_VERSION				3 /*TODO verify */
+#define MV_CESA_SRAM_SIZE               	(2 * 1024)
+
+
+/* This define describes the maximum number of supported Ethernet ports */
+/* TODO - verify all these numbers */
+#define MV_ETH_VERSION 				4 /* for Legacy mode */
+#define MV_NETA_VERSION				1 /* for NETA mode */
+#define MV_ETH_MAX_PORTS			4
+#define MV_ETH_MAX_RXQ              		8
+#define MV_ETH_MAX_TXQ              		8
+#define MV_ETH_TX_CSUM_MAX_SIZE 		9800
+#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
+
+#if defined(MV88F78X60) && !defined(MV88F78X60_Z1)
+/* New GMAC module is used */
+#define MV_ETH_GMAC_NEW
+/* New WRR/EJP module is used */
+#define MV_ETH_WRR_NEW
+/* IPv6 parsing support for Legacy parser */
+#define MV_ETH_LEGACY_PARSER_IPV6
+/* New PNC module - extra fields */
+#define MV_ETH_PNC_NEW
+/* PNC Load Balancing support */
+#define MV_ETH_PNC_LB
+#endif /* MV88F78X60_A0/B0 */
+
+#define MV_78130_ETH_MAX_PORT			3
+#define MV_78460_ETH_MAX_PORT			4
+#define MV_FPGA_ETH_MAX_PORT			1
+
+/* This define describes the the support of USB */
+#define MV_USB_VERSION  			1
+
+#define MV_SPI_VERSION				2
+
+#define MV_INCLUDE_SDRAM_CS0
+#undef  MV_INCLUDE_SDRAM_CS1
+#undef  MV_INCLUDE_SDRAM_CS2
+#undef  MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED	0	/* Used to mark unused entry */
+
+typedef enum {
+	TDM_UNIT_32CH
+} MV_TDM_UNIT_TYPE;
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_32CH_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	SDIO_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,        /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*  0 SDRAM chip select 0		*/
+	SDRAM_CS1,	/*  1 SDRAM chip select 1		*/
+	SDRAM_CS2,	/*  2 SDRAM chip select 2		*/
+	SDRAM_CS3,	/*  3 SDRAM chip select 3		*/
+	DEVICE_CS0,	/*  4 Device chip select 0		*/
+	DEVICE_CS1,	/*  5 Device chip select 1		*/
+	DEVICE_CS2,	/*  6 Device chip select 2		*/
+	DEVICE_CS3,	/*  7 Device chip select 3		*/
+	PEX0_MEM,	/*  8 PCI Express 0 Memory		*/
+	PEX0_IO,	/*  9 PCI Express 0 IO			*/
+	PEX1_MEM,	/* 10 PCI Express 1 Memory		*/
+	PEX1_IO,	/* 11 PCI Express 1 IO			*/
+	PEX2_MEM,	/* 12 PCI Express 2 Memory		*/
+	PEX2_IO,	/* 13 PCI Express 2 IO			*/
+	PEX3_MEM,	/* 14 PCI Express 3 Memory		*/
+	PEX3_IO,	/* 15 PCI Express 3 IO			*/
+	PEX4_MEM,	/* 16 PCI Express 4 Memory		*/
+	PEX4_IO,	/* 17 PCI Express 4 IO			*/
+	PEX5_MEM,	/* 18 PCI Express 5 Memory		*/
+	PEX5_IO,	/* 19 PCI Express 5 IO			*/
+	PEX6_MEM,	/* 20 PCI Express 6 Memory		*/
+	PEX6_IO,	/* 21 PCI Express 6 IO			*/
+	PEX7_MEM,	/* 22 PCI Express 7 Memory		*/
+	PEX7_IO,	/* 23 PCI Express 7 IO			*/
+	PEX8_MEM,	/* 24 PCI Express 8 Memory		*/
+	PEX8_IO,	/* 25 PCI Express 8 IO			*/
+	PEX9_MEM,	/* 26 PCI Express 9 Memory		*/
+	PEX9_IO,	/* 27 PCI Express 9 IO			*/
+	INTER_REGS,	/* 28 Internal registers		*/
+	DMA_UART,	/* 29 DMA based UART request		*/
+	SPI_CS0,	/* 30 SPI_CS0				*/
+	SPI_CS1,	/* 31 SPI_CS1				*/
+	SPI_CS2,	/* 32 SPI_CS2				*/
+	SPI_CS3,	/* 33 SPI_CS3				*/
+	SPI_CS4,	/* 34 SPI_CS4				*/
+	SPI_CS5,	/* 35 SPI_CS5				*/
+	SPI_CS6,	/* 36 SPI_CS6				*/
+	SPI_CS7,	/* 37 SPI_CS7				*/
+	BOOT_ROM_CS,	/* 38 BOOT_ROM_CS			*/
+	DEV_BOOCS,	/* 39 DEV_BOOCS				*/
+	PMU_SCRATCHPAD,	/* 40 PMU Scratchpad			*/
+	CRYPT0_ENG,	/* 41 Crypto0 Engine			*/
+	CRYPT1_ENG,	/* 42 Crypto1 Engine			*/
+	PNC_BM,		/* 43 PNC + BM				*/
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR		0x1E
+#define DRAM_CS1_ATTR		0x1D
+#define DRAM_CS2_ATTR		0x1B
+#define DRAM_CS3_ATTR		0x17
+#else
+#define DRAM_CS0_ATTR		0x0E
+#define DRAM_CS1_ATTR		0x0D
+#define DRAM_CS2_ATTR		0x0B
+#define DRAM_CS3_ATTR		0x07
+#endif
+
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+ #define MAIN_BOOT_ATTR		0x2F	/* Boot Device CS - NOR */
+ #define SEC_BOOT_ATTR		0x1D	/* BootROM - Dummy */
+#else
+ #define MAIN_BOOT_ATTR		0x1D	/* BootROM */
+ #define SEC_BOOT_ATTR		0x2F	/* Boot Device CS */
+#endif
+
+#define TARGETS_DEF_ARRAY	{			\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID    }, /* DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID    }, /* DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID    }, /* DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID    }, /* DEVICE_CS3 */	\
+	{0xE8, PEX0_2_TARGET_ID }, /* PEX0_LANE0_MEM */	\
+	{0xE0, PEX0_2_TARGET_ID }, /* PEX0_LANE0_IO */	\
+	{0xD8, PEX0_2_TARGET_ID }, /* PEX0_LANE1_MEM */	\
+	{0xD0, PEX0_2_TARGET_ID }, /* PEX0_LANE1_IO */	\
+	{0xB8, PEX0_2_TARGET_ID }, /* PEX0_LANE2_MEM */	\
+	{0xB0, PEX0_2_TARGET_ID }, /* PEX0_LANE2_IO */	\
+	{0x78, PEX0_2_TARGET_ID }, /* PEX0_LANE3_MEM */	\
+	{0x70, PEX0_2_TARGET_ID }, /* PEX0_LANE3_IO */	\
+	{0xE8, PEX1_3_TARGET_ID }, /* PEX1_LANE0_MEM */	\
+	{0xE0, PEX1_3_TARGET_ID }, /* PEX1_LANE0_IO */	\
+	{0xD8, PEX1_3_TARGET_ID }, /* PEX1_LANE1_MEM */	\
+	{0xD0, PEX1_3_TARGET_ID }, /* PEX1_LANE1_IO */	\
+	{0xB8, PEX1_3_TARGET_ID }, /* PEX1_LANE2_MEM */	\
+	{0xB0, PEX1_3_TARGET_ID }, /* PEX1_LANE2_IO */	\
+	{0x78, PEX1_3_TARGET_ID }, /* PEX1_LANE3_MEM */	\
+	{0x70, PEX1_3_TARGET_ID }, /* PEX1_LANE3_IO */	\
+	{0xF8, PEX0_2_TARGET_ID }, /* PEX2_LANE0_MEM */	\
+	{0xF0, PEX0_2_TARGET_ID }, /* PEX2_LANE0_IO */	\
+	{0xF8, PEX1_3_TARGET_ID }, /* PEX3_LANE0_MEM */	\
+	{0xF0, PEX1_3_TARGET_ID }, /* PEX3_LANE0_IO */	\
+	{0xFF, 0xFF             }, /* INTER_REGS */	\
+	{0x01, DEV_TARGET_ID    }, /* DMA_UART */	\
+	{0x1E, DEV_TARGET_ID    }, /* SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID    }, /* SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID    }, /* SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID    }, /* SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID    }, /* SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID    }, /* SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID    }, /* SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID    }, /* SPI_CS7 */	\
+	{MAIN_BOOT_ATTR, DEV_TARGET_ID    }, /* Main Boot device */	\
+	{SEC_BOOT_ATTR, DEV_TARGET_ID    }, /* Secondary Boot device, */	\
+	{0x2D, DEV_TARGET_ID    }, /* PMU_SCRATCHPAD */	\
+	{0x01, CRYPT_TARGET_ID  }, /* CRYPT_ENG0 */	\
+	{0x05, CRYPT_TARGET_ID  }, /* CRYPT_ENG1 */     \
+	{0x00, PNC_BM_TARGET_ID }, /* PNC_BM */		\
+}
+
+#define CESA_TARGET_NAME_DEF	("CRYPT_ENG0", "CRYPT_ENG1")
+#define TARGETS_NAME_ARRAY	{		\
+	"SDRAM_CS0",    /* SDRAM_CS0 */		\
+	"SDRAM_CS1",    /* SDRAM_CS1 */		\
+	"SDRAM_CS2",    /* SDRAM_CS1 */		\
+	"SDRAM_CS3",    /* SDRAM_CS1 */		\
+	"DEVICE_CS0",	/* DEVICE_CS0 */	\
+	"DEVICE_CS1",	/* DEVICE_CS1 */	\
+	"DEVICE_CS2",	/* DEVICE_CS2 */	\
+	"DEVICE_CS3",	/* DEVICE_CS3 */	\
+	"PEX0_MEM",	/* PEX0_MEM */		\
+	"PEX0_IO",	/* PEX0_IO */		\
+	"PEX1_MEM",	/* PEX1_MEM */		\
+	"PEX1_IO",	/* PEX1_IO */		\
+	"PEX2_MEM",	/* PEX2_MEM */		\
+	"PEX2_IO",	/* PEX2_IO */		\
+	"PEX3_MEM",	/* PEX3_MEM */		\
+	"PEX3_IO",	/* PEX3_IO */		\
+	"PEX4_MEM",	/* PEX4_MEM */		\
+	"PEX4_IO",	/* PEX4_IO */		\
+	"PEX5_MEM",	/* PEX5_MEM */		\
+	"PEX5_IO",	/* PEX5_IO */		\
+	"PEX6_MEM",	/* PEX6_MEM */		\
+	"PEX6_IO",	/* PEX6_IO */		\
+	"PEX7_MEM",	/* PEX7_MEM */		\
+	"PEX7_IO",	/* PEX7_IO */		\
+	"PEX8_MEM",	/* PEX8_MEM */		\
+	"PEX8_IO",	/* PEX8_IO */		\
+	"PEX9_MEM",	/* PEX9_MEM */		\
+	"PEX9_IO",	/* PEX9_IO */		\
+	"INTER_REGS",	/* INTER_REGS */	\
+	"DMA_UART",	/* DMA_UART */		\
+	"SPI_CS0",	/* SPI_CS0 */		\
+	"SPI_CS1",	/* SPI_CS1 */		\
+	"SPI_CS2",	/* SPI_CS2 */		\
+	"SPI_CS3",	/* SPI_CS3 */		\
+	"SPI_CS4",	/* SPI_CS4 */		\
+	"SPI_CS5",	/* SPI_CS5 */		\
+	"SPI_CS6",	/* SPI_CS6 */		\
+	"SPI_CS7",	/* SPI_CS7 */		\
+	"BOOT_ROM_CS",	/* BOOT_ROM_CS */	\
+	"DEV_BOOTCS",	/* DEV_BOOCS */		\
+	"PMU_SCRATCHPAD",/* PMU_SCRATCHPAD */	\
+	"CRYPT1_ENG",	/* CRYPT1_ENG */	\
+	"CRYPT2_ENG",	/* CRYPT2_ENG */	\
+	"PNC_BM"	/* PNC_BM */		\
+}
+
+
+
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
new file mode 100644
index 0000000..3e116c3
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.c
@@ -0,0 +1,123 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+MV_BOOL mvSemaLock(MV_32 num)
+{
+	MV_U32 tmp;
+	MV_U32 cpuId;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	cpuId = whoAmI();
+	do
+	{
+		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	} while ((tmp & 0xFF) != cpuId);
+	return MV_TRUE;
+}
+
+MV_BOOL mvSemaTryLock(MV_32 num)
+{
+	MV_U32 tmp;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	if ((tmp & 0xFF) != whoAmI())
+	{
+		return MV_FALSE;
+	}
+	else
+		return MV_TRUE;
+}
+
+MV_BOOL mvSemaUnlock(MV_32 num)
+{
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+	return MV_TRUE;
+}
+
+MV_32 mvReadAmpReg(int regId)
+{
+	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+}
+
+MV_32 mvWriteAmpReg(int regId, MV_32 value)
+{
+	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
+}
\ No newline at end of file
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
new file mode 100644
index 0000000..2cd75a8
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvsemaphore_h
+#define mvsemaphore_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+#define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
+#define ADR_WIN_EN_REG			0
+
+#define MV_SEMA_REG_BASE	(0x20500)
+#define MV_MAX_SEMA 	    	128
+#define MV_SEMA_SMI 		50
+#define MV_SEMA_RTC 		51
+#define MV_SEMA_NOR_FLASH 	0
+#define MV_SEMA_BOOT 		1
+#define MV_SEMA_PEX0 		2
+#define MV_SEMA_BRIDGE 		3
+#define MV_SEMA_IRQ 		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_L2		6
+#define MV_SEMA_TWSI		7
+#define MV_SEMA_ADR_WIN		8
+
+#define MV_SEMA_BARRIER(cpu)	(50 + cpu)
+
+
+MV_BOOL mvSemaLock(MV_32 num);
+MV_BOOL mvSemaTryLock(MV_32 num);
+MV_BOOL mvSemaUnlock(MV_32 num);
+MV_32   mvReadAmpReg(int regId);
+MV_32 	mvWriteAmpReg(int regId, MV_32 value);
+
+/* Turn on HW semapores only if AMP is enabled */
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock
+#define mvSemaTryLock
+#define mvSemaUnlock
+#define mvHwBarrier
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvsemaphore_h */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
new file mode 100644
index 0000000..c194503
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
@@ -0,0 +1,231 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+static MV_BOOL mv_rsrc_limited = MV_FALSE;
+static MV_RES_MAP mv_res_table[] = {
+	/* Dividable units */
+	{0, "uart0"},
+	{0, "uart1"},
+	{0, "pex0"},
+	{0, "pex1"},
+	{0, "pex2"},
+	{0, "pex3"},
+	{0, "eth0"},
+	{0, "eth1"},
+	{0, "eth2"},
+	{0, "eth3"},
+	{0, "xor0"},
+	{0, "xor1"},
+	{0, "usb0"},
+	{0, "usb1"},
+	{0, "usb2"},
+	{0, "i2c0"},
+	{0, "i2c1"},
+	/* Single Allocation units */
+	{0, "sata"},
+	{0, "cesa"},
+	{0, "nor"},
+	{0, "nand"},
+	{0, "spi"},
+	{0, "tdm"},
+	{0, "sdio"},
+	{0, "lcd"},
+	{0, "hwmon"},
+	{0, "rtc"},
+	{0, "gpio"},
+	{0, "mstr"},
+	{-1, "last"}
+};
+
+MV_BOOL mvUnitMapIsRsrcLimited(void)
+{
+	return mv_rsrc_limited;
+}
+
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited)
+{
+	mv_rsrc_limited = isLimited;
+}
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx)
+{
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_BOOL mvUnitMapIsPexMine(int pciIf)
+{
+	MV_SOC_UNIT unitIdx;
+
+	/* Map line Number to PEX unit number */
+	/* This is compatible to mvCtrlSerdesPhyConfig in BoardEnvLib.c */
+	if(pciIf < PEX1_0x4)
+		unitIdx = PEX0;
+	else if(pciIf < PEX2_0x4)
+		unitIdx = PEX1;
+	else if(pciIf < PEX3_0x4)
+		unitIdx = PEX2;
+	else
+		unitIdx = PEX3;	
+
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx)
+{
+	if (MV_TRUE == mv_res_table[unitIdx].isMine)
+		return;
+
+	mv_res_table[unitIdx].isMine = 1;
+}
+
+MV_BOOL mvUnitMapSetup(char* cmdLine, STRSTR_FUNCPTR strstr_func)
+{
+	int unitIdx;
+	char* match;
+
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		char *unitName = mv_res_table[unitIdx].unitName;
+		int len;
+		match = strstr_func(cmdLine, unitName);
+		if (!match) continue;
+		/*Look for start delimiter*/
+		if (match > cmdLine) {
+			if (match[-1] != ' ' && match[-1] != ':') {
+				continue;
+			}
+		}
+		/* Calc string length without using strlen() */
+		while (*unitName++ != '\0');
+		len = unitName - mv_res_table[unitIdx].unitName - 1;		
+		/*Look for end delimiter*/
+		if (match[len] != ' ' && match[len] != ':' && match[len] != '\0') {
+			continue;
+		}
+		mvUnitMapSetMine(unitIdx);
+	}
+	return MV_TRUE;
+}
+
+MV_U32 mvSocUnitMapFillFlagFormTable(void)
+{
+	int i;
+	MV_U32 flag = 0;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++) 
+	{
+	    if (mvSocUnitMapGet(i) == 0)//SLAVE_CPU)
+	    {
+		switch (i)
+		{
+		case UART0:  flag |= UART0_T0_CPU1;   	break;        
+		case UART1:  flag |= UART1_TO_CPU1;   	break;       
+		case PEX00:  flag |= PEX0_TO_CPU1;    	break;       
+		case PEX10:  flag |= PEX1_TO_CPU1;    	break;       
+		case GIGA0:  flag |= GIGA0_TO_CPU1;   	break;       
+		case GIGA1:  flag |= GIGA1_TO_CPU1;   	break;       
+		case GIGA2:  flag |= GIGA2_TO_CPU1;   	break;       
+		case GIGA3:  flag |= GIGA3_TO_CPU1;   	break;       
+		case SATA:   flag |= SATA_TO_CPU1;    	break;        
+		case XOR:    flag |= XOR_TO_CPU1;	break;         
+		case IDMA:   flag |= IDMA_TO_CPU1;    	break;        
+		case USB0:   flag |= USB0_TO_CPU1;    	break;        
+		case USB1:   flag |= USB1_TO_CPU1;    	break;        
+		case USB2:   flag |= USB2_TO_CPU1;    	break;        
+		case CESA:   flag |= CESA_TO_CPU1;    	break;        
+		case NOR_FLASH: flag |= NOR_TO_CPU1;   break;
+		case NAND_FLASH: flag |= NAND_TO_CPU1;   break;
+		case SPI_FLASH: flag |= SPI_TO_CPU1;   break;
+		case TDM: flag |= TDM_TO_CPU1;   break;
+		default: 				
+			break;
+		}
+	    }
+	}
+
+	return flag;
+}*/
+MV_VOID mvUnitMapSetAllMine()
+{
+	int unitIdx;
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		mvUnitMapSetMine(unitIdx);
+	}
+}
+
+MV_VOID mvUnitMapPrint()
+{
+	int unitIdx;
+	mvOsPrintf("  AMP: Resources ");
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != -1; unitIdx++) {
+		if (mv_res_table[unitIdx].isMine) {
+			mvOsPrintf("- %s ", mv_res_table[unitIdx].unitName);
+		}
+	}
+	mvOsPrintf("\n");
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.h
new file mode 100644
index 0000000..63b51fa
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvUnitMap_h
+#define mvUnitMap_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+typedef enum
+{
+	UART0=0,
+	UART1,
+	PEX0,
+	PEX1,
+	PEX2,
+	PEX3,
+	ETH0,
+	ETH1,
+	ETH2,
+	ETH3,
+	XOR0,
+	XOR1,
+	USB0,
+	USB1,
+	USB2,
+	I2C0,
+ 	I2C1,
+	SATA,
+	CESA,
+	NOR,
+	NAND,
+	SPI,
+	TDM,
+	SDIO,
+	LCD,
+	HWMON,
+	RTC,
+	GPIO,
+	MSTR,
+	MAX_UNITS
+} MV_SOC_UNIT;
+
+/* binary flags for mvSocUnitMapFillTableFormBitMap */
+/*#define UART0_T0_CPU1	0x0001
+#define UART1_TO_CPU1	0x0002
+#define PEX0_TO_CPU1	0x0004
+#define PEX1_TO_CPU1	0x0008
+#define GIGA0_TO_CPU1	0x0010
+#define GIGA1_TO_CPU1	0x0020
+#define GIGA2_TO_CPU1	0x0040
+#define GIGA3_TO_CPU1	0x0080
+#define SATA_TO_CPU1	0x0100
+#define XOR_TO_CPU1		0x0200
+#define IDMA_TO_CPU1	0x0400
+#define USB0_TO_CPU1	0x0800
+#define USB1_TO_CPU1    0x1000
+#define USB2_TO_CPU1    0x2000
+#define CESA_TO_CPU1	0x4000
+#define NOR_TO_CPU1		0x8000
+#define NAND_TO_CPU1	0x10000
+#define SPI_TO_CPU1		0x20000
+#define TDM_TO_CPU1		0x40000
+  
+#define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
+															 
+typedef struct __MV_RES_MAP 
+{
+	int	isMine;
+	char*	unitName;
+} MV_RES_MAP;
+
+typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapIsPexMine(int pciIf);
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
+MV_VOID mvUnitMapSetAllMine(void);
+MV_VOID mvUnitMapPrint(void);
+MV_BOOL mvUnitMapIsRsrcLimited(void);
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
+#else /* CONFIG_MV_AMP_ENABLE */
+#define mvUnitMapIsMine(rsrc) 		MV_TRUE
+#define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
+#define mvUnitMapIsRsrcLimited 	  	MV_TRUE
+#define mvUnitMapSetRsrcLimited(limit) 
+#define mvUnitMapSetMine(rsrc)
+#define mvUnitMapSetAllMine
+#define mvUnitMapPrint
+#define mvUnitMapSetup(str, strstr_func) MV_TRUE
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
new file mode 100644
index 0000000..8b5da23
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -0,0 +1,738 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvCpuIfRegs.h"
+
+#undef MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* typedefs */
+
+/* CPU address remap registers offsets are inconsecutive. This struct		*/
+/* describes address remap register offsets					*/
+typedef struct _ahbToMbusRemapRegOffs {
+	MV_U32 lowRegOffs;	/* Low 32-bit remap register offset             */
+	MV_U32 highRegOffs;	/* High 32 bit remap register offset            */
+} AHB_TO_MBUS_REMAP_REG_OFFS;
+
+/* locals   */
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs);
+
+/*******************************************************************************
+* mvAhbToMbusInit - Initialize Ahb To Mbus Address Map !
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK laways.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusInit(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinSet - Set CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*       This function sets
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified winNum address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the winNum window, allowing CPU to access
+*       the winNum window.
+*
+* INPUT:
+*       winNum      - Windows number.
+*       pAddrDecWin - CPU winNum window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU winNum window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU winNum window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the winNum is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 sizeToReg;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinSet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvAhbToMbusWinSet:Error setting AHB to MBUS window %d to "
+			   "target %s.\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			   winNum,
+			   mvCtrlTargetNameGet(pAddrDecWin->target),
+			   pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	/* Size parameter validity check.                       */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.size, ATMWCR_WIN_SIZE_ALIGNMENT)) {
+		mvOsPrintf("mvAhbToMbusWinSet: Failed, size not aligned to 0x%x.\n", ATMWCR_WIN_SIZE_ALIGNMENT);
+		return MV_BAD_PARAM;
+	}
+
+	/* Write to address decode Base Address Register        */
+	decRegs.baseReg = (pAddrDecWin->addrWin.baseLow & ATMWBR_BASE_MASK);
+
+	/* Get size register value according to window size     */
+	sizeToReg = (pAddrDecWin->addrWin.size / ATMWCR_WIN_SIZE_ALIGNMENT) - 1;
+
+	/* set size                                             */
+	decRegs.ctrlReg = (sizeToReg << ATMWCR_WIN_SIZE_OFFS);
+
+	/* enable\Disable */
+	if (MV_TRUE == pAddrDecWin->enable)
+		decRegs.ctrlReg |= ATMWCR_WIN_ENABLE;
+	else
+		decRegs.ctrlReg &= ~ATMWCR_WIN_ENABLE;
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* set attributes */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_ATTR_MASK;
+	decRegs.ctrlReg |= targetAttribs.attrib << ATMWCR_WIN_ATTR_OFFS;
+	/* set target ID */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_TARGET_MASK;
+	decRegs.ctrlReg |= targetAttribs.targetId << ATMWCR_WIN_TARGET_OFFS;
+
+#if !defined(MV_RUN_FROM_FLASH)
+	/* To be on the safe side we disable the window before writing the  */
+	/* new values.                                                      */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		mvAhbToMbusWinEnable(winNum, MV_FALSE);
+#endif
+
+	/* 3) Write to address decode Base Address Register                   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), decRegs.baseReg);
+	else
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
+
+
+	/* Internal register space have no size */
+	/* register. Do not perform size register assigment for those targets   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
+		/* Write to address decode Size Register                                */
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), decRegs.ctrlReg);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinGet - Get CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral winNum address window.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU winNum window information data structure.
+*
+* RETURN:
+*       MV_OK if winNum exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_U32 sizeRegVal;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal register space size have no size register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+	else
+		decRegs.ctrlReg = 0;
+
+	/* Read base and size   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	else
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_INTEREG_REG);
+
+	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseLow = decRegs.baseReg & ATMWBR_BASE_MASK;
+	sizeRegVal = (decRegs.ctrlReg & ATMWCR_WIN_SIZE_MASK) >> ATMWCR_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * ATMWCR_WIN_SIZE_ALIGNMENT;
+
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN) {
+		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
+		pAddrDecWin->target = INTER_REGS;
+		pAddrDecWin->enable = MV_TRUE;
+
+		return MV_OK;
+	}
+
+	if (decRegs.ctrlReg & ATMWCR_WIN_ENABLE)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	if (-1 == pAddrDecWin->addrWin.size)
+		return MV_ERROR;
+
+	/* attrib and targetId */
+	targetAttrib.attrib = (decRegs.ctrlReg & ATMWCR_WIN_ATTR_MASK) >> ATMWCR_WIN_ATTR_OFFS;
+	targetAttrib.targetId = (decRegs.ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetGet - Get Window number associated with target
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	if (INTER_REGS == target)
+		return MV_AHB_TO_MBUS_INTREG_WIN;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_TRUE) {
+			if (decWin.target == target)
+				return winNum;
+		}
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinAvailGet - Get First Available window number.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinAvailGet(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_FALSE)
+			return winNum;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other winNum window.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinEnable: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal registers bar can't be disable or enabled */
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+		return (enable ? MV_OK : MV_ERROR);
+
+
+	if (enable == MV_TRUE) {
+		/* enable the window */
+		MV_REG_BIT_SET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	} else {
+		/* Disable address decode winNum window                             */
+		MV_REG_BIT_RESET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*       After a CPU address hits one of PCI address decode windows there is an
+*       option to remap the address to a different one. For example, CPU
+*       executes a read from PCI winNum window address 0x1200.0000. This
+*       can be modified so the address on the PCI bus would be 0x1400.0000
+*       Using the PCI address remap mechanism.
+*
+* INPUT:
+*       winNum      - Peripheral winNum enumerator. Must be a PCI winNum.
+*       pAddrDecWin - CPU winNum window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if winNum is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddr;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegOffs;
+	MV_U32 effectiveBaseAddress = 0, baseAddrValue = 0, windowSizeValue = 0;
+
+	/* Get registers offsets of given winNum                */
+	if (MV_NO_SUCH == ahbToMbusRemapRegOffsGet(winNum, &remapRegOffs))
+		return 0xffffffff;
+
+	/* 1) Set address remap low */
+	baseAddr = pAddrWin->baseLow;
+
+	/* BaseLow[31:16] => base register [31:16]              */
+	baseAddr = baseAddr & ATMWRLR_REMAP_LOW_MASK;
+
+	MV_REG_WRITE(remapRegOffs.lowRegOffs, baseAddr);
+	MV_REG_WRITE(remapRegOffs.highRegOffs, pAddrWin->baseHigh);
+
+	baseAddrValue = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	windowSizeValue = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+
+	baseAddrValue &= ATMWBR_BASE_MASK;
+	windowSizeValue &= ATMWCR_WIN_SIZE_MASK;
+
+	/* Start calculating the effective Base Address */
+	effectiveBaseAddress = baseAddrValue;
+
+	/* The effective base address will be combined from the chopped (if any)
+	   remap value (according to the size value and remap mechanism) and the
+	   window's base address */
+	effectiveBaseAddress |= (((windowSizeValue) | 0xffff) & pAddrWin->baseLow);
+	/* If the effectiveBaseAddress exceed the window boundaries return an
+	   invalid value. */
+
+	if (effectiveBaseAddress > (baseAddrValue + (windowSizeValue | 0xffff))) {
+		mvOsPrintf("mvAhbToMbusPciRemap: Error\n");
+		return 0xffffffff;
+	}
+
+	return effectiveBaseAddress;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetSwap - Swap AhbToMbus windows between targets
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       target1      - CPU Interface target 1
+*       target2      - CPU Interface target 2
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if targets are illigal, or if one of the targets is not
+*	    associated to a valid window .
+*       MV_OK otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2)
+{
+	MV_U32 winNum1, winNum2;
+	MV_AHB_TO_MBUS_DEC_WIN winDec1, winDec2, winDecTemp;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegs1, remapRegs2;
+	MV_U32 remapBaseLow1 = 0, remapBaseLow2 = 0;
+	MV_U32 remapBaseHigh1 = 0, remapBaseHigh2 = 0;
+
+	/* Check parameters */
+	if (target1 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	if (target2 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum1 = mvAhbToMbusWinTargetGet(target1);
+
+	if (winNum1 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target1, winNum1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum2 = mvAhbToMbusWinTargetGet(target2);
+	if (winNum2 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target2, winNum2);
+		return MV_ERROR;
+	}
+
+	/* now Get original values of both Windows */
+	if (MV_OK != mvAhbToMbusWinGet(winNum1, &winDec1)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinGet(winNum2, &winDec2)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* disable both windows */
+	if (MV_OK != mvAhbToMbusWinEnable(winNum1, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable window %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinEnable(winNum2, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable windo %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* now swap targets */
+
+	/* first save winDec2 values */
+	winDecTemp.addrWin.baseHigh = winDec2.addrWin.baseHigh;
+	winDecTemp.addrWin.baseLow = winDec2.addrWin.baseLow;
+	winDecTemp.addrWin.size = winDec2.addrWin.size;
+	winDecTemp.enable = winDec2.enable;
+	winDecTemp.target = winDec2.target;
+
+	/* winDec2 = winDec1 */
+	winDec2.addrWin.baseHigh = winDec1.addrWin.baseHigh;
+	winDec2.addrWin.baseLow = winDec1.addrWin.baseLow;
+	winDec2.addrWin.size = winDec1.addrWin.size;
+	winDec2.enable = winDec1.enable;
+	winDec2.target = winDec1.target;
+
+	/* winDec1 = winDecTemp */
+	winDec1.addrWin.baseHigh = winDecTemp.addrWin.baseHigh;
+	winDec1.addrWin.baseLow = winDecTemp.addrWin.baseLow;
+	winDec1.addrWin.size = winDecTemp.addrWin.size;
+	winDec1.enable = winDecTemp.enable;
+	winDec1.target = winDecTemp.target;
+
+	/* now set the new values */
+	mvAhbToMbusWinSet(winNum1, &winDec1);
+	mvAhbToMbusWinSet(winNum2, &winDec2);
+
+	/* now we will treat the remap windows if exist */
+
+	/* now check if one or both windows has a remap window
+	   as well after the swap ! */
+
+	/* if a window had a remap value differnt than the base value
+	   before the swap , then after the swap the remap value will be
+	   equal to the base value unless both windows has a remap windows */
+
+	/* first get old values */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		remapBaseLow1 = MV_REG_READ(remapRegs1.lowRegOffs);
+		remapBaseHigh1 = MV_REG_READ(remapRegs1.highRegOffs);
+	}
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		remapBaseLow2 = MV_REG_READ(remapRegs2.lowRegOffs);
+		remapBaseHigh2 = MV_REG_READ(remapRegs2.highRegOffs);
+	}
+
+	/* now do the swap */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+			/* Two windows has a remap !!! so swap */
+
+			MV_REG_WRITE(remapRegs2.highRegOffs, remapBaseHigh1);
+			MV_REG_WRITE(remapRegs2.lowRegOffs, remapBaseLow1);
+
+			MV_REG_WRITE(remapRegs1.highRegOffs, remapBaseHigh2);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, remapBaseLow2);
+		} else {
+			/* remap == base */
+			MV_REG_WRITE(remapRegs1.highRegOffs, winDec1.addrWin.baseHigh);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, winDec1.addrWin.baseLow);
+		}
+	} else if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		/* remap == base */
+		MV_REG_WRITE(remapRegs2.highRegOffs, winDec2.addrWin.baseHigh);
+		MV_REG_WRITE(remapRegs2.lowRegOffs, winDec2.addrWin.baseLow);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ahbToMbusRemapRegOffsGet - Get CPU address remap register offsets
+*
+* DESCRIPTION:
+* 		CPU to PCI address remap registers offsets are inconsecutive.
+*		This function returns PCI address remap registers offsets.
+*
+* INPUT:
+*       winNum - Address decode window number. See MV_U32 enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*		MV_ERROR if winNum is not a PCI one.
+*
+*******************************************************************************/
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs)
+{
+	switch (winNum) {
+	case 0:
+	case 1:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 2:
+	case 3:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	default:
+		pRemapRegs->lowRegOffs = 0;
+		pRemapRegs->highRegOffs = 0;
+
+		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		return MV_NO_SUCH;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusAddDecShow - Print the AHB to MBus bridge address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN win;
+	MV_U32 winNum;
+	mvOsOutput("\n");
+	mvOsOutput("AHB To MBUS Bridge:\n");
+	mvOsOutput("-------------------\n");
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		memset(&win, 0, sizeof(MV_AHB_TO_MBUS_DEC_WIN));
+
+		mvOsOutput("win%d - ", winNum);
+
+		if (mvAhbToMbusWinGet(winNum, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("%s base %08x, ", mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+				mvOsOutput("....");
+				mvSizePrint(win.addrWin.size);
+
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		}
+	}
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
new file mode 100644
index 0000000..864463c
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -0,0 +1,92 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvAhbToMbush
+#define __INCmvAhbToMbush
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* defines  */
+typedef struct _mvAhbtoMbusDecWin {
+	MV_TARGET	target;
+	MV_ADDR_WIN	addrWin;    /* An address window*/
+	MV_BOOL		enable;     /* Address decode window is enabled/disabled    */
+} MV_AHB_TO_MBUS_DEC_WIN;
+
+/* mvAhbToMbus.h API list */
+
+MV_STATUS mvAhbToMbusInit(MV_VOID);
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
+MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
+MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
+MV_VOID   mvAhbToMbusAddDecShow(MV_VOID);
+
+#endif /* __INCmvAhbToMbush */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
new file mode 100644
index 0000000..50fd816
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -0,0 +1,143 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbusRegsh
+#define __INCmvAhbToMbusRegsh
+
+#define MAX_AHB_TO_MBUS_WINS			21
+#define MAX_AHB_TO_MBUS_REMAP_WINS		8
+#define MV_AHB_TO_MBUS_INTREG_WIN		20
+
+/***********************/
+/* AHB TO MBUS WINDOWS */
+/***********************/
+/* Window-X Control Registers */
+#define AHB_TO_MBUS_WIN_CTRL_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + winNum * 0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x90 + (winNum-8)*0x08))
+#define ATMWCR_WIN_ENABLE			BIT0
+#define ATMWCR_WIN_TARGET_OFFS			4
+#define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
+#define ATMWCR_WIN_ATTR_OFFS			8
+#define ATMWCR_WIN_ATTR_MASK			(0xff << ATMWCR_WIN_ATTR_OFFS)
+#define ATMWCR_WIN_SIZE_OFFS			16
+#define ATMWCR_WIN_SIZE_MASK			(0xffff << ATMWCR_WIN_SIZE_OFFS)
+#define ATMWCR_WIN_SIZE_ALIGNMENT		0x10000
+
+/* Window-X Base Register */
+#define AHB_TO_MBUS_WIN_BASE_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x4 + winNum*0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x94 + (winNum-8)*0x08))
+#define ATMWBR_BASE_OFFS			16
+#define ATMWBR_BASE_MASK			(0xffff << 	ATMWBR_BASE_OFFS)
+#define ATMWBR_BASE_ALIGNMENT			0x10000
+
+/* Window-X Remap Low Register */
+#define AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x8 + winNum*0x10) : \
+						 (0))
+#define ATMWRLR_REMAP_LOW_OFFS			16
+#define ATMWRLR_REMAP_LOW_MASK			(0xffff << ATMWRLR_REMAP_LOW_OFFS)
+#define ATMWRLR_REMAP_LOW_ALIGNMENT		0x10000
+
+/* Window-X Remap Hi Register */
+#define AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0xC + winNum*0x10) : \
+						 (0))
+#define ATMWRHR_REMAP_HIGH_OFFS			0
+#define ATMWRHR_REMAP_HIGH_MASK			(0xffffffff << ATMWRHR_REMAP_HIGH_OFFS)
+
+/*****************************/
+/* INTERNAL REGISTERS WINDOW */
+/*****************************/
+/* Internal Registers Base Address in set to be window 20 */
+#define AHB_TO_MBUS_WIN_INTEREG_REG		(MV_MBUS_REGS_OFFSET + 0x80)
+
+/************************/
+/* SDRAM DECODE WINDOWS */
+/************************/
+/* All DRAM Window definitions are declared under the ddr2_3 HAL */
+
+/****************************/
+/* SRAM (L2) DECODE WINDOWS */
+/****************************/
+#define SRAM_WIN_CTRL_REG(winNum)		(MV_MBUS_REGS_OFFSET + 0x240 + winNum * 0x4)
+#define SRAMWCR_ENABLE				BIT0
+#define SRAMWCR_SIZE_OFFS			8
+#define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
+#define SRAMWCR_BASE_OFFS			16
+#define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+
+/**********************/
+/* MBUS BRIDGE WINDOW */
+/**********************/
+#define MBUS_BRIDGE_WIN_CTRL_REG		(MV_MBUS_REGS_OFFSET + 0x250)
+#define BRIDGWCR_ENABLE				BIT0
+#define BRIDGWCR_SIZE_OFFS			16
+#define BRIDGWCR_SIZE_MASK			(0xFFFF << BRIDGWCR_SIZE_OFFS)
+#define MBUS_BRIDGE_WIN_BASE_REG		(MV_MBUS_REGS_OFFSET + 0x254)
+
+#endif /* __INCmvAhbToMbusRegsh */
+
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.c
new file mode 100644
index 0000000..0da9477
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.c
@@ -0,0 +1,1027 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+/*#include "cpu/mvCpu.h" *//* whoAmI() */
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "ddr2_3/mvDramIf.h"
+#include "ddr2_3/mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+
+/*#define MV_DEBUG*/
+/* defines  */
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals   */
+/* static functions */
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
+
+MV_TARGET sampleAtResetTargetArray[] = BOOT_TARGETS_NAME_ARRAY;
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+	MV_32 diff;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		if(win.enable == cpuAddrWinMap->enable)
+		{
+			if(win.enable)
+			{
+				diff  = (win.addrWin.baseLow  - cpuAddrWinMap->addrWin.baseLow);
+				diff |= (win.addrWin.baseHigh - cpuAddrWinMap->addrWin.baseHigh);
+				diff |= (win.addrWin.size     - cpuAddrWinMap->addrWin.size);
+				/*TODO - Need to compare the window attributes as well */
+
+				if(diff)
+				{
+					mvOsOutput("mvCpuIfVerify: Mismatched window size in target %d\n", target);
+					return MV_ERROR;
+				}
+			}
+		}
+		else
+		{
+			mvOsOutput("mvCpuIfVerify: Mismatched enable field in target %d\n", target);
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCpuIfInitForCpu - Initialize Controller CPU interface
+*
+* DESCRIPTION:
+*       This function initialize Controller CPU interface:
+*       1. Set CPU interface configuration registers.
+*       2. Set CPU master Pizza arbiter control according to static
+*          configuration described in configuration file.
+*       3. Opens CPU address decode windows. DRAM windows are assumed to be
+*		   already set (auto detection).
+*
+* INPUT:
+*       cpu      	- CPU id.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_U32 regVal, i;
+	MV_TARGET target;
+	MV_ADDR_WIN addrWin;
+	MV_U32 minBase = 0xFFFFFFFF;
+	MV_U32 minSize;
+
+	if (cpuAddrWinMap == NULL) {
+		DB(mvOsPrintf("%s: CPU map NULL pointer\n", __func__));
+		return MV_ERROR;
+	}
+
+	/* Set IO Bypass base address and size according to the cpuAddrWinMap */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow == 0)
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow < minBase)
+			minBase = cpuAddrWinMap[target].addrWin.baseLow;
+	}
+	if (minBase != 0x0) {
+		minSize = 0xFFFFFFFF - minBase + 1;
+		if (!MV_IS_POWER_OF_2(minSize)) {
+			/* Round up to next power of 2. */
+			minSize = (1 << (mvLog2(minSize) + 1));
+			minBase = 0xFFFFFFFF - minSize + 1;
+		}
+
+		/* Now write the base and size */
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_BASE_REG, minBase);
+		/* Align window size to 64KB */
+		regVal = (minSize / SDRAMWBR_BASE_ALIGNMENT) - 1;
+		regVal = (regVal << 16) | 0x1;
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_CTRL_REG, regVal);
+	}
+
+	/* Set CPU Configuration register */
+	regVal = MV_REG_READ(CPU_CONFIG_REG(cpu));
+	regVal &= ~CPU_CONFIG_DEFAULT_MASK;
+	regVal |= CPU_CONFIG_DEFAULT;
+	MV_REG_WRITE(CPU_CONFIG_REG(cpu), regVal);
+
+	for (i = 0; i < MAX_AHB_TO_MBUS_WINS-2; i++)
+		mvAhbToMbusWinEnable(i, MV_FALSE);
+
+	/* Disable all SRAM windows */
+	mvCpuIfSramWinDisable();
+
+	/* First disable all CPU target windows  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
+			continue;
+#ifdef CONFIG_MV_AMP_ENABLE
+		if(target == BOOT_ROM_CS)
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+#if defined(MV_RUN_FROM_FLASH)
+		/* Don't disable the boot device.                               */
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+		mvCpuIfTargetWinEnable(MV_CHANGE_BOOT_CS(target), MV_FALSE);
+	}
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
+	target = DEV_BOOCS;
+
+	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+		DB(mvOsPrintf("%s: ERR: mvCpuIfTargetWinSet failed\n", __func__));
+		return MV_ERROR;
+	}
+
+	addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+	addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+	if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+		DB(mvOsPrintf("%s: WARN: mvAhbToMbusWinRemap can't remap winNum=%d\n",
+			      __func__, cpuAddrWinMap[target].winNum));
+	}
+#endif /* MV_RUN_FROM_FLASH */
+
+	/* Go through all targets in user table until table terminator                  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+
+#if defined(MV_RUN_FROM_FLASH)
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+
+		/* if DRAM auto sizing is used do not initialized DRAM target windows,  */
+		/* assuming this already has been done earlier.                         */
+#ifdef	MV_DRAM_AUTO_SIZE
+		if (MV_TARGET_IS_DRAM(target))
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		else {
+			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+				DB(mvOsPrintf("%s: ERR: mvCpuIfTargetWinSet failed\n", __func__));
+				return MV_ERROR;
+			}
+			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+				DB(mvOsPrintf("%s: WARN: mvAhbToMbusWinRemap can't remap winNum=%d\n",
+					      __func__, cpuAddrWinMap[target].winNum));
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	return mvCpuIfInitForCpu(whoAmI(), cpuAddrWinMap);
+}
+
+/*******************************************************************************
+* mvCpuIfDramInit - Initialize Controller DRAM Fastpath windows
+*
+* DESCRIPTION:
+*       This function initialize Controller DRAM Fastpath windows
+*		It takes the CS size information from the 0x1500 scratch registers
+*		and sets the correct windows sizes and base addresses accordingly
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfDramInit()
+{
+#if !defined(CONFIG_MACH_GENERAL_FPGA)
+	MV_U64 base = 0;
+	MV_U32 size, cs, temp;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+		if (size != 0) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Set Base Address */
+			temp = (base & 0xFF000000ll) | ((base >> 32) & 0xF);
+			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
+
+			/* Check if out of max window size and resize the window */
+#if 0
+			if (base+size > SDRAM_MAX_ADDR) {
+				size = SDRAM_MAX_ADDR - base - 1;
+				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
+			}
+#endif
+			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
+			temp |= (size & SDRAM_ADDR_MASK);
+
+			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
+			base += ((MV_U64)size + 1);
+		}
+	}
+
+#endif
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSet - Set CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI0_MEM0)
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing CPU to access
+*       the target window.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - CPU target window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU target window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU target window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the target is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 existingWinNum;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		/* copy relevant data to MV_DRAM_DEC_WIN structure */
+		addrDecWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		addrDecWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		addrDecWin.addrWin.size = pAddrDecWin->addrWin.size;
+		addrDecWin.enable = pAddrDecWin->enable;
+
+		if (mvDramIfWinSet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvDramIfWinSet Failed\n");
+			return MV_ERROR;
+		}
+	} else {
+		/* copy relevant data to MV_AHB_TO_MBUS_DEC_WIN structure */
+		decWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		decWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		decWin.addrWin.size = pAddrDecWin->addrWin.size;
+		decWin.enable = pAddrDecWin->enable;
+		decWin.target = target;
+
+		existingWinNum = mvAhbToMbusWinTargetGet(target);
+
+		/* check if there is already another Window configured
+		   for this target */
+		if ((existingWinNum < MAX_AHB_TO_MBUS_WINS) && (existingWinNum != pAddrDecWin->winNum)) {
+			/* if we want to enable the new window number
+			   passed by the user , then the old one should
+			   be disabled */
+			if (MV_TRUE == pAddrDecWin->enable) {
+				/* be sure it is disabled */
+				mvAhbToMbusWinEnable(existingWinNum, MV_FALSE);
+			}
+		}
+
+		if (mvAhbToMbusWinSet(pAddrDecWin->winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvAhbToMbusWinSet Failed\n");
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinGet - Get CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral target address window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU target window information data structure.
+*
+* RETURN:
+*       MV_OK if target exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_U32 winNum = 0xffffffff;
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinGet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinGet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to get window target %d\n", target);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = addrDecWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = (MV_U64)addrDecWin.addrWin.size;
+		pAddrDecWin->enable = addrDecWin.enable;
+		pAddrDecWin->winNum = target;
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return MV_NO_SUCH;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: mvAhbToMbusWinGet Failed at winNum = %d\n", __func__, winNum);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = decWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = decWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = decWin.addrWin.size;
+		pAddrDecWin->enable = decWin.enable;
+		pAddrDecWin->winNum = winNum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       target - Peripheral target enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other target window.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable)
+{
+	MV_U32 winNum, temp;
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinEnable: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* get the window and check if it exist */
+	temp = mvCpuIfTargetWinGet(target, &addrDecWin);
+	if (MV_NO_SUCH == temp) {
+		return (enable ? MV_ERROR : MV_OK);
+	} else if (MV_OK != temp) {
+		mvOsPrintf("%s: ERR. Getting target %d failed.\n", __func__, target);
+		return MV_ERROR;
+	}
+
+	/* check overlap */
+	if (MV_TRUE == enable) {
+		if (MV_TRUE == cpuTargetWinOverlap(target, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("%s: ERR. Target %d overlap\n", __func__, target));
+			return MV_ERROR;
+		}
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinEnable(target, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: mvDramIfWinEnable Failed at \n");
+			return MV_ERROR;
+		}
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return (enable ? MV_ERROR : MV_OK);
+
+		if (mvAhbToMbusWinEnable(winNum, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to enable window = %d\n", winNum);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSizeGet - Get CPU target address window size
+*
+* DESCRIPTION:
+*		Get the size of CPU-to-peripheral target window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit size. Function also returns '0' if window is closed.
+*		Function returns 0xFFFFFFFF in case of an error.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinSizeGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet: target %d is illegal\n", target);
+		return 0;
+	}
+
+	/* Get the winNum window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet:ERR. Getting target %d failed.\n", target);
+		return 0;
+	}
+
+	/* Check if window is enabled   */
+	if (addrDecWin.enable == MV_TRUE)
+		return (addrDecWin.addrWin.size);
+	else
+		return 0;	/* Window disabled. return 0 */
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseLowGet - Get CPU target address window base low
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target low base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit low base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseLowGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0xffffffff;
+
+	return (addrDecWin.addrWin.baseLow);
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseHighGet - Get CPU target address window base high
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target high base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit high base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseHighGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseHighGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0;
+
+	return (addrDecWin.addrWin.baseHigh);
+}
+
+
+/*******************************************************************************
+* mvCpuIfSramWinDisable
+*
+* DESCRIPTION:
+*	Disable the SRAM windows.
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID)
+{
+	MV_U32 i;
+
+	for (i = 0; i < 4; i++)
+		MV_REG_WRITE(SRAM_WIN_CTRL_REG(i), SRAM_WIN_CTRL_DEFAULT_VAL);
+
+	return MV_OK;
+}
+
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfPexRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pexTarget   - Peripheral target enumerator. Must be a PEX target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PEX one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (mvCtrlPexMaxIfGet() > 1) {
+		if ((!MV_TARGET_IS_PEX0(pexTarget)) &&
+			(!MV_TARGET_IS_PEX1(pexTarget)) &&
+			(!MV_TARGET_IS_PEX2(pexTarget)) &&
+			(!MV_TARGET_IS_PEX3(pexTarget)) &&
+			(!MV_TARGET_IS_PEX4(pexTarget)) &&
+			(!MV_TARGET_IS_PEX5(pexTarget)) &&
+			(!MV_TARGET_IS_PEX6(pexTarget)) &&
+			(!MV_TARGET_IS_PEX7(pexTarget)) &&
+			(!MV_TARGET_IS_PEX8(pexTarget)) &&
+			(!MV_TARGET_IS_PEX9(pexTarget))) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	} else {
+		if (!MV_TARGET_IS_PEX0(pexTarget)) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	}
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pexTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCpuIfPciRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pciTarget   - Peripheral target enumerator. Must be a PCI target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPciRemap(MV_TARGET pciIfTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pciIfTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+/*******************************************************************************
+* mvCpuIfTargetOfBaseAddressGet - Get the target according to base address
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       baseAddress -  base address to be checked
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the target number that baseAddress belongs to or MAX_TARGETS is not
+*       found
+*
+*******************************************************************************/
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				if ((baseAddress >= win.addrWin.baseLow) &&
+				    (baseAddress < win.addrWin.baseLow + win.addrWin.size))
+					break;
+			}
+		} else
+			return MAX_TARGETS;
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* cpuTargetWinOverlap - Detect CPU address decode windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case CPU address decode
+*       windows overlapps.
+*       This function detects CPU address decode windows overlapping of a
+*       specified target. The function does not check the target itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlaps current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 targetNum;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_STATUS status;
+
+	for (targetNum = 0; targetNum < MAX_TARGETS; targetNum++) {
+		/* don't check our target or illegal targets */
+		if (targetNum == target)
+			continue;
+
+		/* Get window parameters        */
+		status = mvCpuIfTargetWinGet(targetNum, &addrDecWin);
+		if (MV_NO_SUCH == status)
+			continue;
+
+		if (MV_OK != status) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: ERR. TargetWinGet failed\n"));
+			return MV_TRUE;
+		}
+
+		/* Do not check disabled windows        */
+		if (MV_FALSE == addrDecWin.enable)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: Required target %d overlap current %d\n",
+				      target, targetNum));
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCpuIfAddDecShow - Print the CPU address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfAddDecShow(MV_VOID)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	mvOsOutput("\n");
+	mvOsOutput("CPU Interface\n");
+	mvOsOutput("-------------\n");
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		mvOsOutput("%s ", mvCtrlTargetNameGet(target));
+		mvOsOutput("....");
+
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("base %01x%08x, ", win.addrWin.baseHigh, win.addrWin.baseLow);
+				mvSizePrint(win.addrWin.size);
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		} else if (mvCpuIfTargetWinGet(target, &win) == MV_NO_SUCH) {
+			mvOsOutput("no such\n");
+		}
+	}
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfEnablePex - Enable PCI Express unit.
+*
+* DESCRIPTION:
+*	This function enables PCI Express access to the device address
+*	space.
+*
+* INPUT:
+*	pexUnit	- PEX unit (0 - 3).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfEnablePex(MV_U32 pexUnit)
+{
+	MV_U32 socMaxPexUnit = mvCtrlPexMaxUnitGet();
+
+	if (pexUnit > socMaxPexUnit) {
+		DB(mvOsPrintf("mvCpuIfEnablePex: Bad PEX unit ID (%x)\n", pexUnit));
+		return;
+	}
+
+	/* SOC config register Pex enable */
+	MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
+}
+
+/*******************************************************************************
+* mvCpuIfPex4x1Enable - Enable/Disable the 4x1 mode on PCI Express unit.
+*
+* DESCRIPTION:
+*	This function enables/disables 4x1 mode on PCI Express unit 0 or 1
+*
+* INPUT:
+*	pexUnit	- PEX unit (0 or 1).
+*	enable	- enable (MV_TRUE) or disable (MV_FALSE) 4x1 mode
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfPex4x1Enable(MV_U32 pexUnit, MV_BOOL enable)
+{
+	if (pexUnit == 0)
+		MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX0_4BY1_MASK);
+	else if (pexUnit == 1)
+		MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX1_4BY1_MASK);
+	else
+		DB(mvOsPrintf("mvCpuIfPex4x1Enable: Bad PEX unit ID (%x)\n", pexUnit));
+}
+
+#endif
+
+/*******************************************************************************
+* mvCpuIfLvdsPadsEnable
+*
+* DESCRIPTION:
+*	Enable / Disable the LVDS pads.
+*
+* INPUT:
+*	enable - MV_TRUE to enable the pads, MV_FALSE to disable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable)
+{
+	MV_U32 reg;
+	MV_U32 i;
+
+	reg = MV_REG_READ(LVDS_PADS_CTRL_REG);
+
+	for (i = 0; i < 5; i++) {
+		reg &= ~LVDS_PADS_CONF_PD_MASK(i);
+		reg |= LVDS_PADS_CONF_PD_EN(i, enable);
+	}
+
+	MV_REG_WRITE(LVDS_PADS_CTRL_REG, reg);
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.h
new file mode 100644
index 0000000..743ee2e
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIf.h
@@ -0,0 +1,121 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+MV_VOID   mvCpuIfEnablePex(MV_U32 pexUnit);
+MV_VOID   mvCpuIfPex4x1Enable(MV_U32 pexUnit, MV_BOOL enable);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfInit.S b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..655d01b
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvCommon.h"
+#include "mvOsAsm.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+	mov     r11, LR     		/* Save link register */
+	b       done
+#if 0
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+	/* goto calcConfigReg if device is 6281/6282 */
+	ldr     r5, =MV88F6281_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* goto calcConfigReg if device is 6192/6190 */
+	ldr     r5, =MV88F6192_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* Else 6180 */
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_CPUCLCK_MASK_6180
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3_1
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4_1
+	beq    setConfigReg
+	b    setConfigReg
+
+calcConfigReg:
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4
+	beq    setConfigReg
+
+	/* Else */
+	ldr    r4, =0
+
+setConfigReg:
+	/* Read CPU Config register */
+	MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+	ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+	and    r7, r7, r5       /* Clear register fields */
+	orr    r7, r7, r4       /* Set the values according to the findings */
+	MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+#endif
+
+done:
+	mov     PC, r11         /* r11 is saved link register */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
new file mode 100644
index 0000000..dfd52ad
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -0,0 +1,358 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE		(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
+#define CPU_RESET_REG(cpu)			(MV_CPUIF_SHARED_REGS_BASE + (0x800+(cpu)*8))
+#define CPU_RESUME_CTRL_REG			(MV_CPUIF_SHARED_REGS_BASE + (0x988))
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
+#define CL2_DUAL_EVICTION		(0x1 << 4)
+#define CL2_PARITY_ENABLE		(0x1 << 21)
+#define CL2_InvalEvicLineUCErr          (0x1 << 22)
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)			(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)			(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_IRQ_OFFS		28 
+#define CPU_INT_SOURCE_CONTROL_IRQ_MASK		(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS )
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+
+#define MV_IRQ_NR							116
+
+
+/*******************************************/
+/* ARM Doorbell Registers Map		   */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ						(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG					(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/*******************************************/
+/* CLOCK Complex Registers Map			   */
+/*******************************************/
+
+#define CPU_DIV_CLK_CTRL0_REG				(MV_CLK_CMPLX_REGS_OFFSET)
+#define CPU_DIV_CLK_CTRL0_RESET_MASK_OFFS	8
+#define CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0x8)
+#define CPU_DIV_CLK_CTRL2_NB_RATIO_OFFS		16
+#define CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0xC)
+#define CPU_DIV_CLK_CTRL3_CPU_RATIO_OFFS	8
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+
+#endif /* __INCmvCpuIfRegsh */
+
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.c b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.c
new file mode 100644
index 0000000..74c7f27
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "device/mvDevice.h"
+
+/* defines  */
+#ifdef DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvDevPramSet - Set device interface bank parameters
+*
+* DESCRIPTION:
+*       This function sets a device bank parameters to a given device.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*       *pDevParams - Device bank parameter struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+	if (pDevParams->turnOff > MAX_DBP_TURNOFF) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->turnOff out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2First > MAX_DBP_ACC2FIRST) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2First out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2Next > MAX_DBP_ACC2NEXT) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2Next out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->ale2Wr > MAX_DBP_ALE2WR) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrLow > MAX_DBP_WRLOW) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrHigh > MAX_DBP_WRHIGH) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->badrSkew << DBP_BADRSKEW_OFFS) > DBP_BADRSKEW_2CYCLE) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->badrSkew out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->deviceWidth != 8) && (pDevParams->deviceWidth != 16) && (pDevParams->deviceWidth != 32)) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth out of range\n"));
+		return MV_ERROR;
+	}
+
+	/* devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device)); */
+	/* setting values */
+	devParam |= DBP_TURNOFF_SET(pDevParams->turnOff);
+	devParam |= DBP_ACC2FIRST_SET(pDevParams->acc2First);
+	devParam |= DBP_ACC2NEXT_SET(pDevParams->acc2Next);
+	devParam |= ((pDevParams->badrSkew & DBP_BADRSKEW_MASK) << DBP_BADRSKEW_OFFS);
+
+	switch (pDevParams->deviceWidth) {
+	case 8:
+		devParam |= DBP_DEVWIDTH_8BIT;
+		break;
+	case 16:
+		devParam |= DBP_DEVWIDTH_16BIT;
+		break;
+	case 32:
+		devParam |= DBP_DEVWIDTH_32BIT;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	MV_REG_WRITE(DEV_BANK_PARAM_REG(device), devParam);
+
+	devParam = 0;
+	devParam |= DBP_ALE2WR_SET(pDevParams->ale2Wr);
+	devParam |= DBP_WRLOW_SET(pDevParams->wrLow);
+	devParam |= DBP_WRHIGH_SET(pDevParams->wrHigh);
+	MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(device), devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevPramget - Get device interface bank parameters
+*
+* DESCRIPTION:
+*       This function retrieves a device bank parameter settings.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       *pDevParams - Device bank parameter struct.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	pDevParams->turnOff = DBP_TURNOFF_GET(devParam);
+	pDevParams->acc2First = DBP_ACC2FIRST_GET(devParam);
+	pDevParams->acc2Next = DBP_ACC2NEXT_GET(devParam);
+	pDevParams->badrSkew = (devParam & DBP_BADRSKEW_MASK) >> DBP_BADRSKEW_OFFS;
+
+	switch (devParam & DBP_DEVWIDTH_MASK) {
+	case DBP_DEVWIDTH_8BIT:
+		pDevParams->deviceWidth = 8;
+		break;
+	case DBP_DEVWIDTH_16BIT:
+		pDevParams->deviceWidth = 16;
+		break;
+	case DBP_DEVWIDTH_32BIT:
+		pDevParams->deviceWidth = 32;
+		break;
+	default:
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth non valid value\n"));
+		return MV_ERROR;
+		break;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG_WR(device));
+	pDevParams->ale2Wr = DBP_ALE2WR_GET(devParam);
+	pDevParams->wrLow = DBP_WRLOW_GET(devParam);
+	pDevParams->wrHigh = DBP_WRHIGH_GET(devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevWidthGet - Get device width parameter
+*
+* DESCRIPTION:
+*       This function gets width parameter of a given device.
+*
+* INPUT:
+*       device - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Device width in bits (8,16,32...).
+*
+*******************************************************************************/
+MV_U32 mvDevWidthGet(MV_DEVICE device)
+{
+	MV_U32 devParam;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	devParam = (devParam & DBP_DEVWIDTH_MASK) >> DBP_DEVWIDTH_OFFS;
+
+	return (MV_U32) (0x8 << devParam);
+
+}
+
+/*******************************************************************************
+* mvDevNandDevCsSet - Set NAND chip-select, care mode and init sequence
+*
+* DESCRIPTION:
+*       This function set the NAND flash controller registers with NAND
+*       device chip-select.
+*
+* INPUT:
+*       devNum   - Device number. See MV_DEVICE enumerator.
+*       careMode - NAND device care mode (0 = Don't care, '1' = care).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode)
+{
+	MV_U32 nfCtrlReg;	/* NAND Flash Control Register */
+
+	/* Set chip select */
+	nfCtrlReg = MV_REG_READ(DEV_NAND_CTRL_REG);
+
+	nfCtrlReg |= (DINFCR_NF_CS_MASK(device));
+
+	if (careMode)
+		nfCtrlReg |= (DINFCR_NF_ACT_CE_MASK(device));
+	else
+		nfCtrlReg &= ~(DINFCR_NF_ACT_CE_MASK(device));
+
+	MV_REG_WRITE(DEV_NAND_CTRL_REG, nfCtrlReg);
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.h b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.h
new file mode 100644
index 0000000..2f7d33f
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDevice.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceH
+#define __INCmvDeviceH
+
+#include "device/mvDeviceRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* This structure describes device interface parameters to be assigned to   */
+/* device bank parameter                                                    */
+typedef struct _mvDeviceParam {
+				/* boundary values */
+    MV_U32       turnOff;	/* 0x0 - 0xf       */
+    MV_U32       acc2First;	/* 0x0 - 0x1f      */
+    MV_U32       acc2Next;	/* 0x0 - 0x1f      */
+    MV_U32       ale2Wr;	/* 0x0 - 0xf       */
+    MV_U32       wrLow;		/* 0x0 - 0xf       */
+    MV_U32       wrHigh;	/* 0x0 - 0xf       */
+    MV_U32       badrSkew;	/* 0x0 - 0x2       */
+    MV_U32       deviceWidth;	/* in Bytes        */
+} MV_DEVICE_PARAM;
+
+
+/* mvDevPramSet - Set device interface bank parameters */
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevPramget - Get device interface bank parameters */
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevWidthGet - Get device width parameter*/
+MV_U32 mvDevWidthGet(MV_DEVICE device);
+
+/* mvDevNandDevCsSet - Set the NAND flash control registers with NAND device- */
+/* select and care mode */
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode);
+
+#endif /* #ifndef __INCmvDeviceH */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/device/mvDeviceRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDeviceRegs.h
new file mode 100644
index 0000000..25fea91
--- /dev/null
+++ b/arch/arm/mach-avantalp/avanta_lp_family/device/mvDeviceRegs.h
@@ -0,0 +1,270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceRegsH
+#define __INCmvDeviceRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_DEVICE_MAX_XBAR_TIMEOUT  0x0FFF
+/* TODO - usage of DEV_BANK_PARAM_REG_DV is unclear */
+/* #define DEV_BANK_PARAM_REG_DV	    0x80000000 */
+/* registers offsets */
+
+static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
+{
+	switch (num) {
+	case (DEV_BOOCS):
+		return MV_DEV_BUS_REGS_OFFSET + 0x00;
+	case (DEVICE_CS0):
+		return MV_DEV_BUS_REGS_OFFSET + 0x08;
+	case (DEVICE_CS1):
+		return MV_DEV_BUS_REGS_OFFSET + 0x10;
+#ifdef MV_INCLUDE_DEVICE_CS2
+	case (DEVICE_CS2):
+		return MV_DEV_BUS_REGS_OFFSET + 0x18;
+#endif
+#ifdef MV_INCLUDE_DEVICE_CS3
+	case (DEVICE_CS3):
+		return MV_DEV_BUS_REGS_OFFSET + 0x20;
+#endif
+	default:
+		return 0xFFFFFFFF;
+	}
+}
+
+#define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
+
+/* Device Bank Parameters register fields (DBP_REG)*/
+/* Boot Device Bank Parameters (DBP) register fields (DEV_BOOT_BANK_PARAM_REG)*/
+/* DBP_XXX_MASK_HIGH is the offset of the extend bit from the msb of the input value */
+
+#define DBP_TURNOFF_OFFS_LOW		0
+#define DBP_TURNOFF_MASK_LOW		0x3F
+#define MAX_DBP_TURNOFF			0xf
+
+
+#define DBP_TURNOFF_SET(value)			\
+((value & DBP_TURNOFF_MASK_LOW) << DBP_TURNOFF_OFFS_LOW)
+
+#define DBP_TURNOFF_GET(value)			\
+((value >> DBP_TURNOFF_OFFS_LOW) & DBP_TURNOFF_MASK_LOW)
+
+#define DBP_ACC2FIRST_OFFS_LOW		6
+#define DBP_ACC2FIRST_MASK_LOW		0x3f
+#define MAX_DBP_ACC2FIRST		0x3f
+
+#define DBP_ACC2FIRST_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2FIRST_GET(value)			\
+((value >> DBP_ACC2FIRST_OFFS_LOW) & DBP_ACC2FIRST_MASK_LOW)
+
+#define DBP_ACC2NEXT_OFFS_LOW		17
+#define DBP_ACC2NEXT_MASK_LOW		0x3f
+#define MAX_DBP_ACC2NEXT		0x3f
+
+#define DBP_ACC2NEXT_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2NEXT_GET(value)			\
+((value >> DBP_ACC2NEXT_OFFS_LOW) & DBP_ACC2NEXT_MASK_LOW)
+
+#define DBP_DEVWIDTH_OFFS		30 /* Device Width */
+#define DBP_DEVWIDTH_MASK		(0x3 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_8BIT		(0x0 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_16BIT		(0x1 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_32BIT		(0x2 << DBP_DEVWIDTH_OFFS)
+
+#define DBP_BADRSKEW_OFFS		28
+#define DBP_BADRSKEW_MASK		(0x3 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_NOGAP		(0x0 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_1CYCLE		(0x1 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_2CYCLE		(0x2 << DBP_BADRSKEW_OFFS)
+
+
+#define DBP_ALE2WR_OFFS_LOW		0
+#define DBP_ALE2WR_MASK_LOW		0x3f
+#define MAX_DBP_ALE2WR			0x3F
+
+#define DBP_ALE2WR_SET(value)			\
+((value & DBP_ALE2WR_MASK_LOW) << DBP_ALE2WR_OFFS_LOW)
+
+#define DBP_ALE2WR_GET(value)			\
+((value >> DBP_ALE2WR_OFFS_LOW) & DBP_ALE2WR_MASK_LOW)
+
+#define DBP_WRLOW_OFFS_LOW		8
+#define DBP_WRLOW_MASK_LOW		0x3F
+#define MAX_DBP_WRLOW			0x3F
+
+#define DBP_WRLOW_SET(value)			\
+((value & DBP_WRLOW_MASK_LOW) << DBP_WRLOW_OFFS_LOW)
+
+#define DBP_WRLOW_GET(value)			\
+((value >> DBP_WRLOW_OFFS_LOW) & DBP_WRLOW_MASK_LOW)
+
+#define DBP_WRHIGH_OFFS_LOW		16
+#define DBP_WRHIGH_MASK_LOW		0x3F
+#define MAX_DBP_WRHIGH			0x3F
+
+#define DBP_WRHIGH_SET(value)			\
+((value & DBP_WRHIGH_MASK_LOW) << DBP_WRHIGH_OFFS_LOW)
+
+#define DBP_WRHIGH_GET(value)			\
+((value >> DBP_WRHIGH_OFFS_LOW) & DBP_WRHIGH_MASK_LOW)
+
+
+/* Device Interface Control register fields (DIC) (DIC_REG)*/
+#define DIC_TIMEOUT_OFFS 	0 /* Timeout Timer Preset Value. */
+#define DIC_TIMEOUT_MASK 	(0xffff << DIC_TIMEOUT_OFFS)
+#define MAX_DIC_TIMEOUT		0xffff
+
+/* NAND Flash Control register fields (NF) (NF_REG)*/
+#define NF_BOOTCS_OFFS			0 /* Define if BOOTCS is connected to NAND Flash */
+#define NF_BOOT_MASK			(1 << NF_BOOTCS_OFFS)
+#define NF_BOOT_NC			(0 << NF_BOOTCS_OFFS)
+#define NF_BOOT_C			(1 << NF_BOOTCS_OFFS)
+
+#define NF_BOOTCS_CE_ACT_OFFS		1 /* Define if NAND Flash on BOOTCS is CE care or CE don't care */
+#define NF_BOOTCS_CE_ACT_MASK 		(1 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_NCARE		(0 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_CARE		(1 << NF_BOOTCS_CE_ACT_OFFS)
+
+#define NF_CS0_OFFS			2 /* Define if CS0 is connected to NAND Flash */
+#define NF_CS0_MASK			(1 << NF_CS0_OFFS)
+#define NF_CS0_NC			(0 << NF_CS0_OFFS)
+#define NF_CS0_C			(1 << NF_CS0_OFFS)
+
+#define NF_CS0_CE_ACT_OFFS		3 /* Define if NAND Flash on CS0 is CE care or CE don't care */
+#define NF_CS0_CE_ACT_MASK 		(1 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_NCARE		(0 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_CARE		(1 << NF_CS0_CE_ACT_OFFS)
+
+#define NF_CS1_OFFS			4 /* Define if CS1 is connected to NAND Flash */
+#define NF_CS1_MASK			(1 << NF_CS1_OFFS)
+#define NF_CS1_NC			(0 << NF_CS1_OFFS)
+#define NF_CS1_C			(1 << NF_CS1_OFFS)
+
+#define NF_CS1_CE_ACT_OFFS		5 /* Define if NAND Flash on CS1 is CE care or CE don't care */
+#define NF_CS1_CE_ACT_MASK		(1 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_NCARE		(0 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_CARE		(1 << NF_CS1_CE_ACT_OFFS)
+
+#define NF_CS2_OFFS			6 /* Define if CS2 is connected to NAND Flash */
+#define NF_CS2_MASK			(1 << NF_CS2_OFFS)
+#define NF_CS2_NC			(0 << NF_CS2_OFFS)
+#define NF_CS2_C			(1 << NF_CS2_OFFS)
+
+#define NF_CS2_CE_ACT_OFFS		7 /* Define if NAND Flash on CS2 is CE care or CE don't care */
+#define NF_CS2_CE_ACT_MASK		(1 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_NCARE		(0 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_CARE		(1 << NF_CS2_CE_ACT_OFFS)
+
+#define NF_INIT_SEQ_OFFS		8 /* NAND Flash initialization sequence */
+#define NF_INIT_SEQ_MASK		(1 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_EN			(0 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_DIS			(1 << NF_INIT_SEQ_OFFS)
+
+#define NF_OE_HIGHW_OFFS		9 /* NAND Flash OE high width in core clocks units (value + 1) */
+#define NF_OE_HIGHW_MASK		(0x1f << NF_OE_HIGHW_OFFS)
+#define MAX_OE_HIGHW			(0x1f << NF_OE_HIGHW_OFFS)
+
+#define NF_TREADY_OFFS			14 /* NAND Flash time ready in core clocks units (value + 1) */
+#define NF_TREADY_MASK			(0x1f << NF_TREADY_OFFS)
+#define MAX_TREADY			(0x1f << NF_TREADY_OFFS)
+
+#define NF_OE_TCTRL_OFFS		19 /* NAND Flash OE toggle control */
+#define NF_OE_TCTRL_MASK		(1 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_1_CYC_AFT		(0 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_SAME_CYC		(1 << NF_OE_TCTRL_OFFS)
+
+#define NF_CS3_OFFS			20 /* Define if CS3 is connected to NAND Flash */
+#define NF_CS3_MASK			(1 << NF_CS3_OFFS)
+#define NF_CS3_NC			(0 << NF_CS3_OFFS)
+#define NF_CS3_C			(1 << NF_CS3_OFFS)
+
+#define NF_CS3_CE_ACT_OFFS		21 /* Define if NAND Flash on CS3 is CE care or CE don't care */
+#define NF_CS3_CE_ACT_MASK		(1 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_NCARE		(0 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_CARE		(1 << NF_CS3_CE_ACT_OFFS)
+
+
+/* Device Interface NAND Flash Control Register (DINFCR) */
+#define DINFCR_NF_CS_MASK(csNum)         \
+(csNum == BOOT_CS) ?  0x1 : ((csNum == DEV_CS3) ? (0x1 << 20) : (0x1 << (((csNum+1) % MV_DEV_MAX_CS) * 2)))
+
+
+#define DINFCR_NF_ACT_CE_MASK(csNum)     \
+(csNum == DEV_CS3) ? (0x2 << 20) : (0x2 << (((csNum+1) % MV_DEV_MAX_CS) * 2))
+
+#define NAND_ACTCEBOOT_BIT	BIT1
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCmvDeviceRegsH */
diff --git a/arch/arm/plat-armada/common/mvDeviceId.h b/arch/arm/plat-armada/common/mvDeviceId.h
index 1fa4b43..3b4e40c 100644
--- a/arch/arm/plat-armada/common/mvDeviceId.h
+++ b/arch/arm/plat-armada/common/mvDeviceId.h
@@ -70,7 +70,8 @@ extern "C" {
 #endif	/* __cplusplus */
 
 /* defines  */
-#define MARVELL_VEN_ID		    0x11ab
+#define MARVELL_VEN_ID			0x11ab
+#define MV_INVALID_DEV_ID		0xffff
 
 /* Disco-3 */
 #define MV64460_DEV_ID          	0x6480
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
index 2b620c1..41a7954 100755
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
@@ -137,6 +137,7 @@ MV_U32 mvDramIfSizeGet(MV_VOID)
 }
 MV_U32 mvDramIfHwSizeGet(MV_VOID)
 {
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
 	MV_U32 base = 0;
 	MV_U32 size, cs, totalSize = 0, sizeRegVal;
 
@@ -158,6 +159,9 @@ MV_U32 mvDramIfHwSizeGet(MV_VOID)
 	totalSize = (sizeRegVal + 1) * SDRAMWCR_SIZE_ALLIGNMENT;    	     /* size = alined size (num of 16mb chunks * 16mb) */
 	/* Dram size alignment fix*/
 	return totalSize;
+#else
+	return CONFIG_SYS_FPGA_DRAM_SIZE;
+#endif
 }
 MV_U32 mvDramIfHwCsSizeGet(MV_U32 cs)
 {
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfBasicInit.S b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfBasicInit.S
new file mode 100644
index 0000000..f4e9f87
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfBasicInit.S
@@ -0,0 +1,280 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define	_ASMLANGUAGE
+#define MV_ASMLANGUAGE
+#include "mvSysHwConfig.h"
+#include "mvOsAsm.h"
+#include "mvBoardEnvSpec.h"
+#include "mvCpuIfRegs.h"
+#include "mvDramIfConfig.h"
+#include "mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+#include "mvCtrlEnvSpec.h"
+#include "mvCtrlEnvAsm.h"
+#include "mvCommon.h"
+
+/* defines */
+
+#if defined(MV_STATIC_DRAM_ON_BOARD)
+
+.globl dramBoot1
+dramBoot1:
+        .word   0
+
+	/* For   1GB DDR3 SODIM */
+	#define STATIC_SDRAM_CONFIG	     	0x7301C0C3 /*	0x1400  */
+	#define STATIC_DUNIT_CTRL_LOW		0x3630B800 /*   0x1404  */
+	#define STATIC_SDRAM_TIME_CTRL_LOW	0x43149887 /*   0x1408  */ /* 1600 => 0x5415baab */
+	#define STATIC_SDRAM_TIME_CTRL_HI	0x38583F98 /*   0x140c  */ /* 1600 => 0x38d83fff */
+	#define STATIC_SDRAM_ADDR_CTRL		0x100F0000 /*   0x1410  */ /* 1600 => 0x110F0000 */
+	#define STATIC_DUNIT_CTRL_HI		0x0000d3ff /*   0x1424  default */
+	#define	STATIC_DDR_ODT_TIMING_LOW	0x000f8830 /*   0x1428  New */
+	#define	STATIC_DDR3_TIMING		0x014c2f38 /*   0x142C  New */
+	#define STATIC_SDRAM_DDR2_TIMING_HI	0x0000c671 /*   0x147C  default */
+	#define STATIC_SDRAM_DUNIT_ODT_CTRL    	0x00000001 /*   0x149c  */
+	#define STATIC_DRAM_AXI_CTRL		0x00000101 /*   0x14a8  */
+	#define	STATIC_DDR_IO			0x00008800 /*   0x1524  New */
+	#define	STATIC_DDR_DFS			0x00032af0 /*   0x1528  New */
+	#define	STATIC_DDR_MR0			0x00000620 /*   0x15D0  New - MR0 */
+	#define	STATIC_DDR_MR1			0x00000001 /*   0x15D4  New - MR1 */
+	#define	STATIC_DDR_MR2			0x00000008 /*   0x15D8  New - MR2 */
+	#define STATIC_DDR_MR3			0x00000000 /*   0x15DC  New - MR3 */
+	#define	STATIC_DDR3_RANK_CTRL		0x00000001 /*   0x15E0  New */
+	#define	STATIC_ZQC_CONFIG		0x00203C18 /*   0x15E4  New - ZQC Config */
+	#define STATIC_DRAM_PHY_CONFIG		0xD8000025 /*   0x15EC  - SBen */
+
+
+	#define	STATIC_MAIN_PADS_CALIB_CTRL	0x3d090009 /*   0X14cc  */
+	#define	STATIC_TRAINING_DEBUG_3		0x3d090009 /*   0X15C8  */
+
+
+	/* T-Domain */
+	#define	STATIC_READ_DATA_SMPL_DLY	0x00000808 /*   0x1538  New */
+	#define	STATIC_READ_DATA_RDY_DLY	0x00000d0d /*   0x153C  New */
+	/* Phy */
+	#define	STATIC_PHY_LOCK_MASK		0x00000fff /*   0x1670  New */
+	/* DLB */
+	#define STATIC_DRAM_DLB_CONTROL		0x2000005D /*   0x1700  */
+	#define STATIC_DRAM_DLB_BUS_OPT_WEIT	0x0018C01E /*   0x1704  */
+	#define STATIC_DRAM_DLB_AGING		0x00F7F07F /*   0x1708  */
+	#define STATIC_DRAM_DLB_EVICT_CTRL	0x0000008D /*   0x170C  */
+	#define STATIC_DRAM_DLB_EVICT_TIMR	0x00FF3C1F /*   0x1710  */
+	#define STATIC_DRAM_DLB_USR_CMD		0x00000000 /*   0x1714  */
+
+	/* CIB 2to1 */
+	#define CDI_CONFIG                      0x00000007 /*   0x20220 */
+	#define CDI_CONFIG2                     0x00000001 /*   0x20220 */
+
+	.globl _mvDramIfStaticInit
+_mvDramIfStaticInit:
+
+	mov     r11, LR     		/* Save link register */
+	mov	r10, r2
+
+	ldr	r6, = STATIC_SDRAM_CONFIG
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001400)
+	ldr	r6, = STATIC_DUNIT_CTRL_LOW
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001404)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_LOW
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001408)
+	ldr	r6, = STATIC_SDRAM_TIME_CTRL_HI
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf100140C)
+	ldr	r6, = STATIC_SDRAM_ADDR_CTRL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001410)
+	ldr	r6, = STATIC_DUNIT_CTRL_HI
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001424)
+	ldr	r6, = STATIC_DDR_ODT_TIMING_LOW
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001428)
+	ldr	r6, = STATIC_DDR3_TIMING
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf100142C)
+
+	ldr	r6, = STATIC_SDRAM_DDR2_TIMING_HI
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf100147C)
+	ldr	r6, = STATIC_DRAM_AXI_CTRL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10014A8)
+	ldr	r6, = STATIC_DDR_IO
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001524)
+	ldr	r6, = STATIC_DDR_DFS
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001528)
+
+
+	/* T-Domain */
+	ldr	r6, = STATIC_READ_DATA_SMPL_DLY
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001538)
+	ldr	r6, = STATIC_READ_DATA_RDY_DLY
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf100153C)
+
+	ldr	r6, = STATIC_DDR_MR0
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015D0)
+	ldr	r6, = STATIC_DDR_MR1
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015D4)
+	ldr	r6, = STATIC_DDR_MR2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015D8)
+	ldr	r6, = STATIC_DDR_MR3
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015DC)
+	ldr	r6, = STATIC_DDR3_RANK_CTRL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015E0)
+	ldr	r6, = STATIC_ZQC_CONFIG
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015E4)
+	ldr	r6, = STATIC_DRAM_PHY_CONFIG
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015EC)
+
+
+	ldr	r6, = STATIC_PHY_LOCK_MASK
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001670)
+
+	/* Phase Select */
+	ldr	r6, = 0xC8003400
+	ldr	r2, = FPGA_DDR3_DELAY_PHASE
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8043400
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8000000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8010000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8020000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8030000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8040000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8050000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8060000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8070000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC8090000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+	ldr	r6, = 0xC80a0000
+	orr	r6, r6, r2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10016A0)
+
+#ifdef MV88F66XX
+	ldr	r6, = STATIC_MAIN_PADS_CALIB_CTRL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10014cc)	
+	ldr	r6, = STATIC_TRAINING_DEBUG_3
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf10015C8)	
+#else
+	 /* DLB */
+	/* Enable DLB in DSMP-A0 */
+	ldr	r6, = STATIC_DRAM_DLB_CONTROL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001700)
+	ldr	r6, = STATIC_DRAM_DLB_BUS_OPT_WEIT
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001704)
+	ldr	r6, = STATIC_DRAM_DLB_AGING
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001708)
+	ldr	r6, = STATIC_DRAM_DLB_EVICT_CTRL
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf100170C)
+	ldr	r6, = STATIC_DRAM_DLB_EVICT_TIMR
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001710)
+	ldr	r6, = STATIC_DRAM_DLB_USR_CMD
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf1001714)
+	ldr	r6, = 0x00010F0F
+	MV_32BIT_WRITE_ASM(r6, r5, 0xf102042C)
+#endif
+
+	/* CDI Config  2to1 */
+	ldr	r6, = CDI_CONFIG
+	MV_32BIT_WRITE_ASM(r6, r5, 0xF1020220)
+
+#ifdef MV88F66XX
+	ldr	r6, = CDI_CONFIG2
+	MV_32BIT_WRITE_ASM(r6, r5, 0xF1020220)
+#endif
+
+     	/*DDR SDRAM Initialization Control */
+	ldr	r6, =DSICR_INIT_EN
+	MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+2:	MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
+         and    r6, r6, #DSICR_INIT_EN
+         cmp    r6, #0
+         bne 2b
+
+
+	/* set all dram windows to 0 */
+	mov	r6, #0
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_WIN_CTRL_REG(0))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_WIN_CTRL_REG(1))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_WIN_CTRL_REG(2))
+	MV_REG_WRITE_ASM(r6, r5, SDRAM_WIN_CTRL_REG(3))
+
+
+	ldr	r0, =0
+
+	mov 	r2, r10
+	mov     PC, r11         	/* r11 is saved link register */
+
+#endif /* MV_STATIC_DRAM_ON_BOARD */
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfConfig.h b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfConfig.h
new file mode 100644
index 0000000..080da02
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfConfig.h
@@ -0,0 +1,161 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvDramIfConfigh
+#define __INCmvDramIfConfigh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+
+/* defines  */
+
+/* registers defaults values */
+
+#define SDRAM_CONFIG_DV 	(SDRAM_SRMODE_DRAM | BIT25 | BIT30)
+
+#define SDRAM_DUNIT_CTRL_LOW_DDR2_DV			\
+		(SDRAM_SRCLK_KEPT		|	\
+		 SDRAM_CLK1DRV_NORMAL		|	\
+		 (BIT28 | BIT29))
+
+#define SDRAM_ADDR_CTRL_DV	    2
+
+#define SDRAM_TIMING_CTRL_LOW_REG_DV 	\
+		((0x2 << SDRAM_TRCD_OFFS) | 	\
+		 (0x2 << SDRAM_TRP_OFFS)  | 	\
+		 (0x1 << SDRAM_TWR_OFFS)  | 	\
+		 (0x0 << SDRAM_TWTR_OFFS) | 	\
+		 (0x5 << SDRAM_TRAS_OFFS) | 	\
+		 (0x1 << SDRAM_TRRD_OFFS))
+
+/* Note: value of 0 in register means one cycle, 1 means two and so on  */
+#define SDRAM_TIMING_CTRL_HIGH_REG_DV 	\
+		((0x0 << SDRAM_TR2R_OFFS)	|	\
+		 (0x0 << SDRAM_TR2W_W2R_OFFS)	|	\
+		 (0x1 << SDRAM_TW2W_OFFS))
+
+#define SDRAM_OPEN_PAGES_CTRL_REG_DV 	SDRAM_OPEN_PAGE_EN	
+
+/* Presence	     Ctrl Low    Ctrl High  Dunit Ctrl   Ext Mode     */
+/* CS0              0x84210000  0x00000000  0x0000780F  0x00000440    */
+/* CS0+CS1          0x84210000  0x00000000  0x0000780F  0x00000440    */
+/* CS0+CS2          0x030C030C  0x00000000  0x0000740F  0x00000404    */
+/* CS0+CS1+CS2      0x030C030C  0x00000000  0x0000740F  0x00000404    */
+/* CS0+CS2+CS3      0x030C030C  0x00000000  0x0000740F  0x00000404    */
+/* CS0+CS1+CS2+CS3  0x030C030C  0x00000000  0x0000740F  0x00000404    */
+
+#define DDR2_ODT_CTRL_LOW_CS0_CS1_DV		0x84210000
+#define DDR2_ODT_CTRL_HIGH_CS0_CS1_DV		0x00000000
+#define DDR2_DUNIT_ODT_CTRL_CS0_CS1_DV		0x0000E80F
+#if defined(MV78XX0) && !defined(DB_AURORA)
+#define DDR_SDRAM_EXT_MODE_CS0_CS1_DV		0x00000040
+#elif defined(MV78XX0) && defined(DB_AURORA)
+    #define DDR_SDRAM_EXT_MODE_CS0_CS1_DV		0x00000401
+#else
+#define DDR_SDRAM_EXT_MODE_CS0_CS1_DV		0x00000440
+#endif
+
+#define DDR2_ODT_CTRL_LOW_CS0_CS1_CS2_CS3_DV	0x030C030C
+#define DDR2_ODT_CTRL_HIGH_CS0_CS1_CS2_CS3_DV	0x00000000
+#define DDR2_DUNIT_ODT_CTRL_CS0_CS1_CS2_CS3_DV	0x0000FC0F
+#ifdef MV78XX0
+#define DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV	0x00000004
+#define DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV	0x00000044
+#else
+#define DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV	0x00000404
+#define DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV	0x00000444
+#endif
+
+/* DDR SDRAM Adderss/Control and Data Pads Calibration default values */
+#define DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV	\
+		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
+		
+#define DDR2_DATA_PAD_STRENGTH_TYPICAL_DV		\
+		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
+
+/* DDR SDRAM Mode Register default value */
+#define DDR2_MODE_REG_DV		(SDRAM_BURST_LEN_4 | SDRAM_WR_3_CYC)
+/* DDR SDRAM Timing parameter default values */
+#define DD2_SDRAM_TIMING_LOW_DV			0x85520
+#define DDR2_SDRAM_TIMING_HIGH_DV		0x8552
+#if defined(DB_AURORA)
+#define SDRAM_TIMING_CTRL_LOW_REG_DEFAULT  	0x33036553
+#else
+#define SDRAM_TIMING_CTRL_LOW_REG_DEFAULT  	0x33136552
+#endif
+#define SDRAM_TRFC_DEFAULT_VALUE		0x34
+#define SDRAM_TRFC_DEFAULT		SDRAM_TRFC_DEFAULT_VALUE
+#define SDRAM_TW2W_DEFALT		(0x1 << SDRAM_TW2W_OFFS)
+
+#define SDRAM_TIMING_CTRL_HIGH_REG_DEFAULT  (SDRAM_TRFC_DEFAULT | SDRAM_TW2W_DEFALT)
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvDramIfh */
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
index c1036aa..f2380df 100644
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
@@ -93,6 +93,11 @@ extern "C" {
 #define SDRAM_MAX_CS					4
 #define SRAM_WIN_CTRL_DEFAULT_VAL		0x100
 
+/* DDR SDRAM Initialization Control Register (DSICR) */
+#define DDR_SDRAM_INIT_CTRL_REG	    (MV_DDR_REGS_BASE + 0x1480)
+#define DSICR_INIT_EN		    	(1 << 0)
+#define DSICR_T200_SET		    	(1 << 8)
+
 /* sdram extended mode2 register (SEM2R) */
 #define SDRAM_PHY_REGISTER_FILE_ACCESS		(MV_DDR_CTRL_REGS_BASE + 0x16A0)
 
@@ -141,6 +146,9 @@ extern "C" {
 #define SECR_THRECC_MASK            (SECR_THRECC_MAX << SECR_THRECC_OFFS)
 #define SECR_THRECC(threshold)      (threshold << SECR_THRECC_OFFS)
 
+/* FPGA - Delay Phase */
+#define FPGA_DDR3_DELAY_PHASE		0x00000004
+
  /* SDRAM CSn Size Register (SCSR) */
 #define SDRAM_SIZE_REG(csNum)	(0x1504 + ((csNum) * 8))
 #define SCSR_SIZE_OFFS			24
diff --git a/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c
index 630a5c4..b032ab6 100644
--- a/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c
@@ -91,6 +91,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *	MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
 *
 *******************************************************************************/
+#if !defined (MV88F66XX)
 MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 {
 	MV_PEX_TYPE pexType;
@@ -105,6 +106,7 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 	}
 	return mvSysPexInit(pciIf, pexType);
 }
+#endif
 
 /* PCI configuration space read write */
 /*******************************************************************************
@@ -133,7 +135,11 @@ MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
 *******************************************************************************/
 MV_U32 mvPciIfConfigRead(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexConfigRead(pciIf, bus, dev, func, regOff);
+#else
+	return mvPciConfigRead(pciIf, bus, dev, func, regOff);
+#endif
 }
 
 /*******************************************************************************
@@ -163,7 +169,11 @@ MV_U32 mvPciIfConfigRead(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U
 *******************************************************************************/
 MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff, MV_U32 data)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexConfigWrite(pciIf, bus, dev, func, regOff, data);
+#else
+	return mvPciConfigWrite(pciIf, bus, dev, func, regOff, data);
+#endif
 }
 
 /*******************************************************************************
@@ -188,7 +198,11 @@ MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func,
 *******************************************************************************/
 MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexMasterEnable(pciIf, enable);
+#else
+	return mvPciMasterEnable(pciIf, enable);
+#endif
 }
 
 /*******************************************************************************
@@ -214,7 +228,11 @@ MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable)
 *******************************************************************************/
 MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexSlaveEnable(pciIf, bus, dev, enable);
+#else
+	return mvPciSlaveEnable(pciIf, bus, dev, enable);
+#endif
 }
 
 /*******************************************************************************
@@ -238,7 +256,11 @@ MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enabl
 *******************************************************************************/
 MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexLocalBusNumSet(pciIf, busNum);
+#else
+	return mvPciLocalBusNumSet(pciIf, busNum);
+#endif
 }
 
 /*******************************************************************************
@@ -259,7 +281,11 @@ MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum)
 *******************************************************************************/
 MV_U32 mvPciIfLocalBusNumGet(MV_U32 pciIf)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexLocalBusNumGet(pciIf);
+#else
+	return mvPciLocalBusNumGet(pciIf);
+#endif
 }
 
 /*******************************************************************************
@@ -283,7 +309,11 @@ MV_U32 mvPciIfLocalBusNumGet(MV_U32 pciIf)
 *******************************************************************************/
 MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)
 {
+#if defined(MV_INCLUDE_PEX)
 	return mvPexLocalDevNumSet(pciIf, devNum);
+#else
+	return mvPciLocalDevNumSet(pciIf, devNum);
+#endif
 }
 
 /*******************************************************************************
@@ -304,7 +334,11 @@ MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)
 *******************************************************************************/
 MV_U32 mvPciIfLocalDevNumGet(MV_U32 pciIf)
 {
+#if defined (MV_INCLUDE_PEX)
 	return mvPexLocalDevNumGet(pciIf);
+#else
+	return mvPciLocalDevNumGet(pciIf);
+#endif
 }
 
 /*******************************************************************************
diff --git a/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
index 9596daf..9d5cb79 100644
--- a/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
+++ b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
@@ -110,7 +110,11 @@ MV_STATUS mvPciScan(MV_U32 pciIf, MV_PCI_DEVICE *pPciAgents, MV_U32 * pPciAgents
 {
 
 	MV_U32 devIndex, funcIndex = 0, busIndex = 0, detectedDevNum = 0;
+#if !defined(MV_INCLUDE_PCI)
 	MV_U32 localBus = mvPexLocalBusNumGet(pciIf);
+#else
+	MV_U32 localBus = mvPciIfLocalBusNumGet(pciIf);
+#endif
 	MV_PCI_DEVICE *pPciDevice;
 	MV_PCI_DEVICE *pMainDevice;
 
@@ -246,9 +250,12 @@ static MV_STATUS pciDetectDevice(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 fu
 	 */
 #if defined(MV_INCLUDE_PCI)
 	if ((PCI_IF_TYPE_CONVEN_PCIX == mvPciIfTypeGet(pciIf)) &&
+#if !defined(MV88F66XX)
 			(DB_88F5181_DDR1_PRPMC != mvBoardIdGet()) &&
 			(DB_88F5181_DDR1_PEXPCI != mvBoardIdGet()) &&
-			(DB_88F5181_DDR1_MNG != mvBoardIdGet()) && (mvBoardIsOurPciSlot(bus, dev) == MV_FALSE))
+			(DB_88F5181_DDR1_MNG != mvBoardIdGet()) &&
+#endif 
+			(mvBoardIsOurPciSlot(bus, dev) == MV_FALSE))
 		return MV_ERROR;
 
 #endif /* defined(MV_INCLUDE_PCI) */
-- 
1.7.5.4

