From 61ba743878a0661ff481f5383a7a98c4c48d9df1 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Sun, 10 Nov 2013 13:16:56 +0200
Subject: [PATCH 1143/1825] pp2: pp2.1 add DPI support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9b4f5372900741f686a8e64b6cceb5f49b3d53f8

        - add DPI (deep packet inspection)
	  support for ppv2.1 (A0)

Change-Id: Ic5ab8d6f6898af24631ae38b5a9d28775a2417f9
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4352
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    3 +
 .../mv_drivers_lsp/mv_pp2/dpi/dpi_sysfs.c          |  296 ++++++++++++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h   |    3 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |    2 +
 arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.c   |  370 ++++++++++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.h   |  264 ++++++++++++++
 6 files changed, 938 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/dpi/dpi_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index e4feff2..25bcf51 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -15,6 +15,7 @@ PP2_CLS_DIR   = ../../mv_hal/pp2/cls
 PP2_PME_DIR   = ../../mv_hal/pp2/pme
 PP2_PLCR_DIR  = ../../mv_hal/pp2/plcr
 PP2_WOL_DIR   = ../../mv_hal/pp2/wol
+PP2_DPI_DIR   = ../../mv_hal/pp2/dpi
 PP2_COMMON_DIR= ../../mv_hal/pp2/common
 
 mv_pp2-objs +=	$(PP2_GMAC_DIR)/mvEthGmacApi.o
@@ -29,6 +30,7 @@ mv_pp2-objs += 	$(PP2_PME_DIR)/mvPp2PmeHw.o
 mv_pp2-objs += 	$(PP2_PLCR_DIR)/mvPp2PlcrHw.o
 mv_pp2-objs +=	$(PP2_BM_DIR)/mvBm.o
 mv_pp2-objs +=  $(PP2_WOL_DIR)/mvPp2Wol.o
+mv_pp2-objs +=  $(PP2_DPI_DIR)/mvPp2DpiHw.o
 mv_pp2-objs +=  $(PP2_COMMON_DIR)/mvPp2Common.o
 
 mv_pp2-objs += net_dev/mv_netdev.o net_dev/mv_ethernet.o net_dev/mv_eth_sysfs.o net_dev/mv_eth_tool.o
@@ -45,6 +47,7 @@ mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.
 mv_pp2-objs += pme/pme_sysfs.o
 mv_pp2-objs += plcr/plcr_sysfs.o
 mv_pp2-objs += wol/wol_sysfs.o
+mv_pp2-objs += dpi/dpi_sysfs.o
 
 ifeq ($(CONFIG_MV_ETH_L2FW),y)
 mv_pp2-objs += l2fw/l2fw_sysfs.o l2fw/mv_eth_l2fw.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/dpi/dpi_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/dpi/dpi_sysfs.c
new file mode 100644
index 0000000..f8ddd7b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/dpi/dpi_sysfs.c
@@ -0,0 +1,296 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "dpi/mvPp2DpiHw.h"
+
+
+static ssize_t dpi_help(char *b)
+{
+	int o = 0;
+
+	o += scnprintf(b + o, PAGE_SIZE - o, "arguments c, d, o, s, n: decimal numbers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "arguments b, m         : hexadecimal numbers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "[c] counter valid range [0..%d]\n", MV_PP2_DPI_CNTRS - 1);
+	o += scnprintf(b + o, PAGE_SIZE - o, "[o] window offset valid range [0..%d] bytes\n", MV_PP2_DPI_WIN_OFFSET_MAX);
+	o += scnprintf(b + o, PAGE_SIZE - o, "[s] window size valid range [0..%d] bytes\n", MV_PP2_DPI_WIN_SIZE_MAX);
+	o += scnprintf(b + o, PAGE_SIZE - o, "[n] number of descriptors valid range [0..%d]\n", MV_PP2_DPI_Q_SIZE_MAX);
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat            help    - Show this help\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat            regs    - Show DPI hardware registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo d         queues  - Show DPI request and result queues. 0-brief, 1-full\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo c o s   > win     - Set window offset [o] and size [s] for DPI counter [c]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo b m     > cntrs   - Set map of counters [m] to be incremented for byte [b]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo c b 0|1 > cntr_en - On/Off incrementing of DPI counter [c] for byte [b]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo c       > disable - Disable incrementing of DPI counter [c] for all bytes\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo n       > q_size  - Set number of descriptors [n] for DPI queues\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo data    > do_req  - Put DPI request for [data=xxxxxx...] and print results\n");
+
+	return o;
+}
+
+static ssize_t dpi_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	const char  *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "help"))
+		return dpi_help(buf);
+
+	if (!strcmp(name, "regs")) {
+		mvPp2DpiRegs();
+	} else if (!strcmp(name, "queues")) {
+		mvPp2DpiQueueShow(0);
+	} else {
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static ssize_t dpi_dec_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, a = 0, b = 0, c = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d", &a, &b, &c);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "queues")) {
+		mvPp2DpiQueueShow(a);
+	} else if (!strcmp(name, "win")) {
+		err = mvPp2DpiCntrWinSet(a, b, c);
+	} else if (!strcmp(name, "disable")) {
+		err = mvPp2DpiCntrDisable(a);
+	} else if (!strcmp(name, "q_size")) {
+		if (mvPp2DpiQueuesDelete())
+			pr_err("DPI: %s command error. Can't delete queues\n", name);
+		err = mvPp2DpiQueuesCreate(a);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t dpi_hex_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, a = 0, b = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %x", &a, &b);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "cntrs"))
+		mvPp2DpiByteConfig(a, b);
+	else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t dpi_dec_hex_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, a = 0, b = 0, c = 0;
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %x %d", &a, &b, &c);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "cntr_en"))
+		mvPp2DpiCntrByteSet(a, b, c);
+	else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static char		dpi_pkt_data[MV_PP2_DPI_MAX_PKT_SIZE];
+static unsigned char	dpi_counters[MV_PP2_DPI_CNTRS];
+#define DPI_REQUEST_TIMEOUT  100000
+
+static int mv_pp2_dpi_do_request(char *data, int size, unsigned char *counters)
+{
+	unsigned int timeout = DPI_REQUEST_TIMEOUT;
+	unsigned long phys_addr;
+	int ready_num;
+
+	phys_addr = mvOsCacheFlush(NULL, data, size);
+	if (mvPp2DpiRequestSet(phys_addr, size)) {
+		pr_err("%s: DPI request set failed\n", __func__);
+		return -EINVAL;
+	}
+	/* Start processing */
+	wmb();
+	mvPp2DpiReqPendAdd(1);
+
+	/* Wait for response is ready */
+	ready_num = 0;
+	while (ready_num == 0) {
+		timeout--;
+		if (timeout == 0) {
+			pr_err("%s: DPI result get timeout\n", __func__);
+			return -EINVAL;
+		}
+		ready_num = mvPp2DpiResOccupGet();
+	}
+	pr_info("DPI request is ready after %d\n", DPI_REQUEST_TIMEOUT - timeout);
+	if (ready_num != 1)
+		pr_warning("%s: %d requests became ready - only one processsed\n",
+			__func__, ready_num);
+
+	/* Process single response - copy counters */
+	mvOsCacheIoSync();
+	mvPp2DpiResultGet(dpi_counters, MV_PP2_DPI_CNTRS);
+
+	/* Enable HW to reuse Response descriptors */
+	wmb();
+	mvPp2DpiResOccupDec(ready_num);
+
+	return 0;
+}
+
+static ssize_t dpi_string_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, size = 0, i;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "do_req")) {
+		size = strlen(buf) / 2;
+		if (size > sizeof(dpi_pkt_data))
+			size = sizeof(dpi_pkt_data);
+		mvHexToBin(buf, dpi_pkt_data, size);
+		err = mv_pp2_dpi_do_request(dpi_pkt_data, size, dpi_counters);
+		if (!err) {
+			for (i = 0; i < MV_PP2_DPI_CNTRS; i++)
+				pr_info("#%2d  -  %d\n", i, dpi_counters[i]);
+
+			pr_info("\n");
+		}
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, name);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,          S_IRUSR, dpi_show, NULL);
+static DEVICE_ATTR(regs,          S_IRUSR, dpi_show, NULL);
+static DEVICE_ATTR(queues,        S_IRUSR | S_IWUSR, dpi_show, dpi_dec_store);
+static DEVICE_ATTR(win,           S_IWUSR, NULL, dpi_dec_store);
+static DEVICE_ATTR(cntrs,         S_IWUSR, NULL, dpi_hex_store);
+static DEVICE_ATTR(cntr_en,       S_IWUSR, NULL, dpi_dec_hex_store);
+static DEVICE_ATTR(disable,       S_IWUSR, NULL, dpi_dec_store);
+static DEVICE_ATTR(q_size,        S_IWUSR, NULL, dpi_dec_store);
+static DEVICE_ATTR(do_req,        S_IWUSR, NULL, dpi_string_store);
+
+static struct attribute *dpi_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_regs.attr,
+	&dev_attr_queues.attr,
+	&dev_attr_win.attr,
+	&dev_attr_cntrs.attr,
+	&dev_attr_cntr_en.attr,
+	&dev_attr_disable.attr,
+	&dev_attr_q_size.attr,
+	&dev_attr_do_req.attr,
+	NULL
+};
+
+
+static struct attribute_group mv_dpi_group = {
+	.name = "dpi",
+	.attrs = dpi_attrs,
+};
+
+int mv_pp2_dpi_sysfs_init(struct kobject *pp2_kobj)
+{
+	int err = 0;
+
+	err = sysfs_create_group(pp2_kobj, &mv_dpi_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", mv_dpi_group.name, err);
+
+	return err;
+}
+
+int mv_pp2_dpi_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &mv_dpi_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
index 1bd0968..5789bf9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
@@ -97,6 +97,9 @@ int mv_pp2_dbg_sysfs_exit(struct kobject *pp2_kobj);
 int mv_pp2_wol_sysfs_init(struct kobject *pp2_kobj);
 int mv_pp2_wol_sysfs_exit(struct kobject *pp2_kobj);
 
+int mv_pp2_dpi_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_dpi_sysfs_exit(struct kobject *pp2_kobj);
+
 #ifdef CONFIG_MV_ETH_L2FW
 int mv_pp2_l2fw_sysfs_init(struct kobject *pp2_kobj);
 int mv_pp2_l2fw_sysfs_exit(struct kobject *pp2_kobj);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 5821ae2..3b76ebe 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -3507,6 +3507,7 @@ static void mv_eth_sysfs_exit(void)
 	mv_pp2_l2fw_sysfs_exit(&pd->kobj);
 #endif
 	mv_pp2_wol_sysfs_exit(&pd->kobj);
+	mv_pp2_dpi_sysfs_exit(&pd->kobj);
 	mv_pp2_pme_sysfs_exit(&pd->kobj);
 	mv_pp2_plcr_sysfs_exit(&pd->kobj);
 	mv_pp2_mc_sysfs_exit(&pd->kobj);
@@ -3550,6 +3551,7 @@ static int mv_eth_sysfs_init(void)
 	mv_pp2_pme_sysfs_init(&pd->kobj);
 	mv_pp2_dbg_sysfs_init(&pd->kobj);
 	mv_pp2_wol_sysfs_init(&pd->kobj);
+	mv_pp2_dpi_sysfs_init(&pd->kobj);
 #ifdef CONFIG_MV_ETH_L2FW
 	mv_pp2_l2fw_sysfs_init(&pd->kobj);
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.c b/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.c
new file mode 100644
index 0000000..8c65cc8
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.c
@@ -0,0 +1,370 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "pp2/common/mvPp2Common.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+#include "mvPp2DpiHw.h"
+
+MV_PP2_QUEUE_CTRL *mvPp2DpiReqQ;
+MV_PP2_QUEUE_CTRL *mvPp2DpiResQ;
+
+
+void	mvPp2DpiInit(void)
+{
+	int i;
+
+	/* Reset all counters */
+	mvPp2WrReg(MV_PP2_DPI_INIT_REG, 1);
+
+	/* Clear all counters control  registers */
+	for (i = 0; i < MV_PP2_DPI_BYTE_VAL_MAX; i++)
+		mvPp2DpiByteConfig(i, 0);
+
+	/* Clear all counters window registers */
+	for (i = 0; i < MV_PP2_DPI_CNTRS; i++)
+		mvPp2DpiCntrWinSet(i, 0, 0);
+
+	/* Create Request and Result queues */
+	mvPp2DpiQueuesCreate(MV_PP2_DPI_Q_SIZE);
+}
+
+void	mvPp2DpiRegs(void)
+{
+	int    i;
+
+	mvOsPrintf("\n[DIP registers: %d counters]\n", MV_PP2_DPI_CNTRS);
+
+	mvPp2PrintReg(MV_PP2_DPI_INIT_REG,	 "MV_PP2_DPI_INIT_REG");
+	mvPp2PrintReg(MV_PP2_DPI_REQ_Q_ADDR_REG, "MV_PP2_DPI_REQ_Q_ADDR_REG");
+	mvPp2PrintReg(MV_PP2_DPI_RES_Q_ADDR_REG, "MV_PP2_DPI_RES_Q_ADDR_REG");
+	mvPp2PrintReg(MV_PP2_DPI_Q_SIZE_REG,     "MV_PP2_DPI_Q_SIZE_REG");
+	mvPp2PrintReg(MV_PP2_DPI_Q_STATUS_REG,   "MV_PP2_DPI_Q_STATUS_REG");
+	mvPp2PrintReg(MV_PP2_DPI_Q_INDEX_REG,    "MV_PP2_DPI_Q_INDEX_REG");
+	mvPp2PrintReg(MV_PP2_DPI_Q_PEND_REG,     "MV_PP2_DPI_Q_PEND_REG");
+	mvPp2PrintReg(MV_PP2_DPI_Q_THRESH_REG,   "MV_PP2_DPI_Q_THRESH_REG");
+
+	mvOsPrintf("\nDPI Bytes per counter configuration\n");
+	for (i = 0; i < MV_PP2_DPI_BYTE_VAL_MAX; i++) {
+		mvPp2WrReg(MV_PP2_DPI_BYTE_VAL_REG, i);
+		mvPp2RegPrintNonZero2(MV_PP2_DPI_CNTR_CTRL_REG, "MV_PP2_DPI_CNTR_CTRL_REG", i);
+	}
+
+	mvOsPrintf("\nDPI counters window offset and size confuration\n");
+	for (i = 0; i < MV_PP2_DPI_CNTRS; i++)
+		mvPp2PrintReg2(MV_PP2_DPI_CNTR_WIN_REG(i),   "MV_PP2_DPI_CNTR_WIN_REG", i);
+}
+
+
+MV_STATUS	mvPp2DpiCntrWinSet(int cntr, int offset, int size)
+{
+	MV_U32 regVal;
+
+	if (mvPp2MaxCheck(cntr, MV_PP2_DPI_CNTRS, "DPI counter"))
+		return MV_BAD_PARAM;
+
+	if (mvPp2MaxCheck(offset, (MV_PP2_DPI_WIN_OFFSET_MAX + 1), "DPI win offset"))
+		return MV_BAD_PARAM;
+
+	if (mvPp2MaxCheck(size, (MV_PP2_DPI_WIN_SIZE_MAX + 1), "DPI win size"))
+		return MV_BAD_PARAM;
+
+	regVal = MV_PP2_DPI_WIN_OFFSET_MASK(offset) | MV_PP2_DPI_WIN_SIZE_MASK(size);
+	mvPp2WrReg(MV_PP2_DPI_CNTR_WIN_REG(cntr), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS	mvPp2DpiByteConfig(MV_U8 byte, MV_U16 cntrs_map)
+{
+	mvPp2WrReg(MV_PP2_DPI_BYTE_VAL_REG, byte);
+	mvPp2WrReg(MV_PP2_DPI_CNTR_CTRL_REG, cntrs_map);
+
+	return MV_OK;
+}
+
+MV_STATUS	mvPp2DpiCntrByteSet(int cntr, MV_U8 byte, int en)
+{
+	MV_U32 regVal;
+
+	if (mvPp2MaxCheck(cntr, MV_PP2_DPI_CNTRS, "DPI counter"))
+		return MV_BAD_PARAM;
+
+	mvPp2WrReg(MV_PP2_DPI_BYTE_VAL_REG, byte);
+	regVal = mvPp2RdReg(MV_PP2_DPI_CNTR_CTRL_REG);
+
+	if (en)
+		regVal |= (1 << cntr);
+	else
+		regVal &= ~(1 << cntr);
+
+	mvPp2WrReg(MV_PP2_DPI_CNTR_CTRL_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS	mvPp2DpiCntrDisable(int cntr)
+{
+	int i;
+
+	if (mvPp2MaxCheck(cntr, MV_PP2_DPI_CNTRS, "DPI counter"))
+		return MV_BAD_PARAM;
+
+	for (i = 0; i < MV_PP2_DPI_BYTE_VAL_MAX; i++)
+		mvPp2DpiCntrByteSet(cntr, i, 0);
+
+	return MV_OK;
+}
+
+void	mvPp2DpiQueueShow(int mode)
+{
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+	int i;
+
+	pQueueCtrl = mvPp2DpiReqQ;
+	mvOsPrintf("\n[PPv2 DPI Requests Queue]\n");
+
+	if (pQueueCtrl) {
+		mvOsPrintf("nextToProc=%d (%p), PendingRequests=%d, NextRequestIndex=%d\n",
+			pQueueCtrl->nextToProc, MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, pQueueCtrl->nextToProc),
+			mvPp2DpiReqPendGet(), mvPp2DpiReqNextIdx());
+
+		mvOsPrintf("pFirst=%p (0x%x), descSize=%d, numOfDescr=%d\n",
+			pQueueCtrl->pFirst, (MV_U32) pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *) pQueueCtrl->pFirst),
+			pQueueCtrl->descSize, pQueueCtrl->lastDesc + 1);
+
+		if (mode > 0) {
+			for (i = 0; i <= pQueueCtrl->lastDesc; i++) {
+				PP2_DPI_REQ_DESC *pReqDesc = (PP2_DPI_REQ_DESC *) MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, i);
+
+				mvOsPrintf("%3d. pReqDesc=%p, 0x%08x, %d\n",
+					i, pReqDesc, pReqDesc->bufPhysAddr, pReqDesc->dataSize);
+				mvOsCacheLineInv(NULL, pReqDesc);
+			}
+		}
+	}
+
+	pQueueCtrl = mvPp2DpiResQ;
+	mvOsPrintf("\n[PPv2 DPI Results Queue]\n");
+
+	if (pQueueCtrl) {
+		mvOsPrintf("nextToProc=%d (%p), PendingResults=%d, NextResultIndex=%d\n",
+			pQueueCtrl->nextToProc, MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, pQueueCtrl->nextToProc),
+			mvPp2DpiResOccupGet(), mvPp2DpiResNextIdx());
+
+		mvOsPrintf("pFirst=%p (0x%x), descSize=%d, numOfDescr=%d\n",
+			pQueueCtrl->pFirst, (MV_U32) pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *) pQueueCtrl->pFirst),
+			pQueueCtrl->descSize, pQueueCtrl->lastDesc + 1);
+
+		if (mode > 0) {
+			for (i = 0; i <= pQueueCtrl->lastDesc; i++) {
+				/* Result Queue */
+				PP2_DPI_RES_DESC *pResDesc = (PP2_DPI_RES_DESC *) MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, i);
+				int j;
+
+				mvOsPrintf("%3d. pResDesc=%p, ", i, pResDesc);
+				for (j = 0; j < MV_PP2_DPI_CNTRS; j++)
+					mvOsPrintf("%-2d ", pResDesc->counter[j]);
+
+				mvOsPrintf("\n");
+				mvOsCacheLineInv(NULL, pResDesc);
+			}
+		}
+	}
+}
+
+MV_STATUS mvPp2DpiQueuesCreate(int num)
+{
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+	int size;
+
+	mvPp2WrReg(MV_PP2_DPI_Q_SIZE_REG, num);
+
+	/* Allocate memory for DPI request queue */
+	pQueueCtrl = mvOsMalloc(sizeof(MV_PP2_QUEUE_CTRL));
+	if (pQueueCtrl == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for mvPp2DpiReqQ\n", __func__, sizeof(MV_PP2_QUEUE_CTRL));
+		return MV_OUT_OF_CPU_MEM;
+	}
+	mvOsMemset(pQueueCtrl, 0, sizeof(MV_PP2_QUEUE_CTRL));
+
+	size = (num * sizeof(PP2_DPI_REQ_DESC) + MV_PP2_DPI_Q_ALIGN);
+	pQueueCtrl->descBuf.bufVirtPtr =
+	    mvPp2DescrMemoryAlloc(size, &pQueueCtrl->descBuf.bufPhysAddr, &pQueueCtrl->descBuf.memHandle);
+	pQueueCtrl->descBuf.bufSize = size;
+	pQueueCtrl->descSize = sizeof(PP2_DPI_REQ_DESC);
+
+	if (pQueueCtrl->descBuf.bufVirtPtr == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for %d descr\n", __func__, size, num);
+		return MV_OUT_OF_CPU_MEM;
+	}
+
+	/* Make sure descriptor address is aligned */
+	pQueueCtrl->pFirst = (char *)MV_ALIGN_UP((MV_ULONG) pQueueCtrl->descBuf.bufVirtPtr, MV_PP2_DPI_Q_ALIGN);
+	pQueueCtrl->lastDesc = (num - 1);
+	mvPp2WrReg(MV_PP2_DPI_REQ_Q_ADDR_REG, pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *)pQueueCtrl->pFirst));
+	mvPp2DpiReqQ = pQueueCtrl;
+
+	/* Allocate memory for DPI result queue */
+	pQueueCtrl = mvOsMalloc(sizeof(MV_PP2_QUEUE_CTRL));
+	if (pQueueCtrl == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for mvPp2DpiResQ\n", __func__, sizeof(MV_PP2_QUEUE_CTRL));
+		return MV_OUT_OF_CPU_MEM;
+	}
+	mvOsMemset(pQueueCtrl, 0, sizeof(MV_PP2_QUEUE_CTRL));
+
+	size = (num * sizeof(PP2_DPI_RES_DESC) + MV_PP2_DPI_Q_ALIGN);
+	pQueueCtrl->descBuf.bufVirtPtr =
+	    mvPp2DescrMemoryAlloc(size, &pQueueCtrl->descBuf.bufPhysAddr, &pQueueCtrl->descBuf.memHandle);
+	pQueueCtrl->descBuf.bufSize = size;
+	pQueueCtrl->descSize = sizeof(PP2_DPI_RES_DESC);
+
+	if (pQueueCtrl->descBuf.bufVirtPtr == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for %d descr\n", __func__, size, num);
+		return MV_OUT_OF_CPU_MEM;
+	}
+	/* Make sure descriptor address is aligned */
+	pQueueCtrl->pFirst = (char *)MV_ALIGN_UP((MV_ULONG) pQueueCtrl->descBuf.bufVirtPtr, MV_PP2_DPI_Q_ALIGN);
+	pQueueCtrl->lastDesc = (num - 1);
+	mvPp2WrReg(MV_PP2_DPI_RES_Q_ADDR_REG, pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *)pQueueCtrl->pFirst));
+	mvPp2DpiResQ = pQueueCtrl;
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2DpiQueuesDelete(void)
+{
+	if (mvPp2DpiReqQ) {
+		mvPp2DescrMemoryFree(mvPp2DpiReqQ->descBuf.bufSize, (MV_ULONG *)mvPp2DpiReqQ->descBuf.bufPhysAddr,
+				mvPp2DpiReqQ->descBuf.bufVirtPtr, (MV_U32 *)mvPp2DpiReqQ->descBuf.memHandle);
+		mvOsFree(mvPp2DpiReqQ);
+		mvPp2DpiReqQ = NULL;
+	} else
+		mvOsPrintf("%s: DPI Request queue is not initialized\n", __func__);
+
+
+	if (mvPp2DpiResQ) {
+		mvPp2DescrMemoryFree(mvPp2DpiResQ->descBuf.bufSize, (MV_ULONG *)mvPp2DpiResQ->descBuf.bufPhysAddr,
+				mvPp2DpiResQ->descBuf.bufVirtPtr, (MV_U32 *)mvPp2DpiResQ->descBuf.memHandle);
+		mvOsFree(mvPp2DpiResQ);
+		mvPp2DpiResQ = NULL;
+	} else
+		mvOsPrintf("%s: DPI Result queue is not initialized\n", __func__);
+
+	/* Reset all counters */
+	mvPp2WrReg(MV_PP2_DPI_INIT_REG, 1);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2DpiRequestSet(unsigned long paddr, int size)
+{
+	MV_PP2_QUEUE_CTRL *pQueueCtrl = mvPp2DpiReqQ;
+	PP2_DPI_REQ_DESC  *pReqDesc;
+	int reqDesc = pQueueCtrl->nextToProc;
+
+	if (mvPp2DpiReqQ == NULL) {
+		mvOsPrintf("%s: DPI Request queue is not initialized\n", __func__);
+		return MV_NOT_READY;
+	}
+	/* Check if request queue is not Full */
+	if (mvPp2DpiReqIsFull(pQueueCtrl))
+		return MV_FULL;
+
+	pReqDesc = (PP2_DPI_REQ_DESC *)MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, reqDesc);
+	pReqDesc->bufPhysAddr = paddr;
+	pReqDesc->dataSize = size;
+
+	pQueueCtrl->nextToProc = MV_PP2_QUEUE_NEXT_DESC(pQueueCtrl, reqDesc);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2DpiResultGet(MV_U8 *counters, int num)
+{
+	MV_PP2_QUEUE_CTRL *pQueueCtrl = mvPp2DpiResQ;
+	PP2_DPI_RES_DESC  *pResDesc;
+	int resDesc = pQueueCtrl->nextToProc;
+
+	if (mvPp2DpiResQ == NULL) {
+		mvOsPrintf("%s: DPI Result queue is not initialized\n", __func__);
+		return MV_NOT_READY;
+	}
+	if (num > MV_PP2_DPI_CNTRS) {
+		mvOsPrintf("%s: Number of DPI counters %d is out of maximium %d\n",
+				__func__, num, MV_PP2_DPI_CNTRS);
+		num = MV_PP2_DPI_CNTRS;
+	}
+
+	pResDesc = (PP2_DPI_RES_DESC *)MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, resDesc);
+	pQueueCtrl->nextToProc = MV_PP2_QUEUE_NEXT_DESC(pQueueCtrl, resDesc);
+	if (counters)
+		memcpy(counters, pResDesc->counter, num);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.h b/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.h
new file mode 100644
index 0000000..b7e079f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/dpi/mvPp2DpiHw.h
@@ -0,0 +1,264 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvPp2DipHw_h__
+#define __mvPp2DipHw_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+
+#include "pp2/common/mvPp2Common.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+
+#define MV_PP2_DPI_CNTRS		16
+#define MV_PP2_DPI_MAX_PKT_SIZE		1024
+
+#define MV_PP2_DPI_Q_SIZE		32
+
+/*********************************** DPI Counters Registers *******************/
+
+#define MV_PP2_DPI_INIT_REG		(MV_PP2_REG_BASE + 0x4800)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_BYTE_VAL_REG		(MV_PP2_REG_BASE + 0x4810)
+
+#define MV_PP2_DPI_BYTE_VAL_OFFS	0
+#define MV_PP2_DPI_BYTE_VAL_MAX		256
+#define MV_PP2_DPI_BYTE_VAL_MASK	((MV_PP2_DPI_BYTE_VAL_MAX - 1) << MV_PP2_DPI_BYTE_VAL_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_CNTR_CTRL_REG	(MV_PP2_REG_BASE + 0x4814)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_CNTR_WIN_REG(cntr)	(MV_PP2_REG_BASE + 0x4840 + (cntr) * 4)
+
+#define MV_PP2_DPI_WIN_OFFSET_OFFS	0
+#define MV_PP2_DPI_WIN_OFFSET_BITS	9
+#define MV_PP2_DPI_WIN_OFFSET_MAX	((1 << MV_PP2_DPI_WIN_OFFSET_BITS) - 1)
+#define MV_PP2_DPI_WIN_OFFSET_ALL_MASK	(MV_PP2_DPI_WIN_OFFSET_MAX << MV_PP2_DPI_WIN_OFFSET_OFFS)
+#define MV_PP2_DPI_WIN_OFFSET_MASK(v)   ((v << MV_PP2_DPI_WIN_OFFSET_OFFS) & MV_PP2_DPI_WIN_OFFSET_ALL_MASK)
+
+#define MV_PP2_DPI_WIN_SIZE_OFFS	16
+#define MV_PP2_DPI_WIN_SIZE_BITS	8
+#define MV_PP2_DPI_WIN_SIZE_MAX		((1 << MV_PP2_DPI_WIN_SIZE_BITS) - 1)
+#define MV_PP2_DPI_WIN_SIZE_ALL_MASK	(MV_PP2_DPI_WIN_SIZE_MAX << MV_PP2_DPI_WIN_SIZE_OFFS)
+#define MV_PP2_DPI_WIN_SIZE_MASK(v)	((v << MV_PP2_DPI_WIN_SIZE_OFFS) & MV_PP2_DPI_WIN_SIZE_ALL_MASK)
+/*---------------------------------------------------------------------------------------------*/
+
+/*********************************** DPI Request / Result Queues Registers *******************/
+#define MV_PP2_DPI_Q_SIZE_BITS		12
+#define MV_PP2_DPI_Q_SIZE_MAX		((1 < MV_PP2_DPI_Q_SIZE_BITS) - 1)
+
+#define MV_PP2_DPI_Q_ALIGN		(1 << 7)
+
+#define MV_PP2_DPI_REQ_Q_ADDR_REG	(MV_PP2_REG_BASE + 0x4880)
+#define MV_PP2_DPI_RES_Q_ADDR_REG	(MV_PP2_REG_BASE + 0x4884)
+#define MV_PP2_DPI_Q_SIZE_REG		(MV_PP2_REG_BASE + 0x4888)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_Q_CNTR_BITS          12
+#define MV_PP2_DPI_Q_CNTR_MAX           ((1 << MV_PP2_DPI_Q_CNTR_BITS) - 1)
+
+#define MV_PP2_DPI_Q_UPDATE_REG		(MV_PP2_REG_BASE + 0x4890)
+
+#define MV_PP2_DPI_RES_DEC_OCCUP_OFFS	0
+#define MV_PP2_DPI_RES_DEC_OCCUP_MASK   (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_RES_DEC_OCCUP_OFFS)
+
+#define MV_PP2_DPI_REQ_ADD_PEND_OFFS	16
+#define MV_PP2_DPI_REQ_ADD_PEND_MASK   (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_REQ_ADD_PEND_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_Q_STATUS_REG		(MV_PP2_REG_BASE + 0x4894)
+
+#define MV_PP2_DPI_RES_Q_OCCUP_OFFS	0
+#define MV_PP2_DPI_RES_Q_OCCUP_MASK     (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_RES_Q_OCCUP_OFFS)
+
+#define MV_PP2_DPI_REQ_Q_PEND_OFFS	16
+#define MV_PP2_DPI_REQ_Q_PEND_MASK      (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_REQ_Q_PEND_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_Q_INDEX_REG		(MV_PP2_REG_BASE + 0x4898)
+
+#define MV_PP2_DPI_RES_Q_INDEX_OFFS	0
+#define MV_PP2_DPI_RES_Q_INDEX_MASK     (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_RES_Q_INDEX_OFFS)
+
+#define MV_PP2_DPI_REQ_Q_INDEX_OFFS	16
+#define MV_PP2_DPI_REQ_Q_INDEX_MASK     (MV_PP2_DPI_Q_CNTR_MAX << MV_PP2_DPI_REQ_Q_INDEX_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_DPI_Q_PEND_REG		(MV_PP2_REG_BASE + 0x489C)
+#define MV_PP2_DPI_Q_THRESH_REG		(MV_PP2_REG_BASE + 0x48A0)
+/*---------------------------------------------------------------------------------------------*/
+
+typedef struct pp2_dpi_req_desc {
+	MV_U32 bufPhysAddr;
+	MV_U32 dataSize;
+} PP2_DPI_REQ_DESC;
+
+typedef struct pp2_dpi_res_desc {
+	MV_U8 counter[MV_PP2_DPI_CNTRS];
+} PP2_DPI_RES_DESC;
+
+
+/* Update HW with number of DPI RequestQ descriptors to be processed */
+static INLINE void mvPp2DpiReqPendAdd(int pend)
+{
+	MV_U32 regVal;
+
+	regVal = (pend << MV_PP2_DPI_REQ_ADD_PEND_OFFS);
+	mvPp2WrReg(MV_PP2_DPI_Q_UPDATE_REG, regVal);
+}
+
+/* Get number of DPI requestQ  descriptors are waiting for processing */
+static INLINE int mvPp2DpiReqPendGet(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_DPI_Q_STATUS_REG);
+	regVal = (regVal >> MV_PP2_DPI_REQ_Q_PEND_OFFS);
+
+	return regVal;
+}
+
+/* Update HW with number of DPI ResultQ descriptors to be reused */
+static INLINE void mvPp2DpiResOccupDec(int occup)
+{
+	MV_U32 regVal;
+
+	regVal = (occup << MV_PP2_DPI_RES_Q_OCCUP_OFFS);
+	mvPp2WrReg(MV_PP2_DPI_Q_UPDATE_REG, regVal);
+}
+
+/* Get number of RX descriptors occupied by received packets */
+static INLINE int mvPp2DpiResOccupGet(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_DPI_Q_STATUS_REG);
+	regVal = ((regVal & MV_PP2_DPI_RES_Q_OCCUP_MASK) >> MV_PP2_DPI_RES_Q_OCCUP_OFFS);
+
+	return regVal;
+}
+
+static INLINE int mvPp2DpiReqNextIdx(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_DPI_Q_INDEX_REG);
+	regVal = ((regVal & MV_PP2_DPI_REQ_Q_INDEX_MASK) >> MV_PP2_DPI_REQ_Q_INDEX_OFFS);
+
+	return regVal;
+}
+
+static INLINE int mvPp2DpiResNextIdx(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_DPI_Q_INDEX_REG);
+	regVal = ((regVal & MV_PP2_DPI_RES_Q_INDEX_MASK) >> MV_PP2_DPI_RES_Q_INDEX_OFFS);
+
+	return regVal;
+}
+
+static INLINE MV_BOOL mvPp2DpiReqIsFull(MV_PP2_QUEUE_CTRL *pQueueCtrl)
+{
+	if ((pQueueCtrl->lastDesc + 1) - mvPp2DpiReqPendGet() > 0)
+		return MV_FALSE;
+
+	return MV_TRUE;
+}
+
+static INLINE MV_BOOL mvPp2DpiResIsEmpty(MV_PP2_QUEUE_CTRL *pQueueCtrl)
+{
+	if (mvPp2DpiResOccupGet() > 0)
+		return MV_FALSE;
+
+	return MV_TRUE;
+}
+
+/* Public function prototypes */
+void	  mvPp2DpiInit(void);
+void	  mvPp2DpiRegs(void);
+MV_STATUS mvPp2DpiCntrWinSet(int cntr, int offset, int size);
+MV_STATUS mvPp2DpiByteConfig(MV_U8 byte, MV_U16 cntrs_map);
+MV_STATUS mvPp2DpiCntrByteSet(int cntr, MV_U8 byte, int en);
+MV_STATUS mvPp2DpiCntrDisable(int cntr);
+
+void	  mvPp2DpiQueueShow(int mode);
+MV_STATUS mvPp2DpiQueuesCreate(int num);
+MV_STATUS mvPp2DpiQueuesDelete(void);
+
+MV_STATUS mvPp2DpiRequestSet(unsigned long paddr, int size);
+MV_STATUS mvPp2DpiResultGet(MV_U8 *counters, int num);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __mvPp2DipHw_h__ */
-- 
1.7.5.4

