From b66a80daa23d00eb182e5f95f0c5e0704ab06954 Mon Sep 17 00:00:00 2001
From: Liu Haitao <haitao.liu@windriver.com>
Date: Thu, 27 Jul 2017 14:23:09 +0800
Subject: [PATCH 4/5] mvneta: update neta driver to avoid misconfig when
 operate auto negotiation

Issue: LIN8-7049

- the patch fix the issue SYSTEMSW-2544 that auto negotiation will
make eth0 dead, no packet rx, mib counter is 0
- the reason is register of AN Configuration is updated wrongly

The patch was imported from the Marvell git hub :
(https://github.com/MarvellEmbeddedProcessors/linux-marvell/commit/ccf3ed2ca79fcf63a85254aca0563831fbc5d280)
as of commit id ccf3ed2ca79fcf63a85254aca0563831fbc5d280

Change-Id: I04f06784416c2305d2678aec19f69ecf3d710688
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32354
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>

Signed-off-by: Liu Haitao <haitao.liu@windriver.com>
---
 drivers/net/ethernet/marvell/mvneta.c |  205 +++++++++++++++++++++------------
 1 files changed, 131 insertions(+), 74 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index a5a176b..6ea0427 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -178,9 +178,10 @@
 #define MVNETA_GMAC_CTRL_0                       0x2c00
 #define      MVNETA_GMAC_MAX_RX_SIZE_SHIFT       2
 #define      MVNETA_GMAC_MAX_RX_SIZE_MASK        0x7ffc
+#define      MVNETA_GMAC0_PORT_1000BASE_X        BIT(1)
 #define      MVNETA_GMAC0_PORT_ENABLE            BIT(0)
 #define MVNETA_GMAC_CTRL_2                       0x2c08
-#define      MVNETA_GMAC2_INBAND_AN_ENABLE       BIT(0)
+#define      MVNETA_GMAC2_SGMII_INBAND_AN_MODE   BIT(0)
 #define      MVNETA_GMAC2_PCS_ENABLE             BIT(3)
 #define      MVNETA_GMAC2_PORT_RGMII             BIT(4)
 #define      MVNETA_GMAC2_PORT_RESET             BIT(6)
@@ -197,9 +198,14 @@
 #define      MVNETA_GMAC_FORCE_LINK_DOWN         BIT(0)
 #define      MVNETA_GMAC_FORCE_LINK_PASS         BIT(1)
 #define      MVNETA_GMAC_INBAND_AN_ENABLE        BIT(2)
+#define      MVNETA_GMAC_INBAND_AN_BYPASS_EN     BIT(3)
+#define      MVNETA_GMAC_INBAND_RESTART_AN       BIT(4)
 #define      MVNETA_GMAC_CONFIG_MII_SPEED        BIT(5)
 #define      MVNETA_GMAC_CONFIG_GMII_SPEED       BIT(6)
 #define      MVNETA_GMAC_AN_SPEED_EN             BIT(7)
+#define      MVNETA_GMAC_CONFIG_FLOW_CTRL        BIT(8)
+#define      MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL    BIT(9)
+#define      MVNETA_GMAC_ADVERT_ASYM_FC_ADV      BIT(10)
 #define      MVNETA_GMAC_AN_FLOW_CTRL_EN         BIT(11)
 #define      MVNETA_GMAC_CONFIG_FULL_DUPLEX      BIT(12)
 #define      MVNETA_GMAC_AN_DUPLEX_EN            BIT(13)
@@ -227,6 +233,14 @@
 
 #define MVNETA_CAUSE_TXQ_SENT_DESC_ALL_MASK	 0xff
 
+#define MVNETA_REGS_GMAC_LEN                     0xAC9
+
+enum mvneta_port_type {
+	PORT_TYPE_SGMII,
+	PORT_TYPE_1000BASE_X
+};
+
+
 /* Descriptor ring Macros */
 #define MVNETA_QUEUE_NEXT_DESC(q, index)	\
 	(((index) < (q)->last_desc) ? ((index) + 1) : 0)
@@ -1003,44 +1017,105 @@ static void mvneta_set_other_mcast_table(struct mvneta_port *pp, int queue)
 		mvreg_write(pp, MVNETA_DA_FILT_OTH_MCAST + offset, val);
 }
 
+static enum mvneta_port_type mvneta_port_type_get(struct mvneta_port *pp)
+{
+	u32 val;
 
+	val = mvreg_read(pp, MVNETA_GMAC_CTRL_0);
+	if (val & MVNETA_GMAC0_PORT_1000BASE_X)
+		return PORT_TYPE_1000BASE_X;
+	else
+		return PORT_TYPE_SGMII;
+}
 
-static void mvneta_set_autoneg(struct mvneta_port *pp, int enable)
+static void mvneta_mac_config(struct mvneta_port *pp)
 {
-	u32 val;
+	enum mvneta_port_type port_type = mvneta_port_type_get(pp);
+	u32 new_ctrl2, gmac_ctrl2 = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
+	u32 new_clk, gmac_clk = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
+	u32 new_an, gmac_an = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
 
-	if (enable) {
-		val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-		val &= ~(MVNETA_GMAC_FORCE_LINK_PASS |
-				MVNETA_GMAC_FORCE_LINK_DOWN |
-				MVNETA_GMAC_AN_FLOW_CTRL_EN);
-		val |= MVNETA_GMAC_INBAND_AN_ENABLE |
+	/* Clear all fields need to config with different work mode */
+	new_ctrl2 = gmac_ctrl2 & ~MVNETA_GMAC2_SGMII_INBAND_AN_MODE;
+	new_clk = gmac_clk & ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
+	new_an = gmac_an & ~(MVNETA_GMAC_INBAND_AN_ENABLE |
+			MVNETA_GMAC_INBAND_RESTART_AN |
+			MVNETA_GMAC_CONFIG_MII_SPEED |
+			MVNETA_GMAC_CONFIG_GMII_SPEED |
 			MVNETA_GMAC_AN_SPEED_EN |
-			MVNETA_GMAC_AN_DUPLEX_EN;
-		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
+			MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL |
+			MVNETA_GMAC_CONFIG_FLOW_CTRL |
+			MVNETA_GMAC_AN_FLOW_CTRL_EN |
+			MVNETA_GMAC_CONFIG_FULL_DUPLEX |
+			MVNETA_GMAC_AN_DUPLEX_EN |
+			MVNETA_GMAC_FORCE_LINK_PASS |
+			MVNETA_GMAC_FORCE_LINK_DOWN);
+
+	if (pp->use_inband_status) {
+		switch (port_type) {
+		case PORT_TYPE_SGMII:
+			/* SGMII mode receives the state from the PHY*/
+			new_ctrl2 |= MVNETA_GMAC2_SGMII_INBAND_AN_MODE;
+			new_clk |= MVNETA_GMAC_1MS_CLOCK_ENABLE;
+			/* SGMII aoto-nego clock*/
+			new_an |= MVNETA_GMAC_INBAND_AN_ENABLE |
+				MVNETA_GMAC_INBAND_AN_BYPASS_EN |
+				MVNETA_GMAC_AN_SPEED_EN |
+				MVNETA_GMAC_AN_DUPLEX_EN;
+			break;
 
-		val = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
-		val |= MVNETA_GMAC_1MS_CLOCK_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, val);
+		case PORT_TYPE_1000BASE_X:
+			/* A3700 spec: In 1000BASE-X, the port must be set to work
+			 * in full-duplex mode, at 1000 Mbps.
+			 * Duplex and Speed Auto-Negotiation must be disabled
+			 */
+			new_an |= MVNETA_GMAC_INBAND_AN_ENABLE |
+				MVNETA_GMAC_INBAND_AN_BYPASS_EN |
+				MVNETA_GMAC_CONFIG_GMII_SPEED |
+				MVNETA_GMAC_ADVERT_SYM_FLOW_CTRL |
+				MVNETA_GMAC_AN_FLOW_CTRL_EN |
+				MVNETA_GMAC_CONFIG_FLOW_CTRL |
+				MVNETA_GMAC_CONFIG_FULL_DUPLEX;
 
-		val = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
-		val |= MVNETA_GMAC2_INBAND_AN_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CTRL_2, val);
+			break;
+		}
 	} else {
-		val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-		val &= ~(MVNETA_GMAC_INBAND_AN_ENABLE |
-				MVNETA_GMAC_AN_SPEED_EN |
-				MVNETA_GMAC_AN_DUPLEX_EN);
-		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
+		/* SMI auto-nego, GMAC will get info from PHY with SMI */
+		if (pp->phy_dev) {
+			if (pp->phy_dev->duplex)
+				new_an |= MVNETA_GMAC_CONFIG_FULL_DUPLEX;
+
+			if (pp->phy_dev->speed == SPEED_1000)
+				new_an |= MVNETA_GMAC_CONFIG_GMII_SPEED;
+			else if (pp->phy_dev->speed == SPEED_100)
+				new_an |= MVNETA_GMAC_CONFIG_MII_SPEED;
+
+			if (pp->phy_dev->pause)
+				new_an |= MVNETA_GMAC_CONFIG_FLOW_CTRL;
 
-		val = mvreg_read(pp, MVNETA_GMAC_CLOCK_DIVIDER);
-		val &= ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, val);
+			if (pp->phy_dev->asym_pause)
+				new_an |= MVNETA_GMAC_ADVERT_ASYM_FC_ADV;
+		}
+	}
+
+	/* Armada 370 documentation says we can only change the port Mode
+	 * and in-band enable when the link is down, so force it down
+	 * while making these changes. We also do this for GMAC_CTRL2
+	 */
 
-		val = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
-		val &= ~MVNETA_GMAC2_INBAND_AN_ENABLE;
-		mvreg_write(pp, MVNETA_GMAC_CTRL_2, val);
+	if ((new_ctrl2 ^ gmac_ctrl2) & MVNETA_GMAC2_SGMII_INBAND_AN_MODE ||
+			(new_an  ^ gmac_an) & MVNETA_GMAC_INBAND_AN_ENABLE) {
+		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG,
+				(gmac_an & ~MVNETA_GMAC_FORCE_LINK_PASS) |
+				MVNETA_GMAC_FORCE_LINK_DOWN);
 	}
+
+	if (new_ctrl2 != gmac_ctrl2)
+		mvreg_write(pp, MVNETA_GMAC_CTRL_2, new_ctrl2);
+	if (new_clk != gmac_clk)
+		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, new_clk);
+	if (new_an != gmac_an)
+		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, new_an);
 }
 
 static void mvneta_percpu_unmask_interrupt(void *arg)
@@ -1182,7 +1257,7 @@ static void mvneta_defaults_set(struct mvneta_port *pp)
 	val &= ~MVNETA_PHY_POLLING_ENABLE;
 	mvreg_write(pp, MVNETA_UNIT_CONTROL, val);
 
-	mvneta_set_autoneg(pp, pp->use_inband_status);
+	mvneta_mac_config(pp);
 	mvneta_set_ucast_table(pp, -1);
 	mvneta_set_special_mcast_table(pp, -1);
 	mvneta_set_other_mcast_table(pp, -1);
@@ -2591,7 +2666,9 @@ static void mvneta_start_dev(struct mvneta_port *pp)
 		    MVNETA_CAUSE_LINK_CHANGE |
 		    MVNETA_CAUSE_PSC_SYNC_CHANGE);
 
-	phy_start(pp->phy_dev);
+	if (!pp->use_inband_status)
+		phy_start(pp->phy_dev);
+
 	netif_tx_start_all_queues(pp->dev);
 }
 
@@ -2599,16 +2676,15 @@ static void mvneta_stop_dev(struct mvneta_port *pp)
 {
 	unsigned int cpu;
 
-	phy_stop(pp->phy_dev);
+	if (!pp->use_inband_status)
+		phy_stop(pp->phy_dev);
 
 	for_each_online_cpu(cpu) {
 		struct mvneta_pcpu_port *port = per_cpu_ptr(pp->ports, cpu);
-
 		napi_disable(&port->napi);
 	}
 
 	netif_carrier_off(pp->dev);
-
 	mvneta_port_down(pp);
 	netif_tx_stop_all_queues(pp->dev);
 
@@ -3056,8 +3132,6 @@ static int mvneta_open(struct net_device *dev)
 
 	return 0;
 
-err_free_irq:
-	free_percpu_irq(pp->dev->irq, pp->ports);
 err_cleanup_txqs:
 	mvneta_cleanup_txqs(pp);
 err_cleanup_rxqs:
@@ -3140,44 +3214,21 @@ int mvneta_ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 /* Set settings (phy address, speed) for ethtools */
 int mvneta_ethtool_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
+	int ret = 0;
 	struct mvneta_port *pp = netdev_priv(dev);
 	struct phy_device *phydev = pp->phy_dev;
 
-	if (!phydev)
-		return -ENODEV;
-
-	if ((cmd->autoneg == AUTONEG_ENABLE) != pp->use_inband_status) {
-		u32 val;
-
-		mvneta_set_autoneg(pp, cmd->autoneg == AUTONEG_ENABLE);
-
-		if (cmd->autoneg == AUTONEG_DISABLE) {
-			val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
-			val &= ~(MVNETA_GMAC_CONFIG_MII_SPEED |
-				 MVNETA_GMAC_CONFIG_GMII_SPEED |
-				 MVNETA_GMAC_CONFIG_FULL_DUPLEX);
-
-			if (phydev->duplex)
-				val |= MVNETA_GMAC_CONFIG_FULL_DUPLEX;
-
-			if (phydev->speed == SPEED_1000)
-				val |= MVNETA_GMAC_CONFIG_GMII_SPEED;
-			else if (phydev->speed == SPEED_100)
-				val |= MVNETA_GMAC_CONFIG_MII_SPEED;
-
-			mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, val);
-		}
-
-		pp->use_inband_status = (cmd->autoneg == AUTONEG_ENABLE);
-		netdev_info(pp->dev, "autoneg status set to %i\n",
-			    pp->use_inband_status);
-
-		if (netif_running(dev)) {
-			mvneta_port_down(pp);
-			mvneta_port_up(pp);
-		}
+	if (phydev) {
+		if (mvneta_spd_dplx_valid(pp, cmd))
+			return -EINVAL;
+		ret = phy_ethtool_sset(pp->phy_dev, cmd);
+		if (ret)
+			return ret;
 	}
-	return phy_ethtool_sset(pp->phy_dev, cmd);
+	/* Config MAC */
+	mvneta_mac_config(pp);
+
+	return ret;
 }
 
 /* Set interrupt coalescing for ethtools */
@@ -3762,14 +3813,18 @@ static int mvneta_probe(struct platform_device *pdev)
 		put_device(&phy->dev);
 	}
 
-	err = mvneta_mdio_probe(pp);
-	if(err<0){
-		netdev_err(dev,"cannot probe MDIO bus\n");
-		goto err_free_stats;
+	if(!pp->use_inband_status){
+		err = mvneta_mdio_probe(pp);
+		if(err<0){
+			netdev_err(dev,"cannot probe MDIO bus\n");
+			goto err_netdev;
+		}
 	}
 
 	return 0;
 
+err_netdev:
+	unregister_netdev(dev);
 err_free_stats:
 	free_percpu(pp->stats);
 err_free_ports:
@@ -3791,7 +3846,9 @@ static int mvneta_remove(struct platform_device *pdev)
 	struct net_device  *dev = platform_get_drvdata(pdev);
 	struct mvneta_port *pp = netdev_priv(dev);
 
-	mvneta_mdio_remove(pp);
+	if(!pp->use_inband_status)
+		mvneta_mdio_remove(pp);
+
 	unregister_netdev(dev);
 	clk_disable_unprepare(pp->clk);
 	free_percpu(pp->ports);
-- 
1.7.5.4

